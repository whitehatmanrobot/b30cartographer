
    //
    if (lpbiOut == NULL) {
        return ICERR_OK;
    }

    // check output format to make sure we can convert to this

    // must be full dib
    if (lpbiOut->biCompression == BI_RGB) {
        pinst->bRGB565 = FALSE;
#ifdef  TOSHIBA
#ifdef  COLOR_MODIFY
        if (lpbiOut->biBitCount == 24) {
            pinst->bRGB24 = TRUE;
        } else {
            pinst->bRGB24 = FALSE;
        }
#endif//COLOR_MODIFY
#endif//TOSHIBA
    } else if ((lpbiOut->biCompression == BI_BITFIELDS) &&
               (lpbiOut->biBitCount == 16) &&
               (((LPDWORD)(lpbiOut+1))[0] == 0x00f800) &&
               (((LPDWORD)(lpbiOut+1))[1] == 0x0007e0) &&
               (((LPDWORD)(lpbiOut+1))[2] == 0x00001f))  {

        dprintf1((TEXT("rgb565 output")));
        pinst->bRGB565 = TRUE;
#ifdef  TOSHIBA
#ifdef  COLOR_MODIFY
        pinst->bRGB24 = FALSE;
#endif//COLOR_MODIFY
#endif//TOSHIBA
    } else {

        dprintf1((TEXT("bad compression for output")));

        return (DWORD)ICERR_BADFORMAT;
    }

    /* must be 1:1 (no stretching) */
    if ((lpbiOut->biWidth != lpbiIn->biWidth) ||
        (lpbiOut->biHeight != lpbiIn->biHeight)) {
            dprintf1((TEXT("YUV can't stretch: %dx%d->%dx%d"),
                    lpbiIn->biWidth, lpbiIn->biHeight,
                    lpbiOut->biWidth, lpbiOut->biHeight
            ));

            return((DWORD) ICERR_BADFORMAT);
    }

    /*
     * we translate to 16 bits
     */

#ifdef  TOSHIBA
#ifdef  COLOR_MODIFY
    if ((lpbiOut->biBitCount != 16) &&
        (lpbiOut->biBitCount != 24)) {
        dprintf1((TEXT("YUV to 16 or 24 only")));
        return((DWORD) ICERR_BADFORMAT);
    }
#else //COLOR_MODIFY
    if (lpbiOut->biBitCount != 16) {
        dprintf1((TEXT("YUV 16:16 only")));
        return((DWORD) ICERR_BADFORMAT);
    }
#endif//COLOR_MODIFY
#else //TOSHIBA
    if (lpbiOut->biBitCount != 16) {
        dprintf1((TEXT("YUV 16:16 only")));
        return((DWORD) ICERR_BADFORMAT);
    }
#endif//TOSHIBA

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD  DecompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    DWORD dw;
    int dx,dy;

    dw = DecompressQuery(pinst, lpbiIn, NULL);
    if (dw != ICERR_OK) {
        return dw;
    }

    //
    // if lpbiOut == NULL then, return the size required to hold a output
    // format
    //
    if (lpbiOut == NULL) {
        dprintf2((TEXT("get format size query")));
        return (int)lpbiIn->biSize + (int)lpbiIn->biClrUsed * sizeof(RGBQUAD);
    }

    memcpy(lpbiOut, lpbiIn,
        (int)lpbiIn->biSize + (int)lpbiIn->biClrUsed * sizeof(RGBQUAD));

    dx = (int)lpbiIn->biWidth & ~3;
    dy = (int)lpbiIn->biHeight & ~3;

    lpbiOut->biWidth       = dx;
    lpbiOut->biHeight      = dy;
#ifdef  TOSHIBA
    lpbiOut->biBitCount    = 16;
#else //TOSHIBA
    lpbiOut->biBitCount    = lpbiIn->biBitCount;    // convert 16->16
#endif//TOSHIBA

    lpbiOut->biCompression = BI_RGB;
    lpbiOut->biSizeImage   = dx*dy*2;

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL DecompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    DWORD dw;


    /* check that the conversion formats are valid */
    dw = DecompressQuery(pinst, lpbiIn, lpbiOut);
    if (dw != ICERR_OK) {
        return dw;
    }

    /* init the yuv-to-rgb55 xlate table if not already inited */

    /* free up the existing table if the formats differ */
    if (lpbiIn->biCompression != pinst->dwFormat) {
        if (pinst->pXlate != NULL) {
            DecompressEnd(pinst);
        }
    }

    if (pinst->pXlate == NULL) {

        switch(lpbiIn->biCompression) {
        case FOURCC_YUV411:
            if (pinst->bRGB565) {
                pinst->pXlate = BuildYUVToRGB565(pinst);
            } else {
                pinst->pXlate = BuildYUVToRGB555(pinst);
            }
            break;

        case FOURCC_YUV422:
            if (pinst->bRGB565) {
                pinst->pXlate = BuildYUV422ToRGB565(pinst);
            } else {
                pinst->pXlate = BuildYUV422ToRGB555(pinst);
            }
            break;

#ifdef  TOSHIBA
#ifdef  COLOR_MODIFY
        case FOURCC_YUV12:
            pinst->pXlate = BuildYUVToRB(pinst);
            break;

        case FOURCC_YUV9:
            pinst->pXlate = BuildYUVToRB(pinst);              // same to YUV12
            break;
#else //COLOR_MODIFY
        case FOURCC_YUV12:
            if (pinst->bRGB565) {
                pinst->pXlate = BuildYUV12ToRGB565(pinst);
            } else {
                pinst->pXlate = BuildYUV12ToRGB555(pinst);
            }
            break;

        case FOURCC_YUV9:
            if (pinst->bRGB565) {
                pinst->pXlate = BuildYUV12ToRGB565(pinst);              // same to YUV12
            } else {
                pinst->pXlate = BuildYUV12ToRGB555(pinst);              // same to YUV12
            }
            break;
#endif//COLOR_MODIFY
#endif//TOSHIBA

        default:
            return((DWORD) ICERR_BADFORMAT);
        }

        if (pinst->pXlate == NULL) {
            return((DWORD) ICERR_MEMORY);
        }
        pinst->dwFormat = lpbiIn->biCompression;
    }

    return(ICERR_OK);

}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL Decompress(INSTINFO * pinst, ICDECOMPRESS FAR *icinfo, DWORD dwSize)
{
    /* must have been a DecompressBegin first */
    if (pinst->pXlate == NULL) {
        return((DWORD) ICERR_ERROR);
    }

#ifdef  TOSHIBA
    if (pinst->dwFormat == FOURCC_YUV9) {

#ifdef  COLOR_MODIFY
        if (pinst->bRGB24) {
            YUV9ToRGB24(pinst,
                icinfo->lpbiInput,
                icinfo->lpInput,
                icinfo->lpbiOutput,
                icinfo->lpOutput
            );
        } else {
            if (pinst->bRGB565) {
                YUV9ToRGB565(pinst,
                    icinfo->lpbiInput,
                    icinfo->lpInput,
                    icinfo->lpbiOutput,
                    icinfo->lpOutput
                );
            } else {
                YUV9ToRGB555(pinst,
                    icinfo->lpbiInput,
                    icinfo->lpInput,
                    icinfo->lpbiOutput,
                    icinfo->lpOutput
                );
            }
        }
#else //COLOR_MODIFY
        YUV9ToRGB(pinst,
            icinfo->lpbiInput,
            icinfo->lpInput,
            icinfo->lpbiOutput,
            icinfo->lpOutput
        );
#endif//COLOR_MODIFY

    } else

    if (pinst->dwFormat == FOURCC_YUV12) {

#ifdef  COLOR_MODIFY
        if (pinst->bRGB24) {
            YUV12ToRGB24(pinst,
                icinfo->lpbiInput,
                icinfo->lpInput,
                icinfo->lpbiOutput,
                icinfo->lpOutput
            );
        } else {
            if (pinst->bRGB565) {
                YUV12ToRGB565(pinst,
                    icinfo->lpbiInput,
                    icinfo->lpInput,
                    icinfo->lpbiOutput,
                    icinfo->lpOutput
                );
            } else {
                YUV12ToRGB555(pinst,
                    icinfo->lpbiInput,
                    icinfo->lpInput,
                    icinfo->lpbiOutput,
                    icinfo->lpOutput
                );
            }
        }
#else //COLOR_MODIFY
        YUV12ToRGB(pinst,
            icinfo->lpbiInput,
            icinfo->lpInput,
            icinfo->lpbiOutput,
            icinfo->lpOutput
        );
#endif//COLOR_MODIFY

    } else
#endif//TOSHIBA

    if (pinst->dwFormat == FOURCC_YUV411) {

        YUV411ToRGB(pinst,
            icinfo->lpbiInput,
            icinfo->lpInput,
            icinfo->lpbiOutput,
            icinfo->lpOutput
        );
    } else {

        /*
         * for compatibility with 16-bit Spigot driver,
         * check for Guard field at start of data
         */
        LPDWORD lpInput = icinfo->lpInput;

        if (*lpInput == FOURCC_YUV422) {
            lpInput++;
        }


        YUV422ToRGB(pinst,
            icinfo->lpbiInput,
            icinfo->lpInput,
            icinfo->lpbiOutput,
            icinfo->lpOutput
        );
    }



    return ICERR_OK;
}

/*****************************************************************************
 *
 * DecompressGetPalette() implements ICM_GET_PALETTE
 *
 * This function has no Compress...() equivalent
 *
 * It is used to pull the palette from a frame in order to possibly do
 * a palette change.
 *
 ****************************************************************************/
DWORD NEAR PASCAL DecompressGetPalette(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{

    dprintf2((TEXT("DecompressGetPalette()")));


    /*
     * only applies to 8-bit output formats. We only decompress to 16 bits
     */
    return((DWORD) ICERR_BADFORMAT);

}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL DecompressEnd(INSTINFO * pinst)
{
    if (pinst->pXlate == NULL) {
        return (DWORD)ICERR_ERROR;
    }

    FreeXlate(pinst);
    pinst->dwFormat = 0;

    return ICERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\codec\tsbyuv\vcuser.h ===
/*
 * Copyright Microsoft Corporation, 1993 - 1995. All Rights Reserved.
 */

/*
 * vcuser.h
 *
 * 32-bit Video Capture driver
 * User-mode support library
 *
 * define functions providing access to video capture hardware. On NT,
 * these functions will interface to the kernel-mode driver.
 *
 * include vcstruct.h before this.
 *
 * Geraint Davies, Feb 93
 */

#ifndef _VCUSER_H_
#define _VCUSER_H_

/*
 * capture device handle. This structure is opaque to the caller
 */
typedef struct _VCUSER_HANDLE * VCUSER_HANDLE;

/*
 * these are the parameters we need to issue a DriverCallback. A
 * pointer to one of these structs is passed on StreamInit
 * If the pointer is null, we don't need callbacks.
 */
typedef struct _VCCALLBACK {
    DWORD dwCallback;
    DWORD dwFlags;
    HDRVR hDevice;
    DWORD dwUser;
} VCCALLBACK, * PVCCALLBACK;


/*
 * open the device and return a capture device handle that can be used
 * in future calls.
 * The device index is 0 for the first capture device up to N for the
 * Nth installed capture device.
 *
 * If pDriverName is non-null, then we will open the Nth device handled
 * by this driver. (Current implementation supports only one device per
 * drivername.)
 *
 * This function returns NULL if it is not able to open the device.
 */
VCUSER_HANDLE VC_OpenDevice(PTCHAR pDriverName, int DeviceIndex);


/*
 * close a capture device. This will abort any operation in progress and
 * render the device handle invalid.
 */
VOID VC_CloseDevice(VCUSER_HANDLE vh);


/*
 * Configuration.
 *
 * These functions perform device-dependent setup affecting the
 * target format, the source acquisition or the display (overlay).
 *
 * The structures passed are not interpreted by the vcuser and vckernel
 * libraries except that the first ulong of the struct must contain the
 * size in bytes of the entire structure (see vcstruct.h). It is assumed
 * that the structures are defined and agreed between the user-mode
 * hardware-specific code and the kernel-mode hardware specific code
 */
BOOL VC_ConfigFormat(VCUSER_HANDLE, PCONFIG_INFO);
BOOL VC_ConfigSource(VCUSER_HANDLE, PCONFIG_INFO);
BOOL VC_ConfigDisplay(VCUSER_HANDLE, PCONFIG_INFO);


/*
 * overlay and keying
 *
 * Several different methods are used by devices to locate the overlay
 * area on the screen: colour (either rgb or palette index) and/or
 * either a single rectangle, or a series of rectangles defining a complex
 * region. Call GetOverlayMode first to find out which type of overlay
 * keying is available. If this returns 0, this hardware is not capable
 * of overlay.
 */

/*
 * find out the overlay keying method
 */
ULONG VC_GetOverlayMode(VCUSER_HANDLE);

/*
 * set the key colour to a specified RGB colour. This function will only
 * succeed if GetOverlayMode returned  VCO_KEYCOLOUR and VCO_KEYCOLOUR_RGB
 * and not VCO_KEYCOLOUR_FIXED
 */
BOOL VC_SetKeyColourRGB(VCUSER_HANDLE, PRGBQUAD);

/*
 * set the key colour to a specified palette index. This function will only
 * succeed if GetOverlayMode returned VCO_KEYCOLOUR and not either
 * VCO_KEYCOLOUR_RGB or VCO_KEYCOLOUR_FIXED
 */
BOOL VC_SetKeyColourPalIdx(VCUSER_HANDLE, WORD);

/*
 * get the current key colour. This 32-bit value should be interpreted
 * as either a palette index or an RGB value according to the
 * VCO_KEYCOLOUR_RGB flag returned from VC_GetOverlayMode.
 */
DWORD VC_GetKeyColour(VCUSER_HANDLE vh);

/*
 * set the overlay rectangle(s). This rectangle marks the area in device
 * co-ordinates where the overlay video will appear. The video will be
 * panned so that pixel (0,0) will appear at the top-left of this rectangle,
 * and the video will be cropped at the bottom and right.  The video
 * stream will not normally be scaled to fit this window: scaling is normally
 * determined by the destination format set by VC_ConfigFormat.
 *
 * If VCO_KEYCOLOUR was returned, the video
 * will only be shown at those pixels within the rectangle for which the
 * vga display has the key colour (VC_GetKeyColour() for this).
 *
 * Some devices may support complex regions (VCO_COMPLEX_RECT). In that case,
 * the first rectangle in the area must be the bounding rectangle for
 * the overlay area, followed by one rectangle for each region within it in
 * which the overlay should appear.
 */
BOOL VC_SetOverlayRect(VCUSER_HANDLE, POVERLAY_RECTS);


/*
 * set the offset of the overlay. This changes the panning - ie which
 * source co-ordinate appears as the top left pixel in the overlay rectangle.
 * Initially after a call to VC_SetOverlayRect, the source image will be panned
 * so that the top-left of the source image is aligned with the top-left of the
 * overlay rectangle. This call aligns the top-left of the source image
 * with the top-left of this offset rectangle.
 */
BOOL VC_SetOverlayOffset(VCUSER_HANDLE, PRECT);

/* enable or disable overlay. if the BOOL bOverlay is TRUE, and the overlay
 * key colour and rectangle have been set, overlay will be enabled.
 */
BOOL VC_Overlay(VCUSER_HANDLE, BOOL);

/*
 * enable or disable acquisition.
 * If acquisition is disabled, the overlay image will be frozen.
 *
 * this function will have no effect during capture since the acquisition
 * flag is toggled at each frame capture.
 */
BOOL VC_Capture(VCUSER_HANDLE, BOOL);



/*
 * capture a single frame, synchronously. the video header must point
 * to a data buffer large enough to hold one frame of the format set by
 * VC_ConfigFormat.
 */
// BOOL VC_Frame(VCUSER_HANDLE, LPVIDEOHDR);


/*
 * data streaming.
 *
 * Call VC_StreamInit to prepare for streaming.
 * Call VC_StreamStart to initiate capture.
 * Call VC_AddBuffer to add a capture buffer to the list. As each
 * frame capture completes, the callback function specified in
 * VC_StreamInit will be called with the buffer that has completed.
 *
 * If there is no buffer ready when it is time to capture a frame,
 * a callback will occur. In addition, VC_StreamGetError will return
 * a count of the frames missed this session. VC_StreamGetPos will return
 * the position (in millisecs) reached so far.
 *
 * Call VC_StreamStop to terminate streaming. Any buffer currently in
 * progress may still complete. Uncompleted buffers will remain in the
 * queue. Call VC_Reset to release all buffers from the queue.
 *
 * Finally call VC_StreamFini to tidy up.
 */

/*
 * prepare to start capturing frames
 */
BOOL VC_StreamInit(VCUSER_HANDLE,
		PVCCALLBACK,	// pointer to callback function
		ULONG		// desired capture rate: microseconds per frame
);

/*
 * clean up after capturing. You must have stopped capturing first.
 */
BOOL VC_StreamFini(VCUSER_HANDLE);

/*
 * initiate capturing of frames. Must have called VC_StreamInit first.
 */
BOOL VC_StreamStart(VCUSER_HANDLE);

/*
 * stop capturing frames. Current frame may still complete. All other buffers
 * will remain in the queue until capture is re-started, or they are released
 * by VC_StreamReset.
 */
BOOL VC_StreamStop(VCUSER_HANDLE);

/*
 * cancel all buffers that have been 'add-buffered' but have not
 * completed. This will also force VC_StreamStop if it hasn't already been
 * called.
 */
BOOL VC_StreamReset(VCUSER_HANDLE);

/*
 * get the count of frames that have been skipped since the last call
 * to VC_StreamInit.
 */
ULONG VC_GetStreamError(VCUSER_HANDLE);

/*
 * get the current position within the capture stream (ie time
 * in millisecs since capture began)
 */
BOOL VC_GetStreamPos(VCUSER_HANDLE, LPMMTIME);

/*
 * add a buffer to the queue. The buffer should be large enough
 * to hold one frame of the format specified by VC_ConfigFormat.
 */
// BOOL VC_StreamAddBuffer(VCUSER_HANDLE, LPVIDEOHDR);


/*
 * playback
 *
 * Call VC_DrawFrame to draw a frame into the frame buffer. You should
 * call VC_Overlay functions to arrange for the frame buffer to appear
 * on screen.
 */
BOOL VC_DrawFrame(VCUSER_HANDLE, PDRAWBUFFER);



/*
 * installation/configuration
 *
 * on NT, the following functions will start and stop the
 * kernel driver. The callback function can write profile information
 * to the registry between stopping the driver (if already running) and
 * re-starting the driver. The kernel driver DriverEntry routine is responsible
 * for reading these values from the registry before calling VC_Init().
 *
 * The win-16 implementation will (?) call the callback to write
 * values to the profile, and then call the HW_Startup function. This function
 * is responsible for calling VC_Init, initialising the callback table and
 * initialising the hardware.
 */

/*
 * opaque pointer to the information we need to access the registry/profile.
 */
typedef struct _VC_PROFILE_INFO * PVC_PROFILE_INFO;


/*
 * open a handle to whatever functions are needed to access the registry,
 * service controller or profile. Must call this function before
 * calls to the other VC_ configuration routines.
 *
 * The argument is the name of the driver. This should be the name of
 * the kernel driver file (without path or extension). It will also be used
 * as the registry key name or profile section name.
 */
PVC_PROFILE_INFO VC_OpenProfileAccess(PTCHAR DriverName);

/*
 * close a profile access handle
 */
VOID VC_CloseProfileAccess(PVC_PROFILE_INFO);


/*
 * takes a PVC_PROFILE_INFO returned from VC_OpenProfileAccess, and
 * returns TRUE if we currently have sufficient privilege to perform
 * driver configuration operations.
 */
BOOL VC_ConfigAccess(PVC_PROFILE_INFO);


/*
 * This function is called once the driver has definitely been unloaded, and
 * the profile entry created, but before the driver is re-loaded. It can write
 * any configuration information to the registry. It should return TRUE if
 * it is ok to load and start the kernel-mode driver, or false if some
 * error has occured.
 */
typedef BOOL (*PPROFILE_CALLBACK)(PVOID);


/*
 * start the hardware-access portion of the driver. Call the callback
 * function at a moment when it is possible to write configuration information
 * to the profile using VC_WriteProfile.
 * Returns DRVCNF_OK if all is ok, DRVCNF_CANCEL for failure, or DRVCNF_RESTART if
 * all is ok but a system-restart is needed before the driver will load correctly.
 */
LRESULT VC_InstallDriver(
	    PVC_PROFILE_INFO pProfile,		// access info returned by OpenProfileAccess
	    PPROFILE_CALLBACK pCallback,	// callback function
	    PVOID pContext			// context info for callback	
);

/*
 * Write a single string keyword and DWORD value to the registry or profile
 * for this driver.
 * This can be re-read from the h/w driver using VC_ReadProfile (in either
 * the kernel-mode vckernel.lib version or user mode in the vcuser version).
 *
 * return TRUE for success or FALSE for failure.
 */
BOOL VC_WriteProfile(PVC_PROFILE_INFO pProfile, PTCHAR ValueName, DWORD Value);

/*
 * Write a single string keyword and DWORD value to the registry or profile
 * for this driver.
 * This writes to HKEY_CURRENT_USER and is typically used to store user defaults.
 *
 * return TRUE for success or FALSE for failure.
 */
BOOL VC_WriteProfileUser(PVC_PROFILE_INFO pProfile, PTCHAR ValueName, DWORD Value);


/*
 * read back a driver-specific DWORD profile parameter that was written with
 * VC_WriteProfile. If the valuename cannot be found, the default is returned.
 */
DWORD VC_ReadProfile(PVC_PROFILE_INFO pProfile, PTCHAR ValueName, DWORD dwDefault);

/*
 * read back a driver-specific DWORD profile parameter that was written with
 * VC_WriteProfileUser.  If the valuename cannot be found, the default is returned.
 * This reads from HKEY_CURRENT_USER and is typically used to store user defaults.
 */
DWORD VC_ReadProfileUser(PVC_PROFILE_INFO pProfile, PTCHAR ValueName, DWORD dwDefault);

/*
 * read a string parameter from the device's profile. returns FALSE
 * if it fails to read the string.
 */
BOOL VC_ReadProfileString(
    PVC_PROFILE_INFO pProfile,		// access info from OpenProfile
    PTCHAR ValueName,			// name of value to read
    PTCHAR ValueString,			// put value here
    DWORD ValueLength			// size of ValueString in bytes
);


/*
 * unload a driver. On NT, this stops and removes the kernel-mode driver.
 * On win-16, this calls the Cleanup callback.
 *
 * return DRVCNF_OK if the unload was successful, DRVCNF_CANCEL if it failed, and
 * DRVCNF_RESTART if a system-restart is needed before the removal takes effect.
 *
 * note that after this operation, the PVC_PROFILE_INFO information is still held
 * open. A call to VC_CloseProfileAccess is still needed before exiting.
 */
LRESULT VC_RemoveDriver(PVC_PROFILE_INFO pProfile);



#endif //_VCUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\1394dcam\callback.c ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    dcampkt.c

Abstract:

    This file contains code to handle callback from the bus/class driver.
    They might be running in DISPATCH level.

Author:   

    Yee J. Wu 15-Oct-97

Environment:

    Kernel mode only

Revision History:


--*/


#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "wdm.h"       // for DbgBreakPoint() defined in dbg.h
#include "dbg.h"
#include "dcamdef.h"
#include "dcampkt.h"
#include "sonydcam.h"
#include "capprop.h"


NTSTATUS
DCamToInitializeStateCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PDCAM_IO_CONTEXT pDCamIoContext
    )

/*++

Routine Description:

    Completion routine called after the device is initialize to a known state.

Arguments:

    DriverObject - Pointer to driver object created by system.

    pIrp - Irp that just completed

    pDCamIoContext - A structure that contain the context of this IO completion routine.

Return Value:

    None.

--*/

{
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    PIRB pIrb;

    if(!pDCamIoContext) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }


    pIrb = pDCamIoContext->pIrb;
    pDevExt = pDCamIoContext->pDevExt;
    
    DbgMsg2(("\'DCamToInitializeStateCompletionRoutine: completed DeviceState=%d; pIrp->IoStatus.Status=%x\n", 
        pDCamIoContext->DeviceState, pIrp->IoStatus.Status));

    // Free MDL
    if(pIrb->FunctionNumber == REQUEST_ASYNC_WRITE) {
        DbgMsg3(("DCamToInitializeStateCompletionRoutine: IoFreeMdl\n"));
        IoFreeMdl(pIrb->u.AsyncWrite.Mdl);
    }


    // CAUTION:
    //     Do we need to retry if the return is STATUS_TIMEOUT or invalid generation number ?
    //


    if(pIrp->IoStatus.Status != STATUS_SUCCESS) {
        ERROR_LOG(("DCamToInitializeStateCompletionRoutine: Status=%x != STATUS_SUCCESS; cannot restart its state.\n", pIrp->IoStatus.Status));

        if(pDCamIoContext->pSrb) {
            pDCamIoContext->pSrb->Status = STATUS_UNSUCCESSFUL;
            StreamClassStreamNotification(StreamRequestComplete, pDCamIoContext->pSrb->StreamObject, pDCamIoContext->pSrb);
        }
        DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);

        return STATUS_MORE_PROCESSING_REQUIRED;      
    }

    //
    // Done here if we are in STOP or PAUSE state;
    // else setting to RUN state.
    //
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;

    //
    // No stream is open, job is done.
    //
    if(!pStrmEx) {
        if(pDCamIoContext->pSrb) {
            pDCamIoContext->pSrb->Status = STATUS_SUCCESS;
            StreamClassStreamNotification(StreamRequestComplete, pDCamIoContext->pSrb->StreamObject, pDCamIoContext->pSrb);
        }
        return STATUS_MORE_PROCESSING_REQUIRED;      
    }

    switch(pStrmEx->KSStateFinal) {
    case KSSTATE_STOP:
    case KSSTATE_PAUSE:
        pStrmEx->KSState = pStrmEx->KSStateFinal;
        if(pDCamIoContext->pSrb) {
            pDCamIoContext->pSrb->Status = STATUS_SUCCESS;
            StreamClassStreamNotification(StreamRequestComplete, pDCamIoContext->pSrb->StreamObject, pDCamIoContext->pSrb);
        }
        DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);
        break;

    case KSSTATE_RUN:
        if(pDCamIoContext->pSrb) {
            pDCamIoContext->pSrb->Status = STATUS_SUCCESS;
            StreamClassStreamNotification(StreamRequestComplete, pDCamIoContext->pSrb->StreamObject, pDCamIoContext->pSrb);
        }

        // Restart the stream.
        DCamSetKSStateRUN(pDevExt, pDCamIoContext->pSrb);

        // Need pDCamIoContext->pSrb; so free it after DCamSetKSStateRUN().
        DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);
        break;
    }

    return STATUS_MORE_PROCESSING_REQUIRED;      
}

NTSTATUS
DCamSetKSStateInitialize(
    PDCAM_EXTENSION pDevExt
    )
/*++

Routine Description:

    Set KSSTATE to KSSTATE_RUN.

Arguments:

    pDevExt - 

Return Value:

    Nothing

--*/
{

    PSTREAMEX pStrmEx;
    PIRB pIrb;
    PIRP pIrp;
    PDCAM_IO_CONTEXT pDCamIoContext;
    PIO_STACK_LOCATION NextIrpStack;
    NTSTATUS Status;


    ASSERT(pDevExt);
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;                  
    

    if(!DCamAllocateIrbIrpAndContext(&pDCamIoContext, &pIrb, &pIrp, pDevExt->BusDeviceObject->StackSize)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    } 



    //
    // Initialize the device to a known state 
    // may need to do this due to power down??
    //

    pDCamIoContext->DeviceState = DCAM_SET_INITIALIZE;  // Keep track of device state that we just set.
    pDCamIoContext->pDevExt     = pDevExt;
    pDCamIoContext->RegisterWorkArea.AsULONG = 0;
    pDCamIoContext->RegisterWorkArea.Initialize.Initialize = TRUE;
    pDCamIoContext->RegisterWorkArea.AsULONG = bswap(pDevExt->RegisterWorkArea.AsULONG);
    pIrb->FunctionNumber = REQUEST_ASYNC_WRITE;
    pIrb->Flags = 0;
    pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High = INITIAL_REGISTER_SPACE_HI;
    pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =  
              pDevExt->BaseRegister + FIELDOFFSET(CAMERA_REGISTER_MAP, Initialize);
    pIrb->u.AsyncWrite.nNumberOfBytesToWrite = sizeof(ULONG);
    pIrb->u.AsyncWrite.nBlockSize = 0;
    pIrb->u.AsyncWrite.fulFlags = 0;
    InterlockedExchange(&pIrb->u.AsyncWrite.ulGeneration, pDevExt->CurrentGeneration);        
    pIrb->u.AsyncWrite.Mdl = 
        IoAllocateMdl(&pDCamIoContext->RegisterWorkArea, sizeof(ULONG), FALSE, FALSE, NULL);
    MmBuildMdlForNonPagedPool(pIrb->u.AsyncWrite.Mdl);

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pIrb;
          
    IoSetCompletionRoutine(
        pIrp,
        DCamToInitializeStateCompletionRoutine,
        pDCamIoContext,
        TRUE,
        TRUE,
        TRUE
        );

    Status = 
        IoCallDriver(
            pDevExt->BusDeviceObject,
            pIrp
            );

    return STATUS_SUCCESS;
}

VOID
DCamBusResetNotification(
    IN PVOID Context
    )
/*++

Routine Description:

    We receive this callback notification after a bus reset and if the device is still attached.
    This can happen when a new device is plugged in or an existing one is removed, or due to 
    awaken from sleep state. We will restore the device to its original streaming state by
    (1) Initialize the device to a known state and then 
    (2) launch a state machine to restart streaming.
    We will stop the state machine if previous state has failed.  This can happen if the generation 
    count is changed before the state mahcine is completed.
    
    The freeing and realocation of isoch bandwidth and channel are done in the bus reset irp.
    It is passed down by stream class in SRB_UNKNOWN_DEVICE_COMMAND. This IRP is guarantee to 
    call after this bus reset notification has returned and while the state machine is going on.   

    This is a callback at IRQL_DPC level; there are many 1394 APIs cannot be called at this level
    if it does blocking using KeWaitFor*Object().  Consult 1394 docuement for the list.

    
Arguments:

    Context - Pointer to the context of this registered notification.

Return Value:

    Nothing

--*/
{

    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) Context;
    PSTREAMEX pStrmEx;
    NTSTATUS Status;
    PIRP pIrp;
    PIRB pIrb;

    
    if(!pDevExt) {
        ERROR_LOG(("DCamBusResetNotification:pDevExt is 0.\n\n"));  
        ASSERT(pDevExt);        
        return;
    }

    //
    // Check a field in the context that must be valid to make sure that it is Ok to continue. 
    //
    if(!pDevExt->BusDeviceObject) {
        ERROR_LOG(("DCamBusResetNotification:pDevExtBusDeviceObject is 0.\n\n"));  
        ASSERT(pDevExt->BusDeviceObject);        
        return;
    }  
    DbgMsg2(("DCamBusResetNotification: pDevExt %x, pDevExt->pStrmEx %x, pDevExt->BusDeviceObject %x\n", 
        pDevExt, pDevExt->pStrmEx, pDevExt->BusDeviceObject));

    //
    //
    // Get the current generation count first
    //
    // CAUTION: 
    //     not all 1394 APIs can be called in DCamSubmitIrpSynch() if in DISPATCH_LEVEL;
    //     Getting generation count require no blocking so it is OK.
    if(!DCamAllocateIrbAndIrp(&pIrb, &pIrp, pDevExt->BusDeviceObject->StackSize)) {
        ERROR_LOG(("DCamBusResetNotification: DcamAllocateIrbAndIrp has failed!!\n\n\n"));
        ASSERT(FALSE);            
        return;   
    } 

    pIrb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
    pIrb->Flags = 0;
    Status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);
    if(Status) {
        ERROR_LOG(("\'DCamBusResetNotification: Status=%x while trying to get generation number\n", Status));
        // Done with them; free resources.
        DCamFreeIrbIrpAndContext(0, pIrb, pIrp);
        return;
    }
    ERROR_LOG(("DCamBusResetNotification: Generation number from %d to %d\n", 
        pDevExt->CurrentGeneration, pIrb->u.GetGenerationCount.GenerationCount));

    InterlockedExchange(&pDevExt->CurrentGeneration, pIrb->u.GetGenerationCount.GenerationCount);


    // Done with them; free resources.
    DCamFreeIrbIrpAndContext(0, pIrb, pIrp);

    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
    DbgMsg2(("\'%d:%s) DCamBusResetNotification: !!! pDevExt, %x; pStrmEx, %x !!!\n", 
          pDevExt->idxDev, pDevExt->pchVendorName, pDevExt, pStrmEx));

    //
    // If the stream was open (pStrmEx != NULL && pStrmEx->pVideoInfoHeader != NULL),
    // then we need to restore its streaming state.
    //
    if (pStrmEx &&
        pStrmEx->pVideoInfoHeader != NULL) {
        DbgMsg2(("\'%d:%s) DCamBusResetNotification: Stream was open; Try allocate them again.\n", pDevExt->idxDev, pDevExt->pchVendorName));
    } else {
        DbgMsg2(("DCamBusResetNotification:Stream has not open on this device.  Done!\n"));
        return;
    }


    //
    // Save the original state as the final state.
    //
    if(pStrmEx)
        pStrmEx->KSStateFinal = pStrmEx->KSState;     

    //
    // Initialize the device, and restore to its original streaming state.
    // 
    //
    // CAUTION: 
    //    maybe need to do this only if we are recovered from power loss state.
    //    We can move this to power management function in the future.
    //    In the completion routine, it will invoke other function to restore its streaming state.
    //

    DCamSetKSStateInitialize(pDevExt);
    
    DbgMsg2(("\'DCamBusResetNotification: Leaving...; Task complete in the CompletionRoutine.\n"));

    return;
}


NTSTATUS
DCamDetachBufferCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PIRB pIrb
    )
/*++

Routine Description:

    Detaching a buffer has completed.  Attach next buffer.
    Returns more processing required so the IO Manager will leave us alone

Arguments:

    DriverObject - Pointer to driver object created by system.

    pIrp - Irp that just completed

    pIrb - Context set in DCamIsochCallback()

Return Value:

    None.

--*/

{
    IN PISOCH_DESCRIPTOR IsochDescriptor;
    PDCAM_EXTENSION pDevExt;
    PISOCH_DESCRIPTOR_RESERVED IsochDescriptorReserved;
    KIRQL oldIrql;


    if(!pIrb) {
        ERROR_LOG(("\'DCamDetachBufferCR: pIrb is NULL\n"));
        ASSERT(pIrb);
        IoFreeIrp(pIrp);
        return (STATUS_MORE_PROCESSING_REQUIRED);
    }

    // Get IsochDescriptor from the context (pIrb)
    IsochDescriptor = pIrb->u.IsochDetachBuffers.pIsochDescriptor;
    if(!IsochDescriptor) {
        ERROR_LOG(("\'DCamDetachBufferCR: IsochDescriptor is NULL\n"));
        ASSERT(IsochDescriptor);
        IoFreeIrp(pIrp);
        return (STATUS_MORE_PROCESSING_REQUIRED);
    }

    if(pIrp->IoStatus.Status != STATUS_SUCCESS) {
        ERROR_LOG(("\'DCamDetachBufferCR: pIrp->IoStatus.Status(%x) != STATUS_SUCCESS\n", pIrp->IoStatus.Status));
        ASSERT(pIrp->IoStatus.Status == STATUS_SUCCESS);
        IoFreeIrp(pIrp);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }


    // IsochDescriptorReserved->Srb->Irp->IoStatus = pIrp->IoStatus.Status;
    IoFreeIrp(pIrp);

    // Freed and should not be referenced again!
    IsochDescriptor->DeviceReserved[5] = 0;

    IsochDescriptorReserved = (PISOCH_DESCRIPTOR_RESERVED) &IsochDescriptor->DeviceReserved[0];
    pDevExt = (PDCAM_EXTENSION) IsochDescriptor->Context1;
    DbgMsg3(("\'DCamDetachBufferCR: IsochDescriptorReserved=%x; DevExt=%x\n", IsochDescriptorReserved, pDevExt));   

    ASSERT(IsochDescriptorReserved);
    ASSERT(pDevExt);
     
    if(pDevExt &&
       IsochDescriptorReserved) {
        //
        // Indicate that the Srb should be complete
        //

        IsochDescriptorReserved->Flags |= STATE_SRB_IS_COMPLETE;
        IsochDescriptorReserved->Srb->Status = STATUS_SUCCESS;
        IsochDescriptorReserved->Srb->CommandData.DataBufferArray->DataUsed = IsochDescriptor->ulLength;
        IsochDescriptorReserved->Srb->ActualBytesTransferred = IsochDescriptor->ulLength;

        DbgMsg3(("\'DCamDetachBufferCR: Completing Srb %x\n", IsochDescriptorReserved->Srb));

        KeAcquireSpinLock(&pDevExt->IsochDescriptorLock, &oldIrql);
        RemoveEntryList(&IsochDescriptorReserved->DescriptorList);  InterlockedDecrement(&pDevExt->PendingReadCount);
        KeReleaseSpinLock(&pDevExt->IsochDescriptorLock, oldIrql);

        ASSERT(IsochDescriptorReserved->Srb->StreamObject);
        ASSERT(IsochDescriptorReserved->Srb->Flags & SRB_HW_FLAGS_STREAM_REQUEST);
        StreamClassStreamNotification(
               StreamRequestComplete, 
               IsochDescriptorReserved->Srb->StreamObject, 
               IsochDescriptorReserved->Srb);

        // Free it here instead of in DCamCompletionRoutine.
        ExFreePool(IsochDescriptor);     


        KeAcquireSpinLock(&pDevExt->IsochWaitingLock, &oldIrql);
        if (!IsListEmpty(&pDevExt->IsochWaitingList) && pDevExt->PendingReadCount >= MAX_BUFFERS_SUPPLIED) {

            //
            // We had someone blocked waiting for us to complete.  Pull
            // them off the waiting list and get them running
            //

            DbgMsg3(("DCamDetachBufferCR: Dequeueing request - Read Count = %x\n", pDevExt->PendingReadCount));
            IsochDescriptorReserved = \
                   (PISOCH_DESCRIPTOR_RESERVED) RemoveHeadList(
                   &pDevExt->IsochWaitingList
                   );

            KeReleaseSpinLock(&pDevExt->IsochWaitingLock, oldIrql);

            IsochDescriptor = \
                   (PISOCH_DESCRIPTOR) (((PUCHAR) IsochDescriptorReserved) - 
                   FIELDOFFSET(ISOCH_DESCRIPTOR, DeviceReserved[0]));

            DCamReadStreamWorker(IsochDescriptorReserved->Srb, IsochDescriptor);

        } else {
            KeReleaseSpinLock(&pDevExt->IsochWaitingLock, oldIrql);
        }
    }    

    return (STATUS_MORE_PROCESSING_REQUIRED);
}



VOID
DCamIsochCallback(
    IN PDCAM_EXTENSION pDevExt,
    IN PISOCH_DESCRIPTOR IsochDescriptor
    )

/*++

Routine Description:

    Called when an Isoch Descriptor completes

Arguments:

    pDevExt - Pointer to our DeviceExtension

    IsochDescriptor - IsochDescriptor that completed

Return Value:

    Nothing

--*/

{
    PIRB pIrb;
    PIRP pIrp;
    PSTREAMEX pStrmEx;
    PIO_STACK_LOCATION NextIrpStack;
    PISOCH_DESCRIPTOR_RESERVED IsochDescriptorReserved;
    PKSSTREAM_HEADER pDataPacket;
    PKS_FRAME_INFO pFrameInfo;
    KIRQL oldIrql;




    //
    // Debug check to make sure we're dealing with a real IsochDescriptor
    //

    ASSERT ( IsochDescriptor );
    IsochDescriptorReserved = (PISOCH_DESCRIPTOR_RESERVED) &IsochDescriptor->DeviceReserved[0];


    //
    // All Pending read will be either resubmitted, or cancelled (if out of resource).
    //

    if(pDevExt->bStopIsochCallback) {
        ERROR_LOG(("DCamIsochCallback: bStopCallback is set. IsochDescriptor %x (and Reserved %x) is returned and not processed.\n", 
            IsochDescriptor, IsochDescriptorReserved));
        return;
    }
    

    //
    // Synchronization note:
    //
    // We are competing with cancel packet routine in the 
    // event of device removal or setting to STOP state.
    // which ever got the spin lock to set DEATCH_BUFFER 
    // flag take ownership completing the Irp/IsochDescriptor.
    // 

    KeAcquireSpinLock(&pDevExt->IsochDescriptorLock, &oldIrql);
    if(pDevExt->bDevRemoved ||
       (IsochDescriptorReserved->Flags & (STATE_SRB_IS_COMPLETE | STATE_DETACHING_BUFFERS)) ) {
        ERROR_LOG(("DCamIsochCallback: bDevRemoved || STATE_SRB_IS_COMPLETE | STATE_DETACHING_BUFFERS %x %x\n", 
                IsochDescriptorReserved,IsochDescriptorReserved->Flags));
        ASSERT((!pDevExt->bDevRemoved && !(IsochDescriptorReserved->Flags & (STATE_SRB_IS_COMPLETE | STATE_DETACHING_BUFFERS))));
        KeReleaseSpinLock(&pDevExt->IsochDescriptorLock, oldIrql);    
        return;   
    }
    IsochDescriptorReserved->Flags |= STATE_DETACHING_BUFFERS;        
    KeReleaseSpinLock(&pDevExt->IsochDescriptorLock, oldIrql);    


    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;

    ASSERT(pStrmEx == (PSTREAMEX)IsochDescriptorReserved->Srb->StreamObject->HwStreamExtension);

    pStrmEx->FrameCaptured++;
    pStrmEx->FrameInfo.PictureNumber = pStrmEx->FrameCaptured + pStrmEx->FrameInfo.DropCount;

    //
    // Return the timestamp for the frame
    //

    pDataPacket = IsochDescriptorReserved->Srb->CommandData.DataBufferArray;
    pFrameInfo = (PKS_FRAME_INFO) (pDataPacket + 1);

    ASSERT ( pDataPacket );
    ASSERT ( pFrameInfo );

    //
    // Return the timestamp for the frame
    //
    pDataPacket->PresentationTime.Numerator = 1;
    pDataPacket->PresentationTime.Denominator = 1;
    pDataPacket->Duration = pStrmEx->pVideoInfoHeader->AvgTimePerFrame;

    //
    // if we have a master clock
    // 
    if (pStrmEx->hMasterClock) {

        ULONGLONG tmStream;
                    
        tmGetStreamTime(IsochDescriptorReserved->Srb, pStrmEx, &tmStream);
        pDataPacket->PresentationTime.Time = tmStream;
        pDataPacket->OptionsFlags = 0;
          
        pDataPacket->OptionsFlags |= 
             KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
             KSSTREAM_HEADER_OPTIONSF_DURATIONVALID |
             KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT;     // Every frame we generate is a key frame (aka SplicePoint)
               
        DbgMsg3(("\'IsochCallback: Time(%dms); P#(%d)=Cap(%d)+Drp(%d); Pend%d\n",
                (ULONG) tmStream/10000,
                (ULONG) pStrmEx->FrameInfo.PictureNumber,
                (ULONG) pStrmEx->FrameCaptured,
                (ULONG) pStrmEx->FrameInfo.DropCount,
                pDevExt->PendingReadCount));

    } else {

        pDataPacket->PresentationTime.Time = 0;
        pDataPacket->OptionsFlags &=                       
            ~(KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
            KSSTREAM_HEADER_OPTIONSF_DURATIONVALID);
    }

    // Set additional info fields about the data captured such as:
    //   Frames Captured
    //   Frames Dropped
    //   Field Polarity
                
    pStrmEx->FrameInfo.ExtendedHeaderSize = pFrameInfo->ExtendedHeaderSize;
    *pFrameInfo = pStrmEx->FrameInfo;

#ifdef SUPPORT_RGB24
    // Swaps B and R or BRG24 to RGB24.
    // There are 640x480 pixels so 307200 swaps are needed.
    if(pDevExt->CurrentModeIndex == VMODE4_RGB24 && pStrmEx->pVideoInfoHeader) {
        PBYTE pbFrameBuffer;
        BYTE bTemp;
        ULONG i, ulLen;

#ifdef USE_WDM110   // Win2000
        // Driver verifier flag to use this but if this is used, this driver will not load for any Win9x OS.
        pbFrameBuffer = (PBYTE) MmGetSystemAddressForMdlSafe(IsochDescriptorReserved->Srb->Irp->MdlAddress, NormalPagePriority);
#else    // Win9x
        pbFrameBuffer = (PBYTE) MmGetSystemAddressForMdl    (IsochDescriptorReserved->Srb->Irp->MdlAddress);
#endif
        if(pbFrameBuffer) {
            // calculate number of pixels
            ulLen = abs(pStrmEx->pVideoInfoHeader->bmiHeader.biWidth) * abs(pStrmEx->pVideoInfoHeader->bmiHeader.biHeight);
            ASSERT(ulLen == pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage/3);
            if(ulLen > pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage)
                ulLen = pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage/3;

            for (i=0; i < ulLen; i++) {
                // swap R and B
                bTemp = pbFrameBuffer[0];
                pbFrameBuffer[0] = pbFrameBuffer[2];
                pbFrameBuffer[2] = bTemp;
                pbFrameBuffer += 3;  // next RGB24 pixel
            }
        }
    }
#endif

    // Reuse the Irp and Irb
    pIrp = (PIRP) IsochDescriptor->DeviceReserved[5];
    ASSERT(pIrp);            

    pIrb = (PIRB) IsochDescriptor->DeviceReserved[6];
    ASSERT(pIrb);            

#if DBG
    // Same isochdescriptor should only be callback once.    
    ASSERT((IsochDescriptor->DeviceReserved[7] == 0x87654321));
    IsochDescriptor->DeviceReserved[7]++;
#endif

    pIrb->FunctionNumber = REQUEST_ISOCH_DETACH_BUFFERS;
    pIrb->u.IsochDetachBuffers.hResource = pDevExt->hResource;
    pIrb->u.IsochDetachBuffers.nNumberOfDescriptors = 1;
    pIrb->u.IsochDetachBuffers.pIsochDescriptor = IsochDescriptor;

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pIrb;

    IoSetCompletionRoutine(
        pIrp,
        DCamDetachBufferCR,  // Detach complete and will attach queued buffer.
        pIrb,
        TRUE,
        TRUE,
        TRUE
        );
          
    IoCallDriver(pDevExt->BusDeviceObject, pIrp);
            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\1394dcam\capprop.c ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    CapProp.c

Abstract:

    Stream class based WDM driver for 1934 Desktop Camera.
    This file contains code to handle the video and camera control properties.

Author:
    
    Yee J. Wu 9-Sep-97

Environment:

    Kernel mode only

Revision History:

    Yee J. Wu 16-Nov-00

        Make getting, advertising, and setting device properties more generic 
        by querying feature from the device directly instead of static settings
        based on the vendor.  The default and initial current settings will be 
        read from registry (from the INF).  The current setting will continue 
        to be updated and used thereafter.  For device that does not have its INF
        section, mid-range will be used as its default and initial settings.

--*/

#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "wdm.h"       // for DbgBreakPoint() defined in dbg.h
#include "dbg.h"
#include "dcamdef.h"
#include "dcampkt.h"

#include "capprop.h"   // Video and camera property function prototype
#include "PropData.h"  // Generic device properties that are readonly


//
// Registry subky and values wide character strings.
//
WCHAR wszSettings[]     = L"Settings";

WCHAR wszVModeInq0[]    = L"VModeInq0";

WCHAR wszBrightness[]   = L"Brightness";
WCHAR wszHue[]          = L"Hue";
WCHAR wszSaturation[]   = L"Saturation";
WCHAR wszSharpness[]    = L"Sharpness";
WCHAR wszWhiteBalance[] = L"WhiteBalance";
WCHAR wszZoom[]         = L"Zoom";
WCHAR wszFocus[]        = L"Focus";

WCHAR wszBrightnessDef[]   = L"BrightnessDef";
WCHAR wszHueDef[]          = L"HueDef";
WCHAR wszSaturationDef[]   = L"SaturationDef";
WCHAR wszSharpnessDef[]    = L"SharpnessDef";
WCHAR wszWhiteBalanceDef[] = L"WhiteBalanceDef";
WCHAR wszZoomDef[]         = L"ZoomDef";
WCHAR wszFocusDef[]        = L"FocusDef";

NTSTATUS
DCamGetProperty(
    IN PIRB pIrb,
    PDCAM_EXTENSION pDevExt, 
    ULONG ulFieldOffset,
    LONG * plValue,
    ULONG * pulCapability,
    ULONG * pulFlags,
    DCamRegArea * pFeature
    )
/*
    Get a device property from its register.  Return the capabilites and current settings.
*/
{
    NTSTATUS status, StatusWait;

    // Make sure that device support this feature.
    if(pFeature->Feature.PresenceInq == 0) {
        DbgMsg1(("\'OffSet:%d not supported!\n", ulFieldOffset));
        return STATUS_NOT_SUPPORTED;
    }

    // Serialize read/write to the device register
    StatusWait = KeWaitForSingleObject( &pDevExt->hMutexProperty, Executive, KernelMode, FALSE, 0 );

    *pulCapability = 0;  
    if (pFeature->Feature.AutoMode)
        *pulCapability |= KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO;  // or == KSPROPERTY_CAMERACONTROL_FLAGS_AUTO

    if (pFeature->Feature.ManualMode)
        *pulCapability |= KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;

    pDevExt->RegArea.AsULONG = 0;
    status = DCamReadRegister(pIrb, pDevExt, ulFieldOffset, &(pDevExt->RegArea.AsULONG));
    if(NT_SUCCESS(status)) {

        pDevExt->RegArea.AsULONG = bswap(pDevExt->RegArea.AsULONG);

        DbgMsg1(("\'GetProperty: CurrentSettings: Offset:%d; %x; Pres:%d;OnePush:%d;OnOff:%d;Auto:%d;Value:%d\n", 
            ulFieldOffset,
            pDevExt->RegArea.AsULONG, 
            pDevExt->RegArea.Brightness.PresenceInq,   
            pDevExt->RegArea.Brightness.OnePush,
            pDevExt->RegArea.Brightness.OnOff,
            pDevExt->RegArea.Brightness.AutoMode,          
            pDevExt->RegArea.Brightness.Value            
            ));

        *plValue = (LONG) pDevExt->RegArea.Brightness.Value;

        // These only valid if it has these capabilities.
        if (pDevExt->RegArea.Brightness.AutoMode)
            *pulFlags = KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO;
        else 
            *pulFlags = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;

    } else {
        ERROR_LOG(("\'DCamGetProperty: Failed %x to read setting.  Offset:%x\n", status, ulFieldOffset));
        status = STATUS_UNSUCCESSFUL;
    }

    KeReleaseMutex(&pDevExt->hMutexProperty, FALSE);

    return status;
}




NTSTATUS
DCamSetProperty(
    IN PIRB pIrb,
    PDCAM_EXTENSION pDevExt, 
    ULONG ulFieldOffset,
    ULONG ulFlags,
    LONG  lValue,
    DCamRegArea * pFeature,
    DCamRegArea * pCachedRegArea
    )
/*
    For a supported device, set to a new setting.
*/
{
    NTSTATUS status, StatusWait;
    LONG lRetries = MAX_READ_REG_RETRIES;
    LARGE_INTEGER stableTime;


    // Make sure that device support this feature.
    if(pFeature->Feature.PresenceInq == 0) {
        DbgMsg1(("\'OffSet:%d not supported!\n", ulFieldOffset));
        return STATUS_NOT_SUPPORTED;
    }

    // Validate the supported range
    if((LONG) pFeature->Feature.MAX_Value < lValue || lValue < (LONG) pFeature->Feature.MIN_Value) {
        ERROR_LOG(("\'Invalid value:%d for supported range (%d, %d)\n", lValue, pFeature->Feature.MIN_Value, pFeature->Feature.MAX_Value));
        return STATUS_INVALID_PARAMETER;
    }

    // Serialize read/write to the register
    StatusWait = KeWaitForSingleObject( &pDevExt->hMutexProperty, Executive, KernelMode, FALSE, 0 );

    // Read the current setting of this property
    pDevExt->RegArea.AsULONG = 0;
    do {
        status = DCamReadRegister(pIrb, pDevExt, ulFieldOffset, &(pDevExt->RegArea.AsULONG));
        if (!status) {                          
            pDevExt->RegArea.AsULONG = bswap(pDevExt->RegArea.AsULONG);
            DbgMsg3(("\'SetProperty: Current: %x: Pres:%d;OnePush:%d;OnOff:%d;Auto:%d;Value:%d\n", 
                pDevExt->RegArea.AsULONG, 
                pDevExt->RegArea.Brightness.PresenceInq,   
                pDevExt->RegArea.Brightness.OnePush,
                pDevExt->RegArea.Brightness.OnOff,
                pDevExt->RegArea.Brightness.AutoMode,
                pDevExt->RegArea.Brightness.Value
            ));
            // This feature might be in the transition (such as zoom or focus), 
            // it might return pDevExt->RegArea.Brightness.PresenceInq == 0.
            if(pDevExt->RegArea.Brightness.PresenceInq  == 1)
                break;
            else {
                if(lRetries > 1) {
                    stableTime.LowPart = DCAM_REG_STABLE_DELAY;
                    stableTime.HighPart = -1;
                    KeDelayExecutionThread(KernelMode, TRUE, &stableTime);
                    ERROR_LOG(("\'DCamSetProperty: delay, and try again...\n"));
                };
            }
        } else {
            // No need to retry if we failed to read.
            break;
        }

        lRetries--;
    } while (lRetries > 0);

    if(status || lRetries == 0) {
        KeReleaseMutex(&pDevExt->hMutexProperty, FALSE);
        ERROR_LOG(("\'DCamSetProperty: Failed! ST:%x; exceeded retried while pres is still 0\n", status));
        return STATUS_UNSUCCESSFUL;
    }

    pDevExt->RegArea.Brightness.PresenceInq = 1;  // Should be present.

    if((ulFlags & KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO) == KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO) {
        pDevExt->RegArea.Brightness.AutoMode = 1;
        // When Auto is set to 1, Value field is ignored.
    } else {
        pDevExt->RegArea.Brightness.AutoMode = 0;
        // special case for white balance
        if(FIELDOFFSET(CAMERA_REGISTER_MAP, WhiteBalance) == ulFieldOffset) {
            pDevExt->RegArea.WhiteBalance.UValue = pDevExt->RegArea.WhiteBalance.VValue = lValue;
        } else 
            pDevExt->RegArea.Brightness.Value = lValue;    
    }

    DbgMsg2(("\'SetProperty: NewSetting:     Offset:%d; %x; Pres:%d;OnePush:%d;OnOff:%d;Auto:%d;Value:%d\n", 
        ulFieldOffset,
        pDevExt->RegArea.AsULONG, 
        pDevExt->RegArea.Brightness.PresenceInq,   
        pDevExt->RegArea.Brightness.OnePush,
        pDevExt->RegArea.Brightness.OnOff,
        pDevExt->RegArea.Brightness.AutoMode,          
        pDevExt->RegArea.Brightness.Value            
        ));

    pDevExt->RegArea.AsULONG = bswap(pDevExt->RegArea.AsULONG);
    status = DCamWriteRegister(pIrb, pDevExt, ulFieldOffset, pDevExt->RegArea.AsULONG);

    if(status) { 
        ERROR_LOG(("\'DCamGetProperty: failed with status=0x%x\n", status));
    } else {
        // Update the cached setting (saved in the device extension)
        // These cached values will be save to registry as the persisted values for these properties.
        if(pCachedRegArea) {
            // WhiteBalance is an exception
            if(FIELDOFFSET(CAMERA_REGISTER_MAP, WhiteBalance) == ulFieldOffset) {
                pCachedRegArea->WhiteBalance.UValue = pCachedRegArea->WhiteBalance.VValue = lValue;
            } else
                pCachedRegArea->Brightness.Value    = lValue;
             // AutoMode is the 7th bit for all the properties used here.  (we do not use TRIGGER_MODE)
            pCachedRegArea->Brightness.AutoMode = ((ulFlags & KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO) == KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO);                    
        }
#if DBG
        // Verify that data were written as expected.
        pDevExt->RegAreaVerify.AsULONG = 0;
        status = DCamReadRegister(pIrb, pDevExt, ulFieldOffset, &(pDevExt->RegAreaVerify.AsULONG));


        if (!status) {    
            // bswap so we can compare.
            pDevExt->RegArea.AsULONG       = bswap(pDevExt->RegArea.AsULONG);
            pDevExt->RegAreaVerify.AsULONG = bswap(pDevExt->RegAreaVerify.AsULONG);

            DbgMsg2(("\'SetProperty: VerifySetting;  Offset:%d; %x; Pres:%d;OnePush:%d;OnOff:%d;Auto:%d;Value:%d\n\n", 
                ulFieldOffset,
                pDevExt->RegAreaVerify.AsULONG, 
                pDevExt->RegAreaVerify.Brightness.PresenceInq,   
                pDevExt->RegAreaVerify.Brightness.OnePush,
                pDevExt->RegAreaVerify.Brightness.OnOff,
                pDevExt->RegAreaVerify.Brightness.AutoMode,
                pDevExt->RegAreaVerify.Brightness.Value 
                ));

            ASSERT(pDevExt->RegArea.Brightness.PresenceInq == pDevExt->RegAreaVerify.Brightness.PresenceInq);
            ASSERT(pDevExt->RegArea.Brightness.OnePush     == pDevExt->RegAreaVerify.Brightness.OnePush);
            ASSERT(pDevExt->RegArea.Brightness.OnOff       == pDevExt->RegAreaVerify.Brightness.OnOff);
            ASSERT(pDevExt->RegArea.Brightness.AutoMode    == pDevExt->RegAreaVerify.Brightness.AutoMode);
            // If not auto mode, Value must match!
            ASSERT( pDevExt->RegArea.Brightness.Value == pDevExt->RegAreaVerify.Brightness.Value || 
                   (pDevExt->RegArea.Brightness.Value != pDevExt->RegAreaVerify.Brightness.Value && pDevExt->RegArea.Brightness.AutoMode == 1));
        }
#endif
    }

    KeReleaseMutex(&pDevExt->hMutexProperty, FALSE);

    return status;

}



/*
** AdapterGetVideoProcAmpProperty ()
**
**    Handles Set operations on the VideoProcAmp property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
AdapterGetVideoProcAmpProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    NTSTATUS status;

    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;

    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    PKSPROPERTY_VIDEOPROCAMP_S pS = (PKSPROPERTY_VIDEOPROCAMP_S) pSPD->PropertyInfo;    // pointer to the data

    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEOPROCAMP_S));   

    switch (pSPD->Property->Id) {

    case KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:  
        status = DCamGetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Brightness), &pS->Value, &pS->Capabilities, &pS->Flags, &pDevExt->DevProperty[ENUM_BRIGHTNESS].Feature);
        break;

    case KSPROPERTY_VIDEOPROCAMP_SHARPNESS:  
        status = DCamGetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Sharpness), &pS->Value, &pS->Capabilities, &pS->Flags, &pDevExt->DevProperty[ENUM_SHARPNESS].Feature);
        break;

    case KSPROPERTY_VIDEOPROCAMP_HUE:  
        status = DCamGetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Hue), &pS->Value, &pS->Capabilities, &pS->Flags, &pDevExt->DevProperty[ENUM_HUE].Feature); 
        break;
        
    case KSPROPERTY_VIDEOPROCAMP_SATURATION:
        status = DCamGetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Saturation), &pS->Value, &pS->Capabilities, &pS->Flags, &pDevExt->DevProperty[ENUM_SATURATION].Feature);
        break;

    case KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE:
        status = DCamGetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, WhiteBalance), &pS->Value, &pS->Capabilities, &pS->Flags, &pDevExt->DevProperty[ENUM_WHITEBALANCE].Feature);
        break;


    default:
        DbgMsg2(("\'AdapterGetVideoProcAmpProperty, Id (%x)not supported.\n", pSPD->Property->Id));
        ASSERT(FALSE);
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    pSrb->Status = status;
    pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEOPROCAMP_S);

}

/*
** AdapterGetCameraControlProperty ()
**
**    Handles Set operations on the VideoProcAmp property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
AdapterGetCameraControlProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    NTSTATUS status;

    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;

    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    PKSPROPERTY_CAMERACONTROL_S pS = (PKSPROPERTY_CAMERACONTROL_S) pSPD->PropertyInfo;    // pointer to the data

    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_CAMERACONTROL_S));

    switch (pSPD->Property->Id) {

    case KSPROPERTY_CAMERACONTROL_FOCUS:
        status = DCamGetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Focus), &pS->Value, &pS->Capabilities, &pS->Flags, &pDevExt->DevProperty[ENUM_FOCUS].Feature);
        break;       

    case KSPROPERTY_CAMERACONTROL_ZOOM:
        status = DCamGetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Zoom), &pS->Value, &pS->Capabilities, &pS->Flags, &pDevExt->DevProperty[ENUM_ZOOM].Feature);
        break;       

    default:     
        DbgMsg2(("\'AdapterGetCameraControlProperty, Id (%x)not supported.\n", pSPD->Property->Id));
        ASSERT(FALSE);
        status = STATUS_NOT_IMPLEMENTED;  
        break;
    }

    pSrb->Status = status;
    pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_CAMERACONTROL_S);

}


/*
** AdapterGetProperty ()
**
**    Handles Get operations for all adapter properties.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI 
AdapterGetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )

{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEOPROCAMP, &pSPD->Property->Set)) {
        AdapterGetVideoProcAmpProperty (pSrb);
    } else  if (IsEqualGUID(&PROPSETID_VIDCAP_CAMERACONTROL, &pSPD->Property->Set)) {
        AdapterGetCameraControlProperty (pSrb);
    } else {
        //
        // We should never get here
        //

        ASSERT(FALSE);
    }
}

/*
** AdapterSetVideoProcAmpProperty ()
**
**    Handles Set operations on the VideoProcAmp property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
AdapterSetVideoProcAmpProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    NTSTATUS status;

    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;

    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    PKSPROPERTY_VIDEOPROCAMP_S pS = (PKSPROPERTY_VIDEOPROCAMP_S) pSPD->PropertyInfo;    // pointer to the data

    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEOPROCAMP_S));    

    switch (pSPD->Property->Id) {

    case KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:    
        status = DCamSetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Brightness), pS->Flags, pS->Value, &pDevExt->DevProperty[ENUM_BRIGHTNESS].Feature, &pDevExt->DevProperty[ENUM_BRIGHTNESS].StatusNControl);
        break;
        
    case KSPROPERTY_VIDEOPROCAMP_SHARPNESS:
        status = DCamSetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Sharpness), pS->Flags, pS->Value, &pDevExt->DevProperty[ENUM_SHARPNESS].Feature, &pDevExt->DevProperty[ENUM_SHARPNESS].StatusNControl);
        break;

    case KSPROPERTY_VIDEOPROCAMP_HUE:
        status = DCamSetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Hue), pS->Flags, pS->Value, &pDevExt->DevProperty[ENUM_HUE].Feature, &pDevExt->DevProperty[ENUM_HUE].StatusNControl);
        break;

    case KSPROPERTY_VIDEOPROCAMP_SATURATION:
        status = DCamSetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Saturation), pS->Flags, pS->Value, &pDevExt->DevProperty[ENUM_SATURATION].Feature, &pDevExt->DevProperty[ENUM_SATURATION].StatusNControl);
        break;

    case KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE:
        status = DCamSetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, WhiteBalance), pS->Flags, pS->Value, &pDevExt->DevProperty[ENUM_WHITEBALANCE].Feature, &pDevExt->DevProperty[ENUM_WHITEBALANCE].StatusNControl);
        break;

    default:
        status = STATUS_NOT_IMPLEMENTED; 
        break;
    }

    pSrb->Status = status;
    pSrb->ActualBytesTransferred = (status == STATUS_SUCCESS ? sizeof (KSPROPERTY_VIDEOPROCAMP_S) : 0);
 

}


/*
** AdapterSetCameraControlProperty ()
**
**    Handles Set operations on the CameraControl property set.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
AdapterSetCameraControlProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    NTSTATUS status;

    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;

    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    PKSPROPERTY_CAMERACONTROL_S pS = (PKSPROPERTY_CAMERACONTROL_S) pSPD->PropertyInfo;    // pointer to the data

    ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_CAMERACONTROL_S));    

    switch (pSPD->Property->Id) {

    case KSPROPERTY_CAMERACONTROL_FOCUS:
        status = DCamSetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Focus), pS->Flags, pS->Value, &pDevExt->DevProperty[ENUM_FOCUS].Feature, &pDevExt->DevProperty[ENUM_FOCUS].StatusNControl);
        break;

    case KSPROPERTY_CAMERACONTROL_ZOOM:
        status = DCamSetProperty((PIRB) pSrb->SRBExtension, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Zoom), pS->Flags, pS->Value, &pDevExt->DevProperty[ENUM_ZOOM].Feature, &pDevExt->DevProperty[ENUM_ZOOM].StatusNControl);
        break;
 
    default:
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    pSrb->Status = status;
    pSrb->ActualBytesTransferred = (status == STATUS_SUCCESS ? sizeof (KSPROPERTY_CAMERACONTROL_S) : 0);

}


/*
** AdapterSetProperty ()
**
**    Handles Get operations for all adapter properties.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI 
AdapterSetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )

{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID(&PROPSETID_VIDCAP_VIDEOPROCAMP, &pSPD->Property->Set)) {
        AdapterSetVideoProcAmpProperty (pSrb);
    } else  if (IsEqualGUID(&PROPSETID_VIDCAP_CAMERACONTROL, &pSPD->Property->Set)) {
        AdapterSetCameraControlProperty (pSrb);
    } else {
        //
        // We should never get here
        //

        ASSERT(FALSE);
    }
}


NTSTATUS 
CreateRegistryKeySingle(
    IN HANDLE hKey,
    IN ACCESS_MASK desiredAccess,
    PWCHAR pwszSection,
    OUT PHANDLE phKeySection
    )
{
    NTSTATUS status;
    UNICODE_STRING ustr;
    OBJECT_ATTRIBUTES objectAttributes;

    RtlInitUnicodeString(&ustr, pwszSection);
    InitializeObjectAttributes(
        &objectAttributes,
        &ustr,
        OBJ_CASE_INSENSITIVE,
        hKey,
        NULL
        );

    status = 
         ZwCreateKey(
              phKeySection,
              desiredAccess,
              &objectAttributes,
              0,
              NULL,                    /* optional*/
              REG_OPTION_NON_VOLATILE,
              NULL
              );         

    return status;
}



NTSTATUS 
CreateRegistrySubKey(
    IN HANDLE hKey,
    IN ACCESS_MASK desiredAccess,
    PWCHAR pwszSection,
    OUT PHANDLE phKeySection
    )
{
    UNICODE_STRING ustr;
    USHORT usPos = 1;             // Skip first backslash
    static WCHAR wSep = '\\';
    NTSTATUS status = STATUS_SUCCESS;

    RtlInitUnicodeString(&ustr, pwszSection);

    while(usPos < ustr.Length) {
        if(ustr.Buffer[usPos] == wSep) {

            // NULL terminate our partial string
            ustr.Buffer[usPos] = UNICODE_NULL;
            status = 
                CreateRegistryKeySingle(
                    hKey,
                    desiredAccess,
                    ustr.Buffer,
                    phKeySection
                    );
            ustr.Buffer[usPos] = wSep;

            if(NT_SUCCESS(status)) {
                ZwClose(*phKeySection);
            } else {
                break;
            }
        }
        usPos++;
    }

    // Create the full key
    if(NT_SUCCESS(status)) {
        status = 
            CreateRegistryKeySingle(
                 hKey,
                 desiredAccess,
                 ustr.Buffer,
                 phKeySection
                 );
    }

    return status;
}



NTSTATUS 
GetRegistryKeyValue (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN PULONG DataLength
    )

/*++

Routine Description:
    
    This routine gets the specified value out of the registry

Arguments:

    Handle - Handle to location in registry

    KeyNameString - registry key we're looking for

    KeyNameStringLength - length of registry key we're looking for

    Data - where to return the data

    DataLength - how big the data is

Return Value:

    status is returned from ZwQueryValueKey

--*/

{
    NTSTATUS status = STATUS_INSUFFICIENT_RESOURCES;
    UNICODE_STRING keyName;
    ULONG length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;


    RtlInitUnicodeString(&keyName, KeyNameString);
    
    length = sizeof(KEY_VALUE_FULL_INFORMATION) + 
            KeyNameStringLength + *DataLength;
            
    fullInfo = ExAllocatePool(PagedPool, length); 
     
    if (fullInfo) { 
       
        status = ZwQueryValueKey(
                    Handle,
                   &keyName,
                    KeyValueFullInformation,
                    fullInfo,
                    length,
                   &length
                    );
                        
        if (NT_SUCCESS(status)){

            ASSERT(fullInfo->DataLength <= *DataLength); 

            RtlCopyMemory(
                Data,
                ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                fullInfo->DataLength
                );

        }            

        *DataLength = fullInfo->DataLength;
        ExFreePool(fullInfo);

    }        
    
    return (status);

}



NTSTATUS
SetRegistryKeyValue(
   HANDLE hKey,
   PWCHAR pwszEntry, 
   LONG nValue
   )
{
    NTSTATUS status;
    UNICODE_STRING ustr;

    RtlInitUnicodeString(&ustr, pwszEntry);

    status =        
        ZwSetValueKey(
            hKey,
            &ustr,
            0,   /* optional */
            REG_DWORD,
            &nValue,
            sizeof(nValue)
            );         

   return status;
}

BOOL
DCamQueryPropertyFeaturesAndSettings(
    IN PIRB pIrb,
    PDCAM_EXTENSION pDevExt, 
    ULONG ulFieldOffset,
    DCamRegArea * pFeature,
    HANDLE hKeySettings,
    PWCHAR pwszPropertyName,
    ULONG ulPropertyNameLen,
    DCamRegArea * pPropertySettings,
    PWCHAR pwszPropertyNameDef,
    ULONG ulPropertyNameDefLen,
    LONG * plValueDef
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ulLength;
    DCamRegArea RegDefault;


    // Reset settings.
    pFeature->AsULONG = 0;
    pPropertySettings->AsULONG = 0;

    // Read feature of this property
    Status = DCamReadRegister(pIrb, pDevExt, ulFieldOffset-QUERY_ADDR_OFFSET, &(pFeature->AsULONG));
    if(NT_SUCCESS(Status)) {
        pFeature->AsULONG = bswap(pFeature->AsULONG);
        if(pFeature->Feature.PresenceInq == 0) {
            ERROR_LOG(("\'%S not supported; Reset property settings\n", pwszPropertyName));
            return FALSE;
        }
    } else {
        ERROR_LOG(("\'ST:%x reading register\n", Status));
        return FALSE;
    }

    // Get persisted settings saved in the registry; (if it not defined, it is initialize to 0).
    ulLength = sizeof(LONG);
    Status = GetRegistryKeyValue(
        hKeySettings, 
        pwszPropertyName, 
        ulPropertyNameLen, 
        (PVOID) pPropertySettings,
        &ulLength
        );

    if(NT_SUCCESS(Status)) { 
        // Detect if AutoMode was mistakenly set by the registry.
        if(pPropertySettings->Brightness.AutoMode == 1 && pFeature->Feature.AutoMode == 0) {
            ERROR_LOG(("\'Detect %s AutoMode mistakenly set\n", pwszPropertyName));
            pPropertySettings->Brightness.AutoMode = 0;
        }
        // Detect out of range and set it to mid range.
        if(pPropertySettings->Brightness.Value < pFeature->Feature.MIN_Value || 
           pFeature->Feature.MAX_Value < pPropertySettings->Brightness.Value) {
            ERROR_LOG(("\'Detect %S out of range %d not within (%d,%d)\n", 
                pwszPropertyName,
                pPropertySettings->Brightness.Value,
                pFeature->Feature.MIN_Value, 
                pFeature->Feature.MAX_Value));
            pPropertySettings->Brightness.Value = (pFeature->Feature.MIN_Value + pFeature->Feature.MAX_Value)/2;
        }

        // Query default value        
        ulLength = sizeof(LONG);
        RegDefault.AsULONG = 0;
        *plValueDef = 0;
        Status = GetRegistryKeyValue(
            hKeySettings, 
            pwszPropertyNameDef,
            ulPropertyNameDefLen,
            (PVOID) &RegDefault,
            &ulLength
            );

        if(NT_SUCCESS(Status)) { 
            // Make sure that the default is within the range
            if(RegDefault.Brightness.Value < pFeature->Feature.MIN_Value || 
               pFeature->Feature.MAX_Value < RegDefault.Brightness.Value) {
                ERROR_LOG(("\'%S %d out of range (%d, %d), set to midrange.\n", 
                    pwszPropertyNameDef,
                    RegDefault.Brightness.Value, 
                    pFeature->Feature.MIN_Value, 
                    pFeature->Feature.MAX_Value));
                *plValueDef = (LONG) (pFeature->Feature.MIN_Value + pFeature->Feature.MAX_Value)/2;
            } else {
                *plValueDef = (LONG) RegDefault.Brightness.Value;
            }
        } else {
            ERROR_LOG(("\'Read Registry failed! ST:%x; %S; Offset:%d\n", Status, pwszPropertyNameDef, ulFieldOffset));
            *plValueDef = (LONG) (pFeature->Feature.MIN_Value + pFeature->Feature.MAX_Value)/2;
            // Set default so return success too.
            Status = STATUS_SUCCESS;
        }

    } else {
        // If registry key is not in the registry key, we will initialize it to 
        // always use the auto mode, and its value (and the default) in midrange.
        ERROR_LOG(("\'Read Registry failed! ST:%x; %S; Offset:%d\n", Status, pwszPropertyName, ulFieldOffset));
        pPropertySettings->Brightness.AutoMode = pFeature->Feature.AutoMode;
        pPropertySettings->Brightness.Value = (pFeature->Feature.MIN_Value + pFeature->Feature.MAX_Value)/2;
        *plValueDef = (LONG) (pFeature->Feature.MIN_Value + pFeature->Feature.MAX_Value)/2;
        // Set default so return success too.
        Status = STATUS_SUCCESS;
    }

#if DBG
    // Print out a summary of this property setting, include:
    // Features, current setting, and persisted values.
    DCamReadRegister(pIrb, pDevExt, ulFieldOffset, &(pDevExt->RegArea.AsULONG));
    pDevExt->RegArea.AsULONG = bswap(pDevExt->RegArea.AsULONG);

    DbgMsg1(("\'***** St:%x; %S (offset:%d)\n", Status, pwszPropertyName, ulFieldOffset));
    DbgMsg1(("\'Feature: %x; Pres:%d; OnePush:%d; ReadOut:%d; OnOff;%d; (A:%d; M:%d); (%d..%d)\n",
        pFeature->AsULONG,
        pFeature->Feature.PresenceInq,
        pFeature->Feature.OnePush,
        pFeature->Feature.ReadOut_Inq,
        pFeature->Feature.OnOff,
        pFeature->Feature.AutoMode,
        pFeature->Feature.ManualMode,
        pFeature->Feature.MIN_Value,
        pFeature->Feature.MAX_Value
        ));
    DbgMsg1(("\'Setting: %.8x; Pres:%d; OnePush:%d;            OnOff;%d; Auto:%d;     (%d;%d)\n",
        pDevExt->RegArea.AsULONG,
        pDevExt->RegArea.WhiteBalance.PresenceInq,
        pDevExt->RegArea.WhiteBalance.OnePush,
        pDevExt->RegArea.WhiteBalance.OnOff,
        pDevExt->RegArea.WhiteBalance.AutoMode,
        pDevExt->RegArea.WhiteBalance.UValue,
        pDevExt->RegArea.WhiteBalance.VValue
        ));
    DbgMsg1(("\'Registry:%.8x; Pres:%d; OnePush:%d;            OnOff;%d; Auto:%d;     (%d;%d)\n\n",
        pPropertySettings->AsULONG,
        pPropertySettings->WhiteBalance.PresenceInq,
        pPropertySettings->WhiteBalance.OnePush,
        pPropertySettings->WhiteBalance.OnOff,
        pPropertySettings->WhiteBalance.AutoMode,
        pPropertySettings->WhiteBalance.UValue,
        pPropertySettings->WhiteBalance.VValue
        ));
#endif

    return NT_SUCCESS(Status);
}



BOOL
DCamGetPropertyValuesFromRegistry(
    PDCAM_EXTENSION pDevExt
    )
{
    NTSTATUS Status;
    HANDLE hPDOKey, hKeySettings;
    PIRB pIrb;
    ULONG ulLength;

    DbgMsg2(("\'GetPropertyValuesFromRegistry: pDevExt=%x; pDevExt->BusDeviceObject=%x\n", pDevExt, pDevExt->BusDeviceObject));

    pIrb = ExAllocatePoolWithTag(NonPagedPool, sizeof(IRB), 'macd');
    if(!pIrb)
        return FALSE;
   

    //
    // Registry key: 
    //   Windows 2000:
    //   HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\
    //   {6BDD1FC6-810F-11D0-BEC7-08002BE2092F\000x
    //
    // Win98:
    //    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Class\Image\000x
    // 
    Status = 
        IoOpenDeviceRegistryKey(
            pDevExt->PhysicalDeviceObject, 
            PLUGPLAY_REGKEY_DRIVER,
            STANDARD_RIGHTS_READ, 
            &hPDOKey);

    // Can fail only if PDO might be deleted due to device removal.        
    ASSERT(!pDevExt->bDevRemoved && Status == STATUS_SUCCESS);    

    //
    // loop through our table of strings,
    // reading the registry for each.
    //
    if(!NT_SUCCESS(Status)) {    
        ERROR_LOG(("\'GetPropertyValuesFromRegistry: IoOpenDeviceRegistryKey failed with Status=%x\n", Status));
        ExFreePool(pIrb); pIrb = NULL; 
        return FALSE;
    }

    //
    // Create or open the settings key
    //
    Status =         
        CreateRegistrySubKey(
            hPDOKey,
            KEY_ALL_ACCESS,
            wszSettings,
            &hKeySettings
            );

    if(!NT_SUCCESS(Status)) {    
        ERROR_LOG(("\'GetPropertyValuesFromRegistry: CreateRegistrySubKey failed with Status=%x\n", Status));       
        ZwClose(hPDOKey);
        return FALSE;
    }

    // Get persisted settings saved in the registry; (if it not defined, it is initialize to 0).
    
    //
    // Read from registry to find out what compression formats are supported 
    // by the decoder installed on this system.  This registry key can be altered
    // if IHV/ISV add additional decoder.  Currently, Microsft's MSYUV supports 
    // only UYVY format.
    //
    pDevExt->DecoderDCamVModeInq0.AsULONG = 0;
    ulLength = sizeof(LONG);
    Status = GetRegistryKeyValue(
        hKeySettings, 
        wszVModeInq0, 
        sizeof(wszVModeInq0), 
        (PVOID) &pDevExt->DecoderDCamVModeInq0,
        &ulLength
        );

    if(NT_SUCCESS(Status)) { 
        pDevExt->DecoderDCamVModeInq0.AsULONG = bswap(pDevExt->DecoderDCamVModeInq0.AsULONG);
        DbgMsg1(("\'Modes supported by the decoder: %x\n  [0]:%d\n  [1]:%d\n  [2]:%d\n  [3]:%d\n  [4]:%d\n  [5]:%d\n",
            pDevExt->DecoderDCamVModeInq0.AsULONG,
            pDevExt->DecoderDCamVModeInq0.VMode.Mode0,
            pDevExt->DecoderDCamVModeInq0.VMode.Mode1,
            pDevExt->DecoderDCamVModeInq0.VMode.Mode2,
            pDevExt->DecoderDCamVModeInq0.VMode.Mode3,
            pDevExt->DecoderDCamVModeInq0.VMode.Mode4,
            pDevExt->DecoderDCamVModeInq0.VMode.Mode5
            ));
    } else {
        ERROR_LOG(("\'Failed to read VModeInq0 registery: %x\n", Status));
    }
    
    // MSYUV supports these modes; always turn them on.
    pDevExt->DecoderDCamVModeInq0.VMode.Mode1 = 1;  // MSYUV.dll:(UYVY:320x480)
    pDevExt->DecoderDCamVModeInq0.VMode.Mode3 = 1;  // MSYUV.dll:(UYVY:640x480)
#ifdef SUPPORT_RGB24
    pDevExt->DecoderDCamVModeInq0.VMode.Mode4 = 1;  // MSYUV.dll:(RGB24:640x480)
#endif
    

#if DBG
    pDevExt->DevFeature1.AsULONG = 0;
    Status = DCamReadRegister(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, FeaturePresent1), &pDevExt->DevFeature1.AsULONG);
    if(NT_SUCCESS(Status)) { 
        pDevExt->DevFeature1.AsULONG = bswap(pDevExt->DevFeature1.AsULONG);
        DbgMsg1(("\'Features1: %x:\n  Brightness:%d;\n  Exposure:%d\n  Sharpness:%d\n  WhiteBalance:%d\n  Hue:%d;\n  Saturation:%d;\n  Gamma:%d\n  Shutter:%d\n  Gain:%d\n  Iris:%d\n  Focus:%d\n",
            pDevExt->DevFeature1.AsULONG,
            pDevExt->DevFeature1.CameraCap1.Brightness,
            pDevExt->DevFeature1.CameraCap1.Exposure,
            pDevExt->DevFeature1.CameraCap1.Sharpness,
            pDevExt->DevFeature1.CameraCap1.White_Balance,
            pDevExt->DevFeature1.CameraCap1.Hue,
            pDevExt->DevFeature1.CameraCap1.Saturation,
            pDevExt->DevFeature1.CameraCap1.Gamma,
            pDevExt->DevFeature1.CameraCap1.Shutter,
            pDevExt->DevFeature1.CameraCap1.Gain,
            pDevExt->DevFeature1.CameraCap1.Iris,
            pDevExt->DevFeature1.CameraCap1.Focus
            ));
    } else {
        ERROR_LOG(("\'Failed to read Feature1 register: %x\n", Status));
    }

    pDevExt->DevFeature2.AsULONG = 0;
    Status = DCamReadRegister(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, FeaturePresent2), &pDevExt->DevFeature1.AsULONG);
    if(NT_SUCCESS(Status)) { 
        pDevExt->DevFeature2.AsULONG = bswap(pDevExt->DevFeature2.AsULONG);
        DbgMsg1(("\'Features2: %x\n  Zoom:%d\n  Pan:%d\n  Tile:%d\n",
            pDevExt->DevFeature2.AsULONG,
            pDevExt->DevFeature2.CameraCap2.Zoom,
            pDevExt->DevFeature2.CameraCap2.Pan,
            pDevExt->DevFeature1.CameraCap2.Tile
            ));
    } else {
        ERROR_LOG(("\'Failed to read Feature2 register: %x\n", Status));
    }
#endif

    // Brightness
    if(DCamQueryPropertyFeaturesAndSettings(
        pIrb,
        pDevExt,
        FIELDOFFSET(CAMERA_REGISTER_MAP, Brightness),
        &pDevExt->DevProperty[ENUM_BRIGHTNESS].Feature,
        hKeySettings, 
        wszBrightness, 
        sizeof(wszBrightness), 
        &pDevExt->DevProperty[ENUM_BRIGHTNESS].StatusNControl,
        wszBrightnessDef, 
        sizeof(wszBrightnessDef), 
        &pDevExt->DevProperty[ENUM_BRIGHTNESS].DefaultValue
        )) {
        pDevExt->DevProperty[ENUM_BRIGHTNESS].RangeNStep.Bounds.SignedMinimum = pDevExt->DevProperty[ENUM_BRIGHTNESS].Feature.Feature.MIN_Value;
        pDevExt->DevProperty[ENUM_BRIGHTNESS].RangeNStep.Bounds.SignedMaximum = pDevExt->DevProperty[ENUM_BRIGHTNESS].Feature.Feature.MAX_Value;
        pDevExt->DevPropDefine[ENUM_BRIGHTNESS].Range.Members   = (VOID*) &pDevExt->DevProperty[ENUM_BRIGHTNESS].RangeNStep;
        pDevExt->DevPropDefine[ENUM_BRIGHTNESS].Default.Members = (VOID*) &pDevExt->DevProperty[ENUM_BRIGHTNESS].DefaultValue;
    } else {
        pDevExt->VideoProcAmpItems[ENUM_BRIGHTNESS].GetSupported = FALSE;
        pDevExt->VideoProcAmpItems[ENUM_BRIGHTNESS].SetSupported = FALSE;
    }
      // Saturation
    if(DCamQueryPropertyFeaturesAndSettings(
        pIrb,
        pDevExt,
        FIELDOFFSET(CAMERA_REGISTER_MAP, Saturation),
        &pDevExt->DevProperty[ENUM_SATURATION].Feature,
        hKeySettings, 
        wszSaturation, 
        sizeof(wszSaturation), 
        &pDevExt->DevProperty[ENUM_SATURATION].StatusNControl,
        wszSaturationDef, 
        sizeof(wszSaturationDef),
        &pDevExt->DevProperty[ENUM_SATURATION].DefaultValue
        )) {
        pDevExt->DevProperty[ENUM_SATURATION].RangeNStep.Bounds.SignedMinimum = pDevExt->DevProperty[ENUM_SATURATION].Feature.Feature.MIN_Value;
        pDevExt->DevProperty[ENUM_SATURATION].RangeNStep.Bounds.SignedMaximum = pDevExt->DevProperty[ENUM_SATURATION].Feature.Feature.MAX_Value;
        pDevExt->DevPropDefine[ENUM_SATURATION].Range.Members   = (VOID*) &pDevExt->DevProperty[ENUM_SATURATION].RangeNStep;
        pDevExt->DevPropDefine[ENUM_SATURATION].Default.Members = (VOID*) &pDevExt->DevProperty[ENUM_SATURATION].DefaultValue;
    } else {
        pDevExt->VideoProcAmpItems[ENUM_SATURATION].GetSupported = FALSE;
        pDevExt->VideoProcAmpItems[ENUM_SATURATION].SetSupported = FALSE;
    }
      // Hue
    if(DCamQueryPropertyFeaturesAndSettings(
        pIrb,
        pDevExt,
        FIELDOFFSET(CAMERA_REGISTER_MAP, Hue),
        &pDevExt->DevProperty[ENUM_HUE].Feature,
        hKeySettings, 
        wszHue, 
        sizeof(wszHue), 
        &pDevExt->DevProperty[ENUM_HUE].StatusNControl,
        wszHueDef, 
        sizeof(wszHueDef),
        &pDevExt->DevProperty[ENUM_HUE].DefaultValue
        )) {
        pDevExt->DevProperty[ENUM_HUE].RangeNStep.Bounds.SignedMinimum = pDevExt->DevProperty[ENUM_HUE].Feature.Feature.MIN_Value;
        pDevExt->DevProperty[ENUM_HUE].RangeNStep.Bounds.SignedMaximum = pDevExt->DevProperty[ENUM_HUE].Feature.Feature.MAX_Value;
        pDevExt->DevPropDefine[ENUM_HUE].Range.Members   = (VOID*) &pDevExt->DevProperty[ENUM_HUE].RangeNStep;
        pDevExt->DevPropDefine[ENUM_HUE].Default.Members = (VOID*) &pDevExt->DevProperty[ENUM_HUE].DefaultValue;
    } else {
        pDevExt->VideoProcAmpItems[ENUM_HUE].GetSupported = FALSE;
        pDevExt->VideoProcAmpItems[ENUM_HUE].SetSupported = FALSE;
    }
       // Sharpness
    if(DCamQueryPropertyFeaturesAndSettings(
        pIrb,
        pDevExt,
        FIELDOFFSET(CAMERA_REGISTER_MAP, Sharpness),
        &pDevExt->DevProperty[ENUM_SHARPNESS].Feature,
        hKeySettings, 
        wszSharpness, 
        sizeof(wszSharpness), 
        &pDevExt->DevProperty[ENUM_SHARPNESS].StatusNControl,
        wszSharpnessDef, 
        sizeof(wszSharpnessDef),
        &pDevExt->DevProperty[ENUM_SHARPNESS].DefaultValue
        )) {
        pDevExt->DevProperty[ENUM_SHARPNESS].RangeNStep.Bounds.SignedMinimum = pDevExt->DevProperty[ENUM_SHARPNESS].Feature.Feature.MIN_Value;
        pDevExt->DevProperty[ENUM_SHARPNESS].RangeNStep.Bounds.SignedMaximum = pDevExt->DevProperty[ENUM_SHARPNESS].Feature.Feature.MAX_Value;
        pDevExt->DevPropDefine[ENUM_SHARPNESS].Range.Members   = (VOID*) &pDevExt->DevProperty[ENUM_SHARPNESS].RangeNStep;
        pDevExt->DevPropDefine[ENUM_SHARPNESS].Default.Members = (VOID*) &pDevExt->DevProperty[ENUM_SHARPNESS].DefaultValue;
    } else {
        pDevExt->VideoProcAmpItems[ENUM_SHARPNESS].GetSupported = FALSE;
        pDevExt->VideoProcAmpItems[ENUM_SHARPNESS].SetSupported = FALSE;
    }
     // WhiteBalance
    if(DCamQueryPropertyFeaturesAndSettings(
        pIrb,
        pDevExt,
        FIELDOFFSET(CAMERA_REGISTER_MAP, WhiteBalance),
        &pDevExt->DevProperty[ENUM_WHITEBALANCE].Feature,
        hKeySettings, 
        wszWhiteBalance, 
        sizeof(wszWhiteBalance), 
        &pDevExt->DevProperty[ENUM_WHITEBALANCE].StatusNControl,
        wszWhiteBalanceDef, 
        sizeof(wszWhiteBalanceDef),
        &pDevExt->DevProperty[ENUM_WHITEBALANCE].DefaultValue
        )) {
        pDevExt->DevProperty[ENUM_WHITEBALANCE].RangeNStep.Bounds.SignedMinimum = pDevExt->DevProperty[ENUM_WHITEBALANCE].Feature.Feature.MIN_Value;
        pDevExt->DevProperty[ENUM_WHITEBALANCE].RangeNStep.Bounds.SignedMaximum = pDevExt->DevProperty[ENUM_WHITEBALANCE].Feature.Feature.MAX_Value;
        pDevExt->DevPropDefine[ENUM_WHITEBALANCE].Range.Members   = (VOID*) &pDevExt->DevProperty[ENUM_WHITEBALANCE].RangeNStep;
        pDevExt->DevPropDefine[ENUM_WHITEBALANCE].Default.Members = (VOID*) &pDevExt->DevProperty[ENUM_WHITEBALANCE].DefaultValue;
    } else {
        pDevExt->VideoProcAmpItems[ENUM_WHITEBALANCE].GetSupported = FALSE;
        pDevExt->VideoProcAmpItems[ENUM_WHITEBALANCE].SetSupported = FALSE;
    }
     // Zoom
    if(DCamQueryPropertyFeaturesAndSettings(
        pIrb,
        pDevExt,
        FIELDOFFSET(CAMERA_REGISTER_MAP, Zoom),
        &pDevExt->DevProperty[ENUM_ZOOM].Feature,
        hKeySettings, 
        wszZoom, 
        sizeof(wszZoom), 
        &pDevExt->DevProperty[ENUM_ZOOM].StatusNControl,
        wszZoomDef, 
        sizeof(wszZoomDef),
        &pDevExt->DevProperty[ENUM_ZOOM].DefaultValue
        )) {
        pDevExt->DevProperty[ENUM_ZOOM].RangeNStep.Bounds.SignedMinimum = pDevExt->DevProperty[ENUM_ZOOM].Feature.Feature.MIN_Value;
        pDevExt->DevProperty[ENUM_ZOOM].RangeNStep.Bounds.SignedMaximum = pDevExt->DevProperty[ENUM_ZOOM].Feature.Feature.MAX_Value;
        pDevExt->DevPropDefine[ENUM_ZOOM].Range.Members   = (VOID*) &pDevExt->DevProperty[ENUM_ZOOM].RangeNStep;
        pDevExt->DevPropDefine[ENUM_ZOOM].Default.Members = (VOID*) &pDevExt->DevProperty[ENUM_ZOOM].DefaultValue;
    } else {
        pDevExt->VideoProcAmpItems[ENUM_ZOOM].GetSupported = FALSE;
        pDevExt->VideoProcAmpItems[ENUM_ZOOM].SetSupported = FALSE;
    }
      // Focus
    if(DCamQueryPropertyFeaturesAndSettings(
        pIrb,
        pDevExt,
        FIELDOFFSET(CAMERA_REGISTER_MAP, Focus),
        &pDevExt->DevProperty[ENUM_FOCUS].Feature,
        hKeySettings, 
        wszFocus, 
        sizeof(wszFocus), 
        &pDevExt->DevProperty[ENUM_FOCUS].StatusNControl,
        wszFocusDef, 
        sizeof(wszFocusDef),
        &pDevExt->DevProperty[ENUM_FOCUS].DefaultValue
        )) {
        pDevExt->DevProperty[ENUM_FOCUS].RangeNStep.Bounds.SignedMinimum = pDevExt->DevProperty[ENUM_FOCUS].Feature.Feature.MIN_Value;
        pDevExt->DevProperty[ENUM_FOCUS].RangeNStep.Bounds.SignedMaximum = pDevExt->DevProperty[ENUM_FOCUS].Feature.Feature.MAX_Value;
        pDevExt->DevPropDefine[ENUM_FOCUS].Range.Members   = (VOID*) &pDevExt->DevProperty[ENUM_FOCUS].RangeNStep;
        pDevExt->DevPropDefine[ENUM_FOCUS].Default.Members = (VOID*) &pDevExt->DevProperty[ENUM_FOCUS].DefaultValue;
    } else {
        pDevExt->VideoProcAmpItems[ENUM_FOCUS].GetSupported = FALSE;
        pDevExt->VideoProcAmpItems[ENUM_FOCUS].SetSupported = FALSE;
    }


    ZwClose(hKeySettings);
    ZwClose(hPDOKey);

    ExFreePool(pIrb); pIrb = NULL; 

    return TRUE;

}


BOOL
DCamSetPropertyValuesToRegistry( 
    PDCAM_EXTENSION pDevExt
    )
{
    // Set the default to :
    //  HLM\Software\DeviceExtension->pchVendorName\1394DCam

    NTSTATUS Status;
    HANDLE hPDOKey, hKeySettings;

    DbgMsg2(("\'SetPropertyValuesToRegistry: pDevExt=%x; pDevExt->BusDeviceObject=%x\n", pDevExt, pDevExt->BusDeviceObject));


    //
    // Registry key: 
    //   HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\
    //   {6BDD1FC6-810F-11D0-BEC7-08002BE2092F\000x
    //
    Status = 
        IoOpenDeviceRegistryKey(
            pDevExt->PhysicalDeviceObject, 
            PLUGPLAY_REGKEY_DRIVER,
            STANDARD_RIGHTS_WRITE, 
            &hPDOKey);

    // PDO might be deleted when it was removed.    
    if(! pDevExt->bDevRemoved) {
        ASSERT(Status == STATUS_SUCCESS);
    }

    //
    // reading the feature and registry setting for each property
    //
    if(NT_SUCCESS(Status)) {

        // Create or open the settings key
        Status =         
            CreateRegistrySubKey(
                hPDOKey,
                KEY_ALL_ACCESS,
                wszSettings,
                &hKeySettings
                );

        if(NT_SUCCESS(Status)) {

            // Brightness
            Status = SetRegistryKeyValue(
                hKeySettings,
                wszBrightness,
                pDevExt->DevProperty[ENUM_BRIGHTNESS].StatusNControl.AsULONG);
            DbgMsg2(("\'SetPropertyValuesToRegistry: Status %x, Brightness %d\n", Status, pDevExt->DevProperty[ENUM_BRIGHTNESS].StatusNControl.AsULONG));

            // Hue
            Status = SetRegistryKeyValue(
                hKeySettings,
                wszHue,
                pDevExt->DevProperty[ENUM_HUE].StatusNControl.AsULONG);
            DbgMsg2(("\'SetPropertyValuesToRegistry: Status %x, Hue %d\n", Status, pDevExt->DevProperty[ENUM_HUE].StatusNControl.AsULONG));

            // Saturation
            Status = SetRegistryKeyValue(
                hKeySettings,
                wszSaturation,
                pDevExt->DevProperty[ENUM_SATURATION].StatusNControl.AsULONG);
            DbgMsg2(("\'SetPropertyValuesToRegistry: Status %x, Saturation %d\n", Status, pDevExt->DevProperty[ENUM_SATURATION].StatusNControl.AsULONG));

            // Sharpness
            Status = SetRegistryKeyValue(
                hKeySettings,
                wszSharpness,
                pDevExt->DevProperty[ENUM_SHARPNESS].StatusNControl.AsULONG);
            DbgMsg2(("\'SetPropertyValuesToRegistry: Status %x, Sharpness %d\n", Status, pDevExt->DevProperty[ENUM_SHARPNESS].StatusNControl.AsULONG));

            // WhiteBalance
            Status = SetRegistryKeyValue(
                hKeySettings,
                wszWhiteBalance,
                pDevExt->DevProperty[ENUM_WHITEBALANCE].StatusNControl.AsULONG);
            DbgMsg2(("\'SetPropertyValuesToRegistry: Status %x, WhiteBalance %d\n", Status, pDevExt->DevProperty[ENUM_WHITEBALANCE].StatusNControl.AsULONG));

            // Zoom
            Status = SetRegistryKeyValue(
                hKeySettings,
                wszZoom,
                pDevExt->DevProperty[ENUM_ZOOM].StatusNControl.AsULONG);
            DbgMsg2(("\'SetPropertyValuesToRegistry: Status %x, Zoom %d\n", Status, pDevExt->DevProperty[ENUM_ZOOM].StatusNControl.AsULONG));

            // Focus
            Status = SetRegistryKeyValue(
                hKeySettings,
                wszFocus,
                pDevExt->DevProperty[ENUM_FOCUS].StatusNControl.AsULONG);
            DbgMsg2(("\'SetPropertyValuesToRegistry: Status %x, Focus %d\n", Status, pDevExt->DevProperty[ENUM_FOCUS].StatusNControl.AsULONG));

            ZwClose(hKeySettings);
            ZwClose(hPDOKey);

            return TRUE;

        } else {

            ERROR_LOG(("\'SetPropertyValuesToRegistry: CreateRegistrySubKey failed with Status=%x\n", Status));

        }

        ZwClose(hPDOKey);

    } else {

        DbgMsg2(("\'SetPropertyValuesToRegistry: IoOpenDeviceRegistryKey failed with Status=%x\n", Status));

    }

    return FALSE;
}


VOID
SetCurrentDevicePropertyValues(
    PDCAM_EXTENSION pDevExt,
    PIRB pIrb
    )
{
    ULONG ulFlags;

    // Set to the last saved values or the defaults

    // VideoProcAmp
    ulFlags = pDevExt->DevProperty[ENUM_BRIGHTNESS].StatusNControl.Brightness.AutoMode ? KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO : KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
    DCamSetProperty(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Brightness),  ulFlags, pDevExt->DevProperty[ENUM_BRIGHTNESS].StatusNControl.Brightness.Value, &pDevExt->DevProperty[ENUM_BRIGHTNESS].Feature, &pDevExt->DevProperty[ENUM_BRIGHTNESS].StatusNControl);

    ulFlags = pDevExt->DevProperty[ENUM_HUE].StatusNControl.Brightness.AutoMode ? KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO : KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
    DCamSetProperty(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Hue),         ulFlags, pDevExt->DevProperty[ENUM_HUE].StatusNControl.Brightness.Value, &pDevExt->DevProperty[ENUM_HUE].Feature, &pDevExt->DevProperty[ENUM_HUE].StatusNControl);

    ulFlags = pDevExt->DevProperty[ENUM_SATURATION].StatusNControl.Brightness.AutoMode ? KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO : KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
    DCamSetProperty(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Saturation),  ulFlags, pDevExt->DevProperty[ENUM_SATURATION].StatusNControl.Brightness.Value, &pDevExt->DevProperty[ENUM_SATURATION].Feature, &pDevExt->DevProperty[ENUM_SATURATION].StatusNControl);  

    ulFlags = pDevExt->DevProperty[ENUM_SHARPNESS].StatusNControl.Brightness.AutoMode ? KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO : KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
    DCamSetProperty(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Sharpness),   ulFlags, pDevExt->DevProperty[ENUM_SHARPNESS].StatusNControl.Brightness.Value, &pDevExt->DevProperty[ENUM_SHARPNESS].Feature, &pDevExt->DevProperty[ENUM_SHARPNESS].StatusNControl);

    ulFlags = pDevExt->DevProperty[ENUM_WHITEBALANCE].StatusNControl.Brightness.AutoMode ? KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO : KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
    DCamSetProperty(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, WhiteBalance),ulFlags, pDevExt->DevProperty[ENUM_WHITEBALANCE].StatusNControl.WhiteBalance.UValue, &pDevExt->DevProperty[ENUM_WHITEBALANCE].Feature, &pDevExt->DevProperty[ENUM_WHITEBALANCE].StatusNControl);

    // CameraControl
    ulFlags = pDevExt->DevProperty[ENUM_ZOOM].StatusNControl.Brightness.AutoMode ? KSPROPERTY_CAMERACONTROL_FLAGS_AUTO : KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL;
    DCamSetProperty(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Zoom),        ulFlags, pDevExt->DevProperty[ENUM_ZOOM].StatusNControl.Brightness.Value, &pDevExt->DevProperty[ENUM_ZOOM].Feature, &pDevExt->DevProperty[ENUM_ZOOM].StatusNControl);

    ulFlags = pDevExt->DevProperty[ENUM_FOCUS].StatusNControl.Brightness.AutoMode ? KSPROPERTY_CAMERACONTROL_FLAGS_AUTO : KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL;
    DCamSetProperty(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, Focus),       ulFlags, pDevExt->DevProperty[ENUM_FOCUS].StatusNControl.Brightness.Value, &pDevExt->DevProperty[ENUM_FOCUS].Feature, &pDevExt->DevProperty[ENUM_FOCUS].StatusNControl); 
}


BOOL 
DCamPrepareDevProperties(
    PDCAM_EXTENSION pDevExt
    )
/*
    Contruct the property table and initialize them to the default value.
*/
{
    // Initialize property settings (part of the Device Extension)

    // Property Sets: VideoProcAmp and CameraControl sets
    pDevExt->ulPropSetSupported = NUMBER_OF_ADAPTER_PROPERTY_SETS;

    RtlCopyMemory(&pDevExt->VideoProcAmpSet, AdapterPropertyTable, sizeof(KSPROPERTY_SET) * NUMBER_OF_ADAPTER_PROPERTY_SETS);
    pDevExt->VideoProcAmpSet.PropertyItem  = &pDevExt->VideoProcAmpItems[0];
    pDevExt->CameraControlSet.PropertyItem = &pDevExt->CameraControlItems[0];

    // Property Items, VideoProcAmp and CameraControl Items
    RtlCopyMemory(&pDevExt->VideoProcAmpItems,  VideoProcAmpProperties,  sizeof(KSPROPERTY_ITEM) * NUM_VIDEOPROCAMP_ITEMS);
    RtlCopyMemory(&pDevExt->CameraControlItems, CameraControlProperties, sizeof(KSPROPERTY_ITEM) * NUM_CAMERACONTROL_ITEMS);

    // Property values and it member lists (range and default)
    pDevExt->VideoProcAmpItems[ENUM_BRIGHTNESS].Values = &pDevExt->DevPropDefine[ENUM_BRIGHTNESS].Value;
    pDevExt->VideoProcAmpItems[ENUM_SHARPNESS].Values  = &pDevExt->DevPropDefine[ENUM_SHARPNESS].Value;
    pDevExt->VideoProcAmpItems[ENUM_HUE].Values        = &pDevExt->DevPropDefine[ENUM_HUE].Value;
    pDevExt->VideoProcAmpItems[ENUM_SATURATION].Values = &pDevExt->DevPropDefine[ENUM_SATURATION].Value;
    pDevExt->VideoProcAmpItems[ENUM_WHITEBALANCE].Values = &pDevExt->DevPropDefine[ENUM_WHITEBALANCE].Value;
    // 
    pDevExt->VideoProcAmpItems[ENUM_FOCUS].Values      = &pDevExt->DevPropDefine[ENUM_FOCUS].Value;
    pDevExt->VideoProcAmpItems[ENUM_ZOOM].Values       = &pDevExt->DevPropDefine[ENUM_ZOOM].Value;

    pDevExt->DevPropDefine[ENUM_BRIGHTNESS].Value    = BrightnessValues;
    pDevExt->DevPropDefine[ENUM_BRIGHTNESS].Value.MembersList = &pDevExt->DevPropDefine[ENUM_BRIGHTNESS].Range;
    pDevExt->DevPropDefine[ENUM_BRIGHTNESS].Range    = BrightnessMembersList[0];
    pDevExt->DevPropDefine[ENUM_BRIGHTNESS].Default  = BrightnessMembersList[1];
    pDevExt->DevProperty[ENUM_BRIGHTNESS].RangeNStep = BrightnessRangeAndStep[0];


    pDevExt->DevPropDefine[ENUM_SHARPNESS].Value    = SharpnessValues;
    pDevExt->DevPropDefine[ENUM_SHARPNESS].Value.MembersList = &pDevExt->DevPropDefine[ENUM_SHARPNESS].Range;
    pDevExt->DevPropDefine[ENUM_SHARPNESS].Range    = SharpnessMembersList[0];
    pDevExt->DevPropDefine[ENUM_SHARPNESS].Default  = SharpnessMembersList[1];
    pDevExt->DevProperty[ENUM_SHARPNESS].RangeNStep = SharpnessRangeAndStep[0];


    pDevExt->DevPropDefine[ENUM_HUE].Value    = HueValues;
    pDevExt->DevPropDefine[ENUM_HUE].Value.MembersList = &pDevExt->DevPropDefine[ENUM_HUE].Range;
    pDevExt->DevPropDefine[ENUM_HUE].Range    = HueMembersList[0];
    pDevExt->DevPropDefine[ENUM_HUE].Default  = HueMembersList[1];
    pDevExt->DevProperty[ENUM_HUE].RangeNStep = HueRangeAndStep[0];


    pDevExt->DevPropDefine[ENUM_SATURATION].Value    = SaturationValues;
    pDevExt->DevPropDefine[ENUM_SATURATION].Value.MembersList = &pDevExt->DevPropDefine[ENUM_SATURATION].Range;
    pDevExt->DevPropDefine[ENUM_SATURATION].Range    = SaturationMembersList[0];
    pDevExt->DevPropDefine[ENUM_SATURATION].Default  = SaturationMembersList[1];
    pDevExt->DevProperty[ENUM_SATURATION].RangeNStep = SaturationRangeAndStep[0];


    pDevExt->DevPropDefine[ENUM_WHITEBALANCE].Value    = WhiteBalanceValues;
    pDevExt->DevPropDefine[ENUM_WHITEBALANCE].Value.MembersList = &pDevExt->DevPropDefine[ENUM_WHITEBALANCE].Range;
    pDevExt->DevPropDefine[ENUM_WHITEBALANCE].Range    = WhiteBalanceMembersList[0];
    pDevExt->DevPropDefine[ENUM_WHITEBALANCE].Default  = WhiteBalanceMembersList[1];
    pDevExt->DevProperty[ENUM_WHITEBALANCE].RangeNStep = WhiteBalanceRangeAndStep[0];


    pDevExt->DevPropDefine[ENUM_FOCUS].Value    = FocusValues;
    pDevExt->DevPropDefine[ENUM_FOCUS].Value.MembersList = &pDevExt->DevPropDefine[ENUM_FOCUS].Range;
    pDevExt->DevPropDefine[ENUM_FOCUS].Range    = FocusMembersList[0];
    pDevExt->DevPropDefine[ENUM_FOCUS].Default  = FocusMembersList[1];
    pDevExt->DevProperty[ENUM_FOCUS].RangeNStep = FocusRangeAndStep[0];


    pDevExt->DevPropDefine[ENUM_ZOOM].Value    = ZoomValues;
    pDevExt->DevPropDefine[ENUM_ZOOM].Value.MembersList = &pDevExt->DevPropDefine[ENUM_ZOOM].Range;
    pDevExt->DevPropDefine[ENUM_ZOOM].Range    = ZoomMembersList[0];
    pDevExt->DevPropDefine[ENUM_ZOOM].Default  = ZoomMembersList[1];
    pDevExt->DevProperty[ENUM_ZOOM].RangeNStep = ZoomRangeAndStep[0];


    return STATUS_SUCCESS;
}



BOOL
DCamGetVideoMode(
    PDCAM_EXTENSION pDevExt,
    PIRB pIrb
    )
/*
    Query Video format and mode supported by the camera.
*/
{
    NTSTATUS Status;

    // First check if V_MODE_INQ (Format_0) is supported.
    pDevExt->DCamVFormatInq.AsULONG = 0;
    Status = DCamReadRegister(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, VFormat), &(pDevExt->DCamVFormatInq.AsULONG));
    if(NT_SUCCESS(Status)) {
        pDevExt->DCamVFormatInq.AsULONG = bswap(pDevExt->DCamVFormatInq.AsULONG);
        if(pDevExt->DCamVFormatInq.VFormat.Format0 == 1) {
            DbgMsg1(("\'V_FORMAT_INQ %x; Format:[0]:%d; [1]:%d; [2]:%d; [6]:%d; [7]:%d\n",           
                pDevExt->DCamVFormatInq.AsULONG, 
                pDevExt->DCamVFormatInq.VFormat.Format0,   
                pDevExt->DCamVFormatInq.VFormat.Format1,
                pDevExt->DCamVFormatInq.VFormat.Format2,
                pDevExt->DCamVFormatInq.VFormat.Format6,          
                pDevExt->DCamVFormatInq.VFormat.Format7            
                ));
            pDevExt->DCamVModeInq0.AsULONG = 0;
            Status = DCamReadRegister(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, VModeInq[0]), &(pDevExt->DCamVModeInq0.AsULONG));
            if(NT_SUCCESS(Status)) {
                pDevExt->DCamVModeInq0.AsULONG = bswap(pDevExt->DCamVModeInq0.AsULONG);
                DbgMsg1(("\'V_MODE_INQ[0] %x; Mode[]:\n  [0](160x120 YUV444):%d\n  [1](320x240 YUV422):%d\n  [2](640x480 YUV411):%d\n  [3](640x480 YUV422):%d\n  [4](640x480 RGB24):%d\n  [5](640x480 YMono):%d\n",           
                    pDevExt->DCamVModeInq0.AsULONG, 
                    pDevExt->DCamVModeInq0.VMode.Mode0,   
                    pDevExt->DCamVModeInq0.VMode.Mode1,
                    pDevExt->DCamVModeInq0.VMode.Mode2,
                    pDevExt->DCamVModeInq0.VMode.Mode3,
                    pDevExt->DCamVModeInq0.VMode.Mode4,
                    pDevExt->DCamVModeInq0.VMode.Mode5           
                    ));

            } else {
                ERROR_LOG(("\'Read V_MODE_INQ_0 failed:%x!\n", Status))
            }

        } else {
             ERROR_LOG(("\'V_MODE_INQ Format_0 not supported!\n"))
        }
    } else {
        ERROR_LOG(("\'Read V_MODE_INQ failed:%x!\n", Status));
    }

    return NT_SUCCESS(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\codec\tsbyuv\xlate.c ===
/*
 * Microsoft YUV Codec -yuv411 -> rgb conversion functions
 *
 * Copyright (c) Microsoft Corporation 1993
 * All Rights Reserved
 *
 */
/*
 * for TOSHIBA Pistachio yuv12 -> rgb conversion functions
 *
 * Programed by Y.Kasai 05/27/97
 *
 * supported type:
 *           YUV411 (for Bravado)
 *           YUV422 (for Spigot)
 *           YUV12  (for Pistachio)
 *           YUV9   (for Pistachio)
 */

#include <windows.h>
#include <windowsx.h>

#include "msyuv.h"

/*
 * This module provides translation from YUV into RGB. It translates
 * from 8-bit YUV 4:2:2 (as provided by the Spigot video capture driver)
 * or 7-bit YUV 4:1:1 (as provided by the Bravado driver) into 16-bit RGB555
 * or RGB565. All versions use a look-up table built using YUVToRGB555
 * or YUVToRGB565
 */



#define RANGE(x, lo, hi)        max(lo, min(hi, x))

/*
 * Convert a YUV colour into a 15-bit RGB colour.
 *
 * The input Y is in the range 16..235; the input U and V components
 * are in the range -128..+127. The conversion equations for this are
 * (according to CCIR 601):
 *
 *      R = Y + 1.371 V
 *      G = Y - 0.698 V - 0.336 U
 *      B = Y + 1.732 U
 *
 * To avoid floating point, we scale all values by 1024.
 *
 * The resulting RGB values are in the range 16..235: we truncate these to
 * 5 bits each. and return a WORD containing 5-bits each for R, G and B
 * with bit 15 set to 0.
 */
WORD
YUVToRGB555(int y, int u, int v)
{
    int ScaledY = RANGE(y, 16, 235) * 1024;
    int red, green, blue;

    red = RANGE((ScaledY + (1404 * v)) / 1024, 0, 255);
    green = RANGE( (ScaledY - (715 * v) - (344 * u)) / 1024, 0, 255);
    blue = RANGE( (ScaledY + (1774 * u)) / 1024, 0, 255);

    return (WORD) (((red & 0xf8) << 7) | ((green & 0xf8) << 2) | ((blue & 0xf8) >>3) );
}


// same as above but converts to RGB565 instead
WORD
YUVToRGB565(int y, int u, int v)
{
    int ScaledY = RANGE(y, 16, 235) * 1024;
    int red, green, blue;

    red = RANGE((ScaledY + (1404 * v)) / 1024, 0, 255);
    green = RANGE( (ScaledY - (715 * v) - (344 * u)) / 1024, 0, 255);
    blue = RANGE( (ScaledY + (1774 * u)) / 1024, 0, 255);

    return (WORD) (((red & 0xf8) << 8) | ((green & 0xfc) << 3) | ((blue & 0xf8) >>3) );
}


#ifdef  TOSHIBA
#ifdef  COLOR_MODIFY
/*
 * TOSHIBA Y.Kasai
 * for Pistachio.
 *
 * Convert a YUV colour into a 15-bit RGB colour.
 *
 * The input Y is in the range 0..255; the input U and V components
 * are in the same range 0..255. The conversion equations for this are
 * (according to CCIR 601):
 *
 *      R = 1.1644Y + 1.5976 V - 223.0089
 *      G = 1.1644Y - 0.8133 V - 0.3921 U + 135.6523
 *      B = 1.1644Y + 2.0184 U - 276.9814
 *
 * To avoid floating point, we scale all values by 1024.
 *
 *  1024R = 1192Y + 1635V - 228361
 *  1024G = 1192Y - 833V - 402U + 138908
 *  1024B = 1192Y + 2067U - 283629
 *
 */
BYTE
TosYVToR(int y, int v)
{
    int ScaledY = y * 1192;
    int red;

    red = RANGE((ScaledY + (1635 * v) -  228361) / 1024, 0, 255);

    return (BYTE) (red);
}


BYTE
TosYUToB(int y, int u)
{
    int ScaledY = y * 1192;
    int blue;

    blue = RANGE( (ScaledY + (2067 * u) - 283629) / 1024, 0, 255);

    return (BYTE) (blue);
}

#else //COLOR_MODIFY
/*
 * TOSHIBA Y.Kasai
 * for Pistachio.
 *
 * Convert a YUV colour into a 15-bit RGB colour.
 *
 * The input Y is in the range 0..255; the input U and V components
 * are in the same range 0..255. The conversion equations for this are
 * (according to CCIR 601):
 *
 *      R = 1.1644Y + 1.5976 V - 223.0089
 *      G = 1.1644Y - 0.8133 V - 0.3921 U + 135.6523
 *      B = 1.1644Y + 2.0184 U - 276.9814
 *
 * To avoid floating point, we scale all values by 1024.
 *
 *  1024R = 1192Y + 1635V - 228361
 *  1024G = 1192Y - 833V - 402U + 138908
 *  1024B = 1192Y + 2067U - 283629
 *
 * The resulting RGB values are in the range 0..255: we truncate these to
 * 5 bits each. and return a WORD containing 5-bits each for R, G and B
 * with bit 15 set to 0.
 */
WORD
TosYUVToRGB555(int y, int u, int v)
{
    int ScaledY = y * 1192;
    int red, green, blue;

    red = RANGE((ScaledY + (1635 * v) -  228361) / 1024, 0, 255);
    green = RANGE( (ScaledY - (833 * v) - (402 * u) + 138908) / 1024, 0, 255);
    blue = RANGE( (ScaledY + (2067 * u) - 283629) / 1024, 0, 255);

    return (WORD) (((red & 0xf8) << 7) | ((green & 0xf8) << 2) | ((blue & 0xf8) >>3) );
}


// same as above but converts to RGB565 instead
WORD
TosYUVToRGB565(int y, int u, int v)
{
    int ScaledY = y * 1192;
    int red, green, blue;

    red = RANGE((ScaledY + (1635 * v) -  228361) / 1024, 0, 255);
    green = RANGE( (ScaledY - (833 * v) - (402 * u) + 138908) / 1024, 0, 255);
    blue = RANGE( (ScaledY + (2067 * u) - 283629) / 1024, 0, 255);

    return (WORD) (((red & 0xf8) << 8) | ((green & 0xfc) << 3) | ((blue & 0xf8) >>3) );
}
#endif//COLOR_MODIFY
#endif//TOSHIBA



/* --- YUV 4:1:1 support ------------------------------------------ */




/*
 * the input data is in YUV411 format. There is one 7 bit Luma sample
 * per pixel, and 1 each 7-bit U and V sample averaged over 4 pixels,
 * in the following layout:
 *
 *              15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
 * Word 0       u6 u5 v6 v5             y6 y5 y4 y3 y2 y1 y0
 *
 * Word 1       u4 u3 v4 v3             y6 y5 y4 y3 y2 y1 y0
 *
 * Word 2       u2 u1 v2 v1             y6 y5 y4 y3 y2 y1 y0
 *
 * Word 3       u0    v0                y6 y5 y4 y3 y2 y1 y0
 *
 * The 7-bit y values are unsigned (0..127), whereas the 7-bit
 * u and V values are signed (-64..+63).
 *
 *
 * For RGB: we truncate the YUV into a 15-bit format and use a prepared
 *         lookup table to convert the 15-bit YUV into a 15- or 16-bit RGB value.
 *
 * The (64 kbyte) rgb555 lookup table is built by BuildYUVToRGB555.
 *
 */


/*
 * the YUV xlate tables use 5-bits per component with y in the ms bits, and
 * v in the ls bits. To convert from the above layout, look up the nibbles
 * containing the chroma bits in these tables and or together the result to
 * get a word with a 5-bit V component in bits 0..4, and a 5-bit
 * U component in bits 5..9. Note you only need three lookups since
 * we discard chroma bits 0 and 1.
 */
WORD ChromaBits65[] = {
    0x000, 0x008, 0x010, 0x018,
    0x100, 0x108, 0x110, 0x118,
    0x200, 0x208, 0x210, 0x218,
    0x300, 0x308, 0x310, 0x318
};

WORD ChromaBits43[] = {
    0x000, 0x002, 0x004, 0x006,
    0x040, 0x042, 0x044, 0x046,
    0x080, 0x082, 0x084, 0x086,
    0x0c0, 0x0c2, 0x0c4, 0x0c6
};

WORD ChromaBits2[] = {
    0x000, 0x000, 0x001, 0x001,
    0x000, 0x000, 0x001, 0x001,
    0x020, 0x020, 0x021, 0x021,
    0x020, 0x020, 0x021, 0x021
};







/*
 * build yuv411->RGB555 xlate table
 */
LPVOID BuildYUVToRGB555(PINSTINFO pinst)
{
    HGLOBAL hMem = NULL;
    LPVOID pXlate = NULL;

    if (pinst->pXlate != NULL) {
        return(pinst->pXlate);
    }

    /*
     * allocate a table big enough for 32k 2-byte entries
     */

    if ( ( hMem = GlobalAlloc(GPTR, 2 * 32 * 1024))
      && ( pXlate = GlobalLock( hMem ) ) )
    {
        WORD w;
        LPWORD pRGB555 = (LPWORD)pXlate;

        /*
         * build a 15-bit yuv lookup table by stepping through each entry,
         * converting the yuv index to rgb and storing at that index. The index
         * to this table is a 15-bit value with the y component in bits 14..10,
         * u in bits 9..5 and v in bits 4..0. Note that the y component is unsigned,
         * whereas the u and v components are signed.
         */
        for (w = 0; w < 32*1024; w++) {
            /*
             * the YUVtoRGB55 conversion function takes values 0..255 for y,
             * and -128..+127 for u and v. Pick out the relevant bits of the
             * index for this cell, and shift to get values in this range.
             * Remember the cast to ensure sign-extension of these (8-bit) values -
             * and don't assume that chars are signed (they're not on MIPS).
             */
            *pRGB555++ = YUVToRGB555(
                                (w &  0x7c00) >> 7,
                                (signed char) ((w & 0x3e0) >> 2),
                                (signed char) ((w & 0x1f) << 3)
                         );
        }
    }

    return(pXlate);
}

/*
 * build yuv411->RGB565 xlate table
 */
LPVOID BuildYUVToRGB565(PINSTINFO pinst)
{
    HGLOBAL hMem = 0;
    LPVOID pXlate = NULL;

    if (pinst->pXlate != NULL) {
        return(pinst->pXlate);
    }

    /*
     * allocate a table big enough for 32k 2-byte entries
     */
    if ( ( hMem = GlobalAlloc(GPTR, 2 * 32 * 1024))
      && ( pXlate = GlobalLock( hMem ) ) )
    {
        WORD w;
        LPWORD pRGB = (LPWORD)pXlate;

        /*
         * build a 15-bit yuv lookup table by stepping through each entry,
         * converting the yuv index to rgb and storing at that index. The index
         * to this table is a 15-bit value with the y component in bits 14..10,
         * u in bits 9..5 and v in bits 4..0. Note that the y component is unsigned,
         * whereas the u and v components are signed.
         */
        for (w = 0; w < 32*1024; w++) {
            /*
             * the YUVtoRGB conversion function takes values 0..255 for y,
             * and -128..+127 for u and v. Pick out the relevant bits of the
             * index for this cell, and shift to get values in this range.
             * Remember the cast to ensure sign-extension of these (8-bit) values -
             * and don't assume that chars are signed (they're not on MIPS).
             */
            *pRGB++ = YUVToRGB565(
                                (w &  0x7c00) >> 7,
                                (signed char) ((w & 0x3e0) >> 2),
                                (signed char) ((w & 0x1f) << 3)
                         );
        }
    }

    return(pXlate);

}




/*
 * translate one frame from yuv411 to 15/16 bit rgb.
 *
 * The YUV data is spread over 4 16-bit pixels in the format described
 * above. Pick out 4 pixels at a time, truncate them to 15-bit yuv,
 * lookup to translate to 15 or 16-bit rgb (depending on the lookup table
 * and write out.
 *
 * Flip vertically into correct dib format during conversion.
 */
VOID
YUV411ToRGB(
    PINSTINFO pinst,
    LPBITMAPINFOHEADER lpbiInput,
    LPVOID lpInput,
    LPBITMAPINFOHEADER lpbiOutput,
    LPVOID lpOutput
)
{
    int RowInc;
    int i, j;
    DWORD Luma01, Luma23;
    DWORD Chroma;
    int Height, Width;
    int WidthBytes;
    PWORD pXlate;
    PWORD pDst;
    PDWORD pSrc;


    Height = lpbiInput->biHeight;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*2;               // size of (input and output) line
    pXlate = pinst->pXlate;


    /*
     * adjust the source to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pSrc = (PDWORD) ( (PUCHAR) lpInput + ((Height - 1) * WidthBytes));
    pDst = (PWORD) lpOutput;

    /*
     * calculate the amount to adjust source by at the end of one line
     * of copying. At this point we are at the end of line N. We need
     * to move to the start of line N-1.
     */
    RowInc = (WidthBytes * 2) / sizeof(DWORD);

    /* loop copying each scanline */
    for (i = 0; i < Height; i++) {

        /* loop copying four pixels at a time */
        for (j = 0; j < Width; j += 4) {

            /*
             * get four pixels and convert to 15-bpp YUV
             */

            /* get luma for first 2 pixels + higher chroma bits */
            Luma01 = *pSrc++;


            /* pick out u,v components using lookup table.
             * u and v will be the bottom 10 bits of each pixel, so
             * convert to this layout
             */
            Chroma = ChromaBits65[(Luma01 >> 12) & 0xf] |
                        ChromaBits43[ (Luma01 >> 28) & 0xf ];

            /* next two pixels + lower chroma bits */
            Luma23 = *pSrc++;

            /* pickup u and v bits 2 - ignore bits 1, 0 since
             * we only use 5-bits per component for conversion
             */
            Chroma |= ChromaBits2[ ( Luma23 >> 12) & 0xf];

            /*
             * combine luma for pix 0 with common chroma bits to
             * get 15-bit yuv, then lookup to convert to
             * rgb and store.
             */
            *pDst++ = pXlate[ ((Luma01 & 0xf8) << 7) | Chroma];
            *pDst++ = pXlate[ ((Luma01 & 0xf80000) >> 9) | Chroma];
            *pDst++ = pXlate[ ((Luma23 & 0xf8) << 7) | Chroma];
            *pDst++ = pXlate[ ((Luma23 & 0xf80000) >> 9) | Chroma];

        } // loop per 4 pixels

        /* move source pointer back to next line */
        pSrc -= RowInc;
    } // loop per row
}


/* YUV 4:2:2 support ------------------------------------------ */

/*
 * The captured data is in YUV 4:2:2, 8-bits per sample.
 * The data is laid out in alternating Y-U-Y-V-Y-U-Y-V format. Thus
 * every DWORD contains two complete pixels, in the
 * form (msb..lsb) V..Y1..U..Y0
 * All 3 components (y, u and v) are all unsigned 8-bit values in the range
 * 16..235.
 *
 * We have to double scan lines for >= 480 line formats since
 * the hardware only captured one field maximum.
 *
 */





/*
 * build a translation table to translate between YUV and RGB555.
 *
 * This builds a lookup table with 32k 1-word entries: truncate the YUV
 * to 15bits (5-5-5) and look-up in this xlate table to produce the
 * 15-bit rgb value.
 */
LPVOID BuildYUV422ToRGB555(PINSTINFO pinst)
{
    HGLOBAL hMem = 0;
    LPVOID pXlate = NULL;

    if (pinst->pXlate != NULL) {
        return(pinst->pXlate);
    }

    /*
     * allocate a table big enough for 32k 2-byte entries
     */
    if ( ( hMem = GlobalAlloc(GPTR, 2 * 32 * 1024))
      && ( pXlate = GlobalLock( hMem ) ) )
    {
        WORD w;
        LPWORD pRGB555 = (LPWORD)pXlate;

        /*
         * build a 15-bit yuv lookup table by stepping through each entry,
         * converting the yuv index to rgb and storing at that index. The index
         * to this table is a 15-bit value with the y component in bits 14..10,
         * u in bits 9..5 and v in bits 4..0. Note that the y component is unsigned,
         * whereas the u and v components are signed.
         */
        for (w = 0; w < 32*1024; w++) {
            /*
             * the YUVtoRGB55 conversion function takes values 0..255 for y,
             * and -128..+127 for u and v. Pick out the relevant bits of the
             * index for this cell, and shift to get values in this range.
             * Subtract 128 from u and v to shift from 0..255 to -128..+127
             */
            *pRGB555++ = YUVToRGB555(
                                (w &  0x7c00) >> 7,
                                ((w & 0x3e0) >> 2) - 128,
                                ((w & 0x1f) << 3) - 128
                         );
        }
    }

    return(pXlate);


}

/*
 * build a translation table to translate between YUV and RGB 5-6-5
 *
 * This builds a lookup table with 32k 1-word entries: truncate the YUV
 * to 15bits (5-5-5) and look-up in this xlate table to produce the
 * 16-bit rgb value.
 */
LPVOID BuildYUV422ToRGB565(PINSTINFO pinst)
{
    HGLOBAL hMem = 0;
    LPVOID pXlate = NULL;

    if (pinst->pXlate != NULL) {
        return(pinst->pXlate);
    }

    /*
     * allocate a table big enough for 32k 2-byte entries
     */

    if ( ( hMem = GlobalAlloc(GPTR, 2 * 32 * 1024))
      && ( pXlate = GlobalLock( hMem ) ) )
    {
        WORD w;
        LPWORD pRGB = (LPWORD)pXlate;

        /*
         * build a 15-bit yuv lookup table by stepping through each entry,
         * converting the yuv index to rgb and storing at that index. The index
         * to this table is a 15-bit value with the y component in bits 14..10,
         * u in bits 9..5 and v in bits 4..0. Note that the y component is unsigned,
         * whereas the u and v components are signed.
         */
        for (w = 0; w < 32*1024; w++) {
            /*
             * the YUVtoRGB conversion function takes values 0..255 for y,
             * and -128..+127 for u and v. Pick out the relevant bits of the
             * index for this cell, and shift to get values in this range.
             * Subtract 128 from u and v to shift from 0..255 to -128..+127
             */
            *pRGB++ = YUVToRGB565(
                                (w &  0x7c00) >> 7,
                                ((w & 0x3e0) >> 2) - 128,
                                ((w & 0x1f) << 3) - 128
                         );
        }
    }

    return(pXlate);


}

/*
 * translate YUV 4:2:2 into 16-bit RGB using a lookup table. Flip vertically
 * into DIB format during processing. Double scanlines for formats of
 * 480 lines or greater. Produces 565 or 555 format RGB depending on the
 * xlate table.
 */
VOID
YUV422ToRGB(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    int RowInc;
    int i, j;
    DWORD uv55, dwPixel;
    int WidthBytes;                     // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pSrc, pDst;
    int Height, Width;
    PWORD pXlate;
    int InputHeight;


    Height = lpbiInput->biHeight;
    InputHeight = Height;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*2;               // size of (input and output) line
    pXlate = pinst->pXlate;


    /*
     * adjust the destination to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pDst = (PDWORD) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
    pSrc = (PDWORD) lpInput;


    /*
     * do we need to duplicate scans to fill the destination ?
     */
    if (Height >= 480) {
        bDuplicate = TRUE;

        /*
         * we need to skip one line each time we copy a line
         */
        RowInc = WidthBytes * 2 + (Width * 2);

        InputHeight = Height/2;

    } else {


        /*
         * calculate the amount to adjust pDst by at the end of one line
         * of copying. At this point we are at the end of line N. We need
         * to move to the start of line N-1.
         */
        RowInc = WidthBytes + (Width * 2);

    }

    /* remember we are adding to a DWORD pointer */
    RowInc /= sizeof(DWORD);



    /* loop copying each scanline */
    for (i = InputHeight; i > 0; i--) {

        /* loop copying two pixels at a time */
        for (j = Width ; j > 0; j -= 2) {

            /*
             * get two pixels and convert to 15-bpp YUV
             */

            dwPixel = *pSrc++;


            /*
             * dwPixel now has two pixels, in this layout (MSB..LSB):
             *
             *  V Y1 U Y0
             *
             * convert to 2 yuv555 words and lookup in xlate table
             */

            /* get common u and v components to lower 10 bits */
            uv55 = ((dwPixel & 0xf8000000) >> 27) |
                    ((dwPixel & 0x0000f800) >> 6);


            /* build each yuv-655 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwPixel = pXlate[ ((dwPixel & 0xf8) << 7) | uv55 ] |
                      (pXlate[((dwPixel & 0xf80000) >> 9) | uv55 ] << 16);

            /* write two pixels to destination */
            *pDst++ = dwPixel;


        } // loop per 2 pixels


        /* move dest pointer back to next line */
        pDst -= RowInc;

    } // loop per row



    if (bDuplicate) {

        PBYTE pbDst;

        /*
         * Note that since we started at the last line, and didn't duplicate,
         * we placed data in lines 1, 3, 5 etc that needs to be copied
         * to lines 0, 2, 4 etc.
         */
        for (i = 0, pbDst = lpOutput; i < (int) Height; i+= 2) {


            /*
             * duplicate the scan line. We point at the first of the
             * two lines - the data is in the second of the
             * two lines.
             */
            RtlCopyMemory(pbDst, pbDst + WidthBytes, WidthBytes);

            /* skip this pair to get to the next line to be converted */
            pbDst += WidthBytes * 2;
        }
    }
}



#ifdef  TOSHIBA
#ifdef  COLOR_MODIFY
/* YUV12 support ------------------------------------------ */

/*
 * TOSHIBA Y.Kasai
 * for Pistachio
 *
 * The captured data is in YUV12 , 8-bits per.
 * The data is separated each Y,U,V segment.
 * Data format is folow sequence:
 * Y0,Y1,Y2.......Yn,U0,U1,U2.....U(n/4),V0,V1,V2....V(n/4)
 *
 */





/*
 * build a translation table to translate between YUV and RGB555.
 *
 * This builds a lookup table with 32k 1-word entries: truncate the YUV
 * to 15bits (5-5-5) and look-up in this xlate table to produce the
 * 15-bit rgb value.
 */
LPVOID BuildYUVToRB(PINSTINFO pinst)
{
    HGLOBAL hMem = 0;
    LPVOID pXlate = NULL;

    if (pinst->pXlate != NULL) {
        return(pinst->pXlate);
    }

    /*
     * allocate a table big enough for 64k 2-coloer (R, B) entries
     */
    if ( ( hMem = GlobalAlloc(GPTR, 2 * 64 * 1024) )
      && ( pXlate = GlobalLock( hMem ) ) )
    {
        LPBYTE pRB = (LPBYTE)pXlate;
        ULONG  w;

        for (w = 0; w < 64*1024; w++) {
            *pRB++ = TosYVToR( (w &  0xff00) >> 8, ((w & 0xff)) );
        }

        for (w = 0; w < 64*1024; w++) {
            *pRB++ = TosYUToB( (w &  0xff00) >> 8, ((w & 0xff)) );
        }
    }

    return(pXlate);
}

#else //COLOR_MODIFY
/* YUV12 support ------------------------------------------ */

/*
 * TOSHIBA Y.Kasai
 * for Pistachio
 *
 * The captured data is in YUV12 , 8-bits per.
 * The data is separated each Y,U,V segment.
 * Data format is folow sequence:
 * Y0,Y1,Y2.......Yn,U0,U1,U2.....U(n/4),V0,V1,V2....V(n/4)
 *
 */





/*
 * build a translation table to translate between YUV and RGB555.
 *
 * This builds a lookup table with 32k 1-word entries: truncate the YUV
 * to 15bits (5-5-5) and look-up in this xlate table to produce the
 * 15-bit rgb value.
 */
LPVOID BuildYUV12ToRGB555(PINSTINFO pinst)
{
    HGLOBAL hMem = 0;
    LPVOID pXlate = NULL;
    // LPWORD pRGB555;

    if (pinst->pXlate != NULL) {
        return(pinst->pXlate);
    }

    /*
     * allocate a table big enough for 32k 2-byte entries
     */
    if ( ( hMem = GlobalAlloc(GPTR, 2 * 32 * 1024) )
      && ( pXlate = GlobalLock( hMem ) ) )
    {
        WORD w;
        LPWORD pRGB555 = (LPWORD)pXlate;
    
        /*
         * build a 15-bit yuv lookup table by stepping through each entry,
         * converting the yuv index to rgb and storing at that index. The index
         * to this table is a 15-bit value with the y component in bits 14..10,
         * u in bits 9..5 and v in bits 4..0. Note that the y component is unsigned,
         * whereas the u and v components are signed.
         */
        for (w = 0; w < 32*1024; w++) {
            /*
             * the YUVtoRGB55 conversion function takes values 0..255 for y,
             * and 0..255 for u and v. Pick out the relevant bits of the
             * index for this cell, and shift to get values in this range.
             */
            *pRGB555++ = TosYUVToRGB555(
                                (w &  0x7c00) >> 7,
                                ((w & 0x3e0) >> 2),
                                ((w & 0x1f) << 3)
                         );
        }
    }
    return(pXlate);
}

/*
 * build a translation table to translate between YUV and RGB 5-6-5
 *
 * This builds a lookup table with 32k 1-word entries: truncate the YUV
 * to 15bits (5-5-5) and look-up in this xlate table to produce the
 * 16-bit rgb value.
 */
LPVOID BuildYUV12ToRGB565(PINSTINFO pinst)
{
    HGLOBAL hMem = 0;
    LPVOID pXlate = NULL;

    if (pinst->pXlate != NULL) {
        return(pinst->pXlate);
    }

    /*
     * allocate a table big enough for 32k 2-byte entries
     */

    if ( ( hMem = GlobalAlloc(GPTR, 2 * 32 * 1024) )
      && ( pXlate = GlobalLock( hMem ) ) )
    {
        WORD w;
        LPWORD pRGB = (LPWORD)pXlate;

        /*
         * build a 15-bit yuv lookup table by stepping through each entry,
         * converting the yuv index to rgb and storing at that index. The index
         * to this table is a 15-bit value with the y component in bits 14..10,
         * u in bits 9..5 and v in bits 4..0. Note that the y component is unsigned,
         * whereas the u and v components are signed.
         */
        for (w = 0; w < 32*1024; w++) {
    
            /*
             * the YUVtoRGB conversion function takes values 0..255 for y,
             * and 0.255 for u and v. Pick out the relevant bits of the
             * index for this cell, and shift to get values in this range.
             */
            *pRGB++ = TosYUVToRGB565(
                                (w &  0x7c00) >> 7,
                                ((w & 0x3e0) >> 2),
                                ((w & 0x1f) << 3)
                         );
        }
    }

    return(pXlate);
}
#endif//COLOR_MODIFY

/*
 * translate YUV12 into 16-bit RGB using a lookup table. Flip vertically
 * into DIB format during processing. Double scanlines for formats of
 * 240 lines or greater. Produces 565 or 555 format RGB depending on the
 * xlate table.
 */
#ifdef  COLOR_MODIFY
VOID
YUV12ToRGB24(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    int RowInc;
    int UVRowInc;
    int i, j;
    DWORD dwYPixel;
    int dwParam, dwTemp;
    int WidthBytes;                     // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pYSrc;
    volatile PBYTE pDst;  // '98-12-08 Add volatile attr. for Rep.253570
    PWORD pUSrc, pVSrc;
    WORD wUPixel, wVPixel;
    WORD wUPTemp, wVPTemp;
    int Height, Width;
    PBYTE pXlate;
    int InputHeight;
    BYTE ubR, ubG, ubB;


    Height = lpbiInput->biHeight;
    InputHeight = Height;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*3;               // size of (input and output) line
    pXlate = (PBYTE)pinst->pXlate;


    /*
     * adjust the destination to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pDst  = (PBYTE) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
    pYSrc = (PDWORD) lpInput;
    pUSrc = (PWORD) ( (LPBYTE)lpInput + Height * Width);
    pVSrc = (PWORD) ( (LPBYTE)lpInput + Height * Width + Height * Width / 4);

    RowInc = WidthBytes + (Width * 3);

    UVRowInc = Width / 2;
    UVRowInc /= sizeof(WORD);

    /* loop copying each scanline */
    for (i = 0; i < InputHeight; i++) {

        /* loop copying two pixels at a time */
        for (j = Width ; j > 0; j -= 4) {

            /*
             * get four pixels and convert to 15-bpp YUV
             */

            dwYPixel = *pYSrc++;
            wUPixel = *pUSrc++;
            wVPixel = *pVSrc++;

            wVPTemp = wVPixel & 0xff;
            wUPTemp = wUPixel & 0xff;
            dwParam = (833 * wVPTemp) + (402 * wUPTemp) - 138908;

            /*
             * dwY(U or V)Pixel now has two pixels, in this layout (MSB..LSB):
             *
             *  Y3 Y2 Y1 Y0
             *  V1 V0
             *  U1 U0
             *
             * convert to 4 yuv555 words and lookup in xlate table
             */

            /* build each yuv-555 value by truncating
             * y to 8 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwTemp = dwYPixel & 0xff;
            ubG = (BYTE)RANGE((dwTemp * 1192 - dwParam) / 1024, 0, 255);
            dwTemp <<= 8;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];

            *pDst++ = ubB;
            *pDst++ = ubG;
            *pDst++ = ubR;

            // next pixel
            dwTemp = dwYPixel & 0xff00;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            *pDst++ = ubB;
            *pDst++ = ubG;
            *pDst++ = ubR;

            wVPTemp = (wVPixel >> 8) & 0xff;
            wUPTemp = (wUPixel >> 8) & 0xff;
            dwParam = (833 * wVPTemp) + (402 * wUPTemp) - 138908;

            dwTemp = (dwYPixel & 0xff0000) >> 8;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            *pDst++ = ubB;
            *pDst++ = ubG;
            *pDst++ = ubR;

            // next pixel
            dwTemp = (dwYPixel & 0xff000000) >> 16;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            *pDst++ = ubB;
            *pDst++ = ubG;
            *pDst++ = ubR;

        } // loop per 4 pixels

        if (!(i & 1))
        {
            pUSrc -= UVRowInc;
            pVSrc -= UVRowInc;
        }

        /* move dest pointer back to next line */
        pDst -= RowInc;

    } // loop per row
}

VOID
YUV12ToRGB565(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    int RowInc;
    int UVRowInc;
    int i, j;
    DWORD uv55, dwPixel, dwYPixel;
    int dwParam, dwTemp;
    int WidthBytes;                     // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pYSrc;
    volatile PDWORD pDst;  // '98-12-08 Add volatile attr. for Rep.253570
    PWORD pUSrc, pVSrc;
    WORD wUPixel, wVPixel;
    WORD wUPTemp, wVPTemp;
    int Height, Width;
    PBYTE pXlate;
    int InputHeight;
    BYTE ubR, ubG, ubB;


    Height = lpbiInput->biHeight;
    InputHeight = Height;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*2;               // size of (input and output) line
    pXlate = (PBYTE)pinst->pXlate;


    /*
     * adjust the destination to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pDst = (PDWORD) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
    pYSrc = (PDWORD) lpInput;
    pUSrc = (PWORD) ( (LPBYTE)lpInput + Height * Width);
    pVSrc = (PWORD) ( (LPBYTE)lpInput + Height * Width + Height * Width / 4);


    RowInc = WidthBytes + (Width * 2);

    /* remember we are adding to a DWORD pointer */
    RowInc /= sizeof(DWORD);

    UVRowInc = Width / 2;
    UVRowInc /= sizeof(WORD);

    /* loop copying each scanline */
    for (i = 0; i < InputHeight; i++) {

        /* loop copying two pixels at a time */
        for (j = Width ; j > 0; j -= 4) {

            /*
             * get four pixels and convert to 15-bpp YUV
             */

            dwYPixel = *pYSrc++;
            wUPixel = *pUSrc++;
            wVPixel = *pVSrc++;

            wVPTemp = wVPixel & 0xff;
            wUPTemp = wUPixel & 0xff;
            dwParam = (833 * wVPTemp) + (402 * wUPTemp) - 138908;

            /*
             * dwY(U or V)Pixel now has two pixels, in this layout (MSB..LSB):
             *
             *  Y3 Y2 Y1 Y0
             *  V1 V0
             *  U1 U0
             *
             * convert to 4 yuv555 words and lookup in xlate table
             */

            /* build each yuv-555 value by truncating
             * y to 8 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwTemp = dwYPixel & 0xff;
            ubG = (BYTE)RANGE((dwTemp * 1192 - dwParam) / 1024, 0, 255);
            dwTemp <<= 8;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];

            dwPixel = (ubR & 0xf8) << 8 | (ubG & 0xfc) << 3 | (ubB & 0xf8) >> 3;

            // next pixel
            dwTemp = dwYPixel & 0xff00;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel |= (ubR & 0xf8) << 24 | (ubG & 0xfc) << 19 | (ubB & 0xf8) << 13;

            /* write two pixels to destination */
            *pDst++ = dwPixel;

            wVPTemp = (wVPixel >> 8) & 0xff;
            wUPTemp = (wUPixel >> 8) & 0xff;
            dwParam = (833 * wVPTemp) + (402 * wUPTemp) - 138908;

            dwTemp = (dwYPixel & 0xff0000) >> 8;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel = (ubR & 0xf8) << 8 | (ubG & 0xfc) << 3 | (ubB & 0xf8) >> 3;

            // next pixel
            dwTemp = (dwYPixel & 0xff000000) >> 16;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel |= (ubR & 0xf8) << 24 | (ubG & 0xfc) << 19 | (ubB & 0xf8) << 13;

            /* write two pixels to destination */
            *pDst++ = dwPixel;

        } // loop per 4 pixels

        if (!(i & 1))
        {
            pUSrc -= UVRowInc;
            pVSrc -= UVRowInc;
        }

        /* move dest pointer back to next line */
        pDst -= RowInc;

    } // loop per row
}

VOID
YUV12ToRGB555(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    int RowInc;
    int UVRowInc;
    int i, j;
    DWORD uv55, dwPixel, dwYPixel;
    int dwParam, dwTemp;
    int WidthBytes;                     // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pYSrc;
    volatile PDWORD pDst;  // '98-12-08 Add volatile attr. for Rep.253570
    PWORD pUSrc, pVSrc;
    WORD wUPixel, wVPixel;
    WORD wUPTemp, wVPTemp;
    int Height, Width;
    PBYTE pXlate;
    int InputHeight;
    BYTE ubR, ubG, ubB;


    Height = lpbiInput->biHeight;
    InputHeight = Height;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*2;               // size of (input and output) line
    pXlate = (PBYTE)pinst->pXlate;


    /*
     * adjust the destination to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pDst = (PDWORD) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
    pYSrc = (PDWORD) lpInput;
    pUSrc = (PWORD) ( (LPBYTE)lpInput + Height * Width);
    pVSrc = (PWORD) ( (LPBYTE)lpInput + Height * Width + Height * Width / 4);


    RowInc = WidthBytes + (Width * 2);

    /* remember we are adding to a DWORD pointer */
    RowInc /= sizeof(DWORD);

    UVRowInc = Width / 2;
    UVRowInc /= sizeof(WORD);

    /* loop copying each scanline */
    for (i = 0; i < InputHeight; i++) {

        /* loop copying two pixels at a time */
        for (j = Width ; j > 0; j -= 4) {

            /*
             * get four pixels and convert to 15-bpp YUV
             */

            dwYPixel = *pYSrc++;
            wUPixel = *pUSrc++;
            wVPixel = *pVSrc++;

            wVPTemp = wVPixel & 0xff;
            wUPTemp = wUPixel & 0xff;
            dwParam = (833 * wVPTemp) + (402 * wUPTemp) - 138908;

            /*
             * dwY(U or V)Pixel now has two pixels, in this layout (MSB..LSB):
             *
             *  Y3 Y2 Y1 Y0
             *  V1 V0
             *  U1 U0
             *
             * convert to 4 yuv555 words and lookup in xlate table
             */

            /* build each yuv-555 value by truncating
             * y to 8 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwTemp = dwYPixel & 0xff;
            ubG = (BYTE)RANGE((dwTemp * 1192 - dwParam) / 1024, 0, 255);
            dwTemp <<= 8;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];

            dwPixel = (ubR & 0xf8) << 7 | (ubG & 0xf8) << 2 | (ubB & 0xf8) >> 3;

            // next pixel
            dwTemp = dwYPixel & 0xff00;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel |= (ubR & 0xf8) << 23 | (ubG & 0xf8) << 18 | (ubB & 0xf8) << 13;

            /* write two pixels to destination */
            *pDst++ = dwPixel;

            wVPTemp = (wVPixel >> 8) & 0xff;
            wUPTemp = (wUPixel >> 8) & 0xff;
            dwParam = (833 * wVPTemp) + (402 * wUPTemp) - 138908;

            dwTemp = (dwYPixel & 0xff0000) >> 8;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel = (ubR & 0xf8) << 7 | (ubG & 0xf8) << 2 | (ubB & 0xf8) >> 3;

            // next pixel
            dwTemp = (dwYPixel & 0xff000000) >> 16;
            ubR = pXlate[ dwTemp | wVPTemp];
            ubB = pXlate[(dwTemp | wUPTemp) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel |= (ubR & 0xf8) << 23 | (ubG & 0xf8) << 18 | (ubB & 0xf8) << 13;

            /* write two pixels to destination */
            *pDst++ = dwPixel;

        } // loop per 4 pixels

        if (!(i & 1))
        {
            pUSrc -= UVRowInc;
            pVSrc -= UVRowInc;
        }

        /* move dest pointer back to next line */
        pDst -= RowInc;

    } // loop per row
}
#else //COLOR_MODIFY
VOID
YUV12ToRGB(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    int RowInc;
        int UVRowInc;
    int i, j;
    DWORD uv55, dwPixel, dwYPixel;
    int WidthBytes;                     // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pYSrc, pDst;
    PWORD pUSrc, pVSrc;
    WORD wUPixel, wVPixel;
    int Height, Width;
    PWORD pXlate;
    int InputHeight;


    Height = lpbiInput->biHeight;
    InputHeight = Height;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*2;               // size of (input and output) line
    pXlate = pinst->pXlate;


    /*
     * adjust the destination to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pDst = (PDWORD) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
    pYSrc = (PDWORD) lpInput;
#if 1
    pUSrc = (PWORD) ( (LPBYTE)lpInput + Height * Width);
    pVSrc = (PWORD) ( (LPBYTE)lpInput + Height * Width + Height * Width / 4);
#else
    pUSrc = (PWORD) lpInput + Height * Width;
    pVSrc = (PWORD) lpInput + Height * Width + Height * Width / 4;
#endif


#if 1
    RowInc = WidthBytes + (Width * 2);
#else
    /*
     * do we need to duplicate scans to fill the destination ?
     */
    if (Height >= 240) {
        bDuplicate = TRUE;

        /*
         * we need to skip one line each time we copy a line
         */
        RowInc = WidthBytes * 2 + (Width * 2);

        InputHeight = Height/2;

    } else {


        /*
         * calculate the amount to adjust pDst by at the end of one line
         * of copying. At this point we are at the end of line N. We need
         * to move to the start of line N-1.
         */
        RowInc = WidthBytes + (Width * 2);

    }
#endif

    /* remember we are adding to a DWORD pointer */
    RowInc /= sizeof(DWORD);

    UVRowInc = Width / 2;
    UVRowInc /= sizeof(WORD);



    /* loop copying each scanline */
    for (i = 0; i < InputHeight; i++) {

        /* loop copying two pixels at a time */
        for (j = Width ; j > 0; j -= 4) {

            /*
             * get four pixels and convert to 15-bpp YUV
             */

            dwYPixel = *pYSrc++;
            wUPixel = *pUSrc++;
            wVPixel = *pVSrc++;


            /*
             * dwY(U or V)Pixel now has two pixels, in this layout (MSB..LSB):
             *
             *  Y3 Y2 Y1 Y0
             *  V1 V0
             *  U1 U0
             *
             * convert to 4 yuv555 words and lookup in xlate table
             */

            /* get common u0 and v0 components to lower 10 bits */
            uv55 = ((wUPixel & 0xf8) << 2) |
                    ((wVPixel & 0xf8) >> 3);


            /* build each yuv-555 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwPixel = pXlate[ ((dwYPixel & 0xf8) << 7) | uv55 ] |
                      (pXlate[((dwYPixel & 0xf800) >> 1) | uv55 ] << 16);

            /* write two pixels to destination */
            *pDst++ = dwPixel;

            /* get common u1 and v1 components to lower 10 bits */
            uv55 = ((wUPixel & 0xf800) >> 6) |
                    ((wVPixel & 0xf800) >> 11);


            /* build each yuv-655 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwPixel = pXlate[ ((dwYPixel & 0xf80000) >> 9) | uv55 ] |
                      (pXlate[((dwYPixel & 0xf8000000) >> 17) | uv55 ] << 16);

            /* write two pixels to destination */
            *pDst++ = dwPixel;



        } // loop per 4 pixels

        if (!(i & 1))
        {
            pUSrc -= UVRowInc;
            pVSrc -= UVRowInc;
        }

        /* move dest pointer back to next line */
        pDst -= RowInc;

    } // loop per row


#if 0 // Pistachio is not support Interlace mode!!

    if (bDuplicate) {

        PBYTE pbDst;

        /*
         * Note that since we started at the last line, and didn't duplicate,
         * we placed data in lines 1, 3, 5 etc that needs to be copied
         * to lines 0, 2, 4 etc.
         */
        for (i = 0, pbDst = lpOutput; i < (int) Height; i+= 2) {


            /*
             * duplicate the scan line. We point at the first of the
             * two lines - the data is in the second of the
             * two lines.
             */
            RtlCopyMemory(pbDst, pbDst + WidthBytes, WidthBytes);

            /* skip this pair to get to the next line to be converted */
            pbDst += WidthBytes * 2;
        }
    }
#endif
}
#endif//COLOR_MODIFY



/* YUV9 Support ------------------------------------------ */

/*
 * TOSHIBA Y.Kasai
 * for Pistachio
 *
 * The captured data is in YUV9 .
 * The data is separated each Y,U,V segment.
 * Data format is folow sequence:
 * Y0,Y1,Y2.......Yn,V0,V1,V2....V(n/16),U0,U1,U2.....U(n/16)
 *
 */


/*
 * translate YUV9 into 16-bit RGB using a lookup table. Flip vertically
 * into DIB format during processing.
 * Produces 565 or 555 format RGB depending on the
 * xlate table.
 */
#ifdef  COLOR_MODIFY
VOID
YUV9ToRGB24(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    int RowInc;
    int UVRowInc;
    int i, j;
    DWORD dwYPixel;
    int dwParam, dwTemp;
    int WidthBytes;                     // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pYSrc;
    volatile PBYTE pDst;  // '98-12-08 Add volatile attr. for Rep.253570
    PBYTE pUSrc, pVSrc;
    BYTE bUPixel, bVPixel;
    int Height, Width;
    PBYTE pXlate;
    int InputHeight;
    BYTE ubR, ubG, ubB;


    Height = lpbiInput->biHeight;
    InputHeight = Height;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*3;               // size of (input and output) line
    pXlate = (PBYTE)pinst->pXlate;


    /*
     * adjust the destination to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pDst  = (PBYTE) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
    pYSrc = (PDWORD) lpInput;

    pVSrc = (PBYTE) ( (LPBYTE)lpInput + Height * Width);
    pUSrc = (PBYTE) ( (LPBYTE)lpInput + Height * Width + Height * Width / 16);

    /*
     * calculate the amount to adjust pDst by at the end of one line
     * of copying. At this point we are at the end of line N. We need
     * to move to the start of line N-1.
     */
    RowInc = WidthBytes + (Width * 3);

    UVRowInc = Width / 4;
    UVRowInc /= sizeof(BYTE);

    /* loop copying each scanline */
    for (i = 0; i < InputHeight; i++) {

        /* loop copying two pixels at a time */
        for (j = Width ; j > 0; j -= 4) {

            /*
             * get four pixels and convert to 15-bpp YUV
             */

            dwYPixel = *pYSrc++;
            bUPixel = *pUSrc++;
            bVPixel = *pVSrc++;

            dwParam = (833 * bVPixel) + (402 * bUPixel) - 138908;

            /*
             * dwY(U or V)Pixel now has four pixels, in this layout (MSB..LSB):
             *
             *  Y3 Y2 Y1 Y0
             *  V0
             *  U0
             *
             * convert to 4 yuv555 words and lookup in xlate table
             */

            /* build each yuv-555 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwTemp = dwYPixel & 0xff;
            ubG = (BYTE)RANGE((dwTemp * 1192 - dwParam) / 1024, 0, 255);
            dwTemp <<= 8;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];

            *pDst++ = ubB;
            *pDst++ = ubG;
            *pDst++ = ubR;

            // next pixel
            dwTemp = dwYPixel & 0xff00;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            *pDst++ = ubB;
            *pDst++ = ubG;
            *pDst++ = ubR;

            /* build each yuv-655 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwTemp = (dwYPixel & 0xff0000) >> 8;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            *pDst++ = ubB;
            *pDst++ = ubG;
            *pDst++ = ubR;

            // next pixel
            dwTemp = (dwYPixel & 0xff000000) >> 16;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];
            ubG = (BYTE)RANGE((((dwTemp >> 8) & 0xff) * 1192 - dwParam) / 1024, 0, 255);

            *pDst++ = ubB;
            *pDst++ = ubG;
            *pDst++ = ubR;

        } // loop per 4 pixels

        if ((i & 0x3) != 0x03)
        {
            pUSrc -= UVRowInc;
            pVSrc -= UVRowInc;
        }

        /* move dest pointer back to next line */
        pDst -= RowInc;

    } // loop per row
}

VOID
YUV9ToRGB565(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    int RowInc;
    int UVRowInc;
    int i, j;
    DWORD uv55, dwPixel, dwYPixel;
    int dwParam, dwTemp;
    int WidthBytes;                     // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pYSrc;
    volatile PDWORD pDst;  // '98-12-08 Add volatile attr. for Rep.253570
    PBYTE pUSrc, pVSrc;
    BYTE bUPixel, bVPixel;
    int Height, Width;
    PBYTE pXlate;
    int InputHeight;
    BYTE ubR, ubG, ubB;


    Height = lpbiInput->biHeight;
    InputHeight = Height;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*2;               // size of (input and output) line
    pXlate = (PBYTE)pinst->pXlate;


    /*
     * adjust the destination to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pDst = (PDWORD) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
    pYSrc = (PDWORD) lpInput;

    pVSrc = (PBYTE) ( (LPBYTE)lpInput + Height * Width);
    pUSrc = (PBYTE) ( (LPBYTE)lpInput + Height * Width + Height * Width / 16);

    /*
     * calculate the amount to adjust pDst by at the end of one line
     * of copying. At this point we are at the end of line N. We need
     * to move to the start of line N-1.
     */
    RowInc = WidthBytes + (Width * 2);


    /* remember we are adding to a DWORD pointer */
    RowInc /= sizeof(DWORD);


    UVRowInc = Width / 4;
    UVRowInc /= sizeof(BYTE);

    /* loop copying each scanline */
    for (i = 0; i < InputHeight; i++) {

        /* loop copying two pixels at a time */
        for (j = Width ; j > 0; j -= 4) {

            /*
             * get four pixels and convert to 15-bpp YUV
             */

            dwYPixel = *pYSrc++;
            bUPixel = *pUSrc++;
            bVPixel = *pVSrc++;

            dwParam = (833 * bVPixel) + (402 * bUPixel) - 138908;

            /*
             * dwY(U or V)Pixel now has four pixels, in this layout (MSB..LSB):
             *
             *  Y3 Y2 Y1 Y0
             *  V0
             *  U0
             *
             * convert to 4 yuv555 words and lookup in xlate table
             */

            /* build each yuv-555 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwTemp = dwYPixel & 0xff;
            ubG = (BYTE)RANGE((dwTemp * 1192 - dwParam) / 1024, 0, 255);
            dwTemp <<= 8;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];

            dwPixel = (ubR & 0xf8) << 8 | (ubG & 0xfc) << 3 | (ubB & 0xf8) >> 3;

            // next pixel
            dwTemp = dwYPixel & 0xff00;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel |= (ubR & 0xf8) << 24 | (ubG & 0xfc) << 19 | (ubB & 0xf8) << 13;

            *pDst++ = dwPixel;

            /* build each yuv-655 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwTemp = (dwYPixel & 0xff0000) >> 8;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel = (ubR & 0xf8) << 8 | (ubG & 0xfc) << 3 | (ubB & 0xf8) >> 3;

            // next pixel
            dwTemp = (dwYPixel & 0xff000000) >> 16;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];
            ubG = (BYTE)RANGE((((dwTemp >> 8) & 0xff) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel |= (ubR & 0xf8) << 24 | (ubG & 0xfc) << 19 | (ubB & 0xf8) << 13;

            /* write two pixels to destination */
            *pDst++ = dwPixel;

        } // loop per 4 pixels

        if ((i & 0x3) != 0x03)
        {
            pUSrc -= UVRowInc;
            pVSrc -= UVRowInc;
        }

        /* move dest pointer back to next line */
        pDst -= RowInc;

    } // loop per row
}

VOID
YUV9ToRGB555(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    int RowInc;
    int UVRowInc;
    int i, j;
    DWORD uv55, dwPixel, dwYPixel;
    int dwParam, dwTemp;
    int WidthBytes;                     // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pYSrc;
    volatile PDWORD pDst;  // '98-12-08 Add volatile attr. for Rep.253570
    PBYTE pUSrc, pVSrc;
    BYTE bUPixel, bVPixel;
    int Height, Width;
    PBYTE pXlate;
    int InputHeight;
    BYTE ubR, ubG, ubB;


    Height = lpbiInput->biHeight;
    InputHeight = Height;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*2;               // size of (input and output) line
    pXlate = pinst->pXlate;


    /*
     * adjust the destination to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pDst = (PDWORD) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
    pYSrc = (PDWORD) lpInput;

    pVSrc = (PBYTE) ( (LPBYTE)lpInput + Height * Width);
    pUSrc = (PBYTE) ( (LPBYTE)lpInput + Height * Width + Height * Width / 16);

    /*
     * calculate the amount to adjust pDst by at the end of one line
     * of copying. At this point we are at the end of line N. We need
     * to move to the start of line N-1.
     */
    RowInc = WidthBytes + (Width * 2);


    /* remember we are adding to a DWORD pointer */
    RowInc /= sizeof(DWORD);


    UVRowInc = Width / 4;
    UVRowInc /= sizeof(BYTE);

    /* loop copying each scanline */
    for (i = 0; i < InputHeight; i++) {

        /* loop copying two pixels at a time */
        for (j = Width ; j > 0; j -= 4) {

            /*
             * get four pixels and convert to 15-bpp YUV
             */

            dwYPixel = *pYSrc++;
            bUPixel = *pUSrc++;
            bVPixel = *pVSrc++;

            dwParam = (833 * bVPixel) + (402 * bUPixel) - 138908;

            /*
             * dwY(U or V)Pixel now has four pixels, in this layout (MSB..LSB):
             *
             *  Y3 Y2 Y1 Y0
             *  V0
             *  U0
             *
             * convert to 4 yuv555 words and lookup in xlate table
             */

            /* build each yuv-555 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwTemp = dwYPixel & 0xff;
            ubG = (BYTE)RANGE((dwTemp * 1192 - dwParam) / 1024, 0, 255);
            dwTemp <<= 8;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];

            dwPixel = (ubR & 0xf8) << 7 | (ubG & 0xf8) << 2 | (ubB & 0xf8) >> 3;

            // next pixel
            dwTemp = dwYPixel & 0xff00;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel |= (ubR & 0xf8) << 23 | (ubG & 0xf8) << 18 | (ubB & 0xf8) << 13;

            /* write two pixels to destination */
            *pDst++ = dwPixel;


            /* build each yuv-655 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwTemp = (dwYPixel & 0xff0000) >> 8;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];
            ubG = (BYTE)RANGE(((dwTemp >> 8) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel = (ubR & 0xf8) << 7 | (ubG & 0xf8) << 2 | (ubB & 0xf8) >> 3;

            // next pixel
            dwTemp = (dwYPixel & 0xff000000) >> 16;
            ubR = pXlate[ dwTemp | bVPixel];
            ubB = pXlate[(dwTemp | bUPixel) + 65536];
            ubG = (BYTE)RANGE((((dwTemp >> 8) & 0xff) * 1192 - dwParam) / 1024, 0, 255);

            dwPixel |= (ubR & 0xf8) << 23 | (ubG & 0xf8) << 18 | (ubB & 0xf8) << 13;

            /* write two pixels to destination */
            *pDst++ = dwPixel;

        } // loop per 4 pixels

        if ((i & 0x3) != 0x03)
        {
            pUSrc -= UVRowInc;
            pVSrc -= UVRowInc;
        }

        /* move dest pointer back to next line */
        pDst -= RowInc;

    } // loop per row
}

#else //COLOR_MODIFY
VOID
YUV9ToRGB(
    PINSTINFO pinst,
     LPBITMAPINFOHEADER lpbiInput,
     LPVOID lpInput,
     LPBITMAPINFOHEADER lpbiOutput,
     LPVOID lpOutput
)
{
    int RowInc;
        int UVRowInc;
    int i, j;
    DWORD uv55, dwPixel, dwYPixel;
    int WidthBytes;                     // width of one line in BYTES
    BOOL bDuplicate = FALSE;
    PDWORD pYSrc, pDst;
    PBYTE pUSrc, pVSrc;
    BYTE bUPixel, bVPixel;
    int Height, Width;
    PWORD pXlate;
    int InputHeight;


    Height = lpbiInput->biHeight;
    InputHeight = Height;
    Width = lpbiInput->biWidth;
    WidthBytes = Width*2;               // size of (input and output) line
    pXlate = pinst->pXlate;


    /*
     * adjust the destination to point to the start of the last line,
     * and work upwards (to flip vertically into DIB format)
     */
    pDst = (PDWORD) ( (LPBYTE)lpOutput + (Height - 1) * WidthBytes );
    pYSrc = (PDWORD) lpInput;

#if 1
    pVSrc = (PBYTE) ( (LPBYTE)lpInput + Height * Width);
    pUSrc = (PBYTE) ( (LPBYTE)lpInput + Height * Width + Height * Width / 16);
#else
    pVSrc = (PBYTE) lpInput + Height * Width;
    pUSrc = (PBYTE) lpInput + Height * Width + Height * Width / 16;
#endif



        /*
         * calculate the amount to adjust pDst by at the end of one line
         * of copying. At this point we are at the end of line N. We need
         * to move to the start of line N-1.
         */
        RowInc = WidthBytes + (Width * 2);


    /* remember we are adding to a DWORD pointer */
    RowInc /= sizeof(DWORD);


    UVRowInc = Width / 4;
    UVRowInc /= sizeof(BYTE);



    /* loop copying each scanline */
    for (i = 0; i < InputHeight; i++) {

        /* loop copying two pixels at a time */
        for (j = Width ; j > 0; j -= 4) {

            /*
             * get four pixels and convert to 15-bpp YUV
             */

            dwYPixel = *pYSrc++;
            bUPixel = *pUSrc++;
            bVPixel = *pVSrc++;


            /*
             * dwY(U or V)Pixel now has four pixels, in this layout (MSB..LSB):
             *
             *  Y3 Y2 Y1 Y0
             *  V0
             *  U0
             *
             * convert to 4 yuv555 words and lookup in xlate table
             */

            /* get common u0 and v0 components to lower 10 bits */
            uv55 = ((bUPixel & 0xf8) << 2) |
                    ((bVPixel & 0xf8) >> 3);


            /* build each yuv-555 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwPixel = pXlate[ ((dwYPixel & 0xf8) << 7) | uv55 ] |
                      (pXlate[((dwYPixel & 0xf800) >> 1) | uv55 ] << 16);

            /* write two pixels to destination */
            *pDst++ = dwPixel;


            /* build each yuv-655 value by truncating
             * y to 5 bits and adding the common u and v bits,
             * look up to convert to rgb, and combine two pixels
             * into one dword
             */
            dwPixel = pXlate[ ((dwYPixel & 0xf80000) >> 9) | uv55 ] |
                      (pXlate[((dwYPixel & 0xf8000000) >> 17) | uv55 ] << 16);

            /* write two pixels to destination */
            *pDst++ = dwPixel;



        } // loop per 4 pixels

        if ((i & 0x3) != 0x03)
        {
            pUSrc -= UVRowInc;
            pVSrc -= UVRowInc;
        }

        /* move dest pointer back to next line */
        pDst -= RowInc;

    } // loop per row

}
#endif//COLOR_MODIFY
#endif//TOSHIBA



VOID FreeXlate(PINSTINFO pinst)
{

    GlobalFree(GlobalHandle(pinst->pXlate));

    pinst->pXlate = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\1394dcam\dbg.c ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    dbg.c

Abstract:

    Debug Code for 1394 drivers.

Environment:

    kernel mode only

Notes:

Revision History:

    5-Sep-95

--*/

#include "wdm.h"
#include "dbg.h"


#if DBG

struct LOG_ENTRY {
    CHAR     le_name[4];      // Identifying string
    ULONG    le_info1;        // entry specific info
    ULONG    le_info2;        // entry specific info
    ULONG    le_info3;        // entry specific info
}; 


struct LOG_ENTRY *LogStart = 0;    // No log yet
struct LOG_ENTRY *LogPtr;
struct LOG_ENTRY *LogEnd;


#endif


VOID 
Debug_LogEntry(
    IN CHAR *Name, 
    IN ULONG Info1, 
    IN ULONG Info2, 
    IN ULONG Info3
    )

/*++

Routine Description:

    Adds an Entry to log.

Arguments:

Return Value:

    None.

--*/
{

#if DBG

    if (LogStart == 0)
        return;

    if (LogPtr > LogStart)
        LogPtr -= 1;    // Decrement to next entry
    else
        LogPtr = LogEnd;

    RtlCopyMemory(LogPtr->le_name, Name, 4);
    LogPtr->le_info1 = Info1;
    LogPtr->le_info2 = Info2;
    LogPtr->le_info3 = Info3;

#endif

    return;
}

VOID
Debug_LogInit(
    )

/*++

Routine Description:

    Init the debug log - remember interesting information in a circular buffer

Arguments:
    
Return Value:

    None.

--*/
{
    ULONG logSize = 4096;    //1 page of log entries

#if DBG

    LogStart = ExAllocatePoolWithTag(NonPagedPool, logSize, 'macd'); 

    if (LogStart) {
        LogPtr = LogStart;

        // Point the end (and first entry) 1 entry from the end of the segment
        LogEnd = LogStart + (logSize / sizeof(struct LOG_ENTRY)) - 1;
    }

#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\1394dcam\datapkt.c ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    DataPkt.c

Abstract:

    Stream class based WDM driver for 1934 Desktop Camera.
    This file contains code to handle the stream class packets.

Author:

    Yee J. Wu 24-Jun-98

Environment:

    Kernel mode only

Revision History:


--*/


#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "wdm.h"       // for DbgBreakPoint() defined in dbg.h
#include "dbg.h"
#include "dcamdef.h"
#include "dcampkt.h"
#include "sonydcam.h"

extern CAMERA_ISOCH_INFO IsochInfoTable[];



#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, DCamSurpriseRemoval)
    #pragma alloc_text(PAGE, DCamReceiveDataPacket)
#endif



NTSTATUS
DCamCancelOnePacketCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    PISOCH_DESCRIPTOR IsochDescriptor
    )
/*++

Routine Description:

    Completion routine for detach an isoch descriptor associate with a pending read SRB.
    Will cancel the pending SRB here if detaching descriptor has suceeded.

Arguments:

    DriverObject - Pointer to driver object created by system.
    pIrp - Allocated locally, need to be free here.
    IsochDescriptor - Isoch descriptor containing the SRB to be cancelled.

Return Value:

    None.

--*/
{
    PHW_STREAM_REQUEST_BLOCK pSrbToCancel;
    PISOCH_DESCRIPTOR_RESERVED IsochDescriptorReserved;
    PDCAM_EXTENSION pDevExt;


    if(STATUS_SUCCESS != pIrp->IoStatus.Status) {
        ERROR_LOG(("DCamCancelOnePacketCR: Detach buffer failed with pIrp->IoStatus.Status= %x (! STATUS_SUCCESS) \n", pIrp->IoStatus.Status));
        ASSERT(STATUS_SUCCESS == pIrp->IoStatus.Status);

    } else {
        IsochDescriptorReserved = (PISOCH_DESCRIPTOR_RESERVED) &IsochDescriptor->DeviceReserved[0];
        pSrbToCancel = IsochDescriptorReserved->Srb;
        pDevExt = (PDCAM_EXTENSION) pSrbToCancel->HwDeviceExtension;

        IsochDescriptorReserved->Flags |= STATE_SRB_IS_COMPLETE;

        pSrbToCancel->CommandData.DataBufferArray->DataUsed = 0;
        pSrbToCancel->ActualBytesTransferred = 0;
        pSrbToCancel->Status = pDevExt->bDevRemoved ? STATUS_DEVICE_REMOVED : STATUS_CANCELLED;

        DbgMsg2(("DCamCancelOnePacketCR: SRB %x, Status %x, IsochDesc %x, Reserved %x cancelled\n",
            pSrbToCancel, pSrbToCancel->Status, IsochDescriptor, IsochDescriptorReserved));

        StreamClassStreamNotification(
            StreamRequestComplete,
            pSrbToCancel->StreamObject,
            pSrbToCancel);

        ExFreePool(IsochDescriptor);
    }

    // Allocated locally so free it.
    IoFreeIrp(pIrp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
DCamDetachAndCancelOnePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrbToCancel,
    PISOCH_DESCRIPTOR           IsochDescriptorToDetach,
    HANDLE                      hResource,
    PDEVICE_OBJECT              pBusDeviceObject
    )
/*++

Routine Description:

    Detach an isoch descriptor and then cancel pending SRB in the completion routine.

Arguments:

    pSrbToCancel - Pointer to SRB to cancel
    IsochDescriptorToDetach - Iosch descriptor to detach
    hResource - isoch resource allocated
    hBusDeviceObject - bus device object

Return Value:

    None.

--*/
{
    PDCAM_EXTENSION pDevExt;
    PIO_STACK_LOCATION NextIrpStack;
    NTSTATUS Status;
    PIRB     pIrb;
    PIRP     pIrp;


    DbgMsg2(("\'DCamDetachAndCancelOnePacket: pSrbTocancel %x, detaching IsochDescriptorToDetach %x\n", pSrbToCancel, IsochDescriptorToDetach));

    pDevExt = (PDCAM_EXTENSION) pSrbToCancel->HwDeviceExtension;
    pIrp = IoAllocateIrp(pDevExt->BusDeviceObject->StackSize, FALSE);
    ASSERT(pIrp);
    if(!pIrp)
        return;

    pIrb = pSrbToCancel->SRBExtension;

    pIrb->Flags           = 0;
    pIrb->FunctionNumber  = REQUEST_ISOCH_DETACH_BUFFERS;
    pIrb->u.IsochDetachBuffers.hResource            = hResource;
    pIrb->u.IsochDetachBuffers.nNumberOfDescriptors = 1;
    pIrb->u.IsochDetachBuffers.pIsochDescriptor     = IsochDescriptorToDetach;

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pIrb;

    IoSetCompletionRoutine(
        pIrp,
        DCamCancelOnePacketCR,
        IsochDescriptorToDetach,
        TRUE,
        TRUE,
        TRUE
        );

    Status =
        IoCallDriver(
            pBusDeviceObject,
            pIrp
            );

    ASSERT(Status == STATUS_SUCCESS || Status == STATUS_PENDING);
}


VOID
DCamCancelOnePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrbToCancel
    )
/*++

Routine Description:

    This routine is called to cancel a pending streaming SRB.  This is likely to
    happen when transitioning from PAUSE to STOP state.
    Note: This routine is called at DISPATCH_LEVEL !!

Arguments:

    pSrbToCancel - Pointer to SRB to cancel

Return Value:

    None.

--*/
{
    PHW_STREAM_REQUEST_BLOCK pSrbInQ;
    PISOCH_DESCRIPTOR        IsochDescriptorToDetach;

    PDCAM_EXTENSION pDevExt;
    PSTREAMEX       pStrmEx;
    PLIST_ENTRY     pEntry;  // Pointer to an isoch decriptor reserved structure

    KIRQL oldIrql;
    BOOL  Found;


    pDevExt = (PDCAM_EXTENSION) pSrbToCancel->HwDeviceExtension;
    ASSERT(pDevExt);
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
    ASSERT(pStrmEx);

    // Nothing to cancel
    if(pStrmEx == NULL) {
        return;
    }


    //
    // We only expect stream SRB, but not device SRB.
    //
    if ( (pSrbToCancel->Flags & SRB_HW_FLAGS_STREAM_REQUEST) != SRB_HW_FLAGS_STREAM_REQUEST) {
        ERROR_LOG(("DCamCancelOnePacket: Cannot cancel Device SRB %x\n", pSrbToCancel));
        ASSERT( (pSrbToCancel->Flags & SRB_HW_FLAGS_STREAM_REQUEST) == SRB_HW_FLAGS_STREAM_REQUEST );
        return;
    }


    //
    // Loop through the linked list from the beginning to end,
    // trying to find the SRB to cancel
    //
    KeAcquireSpinLock(&pDevExt->IsochDescriptorLock, &oldIrql);

    Found = FALSE;
    pEntry = pDevExt->IsochDescriptorList.Flink;

    while (pEntry != &pDevExt->IsochDescriptorList) {

        pSrbInQ = ((PISOCH_DESCRIPTOR_RESERVED)pEntry)->Srb;
        IsochDescriptorToDetach = \
            (PISOCH_DESCRIPTOR) ( ((PUCHAR) pEntry) -
            FIELDOFFSET(ISOCH_DESCRIPTOR, DeviceReserved[0]));

        if(pSrbToCancel == pSrbInQ) {
            // If we are in RUN state, we could be competing with IsochCallback;
            // Whichever grabs and change STATE_DETACHING_BUFFERS will detach.
            if(((PISOCH_DESCRIPTOR_RESERVED) pEntry)->Flags & (STATE_SRB_IS_COMPLETE | STATE_DETACHING_BUFFERS)) {
                Found = FALSE; // IsochCallback are detaching it (we lost our chance).
                ERROR_LOG(("DCamCancelOnePacket: pSrbToCancel %x, Descriptor %x,  Reserved %x already detaching or completed\n",
                    pSrbToCancel, IsochDescriptorToDetach, pEntry));

            } else {
                ((PISOCH_DESCRIPTOR_RESERVED) pEntry)->Flags |= STATE_DETACHING_BUFFERS;
#if DBG
                // Should not have been detached.
                ASSERT((IsochDescriptorToDetach->DeviceReserved[7] == 0x87654321));
                IsochDescriptorToDetach->DeviceReserved[7]++;
#endif
                RemoveEntryList(pEntry);
                InterlockedDecrement(&pDevExt->PendingReadCount);
                Found = TRUE;
            }
            break;
        }

        pEntry = pEntry->Flink;  // Next
    }
    KeReleaseSpinLock (&pDevExt->IsochDescriptorLock, oldIrql);


    //
    // Since we are in DISPATCH level, we cannot do sync operation;
    // so we will complete this asynchronously in the completion routine.
    //
    if (Found) {

        DCamDetachAndCancelOnePacket(
            pSrbToCancel,
            IsochDescriptorToDetach,
            pDevExt->hResource,
            pDevExt->BusDeviceObject);

    } else {
        ERROR_LOG(("DCamCancelOnePacket: pSrbToCancel %x is not in our list!\n", pSrbToCancel));
        ASSERT(Found);
    }
}

VOID
DCamCancelAllPackets(
    PHW_STREAM_REQUEST_BLOCK pSrb,
    PDCAM_EXTENSION pDevExt,
    LONG *plPendingReadCount
    )
/*++

Routine Description:

    This routine is use to cancel all pending IRP.
    Can be called at DISPATCH_LEVEL.

Arguments:

    pSrbToCancel - Pointer to SRB to cancel
    pDevExt - Device's contect
    plPendingReadCount - Number of pending read

Return Value:

    None.

--*/
{
    PHW_STREAM_REQUEST_BLOCK pSrbToCancel;
    PISOCH_DESCRIPTOR        IsochDescriptorToDetach;
    PLIST_ENTRY pEntry;
    KIRQL       oldIrql;

    PSTREAMEX pStrmEx;


    pStrmEx = pDevExt->pStrmEx;

    // Nothing to cancel
    if(pStrmEx == NULL) {
        return;
    }


    //
    // Loop through the linked list from the beginning to end,
    // trying to find the SRB to cancel
    //
    KeAcquireSpinLock(&pDevExt->IsochDescriptorLock, &oldIrql);
    pEntry = pDevExt->IsochDescriptorList.Flink;

    while (pEntry != &pDevExt->IsochDescriptorList) {

        pSrbToCancel = ((PISOCH_DESCRIPTOR_RESERVED)pEntry)->Srb;
        IsochDescriptorToDetach = \
            (PISOCH_DESCRIPTOR) ( ((PUCHAR) pEntry) -
            FIELDOFFSET(ISOCH_DESCRIPTOR, DeviceReserved[0]));


        if(((PISOCH_DESCRIPTOR_RESERVED) pEntry)->Flags & (STATE_SRB_IS_COMPLETE | STATE_DETACHING_BUFFERS)) {
            // Skip this one since it is already in detaching phase or completed.
            ERROR_LOG(("DCamCancelAllPacket: pSrbToCancel %x, Descriptor %x,  Reserved %x already detaching or completed\n",
                pSrbToCancel, IsochDescriptorToDetach, pEntry));

            pEntry = pEntry->Flink;  // next

        } else {
            ((PISOCH_DESCRIPTOR_RESERVED) pEntry)->Flags |= STATE_DETACHING_BUFFERS;
#if DBG
            // Should not have been detached.
            ASSERT((IsochDescriptorToDetach->DeviceReserved[7] == 0x87654321));
            IsochDescriptorToDetach->DeviceReserved[7]++;
#endif
            RemoveEntryList(pEntry);
            InterlockedDecrement(plPendingReadCount);
            DbgMsg2(("DCamCancelAllPackets: pSrbToCancel %x, Descriptor %x, Reserved %x\n",
                pSrbToCancel, IsochDescriptorToDetach, pEntry));

            pEntry = pEntry->Flink;  // pEntry is deleted in DCamDetachAndCancelOnePacket(); so get next here.

            DCamDetachAndCancelOnePacket(
                pSrbToCancel,
                IsochDescriptorToDetach,
                pDevExt->hResource,
                pDevExt->BusDeviceObject);
        }
    }

    KeReleaseSpinLock (&pDevExt->IsochDescriptorLock, oldIrql);


    pSrb->Status = STATUS_SUCCESS;
    DbgMsg1(("DCamCancelAllPackets: Complete pSrb %x, Status %x\n", pSrb, pSrb->Status));

    COMPLETE_SRB(pSrb)
}



VOID
DCamSurpriseRemoval(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )

/*++

Routine Description:

    Response to SRB_SURPRISE_REMOVAL.

Arguments:

    pSrb - Pointer to the stream request block


Return Value:

    None.

--*/

{

    PIRP pIrp;
    PIRB pIrb;
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    NTSTATUS Status, StatusWait;

    PAGED_CODE();

    pIrb = (PIRB) pSrb->SRBExtension;
    ASSERT(pIrb);
    pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;
    ASSERT(pDevExt);


    //
    // Set this to stop accepting incoming read.
    //

    pDevExt->bDevRemoved = TRUE;


    //
    // Wait for currect read to be attached so we cancel them all.
    //

    pStrmEx = pDevExt->pStrmEx;
    if(pStrmEx) {
        // Make sure that this structure is still valid.
        if(pStrmEx->pVideoInfoHeader) {
            StatusWait = KeWaitForSingleObject( &pStrmEx->hMutex, Executive, KernelMode, FALSE, 0 );
            KeReleaseMutex(&pStrmEx->hMutex, FALSE);
        }
    }

    pIrp = IoAllocateIrp(pDevExt->BusDeviceObject->StackSize, FALSE);
    if(!pIrp) {
        ERROR_LOG(("DCamSurpriseRemovalPacket: faile to get resource; pIrb=%x, pDevExt=%x, pIrp\n", pIrb, pDevExt, pIrp));
        pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
        StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
        return;
    }


    //
    // un-register a bus reset callback notification
    //

    pIrb->FunctionNumber = REQUEST_BUS_RESET_NOTIFICATION;
    pIrb->Flags = 0;
    pIrb->u.BusResetNotification.fulFlags = DEREGISTER_NOTIFICATION_ROUTINE;
    pIrb->u.BusResetNotification.ResetRoutine = (PBUS_BUS_RESET_NOTIFICATION) DCamBusResetNotification;
    pIrb->u.BusResetNotification.ResetContext = 0;
    Status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);
    if(Status) {
        ERROR_LOG(("DCamSurpriseRemoval: Status %x while trying to deregister bus reset notification.\n", Status));
    }


    //
    // Get new generation number
    //

    pIrb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
    pIrb->Flags = 0;
    Status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);
    if(Status) {
        ERROR_LOG(("DCamSurpriseRemoval: Status %x while trying to get generation number.\n", Status));
    } else {
        DbgMsg1(("DCamSurpriseRemoval: pDevExt %x, Generation number from %d to %d\n",
            pDevExt, pDevExt->CurrentGeneration, pIrb->u.GetGenerationCount.GenerationCount));
        InterlockedExchange(&pDevExt->CurrentGeneration, pIrb->u.GetGenerationCount.GenerationCount);
    }


    if(pStrmEx) {
        //
        // Stop isoch transmission so we can detach buffers and cancel pending SRBs
        //
        pIrb->FunctionNumber        = REQUEST_ISOCH_STOP;
        pIrb->Flags                 = 0;
        pIrb->u.IsochStop.hResource = pDevExt->hResource;
        pIrb->u.IsochStop.fulFlags  = 0;
        Status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);
        if(Status) {
            ERROR_LOG(("DCamSurpriseRemoval: Status %x while trying to ISOCH_STOP.\n", Status));
        }
        IoFreeIrp(pIrp);

        DCamCancelAllPackets(
            pSrb,
            pDevExt,
            &pDevExt->PendingReadCount
            );

    } else {
        IoFreeIrp(pIrp);
        StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
    }

}


NTSTATUS
DCamAttachBufferCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PISOCH_DESCRIPTOR IsochDescriptor
    )
/*++

Routine Description:

    This routine is the completion routine from attaching a bufffer to lower driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    pIrp - Irp that just completed

    pDCamIoContext - A structure that contain the context of this IO completion routine.

Return Value:

    None.

--*/

{
    PHW_STREAM_REQUEST_BLOCK pSrb;
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    NTSTATUS Status;
    PIRB pIrb;
    PISOCH_DESCRIPTOR_RESERVED IsochDescriptorReserved;
    KIRQL oldIrql;


    pDevExt = (PDCAM_EXTENSION) IsochDescriptor->Context1;
    ASSERT(pDevExt);
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
    ASSERT(pStrmEx);
    IsochDescriptorReserved = (PISOCH_DESCRIPTOR_RESERVED) &IsochDescriptor->DeviceReserved[0];
    ASSERT(IsochDescriptorReserved);
    pSrb    = IsochDescriptorReserved->Srb;
    ASSERT(pSrb);
    pIrb    = (PIRB) pSrb->SRBExtension;

    DbgMsg3(("\'DCamAttachBufferCR: completed KSSTATE=%d; pIrp->IoStatus.Status=%x; pSrb=%x\n",
        pStrmEx->KSState, pIrp->IoStatus.Status, pSrb));


    //
    // Attaching a buffer return with error.
    //
    if(pIrp->IoStatus.Status) {

        ERROR_LOG(("DCamAttachBufferCR: pIrp->IoStatus.Status=%x (STATUS_PENDING=%x); complete SRB with this status.\n",
             pIrp->IoStatus.Status, STATUS_PENDING));
        ASSERT(pIrp->IoStatus.Status == STATUS_SUCCESS);


        if(!(IsochDescriptorReserved->Flags & STATE_SRB_IS_COMPLETE)) {

            ASSERT(((IsochDescriptorReserved->Flags & STATE_SRB_IS_COMPLETE) != STATE_SRB_IS_COMPLETE));

            IsochDescriptorReserved->Flags |= STATE_SRB_IS_COMPLETE;
            pSrb->Status = pIrp->IoStatus.Status;  // Read is completed with error status.

            KeAcquireSpinLock(&pDevExt->IsochDescriptorLock, &oldIrql);
            RemoveEntryList(&IsochDescriptorReserved->DescriptorList);  InterlockedDecrement(&pDevExt->PendingReadCount);
            KeReleaseSpinLock(&pDevExt->IsochDescriptorLock, oldIrql);

            ExFreePool(IsochDescriptor);
            StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb);

            KeAcquireSpinLock(&pDevExt->IsochWaitingLock, &oldIrql);

            //
            // If we failed to attach (rtn with failed status),
            // removed this entry, and
            // pull one out of the waiting list if not yet exceeded out limit.
            //
            if (!IsListEmpty(&pDevExt->IsochWaitingList) && pDevExt->PendingReadCount >= MAX_BUFFERS_SUPPLIED) {

                //
                // We had someone blocked waiting for us to complete.  Pull
                // them off the waiting list and get them running
                //
                DbgMsg3(("\'DCamAttachBufferCR: Dequeueing request - Read Count=%d\n", pDevExt->PendingReadCount));
                IsochDescriptorReserved = \
                    (PISOCH_DESCRIPTOR_RESERVED) RemoveHeadList(
                       &pDevExt->IsochWaitingList
                        );

                KeReleaseSpinLock(&pDevExt->IsochWaitingLock, oldIrql);

                IsochDescriptor = \
                    (PISOCH_DESCRIPTOR) (((PUCHAR) IsochDescriptorReserved) -
                        FIELDOFFSET(ISOCH_DESCRIPTOR, DeviceReserved[0]));
                DCamReadStreamWorker(IsochDescriptorReserved->Srb, IsochDescriptor);
            } else {
                KeReleaseSpinLock(&pDevExt->IsochWaitingLock, oldIrql);
            }

        } else {

            // Race condition ?  or a valid error code?
            ERROR_LOG(("DCamAttachBufferCR: IsochDescriptorReserved->Flags contain STATE_SRB_IS_COMPLETE\n"));
            ASSERT(FALSE);
        }

    }


    //
    // Ealier when we set to RUN state, it might have failed with
    // STATUS_INSUFFICIENT_RESOURCE due to no buffer attached;
    // we have at least one now, ask controll to start listen and
    // fill and return our buffer.
    //
    if(pDevExt->bNeedToListen) {
        PIRB pIrb2;
        PIRP pIrp2;
        PDCAM_IO_CONTEXT pDCamIoContext;
        PIO_STACK_LOCATION NextIrpStack;


        if(!DCamAllocateIrbIrpAndContext(&pDCamIoContext, &pIrb2, &pIrp2, pDevExt->BusDeviceObject->StackSize)) {
            ERROR_LOG(("DCamAttachBufferCR: Want to stat Listening but no resource !!\n"));
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        pDevExt->bNeedToListen = FALSE;
        DbgMsg2(("\'DCamAttachBufferCR: ##### pDevExt->bNeedToListen\n"));
        pDCamIoContext->pDevExt     = pDevExt;
        pDCamIoContext->pIrb        = pIrb2;

        pIrb2->FunctionNumber = REQUEST_ISOCH_LISTEN;
        pIrb2->Flags = 0;
        pIrb2->u.IsochListen.hResource = pDevExt->hResource;
        pIrb2->u.IsochListen.fulFlags = 0;

        NextIrpStack = IoGetNextIrpStackLocation(pIrp2);
        NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
        NextIrpStack->Parameters.Others.Argument1 = pIrb2;

        pDevExt->lRetries = RETRY_COUNT;

        IoSetCompletionRoutine(
            pIrp2,
            DCamStartListenCR,
            pDCamIoContext,
            TRUE,
            TRUE,
            TRUE
            );

        Status =
            IoCallDriver(
                pDevExt->BusDeviceObject,
                pIrp2);
    }

    // No resource to freed.
    // Resource (pIrb is from original SRB)


    return STATUS_MORE_PROCESSING_REQUIRED;

    //
    // The attached SRB read will be completed in IoschCallback().
    //
}

NTSTATUS
DCamReSubmitPacketCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PISOCH_DESCRIPTOR IsochDescriptor
    )
/*++

Routine Description:

    This routine is called after a packet is detach and
    will be attached here to complete the resubmission of
    packet after a isoch. resource change.

Arguments:

    DriverObject - Pointer to driver object created by system.
    pIrp - Irp that just completed
    pDCamIoContext - A structure that contain the context of this IO completion routine.

Return Value:

    None.

--*/

{
    PIRB pIrb;
    PIO_STACK_LOCATION NextIrpStack;
    PDCAM_EXTENSION pDevExt;
    PISOCH_DESCRIPTOR_RESERVED IsochDescriptorReserved;
    NTSTATUS Status;



    pDevExt = IsochDescriptor->Context1;
    ASSERT(pDevExt);

    pIrb = (PIRB) IsochDescriptor->DeviceReserved[6];
    ASSERT(pIrb);

    IsochDescriptorReserved = (PISOCH_DESCRIPTOR_RESERVED) &IsochDescriptor->DeviceReserved[0];

    //
    // Detached, so unmark it.
    //

    IsochDescriptorReserved->Flags &= ~STATE_DETACHING_BUFFERS;

    DbgMsg2(("\'DCamReSubmitPacketCR: ReSubmit pDevExt %x, pIrb %x, hResource %x, IsochDescriptor %x, IsochDescriptorReserved %x\n",
        pDevExt, pIrb, pDevExt->hResource, IsochDescriptor, IsochDescriptorReserved));


#if DBG
    //
    // Put signatures and use these count to track if the IsochDescriptor
    // has been attached or detached unexpectely.
    //
    // When attach, [4]++  (DCamReadStreamWorker(), DCamReSumbitPacketCR())
    //      detach, [7]++  (DCamIsochcallback(), DCamCancelPacketCR(), DCamResubmitPacket())
    //

    IsochDescriptor->DeviceReserved[4] = 0x12345678;
    IsochDescriptor->DeviceReserved[7] = 0x87654321;
#endif

    //
    // Attach descriptor onto our pending descriptor list
    //

    ExInterlockedInsertTailList(
       &pDevExt->IsochDescriptorList,
       &IsochDescriptorReserved->DescriptorList,
       &pDevExt->IsochDescriptorLock
       );

    pIrb->FunctionNumber           = REQUEST_ISOCH_ATTACH_BUFFERS;
    pIrb->Flags                    = 0;
    pIrb->u.IsochAttachBuffers.hResource = pDevExt->hResource;
    pIrb->u.IsochAttachBuffers.nNumberOfDescriptors = 1;
    pIrb->u.IsochAttachBuffers.pIsochDescriptor = IsochDescriptor;

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pIrb;


    IoSetCompletionRoutine(
        pIrp,
        DCamAttachBufferCR,
        IsochDescriptor,
        TRUE,
        TRUE,
        TRUE
        );

    Status =
        IoCallDriver(
            pDevExt->BusDeviceObject,
            pIrp
            );

    ASSERT(Status == STATUS_SUCCESS || Status == STATUS_PENDING);

    return STATUS_MORE_PROCESSING_REQUIRED;  // Complete Asynchronously in DCamAttachBufferCR

}


NTSTATUS
DCamReSubmitPacket(
    HANDLE hStaleResource,
    PDCAM_EXTENSION pDevExt,
    PSTREAMEX pStrmEx,
    LONG cntPendingRead
    )

/*++

Routine Description:

    Due to a bus reset, if a channel number has changed (subsequently, iso resource
    change too), we must detach and re-attach pending packet(s).
    While this function is executed, incoming SRB_READ is blocked and isoch callback
    are returned and not processed (we are resubmiting them).

Arguments:

    hStaleResource - staled isoch resource
    pDevExt - Device's Extension
    pStrmEx - Stremaing extension
    cntPendingRead - Number of pending packets

Return Value:

    NTSTATUS.

--*/

{
    PIRB pIrb;
    PIRP pIrp;
    PIO_STACK_LOCATION NextIrpStack;
    PISOCH_DESCRIPTOR IsochDescriptor;
    PISOCH_DESCRIPTOR_RESERVED IsochDescriptorReserved;
    NTSTATUS Status = STATUS_SUCCESS;
    KIRQL oldIrql;


    DbgMsg1(("DCamReSubmitPacket: pDevExt %x, pStrmEx %x, PendingCount %d\n", pDevExt, pStrmEx, cntPendingRead));

    for(; cntPendingRead > 0; cntPendingRead--) {

        if(!IsListEmpty(&pDevExt->IsochDescriptorList)) {

            //
            // Synchronization note:
            //
            // We are competing with cancel packet routine in the
            // event of device removal or setting to STOP state.
            // which ever got the spin lock to set DEATCH_BUFFER
            // flag take ownership completing the Irp/IsochDescriptor.
            //

            KeAcquireSpinLock(&pDevExt->IsochDescriptorLock, &oldIrql);
            IsochDescriptorReserved = (PISOCH_DESCRIPTOR_RESERVED) RemoveHeadList(&pDevExt->IsochDescriptorList);

            if((IsochDescriptorReserved->Flags & (STATE_SRB_IS_COMPLETE | STATE_DETACHING_BUFFERS))) {
                ERROR_LOG(("DCamReSubmitPacket: Flags %x aleady mark STATE_SRB_IS_COMPLETE | STATE_DETACHING_BUFFERS\n", IsochDescriptorReserved->Flags));
                ASSERT(( !(IsochDescriptorReserved->Flags & (STATE_SRB_IS_COMPLETE | STATE_DETACHING_BUFFERS))));\
                //Put it back since it has been detached.
                InsertTailList(&pDevExt->IsochDescriptorList, &IsochDescriptorReserved->DescriptorList);

                KeReleaseSpinLock(&pDevExt->IsochDescriptorLock, oldIrql);
                continue;
            }
            IsochDescriptorReserved->Flags |= STATE_DETACHING_BUFFERS;
            KeReleaseSpinLock(&pDevExt->IsochDescriptorLock, oldIrql);

            IsochDescriptor = (PISOCH_DESCRIPTOR) (((PUCHAR) IsochDescriptorReserved) - FIELDOFFSET(ISOCH_DESCRIPTOR, DeviceReserved[0]));

            pIrp = (PIRP) IsochDescriptor->DeviceReserved[5];
            ASSERT(pIrp);
            pIrb = (PIRB) IsochDescriptor->DeviceReserved[6];
            ASSERT(pIrb);


            DbgMsg1(("DCamReSubmitPacket: detaching IsochDescriptor %x IsochDescriptorReserved %x, pSrb %x\n",
                        IsochDescriptor, IsochDescriptorReserved, IsochDescriptorReserved->Srb));

#if DBG
            // Should not have been detached
            ASSERT((IsochDescriptor->DeviceReserved[7] == 0x87654321));
            IsochDescriptor->DeviceReserved[7]++;
#endif
            pIrb->FunctionNumber           = REQUEST_ISOCH_DETACH_BUFFERS;
            pIrb->Flags                    = 0;
            pIrb->u.IsochDetachBuffers.hResource = hStaleResource;
            pIrb->u.IsochDetachBuffers.nNumberOfDescriptors = 1;
            pIrb->u.IsochDetachBuffers.pIsochDescriptor = IsochDescriptor;

            NextIrpStack = IoGetNextIrpStackLocation(pIrp);
            NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
            NextIrpStack->Parameters.Others.Argument1 = pIrb;

            IoSetCompletionRoutine(
                pIrp,
                DCamReSubmitPacketCR,
                IsochDescriptor,
                TRUE,
                TRUE,
                TRUE
                );

            Status =
                IoCallDriver(
                    pDevExt->BusDeviceObject,
                    pIrp
                    );

            ASSERT(Status == STATUS_SUCCESS || Status == STATUS_PENDING);

        } else {
            ERROR_LOG(("PendingCount %d, but list is empty!!\n", cntPendingRead));
            ASSERT(cntPendingRead == 0);
        }

    }  // for()

    return Status;
}



VOID
DCamReadStreamWorker(
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PISOCH_DESCRIPTOR IsochDescriptor
    )

/*++

Routine Description:

    Does most of the work for handling reads via Attach buffers

Arguments:

    Srb - Pointer to Stream request block

    IsochDescriptor - Pointer to IsochDescriptor to be used

Return Value:

    Nothing

--*/

{

    PIRB pIrb;
    PIRP pIrp;
    PIO_STACK_LOCATION NextIrpStack;
    PDCAM_EXTENSION pDevExt;
    PISOCH_DESCRIPTOR_RESERVED IsochDescriptorReserved;
    NTSTATUS Status;


    pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;
    pIrp = (PIRP) IsochDescriptor->DeviceReserved[5];
    ASSERT(pIrp);
    pIrb = (PIRB) IsochDescriptor->DeviceReserved[6];
    ASSERT(pIrb);
#if DBG
    // track number time the same IsochDescriptor are attaching; should only be one.
    IsochDescriptor->DeviceReserved[4]++;
#endif

    //
    // It is pending and will be completed in isoch callback or cancelled.
    //

    pSrb->Status = STATUS_PENDING;

    IsochDescriptorReserved = (PISOCH_DESCRIPTOR_RESERVED) &IsochDescriptor->DeviceReserved[0];

    DbgMsg3(("\'DCamReadStreamWorker: enter with pSrb = %x, pDevExt=0x%x\n", pSrb, pDevExt));

    //
    // Attach descriptor onto our pending descriptor list
    //

    ExInterlockedInsertTailList(
       &pDevExt->IsochDescriptorList,
       &IsochDescriptorReserved->DescriptorList,
       &pDevExt->IsochDescriptorLock
       );

    pIrb->FunctionNumber           = REQUEST_ISOCH_ATTACH_BUFFERS;
    pIrb->Flags                    = 0;
    pIrb->u.IsochAttachBuffers.hResource = pDevExt->hResource;
    pIrb->u.IsochAttachBuffers.nNumberOfDescriptors = 1;
    pIrb->u.IsochAttachBuffers.pIsochDescriptor = IsochDescriptor;

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pIrb;


    IoSetCompletionRoutine(
        pIrp,
        DCamAttachBufferCR,
        IsochDescriptor,
        TRUE,
        TRUE,
        TRUE
        );

    Status =
        IoCallDriver(
            pDevExt->BusDeviceObject,
            pIrp
            );

    ASSERT(Status == STATUS_SUCCESS || Status == STATUS_PENDING);

    return;  // Complete Asynchronously in IoCompletionRoutine*
}




VOID
DCamReadStream(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Called when an Read Data Srb request is received

Arguments:

    Srb - Pointer to Stream request block

Return Value:

    Nothing

--*/

{

    PIRB pIrb;
    PIRP pIrp;
    KIRQL oldIrql;
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX     pStrmEx;
    PISOCH_DESCRIPTOR IsochDescriptor;
    PISOCH_DESCRIPTOR_RESERVED IsochDescriptorReserved;
    NTSTATUS StatusWait;


    pIrb = (PIRB) Srb->SRBExtension;
    pDevExt = (PDCAM_EXTENSION) Srb->HwDeviceExtension;
    ASSERT(pDevExt != NULL);



    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
    ASSERT(pStrmEx);

    if(pDevExt->bDevRemoved ||
       pStrmEx == NULL) {

        Srb->Status = pDevExt->bDevRemoved ? STATUS_DEVICE_REMOVED : STATUS_UNSUCCESSFUL;
        Srb->ActualBytesTransferred = 0;
        Srb->CommandData.DataBufferArray->DataUsed = 0;
        ERROR_LOG(("DCamReadStream: Failed with Status %x or pStrmEx %x\n", Srb->Status, pStrmEx));

        StreamClassStreamNotification(StreamRequestComplete, Srb->StreamObject, Srb);
        return;
    }

    //
    // Mutext for either StreamIo (SRB_READ) ControlIo (SRB_SET_STREAM_STATE)
    //
    // Non-alertable; wait infinite

    StatusWait = KeWaitForSingleObject( &pStrmEx->hMutex, Executive, KernelMode, FALSE, 0 );
    ASSERT(StatusWait == STATUS_SUCCESS);

    DbgMsg3(("\'%d:%s) DCamReadStream: enter with Srb %x, DevExt %x\n",
            pDevExt->idxDev, pDevExt->pchVendorName, Srb, pDevExt));


    // Rule:
    // Only accept read requests when in either the Pause or Run
    // States.  If Stopped, immediately return the SRB.

    if (pStrmEx->KSState == KSSTATE_STOP ||
        pStrmEx->KSState == KSSTATE_ACQUIRE) {

        DbgMsg2(("\'%d:%s)DCamReadStream: Current KSState(%d) < (%d)=KSSTATE_PAUSE; Srb=0x%x; DevExt=0x%x",
                 pDevExt->idxDev, pDevExt->pchVendorName, pStrmEx->KSState,  KSSTATE_PAUSE, Srb, pDevExt));

        DbgMsg2(("\'DCamReadStream: PendingRead=%d, IsochDescriptorList(%s)\n",
              pDevExt->PendingReadCount, IsListEmpty(&pDevExt->IsochDescriptorList)?"Empty":"!Empty"));

        Srb->Status = STATUS_UNSUCCESSFUL;
        Srb->CommandData.DataBufferArray->DataUsed = 0;
        StreamClassStreamNotification(StreamRequestComplete, Srb->StreamObject, Srb);

        KeReleaseMutex(&pStrmEx->hMutex, FALSE);

        return;
    }


    // Buffer need to be big enough
    if (IsochInfoTable[pStrmEx->idxIsochTable].CompletePictureSize > Srb->CommandData.DataBufferArray->FrameExtent) {

        ASSERT(IsochInfoTable[pStrmEx->idxIsochTable].CompletePictureSize <= Srb->CommandData.DataBufferArray->FrameExtent);
        Srb->Status = STATUS_INVALID_PARAMETER;
        StreamClassStreamNotification(StreamRequestComplete, Srb->StreamObject, Srb);

        KeReleaseMutex(&pStrmEx->hMutex, FALSE);

        return;
    }


    //
    // Use our own IRP
    //
    pIrp = IoAllocateIrp(pDevExt->BusDeviceObject->StackSize, FALSE);
    if(!pIrp) {
        ASSERT(pIrp);
        Srb->Status = STATUS_INSUFFICIENT_RESOURCES;
        return;
    }

    //
    // This structure (IsochDescriptor) has (ULONG) DeviceReserved[8];
    // Its first 4 ULONGs are used by IsochDescriptorReserved,
    // The 6th (index[5]), is used to keep pIrp
    //     7th (index[6]), is used to keep pIrb
    //

    IsochDescriptor = ExAllocatePoolWithTag(NonPagedPool, sizeof(ISOCH_DESCRIPTOR), 'macd');
    if (!IsochDescriptor) {

        ASSERT(FALSE);
        Srb->Status = STATUS_INSUFFICIENT_RESOURCES;
        StreamClassStreamNotification(StreamRequestComplete, Srb->StreamObject, Srb);

        KeReleaseMutex(&pStrmEx->hMutex, FALSE);

        return;
    }


    DbgMsg3(("\'DCamReadStream: IsochDescriptor = %x\n", IsochDescriptor));
    IsochDescriptor->fulFlags = SYNCH_ON_SY;

    DbgMsg3(("\'DCamReadStream: Incoming Mdl = %x\n", Srb->Irp->MdlAddress));
    IsochDescriptor->Mdl = Srb->Irp->MdlAddress;

    // Use size match what we originally requested in AllocateIsoch
    IsochDescriptor->ulLength = IsochInfoTable[pStrmEx->idxIsochTable].CompletePictureSize;
    IsochDescriptor->nMaxBytesPerFrame = IsochInfoTable[pStrmEx->idxIsochTable].QuadletPayloadPerPacket << 2;

    IsochDescriptor->ulSynch = START_OF_PICTURE;
    IsochDescriptor->ulTag = 0;
    IsochDescriptor->Callback = DCamIsochCallback;
    IsochDescriptor->Context1 = pDevExt;
    IsochDescriptor->Context2 = IsochDescriptor;

    //
    // IsochDescriptorReserved is pointed to the DeviceReserved[0];
    // The entire, except the links, are kept in the DeviceReserved[]
    //

    IsochDescriptorReserved = (PISOCH_DESCRIPTOR_RESERVED) &IsochDescriptor->DeviceReserved[0];
    IsochDescriptorReserved->Srb = Srb;
    IsochDescriptorReserved->Flags = 0;

    IsochDescriptor->DeviceReserved[5] = (ULONG_PTR) pIrp;
    IsochDescriptor->DeviceReserved[6] = (ULONG_PTR) pIrb;

#if DBG
    //
    // Put signatures and use these count to track if the IsochDescriptor
    // has been attached or detached unexpectely.
    //
    // When attach, [4]++  (DCamReadStreamWorker(), DCamReSumbitPacketCR())
    //      detach, [7]++  (DCamIsochcallback(), DCamCancelPacketCR(), DCamResubmitPacket())
    //

    IsochDescriptor->DeviceReserved[4] = 0x12345678;
    IsochDescriptor->DeviceReserved[7] = 0x87654321;
#endif

    //
    // Checking here to see if we have enuff resources to put this read
    // down right away.  Since we only allocated N amount of resources
    // from the 1394 stack beneath us, we'll have to stay within that
    // limit and do some of the throttling ourself.
    //

    KeAcquireSpinLock(&pDevExt->IsochWaitingLock, &oldIrql);
    if (InterlockedIncrement(&pDevExt->PendingReadCount) > MAX_BUFFERS_SUPPLIED) {

        //
        // don't have enuff resources to do an attach buffers right now.
        // we'll queue this request and pull it off later when another
        // read completes.
        //

        DbgMsg2(("\'DCamReadStream: Queueing request - Read Count = %x\n", pDevExt->PendingReadCount));
        InsertTailList(
           &pDevExt->IsochWaitingList,
           &IsochDescriptorReserved->DescriptorList
           );

        KeReleaseSpinLock(&pDevExt->IsochWaitingLock, oldIrql);

        KeReleaseMutex(&pStrmEx->hMutex, FALSE);

        return;

    }

    if(pStrmEx->KSState == KSSTATE_PAUSE) {
        DbgMsg2(("\'DCamReadStream: Doing Pre-read in _PAUSE state; Srb %x, pDevExt %x, PendingCount %d\n",
                 Srb, pDevExt, pDevExt->PendingReadCount));
    }

    //
    // Do actual read work here via our Read worker function
    //

    KeReleaseSpinLock(&pDevExt->IsochWaitingLock, oldIrql);
    DCamReadStreamWorker(Srb, IsochDescriptor);

    KeReleaseMutex(&pStrmEx->hMutex, FALSE);

}

VOID
DCamReceiveDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Called with video data packet commands

Arguments:

    Srb - Pointer to Stream request block

Return Value:

    Nothing

--*/

{
    PAGED_CODE();

    //
    // determine the type of packet.
    //

    switch (Srb->Command) {

    case SRB_READ_DATA:

         DbgMsg3(("\'DCamReceiveDataPacket: SRB_READ_DATA\n"));
         DCamReadStream(Srb);

         // This request will be completed asynchronously...

         break;

    case SRB_WRITE_DATA:

         DbgMsg3(("\'DCamReceiveDataPacket: SRB_WRITE_DATA, not used for digital camera.\n"));
         ASSERT(FALSE);

    default:

         //
         // invalid / unsupported command. Fail it as such
         //

         Srb->Status = STATUS_NOT_IMPLEMENTED;

         StreamClassStreamNotification(StreamRequestComplete, Srb->StreamObject, Srb);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\1394dcam\ctrlpkt.c ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    CtrlPkt.c

Abstract:

    Stream class based WDM driver for 1934 Desktop Camera.
    This file contains code to handle the stream class control packets.

Author:   

    Yee J. Wu 24-Jun-98

Environment:

    Kernel mode only

Revision History:


--*/


#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "wdm.h"       // for DbgBreakPoint() defined in dbg.h
#include "dbg.h"
#include "dcamdef.h"
#include "dcampkt.h"
#include "sonydcam.h"

#define WAIT_FOR_SLOW_DEVICE

#ifdef ALLOC_PRAGMA   
     #pragma alloc_text(PAGE, DCamSetKSStateSTOP)
     #pragma alloc_text(PAGE, DCamSetKSStatePAUSE)
     #pragma alloc_text(PAGE, DCamReceiveCtrlPacket)
#endif


NTSTATUS
DCamToStopStateCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PDCAM_IO_CONTEXT pDCamIoContext
    )
/*++

Routine Description:

    
    This is the state machine to set the streaming state to STOP.
    It start at PASSIVE_LEVEL and the lower driver may have raised it to DISPATCH_LEVEL.

Arguments:

    DriverObject - Pointer to driver object created by system.

    pIrp - Irp that just completed

    pDCamIoContext - A structure that contain the context of this IO completion routine.

Return Value:

    None.

--*/

{
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    NTSTATUS Status;
    PIRB pIrb;
    PIO_STACK_LOCATION NextIrpStack;


    if(!pDCamIoContext) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }


    pIrb    = pDCamIoContext->pIrb;
    pDevExt = pDCamIoContext->pDevExt;
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;    

    DbgMsg2(("\'DCamToStopStateCR: completed DeviceState=%d; pIrp->IoStatus.Status=%x\n", 
        pDCamIoContext->DeviceState, pIrp->IoStatus.Status));
    
    // Free MDL
    if(pIrb->FunctionNumber == REQUEST_ASYNC_WRITE) {
        DbgMsg3(("DCamToStopStateCR: IoFreeMdl\n"));
        IoFreeMdl(pIrb->u.AsyncWrite.Mdl);
    }


    // Return error status and free resoruce.
    if(pIrp->IoStatus.Status != STATUS_SUCCESS) {
        if(pDCamIoContext->pSrb) {
            ERROR_LOG(("DCamToStopStateCR: pIrp->IoStatus.Status %x; cancel all packets\n", pIrp->IoStatus.Status));
            // In order to stop streaming, we must cancel all pending IRPs
            // Cancel pending IRPS and complete SRB.
            DCamCancelAllPackets(
                pDCamIoContext->pSrb,
                pDevExt,
                &pDevExt->PendingReadCount
                );
        }
        DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);
        return STATUS_MORE_PROCESSING_REQUIRED; 
    } 

    switch (pDCamIoContext->DeviceState) {   

    case DCAM_STOPSTATE_SET_REQUEST_ISOCH_STOP:
    //
    // Now stop the stream at the device itself
    //
        // Next state:
        pDCamIoContext->DeviceState = DCAM_STOPSTATE_SET_STOP_ISOCH_TRANSMISSION;  // Keep track of device state that we just set.

        pDCamIoContext->RegisterWorkArea.AsULONG = STOP_ISOCH_TRANSMISSION;
        pIrb->FunctionNumber = REQUEST_ASYNC_WRITE;
        pIrb->Flags = 0;
        pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High = INITIAL_REGISTER_SPACE_HI;
        pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =  
              pDevExt->BaseRegister + FIELDOFFSET(CAMERA_REGISTER_MAP, IsoEnable);
        pIrb->u.AsyncWrite.nNumberOfBytesToWrite = sizeof(ULONG);
        pIrb->u.AsyncWrite.nBlockSize = 0;
        pIrb->u.AsyncWrite.fulFlags = 0;
        InterlockedExchange(&pIrb->u.AsyncWrite.ulGeneration, pDevExt->CurrentGeneration);
        
        pIrb->u.AsyncWrite.Mdl = 
            IoAllocateMdl(&pDCamIoContext->RegisterWorkArea, sizeof(ULONG), FALSE, FALSE, NULL);
        MmBuildMdlForNonPagedPool(pIrb->u.AsyncWrite.Mdl);

        // Set once and used again in the completion routine.
        NextIrpStack = IoGetNextIrpStackLocation(pIrp);
        NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
        NextIrpStack->Parameters.Others.Argument1 = pIrb;

        IoSetCompletionRoutine(
            pIrp,
            DCamToStopStateCR,
            pDCamIoContext,
            TRUE,
            TRUE,
            TRUE
            );

        Status = 
            IoCallDriver(
                pDevExt->BusDeviceObject,
                pIrp
                );
        return STATUS_MORE_PROCESSING_REQUIRED; 
        

    case DCAM_STOPSTATE_SET_STOP_ISOCH_TRANSMISSION:
    //
    // Detach all buffers that might still be attached.
    //
        DbgMsg2(("\'DCamToStopStateCR: IsListEmpty()=%s; PendingRead=%d\n",
            IsListEmpty(&pDevExt->IsochDescriptorList) ? "Yes" : "No", pDevExt->PendingReadCount));

        if(pDCamIoContext->pSrb) {
            //
            // Cancel all pending and waiting buffers;
            // and Complete DCamSetKSStateSTOP's SRB
            //
            DCamCancelAllPackets(
                pDCamIoContext->pSrb,
                pDevExt,
                &pDevExt->PendingReadCount
                );            

            // This pDCamIoContext->pSrb will be completed in DCamCancelPacket()
            // But its Irb and Irp and context are freed here.
            DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);
            return STATUS_MORE_PROCESSING_REQUIRED; 

        } else {
            ERROR_LOG(("DCamToStopStateCR:CanNOT call DCamCancelPacket() with a null pSrb\n"));
        }

        break;

    default:
        ERROR_LOG(("\'DCamToStopStateCR: Unknown pDCamIoContext->DeviceState=%d\n", pDCamIoContext->DeviceState));
        ASSERT(FALSE);
        break;
    }

    if(pDCamIoContext->pSrb) {
        pDCamIoContext->pSrb->Status = pIrp->IoStatus.Status == STATUS_SUCCESS ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;        
        COMPLETE_SRB(pDCamIoContext->pSrb)  
    }
    DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);


    return STATUS_MORE_PROCESSING_REQUIRED; 

}



VOID
DCamSetKSStateSTOP(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )

/*++

Routine Description:

    Into STOP streaming state.
       (1) Stop device from steaming (!ISO_ENABLE)
       (2) Stop listening (controller)
       (3) Detach pending read buffer and return with Cancel, and 
           start the waiting read to be put into the pengin read and then Cancel.

Arguments:

    pSrb - Pointer to Stream request block

Return Value:

    Nothing

--*/

{

    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    PIRB pIrb;
    PIRP pIrp;
    PDCAM_IO_CONTEXT pDCamIoContext;
    PIO_STACK_LOCATION NextIrpStack;
    NTSTATUS Status, StatusWait;

    PAGED_CODE();

    pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension; 
    ASSERT(pDevExt);
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;                  
    ASSERT(pStrmEx);


    DbgMsg1(("\'DCamSetKSStateSTOP: Frame captured:%d\n", (DWORD) pStrmEx->FrameCaptured));
    //
    // After this, no more read will be accepted.
    //
    pStrmEx->KSState = KSSTATE_STOP;


    //
    // First stop the stream internally inside the PC's 1394
    // stack
    //
    if(!pDevExt->hResource) {
        pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
        COMPLETE_SRB(pSrb)
        return;
    }

    //
    // Wait for last read to complete.  
    // After KState == KSSTATE_STOP, we will return all SRB_READ.
    //
    StatusWait = KeWaitForSingleObject( &pStrmEx->hMutex, Executive, KernelMode, FALSE, 0 );  
    KeReleaseMutex(&pStrmEx->hMutex, FALSE);


    if(!DCamAllocateIrbIrpAndContext(&pDCamIoContext, &pIrb, &pIrp, pDevExt->BusDeviceObject->StackSize)) {
        pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
        COMPLETE_SRB(pSrb)
        return;
    } 

    pDCamIoContext->DeviceState = DCAM_STOPSTATE_SET_REQUEST_ISOCH_STOP;
    pDCamIoContext->pSrb        = pSrb;               // To do StreamClassStreamNotification()
    pDCamIoContext->pDevExt     = pDevExt;
    pIrb->FunctionNumber        = REQUEST_ISOCH_STOP;
    pIrb->Flags                 = 0;
    pIrb->u.IsochStop.hResource = pDevExt->hResource;
    pIrb->u.IsochStop.fulFlags  = 0;

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pIrb;
      
    IoSetCompletionRoutine(
        pIrp,
         DCamToStopStateCR,
        pDCamIoContext,
        TRUE,
        TRUE,
        TRUE
        );

    Status = 
        IoCallDriver(
            pDevExt->BusDeviceObject,
            pIrp
            );

    ASSERT(Status == STATUS_SUCCESS || Status == STATUS_PENDING);

    return;  // Do StreamClassStreamNotification() in IoCompletionRoutine
}



NTSTATUS
DCamToPauseStateCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PDCAM_IO_CONTEXT pDCamIoContext
    )

/*++

Routine Description:

    This routine is for use with synchronous IRP processing.  
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DriverObject - Pointer to driver object created by system.

    pIrp - Irp that just completed

    pDCamIoContext - A structure that contain the context of this IO completion routine.

Return Value:

    None.

--*/

{
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    PIRB pIrb;

    if(!pDCamIoContext) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    pIrb    = pDCamIoContext->pIrb;
    pDevExt = pDCamIoContext->pDevExt;
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;                  
    ASSERT(pStrmEx);

    DbgMsg2(("\'DCamToPauseStateCR: completed DeviceState=%d; pIrp->IoStatus.Status=%x\n", 
        pDCamIoContext->DeviceState, pIrp->IoStatus.Status));

    // No reason it would failed.
    ASSERT(pIrp->IoStatus.Status == STATUS_SUCCESS);

    switch (pDCamIoContext->DeviceState) {   

    case DCAM_PAUSESTATE_SET_REQUEST_ISOCH_STOP:
         break;
    default:
         ERROR_LOG(("DCamToPauseStateCompletionRoutine: Unknown or unexpected pDCamIoContext->DeviceState=%d\n", pDCamIoContext->DeviceState)); 
         ASSERT(FALSE);
         break;
    }

    //
    // We are here only if switching from RUN->PAUSE,
    // It is alreay set to PAUSE state in DCamSetKSStatePAUSE
    //



    if(pDCamIoContext->pSrb) {
        pDCamIoContext->pSrb->Status = pIrp->IoStatus.Status == STATUS_SUCCESS ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL; 
        COMPLETE_SRB(pDCamIoContext->pSrb)
    }

    DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);
    return STATUS_MORE_PROCESSING_REQUIRED;     

}




VOID
DCamSetKSStatePAUSE(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
/*++

Routine Description:

    Set KSSTATE to KSSTATE_PAUSE.

Arguments:

    Srb - Pointer to Stream request block

Return Value:

    Nothing

--*/
{
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    PIRB pIrb;
    PIRP pIrp;
    PDCAM_IO_CONTEXT pDCamIoContext;
    PIO_STACK_LOCATION NextIrpStack;
    NTSTATUS Status;

    PAGED_CODE();

    pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;
    ASSERT(pDevExt);
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
    ASSERT(pStrmEx);

    pSrb->Status = STATUS_SUCCESS;

    switch(pStrmEx->KSState) {
    case KSSTATE_ACQUIRE:
    case KSSTATE_STOP:
    //
    // Out of STOP state, 
    // initialize frame and timestamp information.  
    // (Master's clock's stream time is also reset.)
    //
        pStrmEx->FrameCaptured            = 0;     // Actual count
        pStrmEx->FrameInfo.DropCount      = 0;     
        pStrmEx->FrameInfo.PictureNumber  = 0;
        pStrmEx->FrameInfo.dwFrameFlags   = 0;
       
        // Advanced one frame.
        pStrmEx->FirstFrameTime           = pStrmEx->pVideoInfoHeader->AvgTimePerFrame; 
        DbgMsg2(("\'DCamSetKSStatePAUSE: FirstFrameTime(%d)\n", pStrmEx->FirstFrameTime));
        break;

    case KSSTATE_RUN:
    //
    // Will ask controll to stop listening.
    // All the pening buffer(s) are kept in the controller.
    // Before it completely stop (some latency here), 
    // we might get some IsochCallback() with data.
    //      
        if(!pDevExt->hResource) {
            pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        if(!DCamAllocateIrbIrpAndContext(&pDCamIoContext, &pIrb, &pIrp, pDevExt->BusDeviceObject->StackSize)) {
            pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        } 

        // Set to KSSTATE_PAUSE at the beginning to prvent CancelPacket being processed thinking
        // it is still in KSSTATE_RUN state.
        pStrmEx->KSState            = KSSTATE_PAUSE;
        pDCamIoContext->DeviceState = DCAM_PAUSESTATE_SET_REQUEST_ISOCH_STOP;
        pDCamIoContext->pSrb        = pSrb;               // To do StreamClassStreamNotification()
        pDCamIoContext->pDevExt     = pDevExt;
        pIrb->FunctionNumber        = REQUEST_ISOCH_STOP;
        pIrb->Flags                 = 0;
        pIrb->u.IsochStop.hResource = pDevExt->hResource;
        pIrb->u.IsochStop.fulFlags  = 0;

        NextIrpStack = IoGetNextIrpStackLocation(pIrp);
        NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
        NextIrpStack->Parameters.Others.Argument1 = pIrb;
          
        IoSetCompletionRoutine(
            pIrp,
            DCamToPauseStateCR,
            pDCamIoContext,
            TRUE,
            TRUE,
            TRUE
            );

        Status =\
            IoCallDriver(
                pDevExt->BusDeviceObject,
                pIrp
                );
        return;  // Do StreamClassStreamNotification() in IoCompletionRoutine

    case KSSTATE_PAUSE:
        ERROR_LOG(("DCamSetKSStatePAUSE: Already in KSSTATE_PAUSE state.\n"));
        ASSERT(pStrmEx->KSState != KSSTATE_PAUSE);
        break;
    }     

    pStrmEx->KSState = KSSTATE_PAUSE;

    COMPLETE_SRB(pSrb)
}



NTSTATUS
DCamToRunStateCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PDCAM_IO_CONTEXT pDCamIoContext
    )

/*++

Routine Description:

    This routine is for use with synchronous IRP processing.  
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DriverObject - Pointer to driver object created by system.

    pIrp - Irp that just completed

    pDCamIoContext - A structure that contain the context of this IO completion routine.

Return Value:

    None.

--*/

{
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    NTSTATUS Status;
    PIRB pIrb;
    PIO_STACK_LOCATION NextIrpStack;

    if(!pDCamIoContext) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }


    pIrb = pDCamIoContext->pIrb;
    pDevExt = pDCamIoContext->pDevExt;
    
    DbgMsg2(("\'DCamToRunStateCR: completed DeviceState=%d; pIrp->IoStatus.Status=%x\n", 
        pDCamIoContext->DeviceState, pIrp->IoStatus.Status));

    // Free MDL
    if(pIrb->FunctionNumber == REQUEST_ASYNC_WRITE) {
        DbgMsg3(("DCamToRunStateCR: IoFreeMdl\n"));
        IoFreeMdl(pIrb->u.AsyncWrite.Mdl);
    }

    //
    // CAUTION:
    //    STATUS_TIMEOUT can be a valid return that we may to try again.
    //    But should it be a HW issue that it is not responding to our write.
    //    Controller should have made many reties before return STATUS_TIMEOUT.
    //       
    if(pIrp->IoStatus.Status != STATUS_SUCCESS) {
       if(DCAM_RUNSTATE_SET_REQUEST_ISOCH_LISTEN != pDCamIoContext->DeviceState ||
           STATUS_INSUFFICIENT_RESOURCES != pIrp->IoStatus.Status  ) {

            ERROR_LOG(("DCamToRunStateCR:  pIrp->IoStatus.Status=%x; free resoruce and STOP\n", pIrp->IoStatus.Status));
            if(pDCamIoContext->pSrb) {
                pDCamIoContext->pSrb->Status = pIrp->IoStatus.Status == STATUS_SUCCESS ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
                COMPLETE_SRB(pDCamIoContext->pSrb);
            }
            DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);

            return STATUS_MORE_PROCESSING_REQUIRED; 
        } else {
            //
            // This is OK:
            //   If we get an insufficient resources error that means
            //   we don't have any Reads down yet.  Set flag to TRUE
            //   indicating that when we do get a Read down we'll 
            //   actually need to begin the listening process.
            //
            pDevExt->bNeedToListen = TRUE;
            DbgMsg1(("DCamToRunStateCR: ##### no read yet! set pDevExt->bNeedToListen = TRUE\n"));
        }
    } 

#ifdef WAIT_FOR_SLOW_DEVICE
    KeStallExecutionProcessor(5000);  // 5 msec
#endif


    switch (pDCamIoContext->DeviceState) {   

    case DCAM_RUNSTATE_SET_REQUEST_ISOCH_LISTEN:
        //
        // Bit[24..26]0:0000 = CurrentFrameRate
        //
        pDCamIoContext->RegisterWorkArea.AsULONG = pDevExt->FrameRate << 5;
        DbgMsg2(("\'DCamToRunState: FrameRate %x\n", pDCamIoContext->RegisterWorkArea.AsULONG));
        pIrb->FunctionNumber = REQUEST_ASYNC_WRITE;
        pIrb->Flags = 0;
        pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High = INITIAL_REGISTER_SPACE_HI;
        pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =  
              pDevExt->BaseRegister + FIELDOFFSET(CAMERA_REGISTER_MAP, CurrentVFrmRate);
        pIrb->u.AsyncWrite.nNumberOfBytesToWrite = sizeof(ULONG);
        pIrb->u.AsyncWrite.nBlockSize = 0;
        pIrb->u.AsyncWrite.fulFlags = 0;
        InterlockedExchange(&pIrb->u.AsyncWrite.ulGeneration, pDevExt->CurrentGeneration);
        break;

    case DCAM_RUNSTATE_SET_FRAME_RATE:
        //
        // Bit[24..26]0:0000 = CurrentVideoMode
        //
        pDCamIoContext->RegisterWorkArea.AsULONG = pDevExt->CurrentModeIndex << 5;
      DbgMsg2(("\'DCamToRunState: CurrentVideoMode %x\n", pDCamIoContext->RegisterWorkArea.AsULONG));
        pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =  
                  pDevExt->BaseRegister + FIELDOFFSET(CAMERA_REGISTER_MAP, CurrentVMode);
        break;

    case DCAM_RUNSTATE_SET_CURRENT_VIDEO_MODE:
        pDCamIoContext->RegisterWorkArea.AsULONG = FORMAT_VGA_NON_COMPRESSED;
      DbgMsg2(("\'DCamToRunState: VideoFormat %x\n", pDCamIoContext->RegisterWorkArea.AsULONG));
        pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =  
                  pDevExt->BaseRegister +  FIELDOFFSET(CAMERA_REGISTER_MAP, CurrentVFormat);
        break;

    case DCAM_RUNSTATE_SET_CURRENT_VIDEO_FORMAT:
        //
        // Bit [24..27]:00[30..31] = IsoChannel:00SpeedCode
        // 
        pDCamIoContext->RegisterWorkArea.AsULONG = (pDevExt->IsochChannel << 4) | pDevExt->SpeedCode;
      DbgMsg2(("\'DCamToRunState: pDevExt->SpeedCode 0x%x, Channel+SpeedCode %x\n", pDevExt->SpeedCode, pDCamIoContext->RegisterWorkArea.AsULONG));
        pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =  
                  pDevExt->BaseRegister +  FIELDOFFSET(CAMERA_REGISTER_MAP, IsoChannel);         
        break;

    case DCAM_RUNSTATE_SET_SPEED:
        //
        // Bit[24]000:0000 = start ? 1 : 0;
        //

        pDCamIoContext->RegisterWorkArea.AsULONG = START_ISOCH_TRANSMISSION;
        pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =  
                  pDevExt->BaseRegister +  FIELDOFFSET(CAMERA_REGISTER_MAP, IsoEnable);         
        break;


    case DCAM_RUNSTATE_SET_START:
        pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;                  
        ASSERT(pStrmEx);
        pStrmEx->KSState = KSSTATE_RUN; 

        // If this is called from a SRB, then completed it.
        if(pDCamIoContext->pSrb) {
            pDCamIoContext->pSrb->Status = pIrp->IoStatus.Status == STATUS_SUCCESS ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL; 
            COMPLETE_SRB(pDCamIoContext->pSrb);
        }

        //
        // This is last stop; so
        // we free what we allocated.
        //
        DbgMsg2(("\'DCamToRunStateCR: DONE!\n"));
        DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);
        return STATUS_MORE_PROCESSING_REQUIRED; 

    default:
        ERROR_LOG(("DCamToRunStateCR:DeviceState(%d) is not defined!\n\n", pDCamIoContext->DeviceState));        
        ASSERT(FALSE);
        return STATUS_MORE_PROCESSING_REQUIRED;
        
    }

    pDCamIoContext->DeviceState++;  // Keep track of device state that we just set.

    if(pIrb->FunctionNumber == REQUEST_ASYNC_WRITE) {
        pIrb->u.AsyncWrite.Mdl = 
            IoAllocateMdl(&pDCamIoContext->RegisterWorkArea, sizeof(ULONG), FALSE, FALSE, NULL);
        MmBuildMdlForNonPagedPool(pIrb->u.AsyncWrite.Mdl);
    }


    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pIrb;

    IoSetCompletionRoutine(
        pIrp,
        DCamToRunStateCR,
        pDCamIoContext,
        TRUE,
        TRUE,
        TRUE
        );

    Status = 
        IoCallDriver(
            pDevExt->BusDeviceObject,
            pIrp
            );

    DbgMsg2(("\'DCamToRunStateCR: IoCallDriver, Status=%x; STATUS_PENDING(%x)\n", Status, STATUS_PENDING));

    return STATUS_MORE_PROCESSING_REQUIRED;
}



VOID
DCamSetKSStateRUN(
    PDCAM_EXTENSION pDevExt,
    IN PHW_STREAM_REQUEST_BLOCK pSrb // Needed only to complete the SRB; for bus reset, there is no SRB.
    )
/*++

Routine Description:

    Set KSSTATE to KSSTATE_RUN.
    Can be called at DISPATCH level for initializing the device after a bus reset.

Arguments:

    pSrb - Pointer to Stream request block

Return Value:

    Nothing

--*/
{

    PSTREAMEX pStrmEx;
    PIRB pIrb;
    PIRP pIrp;
    PDCAM_IO_CONTEXT pDCamIoContext;
    PIO_STACK_LOCATION NextIrpStack;
    NTSTATUS Status;


    ASSERT(pDevExt);
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;                  
    ASSERT(pStrmEx);
    

    if(!DCamAllocateIrbIrpAndContext(&pDCamIoContext, &pIrb, &pIrp, pDevExt->BusDeviceObject->StackSize)) {
        if(pSrb) {
            pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
            COMPLETE_SRB(pSrb);
        }
        return;       
    } 

    pStrmEx->KSStateFinal       = KSSTATE_RUN;
    pDCamIoContext->DeviceState = DCAM_RUNSTATE_SET_REQUEST_ISOCH_LISTEN;
    pDCamIoContext->pSrb        = pSrb;               // To do StreamClassStreamNotification()
    pDCamIoContext->pDevExt     = pDevExt;
    pIrb->FunctionNumber        = REQUEST_ISOCH_LISTEN;
    pIrb->Flags                 = 0;
    pIrb->u.IsochStop.hResource = pDevExt->hResource;
    pIrb->u.IsochStop.fulFlags  = 0;

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pIrb;
          
    // In case we time out, we will try again; apply only to start listen;
    // With little change, it can work with other operation as well.
    pDevExt->lRetries = 0;

    IoSetCompletionRoutine(
        pIrp,
        DCamToRunStateCR,
        pDCamIoContext,
        TRUE,
        TRUE,
        TRUE
        );

    Status = 
        IoCallDriver(
            pDevExt->BusDeviceObject,
            pIrp
            );    
}



VOID
DCamReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )

/*++

Routine Description:

    Called with packet commands that control the video stream

Arguments:

    pSrb - Pointer to Stream request block

Return Value:

    Nothing

--*/

{

    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;


    //
    // determine the type of packet.
    //

    PAGED_CODE();

    pSrb->Status = STATUS_SUCCESS;  // default; called functions depends on this.
    pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;     
    ASSERT(pDevExt);
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
    ASSERT(pStrmEx);

    switch (pSrb->Command) {
    case SRB_GET_STREAM_STATE:         
         VideoGetState (pSrb);
         break;

    case SRB_SET_STREAM_STATE:   
         if(pStrmEx == NULL) {
            ERROR_LOG(("\'DCamReceiveCtrlPacket: SRB_SET_STREAM_STATE but pStrmEx is NULL.\n"));
            ASSERT(pStrmEx);
            pSrb->Status = STATUS_UNSUCCESSFUL;
            break;      
         }

         DbgMsg2(("\'DCamReceiveCtrlPacket: Setting state from %d to %d; PendingRead %d\n", 
                     pStrmEx->KSState, pSrb->CommandData.StreamState, pDevExt->PendingReadCount));               


         //
         // The control packet and data packet are not serialized by the stream class.
         // We need to watch for PAUSE->STOP transition.
         // In this transition, SRB_READ can still come in in a separate thread if
         // the client application has separate threads for setting state and read data.
         //
         // A "stop data packet" flag and a mutex is used for this synchronization.       
         // So we set "stop data packet" flag to stop future read, and
         // wait to own the mutex (if read is in progress) and then set stream to STOP state.
         // This "stop data packet" flag can be the stream state.
         //
         switch (pSrb->CommandData.StreamState) {
         case KSSTATE_STOP:
              DCamSetKSStateSTOP(pSrb);
              return;  // Complete Asynchronously in IoCompletionRoutine*

         case KSSTATE_PAUSE:
              DCamSetKSStatePAUSE(pSrb);
              return;  // Complete Asynchronously in IoCompletionRoutine*

         case KSSTATE_RUN:
              DCamSetKSStateRUN(pDevExt, pSrb);
              return;  // Complete Asynchronously in IoCompletionRoutine*

         case KSSTATE_ACQUIRE:
              pSrb->Status = STATUS_SUCCESS;
              break;

         default:
              ERROR_LOG(("\'DCamReceiveCtrlPacket: Error unknown state\n"));
              pSrb->Status = STATUS_NOT_IMPLEMENTED;
              break;
         }

         pStrmEx->KSState = pSrb->CommandData.StreamState;
         break;

    case SRB_GET_STREAM_PROPERTY:
         DbgMsg3(("\'DCamReceiveCtrlPacket: SRB_GET_STREAM_PROPERTY\n"));
         VideoGetProperty(pSrb);
         break;

    case SRB_INDICATE_MASTER_CLOCK:
         //
         // Assigns a clock to a stream
         //
         VideoIndicateMasterClock (pSrb);
         break;

    default:
         //
         // invalid / unsupported command. Fail it as such
         //    
         pSrb->Status = STATUS_NOT_IMPLEMENTED;    
         break;
    }

    StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\1394dcam\capprop.h ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================

//
// Function prototypes
//
NTSTATUS
DCamReadRegister(
    IN PIRB Irb,
    PDCAM_EXTENSION pDevExt,
    ULONG ulFieldOffset,
    ULONG * pulValue
);  

NTSTATUS
DCamWriteRegister(
    IN PIRB Irb,
    PDCAM_EXTENSION pDevExt,
    ULONG ulFieldOffset,
    ULONG ulValue
);

BOOL
DCamGetPropertyValuesFromRegistry(
    PDCAM_EXTENSION pDevExt
);

BOOL
DCamGetVideoMode(
    PDCAM_EXTENSION pDevExt,
    PIRB pIrb
    );

BOOL
DCamBuildFormatTable(
    PDCAM_EXTENSION pDevExt,
    PIRB pIrb
    );

BOOL
DCamSetPropertyValuesToRegistry(
    PDCAM_EXTENSION pDevExt
);

BOOL 
DCamPrepareDevProperties(
    PDCAM_EXTENSION pDevExt
    );

VOID
STREAMAPI 
AdapterGetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI 
AdapterSetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
DCamGetProperty(
    IN PIRB Irb,
    PDCAM_EXTENSION pDevExt, 
    ULONG ulFieldOffset,
    LONG * plValue, 
    ULONG * pulCapability, 
    ULONG * pulFlags,
    DCamRegArea * pFeature
);

NTSTATUS
DCamSetProperty(
    IN PIRB Irb,
    PDCAM_EXTENSION pDevExt, 
    ULONG ulFieldOffset,
    ULONG ulFlags,
    LONG  lValue,
    DCamRegArea * pFeature,
    DCamRegArea * pCachedRegArea
);  

NTSTATUS
DCamGetRange(
    IN PIRB Irb,
    PDCAM_EXTENSION pDevExt,
    ULONG ulFieldOffset,
    LONG * pMinValue,
    LONG * pMaxValue
);

NTSTATUS
DCamSetAutoMode(
    IN PIRB Irb,
    PDCAM_EXTENSION pDevExt, 
    ULONG ulFieldOffset,
    BOOL bAutoMode
);

VOID
SetCurrentDevicePropertyValues(
    PDCAM_EXTENSION pDevExt,
    PIRB pIrb
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\1394dcam\dbg.h ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    dbg.h

Abstract:

    Debug Code for 1394 drivers.

Environment:

    kernel mode only

Notes:

Revision History:

    5-Sep-95

--*/



//
// Various definitions
//


#if DBG

ULONG DCamDebugLevel;

#define ERROR_LOG(_x_)           KdPrint(_x_);

// Critical
#define DbgMsg1(_x_)        {if (DCamDebugLevel >= 1) \
                                KdPrint (_x_);}
// Warning/trace
#define DbgMsg2(_x_)        {if (DCamDebugLevel >= 2) \
                                KdPrint (_x_);}
// Information
#define DbgMsg3(_x_)        {if (DCamDebugLevel >= 3) \
                                KdPrint (_x_);}
#else

#define ERROR_LOG(_x_)    
#define DbgMsg1(_x_)
#define DbgMsg2(_x_)
#define DbgMsg3(_x_)

#endif
          
          

//
// Function declarations
//
VOID
Debug_Assert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    );

VOID 
Debug_LogEntry(
    IN CHAR *Name, 
    IN ULONG Info1, 
    IN ULONG Info2, 
    IN ULONG Info3
    );

VOID
Debug_LogInit(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\1394dcam\dcamdef.h ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    dcamdef.h

Abstract:

    Header file for constants and structures used for this 1394 desktop camera driver

Author:

    Shaun Pierce 25-May-96

Environment:

    Kernel mode only

Revision History:


--*/

//
// Define this to support YUV444
//
#define SUPPORT_YUV444


//
// Define this to support YUV411
//
#define SUPPORT_YUV411


//
// Define this to support RGB24
// This format is the most expensive to support.
// It requires driver to swap R and B og RGB24.
//
// #define SUPPORT_RGB24


//
// Define this to support YMONO
//
#define SUPPORT_YUV800


//
// Various structure definitions
//

typedef struct _INITIALIZE_REGISTER {
        ULONG       Reserved:31;            // Bits 1-31
        ULONG       Initialize:1;           // Bit 0
} INITIALIZE_REGISTER, *PINITIALIZE_REGISTER;

typedef struct _V_FORMAT_INQ_REGISTER {
        ULONG       Reserved:24;            // Bits 8-31
        ULONG       Format7:1;              // Bit 7       Scaleable Image Size Format
        ULONG       Format6:1;              // Bit 6       Still Image format
        ULONG       FormatRsv:3;            // Bits 3-5    Reserved
        ULONG       Format2:1;              // Bit 2       SVGA non-compressed format(2)
        ULONG       Format1:1;              // Bit 1       SVGA non-compressed format(1)
        ULONG       Format0:1;              // Bit 0       VGA non-compressed format (Max 640x480)
} V_FORMAT_INQ_REGISTER, *PV_FORMAT_INQ_REGISTER;

typedef enum {
    VMODE0_YUV444=0,
    VMODE1_YUV422,
    VMODE2_YUV411,
    VMODE3_YUV422,
    VMODE4_RGB24,    
    VMODE5_YUV800
} VMODE_INQ0;

typedef struct _V_MODE_INQ_REGISTER {
        ULONG       Reserved:24;            // Bits 8-31
        ULONG       ModeX:2;                // Bits 6-7
        ULONG       Mode5:1;                // Bit 5
        ULONG       Mode4:1;                // Bit 4
        ULONG       Mode3:1;                // Bit 3
        ULONG       Mode2:1;                // Bit 2
        ULONG       Mode1:1;                // Bit 1
        ULONG       Mode0:1;                // Bit 0
} V_MODE_INQ_REGISTER; *PV_MODE_INQ_REGISTER;

typedef struct _V_RATE_INQ_REGISTER {
        ULONG       Reserved:24;            // Bits 8-31
        ULONG       FrameRateX:2;           // Bits 6-7
        ULONG       FrameRate5:1;           // Bit 5
        ULONG       FrameRate4:1;           // Bit 4
        ULONG       FrameRate3:1;           // Bit 3
        ULONG       FrameRate2:1;           // Bit 2
        ULONG       FrameRate1:1;           // Bit 1
        ULONG       FrameRate0:1;           // Bit 0
} V_RATE_INQ_REGISTER, *PV_RATE_INQ_REGISTER;


typedef struct _FEATURE_PRESENT1 {
        ULONG       Reserved:21;          // Bits 11-31
        ULONG       Focus:1;               // Bit 10
        ULONG       Iris:1;                // Bit 9
        ULONG       Gain:1;                // Bit 8
        ULONG       Shutter:1;             // Bit 7
        ULONG       Gamma:1;               // Bit 6
        ULONG       Saturation:1;          // Bit 5
        ULONG       Hue:1;                 // Bit 4
        ULONG       White_Balance:1;       // Bit 3
        ULONG       Sharpness:1;           // Bit 2
        ULONG       Exposure:1;            // Bit 1
        ULONG       Brightness:1;          // Bit 0
} FEATURE_PRESENT1, *PFEATURE_PRESENT1;

typedef struct _FEATURE_PRESENT2 {
        ULONG       Reserved:29;           // Bits 3-31
        ULONG       Tile:1;                // Bit 2
        ULONG       Pan:1;                 // Bit 1
        ULONG       Zoom:1;                // Bit 0
} FEATURE_PRESENT2, *PFEATURE_PRESENT2;

typedef struct _FEATURE_REGISTER {
        ULONG       MAX_Value:12;           // Bits 20-31
        ULONG       MIN_Value:12;           // Bits 8-19
        ULONG       ManualMode:1;            // Bit 7
        ULONG       AutoMode:1;             // Bit 6
        ULONG       OnOff:1;                // Bit 5
        ULONG       ReadOut_Inq:1;          // Bit 4
        ULONG       OnePush:1;              // Bit 3
        ULONG       Reserved:2;             // Bits 1-2
        ULONG       PresenceInq:1;          // Bit 0
} FEATURE_REGISTER, *PFEATURE_REGISTER;


typedef struct _BRIGHTNESS_REGISTER {
        ULONG       Value:12;               // Bits 20-31
        ULONG       Reserved1:12;           // Bits 8-19
        ULONG       AutoMode:1;             // Bit 7
        ULONG       OnOff:1;                // Bit 6
        ULONG       OnePush:1;              // Bit 5
        ULONG       Reserved2:4;            // Bits 1-4
        ULONG       PresenceInq:1;          // Bit 0
} BRIGHTNESS_REGISTER, *PBRIGHTNESS_REGISTER;

typedef struct _WHITE_BALANCE_REGISTER {
        ULONG       VValue:12;              // Bits 20-31
        ULONG       UValue:12;              // Bits 8-19
        ULONG       AutoMode:1;             // Bit 7
        ULONG       OnOff:1;                // Bit 6
        ULONG       OnePush:1;              // Bit 5
        ULONG       Reserved1:4;            // Bits 1-4
        ULONG       PresenceInq:1;          // Bit 0
} WHITE_BALANCE_REGISTER, *PWHITE_BALANCE_REGISTER;

// A common structure so it is easier to access its elements.
typedef union _DCamRegArea {

        INITIALIZE_REGISTER Initialize;
        V_FORMAT_INQ_REGISTER VFormat;
        V_MODE_INQ_REGISTER VMode;
        V_RATE_INQ_REGISTER VRate;
        BRIGHTNESS_REGISTER Brightness;
        WHITE_BALANCE_REGISTER WhiteBalance;
        FEATURE_REGISTER Feature;
        FEATURE_PRESENT1 CameraCap1;
        FEATURE_PRESENT2 CameraCap2;
        ULONG AsULONG;

} DCamRegArea, * PDCamRegArea;


//
// Structure of the camera's register space
//

typedef struct _CAMERA_REGISTER_MAP {
    INITIALIZE_REGISTER     Initialize;         // @ 0
    ULONG                   Reserved1[63];      // @ 4
    V_FORMAT_INQ_REGISTER   VFormat;            // @ 100
    ULONG                   Reserved2[31];      // @ 104
    V_MODE_INQ_REGISTER     VModeInq[8];        // @ 180-19f
    ULONG                   Reserved3[24];      // @ 1A0-1ff
    V_RATE_INQ_REGISTER     VRateInq[128];      // @ 200-3ff
    ULONG                   Reserved4;          // @ 400-4ff
    FEATURE_PRESENT1        FeaturePresent1;    // @ 404
    FEATURE_PRESENT2        FeaturePresent2;    // @ 408
    ULONG                   Reserved4b[61];     // @ 40c-4ff

    FEATURE_REGISTER        Brightness_Inq;     // @ 500-503
    FEATURE_REGISTER        Exposure_Inq;       // @ 504
    FEATURE_REGISTER        Sharpness_Inq;      // @ 508
    FEATURE_REGISTER        WhiteBalance_Inq;   // @ 50c
    FEATURE_REGISTER        Hue_Inq;            // @ 510
    FEATURE_REGISTER        Saturation_Inq;     // @ 514
    FEATURE_REGISTER        Gamma_Inq;          // @ 518
    FEATURE_REGISTER        Shutter_Inq;        // @ 51c
    FEATURE_REGISTER        Gain_Inq;           // @ 520
    FEATURE_REGISTER        Iris_Inq;           // @ 524
    FEATURE_REGISTER        Focus_Inq;          // @ 528
    ULONG                   Resreved5[(0x580-0x52c)/4];      // @ 52c-57c
    FEATURE_REGISTER        Zoom_Inq;           // @ 580
    FEATURE_REGISTER        Pan_Inq;            // @ 584
    FEATURE_REGISTER        Tilt_Inq;           // @ 588-58b
    ULONG                   Reserved6[(0x600-0x58c)/4];      // @ 58c-5ff
    // Status and control register for camera
    ULONG                   CurrentVFrmRate;    // @ 600
    ULONG                   CurrentVMode;       // @ 604
    ULONG                   CurrentVFormat;     // @ 608
    ULONG                   IsoChannel;         // @ 60C
    ULONG                   CameraPower;        // @ 610
    ULONG                   IsoEnable;          // @ 614
    ULONG                   MemorySave;         // @ 618
    ULONG                   OneShot;            // @ 61C
    ULONG                   MemorySaveChannel;  // @ 620
    ULONG                   CurrentMemChannel;  // @ 624
    ULONG                   Reserved7[(0x800-0x628)/4];     // @ 628-7ff

    // Status and control register for feature
    BRIGHTNESS_REGISTER     Brightness;         // @ 800
    BRIGHTNESS_REGISTER     Exposure;           // @ 804
    BRIGHTNESS_REGISTER     Sharpness;          // @ 808
    WHITE_BALANCE_REGISTER  WhiteBalance;       // @ 80C
    BRIGHTNESS_REGISTER     Hue;                // @ 810
    BRIGHTNESS_REGISTER     Saturation;         // @ 814
    BRIGHTNESS_REGISTER     Gamma;              // @ 818
    BRIGHTNESS_REGISTER     Shutter;            // @ 81C
    BRIGHTNESS_REGISTER     Gain;               // @ 820
    BRIGHTNESS_REGISTER     Iris;               // @ 824
    BRIGHTNESS_REGISTER     Focus;              // @ 828
    ULONG                   Resreved8[(0x880-0x82c)/4];      // @ 82c-87c
    BRIGHTNESS_REGISTER     Zoom;               // @ 880
    BRIGHTNESS_REGISTER     Pan;                // @ 884
    BRIGHTNESS_REGISTER     Tilt;               // @ 888

} CAMERA_REGISTER_MAP, *PCAMERA_REGISTER_MAP;


//
// To make DCAm start streaming,
// it needs to set all these step.
// We will do them one by one in the
// StartDCam's IoCompletionRoutine
//
typedef enum {
    DCAM_STATE_UNDEFINED = 0,
    DCAM_SET_INITIALIZE,

    DCAM_STOPSTATE_SET_REQUEST_ISOCH_STOP,
    DCAM_STOPSTATE_SET_STOP_ISOCH_TRANSMISSION,

    DCAM_PAUSESTATE_SET_REQUEST_ISOCH_STOP,

    DCAM_RUNSTATE_SET_REQUEST_ISOCH_LISTEN,
    DCAM_RUNSTATE_SET_FRAME_RATE,
    DCAM_RUNSTATE_SET_CURRENT_VIDEO_MODE,
    DCAM_RUNSTATE_SET_CURRENT_VIDEO_FORMAT,
    DCAM_RUNSTATE_SET_SPEED,
    DCAM_RUNSTATE_SET_START,

    DCAM_SET_DONE
} DCAM_DEVICE_STATE, *PDCAM_DEVICE_STATE;


//
// Video formats and modes support
//
#define MAX_VMODES               6  // Support at most 6 modes of V_MODE_INQ_0


//
// Support's property, they are used as the index.
//
#define NUM_VIDEOPROCAMP_ITEMS   5
#define NUM_CAMERACONTROL_ITEMS  2
#define NUM_PROPERTY_ITEMS       NUM_VIDEOPROCAMP_ITEMS + NUM_CAMERACONTROL_ITEMS
typedef enum {
    // VideoProcAmp
    ENUM_BRIGHTNESS = 0,
    ENUM_SHARPNESS,
    ENUM_HUE,
    ENUM_SATURATION,
    ENUM_WHITEBALANCE,
    // CameraControl
    ENUM_FOCUS,
    ENUM_ZOOM,

} ENUM_DEV_PROP;


//
// Structure for each device property
//
typedef struct _DEV_PROPERTY {
    // ReadOnly
    KSPROPERTY_STEPPING_LONG RangeNStep;    // Range from the Feature
    LONG  DefaultValue;                     // Read from the registry or midrange if not in registry
#if 0
    ULONG ulFieldOffset;                    // Offset of where the CSR is located
#endif
    // ReadOnly
    DCamRegArea Feature;                    // Register that contain the feature inquery of a property

    // Read/Write
    DCamRegArea StatusNControl;             // Register that is both R/W (Addr has an 0x300 offset from the Feature's)
} DEV_PROPERTY, * PDEV_PROPERTY;


typedef struct _DEV_PROPERTY_DEFINE {
    KSPROPERTY_VALUES Value;
    KSPROPERTY_MEMBERSLIST Range;
    KSPROPERTY_MEMBERSLIST Default;
} DEV_PROPERTY_DEFINE, *PDEV_PROPERTY_DEFINE;


//
// Device Extension for our 1394 Desktop Camera Driver
//

// Circular pointers DevExt<->StrmEx
typedef struct _STREAMEX;
typedef struct _DCAM_EXTENSION;

//
// Context to keep track in the IO Completion routine.
//
typedef struct _DCAM_IO_CONTEXT {
    DWORD               dwSize;

    PHW_STREAM_REQUEST_BLOCK   pSrb;
    struct _DCAM_EXTENSION *pDevExt;
    PIRB                       pIrb;
    PVOID      pReserved[4];   // Maybe used for extra context information.

    DCAM_DEVICE_STATE   DeviceState;

    //
    // Holds an area for us to read/write camera registers to/from here
    //
    union {
        INITIALIZE_REGISTER Initialize;
        V_FORMAT_INQ_REGISTER VFormat;
        V_MODE_INQ_REGISTER VMode;
        V_RATE_INQ_REGISTER VRate;
        BRIGHTNESS_REGISTER Brightness;
        WHITE_BALANCE_REGISTER WhiteBalance;
              FEATURE_REGISTER Feature;
        ULONG AsULONG;
    } RegisterWorkArea;

} DCAM_IO_CONTEXT, *PDCAM_IO_CONTEXT;



typedef struct _DCAM_EXTENSION {

    //
    // Holds the Device Object we share with the stream class
    //
    PDEVICE_OBJECT SharedDeviceObject;

    //
    // Holds the Device Object of our parent (1394 bus driver)
    // pass it in IoCallDriver()
    //
    PDEVICE_OBJECT BusDeviceObject;

    //
    // Holds my Physical Device Object
    // pass it in PnP API, such as IoOpenDeviceRegistryKey()
    //
    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // Holds the current generation count of the bus
    //
    ULONG CurrentGeneration;

    //
    // Holds the Configuration Rom for this device.  Multi-functional
    // devices (i.e. many units) will share this same Config Rom
    // structure, but they are represented as a different Device Object.
    // This is not the entire Config Rom, but does contain the root directory
    // as well as everything in front of it.
    //
    PCONFIG_ROM ConfigRom;

    //
    // Holds the Unit Directory for this device.  Even on multi-functional
    // devices (i.e. many units) this should be unique to each Device Object.
    //
    PVOID UnitDirectory;

    //
    // Holds the Unit Dependent directory for this device.
    //
    PVOID UnitDependentDirectory;

    //
    // Holds the pointer to the Vendor Leaf information
    //
    PTEXTUAL_LEAF VendorLeaf;

    PCHAR pchVendorName;

    //
    // Holds the pointer to the Model Leaf information
    //
    PTEXTUAL_LEAF ModelLeaf;

    //
    // Holds the Base Register of the camera (lower 32 bit portion only)
    //
    ULONG BaseRegister;

    //
    // Holds an area for us to read/write camera registers to/from here
    //
    union {
        INITIALIZE_REGISTER Initialize;
        V_FORMAT_INQ_REGISTER VFormat;
        V_MODE_INQ_REGISTER VMode;
        V_RATE_INQ_REGISTER VRate;
        BRIGHTNESS_REGISTER Brightness;
        WHITE_BALANCE_REGISTER WhiteBalance;
              FEATURE_REGISTER Feature;
        ULONG AsULONG;
    } RegisterWorkArea;

    //
    // Holds what frame rate we'll display at
    //
    ULONG FrameRate;

    //
    // Holds the resource for the isoch stream we got
    //
    HANDLE hResource;

    //
    // Holds the bandwidth resource handle
    //
    HANDLE hBandwidth;

    //
    // Holds the Isoch channel we'll use to receive data
    //
    ULONG IsochChannel;

    //
    // Got this from the parent's PNODE_DEVICE_EXTENSION;
    // Sinceit is from the 1394bus driver, it is safe to be used to set the xmit speed
    //

    ULONG SpeedCode;

    //
    // Holds the Mode Index that we currently supposed to be running at
    //
    ULONG CurrentModeIndex;

    //
    // Holds whether or not we need to listen (after we said we did)
    // Used only if enable isoch streaming while no buffer is attached.
    //
    BOOLEAN bNeedToListen;

    //
    // Holds the list of isoch descriptors that are currently attached
    //
    LIST_ENTRY IsochDescriptorList;

    //
    // Holds the spin lock that must be acquired before playing around with
    // the IsochDescriptorList
    //
    KSPIN_LOCK IsochDescriptorLock;

    //
    // Set to TRUE if isoch channel and resource have changed due to bus reset,
    // and we must either resubmit the pending reads or cancel them.
    //
    BOOL bStopIsochCallback;

    //
    // Holds the number of reads down at any given moment
    //
    LONG PendingReadCount;

    //
    // Holds the list of isoch descriptors that are waiting for resources
    //
    LIST_ENTRY IsochWaitingList;

    //
    // Holds the spin lock that must be acquired before playing around with
    // the IsochWaitingList
    //
    KSPIN_LOCK IsochWaitingLock;

    //
    // The could be an array if the device support multiple streams.  But we only has one capture pin.
    //
    struct _STREAMEX * pStrmEx;

    //
    // Many IEE 1394 cameras can use the same drivers.  After a streamis open, this is incremented.
    //
    LONG idxDev;

    //
    // Query type of host controller and its capabilities (like stripe Quadlets)
    //
    GET_LOCAL_HOST_INFO2 HostControllerInfomation;

    //
    // Query the DMA capabilities; mainly to determine the max DMA buffer size
    //
    GET_LOCAL_HOST_INFO7 HostDMAInformation;

    //
    // Keep track of power state; know only D0 and D3
    //
    DEVICE_POWER_STATE CurrentPowerState;

    //
    // TRUE only after SRB_SURPRIESE_REMOVAL;
    //
    BOOL bDevRemoved;

    //
    // Sometime the camera is not responding to our request;
    // so we retied.
    //
    LONG lRetries;   // [0.. RETRY_COUNT]

    // ************************** //
    // Streams: Formats and Modes //
    // ************************** //
    
    //
    // Set in the INF to inform driver of what compression format 
    // (VMode) is supported by the decoder installed on the system (by default)
    // 
    DCamRegArea DecoderDCamVModeInq0;

    //
    // cache the device's VFormat and VModeInq0 register values
    //
    DCamRegArea DCamVFormatInq;
    DCamRegArea DCamVModeInq0;

    //
    // These values are retrun in the StreamHeader to advertise the stream formats supported.
    //
    ULONG ModeSupported;  // 0..MAX_VMODE
    PKSDATAFORMAT  DCamStrmModes[MAX_VMODES];  

    // ************** //
    // Device control //
    // ************** //

#if DBG
    //
    // Inquire features supported be this device
    //
    DCamRegArea DevFeature1;   //Brightness, Sharpness, WhiteBalance, Hue, Saturation..Focus...
    DCamRegArea DevFeature2;   // Zoom, Pan, Tilt...
#endif

    //
    // Property sets; when sets are in contiguous memory, they forma a property table.
    //
    ULONG ulPropSetSupported;        // Number of property item supported.
    KSPROPERTY_SET VideoProcAmpSet;  // This is also the beginning of the property set table.
    KSPROPERTY_SET CameraControlSet;

    //
    // Property items of what device supports 
    //
    KSPROPERTY_ITEM VideoProcAmpItems[NUM_VIDEOPROCAMP_ITEMS];
    KSPROPERTY_ITEM CameraControlItems[NUM_CAMERACONTROL_ITEMS];

    //
    // Current settings defined (supported) by the device
    //
    DEV_PROPERTY_DEFINE DevPropDefine[NUM_PROPERTY_ITEMS];

    //
    // VideoProcAmp and CameraControl (range and current value)
    //
    DEV_PROPERTY DevProperty[NUM_PROPERTY_ITEMS];
    
    //
    // Global nonpaged pool memory used to read/write device register values (current value)
    //
    DCamRegArea RegArea;

    //
    // Global nonpaged pool memory used to read/write device register values (verify result)
    //
    DCamRegArea RegAreaVerify;

    //
    // Seralize using the global variables. (just in case we are called from multiple threads)
    //
    KMUTEX hMutexProperty;       

} DCAM_EXTENSION, *PDCAM_EXTENSION;


//
// this structure is our per stream extension structure.  This stores
// information that is relevant on a per stream basis.  Whenever a new stream
// is opened, the stream class driver will allocate whatever extension size
// is specified in the HwInitData.PerStreamExtensionSize.
//

typedef struct _STREAMEX {

    // Index to the table contain the data packet information
    LONG idxIsochTable;

    //
    // Holds the master clock
    //
    HANDLE hMasterClock;

    //
    // Pointer to the data that i'm supposed to be working off of
    //
    PKS_VIDEOINFOHEADER  pVideoInfoHeader;

    //
    // Statistic of the frame information since last start stream
    //
    KS_FRAME_INFO FrameInfo;
    ULONGLONG     FrameCaptured;        // Number of frame return to the client
    ULONGLONG     FirstFrameTime;       // Use to calculate drop frame

    //
    // Holds state
    //
    KSSTATE KSState;
    KSSTATE KSStateFinal;   // Final state that we want to reach using IoCompletion routine

    KMUTEX hMutex;   // MutEx of StreamIo or StreamControl, specifically setting to stop state.

    //
    // For Power Management; valid only in DCamChangePower()
    //
    KSSTATE KSSavedState;

} STREAMEX, *PSTREAMEX;




typedef struct _CAMERA_ISOCH_INFO {

    //
    // Holds the number of quadlets in each Isochronous packet
    //
    ULONG QuadletPayloadPerPacket;

    //
    // Holds the speed required in order to receive this mode
    //
    ULONG SpeedRequired;

    //
    // Holds the size of a complete picture at this resolution and mode
    //
    ULONG CompletePictureSize;

} CAMERA_ISOCH_INFO, *PCAMERA_ISOCH_INFO;


typedef struct _ISOCH_DESCRIPTOR_RESERVED {

    //
    // Holds the list of descriptors that we have in use
    //
    LIST_ENTRY DescriptorList;

    //
    // Holds the pointer to the Srb that's associated with this descriptor
    //
    PHW_STREAM_REQUEST_BLOCK Srb;

    //
    // Holds the flags that we use to remember what state we're in
    //
    ULONG Flags;


} ISOCH_DESCRIPTOR_RESERVED, *PISOCH_DESCRIPTOR_RESERVED;


//
// Various definitions
//


#define FIELDOFFSET(type, field)        (int)((INT_PTR)(&((type *)1)->field)-1)

#define QUERY_ADDR_OFFSET          0x0300   // 0x800 - 0x500 = 0x300

#define MAX_READ_REG_RETRIES           10   // Max retries until Pres is ready

#define NUM_POSSIBLE_RATES              6
#define RETRY_COUNT                     5
#define RETRY_COUNT_IRP_SYNC           20
#define DEFAULT_FRAME_RATE              3
#define STOP_ISOCH_TRANSMISSION         0
#define START_ISOCH_TRANSMISSION        0x80
#define START_OF_PICTURE                1
#define MAX_BUFFERS_SUPPLIED            8
#define DCAM_DELAY_VALUE            (ULONG)(-1 *  100 * 1000)    //  10 ms
#define DCAM_DELAY_VALUE_BUSRESET   (ULONG)(-1 * 2000 * 1000)    // 200 ms


#define DCAM_REG_STABLE_DELAY       (ULONG)(-1 * 500 * 1000)    // 50 ms

#define ISO_ENABLE_BIT         0x00000080


//
// Definitions of the Frame Rate register located at offset 0x600
//
#define FRAME_RATE_0                    0
#define FRAME_RATE_1                    0x20
#define FRAME_RATE_2                    0x40
#define FRAME_RATE_3                    0x60
#define FRAME_RATE_4                    0x80
#define FRAME_RATE_5                    0xa0
#define FRAME_RATE_SHIFT                5

#define FORMAT_VGA_NON_COMPRESSED       0

#define ISOCH_CHANNEL_SHIFT             4

#define VIDEO_MODE_SHIFT                5

#define REGISTERS_TO_SET_TO_AUTO        10

#define STATE_SRB_IS_COMPLETE           1
#define STATE_DETACHING_BUFFERS         2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\1394dcam\dcampkt.h ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    dcampkt.h

Abstract:

    Header file for dcampkt.c

Author:
    
    Shaun Pierce 25-May-96

Environment:

    Kernel mode only

Revision History:


--*/


//
// Function prototypes
//

void 
tmGetStreamTime(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    PSTREAMEX pStrmEx, 
    ULONGLONG * ptmStream
    );

BOOL
DCamAllocateIrbAndIrp(
    PIRB * ppIrb,
    PIRP * ppIrp,
    CCHAR StackSize
    );

BOOL
DCamAllocateIrbIrpAndContext(
    PDCAM_IO_CONTEXT * ppDCamIoContext,
    PIRB * ppIrb,
    PIRP * ppIrp,
    CCHAR StackSize
    );

void
DCamFreeIrbIrpAndContext(
    PDCAM_IO_CONTEXT pDCamIoContext,
    PIRB pIrb,
    PIRP pIrp   
    );

BOOL
DCamIsoEnable(
    PIRB pIrb,
    PDCAM_EXTENSION pDevExt,
    BOOL Enable  
    );

VOID
DCamCancelAllPackets(
    PHW_STREAM_REQUEST_BLOCK pSrb,
    PDCAM_EXTENSION pDevExt,
    LONG *plPendingReadCount    
    );

VOID
DCamSurpriseRemoval(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );


VOID
DCamTimeoutHandler(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
DCamReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
DCamGetStreamInfo(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

NTSTATUS
DCamAllocateIsochResource(
    PDCAM_EXTENSION pDevExt,
    PIRB Irb,
    BOOL bAllocateResource
    );

NTSTATUS
DCamFreeIsochResource(    
    PDCAM_EXTENSION pDevExt,
    PIRB Irb,
    BOOL bFreeResource
    );

VOID
DCamOpenStream(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
DCamCloseStream(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
DCamReceiveDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
DCamReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
DCamReadStream(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID
DCamReadStreamWorker(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    IN PISOCH_DESCRIPTOR IsochDescriptor
    );



VOID
DCamIsochCallback(
    IN PVOID Context1,
    IN PVOID Context2
    );

NTSTATUS
DCamDetachBufferCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
DCamStartListenCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID SystemArgument
    );

VOID
DCamSetKSStateSTOP(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

BOOL 
AdapterCompareGUIDsAndFormatSize(
    IN PKSDATARANGE DataRange1,
    IN PKSDATARANGE DataRange2
    );

BOOL 
AdapterVerifyFormat(
    ULONG VideoModesSupported,
    PKSDATAFORMAT *pDCamStrmModesSupported,
    PKS_DATAFORMAT_VIDEOINFOHEADER pKSDataFormatToVerify, 
    int StreamNumber
    );

BOOL 
AdapterFormatFromRange(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID VideoGetProperty(PHW_STREAM_REQUEST_BLOCK Srb);

VOID VideoGetState(PHW_STREAM_REQUEST_BLOCK Srb);

VOID VideoStreamGetConnectionProperty (PHW_STREAM_REQUEST_BLOCK Srb);

VOID VideoStreamGetDroppedFramesProperty(PHW_STREAM_REQUEST_BLOCK Srb);

VOID VideoIndicateMasterClock (PHW_STREAM_REQUEST_BLOCK Srb);

ULONGLONG GetSystemTime();

VOID
DCamSetKSStatePAUSE(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
DCamToRunStateCoR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PDCAM_IO_CONTEXT pDCamIoContext
    );

VOID
DCamSetKSStateRUN(
    PDCAM_EXTENSION pDevExt,
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
DCamCancelBufferCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PDCAM_IO_CONTEXT pDCamIoContext
    );

BOOL
DCamDeviceInUse(
    PIRB pIrb,
    PDCAM_EXTENSION pDevExt
    );

void
DCamProcessPnpIrp(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    PIO_STACK_LOCATION IrpStack,
    PDCAM_EXTENSION pDevExt
    );

VOID 
InitializeStreamExtension(
    PDCAM_EXTENSION pDevExt,
    PHW_STREAM_OBJECT   pStreamObject,
    PSTREAMEX           pStrmEx
    );

BOOL 
AdapterFormatFromRange(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

NTSTATUS
DCamReSubmitPacket(
    HANDLE hOldResource,
    PDCAM_EXTENSION pDevExt,
    PSTREAMEX pStrmEx,
    LONG PendingReadCount
    );

NTSTATUS
DCamSetKSStateInitialize(
    PDCAM_EXTENSION pDevExt
    );

VOID 
DCamChangePower(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\1394dcam\dcampkt.c ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    dcampkt.c

Abstract:

    Stream class based WDM driver for 1934 Desktop Camera.
    This file contains code to handle the stream class packets.

Author:
    
    Shaun Pierce 25-May-96

Modified:

    Yee J. Wu 15-Oct-97

Environment:

    Kernel mode only

Revision History:


--*/


#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "wdm.h"       // for DbgBreakPoint() defined in dbg.h
#include "dbg.h"
#include "dcamdef.h"
#include "dcampkt.h"
#include "strmdata.h"  // stream format and data ranges; static data
#include "capprop.h"   // Video and camera property function prototype

#define WAIT_FOR_SLOW_DEVICE


#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, DCamProcessPnpIrp)
    #pragma alloc_text(PAGE, DCamGetStreamInfo)
    #pragma alloc_text(PAGE, DCamFreeIsochResource)    
    #pragma alloc_text(PAGE, InitializeStreamExtension)    
    #pragma alloc_text(PAGE, DCamOpenStream)   
    #pragma alloc_text(PAGE, DCamCloseStream)           
    #pragma alloc_text(PAGE, AdapterCompareGUIDsAndFormatSize)    
    #pragma alloc_text(PAGE, AdapterVerifyFormat)    
    #pragma alloc_text(PAGE, AdapterFormatFromRange)    
    #pragma alloc_text(PAGE, VideoGetProperty)    
    #pragma alloc_text(PAGE, VideoGetState)    
    #pragma alloc_text(PAGE, VideoStreamGetConnectionProperty)    
    #pragma alloc_text(PAGE, VideoStreamGetDroppedFramesProperty)    
    #pragma alloc_text(PAGE, VideoIndicateMasterClock)    
    #pragma alloc_text(PAGE, DCamReceivePacket)
    #pragma alloc_text(PAGE, DCamChangePower)
#endif

void 
tmGetStreamTime(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    PSTREAMEX pStrmEx, 
    ULONGLONG * ptmStream) 
/*++

Routine Description:

   Query the current time used to timestamp the frame or calculating the dropped frame.
   This is used in IsochCallback so must be paged in always.

Arguments:

    Srb - Pointer to Stream request block

Return Value:

    Nothing

--*/
{

    HW_TIME_CONTEXT TimeContext;

    TimeContext.HwDeviceExtension = (PVOID) Srb->HwDeviceExtension;
    TimeContext.HwStreamObject    = Srb->StreamObject;
    TimeContext.Function          = TIME_GET_STREAM_TIME;
    TimeContext.Time              = 0;
    TimeContext.SystemTime        = 0;

    StreamClassQueryMasterClockSync(
        pStrmEx->hMasterClock,
        &TimeContext);

    *ptmStream = TimeContext.Time;
}

BOOL
DCamAllocateIrbAndIrp(
    PIRB * ppIrb,
    PIRP * ppIrp,
    CCHAR StackSize
    )
{

    // Allocate Irb and Irp
    *ppIrb = ExAllocatePoolWithTag(NonPagedPool, sizeof(IRB), 'macd');
    if(!*ppIrb) {           
        return FALSE;
    }

    *ppIrp = IoAllocateIrp(StackSize, FALSE);
    if(!*ppIrp) {
        ExFreePool(*ppIrb);
        *ppIrb = NULL;
        return FALSE;
    }

    // Initialize IRB
    RtlZeroMemory(*ppIrb, sizeof(IRB));

    return TRUE;
}


BOOL
DCamAllocateIrbIrpAndContext(
    PDCAM_IO_CONTEXT * ppDCamIoContext,
    PIRB * ppIrb,
    PIRP * ppIrp,
    CCHAR StackSize
    )
{

    // Allocate DCamIoContext
    *ppDCamIoContext = ExAllocatePoolWithTag(NonPagedPool, sizeof(DCAM_IO_CONTEXT), 'macd');
    if(!*ppDCamIoContext) {            
        return FALSE;
    }

    // Allocate Irb and Irp
    *ppIrb = ExAllocatePoolWithTag(NonPagedPool, sizeof(IRB), 'macd');
    if(!*ppIrb) {
        ExFreePool(*ppDCamIoContext);            
        *ppDCamIoContext = NULL;
        return FALSE;
    }

    *ppIrp = IoAllocateIrp(StackSize, FALSE);
    if(!*ppIrp) {
        ExFreePool(*ppDCamIoContext);
        *ppDCamIoContext = NULL;
        ExFreePool(*ppIrb);
        *ppIrb = NULL;
        return FALSE;
    }


    // Initialize this context
    RtlZeroMemory(*ppDCamIoContext, sizeof(DCAM_IO_CONTEXT));
    (*ppDCamIoContext)->dwSize      = sizeof(DCAM_IO_CONTEXT);
    (*ppDCamIoContext)->pIrb        = *ppIrb;

    // Initialize IRB
    RtlZeroMemory(*ppIrb, sizeof(IRB));

    return TRUE;
}

void
DCamFreeIrbIrpAndContext(
    PDCAM_IO_CONTEXT pDCamIoContext,
    PIRB pIrb,
    PIRP pIrp   
    )
{
    if(pIrp)
        IoFreeIrp(pIrp);
    if(pIrb)
        ExFreePool(pIrb);
    if(pDCamIoContext)
        ExFreePool(pDCamIoContext);
}


BOOL
DCamIsoEnable(
    PIRB pIrb,
    PDCAM_EXTENSION pDevExt,
    BOOL Enable  
    ) 
/*
    Start or start isoch transmission by setting the ISOEnable bit.
    TRUE: Start transmission; 
    FALSE: Stop transmission.
*/
{
    BOOL EnableVerify;
    DCamRegArea RegArea;
    NTSTATUS Status;
    LARGE_INTEGER stableTime;
    LONG lRetries = MAX_READ_REG_RETRIES;

    do {
        RegArea.AsULONG = (Enable ? START_ISOCH_TRANSMISSION : STOP_ISOCH_TRANSMISSION);
        Status = DCamWriteRegister(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, IsoEnable), RegArea.AsULONG);
        EnableVerify = DCamDeviceInUse(pIrb, pDevExt);
        if(!NT_SUCCESS(Status) || EnableVerify != Enable) {
            ERROR_LOG(("\'DCAmIsoEnable: St:%x; Enable:%d vs EnableVerify:%d\n", Status, Enable, EnableVerify));
            if(lRetries >= 1) {
                stableTime.LowPart = DCAM_REG_STABLE_DELAY;
                stableTime.HighPart = -1;
                KeDelayExecutionThread(KernelMode, TRUE, &stableTime);
                ERROR_LOG(("\'DCamIsoEnable: delayed and try again...\n"))
            }
        }
    } while (--lRetries > 0 && (!NT_SUCCESS(Status) || (EnableVerify != Enable)) );

    return (EnableVerify == Enable);
}

void
DCamProcessPnpIrp(
    IN PHW_STREAM_REQUEST_BLOCK Srb,
    PIO_STACK_LOCATION IrpStack,
    PDCAM_EXTENSION pDevExt
    )

/*++

Routine Description:

    Process PnP Irp. 

Arguments:

    Srb - Pointer to Stream request block

Return Value:

    Nothing

--*/
{
    NTSTATUS Status, StatusWait;
    PIRB pIrb;
    PIRP pIrp;
    PSTREAMEX pStrmEx;

    PAGED_CODE();

    switch (IrpStack->MinorFunction) {
#if 1
    case IRP_MN_QUERY_POWER:
        pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
        ERROR_LOG(("IRP_MN_QUERY_POWER: pStrmEx:%x\n", pStrmEx));
        if(!pStrmEx) {
            Srb->Status = STATUS_SUCCESS;
            break;
        }

        if(pStrmEx->KSState == KSSTATE_PAUSE || pStrmEx->KSState == KSSTATE_RUN) {
            ERROR_LOG(("Does not support hibernation while streaming!\n"));
            Srb->Status = STATUS_NOT_SUPPORTED;
        } else {
            ERROR_LOG(("OK to hibernation if not streaming\n"));
            Srb->Status = STATUS_SUCCESS;
        }
        break;
#endif
    case IRP_MN_BUS_RESET:
    //
    // We will realocate the resource (bandwith and channel) in IRQL PASSIVE level.
    //
        Srb->Status = STATUS_SUCCESS;
        Status = STATUS_SUCCESS;

        //
        // The generation count is updated in the bus reset callback notification only.
        // Continue iff the generation count has been updated.
        // Else, we are assuming another bus reset has occurred,
        // and we will pass to us later.
        //
        if(pDevExt->CurrentGeneration != *((PULONG) &IrpStack->Parameters.Others.Argument4)) {
            ERROR_LOG(("DCamProcessPnpIrp: Generation count old (%d) != new (%d); STOP!\n", 
               pDevExt->CurrentGeneration, *((PULONG) &IrpStack->Parameters.Others.Argument4)) );
            break;
        }

        pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
        DbgMsg2(("\'%d:%s) SonyDCamProcessPnpIrp: pDevExt %x; pStrmEx %x; CurGen %d\n", 
            pDevExt->idxDev, pDevExt->pchVendorName, pDevExt, pStrmEx, pDevExt->CurrentGeneration));

        //
        // If the stream was open (pStrmEx != NULL && pStrmEx->pVideoInfoHeader != NULL);
        // We need to ask controller to allocate bandwidth and channel. 
        //
        if(pStrmEx &&
           pStrmEx->pVideoInfoHeader != NULL) {

            DbgMsg2(("\'%d:%s) DCamProcessPnpIrp: Stream was open so re-allocate resource.\n", pDevExt->idxDev, pDevExt->pchVendorName));


            // Allocate Irb 
            pIrb = ExAllocatePoolWithTag(NonPagedPool, sizeof(IRB), 'macd');
            if(!pIrb) {            
                ERROR_LOG(("\'DCamProcessPnpIrp: allocate IRB failed; insufficient resource.\n"));
                Srb->Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            } else {
                ULONG ulChannel;
                HANDLE hResource;

                pIrp = IoAllocateIrp(pDevExt->BusDeviceObject->StackSize, FALSE);
                if(!pIrp) {
                    ExFreePool(pIrb);
                    Srb->Status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                RtlZeroMemory(pIrb, sizeof(IRB));

                //
                // Bus reset will free the bandwidth but not the bandwidth structure allocated by the lower driver                
                //
                if (pDevExt->hBandwidth) {

                    DbgMsg2(("\'DCamProcessPnpIrp: Attempt to free ->hBandwidth\n"));

                    pIrb->FunctionNumber = REQUEST_ISOCH_FREE_BANDWIDTH;
                    pIrb->Flags = 0;
                    pIrb->u.IsochFreeBandwidth.hBandwidth = pDevExt->hBandwidth;
                    Status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);

                    if (Status) {
                        ERROR_LOG(("DCamProcessPnpIrp: Error %x while trying to free Isoch bandwidth\n", Status));
                        ASSERT(Status == STATUS_SUCCESS || Status ==  STATUS_INVALID_GENERATION);
                    }

                    pDevExt->hBandwidth = NULL;
                }


                //
                // Before we assign the new hResource, we wait for it attaching buffer to complete.
                // For buffer that completed with previous hResource,
                // It will complete with error ?
                //

                StatusWait = KeWaitForSingleObject( &pStrmEx->hMutex, Executive, KernelMode, FALSE, 0 ); 


                //
                // Reallocate bandwidth and channel, and resource if necessary.
                // IF THIS FAIL, we are consider illegally streaming, and need to STOP streaming.
                //

                ulChannel = pDevExt->IsochChannel;
                hResource = pDevExt->hResource;

                Status = DCamAllocateIsochResource(pDevExt, pIrb, FALSE);
 
                if(Status) {

                    ERROR_LOG(("\'%d:%s) DCamProcessPnpIrp: Re-AllocateIsochResource failed! Status=%x; Treat as device removed.\n\n", 
                        pDevExt->idxDev, pDevExt->pchVendorName, Status));
                    ASSERT(Status == STATUS_SUCCESS);

                    //
                    // No resource so let's treat this situation as
                    // Device has been removed because there is no
                    // way to restart this.
                    // This will stop future SRB_READ until stream is STOP and RUN again.
                    //

                    pDevExt->bDevRemoved = TRUE;                   
                    Srb->Status = STATUS_INSUFFICIENT_RESOURCES;

                    // 
                    // Stop tranmission so it will not send data to the old channel,
                    // which might be "owned" by other device.
                    //

                    if(pStrmEx->KSState == KSSTATE_RUN) {
                        // Disable EnableISO
                        DCamIsoEnable(pIrb, pDevExt, FALSE);
                    }

                    KeReleaseMutex(&pStrmEx->hMutex, FALSE);                
                    ExFreePool(pIrb);
                    IoFreeIrp(pIrp);
                    return;
                }

                //
                // If channel number change due to bus reset, we must
                //    - continue to blocking incoming SRB_READ (with mutex)
                //    - if RUN state, stop transmission
                //    - detach all pending buffer(s)
                //    - free "stale" isoch resource
                //    - if RUN state, program device to use the new channel
                //    - if RUN state, restart transmission
                //

                if(pDevExt->IsochChannel != ISOCH_ANY_CHANNEL &&
                   ulChannel != pDevExt->IsochChannel) {

                    // 
                    // Stop tranmission so it will not send data to the old channel,
                    // which might be "owned" by other device.
                    //

                    if(pStrmEx->KSState == KSSTATE_RUN) {
                        // Disable EnableISO
                        DCamIsoEnable(pIrb, pDevExt, FALSE);
                    }

 
                    //
                    // Detach pending packets using the hOldRources and reattached using the new hResource
                    // Note: incoming SRB_READ is block right now.
                    //       free old resource after all pending reads are detached.
                    //

                    if(pDevExt->PendingReadCount > 0) {

                        Status = DCamReSubmitPacket(hResource, pDevExt, pStrmEx, pDevExt->PendingReadCount);
                    }


                    //
                    // Free "stale" isoch resource 
                    //

                    if(pDevExt->hResource != hResource) {

                        DbgMsg2(("DCamReSubmitPacket: Attempt to free hStaleResource %x\n", hResource));
                        pIrb->FunctionNumber = REQUEST_ISOCH_FREE_RESOURCES;
                        pIrb->Flags = 0;
                        pIrb->u.IsochFreeResources.hResource = hResource;
                        Status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);    
                        if (Status) {
                            ERROR_LOG(("\'DCamFreeIsochResource: Error %x while trying to free Isoch resources\n\n", Status));
                            ASSERT(Status == STATUS_SUCCESS);
                        }    
                    }

                    //
                    // Getting ready to accept callback
                    //
                    pDevExt->bStopIsochCallback = FALSE;
                    
                    //
                    // Restore to its initial Streaming state
                    // mainly, programming device.
                    //

                    DCamSetKSStateInitialize(pDevExt);                    
                }

                KeReleaseMutex(&pStrmEx->hMutex, FALSE);                
                ExFreePool(pIrb);
                IoFreeIrp(pIrp);
            }
        }

        if(Status == STATUS_SUCCESS) {

            //
            // Set to last saved configuration
            //

            SetCurrentDevicePropertyValues(pDevExt, (PIRB) Srb->SRBExtension);
        }

        DbgMsg2(("\'DCamProcessPnpIrp, IRP_MN_BUS_RESET: Done, Status %x\n", Status));

        break;
            
    case IRP_MN_QUERY_CAPABILITIES: 
        ERROR_LOG(("\'SonyDCamProcessPnpIrp: IRP_MN_QUERY_CAPABILITIES: Srb->Status = STATUS_NOT_IMPLEMENTED.\n"));
    default:
        Srb->Status = STATUS_NOT_IMPLEMENTED;
        break;
    }
}


VOID 
DCamChangePower(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
)

/*++

Routine Description:

    Process chnaging this device's power state.  

Arguments:

    Srb - Pointer to Stream request block

Return Value:

    Nothing

--*/
{
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(pSrb->Irp);
    DEVICE_POWER_STATE DevicePowerState = pSrb->CommandData.DeviceState;

    PAGED_CODE();

    pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;
    DbgMsg2(("\'DCamChangePower: pSrb=%x; pDevExt=%x\n", pSrb, pDevExt));

    ASSERT(pDevExt != NULL);
    if(!pDevExt) {   
        pSrb->Status = STATUS_INVALID_PARAMETER;
        ERROR_LOG(("DCamChangePower: pDevExt is NULL!\n"));
        return;
    }

    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;     
    if (pStrmEx ==NULL) {        
        pSrb->Status = STATUS_SUCCESS;
        pDevExt->CurrentPowerState = DevicePowerState;
        DbgMsg2(("DCamChangePower: pStrmEx is NULL => Stream is not open. That is Ok!!\n"));
        return;
    }

   


    // 
    // We can honor power state change:
    //
    //    D0: device is on and running
    //    D1,D2: not implemented.
    //    D3: device is off and not running.  Device context is lost.  
    //        Power can be removed from the device.
    //        when power is back on, we will get a bus reset.
    //
    //    (0) Remove DontSuspendIfStreamsAreRunning from INF
    //    save current state.
    //    (1) ->D3, to PAUSE/STOP state (depends on if pending buffers can be kept by its lower driver)
    //    (2) ->D0, to restore saved state
    //
    // We can do the above but we do not know at this point 
    // how our client application react
    //
    if(IrpStack->MinorFunction == IRP_MN_SET_POWER) {
        DbgMsg2(("DCamChangePower: changin power state from %d to %d.\n", pDevExt->CurrentPowerState, DevicePowerState));

        pSrb->Status = STATUS_SUCCESS;

        if(pDevExt->CurrentPowerState != DevicePowerState) {

            switch (DevicePowerState) {
            case PowerDeviceD3:        // D0->D3: save state, stop streaming and Sleep
                if( pDevExt->CurrentPowerState == PowerDeviceD0 ) {
                    DbgMsg1(("DCamChangePower: Switching from D0 to D3; Save current state.\n"));
                    // Save current state to be restored when awake
                    pStrmEx->KSSavedState = pStrmEx->KSState;
                }
                break;

            case PowerDeviceD0:  // to Wakeup, restore state and running
                if( pDevExt->CurrentPowerState == PowerDeviceD3 ) {
                    DbgMsg1(("DCamChangePower: Switching from D3 to D0; restore state.\n"));
                    pStrmEx->KSState = pStrmEx->KSSavedState;                         
                }
                break;

            // These state are not defined and noe used.
            case PowerDeviceD1:
            case PowerDeviceD2:               
            default:
                ERROR_LOG(("DCamChangePower: Invalid PowerState %d\n", DevicePowerState));                  
                pSrb->Status = STATUS_INVALID_PARAMETER;
                break;
            }
        }            

        if(pSrb->Status == STATUS_SUCCESS) 
            pDevExt->CurrentPowerState = DevicePowerState;         

    } else {
       
        pSrb->Status = STATUS_NOT_IMPLEMENTED;

    }


}




VOID
DCamGetStreamInfo(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    Returns the information of all streams that are supported by the driver

Arguments:

    Srb - Pointer to Stream request block

Return Value:

    Nothing

--*/

{
    //
    // pick up the pointer to the stream information data structure
    //
    PIRB pIrb;
    PHW_STREAM_HEADER StreamHeader = &(Srb->CommandData.StreamBuffer->StreamHeader);        
    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) Srb->HwDeviceExtension;
    PHW_STREAM_INFORMATION StreamInfo = &(Srb->CommandData.StreamBuffer->StreamInfo);

    PAGED_CODE();

    pIrb = (PIRB) Srb->SRBExtension;

    //
    // set number of streams
    //

    ASSERT (Srb->NumberOfBytesToTransfer >= 
            sizeof (HW_STREAM_HEADER) +
            sizeof (HW_STREAM_INFORMATION));

    //
    // initialize stream header
    //

    RtlZeroMemory(StreamHeader, 
                sizeof (HW_STREAM_HEADER) +
                sizeof (HW_STREAM_INFORMATION));

    //
    // initialize the number of streams supported
    //

    StreamHeader->NumberOfStreams = 1;
    StreamHeader->SizeOfHwStreamInformation = sizeof(HW_STREAM_INFORMATION);

    //
    // set the device property info
    // 

    StreamHeader->NumDevPropArrayEntries = pDevExt->ulPropSetSupported;
    StreamHeader->DevicePropertiesArray  = &pDevExt->VideoProcAmpSet;


    //
    // Initialize the stream structure.
    //
    // Number of instances field indicates the number of concurrent streams
    // of this type the device can support.  
    //

    StreamInfo->NumberOfPossibleInstances = 1;

    //
    // indicates the direction of data flow for this stream, relative to 
    // the driver
    //

    StreamInfo->DataFlow = KSPIN_DATAFLOW_OUT;

    //
    // dataAccessible - Indicates whether the data is "seen" by the host
    // processor.
    //

    StreamInfo->DataAccessible = TRUE;

    // 
    // Return number of formats and the table.
    // These information is collected dynamically.
    //
    StreamInfo->NumberOfFormatArrayEntries = pDevExt->ModeSupported;
    StreamInfo->StreamFormatsArray = &pDevExt->DCamStrmModes[0];


    //
    // set the property information for the video stream
    //


    StreamInfo->NumStreamPropArrayEntries = NUMBER_VIDEO_STREAM_PROPERTIES;
    StreamInfo->StreamPropertiesArray = (PKSPROPERTY_SET) VideoStreamProperties;

    //
    // set the pin name and category
    //

    StreamInfo->Name = (GUID *) &PINNAME_VIDEO_CAPTURE;
    StreamInfo->Category = (GUID *) &PINNAME_VIDEO_CAPTURE;


    //
    // store a pointer to the topology for the device
    //
        
    Srb->CommandData.StreamBuffer->StreamHeader.Topology = &Topology;


    //
    // indicate success
    //

    Srb->Status = STATUS_SUCCESS;

    DbgMsg2(("\'DCamGetStreamInfo: NumFormat %d, StreamFormatArray %x\n",
        StreamInfo->NumberOfFormatArrayEntries,  StreamInfo->StreamFormatsArray));

}

#define TIME_ROUNDING                        1000   // Give it some rounding error of 100microsec
#define TIME_0750FPS      (1333333+TIME_ROUNDING)   // 1/7.50 * 10,000,000 (unit=100ns)
#define TIME_1500FPS       (666666+TIME_ROUNDING)   // 1/15.0 * 10,000,000 (unit=100ns)  do not round to 666667
#define TIME_3000FPS       (333333+TIME_ROUNDING)   // 1/30.0 * 10,000,000 (unit=100ns)

NTSTATUS
DCamAllocateIsochResource(
    PDCAM_EXTENSION pDevExt,
    PIRB Irb,
    BOOL bAllocateResource
    )
{
    PIRP Irp;
    CCHAR StackSize;
    ULONG ModeIndex;
    PSTREAMEX pStrmEx;
    DWORD dwAvgTimePerFrame, dwCompression;
    ULONG fulSpeed;
    NTSTATUS Status = STATUS_SUCCESS;


    ASSERT(pDevExt);
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
    ASSERT(pStrmEx);


    DbgMsg2(("\'DCamAllocateIsochResource: enter; pStrmEx %x; pVideoInfo %x\n", pStrmEx, pStrmEx->pVideoInfoHeader));
    //
    // Now if they're on a YUV4:2:2 format, we've gotta check what
    // resolution they want it at, since we support this format
    // but in two different resolutions (modes on the camera).
    //

    // This is the INDEX to the frame rate and resource allocation; see IsochInfoTable.
    // 0 : reserved
    // 1 : 3.75
    // 2 : 7.5
    // 3 : 15 (DEFAULT_FRAME_RATE)
    // 4 : 30 
    // 5 : 60 (Not supported for Mode 1 & 3)
    dwAvgTimePerFrame = (DWORD) pStrmEx->pVideoInfoHeader->AvgTimePerFrame;
    dwCompression = (DWORD) pStrmEx->pVideoInfoHeader->bmiHeader.biCompression;



    // Determine the Frame rate
    if (dwAvgTimePerFrame      > TIME_0750FPS) 
        pDevExt->FrameRate = 1;        //  3.75FPS
    else if (dwAvgTimePerFrame >  TIME_1500FPS) 
        pDevExt->FrameRate = 2;        //  7.5FPS
    else if (dwAvgTimePerFrame >  TIME_3000FPS) 
        pDevExt->FrameRate = 3;        // 15 FPS
    else 
        pDevExt->FrameRate = 4;        // 30 FPS


    DbgMsg2(("\'DCamAllocateIsochResource: FrameRate: %d FPS\n", (1 << (pDevExt->FrameRate-1)) * 15 / 4));

    // Determine the Video Mode
    switch(dwCompression) {
#ifdef SUPPORT_YUV444          
    case FOURCC_Y444:     // Mode 0
         ModeIndex = VMODE0_YUV444;
         break;
#endif
    case FOURCC_UYVY:     // Mode 1 or 3
         if (pStrmEx->pVideoInfoHeader->bmiHeader.biWidth == 640 &&
             (pStrmEx->pVideoInfoHeader->bmiHeader.biHeight == 480 || 
             pStrmEx->pVideoInfoHeader->bmiHeader.biHeight == -480)) {
              ModeIndex = VMODE3_YUV422;
              // Max frame rate is 15
              if(pDevExt->FrameRate > 3)
                 pDevExt->FrameRate = 3;
         } else
              ModeIndex = VMODE1_YUV422;
         break;
#ifdef SUPPORT_YUV411          
    case FOURCC_Y411:     // Mode 2
         ModeIndex = VMODE2_YUV411;
         break;
#endif

#ifdef SUPPORT_RGB24          
    case KS_BI_RGB:  // = 0
         ModeIndex = VMODE4_RGB24;
         // Max frame rate is 15
         if(pDevExt->FrameRate > 3)
            pDevExt->FrameRate = 3;
         break;
#endif

#ifdef SUPPORT_YUV800
    case FOURCC_Y800:  
         ModeIndex = VMODE5_YUV800;
         break;
#endif

    default:          
         Status = STATUS_NOT_IMPLEMENTED;;
         return Status;;
    }


    DbgMsg1(("\'DCamAllocateIsochResource: ModeIndex=%d, AvgTimePerFrame=%d, FrameRate=%d\n", 
             ModeIndex, dwAvgTimePerFrame, pDevExt->FrameRate));

    //
    // Get an Irp so we can send some allocation commands down
    //

    StackSize = pDevExt->BusDeviceObject->StackSize;
    Irp = IoAllocateIrp(StackSize, FALSE);

    if (!Irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Calculate the index to use to reference the ISOCH table
    //
    pStrmEx->idxIsochTable = ModeIndex * NUM_POSSIBLE_RATES + pDevExt->FrameRate;

    ASSERT(pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage == IsochInfoTable[pStrmEx->idxIsochTable].CompletePictureSize);
    DbgMsg2(("\'DCamAllocateIsochResource: ModeIndex=%d, idxIsochTable=%d, biSizeImage=%d, CompletePictureSize=%d\n", 
             ModeIndex, pStrmEx->idxIsochTable, pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage, IsochInfoTable[pStrmEx->idxIsochTable].CompletePictureSize));          

    //
    // 0. Determine the MAX_SPEED and not use the speed defined in the static table.
    //
    Irb->FunctionNumber = REQUEST_GET_SPEED_BETWEEN_DEVICES;
    Irb->Flags = 0;
    Irb->u.GetMaxSpeedBetweenDevices.fulFlags = USE_LOCAL_NODE;
    Irb->u.GetMaxSpeedBetweenDevices.ulNumberOfDestinations = 0;
    Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);
    if(Status) {
        ERROR_LOG(("\'DCamAllocateIsochResource: Error %x while trying to get maximun speed between devices.\n", Status));        

        IoFreeIrp(Irp);
        return STATUS_INSUFFICIENT_RESOURCES;
    }     
    
    fulSpeed = Irb->u.GetMaxSpeedBetweenDevices.fulSpeed;

    //
    // The max speed between devices should be within supported speed range, and
    // must be equal or greater than the required speed for the chosen format.
    //
    if(
        (  fulSpeed != SPEED_FLAGS_100 
        && fulSpeed != SPEED_FLAGS_200 
        && fulSpeed != SPEED_FLAGS_400
        )
        || fulSpeed < IsochInfoTable[pStrmEx->idxIsochTable].SpeedRequired
       ) {

        ASSERT(fulSpeed == SPEED_FLAGS_100 || fulSpeed == SPEED_FLAGS_200 ||  fulSpeed == SPEED_FLAGS_400);
        ASSERT(fulSpeed >= IsochInfoTable[pStrmEx->idxIsochTable].SpeedRequired);

        IoFreeIrp(Irp);
        return STATUS_UNSUCCESSFUL;
    }

    pDevExt->SpeedCode = fulSpeed >> 1;  // Safe for S100, 200 and 400 (is checked above).
    DbgMsg2(("\'GetMaxSpeedBetweenDevices.fulSpeed=%x; SpeedCode:%x\n", fulSpeed, pDevExt->SpeedCode));


    //
    // 1. Allocate CHANNEL
    //       First try to re-allocate the same channel
    //       If it is used, try to get any channel.  1394DCam can only be on channel 0..15
    //
    Irb->FunctionNumber = REQUEST_ISOCH_ALLOCATE_CHANNEL;
    Irb->Flags = 0;

    //
    //      ULONG           nRequestedChannel;      // Need a specific channel
    //      ULONG           Channel;                // Returned channel
    //      LARGE_INTEGER   ChannelsAvailable;      // Channels available
    // Instead of hardcoded '0'; use -1 to ask the bus driver to get the next available channel for us.
    // -1 (any channel) or an existing channel
    Irb->u.IsochAllocateChannel.nRequestedChannel = pDevExt->IsochChannel;  
    Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);
    if(Status) {

        //
        // Due to channel change, 
        // all Pending read will be either resubmitted, 
        // or cancelled (if out of resource).
        //
        pDevExt->bStopIsochCallback = TRUE;  // Set back to FALSE after pending buffer are attached.


        //
        // If this is an initial request and no channel available,
        // free all resource and abort.
        //
        if(pDevExt->IsochChannel == ISOCH_ANY_CHANNEL)
            goto NoResource_abort;

        DbgMsg1(("DCamAllocateIsochResource: last allocated channel %d is not available; pending count %d.\n",  
            pDevExt->IsochChannel, pDevExt->PendingReadCount));                      

        // Try gettting any channel.
        Irb->FunctionNumber = REQUEST_ISOCH_ALLOCATE_CHANNEL;
        Irb->Flags = 0;
        Irb->u.IsochAllocateChannel.nRequestedChannel = ISOCH_ANY_CHANNEL;  
        Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);
        if(Status) {
            ERROR_LOG(("DCamAllocateIsochResource: allocate any channel failed, status %x!\n",  Status));
            goto NoResource_abort;           
        }

        //
        // Channel changed, we MUST reallocate resource.
        // The "stale" resrouce will be free later when 
        // pending packet are detached.
        //

        bAllocateResource = TRUE;
    }   
    
    DbgMsg1(("**IsochAlloc: Channel(Old) %d, requested %d, got %d, HiLo(0x%x:%x), PendingRead %d\n", 
         pDevExt->IsochChannel, 
         Irb->u.IsochAllocateChannel.nRequestedChannel, 
         Irb->u.IsochAllocateChannel.Channel, 
         Irb->u.IsochAllocateChannel.ChannelsAvailable.u.HighPart,
         Irb->u.IsochAllocateChannel.ChannelsAvailable.u.LowPart,
         pDevExt->PendingReadCount));

    // New channel
    pDevExt->IsochChannel = Irb->u.IsochAllocateChannel.Channel;  // Used in allocating iso. resource and reallocation


    //
    // 2. Allocate BANDWIDTH
    //
    Irb->FunctionNumber = REQUEST_ISOCH_ALLOCATE_BANDWIDTH;
    Irb->Flags = 0;
    Irb->u.IsochAllocateBandwidth.nMaxBytesPerFrameRequested = IsochInfoTable[pStrmEx->idxIsochTable].QuadletPayloadPerPacket << 2;
    Irb->u.IsochAllocateBandwidth.fulSpeed = fulSpeed;
    Irb->u.IsochAllocateBandwidth.hBandwidth = 0;
    Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);
    
    if(Status) {
        ERROR_LOG(("DCamAllocateIsochResource: Error %x while trying to allocate Isoch bandwidth\n", Status));                  
        goto NoResource_abort;
    }

    pDevExt->hBandwidth = Irb->u.IsochAllocateBandwidth.hBandwidth;
    DbgMsg2(("**IsochAlloc: nMaxBytesPerFrameRequested %d, fulSpeed %d; hBandWidth 0x%x\n",
         IsochInfoTable[pStrmEx->idxIsochTable].QuadletPayloadPerPacket << 2, fulSpeed, pDevExt->hBandwidth));



    //
    // 3. Allocate RESOURCES
    //    Note: after a bus reset, we need not free and re-allocate this resoruce again.
    //
    if(bAllocateResource) {
        Irb->FunctionNumber = REQUEST_ISOCH_ALLOCATE_RESOURCES;
        Irb->Flags = 0;
        Irb->u.IsochAllocateResources.fulSpeed = fulSpeed;
        Irb->u.IsochAllocateResources.nChannel = pDevExt->IsochChannel;
        Irb->u.IsochAllocateResources.nMaxBytesPerFrame = IsochInfoTable[pStrmEx->idxIsochTable].QuadletPayloadPerPacket << 2;
        // For slower frame rate use smaller quadlets
        // smaller frame size will use more packet to fill the same amount of data
        // this is why smaller frame rate actually demand more resource !!
        Irb->u.IsochAllocateResources.nNumberOfBuffers = MAX_BUFFERS_SUPPLIED + 1;  // "+1" as a "safety"
        Irb->u.IsochAllocateResources.nMaxBufferSize = IsochInfoTable[pStrmEx->idxIsochTable].CompletePictureSize;
        if (pDevExt->HostControllerInfomation.HostCapabilities & HOST_INFO_SUPPORTS_RETURNING_ISO_HDR) {       
            Irb->u.IsochAllocateResources.nQuadletsToStrip = 1;
            Irb->u.IsochAllocateResources.fulFlags = RESOURCE_USED_IN_LISTENING | RESOURCE_STRIP_ADDITIONAL_QUADLETS;

        } else {
            Irb->u.IsochAllocateResources.nQuadletsToStrip = 0;
            Irb->u.IsochAllocateResources.fulFlags = RESOURCE_USED_IN_LISTENING;
        }

        Irb->u.IsochAllocateResources.hResource = 0;
        DbgMsg2(("\'DCamAllocateIsochResource: fullSpeed(%d), nMaxBytesPerFrame(%d), nMaxBufferSize(%d)\n", 
                              Irb->u.IsochAllocateResources.fulSpeed,
                              Irb->u.IsochAllocateResources.nMaxBytesPerFrame,
                              Irb->u.IsochAllocateResources.nMaxBufferSize));
        Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);          

        if(Status) {
            ERROR_LOG(("DCamAllocateIsochResource: Error %x while trying to allocate Isoch resources\n", Status));
            goto NoResource_abort;
        }


        pDevExt->hResource = Irb->u.IsochAllocateResources.hResource;

    }

    pDevExt->CurrentModeIndex = ModeIndex;
    DbgMsg2(("**IsochAlloc: hResource = %x\n", pDevExt->hResource));

    IoFreeIrp(Irp);     

    return STATUS_SUCCESS;



NoResource_abort:

    // Free bandwidth
    if(pDevExt->hBandwidth != NULL) {

        Irb->FunctionNumber = REQUEST_ISOCH_FREE_BANDWIDTH;
        Irb->Flags = 0;
        Irb->u.IsochFreeBandwidth.hBandwidth = pDevExt->hBandwidth;
        Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);
        pDevExt->hBandwidth = NULL;
        if(Status) {
            ERROR_LOG(("DCamAllocateIsochResource: Error %x while trying to free Isoch bandwidth\n", Status));
        }
    }

    // Free channel
    if (pDevExt->IsochChannel != ISOCH_ANY_CHANNEL) {

        Irb->FunctionNumber = REQUEST_ISOCH_FREE_CHANNEL;
        Irb->Flags = 0;
        Irb->u.IsochFreeChannel.nChannel = pDevExt->IsochChannel;
        Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);
        pDevExt->IsochChannel = ISOCH_ANY_CHANNEL;  // Reset it.

        if(Status) {
            ERROR_LOG(("DCamAllocateIsochResource: Error %x while trying to free Isoch channel\n", Status));
        }
    }


    IoFreeIrp(Irp);
    return STATUS_INSUFFICIENT_RESOURCES;
    
}


NTSTATUS
DCamFreeIsochResource (
    PDCAM_EXTENSION pDevExt,
    PIRB Irb,
    BOOL bFreeResource
    )
/*++

Routine Description:

    Free resource allocated in DCamAllocateIsochResource().

Arguments:

    Srb - Pointer to Stream request block

Return Value:

    Nothing

--*/
{
    PIRP Irp;
    CCHAR StackSize;
    NTSTATUS Status = STATUS_SUCCESS;


    PAGED_CODE();

    DbgMsg2(("\'DCamFreeIsochResource: enter; DevExt=%x, Irb=%x\n", pDevExt, Irb));

    ASSERT(pDevExt);
    ASSERT(Irb);


    if(Irb == 0 ||
       pDevExt == 0) {
       DbgMsg2(("\'DCamFreeIsochResource: ABORTED!\n"));
       return STATUS_SUCCESS;
    }
    //
    // Get an Irp so we can send some free commands down
    //
    StackSize = pDevExt->BusDeviceObject->StackSize;
    Irp = IoAllocateIrp(StackSize, FALSE);

    if (!Irp) {   
        ERROR_LOG(("DCamFreeIsochResource: Error %x while trying to allocate an Irp\n\n", Status));
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // 1. Free Resource
    //
    if (pDevExt->hResource && bFreeResource) {

        DbgMsg2(("\'DCamFreeIsochResource: Attempt to free ->hResource\n"));

        Irb->FunctionNumber = REQUEST_ISOCH_FREE_RESOURCES;
        Irb->Flags = 0;
        Irb->u.IsochFreeResources.hResource = pDevExt->hResource;
        Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);

        pDevExt->hResource = NULL;
        if (Status) {

            ERROR_LOG(("DCamFreeIsochResource: Error %x while trying to free Isoch resources\n\n", Status));
        }
    }

    //
    // 2. Free Channel
    //
    if (pDevExt->IsochChannel != ISOCH_ANY_CHANNEL) {

        DbgMsg2(("\'DCamFreeIsochResource: Attempt to free ->IsochChannel\n"));

        Irb->FunctionNumber = REQUEST_ISOCH_FREE_CHANNEL;
        Irb->Flags = 0;
        Irb->u.IsochFreeChannel.nChannel = pDevExt->IsochChannel;
        Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);

        pDevExt->IsochChannel = ISOCH_ANY_CHANNEL;

        if(Status) {
            
            ERROR_LOG(("DCamFreeIsochResource: Error %x while trying to free Isoch channel\n\n", Status));
        }
    }

    //
    // 3. Free Bandwidth
    //
    if (pDevExt->hBandwidth) {

        DbgMsg2(("\'DCamFreeIsochResource: Attempt to free ->hBandwidth\n"));

        Irb->FunctionNumber = REQUEST_ISOCH_FREE_BANDWIDTH;
        Irb->Flags = 0;
        Irb->u.IsochFreeBandwidth.hBandwidth = pDevExt->hBandwidth;
        Status = DCamSubmitIrpSynch(pDevExt, Irp, Irb);

        pDevExt->hBandwidth = NULL;

        if (Status) {

            ERROR_LOG(("DCamFreeIsochResource: Error %x while trying to free Isoch bandwidth\n", Status));
        }
    }

    DbgMsg2(("\'DCamFreeIsochResource: hResource = %x\n", pDevExt->hResource));


    IoFreeIrp(Irp);

    return STATUS_SUCCESS;

}



VOID 
InitializeStreamExtension(
    PDCAM_EXTENSION pDevExt,
    PHW_STREAM_OBJECT   pStreamObject,
    PSTREAMEX           pStrmEx
    )
{
    PAGED_CODE();

    pStrmEx->hMasterClock = 0;
    pStrmEx->FrameInfo.ExtendedHeaderSize = sizeof(KS_FRAME_INFO);
    pStrmEx->FrameInfo.PictureNumber = 0;
    pStrmEx->FrameInfo.DropCount     = 0;
    pStrmEx->FrameInfo.dwFrameFlags  = 0;     
    pStrmEx->FirstFrameTime    = 0;
    pStrmEx->pVideoInfoHeader  = 0;
    pStrmEx->KSState           = KSSTATE_STOP;
    pStrmEx->KSSavedState      = KSSTATE_STOP;


    KeInitializeMutex( &pStrmEx->hMutex, 0);  // Level 0 and in Signal state

}

BOOL
DCamDeviceInUse(
    PIRB pIrb,
    PDCAM_EXTENSION pDevExt
)
/*++

Routine Description:

    See if this device is in used.  
    We check ISO_ENABLE since this is the only register
    in a 1394DCam that we can set/get and 99%+ of time
    this bit is set by its owner.

Arguments:

    pIrb - Pointer to IEEE 1394 Request Block definition (IRB)
    pDevExt - this device extension

Return Value:

    TRUE:  Iso_enable != 0
    FALSE: iso_enable == 0

--*/

{
    DCamRegArea RegArea;
    NTSTATUS status;
    LONG lRetries = MAX_READ_REG_RETRIES;


    // If a device is removed, it is not available.
    if(pDevExt->bDevRemoved)
        return TRUE;

    do {
        RegArea.AsULONG = 0;
        status = DCamReadRegister(pIrb, pDevExt, FIELDOFFSET(CAMERA_REGISTER_MAP, IsoEnable), &(RegArea.AsULONG));
#if DBG
        if(!NT_SUCCESS(status))
            ERROR_LOG(("**** DCamDeviceInUse: Status %x, ISO_ENABLE %x\n", status, RegArea.AsULONG));
#endif
    } while (--lRetries > 0 && !NT_SUCCESS(status));

    if(NT_SUCCESS(status)) 
        return ((RegArea.AsULONG & ISO_ENABLE_BIT) == ISO_ENABLE_BIT);

    // failed to query the device.
    return TRUE;  // Assume it is in use.
}


VOID
DCamOpenStream(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )

/*++

Routine Description:

    Called when an OpenStream Srb request is received

Arguments:

    pSrb - Pointer to Stream request block

Return Value:

    Nothing

--*/

{

    PIRB Irb;
    ULONG nSize;
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;
    PKS_DATAFORMAT_VIDEOINFOHEADER  pKSDataFormat = 
                (PKS_DATAFORMAT_VIDEOINFOHEADER) pSrb->CommandData.OpenFormat;
    PKS_VIDEOINFOHEADER     pVideoInfoHdrRequested = 
                &pKSDataFormat->VideoInfoHeader;


    PAGED_CODE();

    Irb = (PIRB) pSrb->SRBExtension;
    pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;
    pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;

    DbgMsg2(("\'DCamOpenStream: >>> !!! pDevEx %x; pStrmEx %x !!!\n", pDevExt, pStrmEx));


    //
    // Cache the stream extension.
    //

    pDevExt->pStrmEx = pStrmEx; 


    //
    // default to success
    //

    pSrb->Status = STATUS_SUCCESS;

    //
    // determine which stream number is being opened.  This number indicates
    // the offset into the array of streaminfo structures that was filled out
    // in the AdapterStreamInfo call.
    //
    // So:
    //   0 - Video data from camera
    //

    switch (pSrb->StreamObject->StreamNumber) {

    case 0:

         //
         // Make sure that this device is not in used 
         //
         if(DCamDeviceInUse(Irb, pDevExt)) {
             ERROR_LOG(("Device is in used! Open Stream fail!!\n"));
             pDevExt->pStrmEx = NULL; 
             pSrb->Status = STATUS_UNSUCCESSFUL;
             return;
         }


         //
         // Figure out what format they're trying to open first
         //

         if (!AdapterVerifyFormat (pDevExt->ModeSupported, pDevExt->DCamStrmModes, pKSDataFormat, pSrb->StreamObject->StreamNumber)) {
             pDevExt->pStrmEx = NULL; 
             ERROR_LOG(("DCamOpenStream: AdapterVerifyFormat failed.\n"));
             pSrb->Status = STATUS_INVALID_PARAMETER;
             return;
         }

         InitializeStreamExtension(pDevExt, pSrb->StreamObject, pStrmEx);

         // It should already been freed by DCamCloseStream()
         ASSERT(pStrmEx->pVideoInfoHeader == NULL);
         ASSERT(pVideoInfoHdrRequested != (PKS_VIDEOINFOHEADER) 0);

         // Use this instead of sizeof(KS_VIDEOINFOHEADER) to handle variable size structure
         nSize = KS_SIZE_VIDEOHEADER (pVideoInfoHdrRequested);

         pStrmEx->pVideoInfoHeader = ExAllocatePoolWithTag(NonPagedPool, nSize, 'macd');
         if (pStrmEx->pVideoInfoHeader == NULL) {

             ERROR_LOG(("DCamOpenStream: ExAllocatePool (->pVideoInfoHeader) failed!\n"));
             ASSERT(pStrmEx->pVideoInfoHeader != NULL);

             pDevExt->pStrmEx = NULL;

             pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
             return;
         }

         // Copy the VIDEOINFOHEADER requested to our storage
         RtlCopyMemory(
                    pStrmEx->pVideoInfoHeader,
                    pVideoInfoHdrRequested,
                    nSize);

         DbgMsg3(("\'DCamOpenStream: Copied biSizeImage=%d Duration=%ld (100ns)\n", 
                    pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage, (DWORD) pStrmEx->pVideoInfoHeader->AvgTimePerFrame));

         // Allocate ISOCH resource
         pSrb->Status = DCamAllocateIsochResource(pDevExt, pSrb->SRBExtension, TRUE);               
         
         if (pSrb->Status) {

             ERROR_LOG(("DCamOpenStream: !!!! Allocate ISOCH resource failed.  CanNOT STREAM!!!!!\n"));
             
             ExFreePool(pStrmEx->pVideoInfoHeader);
             pStrmEx->pVideoInfoHeader = NULL;             
             pDevExt->pStrmEx = NULL;
             pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;             
             return;
         } 

         pSrb->StreamObject->ReceiveDataPacket    = (PVOID) DCamReceiveDataPacket;
         pSrb->StreamObject->ReceiveControlPacket = (PVOID) DCamReceiveCtrlPacket;

         // If bus reset failed and user close the stream and reopen the stream successfully,
         // This must be reset !!
         if(pDevExt->bDevRemoved || pDevExt->bStopIsochCallback) {
            DbgMsg1(("Stream Open successful, reset bDevRemoved and bStopCallback!!\n"));
            pDevExt->bStopIsochCallback = FALSE;
            pDevExt->bDevRemoved = FALSE;
         }

         //
         // initialize the stream extension data handling information
         //

         break;

    default:
         ERROR_LOG(("DCamOpenStream: Hit a non-support pSrb->StreamObject->StreamNumber (%d).\n", pSrb->StreamObject->StreamNumber));
         ASSERT(FALSE);
         pDevExt->pStrmEx = NULL; 
         pSrb->Status = STATUS_INVALID_PARAMETER;
         return;
    }


    pSrb->StreamObject->HwClockObject.ClockSupportFlags = 0;

    // We don't use DMA.
    pSrb->StreamObject->Dma = FALSE;
    pSrb->StreamObject->StreamHeaderMediaSpecific = sizeof(KS_FRAME_INFO);

    //
    // The PIO flag must be set when the mini driver will be accessing the data
    // buffers passed in using logical addressing.  We are not going to touch these 
    // buffer at all.
    //
    pSrb->StreamObject->Pio = FALSE;


    //
    // Set to last saved configuration
    //
    SetCurrentDevicePropertyValues(pDevExt, (PIRB) pSrb->SRBExtension);


    DbgMsg1((" #OPEN_STREAM#: %s DCam, Status %x, pDevExt %x, pStrmEx %x, IsochDescriptorList is at %x\n", 
              pDevExt->pchVendorName, pSrb->Status, pDevExt, pDevExt->pStrmEx, &pDevExt->IsochDescriptorList));

    ASSERT(pSrb->Status == STATUS_SUCCESS);

}




VOID
DCamCloseStream(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
/*++

Routine Description:

    Called when an CloseStream Srb request is received.  We get this when calling user 
    application do a CloseHandle() on the pin connection handle.  This can happen after
    HwUninitialize().

Arguments:

    pSrb - Pointer to Stream request block

Return Value:

    Nothing

--*/
{
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX     pStrmEx;
    PIRB pIrb;

    PAGED_CODE();

    pSrb->Status = STATUS_SUCCESS;

    pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;
    ASSERT(pDevExt);      
    if(!pDevExt) {
        StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
        return;
    }

    pStrmEx = (PSTREAMEX)pDevExt->pStrmEx;
    ASSERT(pStrmEx);
    if(!pStrmEx ) {
        StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
        return;    
    } 

    //
    // pDevExt->Irb might have been freed in HwUninitialize() 
    // due to Surprise removal; so we must use this:
    // 
    pIrb = (PIRB) pSrb->SRBExtension;


    //
    // If it is still in use (setting it to stop failed?),
    // we will diable ISO_ENABLE so other application can use it.
    //

    if(!pDevExt->bDevRemoved && 
       DCamDeviceInUse(pIrb, pDevExt)) {

        DbgMsg1(("DCamCloseStream: Is still in use! Disable it!\n"));
        // Disable EnableISO
        DCamIsoEnable(pIrb, pDevExt, FALSE);
    }


    //
    // Save current state and free resource alllocaed in OpenStream()
    //
    DCamSetPropertyValuesToRegistry(pDevExt);


    //
    // Free Isoch resource and master clock
    //

    DCamFreeIsochResource (pDevExt, pIrb, TRUE);
    if(pStrmEx->pVideoInfoHeader) {
        ExFreePool(pStrmEx->pVideoInfoHeader);
        pStrmEx->pVideoInfoHeader = NULL;
    }

    pStrmEx->hMasterClock = 0;
   

    //                                                 
    // If there are pening read, cancel them all.                                
    //
    if(pDevExt->PendingReadCount > 0) {

        DCamCancelAllPackets(
            pSrb,
            pDevExt,
            &pDevExt->PendingReadCount
            );
        
        pDevExt->pStrmEx = 0;

        return;  // SRB completed in CancelAllPackets       
    }
    
    pDevExt->pStrmEx = 0;

    StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);

}




VOID
DCamTimeoutHandler(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
/*++

Routine Description:

    This routine is called when a packet has been in the minidriver too long (Srb->TimeoutCounter == 0).
    We will cancel the SRB if we are in the RUN state; else set ->TimeoutCounter and return.
    We assume the cancel SRB is serialized and in the same order as it is read.  So this timeout is
    applying to the head of the queue.

Arguments:

    pSrb - Pointer to Stream request block that has timeout.

Return Value:

    Nothing

--*/

{
    PDCAM_EXTENSION pDevExt;
    PSTREAMEX pStrmEx;

    // Called from StreamClass at DisptchLevel


    //
    // We only expect stream SRB, but not device SRB.  
    //

    if ( (pSrb->Flags & SRB_HW_FLAGS_STREAM_REQUEST) != SRB_HW_FLAGS_STREAM_REQUEST) {
        ERROR_LOG(("DCamTimeoutHandler: Device SRB %x (cmd:%x) timed out!\n", pSrb, pSrb->Command));
        return;
    } 


    //
    // StreamSRB only valid if we have a stream extension
    //

    pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;
    ASSERT(pDevExt);
    pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;

    if(!pStrmEx) {
        ERROR_LOG(("DCamTimeoutHandler: Stream SRB %x timeout with pDevExt %x, pStrmEx %x\n", pSrb, pDevExt, pStrmEx));
        ASSERT(pStrmEx);
        return;
    }
 
    //
    // Cancel IRP only if in RUN state, BUT...
    // Note: if we are TIMEOUT and in RUN state, something is terribley wrong.  
    //       but I guess that can happen when it is being suspended;
    //       so we will extend the time out for all states.
    //

    DbgMsg2(("\'DCamTimeoutHandler: pSrb %x, %s state, PendingReadCount %d.\n", 
        pSrb, 
        pStrmEx->KSState == KSSTATE_RUN   ? "RUN" : 
        pStrmEx->KSState == KSSTATE_PAUSE ? "PAUSE":
        pStrmEx->KSState == KSSTATE_STOP  ? "STOP": "Unknown",
        pDevExt->PendingReadCount));   

    // ASSERT(pStrmEx->KSState == KSSTATE_PAUSE);


    //
    // Reset Timeout counter, or we are going to get this call immediately.
    //

    pSrb->TimeoutCounter = pSrb->TimeoutOriginal;

}


NTSTATUS
DCamStartListenCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PDCAM_IO_CONTEXT pDCamIoContext    
    )

/*++

Routine Description:

    Returns more processing required so the IO Manager will leave us alone

Arguments:

    DriverObject - Pointer to driver object created by system.

    pIrp - Irp that just completed

    pDCamIoContext - Context 

Return Value:

    None.

--*/

{
    PDCAM_EXTENSION pDevExt;
    NTSTATUS Status;
    PIRB pIrb; 
    PIO_STACK_LOCATION NextIrpStack;

#ifdef WAIT_FOR_SLOW_DEVICE
    KeStallExecutionProcessor(5000);  // 5 msec
#endif

    DbgMsg2(("\'DCamStartListenCR: pIrp->IoStatus.Status=%x\n", pIrp->IoStatus.Status));

    if(STATUS_SUCCESS != pIrp->IoStatus.Status) {

        pDevExt = pDCamIoContext->pDevExt;
        pIrb = pDCamIoContext->pIrb;

        if(pDevExt->lRetries > 0) {

            pDevExt->lRetries--;
            DbgMsg1(("DCamStartListenCR: Try DCAM_RUNSTATE_SET_REQUEST_ISOCH_LISTEN again!\n"));
            
            pIrb->FunctionNumber = REQUEST_ISOCH_LISTEN;
            pIrb->Flags = 0;
            pIrb->u.IsochListen.hResource = pDevExt->hResource;
            pIrb->u.IsochListen.fulFlags = 0;

            NextIrpStack = IoGetNextIrpStackLocation(pIrp);
            NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
            NextIrpStack->Parameters.Others.Argument1 = pIrb;

            IoSetCompletionRoutine(
                pIrp,
                DCamStartListenCR,
                pDCamIoContext,
                TRUE,
                TRUE,
                TRUE
                );

            Status =
                IoCallDriver(
                    pDevExt->BusDeviceObject, 
                    pIrp);

            return STATUS_MORE_PROCESSING_REQUIRED;

        } else {
            ERROR_LOG(("Start Listening has failed Status=%x; try again in next read.\n", pIrp->IoStatus.Status)); 
            pDCamIoContext->pDevExt->bNeedToListen = TRUE;
        }
    }

    DCamFreeIrbIrpAndContext(pDCamIoContext, pDCamIoContext->pIrb, pIrp);

    // No StreamClassDeviceNotification() here since 
    // this is local initiated Irb (as part of AttachBufferCR().

    return STATUS_MORE_PROCESSING_REQUIRED;

}





/*
** AdapterCompareGUIDsAndFormatSize()
**
**   Checks for a match on the three GUIDs and FormatSize
**
** Arguments:
**
**         IN DataRange1
**         IN DataRange2
**
** Returns:
** 
**   TRUE if all elements match
**   FALSE if any are different
**
** Side Effects:  none
*/

BOOL 
AdapterCompareGUIDsAndFormatSize(
    IN PKSDATARANGE DataRange1,
    IN PKSDATARANGE DataRange2)
{
    PAGED_CODE();

    return (
        IsEqualGUID (
            &DataRange1->MajorFormat, 
            &DataRange2->MajorFormat) &&
        IsEqualGUID (
            &DataRange1->SubFormat, 
            &DataRange2->SubFormat) &&
        IsEqualGUID (
            &DataRange1->Specifier, 
            &DataRange2->Specifier) &&
        (DataRange1->FormatSize == DataRange2->FormatSize));
}

/*
** AdapterVerifyFormat()
**
**   Checks the validity of a format request by walking through the
**       array of supported PKSDATARANGEs for a given stream.
**
** Arguments:
**
**   pKSDataFormatVideoToVerify - pointer of a KS_DATAFORMAT_VIDEOINFOHEADER structure.
**   StreamNumber - index of the stream being queried / opened.
**
** Returns:
** 
**   TRUE if the format is supported
**   FALSE if the format cannot be suppored
**
** Side Effects:  none
*/

BOOL 
AdapterVerifyFormat(
    ULONG VideoModesSupported,
    PKSDATAFORMAT  *pDCamStrmModesSupported,
    PKS_DATAFORMAT_VIDEOINFOHEADER pDataFormatVideoToVerify, 
    int StreamNumber)
{
    PKS_VIDEOINFOHEADER         pVideoInfoHdrToVerify = &pDataFormatVideoToVerify->VideoInfoHeader;
    PKSDATAFORMAT               *paDataFormatsVideoAvail;  // an array of PKSDATAFORMAT (not PKS_DATARANGE_VIDEO !!)
    PKS_DATARANGE_VIDEO         pDataRangeVideo;
    KS_VIDEO_STREAM_CONFIG_CAPS *pConfigCaps; 
    PKS_BITMAPINFOHEADER        pbmiHeader, 
                                pbmiHeaderToVerify;
    int                         j;

    PAGED_CODE();
    
    //
    // Make sure the stream index is valid
    // We only has one capure pin/stream (index 0).
    //
    if (StreamNumber >= 1) {
        return FALSE;
    }

    //
    // Get the pointer to the array of available formats
    //
    paDataFormatsVideoAvail = &pDCamStrmModesSupported[0]; // &pDevExt->DCamStrmModes[0];


    //
    // Walk the array, searching for a match
    //
    for (j = 0; j < (LONG) VideoModesSupported; j++, paDataFormatsVideoAvail++) {

        pDataRangeVideo = (PKS_DATARANGE_VIDEO) *paDataFormatsVideoAvail;
        
        //
        // Check for matching size, Major Type, Sub Type, and Specifier
        //

        //
        // Check for matching size, Major Type, Sub Type, and Specifier
        //

        if (!IsEqualGUID (&pDataRangeVideo->DataRange.MajorFormat, 
            &pDataFormatVideoToVerify->DataFormat.MajorFormat)) {
               DbgMsg2(("\'%d) AdapterVerifyFormat: MajorFormat mismatch!\n", j));
               continue;
        }

        if (!IsEqualGUID (&pDataRangeVideo->DataRange.SubFormat, 
            &pDataFormatVideoToVerify->DataFormat.SubFormat)) {
               DbgMsg2(("\'%d) AdapterVerifyFormat: SubFormat mismatch!\n", j));
               continue;
        }

        if (!IsEqualGUID (&pDataRangeVideo->DataRange.Specifier,
            &pDataFormatVideoToVerify->DataFormat.Specifier)) {
               DbgMsg2(("\'%d) AdapterVerifyFormat: Specifier mismatch!\n", j));
               continue;
        }

        if(pDataFormatVideoToVerify->DataFormat.FormatSize < 
            sizeof(KS_DATAFORMAT_VIDEOINFOHEADER))
            continue;

        //
        // Only if we get here, we are certain that we are dealing with video info.
        //

        // We do not support scaling or cropping so the dimension 
        // (biWidth, biHeight, biBitCount and biCompression)
        // must match.
        // 
        pbmiHeader         = &pDataRangeVideo->VideoInfoHeader.bmiHeader;
        pbmiHeaderToVerify = &pDataFormatVideoToVerify->VideoInfoHeader.bmiHeader;

        if(pbmiHeader->biWidth       != pbmiHeaderToVerify->biWidth    ||
           pbmiHeader->biHeight      != pbmiHeaderToVerify->biHeight   ||
           pbmiHeader->biBitCount    != pbmiHeaderToVerify->biBitCount ||
           pbmiHeader->biCompression != pbmiHeaderToVerify->biCompression
           ) {

            DbgMsg2(("AdapterVerifyFormat: Supported: %dx%dx%d [%x] != ToVerify: %dx%dx%d [%x]\n",
                    pbmiHeader->biWidth, pbmiHeader->biHeight,  pbmiHeader->biBitCount, pbmiHeader->biCompression,
                    pbmiHeaderToVerify->biWidth, pbmiHeaderToVerify->biHeight,  pbmiHeaderToVerify->biBitCount, pbmiHeaderToVerify->biCompression));
            continue;
        }

        // biSizeImage must be to be BIG ENOUGH
        if(pbmiHeaderToVerify->biSizeImage < pbmiHeader->biSizeImage) {

            DbgMsg2(("AdapterVerifyFormat: biSizeImageToVerify %d < required %x\n", 
                pbmiHeaderToVerify->biSizeImage, pbmiHeader->biSizeImage));
            continue;
        }

        // Frame rate needs to be within range
        pConfigCaps = &pDataRangeVideo->ConfigCaps;
        if(pDataFormatVideoToVerify->VideoInfoHeader.AvgTimePerFrame > pConfigCaps->MaxFrameInterval &&
           pDataFormatVideoToVerify->VideoInfoHeader.AvgTimePerFrame < pConfigCaps->MinFrameInterval) {

           DbgMsg2(("\'format index %d) AdapterVerifyFormat: Frame rate %ld is not within range(%ld, %ld)!\n", 
              j, pDataFormatVideoToVerify->VideoInfoHeader.AvgTimePerFrame,
              pConfigCaps->MaxFrameInterval, pConfigCaps->MinFrameInterval));
           continue;
        }


        //
        // The format passed all of the tests, so we support it
        //

        DbgMsg2(("\'(format idx %d) AdapterVerifyFormat: Verify!! Width=%d, Height=%d, biBitCount=%d, biSizeImage=%d\n", j,
            pbmiHeaderToVerify->biWidth, pbmiHeaderToVerify->biHeight, pbmiHeaderToVerify->biBitCount,pbmiHeaderToVerify->biSizeImage));
        DbgMsg2(("AdapterVerifyFormat: AvgTimePerFrame = %ld\n", pDataFormatVideoToVerify->VideoInfoHeader.AvgTimePerFrame));
        DbgMsg2(("AdapterVerifyFormat: (Max %ld\n", pConfigCaps->MaxFrameInterval));
        DbgMsg2(("AdapterVerifyFormat:               Min %ld)\n", pConfigCaps->MinFrameInterval));

        return TRUE;
    } 

    //
    // The format requested didn't match any of our listed ranges,
    // so refuse the connection.
    //
    DbgMsg2(("AdapterVerifyFormat: This format is not supported!\n"));

    return FALSE;
}



/*
** AdapterFormatFromRange()
**
**   Examine the given data format with many key fields and 
**   return a complete data format that can be used to open a stream.
**
** Arguments:
**
**   IN PHW_STREAM_REQUEST_BLOCK Srb 
**
** Returns:
** 
**   TRUE if the format is supported
**   FALSE if the format cannot be suppored
**
** Side Effects:  none
*/
BOOL 
AdapterFormatFromRange(
    IN PHW_STREAM_REQUEST_BLOCK Srb)
{
    PDCAM_EXTENSION             pDevExt = (PDCAM_EXTENSION) Srb->HwDeviceExtension;
    PSTREAM_DATA_INTERSECT_INFO IntersectInfo;
    PKSDATARANGE                DataRange,
                                *pAvailableFormats;  // KSDATARANGE == KSDATAFORMAT
    PKS_DATARANGE_VIDEO         DataRangeVideoToVerify,
                                DataRangeVideo;
    PKS_BITMAPINFOHEADER        pbmiHeader, 
                                pbmiHeaderToVerify;
    ULONG                       FormatSize;
    BOOL                        MatchFound = FALSE;
    ULONG                       j;


    PAGED_CODE();

    Srb->Status = STATUS_SUCCESS;
    IntersectInfo = Srb->CommandData.IntersectInfo;
    DataRange = IntersectInfo->DataRange;
    DbgMsg2(("IntersectIfo->DataFormatBuffer=%x, size=%d\n", IntersectInfo->DataFormatBuffer, IntersectInfo->SizeOfDataFormatBuffer));


    //
    // Check that the stream number is valid
    // We support only one capture pin/stream (index 0)
    //

    if (IntersectInfo->StreamNumber >= 1) {

        Srb->Status = STATUS_NOT_IMPLEMENTED;
        ERROR_LOG(("\'AdapterFormatFromRange: StreamNumber(=%d) is not implemented.\n", IntersectInfo->StreamNumber));
        ASSERT(FALSE);
        return FALSE;
    }


    //
    // Get the pointer to the array of available formats
    //

    pAvailableFormats = &pDevExt->DCamStrmModes[0];


    //
    // Walk the formats supported by the stream searching for a match
    // of the three GUIDs which together define a DATARANGE
    //
    
    DataRangeVideoToVerify = (PKS_DATARANGE_VIDEO) DataRange;

    for (j = 0; j < pDevExt->ModeSupported; j++, pAvailableFormats++) {
       
        DataRangeVideo = (PKS_DATARANGE_VIDEO) *pAvailableFormats;

        //
        // STREAM_DATA_INTERSECT_INFO
        //  [IN]   ULONG        StreamNumber;
        //  [IN]   PKSDATARANGE DataRange;   
        //  [OUT]  PVOID        DataFormatBuffer;   // == PKS_DATAFORMAT_VIDEOINFOHEADER
        //  [OUT]  ULONG        SizeOfDataFormatBuffer;
        //
        
        //
        // KS_DATAFORMAT_VIDEOINFOHEADER:
        //    fields marked with 'm' must match; 
        //           marked with 'r' must within range;
        //           marked with 'f' is filled by us
        //
        //     KSDATAFORMAT == KSDATARANGE
        //       m ULONG   FormatSize;
        //         ULONG   Flags;
        //         ULONG   SampleSize;
        //         ULONG   Reserved;
        //       m GUID    MajorFormat;
        //       m GUID    SubFormat;
        //       m GUID    Specifier;.
        //  m  BOOL                         bFixedSizeSamples;      // all samples same size?
        //  m  BOOL                         bTemporalCompression;   // all I frames?
        //  m  DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
        //  m  DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
        //  m  KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
        //     KS_VIDEOINFOHEADER 
        //         RECT                rcSource;          // The bit we really want to use
        //         RECT                rcTarget;          // Where the video should go
        //         DWORD               dwBitRate;         // Approximate bit data rate
        //         DWORD               dwBitErrorRate;    // Bit error rate for this stream
        //     r/f REFERENCE_TIME      AvgTimePerFrame;   // Average time per frame (100ns units)
        //         KS_BITMAPINFOHEADER bmiHeader;
        //             DWORD      biSize;
        //       m     LONG       biWidth;
        //       m     LONG       biHeight;
        //             WORD       biPlanes;
        //       m     WORD       biBitCount;
        //       m     DWORD      biCompression;
        //       f     DWORD      biSizeImage;
        //             LONG       biXPelsPerMeter;
        //             LONG       biYPelsPerMeter;
        //             DWORD      biClrUsed;
        //             DWORD      biClrImportant;
        //     

        // Verify that it is a VIDEO format/range.
        if (!AdapterCompareGUIDsAndFormatSize((PKSDATARANGE)DataRangeVideoToVerify, (PKSDATARANGE)DataRangeVideo)) {
            continue;
        }
    
        //
        // It is valid video format/range; now check that the other fields match
        //
        if ((DataRangeVideoToVerify->bFixedSizeSamples      != DataRangeVideo->bFixedSizeSamples)      ||
            (DataRangeVideoToVerify->bTemporalCompression   != DataRangeVideo->bTemporalCompression)   ||
            (DataRangeVideoToVerify->StreamDescriptionFlags != DataRangeVideo->StreamDescriptionFlags) ||
            (DataRangeVideoToVerify->MemoryAllocationFlags  != DataRangeVideo->MemoryAllocationFlags)  ||
            (RtlCompareMemory (&DataRangeVideoToVerify->ConfigCaps, &DataRangeVideo->ConfigCaps, sizeof(KS_VIDEO_STREAM_CONFIG_CAPS)) != sizeof(KS_VIDEO_STREAM_CONFIG_CAPS))) {

            continue;
        }

        //
        // We do not support scaling or cropping so the dimension 
        // (biWidth, biHeight, biBitCount and biCompression)
        // must match, and we will filled in the biSizeImage and others.
        // 
        pbmiHeader         = &DataRangeVideo->VideoInfoHeader.bmiHeader;
        pbmiHeaderToVerify = &DataRangeVideoToVerify->VideoInfoHeader.bmiHeader;

        if(pbmiHeader->biWidth       != pbmiHeaderToVerify->biWidth    ||
           abs(pbmiHeader->biHeight) != abs(pbmiHeaderToVerify->biHeight)  ||
           pbmiHeader->biBitCount    != pbmiHeaderToVerify->biBitCount ||
           pbmiHeader->biCompression != pbmiHeaderToVerify->biCompression
           ) {

            DbgMsg1(("AdapterFormatFromRange: Supported: %dx%dx%d [%x] != ToVerify: %dx%dx%d [%x]\n",
                    pbmiHeader->biWidth, pbmiHeader->biHeight,  pbmiHeader->biBitCount, pbmiHeader->biCompression,
                    pbmiHeaderToVerify->biWidth, pbmiHeaderToVerify->biHeight,  pbmiHeaderToVerify->biBitCount, pbmiHeaderToVerify->biCompression));
            continue;
        }


        // MATCH FOUND!
        MatchFound = TRUE; 
        


        // KS_DATAFORMAT_VIDEOINFOHEADER
        //    KSDATAFORMAT            DataFormat;
        //    KS_VIDEOINFOHEADER      VideoInfoHeader;
        FormatSize = sizeof (KSDATAFORMAT) +  KS_SIZE_VIDEOHEADER (&DataRangeVideo->VideoInfoHeader);

        //    
        // 1st query:  Srb->ActualBytesTransferred = FormatSize
        //

        if(IntersectInfo->SizeOfDataFormatBuffer == 0) {

            Srb->Status = STATUS_BUFFER_OVERFLOW;
            // We actually have not returned this much data,
            // this "size" will be used by Ksproxy to send down 
            // a buffer of that size in next query.
            Srb->ActualBytesTransferred = FormatSize;
            break;
        }


        //
        // 2nd time: pass back the format information
        //

        if (IntersectInfo->SizeOfDataFormatBuffer < FormatSize) {
            Srb->Status = STATUS_BUFFER_TOO_SMALL;
            DbgMsg2(("IntersectInfo->SizeOfDataFormatBuffer=%d, FormatSize=%d\n", IntersectInfo->SizeOfDataFormatBuffer, FormatSize));
            return FALSE;
        }

        //
        // A match is found,  Copy from our supported/matched data range and set frame rate:
        // KS_DATAFORMAT_VIDEOINFOHEADER
        //    KSDATAFORMAT            DataFormat;
        //    KS_VIDEOINFOHEADER      VideoInfoHeader;
        //
        
        RtlCopyMemory(
            &((PKS_DATAFORMAT_VIDEOINFOHEADER)IntersectInfo->DataFormatBuffer)->DataFormat,
            &DataRangeVideo->DataRange,
            sizeof (KSDATAFORMAT));

        RtlCopyMemory(
            &((PKS_DATAFORMAT_VIDEOINFOHEADER) IntersectInfo->DataFormatBuffer)->VideoInfoHeader,  // KS_VIDEOINFOHEADER
            &DataRangeVideo->VideoInfoHeader,                                                      // KS_VIDEOINFOHEADER
            KS_SIZE_VIDEOHEADER (&DataRangeVideo->VideoInfoHeader));  // Use KS_SIZE_VIDEOHEADER() since this is variable size       

        //
        // Special atttention to these two fields: biSizeImage and AvgTimePerFrame.
        // We do not scale or stretch so biSizeImage is fixed.
        // However, AvgTimePerFrame (FrameRate) can/need to be within (ConfigCaps.MinFrameInterval, ConfigCaps.MaxFrameInterval)
        //

        if (DataRangeVideoToVerify->VideoInfoHeader.AvgTimePerFrame > DataRangeVideoToVerify->ConfigCaps.MaxFrameInterval ||      
            DataRangeVideoToVerify->VideoInfoHeader.AvgTimePerFrame < DataRangeVideoToVerify->ConfigCaps.MinFrameInterval) {
         
            ((PKS_DATAFORMAT_VIDEOINFOHEADER) IntersectInfo->DataFormatBuffer)->VideoInfoHeader.AvgTimePerFrame = 
                 DataRangeVideo->VideoInfoHeader.AvgTimePerFrame;
            DbgMsg2(("AdapterFormatFromRange: out of range; so set it to default (%ld)\n",DataRangeVideo->VideoInfoHeader.AvgTimePerFrame));
        } else {

            ((PKS_DATAFORMAT_VIDEOINFOHEADER) IntersectInfo->DataFormatBuffer)->VideoInfoHeader.AvgTimePerFrame = 
                  DataRangeVideoToVerify->VideoInfoHeader.AvgTimePerFrame;
        }

        ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;
        Srb->ActualBytesTransferred = FormatSize;

        DbgMsg2(("AdapterFormatFromRange: match found: [%x], %dx%dx%d=%d, AvgTimePerFrame %ld\n",
                pbmiHeader->biCompression, pbmiHeader->biWidth, pbmiHeader->biHeight,  pbmiHeader->biBitCount, pbmiHeader->biSizeImage,
                ((PKS_DATAFORMAT_VIDEOINFOHEADER) IntersectInfo->DataFormatBuffer)->VideoInfoHeader.AvgTimePerFrame));
        break;

    } // End of loop on all formats for this stream

    if(!MatchFound) {

        DbgMsg2(("AdapterFormatFromRange: No match !!\n"));
        Srb->Status = STATUS_NO_MATCH;
        return FALSE;
    }

    return TRUE;
}

BOOL
DCamBuildFormatTable(
    PDCAM_EXTENSION pDevExt,
    PIRB pIrb
    )
/*
    Description:

        Query Video format and mode supported by the camera.

    Return:

       TRUE: support at least one mode
       FALSE: failed to read mode register or do not support any mode.
*/
{
    // Initialize 
    pDevExt->ModeSupported = 0;

    if(DCamGetVideoMode(pDevExt, pIrb)) {

#ifdef SUPPORT_YUV444
        // Mode0: 160x120 (4:4:4)
        if(pDevExt->DCamVModeInq0.VMode.Mode0 == 1 && pDevExt->DecoderDCamVModeInq0.VMode.Mode0 == 1) {
            pDevExt->DCamStrmModes[pDevExt->ModeSupported] = (PKSDATAFORMAT) &DCAM_StreamMode_0;
            pDevExt->ModeSupported++;
        }
#endif
        // Mode1: 320x240 (4:2:2)
        if(pDevExt->DCamVModeInq0.VMode.Mode1 == 1 && pDevExt->DecoderDCamVModeInq0.VMode.Mode1 == 1) {
            pDevExt->DCamStrmModes[pDevExt->ModeSupported] = (PKSDATAFORMAT) &DCAM_StreamMode_1;
            pDevExt->ModeSupported++;
        }

#ifdef SUPPORT_YUV411
        // Mode2: 640x480 (4:1:1)
        if(pDevExt->DCamVModeInq0.VMode.Mode2 == 1 && pDevExt->DecoderDCamVModeInq0.VMode.Mode2 == 1) {
            pDevExt->DCamStrmModes[pDevExt->ModeSupported] = (PKSDATAFORMAT) &DCAM_StreamMode_2;
            pDevExt->ModeSupported++;
        }
#endif

        // Mode3: 640x480 (4:2:2)
        if(pDevExt->DCamVModeInq0.VMode.Mode3 == 1 && pDevExt->DecoderDCamVModeInq0.VMode.Mode3 == 1) {
            pDevExt->DCamStrmModes[pDevExt->ModeSupported] = (PKSDATAFORMAT) &DCAM_StreamMode_3;        
            pDevExt->ModeSupported++;
        }

#ifdef SUPPORT_RGB24
        // Mode4: 640x480 (RGB24)
        if(pDevExt->DCamVModeInq0.VMode.Mode4 == 1 && pDevExt->DecoderDCamVModeInq0.VMode.Mode4 == 1) {
            pDevExt->DCamStrmModes[pDevExt->ModeSupported] = (PKSDATAFORMAT) &DCAM_StreamMode_4;
            pDevExt->ModeSupported++;
        }
#endif

#ifdef SUPPORT_YUV800
        // Mode5: 640x480 (Y800)
        if(pDevExt->DCamVModeInq0.VMode.Mode5 == 1 && pDevExt->DecoderDCamVModeInq0.VMode.Mode5 == 1) {
            pDevExt->DCamStrmModes[pDevExt->ModeSupported] = (PKSDATAFORMAT) &DCAM_StreamMode_5;
            pDevExt->ModeSupported++;
        }
#endif
    } 

    DbgMsg1(("\'Support %d modes; ->DCamStrmModes[]:%x\n", pDevExt->ModeSupported, &pDevExt->DCamStrmModes[0]));
    ASSERT(pDevExt->ModeSupported > 0);

    return (pDevExt->ModeSupported > 0);
}

/*
** VideoGetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    Srb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID 
VideoGetProperty(
    PHW_STREAM_REQUEST_BLOCK Srb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = Srb->CommandData.PropertyInfo;


    // preset to success

    Srb->Status = STATUS_SUCCESS;

    if (IsEqualGUID (&KSPROPSETID_Connection, &pSPD->Property->Set)) {
        VideoStreamGetConnectionProperty (Srb);
    } else if (IsEqualGUID (&PROPSETID_VIDCAP_DROPPEDFRAMES, &pSPD->Property->Set)) {
        VideoStreamGetDroppedFramesProperty (Srb);
    } else {
        Srb->Status = STATUS_NOT_IMPLEMENTED;
    }

}


/*
** VideoGetState()
**
**    Gets the current state of the requested stream
**
** Arguments:
**
**    Srb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID 
VideoGetState(
    PHW_STREAM_REQUEST_BLOCK Srb)
{
    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) Srb->HwDeviceExtension;
    PSTREAMEX pStrmEx = pDevExt->pStrmEx;

    PAGED_CODE();

    DbgMsg2(("\'%d:%s) VideoGetState: KSSTATE=%s.\n", 
          pDevExt->idxDev, pDevExt->pchVendorName, 
          pStrmEx->KSState == KSSTATE_STOP ? "STOP" : 
          pStrmEx->KSState == KSSTATE_PAUSE ? "PAUSE" :     
          pStrmEx->KSState == KSSTATE_RUN ? "RUN" : "ACQUIRE"));

    Srb->CommandData.StreamState = pStrmEx->KSState;
    Srb->ActualBytesTransferred = sizeof (KSSTATE);

    // A very odd rule:
    // When transitioning from stop to pause, DShow tries to preroll
    // the graph.  Capture sources can't preroll, and indicate this
    // by returning VFW_S_CANT_CUE in user mode.  To indicate this
    // condition from drivers, they must return ERROR_NO_DATA_DETECTED

    Srb->Status = STATUS_SUCCESS;


    if (pStrmEx->KSState == KSSTATE_PAUSE) {
       Srb->Status = STATUS_NO_DATA_DETECTED;
    }
}


VOID  
VideoStreamGetConnectionProperty (
    PHW_STREAM_REQUEST_BLOCK Srb)
{
    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) Srb->HwDeviceExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = Srb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    PSTREAMEX pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;
    ASSERT(pStrmEx == (PSTREAMEX)Srb->StreamObject->HwStreamExtension);

    PAGED_CODE();

    switch (Id) {

    case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:

        if (pStrmEx->pVideoInfoHeader) {

            PKSALLOCATOR_FRAMING Framing = 
                (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;
            Framing->RequirementsFlags =
                KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
                KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
            Framing->PoolType = PagedPool;
            Framing->Frames = MAX_BUFFERS_SUPPLIED; 
            Framing->FrameSize = pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage;
            Framing->FileAlignment = FILE_BYTE_ALIGNMENT; // 0: Basically no alignment by spec
            Framing->Reserved = 0;
            Srb->ActualBytesTransferred = sizeof (KSALLOCATOR_FRAMING);
            Srb->Status = STATUS_SUCCESS;
               DbgMsg2(("\'VideoStreamGetConnectionProperty: status=0x%x, Alignment %d, Frame %d, FrameSize %d\n",
                    Srb->Status, Framing->FileAlignment+1, Framing->Frames, Framing->FrameSize));

        } else {

            Srb->Status = STATUS_INVALID_PARAMETER;
            DbgMsg2(("\'VideoStreamGetConnectionProperty: status=0x\n",Srb->Status));
        }
        break;

    default:
        ERROR_LOG(("VideoStreamGetConnectionProperty: Unsupported property id=%d\n",Id));
        ASSERT(FALSE);
        break;
    }
}

/*
** VideoStreamGetConnectionProperty()
**
**    Gets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
VideoStreamGetDroppedFramesProperty(
    PHW_STREAM_REQUEST_BLOCK Srb
    )
{
    PSTREAMEX pStrmEx = (PSTREAMEX)Srb->StreamObject->HwStreamExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = Srb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    ULONGLONG tmStream;

    PAGED_CODE();

    switch (Id) {

    case KSPROPERTY_DROPPEDFRAMES_CURRENT:
         {

         PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames = 
                     (PKSPROPERTY_DROPPEDFRAMES_CURRENT_S) pSPD->PropertyInfo;

         if (pStrmEx->hMasterClock) {
                    
             tmGetStreamTime(Srb, pStrmEx, &tmStream);

             if (tmStream < pStrmEx->FirstFrameTime) {
                 DbgMsg2(("\'*DroppedFP: Tm(%dms) < 1stFrameTm(%d)\n",
                           (LONG) tmStream/10000, (LONG)pStrmEx->FirstFrameTime));
                 pDroppedFrames->DropCount = 0;
             } else {
                 pDroppedFrames->DropCount = (tmStream - pStrmEx->FirstFrameTime)
                                / pStrmEx->pVideoInfoHeader->AvgTimePerFrame + 1 - pStrmEx->FrameCaptured;
             }

             if (pDroppedFrames->DropCount < 0)
                 pDroppedFrames->DropCount = 0;
                    
         } else {
             pDroppedFrames->DropCount = 0;
         }

         // Update our drop frame here. "pDroppedFrames->DropCount" is return when a frame is returned. 
         if (pDroppedFrames->DropCount > pStrmEx->FrameInfo.DropCount) {
             pStrmEx->FrameInfo.DropCount = pDroppedFrames->DropCount;
             //pStrmEx->bDiscontinue = TRUE;
         } else {
             pDroppedFrames->DropCount = pStrmEx->FrameInfo.DropCount;
         }

         pDroppedFrames->AverageFrameSize = pStrmEx->pVideoInfoHeader->bmiHeader.biSizeImage;
         pDroppedFrames->PictureNumber = pStrmEx->FrameCaptured + pDroppedFrames->DropCount;

         // Correction if no picture has been successfully capture in the IsochCallback.
         if (pDroppedFrames->PictureNumber < pDroppedFrames->DropCount)
             pDroppedFrames->PictureNumber = pDroppedFrames->DropCount;

         DbgMsg2(("\'*DroppedFP: tm(%d); Pic#(%d)=?Cap(%d)+Drp(%d)\n",
                  (ULONG) tmStream/10000,
                  (LONG) pDroppedFrames->PictureNumber,
                  (LONG) pStrmEx->FrameCaptured,
                  (LONG) pDroppedFrames->DropCount));
               
         Srb->ActualBytesTransferred = sizeof (KSPROPERTY_DROPPEDFRAMES_CURRENT_S);
               Srb->Status = STATUS_SUCCESS;

         }
         break;

    default:
        ERROR_LOG(("VideoStreamGetDroppedFramesProperty: Unsupported property id=%d\n",Id));
        ASSERT(FALSE);
        break;
    }
}




VOID 
VideoIndicateMasterClock(
    PHW_STREAM_REQUEST_BLOCK Srb)
/*++

Routine Description:

    Assign a master clock for this stream.

Arguments:

    pSrb - Pointer to Stream request block

Return Value:

    Nothing

--*/
{


    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) Srb->HwDeviceExtension;
    PSTREAMEX pStrmEx = (PSTREAMEX) pDevExt->pStrmEx;

    PAGED_CODE();

    ASSERT(pStrmEx == (PSTREAMEX)Srb->StreamObject->HwStreamExtension);

    pStrmEx->hMasterClock = Srb->CommandData.MasterClockHandle;

    DbgMsg2(("\'%d:%s)VideoIndicateMasterClock: hMasterClock = 0x%x\n", pDevExt->idxDev, pDevExt->pchVendorName, pStrmEx->hMasterClock));

}


VOID
DCamReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )

/*++

Routine Description:

    This is where most of the interesting Stream requests come to us

Arguments:

    pSrb - Pointer to Stream request block

Return Value:

    Nothing

--*/

{
    PIO_STACK_LOCATION IrpStack;
    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) pSrb->HwDeviceExtension;


    PAGED_CODE();

    pSrb->Status = STATUS_SUCCESS;

    //
    // Switch on the command within the Srb itself
    //

    switch (pSrb->Command) {

    case SRB_INITIALIZE_DEVICE:     // Per device
          
         pSrb->Status = DCamHwInitialize(pSrb);
         break;

    case SRB_INITIALIZATION_COMPLETE:

         pSrb->Status = STATUS_NOT_IMPLEMENTED;
         break;

    case SRB_GET_STREAM_INFO:     // Per Device

         //
         // this is a request for the driver to enumerate requested streams
         //
         DCamGetStreamInfo(pSrb);
         break;

    case SRB_OPEN_STREAM:          // Per stream

         DCamOpenStream(pSrb);
         break;

    case SRB_CLOSE_STREAM:          // Per Stream
        DbgMsg1((" #CLOSE_STREAM# (%d) camera: pSrb %x, pDevExt %x, pStrmEx %x, PendingRead %d\n", 
              pDevExt->idxDev, pSrb, pDevExt, pDevExt->pStrmEx, pDevExt->PendingReadCount));
        DCamCloseStream(pSrb);
        return;       // SRB will finish asynchronously in its IoCompletionRoutine if there are pending reads to cancel.
     
    case SRB_SURPRISE_REMOVAL:

        DbgMsg1((" #SURPRISE_REMOVAL# (%d) camera: pSrb %x, pDevExt %x, pStrmEx %x, PendingRead %d\n", 
             pDevExt->idxDev, pSrb, pDevExt, pDevExt->pStrmEx, pDevExt->PendingReadCount));
        DCamSurpriseRemoval(pSrb);
        return;       // SRB will finish asynchronously in its IoCompletionRoutine.

    case SRB_UNKNOWN_DEVICE_COMMAND:

         //
         // We might be interested in unknown commands if they pertain
         // to bus resets.  We will reallocate resource (bandwidth and 
         // channel) if this device is streaming.
         //
         IrpStack = IoGetCurrentIrpStackLocation(pSrb->Irp);

         if (IrpStack->MajorFunction == IRP_MJ_PNP)
             DCamProcessPnpIrp(pSrb, IrpStack, pDevExt);
         else            
             pSrb->Status = STATUS_NOT_IMPLEMENTED;
         break;


    case SRB_UNINITIALIZE_DEVICE:     // Per device

         DbgMsg1((" #UNINITIALIZE_DEVICE# (%d) %s camera : pSrb %x, pDevExt %x, pStrmEx %x\n", 
              pDevExt->idxDev, pDevExt->pchVendorName, pSrb, pDevExt, pDevExt->pStrmEx));
         pSrb->Status = DCamHwUnInitialize(pSrb);
         break;

    case SRB_GET_DATA_INTERSECTION:

         //
         // Return a format, given a range
         //
         AdapterFormatFromRange(pSrb);
         StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
         return;

    case SRB_CHANGE_POWER_STATE:

         DCamChangePower(pSrb);
         break;
            
    // VideoProcAmp and CameraControl requests
    case SRB_GET_DEVICE_PROPERTY:

         AdapterGetProperty(pSrb);
         break;
          
    case SRB_SET_DEVICE_PROPERTY:
    
         AdapterSetProperty(pSrb);
         break;

    case SRB_PAGING_OUT_DRIVER:

         // Once we register bus reset, we can be called at any time;
         // So we cannot page out.
         pSrb->Status = STATUS_NOT_IMPLEMENTED;
         break;


    default:   

         DbgMsg1(("DCamReceivePacket: entry with unknown and unsupported SRB command 0x%x\n", pSrb->Command));
         //
         // this is a request that we do not understand.  Indicate invalid
         // command and complete the request
         //

         pSrb->Status = STATUS_NOT_IMPLEMENTED;
         break;
    }

    //
    // NOTE:
    //
    // all of the commands that we do, or do not understand can all be completed
    // synchronously at this point, so we can use a common callback routine here.
    // If any of the above commands require asynchronous processing, this will
    // have to change
    //

#if DBG
    if (pSrb->Status != STATUS_SUCCESS && 
        pSrb->Status != STATUS_NOT_IMPLEMENTED) {
        DbgMsg1(("pSrb->Command(0x%x) does not return STATUS_SUCCESS or NOT_IMPLEMENTED but 0x%x\n", pSrb->Command, pSrb->Status));
    }
#endif

    StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\1394dcam\propdata.h ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================

//
// Video and camera properties of a 1394 desktop digital camera
//


#ifndef _PROPDATA_H
#define _PROPDATA_H


// ------------------------------------------------------------------------
//  S O N Y    D i g i t a l    C a m e r a
// ------------------------------------------------------------------------

// ------------------------------------------------------------------------
// Property set for VideoProcAmp
// ------------------------------------------------------------------------

// Default values for some of the properties

#define SONYDCAM_DEF_BRIGHTNESS     12
#define SONYDCAM_DEF_HUE           128
#define SONYDCAM_DEF_SATURATION     25
#define SONYDCAM_DEF_SHARPNESS      15
#define SONYDCAM_DEF_WHITEBALANCE  160
#define SONYDCAM_DEF_ZOOM          640
#define SONYDCAM_DEF_FOCUS        1600

//
// First define all of the ranges and stepping values
//

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG BrightnessRangeAndStep [] = 
{
    {
        1,                  // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum in (IRE * 100) units
        15                  // Maximum in (IRE * 100) units
    }
};

const static LONG BrightnessDefault = SONYDCAM_DEF_BRIGHTNESS;


static KSPROPERTY_MEMBERSLIST BrightnessMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (BrightnessRangeAndStep),
            SIZEOF_ARRAY (BrightnessRangeAndStep),
            0
        },
        (PVOID) BrightnessRangeAndStep,
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (BrightnessDefault),
            sizeof (BrightnessDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &BrightnessDefault,
    }    
};

static KSPROPERTY_VALUES BrightnessValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (BrightnessMembersList),
    BrightnessMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG SharpnessRangeAndStep [] = 
{
    {
        1,                  // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum in (gain * 100) units
        15                  // Maximum in (gain * 100) units
    }
};

const static LONG SharpnessDefault = SONYDCAM_DEF_SHARPNESS;


static KSPROPERTY_MEMBERSLIST SharpnessMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (SharpnessRangeAndStep),
            SIZEOF_ARRAY (SharpnessRangeAndStep),
            0
        },
        (PVOID) SharpnessRangeAndStep
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (SharpnessDefault),
            sizeof (SharpnessDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &SharpnessDefault,
    }    
};

static KSPROPERTY_VALUES SharpnessValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (SharpnessMembersList),
    SharpnessMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG HueRangeAndStep [] = 
{
    {
        1,                  // SteppingDelta (range / steps)
        0,                  // Reserved
        96,                 // Minimum in (gain * 100) units
        160                 // Maximum in (gain * 100) units
    }
};

const static LONG HueDefault = SONYDCAM_DEF_HUE;


static KSPROPERTY_MEMBERSLIST HueMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (HueRangeAndStep),
            SIZEOF_ARRAY (HueRangeAndStep),
            0
        },
        (PVOID) HueRangeAndStep
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (HueDefault),
            sizeof (HueDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &HueDefault,
    }    
};

static KSPROPERTY_VALUES HueValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (HueMembersList),
    HueMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG SaturationRangeAndStep [] = 
{
    {
        1,                  // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum in (gain * 100) units
        199                 // Maximum in (gain * 100) units
    }
};

const static LONG SaturationDefault = SONYDCAM_DEF_SATURATION;


static KSPROPERTY_MEMBERSLIST SaturationMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (SaturationRangeAndStep),
            SIZEOF_ARRAY (SaturationRangeAndStep),
            0
        },
        (PVOID) SaturationRangeAndStep
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (SaturationDefault),
            sizeof (SaturationDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &SaturationDefault,
    }    
};

static KSPROPERTY_VALUES SaturationValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (SaturationMembersList),
    SaturationMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG WhiteBalanceRangeAndStep [] = 
{
    {
        1,                  // SteppingDelta (range / steps)
        0,                  // Reserved
        32,                 // Minimum in (gain * 100) units
        224                 // Maximum in (gain * 100) units
    }
};

const static LONG WhiteBalanceDefault = SONYDCAM_DEF_WHITEBALANCE;


static KSPROPERTY_MEMBERSLIST WhiteBalanceMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (WhiteBalanceRangeAndStep),
            SIZEOF_ARRAY (WhiteBalanceRangeAndStep),
            0
        },
        (PVOID) WhiteBalanceRangeAndStep
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (WhiteBalanceDefault),
            sizeof (WhiteBalanceDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &WhiteBalanceDefault,
    }    
};

static KSPROPERTY_VALUES WhiteBalanceValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (WhiteBalanceMembersList),
    WhiteBalanceMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG FocusRangeAndStep [] = 
{
    {
        1,                  // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum in (IRE * 100) units
        3456                // Maximum in (IRE * 100) units
    }
};

const static LONG FocusDefault = SONYDCAM_DEF_FOCUS;


static KSPROPERTY_MEMBERSLIST FocusMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (FocusRangeAndStep),
            SIZEOF_ARRAY (FocusRangeAndStep),
            0
        },
        (PVOID) FocusRangeAndStep,
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (FocusDefault),
            sizeof (FocusDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &FocusDefault,
    }    
};

static KSPROPERTY_VALUES FocusValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (FocusMembersList),
    FocusMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG ZoomRangeAndStep [] = 
{
    {
        1,                  // SteppingDelta (range / steps)
        0,                  // Reserved
        64,                 // Minimum in (IRE * 100) units
        1855                // Maximum in (IRE * 100) units
    }
};

const static LONG ZoomDefault = SONYDCAM_DEF_ZOOM;


static KSPROPERTY_MEMBERSLIST ZoomMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_RANGES,
            sizeof (ZoomRangeAndStep),
            SIZEOF_ARRAY (ZoomRangeAndStep),
            0
        },
        (PVOID) ZoomRangeAndStep,
     },
     {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (ZoomDefault),
            sizeof (ZoomDefault),
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &ZoomDefault,
    }    
};

static KSPROPERTY_VALUES ZoomValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (ZoomMembersList),
    ZoomMembersList
};

// ------------------------------------------------------------------------
DEFINE_KSPROPERTY_TABLE(VideoProcAmpProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &BrightnessValues,                      // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_SHARPNESS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &SharpnessValues,                       // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_HUE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &HueValues,                             // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),    

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_SATURATION,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &SaturationValues,                      // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &WhiteBalanceValues,                    // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};

DEFINE_KSPROPERTY_TABLE(CameraControlProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CAMERACONTROL_FOCUS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CAMERACONTROL_S),     // MinProperty
        sizeof(KSPROPERTY_CAMERACONTROL_S),     // MinData
        TRUE,                                   // SetSupported or Handler
        &FocusValues,                            // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CAMERACONTROL_ZOOM,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CAMERACONTROL_S),     // MinProperty
        sizeof(KSPROPERTY_CAMERACONTROL_S),     // MinData
        TRUE,                                   // SetSupported or Handler
        &ZoomValues,                            // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};


// ------------------------------------------------------------------------
// Array of all of the property sets supported by the adapter
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(AdapterPropertyTable)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_VIDEOPROCAMP,
        SIZEOF_ARRAY(VideoProcAmpProperties),
        VideoProcAmpProperties,
        0, 
        NULL
    ),

    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_CAMERACONTROL,
        SIZEOF_ARRAY(CameraControlProperties),
        CameraControlProperties,
        0, 
        NULL
    )
};

#define NUMBER_OF_ADAPTER_PROPERTY_SETS (SIZEOF_ARRAY (AdapterPropertyTable))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\1394dcam\sonydcam.c ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    sonydcam.c

Abstract:

    Stream class based WDM driver for 1934 Desktop Camera.
    This driver fits under the WDM stream class.

Author:
    
    Shaun Pierce 25-May-96

Modified:

    Yee J. Wu 15-Oct-97

Environment:

    Kernel mode only

Revision History:


--*/

#include "strmini.h"
#include "1394.h"
#include "dbg.h"
#include "ksmedia.h"
#include "dcamdef.h"
#include "sonydcam.h"
#include "dcampkt.h"
#include "capprop.h"   // Video and camera property function prototype


CHAR szUnknownVendorName[] = "UnknownVendor";


#ifdef ALLOC_PRAGMA
    // #pragma alloc_text(INIT, DriverEntry)
    #pragma alloc_text(PAGE, DCamHwUnInitialize)
    #pragma alloc_text(PAGE, InitializeDeviceExtension)
    #pragma alloc_text(PAGE, DCamHwInitialize)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This where life begins for a driver.  The stream class takes care
    of alot of stuff for us, but we still need to fill in an initialization
    structure for the stream class and call it.

Arguments:

    DriverObject - Pointer to the driver object created by the system.
    RegistryPath - unused.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{

    HW_INITIALIZATION_DATA HwInitData;
    
    PAGED_CODE();
    DbgMsg1(("SonyDCam DriverEntry: DriverObject=%x; RegistryPath=%x\n",
        DriverObject, RegistryPath));

    ERROR_LOG(("<<<<<<< Sonydcam.sys: %s; %s; %x %x >>>>>>>>\n", 
        __DATE__, __TIME__, DriverObject, RegistryPath));

    //
    // Fill in the HwInitData structure
    //
    RtlZeroMemory( &HwInitData, sizeof(HW_INITIALIZATION_DATA) );

    HwInitData.HwInitializationDataSize = sizeof(HwInitData);
    HwInitData.HwInterrupt              = NULL;
    HwInitData.HwReceivePacket          = DCamReceivePacket;
    HwInitData.HwCancelPacket           = DCamCancelOnePacket;
    HwInitData.HwRequestTimeoutHandler  = DCamTimeoutHandler;
    HwInitData.DeviceExtensionSize      = sizeof(DCAM_EXTENSION);
    HwInitData.PerStreamExtensionSize   = sizeof(STREAMEX); 
    HwInitData.PerRequestExtensionSize  = sizeof(IRB);
    HwInitData.FilterInstanceExtensionSize = 0;
    HwInitData.BusMasterDMA             = FALSE;
    HwInitData.Dma24BitAddresses        = FALSE;
    HwInitData.BufferAlignment          = sizeof(ULONG) - 1;
    HwInitData.TurnOffSynchronization   = TRUE;
    HwInitData.DmaBufferSize            = 0;

    return (StreamClassRegisterAdapter(DriverObject, RegistryPath, &HwInitData));

}



#define DEQUEUE_SETTLE_TIME      (ULONG)(-1 * MAX_BUFFERS_SUPPLIED * 10000) 

NTSTATUS
DCamHwUnInitialize(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    Device is asked to be unloaded.
       
    Note: this can be called BEFORE CloseStream in the situation when a DCam 
    is unplugged while streaming in any state (RUN,PAUSE or STOP).  So if we 
    are here and the stream is not yet close, we will stop, close stream and then
    free resource.

Arguments:

    Srb - Pointer to stream request block

Return Value:

    Nothing

--*/
{
    NTSTATUS Status;
    PIRP pIrp;
    PIRB pIrb;    
    PDCAM_EXTENSION pDevExt = (PDCAM_EXTENSION) Srb->HwDeviceExtension;

    PAGED_CODE();

    ASSERT(pDevExt->PendingReadCount == 0);

    //
    // Host controller could be disabled which will cause us to be uninitialized.
    //
    if(DCamAllocateIrbAndIrp(&pIrb, &pIrp, pDevExt->BusDeviceObject->StackSize)) {

        //
        // un-register a bus reset callback notification
        //
        pIrb->FunctionNumber = REQUEST_BUS_RESET_NOTIFICATION;
        pIrb->Flags = 0;
        pIrb->u.BusResetNotification.fulFlags = DEREGISTER_NOTIFICATION_ROUTINE;
        pIrb->u.BusResetNotification.ResetRoutine = (PBUS_BUS_RESET_NOTIFICATION) DCamBusResetNotification;
        pIrb->u.BusResetNotification.ResetContext = 0; 
        Status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);
        if(Status) {
            ERROR_LOG(("DCamHwUnInitialize: Error (Status %x) while trying to deregister nus reset callback routine.\n", Status));
        } 

        DbgMsg1(("DCamHwUnInitialize: DeRegister bus reset notification done; status %x.\n", Status));

        DCamFreeIrbIrpAndContext(0, pIrb, pIrp);
    } else {
        ERROR_LOG(("DCamBusResetNotification: DcamAllocateIrbAndIrp has failed!!\n\n\n"));
        ASSERT(FALSE);   
    }

    // Free resource (from below)
    if(pDevExt->UnitDirectory) {
        ExFreePool(pDevExt->UnitDirectory);
        pDevExt->UnitDirectory = 0;
    }

    if(pDevExt->UnitDependentDirectory) {
        ExFreePool(pDevExt->UnitDependentDirectory);
        pDevExt->UnitDependentDirectory = 0;
    }

    if(pDevExt->ModelLeaf) {
        ExFreePool(pDevExt->ModelLeaf);
        pDevExt->ModelLeaf = 0;
    }

    if (pDevExt->ConfigRom) {
        ExFreePool(pDevExt->ConfigRom);
        pDevExt->ConfigRom = 0;
    }

    if (pDevExt->VendorLeaf) {
        ExFreePool(pDevExt->VendorLeaf);
        pDevExt->VendorLeaf = 0;
    }
      
    return STATUS_SUCCESS;
}




VOID 
InitializeDeviceExtension(
    PPORT_CONFIGURATION_INFORMATION ConfigInfo
    )
{
    PDCAM_EXTENSION pDevExt;

    pDevExt = (PDCAM_EXTENSION) ConfigInfo->HwDeviceExtension;
    pDevExt->SharedDeviceObject = ConfigInfo->ClassDeviceObject;
    pDevExt->BusDeviceObject = ConfigInfo->PhysicalDeviceObject;  // Used in IoCallDriver()
    pDevExt->PhysicalDeviceObject = ConfigInfo->RealPhysicalDeviceObject;  // Used in PnP API
    // In case sonydcam is used with old stream.sys, 
    // which has not implemented RealPhysicalDeviceObject.   
    if(!pDevExt->PhysicalDeviceObject)
        pDevExt->PhysicalDeviceObject = pDevExt->BusDeviceObject;
    ASSERT(pDevExt->PhysicalDeviceObject != 0);
    pDevExt->BaseRegister = 0;
    pDevExt->FrameRate = DEFAULT_FRAME_RATE;
    InitializeListHead(&pDevExt->IsochDescriptorList);
    KeInitializeSpinLock(&pDevExt->IsochDescriptorLock);
    pDevExt->bNeedToListen = FALSE;
    pDevExt->hResource = NULL;
    pDevExt->hBandwidth = NULL;
    pDevExt->IsochChannel = ISOCH_ANY_CHANNEL;
    pDevExt->PendingReadCount = 0; 
    pDevExt->pStrmEx = 0;

    InitializeListHead(&pDevExt->IsochWaitingList);
    KeInitializeSpinLock(&pDevExt->IsochWaitingLock);

    pDevExt->bDevRemoved = FALSE;

    pDevExt->CurrentPowerState = PowerDeviceD0;  // full power state.

    KeInitializeMutex( &pDevExt->hMutexProperty, 0);  // Level 0 and in Signal state
}


NTSTATUS
DCamHwInitialize(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This where we perform the necessary initialization tasks.

Arguments:

    Srb - Pointer to stream request block

Return Value:

    Nothing

--*/

{

    PIRB pIrb;
    PIRP pIrp;
    CCHAR StackSize;
    ULONG i;
    ULONG DirectoryLength;
    NTSTATUS status = STATUS_SUCCESS;
    PDCAM_EXTENSION pDevExt;
    PPORT_CONFIGURATION_INFORMATION ConfigInfo; 

         

    PAGED_CODE();

    ConfigInfo = Srb->CommandData.ConfigInfo;
    pIrb = (PIRB) Srb->SRBExtension;
    pDevExt = (PDCAM_EXTENSION) ConfigInfo->HwDeviceExtension;

    //
    // Initialize DeviceExtension
    //
    InitializeDeviceExtension(ConfigInfo); 


    StackSize = pDevExt->BusDeviceObject->StackSize;
    pIrp = IoAllocateIrp(StackSize, FALSE);
    if (!pIrp) {

        ASSERT(FALSE);
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // find what the host adaptor below us supports...
    //
    pIrb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
    pIrb->Flags = 0;
    pIrb->u.GetLocalHostInformation.nLevel = GET_HOST_CAPABILITIES;
    pIrb->u.GetLocalHostInformation.Information = &pDevExt->HostControllerInfomation;
    status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);
    if (status) {

        ERROR_LOG(("DCamHwInitialize: Error (Status=%x) while trying to get local hsot info.\n", status));
        status = STATUS_UNSUCCESSFUL;
        goto AbortLoading;
    }        


    //
    // find what the max buffer size is supported by the host.
    //
    pIrb->FunctionNumber = REQUEST_GET_LOCAL_HOST_INFO;
    pIrb->Flags = 0;
    pIrb->u.GetLocalHostInformation.nLevel = GET_HOST_DMA_CAPABILITIES;
    pIrb->u.GetLocalHostInformation.Information = &pDevExt->HostDMAInformation;
    status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);
    if (status) {
        ERROR_LOG(("DCamHwInitialize: Error (Status=%x) while trying to get GET_HOST_DMA_CAPABILITIES.\n", status));
        // May not supported in the ealier version of 1394
        // Set default.
    } else {
        ERROR_LOG(("\'GET_HOST_DMA_CAPABILITIES: HostDmaCapabilities;:%x; MaxDmaBufferSize:(Quad:%x; High:%x;Low:%x)\n",
            pDevExt->HostDMAInformation.HostDmaCapabilities, 
            (DWORD) pDevExt->HostDMAInformation.MaxDmaBufferSize.QuadPart,
            pDevExt->HostDMAInformation.MaxDmaBufferSize.u.HighPart,
            pDevExt->HostDMAInformation.MaxDmaBufferSize.u.LowPart
            ));
    }
    

    //
    // Make a call to determine what the generation # is on the bus,
    // followed by a call to find out about ourself (config rom info)
    //
    //
    // Get the current generation count first
    //

    pIrb->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
    pIrb->Flags = 0;

    status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);

    if (status) {

        ERROR_LOG(("\'DCamHwInitialize: Error %x while trying to get generation number\n", status));
        status = STATUS_UNSUCCESSFUL;
        goto AbortLoading;
    }

    InterlockedExchange(&pDevExt->CurrentGeneration, pIrb->u.GetGenerationCount.GenerationCount);

    //
    // Now that we have the current generation count, find out how much
    // configuration space we need by setting lengths to zero.
    //

    pIrb->FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;
    pIrb->Flags = 0;
    pIrb->u.GetConfigurationInformation.UnitDirectoryBufferSize = 0;
    pIrb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize = 0;
    pIrb->u.GetConfigurationInformation.VendorLeafBufferSize = 0;
    pIrb->u.GetConfigurationInformation.ModelLeafBufferSize = 0;

    status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);

    if (status) {

        ERROR_LOG(("\'DCamHwInitialize: Error %x while trying to get configuration info (1)\n", status));
        status = STATUS_UNSUCCESSFUL;
        goto AbortLoading;
    }

    //
    // Now go thru and allocate what we need to so we can get our info.
    //

    pDevExt->ConfigRom = ExAllocatePoolWithTag(PagedPool, sizeof(CONFIG_ROM), 'macd');
    if (!pDevExt->ConfigRom) {

        ERROR_LOG(("\'DCamHwInitialize: Couldn't allocate memory for the Config Rom\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto AbortLoading;
    }


    pDevExt->UnitDirectory = ExAllocatePoolWithTag(PagedPool, pIrb->u.GetConfigurationInformation.UnitDirectoryBufferSize, 'macd');
    if (!pDevExt->UnitDirectory) {

        ERROR_LOG(("\'DCamHwInitialize: Couldn't allocate memory for the UnitDirectory\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto AbortLoading;
    }


    if (pIrb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize) {

        pDevExt->UnitDependentDirectory = ExAllocatePoolWithTag(PagedPool, pIrb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize, 'macd');
        if (!pDevExt->UnitDependentDirectory) {

            ERROR_LOG(("\'DCamHwInitialize: Couldn't allocate memory for the UnitDependentDirectory\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto AbortLoading;
        }
    }


    if (pIrb->u.GetConfigurationInformation.VendorLeafBufferSize) {

        // From NonPaged pool since vendor name can be used in a func with DISPATCH level
        pDevExt->VendorLeaf = ExAllocatePoolWithTag(NonPagedPool, pIrb->u.GetConfigurationInformation.VendorLeafBufferSize, 'macd');
        if (!pDevExt->VendorLeaf) {

            ERROR_LOG(("\'DCamHwInitialize: Couldn't allocate memory for the VendorLeaf\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto AbortLoading;
        }
    } 

    if (pIrb->u.GetConfigurationInformation.ModelLeafBufferSize) {

        pDevExt->ModelLeaf = ExAllocatePoolWithTag(NonPagedPool, pIrb->u.GetConfigurationInformation.ModelLeafBufferSize, 'macd');
        if (!pDevExt->ModelLeaf) {

            ERROR_LOG(("\'DCamHwInitialize: Couldn't allocate memory for the ModelLeaf\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto AbortLoading;
        }
    }

    //
    // Now resubmit the pIrb with the appropriate pointers inside
    //

    pIrb->FunctionNumber = REQUEST_GET_CONFIGURATION_INFO;
    pIrb->Flags = 0;
    pIrb->u.GetConfigurationInformation.ConfigRom = pDevExt->ConfigRom;
    pIrb->u.GetConfigurationInformation.UnitDirectory = pDevExt->UnitDirectory;
    pIrb->u.GetConfigurationInformation.UnitDependentDirectory = pDevExt->UnitDependentDirectory;
    pIrb->u.GetConfigurationInformation.VendorLeaf = pDevExt->VendorLeaf;
    pIrb->u.GetConfigurationInformation.ModelLeaf = pDevExt->ModelLeaf;

    status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);

    if (status) {

        ERROR_LOG(("DCamHwInitialize: Error %x while trying to get configuration info (2)\n", status));
        status = STATUS_UNSUCCESSFUL;
        goto AbortLoading;
    }

    //
    // We might be able to return strings about a Device
    //

    if (pDevExt->VendorLeaf) {

        //
        // bswap to get the actual leaf length (in quadlets)
        //

        *((PULONG) pDevExt->VendorLeaf) = bswap(*((PULONG) pDevExt->VendorLeaf));

        DbgMsg1(("\'DCamHwInitialize: BufSize %d (byte); VendorLeaf %x; Len %d (Quad)\n", 
            pIrb->u.GetConfigurationInformation.VendorLeafBufferSize, 
            pDevExt->VendorLeaf, 
            pDevExt->VendorLeaf->TL_Length));

        if(pDevExt->VendorLeaf->TL_Length >= 1) {
            pDevExt->pchVendorName = &pDevExt->VendorLeaf->TL_Data;

        } else {
            pDevExt->pchVendorName = szUnknownVendorName;
        }

        DbgMsg1(("\'DCamHwInitialize: VendorName %s, strLen %d\n", pDevExt->pchVendorName, strlen(pDevExt->pchVendorName)));
    }

    //
    // Now we chew thru the Unit Dependent Directory looking for our command
    // base register key.
    //

    DirectoryLength = pIrb->u.GetConfigurationInformation.UnitDependentDirectoryBufferSize >> 2;
    for (i=1; i < DirectoryLength; i++) {

        if ((*(((PULONG) pDevExt->UnitDependentDirectory)+i) & CONFIG_ROM_KEY_MASK) == COMMAND_BASE_KEY_SIGNATURE) {

            //
            // Found the command base offset.  This is a quadlet offset from
            // the initial register space.  (Should come out to 0xf0f00000)
            //

            pDevExt->BaseRegister = bswap(*(((PULONG) pDevExt->UnitDependentDirectory)+i) & CONFIG_ROM_OFFSET_MASK);
            pDevExt->BaseRegister <<= 2;
            pDevExt->BaseRegister |= INITIAL_REGISTER_SPACE_LO;
            break;

        }
        
    }

    ASSERT( pDevExt->BaseRegister );

    if(!DCamDeviceInUse(pIrb, pDevExt)) {
        //
        // Now let's actually do a write request to initialize the device
        //
        pDevExt->RegisterWorkArea.AsULONG = 0;
        pDevExt->RegisterWorkArea.Initialize.Initialize = TRUE;
        pDevExt->RegisterWorkArea.AsULONG = bswap(pDevExt->RegisterWorkArea.AsULONG);

        status = DCamWriteRegister ((PIRB) Srb->SRBExtension, pDevExt, 
                  FIELDOFFSET(CAMERA_REGISTER_MAP, Initialize), pDevExt->RegisterWorkArea.AsULONG);

        if(status) {

            ERROR_LOG(("DCamHwInitialize: Error %x while trying to write to Initialize register\n", status));
            status = STATUS_UNSUCCESSFUL;
            goto AbortLoading;   
        }
    }

    //
    // Now we initialize the size of stream descriptor information.
    // We have one stream descriptor, and we attempt to dword align the
    // structure.
    //

    ConfigInfo->StreamDescriptorSize = 
        1 * (sizeof (HW_STREAM_INFORMATION)) +      // 1 stream descriptor
        sizeof(HW_STREAM_HEADER);                   // and 1 stream header


    //
    // Construct the device property table from querying the device and registry
    //
    if(!NT_SUCCESS(status = DCamPrepareDevProperties(pDevExt))) {
        goto AbortLoading;
    }

    // Get the features of the properties as well as its persisted value.
    // It will also updated the table.
    // The return is ignored since the default values are set when there is a failure.
    DCamGetPropertyValuesFromRegistry(
        pDevExt
        );

    //
    // Query video mode supported, and then contruct the stream format table.
    //
    if(!DCamBuildFormatTable(pDevExt, pIrb)) {
        ERROR_LOG(("\'Failed to get Video Format and Mode information; return STATUS_NOT_SUPPORTED\n"));
        status = STATUS_NOT_SUPPORTED;    
        goto AbortLoading;
    }

    //
    // register a bus reset callback notification (as the last action in this function)
    //
    // The controller driver will call (at DPC level)
    // if and only if the device is STILL attached.
    //
    // The device that has been removed, its
    // driver will get SRB_SURPRISE_REMOVAL instead.
    //
    
    pIrb->FunctionNumber = REQUEST_BUS_RESET_NOTIFICATION;
    pIrb->Flags = 0;
    pIrb->u.BusResetNotification.fulFlags = REGISTER_NOTIFICATION_ROUTINE;
    pIrb->u.BusResetNotification.ResetRoutine = (PBUS_BUS_RESET_NOTIFICATION) DCamBusResetNotification;
    pIrb->u.BusResetNotification.ResetContext = pDevExt;
    status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);
    if (status) {

        ERROR_LOG(("DCamHwInitialize: Error (Status=%x) while trying to get local host info.\n", status));
        status = STATUS_UNSUCCESSFUL;
        goto AbortLoading;
    }

    // This Irp is used locally only.
    IoFreeIrp(pIrp);  pIrp = NULL;


    DbgMsg1(("#### %s DCam loaded. ClassDO %x, PhyDO %x, BusDO %x, pDevExt %x, Gen# %d\n", 
        pDevExt->pchVendorName, pDevExt->SharedDeviceObject, pDevExt->PhysicalDeviceObject, pDevExt->BusDeviceObject, pDevExt, pDevExt->CurrentGeneration));

    return (STATUS_SUCCESS);

AbortLoading:


    if(pIrp) {
        IoFreeIrp(pIrp); pIrp = NULL;
    }

    if(pDevExt->ConfigRom) {
        ExFreePool(pDevExt->ConfigRom); pDevExt->ConfigRom = NULL;
    }

    if(pDevExt->UnitDirectory) {
        ExFreePool(pDevExt->UnitDirectory); pDevExt->UnitDirectory = NULL;
    }

    if(pDevExt->UnitDependentDirectory) {
        ExFreePool(pDevExt->UnitDependentDirectory); pDevExt->UnitDependentDirectory = NULL;
    }

    if(pDevExt->VendorLeaf) {
        ExFreePool(pDevExt->VendorLeaf); pDevExt->VendorLeaf = NULL;
    }

    if(pDevExt->ModelLeaf) {
        ExFreePool(pDevExt->ModelLeaf); pDevExt->ModelLeaf = NULL;
    }

    return status;

}


NTSTATUS
DCamSubmitIrpSynch(
    PDCAM_EXTENSION pDevExt,
    PIRP pIrp,
    PIRB pIrb
    )

/*++

Routine Description:

    This routine submits an Irp synchronously to the bus driver.  We'll
    wait here til the Irp comes back

Arguments:

    pDevExt - Pointer to my local device extension

    pIrp - Pointer to Irp we're sending down to the port driver synchronously

    pIrb - Pointer to Irb we're submitting to the port driver

Return Value:

    Status is returned from Irp

--*/

{


    LONG Retries=RETRY_COUNT_IRP_SYNC;  // Take the worst case of 20 * 100 msec = 1sec
    KEVENT Event;
    NTSTATUS status;
    LARGE_INTEGER deltaTime;
    PIO_STACK_LOCATION NextIrpStack;
    BOOL bCanWait = KeGetCurrentIrql() < DISPATCH_LEVEL;
    BOOL bRetryStatus;
    PIRB pIrbRetry;
    NTSTATUS StatusRetry;
    ULONG ulGeneration;

    

    do {

        NextIrpStack = IoGetNextIrpStackLocation(pIrp);
        NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_1394_CLASS;
        NextIrpStack->Parameters.Others.Argument1 = pIrb;

        KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

        IoSetCompletionRoutine(
            pIrp,
            DCamSynchCR,
           &Event,
            TRUE,
            TRUE,
            TRUE
            );

        status = IoCallDriver(
                    pDevExt->BusDeviceObject,
                    pIrp
                    );


        DbgMsg3(("\'DCamSubmitIrpSynch: pIrp is pending(%s); will wait(%s)\n", 
                   status == STATUS_PENDING?"Y":"N", bCanWait?"Y":"N"));

        if (bCanWait &&
            status == STATUS_PENDING) {

            //
            // Still pending, wait for the IRP to complete
            //

            KeWaitForSingleObject(  // Only in <= IRQL_DISPATCH_LEVEL; can only in DISPATCH if Timeout is 0
               &Event,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );

        }

        // Will retry for any of these return status codes.
        bRetryStatus = 
             pIrp->IoStatus.Status == STATUS_TIMEOUT ||
             pIrp->IoStatus.Status == STATUS_IO_TIMEOUT ||
             pIrp->IoStatus.Status == STATUS_DEVICE_BUSY ||
             pIrp->IoStatus.Status == STATUS_INVALID_GENERATION;

        if (bCanWait && bRetryStatus && Retries > 0) {

            // Camera isn't fast enough to respond so delay this thread and try again.
            switch(pIrp->IoStatus.Status) {

            case STATUS_TIMEOUT: 
            case STATUS_IO_TIMEOUT: 
            case STATUS_DEVICE_BUSY: 

                deltaTime.LowPart = DCAM_DELAY_VALUE;
                deltaTime.HighPart = -1;
                KeDelayExecutionThread(KernelMode, TRUE, &deltaTime); 
                break;

            case STATUS_INVALID_GENERATION:

                // Cache obsolete ulGeneration and use it to detect its udpate in busreset callback.               
                if(pIrb->FunctionNumber == REQUEST_ASYNC_READ)
                    ulGeneration = pIrb->u.AsyncRead.ulGeneration;
                else if(pIrb->FunctionNumber == REQUEST_ASYNC_WRITE)
                    ulGeneration = pIrb->u.AsyncWrite.ulGeneration;
                else if(pIrb->FunctionNumber == REQUEST_ASYNC_LOCK)
                    ulGeneration = pIrb->u.AsyncLock.ulGeneration;
                else if(pIrb->FunctionNumber == REQUEST_ISOCH_FREE_BANDWIDTH) {
                    ERROR_LOG(("InvGen when free BW\n"));                    
                    // Special case that we do not need to retry since BW should be free
                    // and 1394 bus should just free the BW structure.
                    Retries = 0;  // no more retry and exit.
                    break;
                }
                else {
                    // Other REQUEST_* that depends on ulGeneration
                    ERROR_LOG(("Unexpected IRB function with InvGen:%d\n", pIrb->FunctionNumber));  
                    ASSERT(FALSE && "New REQUEST that requires ulGeneration");
                    Retries = 0;  // do not know what to do so no more retry and exit.
                    break;
                }
                
                pIrbRetry = ExAllocatePoolWithTag(NonPagedPool, sizeof(IRB), 'macd');
                if (pIrbRetry) {

                    deltaTime.LowPart = DCAM_DELAY_VALUE_BUSRESET;  // Longer than the regular delay
                    deltaTime.HighPart = -1;

                    do {
                        KeDelayExecutionThread(KernelMode, TRUE, &deltaTime);

                        pIrbRetry->FunctionNumber = REQUEST_GET_GENERATION_COUNT;
                        pIrbRetry->u.GetGenerationCount.GenerationCount = 0;
                        pIrbRetry->Flags = 0;
                        StatusRetry = DCamSubmitIrpSynch(pDevExt, pIrp, pIrbRetry);  // Recursive with differnt IRB but same IRP.

                        if(NT_SUCCESS(StatusRetry) && pIrbRetry->u.GetGenerationCount.GenerationCount > ulGeneration) {
                            InterlockedExchange(&pDevExt->CurrentGeneration, pIrbRetry->u.GetGenerationCount.GenerationCount);
                            // Update the generation count for the original IRB request and try again.
                            if(pIrb->FunctionNumber == REQUEST_ASYNC_READ)
                                InterlockedExchange(&pIrb->u.AsyncRead.ulGeneration, pDevExt->CurrentGeneration);
                            else if(pIrb->FunctionNumber == REQUEST_ASYNC_WRITE)
                                InterlockedExchange(&pIrb->u.AsyncWrite.ulGeneration, pDevExt->CurrentGeneration);
                            else if(pIrb->FunctionNumber == REQUEST_ASYNC_LOCK)
                                InterlockedExchange(&pIrb->u.AsyncLock.ulGeneration, pDevExt->CurrentGeneration);
                            else {
                                // Other (new) REQUEST_* that depends on ulGeneration
                            }                        
                        }

                        if(Retries)
                            Retries--;

                    } while (Retries && ulGeneration >= pDevExt->CurrentGeneration);

                    ERROR_LOG(("(%d) IrpSync: StautsRetry %x; Generation %d -> %d\n", 
                        Retries, StatusRetry, ulGeneration, pDevExt->CurrentGeneration));

                    ExFreePool(pIrbRetry); pIrbRetry = 0;
                }  // if
                break;                                            

            // All other status
            default:
                break;      
            }
        }

        if(Retries)
            Retries--;
 
    } while (bCanWait && bRetryStatus && (Retries > 0));

#if DBG
    if(!NT_SUCCESS(pIrp->IoStatus.Status)) {
        ERROR_LOG(("IrpSynch: IoCallDriver Status:%x; pIrp->IoStatus.Status (final):%x; Wait:%d; Retries:%d\n", status, pIrp->IoStatus.Status, bCanWait, Retries)); 
    }
#endif

    return (pIrp->IoStatus.Status);

}


NTSTATUS
DCamSynchCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This routine is for use with synchronous IRP processing.  
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DriverObject - Pointer to driver object created by system.

    pIrp - Irp that just completed

    Event - Event we'll signal to say Irp is done

Return Value:

    None.

--*/

{

    KeSetEvent((PKEVENT) Event, 0, FALSE);
    return (STATUS_MORE_PROCESSING_REQUIRED);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\1394dcam\sonydcam.h ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    sonydcam.h

Abstract:

    Header file for sonydcam.c 

Author:
    
    Shaun Pierce 25-May-96

Environment:

    Kernel mode only

Revision History:


--*/



//
// Function prototypes
//

NTSTATUS
DriverEntry(
    IN PVOID Context1,
    IN PVOID Context2
    );

VOID 
InitializeDeviceExtension(
    PPORT_CONFIGURATION_INFORMATION ConfigInfo
    );

NTSTATUS
DCamHwUnInitialize(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
DCamHwInitialize(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
DCamSubmitIrpSynch(
    PDCAM_EXTENSION pDevExt,
    PIRP pIrp,
    PIRB pIrb
    );

NTSTATUS
DCamSynchCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PKEVENT Event
    );

ULONG
bitcount(
    IN ULONG b
    );


#define COMPLETE_SRB(pSrb) if(pSrb->Flags & SRB_HW_FLAGS_STREAM_REQUEST)  \
                              StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb); \
                           else  \
                              StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb); 
        


//
// External functions
//

extern 
VOID
DCamReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

extern
VOID
DCamCancelAllPackets(
    PHW_STREAM_REQUEST_BLOCK pSrb,
    PDCAM_EXTENSION pDevExt,
    LONG *plPendingReadCount    
    );

extern
VOID
DCamCancelOnePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

extern 
VOID
DCamTimeoutHandler(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

extern VOID
DCamBusResetNotification(
    IN PVOID Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\1394dcam\device.c ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================
/*++

Module Name:

    Device.c

Abstract:

    This file contains code to read/write request from the DCam.

Author:
    
    Yee J. Wu 9-Sep-97

Environment:

    Kernel mode only

Revision History:


--*/
#include "strmini.h"
#include "ksmedia.h"
#include "1394.h"
#include "wdm.h"       // for DbgBreakPoint() defined in dbg.h
#include "dbg.h"
#include "dcamdef.h"
#include "dcampkt.h"
#include "sonydcam.h"




NTSTATUS
DCamReadRegister(
    IN PIRB pIrb,
    PDCAM_EXTENSION pDevExt,
    ULONG ulFieldOffset,
    ULONG * pulValue
)
{
    NTSTATUS status;
    LARGE_INTEGER deltaTime;
       PIRP pIrp;


    //
    // Delay for camera before next request
    //
    ASSERT(pDevExt->BusDeviceObject != NULL);

    pIrp = IoAllocateIrp(pDevExt->BusDeviceObject->StackSize, FALSE);

    if (!pIrp) {

        ASSERT(FALSE);
        return (STATUS_INSUFFICIENT_RESOURCES);

    }

    //
    // Delay for camera before next request
    //
    if(KeGetCurrentIrql() < DISPATCH_LEVEL) {
        deltaTime.LowPart = DCAM_DELAY_VALUE;
        deltaTime.HighPart = -1;
        KeDelayExecutionThread(KernelMode, TRUE, &deltaTime);
    }

    pIrb->FunctionNumber = REQUEST_ASYNC_READ;
    pIrb->Flags = 0;
    pIrb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_High = INITIAL_REGISTER_SPACE_HI;
    pIrb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low = pDevExt->BaseRegister + ulFieldOffset;
    pIrb->u.AsyncRead.nNumberOfBytesToRead = sizeof(ULONG);
    pIrb->u.AsyncRead.nBlockSize = 0;
    pIrb->u.AsyncRead.fulFlags = 0;
    InterlockedExchange(&pIrb->u.AsyncRead.ulGeneration, pDevExt->CurrentGeneration);
    pDevExt->RegisterWorkArea.AsULONG = 0;    // Initilize the return buffer.
    pIrb->u.AsyncRead.Mdl = 
    IoAllocateMdl(&pDevExt->RegisterWorkArea, sizeof(ULONG), FALSE, FALSE, NULL);
    MmBuildMdlForNonPagedPool(pIrb->u.AsyncRead.Mdl);

    DbgMsg3(("\'DCamReadRegister: Read from address (%x, %x)\n",
          pIrb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_High,
          pIrb->u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low));    

    status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);

    if (status) {

        ERROR_LOG(("DCamRange: Error %x while trying to read from register\n", status));               
    } else {

        *pulValue = pDevExt->RegisterWorkArea.AsULONG;
        DbgMsg3(("\'DCamReadRegister: status=0x%x, value=0x%x\n", status, *pulValue));               
    }


    IoFreeMdl(pIrb->u.AsyncWrite.Mdl);
    IoFreeIrp(pIrp);

    return status;
}


NTSTATUS
DCamWriteRegister(
    IN PIRB pIrb,
    PDCAM_EXTENSION pDevExt,
    ULONG ulFieldOffset,
    ULONG ulValue
)
{
    NTSTATUS status;
    LARGE_INTEGER deltaTime;
    PIRP pIrp;

    ASSERT(pDevExt->BusDeviceObject != NULL);
    pIrp = IoAllocateIrp(pDevExt->BusDeviceObject->StackSize, FALSE);

    if (!pIrp) {

        ASSERT(FALSE);
        return (STATUS_INSUFFICIENT_RESOURCES);

    }

    //
    // Delay for camera before next request
    //
    if(KeGetCurrentIrql() < DISPATCH_LEVEL) {
        deltaTime.LowPart = DCAM_DELAY_VALUE;
        deltaTime.HighPart = -1;
        KeDelayExecutionThread(KernelMode, TRUE, &deltaTime);
    }


    pIrb->FunctionNumber = REQUEST_ASYNC_WRITE;
    pIrb->Flags = 0;
    pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High = INITIAL_REGISTER_SPACE_HI;
    pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low =     pDevExt->BaseRegister + ulFieldOffset;
    pIrb->u.AsyncWrite.nNumberOfBytesToWrite = sizeof(ULONG);
    pIrb->u.AsyncWrite.nBlockSize = 0;
    pIrb->u.AsyncWrite.fulFlags = 0;
    InterlockedExchange(&pIrb->u.AsyncWrite.ulGeneration, pDevExt->CurrentGeneration);
    pDevExt->RegisterWorkArea.AsULONG = ulValue;    // Initilize the return buffer.
    pIrb->u.AsyncWrite.Mdl = 
    IoAllocateMdl(&pDevExt->RegisterWorkArea, sizeof(ULONG), FALSE, FALSE, NULL);
    MmBuildMdlForNonPagedPool(pIrb->u.AsyncWrite.Mdl);
    
    DbgMsg3(("\'DCamWriteRegister: Write to address (%x, %x)\n", pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High, pIrb->u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low));    

    status = DCamSubmitIrpSynch(pDevExt, pIrp, pIrb);

    if (status) {
        ERROR_LOG(("\'DCamWriteRegister: Error %x while trying to write to register\n", status));               
    } 
    

    IoFreeMdl(pIrb->u.AsyncWrite.Mdl);
    IoFreeIrp(pIrp);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\atibios.h ===
//==========================================================================;
//
//File:			ATIBIOS.H
//
//Purpose:		Provide definitions for BIOS structures used in the ATI private
//			interfacese exposed via GPIO Interface
//
//Reference:	Ilya Klebanov
//
//Notes:		This file is provided under strict non-disclosure agreements
//			it is and remains the property of ATI Technologies Inc.
//			Any use of this file or the information it contains to
//			develop products commercial or otherwise must be with the
//			permission of ATI Technologies Inc.
//
//Copyright (C) 1997 - 1998, ATI Technologies Inc.
//
//==========================================================================;

#ifndef _ATIBIOS_H_
#define _ATIBIOS_H_

typedef struct tag_ATI_MULTIMEDIAINFO
{
	UCHAR	MMInfo_Byte0;
	UCHAR	MMInfo_Byte1;
	UCHAR	MMInfo_Byte2;
	UCHAR	MMInfo_Byte3;
	UCHAR	MMInfo_Byte4;
	UCHAR	MMInfo_Byte5;
	UCHAR	MMInfo_Byte6;
	UCHAR	MMInfo_Byte7;

} ATI_MULTIMEDIAINFO, * PATI_MULTIMEDIAINFO;


typedef struct tag_ATI_MULTIMEDIAINFO1
{
	UCHAR	MMInfo1_Byte0;
	UCHAR	MMInfo1_Byte1;
	UCHAR	MMInfo1_Byte2;
	UCHAR	MMInfo1_Byte3;
	UCHAR	MMInfo1_Byte4;
	UCHAR	MMInfo1_Byte5;
	UCHAR	MMInfo1_Byte6;
	UCHAR	MMInfo1_Byte7;
	UCHAR	MMInfo1_Byte8;
	UCHAR	MMInfo1_Byte9;
	UCHAR	MMInfo1_Byte10;
	UCHAR	MMInfo1_Byte11;

} ATI_MULTIMEDIAINFO1, * PATI_MULTIMEDIAINFO1;


typedef struct tag_ATI_HARDWAREINFO
{
	UCHAR	I2CHardwareMethod;
	UCHAR	ImpactTVSupport;
	UCHAR	VideoPortType;

} ATI_HARDWAREINFO, * PATI_HARDWAREINFO;

// this structure definition left for compatability purposes with MiniVDD checked in
// for Windows98 Beta3. The latest MiniVDD exposes set of Private Interfaces instead
// of copying the information into the Registry.
typedef struct
{
    UINT    uiSize;
    UINT    uiVersion;
    UINT    uiCardNumber;
    UINT    uiBoardRevision;
    UINT    uiTunerType;
    UINT    uiVideoInputConnectorType;
    UINT    uiVideoOutputConnectorType;
    UINT    uiCDInputConnector;
    UINT    uiCDOutputConnector;
    UINT    uiVideoPassThrough;
    UINT    uiVideoDecoderType;
    UINT    uiVideoDecoderCrystals;
    UINT    uiVideoOutCrystalFrequency;
    UINT    uiAudioCircuitType;
    UCHAR   uchATIProdType;
    UCHAR   uchOEM;
    UCHAR   uchOEMVersion;
    UCHAR   uchReserved3;
    UCHAR   uchReserved4;

} CWDDE32BoardIdBuffer, * PCWDDE32BoardIdBuffer;

#endif	// _ATIBIOS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\aticonfg.h ===
//==========================================================================;
//
//  ATIConfg.H
//      CATIHwConfiguration Class definition.
//  Copyright (c) 1996 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//      $Date:   16 Nov 1998 13:40:34  $
//  $Revision:   1.9  $
//    $Author:   minyailo  $
//
//==========================================================================;

#ifndef _ATICONFG_H_

#define _ATICONFG_H_


#include "i2script.h"
#include "tda9850.h"
#include "tda9851.h"
#include "atibios.h"
// this file is included for compatability with MiniVDD checked in for Beta3 of Windows98
#include "registry.h"
#include "mmconfig.h"   //Paul


class CATIHwConfiguration
{
public:
    // constructor
    CATIHwConfiguration     ( PPORT_CONFIGURATION_INFORMATION pConfigInfo, CI2CScript * pCScript, PUINT puiError);
    PVOID operator new      ( size_t size, PVOID pAllocation);

// Attributes   
private:
    // tuner's configuration properties
    USHORT          m_usTunerId;
    UCHAR           m_uchTunerAddress;
    USHORT          m_usTunerPowerConfiguration;
    // decoder's configuration properties
    USHORT          m_usDecoderId;
    UCHAR           m_uchDecoderAddress;
    USHORT          m_usDecoderConfiguration;
    // audio's configuration properties
    UCHAR           m_uchAudioAddress;
    UINT            m_uiAudioConfiguration;
    // hardware configuration
    UCHAR           m_uchI2CExpanderAddress;
    USHORT          m_usE2PROMValidation;
    // GPIO Provider related
    GPIOINTERFACE   m_gpioProviderInterface;
    PDEVICE_OBJECT  m_pdoDriver;
    DWORD           m_dwGPIOAccessKey;
    // Paul:  Decide video in standards supported by crystal by looking at MMTable or I2C expander crystal information
    ULONG           m_VideoInStandardsSupported;
    UCHAR           m_CrystalIDInMMTable;           

// Implementation
public:
    BOOL            GetTunerConfiguration       ( PUINT puiTunerId, PUCHAR puchTunerAddress);
    BOOL            GetDecoderConfiguration     ( PUINT puiDecoderId, PUCHAR puchDecoderAddress);
    BOOL            GetAudioConfiguration       ( PUINT puiAudioId, PUCHAR puchAudioAddress);
    UINT            GetDecoderOutputEnableLevel ( void);

    void            EnableDecoderI2CAccess      ( CI2CScript * pCScript, BOOL bEnable);
    BOOL            GetAudioProperties          ( PULONG puiNumberOfInputs, PULONG puiNumberOfOutputs);
    BOOL            InitializeAudioConfiguration( CI2CScript * pCScript, UINT uiAudioConfigurationId, UCHAR uchAudioChipAddress);

    BOOL            CanConnectAudioSource       ( int nAudioSource);
    BOOL            ConnectAudioSource          ( CI2CScript * pCScript, int nAudioSource);
    BOOL            GetTVAudioSignalProperties  ( CI2CScript * pCScript, PBOOL pbStereo, PBOOL pbSAP);

    BOOL            SetTunerPowerState          ( CI2CScript * pCScript,
                                                  BOOL bPowerState);
    ULONG           GetVideoInStandardsSupportedByCrystal( )
        { return m_VideoInStandardsSupported; }                 //Paul
    ULONG           GetVideoInStandardsSupportedByTuner( )
        { return ReturnTunerVideoStandard( m_usTunerId ); }
    BOOL            GetMMTableCrystalID( PUCHAR pucCrystalID );

private:
    BOOL            FindI2CExpanderAddress      ( CI2CScript * pCScript);
    BOOL            FindHardwareProperties      ( PDEVICE_OBJECT pDeviceObject, CI2CScript * pCScript);

    BOOL            GetI2CExpanderConfiguration ( CI2CScript * pCScript, PUCHAR puchI2CValue);
    BOOL            SetDefaultVolumeControl     ( CI2CScript * pCScript);

    BOOL            ValidateConfigurationE2PROM ( CI2CScript * pCScript);
    BOOL            ReadConfigurationE2PROM     ( CI2CScript * pCScript, ULONG nOffset, PUCHAR puchValue);

    BOOL            InitializeAttachGPIOProvider( GPIOINTERFACE * pGPIOInterface, PDEVICE_OBJECT pDeviceObject);
    BOOL            LocateAttachGPIOProvider    ( GPIOINTERFACE * pGPIOInterface, PDEVICE_OBJECT pDeviceObject, UCHAR nIrpMajorFunction);

    BOOL            LockGPIOProviderEx          ( PGPIOControl pgpioAccessBlock);
    BOOL            ReleaseGPIOProvider         ( PGPIOControl pgpioAccessBlock);
    BOOL            AccessGPIOProvider          ( PDEVICE_OBJECT pdoClient, PGPIOControl pgpioAccessBlock);
    ULONG           ReturnTunerVideoStandard    ( USHORT usTunerId );   //Paul:  For PAL support
    ULONG           SetVidStdBasedOnI2CExpander ( UCHAR ucI2CValue );   //Paul
    ULONG           SetVidStdBasedOnMMTable     ( CATIMultimediaTable * pCMultimediaInfo );    //Paul
};


#define ATIHARDWARE_TUNER_WAKEUP_DELAY      -100000     // 10 msec in 100 nsec units

typedef enum
{
    VIDEODECODER_TYPE_NOTINSTALLED = 0,
    VIDEODECODER_TYPE_BT819,
    VIDEODECODER_TYPE_BT829,
    VIDEODECODER_TYPE_BT829A,
    VIDEODECODER_TYPE_PH7111,
    VIDEODECODER_TYPE_PH7112,
    VIDEODECODER_TYPE_RTHEATER  //  RTheater

} ATI_VIDEODECODER_TYPE;

enum
{
    AUDIOSOURCE_MUTE = 0,
    AUDIOSOURCE_TVAUDIO,
    AUDIOSOURCE_LINEIN,
    AUDIOSOURCE_FMAUDIO,
    AUDIOSOURCE_LASTSUPPORTED

};
//****************************************************************************
//  Decoder Configurations          Dec. Type               Dec. Enable Method
//****************************************************************************
typedef enum
{
    ATI_VIDEODECODER_CONFIG_UNDEFINED = 0,
    ATI_VIDEODECODER_CONFIG_1,      //  BT829 on ATI TV or AIW  IO Exp Bit 7
    ATI_VIDEODECODER_CONFIG_2,      //  BT829A and above        BT Reg 0x16, OE=1
    ATI_VIDEODECODER_CONFIG_3,      //  BT829                   CPU GPIO 0x7c
    ATI_VIDEODECODER_CONFIG_4,      //  BT829                   CPU GPIO 0x78

} ATI_DECODER_CONFIGURATION;

//****************************************************************************
//  Audio Configurations        SAP     STEREO          VOLUME      MUX
//****************************************************************************
enum
{
    ATI_AUDIO_CONFIG_1 = 1, //  No      IO Exp b6=0     No          IO Exp
                            //                                        b6:b4
                            //                                      M x:0
                            //                                      T 0:1
                            //                                      L 1:1
                            //                                      F n/a
//****************************************************************************
    ATI_AUDIO_CONFIG_2,     //  TDA9850 TDA9850         Yes         EXT_DAC_REGS
                            //                                        b6:b4
                            //                                      M 1:0
                            //                                      T 0:1
                            //                                      L 0:0
                            //                                      F 1:1
//****************************************************************************
    ATI_AUDIO_CONFIG_3,     //  No      No              No          IO Exp
                            //                                        b6
                            //                                      M n/a
                            //                                      T 0
                            //                                      L 1
                            //                                      F n/a
//****************************************************************************
    ATI_AUDIO_CONFIG_4,     //  No      No              Yes         TDA8425
//****************************************************************************
    ATI_AUDIO_CONFIG_5,     //  No      TEA5582         No          IO Exp
                            //                                        b6:b4
                            //                                      M 1:1
                            //                                      T 0:0
                            //                                      L 1:0
                            //                                      F 0:1
//****************************************************************************
    ATI_AUDIO_CONFIG_6,     //  No      BT829           Automatic   BT829 GPIO
                            //          GPIO4           Volume        0:1
                            //          and             Control     M 0:1
                            //          TDA9851                     T 1:0
                            //          for TV                      L 0:0
                            //                                      F 1:1
//****************************************************************************
    ATI_AUDIO_CONFIG_7,     //  TDA9850 TDA9850         Yes         BT829 GPIO
                            //                                      AS0:1
                            //                                      M 0:1
                            //                                      T 1:0
                            //                                      L 0:0
                            //                                      F 1:1
//****************************************************************************
    ATI_AUDIO_CONFIG_8      //  MSP3430 MSP3430         Yes         MSP3430
//****************************************************************************

};


//****************************************************************************
//  Tuner Power Mode Configurations     Supported   Control
//****************************************************************************
enum
{
    ATI_TUNER_POWER_CONFIG_0 = 0,   //  No
//****************************************************************************
    ATI_TUNER_POWER_CONFIG_1,       //  Yes         EXT_DAC_REGS
                                    //                  b4
                                    //              ON  0
                                    //              OFF 1
//****************************************************************************
    ATI_TUNER_POWER_CONFIG_2        //  Yes         BT829 GPIO
                                    //                  3
                                    //              ON  0
                                    //              OFF 1
//****************************************************************************
};


enum 
{
    OEM_ID_ATI = 0,
    OEM_ID_INTEL,
    OEM_ID_APRICOT,
    OEM_ID_COMPAQ,
    OEM_ID_SAMSUNG,
    OEM_ID_BCM,
    OEM_ID_QUANTA,
    OEM_ID_SAMREX,
    OEM_ID_FUJITSU,
    OEM_ID_NEC,

};

enum 
{
    REVISION0 = 0,
    REVISION1,
    REVISION2,
    REVISION3,
    REVISION4,
};

enum 
{
    ATI_PRODUCT_TYPE_AIW = 1,
    ATI_PRODUCT_TYPE_AIW_PRO_NODVD,             // 2
    ATI_PRODUCT_TYPE_AIW_PRO_DVD,               // 3
    ATI_PRODUCT_TYPE_AIW_PLUS,                  // 4
    ATI_PRODUCT_TYPE_AIW_PRO_R128_KITCHENER,    // 5
    ATI_PRODUCT_TYPE_AIW_PRO_R128_TORONTO       // 6

};

#define INTEL_ANCHORAGE                         1

#define AIWPRO_CONFIGURATIONE2PROM_ADDRESS      0xA8
#define AIWPRO_CONFIGURATIONE2PROM_LENGTH       128         // 0x80

#endif  // _ATICONFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\aticonfg.cpp ===
//==========================================================================;
//
//  ATIConfg.CPP
//  WDM MiniDrivers development.
//      ATIHwConfiguration class implementation.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//      $Date:   10 Jun 1999 09:54:42  $
//  $Revision:   1.21  $
//    $Author:   KLEBANOV  $
//
//==========================================================================;

extern"C"
{
#include "conio.h"
#include "strmini.h"
#include "wdmdebug.h"
#include "ksmedia.h"    //Paul
}

#include "aticonfg.h"
#include "wdmdrv.h"
#include "atigpio.h"
#include "mmconfig.h"


/*^^*
 *      CATIHwConfiguration()
 * Purpose  : CATIHwConfiguration Class constructor
 *              Determines I2CExpander address and all possible hardware IDs and addresses
 *
 * Inputs   : PDEVICE_OBJECT pDeviceObject  : pointer to the creator DeviceObject
 *            CI2CScript * pCScript         : pointer to the I2CScript class object
 *            PUINT puiError                : pointer to return Error code
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
CATIHwConfiguration::CATIHwConfiguration( PPORT_CONFIGURATION_INFORMATION pConfigInfo, CI2CScript * pCScript, PUINT puiError)
{

    ENSURE
    {
        m_VideoInStandardsSupported = 0;
        m_CrystalIDInMMTable = 0xF; // invalid entry, needs to be set when set with the value from MMTable
        m_gpioProviderInterface.gpioOpen = NULL;
        m_gpioProviderInterface.gpioAccess = NULL;
        m_pdoDriver = NULL;
        
        m_usE2PROMValidation = ( USHORT)-1;

        if( InitializeAttachGPIOProvider( &m_gpioProviderInterface, pConfigInfo->PhysicalDeviceObject))
            // there was no error to get GPIOInterface from the MiniVDD
            m_pdoDriver = pConfigInfo->RealPhysicalDeviceObject;
        else
        {
            * puiError = WDMMINI_ERROR_NOGPIOPROVIDER;
            FAIL;
        }

        if( !FindI2CExpanderAddress( pCScript))
        {
            * puiError = WDMMINI_NOHARDWARE;
            FAIL;
        }
    
        if( !FindHardwareProperties( pConfigInfo->RealPhysicalDeviceObject, pCScript))
        {
            * puiError = WDMMINI_NOHARDWARE;
            FAIL;
        }

        * puiError = WDMMINI_NOERROR;

        OutputDebugTrace(( "CATIHwConfig:CATIHwConfiguration() exit\n"));

    } END_ENSURE;

    if( * puiError != WDMMINI_NOERROR)
        OutputDebugError(( "CATIHwConfig:CATIHwConfiguration() uiError=%x\n", * puiError));
}


/*^^*
 *      FindHardwareProperties()
 * Purpose  : Determines hardware properties : I2C address and the type
 *
 * Inputs   : PDEVICEOBJECT pDeviceObject: pointer to device object
 *            CI2CScript * pCScript : pointer to the I2CScript object
 *
 * Outputs  : BOOL, TRUE if a valid ATI hardware Configuration was found
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::FindHardwareProperties( PDEVICE_OBJECT pDeviceObject, CI2CScript * pCScript)
{
    UCHAR                   uchI2CValue;
    UCHAR                   uchORMask = 0x00;
    UCHAR                   uchANDMask = 0xFF;
    BOOL                    bResult = TRUE;
    I2CPacket               i2cPacket;

    m_VideoInStandardsSupported = 0;    //Paul

    m_uchTunerAddress = 0;
    m_usTunerId = 0;
    m_usTunerPowerConfiguration = ATI_TUNER_POWER_CONFIG_0;

    m_uchDecoderAddress = 0;
    m_usDecoderId = VIDEODECODER_TYPE_NOTINSTALLED;
    m_usDecoderConfiguration = 0;

    m_uchAudioAddress = 0;
    m_uiAudioConfiguration = 0;

    switch( m_uchI2CExpanderAddress)
    {
        case 0x70:          // a standard external tuner board

            m_uchTunerAddress   = 0xC0;
            m_uchDecoderAddress = 0x88;
            // we need to determine actual Decoder ID, implement later
            m_usDecoderId = VIDEODECODER_TYPE_BT829;

            if( GetI2CExpanderConfiguration( pCScript, &uchI2CValue))
            {
                m_usTunerId = uchI2CValue & 0x0F;

                m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_1;

                if( uchI2CValue & 0x10)
                {
                    m_uiAudioConfiguration = ATI_AUDIO_CONFIG_4;
                    m_uchAudioAddress = 0x82;
                }
                else
                    m_uiAudioConfiguration = ATI_AUDIO_CONFIG_3;
            }

            m_VideoInStandardsSupported = SetVidStdBasedOnI2CExpander( uchI2CValue );   //Paul

            break;

        case 0x78:          // FM tuner
            m_uchTunerAddress   = 0xC0;
            m_uchDecoderAddress = 0x88;
            // we need to determine actual Decoder ID, implement later
            m_usDecoderId = VIDEODECODER_TYPE_BT829;

            if( GetI2CExpanderConfiguration( pCScript, &uchI2CValue))
            {
                m_usTunerId = uchI2CValue & 0x0F;

                m_usDecoderConfiguration    = ATI_VIDEODECODER_CONFIG_1;
                m_uiAudioConfiguration      = ATI_AUDIO_CONFIG_5;
            }

            m_VideoInStandardsSupported = SetVidStdBasedOnI2CExpander( uchI2CValue );   //Paul

            break;

        case 0x76:      // AllInWonder, configuration is in the BIOS
            {
                CATIMultimediaTable CMultimediaInfo( pDeviceObject, &m_gpioProviderInterface, &bResult);

                if( bResult)
                {
                    // tuner and decoder Info is included
                    m_uchTunerAddress   = 0xC6;
                    m_uchDecoderAddress = 0x8A;
                    m_usDecoderConfiguration    = ATI_VIDEODECODER_CONFIG_1;
                    m_uiAudioConfiguration      = ATI_AUDIO_CONFIG_1;

                    if( !CMultimediaInfo.GetTVTunerId( &m_usTunerId) ||
                        !CMultimediaInfo.GetVideoDecoderId( &m_usDecoderId))
                        bResult = FALSE;
                    else
                        m_VideoInStandardsSupported = SetVidStdBasedOnMMTable( &CMultimediaInfo );  //Paul

                }
                break;
            }

        case 0x7C:
            ENSURE
            {
                i2cPacket.uchChipAddress = m_uchI2CExpanderAddress;
                i2cPacket.cbReadCount = 1;
                i2cPacket.cbWriteCount = 0;
                i2cPacket.puchReadBuffer = &uchI2CValue;
                i2cPacket.puchWriteBuffer = NULL;
                i2cPacket.usFlags = 0;
            
                pCScript->ExecuteI2CPacket( &i2cPacket);
            
                if( i2cPacket.uchI2CResult != I2C_STATUS_NOERROR)
                {
                    bResult = FALSE;
                    FAIL;
                }

                uchI2CValue |= 0x0F;

                i2cPacket.uchChipAddress = m_uchI2CExpanderAddress;
                i2cPacket.cbReadCount = 0;
                i2cPacket.cbWriteCount = 1;
                i2cPacket.puchReadBuffer = NULL;
                i2cPacket.puchWriteBuffer = &uchI2CValue;
                i2cPacket.usFlags = 0;
            
                pCScript->ExecuteI2CPacket( &i2cPacket);
            
                if (i2cPacket.uchI2CResult != I2C_STATUS_NOERROR)
                {
                    bResult = FALSE;
                    FAIL;
                }

                // information should be correct now
                if( GetI2CExpanderConfiguration( pCScript, &uchI2CValue))
                {
                    m_usTunerId = uchI2CValue & 0x0F;
                }

                m_VideoInStandardsSupported = SetVidStdBasedOnI2CExpander( uchI2CValue );   //Paul


            } END_ENSURE;

            if (!bResult)
                break;
            // For IO Expander address == 0x7c there might be more information in the BIOS Table sto do not return
            // or break at this point

        case 0xFF:      // AllInWonder PRO, configuration is in the BIOS
            ENSURE
            {
                CATIMultimediaTable CMultimediaInfo( pDeviceObject, &m_gpioProviderInterface, &bResult);
                USHORT              nOEMId, nOEMRevision, nATIProductType;
                BOOL                bATIProduct;
                    
                if( !bResult)
                    FAIL;

                // OEM Id information is included
                if( !CMultimediaInfo.IsATIProduct( &bATIProduct))
                {
                    bResult = FALSE;
                    FAIL;
                }

                m_uchDecoderAddress = 0x8A;
                m_uchTunerAddress = 0xC6;

                if( bATIProduct)
                {
                    if( !CMultimediaInfo.GetATIProductId( &nATIProductType))
                    {
                        bResult = FALSE;
                        FAIL;
                    }

                    if( CMultimediaInfo.GetTVTunerId( &m_usTunerId) &&
                        CMultimediaInfo.GetVideoDecoderId( &m_usDecoderId))
                    {
                        switch( nATIProductType)
                        {
                            case ATI_PRODUCT_TYPE_AIW_PRO_NODVD:
                            case ATI_PRODUCT_TYPE_AIW_PRO_DVD:
                                m_usDecoderConfiguration    = ATI_VIDEODECODER_CONFIG_2;
                                m_uiAudioConfiguration      = ATI_AUDIO_CONFIG_2;
                                m_usTunerPowerConfiguration = ATI_TUNER_POWER_CONFIG_1;

                                m_uchAudioAddress = 0xB4;

                                break;

                            case ATI_PRODUCT_TYPE_AIW_PLUS:
                                m_uiAudioConfiguration      = ATI_AUDIO_CONFIG_6;
                                m_usDecoderConfiguration    = ATI_VIDEODECODER_CONFIG_2;

                                m_uchAudioAddress = 0xB6;
                                break;

                            case ATI_PRODUCT_TYPE_AIW_PRO_R128_KITCHENER:
                                m_uiAudioConfiguration      = ATI_AUDIO_CONFIG_7;
                                m_usDecoderConfiguration    = ATI_VIDEODECODER_CONFIG_2;

                                m_uchAudioAddress = 0xB4;
                                break;

                            case ATI_PRODUCT_TYPE_AIW_PRO_R128_TORONTO:
                                m_uiAudioConfiguration      = ATI_AUDIO_CONFIG_8;
                                m_usDecoderConfiguration    = ATI_VIDEODECODER_CONFIG_UNDEFINED;

                                m_uchAudioAddress = 0x80;
                                break;

                            default:
                                bResult = FALSE;
                                break;
                        }
                    }
                    else
                        bResult = FALSE;
                }
                else
                {
                    // non ATI Product
                    if( !CMultimediaInfo.GetOEMId( &nOEMId)             ||
                        !CMultimediaInfo.GetOEMRevisionId( &nOEMRevision))
                    {
                        bResult = FALSE;
                        FAIL;
                    }

                    m_uchDecoderAddress = 0x8A;
                    m_uchTunerAddress = 0xC6;
                    
                    switch( nOEMId)
                    {
                        case OEM_ID_INTEL:
                            switch( nOEMRevision)
                            {
                                case INTEL_ANCHORAGE:
                                    if( CMultimediaInfo.GetVideoDecoderId( &m_usDecoderId) &&
                                        CMultimediaInfo.GetTVTunerId( &m_usTunerId))
                                    {
                                        m_uiAudioConfiguration  = ATI_AUDIO_CONFIG_1;
                                        switch( m_usDecoderId)
                                        {
                                            case VIDEODECODER_TYPE_BT829:
                                                m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_3;
                                                break;

                                            case VIDEODECODER_TYPE_BT829A:
                                                m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_2;
                                                break;

                                            default:
                                                bResult = FALSE;
                                                break;
                                        }
                                    }
                                    else
                                        bResult = FALSE;
                                    break;

                                default:
                                    bResult = FALSE;
                                    break;
                            }
                            break;

                        case OEM_ID_APRICOT:
                            switch( nOEMRevision)
                            {
                                case REVISION1:
                                case REVISION2:
                                    if( CMultimediaInfo.GetTVTunerId( &m_usTunerId))
                                    {
                                        switch( m_usDecoderId)
                                        {
                                            case VIDEODECODER_TYPE_BT829:
                                                m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_4;
                                                break;

                                            case VIDEODECODER_TYPE_BT829A:
                                                m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_2;
                                                break;
                                        }
                                    }
                                    else
                                        bResult = FALSE;
                                    break;

                                default:
                                    bResult = FALSE;
                                    break;
                            }
                            break;

                        case OEM_ID_FUJITSU:
                            m_uchDecoderAddress = 0x88;
                            switch( nOEMRevision)
                            {
                                case REVISION1:
                                    if( CMultimediaInfo.GetVideoDecoderId( &m_usDecoderId))
                                    {
                                        switch( m_usDecoderId)
                                        {
                                            case VIDEODECODER_TYPE_BT829A:
                                                m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_2;
                                                break;

                                            default:
                                                bResult = FALSE;
                                                break;
                                        }
                                    }
                                    else
                                        bResult = FALSE;
                                    break;

                                default:
                                    bResult = FALSE;
                                    break;
                            }
                            break;

                        case OEM_ID_COMPAQ:
                            switch( nOEMRevision)
                            {
                                case REVISION1:
                                    if( CMultimediaInfo.GetVideoDecoderId( &m_usDecoderId))
                                    {
                                        switch( m_usDecoderId)
                                        {
                                            case VIDEODECODER_TYPE_BT829:
                                                m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_3;
                                                break;

                                            case VIDEODECODER_TYPE_BT829A:
                                                m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_2;
                                                break;

                                            default:
                                                bResult = FALSE;
                                                break;
                                        }
                                    }
                                    else
                                        bResult = FALSE;
                                    break;

                                default:
                                    bResult = FALSE;
                                    break;
                            }
                            break;

                        case OEM_ID_BCM:
                        case OEM_ID_SAMSUNG:
                            switch( nOEMRevision)
                            {
                                case REVISION0:
                                    if( CMultimediaInfo.GetVideoDecoderId( &m_usDecoderId))
                                    {
                                        switch( m_usDecoderId)
                                        {
                                            case VIDEODECODER_TYPE_BT829A:
                                                m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_2;
                                                break;

                                            default:
                                                bResult = FALSE;
                                        }
                                    }
                                    else
                                        bResult = FALSE;
                                    break;

                                default:
                                    bResult = FALSE;
                                    break;
                            }
                            break;

                        case OEM_ID_SAMREX:
                            switch( nOEMRevision)
                            {
                                case REVISION0:
                                    if( CMultimediaInfo.GetVideoDecoderId( &m_usDecoderId))
                                    {
                                        switch( m_usDecoderId)
                                        {
                                            case VIDEODECODER_TYPE_BT829A:
                                                m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_2;
                                                break;

                                            default:
                                                bResult = FALSE;
                                                break;
                                        }
                                    }
                                    else
                                        bResult = FALSE;
                                    break;

                                default:
                                    bResult = FALSE;
                                    break;
                            }
                            break;

                        case OEM_ID_NEC:
                            switch( nOEMRevision)
                            {
                                case REVISION0:
                                case REVISION1:
                                    if( CMultimediaInfo.GetVideoDecoderId( &m_usDecoderId))
                                    {
                                        switch( m_usDecoderId)
                                        {
                                            case VIDEODECODER_TYPE_BT829A:
                                                m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_2;
                                                break;

                                            default:
                                                bResult = FALSE;
                                                break;
                                        }
                                    }
                                    else
                                        bResult = FALSE;
                                    break;

                                default:
                                    bResult = FALSE;
                                    break;
                            }
                            break;

                        default:
                                                        if( CMultimediaInfo.GetVideoDecoderId( &m_usDecoderId))
                                                        {
                                                            if( m_usDecoderId == VIDEODECODER_TYPE_RTHEATER)
                                                            {
                                                                // default the configuration to Toronto board
                                                                m_uiAudioConfiguration   = ATI_AUDIO_CONFIG_8;
                                                                m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_UNDEFINED;

                                m_uchAudioAddress = 0x80;
                                                            }
                                                            else
                                                            {
                                                                // default the configuration to Kitchener board
                                                                m_uiAudioConfiguration   = ATI_AUDIO_CONFIG_7;
                                                                m_usDecoderConfiguration = ATI_VIDEODECODER_CONFIG_2;

                                m_uchAudioAddress = 0xB4;
                                                            }

                                                            bResult = TRUE;
                                                            
                                                        }
                                                        else
                                                            bResult = FALSE;

                            break;
                    }
                }

                m_VideoInStandardsSupported = SetVidStdBasedOnMMTable( &CMultimediaInfo );  //Paul

            } END_ENSURE;

            break;
    }
    
    OutputDebugInfo(( "CATIHwConfig:FindHardwareConfiguration() found:\n"));
    OutputDebugInfo(( "Tuner:   Id = %d, I2CAddress = 0x%x\n",
        m_usTunerId, m_uchTunerAddress));
    OutputDebugInfo(( "Decoder: Id = %d, I2CAddress = 0x%x, Configuration = %d\n",
        m_usDecoderId, m_uchDecoderAddress, m_usDecoderConfiguration));
    OutputDebugInfo(( "Audio:           I2CAddress = 0x%x, Configuration = %d\n",
        m_uchAudioAddress, m_uiAudioConfiguration));

    return( bResult);
}


/*^^*
 *      GetTunerConfiguration()
 * Purpose  : Gets tuner Id and i2C address
 * Inputs   :   PUINT  puiTunerId       : pointer to return tuner Id
 *              PUCHAR puchTunerAddress : pointer to return tuner I2C address
 *
 * Outputs  : BOOL : returns TRUE
 *              also sets the requested values into the input pointers
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::GetTunerConfiguration( PUINT puiTunerId, PUCHAR puchTunerAddress)
{

    if(( puiTunerId != NULL) && ( puchTunerAddress != NULL))
    {
        * puiTunerId = ( UINT)m_usTunerId;
        * puchTunerAddress = m_uchTunerAddress;

        return( TRUE);
    }
    else
        return( FALSE);
}



/*^^*
 *      GetDecoderConfiguration()
 * Purpose  : Gets decoder Id and i2C address
 *
 * Inputs   :   puiDecoderId        : pointer to return Decoder Id
 *
 * Outputs  : BOOL : returns TRUE
 *              also sets the requested values into the input pointer
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::GetDecoderConfiguration( PUINT puiDecoderId, PUCHAR puchDecoderAddress)
{

    if(( puiDecoderId != NULL) && ( puchDecoderAddress != NULL))
    {
        * puiDecoderId = ( UINT)m_usDecoderId;
        * puchDecoderAddress = m_uchDecoderAddress;

        return( TRUE);
    }
    else
        return( FALSE);
}



/*^^*
 *      GetAudioConfiguration()
 * Purpose  : Gets Audio solution Id and i2C address
 *
 * Inputs   : PUINT puiAudioConfiguration   : pointer to return Audio configuration Id
 *            PUCHAR puchAudioAddress       : pointer to return audio hardware
 *                                              I2C address
 *
 * Outputs  : BOOL : returns TRUE
 *              also sets the requested values into the input pointer
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::GetAudioConfiguration( PUINT puiAudioConfiguration, PUCHAR puchAudioAddress)
{

    if(( puiAudioConfiguration != NULL) && ( puchAudioAddress != NULL))
    {
        * puiAudioConfiguration = ( UINT)m_uiAudioConfiguration;
        * puchAudioAddress = m_uchAudioAddress;

        return( TRUE);
    }
    else
        return( FALSE);
}



/*^^*
 *      InitializeAudioConfiguration()
 * Purpose  : Initializes Audio Chip with default / power up values. This function will
 *              be called at Low priority with i2CProvider locked
 *
 * Inputs   :   CI2CScript * pCScript       : pointer to the I2CScript object
 *              UINT uiAudioConfigurationId : detected Audio configuration
 *              UCHAR uchAudioChipAddress   : detected Audio chip I2C address
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::InitializeAudioConfiguration( CI2CScript * pCScript, UINT uiAudioConfigurationId, UCHAR uchAudioChipAddress)
{
    I2CPacket i2cPacket;
    UCHAR uchWrite16Value[5];
#ifdef  I2S_CAPTURE
    UCHAR uchRead16Value[5];
#endif // I2S_CAPTURE
    BOOL        bResult;


    switch( uiAudioConfigurationId)
    {
        case ATI_AUDIO_CONFIG_2:
        case ATI_AUDIO_CONFIG_7:
            // TDA9850 has to be initialized with the values from I2C EEPROM, if
            // those answers the CheckSum. If not, take hardcoded default values
            {
                UINT    nIndex, nNumberOfRegs;
                PUCHAR  puchInitializationBuffer = NULL;
                UCHAR   uchWriteBuffer[2];
                
                bResult = FALSE;

                nNumberOfRegs = AUDIO_TDA9850_Reg_Align3 - AUDIO_TDA9850_Reg_Control1 + 1;

                puchInitializationBuffer = ( PUCHAR) \
                    ::ExAllocatePool( NonPagedPool, nNumberOfRegs * sizeof( PUCHAR));

                if( puchInitializationBuffer == NULL)
                    return( bResult);

                // fill in the Initialization buffer with the defaults values
                puchInitializationBuffer[0] = AUDIO_TDA9850_Control1_DefaultValue;
                puchInitializationBuffer[1] = AUDIO_TDA9850_Control2_DefaultValue;
                puchInitializationBuffer[2] = AUDIO_TDA9850_Control3_DefaultValue;
                puchInitializationBuffer[3] = AUDIO_TDA9850_Control4_DefaultValue;
                puchInitializationBuffer[4] = AUDIO_TDA9850_Align1_DefaultValue;
                puchInitializationBuffer[5] = AUDIO_TDA9850_Align2_DefaultValue;
                puchInitializationBuffer[6] = AUDIO_TDA9850_Align3_DefaultValue;

                // we have to see if anything in I2C EEPROM is waiting for us to
                // overwrite the default values
                if( ValidateConfigurationE2PROM( pCScript))
                {
                    // The configuration E2PROM kept its integrity. Let's read the
                    // initialization values from the device
                    ReadConfigurationE2PROM( pCScript, 3, &puchInitializationBuffer[4]);
                    ReadConfigurationE2PROM( pCScript, 4, &puchInitializationBuffer[5]);
                }

                // write the power-up defaults values into the chip
                i2cPacket.uchChipAddress = uchAudioChipAddress;
                i2cPacket.cbReadCount = 0;
                i2cPacket.cbWriteCount = 2;
                i2cPacket.puchReadBuffer = NULL;
                i2cPacket.puchWriteBuffer = uchWriteBuffer;
                i2cPacket.usFlags = I2COPERATION_WRITE;

                for( nIndex = 0; nIndex < nNumberOfRegs; nIndex ++)
                {
                    uchWriteBuffer[0] = AUDIO_TDA9850_Reg_Control1 + nIndex;
                    uchWriteBuffer[1] = puchInitializationBuffer[nIndex];
                    if( !( bResult = pCScript->ExecuteI2CPacket( &i2cPacket)))
                        break;
                }

                if( puchInitializationBuffer != NULL)
                    ::ExFreePool( puchInitializationBuffer);

                return( bResult);
            }
            break;

        case ATI_AUDIO_CONFIG_4:
                // TDA8425 volume control should be initialized
                return( SetDefaultVolumeControl( pCScript));
            break;

        case ATI_AUDIO_CONFIG_6:
            {
                UCHAR   uchWriteBuffer;

                // write the power-up defaults values into the chip
                i2cPacket.uchChipAddress = uchAudioChipAddress;
                i2cPacket.cbReadCount = 0;
                i2cPacket.cbWriteCount = 1;
                i2cPacket.puchReadBuffer = NULL;
                i2cPacket.puchWriteBuffer = &uchWriteBuffer;
                i2cPacket.usFlags = I2COPERATION_WRITE;
                uchWriteBuffer = AUDIO_TDA9851_DefaultValue;

                return( pCScript->ExecuteI2CPacket( &i2cPacket));
            }
            break;

        case ATI_AUDIO_CONFIG_8:
            //Reset MSP3430
            
                    i2cPacket.uchChipAddress = m_uchAudioAddress;
                    i2cPacket.cbReadCount = 0;
                    i2cPacket.usFlags = I2COPERATION_WRITE;
                    i2cPacket.puchWriteBuffer = uchWrite16Value;


                    //Write 0x80 - 00 to Subaddr 0x00
                    i2cPacket.cbWriteCount = 3;
                    uchWrite16Value[0] = 0x00;
                    uchWrite16Value[1] = 0x80;
                    uchWrite16Value[2] = 0x00;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);

                    //Write 0x00 - 00 to Subaddr 0x00
                    i2cPacket.cbWriteCount = 3;
                    uchWrite16Value[0] = 0x00;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x00;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);

                    //SubAddr 0x12 Reg 0x13 Val 0x3f60
                    i2cPacket.cbWriteCount = 5;
                    uchWrite16Value[0] = 0x12;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x13;
                    uchWrite16Value[3] = 0x3f;
                    uchWrite16Value[4] = 0x60;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);

                    //SubAddr 0x12 Reg 0x00 Val 0x0000
                    i2cPacket.cbWriteCount = 5;
                    uchWrite16Value[0] = 0x12;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x00;
                    uchWrite16Value[3] = 0x00;
                    uchWrite16Value[4] = 0x00;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);
#ifdef  I2S_CAPTURE
#pragma message ("\n!!! PAY ATTENTION: Driver has been build with ITT CHIP I2S CAPTURE CONFIGURED !!!\n")


                    i2cPacket.uchChipAddress = m_uchAudioAddress;
                    i2cPacket.usFlags = I2COPERATION_WRITE;
                    i2cPacket.puchWriteBuffer = uchWrite16Value;
                    i2cPacket.puchReadBuffer = uchRead16Value;

                    //Setup I2S Source Select and Output Channel Matrix

                    //SubAddr 0x12 Reg 0x0b Val 0x0320
                    i2cPacket.cbWriteCount = 5;
                    i2cPacket.cbReadCount = 0;
                    uchWrite16Value[0] = 0x12;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x0b;
                    uchWrite16Value[3] = 0x03;
                    uchWrite16Value[4] = 0x20;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);



                    //Setup MODUS 

                    i2cPacket.cbWriteCount = 5;
                    i2cPacket.cbReadCount = 0;
                    uchWrite16Value[0] = 0x10;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x30;
                    uchWrite16Value[3] = 0x20;
                    uchWrite16Value[4] = 0xe3;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);

#endif // I2S_CAPTURE

            break;

        default:
            break;
    }

    return( TRUE);
}



/*^^*
 *      GetTVAudioSignalProperties()
 * Purpose  : Gets Audio signal properties readable from ATI dependand hardware,
 *              like I2C expander. This call is always synchronous.
 *
 * Inputs   :   CI2CScript * pCScript   : pointer to the I2CScript object
 *              PBOOL pbStereo          : pointer to the Stereo Indicator
 *              PBOOL pbSAP             : pointer to the SAP Indicator
 *
 * Outputs  : BOOL, returns TRUE, if successful
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::GetTVAudioSignalProperties( CI2CScript * pCScript, PBOOL pbStereo, PBOOL pbSAP)
{
    I2CPacket   i2cPacket;
    UCHAR       uchReadValue, uchWriteValue;
    BOOL        bResult;

    switch( m_uiAudioConfiguration)
    {
        case ATI_AUDIO_CONFIG_1:
        case ATI_AUDIO_CONFIG_5:
            // Stereo property is read back from I2C expander
            i2cPacket.uchChipAddress = m_uchI2CExpanderAddress;
            i2cPacket.cbReadCount = 1;
            i2cPacket.cbWriteCount = 1;
            i2cPacket.puchReadBuffer = &uchReadValue;
            i2cPacket.puchWriteBuffer = &uchWriteValue;
            i2cPacket.usFlags = I2COPERATION_READWRITE;
            i2cPacket.uchORValue = 0x40;
            i2cPacket.uchANDValue = 0xFF;

            bResult = FALSE;

            ENSURE
            {
                if( !pCScript->LockI2CProviderEx())
                    FAIL;

                pCScript->ExecuteI2CPacket( &i2cPacket);
                if( !( bResult = ( i2cPacket.uchI2CResult == I2C_STATUS_NOERROR)))
                    FAIL;

                i2cPacket.puchWriteBuffer = NULL;
                i2cPacket.usFlags = I2COPERATION_READ;

                pCScript->ExecuteI2CPacket( &i2cPacket);
                if( !( bResult = ( i2cPacket.uchI2CResult == I2C_STATUS_NOERROR)))
                    FAIL;

                * pbStereo = uchReadValue & 0x40;

                bResult = TRUE;

            } END_ENSURE;

            pCScript->ReleaseI2CProvider();

            break;

        default:
            bResult = FALSE;
            break;
    }

    if( bResult)
        // no case, where SAP property is read back from ATI's hardware
        * pbSAP = FALSE;

    return( bResult);
}



/*^^*
 *      GetDecoderOutputEnableLevel()
 * Purpose  : Retrieves ATI dependent hardware configuration property of the logical level
 *              should be applied on OUTEN field of Bt829x decoder in order to enable
 *              output stream
 *
 * Inputs   : none
 *
 * Outputs  : UINT,
 *              UINT( -1) value is returned if an error occures
 * Author   : IKLEBANOV
 *^^*/
UINT CATIHwConfiguration::GetDecoderOutputEnableLevel( void)
{
    UINT uiEnableLevel;

    switch( m_usDecoderConfiguration)
    {
        case ATI_VIDEODECODER_CONFIG_1:
        case ATI_VIDEODECODER_CONFIG_3:
        case ATI_VIDEODECODER_CONFIG_4:
            uiEnableLevel = 0;
            break;

        case ATI_VIDEODECODER_CONFIG_2:
            uiEnableLevel = 1;
            break;

        default:
            uiEnableLevel = UINT( -1);
            break;
    }

    return( uiEnableLevel);
}



/*^^*
 *      EnableDecoderI2CAccess()
 * Purpose  : Enables/disables I2C access to the decoder chip
 *
 * Inputs   : CI2CScript * pCScript : pointer to the I2CScript object
 *            BOOL bEnable          : defines what to do - enable/disable the decoder's outputs
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
void CATIHwConfiguration::EnableDecoderI2CAccess( CI2CScript * pCScript, BOOL bEnable)
{
    UCHAR       uchORMask   = 0;
    UCHAR       uchANDMask  = 0xFF;
    UCHAR       uchReadValue, uchWriteValue;
    I2CPacket   i2cPacket;

    switch( m_usDecoderConfiguration)
    {
        case ATI_VIDEODECODER_CONFIG_1:     // Add-On TV Tuner board - ATI TV requires certain actions to be taken
            i2cPacket.uchChipAddress = m_uchI2CExpanderAddress;
            i2cPacket.cbReadCount = 1;
            i2cPacket.cbWriteCount = 1;
            if( bEnable)
                uchANDMask &= 0x7F;
            else
                uchORMask |= 0x80;

            i2cPacket.puchReadBuffer = &uchReadValue;
            i2cPacket.puchWriteBuffer = &uchWriteValue;
            i2cPacket.usFlags = I2COPERATION_READWRITE;
            i2cPacket.uchORValue = uchORMask;
            i2cPacket.uchANDValue = uchANDMask;

            pCScript->PerformI2CPacketOperation( &i2cPacket);

            break;

#ifdef _X86_
        case ATI_VIDEODECODER_CONFIG_3:
            _outp( 0x7D, ( _inp( 0x7D) | 0x80));
            if( bEnable)
                _outp( 0x7C, ( _inp( 0x7C) & 0x7F));
            else
                _outp( 0x7C, ( _inp( 0x7C) | 0x80));
            return;

        case ATI_VIDEODECODER_CONFIG_4:
            if( bEnable)
                _outp( 0x78, ( _inp( 0x78) & 0xF7));
            else
                _outp( 0x78, ( _inp( 0x78) | 0x08));
            return;
#endif

        default:
            break;
    }
}


/*^^*
 *      GetI2CExpanderConfiguration()
 * Purpose  : Gets board configuration via I2C expander
 *              Reads the configuration registers back
 * Inputs   :   CI2CScript * pCScript   : pointer to CI2CScript object
 *              PUCHAR puchI2CValue     : pointer to read the I2C value into    
 *
 * Outputs  : BOOL : returns TRUE
 *              also sets the requested values into the input pointers
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::GetI2CExpanderConfiguration( CI2CScript * pCScript, PUCHAR puchI2CValue)
{
    I2CPacket   i2cPacket;

    if( puchI2CValue == NULL)
        return( FALSE);

    i2cPacket.uchChipAddress = m_uchI2CExpanderAddress;
    i2cPacket.cbReadCount = 1;
    i2cPacket.cbWriteCount = 0;
    i2cPacket.puchReadBuffer = puchI2CValue;
    i2cPacket.puchWriteBuffer = NULL;
    i2cPacket.usFlags = 0;

    pCScript->ExecuteI2CPacket( &i2cPacket);

    return(( i2cPacket.uchI2CResult == I2C_STATUS_NOERROR) ? TRUE : FALSE);
}



/*^^*
 *      FindI2CExpanderAddress()
 * Purpose  : Determines I2C expander address.
 *
 * Inputs   :   CI2CScript * pCScript   : pointer to the I2CScript class object
 *
 * Outputs  : BOOL : returns TRUE, if no I2C access error;
 *              also sets m_uchI2CExpanderAddress class member. If any was not found, set it as 0xFF
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::FindI2CExpanderAddress( CI2CScript * pCScript)
{
    USHORT      nIndex;
    UCHAR       uchI2CValue;
    I2CPacket   i2cPacket;
    // table of the possible I2C expender addresses
    UCHAR       auchI2CExpenderAddress[] = { 0x70, 0x78, 0x7c, 0x76};

    // unknown I2C expender address
    m_uchI2CExpanderAddress = 0xFF;
    for( nIndex = 0; nIndex < sizeof( auchI2CExpenderAddress); nIndex ++)
    {
        i2cPacket.uchChipAddress = auchI2CExpenderAddress[nIndex];
        i2cPacket.cbReadCount = 1;
        i2cPacket.cbWriteCount = 0;
        i2cPacket.puchReadBuffer = &uchI2CValue;
        i2cPacket.puchWriteBuffer = NULL;
        i2cPacket.usFlags = 0;

        pCScript->ExecuteI2CPacket( &i2cPacket);
        if( i2cPacket.uchI2CResult == I2C_STATUS_NOERROR)
        {
            m_uchI2CExpanderAddress = auchI2CExpenderAddress[nIndex];
            break;
        }
    }

    OutputDebugInfo(( "CATIHwConfig:FindI2CExpanderAddress() exit address = %x\n", m_uchI2CExpanderAddress));

    return( TRUE);
}



/*^^*
 *      GetAudioProperties()
 * Purpose  : Gets numbers of Audio inputs and outputs
 * Inputs   :   PULONG pulNumberOfInputs    : pointer to return number of Audio inputs
 *              PULONG pulNumberOfOutputs   : pointer to return number of Audio outputs
 *
 * Outputs  : BOOL : returns TRUE
 *              also sets the requested values into the input pointers
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::GetAudioProperties( PULONG pulNumberOfInputs, PULONG pulNumberOfOutputs)
{

    if(( pulNumberOfInputs != NULL) && ( pulNumberOfOutputs != NULL))
    {
        // Hardcoded for AIW with no FM support - FM stuff has not been defined by Microsoft yet 
        * pulNumberOfInputs = 2;
        * pulNumberOfOutputs = 1;

        return( TRUE);
    }
    else
        return( FALSE);
}



/*^^*
 *      CanConnectAudioSource()
 * Purpose  : Determines possibility to connect the specified Audio source to the audio output.
 *
 * Inputs   : int nAudioSource  : the audio source the function is asked about
 *
 * Outputs  : BOOL : returns TRUE, the connection is possible;
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::CanConnectAudioSource( int nAudioSource)
{
    BOOL bResult;

    if( nAudioSource != AUDIOSOURCE_MUTE)
        bResult = nAudioSource < AUDIOSOURCE_LASTSUPPORTED;
    else
        switch( m_uiAudioConfiguration)
        {
            case ATI_AUDIO_CONFIG_1:
            case ATI_AUDIO_CONFIG_2:
            case ATI_AUDIO_CONFIG_4:
            case ATI_AUDIO_CONFIG_5:
            case ATI_AUDIO_CONFIG_6:
            case ATI_AUDIO_CONFIG_7:
            case ATI_AUDIO_CONFIG_8:
                bResult = TRUE;
                break;

            case ATI_AUDIO_CONFIG_3:
            default:
                bResult = FALSE;
                break;
        }

    return( bResult);
}


/*^^*
 *      SetDefaultVolumeControl()
 * Purpose  : Set the default volume level, if the hardware support volume control
 *
 * Inputs   :   CI2CScript * pCScript   : pointer to I2CScript class object
 *
 * Outputs  : BOOL : returns FALSE, if either unknown audio source or I2C access error;
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::SetDefaultVolumeControl( CI2CScript * pCScript)
{
    BOOL        bResult;
    I2CPacket   i2cPacket;
    UCHAR       uchWriteBuffer[3];

    switch( m_uiAudioConfiguration)
    {
        case ATI_AUDIO_CONFIG_4:

            ENSURE
            {
                i2cPacket.uchChipAddress = m_uchAudioAddress;
                i2cPacket.cbReadCount = 0;
                i2cPacket.cbWriteCount = 3;
                i2cPacket.puchReadBuffer = NULL;
                i2cPacket.puchWriteBuffer = uchWriteBuffer;
                i2cPacket.usFlags = I2COPERATION_WRITE;

                uchWriteBuffer[0] = 0x00;       // volume left + right
                uchWriteBuffer[1] = 0xFA;
                uchWriteBuffer[2] = 0xFA;

                bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);

            } END_ENSURE;

            break;

        default:
            bResult = TRUE;
            break;
    }

    return( bResult);
}



/*^^*
 *      ConnectAudioSource()
 * Purpose  : Connects the specified Audio input to the Audio output.
 *
 * Inputs   :   CI2CScript * pCScript   : pointer to I2CScript class object
 *              int nAudioSource        : the audio source to be connected to the audio output
 *
 * Outputs  : BOOL : returns FALSE, if either unknown audio source or I2C access error;
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::ConnectAudioSource( CI2CScript *  pCScript, 
                                              int           nAudioSource)
{
    UCHAR       uchORMask = 0;
    UCHAR       uchANDMask = 0xFF;
    UCHAR       uchReadValue, uchWriteValue[2];
    UCHAR       uchWrite16Value[5]; 
    I2CPacket   i2cPacket;
    BOOL        bI2CAccess, bResult;
    GPIOControl gpioAccessBlock;
    UCHAR       uchI2CAddr;
    USHORT      cbWRCount;
    USHORT      cbRDCount;
    USHORT      usI2CMode;

    switch( m_uiAudioConfiguration)
    {
        case ATI_AUDIO_CONFIG_1:
            bI2CAccess = TRUE;
            uchI2CAddr = m_uchI2CExpanderAddress;
            cbWRCount = 1;
            cbRDCount = 1;
            usI2CMode = I2COPERATION_READWRITE;

            uchANDMask &= 0xAF;
            switch( nAudioSource)
            {
                case AUDIOSOURCE_MUTE:
                    uchORMask |= 0x00;
                    break;
            
                case AUDIOSOURCE_TVAUDIO:
                    uchORMask |= 0x10;
                    break;
            
                case AUDIOSOURCE_LINEIN:
                    uchORMask |= 0x50;
                    break;
            
                case AUDIOSOURCE_FMAUDIO:
                    // no FM is supported

                default:
                    return( FALSE);
            }
            break;

        case ATI_AUDIO_CONFIG_2:
            bI2CAccess = FALSE;
            uchANDMask &= 0xFC;
            switch( nAudioSource)
            {
                case AUDIOSOURCE_MUTE:
                    uchORMask |= 0x02;
                    break;
            
                case AUDIOSOURCE_TVAUDIO:
                    uchORMask |= 0x01;
                    break;
            
                case AUDIOSOURCE_LINEIN:
                    uchORMask |= 0x00;
                    break;
            
                case AUDIOSOURCE_FMAUDIO:
                    uchORMask |= 0x03;

                default:
                    return( FALSE);
            }
            break;


        case ATI_AUDIO_CONFIG_3:
            bI2CAccess = TRUE;
            uchI2CAddr = m_uchI2CExpanderAddress;
            cbWRCount = 1;
            cbRDCount = 1;
            usI2CMode = I2COPERATION_READWRITE;

            uchANDMask &= 0xDF;
            switch( nAudioSource)
            {
                case AUDIOSOURCE_TVAUDIO:
                    uchORMask |= 0x00;
                    break;
            
                case AUDIOSOURCE_LINEIN:
                    uchORMask |= 0x40;
                    break;
            
                case AUDIOSOURCE_FMAUDIO:
                    // no FM is supported
                case AUDIOSOURCE_MUTE:
                    // no mute is supported
                default:
                    return( FALSE);
            }
            break;

        case ATI_AUDIO_CONFIG_4:
            bI2CAccess = TRUE;
            uchI2CAddr = m_uchAudioAddress;
            cbWRCount = 2;
            cbRDCount = 0;
            usI2CMode = I2COPERATION_WRITE;

            uchWriteValue[0] = 0x08;
            switch( nAudioSource)
            {
                case AUDIOSOURCE_MUTE:
                    uchWriteValue[1] = 0xF7;
                    break;

                case AUDIOSOURCE_TVAUDIO:
                    SetDefaultVolumeControl( pCScript);
                    uchWriteValue[1] = 0xD7;
                    break;
            
                case AUDIOSOURCE_LINEIN:
                    SetDefaultVolumeControl( pCScript);
                    uchWriteValue[1] = 0xCE;
                    break;
            
                case AUDIOSOURCE_FMAUDIO:
                    // no FM is supported
                default:
                    return( FALSE);
            }
            break;

        case ATI_AUDIO_CONFIG_5:
            bI2CAccess = TRUE;
            uchI2CAddr = m_uchI2CExpanderAddress;
            cbWRCount = 1;
            cbRDCount = 1;
            usI2CMode = I2COPERATION_READWRITE;

            uchANDMask &= 0xAF;
            switch( nAudioSource)
            {
                case AUDIOSOURCE_MUTE:
                    uchORMask |= 0x50;
                    break;
            
                case AUDIOSOURCE_TVAUDIO:
                    uchORMask |= 0x00;
                    break;
            
                case AUDIOSOURCE_LINEIN:
                    uchORMask |= 0x40;
                    break;
            
                case AUDIOSOURCE_FMAUDIO:
                    uchORMask |= 0x10;

                default:
                    return( FALSE);
            }
            break;

        case ATI_AUDIO_CONFIG_6:
        case ATI_AUDIO_CONFIG_7:
            bI2CAccess = TRUE;
            uchI2CAddr = m_uchDecoderAddress;
            cbWRCount = 2;
            cbRDCount = 1;
            usI2CMode = I2COPERATION_READWRITE;
            uchWriteValue[0] = 0x3F;

            uchANDMask &= 0xFC;
            switch( nAudioSource)
            {
                case AUDIOSOURCE_MUTE:
                    uchORMask |= 0x02;
                    break;
            
                case AUDIOSOURCE_TVAUDIO:
                    uchORMask |= 0x01;
                    break;
            
                case AUDIOSOURCE_LINEIN:
                    uchORMask |= 0x00;
                    break;
            
                case AUDIOSOURCE_FMAUDIO:
                    uchORMask |= 0x03;

                default:
                    return( FALSE);
            }
            break;

        case ATI_AUDIO_CONFIG_8:

            switch( nAudioSource)
            {

                case AUDIOSOURCE_MUTE:

                    i2cPacket.uchChipAddress = m_uchAudioAddress;
                    i2cPacket.cbReadCount = 0;
                    i2cPacket.cbWriteCount = 5;
                    i2cPacket.usFlags = I2COPERATION_WRITE;
                    i2cPacket.puchWriteBuffer = uchWrite16Value;


                    //SubAddr 0x12 Reg 0x13 Val 0x3f60
                    uchWrite16Value[0] = 0x12;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x13;
                    uchWrite16Value[3] = 0x3f;
                    uchWrite16Value[4] = 0x60;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);

                    //SubAddr 0x12 Reg 0xD Val 0x0000

                    uchWrite16Value[0] = 0x12;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x0d;
                    uchWrite16Value[3] = 0x00;
                    uchWrite16Value[4] = 0x00;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);

                    //SubAddr 0x12 Reg 0x8 Val 0x0220

                    uchWrite16Value[0] = 0x12;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x08;
                    uchWrite16Value[3] = 0x02;
                    uchWrite16Value[4] = 0x20;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);

                    //SubAddr 0x12 Reg 0x00 Val 0x0000

                    uchWrite16Value[0] = 0x12;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x00;
                    uchWrite16Value[3] = 0x00;
                    uchWrite16Value[4] = 0x00;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);


                    break;


                case AUDIOSOURCE_LINEIN:

                    i2cPacket.uchChipAddress = m_uchAudioAddress;
                    i2cPacket.cbReadCount = 0;
                    i2cPacket.cbWriteCount = 5;
                    i2cPacket.usFlags = I2COPERATION_WRITE;
                    i2cPacket.puchWriteBuffer = uchWrite16Value;


                    //SubAddr 0x10 Reg 0x30 Val 0x0000
                    uchWrite16Value[0] = 0x10;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x30;
                    uchWrite16Value[3] = 0x00;
#ifdef  I2S_CAPTURE
#pragma message ("\n!!! PAY ATTENTION: Driver has been build with ITT CHIP I2S CAPTURE CONFIGURED !!!\n")
                    uchWrite16Value[4] = 0xe0;
#else
                    uchWrite16Value[4] = 0x00;
#endif

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);


                    //SubAddr 0x10 Reg 0x20 Val 0x0000
                    uchWrite16Value[0] = 0x10;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x20;
                    uchWrite16Value[3] = 0x00;
                    uchWrite16Value[4] = 0x00;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);


                    //SubAddr 0x12 Reg 0xe Val 0x0000
                    uchWrite16Value[0] = 0x12;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x0e;
                    uchWrite16Value[3] = 0x00;
                    uchWrite16Value[4] = 0x00;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);


                    //SubAddr 0x12 Reg 0x13 Val 0x3c40
                    uchWrite16Value[0] = 0x12;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x13;
                    uchWrite16Value[3] = 0x3c;
                    uchWrite16Value[4] = 0x40;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);


                    //SubAddr 0x12 Reg 0x8 Val 0x3c40
                    uchWrite16Value[0] = 0x12;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x08;
                    uchWrite16Value[3] = 0x02;
                    uchWrite16Value[4] = 0x20;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);

                    //SubAddr 0x12 Reg 0xd Val 0x1900
                    uchWrite16Value[0] = 0x12;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x0d;
                    uchWrite16Value[3] = 0x19;
                    uchWrite16Value[4] = 0x00;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);

                    //SubAddr 0x12 Reg 0x00 Val 0x7300
                    uchWrite16Value[0] = 0x12;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x00;
                    uchWrite16Value[3] = 0x73;
                    uchWrite16Value[4] = 0x00;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);


                    break;

                case AUDIOSOURCE_TVAUDIO:
                    i2cPacket.uchChipAddress = m_uchAudioAddress;
                    i2cPacket.cbReadCount = 0;
                    i2cPacket.cbWriteCount = 5;
                    i2cPacket.usFlags = I2COPERATION_WRITE;
                    i2cPacket.puchWriteBuffer = uchWrite16Value;

                    //SubAddr 0x12 Reg 0x13 Val 0x3f60
                    uchWrite16Value[0] = 0x12;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x13;
                    uchWrite16Value[3] = 0x3f;
                    uchWrite16Value[4] = 0x60;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);


                    //SubAddr 0x12 Reg 0xD Val 0x0000
                    uchWrite16Value[0] = 0x12;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x0d;
                    uchWrite16Value[3] = 0x00;
                    uchWrite16Value[4] = 0x00;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);


                    //SubAddr 0x10 Reg 0x30 Val 0x2003
                    uchWrite16Value[0] = 0x10;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x30;
                    uchWrite16Value[3] = 0x20;
#ifdef  I2S_CAPTURE
#pragma message ("\n!!! PAY ATTENTION: Driver has been build with ITT CHIP I2S CAPTURE CONFIGURED !!!\n")
                    uchWrite16Value[4] = 0xe3;
#else
                    uchWrite16Value[4] = 0x03;
#endif

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);

                    //SubAddr 0x10 Reg 0x20 Val 0x0020

                    uchWrite16Value[0] = 0x10;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x20;
                    uchWrite16Value[3] = 0x00;
                    uchWrite16Value[4] = 0x20;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);


                    //SubAddr 0x12 Reg 0xE Val 0x2403
                    uchWrite16Value[0] = 0x12;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x0e;
                    uchWrite16Value[3] = 0x24;
                    uchWrite16Value[4] = 0x03;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);

                    //SubAddr 0x12 Reg 0x08 Val 0x0320
                    uchWrite16Value[0] = 0x12;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x08;
                    uchWrite16Value[3] = 0x03;
                    uchWrite16Value[4] = 0x20;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);

                    //SubAddr 0x12 Reg 0x00 Val 0x7300

                    uchWrite16Value[0] = 0x12;
                    uchWrite16Value[1] = 0x00;
                    uchWrite16Value[2] = 0x00;
                    uchWrite16Value[3] = 0x73;
                    uchWrite16Value[4] = 0x00;

                    bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
                    if(bResult)
                    {
                        if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
                            return(FALSE);
                    }
                    else
                        return(FALSE);

                    break;

                default:
                    return(FALSE);
                
            }//switch
        
            return(TRUE);
            //break;

        default :
            return( FALSE);
    }

    if( bI2CAccess)
    {
        if( pCScript == NULL)
            return( FALSE);

        i2cPacket.uchChipAddress = uchI2CAddr;
        i2cPacket.cbReadCount = cbRDCount;
        i2cPacket.cbWriteCount = cbWRCount; 
        i2cPacket.puchReadBuffer = &uchReadValue;
        i2cPacket.puchWriteBuffer = uchWriteValue;
        i2cPacket.usFlags = usI2CMode;
        i2cPacket.uchORValue = uchORMask;
        i2cPacket.uchANDValue = uchANDMask;                 

        // synchronous execution
        bResult = pCScript->PerformI2CPacketOperation( &i2cPacket);
        OutputDebugInfo(( "CATIHwConfig: ConnectAudioSource( %d) = %d\n", nAudioSource, bResult));

        if( bResult)
            bResult = ( i2cPacket.uchI2CResult == I2CSCRIPT_NOERROR);

        return( bResult);
    }
    else    
    {
        // use GPIO interface to switch Audio source
        bResult = FALSE;

        ENSURE 
        {
            if(( m_gpioProviderInterface.gpioOpen == NULL) ||
                ( m_gpioProviderInterface.gpioAccess == NULL))
                FAIL;

            uchReadValue = AUDIO_MUX_PINS;          // use as a PinMask
            gpioAccessBlock.Pins = &uchReadValue;
            gpioAccessBlock.Flags = GPIO_FLAGS_BYTE;
            gpioAccessBlock.nBytes = 1;
            gpioAccessBlock.nBufferSize = 1;
            gpioAccessBlock.AsynchCompleteCallback = NULL;

            // lock GPIO provider
            if( !LockGPIOProviderEx( &gpioAccessBlock))
                FAIL;

            uchReadValue = AUDIO_MUX_PINS;          // use as a PinMask
            gpioAccessBlock.Command = GPIO_COMMAND_READ_BUFFER;
            gpioAccessBlock.Flags = GPIO_FLAGS_BYTE;
            gpioAccessBlock.dwCookie = m_dwGPIOAccessKey;
            gpioAccessBlock.nBytes = 1;
            gpioAccessBlock.nBufferSize = 1;
            gpioAccessBlock.Pins = &uchReadValue;
            gpioAccessBlock.Buffer = uchWriteValue;
            gpioAccessBlock.AsynchCompleteCallback = NULL;

            if( !AccessGPIOProvider( m_pdoDriver, &gpioAccessBlock))
                FAIL;

            uchWriteValue[0] &= uchANDMask;
            uchWriteValue[0] |= uchORMask;

            gpioAccessBlock.Command = GPIO_COMMAND_WRITE_BUFFER;

            if( !AccessGPIOProvider( m_pdoDriver, &gpioAccessBlock))
                FAIL;

            bResult = TRUE;

        }END_ENSURE;

        // nothing bad will happen if we try to release the provider even we
        // have not obtained it at the first place
        uchReadValue = AUDIO_MUX_PINS;          // use as a PinMask
        gpioAccessBlock.Pins = &uchReadValue;
        gpioAccessBlock.Flags = GPIO_FLAGS_BYTE;
        gpioAccessBlock.nBytes = 1;
        gpioAccessBlock.nBufferSize = 1;
        gpioAccessBlock.AsynchCompleteCallback = NULL;

        ReleaseGPIOProvider( &gpioAccessBlock);

        return( bResult);
    }
}



/*^^*
 *      GPIOIoSynchCompletionRoutine()
 * Purpose  : This routine is for use with synchronous IRP processing.
 *          All it does is signal an event, so the driver knows it and can continue.
 *
 * Inputs   :   PDEVICE_OBJECT DriverObject : Pointer to driver object created by system
 *              PIRP pIrp                   : Irp that just completed
 *              PVOID Event                 : Event we'll signal to say Irp is done
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
extern "C"
NTSTATUS GPIOIoSynchCompletionRoutine( IN PDEVICE_OBJECT pDeviceObject,
                                       IN PIRP pIrp,
                                       IN PVOID Event)
{

    KeSetEvent(( PKEVENT)Event, 0, FALSE);
    return( STATUS_MORE_PROCESSING_REQUIRED);
}



/*^^*
 *      InitializeAttachGPIOProvider()
 * Purpose  : determines the pointer to the parent GPIO Provider interface
 *              This function will be called at Low priority
 *
 * Inputs   :   GPIOINTERFACE * pGPIOInterface  : pointer to the Interface to be filled in
 *              PDEVICE_OBJECT pDeviceObject    : MiniDriver device object, which is a child of GPIO Master
 *
 * Outputs  : BOOL  - returns TRUE, if the interface was found
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::InitializeAttachGPIOProvider( GPIOINTERFACE * pGPIOInterface, PDEVICE_OBJECT pDeviceObject)
{
    BOOL bResult;

    bResult = LocateAttachGPIOProvider( pGPIOInterface, pDeviceObject, IRP_MJ_PNP);
    if(( pGPIOInterface->gpioOpen == NULL) || ( pGPIOInterface->gpioAccess == NULL))
    {
        OutputDebugError(( "CATIHwConfig(): GPIO interface has NULL pointers\n"));
        bResult = FALSE;
    }

    return( bResult);
}



/*^^*
 *      LocateAttachGPIOProvider()
 * Purpose  : gets the pointer to the parent GPIO Provider interface
 *              This function will be called at Low priority
 *
 * Inputs   :   GPIOINTERFACE * pGPIOInterface  : pointer to the Interface to be filled in
 *              PDEVICE_OBJECT pDeviceObject    : MiniDriver device object, which is a child of I2C Master
 *              int         nIrpMajorFunction   : IRP major function to query the GPIO Interface
 *
 * Outputs  : BOOL  - returns TRUE, if the interface was found
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::LocateAttachGPIOProvider( GPIOINTERFACE * pGPIOInterface, PDEVICE_OBJECT pDeviceObject, UCHAR nIrpMajorFunction)
{
    PIRP    pIrp;
    BOOL    bResult = FALSE;

    ENSURE
    {
        PIO_STACK_LOCATION  pNextStack;
        NTSTATUS            ntStatus;
        KEVENT              Event;
            
            
        pIrp = IoAllocateIrp( pDeviceObject->StackSize, FALSE);
        if( pIrp == NULL)
        {
            OutputDebugError(( "CATIHwConfig(): can not allocate IRP\n"));
            FAIL;
        }

        pNextStack = IoGetNextIrpStackLocation( pIrp);
        if( pNextStack == NULL)
        {
            OutputDebugError(( "CATIHwConfig(): can not allocate NextStack\n"));
            FAIL;
        }

        pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        pNextStack->MajorFunction = nIrpMajorFunction;
        pNextStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
        KeInitializeEvent( &Event, NotificationEvent, FALSE);

        IoSetCompletionRoutine( pIrp,
                                GPIOIoSynchCompletionRoutine,
                                &Event, TRUE, TRUE, TRUE);

        pNextStack->Parameters.QueryInterface.InterfaceType = ( struct _GUID *)&GUID_GPIO_INTERFACE;
        pNextStack->Parameters.QueryInterface.Size = sizeof( GPIOINTERFACE);
        pNextStack->Parameters.QueryInterface.Version = 1;
        pNextStack->Parameters.QueryInterface.Interface = ( PINTERFACE)pGPIOInterface;
        pNextStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

        ntStatus = IoCallDriver( pDeviceObject, pIrp);

        if( ntStatus == STATUS_PENDING)
            KeWaitForSingleObject(  &Event,
                                    Suspended, KernelMode, FALSE, NULL);
        if(( pGPIOInterface->gpioOpen == NULL) || ( pGPIOInterface->gpioAccess == NULL))
            FAIL;

        bResult = TRUE;

    } END_ENSURE;
 
    if( pIrp != NULL)
        IoFreeIrp( pIrp);

    return( bResult);
}



/*^^*
 *      LockGPIOProviderEx()
 * Purpose  : locks the GPIOProvider for exclusive use
 *
 * Inputs   : PGPIOControl pgpioAccessBlock : pointer to GPIO control structure
 *
 * Outputs  : BOOL : retunrs TRUE, if the GPIOProvider is locked
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::LockGPIOProviderEx( PGPIOControl pgpioAccessBlock)
{
    NTSTATUS        ntStatus;
    LARGE_INTEGER   liStartTime, liCurrentTime;

    KeQuerySystemTime( &liStartTime);

    ENSURE
    {
        if(( m_gpioProviderInterface.gpioOpen == NULL)      || 
            ( m_gpioProviderInterface.gpioAccess == NULL)   ||
            ( m_pdoDriver == NULL))
            FAIL;

        pgpioAccessBlock->Status = GPIO_STATUS_NOERROR;
        pgpioAccessBlock->Command = GPIO_COMMAND_OPEN_PINS;

        while( TRUE)
        {
            KeQuerySystemTime( &liCurrentTime);

            if(( liCurrentTime.QuadPart - liStartTime.QuadPart) >= GPIO_TIMELIMIT_OPENPROVIDER)
            {
                // time has expired for attempting to lock GPIO provider
                return (FALSE);
            }

            ntStatus = m_gpioProviderInterface.gpioOpen( m_pdoDriver, TRUE, pgpioAccessBlock);

            if(( NT_SUCCESS( ntStatus)) && ( pgpioAccessBlock->Status == GPIO_STATUS_NOERROR))
                break;
        }

        // the GPIO Provider has granted access - save dwCookie for further use
        m_dwGPIOAccessKey = pgpioAccessBlock->dwCookie;

        return( TRUE);

    } END_ENSURE;

    return( FALSE);
}



/*^^*
 *      ReleaseGPIOProvider()
 * Purpose  : releases the GPIOProvider for other clients' use
 *
 * Inputs   : PGPIOControl pgpioAccessBlock : pointer to a composed GPIO access block
 *
 * Outputs  : BOOL : retunrs TRUE, if the GPIOProvider is released
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::ReleaseGPIOProvider( PGPIOControl pgpioAccessBlock)
{
    NTSTATUS    ntStatus;

    ENSURE
    {
        if(( m_gpioProviderInterface.gpioOpen == NULL)      ||
            ( m_gpioProviderInterface.gpioAccess == NULL)   ||
            ( m_pdoDriver == NULL))
            FAIL;

        pgpioAccessBlock->Status = GPIO_STATUS_NOERROR;
        pgpioAccessBlock->Command = GPIO_COMMAND_CLOSE_PINS;
        pgpioAccessBlock->dwCookie = m_dwGPIOAccessKey;

        ntStatus = m_gpioProviderInterface.gpioOpen( m_pdoDriver, FALSE, pgpioAccessBlock);

        if( !NT_SUCCESS( ntStatus)) 
        {
            OutputDebugError(( "CATIHwConfig: ReleaseGPIOProvider() NTSTATUS = %x\n", ntStatus));
            FAIL;
        }

        if( pgpioAccessBlock->Status != GPIO_STATUS_NOERROR)
        {
            OutputDebugError(( "CATIHwConfig: ReleaseGPIOProvider() Status = %x\n", pgpioAccessBlock->Status));
            FAIL;
        }

        m_dwGPIOAccessKey = 0;
        return ( TRUE);

    } END_ENSURE;

    return( FALSE);
}



/*^^*
 *      AccessGPIOProvider()
 * Purpose  : provide synchronous type of access to GPIOProvider
 *
 * Inputs   :   PDEVICE_OBJECT pdoDriver    : pointer to the client's device object
 *              PGPIOControl pgpioAccessBlock   : pointer to a composed GPIO access block
 *
 * Outputs  : BOOL, TRUE if acsepted by the GPIO Provider
 *
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIHwConfiguration::AccessGPIOProvider( PDEVICE_OBJECT pdoClient, PGPIOControl pgpioAccessBlock)
{
    NTSTATUS    ntStatus;

    ENSURE 
    {

        if(( m_gpioProviderInterface.gpioOpen == NULL)      || 
            ( m_gpioProviderInterface.gpioAccess == NULL)   ||
            ( m_pdoDriver == NULL))
            FAIL;

        ntStatus = m_gpioProviderInterface.gpioAccess( pdoClient, pgpioAccessBlock);

        if( !NT_SUCCESS( ntStatus)) 
        {
            OutputDebugError(( "CATIHwConfig: AccessGPIOProvider() NTSTATUS = %x\n", ntStatus));
            FAIL;
        }

        if( pgpioAccessBlock->Status != GPIO_STATUS_NOERROR)
        {
            OutputDebugError(( "CATIHwConfig: AccessGPIOProvider() Status = %x\n", pgpioAccessBlock->Status));
            FAIL;
        }

        return TRUE;

    } END_ENSURE;

    return( FALSE);
}



/*^^*
 *      SetTunerPowerState
 * Purpose  : Sets Tuner power mode
 * Inputs   : CI2CScript * pCScript : pointer to the I2C Provider class
 *            BOOL bPowerState      : TRUE, if turne the power on
 *
 * Outputs  : BOOL, TRUE if successfull
 * Author   : TOM
 *^^*/
BOOL CATIHwConfiguration::SetTunerPowerState( CI2CScript *  pCScript,
                                              BOOL          bPowerState)
{
    UCHAR       uchORMask = 0x0;
    UCHAR       uchANDMask = 0xFF;
    UCHAR       uchPinsMask, uchValue;
    BOOL        bResult;
    GPIOControl gpioAccessBlock;

    switch( m_usTunerPowerConfiguration)
    {
        case ATI_TUNER_POWER_CONFIG_1:

            if( bPowerState)
                uchANDMask &= 0xF7;
            else
                uchORMask |= 0x08;
            break;

        default :
            return( FALSE);
    }

    // use GPIO interface to turn Tuner power ON / OFF
    bResult = FALSE;

    ENSURE 
    {
        if(( m_gpioProviderInterface.gpioOpen == NULL) ||
            ( m_gpioProviderInterface.gpioAccess == NULL))
            FAIL;

        uchPinsMask = TUNER_PM_PINS;                // use as a PinMask
        gpioAccessBlock.Pins = &uchPinsMask;
        gpioAccessBlock.Flags = GPIO_FLAGS_BYTE;
        gpioAccessBlock.nBytes = 1;
        gpioAccessBlock.nBufferSize = 1;
        gpioAccessBlock.AsynchCompleteCallback = NULL;

        // try to get GPIO Provider
        if( !LockGPIOProviderEx( &gpioAccessBlock))
            FAIL;

        uchPinsMask = TUNER_PM_PINS;                // use as a PinMask
        gpioAccessBlock.Command = GPIO_COMMAND_READ_BUFFER;
        gpioAccessBlock.Flags = GPIO_FLAGS_BYTE;
        gpioAccessBlock.dwCookie = m_dwGPIOAccessKey;
        gpioAccessBlock.nBytes = 1;
        gpioAccessBlock.nBufferSize = 1;
        gpioAccessBlock.Pins = &uchPinsMask;
        gpioAccessBlock.Buffer = &uchValue;
        gpioAccessBlock.AsynchCompleteCallback = NULL;

        if( !AccessGPIOProvider( m_pdoDriver, &gpioAccessBlock))
            FAIL;

        uchValue &= uchANDMask;
        uchValue |= uchORMask;

        gpioAccessBlock.Command = GPIO_COMMAND_WRITE_BUFFER;

        if( !AccessGPIOProvider( m_pdoDriver, &gpioAccessBlock))
            FAIL;

        bResult = TRUE;

    } END_ENSURE;

    // nothing bad will happen if we try to release the provider even we
    // have not obtained it at the first place
    uchValue = TUNER_PM_PINS;                       // use as a PinMask
    gpioAccessBlock.Pins = &uchValue;
    gpioAccessBlock.Flags = GPIO_FLAGS_BYTE;
    gpioAccessBlock.nBytes = 1;
    gpioAccessBlock.nBufferSize = 1;
    gpioAccessBlock.AsynchCompleteCallback = NULL;
    
    ReleaseGPIOProvider( &gpioAccessBlock);

    return( bResult);
}



/*^^*
 *      ValidateConfigurationE2PROM
 * Purpose  : Checks the integrity ( check-sum) of I2C driven configuration EEPROM
 * Inputs   : CI2CScript * pCScript : pointer to the I2C Provider class
 *
 * Outputs  : BOOL, TRUE if the information inside EEPROM is valid
 * Author   : TOM
 *^^*/
BOOL CATIHwConfiguration::ValidateConfigurationE2PROM( CI2CScript * pCScript)
{
    I2CPacket   i2cPacket;
    UCHAR       uchReadValue=0, uchWriteValue, uchCheckSum=0;
    UINT        nIndex;
    BOOL        bResult = ( BOOL)m_usE2PROMValidation;

    if( m_usE2PROMValidation == ( USHORT)-1)
    {
        // the validation has not been done yet.
        bResult = FALSE;

        ENSURE
        {
            // Let's always start from byte 0.
            i2cPacket.uchChipAddress = AIWPRO_CONFIGURATIONE2PROM_ADDRESS;
            i2cPacket.cbWriteCount = 1;
            i2cPacket.cbReadCount = 1;
            i2cPacket.puchReadBuffer = &uchCheckSum;
            uchWriteValue = 0;
            i2cPacket.puchWriteBuffer = &uchWriteValue;
            i2cPacket.usFlags = I2COPERATION_READ | I2COPERATION_RANDOMACCESS;

            if( !pCScript->ExecuteI2CPacket( &i2cPacket))
                FAIL;

            for( nIndex = 1; nIndex < AIWPRO_CONFIGURATIONE2PROM_LENGTH; nIndex ++)
            {
                // let's use auto-increment address mode
                i2cPacket.usFlags = I2COPERATION_READ;
                i2cPacket.cbWriteCount = 0;
                i2cPacket.puchWriteBuffer = NULL;
                i2cPacket.puchReadBuffer = &uchReadValue;

                if( !pCScript->ExecuteI2CPacket( &i2cPacket))
                    FAIL;

                uchCheckSum ^= uchReadValue;
            }

            if( nIndex != AIWPRO_CONFIGURATIONE2PROM_LENGTH)
                FAIL;

            bResult = ( uchCheckSum == 0);


        } END_ENSURE;

        m_usE2PROMValidation = ( USHORT)bResult;
    }

    return( bResult);
}



/*^^*
 *      ReadConfigurationE2PROM
 * Purpose  : Reads a single byte from I2C driver configuration EEPROM by offset
 * Inputs   : CI2CScript * pCScript : pointer to the I2C Provider class
 *            ULONG ulOffset        : byte offset within the EEPROM
 *            PUCHAR puchValue      : pointer to the buffer to read into
 *
 * Outputs  : BOOL, TRUE if I2C read operation succeeded
 * Author   : TOM
 *^^*/
BOOL CATIHwConfiguration::ReadConfigurationE2PROM( CI2CScript * pCScript, ULONG ulOffset, PUCHAR puchValue)
{
    I2CPacket   i2cPacket;
    UCHAR       uchReadValue=0, uchWriteValue;

    ENSURE
    {
        if( ulOffset >= AIWPRO_CONFIGURATIONE2PROM_LENGTH)
            FAIL;

        uchWriteValue = ( UCHAR)ulOffset;
        i2cPacket.uchChipAddress = AIWPRO_CONFIGURATIONE2PROM_ADDRESS;
        i2cPacket.cbWriteCount = 1;
        i2cPacket.cbReadCount = 1;
        i2cPacket.puchReadBuffer = &uchReadValue;
        i2cPacket.puchWriteBuffer = &uchWriteValue;
        i2cPacket.usFlags = I2COPERATION_READ | I2COPERATION_RANDOMACCESS;

        if( !pCScript->ExecuteI2CPacket( &i2cPacket))
            FAIL;

        * puchValue = uchReadValue;

        return( TRUE);

    } END_ENSURE;

    return( FALSE);
}


//Paul
ULONG CATIHwConfiguration::ReturnTunerVideoStandard( USHORT usTunerId )   //Paul:  For PAL support
{
    switch( usTunerId )
    {
    case 1:
        return KS_AnalogVideo_NTSC_M;
        break;
    case 2:
        return KS_AnalogVideo_NTSC_M_J;
        break;
    case 3:
        return KS_AnalogVideo_PAL_B | KS_AnalogVideo_PAL_G;
        break;
    case 4:
        return KS_AnalogVideo_PAL_I;
        break;
    case 5:
        return KS_AnalogVideo_PAL_B | KS_AnalogVideo_PAL_G | KS_AnalogVideo_SECAM_L | KS_AnalogVideo_SECAM_L1;
        break;
    case 6:
        return KS_AnalogVideo_NTSC_M;
        break;
    case 7:
        return KS_AnalogVideo_SECAM_D | KS_AnalogVideo_SECAM_K;
        break;
    case 8:
        return KS_AnalogVideo_NTSC_M;
        break;
    case 9:
        return KS_AnalogVideo_PAL_B | KS_AnalogVideo_PAL_G;
        break;
    case 10:
        return KS_AnalogVideo_PAL_I;
        break;
    case 11:
        return KS_AnalogVideo_PAL_B | KS_AnalogVideo_PAL_G | KS_AnalogVideo_SECAM_L | KS_AnalogVideo_SECAM_L1;
        break;
    case 12:
        return KS_AnalogVideo_NTSC_M;
        break;
    case 13:
        return KS_AnalogVideo_PAL_B | KS_AnalogVideo_PAL_D | KS_AnalogVideo_PAL_G | KS_AnalogVideo_PAL_I | KS_AnalogVideo_SECAM_D | KS_AnalogVideo_SECAM_K;
        break;
    case 14:
        return 0;
        break;
    case 15:
        return 0;
        break;
    case 16:
        return KS_AnalogVideo_NTSC_M;
        break;
    case 17:
        return KS_AnalogVideo_NTSC_M;
        break;
    case 18:
        return KS_AnalogVideo_NTSC_M;
        break;
    default:
        return 0;   // if we don't recognize the tuner, we say that no video standard is supported
    }
}

//Paul
// bit 5 indicates the number of crystals installed.  0 means we have 2 crystals,
// 1 means we only have 1, so the tuner determines the standard
ULONG CATIHwConfiguration::SetVidStdBasedOnI2CExpander( UCHAR ucI2CValue )
{
    if ( ucI2CValue & 0x20 )    // only 1 crystal
    {
        ULONG ulTunerStd = ReturnTunerVideoStandard( ucI2CValue & 0x0F );
        if ( ulTunerStd & ( KS_AnalogVideo_NTSC_Mask & ~KS_AnalogVideo_NTSC_433 | KS_AnalogVideo_PAL_60 ) ) // Then we should have NTSC-type crystal
        {
            return KS_AnalogVideo_NTSC_Mask & ~KS_AnalogVideo_NTSC_433 | KS_AnalogVideo_PAL_60 | KS_AnalogVideo_PAL_M | KS_AnalogVideo_PAL_N;
        }
        else
        {
            return KS_AnalogVideo_PAL_Mask & ~KS_AnalogVideo_PAL_60 & ~KS_AnalogVideo_PAL_M & ~KS_AnalogVideo_PAL_N | KS_AnalogVideo_SECAM_Mask | KS_AnalogVideo_NTSC_433;
        }
    }
    else
        return KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_Mask | KS_AnalogVideo_SECAM_Mask;  // we support all standards (is this testable?)
}

//Paul
// The Video In crystal type in MMTable will tell us whether we support NTSC, PAL/SECAM, or both
ULONG CATIHwConfiguration::SetVidStdBasedOnMMTable( CATIMultimediaTable * pCMultimediaInfo )
{
    if ( pCMultimediaInfo )
    {
        if ( pCMultimediaInfo->GetVideoInCrystalId( &m_CrystalIDInMMTable ) )
        {
            switch ( m_CrystalIDInMMTable )
            {
            // "NTSC and PAL Crystals Installed (for Bt8xx)"
            case 0:
                return KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_Mask;  // may need to add SECAM.  We will see
                break;
            // "NTSC Crystal Only (for Bt8xx)"
            case 1:
                return KS_AnalogVideo_NTSC_Mask & ~KS_AnalogVideo_NTSC_433 | KS_AnalogVideo_PAL_60 | KS_AnalogVideo_PAL_M | KS_AnalogVideo_PAL_N;   // standards that use "NTSC" clock
                break;
            // "PAL Crystal Only (for Bt8xx)"
            case 2:
                return KS_AnalogVideo_PAL_Mask & ~KS_AnalogVideo_PAL_60 & ~KS_AnalogVideo_PAL_M & ~KS_AnalogVideo_PAL_N | KS_AnalogVideo_SECAM_Mask | KS_AnalogVideo_NTSC_433; // standards that use "PAL" clock
                break;
            // "NTSC, PAL, SECAM (for Bt829)"
            case 3:
                return KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_Mask | KS_AnalogVideo_SECAM_Mask;
                break;
            }
        }
    }
    return 0;
            

}

//Paul:  Used by RT WDM to determine the VIN PLL
BOOL CATIHwConfiguration::GetMMTableCrystalID( PUCHAR pucCrystalID )
{   if ( ( m_uchI2CExpanderAddress==0xFF ) || ( !pucCrystalID ) )
    {
        return FALSE;
    }
    else
    {
        *pucCrystalID = m_CrystalIDInMMTable;
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\1394dcam\strmdata.h ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//===========================================================================

//
// External functions
//


#include "sonydcam.h"

//
// Local variables
//

CAMERA_ISOCH_INFO IsochInfoTable[] = {

        0,      SPEED_FLAGS_100,        0,          // Reserved <---+
        0,      SPEED_FLAGS_100,        0,          // 3.75 fps     |
        15,     SPEED_FLAGS_100,        57600,      // 7.5  fps     |
        30,     SPEED_FLAGS_100,        57600,      // 15   fps     +- Mode0
        60,     SPEED_FLAGS_100,        57600,      // 30   fps     |
        0,      SPEED_FLAGS_100,        0,          // 60   fps <---+
        0,      SPEED_FLAGS_100,        0,          // Reserved <---+
        20,     SPEED_FLAGS_100,        153600,     // 3.75 fps     |
        40,     SPEED_FLAGS_100,        153600,     // 7.5  fps     |
        80,     SPEED_FLAGS_100,        153600,     // 15   fps     +- Mode1
        160,    SPEED_FLAGS_100,        153600,     // 30   fps     |
        0,      SPEED_FLAGS_100,        0,          // 60   fps <---+
        0,      SPEED_FLAGS_100,        0,          // Reserved <---+
        60,     SPEED_FLAGS_100,        460800,     // 3.75 fps     |
        120,    SPEED_FLAGS_100,        460800,     // 7.5  fps     |
        240,    SPEED_FLAGS_100,        460800,     // 15   fps     +- Mode2
        480,    SPEED_FLAGS_200,        460800,     // 30   fps     |
        0,      SPEED_FLAGS_100,        0,          // 60   fps <---+
        0,      SPEED_FLAGS_100,        0,          // Reserved <---+
        80,     SPEED_FLAGS_100,        614400,     // 3.75 fps     |
        160,    SPEED_FLAGS_100,        614400,     // 7.5  fps     |
        320,    SPEED_FLAGS_200,        614400,     // 15   fps     +- Mode3
        640,    SPEED_FLAGS_400,        614400,     // 30   fps     |
        0,      SPEED_FLAGS_100,        0,          // 60   fps <---+
        0,      SPEED_FLAGS_100,        0,          // Reserved <---+
        120,    SPEED_FLAGS_100,        921600,     // 3.75 fps     |
        240,    SPEED_FLAGS_100,        921600,     // 7.5  fps     |
        480,    SPEED_FLAGS_200,        921600,     // 15   fps     +- Mode4
        960,    SPEED_FLAGS_400,        921600,     // 30   fps     |
        0,      SPEED_FLAGS_100,        0,          // 60   fps <---+
        0,      SPEED_FLAGS_100,        0,          // Reserved <---+
        40,     SPEED_FLAGS_100,        307200,     // 3.75 fps     |
        80,     SPEED_FLAGS_100,        307200,     // 7.5  fps     |
        160,    SPEED_FLAGS_100,        307200,     // 15   fps     +- Mode5
        320,    SPEED_FLAGS_200,        307200,     // 30   fps     |
        640,    SPEED_FLAGS_400,        307200,     // 60   fps <---+
        
};




// ------------------------------------------------------------------------
// Property set for all video capture streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoStreamConnectionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSALLOCATOR_FRAMING),            // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};

DEFINE_KSPROPERTY_TABLE(VideoStreamDroppedFramesProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_DROPPEDFRAMES_CURRENT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinProperty
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};



// ------------------------------------------------------------------------
// Array of all of the property sets supported by video streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(VideoStreamProperties)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(VideoStreamConnectionProperties),  // PropertiesCount
        VideoStreamConnectionProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_DROPPEDFRAMES,                // Set
        SIZEOF_ARRAY(VideoStreamDroppedFramesProperties),  // PropertiesCount
        VideoStreamDroppedFramesProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),

};

#define NUMBER_VIDEO_STREAM_PROPERTIES (SIZEOF_ARRAY(VideoStreamProperties))
    
#ifndef mmioFOURCC    
#define mmioFOURCC( ch0, ch1, ch2, ch3 ) 	 	\
 	( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |  \
 	( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif  

//
// FourCC of the YUV formats
// For information about FourCC, go to http://www.webartz.com/fourcc/indexyuv.htm
//
#define FOURCC_Y444 mmioFOURCC('Y', '4', '4', '4')  // TIYUV: 1394 conferencing camera 4:4:4 mode 0
#define FOURCC_UYVY mmioFOURCC('U', 'Y', 'V', 'Y')  // MSYUV: 1394 conferencing camera 4:4:4 mode 1 and 3
#define FOURCC_Y411 mmioFOURCC('Y', '4', '1', '1')  // TIYUV: 1394 conferencing camera 4:1:1 mode 2
#define FOURCC_Y800 mmioFOURCC('Y', '8', '0', '0')  // TIYUV: 1394 conferencing camera 4:1:1 mode 5




#ifdef SUPPORT_YUV444

#define DX 	        160
#define DY          120
#define DBITCOUNT    32

KS_DATARANGE_VIDEO DCAM_StreamMode_0 = 
{
    // KSDATARANGE
    {   
        sizeof (KS_DATARANGE_VIDEO),     // Flags
        0,
        57600,                          // SampleSize
        0,                               // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,  
        FOURCC_Y444, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71,
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO
    },

    TRUE,                   // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,                   // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                      // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, 
        KS_AnalogVideo_None, // AnalogVideoStandard
        DX,DY,   // InputSize, (the inherent size of the incoming signal
                 //             with every digitized pixel unique)
        DX,DY,   // MinCroppingSize, smallest rcSrc cropping rect allowed
        DX,DY,   // MaxCroppingSize, largest  rcSrc cropping rect allowed
        1,       // CropGranularityX, granularity of cropping size
        1,       // CropGranularityY
        1,       // CropAlignX, alignment of cropping rect 
        1,       // CropAlignY;
        DX, DY,  // MinOutputSize, smallest bitmap stream can produce
        DX, DY,  // MaxOutputSize, largest  bitmap stream can produce
        DX,      // OutputGranularityX, granularity of output bitmap size
        DY,      // OutputGranularityY;
        0,       // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,       // StretchTapsY
        0,       // ShrinkTapsX 
        0,       // ShrinkTapsY 
        // Allow 1% difference
        333000,  // MinFrameInterval (10,000,000 / 30.00FPS), 100nS units
        1333333, // MaxFrameInterval (10,000,000 /  7.50FPS), 100nS units
        4608000,  // (DX * DY * DBITCOUNT) * DFPS_MIN,    // MinBitsPerSecond (7.50 FPS);
        36864000, // (DX * DY * DBITCOUNT) * DFPS_MAX     // MaxBitsPerSecond (30.0 FPS);
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        13824000,                           // DWORD dwBitRate; 57600 * 30FPS * 8 bit/Byte
        0L,                                 // DWORD dwBitErrorRate;   
        333333,                             // REFERENCE_TIME  AvgTimePerFrame (30 FPS); 
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        DX,                                 // LONG  biWidth;
        DY,                                 // LONG  biHeight;
        1,                        // WORD  biPlanes;
        DBITCOUNT,                // WORD  biBitCount;
        FOURCC_Y444,              // DWORD biCompression;
        57600,                    // DWORD biSizeImage;
        0,                        // LONG  biXPelsPerMeter;
        0,                        // LONG  biYPelsPerMeter;
        0,                        // DWORD biClrUsed;
        0                         // DWORD biClrImportant;
    }
}; 

#endif

#undef DX            
#undef DY            
#undef DBITCOUNT 

#define DX 	        320
#define DY          240
#define DBITCOUNT    16

KS_DATARANGE_VIDEO DCAM_StreamMode_1 = 
{
    // KSDATARANGE
    {   
        sizeof (KS_DATARANGE_VIDEO),     // Flags
        0,
        153600,                          // SampleSize
        0,                               // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,  
        FOURCC_UYVY, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71,
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO
    },

    TRUE,                   // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,                   // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                      // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, 
        KS_AnalogVideo_None, // AnalogVideoStandard
        DX,DY,   // InputSize, (the inherent size of the incoming signal
                 //             with every digitized pixel unique)
        DX,DY,   // MinCroppingSize, smallest rcSrc cropping rect allowed
        DX,DY,   // MaxCroppingSize, largest  rcSrc cropping rect allowed
        1,       // CropGranularityX, granularity of cropping size
        1,       // CropGranularityY
        1,       // CropAlignX, alignment of cropping rect 
        1,       // CropAlignY;
        DX, DY,  // MinOutputSize, smallest bitmap stream can produce
        DX, DY,  // MaxOutputSize, largest  bitmap stream can produce
        DX,      // OutputGranularityX, granularity of output bitmap size
        DY,      // OutputGranularityY;
        0,       // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,       // StretchTapsY
        0,       // ShrinkTapsX 
        0,       // ShrinkTapsY 
        // Allow 1% difference
        333000,  // MinFrameInterval (10,000,000 / 30.00FPS), 100nS units
        2666666, // MaxFrameInterval (10,000,000 /  3.75FPS), 100nS units
        4608000, // (DX * DY * DBITCOUNT) * DFPS_MIN,    // MinBitsPerSecond (3.75 FPS);
        36864000, // (DX * DY * DBITCOUNT) * DFPS_MAX     // MaxBitsPerSecond (30.0 FPS);
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        18432000,                           // DWORD dwBitRate; 153600 * 15FPS * 8 bit/Byte
        0L,                                 // DWORD dwBitErrorRate;   
        666666,                             // REFERENCE_TIME  AvgTimePerFrame (15 FPS); 
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        DX,                                 // LONG  biWidth;
        DY,                                 // LONG  biHeight;
        1,                        // WORD  biPlanes;
        DBITCOUNT,                // WORD  biBitCount;
        FOURCC_UYVY,              // DWORD biCompression;
        153600,                   // DWORD biSizeImage;
        0,                        // LONG  biXPelsPerMeter;
        0,                        // LONG  biYPelsPerMeter;
        0,                        // DWORD biClrUsed;
        0                         // DWORD biClrImportant;
    }
}; 


#ifdef SUPPORT_YUV411  

#undef DX            
#undef DY            
#undef DBITCOUNT    

//
// This has format of UYYV YYUY YVYY (8Y+2U+2V = 12 bytes = 8 pixels)
//                   
#define DX           640
#define DY           480
#define DBITCOUNT     12

// To support Mode 2, 640x480, FourCC=Y411
KS_DATARANGE_VIDEO DCAM_StreamMode_2 = 
{
    // KSDATARANGE
    {   
        sizeof (KS_DATARANGE_VIDEO),
        0,                           // Flags
        460800,   // SampleSize
        0,                           // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,
        FOURCC_Y411, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71,
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO
    },

    TRUE,                   // BOOL, bFixedSizeSamples (all samples same size?)
    TRUE,                   // BOOL, bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                      // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, 
        KS_AnalogVideo_None, // AnalogVideoStandard
        DX,DY,               // InputSize, (the inherent size of the incoming signal
                             //             with every digitized pixel unique)
        DX,DY,   // MinCroppingSize, smallest rcSrc cropping rect allowed
        DX,DY,   // MaxCroppingSize, largest  rcSrc cropping rect allowed
        1,       // CropGranularityX, granularity of cropping size
        1,       // CropGranularityY
        1,       // CropAlignX, alignment of cropping rect 
        1,       // CropAlignY;
        DX, DY,  // MinOutputSize, smallest bitmap stream can produce
        DX, DY,  // MaxOutputSize, largest  bitmap stream can produce
        DX,      // OutputGranularityX, granularity of output bitmap size
        DY,      // OutputGranularityY;
        0,       // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,       // StretchTapsY
        0,       // ShrinkTapsX 
        0,       // ShrinkTapsY 
        // allow 1% difference
        333000,  // MinFrameInterval (10,000,000 / 30.00FPS), 100nS units
        2666666, // MaxFrameInterval (10,000,000 /  3.75FPS), 100nS units
        27648000,  // MinBitsPerSecond (7.5 FPS);
        110592000  // MaxBitsPerSecond (30.0 FPS);
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        110592000,                          // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate;   
        333333,                             // REFERENCE_TIME  AvgTimePerFrame (30 FPS); 
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        DX,                                 // LONG  biWidth;
        DY,                                 // LONG  biHeight;
        1,                        // WORD  biPlanes;
        DBITCOUNT,                // WORD  biBitCount;
        FOURCC_Y411,              // DWORD biCompression;
        460800,                   // DWORD biSizeImage;
        0,                        // LONG  biXPelsPerMeter;
        0,                        // LONG  biYPelsPerMeter;
        0,                        // DWORD biClrUsed;
        0                         // DWORD biClrImportant;
    }
};

#endif  // SUPPORT_YUV411
    
#undef DX            
#undef DY            
#undef DBITCOUNT    

#define DX          640
#define DY          480
#define DBITCOUNT    16

// To support mode3, 640x480
KS_DATARANGE_VIDEO DCAM_StreamMode_3 = 
{
    // KSDATARANGE
    {   
        sizeof (KS_DATARANGE_VIDEO),
        0,                            // Flags
        614400,                       // SampleSize
        0,                            // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,
        FOURCC_UYVY, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71, 
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO
    },

    TRUE,                   // BOOL, bFixedSizeSamples (all samples same size?)
    TRUE,                   // BOOL, bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                      // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, 
        KS_AnalogVideo_None, // AnalogVideoStandard
        DX,DY,   // InputSize, (the inherent size of the incoming signal
                 //             with every digitized pixel unique)
        DX,DY,   // MinCroppingSize, smallest rcSrc cropping rect allowed
        DX,DY,   // MaxCroppingSize, largest  rcSrc cropping rect allowed
        1,       // CropGranularityX, granularity of cropping size
        1,       // CropGranularityY
        1,       // CropAlignX, alignment of cropping rect 
        1,       // CropAlignY;
        DX, DY,  // MinOutputSize, smallest bitmap stream can produce
        DX, DY,  // MaxOutputSize, largest  bitmap stream can produce
        DX,      // OutputGranularityX, granularity of output bitmap size
        DY,      // OutputGranularityY;
        0,       // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,       // StretchTapsY
        0,       // ShrinkTapsX 
        0,       // ShrinkTapsY 
        666666,  // MinFrameInterval (10,000,000 / 15.00FPS), 100nS units
        2666666, // MaxFrameInterval (10,000,000 /  3.75FPS), 100nS units
        36864000, // MinBitsPerSecond ( 7.5 FPS);
        73728000, // MaxBitsPerSecond (15 FPS);
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,    // RECT  rcSource; 
        0,0,0,0,    // RECT  rcTarget; 
        73728000,   // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate;   
        666666,                            // REFERENCE_TIME  AvgTimePerFrame (15 FPS); 
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        DX,                                 // LONG  biWidth;
        DY,                                 // LONG  biHeight;
        1,                                  // WORD  biPlanes;
        DBITCOUNT,                          // WORD  biBitCount;
        FOURCC_UYVY,                        // DWORD biCompression;
        614400,                             // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0                                   // DWORD biClrImportant;
    }
};


#ifdef SUPPORT_RGB24

#undef DX            
#undef DY            
#undef DBITCOUNT 
   
#undef DFPS_DEF     
#undef DFPS_MAX     
#undef DFPS_MIN

#define DX          640
#define DY          480
#define DBITCOUNT    24

// To support mode4, 640x480, RGB
KS_DATARANGE_VIDEO DCAM_StreamMode_4 = 
{
    // KSDATARANGE
    {   
        sizeof (KS_DATARANGE_VIDEO),
        0,                  // Flags
        921600,             // SampleSize
        0,                  // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,
        0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70, 
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO
    },

    TRUE,                   // BOOL, bFixedSizeSamples (all samples same size?)
    TRUE,                   // BOOL, bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                      // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, 
        KS_AnalogVideo_None, // AnalogVideoStandard
        DX,DY,   // InputSize, (the inherent size of the incoming signal
                 //             with every digitized pixel unique)
        DX,DY,   // MinCroppingSize, smallest rcSrc cropping rect allowed
        DX,DY,   // MaxCroppingSize, largest  rcSrc cropping rect allowed
        1,       // CropGranularityX, granularity of cropping size
        1,       // CropGranularityY
        1,       // CropAlignX, alignment of cropping rect 
        1,       // CropAlignY;
        DX, DY,  // MinOutputSize, smallest bitmap stream can produce
        DX, DY,  // MaxOutputSize, largest  bitmap stream can produce
        DX,      // OutputGranularityX, granularity of output bitmap size
        DY,      // OutputGranularityY;
        0,       // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,       // StretchTapsY
        0,       // ShrinkTapsX 
        0,       // ShrinkTapsY 
        666666,  // MinFrameInterval (10,000,000 / 15.00FPS), 100nS units
        2666666, // MaxFrameInterval (10,000,000 /  3.75FPS), 100nS units
        55296000,  // MinBitsPerSecond ( 7.50 FPS);
        110592000  // MaxBitsPerSecond (15.00 FPS);
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        110592000,                          // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate;   
        666666,                             // REFERENCE_TIME  AvgTimePerFrame (15 FPS); 
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        DX,                                 // LONG  biWidth;
        -DY,                                // LONG  biHeight; -biHeight indicate TopDown for RGB
        1,                         // WORD  biPlanes;
        DBITCOUNT,                 // WORD  biBitCount;
        KS_BI_RGB,                 // DWORD biCompression;
        921600,                    // DWORD biSizeImage;
        0,                         // LONG  biXPelsPerMeter;
        0,                         // LONG  biYPelsPerMeter;
        0,                         // DWORD biClrUsed;
        0                          // DWORD biClrImportant;
    }
};
    
#endif  // SUPPORT_RGB24

#ifdef SUPPORT_YUV800

#undef DX            
#undef DY            
#undef DBITCOUNT 

#define DX 	        640
#define DY          480
#define DBITCOUNT     8

KS_DATARANGE_VIDEO DCAM_StreamMode_5 = 
{
    // KSDATARANGE
    {   
        sizeof (KS_DATARANGE_VIDEO),     // Flags
        0,
        307200,                          // SampleSize
        0,                               // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,  
        FOURCC_Y800, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71,
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO
    },

    TRUE,                   // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,                   // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                      // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, 
        KS_AnalogVideo_None, // AnalogVideoStandard
        DX,DY,   // InputSize, (the inherent size of the incoming signal
                 //             with every digitized pixel unique)
        DX,DY,   // MinCroppingSize, smallest rcSrc cropping rect allowed
        DX,DY,   // MaxCroppingSize, largest  rcSrc cropping rect allowed
        1,       // CropGranularityX, granularity of cropping size
        1,       // CropGranularityY
        1,       // CropAlignX, alignment of cropping rect 
        1,       // CropAlignY;
        DX, DY,  // MinOutputSize, smallest bitmap stream can produce
        DX, DY,  // MaxOutputSize, largest  bitmap stream can produce
        DX,      // OutputGranularityX, granularity of output bitmap size
        DY,      // OutputGranularityY;
        0,       // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,       // StretchTapsY
        0,       // ShrinkTapsX 
        0,       // ShrinkTapsY 
        // Allow 1% difference
        333000,  // MinFrameInterval (10,000,000 / 30.00FPS), 100nS units
        2666666, // MaxFrameInterval (10,000,000 /  3.75FPS), 100nS units
        4608000,  // (DX * DY * DBITCOUNT) * DFPS_MIN,    // MinBitsPerSecond (3.75 FPS);
        36864000, // (DX * DY * DBITCOUNT) * DFPS_MAX     // MaxBitsPerSecond (30.0 FPS);
    }, 
        
    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        73728000,                           // DWORD dwBitRate; 307200 * 30FPS * 8 bit/Byte
        0L,                                 // DWORD dwBitErrorRate;   
        333333,                             // REFERENCE_TIME  AvgTimePerFrame (30 FPS); 
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        DX,                                 // LONG  biWidth;
        DY,                                 // LONG  biHeight;
        1,                        // WORD  biPlanes;
        DBITCOUNT,                // WORD  biBitCount;
        FOURCC_Y800,              // DWORD biCompression;
        307200,                   // DWORD biSizeImage;
        0,                        // LONG  biXPelsPerMeter;
        0,                        // LONG  biYPelsPerMeter;
        0,                        // DWORD biClrUsed;
        0                         // DWORD biClrImportant;
    }
}; 

#endif

//---------------------------------------------------------------------------
// Topology
//---------------------------------------------------------------------------

// Categories define what the device does.

static GUID Categories[] = {
    STATIC_KSCATEGORY_VIDEO,
    STATIC_KSCATEGORY_CAPTURE
};

#define NUMBER_OF_CATEGORIES  SIZEOF_ARRAY (Categories)

static KSTOPOLOGY Topology = {
    NUMBER_OF_CATEGORIES,
    (GUID*) &Categories,
    0,
    NULL,
    0,
    NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\atigpio.h ===
//==========================================================================;
//
// File:		ATIGPIO.H
//
// Notes:	This file is provided under strict non-disclosure agreements
//				it is and remains the property of ATI Technologies Inc.
//				Any use of this file or the information it contains to
//				develop products commercial or otherwise must be with the
//				permission of ATI Technologies Inc.
//
// Copyright (C) 1997 - 1998, ATI Technologies Inc.
//
//==========================================================================;

#ifndef _ATIGPIO_H_
#define _ATIGPIO_H_

#define GPIO_TIMELIMIT_OPENPROVIDER		50000000	// 5 seconds in 100 nsec.

#define	AUDIO_MUX_PINS					0x0003
#define	TUNER_PM_PINS					0x0004

#define AVAILABLE_GPIOPINS				AUDIO_MUX_PINS | TUNER_PM_PINS

#endif	// _ATIGPIO_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\common.h ===
#pragma once

//==========================================================================;
//
//	Common include file for wdm source modules
//
//		$Date:   15 Apr 1999 11:06:02  $
//	$Revision:   1.1  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1999  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "mmsystem.h"
#include "ksmedia.h"
}

#include "wdmdebug.h"
#include "wdmdrv.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\atidigad.h ===
//==========================================================================;
//
// File:		ATIDIGAD.H
//
// Notes:	This file is provided under strict non-disclosure agreements
//				it is and remains the property of ATI Technologies Inc.
//				Any use of this file or the information it contains to
//				develop products commercial or otherwise must be with the
//				permission of ATI Technologies Inc.
//
// Copyright (C) 1997 - 1998, ATI Technologies Inc.
//
//==========================================================================;

#ifndef _ATIDIGAD_H_

#define _ATIDIGAD_H_

typedef struct tag_DIGITAL_AUD_INFO
{
	BOOL	bI2SInSupported;
	BOOL	bI2SOutSupported;
	WORD	wI2S_DAC_Device;
	WORD	wReference_Clock;
	BOOL	bSPDIFSupported;

} DIGITAL_AUD_INFO, * PDIGITAL_AUD_INFO;


// Start enum value matches value in MM Table
enum
{
	TDA1309_32 = 0,
	TDA1309_64,
	ITTMSP3430,
};

// Start enum value matches value in MM Table
enum
{
	REF_286MHZ = 4,
	REF_295MHZ,
	REF_270MHZ,
	REF_143MHZ,
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\i2script.h ===
//==========================================================================;
//
//  I2CSCRPT.H
//  I2CScript class definitions. 
//      Main Include Module.
//  Copyright (c) 1996 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

#ifndef _I2CSCRIPT_H_
#define _I2CSCRIPT_H_


#include "i2cgpio.h"


#define I2CSCRIPT_LENGTH_MAXIMUM    100
#define I2C_FIXED_CLOCK_RATE        10000


// The I2CScript is build from the following primitives
typedef struct tagI2CScriptPrimitive
{
    BYTE    byData;             // Data to be used in the I2C operation
    BYTE    byORData;           // Data to be used for a logical OR operation
    BYTE    byANDData;          // Data to be used for a logical AND operation
    BYTE    byFlags;            // implementation specific internal Script flags for I2C operation
    ULONG   ulProviderFlags;    // I2CProvider specific flags
    ULONG   ulCommand;          // I2CProvider specific command

} I2CScriptPrimitive, * PI2CScriptPrimitive;

typedef struct
{
    UCHAR uchModifyORValue;
    UCHAR uchModifyANDValue;

} I2C_MODIFY_VALUES, * PI2C_MODIFY_VALUES;

// New I2CScript control structure - extension to the old I2C access structure
typedef struct tagI2CPacket
{
    UCHAR   uchChipAddress;     // I2C Address
    UCHAR   uchI2CResult;       // valid in synchronous operation only
    USHORT  cbWriteCount;       // bytes to write ( included SubAddress, if exist)
    USHORT  cbReadCount;        // bytes to read ( usually one)
    USHORT  usFlags;            // describes the desired operation
    PUCHAR  puchWriteBuffer;    // buffer to write
    PUCHAR  puchReadBuffer;     // buffer to read
    UCHAR   uchORValue;         // applied only in Read-Modify-Write cycle
    UCHAR   uchANDValue;        // applied only in Read-Modify-Write cycle
    USHORT  usReserved;         //

} I2CPacket, * PI2CPacket;

// possible flags applied to usFlags
#define I2COPERATION_READ           0x0001  // might not be needed - use bcReadCount
#define I2COPERATION_WRITE          0x0002  // might be not needed - use bcReadCount
#define I2COPERATION_READWRITE      0x0004  
#define I2COPERATION_RANDOMACCESS   0x0100  // to indicate 16 bits emulation to provide
                                            // built-in support for ITT decoder and ST24 series
                                            // of I2C driven EEPROM

extern "C"
{
typedef VOID ( STREAMAPI * PHWCompletionRoutine)( IN PVOID pSrb);
}

class CI2CScript
{
public:
    CI2CScript              ( PPORT_CONFIGURATION_INFORMATION pConfigInfo, PUINT puiError);
    PVOID operator new      ( size_t stSize, PVOID pAllocation);

// Attributes   
public:
    
private:
    // I2C Provider related
    I2CINTERFACE                m_i2cProviderInterface;
    PDEVICE_OBJECT              m_pdoDriver;
    ULONG                       m_ulI2CAccessClockRate;
    DWORD                       m_dwI2CAccessKey;

    // I2CScript management related
    BOOL                        m_bExecutionInProcess;
    UINT                        m_nExecutionIndex;
    UINT                        m_nCompletionIndex;
    UINT                        m_nScriptLength;
    PHWCompletionRoutine        m_pfnReturnWhenDone;
    I2CScriptPrimitive          m_i2cScript[I2CSCRIPT_LENGTH_MAXIMUM];

// Implementation
public:
    BOOL    LockI2CProviderEx               ( void);
    BOOL    ReleaseI2CProvider              ( void);

    BOOL    ExecuteI2CPacket                ( IN OUT PI2CPacket);
    BOOL    PerformI2CPacketOperation       ( IN OUT PI2CPacket pI2CPacket);

    BOOL    AppendToScript                  ( IN PI2CPacket);
    void    ClearScript                     ( void);
    BOOL    ExecuteScript                   ( IN PHW_STREAM_REQUEST_BLOCK   pSrb,
                                              IN PHWCompletionRoutine       pfnScriptCompletion);
    void    InterpreterScript               ( void);
    UINT    GetScriptResults                ( PUINT puiReadCount, PUCHAR puchReadBuffer);

private:
    BOOL    LockI2CProvider                 ( void);
    UINT    AccessI2CProvider               ( PDEVICE_OBJECT pdoClient, PI2CControl pi2cAccessBlock);
    BOOL    InitializeAttachI2CProvider     ( I2CINTERFACE * pI2CInterface, PDEVICE_OBJECT pDeviceObject);
    BOOL    LocateAttachI2CProvider         ( I2CINTERFACE * pI2CInterface, PDEVICE_OBJECT pDeviceObject, int nIrpMajorFunction);
    UINT    CheckI2CScriptPacket            ( IN PI2CPacket pI2CPacket);
    BOOL    GetI2CProviderLockStatus        ( void);
};


extern "C"
NTSTATUS I2CScriptIoSynchCompletionRoutine  ( IN PDEVICE_OBJECT pDeviceObject,
                                              IN PIRP pIrp,
                                              IN PVOID Event);

// errors definition for internal use
#define I2CSCRIPT_NOERROR               0x00
#define I2CSCRIPT_ERROR_NOPROVIDER      0x01
#define I2CSCRIPT_ERROR_NODATA          0x02
#define I2CSCRIPT_ERROR_NOBUFFER        0x03
#define I2CSCRIPT_ERROR_READWRITE       0x04
#define I2CSCRIPT_ERROR_OVERFLOW        0x05

// time definitions
#define I2CSCRIPT_DELAY_OPENPROVIDER        -2000
#define I2CSCRIPT_DELAY_GETPROVIDERSTATUS   -2000

// time limits
#define I2CSCRIPT_TIMELIMIT_OPENPROVIDER    50000000    // 5 seconds in 100 nsec.


#endif  // _I2CSCRIPT_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\atiguids.h ===
/*^^*
 * File:		ATIGUIDS.H
 *
 * Purpose:		Defines the GUIDS of ATI private interfaces exposed
 *				by the MiniVDD via GPIO Interface.
 *
 * Reference:	Ilya Klebanov
 *
 * Notes:	This file is provided under strict non-disclosure agreements
 *				it is and remains the property of ATI Technologies Inc.
 *				Any use of this file or the information it contains to
 *				develop products commercial or otherwise must be with the
 *				permission of ATI Technologies Inc.
 *
 * Copyright (C) December 1997, ATI Technologies Inc.
*
*	Please, come to talk to Ilya before you're making any changes to thos file
*
 *^^*/

#ifndef _ATIGUIDS_H_
#define _ATIGUIDS_H_

#include "atibios.h"

#ifndef DEVNODE
#define DEVNODE DWORD
#endif

/*
	This interface is an entry point to all possible ATI Private interfaces
	This GUID is reported back at GPIOOpen command via GPIO Microsoft defined
	interface. Among this GUID there is a PVOID pointer exposed, which we'll
	cast to the ATIQueryPrivateInterface function pointer as defined below.
	The function should return pointer to the specific interface if supported,
	or NULL based upon the GUID passed in.
*/
// {E3F5D200-6714-11d1-9065-00A02481E06C}
DEFINE_GUID( GUID_ATI_PRIVATE_INTERFACES_QueryInterface, 
	0xe3f5d200L, 0x6714, 0x11d1, 0x90, 0x65, 0x0, 0xa0, 0x24, 0x81, 0xe0, 0x6c);

typedef VOID ( STDMETHODCALLTYPE * ATI_QueryPrivateInterface)( PDEVICE_OBJECT, REFGUID, PVOID *);
typedef VOID ( STDMETHODCALLTYPE * ATI_QueryPrivateInterfaceOne)( DEVNODE, REFGUID, PVOID *);


/*
	This Interface allows to client get MultiMedia related information from
	the BIOS. Usual client is a WDM MiniDriver.
*/
// {AD5D6C00-673A-11d1-9065-00A02481E06C}
DEFINE_GUID( GUID_ATI_PRIVATE_INTERFACES_Configuration,
	0xad5d6c00, 0x673a, 0x11d1, 0x90, 0x65, 0x0, 0xa0, 0x24, 0x81, 0xe0, 0x6c);

// {D24AB480-B4D5-11d1-9065-00A02481E06C}
DEFINE_GUID( GUID_ATI_PRIVATE_INTERFACES_Configuration_One, 
	0xd24ab480, 0xb4d5, 0x11d1, 0x90, 0x65, 0x0, 0xa0, 0x24, 0x81, 0xe0, 0x6c);

// {299D9CA0-69C3-11d2-BE4D-008029E75CEB}
DEFINE_GUID( GUID_ATI_PRIVATE_INTERFACES_Configuration_Two,
	0x299d9ca0, 0x69c3, 0x11d2, 0xbe, 0x4d, 0x0, 0x80, 0x29, 0xe7, 0x5c, 0xeb);

// {58AEE200-FBBA-11d1-A419-00104B712355}
DEFINE_GUID( GUID_ATI_PRIVATE_INTERFACES_MPP, 
	0x58aee200, 0xfbba, 0x11d1, 0xa4, 0x19, 0x0, 0x10, 0x4b, 0x71, 0x23, 0x55);

// {7CF92CA0-06CE-11d2-A419-00104B712355}
DEFINE_GUID( GUID_ATI_PRIVATE_INTERFACES_StreamServices,
	0x7cf92ca0, 0x6ce, 0x11d2, 0xa4, 0x19, 0x0, 0x10, 0x4b, 0x71, 0x23, 0x55);

// {038D2B00-D6DF-11d2-BE4D-008029E75CEB}
DEFINE_GUID( GUID_ATI_PRIVATE_INTERFACES_MVProtection, 
	0x38d2b00, 0xd6df, 0x11d2, 0xbe, 0x4d, 0x0, 0x80, 0x29, 0xe7, 0x5c, 0xeb);


typedef NTSTATUS ( STDMETHODCALLTYPE * GETCONFIGURATION_MULTIMEDIA)	\
	( PVOID, PUCHAR, PULONG pulSize);
typedef NTSTATUS ( STDMETHODCALLTYPE * GETCONFIGURATION_HARDWARE)	\
	( PVOID, PUCHAR, PULONG pulSize);

typedef struct
{
	ATI_QueryPrivateInterface	pfnQueryPrivateInterface;
	GETCONFIGURATION_MULTIMEDIA	pfnGetMultimediaConfiguration;
	GETCONFIGURATION_HARDWARE	pfnGetHardwareConfiguration;

} ATI_PRIVATE_INTERFACE_CONFIGURATION, * PATI_PRIVATE_INTERFACE_CONFIGURATION;

typedef struct
{
    USHORT                  	usSize;
    USHORT                  	nVersion;
    PVOID                   	pvContext;
    PVOID                   	pvInterfaceReference;
    PVOID                   	pvInterfaceDereference;

	GETCONFIGURATION_MULTIMEDIA	pfnGetMultimediaConfiguration;
	GETCONFIGURATION_HARDWARE	pfnGetHardwareConfiguration;

} ATI_PRIVATE_INTERFACE_CONFIGURATION_One, * PATI_PRIVATE_INTERFACE_CONFIGURATION_One;


// Definitions for ulTable
typedef enum
{
	ATI_BIOS_CONFIGURATIONTABLE_MULTIMEDIA = 1,
	ATI_BIOS_CONFIGURATIONTABLE_HARDWARE

} ATI_CONFIGURATION_TABLE;

typedef NTSTATUS ( STDMETHODCALLTYPE * GETCONFIGURATION_DATA)		\
	( PVOID pvContext, ULONG ulTable, PUCHAR puchData, PULONG pulSize);
typedef NTSTATUS ( STDMETHODCALLTYPE * GETCONFIGURATION_REVISION)	\
	( PVOID pvContext, ULONG ulTable, PULONG pulRevision);

typedef struct
{
    USHORT                  	usSize;
    USHORT                  	nVersion;
    PVOID                   	pvContext;
    PVOID                   	pvInterfaceReference;
    PVOID                   	pvInterfaceDereference;

	GETCONFIGURATION_REVISION	pfnGetConfigurationRevision;
	GETCONFIGURATION_DATA		pfnGetConfigurationData;

} ATI_PRIVATE_INTERFACE_CONFIGURATION_Two, * PATI_PRIVATE_INTERFACE_CONFIGURATION_Two;


typedef NTSTATUS ( STDMETHODCALLTYPE * MACROVISIONPROTECTION_SETLEVEL) \
	( PVOID, ULONG ulProtectionLevel);
typedef NTSTATUS ( STDMETHODCALLTYPE * MACROVISIONPROTECTION_GETLEVEL) \
	( PVOID, PULONG pulProtectionLevel);

typedef struct
{
    USHORT                  		usSize;
    USHORT                  		nVersion;
    PVOID                   		pvContext;
    PVOID                   		pvInterfaceReference;
    PVOID                   		pvInterfaceDereference;

	MACROVISIONPROTECTION_SETLEVEL	pfnSetProtectionLevel;
	MACROVISIONPROTECTION_GETLEVEL	pfnGetProtectionLevel;

} ATI_PRIVATE_INTERFACE_MVProtection, *PATI_PRIVATE_INTERFACE_MVProtection;


#endif	// _ATIGUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\mmconfig.h ===
//==========================================================================;
//
//	MMCONFIG.H
//		CATIMultimediaTable Class definition.
//  Copyright (c) 1996 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//		$Date:   23 Jun 1999 11:59:52  $
//	$Revision:   1.3  $
//	  $Author:   pleung  $
//
//==========================================================================;

#ifndef _MMCONFIG_H_
#define _MMCONFIG_H_


#include "i2cgpio.h"
#include "atibios.h"
#include "atiguids.h"
#include "atidigad.h"


class CATIMultimediaTable
{
public:
	// constructor
			CATIMultimediaTable		( PDEVICE_OBJECT pDeviceObject, GPIOINTERFACE * pGPIOInterface, PBOOL pbResult);
			~CATIMultimediaTable	();
	PVOID	operator new			( size_t stSize);
	void	operator delete			( PVOID pvAllocation);

// Attributes	
private:
	ULONG		m_ulRevision;
	ULONG		m_ulSize;
	PUCHAR		m_pvConfigurationData;

// Implementation
public:
	BOOL	GetTVTunerId						( PUSHORT	pusTVTunerId);
	BOOL	GetVideoDecoderId					( PUSHORT	pusDecoderId);
	BOOL	GetOEMId							( PUSHORT	pusOEMId);
	BOOL	GetOEMRevisionId					( PUSHORT	pusOEMRevisionId);
	BOOL	GetATIProductId						( PUSHORT	pusProductId);
	BOOL	IsATIProduct						( PBOOL		pbATIProduct);
	BOOL	GetDigialAudioConfiguration			( PDIGITAL_AUD_INFO pInput);
    BOOL    GetVideoInCrystalId                 ( PUCHAR   pucVInCrystalId );  //Paul

private:
	BOOL	GetMultimediaInfo_IConfiguration2	( PDEVICE_OBJECT			pDeviceObject,
												  ATI_QueryPrivateInterface	pfnQueryInterface);
	BOOL	GetMultimediaInfo_IConfiguration1	( PDEVICE_OBJECT			pDeviceObject,
												  ATI_QueryPrivateInterface	pfnQueryInterface);
	BOOL	GetMultimediaInfo_IConfiguration	( PDEVICE_OBJECT			pDeviceObject,
												  ATI_QueryPrivateInterface	pfnQueryInterface);
	BOOL	QueryGPIOProvider					( PDEVICE_OBJECT			pDeviceObject,
												  GPIOINTERFACE *			pGPIOInterface,
												  PGPIOControl				pGPIOControl);
};

#endif // _MMCONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\i2script.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//  I2CSCRPT.C
//  I2CScript class implementation. 
//      Main Include Module.
//
//==========================================================================;

extern "C"
{
#define INITGUID

#include "strmini.h"
#include "ksmedia.h"
#include "wdm.h"

#include "wdmdebug.h"
}

#include "i2script.h"
#include "wdmdrv.h"


/*^^*
 *      operator new
 * Purpose  : CI2CScript class overloaded operator new.
 *              Provides placement for a CI2CScript class object from the PADAPTER_DEVICE_EXTENSION
 *              allocated by the StreamClassDriver for the MiniDriver.
 *
 * Inputs   :   UINT size_t         : size of the object to be placed
 *              PVOID pAllocation   : casted pointer to the CI2CScript allocated data
 *
 * Outputs  : PVOID : pointer of the CI2CScript class object
 * Author   : IKLEBANOV
 *^^*/
PVOID CI2CScript::operator new( size_t stSize,  PVOID pAllocation)
{

    if( stSize != sizeof( CI2CScript))
    {
        OutputDebugError(( "CI2CScript: operator new() fails\n"));
        return( NULL);
    }
    else
        return( pAllocation);
}



/*^^*
 *      CI2CScript()
 * Purpose  : CI2CScript class constructor.
 *              Performs checking of the I2C provider presence. Sets the script in the initial state.
 *
 * Inputs   :   PUINT puiError                      : pointer to return a completion error code
 *              PHW_STREAM_REQUEST_BLOCK    pSrb    : pointer to HW_INITIALIZE SRB
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
CI2CScript::CI2CScript( PPORT_CONFIGURATION_INFORMATION pConfigInfo,
                        PUINT puiErrorCode)
{
    m_dwI2CAccessKey = 0;

    m_i2cProviderInterface.i2cOpen = NULL;
    m_i2cProviderInterface.i2cAccess = NULL;

    m_pdoDriver = NULL;

    if( !InitializeAttachI2CProvider( &m_i2cProviderInterface, pConfigInfo->PhysicalDeviceObject))
        * puiErrorCode = WDMMINI_ERROR_NOI2CPROVIDER;
    else
    {
        // there was no error to get I2CInterface from the MiniVDD
        m_pdoDriver = pConfigInfo->RealPhysicalDeviceObject;
        m_ulI2CAccessClockRate = I2C_FIXED_CLOCK_RATE;
        * puiErrorCode = WDMMINI_NOERROR;
    }

    OutputDebugTrace(( "CI2CScript:CI2CScript() exit Error = %x\n", * puiErrorCode));
}



/*^^*
 *      LockI2CProvider()
 * Purpose  : locks the I2CProvider for exclusive use
 *
 * Inputs   : none
 *
 * Outputs  : BOOL : retunrs TRUE, if the I2CProvider is locked
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::LockI2CProvider( void)
{
    BOOL        bResult;
    I2CControl  i2cAccessBlock;

    bResult = FALSE;

    ENSURE
    {
        if(( m_i2cProviderInterface.i2cOpen == NULL)    || 
            ( m_i2cProviderInterface.i2cAccess == NULL) ||
            ( m_pdoDriver == NULL))
            FAIL;

        i2cAccessBlock.Status = I2C_STATUS_NOERROR;
        if( m_i2cProviderInterface.i2cOpen( m_pdoDriver, TRUE, &i2cAccessBlock) != STATUS_SUCCESS)
        {
            OutputDebugError(( "CI2CScript: LockI2CProvider() bResult = %x\n", bResult));
            FAIL;
        }

        if( i2cAccessBlock.Status != I2C_STATUS_NOERROR)
        {
            OutputDebugError(( "CI2CScript: LockI2CProvider() Status = %x\n", i2cAccessBlock.Status));
            FAIL;
        }

        // the I2C Provider has granted access - save dwCookie for further use
        m_dwI2CAccessKey = i2cAccessBlock.dwCookie;

        bResult = TRUE;

    } END_ENSURE;

    return( bResult);
}



/*^^*
 *      LockI2CProvider()
 * Purpose  : locks the I2CProvider for exclusive use. Provides attempts to lock the
 *              provider unless either the time-out condition or the attempt succeeded.
 *
 * Inputs   : none
 *
 * Outputs  : BOOL : retunrs TRUE, if the I2CProvider is locked
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::LockI2CProviderEx( void)
{
    LARGE_INTEGER liTime, liOperationStartTime;

    liOperationStartTime.QuadPart = 0;

    while( !LockI2CProvider())
    {
        KeQuerySystemTime( &liTime);

        if( !liOperationStartTime.QuadPart)
            liOperationStartTime.QuadPart = liTime.QuadPart;
        else
            if( liTime.QuadPart - liOperationStartTime.QuadPart >
                I2CSCRIPT_TIMELIMIT_OPENPROVIDER)
            {
                // the time is expired - abort the initialization
                return( FALSE);
            }

        liTime.QuadPart = I2CSCRIPT_DELAY_OPENPROVIDER;
        KeDelayExecutionThread( KernelMode, FALSE, &liTime);
    }

    return( TRUE);
}




/*^^*
 *      GetI2CProviderLockStatus()
 * Purpose  : retrieves I2CProvider lock status
 *
 * Inputs   : none
 *
 * Outputs  : BOOL : retunrs TRUE, if the I2CProvider has been locked
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::GetI2CProviderLockStatus( void)
{

    return( m_dwI2CAccessKey);
}




/*^^*
 *      ReleaseI2CProvider()
 * Purpose  : releases the I2CProvider for other clients' use
 *
 * Inputs   : none
 *
 * Outputs  : BOOL : retunrs TRUE, if the I2CProvider is released
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::ReleaseI2CProvider( void)
{
    BOOL        bResult;
    I2CControl  i2cAccessBlock;

    bResult = FALSE;

    ENSURE
    {
        if(( m_i2cProviderInterface.i2cOpen == NULL)    ||
            ( m_i2cProviderInterface.i2cAccess == NULL) ||
            ( m_pdoDriver == NULL))
            // the I2CProvider was not found
            FAIL;

        i2cAccessBlock.Status = I2C_STATUS_NOERROR;
        i2cAccessBlock.dwCookie = m_dwI2CAccessKey;
        i2cAccessBlock.ClockRate = m_ulI2CAccessClockRate;
        if( m_i2cProviderInterface.i2cOpen( m_pdoDriver, FALSE, &i2cAccessBlock) != STATUS_SUCCESS)
        {
            OutputDebugError(( "CI2CScript: ReleaseI2CProvider() bResult = %x\n", bResult));
            FAIL;
        }

        if( i2cAccessBlock.Status != I2C_STATUS_NOERROR)
        {
            OutputDebugError(( "CI2CScript: ReleaseI2CProvider() bResult = %x\n", bResult));
            FAIL;
        }

        m_dwI2CAccessKey = 0;
        bResult = TRUE;

    } END_ENSURE;

    return( bResult);
}



/*^^*
 *      PerformI2CPacketOperation()
 * Purpose  : synchronosly executes I2C access packet. It assumed to be executed at Low priority.
 *              The function does not return until the I2C session is done. The execution
 *              is not dependent on the I2C Provider lock status
 *      
 * Inputs   :   PI2CPacket pI2CPacket : pointer to I2C access packet
 *
 * Outputs  : BOOL : returns TRUE, if I2C operation was carried out successfuly
 *              The error status is returned via uchI2CResult field of the PI2CPacket
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::PerformI2CPacketOperation( IN OUT PI2CPacket pI2CPacket)
{
    BOOL bResult;

    if( GetI2CProviderLockStatus())
        // the Provider was locked before and we're not going to change it
        bResult = ExecuteI2CPacket( pI2CPacket);
    else
    {
        // the Provider was not locked and it's our responsibility to lock it first,
        // execute I2C operation and release it after the use
        if( LockI2CProviderEx())
        {
            bResult = ExecuteI2CPacket( pI2CPacket);
            ReleaseI2CProvider();
        }
        else
            bResult = FALSE;
    }

    return( bResult);
}



/*^^*
 *      ExecuteI2CPacket()
 * Purpose  : synchronosly executes I2C access packet. It assumed to be executed at Low priority.
 *              The function does not return until the I2C session is done. This kind of access
 *              is used during initialization ( boot up) time only. This function should be
 *              called only after the I2CProvider was locked for exclusive service
 *      
 * Inputs   :   PI2CPacket pI2CPacket : pointer to I2C access packet
 *
 * Outputs  : BOOL : returns TRUE, if I2C operation was carried out successfuly
 *              The error status is returned via uchI2CResult field of the PI2CPacket
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::ExecuteI2CPacket( IN OUT PI2CPacket pI2CPacket)
{
    UINT    nError, cbCount;
    UCHAR   uchValue;
    UCHAR   uchI2CResult = I2C_STATUS_ERROR;

    ENSURE
    {
        I2CControl  i2cAccessBlock;

        if(( nError = CheckI2CScriptPacket( pI2CPacket)) != I2CSCRIPT_NOERROR)
            FAIL;

        // we'll use I2CProvider interface, assuming there is a syncronous provider
        // for asynchronous provider some work has to be added. 16 bits emulation is
        // not supported at this time either. This implementation does not support
        // Read-Modify-Write request either
        ENSURE
        {
            UINT        nIndex;

            i2cAccessBlock.dwCookie = m_dwI2CAccessKey;
            i2cAccessBlock.ClockRate = m_ulI2CAccessClockRate;

            // We assume the last byte in the buffer belongs to the Write operation 
            // after Read-Modify, is specified.
            cbCount = ( pI2CPacket->usFlags & I2COPERATION_READWRITE) ?
                            ( pI2CPacket->cbWriteCount - 1) : ( pI2CPacket->cbWriteCount);

            if( cbCount)
            {
                // implement a write request
                // apply START condition with the I2C chip address first
                i2cAccessBlock.Flags = I2C_FLAGS_START | I2C_FLAGS_ACK;
                i2cAccessBlock.Command = I2C_COMMAND_WRITE;
                i2cAccessBlock.Data = pI2CPacket->uchChipAddress & 0xFE;
                if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) != I2C_STATUS_NOERROR)
                    FAIL;

                i2cAccessBlock.Flags = I2C_FLAGS_ACK;
                for( nIndex = 0; nIndex < cbCount; nIndex ++)
                {
                    // write the data from the buffer
                    i2cAccessBlock.Data = pI2CPacket->puchWriteBuffer[nIndex];
                    if(( nIndex == cbCount - 1) &&
                        !( pI2CPacket->usFlags & I2COPERATION_RANDOMACCESS))
                        // the last byte to write - apply STOP condition, if no
                        // I2COPERATION_RANDOMACCESS flag is specified
                        i2cAccessBlock.Flags |= I2C_FLAGS_STOP;

                    if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) != I2C_STATUS_NOERROR)
                        break;
                }
                if( nIndex != cbCount)
                    FAIL;
/*  // STOP condition is applied withe the last byte to be written
                // apply stop condition as the end of write operation
                i2cAccessBlock.Flags = I2C_FLAGS_STOP;
                i2cAccessBlock.Command = I2C_COMMAND_NULL;
                m_i2cProviderInterface.i2cAccess( m_pdoDriver, &i2cAccessBlock);
*/
            }

            if( pI2CPacket->cbReadCount)
            {
                // implement a read request
                // apply START condition with the I2C chip address first
                i2cAccessBlock.Flags = I2C_FLAGS_START | I2C_FLAGS_ACK;
                i2cAccessBlock.Command = I2C_COMMAND_WRITE;
                i2cAccessBlock.Data = pI2CPacket->uchChipAddress | 0x01;
                if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) != I2C_STATUS_NOERROR)
                    FAIL;

                i2cAccessBlock.Flags = I2C_FLAGS_ACK;
                i2cAccessBlock.Command = I2C_COMMAND_READ;
                for( nIndex = 0; nIndex < pI2CPacket->cbReadCount; nIndex ++)
                {
                    // read the data to the buffer
                    if( nIndex == ( UINT)( pI2CPacket->cbReadCount - 1))
                    {
                        // don't apply ACK at the last read - read operation termination
                        i2cAccessBlock.Flags &= ~I2C_FLAGS_ACK;
                        // also apply STOP condition for the last byte
                        i2cAccessBlock.Flags |= I2C_FLAGS_STOP;
                    }

                    if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) != I2C_STATUS_NOERROR)
                        break;
                    pI2CPacket->puchReadBuffer[nIndex] = i2cAccessBlock.Data;
                }
                if( nIndex != pI2CPacket->cbReadCount)
                    FAIL;

/*  // STOP condition is applied with the last byte to be read
                // apply stop condition as the end of read operation
                i2cAccessBlock.Flags = I2C_FLAGS_STOP;
                i2cAccessBlock.Command = I2C_COMMAND_NULL;
                m_i2cProviderInterface.i2cAccess( m_pdoDriver, &i2cAccessBlock);
*/
                if( pI2CPacket->usFlags & I2COPERATION_READWRITE)
                {
                    // write operation should be taken care again, the last byte in the pbyWriteBuffer
                    // should be constructed from the value read back and the binary operations OR and AND
                    // with the values specified in the packet
                    uchValue = pI2CPacket->puchReadBuffer[pI2CPacket->cbReadCount - 1];
                    uchValue &= pI2CPacket->uchANDValue;
                    pI2CPacket->puchWriteBuffer[pI2CPacket->cbWriteCount - 1] = uchValue | pI2CPacket->uchORValue;

                    if( pI2CPacket->cbWriteCount)
                    {
                        // implement a write request
                        // apply START condition with the I2C chip address first
                        i2cAccessBlock.Flags = I2C_FLAGS_START | I2C_FLAGS_ACK;
                        i2cAccessBlock.Command = I2C_COMMAND_WRITE;
                        i2cAccessBlock.Data = pI2CPacket->uchChipAddress & 0xFE;
                        if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) != I2C_STATUS_NOERROR)
                            FAIL;

                        i2cAccessBlock.Flags = I2C_FLAGS_ACK;
                        for( nIndex = 0; nIndex < pI2CPacket->cbWriteCount; nIndex ++)
                        {
                            // write the data from the buffer
                            i2cAccessBlock.Data = pI2CPacket->puchWriteBuffer[nIndex];
                            if( nIndex == ( UINT)( pI2CPacket->cbWriteCount - 1))
                                // the last byte to write - apply STOP condition
                                i2cAccessBlock.Flags |= I2C_FLAGS_STOP;

                            if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) != I2C_STATUS_NOERROR)
                                break;
                        }

                        if( nIndex != pI2CPacket->cbWriteCount)
                            FAIL;
/*  // STOP condition is applied withe the last byte to be written
                        // apply stop condition as the end of write operation
                        i2cAccessBlock.Flags = I2C_FLAGS_STOP;
                        i2cAccessBlock.Command = I2C_COMMAND_NULL;
                        m_i2cProviderInterface.i2cAccess( m_pdoDriver, &i2cAccessBlock);
*/
                    }
                }
            }

            uchI2CResult = I2C_STATUS_NOERROR;

        } END_ENSURE;

        if( uchI2CResult == I2C_STATUS_ERROR)
        {
            // there was an error during accessing I2C - issue Reset command
            i2cAccessBlock.Command = I2C_COMMAND_RESET;
            AccessI2CProvider( m_pdoDriver, &i2cAccessBlock);
        }
        
        pI2CPacket->uchI2CResult = uchI2CResult;

        return( TRUE);

    } END_ENSURE;

    OutputDebugTrace(( "CI2CScript:ExecuteI2CPacket() nError = %x", nError));
    return( FALSE);
}



/*^^*
 *      CheckI2CScriptPacket()
 * Purpose  : checks integrity of the I2C control package
 *
 * Inputs   :   PI2CPacket pI2CPacket   : pointer to I2C access packet
 *
 * Outputs  : BOOL : returns TRUE, if I2C control package is a valid one
 *
 * Author   : IKLEBANOV
 *^^*/
UINT CI2CScript::CheckI2CScriptPacket( IN PI2CPacket pI2CPacket)
{
    UINT nPacketError;

    ENSURE
    {
        if(( m_i2cProviderInterface.i2cOpen == NULL)    ||
            ( m_i2cProviderInterface.i2cAccess == NULL) ||
            ( m_pdoDriver == NULL))
        {
            // the I2CProvider was not found
            nPacketError = I2CSCRIPT_ERROR_NOPROVIDER;
            FAIL;
        }

        if(( !pI2CPacket->cbWriteCount) && ( !pI2CPacket->cbReadCount))
        {
            // nothing to do
            nPacketError = I2CSCRIPT_ERROR_NODATA;
            FAIL;
        }

        if((( pI2CPacket->cbWriteCount) && ( pI2CPacket->puchWriteBuffer == NULL))
            || (( pI2CPacket->cbReadCount) && ( pI2CPacket->puchReadBuffer == NULL)))
        {
            // NULL pointer, when the data is specified
            nPacketError = I2CSCRIPT_ERROR_NOBUFFER;
            FAIL;
        }

        if(( pI2CPacket->usFlags & I2COPERATION_READWRITE) && ( !pI2CPacket->cbWriteCount))
        {
            // if Read-Modify-Write is specified, the Write data should be present
            nPacketError = I2CSCRIPT_ERROR_READWRITE;
            FAIL;
        }

        nPacketError = I2CSCRIPT_NOERROR;

    } END_ENSURE;

    return( nPacketError);
}




/*^^*
 *      ClearScript()
 * Purpose  : clears I2CScript to the NULL state - no I2C operations are on hold.
 *
 * Inputs   :   none
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
void CI2CScript::ClearScript( void)
{

    m_nExecutionIndex = 0;
    m_nScriptLength = 0;
    m_pfnReturnWhenDone = NULL;
    m_bExecutionInProcess = FALSE;
}



/*^^*
 *      AppendToScript()
 * Purpose  : appends a I2CPacket to the bottom of the I2CScript.
 *              The 16 bits emulation is not implemented at this time.
 *
 * Inputs   :   PI2CPacket pI2CPacket - pointer to the I2C packet to append
 *
 * Outputs  : BOOL : returns TRUE, if the packet was successfully appended.
 *              FALSE might happend if the I2CPacket is a bad one, or overflow occurs
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::AppendToScript( PI2CPacket pI2CPacket)
{
    UINT    nError, nScriptIndex;
    UINT    nIndex, cbCount;
    
    ENSURE
    {
        PI2CScriptPrimitive pI2CPrimitive;

        if(( nError = CheckI2CScriptPacket( pI2CPacket)) != I2CSCRIPT_NOERROR)
            FAIL;
        nError = I2CSCRIPT_ERROR_OVERFLOW;

        // m_nExecutionIndex is used as a Script build index. We will work with a local copy of it
        // first to ensure we have no overflow
        nScriptIndex = m_nExecutionIndex;
        pI2CPrimitive = &m_i2cScript[nScriptIndex];

        // We assume the last byte in the buffer belongs to the Write operation 
        // after Read-Modify, is specified.
        cbCount = ( pI2CPacket->usFlags & I2COPERATION_READWRITE) ? \
                        ( pI2CPacket->cbWriteCount - 1) : ( pI2CPacket->cbWriteCount);

        if( cbCount)
        {
            // I2C Chip address should be taken care of first
            pI2CPrimitive->ulCommand = I2C_COMMAND_WRITE;
            pI2CPrimitive->byData = pI2CPacket->uchChipAddress;
            pI2CPrimitive->byANDData = 0xFE;
            pI2CPrimitive->byORData = 0x00;
            pI2CPrimitive->ulProviderFlags = I2C_FLAGS_START | I2C_FLAGS_ACK;
            pI2CPrimitive->byFlags = 0x0;

            // check the Script length
            if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                FAIL;
            pI2CPrimitive ++;

            // I2C write buffer should be taken care of.
            for( nIndex = 0; nIndex < cbCount; nIndex ++)
            {
                pI2CPrimitive->ulCommand = I2C_COMMAND_WRITE;
                pI2CPrimitive->byData = pI2CPacket->puchWriteBuffer[nIndex];
                pI2CPrimitive->byORData = 0x00;
                pI2CPrimitive->byANDData = 0xFF;
                pI2CPrimitive->ulProviderFlags = I2C_FLAGS_ACK;
                pI2CPrimitive->byFlags = 0x0;

                if( nIndex == cbCount - 1)
                    // this is the last byte to be written - apply STOP
                    pI2CPrimitive->ulProviderFlags |= I2C_FLAGS_STOP;

                // check the Script length
                if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                    break;
                pI2CPrimitive ++;
            }

            // check the Script length
            if( nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                FAIL;

/*
    // Stop condition is applied with the last byte to be written
    // We finished Write portion here, whether it's a Write only, Read-Modify-Write operation
            pI2CPrimitive->ulCommand = I2C_COMMAND_NULL;
            pI2CPrimitive->ulProviderFlags = I2C_FLAGS_STOP;
            pI2CPrimitive->byFlags = 0x0;
        
            // check the Script length
            if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                FAIL;
            pI2CPrimitive ++;
*/
        }

        // We have to see, if there is a Read operation involved
        if( pI2CPacket->cbReadCount)
        {
            // I2C Chip address should be taken care of first
            pI2CPrimitive->ulCommand = I2C_COMMAND_WRITE;
            pI2CPrimitive->byData = pI2CPacket->uchChipAddress;
            pI2CPrimitive->byANDData = 0xFE;
            pI2CPrimitive->byORData = 0x01;
            pI2CPrimitive->ulProviderFlags = I2C_FLAGS_START | I2C_FLAGS_ACK;
            pI2CPrimitive->byFlags = 0x0;

            // check the Script length
            if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                FAIL;
            pI2CPrimitive ++;

            // I2C read buffer should be taken care of. We assume the last byte in the buffer belongs to
            // the Write operation after Read-Modify, is specified.
            for( nIndex = 0; nIndex < pI2CPacket->cbReadCount; nIndex ++)
            {
                pI2CPrimitive->ulCommand = I2C_COMMAND_READ;
                if( nIndex == ( UINT)( pI2CPacket->cbReadCount - 1))
                {
                    pI2CPrimitive->ulProviderFlags = I2C_FLAGS_STOP;
                    pI2CPrimitive->byFlags = pI2CPacket->usFlags & I2COPERATION_READWRITE;
                }
                else
                {
                    pI2CPrimitive->ulProviderFlags = I2C_FLAGS_ACK;
                    pI2CPrimitive->byFlags = 0x0;
                }

                // check the Script length
                if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                    break;
                pI2CPrimitive ++;
            }

            // check the Script length
            if( nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                FAIL;

/*  // Stop condition is applied with the last byte to be read
            // We finished Read portion here, whether it's a Read only, Read-Modify-Write operation
            pI2CPrimitive->ulCommand = I2C_COMMAND_NULL;
            pI2CPrimitive->ulProviderFlags = I2C_FLAGS_STOP;
            pI2CPrimitive->byFlags = 0x0;
        
            // check the Script length
            if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                FAIL;
            pI2CPrimitive ++;
*/
        }
        
        // the last thing left to do, is to implement Write after Read-Modify, if specified
        if( pI2CPacket->usFlags & I2COPERATION_READWRITE)
        {
            // I2C Chip address should be taken care of first
            pI2CPrimitive->ulCommand = I2C_COMMAND_WRITE;
            pI2CPrimitive->byData = pI2CPacket->uchChipAddress;
            pI2CPrimitive->byANDData = 0xFE;
            pI2CPrimitive->byORData = 0x00;
            pI2CPrimitive->ulProviderFlags = I2C_FLAGS_START | I2C_FLAGS_ACK;
            pI2CPrimitive->byFlags = 0x0;

            // check the Script length
            if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                FAIL;
            pI2CPrimitive ++;

            // I2C write buffer should be taken care of.
            for( nIndex = 0; nIndex < pI2CPacket->cbWriteCount; nIndex ++)
            {
                pI2CPrimitive->ulCommand = I2C_COMMAND_WRITE;
                pI2CPrimitive->byData = pI2CPacket->puchWriteBuffer[nIndex];
                pI2CPrimitive->ulProviderFlags = I2C_FLAGS_ACK;
                if( nIndex == ( UINT)( pI2CPacket->cbWriteCount - 1))
                {
                    // it's time to write the byte modified after the Read operation
                    pI2CPrimitive->byORData = pI2CPacket->uchORValue;
                    pI2CPrimitive->byANDData = pI2CPacket->uchANDValue;
                    pI2CPrimitive->byFlags = I2COPERATION_READWRITE;
                    // apply STOP condition with the last byte to be read
                    pI2CPrimitive->ulProviderFlags |= I2C_FLAGS_STOP;
                }
                else
                {
                    pI2CPrimitive->byORData = 0x00;
                    pI2CPrimitive->byANDData = 0xFF;
                    pI2CPrimitive->byFlags = 0x0;
                }

                // check the Script length
                if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                    break;
                pI2CPrimitive ++;
            }

            // check the Script length
            if( nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                FAIL;

/*  // Stop condition is applied with the last byte to be written
            // We finished Write portion here, whether it's a Write only, Read-Modify-Write operation
            pI2CPrimitive->ulCommand = I2C_COMMAND_NULL;
            pI2CPrimitive->ulProviderFlags = I2C_FLAGS_STOP;
            pI2CPrimitive->byFlags = 0x0;
        
            // check the Script length
            if( ++ nScriptIndex >= I2CSCRIPT_LENGTH_MAXIMUM)
                FAIL;
            pI2CPrimitive ++;
*/
        }

        // the Packet was added succesfully to the Script. Modify the Script propertirs
        m_nExecutionIndex = nScriptIndex;
        m_nScriptLength = nScriptIndex;
        return( TRUE);

    } END_ENSURE;

    OutputDebugTrace(( "CI2CScript:AppendToScript() nError = %x", nError));
    return( FALSE);
}



/*^^*
 *      ExecuteScript()
 * Purpose  : triggers the execution of previously built I2CScript. This function is also
 *              responsible for allocating I2CProvider for its own exclusive use.
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK    pSrb        : pointer to the current SRB
 *              PHWCompletionRoutine pfnScriptCompletion: function pointer will be called,
 *                  when the script execution is completed. Indicates the Script execution
 *                  is to be carried out asynchronously.
 *
 * Outputs  : BOOL : returns TRUE, if the execution was successfully triggered.
 *              FALSE might happend if the Script has not been built by the time of the call
 *
 * Note     : if pfnScriptExecuted is NULL pointer, the Script will be executed synchronously
 *
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::ExecuteScript( IN PHW_STREAM_REQUEST_BLOCK pSrb,
                                IN PHWCompletionRoutine     pfnScriptCompletion)
{

    ENSURE
    {
        if( pfnScriptCompletion != NULL)
            // not supported at this point. The idea is to create a new system thread,
            // where the Script to be executed. When the Script will be copleted,
            // call-back is called and the thred terminates itself.
            FAIL;

        if( !m_nExecutionIndex)
            FAIL;

        // there is not a NULL Script - proceed
        m_nScriptLength = m_nExecutionIndex;
        m_nExecutionIndex = m_nCompletionIndex = 0;

        if( !GetI2CProviderLockStatus())
            // The provider was not locked prior the Script execution
            if( !LockI2CProviderEx())
                FAIL;

        InterpreterScript();

        ReleaseI2CProvider();
    
        return( TRUE);

    } END_ENSURE;

    return( FALSE);
}



/*^^*
 *      InterpreterScript()
 * Purpose  : interpreters the I2CScript line by line. The Script is not cleaned up 
 *              after the completion to allow to client retrive the results of 
 *              the script execution. It's the client responsibility to clean it up
 *              upon the results retrieving
 *
 * Inputs   : none
 * Outputs  : none
 *
 * Author   : IKLEBANOV
 *^^*/
void CI2CScript::InterpreterScript( void)
{
    UINT        nScriptIndex, nIndex;
    I2CControl  i2cAccessBlock;

    m_bExecutionInProcess = TRUE;
    
    i2cAccessBlock.dwCookie = m_dwI2CAccessKey;
    i2cAccessBlock.ClockRate = m_ulI2CAccessClockRate;
        
    // We'll interpreter every line of the Script and call the I2C Provider to
    // execute it. It's assumed the I2CProvider is a syncronous one. If it's not the
    // case, the special care should be taken of based upon returned value I2C_STATUS_BUSY
    // in the Status.
    for( nScriptIndex = 0; nScriptIndex < m_nScriptLength; nScriptIndex ++)
    {
        i2cAccessBlock.Command = m_i2cScript[nScriptIndex].ulCommand;
        i2cAccessBlock.Flags = m_i2cScript[nScriptIndex].ulProviderFlags;
        if( i2cAccessBlock.Command == I2C_COMMAND_WRITE)
        {
            i2cAccessBlock.Data = m_i2cScript[nScriptIndex].byData;
            i2cAccessBlock.Data &= m_i2cScript[nScriptIndex].byANDData;
            i2cAccessBlock.Data |= m_i2cScript[nScriptIndex].byORData;
        }

        if( AccessI2CProvider( m_pdoDriver, &i2cAccessBlock) == I2C_STATUS_ERROR)
            break;

        // check, wether it's a Read operation - save result
        if( i2cAccessBlock.Command == I2C_COMMAND_READ)
        {
            m_i2cScript[nScriptIndex].byData = i2cAccessBlock.Data;
            // check, if this data belongs to Read-Modify-Write operation
            if( m_i2cScript[nScriptIndex].byFlags & I2COPERATION_READWRITE)
            {
                // let's look for the next I2COPERATION_READWRITE flag - it is the pair
                for( nIndex = nScriptIndex; nIndex < m_nScriptLength; nIndex ++)
                    if(( m_i2cScript[nIndex].ulCommand == I2C_COMMAND_WRITE) &&
                        ( m_i2cScript[nIndex].byFlags & I2COPERATION_READWRITE))
                        break;

                if( nIndex >= m_nScriptLength)
                    // the Script got corrupted
                    break;

                m_i2cScript[nIndex].byData = i2cAccessBlock.Data;
            }
        }
    }

    m_nCompletionIndex = nScriptIndex;

    m_bExecutionInProcess = FALSE;
}



/*^^*
 *      AccessI2CProvider()
 * Purpose  : provide synchronous type of access to I2CProvider
 *
 * Inputs   :   PDEVICE_OBJECT pdoDriver    : pointer to the client's device object
 *              PI2CControl pi2cAccessBlock : pointer to a composed I2C access block
 *
 * Outputs  : UINT : status of the I2C operation I2C_STATUS_NOERROR or I2C_STATUS_ERROR
 *
 * Author   : IKLEBANOV
 *^^*/
UINT CI2CScript::AccessI2CProvider( PDEVICE_OBJECT pdoClient, PI2CControl pi2cAccessBlock)
{
    UINT            uiStatus;
    LARGE_INTEGER   liTime;

    do
    {
        // this loop is infinitive. It has to be taken care of
        if( m_i2cProviderInterface.i2cAccess( pdoClient, pi2cAccessBlock) != STATUS_SUCCESS)
        {
            uiStatus = I2C_STATUS_ERROR;
            break;
        }

        if( pi2cAccessBlock->Status != I2C_STATUS_BUSY)
        {
            uiStatus = pi2cAccessBlock->Status;
            break;
        }

        liTime.QuadPart = I2CSCRIPT_DELAY_GETPROVIDERSTATUS;
        ::KeDelayExecutionThread( KernelMode, FALSE, &liTime);

        pi2cAccessBlock->Command = I2C_COMMAND_STATUS;

    } while( TRUE);

    return( uiStatus);
}



/*^^*
 *      GetScriptResults()
 * Purpose  : returns result of the executed Script
 *              This function idealy is called twice:
 *                  first time with the puchReadBuffer = NULL to retrive the number of bytes read
 *                  second time - to fill in the pointer
 * Inputs   :   PUINT puiReadCount  : pointer to the counter of the bytes were read
 *              PUCH puchReadBuffer : pointer to the buffer to put the data
 *
 * Outputs  : UINT : status of the I2C operation
 *              If the status is I2C_STATUS_ERROR, puiReadCount will contain the step, where
 *              I2CScript failed
 * Author   : IKLEBANOV
 *^^*/
UINT CI2CScript::GetScriptResults( PUINT puiReadCount, PUCHAR puchReadBuffer)
{
    UINT nScriptIndex, nCount;

    ASSERT( puiReadCount != NULL);

    if( m_bExecutionInProcess)
        return( I2C_STATUS_BUSY);

    if( m_nScriptLength != m_nCompletionIndex)
    {
        // if the case of failure, step where I2CScript failed is return
        // instead of Read Counter. The returned status indicates the
        // failure
        * puiReadCount = m_nCompletionIndex;

        return( I2C_STATUS_ERROR);
    }
    else
    {
        nCount = 0;

        for( nScriptIndex = 0; nScriptIndex < m_nCompletionIndex; nScriptIndex ++)
        {
            if( m_i2cScript[nScriptIndex].ulCommand == I2C_COMMAND_READ)
            {
                if( puchReadBuffer != NULL)
                    // fill in the supplied buffer
                    puchReadBuffer[nCount] = m_i2cScript[nScriptIndex].byData;
                nCount ++;
            }
        }

        * puiReadCount = nCount;

        return( I2C_STATUS_NOERROR);
    }
}



/*^^*
 *      InitializeAttachI2CProvider()
 * Purpose  : gets the pointer to the parent I2C Provider interface using
 *              several IRP_MJ_??? functions.
 *              This function will be called at Low priority
 *
 * Inputs   :   I2CINTERFACE * pI2CInterface    : pointer to the Interface to be filled in
 *              PDEVICE_OBJECT pDeviceObject    : MiniDriver device object, which is a child of I2C Master
 *
 * Outputs  : BOOL  - returns TRUE, if the interface was found
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::InitializeAttachI2CProvider( I2CINTERFACE * pI2CInterface, PDEVICE_OBJECT pDeviceObject)
{
    BOOL bResult;

    bResult = LocateAttachI2CProvider( pI2CInterface, pDeviceObject, IRP_MJ_PNP);
    if(( pI2CInterface->i2cOpen == NULL) || ( pI2CInterface->i2cAccess == NULL))
    {
        TRAP;
        OutputDebugError(( "CI2CScript(): interface has NULL pointers\n"));
        bResult = FALSE;
    }

    return( bResult);
}



/*^^*
 *      LocateAttachI2CProvider()
 * Purpose  : gets the pointer to the parent I2C Provider interface
 *              This function will be called at Low priority
 *
 * Inputs   :   I2CINTERFACE * pI2CInterface    : pointer to the Interface to be filled in
 *              PDEVICE_OBJECT pDeviceObject    : MiniDriver device object, which is a child of I2C Master
 *              int         nIrpMajorFunction   : IRP major function to query the I2C Interface
 *
 * Outputs  : BOOL  - returns TRUE, if the interface was found
 * Author   : IKLEBANOV
 *^^*/
BOOL CI2CScript::LocateAttachI2CProvider( I2CINTERFACE * pI2CInterface, PDEVICE_OBJECT pDeviceObject, int nIrpMajorFunction)
{
    PIRP    pIrp;
    BOOL    bResult = FALSE;

    ENSURE
    {
        PIO_STACK_LOCATION  pNextStack;
        NTSTATUS            ntStatus;
        KEVENT              Event;
            
            
        pIrp = IoAllocateIrp( pDeviceObject->StackSize, FALSE);
        if( pIrp == NULL)
        {
            TRAP;
            OutputDebugError(( "CI2CScript(): can not allocate IRP\n"));
            FAIL;
        }

        pNextStack = IoGetNextIrpStackLocation( pIrp);
        if( pNextStack == NULL)
        {
            TRAP;
            OutputDebugError(( "CI2CScript(): can not allocate NextStack\n"));
            FAIL;
        }

        pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        pNextStack->MajorFunction = (UCHAR)nIrpMajorFunction;
        pNextStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
        KeInitializeEvent( &Event, NotificationEvent, FALSE);

        IoSetCompletionRoutine( pIrp,
                                I2CScriptIoSynchCompletionRoutine,
                                &Event, TRUE, TRUE, TRUE);

        pNextStack->Parameters.QueryInterface.InterfaceType = ( struct _GUID *)&GUID_I2C_INTERFACE;
        pNextStack->Parameters.QueryInterface.Size = sizeof( I2CINTERFACE);
        pNextStack->Parameters.QueryInterface.Version = 1;
        pNextStack->Parameters.QueryInterface.Interface = ( PINTERFACE)pI2CInterface;
        pNextStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

        ntStatus = IoCallDriver( pDeviceObject, pIrp);

        if( ntStatus == STATUS_PENDING)
            KeWaitForSingleObject(  &Event,
                                    Suspended, KernelMode, FALSE, NULL);
        if(( pI2CInterface->i2cOpen == NULL) || ( pI2CInterface->i2cAccess == NULL))
            FAIL;

        bResult = TRUE;

    } END_ENSURE;
 
    if( pIrp != NULL)
        IoFreeIrp( pIrp);

    return( bResult);
}


/*^^*
 *      I2CScriptIoSynchCompletionRoutine()
 * Purpose  : This routine is for use with synchronous IRP processing.
 *              All it does is signal an event, so the driver knows it and can continue.
 *
 * Inputs   :   PDEVICE_OBJECT DriverObject : Pointer to driver object created by system
 *              PIRP pIrp                   : Irp that just completed
 *              PVOID Event                 : Event we'll signal to say Irp is done
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
extern "C"
NTSTATUS I2CScriptIoSynchCompletionRoutine( IN PDEVICE_OBJECT pDeviceObject,
                                            IN PIRP pIrp,
                                            IN PVOID Event)
{

    KeSetEvent(( PKEVENT)Event, 0, FALSE);
    return( STATUS_MORE_PROCESSING_REQUIRED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\pinmedia.cpp ===
//==========================================================================;
//
//	PinMedia.CPP
//	WDM MiniDrivers.
//		AIW Hardware platform. 
//			Global shared in Mediums support functions inplementation
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "wdmdrv.h"
#include "pinmedia.h"


/*^^*
 *		GetDriverInstanceNumber()
 * Purpose	: gets the instance number of the driver. I think it can be retrived from the
 *				Registry path, where Instance is a part of the PCI device address
 *
 * Inputs	:	PDEVICE_OBJECT pDeviceObject	: pointer to DeviceObject
 *
 * Outputs	: ULONG Instance of the driver
 * Author	: IKLEBANOV
 *^^*/
ULONG GetDriverInstanceNumber( PDEVICE_OBJECT pDeviceObject)
{

	return( 0);
}



/*^^*
 *		ReadPinMediumFromRegistryFolder()
 * Purpose	: Reads the pin GUID from the Registry if the default is overwritten
 *				by user .INF file. Also construct medium from this GUID and two ULONG 0.
 *
 * Inputs	:	HANDLE hFolder				: Registry folder handle
 *				ULONG nPin					: pin number to get Medium data of
 *				PKSPIN_MEDIUM pMediumKSPin	: pointer to return pin Medium data
 *
 * Outputs	: BOOL, TRUE if Registry Medium data found for this pin and valid
 * Author	: IKLEBANOV
 *^^*/
BOOL ReadPinMediumFromRegistryFolder( HANDLE hFolder, ULONG nPin, PKSPIN_MEDIUM pPinMedium)
{
    NTSTATUS        			ntStatus;
    UNICODE_STRING  			unicodeValueName, unicodeNumber, unicodeResult, unicodeGUID;
	ULONG						ulBufLength;
	PKEY_VALUE_FULL_INFORMATION pRegistryFullInfo = NULL;
	GUID						guidPin;
	WCHAR						wchBuffer[PINMEDIA_REGISTRY_BUFFER_LENGTH];
	WCHAR						wchResultBuffer[PINMEDIA_REGISTRY_BUFFER_LENGTH];

	ENSURE 
	{
		if( hFolder == NULL)
			FAIL;

		unicodeNumber.Buffer		= wchBuffer;
		unicodeNumber.MaximumLength	= sizeof( wchBuffer);
		unicodeNumber.Length		= 0;
		ntStatus = ::RtlIntegerToUnicodeString( nPin, 10, &unicodeNumber);
		if( !NT_SUCCESS( ntStatus))
			FAIL;

		::RtlInitUnicodeString( &unicodeValueName, UNICODE_WDM_REG_PIN_NUMBER);

		unicodeResult.Buffer		= wchResultBuffer;
		unicodeResult.MaximumLength	= sizeof( wchResultBuffer);
		unicodeResult.Length		= 0;

		::RtlCopyUnicodeString( &unicodeResult,
							    &unicodeValueName);

		ntStatus = ::RtlAppendUnicodeStringToString( &unicodeResult,
													 &unicodeNumber);
		if( !NT_SUCCESS( ntStatus))
			FAIL;

		ulBufLength = 0;
		ntStatus = ::ZwQueryValueKey( hFolder,
									  &unicodeResult,
									  KeyValueFullInformation,
									  pRegistryFullInfo,
									  ulBufLength, &ulBufLength);
		//
		// This call is expected to fail. It's called only to retrieve the required
		// buffer length
		//
		if( !ulBufLength || ( ulBufLength >= sizeof( KEY_VALUE_FULL_INFORMATION) + 100))
			FAIL;

		pRegistryFullInfo = ( PKEY_VALUE_FULL_INFORMATION) \
			::ExAllocatePool( PagedPool, ulBufLength);

		if( pRegistryFullInfo == NULL)
			FAIL;

		ntStatus = ::ZwQueryValueKey( hFolder,
									  &unicodeResult,
									  KeyValueFullInformation,
									  pRegistryFullInfo,
									  ulBufLength, &ulBufLength);
		if( !NT_SUCCESS( ntStatus))
			FAIL;

		if( !pRegistryFullInfo->DataLength || !pRegistryFullInfo->DataOffset)
			FAIL;

		::RtlInitUnicodeString( &unicodeGUID,
								( WCHAR*)((( PUCHAR)pRegistryFullInfo) + pRegistryFullInfo->DataOffset));

		ntStatus = ::RtlGUIDFromString( &unicodeGUID, &guidPin);
		if( !NT_SUCCESS( ntStatus))
			FAIL;

		::RtlCopyMemory( &pPinMedium->Set,
						 ( PUCHAR)&guidPin,
						 sizeof( GUID));
		pPinMedium->Id = 0;
		pPinMedium->Flags = 0;

		::ExFreePool( pRegistryFullInfo);

		return( TRUE);

	} END_ENSURE;

	if( pRegistryFullInfo != NULL)
		::ExFreePool( pRegistryFullInfo);

	return( FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\mmconfig.cpp ===
//==========================================================================;
//
//	MMCONFIG.CPP
//		CATIMultimediaTable Class implementation.
//  Copyright (c) 1996 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//		$Date:   23 Jun 1999 11:58:20  $
//	$Revision:   1.8  $
//	  $Author:   pleung  $
//
//==========================================================================;

extern"C"
{
#include "conio.h"
#include "strmini.h"
#include "wdmdebug.h"
}

#include "wdmdrv.h"
#include "i2cgpio.h"

#include "initguid.h"
#include "mmconfig.h"

#include "atiguids.h"
#include "aticonfg.h"


/*^^*
 *		operator new
 * Purpose	: called, before the class constructor, when the class object is created
 *				by invoking the operator new
 *
 * Inputs	: UINT size_t	: size of the object to be placed
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
PVOID CATIMultimediaTable::operator new( size_t stSize)
{
	PVOID pvAllocation = NULL;

	ENSURE
	{
		if( stSize != sizeof( CATIMultimediaTable))
			FAIL;

		pvAllocation = ::ExAllocatePool( PagedPool, stSize);

	} END_ENSURE;

	return( pvAllocation);
}


/*^^*
 *		operator delete
 * Purpose	: called, after the class destructor, when the class object is killed
 *				by invoking the operator delete
 *
 * Inputs	: PVOID pvAllocation	: memory assisiated with the class object
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
void CATIMultimediaTable::operator delete( PVOID pvAllocation)
{

	if( pvAllocation != NULL)
		::ExFreePool( pvAllocation);
}


/*^^*
 *		CATIMultimediaTable()
 * Purpose	: CATIMultimediaTable Class constructor
 *
 * Inputs	: PDEVICE_OBJECT pDeviceObject		: pointer to the creator DeviceObject
 *			  GPIOINTERFACE * pGPIOInterface	: pointer to GPIO Interface
 *			  PBOOL pbResult					: pointer to return success indicator
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
CATIMultimediaTable::CATIMultimediaTable( PDEVICE_OBJECT	pDeviceObject,
										  GPIOINTERFACE *	pGPIOInterface,
										  PBOOL				pbResult)
{
	GPIOControl					gpioAccessBlock;
	ATI_QueryPrivateInterface	pfnQueryInterface;
	BOOL						bResult = FALSE;

	m_ulRevision = ( DWORD)-1;
	m_ulSize = 0;
	m_pvConfigurationData = NULL;

	// Let's get MultiMedia data using private interfaces exposed by MiniVDD via
	// the standard Microsoft-defined GPIO interface
	ENSURE
	{
		if( !QueryGPIOProvider( pDeviceObject, pGPIOInterface, &gpioAccessBlock))
			FAIL;

		if( !::IsEqualGUID( ( const struct _GUID &)gpioAccessBlock.PrivateInterfaceType,
							( const struct _GUID &)GUID_ATI_PRIVATE_INTERFACES_QueryInterface))
			FAIL;

		pfnQueryInterface = ( ATI_QueryPrivateInterface)gpioAccessBlock.PrivateInterface;

		if( pfnQueryInterface == NULL)
			FAIL;

		if( !GetMultimediaInfo_IConfiguration2( pDeviceObject,
												pfnQueryInterface))
		{
		    OutputDebugError(( "CATIMultimediaTable constructor fails to access IConfiguration2 for pDO = %x\n",
				pDeviceObject));

			if( !GetMultimediaInfo_IConfiguration1( pDeviceObject,
													pfnQueryInterface))
			{
			    OutputDebugError(( "CATIMultimediaTable constructor fails to access IConfiguration1 for pDO = %x\n",
					pDeviceObject));

				if( !GetMultimediaInfo_IConfiguration( pDeviceObject,
													   pfnQueryInterface))
				{
				    OutputDebugError(( "CATIMultimediaTable constructor fails to access IConfiguration for pDO = %x\n",
						pDeviceObject));

					FAIL;
				}
			}
		}

		bResult = TRUE;

	} END_ENSURE;

	* pbResult = bResult;
}


/*^^*
 *		CATIMultimediaTable()
 * Purpose	: CATIMultimediaTable Class destructor
 *
 * Inputs	: none
 *
 * Outputs	: none
 * Author	: IKLEBANOV
 *^^*/
CATIMultimediaTable::~CATIMultimediaTable()

{

	if( m_pvConfigurationData != NULL)
	{
		::ExFreePool( m_pvConfigurationData);
		m_pvConfigurationData = NULL;
	}

	m_ulSize = 0;
	m_ulRevision = ( DWORD)-1;
}


/*^^*
 *		GetMultimediaInfo_IConfiguration2()
 * Purpose	: Get ATI Multimedia table, using IConfiguration2 interface
 *
 * Inputs	: PDEVICE_OBJECT pDeviceObject					: pointer to the creator DeviceObject
 *			  ATI_QueryPrivateInterface	pfnQueryInterface	: pointer to Query interface function
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::GetMultimediaInfo_IConfiguration2( PDEVICE_OBJECT				pDeviceObject,
															 ATI_QueryPrivateInterface	pfnQueryInterface)
{
	BOOL										bResult = FALSE;
	ATI_PRIVATE_INTERFACE_CONFIGURATION_Two		iConfigurationTwo;
	PATI_PRIVATE_INTERFACE_CONFIGURATION_Two	pIConfigurationTwo = &iConfigurationTwo;

	ENSURE
	{
		iConfigurationTwo.usSize = sizeof( ATI_PRIVATE_INTERFACE_CONFIGURATION_Two);
		pfnQueryInterface( pDeviceObject,
						   ( const struct _GUID &)GUID_ATI_PRIVATE_INTERFACES_Configuration_Two,
						   ( PVOID *)&pIConfigurationTwo);

		if(( pIConfigurationTwo == NULL)								||
			( pIConfigurationTwo->pfnGetConfigurationRevision == NULL)	||
			( pIConfigurationTwo->pfnGetConfigurationData == NULL))
			FAIL;

		//let's query GetConfigurationRevision Interface member first
		if( !( NT_SUCCESS( pIConfigurationTwo->pfnGetConfigurationRevision( pIConfigurationTwo->pvContext,
																			ATI_BIOS_CONFIGURATIONTABLE_MULTIMEDIA,
																			&m_ulRevision))))
			FAIL;

		if( !( NT_SUCCESS( pIConfigurationTwo->pfnGetConfigurationData( pIConfigurationTwo->pvContext,
																		ATI_BIOS_CONFIGURATIONTABLE_MULTIMEDIA,
																		NULL,
																		&m_ulSize))))
			FAIL;

		m_pvConfigurationData = ( PUCHAR)::ExAllocatePool( PagedPool, m_ulSize);
		if( m_pvConfigurationData == NULL)
			FAIL;

		if( !( NT_SUCCESS( pIConfigurationTwo->pfnGetConfigurationData( pIConfigurationTwo->pvContext,
																		ATI_BIOS_CONFIGURATIONTABLE_MULTIMEDIA,
																		m_pvConfigurationData,
																		&m_ulSize))))
			FAIL;

		bResult = TRUE;

	} END_ENSURE;

	return( bResult);
}


/*^^*
 *		GetMultimediaInfo_IConfiguration1()
 * Purpose	: Get ATI Multimedia table, using IConfiguration1 interface
 *
 * Inputs	: PDEVICE_OBJECT pDeviceObject					: pointer to the creator DeviceObject
 *			  ATI_QueryPrivateInterface	pfnQueryInterface	: pointer to Query interface function
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::GetMultimediaInfo_IConfiguration1( PDEVICE_OBJECT				pDeviceObject,
															 ATI_QueryPrivateInterface	pfnQueryInterface)
{
	BOOL										bResult = FALSE;
	ATI_PRIVATE_INTERFACE_CONFIGURATION_One		iConfigurationOne;
	PATI_PRIVATE_INTERFACE_CONFIGURATION_One	pIConfigurationOne = &iConfigurationOne;

	ENSURE
	{
		iConfigurationOne.usSize = sizeof( ATI_PRIVATE_INTERFACE_CONFIGURATION_One);
		pfnQueryInterface( pDeviceObject,
						   ( const struct _GUID &)GUID_ATI_PRIVATE_INTERFACES_Configuration_One,
						   ( PVOID *)&pIConfigurationOne);

		if(( pIConfigurationOne == NULL) ||
			( pIConfigurationOne->pfnGetMultimediaConfiguration == NULL))
			FAIL;

		if( !( NT_SUCCESS( pIConfigurationOne->pfnGetMultimediaConfiguration( pIConfigurationOne->pvContext,
																			  NULL,
																			  &m_ulSize))))
			FAIL;

		if( m_ulSize != sizeof( ATI_MULTIMEDIAINFO))
			FAIL;

		m_pvConfigurationData = ( PUCHAR)::ExAllocatePool( PagedPool, m_ulSize);
		if( m_pvConfigurationData == NULL)
			FAIL;

		if( !( NT_SUCCESS( pIConfigurationOne->pfnGetMultimediaConfiguration( pIConfigurationOne->pvContext,
																			  m_pvConfigurationData,
																			  &m_ulSize))))
			FAIL;

		m_ulRevision = 0;

		bResult = TRUE;

	} END_ENSURE;

	return( bResult);
}


/*^^*
 *		GetMultimediaInfo_IConfiguration()
 * Purpose	: Get ATI Multimedia table, using IConfiguration interface
 *
 * Inputs	: PDEVICE_OBJECT pDeviceObject					: pointer to the creator DeviceObject
 *			  ATI_QueryPrivateInterface	pfnQueryInterface	: pointer to Query interface function
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::GetMultimediaInfo_IConfiguration( PDEVICE_OBJECT				pDeviceObject,
															ATI_QueryPrivateInterface	pfnQueryInterface)
{
	BOOL									bResult = FALSE;
	PATI_PRIVATE_INTERFACE_CONFIGURATION	pIConfiguration = NULL;

	ENSURE
	{
		pfnQueryInterface( pDeviceObject,
						   ( const struct _GUID &)GUID_ATI_PRIVATE_INTERFACES_Configuration,
						   ( PVOID *)&pIConfiguration);

		if(( pIConfiguration == NULL) ||
			( pIConfiguration->pfnGetMultimediaConfiguration == NULL))
			FAIL;

		if( !( NT_SUCCESS( pIConfiguration->pfnGetMultimediaConfiguration( pDeviceObject,
																		   NULL,
																		   &m_ulSize))))
			FAIL;

		if( m_ulSize != sizeof( ATI_MULTIMEDIAINFO))
			FAIL;

		m_pvConfigurationData = ( PUCHAR)::ExAllocatePool( PagedPool, m_ulSize);
		if( m_pvConfigurationData == NULL)
			FAIL;

		if( !( NT_SUCCESS( pIConfiguration->pfnGetMultimediaConfiguration( pDeviceObject,
																		   m_pvConfigurationData,
																		   &m_ulSize))))
			FAIL;

		m_ulRevision = 0;

		bResult = TRUE;

	} END_ENSURE;

	return( bResult);
}


/*^^*
 *		GetTVTunerId()
 * Purpose	: Retrieves TVTuner Id from the Multimedia configuration table
 *
 * Inputs	: PUSHORT pusTVTunerId	: pointer to return TVTuner Id
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::GetTVTunerId( PUSHORT pusTVTunerId)
{
	USHORT	usValue;
	BOOL	bResult = TRUE;

	if(( m_pvConfigurationData != NULL) && ( m_ulSize) && ( pusTVTunerId != NULL))
	{
		switch( m_ulRevision)
		{
			case 0:
				usValue = ( USHORT)(( PATI_MULTIMEDIAINFO)m_pvConfigurationData)->MMInfo_Byte0;
				break;

			case 1:
				usValue = ( USHORT)(((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte0) & 0x1F);
				break;

			default:
				bResult = FALSE;
				break;
		}
	}
	else
		bResult = FALSE;

	if( bResult)
		* pusTVTunerId = usValue;
	else
	    OutputDebugError(( "CATIMultimediaTable::GetTVTunerId() fails\n"));

	return( bResult);
}


/*^^*
 *		GetVideoDecoderId()
 * Purpose	: Retrieves Video decoder Id from the Multimedia configuration table
 *
 * Inputs	: PUSHORT pusDecoderId	: pointer to return Video decoder Id
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::GetVideoDecoderId( PUSHORT pusDecoderId)
{
	USHORT	usValue;
	BOOL	bResult = TRUE;

	if(( m_pvConfigurationData != NULL) && ( m_ulSize) && ( pusDecoderId != NULL))
	{
		switch( m_ulRevision)
		{
			case 0:
				usValue = ( USHORT)(((( PATI_MULTIMEDIAINFO)m_pvConfigurationData)->MMInfo_Byte2) & 0x07);
				break;

			case 1:
				usValue = ( USHORT)(((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte5) & 0x0F);
				break;

			default:
				bResult = FALSE;
				break;
		}
	}
	else
		bResult = FALSE;

	if( bResult)
		* pusDecoderId = usValue;
	else
	    OutputDebugError(( "CATIMultimediaTable::GetVideoDecoderId() fails\n"));

	return( bResult);
}


/*^^*
 *		GetOEMId()
 * Purpose	: Retrieves OEM Id from the Multimedia configuration table
 *
 * Inputs	: PUSHORT pusOEMId	: pointer to return OEM Id
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::GetOEMId( PUSHORT	pusOEMId)
{
	USHORT	usValue;
	BOOL	bResult = TRUE;

	if(( m_pvConfigurationData != NULL) && ( m_ulSize) && ( pusOEMId != NULL))
	{
		switch( m_ulRevision)
		{
			case 0:
				usValue = ( USHORT)((( PATI_MULTIMEDIAINFO)m_pvConfigurationData)->MMInfo_Byte4);
				break;

			case 1:
				usValue = ( USHORT)((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte2);
				break;

			default:
				bResult = FALSE;
				break;
		}
	}
	else
		bResult = FALSE;

	if( bResult)
		* pusOEMId = usValue;
	else
	    OutputDebugError(( "CATIMultimediaTable::GetOEMId() fails\n"));

	return( bResult);
}


/*^^*
 *		GetATIProductId()
 * Purpose	: Retrieves ATI Product Id from the Multimedia configuration table
 *
 * Inputs	: PUSHORT pusProductId: pointer to return Product Id
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::GetATIProductId( PUSHORT	pusProductId)
{
	USHORT	usValue;
	BOOL	bResult = TRUE;

	if(( m_pvConfigurationData != NULL) && ( m_ulSize) && ( pusProductId != NULL))
	{
		switch( m_ulRevision)
		{
			case 0:
				usValue = ( USHORT)((((( PATI_MULTIMEDIAINFO)m_pvConfigurationData)->MMInfo_Byte3) >> 4) & 0x0F);
				break;

			case 1:
				usValue = ( USHORT)((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte2);
				break;

			default:
				bResult = FALSE;
				break;
		}
	}
	else
		bResult = FALSE;

	if( bResult)
		* pusProductId = usValue;
	else
	    OutputDebugError(( "CATIMultimediaTable::GetVideoDecoderId() fails\n"));

	return( bResult);
}



/*^^*
 *		GetOEMRevisionId()
 * Purpose	: Retrieves OEM Revision Id from the Multimedia configuration table
 *
 * Inputs	: PUSHORT pusOEMRevisionId	: pointer to return OEM Revision Id
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::GetOEMRevisionId( PUSHORT	pusOEMRevisionId)
{
	USHORT	usValue;
	BOOL	bResult = TRUE;

	if(( m_pvConfigurationData != NULL) && ( m_ulSize) && ( pusOEMRevisionId != NULL))
	{
		switch( m_ulRevision)
		{
			case 0:
				usValue = ( USHORT)((( PATI_MULTIMEDIAINFO)m_pvConfigurationData)->MMInfo_Byte5);
				break;

			case 1:
				usValue = ( USHORT)((((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte1) >> 5) & 0x07);
				break;

			default:
				bResult = FALSE;
				break;
		}
	}
	else
		bResult = FALSE;

	if( bResult)
		* pusOEMRevisionId = usValue;
	else
	    OutputDebugError(( "CATIMultimediaTable::GetVideoDecoderId() fails\n"));

	return( bResult);
}


/*^^*
 *		IsATIProduct()
 * Purpose	: Returnes ATI ownership
 *
 * Inputs	: PUSHORT pusProductId: pointer to return ATI Product ownership
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::IsATIProduct( PBOOL pbATIProduct)
{
	BOOL	bATIOwnership;
	BOOL	bResult = TRUE;

	if(( m_pvConfigurationData != NULL) && ( m_ulSize) && ( pbATIProduct != NULL))
	{
		switch( m_ulRevision)
		{
			case 0:
				bATIOwnership = (( PATI_MULTIMEDIAINFO)m_pvConfigurationData)->MMInfo_Byte4 == OEM_ID_ATI;
				break;

			case 1:
				bATIOwnership = ( BOOL)(((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte1) & 0x10);
				break;

			default:
				bResult = FALSE;
				break;
		}
	}
	else
		bResult = FALSE;

	if( bResult)
		* pbATIProduct = bATIOwnership;
	else
	    OutputDebugError(( "CATIMultimediaTable::GetVideoDecoderId() fails\n"));

	return( bResult);
}


/*^^*
 *		QueryGPIOProvider()
 * Purpose	: queries the GPIOProvider for the pins supported and private interfaces
 *
 * Inputs	: PDEVICE_OBJECT pDeviceObject		: pointer to accosiated Device Object
 *			  GPIOINTERFACE * pGPIOInterface	: pointer to GPIO interface
 *			  PGPIOControl pgpioAccessBlock		: pointer to GPIO control structure
 *
 * Outputs	: BOOL : retunrs TRUE, if the query function was carried on successfully
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIMultimediaTable::QueryGPIOProvider( PDEVICE_OBJECT		pDeviceObject,
											 GPIOINTERFACE *	pGPIOInterface,
											 PGPIOControl		pgpioAccessBlock)
{

	ENSURE
	{
		if(( pGPIOInterface->gpioOpen == NULL)		|| 
			( pGPIOInterface->gpioAccess == NULL)	||
			( pDeviceObject == NULL))
			FAIL;

		pgpioAccessBlock->Status = GPIO_STATUS_NOERROR;
		pgpioAccessBlock->Command = GPIO_COMMAND_QUERY;
		pgpioAccessBlock->AsynchCompleteCallback = NULL;
        pgpioAccessBlock->Pins = NULL;

	    if(( !NT_SUCCESS( pGPIOInterface->gpioOpen( pDeviceObject, TRUE, pgpioAccessBlock))) ||
			( pgpioAccessBlock->Status != GPIO_STATUS_NOERROR))
			FAIL;

		return( TRUE);

	} END_ENSURE;

	return( FALSE);
}


/*^^*
 *		GetDigitalAudioProperties()
 * Purpose	: Gets Digital Audio support and information
 * Inputs	: Pointer to Digital Audio Info structure	
 *
 * Outputs	: BOOL : returns TRUE
 *				also sets the requested values into the input pointer
 * Author	: TOM
 *^^*/
BOOL CATIMultimediaTable::GetDigialAudioConfiguration( PDIGITAL_AUD_INFO pInput)
{
	BOOL bResult = FALSE;

	ENSURE
	{
		if (pInput == NULL)
			FAIL;
#if 1
		if (m_pvConfigurationData == NULL)
			FAIL;
	

		switch( m_ulRevision)
		{
			case 1:

			// Disable I2S in support for the time being - TL
//				pInput->bI2SInSupported  = ( BOOL)(((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte4) & 0x01);
				pInput->bI2SInSupported  = 0;
				pInput->bI2SOutSupported  = ( BOOL)(((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte4) & 0x02);
				pInput->wI2S_DAC_Device = ( WORD)((((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte4) & 0x1c) >> 2);
				pInput->bSPDIFSupported = ( BOOL)(((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte4) & 0x20);
				pInput->wReference_Clock = ( WORD)((((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte5) & 0xf0) >> 4);
				bResult = TRUE;
				break;
	
			default:
				bResult = FALSE;
				break;
		}

#else
		pInput->bI2SInSupported = TRUE;
		pInput->bI2SOutSupported = TRUE;
		pInput->wI2S_DAC_Device = TDA1309_32;
		pInput->wReference_Clock = REF_295MHZ;
		pInput->bSPDIFSupported = TRUE;
		bResult = TRUE;
#endif

	} END_ENSURE;

	return (bResult);
}


/*^^*
 *		GetVideoInCrystalId()
 * Purpose	: Retrieves Video in crystal ID from the Multimedia configuration table
 *
 * Inputs	: PUSHORT pusVInCrystalId	: pointer to return Video in crystal Id
 *
 * Outputs	: BOOL, returns TRUE, if succeeded
 * Author	: Paul
 *^^*/
BOOL CATIMultimediaTable::GetVideoInCrystalId( PUCHAR pucVInCrystalId)
{
	UCHAR	ucValue;
	BOOL	bResult = TRUE;

	if(( m_pvConfigurationData != NULL) && ( m_ulSize) && ( pucVInCrystalId != NULL))
	{
		switch( m_ulRevision)
		{
			case 0:
				ucValue = ( UCHAR)((((( PATI_MULTIMEDIAINFO)m_pvConfigurationData)->MMInfo_Byte2) & 0x18) >> 3);
				break;

			case 1:
				ucValue = ( UCHAR)((((( PATI_MULTIMEDIAINFO1)m_pvConfigurationData)->MMInfo1_Byte5) & 0xF0) >> 4);
				break;

			default:
				bResult = FALSE;
				break;
		}
	}
	else
		bResult = FALSE;

	if( bResult)
		* pucVInCrystalId = ucValue;
	else
	    OutputDebugError(( "CATIMultimediaTable::GetVideoInCrystalId() fails\n"));

	return( bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\pinmedia.h ===
//==========================================================================;
//
//	PinMedia.H
//	WDM MiniDriver development
//		AIW / AIWPro hardware platform. 
//			ATI connections GUIDs Include Module.
//  Copyright (c) 1996 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

#ifndef _PINMEDIA_H_
#define _PINMEDIA_H_


#define WDM_REG_PIN_MEDIUMS					"Mediums"
#define UNICODE_WDM_REG_PIN_MEDIUMS			L"Mediums"

#define WDM_REG_PIN_NUMBER					"Pin"
#define UNICODE_WDM_REG_PIN_NUMBER			L"Pin"

#define PINMEDIA_REGISTRY_BUFFER_LENGTH		16


/*
	TVTuner, XBar, and TVAudio Medium definitions
*/

// {F3954420-34F6-11d1-821D-0000F8300212}
#define STATIC_MEDIUM_ATIXBAR_VIDEOTUNERIN \
 0xf3954420, 0x34f6, 0x11d1,  0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12
DEFINE_GUIDSTRUCT( "F3954420-34F6-11D1-821D-0000F8300212", MEDIUM_ATIXBAR_VIDEOTUNERIN);
#define MEDIUM_ATXBAR_VIDEOTUNERIN DEFINE_GUIDNAMED( MEDIUM_ATIXBAR_VIDEOTUNERIN)


// {F3954421-34F6-11d1-821D-0000F8300212}
#define STATIC_MEDIUM_ATIXBAR_AUDIOTUNERIN \
 0xf3954421, 0x34f6, 0x11d1,  0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12 
DEFINE_GUIDSTRUCT( "F3954421-34F6-11D1-821D-0000F8300212", MEDIUM_VIDEO_ATIXBAR_AUDIOTUNERIN);
#define MEDIUM_ATXBAR_AUDIOTUNERIN DEFINE_GUIDNAMED( MEDIUM_ATIXBAR_AUDIOTUNERIN)


// {6001AFE0-39A7-11D1-821D-0000F8300212}
#define STATIC_MEDIUM_ATIXBAR_VIDEOCOMPOSITEOUT \
	0x6001afe0, 0x39a7, 0x11d1,  0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12
DEFINE_GUIDSTRUCT( "6001AFE0-39A7-11D1-821D-0000F8300212", MEDIUM_ATIXBAR_VIDEOCOMPOSITEOUT);
#define MEDIUM_ATXBAR_VIDEOCOMPOSITEOUT DEFINE_GUIDNAMED( MEDIUM_ATIXBAR_VIDEOCOMPOSITEOUT)


// {6001AFE1-39A7-11D1-821D-0000F8300212}
#define STATIC_MEDIUM_ATIXBAR_VIDEOSVIDEOOUT \
	0x6001afe1, 0x39a7, 0x11d1,  0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12
DEFINE_GUIDSTRUCT( "6001AFE1-39A7-11D1-821D-0000F8300212", MEDIUM_ATIXBAR_VIDEOSVIDEOOUT);
#define MEDIUM_ATXBAR_VIDEOSVIDEOOUT DEFINE_GUIDNAMED( MEDIUM_ATIXBAR_VIDEOSVIDEOOUT)


// {AE8F28C0-3346-11D1-821D-0000F8300212}
#define STATIC_MEDIUM_ATIXBAR_VIDEOTUNEROUT \
	0xae8f28c0, 0x3346, 0x11d1,  0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12
DEFINE_GUIDSTRUCT( "AE8F28C0-3346-11D1-821D-0000F8300212", MEDIUM_ATIXBAR_VIDEOTUNEROUT);
#define MEDIUM_ATXBAR_VIDEOTUNEROUT DEFINE_GUIDNAMED( MEDIUM_ATIXBAR_VIDEOTUNEROUT)


// {AE8F28C1-3346-11D1-821D-0000F8300212}
#define STATIC_MEDIUM_ATIXBAR_AUDIODECODEROUT \
	0xae8f28c1, 0x3346, 0x11d1,  0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12 
DEFINE_GUIDSTRUCT( "AE8F28C1-3346-11D1-821D-0000F8300212", MEDIUM_ATIXBAR_AUDIODECODEROUT);
#define MEDIUM_ATXBAR_AUDIODECODEROUT DEFINE_GUIDNAMED( MEDIUM_ATIXBAR_AUDIODECODEROUT)


// {F3954422-34F6-11D1-821D-0000F8300212}
#define STATIC_MEDIUM_ATITVTUNER_RADIOAUDIOOUT \
 0xf3954422, 0x34f6, 0x11d1,  0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12 
DEFINE_GUIDSTRUCT("F3954422-34F6-11D1-821D-0000F8300212", MEDIUM_VIDEO_ATITVTUNER_RADIOAUDIOOUT);
#define MEDIUM_ATXBAR_RADIOAUDIOOUT DEFINE_GUIDNAMED( MEDIUM_ATITVTUNER_RADIOAUDIOOUT)


// {F3954423-34F6-11d1-821D-0000F8300212}
#define STATIC_MEDIUM_ATITVTUNER_TVAUDIOOUT \
 0xf3954423, 0x34f6, 0x11d1,  0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12 
DEFINE_GUIDSTRUCT( "F3954423-34F6-11D1-821D-0000F8300212", MEDIUM_VIDEO_ATITVTUNER_TVAUDIOOUT);
#define MEDIUM_ATITVTUNER_TVAUDIOOUT DEFINE_GUIDNAMED( MEDIUM_ATITVTUNER_TVAUDIOOUT)


const KSPIN_MEDIUM ATIXBarVideoTunerInMedium =
{
	STATIC_MEDIUM_ATIXBAR_VIDEOTUNERIN,
	0,
	0
};

const KSPIN_MEDIUM ATIXBarAudioTunerInMedium =
{
	STATIC_MEDIUM_ATIXBAR_AUDIOTUNERIN,
	0,
	0
};

const KSPIN_MEDIUM ATIXBarVideoCompositeOutMedium =
{
	STATIC_MEDIUM_ATIXBAR_VIDEOCOMPOSITEOUT,
	0,
	0
};

const KSPIN_MEDIUM ATIXBarVideoSVideoOutMedium =
{
	STATIC_MEDIUM_ATIXBAR_VIDEOSVIDEOOUT,
	0,
	0
};

const KSPIN_MEDIUM ATIXBarVideoTunerOutMedium =
{
	STATIC_MEDIUM_ATIXBAR_VIDEOTUNEROUT,
	0,
	0
};

const KSPIN_MEDIUM ATIXBarAudioDecoderOutMedium =
{
	STATIC_GUID_NULL,
	0,
	0
};

const KSPIN_MEDIUM ATITVTunerRadioAudioOutMedium =
{
	STATIC_MEDIUM_ATITVTUNER_RADIOAUDIOOUT,
	0,
	0
};

const KSPIN_MEDIUM ATITVTunerTVAudioOutMedium =
{
	STATIC_MEDIUM_ATITVTUNER_TVAUDIOOUT,
	0,
	0
};

const KSPIN_MEDIUM MEDIUM_WILDCARD =
{
    STATIC_GUID_NULL,
    0,
	0
};

// compatible mediums between ATITVTuner and ATIXBar
#define ATITVTunerVideoOutMedium	ATIXBarVideoTunerInMedium
#define ATITVAudioInMedium			ATITVTunerTVAudioOutMedium			
#define ATITVAudioOutMedium			ATIXBarAudioTunerInMedium

// Pin Mediums support functions prototypes
ULONG		GetDriverInstanceNumber			( PDEVICE_OBJECT pDeviceObject);
HANDLE		OpenRegistryPinMediumFolder		( PDEVICE_OBJECT pDeviceObject, PWCHAR pwchFolderName);
BOOL		ReadPinMediumFromRegistryFolder	( HANDLE hFolder, ULONG nPin, PKSPIN_MEDIUM pMediumKSPin);


#endif	// _PINMEDIA_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\register.h ===
#pragma once

//==========================================================================;
//
//	Declarations of the RT Register manipulation classes
//
//		$Date:   11 Mar 1999 12:48:20  $
//	$Revision:   1.1  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C" {
	#include "strmini.h"
	#include "ksmedia.h"
}

#include "Provider.h"

/*
 * Type: RegisterType
 * Purpose: A type to differentiate between diferent kinds of registers.
 *   Depending on the type register may not peforms certain operations
 *   RW - read/write, RO - read-only, WO - write-only
*/
typedef enum { RW, RO, WO, RR } RegisterType;


class Register
{
public:
	Register(Provider * provider, DWORD offset, RegisterType type) :
		m_Provider(provider),
		m_dwOffset(offset),
		m_Type(type),
		m_bShadow(false) {};

	DWORD Read() {
		m_bShadow = true;
		return m_dwShadow = m_Provider->Read(m_dwOffset);
	}

	void Write(DWORD dwValue) {
		m_bShadow = true;
		m_Provider->Write(m_dwOffset, m_dwShadow = dwValue);
	}

	operator DWORD() 
	{
#if 1 //def _DEBUG
		return Read();
#else
		return m_bShadow ? m_dwShadow : Read();
#endif
	}

	DWORD operator=(DWORD dwValue) {
		Write(dwValue);
		return dwValue;
	}

private:
	static DWORD m_dwBaseAddress;

	Provider*	m_Provider;
	DWORD		m_dwOffset;
	bool		m_bShadow;
	DWORD		m_dwShadow;
	RegisterType m_Type;
};


class BitField
{
	private:
		Register&	m_Register;
		DWORD		m_FieldMask;
		BYTE		m_LowBit;

	public:
		BitField(Register& reg, DWORD fieldMask, BYTE lowBit) :
			m_Register(reg), m_FieldMask(fieldMask), m_LowBit(lowBit) {}

		operator DWORD() {
			return (m_Register & m_FieldMask) >> m_LowBit;
		}

		DWORD operator=(DWORD dwValue) { 
			m_Register = m_Register & ~m_FieldMask | dwValue << m_LowBit;
			return dwValue;
		}

		DWORD Read() {
			m_Register.Read();
			return DWORD();
		}
};


class IntField
{
	private:
		Register&	m_Register;
		DWORD		m_FieldMask;
		DWORD		m_HighBitMask;
		BYTE		m_LowBit;

	public:
		IntField(Register& reg, LONG fieldMask, BYTE lowBit, DWORD highBitMask) :
			m_Register(reg), m_FieldMask(fieldMask), m_LowBit(lowBit), m_HighBitMask(highBitMask) {}

		operator LONG() {
			if (m_HighBitMask & m_Register)
				return -1 * (((~m_Register & m_FieldMask) >> m_LowBit) + 1);
			else
				return (m_Register & m_FieldMask) >> m_LowBit;
		}

		LONG operator=(LONG lValue) {
			m_Register = (m_Register & ~m_FieldMask) | ((lValue << m_LowBit) & m_FieldMask);
			return lValue;
		}

		DWORD Read() {
			m_Register.Read();
			return LONG();
		}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\registry.h ===
//==========================================================================;
//
// File:        REGISTRY.H
//
// Purpose:     To provide Header file for ATI WDM Registry configurations
//
// Notes:       This file is provided under strict non-disclosure agreements
//              it is and remains the property of ATI Technologies Inc.
//              Any use of this file or the information it contains to
//              develop products commercial or otherwise must be with the
//              permission of ATI Technologies Inc.
//
// Copyright (C) 1997 - 1998, ATI Technologies Inc.
//
//==========================================================================;

#define REGISTRY_BUFFER_SIZE                6

#define WDM_REGISTRY_KEY                    "ATI WDM Configurations"

#define WDM_REG_MULTIMEDIA                  "ATI WDM Configurations\\Multimedia Table"
#define UNICODE_WDM_REG_MULTIMEDIA          L"ATI WDM Configurations\\Multimedia Table"

#define WDM_REG_MM_TUNER                    "Tuner Type"
#define UNICODE_WDM_REG_MM_TUNER            L"Tuner Type"

#define WDM_REG_MM_DECODER                  "Decoder Type"
#define UNICODE_WDM_REG_MM_DECODER          L"Decoder Type"

#define WDM_REG_MM_DECODER_CRYSTALS         "Decoder Crystals Type"
#define UNICODE_WDM_REG_MM_DECODER_CRYSTALS L"Decoder Crystals Type"

#define WDM_REG_MM_AUDIO                    "Audio Chip Type"
#define UNICODE_WDM_REG_MM_AUDIO            L"Audio Chip Type"

#define WDM_REG_MM_OEM                      "OEM Id"
#define UNICODE_WDM_REG_MM_OEM              L"OEM Id"

#define WDM_REG_MM_ATI_PRODUCT              "ATI Product Id"
#define UNICODE_WDM_REG_MM_ATI_PRODUCT      L"ATI Product Id"

#define WDM_REG_MM_PRODUCT_REVISION         "Product Revision Id"
#define UNICODE_WDM_REG_MM_PRODUCT_REVISION L"Product Revision Id"

#define WDM_REG_MM_BYTE1                    "MMTableByte1"
#define UNICODE_WDM_REG_MM_BYTE1            L"MMTableByte1"

#define WDM_REG_MM_BYTE6                    "MMTableByte6"
#define UNICODE_WDM_REG_MM_BYTE6            L"MMTableByte6"

#define WDM_REG_MM_BYTE7                    "MMTableByte7"
#define UNICODE_WDM_REG_MM_BYTE7            L"MMTableByte7"

#define WDM_REG_I2C                         "ATI WDM Configurations\\I2C Configuration"
#define UNICODE_WDM_REG_I2C                 L"ATI WDM Configurations\\I2C Configuration"

#define WDM_REG_I2C_METHOD                  "I2C Method"
#define UNICODE_WDM_REG_I2C_METHOD          L"I2C Method"

#define WDM_REG_TVOUT                       "ATI WDM Configurations\\TVOut Configuration"
#define UNICODE_WDM_REG_TVOUT               L"ATI WDM Configurations\\TVOut Configuration"

#define WDM_REG_TVOUT_INFO                  "TVOut Information"
#define UNICODE_WDM_REG_TVOUT_INFO          L"TVOut Information"

#define WDM_DEBUGLEVEL_INFO                 "DebugLevel"
#define UNICODE_WDM_DEBUGLEVEL_INFO         L"DebugLevel"

#define WDM_DRIVER_NAME                     "NTMPDriver"
#define UNICODE_WDM_DRIVER_NAME             L"NTMPDriver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\wdmdebug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;


#ifndef _WDMDEBUG_H_
#define _WDMDEBUG_H_

#define TRAP DEBUG_BREAKPOINT();

// global variables
extern "C" ULONG	g_DebugLevel;


#define OutputDebugTrace(x)	{ if( g_DebugLevel >= MINIDRIVER_DEBUGLEVEL_MESSAGE)	DbgPrint x; }

#define OutputDebugInfo(x)	{ if( g_DebugLevel >= MINIDRIVER_DEBUGLEVEL_INFO)	DbgPrint x; }

#define OutputDebugError(x)	{ if( g_DebugLevel >= MINIDRIVER_DEBUGLEVEL_ERROR)	DbgPrint x; }


#endif // #ifndef _WDMDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\capdebug.h ===
#pragma once

//==========================================================================;
//
//	WDM Video Decoder debug tools
//
//		$Date:   05 Aug 1998 11:22:36  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;


#ifdef DEBUG

#include "debugdef.h"

#ifdef _X86_
#define TRAP()          __asm int 3
#else
#define TRAP()          KdBreakPoint()
#endif

extern "C" ULONG g_DebugLevel;

#define DBGPRINTF(x)    {KdPrint(x);}
#define DBGERROR(x)     {KdPrint((DBG_COMPONENT)); KdPrint(x);}
#define DBGWARN(x)      {if (g_DebugLevel >= 1) {KdPrint((DBG_COMPONENT)); KdPrint(x);}}
#define DBGINFO(x)      {if (g_DebugLevel >= 2) {KdPrint((DBG_COMPONENT)); KdPrint(x);}}
#define DBGTRACE(x)     {if (g_DebugLevel >= 3) {KdPrint((DBG_COMPONENT)); KdPrint(x);}}

#else

#define TRAP()

#define DBGPRINTF(x)
#define DBGERROR(x)
#define DBGWARN(x)
#define DBGINFO(x)
#define DBGTRACE(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\registry.cpp ===
//==========================================================================;
//
//  Registry.CPP
//  WDM MiniDrivers development.
//      Global space.
//          Registry data management.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//      $Date:   15 Apr 1999 11:08:06  $
//  $Revision:   1.6  $
//    $Author:   Tashjian  $
//
//==========================================================================;

#include "common.h"

#include "registry.h"


ULONG   g_DebugLevel;
PCHAR   g_DebugComponent = WDM_DRIVER_NAME " not set in registry: ";


/*^^*
 *      OpenRegistryFolder()
 * Purpose  : Gets the specified Registry folder handle ( opens the folder) to be used later on
 *
 * Inputs   : PDEVICE_OBJECT pDeviceObject  : pointer to DeviceObject
 *            PWCHAR pwchFolderName         : name of the Registry folder to open, might be NULL
 * Outputs  : HANDLE, NULL if the Registry folder has not been opened
 * Author   : IKLEBANOV
 *^^*/
HANDLE OpenRegistryFolder( PDEVICE_OBJECT pDeviceObject, PWCHAR pwchFolderName)
{
    HANDLE              hFolder, hDevice;
    NTSTATUS            ntStatus;
    UNICODE_STRING      FolderName;
    OBJECT_ATTRIBUTES   attr;

    hFolder = hDevice = NULL;

    ENSURE
    {
        ntStatus = ::IoOpenDeviceRegistryKey( pDeviceObject,
                                              PLUGPLAY_REGKEY_DRIVER, STANDARD_RIGHTS_ALL,
                                              &hDevice);

        if( !NT_SUCCESS( ntStatus) || ( hDevice == NULL))
            FAIL;

        if( pwchFolderName != NULL)
        {
            ::RtlInitUnicodeString( &FolderName, pwchFolderName);
            InitializeObjectAttributes( &attr, &FolderName, OBJ_INHERIT|OBJ_KERNEL_HANDLE, hDevice, NULL);

            ntStatus = ::ZwOpenKey( &hFolder, KEY_QUERY_VALUE, &attr);
            ::ZwClose( hDevice);

            if( !NT_SUCCESS( ntStatus)) 
                FAIL;
        }
        else
            hFolder = hDevice;

        return( hFolder);

    } END_ENSURE;

    return( NULL);
}



/*^^*
 *      SetMiniDriverDebugLevel()
 * Purpose  : Sets the Debugging level required by user
 *
 * Inputs   : PUNICODE_STRING pRegistryPath : MiniDriver's private Registry path
 * Outputs  : none
 *
 * Author   : IKLEBANOV
 *^^*/
extern "C"
void SetMiniDriverDebugLevel( PUNICODE_STRING pRegistryPath)
{
    OBJECT_ATTRIBUTES   objectAttributes;
    HANDLE              hFolder;
    ULONG               ulValue;
    WCHAR               wcDriverName[20];

    // Set the default value as no Debug
    g_DebugLevel = 0;

    InitializeObjectAttributes( &objectAttributes, 
                                pRegistryPath, 
                                OBJ_CASE_INSENSITIVE, 
                                NULL, 
                                NULL); 

    if( NT_SUCCESS( ZwOpenKey( &hFolder, KEY_READ, &objectAttributes)))
    {
        ulValue = 0;

        if( NT_SUCCESS( ReadStringFromRegistryFolder( hFolder,
                                                      UNICODE_WDM_DEBUGLEVEL_INFO,
                                                      ( PWCHAR)&ulValue,
                                                      sizeof( ULONG))))
            g_DebugLevel = ulValue;

        // fetch the driver name from the registry
        if( NT_SUCCESS( ReadStringFromRegistryFolder( hFolder,
                                                      UNICODE_WDM_DRIVER_NAME,
                                                      wcDriverName,
                                                      sizeof(wcDriverName)))) {

            // set g_DebugComponent by using driver name
            ANSI_STRING     stringDriverName;
            UNICODE_STRING  unicodeDriverName;

            // convert unicode driver name to ansi
            RtlInitAnsiString(&stringDriverName, g_DebugComponent);
            RtlInitUnicodeString(&unicodeDriverName, wcDriverName);
            RtlUnicodeStringToAnsiString(&stringDriverName, &unicodeDriverName, FALSE);

            // remove extension and put a colon 
            PCHAR pExt = strchr(g_DebugComponent, '.');
            if (pExt) {
                *pExt++ = ':';
                *pExt++ = ' ';
                *pExt   = 0;
            }

            // convert to upper case (or lower case... whatever your fancy)
            //_strupr(g_DebugComponent);  
            //_strlwr(g_DebugComponent);  
        }
        ZwClose( hFolder);
    }

}



/*^^*
 *      ReadStringFromRegistryFolder
 * Purpose  : Read ASCII string from the Registry folder
 *
 * Inputs   : HANDLE hFolder            : Registry folder handle to read the values from
 *            PWCHAR pwcKeyNameString   : pointer to the StringValue to read
 *            PWCHAR pwchBuffer         : pointer to the buffer to read into
 *            ULONG ulDataLength        : length of the data to be expected to read
 *
 * Outputs  : NTSTATUS of the registry read operation
 * Author   : IKLEBANOV
 *^^*/
NTSTATUS ReadStringFromRegistryFolder( HANDLE hFolder, PWCHAR pwcKeyNameString, PWCHAR pwchBuffer, ULONG ulDataLength)
{
    NTSTATUS                    ntStatus = STATUS_UNSUCCESSFUL;
    UNICODE_STRING              unicodeKeyName;
    ULONG                       ulLength;
    PKEY_VALUE_FULL_INFORMATION FullInfo;

    ENSURE 
    {
        ::RtlInitUnicodeString( &unicodeKeyName, pwcKeyNameString);

        ulLength = sizeof( KEY_VALUE_FULL_INFORMATION) + unicodeKeyName.MaximumLength + ulDataLength;

        FullInfo = ( PKEY_VALUE_FULL_INFORMATION)::ExAllocatePool( PagedPool, ulLength);

        if( FullInfo) 
        {
            ntStatus = ::ZwQueryValueKey( hFolder,
                                          &unicodeKeyName,
                                          KeyValueFullInformation,
                                          FullInfo,
                                          ulLength,
                                          &ulLength);

            if( NT_SUCCESS( ntStatus)) 
            {
                if( ulDataLength >= FullInfo->DataLength) 
                    RtlCopyMemory( pwchBuffer, (( PUCHAR)FullInfo) + FullInfo->DataOffset, FullInfo->DataLength);
                else 
                {
                    TRAP;
                    ntStatus = STATUS_BUFFER_TOO_SMALL;
                } // buffer right length

            } // if success

            ::ExFreePool( FullInfo);
        }
        else
        {
            ntStatus = STATUS_NO_MEMORY;
        }

    } END_ENSURE;

    return( ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\tda9850.h ===
//==========================================================================;
//
//	TDA9850.H
//	WDM TVAudio MiniDriver.
//		AIW / AIWPro hardware platform. 
//			Philips TDA9850 Stereo/SAP decoder Include Module.
//  Copyright (c) 1996 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

#ifndef _ATIAUDIO_TDA9850_H_
#define _ATIAUDIO_TDA9850_H_

enum
{
	AUDIO_TDA9850_Reg_Control1 = 0x04,
	AUDIO_TDA9850_Reg_Control2,
	AUDIO_TDA9850_Reg_Control3,
	AUDIO_TDA9850_Reg_Control4,
	AUDIO_TDA9850_Reg_Align1,
	AUDIO_TDA9850_Reg_Align2,
	AUDIO_TDA9850_Reg_Align3

};

// Control3 register definitions
#define AUDIO_TDA9850_Control_SAP				0x80
#define AUDIO_TDA9850_Control_Stereo			0x40
#define AUDIO_TDA9850_Control_SAP_Mute			0x10
#define AUDIO_TDA9850_Control_Mute				0x08

// Status register definitions
#define AUDIO_TDA9850_Indicator_Stereo			0x20
#define AUDIO_TDA9850_Indicator_SAP				0x40


#define AUDIO_TDA9850_Control1_DefaultValue		0x0F		// stereo 16
#define AUDIO_TDA9850_Control2_DefaultValue		0x0F		// sap 16
#define AUDIO_TDA9850_Control3_DefaultValue		AUDIO_TDA9850_Control_Stereo		// stereo, no mute
#define AUDIO_TDA9850_Control4_DefaultValue		0x07		// +2.5
#define AUDIO_TDA9850_Align1_DefaultValue		0x00		// normal gain
#define AUDIO_TDA9850_Align2_DefaultValue		0x00		// normal gain
#define AUDIO_TDA9850_Align3_DefaultValue		0x03		// stereo decoder operation mode / nominal

#endif // _ATIAUDIO_TDA9850_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\tda9851.h ===
//==========================================================================;
//
//	TDA98501.H
//	WDM TVAudio MiniDriver.
//		AIW / AIWPro hardware platform. 
//			Philips TDA9851 Stereo decoder Include Module.
//  Copyright (c) 1996 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//		$Date:   15 Apr 1998 14:05:54  $
//	$Revision:   1.1  $
//	  $Author:   KLEBANOV  $
//
//==========================================================================;

#ifndef _ATIAUDIO_TDA9851_H_
#define _ATIAUDIO_TDA9851_H_

// TDA9851 CONTROL SETTINGS:                                    
#define	TDA9851_AU_MODE_MASK			0xFE	// Mask for Audio Mode Selection (Bit0)
#define	TDA9851_STEREO					0x01	// Set Stereo
#define	TDA9851_MONO					0x00	// Set Mono	
#define	TDA9851_STEREO_DETECTED			0x01 	// Stereo is detected.

#define	TDA9851_MUTE_MASK				0xFD	// Mask for Mute on TDA9851.(Bit1)
#define	TDA9851_MUTE					0x02    // Mute   at OUTR and OUTL.
#define	TDA9851_UNMUTE					0x00    // Unmute at OUTR and OUTL.

#define	TDA9851_AVL_MASK				0xFB	// Mask for AVL. (Bit2)
#define	TDA9851_AVL_ON					0x04	// Auto Volume Level Addjustment ON.
#define	TDA9851_AVL_OFF					0x00	// Auto Volume Level Addjustment OFF.
                                             
#define	TDA9851_CCD_MASK				0xF7	// Mask for CCD bit setting. (Bit3)
#define	TDA9851_NORMAL_CURRENT			0x00	// Load current for normal AVL decay.
#define	TDA9851_INCREASED_CURRENT		0x08	// Increased load current.           

#define TDA9851_AVL_ATTACK_MASK			0xCF	// Mask for AVL ATTACK. (Bit4,5)
#define	TDA9851_AVL_ATTACK_420			0x00	// AVL Attack time 420  ohm.
#define	TDA9851_AVL_ATTACK_730			0x10    // AVL Attack time 730  ohm.
#define	TDA9851_AVL_ATTACK_1200			0x20    // AVL Attack time 1200 ohm.
#define	TDA9851_AVL_ATTACK_2100			0x30	// AVL Attack time 2100 ohm.

					 
#define AUDIO_TDA9851_DefaultValue		( TDA9851_AVL_ATTACK_730	|	\
										  TDA9851_STEREO)

// Status register definitions
#define AUDIO_TDA9851_Indicator_Stereo	0x01

#define	AUDIO_TDA9851_Control_Stereo	TDA9851_STEREO

#endif // _ATIAUDIO_TDA9851_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\atishare\wdmdrv.h ===
//==========================================================================;
//
//	WDMDRV.H
//	WDM Capture Class Driver definitions. 
//		Main Include Module.
//  Copyright (c) 1996 - 1998  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

#ifndef _WDMDRV_H_
#define _WDMDRV_H_


#define ENSURE		do
#define END_ENSURE	while( FALSE)
#define FAIL		break

// WDM MiniDriver Error codes
#define WDMMINI_NOERROR					0x0000
#define WDMMINI_INVALIDPARAM			0x0010
#define WDMMINI_NOHARDWARE				0x0020
#define WDMMINI_UNKNOWNHARDWARE			0x0021
#define WDMMINI_HARDWAREFAILURE			0x0022
#define WDMMINI_ERROR_NOI2CPROVIDER		0x0040
#define WDMMINI_ERROR_NOGPIOPROVIDER	0x0041
#define WDMMINI_ERROR_MEMORYALLOCATION	0x0080

// global space functions definition
ULONG		GetDriverInstanceNumber			( PDEVICE_OBJECT pDeviceObject);
HANDLE		OpenRegistryFolder				( PDEVICE_OBJECT pDeviceObject, PWCHAR pwchFolderName);
NTSTATUS	ReadStringFromRegistryFolder	( HANDLE hFolder, PWCHAR pwcKeyNameString, PWCHAR pwchBuffer, ULONG ulDataLength);
void		OutputDebugMessage				( ULONG ulDebugLevel, PCCHAR DebugMessage, ...);
											 
extern "C"
void		SetMiniDriverDebugLevel			( PUNICODE_STRING pRegistryPath);

// DebugLevel
#define MINIDRIVER_DEBUGLEVEL_ERROR		0x0001
#define MINIDRIVER_DEBUGLEVEL_INFO		0x0003
#define MINIDRIVER_DEBUGLEVEL_MESSAGE	0x0005


#endif	// _WDMDRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\capstrm.h ===
#pragma once

//==========================================================================;
//
//	CWDMCaptureStream - Capture Stream base class declarations
//
//		$Date:   22 Feb 1999 15:48:16  $
//	$Revision:   1.1  $
//	  $Author:   KLEBANOV  $
//
// $Copyright:	(c) 1997 - 1999  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "i2script.h"
#include "aticonfg.h"

#include "VidStrm.h"


typedef enum {
    ChangeComplete,
    Starting,
    Closing,
    Running,
    Pausing,
    Stopping,
    Initializing
};


#define DD_OK 0


class CWDMCaptureStream : public CWDMVideoStream
{
public:
	CWDMCaptureStream(PHW_STREAM_OBJECT pStreamObject,
						CWDMVideoDecoder * pCWDMVideoDecoder,
						PUINT puiErrorCode)
		:	CWDMVideoStream(pStreamObject, pCWDMVideoDecoder, puiErrorCode) {}

	void Startup(PUINT puiErrorCode);
	void Shutdown();

	VOID STREAMAPI VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
	void TimeoutPacket(IN OUT PHW_STREAM_REQUEST_BLOCK pSrb);

	VOID VideoSetState(PHW_STREAM_REQUEST_BLOCK, BOOL bVPConnected, BOOL bVPVBIConnected);
	VOID VideoGetProperty(PHW_STREAM_REQUEST_BLOCK);

	VOID VideoStreamGetConnectionProperty (PHW_STREAM_REQUEST_BLOCK);
	VOID VideoStreamGetDroppedFramesProperty(PHW_STREAM_REQUEST_BLOCK);

	VOID DataLock(PKIRQL pIrql) {
	    KeAcquireSpinLock(&m_streamDataLock, pIrql);
	}

	VOID DataUnLock(KIRQL Irql) {
	    KeReleaseSpinLock(&m_streamDataLock, Irql);
	}

	void CloseCapture();

	void CancelPacket( PHW_STREAM_REQUEST_BLOCK);

protected:
    UINT                        m_stateChange;

    KSPIN_LOCK                  m_streamDataLock;

    // Incoming SRBs go here
    LIST_ENTRY                  m_incomingDataSrbQueue;

    // SRBs in DDraw-land are moved to this queue
    LIST_ENTRY                  m_waitQueue;

    // During some state transitions, we need to 
    // temporarily move SRBs here (purely for the
    // purpose of reordering them) before being
    // returned to the incomingDataSrbQueue.
    LIST_ENTRY                  m_reversalQueue;

    // for synchronizing state changes
    KEVENT                      m_specialEvent;
    KEVENT                      m_SrbAvailableEvent;
    KEVENT                      m_stateTransitionEvent;
    
    // We get this from Ddraw
    HANDLE                      m_hCapture;

private:

	BOOL FlushBuffers();
	BOOL ResetFieldNumber();
	BOOL ReleaseCaptureHandle();
	VOID EmptyIncomingDataSrbQueue();
	VOID HandleStateTransition();
	void AddBuffersToDirectDraw();
	BOOL AddBuffer(PHW_STREAM_REQUEST_BLOCK);
	VOID HandleBusmasterCompletion(PHW_STREAM_REQUEST_BLOCK);
	VOID TimeStampSrb(PHW_STREAM_REQUEST_BLOCK);

	virtual void ResetFrameCounters() = 0;
	virtual ULONG GetFrameSize() = 0;
	virtual void GetDroppedFrames(PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames) = 0;
	virtual BOOL GetCaptureHandle() = 0;
	virtual ULONG GetFieldInterval() = 0;
	virtual void SetFrameInfo(PHW_STREAM_REQUEST_BLOCK) = 0;

	void ThreadProc();
	static void ThreadStart(CWDMCaptureStream *pStream)
			{	pStream->ThreadProc();	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\capvbi.cpp ===
//==========================================================================;
//
//	CWDMVBICaptureStream - VBI Capture Stream class implementation
//
//		$Date:   05 Aug 1998 11:11:20  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "ddkmapi.h"
}

#include "wdmvdec.h"
#include "wdmdrv.h"
#include "aticonfg.h"
#include "capdebug.h"
#include "defaults.h"


CWDMVBICaptureStream::CWDMVBICaptureStream(PHW_STREAM_OBJECT pStreamObject,
						CWDMVideoDecoder * pCWDMVideoDecoder,
						PKSDATAFORMAT pKSDataFormat,
						PUINT puiErrorCode)
		:	CWDMCaptureStream(pStreamObject, pCWDMVideoDecoder, puiErrorCode)
{
    m_stateChange = Initializing;

	DBGTRACE(("CWDMVBICaptureStream::Startup()\n"));

    PKS_DATAFORMAT_VBIINFOHEADER  pVBIInfoHeader = 
                (PKS_DATAFORMAT_VBIINFOHEADER) pKSDataFormat;

    PKS_VBIINFOHEADER     pVBIInfoHdrRequested = 
                &pVBIInfoHeader->VBIInfoHeader;
    
    DBGINFO(("pVBIInfoHdrRequested->StartLine = %d\n", pVBIInfoHdrRequested->StartLine));
    DBGINFO(("pVBIInfoHdrRequested->EndLine = %d\n", pVBIInfoHdrRequested->EndLine));
    DBGINFO(("pVBIInfoHdrRequested->MinLineStartTime = %d\n", pVBIInfoHdrRequested->MinLineStartTime));
    DBGINFO(("pVBIInfoHdrRequested->MaxLineStartTime = %d\n", pVBIInfoHdrRequested->MaxLineStartTime));
    DBGINFO(("pVBIInfoHdrRequested->ActualLineStartTime = %d\n", pVBIInfoHdrRequested->ActualLineStartTime));
    DBGINFO(("pVBIInfoHdrRequested->VideoStandard = 0x%x\n", pVBIInfoHdrRequested->VideoStandard));
    DBGINFO(("pVBIInfoHdrRequested->SamplesPerLine = %d\n", pVBIInfoHdrRequested->SamplesPerLine));
    DBGINFO(("pVBIInfoHdrRequested->StrideInBytes = %d\n", pVBIInfoHdrRequested->StrideInBytes));
    DBGINFO(("pVBIInfoHdrRequested->BufferSize = %d\n", pVBIInfoHdrRequested->BufferSize));

	m_pVBIInfoHeader = &m_VBIFrameInfo.VBIInfoHeader;

    // Copy the VBIINFOHEADER requested to our storage
    RtlCopyMemory(
            m_pVBIInfoHeader,
            pVBIInfoHdrRequested,
            sizeof(KS_VBIINFOHEADER));

	Startup(puiErrorCode);
}

CWDMVBICaptureStream::~CWDMVBICaptureStream()
{
	DBGTRACE(("CWDMVBICaptureStream::~CWDMVBICaptureStream()\n"));
	Shutdown();
}


BOOL CWDMVBICaptureStream::GetCaptureHandle()
{    

    if (m_hCapture == 0)
    {
        DBGTRACE(("Stream %d getting capture handle\n", m_pStreamObject->StreamNumber));
        
        DDOPENVPCAPTUREDEVICEIN  ddOpenCaptureIn;
        DDOPENVPCAPTUREDEVICEOUT ddOpenCaptureOut;

        RtlZeroMemory(&ddOpenCaptureIn, sizeof(ddOpenCaptureIn));
        RtlZeroMemory(&ddOpenCaptureOut, sizeof(ddOpenCaptureOut));

        ddOpenCaptureIn.hDirectDraw = m_pVideoPort->GetDirectDrawHandle();
        ddOpenCaptureIn.hVideoPort = m_pVideoPort->GetVideoPortHandle();
        ddOpenCaptureIn.pfnCaptureClose = DirectDrawEventCallback;
        ddOpenCaptureIn.pContext = this;

        if ((!ddOpenCaptureIn.hDirectDraw)||
            (!ddOpenCaptureIn.hVideoPort)||
            (!ddOpenCaptureIn.pfnCaptureClose)||
            (!ddOpenCaptureIn.pContext))
        {
            return FALSE;
        }
        // Now to get the size, etc
		int xOrigin, yOrigin;
		m_pDevice->GetVBISurfaceOrigin(&xOrigin, &yOrigin);
        ddOpenCaptureIn.dwStartLine = 0 + yOrigin;
        ddOpenCaptureIn.dwEndLine = NTSCVBILines - 1 + yOrigin;

        // Fail-safe
        if (ddOpenCaptureIn.dwStartLine > 500)
        {
            DBGERROR(("Unexpected VBI start line = %d. Using default\n"));
            ddOpenCaptureIn.dwStartLine = m_pVBIInfoHeader->StartLine - VREFDiscard - 1;

        }

        if (ddOpenCaptureIn.dwEndLine > 500)
        {
            DBGERROR(("Unexpected VBI end line. Using default\n"));
            ddOpenCaptureIn.dwEndLine = m_pVBIInfoHeader->EndLine - VREFDiscard - 1;
        }

        DBGINFO(("VBI surface: %d, %d\n",
            ddOpenCaptureIn.dwStartLine,
            ddOpenCaptureIn.dwEndLine));

        ddOpenCaptureIn.dwFlags = DDOPENCAPTURE_VBI;
        ddOpenCaptureIn.dwCaptureEveryNFields = 1;
            
        DxApi(DD_DXAPI_OPENVPCAPTUREDEVICE, &ddOpenCaptureIn, sizeof(ddOpenCaptureIn), &ddOpenCaptureOut, sizeof(ddOpenCaptureOut));

        if (ddOpenCaptureOut.ddRVal != DD_OK)
        {
            m_hCapture = 0;
            DBGERROR(("DD_DXAPI_OPENVPCAPTUREDEVICE failed.\n"));
            // TRAP();
            return FALSE;
        }
        else
        {
            m_hCapture = ddOpenCaptureOut.hCapture;
        }
    }
    return TRUE;
}   


VOID CWDMVBICaptureStream::SetFrameInfo(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSRB_DATA_EXTENSION      pSrbExt = (PSRB_DATA_EXTENSION)pSrb->SRBExtension;
    PKSSTREAM_HEADER    pDataPacket = pSrb->CommandData.DataBufferArray;
    
    LONGLONG droppedThisTime = 0;
    PKS_VBI_FRAME_INFO  pFrameInfo = (PKS_VBI_FRAME_INFO) (pDataPacket + 1);

    m_VBIFrameInfo.dwFrameFlags = 0;
    m_VBIFrameInfo.ExtendedHeaderSize = pFrameInfo->ExtendedHeaderSize;

    // Set the discontinuity flag if frames have been previously dropped.
    if ((m_VBIFrameInfo.PictureNumber + 1) <
        pSrbExt->ddCapBuffInfo.dwFieldNumber)
    {
        droppedThisTime =
        pSrbExt->ddCapBuffInfo.dwFieldNumber -
        (m_VBIFrameInfo.PictureNumber + 1);
        m_VBIFrameInfo.DropCount += droppedThisTime;
        pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
#ifdef DEBUG
        static int j;
        DBGERROR((" D%d ", droppedThisTime));
        if ((++j % 10) == 0)
        {
            DBGERROR(("\n"));
        }
#endif
    }
    m_VBIFrameInfo.PictureNumber = pSrbExt->ddCapBuffInfo.dwFieldNumber;
    m_VBIFrameInfo.dwSamplingFrequency = SamplingFrequency;

    if (m_pVideoDecoder->GetTunerInfo(&m_VBIFrameInfo.TvTunerChangeInfo))
    {
        m_VBIFrameInfo.dwFrameFlags |= KS_VBI_FLAG_TVTUNER_CHANGE;
#ifdef DEBUG
        if (m_VBIFrameInfo.TvTunerChangeInfo.dwFlags & KS_TVTUNER_CHANGE_BEGIN_TUNE)
        {
            DBGTRACE(("Sending KS_TVTUNER_CHANGE_BEGIN_TUNE.\n"));
        }
        else if (m_VBIFrameInfo.TvTunerChangeInfo.dwFlags & KS_TVTUNER_CHANGE_END_TUNE)
        {
            DBGTRACE(("Sending KS_TVTUNER_CHANGE_END_TUNE.\n"));
        }
        else
        {
            DBGERROR(("Unexpected value in TVTunerChangeInfo.dwFlags\n"));
        }
#endif
    }

    if (!m_bVBIinitialized)
    {
        m_VBIFrameInfo.dwFrameFlags |= KS_VBI_FLAG_VBIINFOHEADER_CHANGE;
		m_bVBIinitialized = TRUE;
    }

    if (pSrbExt->ddCapBuffInfo.bPolarity)
    {
        m_VBIFrameInfo.dwFrameFlags |= KS_VIDEO_FLAG_FIELD2;
    }
    else
    {
        m_VBIFrameInfo.dwFrameFlags |= KS_VIDEO_FLAG_FIELD1;
    }

    *pFrameInfo = (KS_VBI_FRAME_INFO)m_VBIFrameInfo;
}

void CWDMVBICaptureStream::ResetFrameCounters()
{
	m_VBIFrameInfo.PictureNumber = 0;
	m_VBIFrameInfo.DropCount = 0;
}

void CWDMVBICaptureStream::GetDroppedFrames(PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames)
{
	pDroppedFrames->PictureNumber = m_VBIFrameInfo.PictureNumber;
	pDroppedFrames->DropCount = m_VBIFrameInfo.DropCount;
	pDroppedFrames->AverageFrameSize = m_pVBIInfoHeader->BufferSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\capstrm.cpp ===
//==========================================================================;
//
//  CWDMCaptureStream - Capture Stream base class implementation
//
//      $Date:   22 Feb 1999 15:13:58  $
//  $Revision:   1.1  $
//    $Author:   KLEBANOV  $
//
// $Copyright:  (c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "ddkmapi.h"
}

#include "wdmvdec.h"
#include "wdmdrv.h"
#include "aticonfg.h"
#include "capdebug.h"
#include "defaults.h"
#include "winerror.h"


void CWDMCaptureStream::TimeoutPacket(IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    if (m_KSState == KSSTATE_STOP || !m_pVideoDecoder->PreEventOccurred())
    {
        DBGTRACE(("Attempting to complete Srbs.\n"));
        EmptyIncomingDataSrbQueue();
    }
}


void CWDMCaptureStream::Startup(PUINT puiErrorCode) 
{
    KIRQL Irql;
    DBGTRACE(("CWDMCaptureStream::Startup()\n"));

    KeInitializeEvent(&m_specialEvent, SynchronizationEvent, FALSE);
    KeInitializeEvent(&m_stateTransitionEvent, SynchronizationEvent, FALSE);
    KeInitializeEvent(&m_SrbAvailableEvent, SynchronizationEvent, FALSE);

    KeInitializeSpinLock(&m_streamDataLock);

    KeAcquireSpinLock(&m_streamDataLock, &Irql);

    InitializeListHead(&m_incomingDataSrbQueue);
    InitializeListHead(&m_waitQueue);
    InitializeListHead(&m_reversalQueue);

    KeReleaseSpinLock(&m_streamDataLock, Irql);
    
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    
    ASSERT(m_stateChange == Initializing);
    m_stateChange = Starting;
    
    HANDLE  threadHandle;
    NTSTATUS status = PsCreateSystemThread(&threadHandle,
                                    (ACCESS_MASK) 0L,
                                    NULL,
                                    NULL,
                                    NULL,
                                    (PKSTART_ROUTINE) ThreadStart,
                                    (PVOID) this);
    if (status != STATUS_SUCCESS)
    {
        DBGERROR(("CreateStreamThread failed\n"));
        *puiErrorCode = WDMMINI_ERROR_MEMORYALLOCATION;
        return;
    }

    // Don't need this for anything, so might as well close it now.
    // The thread will call PsTerminateThread on itself when it
    // is done.
    ZwClose(threadHandle);

    KeWaitForSingleObject(&m_specialEvent, Suspended, KernelMode, FALSE, NULL);
    ASSERT(m_stateChange == ChangeComplete);
    
    DBGTRACE(("SrbOpenStream got notification that thread started\n"));
    *puiErrorCode = WDMMINI_NOERROR;
}


void CWDMCaptureStream::Shutdown()
{
    KIRQL                   Irql;

      DBGTRACE(("CWDMCaptureStream::Shutdown()\n"));

    if ( m_stateChange != Initializing )
    {
        ASSERT(m_stateChange == ChangeComplete);
        m_stateChange = Closing;
        KeResetEvent(&m_specialEvent);
        KeSetEvent(&m_stateTransitionEvent, 0, TRUE);
        KeWaitForSingleObject(&m_specialEvent, Suspended, KernelMode, FALSE, NULL);
        ASSERT(m_stateChange == ChangeComplete);
    

        KeAcquireSpinLock(&m_streamDataLock, &Irql);
        if (!IsListEmpty(&m_incomingDataSrbQueue))
        {
            TRAP();
        }

        if (!IsListEmpty(&m_waitQueue))
        {
            TRAP();
        }
        KeReleaseSpinLock(&m_streamDataLock, Irql);
    }

    ReleaseCaptureHandle();
}


void CWDMCaptureStream::ThreadProc()
{
    PHW_STREAM_REQUEST_BLOCK pCurrentSrb = NULL;
    PSRB_DATA_EXTENSION pSrbExt = NULL;
    KEVENT DummyEvent;
    const int numEvents = 3;

    NTSTATUS status;

    // Wo unto you if you overrun this array
    PVOID eventArray[numEvents];

    KeInitializeEvent(&DummyEvent, SynchronizationEvent, FALSE);

    ASSERT(m_stateChange == Starting);

    // Indicates to SrbOpenStream() to continue
    m_stateChange = ChangeComplete;
    KeSetEvent(&m_specialEvent, 0, FALSE);

    // These should remain constant the whole time
    eventArray[0] = &m_stateTransitionEvent;
    eventArray[1] = &m_SrbAvailableEvent;

    // eventArray[2] changes, so it is set below

    // This runs until the thread terminates itself
    // inside of HandleStateTransition
    while (1)
    {
// May not be necessary
#define ENABLE_TIMEOUT
#ifdef ENABLE_TIMEOUT
        LARGE_INTEGER i;
#endif

        if (pCurrentSrb == NULL)
        {
            pSrbExt = (PSRB_DATA_EXTENSION)ExInterlockedRemoveHeadList(&m_waitQueue, &m_streamDataLock);

            if (pSrbExt)
            {
                pCurrentSrb = pSrbExt->pSrb;
                eventArray[2] = &pSrbExt->bufferDoneEvent;
            }
            else
            {
#ifdef DEBUG
                if (m_KSState == KSSTATE_RUN &&
                    m_stateChange == ChangeComplete &&
                    m_pVideoDecoder->PreEventOccurred() == FALSE)
                {
                    static int j;

                    // Indicates that we are starved for buffers. Probably
                    // a higher level is not handing them to us in a timely
                    // fashion for some reason
                    DBGPRINTF((" S "));
                    if ((++j % 10) == 0)
                    {
                        DBGPRINTF(("\n"));
                    }
                }
#endif
                pCurrentSrb = NULL;
                eventArray[2] = &DummyEvent;
            }
        }

#ifdef ENABLE_TIMEOUT
        // This is meant mainly as a failsafe measure.
        i.QuadPart = -2000000;      // 200 ms
#endif
        
        status = KeWaitForMultipleObjects(  numEvents,  // count
                                            eventArray, // DispatcherObjectArray
                                            WaitAny,    // WaitType
                                            Executive,  // WaitReason
                                            KernelMode, // WaitMode
                                            FALSE,      // Alertable
#ifdef ENABLE_TIMEOUT
                                            &i,         // Timeout (Optional)
#else
                                            NULL,
#endif
                                            NULL);      // WaitBlockArray (Optional)

        switch (status)
        {
            // State transition. May including killing this very thread
            case 0:
                if ( pCurrentSrb )
                {
                  ExInterlockedInsertHeadList( &m_waitQueue, &pSrbExt->srbListEntry, &m_streamDataLock );
                  pCurrentSrb = NULL;
                }
                HandleStateTransition();
                break;

            // New Srb available
            case 1:
                if ( pCurrentSrb )
                {
                  ExInterlockedInsertHeadList( &m_waitQueue, &pSrbExt->srbListEntry, &m_streamDataLock );
                  pCurrentSrb = NULL;
                }
                if (m_KSState == KSSTATE_RUN && m_stateChange == ChangeComplete)
                {
                    AddBuffersToDirectDraw();
                }
                break;

            // Busmaster complete
            case 2:
                if ( pCurrentSrb )
                {
                    HandleBusmasterCompletion(pCurrentSrb);
                    pCurrentSrb = NULL;
                }
                break;

#ifdef ENABLE_TIMEOUT
            // If we timeout in the RUN state, this is our chance to try again
            // to add buffers. May not be necessary, since currently, we go
            // through a state transition for DOS boxes, etc.
            case STATUS_TIMEOUT:
                if ( pCurrentSrb )
                {
                  ExInterlockedInsertHeadList( &m_waitQueue, &pSrbExt->srbListEntry, &m_streamDataLock );
                  pCurrentSrb = NULL;
                }
                if (m_KSState == KSSTATE_RUN &&
                    m_stateChange == ChangeComplete &&
                    m_pVideoDecoder->PreEventOccurred() == FALSE)
                {
                    AddBuffersToDirectDraw();
                }
                break;
#endif

            default:
                TRAP();
                break;
        }
    }
}


VOID STREAMAPI CWDMCaptureStream::VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
    KIRQL                   Irql;
    PSRB_DATA_EXTENSION          pSrbExt;

    ASSERT(pSrb->Irp->MdlAddress);
    
    DBGINFO(("Receiving SD---- SRB=%x\n", pSrb));

    pSrb->Status = STATUS_SUCCESS;

    switch (pSrb->Command) {

        case SRB_READ_DATA:

            // Rule: 
            // Only accept read requests when in either the Pause or Run
            // States.  If Stopped, immediately return the SRB.

            if ( (m_KSState == KSSTATE_STOP) || ( m_stateChange == Initializing ) ) {
                StreamClassStreamNotification(  StreamRequestComplete,
                                                pSrb->StreamObject,
                                                pSrb);
                break;
            } 

            pSrbExt = (PSRB_DATA_EXTENSION)pSrb->SRBExtension;
            RtlZeroMemory (pSrbExt, sizeof (SRB_DATA_EXTENSION));
            pSrbExt->pSrb = pSrb;
            KeInitializeEvent(&pSrbExt->bufferDoneEvent, SynchronizationEvent, FALSE);

            DBGINFO(("Adding 0x%x to data queue\n", pSrb));

            KeAcquireSpinLock(&m_streamDataLock, &Irql);
            InsertTailList(&m_incomingDataSrbQueue, &pSrbExt->srbListEntry);
            KeReleaseSpinLock(&m_streamDataLock, Irql);
            KeSetEvent(&m_SrbAvailableEvent, 0, FALSE);

            break;

        default:

            //
            // invalid / unsupported command. Fail it as such
            //

            TRAP();

            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            StreamClassStreamNotification(  StreamRequestComplete,
                                            pSrb->StreamObject,
                                            pSrb);
            break;
    }
}

/*
** VideoGetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMCaptureStream::VideoGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID (KSPROPSETID_Connection, pSPD->Property->Set)) {
        VideoStreamGetConnectionProperty (pSrb);
    }
    else if (IsEqualGUID (PROPSETID_VIDCAP_DROPPEDFRAMES, pSPD->Property->Set)) {
        VideoStreamGetDroppedFramesProperty (pSrb);
    }
    else {
       pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }
}


/*
** VideoSetState()
**
**    Sets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**    BOOL bVPVBIConnected
**    BOOL bVPConnected
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMCaptureStream::VideoSetState(PHW_STREAM_REQUEST_BLOCK pSrb, BOOL bVPConnected, BOOL bVPVBIConnected)
{
    //
    // For each stream, the following states are used:
    // 
    // Stop:    Absolute minimum resources are used.  No outstanding IRPs.
    // Pause:   Getting ready to run.  Allocate needed resources so that 
    //          the eventual transition to Run is as fast as possible.
    //          SRBs will be queued at either the Stream class or in your
    //          driver.
    // Run:     Streaming. 
    //
    // Moving to Stop or Run ALWAYS transitions through Pause, so that ONLY 
    // the following transitions are possible:
    //
    // Stop -> Pause
    // Pause -> Run
    // Run -> Pause
    // Pause -> Stop
    //
    // Note that it is quite possible to transition repeatedly between states:
    // Stop -> Pause -> Stop -> Pause -> Run -> Pause -> Run -> Pause -> Stop
    //
    BOOL bStreamCondition;

    DBGINFO(("CWDMCaptureStream::VideoSetState for stream %d\n", pSrb->StreamObject->StreamNumber));

    pSrb->Status = STATUS_SUCCESS;

    switch (pSrb->CommandData.StreamState)  
    {
        case KSSTATE_STOP:
            DBGINFO(("   state KSSTATE_STOP"));

            ASSERT(m_stateChange == ChangeComplete);
            m_stateChange = Stopping;
            FlushBuffers();
            KeResetEvent(&m_specialEvent);
            KeSetEvent(&m_stateTransitionEvent, 0, TRUE);
            KeWaitForSingleObject(&m_specialEvent, Suspended, KernelMode, FALSE, NULL);
            ASSERT(m_stateChange == ChangeComplete);
            break;

        case KSSTATE_ACQUIRE:
            DBGINFO(("   state KSSTATE_ACQUIRE"));
            ASSERT(m_KSState == KSSTATE_STOP);
            break;

        case KSSTATE_PAUSE:
            DBGINFO(("   state KSSTATE_PAUSE"));
            
            switch( pSrb->StreamObject->StreamNumber)
            {
                case STREAM_VideoCapture:
                    bStreamCondition = bVPConnected;
                    break;

                case STREAM_VBICapture:
                    bStreamCondition = bVPVBIConnected;
                    break;

                default:
                    bStreamCondition = FALSE;
                    break;
            }
            
            if( !bStreamCondition)
            {
                pSrb->Status = STATUS_UNSUCCESSFUL;
            }
            else 

            if (m_pVideoDecoder->PreEventOccurred() &&
                        (m_KSState == KSSTATE_STOP || m_KSState == KSSTATE_ACQUIRE))
            {
                pSrb->Status = STATUS_UNSUCCESSFUL;
            }
            else if (m_KSState == KSSTATE_STOP || m_KSState == KSSTATE_ACQUIRE)
            {
                ResetFrameCounters();
                ResetFieldNumber();
                
                if (!GetCaptureHandle())
                    pSrb->Status = STATUS_UNSUCCESSFUL;
            }
            else if (m_KSState == KSSTATE_RUN)
            {
                // Transitioning from run to pause
                ASSERT(m_stateChange == ChangeComplete);
                m_stateChange = Pausing;
                FlushBuffers();
                KeResetEvent(&m_specialEvent);
                KeSetEvent(&m_stateTransitionEvent, 0, TRUE);
                KeWaitForSingleObject(&m_specialEvent, Suspended, KernelMode, FALSE, NULL);
                ASSERT(m_stateChange == ChangeComplete);
            }
            
            break;

        case KSSTATE_RUN:
            DBGINFO(("   state KSSTATE_RUN"));

            ASSERT(m_KSState == KSSTATE_ACQUIRE || m_KSState == KSSTATE_PAUSE);

            if (m_pVideoDecoder->PreEventOccurred())
            {
                pSrb->Status = STATUS_UNSUCCESSFUL;
            }
            else
            {
                ResetFieldNumber();

                // Transitioning from pause to run
                ASSERT(m_stateChange == ChangeComplete);
                m_stateChange = Running;
                KeResetEvent(&m_specialEvent);
                KeSetEvent(&m_stateTransitionEvent, 0, TRUE);
                KeWaitForSingleObject(&m_specialEvent, Suspended, KernelMode, FALSE, NULL);
                ASSERT(m_stateChange == ChangeComplete);
            }
            break;
    }

    if (pSrb->Status == STATUS_SUCCESS) {
        m_KSState = pSrb->CommandData.StreamState;
        DBGINFO((" entered\n"));
    }
    else
        DBGINFO((" NOT entered ***\n"));
}


VOID CWDMCaptureStream::VideoStreamGetConnectionProperty (PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    PKSALLOCATOR_FRAMING Framing = (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;

    ASSERT(pSPD->Property->Id == KSPROPERTY_CONNECTION_ALLOCATORFRAMING);
    if (pSPD->Property->Id == KSPROPERTY_CONNECTION_ALLOCATORFRAMING) {

        RtlZeroMemory(Framing, sizeof(KSALLOCATOR_FRAMING));

        Framing->RequirementsFlags   =
            KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY |
            KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
            KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY;
        Framing->PoolType = NonPagedPool;
        Framing->Frames = NumBuffers;
        Framing->FrameSize = GetFrameSize();
        Framing->FileAlignment = 0;//FILE_QUAD_ALIGNMENT;// PAGE_SIZE - 1;

        pSrb->ActualBytesTransferred = sizeof(KSALLOCATOR_FRAMING);
    }
    else {

        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }
}

/*
** VideoStreamGetDroppedFramesProperty
**
**    Gets dropped frame information
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMCaptureStream::VideoStreamGetDroppedFramesProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames = 
        (PKSPROPERTY_DROPPEDFRAMES_CURRENT_S) pSPD->PropertyInfo;

    ASSERT(pSPD->Property->Id == KSPROPERTY_DROPPEDFRAMES_CURRENT);
    if (pSPD->Property->Id == KSPROPERTY_DROPPEDFRAMES_CURRENT) {

        RtlCopyMemory(pDroppedFrames, pSPD->Property, sizeof(KSPROPERTY));  // initialize the unused portion

        GetDroppedFrames(pDroppedFrames);

        DBGINFO(("PictNumber: 0x%x; DropCount: 0x%x; BufSize: 0x%x\n",
            (ULONG) pDroppedFrames->PictureNumber,
            (ULONG) pDroppedFrames->DropCount,
            (ULONG) pDroppedFrames->AverageFrameSize));

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_DROPPEDFRAMES_CURRENT_S);
    }
    else {

        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }
}


VOID CWDMCaptureStream::CloseCapture()
{
    DBGTRACE(("DDNOTIFY_CLOSECAPTURE; stream = %d\n", m_pStreamObject->StreamNumber));

    m_hCapture = 0;
}    


VOID CWDMCaptureStream::EmptyIncomingDataSrbQueue()
{
    KIRQL Irql;
    PKSSTREAM_HEADER pDataPacket;
    
    if ( m_stateChange == Initializing )
    {
        return; // queue not setup yet, so we can return knowing that nothing is in the queue
    }
    
    // Think about replacing with ExInterlockedRemoveHeadList. 
    KeAcquireSpinLock(&m_streamDataLock, &Irql);
    
    while (!IsListEmpty(&m_incomingDataSrbQueue))
    {
        PSRB_DATA_EXTENSION pSrbExt = (PSRB_DATA_EXTENSION)RemoveHeadList(&m_incomingDataSrbQueue);
        PHW_STREAM_REQUEST_BLOCK pSrb = pSrbExt->pSrb;
        
        pSrb->Status = STATUS_SUCCESS;
        pDataPacket = pSrb->CommandData.DataBufferArray;
        pDataPacket->DataUsed = 0;
        
        KeReleaseSpinLock(&m_streamDataLock, Irql);
        DBGINFO(("Completing Srb 0x%x in STATE_STOP\n", pSrb));
        StreamClassStreamNotification(  StreamRequestComplete,
                                        pSrb->StreamObject,
                                        pSrb);
        KeAcquireSpinLock(&m_streamDataLock, &Irql);
    }
    
    KeReleaseSpinLock(&m_streamDataLock, Irql);
}


BOOL CWDMCaptureStream::ReleaseCaptureHandle()
{
    int streamNumber = m_pStreamObject->StreamNumber;
    DWORD ddOut = DD_OK;
    DDCLOSEHANDLE ddClose;

    if (m_hCapture != 0)
    {
        DBGTRACE(("Stream %d releasing capture handle\n", streamNumber));
        
        ddClose.hHandle = m_hCapture;

        DxApi(DD_DXAPI_CLOSEHANDLE, &ddClose, sizeof(ddClose), &ddOut, sizeof(ddOut));

        if (ddOut != DD_OK)
        {
            DBGERROR(("DD_DXAPI_CLOSEHANDLE failed.\n"));
            TRAP();
            return FALSE;
        }
        m_hCapture = 0;
    }
    return TRUE;
}

VOID CWDMCaptureStream::HandleBusmasterCompletion(PHW_STREAM_REQUEST_BLOCK pCurrentSrb)
{
    int streamNumber =  m_pStreamObject->StreamNumber;
    PSRB_DATA_EXTENSION pSrbExt = (PSRB_DATA_EXTENSION)pCurrentSrb->SRBExtension;
    KIRQL Irql;
    // This function is called as a result of DD completing a BM.  That means
    // m_stateChange will not be in the Initializing state for sure

    // First handle case where we get a Busmaster completion
    // indication while we are trying to pause or stop
    if (m_stateChange == Pausing || m_stateChange == Stopping)
    {
        PUCHAR ptr;
        KeAcquireSpinLock(&m_streamDataLock, &Irql);

        // Put it at the head of the temporary 'reversal' queue.
        InsertHeadList(&m_reversalQueue, &pSrbExt->srbListEntry);
        
        if (IsListEmpty(&m_waitQueue))
        {
            // if there is nothing left in the wait queue we can now
            // proceed to move everything back to the incoming queue.
            // This whole ugly ordeal is to
            // make sure that they end up in the original order
            while (!IsListEmpty(&m_reversalQueue))
            {
                ptr = (PUCHAR)RemoveHeadList(&m_reversalQueue);
                InsertHeadList(&m_incomingDataSrbQueue, (PLIST_ENTRY) ptr);
            }
            
            KeReleaseSpinLock(&m_streamDataLock, Irql);
            
            if (m_stateChange == Stopping)
            {
                EmptyIncomingDataSrbQueue();
            }
            
            // Indicate that we have successfully completed this part
            // of the transition to the pause state.
            m_stateChange = ChangeComplete;
            KeSetEvent(&m_specialEvent, 0, FALSE);
            return;
        }

        KeReleaseSpinLock(&m_streamDataLock, Irql);
        return;
    }

    // else it is a regular busmaster completion while in the run state
    else
    {
        ASSERT (pCurrentSrb);
        PKSSTREAM_HEADER    pDataPacket = pCurrentSrb->CommandData.DataBufferArray;
        pDataPacket->OptionsFlags = 0;

        pSrbExt = (PSRB_DATA_EXTENSION)pCurrentSrb->SRBExtension;

        DBGINFO(("FieldNum: %d; ddRVal: 0x%x; polarity: 0x%x\n",
                 pSrbExt->ddCapBuffInfo.dwFieldNumber,
                 pSrbExt->ddCapBuffInfo.ddRVal,
                 pSrbExt->ddCapBuffInfo.bPolarity));

        // It's possible that the srb got cancelled while we were waiting.
        // Currently, this status is reset below
        if (pCurrentSrb->Status == STATUS_CANCELLED)
        {
            DBGINFO(("pCurrentSrb 0x%x was cancelled while we were waiting\n", pCurrentSrb));
            pDataPacket->DataUsed = 0;
        }

        // It's also possible that there was a problem in DD-land
        else if (pSrbExt->ddCapBuffInfo.ddRVal != DD_OK)
        {
            // Two cases of which I am aware.
            // 1) flushed buffers
            if (pSrbExt->ddCapBuffInfo.ddRVal == E_FAIL)
            {
                DBGINFO(("ddRVal = 0x%x. Assuming we flushed\n", pSrbExt->ddCapBuffInfo.ddRVal));
                pDataPacket->DataUsed = 0;
            }
            // 2) something else
            else
            {
                DBGERROR(("= 0x%x. Problem in Busmastering?\n", pSrbExt->ddCapBuffInfo.ddRVal));
                pDataPacket->DataUsed = 0;
            }
        }

        // There is also the remote possibility that everything is OK
        else
        {
            SetFrameInfo(pCurrentSrb);
            TimeStampSrb(pCurrentSrb);
            pDataPacket->DataUsed = pDataPacket->FrameExtent;
        }
        
        DBGINFO(("StreamRequestComplete for SRB 0x%x\n", pCurrentSrb));

        // Always return success. Failure
        // is indicated by setting DataUsed to 0.
        pCurrentSrb->Status = STATUS_SUCCESS;

        ASSERT(pCurrentSrb->Irp->MdlAddress);

        StreamClassStreamNotification(  StreamRequestComplete,
                                        pCurrentSrb->StreamObject,
                                        pCurrentSrb);
    }
}

void CWDMCaptureStream::AddBuffersToDirectDraw()
{
    KIRQL Irql;
    BOOL  fAdded;
    
    KeAcquireSpinLock(&m_streamDataLock, &Irql);
    
    while (!IsListEmpty(&m_incomingDataSrbQueue))
    {
        // So if we've reached this point, we are in the run state, and
        // we have an SRB on our incoming queue, and we are holding the
        // the stream lock
        PSRB_DATA_EXTENSION pSrbExt = (PSRB_DATA_EXTENSION)RemoveHeadList(&m_incomingDataSrbQueue);
        PHW_STREAM_REQUEST_BLOCK pSrb = pSrbExt->pSrb;

        // Calls to DXAPI must be at Passive level, so release the spinlock temporarily

        KeReleaseSpinLock(&m_streamDataLock, Irql);

        DBGINFO(("Removed 0x%x from data queue\n", pSrb));

        fAdded = AddBuffer(pSrb);

        KeAcquireSpinLock(&m_streamDataLock, &Irql);

        if (fAdded)
        {
            DBGINFO(("Adding 0x%x to wait queue\n", pSrb));
            InsertTailList(&m_waitQueue, &pSrbExt->srbListEntry);
        }
        else
        {
            DBGINFO(("Adding 0x%x back to dataqueue\n", pSrb));

            // put it back where it was
            InsertHeadList(&m_incomingDataSrbQueue, &pSrbExt->srbListEntry);
            break;
        }
    }
    KeReleaseSpinLock(&m_streamDataLock, Irql);
}


BOOL CWDMCaptureStream::AddBuffer(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    DDADDVPCAPTUREBUFF ddAddVPCaptureBuffIn;
    DWORD ddOut = DD_OK;

    PIRP irp = pSrb->Irp;
    PSRB_DATA_EXTENSION pSrbExt = (PSRB_DATA_EXTENSION)pSrb->SRBExtension;
    
    DBGINFO(("In AddBuffer. pSrb: 0x%x.\n", pSrb));

    // For handling full-screen DOS, res changes, etc.
    if (m_hCapture == 0)
    {
        if (!GetCaptureHandle())
        {
            return FALSE;
        }
    }

    ddAddVPCaptureBuffIn.hCapture = m_hCapture;
    ddAddVPCaptureBuffIn.dwFlags = DDADDBUFF_SYSTEMMEMORY;
    ddAddVPCaptureBuffIn.pMDL = irp->MdlAddress;

    ddAddVPCaptureBuffIn.lpBuffInfo = &pSrbExt->ddCapBuffInfo;
    ddAddVPCaptureBuffIn.pKEvent = &pSrbExt->bufferDoneEvent;

    DxApi(DD_DXAPI_ADDVPCAPTUREBUFFER, &ddAddVPCaptureBuffIn, sizeof(ddAddVPCaptureBuffIn), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        // Not necessarily an error.
        DBGINFO(("DD_DXAPI_ADDVPCAPTUREBUFFER failed.\n"));
        // TRAP();
        return FALSE;
    }

    return TRUE;
}


VOID CWDMCaptureStream::HandleStateTransition()
{
    KIRQL Irql;
    switch (m_stateChange)
    {
        case Running:
            AddBuffersToDirectDraw();
            m_stateChange = ChangeComplete;
            KeSetEvent(&m_specialEvent, 0, FALSE);
            break;

        case Pausing:
            KeAcquireSpinLock(&m_streamDataLock, &Irql);
            if (IsListEmpty(&m_waitQueue))
            {
                KeReleaseSpinLock(&m_streamDataLock, Irql);
                m_stateChange = ChangeComplete;
                KeSetEvent(&m_specialEvent, 0, FALSE);
            }
            else
            {
                KeReleaseSpinLock(&m_streamDataLock, Irql);
            }
            break;

        case Stopping:
            KeAcquireSpinLock(&m_streamDataLock, &Irql);
            if (IsListEmpty(&m_waitQueue))
            {
                KeReleaseSpinLock(&m_streamDataLock, Irql);
                EmptyIncomingDataSrbQueue();
                m_stateChange = ChangeComplete;
                KeSetEvent(&m_specialEvent, 0, FALSE);
            }
            else
            {
                KeReleaseSpinLock(&m_streamDataLock, Irql);
            }
            break;

        case Closing:
            m_stateChange = ChangeComplete;
            KeSetEvent(&m_specialEvent, 0, FALSE);
            DBGTRACE(("StreamThread exiting\n"));
            
            PsTerminateSystemThread(STATUS_SUCCESS);

            DBGERROR(("Shouldn't get here\n"));
            TRAP();
            break;

        case ChangeComplete:
            DBGTRACE(("Must have completed transition in HandleBusMasterCompletion\n"));
            break;

        default:
            TRAP();
            break;
    }
}

    
BOOL CWDMCaptureStream::ResetFieldNumber()
{
    int                     streamNumber = m_pStreamObject->StreamNumber;
    DDSETFIELDNUM           ddSetFieldNum;
    DWORD                   ddOut;

    ASSERT(streamNumber == STREAM_VideoCapture || streamNumber == STREAM_VBICapture);

    if (m_pVideoPort->GetDirectDrawHandle() == 0) {
        DBGERROR(("Didn't expect ring0DirectDrawHandle to be zero.\n"));
        TRAP();
        return FALSE;
    }
    
    if (m_pVideoPort->GetVideoPortHandle() == 0) {
        DBGERROR(("Didn't expect ring0VideoPortHandle to be zero.\n"));
        TRAP();
        return FALSE;
    }
    
    RtlZeroMemory(&ddSetFieldNum, sizeof(ddSetFieldNum));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    KSPROPERTY_DROPPEDFRAMES_CURRENT_S DroppedFrames;
    GetDroppedFrames(&DroppedFrames);

    ddSetFieldNum.hDirectDraw = m_pVideoPort->GetDirectDrawHandle();
    ddSetFieldNum.hVideoPort = m_pVideoPort->GetVideoPortHandle();
    ddSetFieldNum.dwFieldNum = ((ULONG)DroppedFrames.PictureNumber + 1) * GetFieldInterval();
    
    DxApi(DD_DXAPI_SET_VP_FIELD_NUMBER, &ddSetFieldNum, sizeof(ddSetFieldNum), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_SET_VP_FIELD_NUMBER failed.\n"));
        TRAP();
        return FALSE;
    }
    else
    {
#ifdef DEBUG
        DBGINFO(("PictureNumber: %d; ", DroppedFrames.PictureNumber));
        DBGINFO(("DropCount: %d\n", DroppedFrames.DropCount));
        DBGINFO(("AverageFrameSize: %d\n", DroppedFrames.AverageFrameSize));
#endif
        return TRUE;
    }
}

BOOL CWDMCaptureStream::FlushBuffers()
{
    DWORD ddOut = DD_OK;

    // commented out the trap because it is possible that capture handle is closed in DD before flushbuffer is called during mode switch
    if (m_hCapture == NULL) {
       //DBGERROR(("m_hCapture === NULL in FlushBuffers.\n"));
       //TRAP();
       return FALSE;
    }

    DxApi(DD_DXAPI_FLUSHVPCAPTUREBUFFERS, &m_hCapture, sizeof(HANDLE), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_FLUSHVPCAPTUREBUFFERS failed.\n"));
        TRAP();
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}
    

VOID CWDMCaptureStream::TimeStampSrb(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PKSSTREAM_HEADER    pDataPacket = pSrb->CommandData.DataBufferArray;
    PSRB_DATA_EXTENSION      pSrbExt = (PSRB_DATA_EXTENSION)pSrb->SRBExtension;

    pDataPacket->Duration = GetFieldInterval() * NTSCFieldDuration;

    pDataPacket->OptionsFlags |= 
        KSSTREAM_HEADER_OPTIONSF_DURATIONVALID |
        KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT;

    // Find out what time it is, if we're using a clock

    if (m_hMasterClock) {
        LARGE_INTEGER Delta;

        HW_TIME_CONTEXT TimeContext;

//        TimeContext.HwDeviceExtension = pHwDevExt; 
        TimeContext.HwDeviceExtension = (struct _HW_DEVICE_EXTENSION *)m_pVideoDecoder; 
        TimeContext.HwStreamObject = m_pStreamObject;
        TimeContext.Function = TIME_GET_STREAM_TIME;

        StreamClassQueryMasterClockSync (
            m_hMasterClock,
            &TimeContext);

        // This calculation should result in the stream time WHEN the buffer
        // was filled.
        Delta.QuadPart = TimeContext.SystemTime -
                            pSrbExt->ddCapBuffInfo.liTimeStamp.QuadPart;

        // Be safe, just use the current stream time, without the correction for when
        // DDraw actually returned the buffer to us.
        pDataPacket->PresentationTime.Time = TimeContext.Time; 

#ifdef THIS_SHOULD_WORK_BUT_IT_DOESNT
        if (TimeContext.Time > (ULONGLONG) Delta.QuadPart)
        {
            pDataPacket->PresentationTime.Time = TimeContext.Time - Delta.QuadPart;
        }
        else
        {
            // There's a bug in Ks or Stream after running for 2 hours
            // that makes this hack necessary.  Will be fixed soon...
            pDataPacket->PresentationTime.Time = TimeContext.Time;
        }
#endif

#ifdef DEBUG
        ULONG *tmp1, *tmp2;

        tmp1 = (ULONG *)&pDataPacket->PresentationTime.Time;
        tmp2 = (ULONG *)&TimeContext.Time;
        DBGINFO(("PT: 0x%x%x; ST: 0x%x%x\n", tmp1[1], tmp1[0], tmp2[1], tmp2[0]));
#endif

        pDataPacket->PresentationTime.Numerator = 1;
        pDataPacket->PresentationTime.Denominator = 1;

        pDataPacket->OptionsFlags |= 
            KSSTREAM_HEADER_OPTIONSF_TIMEVALID;
    }
    else
    {
        pDataPacket->OptionsFlags &= 
            ~KSSTREAM_HEADER_OPTIONSF_TIMEVALID;
    }
}


void CWDMCaptureStream::CancelPacket( PHW_STREAM_REQUEST_BLOCK pSrbToCancel)
{
    PHW_STREAM_REQUEST_BLOCK    pCurrentSrb;
    KIRQL                       Irql;
    PLIST_ENTRY                 Entry;
    BOOL                        bFound = FALSE;

    if ( m_stateChange == Initializing )  // Stream not completely setup, so nothing in the queue
    {
        DBGINFO(( "Bt829: Didn't find Srb 0x%x\n", pSrbToCancel));
        return;
    }

    KeAcquireSpinLock( &m_streamDataLock, &Irql);

    Entry = m_incomingDataSrbQueue.Flink;

    // 
    // Loop through the linked list from the beginning to end,
    // trying to find the SRB to cancel
    //
    while( Entry != &m_incomingDataSrbQueue)
    {
        PSRB_DATA_EXTENSION pSrbExt;
    
        pSrbExt = ( PSRB_DATA_EXTENSION)Entry;
        pCurrentSrb = pSrbExt->pSrb;
        
        if( pCurrentSrb == pSrbToCancel)
        {
            RemoveEntryList( Entry);
            bFound = TRUE;
            break;
        }
        Entry = Entry->Flink;
    }

    KeReleaseSpinLock( &m_streamDataLock, Irql);

    if( bFound)
    {
        pCurrentSrb->Status = STATUS_CANCELLED;
        pCurrentSrb->CommandData.DataBufferArray->DataUsed = 0;
        
        DBGINFO(( "Bt829: Cancelled Srb 0x%x\n", pCurrentSrb));
        StreamClassStreamNotification( StreamRequestComplete,
                                       pCurrentSrb->StreamObject,
                                       pCurrentSrb);
    }
    else
    {
        // If this is a DATA_TRANSFER and a STREAM_REQUEST SRB, 
        // then it must be in the waitQueue, being filled by DDraw.

        // If so, mark it cancelled, and it will 
        // be returned when  DDraw is finished with it.
        if(( pSrbToCancel->Flags & (SRB_HW_FLAGS_DATA_TRANSFER | SRB_HW_FLAGS_STREAM_REQUEST)) ==
                                  (SRB_HW_FLAGS_DATA_TRANSFER | SRB_HW_FLAGS_STREAM_REQUEST))
        {
            pSrbToCancel->Status = STATUS_CANCELLED;
            DBGINFO(( "Bt829: Cancelled Srb on waitQueue 0x%x\n", pSrbToCancel));
        }
        else 
        {
           DBGINFO(( "Bt829: Didn't find Srb 0x%x\n", pSrbToCancel));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\capvbi.h ===
#pragma once

//==========================================================================;
//
//	CWDMVBICaptureStream - VBI Capture Stream class declarations
//
//		$Date:   05 Aug 1998 11:22:46  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "i2script.h"
#include "aticonfg.h"

#include "CapStrm.h"


class CWDMVBICaptureStream : public CWDMCaptureStream
{
public:
	CWDMVBICaptureStream(PHW_STREAM_OBJECT pStreamObject,
						CWDMVideoDecoder * pCWDMVideoDecoder,
						PKSDATAFORMAT pKSDataFormat,
						PUINT puiErrorCode);
	~CWDMVBICaptureStream();

	void * operator new(size_t size, void * pAllocation) { return(pAllocation);}
	void operator delete(void * pAllocation) {}

private:
	PKS_VBIINFOHEADER		m_pVBIInfoHeader;    //
	KS_VBI_FRAME_INFO       m_VBIFrameInfo;
	BOOL					m_bVBIinitialized;

	void ResetFrameCounters();
	ULONG GetFrameSize() { return m_pVBIInfoHeader->BufferSize; }
	void GetDroppedFrames(PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames);
	BOOL GetCaptureHandle();
	VOID SetFrameInfo(PHW_STREAM_REQUEST_BLOCK);
	ULONG GetFieldInterval() { return 1; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\decdev.h ===
#pragma once

//==========================================================================;
//
//  Video Decoder Device abstract base class definition
//
//      $Date:   28 Aug 1998 14:43:46  $
//  $Revision:   1.1  $
//    $Author:   Tashjian  $
//
// $Copyright:  (c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;


#include "viddefs.h"
#include "mytypes.h"

class CWDMVideoDecoder;

class CVideoDecoderDevice
{
private:
    BOOL m_bOutputEnabledSet;
    CWDMVideoDecoder* m_pDecoder;


public:
    CVideoDecoderDevice();
    virtual ~CVideoDecoderDevice();

    virtual int GetDefaultDecoderWidth() = 0;
    virtual int GetDefaultDecoderHeight() = 0;

    virtual void SetRect(MRect &) = 0;

    virtual void SetVBIEN(BOOL b) = 0;
    virtual void SetVBIFMT(BOOL b) = 0;

    virtual void SaveState() = 0;
    virtual void RestoreState(DWORD dwStreamsOpen = -1) = 0;


    void GetCrossbarProperty(PHW_STREAM_REQUEST_BLOCK);
    void SetCrossbarProperty(PHW_STREAM_REQUEST_BLOCK);
    virtual BOOL GoodPins(ULONG InPin, ULONG OutPin) = 0;
    virtual BOOL TestRoute(ULONG InPin, ULONG OutPin) = 0;
    virtual void Route(ULONG OutPin, ULONG InPin) = 0;
    virtual ULONG GetNoInputs() = 0;
    virtual ULONG GetNoOutputs() = 0;
    virtual ULONG GetPinInfo(KSPIN_DATAFLOW dir, ULONG idx, ULONG &related) = 0;
    virtual ULONG GetRoute(ULONG OutPin) = 0;
    virtual KSPIN_MEDIUM * GetPinMedium(KSPIN_DATAFLOW dir, ULONG idx) = 0;

    virtual ErrorCode SetVideoInput(Connector c) = 0;

    
    virtual NTSTATUS GetProcAmpProperty(ULONG, PLONG) = 0;
    virtual NTSTATUS SetProcAmpProperty(ULONG, LONG) = 0;


    void GetDecoderProperty(PHW_STREAM_REQUEST_BLOCK);
    virtual void GetVideoDecoderCaps(PKSPROPERTY_VIDEODECODER_CAPS_S) = 0;
    virtual DWORD GetVideoDecoderStandard() = 0;
    virtual void GetVideoDecoderStatus(PKSPROPERTY_VIDEODECODER_STATUS_S) = 0;
    virtual BOOL IsOutputEnabled() = 0;
    void SetDecoderProperty(PHW_STREAM_REQUEST_BLOCK);
    virtual BOOL SetVideoDecoderStandard(DWORD) = 0;
    virtual void SetOutputEnabled(BOOL) = 0;
    void SetOutputEnabledOverridden(BOOL bOutputEnabledSet)
    {
        m_bOutputEnabledSet = bOutputEnabledSet;
    }
    BOOL IsOutputEnabledOverridden()
    {
        return m_bOutputEnabledSet;
    }


    virtual void GetVideoPortProperty(PHW_STREAM_REQUEST_BLOCK pSrb) = 0;
    virtual void GetVideoPortVBIProperty(PHW_STREAM_REQUEST_BLOCK pSrb) = 0;

    virtual void Set16BitDataStream(BOOL b) = 0;
    virtual BOOL IsHighOdd() = 0;
    virtual void SetHighOdd(BOOL b) = 0;
    virtual void ConfigVPSurfaceParams(PKSVPSURFACEPARAMS pSurfaceParams) = 0;
    virtual void ConfigVPVBISurfaceParams(PKSVPSURFACEPARAMS pSurfaceParams) = 0;

    virtual int GetDecoderHeight() = 0;

    virtual void GetVideoSurfaceOrigin(int*, int*) = 0;
    virtual void GetVBISurfaceOrigin(int*, int*) = 0;
    void SetVideoDecoder(CWDMVideoDecoder* pDecoder)
    {
        m_pDecoder = pDecoder;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\capvideo.cpp ===
//==========================================================================;
//
//	CWDMVideoCaptureStream - Video Capture Stream class implementation
//
//		$Date:   05 Aug 1998 11:11:00  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "ddkmapi.h"
}

#include "wdmvdec.h"
#include "wdmdrv.h"
#include "aticonfg.h"
#include "capdebug.h"
#include "defaults.h"
#include "winerror.h"

CWDMVideoCaptureStream::CWDMVideoCaptureStream(PHW_STREAM_OBJECT pStreamObject,
						CWDMVideoDecoder * pCWDMVideoDecoder,
						PKSDATAFORMAT pKSDataFormat,
						PUINT puiErrorCode)
		:	CWDMCaptureStream(pStreamObject, pCWDMVideoDecoder, puiErrorCode)
{
    m_stateChange = Initializing;

	DBGTRACE(("CWDMVideoCaptureStream::Startup()\n"));

    PKS_DATAFORMAT_VIDEOINFOHEADER  pVideoInfoHeader = 
                (PKS_DATAFORMAT_VIDEOINFOHEADER) pKSDataFormat;
    PKS_VIDEOINFOHEADER     pVideoInfoHdrRequested = 
                &pVideoInfoHeader->VideoInfoHeader;

    // Since the VIDEOINFOHEADER is of potentially variable size
    // allocate memory for it

    UINT nSize = KS_SIZE_VIDEOHEADER(pVideoInfoHdrRequested);

    DBGINFO(("pVideoInfoHdrRequested=%x\n", pVideoInfoHdrRequested));
    DBGINFO(("KS_VIDEOINFOHEADER size=%d\n", nSize));
    DBGINFO(("Width=%d  Height=%d  BitCount=%d\n", 
                pVideoInfoHdrRequested->bmiHeader.biWidth,
                pVideoInfoHdrRequested->bmiHeader.biHeight,
                pVideoInfoHdrRequested->bmiHeader.biBitCount));
    DBGINFO(("biSizeImage=%d\n", 
                pVideoInfoHdrRequested->bmiHeader.biSizeImage));
    DBGINFO(("AvgTimePerFrame=%d\n", 
                pVideoInfoHdrRequested->AvgTimePerFrame));

    m_pVideoInfoHeader = (PKS_VIDEOINFOHEADER)ExAllocatePool(NonPagedPool, nSize);

    if (m_pVideoInfoHeader == NULL) {
        DBGERROR(("ExAllocatePool failed\n"));
		*puiErrorCode = WDMMINI_ERROR_MEMORYALLOCATION;
		return;
    }

    // Copy the VIDEOINFOHEADER requested to our storage
    RtlCopyMemory(
            m_pVideoInfoHeader,
            pVideoInfoHdrRequested,
            nSize);

	MRect t(0, 0,   pVideoInfoHdrRequested->bmiHeader.biWidth,
					pVideoInfoHdrRequested->bmiHeader.biHeight);
	m_pDevice->SetRect(t);

	Startup(puiErrorCode);
}

CWDMVideoCaptureStream::~CWDMVideoCaptureStream()
{
	DBGTRACE(("CWDMVideoCaptureStream::~CWDMVideoCaptureStream()\n"));

	Shutdown();

    if (m_pVideoInfoHeader) {
        ExFreePool(m_pVideoInfoHeader);
        m_pVideoInfoHeader = NULL;
    }
}


BOOL CWDMVideoCaptureStream::GetCaptureHandle()
{    
    int streamNumber = m_pStreamObject->StreamNumber;

    if (m_hCapture == 0)
    {
        DBGTRACE(("Stream %d getting capture handle\n", streamNumber));
        
        DDOPENVPCAPTUREDEVICEIN  ddOpenCaptureIn;
        DDOPENVPCAPTUREDEVICEOUT ddOpenCaptureOut;

        RtlZeroMemory(&ddOpenCaptureIn, sizeof(ddOpenCaptureIn));
        RtlZeroMemory(&ddOpenCaptureOut, sizeof(ddOpenCaptureOut));

        ddOpenCaptureIn.hDirectDraw = m_pVideoPort->GetDirectDrawHandle();
        ddOpenCaptureIn.hVideoPort = m_pVideoPort->GetVideoPortHandle();
        ddOpenCaptureIn.pfnCaptureClose = DirectDrawEventCallback;
        ddOpenCaptureIn.pContext = this;

        if ((!ddOpenCaptureIn.hDirectDraw)||
            (!ddOpenCaptureIn.hVideoPort)||
            (!ddOpenCaptureIn.pfnCaptureClose)||
            (!ddOpenCaptureIn.pContext))
        {
            return FALSE;
        }
        // Now to get the size, etc
        RECT                rcImage;

        /* 
        **  HOW BIG IS THE IMAGE REQUESTED (pseudocode follows)
        **
        **  if (IsRectEmpty (&rcTarget) {
        **      SetRect (&rcImage, 0, 0, 
        **              BITMAPINFOHEADER.biWidth,
                        BITMAPINFOHEADER.biHeight);
        **  }
        **  else {
        **      // Probably rendering to a DirectDraw surface,
        **      // where biWidth is used to expressed the "stride" 
        **      // in units of pixels (not bytes) of the destination surface.
        **      // Therefore, use rcTarget to get the actual image size 
        **      
        **      rcImage = rcTarget;
        **  }
        */

        if ((m_pVideoInfoHeader->rcTarget.right - 
             m_pVideoInfoHeader->rcTarget.left <= 0) ||
            (m_pVideoInfoHeader->rcTarget.bottom - 
             m_pVideoInfoHeader->rcTarget.top <= 0)) {

             rcImage.left = rcImage.top = 0;
             rcImage.right = m_pVideoInfoHeader->bmiHeader.biWidth - 1;
             rcImage.bottom = m_pVideoInfoHeader->bmiHeader.biHeight - 1;
        }
        else {
             rcImage = m_pVideoInfoHeader->rcTarget;
        }

		int xOrigin, yOrigin;
		m_pDevice->GetVideoSurfaceOrigin(&xOrigin, &yOrigin);
        ddOpenCaptureIn.dwStartLine = rcImage.top + yOrigin;
        ddOpenCaptureIn.dwEndLine = rcImage.bottom + yOrigin;

        // Fail-safe
        if (ddOpenCaptureIn.dwStartLine > 500)
        {
            DBGERROR(("Unexpected capture start line. Using default\n"));
            ddOpenCaptureIn.dwStartLine = 0;
        }

        if (ddOpenCaptureIn.dwEndLine > 500)
        {
            DBGERROR(("Unexpected capture end line. Using default\n"));
            ddOpenCaptureIn.dwEndLine = m_pDevice->GetDecoderHeight() - 1;
        }
        DBGINFO(("Video surface: %d, %d\n",
            ddOpenCaptureIn.dwStartLine,
            ddOpenCaptureIn.dwEndLine));

        ddOpenCaptureIn.dwFlags = DDOPENCAPTURE_VIDEO;

        // Integer math, so it will throw away fractional part
        m_everyNFields = min (max ( 1,
                        (ULONG) m_pVideoInfoHeader->AvgTimePerFrame/NTSCFieldDuration),
                        MAXULONG);

        // Now look at that fractional part. If there was a significant
        // amount, we'll need to round down to the next nearest
        // frame rate (i.e., skip additional field)

        // 'Significant' is currently assumed to be 1 uS. That
        // is '10' in units of 100ns 
        if ((m_pVideoInfoHeader->AvgTimePerFrame -
             (NTSCFieldDuration * m_everyNFields)) > 10)
        {
            m_everyNFields++;
        }

        ddOpenCaptureIn.dwCaptureEveryNFields = m_everyNFields;
               
        DBGINFO(("Capturing every %d fields\n",
                        ddOpenCaptureIn.dwCaptureEveryNFields));

        DxApi(DD_DXAPI_OPENVPCAPTUREDEVICE, &ddOpenCaptureIn, sizeof(ddOpenCaptureIn), &ddOpenCaptureOut, sizeof(ddOpenCaptureOut));

        if (ddOpenCaptureOut.ddRVal != DD_OK)
        {
            m_hCapture = 0;
            DBGERROR(("DD_DXAPI_OPENVPCAPTUREDEVICE failed.\n"));
            // TRAP();
            return FALSE;
        }
        else
        {
            m_hCapture = ddOpenCaptureOut.hCapture;
        }
    }
    return TRUE;
}   

    
VOID CWDMVideoCaptureStream::SetFrameInfo(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    int streamNumber = m_pStreamObject->StreamNumber;
    PSRB_DATA_EXTENSION      pSrbExt = (PSRB_DATA_EXTENSION)pSrb->SRBExtension;
    PKSSTREAM_HEADER    pDataPacket = pSrb->CommandData.DataBufferArray;
    
    LONGLONG droppedThisTime = 0;

    PKS_FRAME_INFO pFrameInfo = (PKS_FRAME_INFO) (pDataPacket + 1);

    m_FrameInfo.dwFrameFlags = 0;
    m_FrameInfo.ExtendedHeaderSize = pFrameInfo->ExtendedHeaderSize;

    // Set the discontinuity flag if frames have been previously dropped.
    if ((m_FrameInfo.PictureNumber + 1) <
        pSrbExt->ddCapBuffInfo.dwFieldNumber/m_everyNFields)
    {
        droppedThisTime =
        pSrbExt->ddCapBuffInfo.dwFieldNumber/m_everyNFields -
        (m_FrameInfo.PictureNumber + 1);
        m_FrameInfo.DropCount += droppedThisTime;
        pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
#ifdef DEBUG
        static int j;
        DBGPRINTF((" D%d ", droppedThisTime));
        if ((++j % 10) == 0)
        {
            DBGERROR(("\n"));
        }
#endif
    }
    m_FrameInfo.PictureNumber = pSrbExt->ddCapBuffInfo.dwFieldNumber/m_everyNFields;
    m_FrameInfo.dwFrameFlags |= KS_VIDEO_FLAG_FRAME;
    *pFrameInfo = (KS_FRAME_INFO)m_FrameInfo;
}


void CWDMVideoCaptureStream::ResetFrameCounters()
{
	m_FrameInfo.PictureNumber = 0;
	m_FrameInfo.DropCount = 0;
}

void CWDMVideoCaptureStream::GetDroppedFrames(PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames)
{
	pDroppedFrames->PictureNumber = m_FrameInfo.PictureNumber;
	pDroppedFrames->DropCount = m_FrameInfo.DropCount;
	pDroppedFrames->AverageFrameSize = m_pVideoInfoHeader->bmiHeader.biSizeImage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\capvideo.h ===
#pragma once

//==========================================================================;
//
//	CWDMVideoCaptureStream - Video Capture Stream class declarations
//
//		$Date:   05 Aug 1998 11:22:44  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "i2script.h"
#include "aticonfg.h"

#include "CapStrm.h"



class CWDMVideoCaptureStream : public CWDMCaptureStream
{
public:
	CWDMVideoCaptureStream(PHW_STREAM_OBJECT pStreamObject,
						CWDMVideoDecoder * pCWDMVideoDecoder,
						PKSDATAFORMAT pKSDataFormat,
						PUINT puiErrorCode);
	~CWDMVideoCaptureStream();

	void * operator new(size_t size, void * pAllocation) { return(pAllocation);}
	void operator delete(void * pAllocation) {}

private:
	PKS_VIDEOINFOHEADER		m_pVideoInfoHeader;  // format (variable size!)
    KS_FRAME_INFO           m_FrameInfo;          // PictureNumber, etc.
	ULONG					m_everyNFields;

	void ResetFrameCounters();
	ULONG GetFrameSize() { return m_pVideoInfoHeader->bmiHeader.biSizeImage; }
	void GetDroppedFrames(PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames);
	BOOL GetCaptureHandle();
	VOID SetFrameInfo(PHW_STREAM_REQUEST_BLOCK);
	ULONG GetFieldInterval() { return m_everyNFields; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\decvport.cpp ===
//==========================================================================;
//
//  CDecoderVideoPort - Video Port interface implementation
//
//      $Date:   14 Oct 1998 15:09:54  $
//  $Revision:   1.1  $
//    $Author:   Tashjian  $
//
// $Copyright:  (c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;


extern "C"
{
#include "strmini.h"
#include "ksmedia.h"
#include "ddkmapi.h"
}

#include "wdmdrv.h"
#include "decvport.h"
#include "capdebug.h"
#include "vidstrm.h"


/*^^*
 *      CDecoderVideoPort()
 * Purpose  : CDecoderVideoPort class constructor
 *
 * Inputs   : PDEVICE_OBJECT pDeviceObject      : pointer to the Driver object to access the Registry
 *            CI2CScript * pCScript             : pointer to CI2CScript class object
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
CDecoderVideoPort::CDecoderVideoPort(PDEVICE_OBJECT pDeviceObject)
{

    // It's a right place to provide Video Port connection parameters
    // initialization. The custom parameters should be placed in the Registry
    // in a standard way.
    // The list of custom parameters includes:
    //  - Clock type, the decoder runs off : single, double, QCLK
    //  - VACTIVE / VRESET configuration
    //  - HACTIVE / HRESET configuration
    //  - 8 / 16 bits VideoPort connection
    //  - connection type : SPI / embedded (in the case of 8 bits also called ByteSream)

    m_pDeviceObject = pDeviceObject;

    // zero is a valid ID, therefore, set to something
        // else to initialize it.
    m_ring3VideoPortHandle = -1;
}


void CDecoderVideoPort::Open()
{
}

void CDecoderVideoPort::Close()
{
    ReleaseRing0VideoPortHandle();
    m_ring3VideoPortHandle = -1;
    
    ReleaseRing0DirectDrawHandle();
    m_ring3DirectDrawHandle = 0;
}


BOOL CDecoderVideoPort::ReleaseRing0VideoPortHandle()
{
    DWORD ddOut = DD_OK;

    DDCLOSEHANDLE ddClose;

    if (m_ring0VideoPortHandle != 0)
    {
        //DBGTRACE(("Stream %d releasing ring0 vport handle\n", streamNumber));
        
        ddClose.hHandle = m_ring0VideoPortHandle;

        DxApi(DD_DXAPI_CLOSEHANDLE, &ddClose, sizeof(ddClose), &ddOut, sizeof(ddOut));

        if (ddOut != DD_OK)
        {
            DBGERROR(("DD_DXAPI_CLOSEHANDLE failed.\n"));
            TRAP();
            return FALSE;
        }
        m_ring0VideoPortHandle = 0;
    }
    return TRUE;
}

BOOL CDecoderVideoPort::ReleaseRing0DirectDrawHandle()
{
    DWORD ddOut = DD_OK;
    DDCLOSEHANDLE ddClose;

    if (m_ring0DirectDrawHandle != 0)
    {
        //DBGTRACE(("Bt829: Stream %d releasing ring0 ddraw handle\n", streamNumber));
        
        ddClose.hHandle = m_ring0DirectDrawHandle;

        DxApi(DD_DXAPI_CLOSEHANDLE, &ddClose, sizeof(ddClose), &ddOut, sizeof(ddOut));

        if (ddOut != DD_OK)
        {
            DBGERROR(("DD_DXAPI_CLOSEHANDLE failed.\n"));
            TRAP();
            return FALSE;
        }
        m_ring0DirectDrawHandle = 0;
    }
    return TRUE;
}


BOOL CDecoderVideoPort::RegisterForDirectDrawEvents(CWDMVideoPortStream* pStream)
{
    DDREGISTERCALLBACK ddRegisterCallback;
    DWORD ddOut;

//    DBGTRACE(("Stream %d registering for DirectDraw events\n", streamNumber));
    
    // =============== DDEVENT_PRERESCHANGE ===============
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = m_ring0DirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_PRERESCHANGE;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStream;

    DxApi(DD_DXAPI_REGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_REGISTER_CALLBACK failed.\n"));
        TRAP();
        return FALSE;
    }

    // =============== DDEVENT_POSTRESCHANGE ==============
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = m_ring0DirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_POSTRESCHANGE;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStream;

    DxApi(DD_DXAPI_REGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_REGISTER_CALLBACK failed.\n"));
        TRAP();
        return FALSE;
    }

    // =============== DDEVENT_PREDOSBOX =================
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = m_ring0DirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_PREDOSBOX;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStream;

    DxApi(DD_DXAPI_REGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_REGISTER_CALLBACK failed.\n"));
        TRAP();
        return FALSE;
    }

    // =============== DDEVENT_POSTDOSBOX ================
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = m_ring0DirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_POSTDOSBOX;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStream;

    DxApi(DD_DXAPI_REGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_REGISTER_CALLBACK failed.\n"));
        TRAP();
        return FALSE;
    }

    return TRUE;
}


BOOL CDecoderVideoPort::UnregisterForDirectDrawEvents( CWDMVideoPortStream* pStream)
{
    DDREGISTERCALLBACK ddRegisterCallback;
    DWORD ddOut;

//    DBGTRACE(("Stream %d UNregistering for DirectDraw events\n", m_pStreamObject->StreamNumber));
    
    // =============== DDEVENT_PRERESCHANGE ===============
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = m_ring0DirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_PRERESCHANGE ;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStream;

    DxApi(DD_DXAPI_UNREGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_UNREGISTER_CALLBACK failed.\n"));
        TRAP();
        return FALSE;
    }

    // =============== DDEVENT_POSTRESCHANGE ==============
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = m_ring0DirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_POSTRESCHANGE;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStream;

    DxApi(DD_DXAPI_UNREGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_UNREGISTER_CALLBACK failed.\n"));
        TRAP();
        return FALSE;
    }

    // =============== DDEVENT_PREDOSBOX ==================
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = m_ring0DirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_PREDOSBOX;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStream;

    DxApi(DD_DXAPI_UNREGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_UNREGISTER_CALLBACK failed.\n"));
        TRAP();
        return FALSE;
    }

    // =============== DDEVENT_POSTDOSBOX =================
    RtlZeroMemory(&ddRegisterCallback, sizeof(ddRegisterCallback));
    RtlZeroMemory(&ddOut, sizeof(ddOut));

    ddRegisterCallback.hDirectDraw = m_ring0DirectDrawHandle;
    ddRegisterCallback.dwEvents = DDEVENT_POSTDOSBOX;
    ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
    ddRegisterCallback.pContext = pStream;

    DxApi(DD_DXAPI_UNREGISTER_CALLBACK, &ddRegisterCallback, sizeof(ddRegisterCallback), &ddOut, sizeof(ddOut));

    if (ddOut != DD_OK)
    {
        DBGERROR(("DD_DXAPI_UNREGISTER_CALLBACK failed.\n"));
        TRAP();
        return FALSE;
    }
    
    return TRUE;
}


BOOL CDecoderVideoPort::GetRing0DirectDrawHandle()
{
    if (m_ring0DirectDrawHandle == 0)
    {
//        DBGTRACE(("Stream %d getting ring0 ddraw handle\n", streamNumber));
        
        DDOPENDIRECTDRAWIN  ddOpenIn;
        DDOPENDIRECTDRAWOUT ddOpenOut;

        RtlZeroMemory(&ddOpenIn, sizeof(ddOpenIn));
        RtlZeroMemory(&ddOpenOut, sizeof(ddOpenOut));

        ddOpenIn.dwDirectDrawHandle = m_ring3DirectDrawHandle;
        ddOpenIn.pfnDirectDrawClose = DirectDrawEventCallback;
        ddOpenIn.pContext = this;

        DxApi(DD_DXAPI_OPENDIRECTDRAW, &ddOpenIn, sizeof(ddOpenIn), &ddOpenOut, sizeof(ddOpenOut));

        if (ddOpenOut.ddRVal != DD_OK)
        {
            m_ring0DirectDrawHandle = 0;
            DBGERROR(("DD_DXAPI_OPENDIRECTDRAW failed.\n"));
            TRAP();
            return FALSE;
        }
        else
        {
            m_ring0DirectDrawHandle = ddOpenOut.hDirectDraw;
        }
    }
    return TRUE;
}
    

BOOL CDecoderVideoPort::GetRing0VideoPortHandle()
{
    if (m_ring0VideoPortHandle == 0)
    {
//        DBGTRACE(("Stream %d getting ring0 vport handle\n", streamNumber));
        
        DDOPENVIDEOPORTIN  ddOpenVPIn;
        DDOPENVIDEOPORTOUT ddOpenVPOut;
        RtlZeroMemory(&ddOpenVPIn, sizeof(ddOpenVPIn));
        RtlZeroMemory(&ddOpenVPOut, sizeof(ddOpenVPOut));

        ddOpenVPIn.hDirectDraw = m_ring0DirectDrawHandle;
        ddOpenVPIn.pfnVideoPortClose = DirectDrawEventCallback;
        ddOpenVPIn.pContext = this;

        ddOpenVPIn.dwVideoPortHandle = m_ring3VideoPortHandle;
        
        DxApi(DD_DXAPI_OPENVIDEOPORT, &ddOpenVPIn, sizeof(ddOpenVPIn), &ddOpenVPOut, sizeof(ddOpenVPOut));

        if (ddOpenVPOut.ddRVal != DD_OK)
        {
            m_ring0VideoPortHandle = 0;
            DBGERROR(("DD_DXAPI_OPENVIDEOPORT failed.\n"));
            TRAP();
            return FALSE;
        }
        else
        {
            m_ring0VideoPortHandle = ddOpenVPOut.hVideoPort;
        }
    }    
    return TRUE;
}


BOOL CDecoderVideoPort::ConfigVideoPortHandle(ULONG info)
{
    if (m_ring3VideoPortHandle == -1)
    {
        m_ring3VideoPortHandle = info;
        
        if (!GetRing0VideoPortHandle())
        {
            return FALSE;
        }
    }
    return TRUE;
}


BOOL CDecoderVideoPort::ConfigDirectDrawHandle(ULONG_PTR info)
{
    if (m_ring3DirectDrawHandle == NULL)
    {
        m_ring3DirectDrawHandle = info;
        
        if (!GetRing0DirectDrawHandle())
        {
            return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\decdev.cpp ===
//==========================================================================;
//
//  Video Decoder Device abstract base class implementation
//
//      $Date:   28 Aug 1998 14:43:00  $
//  $Revision:   1.2  $
//    $Author:   Tashjian  $
//
// $Copyright:  (c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;


extern "C"
{
#include "strmini.h"
#include "ksmedia.h"
}

#include "wdmdrv.h"
#include "decdev.h"

#include "capdebug.h"

#include "wdmvdec.h"

/*^^*
 *      CVideoDecoderDevice()
 * Purpose  : CVideoDecoderDevice class constructor
 *
 * Inputs   : PDEVICE_OBJECT pDeviceObject      : pointer to the Driver object to access the Registry
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/

CVideoDecoderDevice::CVideoDecoderDevice()
        : m_pDecoder(NULL),
          m_bOutputEnabledSet(FALSE)
{
}

CVideoDecoderDevice::~CVideoDecoderDevice()
{
}

// -------------------------------------------------------------------
// XBar Property Set functions
// -------------------------------------------------------------------

//
// The only property to set on the XBar selects the input to use
//

/* Method: CVideoDecoderDevice::SetCrossbarProperty
 * Purpose:
 */
VOID CVideoDecoderDevice::SetCrossbarProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
   PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
   ULONG Id  = pSPD->Property->Id;              // index of the property

   pSrb->Status = STATUS_SUCCESS;

   switch (Id) {
   case KSPROPERTY_CROSSBAR_ROUTE:
      ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_CROSSBAR_ROUTE_S));
      {
         PKSPROPERTY_CROSSBAR_ROUTE_S  pRoute =
            (PKSPROPERTY_CROSSBAR_ROUTE_S)pSPD->PropertyInfo;

         ULONG InPin, OutPin;
         InPin  = pRoute->IndexInputPin;
         OutPin = pRoute->IndexOutputPin;

         if (GoodPins(InPin, OutPin) && TestRoute(InPin, OutPin)) {

            SetVideoInput((Connector)InPin);

            // this just sets the association
            Route(OutPin, InPin);
         }
         else {

           pSrb->Status = STATUS_INVALID_PARAMETER;
         }
      }
      break;
   default:
      TRAP();
      pSrb->Status = STATUS_NOT_IMPLEMENTED;
      break;
   }
}

/* Method: CVideoDecoderDevice::GetCrossbarProperty
 * Purpose:
 */
VOID CVideoDecoderDevice::GetCrossbarProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
   PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
   ULONG Id = pSPD->Property->Id;              // index of the property

   pSrb->Status = STATUS_SUCCESS;

   // Property set specific structure

   switch (Id)
   {
   case KSPROPERTY_CROSSBAR_CAPS:                  // R
      ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_CROSSBAR_CAPS_S));
      {
         PKSPROPERTY_CROSSBAR_CAPS_S  pCaps =
            (PKSPROPERTY_CROSSBAR_CAPS_S)pSPD->PropertyInfo;

         // Copy the input property info to the output property info
         RtlCopyMemory(pCaps, pSPD->Property, sizeof KSPROPERTY_CROSSBAR_CAPS_S);

         pCaps->NumberOfInputs  = GetNoInputs();
         pCaps->NumberOfOutputs = GetNoOutputs();

         pSrb->ActualBytesTransferred = sizeof KSPROPERTY_CROSSBAR_CAPS_S;
      }
      break;

   case KSPROPERTY_CROSSBAR_CAN_ROUTE:
      ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_CROSSBAR_ROUTE_S));
      {
         PKSPROPERTY_CROSSBAR_ROUTE_S  pRoute =
            (PKSPROPERTY_CROSSBAR_ROUTE_S)pSPD->PropertyInfo;

         // Copy the input property info to the output property info
         RtlCopyMemory(pRoute, pSPD->Property, sizeof KSPROPERTY_CROSSBAR_ROUTE_S);

         ULONG InPin, OutPin;
         InPin  = pRoute->IndexInputPin;
         OutPin = pRoute->IndexOutputPin;

         if (GoodPins(InPin, OutPin)) {
            pRoute->CanRoute = TestRoute(InPin, OutPin);
         } else {
            pRoute->CanRoute = FALSE;
         }
         pSrb->ActualBytesTransferred = sizeof KSPROPERTY_CROSSBAR_ROUTE_S;
      }
      break;

   case KSPROPERTY_CROSSBAR_ROUTE:
      ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_CROSSBAR_ROUTE_S));
      {
         PKSPROPERTY_CROSSBAR_ROUTE_S  pRoute =
            (PKSPROPERTY_CROSSBAR_ROUTE_S)pSPD->PropertyInfo;

         // Copy the input property info to the output property info
         RtlCopyMemory(pRoute, pSPD->Property, sizeof KSPROPERTY_CROSSBAR_ROUTE_S);

         ULONG OutPin = pRoute->IndexOutputPin;

         if (OutPin < GetNoOutputs())
            pRoute->IndexInputPin = GetRoute(OutPin);
         else
            pRoute->IndexInputPin = (ULONG)-1;

         pSrb->ActualBytesTransferred = sizeof KSPROPERTY_CROSSBAR_ROUTE_S;
      }
      break;

   case KSPROPERTY_CROSSBAR_PININFO:                     // R
      ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_CROSSBAR_PININFO_S));
      {
         PKSPROPERTY_CROSSBAR_PININFO_S  pPinInfo =
            (PKSPROPERTY_CROSSBAR_PININFO_S)pSPD->PropertyInfo;

         // Copy the input property info to the output property info
         RtlCopyMemory(pPinInfo, pSPD->Property, sizeof KSPROPERTY_CROSSBAR_PININFO_S);

         if (pPinInfo->Direction == KSPIN_DATAFLOW_IN) {

            if (pPinInfo->Index >= GetNoInputs()) {

               pSrb->Status = STATUS_INVALID_PARAMETER;
               break;
            }
         }
         else
         if (pPinInfo->Direction == KSPIN_DATAFLOW_OUT) {

            if (pPinInfo->Index >= GetNoOutputs()) {

               pSrb->Status = STATUS_INVALID_PARAMETER;
               break;
            }
         }
         else {

            pSrb->Status = STATUS_INVALID_PARAMETER;
            break;
         }

         pPinInfo->PinType = GetPinInfo(pPinInfo->Direction,
            pPinInfo->Index, 
            pPinInfo->RelatedPinIndex);

         pPinInfo->Medium = * GetPinMedium(pPinInfo->Direction,
            pPinInfo->Index);

         pSrb->ActualBytesTransferred = sizeof KSPROPERTY_CROSSBAR_PININFO_S;
      }
      break;

   default:
      TRAP();
      pSrb->Status = STATUS_NOT_IMPLEMENTED;
      break;
   }
}

// -------------------------------------------------------------------
// Decoder functions
// -------------------------------------------------------------------

/*
** CVideoDecoderDevice::SetDecoderProperty ()
**
**    Handles Set operations on the Decoder property set.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID CVideoDecoderDevice::SetDecoderProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property

    switch (Id)
    {
    case KSPROPERTY_VIDEODECODER_STANDARD:
        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEODECODER_S));
        {
            PKSPROPERTY_VIDEODECODER_S pS = (PKSPROPERTY_VIDEODECODER_S) pSPD->PropertyInfo;

            DBGTRACE(("KSPROPERTY_VIDEODECODER_STANDARD.\n"));

            if (!SetVideoDecoderStandard(pS->Value))
            {
                DBGERROR(("Unsupported video standard.\n"));
                pSrb->Status = STATUS_UNSUCCESSFUL;
            }
        }
        break;

    case KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE:
        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEODECODER_S));
        {
            PKSPROPERTY_VIDEODECODER_S pS = (PKSPROPERTY_VIDEODECODER_S) pSPD->PropertyInfo;

            DBGTRACE(("KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE.\n"));

            // Should we leave this property as it was and add a new
            // property that supports the new behavior? 

            // We probably should allow this if the filter is stopped because
            // the transition to Acquire/Pause/Run will fail if the
            // PreEvent has not been cleared by then. We'll have to add
            // some logic to this class to track the filter's state.

            if (pS->Value && m_pDecoder && m_pDecoder->PreEventOccurred())
            {
                DBGERROR(("Output enabled when preevent has occurred.\n"));
                pSrb->Status = STATUS_UNSUCCESSFUL;
            }
            else
            {
                SetOutputEnabled(pS->Value);
                SetOutputEnabledOverridden(TRUE);
            }
        }
        break;

    default:
        TRAP();
        break;
    }
}

/*
** CVideoDecoderDevice::GetDecoderProperty ()
**
**    Handles Get operations on the Decoder property set.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID CVideoDecoderDevice::GetDecoderProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property

    switch (Id)
    {
    case KSPROPERTY_VIDEODECODER_CAPS:
        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEODECODER_CAPS_S));
        {
            DBGTRACE(("KSPROPERTY_VIDEODECODER_CAPS\n"));

            PKSPROPERTY_VIDEODECODER_CAPS_S  pCaps =
                (PKSPROPERTY_VIDEODECODER_CAPS_S)pSPD->PropertyInfo;

            // Copy the input property info to the output property info
            RtlCopyMemory(pCaps, pSPD->Property, sizeof KSPROPERTY);

            GetVideoDecoderCaps(pCaps);

            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_CAPS_S);
        }
        break;

    case KSPROPERTY_VIDEODECODER_STANDARD:
        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEODECODER_S));
        {
            DBGTRACE(("KSPROPERTY_VIDEODECODER_STANDARD\n"));

            PKSPROPERTY_VIDEODECODER_S  pS =
                (PKSPROPERTY_VIDEODECODER_S)pSPD->PropertyInfo;

            // Copy the input property info to the output property info
            RtlCopyMemory(pS, pSPD->Property, sizeof KSPROPERTY);

            pS->Value = GetVideoDecoderStandard();

            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_S);
        }
        break;

    case KSPROPERTY_VIDEODECODER_STATUS:
        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEODECODER_STATUS_S));
        {
            DBGTRACE(("KSPROPERTY_VIDEODECODER_STATUS\n"));

            PKSPROPERTY_VIDEODECODER_STATUS_S  pS =
                (PKSPROPERTY_VIDEODECODER_STATUS_S)pSPD->PropertyInfo;

            // Copy the input property info to the output property info
            RtlCopyMemory(pS, pSPD->Property, sizeof KSPROPERTY);

            GetVideoDecoderStatus(pS);

            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_STATUS_S);
        }
        break;

    case KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE:
        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEODECODER_S));
        {
            DBGTRACE(("KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE\n"));

            PKSPROPERTY_VIDEODECODER_S pS = (PKSPROPERTY_VIDEODECODER_S) pSPD->PropertyInfo;    // pointer to the data

            // Copy the input property info to the output property info
            RtlCopyMemory(pS, pSPD->Property, sizeof KSPROPERTY);

            pS->Value = IsOutputEnabled();

            pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_S);
        }
        break;

    default:
        TRAP();
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\decvport.h ===
#pragma once

//==========================================================================;
//
//  CDecoderVideoPort - Video Port interface definitions
//
//      $Date:   14 Oct 1998 15:11:14  $
//  $Revision:   1.1  $
//    $Author:   Tashjian  $
//
// $Copyright:  (c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;


#include "i2script.h"
#include "aticonfg.h"


#define DD_OK 0


class CWDMVideoPortStream;

class CDecoderVideoPort
{
public:
    CDecoderVideoPort(PDEVICE_OBJECT pDeviceObject);

// Attributes   
private:
    PDEVICE_OBJECT          m_pDeviceObject;    

    CATIHwConfiguration *   m_pCATIConfig;

    ULONG                   m_ring3VideoPortHandle;
    ULONG_PTR               m_ring3DirectDrawHandle;

    HANDLE                  m_ring0VideoPortHandle;
    HANDLE                  m_ring0DirectDrawHandle;

    BOOL GetRing0VideoPortHandle();
    BOOL GetRing0DirectDrawHandle();
    
    // Implementation
public:
    void Open();
    void Close();

    BOOL RegisterForDirectDrawEvents( CWDMVideoPortStream* pStream);
    BOOL UnregisterForDirectDrawEvents( CWDMVideoPortStream* pStream);

    BOOL ReleaseRing0VideoPortHandle();
    BOOL ReleaseRing0DirectDrawHandle();        

    BOOL ConfigVideoPortHandle(ULONG info);
    BOOL ConfigDirectDrawHandle(ULONG_PTR info);

    HANDLE GetVideoPortHandle()     { return m_ring0VideoPortHandle; }
    HANDLE GetDirectDrawHandle()    { return m_ring0DirectDrawHandle; }

    void CloseDirectDraw() {
                m_ring0DirectDrawHandle = 0;
                m_ring3DirectDrawHandle = 0;
        }

    void CloseVideoPort()  {
                m_ring0VideoPortHandle = 0;
                m_ring3VideoPortHandle = -1;
        }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\drventry.cpp ===
//==========================================================================;
//
//  MiniDriver entry points for stream class driver
//
//      $Date:   05 Aug 1998 11:11:18  $
//  $Revision:   1.0  $
//    $Author:   Tashjian  $
//
// $Copyright:  (c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"
}


#include "DrvEntry.h"
#include "wdmvdec.h"
#include "wdmdrv.h"
#include "capdebug.h"
#include "VidStrm.h"


/*^^*
 *      DriverEntry()
 * Purpose  : Called when an SRB_INITIALIZE_DEVICE request is received
 *
 * Inputs   : IN PDRIVER_OBJECT     pDriverObject
 *            IN PUNICODE_STRING    pRegistryPath
 *
 * Outputs  : result of StreamClassregisterAdapter()
 * Author   : IKLEBANOV
 *^^*/
extern "C" 
ULONG DriverEntry ( IN PDRIVER_OBJECT   pDriverObject,
                    IN PUNICODE_STRING  pRegistryPath )
{
    HW_INITIALIZATION_DATA HwInitData;

    SetMiniDriverDebugLevel(pRegistryPath);

    DBGTRACE(("DriverEntry\n"));
     
    RtlZeroMemory(&HwInitData, sizeof(HwInitData));

    HwInitData.HwInitializationDataSize = sizeof(HwInitData);

    // Entry points for Port Driver

    HwInitData.HwInterrupt                  = NULL; // HwInterrupt;

    HwInitData.HwReceivePacket              = ReceivePacket;
    HwInitData.HwCancelPacket               = CancelPacket;
    HwInitData.HwRequestTimeoutHandler      = TimeoutPacket;

    HwInitData.DeviceExtensionSize          = DeivceExtensionSize();
    HwInitData.PerRequestExtensionSize      = sizeof(SRB_DATA_EXTENSION); 
    HwInitData.FilterInstanceExtensionSize  = 0;
    HwInitData.PerStreamExtensionSize       = streamDataExtensionSize;
    HwInitData.BusMasterDMA                 = FALSE;  
    HwInitData.Dma24BitAddresses            = FALSE;
    HwInitData.BufferAlignment              = 3;
    HwInitData.TurnOffSynchronization       = TRUE;
    HwInitData.DmaBufferSize                = 0;

    DBGTRACE(("StreamClassRegisterAdapter\n"));

    return(StreamClassRegisterAdapter(pDriverObject, pRegistryPath, &HwInitData));
}

/*^^*
 *      ReceivePacket()
 * Purpose  : Main entry point for receiving adapter based request SRBs from the Class Driver.
 *              Will always be called at High Priority.
 * Note     : This is an asyncronous entry point.  The request does not complete on return from 
 *              this function, the request only completes when a StreamClassDeviceNotification 
 *              on this request block, of type  DeviceRequestComplete, is issued.
 *
 * Inputs   : PHW_STREAM_REQUEST_BLOCK pSrb : pointer to the current Srb
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/

void STREAMAPI ReceivePacket(IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    DBGINFO(("ReceivePacket() SRB = %x, Command = %x\n",
        pSrb, pSrb->Command));

    // This needs to be a special case because no spinlocks, etc
    // have been initialized until HwInitialize runs. Even though
    // this minidriver handles synchronization itself, it assumes
    // that no adapter SRBs will arrive until after this one
    // completes.
    if (pSrb->Command == SRB_INITIALIZE_DEVICE)
    {
        DBGTRACE(("SRB_INITIALIZE_DEVICE; SRB=%x\n", pSrb));

        SrbInitializeDevice(pSrb);
        StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
    }
    else
    {
        CWDMVideoDecoder* pCWDMVideoDecoder = (CWDMVideoDecoder*)pSrb->HwDeviceExtension;

        // check the device extension pointer
        if(pCWDMVideoDecoder == NULL)
        {
            DBGERROR(("ReceivePacket(): Device extension pointer is null!\n"));
            TRAP();
            pSrb->Status = STATUS_INVALID_PARAMETER;
            StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
        }
        else
            pCWDMVideoDecoder->ReceivePacket(pSrb);
    }
}


void STREAMAPI CancelPacket(IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    CWDMVideoDecoder* pCWDMVideoDecoder = (CWDMVideoDecoder*)pSrb->HwDeviceExtension;

    pCWDMVideoDecoder->CancelPacket(pSrb);
}


void STREAMAPI TimeoutPacket(IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    CWDMVideoDecoder* pCWDMVideoDecoder = (CWDMVideoDecoder*)pSrb->HwDeviceExtension;

    pCWDMVideoDecoder->TimeoutPacket(pSrb);
}



/*^^*
 *      SrbInitializeDevice()
 * Purpose  : Called when SRB_INITIALIZE_DEVICE SRB is received.
 *              Performs checking of the hardware presence and I2C provider availability.
 *              Sets the hardware in an initial state.
 * Note     : The request does not completed unless we know everything
 *              about the hardware and we are sure it is capable to work in the current configuration.
 *              The hardware Caps are also aquised at this point.
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/

void SrbInitializeDevice(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    DBGTRACE(("SrbInitializeDevice()\n"));

    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;

    pSrb->Status = STATUS_SUCCESS;

    ENSURE
    {
        PBYTE pHwDevExt = (PBYTE)pConfigInfo->HwDeviceExtension;

        if (pConfigInfo->NumberOfAccessRanges != 0) {
            DBGERROR(("Illegal config info!\n"));
            pSrb->Status = STATUS_NO_SUCH_DEVICE;
            TRAP();
            FAIL;
        }

        CVideoDecoderDevice * pDevice = InitializeDevice(pConfigInfo, pHwDevExt);
        if (!pDevice)
        {
            DBGERROR(("CI2CScript creation failure!\n"));
            pSrb->Status = STATUS_NO_SUCH_DEVICE;
            TRAP();
            FAIL;
        }

        CWDMVideoDecoder *pCWDMVideoDecoder = (CWDMVideoDecoder *) new ((PVOID)pHwDevExt)
                CWDMVideoDecoder(pConfigInfo, pDevice);
    
    } END_ENSURE;
    
    DBGTRACE(("Exit : SrbInitializeDevice()\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\drventry.h ===
#pragma once

//==========================================================================;
//
//	MiniDriver entry points for stream class driver
//
//		$Date:   05 Aug 1998 11:22:42  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"
}

#include "wdmvdec.h"

//	Call-backs from the StreamClass
void STREAMAPI ReceivePacket		(PHW_STREAM_REQUEST_BLOCK pSrb);
void STREAMAPI CancelPacket			(PHW_STREAM_REQUEST_BLOCK pSrb);
void STREAMAPI TimeoutPacket		(PHW_STREAM_REQUEST_BLOCK pSrb);


// Local prototypes
void SrbInitializeDevice(PHW_STREAM_REQUEST_BLOCK pSrb);
CVideoDecoderDevice * InitializeDevice(PPORT_CONFIGURATION_INFORMATION, PBYTE);
size_t DeivceExtensionSize();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\mediums.cpp ===
//==========================================================================;
//
//	WDM Video Decoder Mediums
//
//		$Date:   05 Aug 1998 11:11:12  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"
}

#include "mediums.h"


KSPIN_MEDIUM CrossbarMediums[] = {
    {STATIC_MEDIUM_ATIXBAR_VIDEOCOMPOUT,        0, 0},  // Pin 0
    {STATIC_MEDIUM_ATIXBAR_VIDEOTUNEROUT,       0, 0},  // Pin 1
    {STATIC_MEDIUM_ATIXBAR_SVIDEOOUT,           0, 0},  // Pin 2
    {STATIC_MEDIUM_VIDEO_BT829_ANALOGVIDEOIN,   0, 0},  // Pin 3
};

BOOL CrossbarPinDirection [] = {
    FALSE,                      // Input  Pin 0
    FALSE,                      // Input  Pin 1
    FALSE,                      // Input  Pin 2
    TRUE,                       // Output Pin 3
};

// -----------------------------------------------

KSPIN_MEDIUM CaptureMediums[] = {
    {STATIC_GUID_NULL,                          0, 0},  // Pin 0  Vid Capture
    {STATIC_GUID_NULL,                          0, 0},  // Pin 1  Vid VP
    {STATIC_GUID_NULL,                          0, 0},  // Pin 2  VBI Capture
    {STATIC_GUID_NULL,                          0, 0},  // Pin 3  VBI VP
    {STATIC_MEDIUM_VIDEO_BT829_ANALOGVIDEOIN,   0, 0},  // Pin 4  Analog Video In
};

BOOL CapturePinDirection [] = {
    TRUE,                       // Output Pin 0
    TRUE,                       // Output Pin 1
    TRUE,                       // Output Pin 2
    TRUE,                       // Output Pin 3
    FALSE,                      // Input  Pin 4
};

ULONG CrossbarPins()
{
	return SIZEOF_ARRAY (CrossbarMediums);
}

ULONG CapturePins()
{
	return SIZEOF_ARRAY (CaptureMediums);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\mediums.h ===
#pragma once

//==========================================================================;
//
//	WDM Video Decoder Mediums
//
//		$Date:   05 Aug 1998 11:22:40  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

/*
-----------------------------------------------------------

                            PinDir  FilterPin#
    Crossbar
        CompositeIn         in          0
        TunerIn             in          1
        SVideo              in          2
        Decoder             out         3
        
-----------------------------------------------------------
*/

// {6001AFE0-39A7-11d1-821D-0000F8300212}
#define STATIC_MEDIUM_ATIXBAR_VIDEOCOMPOUT \
0x6001afe0, 0x39a7, 0x11d1, 0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12
//  0x6001afe0, 0x39a7, 0x11d1, 0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12
DEFINE_GUIDSTRUCT("6001AFE0-39A7-11d1-821D-0000F8300212", MEDIUM_ATIXBAR_VIDEOCOMPOUT);
#define MEDIUM_ATIXBAR_VIDEOCOMPOUT DEFINE_GUIDNAMED(MEDIUM_ATIXBAR_VIDEOCOMPOUT)

// {AE8F28C0-3346-11d1-821D-0000F8300212}
#define STATIC_MEDIUM_ATIXBAR_VIDEOTUNEROUT \
    0xae8f28c0, 0x3346, 0x11d1,  0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12 
DEFINE_GUIDSTRUCT("AE8F28C0-3346-11d1-821D-0000F8300212", MEDIUM_ATIXBAR_VIDEOTUNEROUT);
#define MEDIUM_ATIXBAR_VIDEOTUNEROUT DEFINE_GUIDNAMED(MEDIUM_ATIXBAR_VIDEOTUNEROUT)

// {6001AFE1-39A7-11d1-821D-0000F8300212}
#define STATIC_MEDIUM_ATIXBAR_SVIDEOOUT \
0x6001afe1, 0x39a7, 0x11d1, 0x82, 0x1d, 0x0, 0x0, 0xf8, 0x30, 0x2, 0x12 
DEFINE_GUIDSTRUCT("6001AFE1-39A7-11d1-821D-0000F8300212", MEDIUM_ATIXBAR_SVIDEOOUT);
#define MEDIUM_ATIXBAR_SVIDEOOUT DEFINE_GUIDNAMED(MEDIUM_ATIXBAR_SVIDEOOUT)

// {CEA3DBE0-0A58-11d1-A317-00A0C90C484A}
#define STATIC_MEDIUM_VIDEO_BT829_ANALOGVIDEOIN \
    0xcea3dbe0, 0xa58, 0x11d1, 0xa3, 0x17, 0x0, 0xa0, 0xc9, 0xc, 0x48, 0x4a
DEFINE_GUIDSTRUCT("CEA3DBE0-0A58-11d1-A317-00A0C90C484A", MEDIUM_VIDEO_BT829_ANALOGVIDEOIN);
#define MEDIUM_VIDEO_BT829_ANALOGVIDEOIN DEFINE_GUIDNAMED(MEDIUM_VIDEO_BT829_ANALOGVIDEOIN)


extern KSPIN_MEDIUM CrossbarMediums[];
extern KSPIN_MEDIUM CaptureMediums[];

extern BOOL CrossbarPinDirection [];
extern BOOL CapturePinDirection [];

extern ULONG CrossbarPins();
extern ULONG CapturePins();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\vidstrm.cpp ===
//==========================================================================;
//
//  CWDMVideoStream - WDM Video Stream base class implementation
//
//      $Date:   05 Aug 1998 11:10:52  $
//  $Revision:   1.0  $
//    $Author:   Tashjian  $
//
// $Copyright:  (c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"
}

#include "wdmvdec.h"
#include "wdmdrv.h"
#include "device.h"
#include "aticonfg.h"
#include "capdebug.h"
#include "StrmInfo.h"


/*
** VideoReceiveDataPacket()
**
**   Receives Video data packet commands
**
** Arguments:
**
**   pSrb - Stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID STREAMAPI VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
    CWDMVideoStream * pVideoStream = (CWDMVideoStream *)pSrb->StreamObject->HwStreamExtension;
    pVideoStream->VideoReceiveDataPacket(pSrb);
}


/*
** VideoReceiveCtrlPacket()
**
**   Receives packet commands that control the Video stream
**
** Arguments:
**
**   pSrb - The stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID STREAMAPI VideoReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
    CWDMVideoStream * pVideoStream = (CWDMVideoStream *)pSrb->StreamObject->HwStreamExtension;
    pVideoStream->VideoReceiveCtrlPacket(pSrb);
}




void CWDMVideoStream::TimeoutPacket(IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    if (m_KSState == KSSTATE_STOP || !m_pVideoDecoder->PreEventOccurred())
    {
        DBGTRACE(("Suspicious timeout. SRB %8x. \n", pSrb));
    }
}



CWDMVideoStream::CWDMVideoStream(PHW_STREAM_OBJECT pStreamObject, 
                        CWDMVideoDecoder * pVideoDecoder,
                        PUINT puiErrorCode)
    :   m_pStreamObject(pStreamObject),
        m_pVideoDecoder(pVideoDecoder)
{
    DBGTRACE(("CWDMVideoStream::CWDMVideoStream\n"));

    m_pVideoPort = m_pVideoDecoder->GetVideoPort();
    m_pDevice = m_pVideoDecoder->GetDevice();

    KeInitializeSpinLock(&m_ctrlSrbLock);
    InitializeListHead(&m_ctrlSrbQueue);

    m_KSState = KSSTATE_STOP;
 
    *puiErrorCode = WDMMINI_NOERROR;
}


CWDMVideoStream::~CWDMVideoStream()
{
    KIRQL Irql;

    DBGTRACE(("CWDMVideoStream::~CWDMVideoStream()\n"));

    KeAcquireSpinLock(&m_ctrlSrbLock, &Irql);
    if (!IsListEmpty(&m_ctrlSrbQueue))
    {
        TRAP();
    }
    KeReleaseSpinLock(&m_ctrlSrbLock, Irql);
}


/*
** VideoReceiveDataPacket()
**
**   Receives Video data packet commands
**
** Arguments:
**
**   pSrb - Stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID STREAMAPI CWDMVideoStream::VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
    ASSERT(pSrb->StreamObject->StreamNumber == STREAM_AnalogVideoInput);

    ASSERT(pSrb->Irp->MdlAddress);
    
    DBGINFO(("Receiving SD---- SRB=%x\n", pSrb));

    pSrb->Status = STATUS_SUCCESS;
    
    switch (pSrb->Command) {

        case SRB_WRITE_DATA:
            
            m_pVideoDecoder->ReceivePacket(pSrb);
            break;

        default:

            //
            // invalid / unsupported command. Fail it as such
            //

            TRAP();

            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            StreamClassStreamNotification(  StreamRequestComplete,
                                            pSrb->StreamObject,
                                            pSrb);
            break;
    }
}

/*
** VideoReceiveCtrlPacket()
**
**   Receives packet commands that control the Video stream
**
** Arguments:
**
**   pSrb - The stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID STREAMAPI CWDMVideoStream::VideoReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{
    KIRQL Irql;
    PSRB_DATA_EXTENSION pSrbExt;

    KeAcquireSpinLock(&m_ctrlSrbLock, &Irql);
    if (m_processingCtrlSrb)
    {
        pSrbExt = (PSRB_DATA_EXTENSION)pSrb->SRBExtension;
        pSrbExt->pSrb = pSrb;
        InsertTailList(&m_ctrlSrbQueue, &pSrbExt->srbListEntry);
        KeReleaseSpinLock(&m_ctrlSrbLock, Irql);
        return;
    }

    m_processingCtrlSrb = TRUE;
    KeReleaseSpinLock(&m_ctrlSrbLock, Irql);

    // This will run until the queue is empty
    while (TRUE)
    {
        // Assume success. Might be changed below
    
        pSrb->Status = STATUS_SUCCESS;

        switch (pSrb->Command)
        {
            case SRB_GET_STREAM_STATE:
                VideoGetState(pSrb);
                break;

            case SRB_SET_STREAM_STATE:
                {
                    BOOL bVPConnected, bVPVBIConnected;
                    PDEVICE_DATA_EXTENSION pDevExt = (PDEVICE_DATA_EXTENSION)pSrb->HwDeviceExtension;

                    bVPConnected = pDevExt->CWDMDecoder.IsVideoPortPinConnected();
                    bVPVBIConnected = pDevExt->CDevice.IsVBIEN();

                    VideoSetState(pSrb, bVPConnected, bVPVBIConnected);
                }
                break;

            case SRB_GET_STREAM_PROPERTY:
                VideoGetProperty(pSrb);
                break;

            case SRB_SET_STREAM_PROPERTY:
                VideoSetProperty(pSrb);
                break;

            case SRB_INDICATE_MASTER_CLOCK:
                VideoIndicateMasterClock (pSrb);
                break;

           case SRB_PROPOSE_DATA_FORMAT:
                // This may be inappropriate for Bt829. CHECK!!!
                DBGERROR(("Propose Data format\n"));

                if (!(AdapterVerifyFormat (
                    pSrb->CommandData.OpenFormat, 
                    pSrb->StreamObject->StreamNumber))) {
                    pSrb->Status = STATUS_NO_MATCH;
                }
                break;
            default:
                TRAP();
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;
        }

        StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb);

        KeAcquireSpinLock(&m_ctrlSrbLock, &Irql);
        if (IsListEmpty(&m_ctrlSrbQueue))
        {
            m_processingCtrlSrb = FALSE;
            KeReleaseSpinLock(&m_ctrlSrbLock, Irql);
            return;
        }
        else
        {
            pSrbExt = (PSRB_DATA_EXTENSION)RemoveHeadList(&m_ctrlSrbQueue);
            KeReleaseSpinLock(&m_ctrlSrbLock, Irql);
            pSrb = pSrbExt->pSrb;
        }
    }
}


/*
** VideoSetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMVideoStream::VideoSetProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    DBGERROR(("CWDMVideoStream::VideoSetProperty called"));
    pSrb->Status = STATUS_NOT_IMPLEMENTED;
}

/*
** VideoGetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMVideoStream::VideoGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID (KSPROPSETID_Connection, pSPD->Property->Set)) {
        VideoStreamGetConnectionProperty (pSrb);
    }
    else {
       pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }
}

/*
** VideoSetState()
**
**    Sets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMVideoStream::VideoSetState(PHW_STREAM_REQUEST_BLOCK pSrb, BOOL bVPConnected, BOOL bVPVBIConnected)
{
    //
    // For each stream, the following states are used:
    // 
    // Stop:    Absolute minimum resources are used.  No outstanding IRPs.
    // Pause:   Getting ready to run.  Allocate needed resources so that 
    //          the eventual transition to Run is as fast as possible.
    //          SRBs will be queued at either the Stream class or in your
    //          driver.
    // Run:     Streaming. 
    //
    // Moving to Stop or Run ALWAYS transitions through Pause, so that ONLY 
    // the following transitions are possible:
    //
    // Stop -> Pause
    // Pause -> Run
    // Run -> Pause
    // Pause -> Stop
    //
    // Note that it is quite possible to transition repeatedly between states:
    // Stop -> Pause -> Stop -> Pause -> Run -> Pause -> Run -> Pause -> Stop
    //

    DBGINFO(("CWDMVideoStream::VideoSetState for stream %d\n", pSrb->StreamObject->StreamNumber));

    pSrb->Status = STATUS_SUCCESS;

    switch (pSrb->CommandData.StreamState)  

    {
        case KSSTATE_STOP:
            DBGINFO(("   state KSSTATE_STOP"));

            // Reset the overridden flag so that the next time we go to the
            // Run state, output will be enabled (unless the app overrides
            // it again later). We should really do this after the graph
            // has been stopped so that if a filter that has yet to be stopped
            // cleans up by clearing the flag, it is not considered to be
            // overriding it again. Since we are not called after the graph
            // has been fully stopped, this is the best we can do.
            //
            // An alternative (and probably less confusing) approach is to
            // leave the overridden flag set and force the app to control
            // the output enabled feature if it changes it once.
            //
            // We have decided to follow the latter approach.

            // m_pDevice->SetOutputEnabledOverridden(FALSE);
            break;

        case KSSTATE_ACQUIRE:
            DBGINFO(("   state KSSTATE_ACQUIRE"));
            ASSERT(m_KSState == KSSTATE_STOP);
            break;

        case KSSTATE_PAUSE:
            DBGINFO(("   state KSSTATE_PAUSE"));
           
            if (m_pVideoDecoder->PreEventOccurred() &&
                (!m_pDevice->IsOutputEnabledOverridden() || m_pDevice->IsOutputEnabled()) &&
                        (m_KSState == KSSTATE_STOP || m_KSState == KSSTATE_ACQUIRE))
            {
                DBGERROR(("VidStrm Pause: Overridden = %d, OutputEnabled = %d",
                          m_pDevice->IsOutputEnabledOverridden(),
                          m_pDevice->IsOutputEnabled()
                        ));
                pSrb->Status = STATUS_UNSUCCESSFUL;
            }
            break;

        case KSSTATE_RUN:
            DBGINFO(("   state KSSTATE_RUN"));
            ASSERT(m_KSState == KSSTATE_ACQUIRE || m_KSState == KSSTATE_PAUSE);

            if (m_pVideoDecoder->PreEventOccurred() &&
                (!m_pDevice->IsOutputEnabledOverridden() || m_pDevice->IsOutputEnabled()))
            {
                DBGERROR(("VidStrm Run: Overridden = %d, OutputEnabled = %d",
                          m_pDevice->IsOutputEnabledOverridden(),
                          m_pDevice->IsOutputEnabled()
                        ));
                pSrb->Status = STATUS_UNSUCCESSFUL;
            }
            break;
    }

    if (pSrb->Status == STATUS_SUCCESS) {
        m_KSState = pSrb->CommandData.StreamState;
        DBGINFO((" entered\n"));
    }
    else
        DBGINFO((" NOT entered ***\n"));
}

/*
** VideoGetState()
**
**    Gets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMVideoStream::VideoGetState(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    pSrb->CommandData.StreamState = m_KSState;
    pSrb->ActualBytesTransferred = sizeof (KSSTATE);

    // A very odd rule:
    // When transitioning from stop to pause, DShow tries to preroll
    // the graph.  Capture sources can't preroll, and indicate this
    // by returning VFW_S_CANT_CUE in user mode.  To indicate this
    // condition from drivers, they must return ERROR_NO_DATA_DETECTED

    if (m_KSState == KSSTATE_PAUSE) {
       pSrb->Status = STATUS_NO_DATA_DETECTED;
    }
}


VOID CWDMVideoStream::VideoStreamGetConnectionProperty (PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    PKSALLOCATOR_FRAMING Framing = (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;

    ASSERT(pSPD->Property->Id == KSPROPERTY_CONNECTION_ALLOCATORFRAMING);
    if (pSPD->Property->Id == KSPROPERTY_CONNECTION_ALLOCATORFRAMING) {

        RtlZeroMemory(Framing, sizeof(KSALLOCATOR_FRAMING));

        Framing->RequirementsFlags   =
            KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY |
            KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
            KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY;
        Framing->PoolType = NonPagedPool;
        Framing->Frames = 1;
        Framing->FrameSize = 
            pSrb->StreamObject->StreamNumber == STREAM_AnalogVideoInput ?
                sizeof(KS_TVTUNER_CHANGE_INFO) : 1;
        Framing->FileAlignment = 0;//FILE_QUAD_ALIGNMENT;// PAGE_SIZE - 1;

        pSrb->ActualBytesTransferred = sizeof(KSALLOCATOR_FRAMING);
    }
    else {

        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }
}


//==========================================================================;
//                   Clock Handling Routines
//==========================================================================;


/*
** VideoIndicateMasterClock ()
**
**    If this stream is not being used as the master clock, this function
**      is used to provide us with a handle to the clock to use.
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMVideoStream::VideoIndicateMasterClock(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    m_hMasterClock = pSrb->CommandData.MasterClockHandle;
}



DWORD FAR PASCAL DirectDrawEventCallback(DWORD dwEvent, PVOID pContext, DWORD dwParam1, DWORD dwParam2)
{
    CDecoderVideoPort* pCDecoderVideoPort = (CDecoderVideoPort*) pContext;
    CWDMVideoPortStream* pCWDMVideoPortStream = (CWDMVideoPortStream*) pContext;
    CWDMCaptureStream* pCWDMCaptureStream = (CWDMVideoCaptureStream*) pContext;

    switch (dwEvent)
    {
        case DDNOTIFY_PRERESCHANGE:
            pCWDMVideoPortStream->PreResChange();
            break;

        case DDNOTIFY_POSTRESCHANGE:
            pCWDMVideoPortStream->PostResChange();
            break;

        case DDNOTIFY_PREDOSBOX:
            pCWDMVideoPortStream->PreDosBox();
            break;

        case DDNOTIFY_POSTDOSBOX:
            pCWDMVideoPortStream->PostDosBox();
            break;

        case DDNOTIFY_CLOSECAPTURE:
            pCWDMCaptureStream->CloseCapture();
            break;

        case DDNOTIFY_CLOSEDIRECTDRAW:
            pCDecoderVideoPort->CloseDirectDraw();
            break;

        case DDNOTIFY_CLOSEVIDEOPORT:
            pCDecoderVideoPort->CloseVideoPort();
            break;

        default:
            TRAP();
            break;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\ourcrt.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifdef __cplusplus
extern "C" {

#include "strmini.h"
#include "ksmedia.h"
}
#endif

extern "C" const int _fltused = 0;

/*
 * This function serves to avoid linking CRT code
 */

int __cdecl  _purecall(void)
{
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\vidstrm.h ===
#pragma once

//==========================================================================;
//
//	CWDMVideoStream - WDM Video Stream base class definition
//
//		$Date:   22 Feb 1999 15:48:34  $
//	$Revision:   1.2  $
//	  $Author:   KLEBANOV  $
//
// $Copyright:	(c) 1997 - 1999  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "i2script.h"
#include "aticonfg.h"


#include "decdev.h"
#include "decvport.h"


typedef enum {
    STREAM_VideoCapture,
    STREAM_VPVideo,
    STREAM_VBICapture,
    STREAM_VPVBI,
    STREAM_AnalogVideoInput
}; 


class CWDMVideoDecoder;

class CWDMVideoStream
{
public:

	CWDMVideoStream(PHW_STREAM_OBJECT pStreamObject,
					CWDMVideoDecoder * pCWDMVideoDecoder,
					PUINT puiError);
	virtual ~CWDMVideoStream();

	void * operator new(size_t size, void * pAllocation) { return(pAllocation);}
	void operator delete(void * pAllocation) {}

	virtual VOID STREAMAPI VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
	VOID STREAMAPI VideoReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
	virtual void TimeoutPacket(IN OUT PHW_STREAM_REQUEST_BLOCK pSrb);

	VOID VideoGetState(PHW_STREAM_REQUEST_BLOCK);
	virtual VOID VideoSetState(PHW_STREAM_REQUEST_BLOCK, BOOL bVPConnected, BOOL bVPVBIConnected);

	virtual VOID VideoGetProperty(PHW_STREAM_REQUEST_BLOCK);
	virtual VOID VideoSetProperty(PHW_STREAM_REQUEST_BLOCK);

	VOID VideoStreamGetConnectionProperty (PHW_STREAM_REQUEST_BLOCK);
	VOID VideoIndicateMasterClock (PHW_STREAM_REQUEST_BLOCK);

	virtual void CancelPacket( PHW_STREAM_REQUEST_BLOCK)
	{
	};

protected:
	PHW_STREAM_OBJECT			m_pStreamObject;

    // General purpose lock. We could use a separate one
    // for each queue, but this keeps things a little
    // more simple. Since it is never held for very long,
    // this shouldn't be a big performance hit.

    KSSTATE                     m_KSState;            // Run, Stop, Pause

    HANDLE                      m_hMasterClock;       // 
	
	// -------------------


    CWDMVideoDecoder *			m_pVideoDecoder;
	CDecoderVideoPort *			m_pVideoPort;
	CVideoDecoderDevice *		m_pDevice;

private:

    // Control SRBs go here
    LIST_ENTRY                  m_ctrlSrbQueue;
    KSPIN_LOCK                  m_ctrlSrbLock;

    // Flag to indicate whether or not we are currently
    // busy processing a control SRB
    BOOL                        m_processingCtrlSrb;
};


//
// prototypes for data handling routines
//

VOID STREAMAPI VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK);
VOID STREAMAPI VideoReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK);

DWORD FAR PASCAL DirectDrawEventCallback(DWORD dwEvent, PVOID pContext, DWORD dwParam1, DWORD dwParam2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\vpstrm.cpp ===
//==========================================================================;
//
//  CWDMVideoPortStream - Video Port Stream class implementation
//
//      $Date:   05 Aug 1998 11:11:22  $
//  $Revision:   1.0  $
//    $Author:   Tashjian  $
//
// $Copyright:  (c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"
}

#include "wdmvdec.h"
#include "wdmdrv.h"
#include "aticonfg.h"
#include "capdebug.h"


CWDMVideoPortStream::CWDMVideoPortStream(PHW_STREAM_OBJECT pStreamObject, 
                        CWDMVideoDecoder * pVideoDecoder,
                        PUINT puiErrorCode)
    :   CWDMVideoStream(pStreamObject, pVideoDecoder, puiErrorCode)
{
    DBGTRACE(("CWDMVideoPortStream::CWDMVideoPortStream()\n"));

    int StreamNumber = pStreamObject->StreamNumber;
        
    if (StreamNumber == STREAM_VPVideo)
    {
    }
    else if (StreamNumber == STREAM_VPVBI)
    {
    }

    *puiErrorCode = WDMMINI_NOERROR;
}


CWDMVideoPortStream::~CWDMVideoPortStream()
{
    DBGTRACE(("CWDMVideoPortStream::~CWDMVideoPortStream()\n"));

    if (m_Registered)
    {
        m_pVideoPort->UnregisterForDirectDrawEvents( this);
    }
}


VOID STREAMAPI CWDMVideoPortStream::VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb)
{  
    DBGERROR(("Unexpected data packet on non VP stream.\n"));
    ASSERT(0);
}

/*
** VideoSetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMVideoPortStream::VideoSetProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID (KSPROPSETID_VPConfig, pSPD->Property->Set)) {
        SetVideoPortProperty (pSrb);
    }
    else if (IsEqualGUID (KSPROPSETID_VPVBIConfig, pSPD->Property->Set)) {
        SetVideoPortVBIProperty (pSrb);
    }
    else {
       pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }
}

/*
** VideoGetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMVideoPortStream::VideoGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID (KSPROPSETID_Connection, pSPD->Property->Set)) {
        VideoStreamGetConnectionProperty (pSrb);
    }
    else if (IsEqualGUID (KSPROPSETID_VPConfig, pSPD->Property->Set)) {
        m_pDevice->GetVideoPortProperty (pSrb);
    }
    else if (IsEqualGUID (KSPROPSETID_VPVBIConfig, pSPD->Property->Set)) {
        m_pDevice->GetVideoPortVBIProperty (pSrb);
    }
    else {
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }
}

/*
** VideoSetState()
**
**    Sets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID CWDMVideoPortStream::VideoSetState(PHW_STREAM_REQUEST_BLOCK pSrb, BOOL bVPConnected, BOOL bVPVBIConnected)
{
    //
    // For each stream, the following states are used:
    // 
    // Stop:    Absolute minimum resources are used.  No outstanding IRPs.
    // Pause:   Getting ready to run.  Allocate needed resources so that 
    //          the eventual transition to Run is as fast as possible.
    //          SRBs will be queued at either the Stream class or in your
    //          driver.
    // Run:     Streaming. 
    //
    // Moving to Stop or Run ALWAYS transitions through Pause, so that ONLY 
    // the following transitions are possible:
    //
    // Stop -> Pause
    // Pause -> Run
    // Run -> Pause
    // Pause -> Stop
    //
    // Note that it is quite possible to transition repeatedly between states:
    // Stop -> Pause -> Stop -> Pause -> Run -> Pause -> Run -> Pause -> Stop
    //

    DBGINFO(("CWDMVideoPortStream::VideoSetState for stream %d\n", pSrb->StreamObject->StreamNumber));

    pSrb->Status = STATUS_SUCCESS;

    switch (pSrb->CommandData.StreamState)  

    {
        case KSSTATE_STOP:
            DBGINFO(("   state KSSTATE_STOP"));
            m_pDevice->SetOutputEnabled(FALSE);

            // Reset the overridden flag so that the next time we go to the
            // Run state, output will be enabled (unless the app overrides
            // it again later). We should really do this after the graph
            // has been stopped so that if a filter that has yet to be stopped
            // cleans up by clearing the flag, it is not considered to be
            // overriding it again. Since we are not called after the graph
            // has been fully stopped, this is the best we can do.
            //
            // An alternative (and probably less confusing) approach is to
            // leave the overridden flag set and force the app to control
            // the output enabled feature if it changes it once.
            //
            // We have decided to follow the latter approach.

            // m_pDevice->SetOutputEnabledOverridden(FALSE);
            break;

        case KSSTATE_ACQUIRE:
            DBGINFO(("   state KSSTATE_ACQUIRE"));
            ASSERT(m_KSState == KSSTATE_STOP);
            break;

        case KSSTATE_PAUSE:
            DBGINFO(("   state KSSTATE_PAUSE"));
            
            if (m_pVideoDecoder->PreEventOccurred() &&
                (!m_pDevice->IsOutputEnabledOverridden() || m_pDevice->IsOutputEnabled()) &&
                        (m_KSState == KSSTATE_STOP || m_KSState == KSSTATE_ACQUIRE))
            {
                DBGERROR(("VpStrm Pause: Overridden = %d, OutputEnabled = %d",
                          m_pDevice->IsOutputEnabledOverridden(),
                          m_pDevice->IsOutputEnabled()
                        ));

                pSrb->Status = STATUS_UNSUCCESSFUL;
            }
            break;

        case KSSTATE_RUN:
            DBGINFO(("   state KSSTATE_RUN"));

            ASSERT(m_KSState == KSSTATE_ACQUIRE || m_KSState == KSSTATE_PAUSE);

            if (m_pVideoDecoder->PreEventOccurred() &&
                (!m_pDevice->IsOutputEnabledOverridden() ||
                                        m_pDevice->IsOutputEnabled()))
            {
                DBGERROR(("VpStrm Run: Overridden = %d, OutputEnabled = %d",
                          m_pDevice->IsOutputEnabledOverridden(),
                          m_pDevice->IsOutputEnabled()
                        ));
                pSrb->Status = STATUS_UNSUCCESSFUL;
            }
            else if (!m_pDevice->IsOutputEnabledOverridden())
                m_pDevice->SetOutputEnabled(TRUE);
            break;
    }

    if (pSrb->Status == STATUS_SUCCESS) {
        m_KSState = pSrb->CommandData.StreamState;
        DBGINFO((" entered\n"));
    }
    else
        DBGINFO((" NOT entered ***\n"));
}


VOID CWDMVideoPortStream::SetVideoPortProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSpd = pSrb->CommandData.PropertyInfo;
    ULONG Id  = pSpd->Property->Id;            // index of the property
    ULONG nS  = pSpd->PropertyOutputSize;        // size of data supplied

    pSrb->Status = STATUS_SUCCESS;

    ASSERT (m_pDevice != NULL);
    switch (Id)
    {
    case KSPROPERTY_VPCONFIG_DDRAWHANDLE:
        ASSERT (nS >= sizeof(ULONG_PTR));

        if (!m_pVideoPort->ConfigDirectDrawHandle(*(PULONG_PTR)pSpd->PropertyInfo)) {
            pSrb->Status = STATUS_UNSUCCESSFUL;
            break;
        }
        
        if (!m_Registered) {
            m_Registered = m_pVideoPort->RegisterForDirectDrawEvents(this);
            if (!m_Registered) {
                pSrb->Status = STATUS_UNSUCCESSFUL;
                break;
            }
        }
        break;

    case KSPROPERTY_VPCONFIG_VIDEOPORTID:
        ASSERT (nS >= sizeof(ULONG));

        if (!m_pVideoPort->ConfigVideoPortHandle(*(PULONG)pSpd->PropertyInfo)) {
            pSrb->Status = STATUS_UNSUCCESSFUL;
        }
        break;

    case KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE:
        ASSERT (nS >= sizeof(ULONG_PTR));
        {
            // This sample does not use the surface kernel handles,
            // but the validation is as follows.
            ULONG_PTR cHandles = *(PULONG_PTR)pSpd->PropertyInfo;
            if (nS != (cHandles + 1) * sizeof(ULONG_PTR)) {

                pSrb->Status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            m_pVideoDecoder->ResetEvents();
        }
        break;

    case KSPROPERTY_VPCONFIG_SETCONNECTINFO :
        ASSERT (nS >= sizeof(ULONG));
        {
            // Indexes are correlated to the implementation of KSPROPERTY_VPCONFIG_GETCONNECTINFO
            ULONG Index = *(PULONG)pSpd->PropertyInfo;
            switch (Index)
            {
            case 0:
                m_pDevice->Set16BitDataStream(FALSE);
                break;

#ifdef BT829_SUPPORT_16BIT
            case 1:
                m_pDevice->Set16BitDataStream(TRUE);
                break;
#endif

            default:
                pSrb->Status = STATUS_INVALID_PARAMETER;
            }

        } 
        break;

    case KSPROPERTY_VPCONFIG_INVERTPOLARITY :
        m_pDevice->SetHighOdd(!m_pDevice->IsHighOdd());
        break;

    case KSPROPERTY_VPCONFIG_SETVIDEOFORMAT :
        ASSERT (nS >= sizeof(ULONG));

        //
        // pSrb->CommandData.PropertInfo->PropertyInfo
        // points to a ULONG which is an index into the array of
        // VIDEOFORMAT structs returned to the caller from the
        // Get call to FORMATINFO
        //
        // Since the sample only supports one FORMAT type right
        // now, we will ensure that the requested index is 0.
        //

        switch (*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo)
        {
        case 0:

            //
            // at this point, we would program the hardware to use
            // the right connection information for the videoport.
            // since we are only supporting one connection, we don't
            // need to do anything, so we will just indicate success
            //

            break;

        default:

            pSrb->Status = STATUS_NO_MATCH;
            break;
        }

        break;

    case KSPROPERTY_VPCONFIG_INFORMVPINPUT:
        ASSERT (nS >= sizeof(DDPIXELFORMAT));

        // This would be supported if we wanted to be informed of the available formats
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        break;

    case KSPROPERTY_VPCONFIG_SCALEFACTOR :
        ASSERT (nS >= sizeof(KS_AMVPSIZE));
        {
            PKS_AMVPSIZE    pAMVPSize;

            pAMVPSize = (PKS_AMVPSIZE)(pSrb->CommandData.PropertyInfo->PropertyInfo);

            MRect t(0, 0,   pAMVPSize->dwWidth, pAMVPSize->dwHeight);

            m_pDevice->SetRect(t);
        }
        break;

    case KSPROPERTY_VPCONFIG_SURFACEPARAMS :
        ASSERT(nS >= sizeof(KSVPSURFACEPARAMS));

        m_pDevice->ConfigVPSurfaceParams((PKSVPSURFACEPARAMS)pSpd->PropertyInfo);
        break;

    default:
        TRAP();
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        break;
    }
}




VOID CWDMVideoPortStream::SetVideoPortVBIProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSpd = pSrb->CommandData.PropertyInfo;
    ULONG Id  = pSpd->Property->Id;             // index of the property
    ULONG nS  = pSpd->PropertyOutputSize;       // size of data supplied

    pSrb->Status = STATUS_SUCCESS;

    ASSERT (m_pDevice != NULL);
    switch (Id)
    {
    case KSPROPERTY_VPCONFIG_DDRAWHANDLE:
        ASSERT (nS >= sizeof(ULONG_PTR));

        if (!m_pVideoPort->ConfigDirectDrawHandle(*(PULONG_PTR)pSpd->PropertyInfo)) {
            pSrb->Status = STATUS_UNSUCCESSFUL;
            break;
        }

        if (!m_Registered) {
            m_Registered = m_pVideoPort->RegisterForDirectDrawEvents(this);
            if (!m_Registered) {
                pSrb->Status = STATUS_UNSUCCESSFUL;
                break;
            }
        }
        break;

    case KSPROPERTY_VPCONFIG_VIDEOPORTID:
        ASSERT (nS >= sizeof(ULONG));

        if (!m_pVideoPort->ConfigVideoPortHandle(*(PULONG)pSpd->PropertyInfo)) {
            pSrb->Status = STATUS_UNSUCCESSFUL;
        }
        break;

    case KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE:
        ASSERT (nS >= sizeof(ULONG_PTR));
        {
            // This sample does not use the surface kernel handles,
            // but the validation is as follows.
            ULONG_PTR cHandles = *(PULONG_PTR)pSpd->PropertyInfo;
            if (nS != (cHandles + 1) * sizeof(ULONG_PTR)) {

                pSrb->Status = STATUS_INVALID_BUFFER_SIZE;
                break;
            }

            m_pVideoDecoder->ResetEvents();
        }
        break;

    case KSPROPERTY_VPCONFIG_SETCONNECTINFO :
        ASSERT (nS >= sizeof(ULONG));
        {
            // Indexes are correlated to the implementation of KSPROPERTY_VPCONFIG_GETCONNECTINFO
            ULONG Index = *(PULONG)pSpd->PropertyInfo;
            switch (Index)
            {
            case 0:
                m_pDevice->Set16BitDataStream(FALSE);
                break;

#ifdef BT829_SUPPORT_16BIT
            case 1:
                m_pDevice->Set16BitDataStream(TRUE);
                break;
#endif

            default:
                pSrb->Status = STATUS_INVALID_PARAMETER;
            }
        } 
        break;

    case KSPROPERTY_VPCONFIG_INVERTPOLARITY :
        m_pDevice->SetHighOdd(!m_pDevice->IsHighOdd());
        break;

    case KSPROPERTY_VPCONFIG_SETVIDEOFORMAT :
        ASSERT (nS >= sizeof(ULONG));

        //
        // pSrb->CommandData.PropertInfo->PropertyInfo
        // points to a ULONG which is an index into the array of
        // VIDEOFORMAT structs returned to the caller from the
        // Get call to FORMATINFO
        //
        // Since the sample only supports one FORMAT type right
        // now, we will ensure that the requested index is 0.
        //

        switch (*(PULONG)pSrb->CommandData.PropertyInfo->PropertyInfo)
        {
        case 0:

            //
            // at this point, we would program the hardware to use
            // the right connection information for the videoport.
            // since we are only supporting one connection, we don't
            // need to do anything, so we will just indicate success
            //

            break;

        default:

            pSrb->Status = STATUS_NO_MATCH;
            break;
        }

        break;

    case KSPROPERTY_VPCONFIG_INFORMVPINPUT:
        ASSERT (nS >= sizeof(DDPIXELFORMAT));

        // This would be supported if we wanted to be informed of the available formats
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        break;

    case KSPROPERTY_VPCONFIG_SCALEFACTOR :
        ASSERT (nS >= sizeof(KS_AMVPSIZE));

        // TBD
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        break;

    case KSPROPERTY_VPCONFIG_SURFACEPARAMS :
        ASSERT(nS >= sizeof(KSVPSURFACEPARAMS));

        m_pDevice->ConfigVPVBISurfaceParams((PKSVPSURFACEPARAMS)pSpd->PropertyInfo);
        break;

    default:
        TRAP();
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        break;
    }
}


VOID CWDMVideoPortStream::PreResChange()
{
    DBGTRACE(("DDNOTIFY_PRERESCHANGE; stream = %d\n", m_pStreamObject->StreamNumber));

    m_pVideoDecoder->SetPreEvent();
}


VOID CWDMVideoPortStream::PostResChange()
{
    DBGTRACE(("DDNOTIFY_POSTRESCHANGE; stream = %d\n", m_pStreamObject->StreamNumber));

    m_pVideoDecoder->SetPostEvent();
    DBGTRACE(("Before Attempted Renegotiation due to DDNOTIFY_POSTRESCHANGE\n"));
    AttemptRenegotiation();
    DBGTRACE(("Afer Attempted Renegotiation due to DDNOTIFY_POSTRESCHANGE\n"));
}




VOID CWDMVideoPortStream::PreDosBox()
{
    DBGTRACE(("DDNOTIFY_PREDOSBOX; stream = %d\n", m_pStreamObject->StreamNumber));

    m_pVideoDecoder->SetPreEvent();
}



VOID CWDMVideoPortStream::PostDosBox()
{
    DBGTRACE(("DDNOTIFY_POSTDOSBOX; stream = %d\n", m_pStreamObject->StreamNumber));

    m_pVideoDecoder->SetPostEvent();
    DBGTRACE(("Before Attempted Renegotiation due to DDNOTIFY_POSTDOSBOX\n"));
    AttemptRenegotiation();
    DBGTRACE(("After Attempted Renegotiation due to DDNOTIFY_POSTDOSBOX\n"));
}

NTSTATUS STREAMAPI VPStreamEventProc (PHW_EVENT_DESCRIPTOR pEvent)
{
    CWDMVideoPortStream* pstrm=(CWDMVideoPortStream*)pEvent->StreamObject->HwStreamExtension;
    pstrm->StreamEventProc(pEvent);
    return STATUS_SUCCESS;
}

NTSTATUS STREAMAPI VPVBIStreamEventProc (PHW_EVENT_DESCRIPTOR pEvent)
{
    CWDMVideoPortStream* pstrm=(CWDMVideoPortStream*)pEvent->StreamObject->HwStreamExtension;
    pstrm->StreamEventProc(pEvent);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\capmain.cpp ===
//==========================================================================;
//
//  Decoder specific initialization routines
//
//      $Date:   21 Aug 1998 21:46:10  $
//  $Revision:   1.1  $
//    $Author:   Tashjian  $
//
// $Copyright:  (c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

}

#include "wdmvdec.h"
#include "capmain.h"
#include "wdmdrv.h"
#include "Device.h"
#include "capdebug.h"


CVideoDecoderDevice * InitializeDevice(PPORT_CONFIGURATION_INFORMATION pConfigInfo, 
                                       PBYTE pWorkspace)
{
    UINT                    nErrorCode = 0;
    Device *                pDevice = NULL;
    
    PDEVICE_DATA_EXTENSION pDevExt = (PDEVICE_DATA_EXTENSION) pWorkspace;

    DBGTRACE(("InitializeDevice()\n"));


    ENSURE
    {
        CI2CScript *pI2cScript = (CI2CScript *) new ((PVOID)&pDevExt->CScript)
                CI2CScript(pConfigInfo, &nErrorCode);
    
        if (nErrorCode != WDMMINI_NOERROR)
        {
            DBGERROR(("CI2CScript creation failure = %lx\n", nErrorCode));
            TRAP();
            FAIL;
        }
    
        if (!pI2cScript->LockI2CProviderEx())
        {
            DBGERROR(("Couldn't get I2CProvider.\n"));
            TRAP();
            FAIL;
        }
    
        {
            CATIHwConfiguration CATIHwConfig(pConfigInfo, pI2cScript, &nErrorCode);

            pI2cScript->ReleaseI2CProvider();

            if(nErrorCode != WDMMINI_NOERROR)
            {
                DBGERROR(("CATIHwConfig constructor failure = %lx\n", nErrorCode));
                TRAP();
                FAIL;
            }

            UINT uiDecoderId;
            UCHAR chipAddr;
            CATIHwConfig.GetDecoderConfiguration(&uiDecoderId, &chipAddr);
            // check the device installed before enabling any access to it
            if((uiDecoderId != VIDEODECODER_TYPE_BT829) &&
                (uiDecoderId != VIDEODECODER_TYPE_BT829A)) {
                TRAP();
                FAIL;
            }

            CATIHwConfig.EnableDecoderI2CAccess(pI2cScript, TRUE);

            int outputEnablePolarity = CATIHwConfig.GetDecoderOutputEnableLevel();
            if(outputEnablePolarity == UINT(-1))
            {
                DBGERROR(("Unexpected outputEnablePolarity"));
                TRAP();
                FAIL;
            }

            pDevExt->deviceParms.pI2cScript = pI2cScript;
            pDevExt->deviceParms.chipAddr   = chipAddr;
            pDevExt->deviceParms.outputEnablePolarity = outputEnablePolarity;
            pDevExt->deviceParms.ulVideoInStandardsSupportedByCrystal = CATIHwConfig.GetVideoInStandardsSupportedByCrystal(); //Paul
            pDevExt->deviceParms.ulVideoInStandardsSupportedByTuner = CATIHwConfig.GetVideoInStandardsSupportedByTuner(); //Paul
        }

        pDevice = (Device*) new ((PVOID)&pDevExt->CDevice)
            Device(pConfigInfo, &pDevExt->deviceParms, &nErrorCode);

        if (nErrorCode)
        {
            pDevice = NULL;
            TRAP();
            FAIL;
        }
    
    } END_ENSURE;
    
    DBGTRACE(("Exit : InitializeDevice()\n"));
    
    return pDevice;
}


size_t DeivceExtensionSize()
{
    return (sizeof(DEVICE_DATA_EXTENSION));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\wdmvdec.h ===
#pragma once

//==========================================================================;
//
//	WDM Video Decoder common SRB dispatcher
//
//		$Date:   05 Aug 1998 11:22:30  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;


#include "CapStrm.h"
#include "VPStrm.h"
#include "CapVBI.h"
#include "CapVideo.h"
#include "decvport.h"

#include "ddkmapi.h"


typedef struct
{
	// Please don't move srbListEntry from its first place in the structure
	LIST_ENTRY					srbListEntry;

	PHW_STREAM_REQUEST_BLOCK	pSrb;
    KEVENT                      bufferDoneEvent;
    DDCAPBUFFINFO               ddCapBuffInfo;
} SRB_DATA_EXTENSION, * PSRB_DATA_EXTENSION;


class CWDMVideoDecoder
{
public:
	CWDMVideoDecoder( PPORT_CONFIGURATION_INFORMATION pConfigInfo, 
					  CVideoDecoderDevice* pDevice );
	virtual ~CWDMVideoDecoder();

	void * operator new(size_t size, void * pAllocation) { return(pAllocation);}
	void operator delete(void * pAllocation) {}

	void	ReceivePacket		(PHW_STREAM_REQUEST_BLOCK pSrb);
	void	CancelPacket		(PHW_STREAM_REQUEST_BLOCK pSrb);
	void	TimeoutPacket		(PHW_STREAM_REQUEST_BLOCK pSrb);

	void	SetTunerInfo		(PHW_STREAM_REQUEST_BLOCK pSrb);
    BOOL	GetTunerInfo		(KS_TVTUNER_CHANGE_INFO *);

	NTSTATUS
		EventProc				( IN PHW_EVENT_DESCRIPTOR pEventDescriptor);

	void	ResetEvents()		{ m_preEventOccurred = m_postEventOccurred = FALSE; }
	void	SetPreEvent()		{ m_preEventOccurred = TRUE; }
	void	SetPostEvent()		{ m_postEventOccurred = TRUE; }
	BOOL	PreEventOccurred()	{ return m_preEventOccurred; }

	CVideoDecoderDevice* GetDevice() { return m_pDevice; }
	CDecoderVideoPort*	GetVideoPort() { return &m_CDecoderVPort; }	// video port

	BOOL    IsVideoPortPinConnected()       { return( m_pVideoPortStream != NULL); }
private:
	// for serializing SRB arriving into driver synchronization
	BOOL				m_bSrbInProcess;
	LIST_ENTRY			m_srbQueue;
	KSPIN_LOCK			m_spinLock;

	CVideoDecoderDevice *		m_pDevice;
	CDecoderVideoPort			m_CDecoderVPort;	// video port

	PDEVICE_OBJECT				m_pDeviceObject;

    // Channel Change information
    KS_TVTUNER_CHANGE_INFO		m_TVTunerChangeInfo;
    BOOL						m_TVTunerChanged;
	PHW_STREAM_REQUEST_BLOCK	m_TVTunerChangedSrb;

    // shared between full-screen DOS and res changes
    BOOL						m_preEventOccurred;
    BOOL						m_postEventOccurred;

	// Streams
    UINT						m_OpenStreams;
    CWDMVideoPortStream *		m_pVideoPortStream;
    CWDMVBICaptureStream *		m_pVBICaptureStream;
    CWDMVideoCaptureStream *	m_pVideoCaptureStream;

	UINT						m_nMVDetectionEventCount;

	BOOL SrbInitializationComplete	(PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL SrbChangePowerState		(PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL SrbGetDataIntersection		(PHW_STREAM_REQUEST_BLOCK pSrb);
	void SrbGetStreamInfo			(PHW_STREAM_REQUEST_BLOCK pSrb);
	void SrbGetProperty				(PHW_STREAM_REQUEST_BLOCK pSrb);
	void SrbSetProperty				(PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL SrbOpenStream				(PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL SrbCloseStream				(PHW_STREAM_REQUEST_BLOCK pSrb);
};

const size_t streamDataExtensionSize = 
	max(
		max(sizeof(CWDMVideoStream), sizeof(CWDMVideoPortStream)), 
		max(sizeof(CWDMVideoCaptureStream), sizeof(CWDMVBICaptureStream))
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\capmain.h ===
#pragma once

//==========================================================================;
//
//	Decoder specific declarations
//
//		$Date:   21 Aug 1998 21:46:20  $
//	$Revision:   1.1  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include "ddkmapi.h"

#include "i2script.h"
#include "aticonfg.h"

#ifdef    __cplusplus
}
#endif // __cplusplus


typedef struct {
    CI2CScript *			pI2cScript;
    UINT                    chipAddr;
    UINT                    chipID;
    UINT                    chipRev;
	int						outputEnablePolarity;
    ULONG                   ulVideoInStandardsSupportedByCrystal;   //Paul
    ULONG                   ulVideoInStandardsSupportedByTuner;     //Paul
} DEVICE_PARMS, *PDEVICE_PARMS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\vpstrm.h ===
#pragma once

//==========================================================================;
//
//  CWDMVideoPortStream - Video Port Stream class declarations
//
//      $Date:   22 Feb 1999 15:48:40  $
//  $Revision:   1.1  $
//    $Author:   KLEBANOV  $
//
// $Copyright:  (c) 1997 - 1999  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "i2script.h"
#include "aticonfg.h"


#include "VidStrm.h"



class CWDMVideoPortStream : public CWDMVideoStream
{
public:
    CWDMVideoPortStream(PHW_STREAM_OBJECT pStreamObject,
                        CWDMVideoDecoder * pCWDMVideoDecoder,
                        PUINT puiError);
    ~CWDMVideoPortStream    ();

    void * operator new(size_t size, void * pAllocation) { return(pAllocation);}
    void operator delete(void * pAllocation) {}

    VOID STREAMAPI VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);

    VOID VideoSetState(PHW_STREAM_REQUEST_BLOCK, BOOL bVPConnected, BOOL bVPVBIConnected);
    VOID VideoGetProperty(PHW_STREAM_REQUEST_BLOCK);
    VOID VideoSetProperty(PHW_STREAM_REQUEST_BLOCK);
    VOID AttemptRenegotiation();

    VOID PreResChange();
    VOID PostResChange();
    VOID PreDosBox();
    VOID PostDosBox();

    VOID StreamEventProc (PHW_EVENT_DESCRIPTOR pEvent)
    {
        if (pEvent->Enable)
        {
            m_EventCount++;
        }
        else
        {
            m_EventCount--;
        }
    }

    void CancelPacket(PHW_STREAM_REQUEST_BLOCK pSrbToCancel)
    {
        DBGERROR(("CancelPacket(): came to VideoPort stream object\n"));
    }

private:

    VOID SetVideoPortProperty(PHW_STREAM_REQUEST_BLOCK);

    VOID SetVideoPortVBIProperty(PHW_STREAM_REQUEST_BLOCK);
    
    
    // internal flag to indicate whether or not we
    // have registered for DirectDraw events
    BOOL        m_Registered;

    UINT        m_EventCount;                                // for IVPNotify interface

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\dcdrvals.h ===
#pragma once

//==========================================================================;
//
//	Decoder specific constants
//
//		$Date:   05 Aug 1998 11:31:52  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#ifdef __cplusplus

const int HueMin = -90;
const int HueMax = 90;
const int HueDef = 0;

const int SatMinNTSC = 0;
const int SatMaxNTSC = 0x1FF;
const int SatDefNTSC = 0xFE;

const int SatMinSECAM = 0;
const int SatMaxSECAM = 0x1FF;
const int SatDefSECAM = 0x87;

const int ConMin = 0;
const int ConMax = 236;
const int ConDef = 100;

const int BrtMin = -50;
const int BrtMax = 50;
const int BrtDef = 0;

const int ParamMin = 0;
const int ParamMax = 255;
const int ParamDef = 128;

#else
#define HueMin -90
#define HueMax 90
#define HueDef 0

#define SatMinNTSC 0
#define SatMaxNTSC 0x1FF
#define SatDefNTSC 0xFE

#define SatMinSECAM 0
#define SatMaxSECAM 0x1FF
#define SatDefSECAM 0x87

#define ConMin 0
#define ConMax 236
#define ConDef 100

#define BrtMin -50
#define BrtMax 50
#define BrtDef 0

#define ParamMin 0
#define ParamMax 255
#define ParamDef 128

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\wdmvdec.cpp ===
//==========================================================================;
//
//  WDM Video Decoder common SRB dispatcher
//
//      $Date:   02 Oct 1998 23:00:24  $
//  $Revision:   1.2  $
//    $Author:   KLEBANOV  $
//
// $Copyright:  (c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"
}


#include "wdmvdec.h"
#include "wdmdrv.h"
#include "capdebug.h"
#include "VidStrm.h"

#include "DecProp.h"
#include "StrmInfo.h"

#include "Mediums.h"
#include "mytypes.h"

extern NTSTATUS STREAMAPI DeviceEventProc( PHW_EVENT_DESCRIPTOR pEventDescriptor);

CWDMVideoDecoder::CWDMVideoDecoder(PPORT_CONFIGURATION_INFORMATION pConfigInfo,
                                   CVideoDecoderDevice* pDevice)
    :   m_pDeviceObject(pConfigInfo->RealPhysicalDeviceObject),
        m_CDecoderVPort(pConfigInfo->RealPhysicalDeviceObject),
        m_pDevice(pDevice),
        m_TVTunerChangedSrb( NULL)
{
    DBGTRACE(("CWDMVideoDecoder:CWDMVideoDecoder() enter\n"));
    DBGINFO(("Physical Device Object = %lx\n", m_pDeviceObject));

    pConfigInfo->StreamDescriptorSize = sizeof (HW_STREAM_HEADER) +
            NumStreams * sizeof (HW_STREAM_INFORMATION);

    InitializeListHead(&m_srbQueue);
    KeInitializeSpinLock(&m_spinLock);
    m_bSrbInProcess = FALSE;
        if (pDevice)
        {
            pDevice->SetVideoDecoder(this);
        }
}


CWDMVideoDecoder::~CWDMVideoDecoder()
{

    DBGTRACE(("CWDMVideoDecoder:~CWDMVideoDecoder()\n"));
}


void CWDMVideoDecoder::ReceivePacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    KIRQL Irql;
    PSRB_DATA_EXTENSION pSrbExt;

    KeAcquireSpinLock(&m_spinLock, &Irql);
    if (m_bSrbInProcess)
    {
        pSrbExt = (PSRB_DATA_EXTENSION)pSrb->SRBExtension;
        pSrbExt->pSrb = pSrb;
        InsertTailList(&m_srbQueue, &pSrbExt->srbListEntry);
        KeReleaseSpinLock(&m_spinLock, Irql);
        return;
    }

    m_bSrbInProcess = TRUE;
    KeReleaseSpinLock(&m_spinLock, Irql);


    for (;;) {

        // Assume success. Might be changed below

        pSrb->Status = STATUS_SUCCESS;
        BOOL notify = TRUE;
        
        // determine the type of packet.
        switch(pSrb->Command)
        {
            case SRB_INITIALIZATION_COMPLETE:
                DBGTRACE(("SRB_INITIALIZATION_COMPLETE; SRB=%x\n", pSrb));

                // Stream class has finished initialization.
                // Now create DShow Medium interface BLOBs.
                // This needs to be done at low priority since it uses the registry
                //
                // Do we need to worry about synchronization here?

                SrbInitializationComplete(pSrb);
                break;
            case SRB_UNINITIALIZE_DEVICE:
                DBGTRACE(("SRB_UNINITIALIZE_DEVICE; SRB=%x\n", pSrb));
                // close the device.  

                break;
            case SRB_PAGING_OUT_DRIVER:
                DBGTRACE(("SRB_PAGING_OUT_DRIVER; SRB=%x\n", pSrb));
                //
                // The driver is being paged out
                // Disable Interrupts if you have them!
                //
                break;
            case SRB_CHANGE_POWER_STATE:
                DBGTRACE(("SRB_CHANGE_POWER_STATE. SRB=%x. State=%d\n",
                                                pSrb, pSrb->CommandData.DeviceState));

                SrbChangePowerState(pSrb);
                break;
    
            case SRB_OPEN_STREAM:
                DBGTRACE(("SRB_OPEN_STREAM; SRB=%x\n", pSrb));

                SrbOpenStream(pSrb);
                break;

            case SRB_CLOSE_STREAM:
                DBGTRACE(("SRB_CLOSE_STREAM; SRB=%x\n", pSrb));

                if (!IsListEmpty(&m_srbQueue))  // is this necessary ???
                {
                    TRAP();
                }

                SrbCloseStream(pSrb);
                break;
            case SRB_GET_DATA_INTERSECTION:
                DBGTRACE(("SRB_GET_DATA_INTERSECTION; SRB=%x\n", pSrb));

                SrbGetDataIntersection(pSrb);
                break;

            case SRB_GET_STREAM_INFO:
                SrbGetStreamInfo(pSrb);
                break;

            case SRB_GET_DEVICE_PROPERTY:
                SrbGetProperty(pSrb);
                break;        

            case SRB_SET_DEVICE_PROPERTY:
                SrbSetProperty(pSrb);
                break;

            case SRB_WRITE_DATA:

                DBGTRACE(("SRB_WRITE_DATA; SRB=%x\n", pSrb));

                SetTunerInfo(pSrb);
                StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb);
                notify = FALSE;
                break;

            case SRB_UNKNOWN_DEVICE_COMMAND:
                // not sure why this gets called every time.
                DBGTRACE(("SRB_UNKNOWN_DEVICE_COMMAND; SRB=%x\n", pSrb));

                // TRAP()();
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_OPEN_DEVICE_INSTANCE:
            case SRB_CLOSE_DEVICE_INSTANCE:
            default:
                TRAP();
                // this is a request that we do not understand.  Indicate invalid command and complete the request
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
        }

        if (notify)
            StreamClassDeviceNotification(DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);

        KeAcquireSpinLock(&m_spinLock, &Irql);
        if (IsListEmpty(&m_srbQueue))
        {
            m_bSrbInProcess = FALSE;
            KeReleaseSpinLock(&m_spinLock, Irql);
            return;
        }
        else
        {
            pSrbExt = (PSRB_DATA_EXTENSION)RemoveHeadList(&m_srbQueue);
            KeReleaseSpinLock(&m_spinLock, Irql);
            pSrb = pSrbExt->pSrb;
        }
    }
}


void CWDMVideoDecoder::CancelPacket( PHW_STREAM_REQUEST_BLOCK pSrbToCancel)
{
    CWDMVideoStream*    pVideoStream = ( CWDMVideoStream*)pSrbToCancel->StreamObject->HwStreamExtension;
 
    DBGINFO(( "Bt829: AdapterCancelPacket, Starting attempting to cancel Srb 0x%x\n",
        pSrbToCancel));

    if( pVideoStream == NULL)
    {
        //
        // Device command IRPs are not queued, so nothing to do
        //
        DBGINFO(( "Bt829: AdapterCancelPacketStart, no pVideoStream Srb 0x%x\n",
            pSrbToCancel));

        return;
    } 

    pVideoStream->CancelPacket( pSrbToCancel);

    DBGINFO(( "Bt829: AdapterCancelPacket, Exiting\n"));
}



void CWDMVideoDecoder::TimeoutPacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    CWDMVideoStream * pVideoStream = (CWDMVideoStream *)pSrb->StreamObject->HwStreamExtension;

    DBGTRACE(("Timeout. SRB %8x. \n", pSrb));
    pVideoStream->TimeoutPacket(pSrb);

    DBGTRACE(("TimeoutPacket: SRB %8x. Resetting.\n", pSrb));
    pSrb->TimeoutCounter = pSrb->TimeoutOriginal;
}


BOOL CWDMVideoDecoder::SrbInitializationComplete(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    NTSTATUS                Status;
    ULONG *tmp = (ULONG *) &CrossbarPinDirection[0];

    // Create the Registry blobs that DShow uses to create
    // graphs via Mediums

    Status = StreamClassRegisterFilterWithNoKSPins (
                    m_pDeviceObject,                    // IN PDEVICE_OBJECT   DeviceObject,
                    &KSCATEGORY_CROSSBAR,               // IN GUID           * InterfaceClassGUID,
                    CrossbarPins(),     // IN ULONG            PinCount,
                    (int *) CrossbarPinDirection,       // IN ULONG          * Flags,
                    (KSPIN_MEDIUM *) CrossbarMediums,   // IN KSPIN_MEDIUM   * MediumList,
                    NULL                                // IN GUID           * CategoryList
            );

    // Register the Capture filter
    // Note:  This should be done automatically be MSKsSrv.sys, 
    // when that component comes on line (if ever) ...
    Status = StreamClassRegisterFilterWithNoKSPins (
                    m_pDeviceObject,                    // IN PDEVICE_OBJECT   DeviceObject,
                    &KSCATEGORY_CAPTURE,                // IN GUID           * InterfaceClassGUID,
                    CapturePins(),      // IN ULONG            PinCount,
                    (int *) CapturePinDirection,        // IN ULONG          * Flags,
                    (KSPIN_MEDIUM *) CaptureMediums,    // IN KSPIN_MEDIUM   * MediumList,
                    NULL                                // IN GUID           * CategoryList
            );
    pSrb->Status = STATUS_SUCCESS;
    return(TRUE);
}


BOOL CWDMVideoDecoder::SrbOpenStream(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    DBGTRACE(("CWDMVideoDecoder:SrbOpenStream()\n"));
    PHW_STREAM_OBJECT       pStreamObject = pSrb->StreamObject;
    void *                  pStrmEx = pStreamObject->HwStreamExtension;
    int                     StreamNumber = pStreamObject->StreamNumber;
    PKSDATAFORMAT           pKSDataFormat = pSrb->CommandData.OpenFormat;
    CWDMVideoStream *       pVideoStream;
    CWDMVideoPortStream *   pVPVBIStream;
    UINT    nErrorCode;

    RtlZeroMemory(pStrmEx, streamDataExtensionSize);

    DBGINFO(("SRBOPENSTREAM ------- StreamNumber=%d\n", StreamNumber));

    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //

    if (StreamNumber >= (int)NumStreams || StreamNumber < 0) {

        pSrb->Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }


    //
    // Check the validity of the format being requested
    //

    if (!AdapterVerifyFormat (pKSDataFormat, StreamNumber)) {

        pSrb->Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    //
    // Set up pointers to the handlers for the stream data and control handlers
    //

    pStreamObject->ReceiveDataPacket = VideoReceiveDataPacket;
    pStreamObject->ReceiveControlPacket = VideoReceiveCtrlPacket;

    //
    // Indicate the clock support available on this stream
    //

    pStreamObject->HwClockObject.HwClockFunction = NULL;
    pStreamObject->HwClockObject.ClockSupportFlags = 0;

    //
    // The DMA flag must be set when the device will be performing DMA directly
    // to the data buffer addresses passed in to the ReceiceDataPacket routines.
    //
    pStreamObject->Dma = Streams[StreamNumber].hwStreamObjectInfo.Dma;

    //
    // The PIO flag must be set when the mini driver will be accessing the data
    // buffers passed in using logical addressing
    //
    pStreamObject->Pio = Streams[StreamNumber].hwStreamObjectInfo.Pio;

    //
    // How many extra bytes will be passed up from the driver for each frame?
    //
    pStreamObject->StreamHeaderMediaSpecific = 
        Streams[StreamNumber].hwStreamObjectInfo.StreamHeaderMediaSpecific;

    pStreamObject->StreamHeaderWorkspace =
        Streams[StreamNumber].hwStreamObjectInfo.StreamHeaderWorkspace;

    //
    // Indicate the allocator support available on this stream
    //

    pStreamObject->Allocator = Streams[StreamNumber].hwStreamObjectInfo.Allocator;

    //
    // Indicate the event support available on this stream
    //

    pStreamObject->HwEventRoutine = 
        Streams[StreamNumber].hwStreamObjectInfo.HwEventRoutine;

    switch (StreamNumber)
    {
        case STREAM_AnalogVideoInput:
            ASSERT(IsEqualGUID(pKSDataFormat->Specifier, KSDATAFORMAT_SPECIFIER_ANALOGVIDEO));
            pVideoStream = (CWDMVideoStream *)new(pStrmEx)
                CWDMVideoStream(pStreamObject, this, &nErrorCode);
            break;
        case STREAM_VideoCapture:
            ASSERT(IsEqualGUID(pKSDataFormat->Specifier, KSDATAFORMAT_SPECIFIER_VIDEOINFO));
            m_pVideoCaptureStream = (CWDMVideoCaptureStream *)new(pStrmEx)
                CWDMVideoCaptureStream(pStreamObject, this, pKSDataFormat, &nErrorCode);
            if (m_pVideoPortStream)
            {
                m_pVideoPortStream->AttemptRenegotiation();
            }
            break;
        case STREAM_VBICapture:
            ASSERT(IsEqualGUID(pKSDataFormat->Specifier, KSDATAFORMAT_SPECIFIER_VBI));
            m_pVBICaptureStream = (CWDMVBICaptureStream *)new(pStrmEx)
                CWDMVBICaptureStream(pStreamObject, this, pKSDataFormat, &nErrorCode);
            break;
        case STREAM_VPVideo:
            ASSERT(IsEqualGUID(pKSDataFormat->Specifier, KSDATAFORMAT_SPECIFIER_NONE) &&
                   IsEqualGUID(pKSDataFormat->SubFormat, KSDATAFORMAT_SUBTYPE_VPVideo));
            m_pVideoPortStream = (CWDMVideoPortStream *)new(pStrmEx)
                CWDMVideoPortStream(pStreamObject, this, &nErrorCode);
            if (m_pVideoCaptureStream == NULL)
            {
                MRect t(0, 0,   m_pDevice->GetDefaultDecoderWidth(),
                                m_pDevice->GetDefaultDecoderHeight());
                m_pDevice->SetRect(t);
            }
            break;
        case STREAM_VPVBI:
            ASSERT(IsEqualGUID(pKSDataFormat->Specifier, KSDATAFORMAT_SPECIFIER_NONE) &&
                   IsEqualGUID(pKSDataFormat->SubFormat, KSDATAFORMAT_SUBTYPE_VPVBI));
            pVPVBIStream = (CWDMVideoPortStream *)new(pStrmEx)
                CWDMVideoPortStream(pStreamObject, this, &nErrorCode);
            m_pDevice->SetVBIEN(TRUE);
            m_pDevice->SetVBIFMT(TRUE);
            break;
        default:
            pSrb->Status = STATUS_UNSUCCESSFUL;
            goto Exit;
    }

    if(nErrorCode == WDMMINI_NOERROR)
        m_OpenStreams++;
    else
        pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;

Exit:
 
    DBGTRACE(("SrbOpenStream Exit\n"));
    return(TRUE);
}


BOOL CWDMVideoDecoder::SrbCloseStream(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;

    DBGTRACE(("CWDMVideoDecoder:SrbCloseStream()\n"));
    DBGINFO(("SRBCLOSESTREAM ------- StreamNumber=%d\n", StreamNumber));
    
    //
    // the minidriver may wish to free any resources that were allocated at
    // open stream time etc.
    //

    CWDMVideoStream * pVideoStream = (CWDMVideoStream *)pSrb->StreamObject->HwStreamExtension;

    delete pVideoStream;

    switch (StreamNumber)
    {
        case STREAM_AnalogVideoInput:
            break;
        case STREAM_VideoCapture:
            m_pVideoCaptureStream = NULL;
            break;
        case STREAM_VBICapture:
            m_pVBICaptureStream = NULL;
            break;
        case STREAM_VPVideo:
            m_pVideoPortStream = NULL;
            break;
        case STREAM_VPVBI:
            m_pDevice->SetVBIEN(FALSE);
            m_pDevice->SetVBIFMT(FALSE);
            break;
        default:
            pSrb->Status = STATUS_UNSUCCESSFUL;
            return FALSE;
    }

    if (--m_OpenStreams == 0)
    {
        DBGINFO(("Last one out turns off the lights\n"));

        m_CDecoderVPort.Close();

        m_preEventOccurred = FALSE;
        m_postEventOccurred = FALSE;

        m_pDevice->SaveState();
    }

    pSrb->Status = STATUS_SUCCESS;

    return TRUE;
}


BOOL CWDMVideoDecoder::SrbGetDataIntersection(PHW_STREAM_REQUEST_BLOCK pSrb)
{

    DBGTRACE(("CWDMVideoDecoder:SrbGetDataIntersection()\n"));

    PSTREAM_DATA_INTERSECT_INFO IntersectInfo;
    PKSDATARANGE                DataRange;
    BOOL                        OnlyWantsSize;
    BOOL                        MatchFound = FALSE;
    ULONG                       FormatSize;
    ULONG                       StreamNumber;
    ULONG                       j;
    ULONG                       NumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;

    IntersectInfo = pSrb->CommandData.IntersectInfo;
    StreamNumber = IntersectInfo->StreamNumber;
    DataRange = IntersectInfo->DataRange;

    //
    // Check that the stream number is valid
    //

    if (StreamNumber >= NumStreams) {
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        TRAP();
        return FALSE;
    }
    
    NumberOfFormatArrayEntries = 
            Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

    //
    // Get the pointer to the array of available formats
    //

    pAvailableFormats = Streams[StreamNumber].hwStreamInfo.StreamFormatsArray;

    //
    // Is the caller trying to get the format, or the size of the format?
    //

    OnlyWantsSize = ( (IntersectInfo->SizeOfDataFormatBuffer == sizeof(ULONG)) ||
                      (IntersectInfo->SizeOfDataFormatBuffer == 0) );

    //
    // Walk the formats supported by the stream searching for a match
    // of the three GUIDs which together define a DATARANGE
    //

    for (j = 0; j < NumberOfFormatArrayEntries; j++, pAvailableFormats++) {

        if (!AdapterCompareGUIDsAndFormatSize(
                        DataRange, 
                        *pAvailableFormats,
                        TRUE /* CompareFormatSize */)) {
            continue;
        }

        //
        // Now that the three GUIDs match, switch on the Specifier
        // to do a further type-specific check
        //

        // -------------------------------------------------------------------
        // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
        // -------------------------------------------------------------------

        if (IsEqualGUID (DataRange->Specifier, 
                KSDATAFORMAT_SPECIFIER_VIDEOINFO)) {
                
            PKS_DATARANGE_VIDEO DataRangeVideoToVerify = 
                    (PKS_DATARANGE_VIDEO) DataRange;
            PKS_DATARANGE_VIDEO DataRangeVideo = 
                    (PKS_DATARANGE_VIDEO) *pAvailableFormats;
            PKS_DATAFORMAT_VIDEOINFOHEADER DataFormatVideoInfoHeaderOut;

            //
            // Check that the other fields match
            //
            if ((DataRangeVideoToVerify->bFixedSizeSamples != DataRangeVideo->bFixedSizeSamples) ||
                (DataRangeVideoToVerify->bTemporalCompression != DataRangeVideo->bTemporalCompression) ||
                (DataRangeVideoToVerify->StreamDescriptionFlags != DataRangeVideo->StreamDescriptionFlags) ||
                (DataRangeVideoToVerify->MemoryAllocationFlags != DataRangeVideo->MemoryAllocationFlags) ||
                (RtlCompareMemory (&DataRangeVideoToVerify->ConfigCaps,
                        &DataRangeVideo->ConfigCaps,
                        sizeof (KS_VIDEO_STREAM_CONFIG_CAPS)) != 
                        sizeof (KS_VIDEO_STREAM_CONFIG_CAPS))) {
                continue;
            }

            // Validate each step of the size calculations for arithmetic overflow,
            // and verify that the specified sizes correlate
            // (with unsigned math, a+b < b iff an arithmetic overflow occured)
            ULONG VideoHeaderSize = DataRangeVideoToVerify->VideoInfoHeader.bmiHeader.biSize +
                FIELD_OFFSET(KS_VIDEOINFOHEADER,bmiHeader);
            ULONG RangeSize = VideoHeaderSize +
                FIELD_OFFSET(KS_DATARANGE_VIDEO,VideoInfoHeader);

            if (VideoHeaderSize < FIELD_OFFSET(KS_VIDEOINFOHEADER,bmiHeader) ||
                RangeSize < FIELD_OFFSET(KS_DATARANGE_VIDEO,VideoInfoHeader) ||
                RangeSize > DataRangeVideoToVerify->DataRange.FormatSize) {

                pSrb->Status = STATUS_INVALID_PARAMETER;
                return FALSE;
            }

            // MATCH FOUND!
            MatchFound = TRUE;            
            FormatSize = sizeof (KSDATAFORMAT) +
                VideoHeaderSize;

            if (OnlyWantsSize) {
                break;
            }

            // Caller wants the full data format
            if (IntersectInfo->SizeOfDataFormatBuffer < FormatSize) {
                pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                return FALSE;
            }

            // Copy over the KSDATAFORMAT, followed by the 
            // actual VideoInfoHeader
                
            DataFormatVideoInfoHeaderOut = (PKS_DATAFORMAT_VIDEOINFOHEADER) IntersectInfo->DataFormatBuffer;

            // Copy over the KSDATAFORMAT 
            RtlCopyMemory(
                &DataFormatVideoInfoHeaderOut->DataFormat,
                &DataRangeVideoToVerify->DataRange,
                sizeof (KSDATARANGE));

            DataFormatVideoInfoHeaderOut->DataFormat.FormatSize = FormatSize;

            // Copy over the caller's requested VIDEOINFOHEADER
            RtlCopyMemory(
                &DataFormatVideoInfoHeaderOut->VideoInfoHeader,
                &DataRangeVideoToVerify->VideoInfoHeader,
                VideoHeaderSize);

            // Calculate biSizeImage for this request, and put the result in both
            // the biSizeImage field of the bmiHeader AND in the SampleSize field
            // of the DataFormat.
            //
            // Note that for compressed sizes, this calculation will probably not
            // be just width * height * bitdepth

            DataFormatVideoInfoHeaderOut->VideoInfoHeader.bmiHeader.biSizeImage =
                DataFormatVideoInfoHeaderOut->DataFormat.SampleSize = 
                KS_DIBSIZE(DataFormatVideoInfoHeaderOut->VideoInfoHeader.bmiHeader);

            //
            // Perform other validation such as cropping and scaling checks
            // 

            break;

        } // End of VIDEOINFOHEADER specifier

        // -------------------------------------------------------------------
        // Specifier FORMAT_AnalogVideo for KS_ANALOGVIDEOINFO
        // -------------------------------------------------------------------

        else if (IsEqualGUID (DataRange->Specifier, 
                KSDATAFORMAT_SPECIFIER_ANALOGVIDEO)) {
      
            //
            // For analog video, the DataRange and DataFormat
            // are identical, so just copy the whole structure
            //

            PKS_DATARANGE_ANALOGVIDEO DataRangeVideo = 
                    (PKS_DATARANGE_ANALOGVIDEO) *pAvailableFormats;

            // MATCH FOUND!
            MatchFound = TRUE;            
            FormatSize = sizeof (KS_DATARANGE_ANALOGVIDEO);

            if (OnlyWantsSize) {
                break;
            }
            
            // Caller wants the full data format
            if (IntersectInfo->SizeOfDataFormatBuffer < FormatSize) {
                pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                return FALSE;
            }

            RtlCopyMemory(
                IntersectInfo->DataFormatBuffer,
                DataRangeVideo,
                sizeof (KS_DATARANGE_ANALOGVIDEO));

            ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;

            break;

        } // End of KS_ANALOGVIDEOINFO specifier

        // -------------------------------------------------------------------
        // Specifier STATIC_KSDATAFORMAT_TYPE_VIDEO for Video Port
        // -------------------------------------------------------------------

        else if (IsEqualGUID (DataRange->Specifier, 
                      KSDATAFORMAT_SPECIFIER_NONE) &&
                      IsEqualGUID (DataRange->SubFormat, KSDATAFORMAT_SUBTYPE_VPVideo)) {
      
      
            // MATCH FOUND!
            MatchFound = TRUE;            
            FormatSize = sizeof (KSDATAFORMAT);

            if (OnlyWantsSize) {
                break;
            }
            
            // Caller wants the full data format
            if (IntersectInfo->SizeOfDataFormatBuffer < FormatSize) {
                pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                return FALSE;
            }

   
            RtlCopyMemory(
            IntersectInfo->DataFormatBuffer,
            &StreamFormatVideoPort,
            sizeof (KSDATAFORMAT));

            ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;

            break;
        }

        // -------------------------------------------------------------------
        // Specifier KSDATAFORMAT_SPECIFIER_NONE for VP VBI
        // -------------------------------------------------------------------

        else if (IsEqualGUID (DataRange->Specifier, 
                      KSDATAFORMAT_SPECIFIER_NONE) &&
                      IsEqualGUID (DataRange->SubFormat, KSDATAFORMAT_SUBTYPE_VPVBI)) {
      
            // MATCH FOUND!
            MatchFound = TRUE;            
            FormatSize = sizeof (KSDATAFORMAT);

            if (OnlyWantsSize) {
                break;
            }
            
            // Caller wants the full data format
            if (IntersectInfo->SizeOfDataFormatBuffer < FormatSize) {
                pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                return FALSE;
            }

   
            RtlCopyMemory(
            IntersectInfo->DataFormatBuffer,
            &StreamFormatVideoPortVBI,
            sizeof (KSDATAFORMAT));

            ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;

            break;
        }

        // -------------------------------------------------------------------
        // Specifier STATIC_KSDATAFORMAT_TYPE_NONE for VBI capture stream
        // -------------------------------------------------------------------

        else if (IsEqualGUID (DataRange->Specifier, 
                      KSDATAFORMAT_SPECIFIER_VBI)) {
      
            PKS_DATARANGE_VIDEO_VBI DataRangeVBIToVerify = 
                    (PKS_DATARANGE_VIDEO_VBI) DataRange;
            PKS_DATARANGE_VIDEO_VBI DataRangeVBI = 
                    (PKS_DATARANGE_VIDEO_VBI) *pAvailableFormats;

            //
            // Check that the other fields match
            //
            if ((DataRangeVBIToVerify->bFixedSizeSamples != DataRangeVBI->bFixedSizeSamples) ||
                (DataRangeVBIToVerify->bTemporalCompression != DataRangeVBI->bTemporalCompression) ||
                (DataRangeVBIToVerify->StreamDescriptionFlags != DataRangeVBI->StreamDescriptionFlags) ||
                (DataRangeVBIToVerify->MemoryAllocationFlags != DataRangeVBI->MemoryAllocationFlags) ||
                (RtlCompareMemory (&DataRangeVBIToVerify->ConfigCaps,
                        &DataRangeVBI->ConfigCaps,
                        sizeof (KS_VIDEO_STREAM_CONFIG_CAPS)) != 
                        sizeof (KS_VIDEO_STREAM_CONFIG_CAPS))) {
                continue;
            }
            
            // MATCH FOUND!
            MatchFound = TRUE;            
            FormatSize = sizeof (KS_DATAFORMAT_VBIINFOHEADER);

            if (OnlyWantsSize) {
                break;
            }
            
            // Caller wants the full data format
            if (IntersectInfo->SizeOfDataFormatBuffer < FormatSize) {
                pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                return FALSE;
            }

            // Copy over the KSDATAFORMAT, followed by the 
            // actual VBIInfoHeader
                
            RtlCopyMemory(
                &((PKS_DATAFORMAT_VBIINFOHEADER)IntersectInfo->DataFormatBuffer)->DataFormat,
                &DataRangeVBIToVerify->DataRange,
                sizeof (KSDATARANGE));

            ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;

            RtlCopyMemory(
                &((PKS_DATAFORMAT_VBIINFOHEADER) IntersectInfo->DataFormatBuffer)->VBIInfoHeader,
                &DataRangeVBIToVerify->VBIInfoHeader,
                sizeof (KS_VBIINFOHEADER));
        }

    } // End of loop on all formats for this stream
    
    if (!MatchFound) {

        pSrb->Status = STATUS_NO_MATCH;
        return FALSE;
    }

    if (OnlyWantsSize) {

        // Check for special case where there is no buffer being passed
        if ( IntersectInfo->SizeOfDataFormatBuffer == 0 ) {

            pSrb->Status = STATUS_BUFFER_OVERFLOW;
        }
        else {
    
            *(PULONG) IntersectInfo->DataFormatBuffer = FormatSize;
            FormatSize = sizeof(ULONG);
        }
    }

    pSrb->ActualBytesTransferred = FormatSize;
    return TRUE;
}


void CWDMVideoDecoder::SrbGetStreamInfo(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    DBGTRACE(("CWDMVideoDecoder:SrbGetStreamInfo()\n"));

    // 
    // verify that the buffer is large enough to hold our return data
    //
    DEBUG_ASSERT (pSrb->NumberOfBytesToTransfer >= 
        sizeof (HW_STREAM_HEADER) +
        sizeof (HW_STREAM_INFORMATION) * NumStreams);

    //
    // Set the header
    // 

    PHW_STREAM_HEADER pstrhdr =
        (PHW_STREAM_HEADER)&(pSrb->CommandData.StreamBuffer->StreamHeader);

    pstrhdr->NumberOfStreams = NumStreams;
    pstrhdr->SizeOfHwStreamInformation = sizeof (HW_STREAM_INFORMATION);
    pstrhdr->NumDevPropArrayEntries = NumAdapterProperties();
    pstrhdr->DevicePropertiesArray = (PKSPROPERTY_SET)AdapterProperties;
    pstrhdr->Topology = &Topology;

    //
    // stuff the contents of each HW_STREAM_INFORMATION struct 
    //
    PHW_STREAM_INFORMATION pstrinfo =
        (PHW_STREAM_INFORMATION)&(pSrb->CommandData.StreamBuffer->StreamInfo);

    for (unsigned j = 0; j < NumStreams; j++) {
        *pstrinfo++ = Streams[j].hwStreamInfo;
    }

    DBGTRACE(("Exit: CWDMVideoDecoder:SrbGetStreamInfo()\n"));
}


VOID CWDMVideoDecoder::SrbSetProperty (PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID(PROPSETID_VIDCAP_CROSSBAR, pSPD->Property->Set)) {
        m_pDevice->SetCrossbarProperty (pSrb);
    }
    else if (IsEqualGUID(PROPSETID_VIDCAP_VIDEOPROCAMP, pSPD->Property->Set)) {
        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEOPROCAMP_S));

        ULONG Id = pSPD->Property->Id;              // index of the property
        PKSPROPERTY_VIDEOPROCAMP_S pS = (PKSPROPERTY_VIDEOPROCAMP_S) pSPD->PropertyInfo;    // pointer to the data

        pSrb->Status = m_pDevice->SetProcAmpProperty(Id, pS->Value);
    }
    else if (IsEqualGUID(PROPSETID_VIDCAP_VIDEODECODER, pSPD->Property->Set)) {
        m_pDevice->SetDecoderProperty (pSrb);
    }
    else
        DBGERROR(("CWDMVideoDecoder:SrbSetProperty() unknown property\n"));
}


VOID CWDMVideoDecoder::SrbGetProperty (PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID (PROPSETID_VIDCAP_CROSSBAR, pSPD->Property->Set)) {
        m_pDevice->GetCrossbarProperty (pSrb);
    }
    else if (IsEqualGUID(PROPSETID_VIDCAP_VIDEOPROCAMP, pSPD->Property->Set)) {
        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEOPROCAMP_S));

        ULONG Id = pSPD->Property->Id;              // index of the property
        PKSPROPERTY_VIDEOPROCAMP_S pS = (PKSPROPERTY_VIDEOPROCAMP_S) pSPD->PropertyInfo;    // pointer to the data

        RtlCopyMemory(pS, pSPD->Property, sizeof(KSPROPERTY));

        pS->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
        pSrb->Status = m_pDevice->GetProcAmpProperty(Id, &pS->Value);
        pSrb->ActualBytesTransferred = pSrb->Status == STATUS_SUCCESS ?
            sizeof (KSPROPERTY_VIDEOPROCAMP_S) : 0;
    }
    else if (IsEqualGUID(PROPSETID_VIDCAP_VIDEODECODER, pSPD->Property->Set)) {
        m_pDevice->GetDecoderProperty (pSrb);
    }
    else
        DBGERROR(("CWDMVideoDecoder:SrbGetProperty() unknown property\n"));
}


void CWDMVideoDecoder::SetTunerInfo( PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PKSSTREAM_HEADER pDataPacket = pSrb->CommandData.DataBufferArray;

    ASSERT (pDataPacket->FrameExtent == sizeof (KS_TVTUNER_CHANGE_INFO));

    KIRQL Irql;

    if (m_pVBICaptureStream)
        m_pVBICaptureStream->DataLock(&Irql); 

    RtlCopyMemory(  &m_TVTunerChangeInfo,
                    pDataPacket->Data,
                    sizeof (KS_TVTUNER_CHANGE_INFO));

    m_TVTunerChanged = TRUE;

    if (m_pVBICaptureStream)
        m_pVBICaptureStream->DataUnLock(Irql); 
}


BOOL CWDMVideoDecoder::GetTunerInfo(KS_TVTUNER_CHANGE_INFO* pTVChangeInfo)
{
    if (m_TVTunerChanged) {
        KIRQL Irql;
        m_pVBICaptureStream->DataLock(&Irql); 
        RtlCopyMemory(pTVChangeInfo, &m_TVTunerChangeInfo, sizeof (KS_TVTUNER_CHANGE_INFO));
        m_TVTunerChanged = FALSE;
        m_pVBICaptureStream->DataUnLock(Irql); 
        return TRUE;
    }
    else
        return FALSE;
}


BOOL CWDMVideoDecoder::SrbChangePowerState(PHW_STREAM_REQUEST_BLOCK pSrb)
{

    DBGTRACE(("CWDMVideoDecoder:SrbChangePowerState()\n"));

    switch (pSrb->CommandData.DeviceState)
    {
        case PowerDeviceD3:
            m_preEventOccurred = TRUE;
            m_pDevice->SaveState();
            break;
        case PowerDeviceD2:
            m_preEventOccurred = TRUE;
            m_pDevice->SaveState();
            break;
        case PowerDeviceD1:
            m_preEventOccurred = TRUE;
            m_pDevice->SaveState();
            break;
        case PowerDeviceD0:
            m_postEventOccurred = TRUE;
            m_pDevice->RestoreState(m_OpenStreams);
            break;
    }

    pSrb->Status = STATUS_SUCCESS;

    return(TRUE);
}


VOID CWDMVideoPortStream::AttemptRenegotiation()
{
    int streamNumber = m_pStreamObject->StreamNumber;
    if (m_EventCount)
    {
        DBGINFO(("Attempting renegotiation on stream %d\n", streamNumber));

        if (streamNumber == STREAM_VPVideo)
        {
            StreamClassStreamNotification(
                SignalMultipleStreamEvents,
                m_pStreamObject,
                &MY_KSEVENTSETID_VPNOTIFY,
                KSEVENT_VPNOTIFY_FORMATCHANGE);
        }
        else if (streamNumber == STREAM_VPVBI)
        {
            StreamClassStreamNotification(
                SignalMultipleStreamEvents,
                m_pStreamObject,
                &MY_KSEVENTSETID_VPVBINOTIFY,
                KSEVENT_VPVBINOTIFY_FORMATCHANGE);
        }
        else
            ASSERT(0);
    }
    else
    {
        DBGINFO(("NOT attempting renegotiation on stream %d\n", streamNumber));
    }
}


NTSTATUS CWDMVideoDecoder::EventProc( IN PHW_EVENT_DESCRIPTOR pEventDescriptor)
{

    if( pEventDescriptor->Enable)
        m_nMVDetectionEventCount++;
    else
        m_nMVDetectionEventCount--;

    return( STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\debugdef.h ===
#pragma once

//==========================================================================;
//
//	Decoder specific debug declarations
//
//		$Date:   05 Aug 1998 11:31:52  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#define DBG_COMPONENT "ATIBT: "
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\decoder.h ===
#pragma once

//==========================================================================;
//
//  Decoder - Main decoder declarations
//
//      $Date:   21 Aug 1998 21:46:28  $
//  $Revision:   1.1  $
//    $Author:   Tashjian  $
//
// $Copyright:  (c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "viddefs.h"
#include "retcode.h"

#include "capmain.h"
#include "register.h"

/////////////////////////////////////////////////////////////////////////////
// CLASS CRegInfo
//
// Description:
//    Provides min, max, and default values for a register. To use this class,
//    user will declare an object of this class and provide min, max and default
//    values of the register.
//
// Attributes:
//    int intMin - minumum value
//    int intMax - maximum value
//    int intDefault - default value
//
// Methods:
//    Min() : return minimum value of the register
//    Max() : return maximum value of the register
//    Default(): return default value of the register
//    OutOfRange() : check if an value is out of range
//
/////////////////////////////////////////////////////////////////////////////
class CRegInfo
{
   int intMin;       // minumum value
   int intMax;       // maximum value
   int intDefault;   // default value

public:
   CRegInfo()
   {
      intMin = 0;
      intMax = 0;
      intDefault = 0;
   }

   CRegInfo(int min, int max, int def)
   {
      intMin = min;
      intMax = max;
      intDefault = def;
   }

   // return min, max and default value of a register
   inline int Min() const { return intMin; }
   inline int Max() const { return intMax; }
   inline int Default() const { return intDefault; }

   // check if an value is out of range of a register
   inline BOOL OutOfRange(int x)
   {
      if((x > intMax) || (x < intMin))
         return TRUE;
      return FALSE;
   }
};


/////////////////////////////////////////////////////////////////////////////
// CLASS Decoder
//
// Description:
//    This class encapsulates the register fields in the decoder portion of
//    the Bt848.
//    A complete set of functions are developed to manipulate all the
//    register fields in the decoder for the Bt848.
//    For Read-Write register field, "Set..." function is provided to modify
//    the content of the reigster field. And either "Get..." (for more
//    than 1 bit) or "Is..." (for 1 bit) function is provided to obtain the
//    value of the register field.
//    For Read-Only register field, only "Get..." (for more than 1 bit) or
//    "Is..." (for 1 bit) function is provided to obtain the content of the
//    register field.
//    When there are odd-field complements to the even-field register field,
//    same value is set to both odd and even register fields.
//    Several direct register content modifying/retrieval functions are
//    implemented for direct access to the register contents. They were
//    originally developed for testing purpose only. They are retained in the
//    class for convenience only and usage of these functions must be very cautious.
//
// Methods:
//    See below
//
// Note: 1) Scaling registers are not implemented.
//       2) Odd-fields are set to the same value as the even-field registers
/////////////////////////////////////////////////////////////////////////////

class Decoder
{
protected:
    RegisterB decRegSTATUS;
    RegField  decFieldHLOC;
    RegField  decFieldNUML;
    RegField  decFieldCSEL;
    RegField  decFieldSTATUS_RES;
    RegField  decFieldLOF;
    RegField  decFieldCOF;
    RegisterB decRegIFORM;
    RegField  decFieldHACTIVE;
    RegField  decFieldMUXSEL;
    RegField  decFieldXTSEL;
    RegField  decFieldFORMAT;
    RegisterB decRegTDEC;
    RegField  decFieldDEC_FIELD;
    RegField  decFieldDEC_FIELDALIGN;
    RegField  decFieldDEC_RAT;
    RegisterB decRegBRIGHT;
    RegisterB decRegMISCCONTROL;
    RegField  decFieldLNOTCH;
    RegField  decFieldCOMP;
    RegField  decFieldLDEC;
    RegField  decFieldMISCCONTROL_RES;
    RegField  decFieldCON_MSB;
    RegField  decFieldSAT_U_MSB;
    RegField  decFieldSAT_V_MSB;
    RegisterB decRegCONTRAST_LO;
    RegisterB decRegSAT_U_LO;
    RegisterB decRegSAT_V_LO;
    RegisterB decRegHUE;
    RegisterB decRegSCLOOP;
    RegField  decFieldCAGC;
    RegField  decFieldCKILL;
    RegisterB decRegWC_UP;
    RegisterB decRegOFORM;
    RegField  decFieldVBI_FRAME;
    RegField  decFieldCODE;
    RegField  decFieldLEN;
    RegisterB decRegVSCALE_HI;
    RegField  decFieldYCOMB;
    RegField  decFieldCOMB;
    RegField  decFieldINT;
    RegisterB decRegTEST;
    RegisterB decRegVPOLE;
    RegField  decFieldOUT_EN;
    RegField  decFieldDVALID;
    RegField  decFieldVACTIVE;
    RegField  decFieldCBFLAG;
    RegField  decFieldFIELD;
    RegField  decFieldACTIVE;
    RegField  decFieldHRESET;
    RegField  decFieldVRESET;
    RegisterB decRegADELAY;
    RegisterB decRegBDELAY;
    RegisterB decRegADC;
    RegField  decFieldCLK_SLEEP;
    RegField  decFieldC_SLEEP;
    RegField  decFieldCRUSH;
    RegisterB decRegVTC;
    RegField  decFieldHSFMT;
    RegisterB decRegWC_DN;
    RegisterB decRegSRESET;
    RegisterB decRegODD_MISCCONTROL;
    RegField  decFieldODD_LNOTCH;
    RegField  decFieldODD_COMP;
    RegField  decFieldODD_LDEC;
    RegField  decFieldODD_CBSENSE;
    RegField  decFieldODD_MISCCONTROL_RES;
    RegField  decFieldODD_CON_MSB;
    RegField  decFieldODD_SAT_U_MSB;
    RegField  decFieldODD_SAT_V_MSB;
    RegisterB decRegODD_SCLOOP;
    RegField  decFieldODD_CAGC;
    RegField  decFieldODD_CKILL;
    RegField  decFieldODD_HFILT;
    RegisterB decRegODD_VSCALE_HI;
    RegField  decFieldODD_YCOMB;
    RegField  decFieldODD_COMB;
    RegField  decFieldODD_INT;
    RegisterB decRegODD_VTC;
    RegField  decFieldODD_HSFMT;

   // used for checking if parameter out of register's range
    CRegInfo m_regHue, m_regSaturationNTSC, m_regSaturationSECAM,
            m_regContrast,  m_regBrightness;

   // used for checking parameter range
   CRegInfo m_param;

   // value set to after calculations
   WORD m_satParam, m_conParam, m_hueParam, m_briParam;

   // to be used to adjust contrast
   int  regBright;      // brightness register value before adjustment
   WORD regContrast;    // contrast register value before adjustment

   // for 829 vs 829a setup
   unsigned m_outputEnablePolarity;

   DWORD m_videoStandard;   //Paul
   DWORD m_supportedVideoStandards;  //Paul:  The standards supported by the decoder AND'd with standards supported by Crystal
public:
   // constructor and destructor
    Decoder(PDEVICE_PARMS);
    virtual ~Decoder();

    void * operator new(size_t size, void * pAllocation) { return(pAllocation);}
    void operator delete(void * pAllocation) {}


    void GetVideoDecoderCaps(PKSPROPERTY_VIDEODECODER_CAPS_S caps);
    void GetVideoDecoderStatus(PKSPROPERTY_VIDEODECODER_STATUS_S status);
    DWORD GetVideoDecoderStandard();
    ULONG GetVideoDeocderStandardsSupportedInThisConfiguration()
        { return m_supportedVideoStandards; }

    BOOL SetVideoDecoderStandard(DWORD standard);


   // Device Status register (DSTATUS)
   virtual BOOL      Is525LinesVideo();
   virtual BOOL      IsCrystal0Selected();
   virtual BOOL      IsLumaOverflow();
   virtual void      ResetLumaOverflow();
   virtual BOOL      IsChromaOverflow();
   virtual void      ResetChromaOverflow();

   // Input Format register (IFORM)
   virtual ErrorCode SetVideoInput(Connector);
   virtual Connector GetVideoInput();
   virtual ErrorCode SetCrystal(Crystal);
   virtual int       GetCrystal();
   virtual ErrorCode SetVideoFormat(VideoFormat);
   virtual int       GetVideoFormat();

   // Temporal Decimation register (TDEC)
   virtual ErrorCode SetRate(BOOL, VidField, int);

   // Brightness Control register (BRIGHT)
   virtual ErrorCode SetBrightness(int);
   virtual int       GetBrightness();

   // Miscellaneous Control register (E_CONTROL, O_CONTROL)
   virtual void      SetLumaNotchFilter(BOOL);
   virtual BOOL      IsLumaNotchFilter();
   virtual void      SetCompositeVideo(BOOL);
   virtual void      SetLumaDecimation(BOOL);

   // Luma Gain register (CON_MSB, CONTRAST_LO)
   virtual ErrorCode SetContrast(int);
   virtual int       GetContrast();

   // Chroma Gain register (SAT_U_MSB, SAT_V_MSB, SAT_U_LO, SAT_V_LO)
   virtual ErrorCode SetSaturation(int);
   virtual int       GetSaturation();

   // Hue Control register (HUE)
   virtual ErrorCode SetHue(int);
   virtual int       GetHue();

   // SC Loop Control register (E_SCLOOP, O_SCLOOP)
   virtual void      SetChromaAGC(BOOL);
   virtual BOOL      IsChromaAGC();
   virtual void      SetLowColorAutoRemoval(BOOL);

   // Output Format register (OFORM)
   virtual void      SetVBIFrameMode(BOOL);
   virtual BOOL      IsVBIFrameMode();
   virtual void      SetCodeInsertionEnabled(BOOL);
   virtual BOOL      IsCodeInsertionEnabled();
   virtual void      Set16BitDataStream(BOOL);
   virtual BOOL      Is16BitDataStream();

   // Vertical Scaling register (E_VSCALE_HI, O_VSCALE_HI)
   virtual void      SetChromaComb(BOOL);
   virtual BOOL      IsChromaComb();
   virtual void      SetInterlaced(BOOL);
   virtual BOOL      IsInterlaced();
   
   // VPOLE register
   void SetOutputEnablePolarity(int i)
        {m_outputEnablePolarity = i;}
    
   int GetOutputEnablePolarity()
        {return m_outputEnablePolarity;}
    
   virtual void      SetOutputEnabled(BOOL);
   virtual BOOL      IsOutputEnabled();
   virtual void      SetHighOdd(BOOL);
   virtual BOOL      IsHighOdd();

   // ADC Interface register (ADC)
   virtual void      PowerDown(BOOL);
   virtual BOOL      IsPowerDown();
   virtual void      SetChromaADC(BOOL);
   virtual void      SetAdaptiveAGC(BOOL);
   virtual BOOL      IsAdaptiveAGC();

   // Software Reset register (SRESET)
   virtual void      SoftwareReset();

   // Test Control register (TEST)
   virtual void      AdjustInertialDampener(BOOL);

protected:
   // mapping function
   virtual ErrorCode Mapping(int, CRegInfo, int *, CRegInfo);

   // check registry key value to determine if contrast should be adjusted
   virtual BOOL IsAdjustContrast();

private:
   void              SelectCrystal(char);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\decprop.h ===
//==========================================================================;
//
//  WDM Video Decoder adapter properties definitions
//
//      $Date:   02 Oct 1998 22:59:36  $
//  $Revision:   1.1  $
//    $Author:   KLEBANOV  $
//
// $Copyright:  (c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#ifdef _DEC_PROP_H_
#pragma message("DecProp.h INCLUDED MORE THAN ONCE")
#else
#define _DEC_PROP_H_
#endif

// ------------------------------------------------------------------------
// Property set for the Video Crossbar
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(XBarProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_CAPS_S),    // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_CAPS_S),    // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_CAN_ROUTE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_ROUTE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_PININFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_PININFO_S),    // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_PININFO_S),    // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    )

};


// ------------------------------------------------------------------------
// Property set for VideoProcAmp
// ------------------------------------------------------------------------

// defaults
static const LONG BrightnessDefault = 128;
static const LONG ContrastDefault = 128;
static const LONG HueDefault = 128;
static const LONG SaturationDefault = 128;

//
// First define all of the ranges and stepping values
//

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG BrightnessRangeAndStep [] = 
{
    {
        // Eventually need to convert these to IRE * 100 unites
        256/1,              // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum
        255                 // Maximum
    }
};

static KSPROPERTY_MEMBERSLIST BrightnessMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_STEPPEDRANGES,
            sizeof (BrightnessRangeAndStep),
            SIZEOF_ARRAY (BrightnessRangeAndStep),
            0
        },
        (PVOID) BrightnessRangeAndStep
    },
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (BrightnessDefault),
            1,
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &BrightnessDefault
    }
};

static KSPROPERTY_VALUES BrightnessValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (BrightnessMembersList),
    BrightnessMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG ContrastRangeAndStep [] = 
{
    {
        256/1,        // SteppingDelta (range / steps)
        0,                  // Reserved
        0,                  // Minimum in (gain * 100) units
        255               // Maximum in (gain * 100) units
    }
};

static KSPROPERTY_MEMBERSLIST ContrastMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_STEPPEDRANGES,
            sizeof (ContrastRangeAndStep),
            SIZEOF_ARRAY (ContrastRangeAndStep),
            0
        },
        (PVOID) ContrastRangeAndStep
    },
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (ContrastDefault),
            1,
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &ContrastDefault
    }    
};

static KSPROPERTY_VALUES ContrastValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (ContrastMembersList),
    ContrastMembersList
};

KSPROPERTY_STEPPING_LONG HueRangeAndStep [] = 
{
    {
        256/1,        // SteppingDelta
        0,                                // Reserved
        0,                                // Minimum 
        255         // Maximum 
    }
};

KSPROPERTY_MEMBERSLIST HueMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_STEPPEDRANGES,
            sizeof (HueRangeAndStep),
            SIZEOF_ARRAY (HueRangeAndStep),
            0
        },
        (PVOID) HueRangeAndStep
    },
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (HueDefault),
            1,
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &HueDefault
    }
};

KSPROPERTY_VALUES HueValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (HueMembersList),
    HueMembersList
};

KSPROPERTY_STEPPING_LONG SaturationRangeAndStep [] = 
{
    {
        256/1,        // SteppingDelta
        0,                                // Reserved
        0,                                // Minimum 
        255         // Maximum 
    }
};

KSPROPERTY_MEMBERSLIST SaturationMembersList [] = 
{
    {
        {
            KSPROPERTY_MEMBER_STEPPEDRANGES,
            sizeof (SaturationRangeAndStep),
            SIZEOF_ARRAY (SaturationRangeAndStep),
            0
        },
        (PVOID) SaturationRangeAndStep
    },
    {
        {
            KSPROPERTY_MEMBER_VALUES,
            sizeof (SaturationDefault),
            1,
            KSPROPERTY_MEMBER_FLAG_DEFAULT
        },
        (PVOID) &SaturationDefault
    }    
};

KSPROPERTY_VALUES SaturationValues =
{
    {
        STATICGUIDOF (KSPROPTYPESETID_General),
        VT_I4,
        0
    },
    SIZEOF_ARRAY (SaturationMembersList),
    SaturationMembersList
};

// ------------------------------------------------------------------------
DEFINE_KSPROPERTY_TABLE(VideoProcAmpProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_CONTRAST,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &ContrastValues,                        // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &BrightnessValues,                       // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_HUE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &HueValues,                       // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEOPROCAMP_SATURATION,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        &SaturationValues,                       // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    )
};

// ------------------------------------------------------------------------
// Property set for AnalogVideoDecoder
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(AnalogVideoDecoder)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEODECODER_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEODECODER_CAPS_S), // MinProperty
        sizeof(KSPROPERTY_VIDEODECODER_CAPS_S), // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEODECODER_STANDARD,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEODECODER_STATUS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEODECODER_STATUS_S),// MinProperty
        sizeof(KSPROPERTY_VIDEODECODER_STATUS_S),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinProperty
        sizeof(KSPROPERTY_VIDEODECODER_S),      // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    )
};

// ------------------------------------------------------------------------
// Array of all of the property sets supported by the adapter
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(AdapterProperties)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_VIDEOPROCAMP,
        SIZEOF_ARRAY(VideoProcAmpProperties),
        VideoProcAmpProperties,
        0, 
        NULL
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_CROSSBAR,             // Set
        SIZEOF_ARRAY(XBarProperties),           // PropertiesCount
        XBarProperties,                         // PropertyItem
        0,                                      // FastIoCount
        NULL                                    // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_VIDEODECODER,
        SIZEOF_ARRAY(AnalogVideoDecoder),
        AnalogVideoDecoder,
        0, 
        NULL
    )
};

ULONG NumAdapterProperties()
{
    return SIZEOF_ARRAY(AdapterProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\regbase.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include "regbase.h"

// static; holds the base address of the PCI registers
DWORD RegBase::dwBaseAddress_ = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\decoder.cpp ===
//==========================================================================;
//
//	Decoder - Main decoder implementation
//
//		$Date:   21 Aug 1998 21:46:26  $
//	$Revision:   1.1  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "mytypes.h"
#include "Scaler.h"
#include "decoder.h"
#include "dcdrvals.h"

#include "capmain.h"

#define CON_vs_BRI   // HW does contrast incorrectly, try to adjust in SW


//===========================================================================
// Bt848 Decoder Class Implementation
//===========================================================================

#define REGALIGNMENT 1

/////////////////////////////////////////////////////////////////////////////
// Constructor
/////////////////////////////////////////////////////////////////////////////
Decoder::Decoder(PDEVICE_PARMS pDeviceParms) :
   // init register min, max, default
   m_regHue(HueMin, HueMax, HueDef),
   m_regSaturationNTSC(SatMinNTSC, SatMaxNTSC, SatDefNTSC),
   m_regSaturationSECAM(SatMinSECAM, SatMaxSECAM, SatDefSECAM),
   m_regContrast(ConMin, ConMax, ConDef),
   m_regBrightness(BrtMin, BrtMax, BrtDef),
   m_param(ParamMin, ParamMax, ParamDef),

	decRegSTATUS (((0x00 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldHLOC(decRegSTATUS, 6, 1, RW) ,
	decFieldNUML(decRegSTATUS, 4, 1, RW) ,
	decFieldCSEL(decRegSTATUS, 3, 1, RW) ,
	decFieldSTATUS_RES(decRegSTATUS, 2, 1, RW) ,
	decFieldLOF(decRegSTATUS, 1, 1, RW) ,
	decFieldCOF(decRegSTATUS, 0, 1, RW) ,
	decRegIFORM (((0x01 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldHACTIVE(decRegIFORM, 7, 1, RW) ,
	decFieldMUXSEL(decRegIFORM, 5, 2, RW) ,
	decFieldXTSEL(decRegIFORM, 3, 2, RW) ,
	decFieldFORMAT(decRegIFORM, 0, 3, RW) ,
	decRegTDEC (((0x02 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldDEC_FIELD(decRegTDEC, 7, 1, RW) ,
	decFieldDEC_FIELDALIGN(decRegTDEC, 6, 1, RW) ,
	decFieldDEC_RAT(decRegTDEC, 0, 6, RW) ,
	decRegBRIGHT (((0x0A + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegMISCCONTROL (((0x0B + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldLNOTCH(decRegMISCCONTROL, 7, 1, RW) ,
	decFieldCOMP(decRegMISCCONTROL, 6, 1, RW) ,
	decFieldLDEC(decRegMISCCONTROL, 5, 1, RW) ,
	decFieldMISCCONTROL_RES(decRegMISCCONTROL, 3, 1, RW) ,
	decFieldCON_MSB(decRegMISCCONTROL, 2, 1, RW) ,
	decFieldSAT_U_MSB(decRegMISCCONTROL, 1, 1, RW) ,
	decFieldSAT_V_MSB(decRegMISCCONTROL, 0, 1, RW) ,
	decRegCONTRAST_LO (((0x0C + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegSAT_U_LO (((0x0D + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegSAT_V_LO (((0x0E + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegHUE (((0x0F + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegSCLOOP (((0x10 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldCAGC(decRegSCLOOP, 6, 1, RW) ,
	decFieldCKILL(decRegSCLOOP, 5, 1, RW) ,
	decRegWC_UP(((0x11 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegOFORM (((0x12 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldVBI_FRAME(decRegOFORM, 4, 1, RW) ,
	decFieldCODE(decRegOFORM, 3, 1, RW) ,
	decFieldLEN(decRegOFORM, 2, 1, RW) ,
	decRegVSCALE_HI (((0x13 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldYCOMB(decRegVSCALE_HI, 7, 1, RW) ,
	decFieldCOMB(decRegVSCALE_HI, 6, 1, RW) ,
	decFieldINT(decRegVSCALE_HI, 5, 1, RW) ,
	decRegTEST (((0x15 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegVPOLE (((0x16 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldOUT_EN (decRegVPOLE, 7, 1, RW), 
	decFieldDVALID (decRegVPOLE, 6, 1, RW), 
	decFieldVACTIVE (decRegVPOLE, 5, 1, RW), 
	decFieldCBFLAG (decRegVPOLE, 4, 1, RW), 
	decFieldFIELD (decRegVPOLE, 3, 1, RW), 
	decFieldACTIVE (decRegVPOLE, 2, 1, RW), 
	decFieldHRESET (decRegVPOLE, 1, 1, RW), 
	decFieldVRESET (decRegVPOLE, 0, 1, RW), 
	decRegADELAY (((0x18 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegBDELAY (((0x19 + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegADC (((0x1A + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldCLK_SLEEP(decRegADC, 3, 1, RW) ,
	decFieldC_SLEEP(decRegADC, 1, 1, RW) ,
	decFieldCRUSH(decRegADC, 0, 1, RW),
	decRegVTC (((0x1B + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decFieldHSFMT(decRegVTC, 7, 1, RW) ,
	decRegWC_DN(((0x1E + 0) * REGALIGNMENT) + 0, RW, pDeviceParms) ,
	decRegSRESET (((0x1F + 0) * REGALIGNMENT) + 0, RW, pDeviceParms), 
	decRegODD_MISCCONTROL (((0x0B + -0x03) * REGALIGNMENT) + 0x8C, RW, pDeviceParms) ,
	decFieldODD_LNOTCH(decRegODD_MISCCONTROL, 7, 1, RW) ,
	decFieldODD_COMP(decRegODD_MISCCONTROL, 6, 1, RW) ,
	decFieldODD_LDEC(decRegODD_MISCCONTROL, 5, 1, RW) ,
	decFieldODD_CBSENSE(decRegODD_MISCCONTROL, 4, 1, RW) ,
	decFieldODD_MISCCONTROL_RES(decRegODD_MISCCONTROL, 3, 1, RW) ,
	decFieldODD_CON_MSB(decRegODD_MISCCONTROL, 2, 1, RW) ,
	decFieldODD_SAT_U_MSB(decRegODD_MISCCONTROL, 1, 1, RW) ,
	decFieldODD_SAT_V_MSB(decRegODD_MISCCONTROL, 0, 1, RW) ,
	decRegODD_SCLOOP (((0x10 + -0x03) * REGALIGNMENT) + 0x8C, RW, pDeviceParms) ,
	decFieldODD_CAGC(decRegODD_SCLOOP, 6, 1, RW) ,
	decFieldODD_CKILL(decRegODD_SCLOOP, 5, 1, RW) ,
	decFieldODD_HFILT(decRegODD_SCLOOP, 3, 2, RW) ,
	decRegODD_VSCALE_HI (((0x13 + -0x03) * REGALIGNMENT) + 0x8C, RW, pDeviceParms) ,
	decFieldODD_YCOMB(decRegODD_VSCALE_HI, 7, 1, RW) ,
	decFieldODD_COMB(decRegODD_VSCALE_HI, 6, 1, RW) ,
	decFieldODD_INT(decRegODD_VSCALE_HI, 5, 1, RW) ,
	decRegODD_VTC (((0x1B + -0x03) * REGALIGNMENT) + 0x8C, RW, pDeviceParms) ,
	decFieldODD_HSFMT(decRegODD_VTC, 7, 1, RW)
{
   if(!(pDeviceParms->chipRev < 4))
   {
	   // need to set this to 0x4F
	   decRegWC_UP = 0x4F;
	   // and this one to 0x7F to make sure CRUSH bit works for not plain vanila BT829
	   decRegWC_DN = 0x7F;
   }

   // HACTIVE should always be 0
   decFieldHACTIVE = 0;

   decFieldHSFMT = 0;

   // The following lines were commented out in an attempt to
   // have a picture which closely matches what an ordinary TV would
   // show. However, it should be noted that Brooktree recommended to
   // comment out only the 'SetLowColorAutoRemoval' line. Probably the
   // best solution of all would be to somehow expose these options
   // to the application.

   // Instead of using default values, set some registers fields to optimum values
/*
   SetLumaDecimation(TRUE);
   SetChromaAGC(TRUE);
   SetLowColorAutoRemoval(FALSE);
   SetAdaptiveAGC(FALSE);
*/

   // for contrast adjustment purpose
   regBright = 0x00;     // brightness register value before adjustment
   regContrast = 0xD8;   // contrast register value before adjustment
   m_supportedVideoStandards = KS_AnalogVideo_NTSC_M |
                               KS_AnalogVideo_NTSC_M_J |
                               KS_AnalogVideo_PAL_B |
                               KS_AnalogVideo_PAL_D |
                               KS_AnalogVideo_PAL_G |
                               KS_AnalogVideo_PAL_H |
                               KS_AnalogVideo_PAL_I |
                               KS_AnalogVideo_PAL_M |
                               KS_AnalogVideo_PAL_N;   //Paul: what BT 829 can support (from L829A_A functional Description)

   if(!(pDeviceParms->chipRev < 4))
		   m_supportedVideoStandards |= KS_AnalogVideo_SECAM_B		|
									 KS_AnalogVideo_SECAM_D		|
									 KS_AnalogVideo_SECAM_G		|
									 KS_AnalogVideo_SECAM_H		|
									 KS_AnalogVideo_SECAM_K		|
									 KS_AnalogVideo_SECAM_K1	|
									 KS_AnalogVideo_SECAM_L		|
									 KS_AnalogVideo_SECAM_L1;
      
   m_supportedVideoStandards &= pDeviceParms->ulVideoInStandardsSupportedByCrystal;   //Paul: AND with whatever supported by the onboard crystal

   // jaybo 
   // loop until we find a supported TV standard, and use that to init
   UINT k;
   for (k = 1; k; k += k) {
      if (k & m_supportedVideoStandards) {
         SetVideoDecoderStandard(k);
         break; 
      }
   }
   // end jaybo
}

/////////////////////////////////////////////////////////////////////////////
// Destructor
/////////////////////////////////////////////////////////////////////////////
Decoder::~Decoder()
{
}


void Decoder::GetVideoDecoderCaps(PKSPROPERTY_VIDEODECODER_CAPS_S pS)
{
    pS->StandardsSupported = m_supportedVideoStandards;

    pS->Capabilities = KS_VIDEODECODER_FLAGS_CAN_DISABLE_OUTPUT  |
                       KS_VIDEODECODER_FLAGS_CAN_INDICATE_LOCKED ;

    // How long (ms) til locked indicator is valid.
    // 31 line periods * 63.5uS per line.
    pS->SettlingTime = 2;       

    // Not sure about this
    // HSync per VSync
    pS->HSyncPerVSync = 6;
}

void Decoder::GetVideoDecoderStatus(PKSPROPERTY_VIDEODECODER_STATUS_S pS)
{
	pS->NumberOfLines = Is525LinesVideo() ? 525 : 625;
	pS->SignalLocked = decFieldHLOC == 1;
}

DWORD Decoder::GetVideoDecoderStandard()
{
	return m_videoStandard; //Paul
}

BOOL Decoder::SetVideoDecoderStandard(DWORD standard)
{
    if (m_supportedVideoStandards & standard) //Paul: standard must be a supported standard
    {
        m_videoStandard = standard;

        switch ( m_videoStandard )
        {
        case KS_AnalogVideo_NTSC_M:
            Decoder::SetVideoFormat(VFormat_NTSC);
            break;
        case KS_AnalogVideo_NTSC_M_J:
            Decoder::SetVideoFormat(VFormat_NTSC_J);
            break;
			case KS_AnalogVideo_PAL_B:
			case KS_AnalogVideo_PAL_D:
			case KS_AnalogVideo_PAL_G:
			case KS_AnalogVideo_PAL_H:
			case KS_AnalogVideo_PAL_I:
            Decoder::SetVideoFormat(VFormat_PAL_BDGHI);    // PAL_BDGHI covers most areas 
            break;
        case KS_AnalogVideo_PAL_M:
            Decoder::SetVideoFormat(VFormat_PAL_M); 
            break;
        case KS_AnalogVideo_PAL_N:
            Decoder::SetVideoFormat(VFormat_PAL_N_COMB); 
            break;
        default:    //Paul:  SECAM
            Decoder::SetVideoFormat(VFormat_SECAM);

        }
        return TRUE;
    }
    else
        return FALSE;

}


//===== Device Status register ==============================================

/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::Is525LinesVideo()
// Purpose: Check to see if we are dealing with 525 lines video signal
// Input:   None
// Output:  None
// Return:  TRUE if 525 lines detected; else FALSE (assume 625 lines)
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::Is525LinesVideo()
{
  return (BOOL) (decFieldNUML == 0);  //525
}

/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsCrystal0Selected()
// Purpose: Reflect whether XTAL0 or XTAL1 is selected
// Input:   None
// Output:  None
// Return:  TRUE if XTAL0 selected; else FALSE (XTAL1 selected)
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsCrystal0Selected()
{
  return (BOOL) (decFieldCSEL == 0);
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsLumaOverflow()
// Purpose: Indicates if luma ADC overflow
// Input:   None
// Output:  None
// Return:  TRUE if luma ADC overflow; else FALSE
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsLumaOverflow()
{
  return (BOOL) (decFieldLOF == 1);
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::ResetLumaOverflow()
// Purpose: Reset luma ADC overflow bit
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::ResetLumaOverflow()
{
  decFieldLOF = 0;  // write to it will reset the bit
}

/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsChromaOverflow()
// Purpose: Indicates if chroma ADC overflow
// Input:   None
// Output:  None
// Return:  TRUE if chroma ADC overflow; else FALSE
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsChromaOverflow()
{
  return (BOOL) (decFieldCOF == 1);
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::ResetChromaOverflow()
// Purpose: Reset chroma ADC overflow bit
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::ResetChromaOverflow()
{
  decFieldCOF = 0;  // write to it will reset the bit
}


//===== Input Format register ===============================================

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetVideoInput(Connector source)
// Purpose: Select which connector as input
// Input:   Connector source - SVideo, Tuner, Composite
// Output:  None
// Return:  Fail if error in parameter, else Success
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetVideoInput(Connector source)
{
  if ((source != ConSVideo) &&
       (source != ConTuner) &&
       (source != ConComposite))
    return Fail;

  decFieldMUXSEL = (ULONG)source + 1;

  // set to composite or Y/C component video depends on video source
  SetCompositeVideo((source == ConSVideo) ? FALSE : TRUE);
  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  Connector Decoder::GetVideoInput()
// Purpose: Get which connector is input
// Input:   None
// Output:  None
// Return:  Video source - SVideo, Tuner, Composite
/////////////////////////////////////////////////////////////////////////////
Connector Decoder::GetVideoInput()
{
  return ((Connector)(decFieldMUXSEL-1));
}

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetCrystal(Crystal crystalNo)
// Purpose: Select which crystal as input
// Input:   Crystal crystalNo:
//            XT0         - Crystal_XT0
//            XT1         - Crystal_XT1
//            Auto select - Crystal_AutoSelect
// Output:  None
// Return:  Fail if error in parameter, else Success
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetCrystal(Crystal crystalNo)
{
  if ((crystalNo < Crystal_XT0) || (crystalNo >  Crystal_AutoSelect))
    return Fail;

  decFieldXTSEL = crystalNo;
  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetCrystal()
// Purpose: Get which crystal is input
// Input:   None
// Output:  None
// Return:   Crystal Number:
//            XT0         - Crystal_XT0
//            XT1         - Crystal_XT1
//            Auto select - Crystal_AutoSelect
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetCrystal()
{
  return ((int)decFieldXTSEL);
}


/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetVideoFormat(VideoFormat format)
// Purpose: Set video format
// Input:   Video format -
//            Auto format:          VFormat_AutoDetect
//            NTSC (M):             VFormat_NTSC
//            NTSC Japan:           VFormat_NTSC_J
//            PAL (B, D, G, H, I):  VFormat_PAL_BDGHI
//            PAL (M):              VFormat_PAL_M
//            PAL(N):               VFormat_PAL_N
//            SECAM:                VFormat_SECAM
//            PAN(N Combo)          VFormat_PAL_N_COMB
// Output:  None
// Return:  Fail if error in parameter, else Success
// Notes:   Available video formats are: NTSC, PAL(B, D, G, H, I), PAL(M),
//                                       PAL(N), SECAM
//          This function also sets the AGCDelay (ADELAY) and BrustDelay
//          (BDELAY) registers
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetVideoFormat(VideoFormat format)
{
  if ((format <  VFormat_AutoDetect)  ||
       (format >  VFormat_PAL_N_COMB))
    return Fail;

  switch (format)
  {
    case VFormat_PAL_M:
    case VFormat_NTSC:
    case VFormat_NTSC_J:
      decFieldFORMAT = format;
      decRegADELAY = 0x68;
      decRegBDELAY = 0x5D;
      SetChromaComb(TRUE);        // enable chroma comb
      SelectCrystal('N');         // select NTSC crystal
      break;

    case VFormat_PAL_BDGHI:
    case VFormat_PAL_N:
      decFieldFORMAT = format;
      decRegADELAY = 0x7F;
      decRegBDELAY = 0x72;
      SetChromaComb(TRUE);        // enable chroma comb
      SelectCrystal('P');         // select PAL crystal
      break;

    case VFormat_PAL_N_COMB:
      decFieldFORMAT = format;
      decRegADELAY = 0x7F;
      decRegBDELAY = 0x72;
      SetChromaComb(TRUE);        // enable chroma comb
      SelectCrystal('N');         // select NTSC crystal
      break;

    case VFormat_SECAM:
      decFieldFORMAT = format;
      decRegADELAY = 0x7F;
      decRegBDELAY = 0xA0;
      SetChromaComb(FALSE);       // disable chroma comb
      SelectCrystal('P');         // select PAL crystal
      break;
      
    default: // VFormat_AutoDetect
      // auto format detect by examining the number of lines
      if (Decoder::Is525LinesVideo()) // lines == 525 -> NTSC
        Decoder::SetVideoFormat(VFormat_NTSC);
      else  // lines == 625 -> PAL/SECAM
        Decoder::SetVideoFormat(VFormat_PAL_BDGHI);    // PAL_BDGHI covers most areas 
  }

  SetSaturation(m_satParam);
  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetVideoFormat()
// Purpose: Obtain video format
// Input:   None
// Output:  None
// Return:  Video format
//            Auto format:          VFormat_AutoDetect
//            NTSC (M):             VFormat_NTSC
//            PAL (B, D, G, H, I):  VFormat_PAL_BDGHI
//            PAL (M):              VFormat_PAL_M
//            PAL(N):               VFormat_PAL_N
//            SECAM:                VFormat_SECAM
//            PAN(N Combo)          VFormat_PAL_N_COMB
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetVideoFormat()
{
   BYTE bFormat = (BYTE)decFieldFORMAT;
   if (!bFormat) // autodetection enabled
      return Is525LinesVideo() ? VFormat_NTSC : VFormat_SECAM;
   else
     return bFormat;
}


//===== Temporal Decimation register ========================================

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetRate(BOOL fields, VidField even, int rate)
// Purpose: Set frames or fields rate
// Input:   BOOL fields   - TRUE for fields, FALSE for frames
//          VidField even - TRUE to start decimation with even field, FALSE odd
//          int  rate     - decimation rate: frames (1-50/60); fields(1-25/30)
// Output:  None
// Return:  Fail if error in parameter, else Success
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetRate(BOOL fields, VidField vf, int rate)
{
  int nMax;
  if (Is525LinesVideo() == TRUE)
    nMax = 30;  // NTSC
  else
    nMax = 25;  // PAL/SECAM

  // if setting frame rate, double the max value
  if (fields == FALSE)
    nMax *= 2;

  if (rate < 0 || rate > nMax)
    return Fail;

  decFieldDEC_FIELD = (fields == FALSE) ? Off : On;
  decFieldDEC_FIELDALIGN = (vf == VF_Even) ? On : Off;
  int nDrop = (BYTE) nMax - rate;
  decFieldDEC_RAT = (BYTE) (fields == FALSE) ? nDrop : nDrop * 2;

  return Success;
}


//===== Brightness Control register =========================================

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetBrightness(int param)
// Purpose: Set video brightness
// Input:   int param - parameter value (0-255; default 128)
// Output:  None
// Return:  Fail if error in parameter, else Success
// Note:    See IsAdjustContrast() for detailed description of the contrast
//          adjustment calculation
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetBrightness(int param)
{
  if(m_param.OutOfRange(param))
    return Fail;

  // perform mapping to our range
  int mapped;
  if (Mapping(param, m_param, &mapped, m_regBrightness) == Fail)
    return Fail;

  m_briParam = (WORD)param;

  // calculate brightness value
  int value = (128 * mapped) / m_regBrightness.Max() ;

  // need to limit the value to 0x7F (+50%) because 0x80 is -50%!
  if ((mapped > 0) && (value == 0x80))
    value = 0x7F;

  // perform adjustment of brightness register if adjustment is needed
  if (IsAdjustContrast())
  {
    regBright = value;   // brightness value before adjustment

    long A = (long)regBright * (long)0xD8;
    long B = 64 * ((long)0xD8 - (long)regContrast);
    long temp = 0x00;
    if (regContrast != 0)  // already limit contrast > zero; just in case here
       temp = ((A + B) / (long)regContrast);
    temp = (temp < -128) ? -128 : ((temp > 127) ? 127 : temp);
    value = (BYTE)temp;

  }

  decRegBRIGHT = (BYTE)value;

  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetBrightness()
// Purpose: Obtain brightness value
// Input:   None
// Output:  None
// Return:  Brightness parameter (0-255)
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetBrightness()
{
  return m_briParam;
}


//===== Miscellaneous Control register (E_CONTROL, O_CONTROL) ===============

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetLumaNotchFilter(BOOL mode)
// Purpose: Enable/Disable luma notch filter
// Input:   BOOL mode - TRUE = Enable; FALSE = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetLumaNotchFilter(BOOL mode)
{
  decFieldLNOTCH = (mode == FALSE) ? On : Off;  // reverse
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsLumaNotchFilter()
// Purpose: Check if luma notch filter is enable or disable
// Input:   None
// Output:  None
// Return:  TRUE = Enable; FALSE = Disable
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsLumaNotchFilter()
{
  return (decFieldLNOTCH == Off) ? TRUE : FALSE;  // reverse
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetCompositeVideo(BOOL mode)
// Purpose: Select composite or Y/C component video
// Input:   BOOL mode - TRUE = Composite; FALSE = Y/C Component
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetCompositeVideo(BOOL mode)
{
  if (mode == TRUE)
  {
    // composite video
    decFieldCOMP = Off;
    Decoder::SetChromaADC(FALSE);  // disable chroma ADC
    Decoder::SetLumaNotchFilter(TRUE);  // enable luma notch filter
  }
  else
  {
    // Y/C Component video
    decFieldCOMP = On;
    Decoder::SetChromaADC(TRUE);  // enable chroma ADC
    Decoder::SetLumaNotchFilter(FALSE);  // disable luma notch filter
  }
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetLumaDecimation(BOOL mode)
// Purpose: Enable/Disable luma decimation filter
// Input:   BOOL mode - TRUE = Enable; FALSE = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetLumaDecimation(BOOL mode)
{
   // value of 0 turns the decimation on
   decFieldLDEC = (mode == TRUE) ? 0 : 1;
}


//===== Luma Gain register (CON_MSB, CONTRAST_LO) ===========================

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetContrast(int param)
// Purpose: Set video contrast
// Input:   int param - parameter value (0-255; default 128)
// Output:  None
// Return:  Fail if error in parameter, else Success
// Note:    See IsAdjustContrast() for detailed description of the contrast
//          adjustment calculation
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetContrast(int param)
{
  if(m_param.OutOfRange(param))
    return Fail;

  BOOL adjustContrast = IsAdjustContrast(); // is contrast need to be adjusted

  // if adjust contrast is needed, make sure contrast reg value != 0
  if (adjustContrast)
    m_regContrast = CRegInfo(1, ConMax, ConDef);

  // perform mapping to our range
  int mapped;
  if (Mapping(param, m_param, &mapped, m_regContrast) == Fail)
    return Fail;

  m_conParam = (WORD)param;

  // calculate contrast
  DWORD value =  (DWORD)0x1FF * (DWORD)mapped;
  value /= (DWORD)m_regContrast.Max();
  if (value > 0x1FF)
    value = 0x1FF;

  // contrast is set by a 9 bit value; set LSB first
  decRegCONTRAST_LO = value;

  // now set the Miscellaneous Control Register CON_V_MSB to the 9th bit value
  decFieldCON_MSB = ((value & 0x0100) ? On : Off);

  // perform adjustment of brightness register if adjustment is needed
  if (adjustContrast)
  {
    regContrast = (WORD)value;    // contrast value

    long A = (long)regBright * (long)0xD8;
    long B = 64 * ((long)0xD8 - (long)regContrast);
    long temp = 0x00;
    if (regContrast != 0)  // already limit contrast > zero; just in case here
       temp = ((A + B) / (long)regContrast);
    temp = (temp < -128) ? -128 : ((temp > 127) ? 127 : temp);
    decRegBRIGHT = (BYTE)temp;

  }

  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetContrast()
// Purpose: Obtain contrast value
// Input:   None
// Output:  None
// Return:  Contrast parameter (0-255)
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetContrast()
{
  return m_conParam;
}


//===== Chroma Gain register (SAT_U_MSB, SAT_V_MSB, SAT_U_LO, SAT_V_LO) =====

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetSaturation(int param)
// Purpose: Set color saturation by modifying U and V values
// Input:   int param - parameter value (0-255; default 128)
// Output:  None
// Return:  Fail if error in parameter, else Success
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetSaturation(int param)
{
  if(m_param.OutOfRange(param))
    return Fail;

  // color saturation is controlled by two nine bit values:
  // ChromaU & ChromaV
  // To maintain normal color balance, the ratio between the 2 register
  // values should be kept at the power-up default ratio

  // Note that U & V values for NTSC and PAL are the same, SECAM is different

  WORD nominalNTSC_U = 0xFE;     // nominal value (i.e. 100%) for NTSC/PAL
  WORD nominalNTSC_V = 0xB4;
  WORD nominalSECAM_U = 0x87;    // nominal value (i.e. 100%) for SECAM
  WORD nominalSECAM_V = 0x85;

  CRegInfo regSat;               // selected saturation register; NTSC/PAL or SECAM
  WORD nominal_U, nominal_V;     // selected nominal U and V value; NTSC/PAL or SECAM

  // select U & V values of either NTSC/PAL or SECAM to be used for calculation
  if (GetVideoFormat() == VFormat_SECAM)
  {
    nominal_U = nominalSECAM_U;
    nominal_V = nominalSECAM_V;
    regSat = m_regSaturationSECAM;
  }
  else
  {
    nominal_U = nominalNTSC_U;
    nominal_V = nominalNTSC_V;
    regSat = m_regSaturationNTSC;
  }

  // perform mapping to our range
  int mapped;
  if (Mapping(param, m_param, &mapped, regSat) == Fail)
    return Fail;

  m_satParam = (WORD)param;

  WORD max_nominal = max(nominal_U, nominal_V);

  // calculate U and V values
  WORD Uvalue = (WORD) ((DWORD)mapped * (DWORD)nominal_U / (DWORD)max_nominal);
  WORD Vvalue = (WORD) ((DWORD)mapped * (DWORD)nominal_V / (DWORD)max_nominal);

  // set U
  decRegSAT_U_LO = Uvalue;

  // now set the Miscellaneous Control Register SAT_U_MSB to the 9th bit value
  decFieldSAT_U_MSB = ((Uvalue & 0x0100) ? On : Off);

  // set V
  decRegSAT_V_LO = Vvalue;

  // now set the Miscellaneous Control Register SAT_V_MSB to the 9th bit value
  decFieldSAT_V_MSB = ((Vvalue & 0x0100) ? On : Off);

  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetSaturation()
// Purpose: Obtain saturation value
// Input:   None
// Output:  None
// Return:  Saturation parameter (0-255)
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetSaturation()
{
  return m_satParam;
}


//===== Hue Control register (HUE) ==========================================

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetHue(int param)
// Purpose: Set video hue
// Input:   int param - parameter value (0-255; default 128)
// Output:  None
// Return:  Fail if error in parameter, else Success
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetHue(int param)
{
  if(m_param.OutOfRange(param))
    return Fail;

  // perform mapping to our range
  int mapped;
  if (Mapping(param, m_param, &mapped, m_regHue) == Fail)
    return Fail;

  m_hueParam = (WORD)param;

  int value = (-128 * mapped) / m_regHue.Max();

  if (value > 127)
    value = 127;
  else if (value < -128)
    value = -128;

  decRegHUE = value;

  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetHue()
// Purpose: Obtain hue value
// Input:   None
// Output:  None
// Return:  Hue parameter (0-255)
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetHue()
{
  return m_hueParam;
}


//===== SC Loop Control register (E_SCLOOP, O_SCLOOP) =======================


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetChromaAGC(BOOL mode)
// Purpose: Enable/Disable Chroma AGC compensation
// Input:   BOOL mode - TRUE = Enable, FALSE = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetChromaAGC(BOOL mode)
{
  decFieldCAGC = (mode == FALSE) ? Off : On;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsChromaAGC()
// Purpose: Check if Chroma AGC compensation is enable or disable
// Input:   None
// Output:  None
// Return:  TRUE = Enable, FALSE = Disable
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsChromaAGC()
{
  return (decFieldCAGC == On) ? TRUE : FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetLowColorAutoRemoval(BOOL mode)
// Purpose: Enable/Disable low color detection and removal
// Input:   BOOL mode - TRUE = Enable, FALSE = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetLowColorAutoRemoval(BOOL mode)
{
  decFieldCKILL = (mode == FALSE) ? Off : On;
}


//===== Output Format register (OFORM) ======================================

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetVBIFrameMode(BOOL mode)
// Purpose: Enable/Disable VBI frame output mode
// Input:   BOOL mode - TRUE = Enable, FALSE = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetVBIFrameMode(BOOL mode)
{
  decFieldVBI_FRAME = (mode == FALSE) ? Off : On;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsVBIFrameMode()
// Purpose: Check if VBI frame output mode is enabled
// Input:   None
// Output:  None
// Return:  TRUE = Enable, FALSE = Disable
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsVBIFrameMode()
{
  return (decFieldVBI_FRAME == On) ? TRUE : FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetCodeInsertionEnabled(BOOL mode)
// Purpose: 
// Input:   BOOL mode - TRUE = Disabled, FALSE = Enabled
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetCodeInsertionEnabled(BOOL mode)
{
  decFieldCODE = (mode == TRUE) ? On : Off;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsCodeInsertionEnabled()
// Purpose: Check if code insertion in data stream is enabled
// Input:   None
// Output:  None
// Return:  TRUE = enabled, FALSE = disabled
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsCodeInsertionEnabled()
{
  return (decFieldCODE == On) ? TRUE : FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::Set16BitDataStream(BOOL mode)
// Purpose: 8 or 16 bit data stream
// Input:   BOOL mode - TRUE = 16, FALSE = 8
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::Set16BitDataStream(BOOL mode)
{
  decFieldLEN = (mode == TRUE) ? On : Off;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::Is16BitDatastream()
// Purpose: Check if 16 bit data stream
// Input:   None
// Output:  None
// Return:  TRUE = 16, FALSE = 8
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::Is16BitDataStream()
{
  return (decFieldLEN == On) ? TRUE : FALSE;
}


//===== Vertical Scaling register (E_VSCALE_HI, O_VSCALE_HI) ================

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetChromaComb(BOOL mode)
// Purpose: Enable/Disable chroma comb
// Input:   BOOL mode - TRUE = Enable, FALSE = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetChromaComb(BOOL mode)
{
  decFieldCOMB = (mode == FALSE) ? Off : On;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsChromaComb()
// Purpose: Check if chroma comb is enable or disable
// Input:   None
// Output:  None
// Return:  TRUE = Enable, FALSE = Disable
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsChromaComb()
{
  return (decFieldCOMB == On) ? TRUE : FALSE;
}
   
/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetInterlaced(BOOL mode)
// Purpose: Enable/Disable Interlace
// Input:   BOOL mode - TRUE = Interlaced
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetInterlaced(BOOL mode)
{
  decFieldINT = (mode == FALSE) ? Off : On;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsInterlaced()
// Purpose: Check if interlaced or non-interlaced
// Input:   None
// Output:  None
// Return:  TRUE = Interlaced
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsInterlaced()
{
  return (decFieldINT == On) ? TRUE : FALSE;
}
   
//===== VPOLE register ==================================================

BOOL Decoder::IsOutputEnabled ()
{
    return (decFieldOUT_EN == m_outputEnablePolarity);
}

void Decoder::SetOutputEnabled (BOOL mode)
{
    decFieldOUT_EN = (mode == TRUE) ? m_outputEnablePolarity : !m_outputEnablePolarity;
}

BOOL Decoder::IsHighOdd ()
{
    return (decFieldFIELD == 0); // 0 enabled; 1 even
}

void Decoder::SetHighOdd (BOOL mode)
{
    decFieldFIELD = (mode == TRUE) ? 0 : 1; // 0 enabled; 1 even
}

//===== ADC Interface register (ADC) =========================================

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::PowerDown(BOOL mode)
// Purpose: Select normal or shut down clock operation
// Input:   BOOL mode - TRUE = shut down, FALSE = normal operation
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::PowerDown(BOOL mode)
{
  decFieldCLK_SLEEP = (mode == FALSE) ? Off : On;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsPowerDown()
// Purpose: Check if clock operation has been shut down
// Input:   None
// Output:  None
// Return:  TRUE = shut down, FALSE = normal operation
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsPowerDown()
{
  return (decFieldCLK_SLEEP == On) ? TRUE : FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetChromaADC(BOOL mode)
// Purpose: Select normal or sleep C ADC operation
// Input:   BOOL mode - TRUE = normal, FALSE = sleep
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetChromaADC(BOOL mode)
{
  decFieldC_SLEEP = (mode == FALSE) ? On : Off; // reverse
}


/*^^////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetAdaptiveAGC(BOOL mode)
// Purpose: Set adaptive or non-adaptive AGC operation
// Input:   BOOL mode - TRUE = Adaptive, FALSE = Non-adaptive
// Output:  None
// Return:  None
*////////////////////////////////////////////////////////////////////////////
void Decoder::SetAdaptiveAGC(BOOL mode)
{
   decFieldCRUSH = (mode == FALSE) ? Off : On;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsAdaptiveAGC()
// Purpose: Check if adaptive or non-adaptive AGC operation is selected
// Input:   None
// Output:  None
// Return:  TRUE = Adaptive, FALSE = Non-adaptive
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsAdaptiveAGC()
{
  return (decFieldCRUSH == On) ? TRUE : FALSE;
}


//===== Software Reset register (SRESET) ====================================

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SoftwareReset()
// Purpose: Perform software reset; all registers set to default values
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SoftwareReset()
{
  decRegSRESET = 0x00;  // write any value will do
}


//===== Test Control register (TEST) ========================================

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::AdjustInertialDampener(BOOL mode)
// Purpose: for factory diagnostics only
// Input:   TRUE or FALSE
// Output:  None
// Return:  None
// NOTE:    For factory diagnostics only!!!!!!!
//          John Welch's dirty little secret
/////////////////////////////////////////////////////////////////////////////
void Decoder::AdjustInertialDampener(BOOL mode)
{
#pragma message ("FOR TEST DIAGNOSTICS ONLY!  ")
  decRegTEST = (mode == FALSE) ? 0x00 : 0x01;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SelectCrystal(char useCrystal)
// Purpose: Select correct crystal for NTSC or PAL
// Input:   char useCrystal - 'N' for NTSC; 'P' for PAL
// Output:  None
// Return:  None
// NOTE:    Assume at most 2 crystals installed in hardware. i.e. 1 for NTSC
//          and the other for PAL/SECAM.
//          If there is only 1 crystal exists (which must be crystal XT0),
//          do nothing since it is already selected.
/////////////////////////////////////////////////////////////////////////////
void Decoder::SelectCrystal(char useCrystal)
{
#pragma message("do something about registry")
/*
   // locate crystal information in the registry
   // the keys to look for in registry are:
   //    1. Bt848\NumXTAL - number of crystal installed
   //                       possible values are "1" or "2"
   //    2. Bt848\XT0     - what crystal type is for crystal 0
   //                       possible values are "NTSC", "PAL"
   // There is another key exist which may be useful in the future:
   //    Bt848\XT1        - what crystal type is for crystal 1
   //                       possible values are "NTSC", "PAL", and "NONE"

   VRegistryKey vkey(PRK_CLASSES_ROOT, "Bt848");

   // make sure the key exists
   if (vkey.lastError() == ERROR_SUCCESS)
   {
      char * numCrystalKey = "NumXTAL";
      char   nCrystal[5];
      DWORD  nCrystalLen = 2;    // need only first char; '1' or '2'

      // get number of crystal exists
      if (vkey.getSubkeyValue(numCrystalKey, nCrystal, (DWORD *)&nCrystalLen))
      {
         // if there is only 1 crystal, no other crystal to change to
         if (nCrystal[0] == '2')
         {
            char * crystalTypeKey = "XT0";    // crystal 0 type
            char   crystalType[10];
            DWORD  crystalTypeLen = 6;    // need only first char: 'N' or 'P'

            // get the crystal 0 information
            if (vkey.getSubkeyValue(crystalTypeKey, crystalType, (DWORD *)&crystalTypeLen))
               // compare with what we want to use
               if ((IsCrystal0Selected() && (crystalType[0] != useCrystal)) ||
                    (!IsCrystal0Selected() && (crystalType[0] == useCrystal)))
                  // need to change crystal
                  SetCrystal(IsCrystal0Selected() ? Crystal_XT1 : Crystal_XT0);
         }
      }
   }
*/   
}

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::Mapping(int fromValue, CRegInfo fromRange,
//                                           int * toValue, CRegInfo toRange)
// Purpose: Map a value in certain range to a value in another range
// Input:   int fromValue - value to be mapped from
//          CRegInfo fromRange - range of value mapping from
//          CRegInfo toRange   - range of value mapping to
// Output:  int * toValue - mapped value
// Return:  Fail if error in parameter, else Success
// Comment: No range checking is performed here. Assume parameters are in
//          valid ranges.
//          The mapping function does not assume default is always the mid
//          point of the whole range. It only assumes default values of the
//          two ranges correspond to each other.
//          
//          The mapping formula is:
//
//            For fromRange.Min() <= fromValue <= fromRange.Default():
//
//               fromValue (fromRange.Default() - fromRange.Min())
//               ------------------------------------------------ + fromRange.Min()
//                     toRange.Default() - toRange.Min()
//
//            For fromRange.Default() < fromValue <= fromRange.Max():
//
//               (fromValue - fromRange.Default()) (toRange.Max() - toRange.Default())
//               --------------------------------------------------------------------- + toRange.Default()
//                           toRange.Max() - toRange.Default()
//
////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::Mapping(int fromValue, CRegInfo fromRange,
                                 int * toValue, CRegInfo toRange)
{
   // calculate intermediate values
   DWORD a = toRange.Default() - toRange.Min();
   DWORD b = fromRange.Default() - fromRange.Min();
   DWORD c = toRange.Max() - toRange.Default();
   DWORD d = fromRange.Max() - fromRange.Default();

   // prevent divide by zero
   if ((b == 0) || (d == 0))
      return (Fail);

   // perform mapping
   if (fromValue <= fromRange.Default())
      *toValue = (int) (DWORD)fromValue * a / b + (DWORD)toRange.Min();
   else
      *toValue = (int) ((DWORD)fromValue - (DWORD)fromRange.Default()) * c / d
                       + (DWORD)toRange.Default();

   return (Success);
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL Decoder::IsAdjustContrast()
// Purpose: Check registry key whether adjust contrast is needed
// Input:   None
// Output:  None
// Return:  TRUE = adjust contrast, FALSE = don't adjust contrast
// Note:    If adjust contrast is turn on, brightness register value will be
//          adjusted such that it remains a constant after the calculation
//          performed by the hardware.
//
//          The formula is:
//             To keep brightness constant (i.e. not affect by changing contrast)
//             set brightness to B/(C/C0)
//             where B is value of brightness before adjustment
//                   C is contrast value
//                   C0 is nominal contrast value (0xD8)
//
//             To adjust the contrast level such that it is at the middle of
//             black and white: set brightness to (B * C0 + 64 * (C0 - C))/C
//             (this is what Intel wants)
//
//             Currently there is still limitation of how much adjustment
//             can be performed. For example, if brightness is already high,
//             (i.e. brightness reg value close to 0x7F), lowering contrast
//             until a certain level will have no adjustment effect on brightness.
//             In fact, it would even bring down brightness to darkness.
//
//             Example 1: if brightness is at nominal value (0x00), contrast can
//                        only go down to 0x47 (brightness adjustment is already
//                        at max of 0x7F) before it starts affecting brightness
//                        which takes it darkness.
//             Example 2: if brightness is at nominal value (0x00), contrast can
//                        go all the way up with brightness adjusted correctly.
//                        However, the max adjustment used is only 0xDC and
//                        the max adjustment we can use is 0x&F.
//             Example 3: if brightness is at max (0x7F), lowering contrast
//                        cannot be compensated by adjusting brightness anymore.
//                        The result is gradually taking brightness to darkness.
//             Example 4: if brightness is at min (0x80), lowering contrast has
//                        no visual effect. Bringing contrast to max is using
//                        0xA5 in brightness for compensation.
//
//             One last note, the center is defined as the middle of the
//             gamma adjusted luminance level. Changing it to use the middle of
//             the linear (RGB) luminance level is possible.
/////////////////////////////////////////////////////////////////////////////
BOOL Decoder::IsAdjustContrast()
{
   return FALSE;
/*
   // locate adjust contrast information in the registry
   // the key to look for in registry is:
   //    Bt848\AdjustContrast - 0 = don't adjust contrast
   //                           1 = adjust contrast

   VRegistryKey vkey(PRK_CLASSES_ROOT, "Bt848");

   // make sure the key exists
   if (vkey.lastError() == ERROR_SUCCESS)
   {
      char * adjustContrastKey = "AdjustContrast";
      char   key[3];
      DWORD  keyLen = 2;    // need only first char; '0' or '1'

      // get the registry value and check it, if exist
      if ((vkey.getSubkeyValue(adjustContrastKey, key, (DWORD *)&keyLen)) &&
           (key[0] == '1'))
         return (TRUE);
   }
   return (FALSE);
*/   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\device.cpp ===
//==========================================================================;
//
//  Device - Implementation of the Bt829 CVideoDecoderDevice
//
//      $Date:   28 Aug 1998 14:44:20  $
//  $Revision:   1.2  $
//    $Author:   Tashjian  $
//
// $Copyright:  (c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "register.h"
#include "defaults.h"
#include "device.h"
#include "mediums.h"
#include "capdebug.h"
#include "StrmInfo.h"

#include "initguid.h"
DEFINE_GUID(DDVPTYPE_BROOKTREE,     0x1352A560L,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);


#ifdef BT829_SUPPORT_16BIT
#define BT829_VPCONNECTIONS_NUMBER  2
#else
#define BT829_VPCONNECTIONS_NUMBER  1
#endif
#define BT829_PIXELFORMATS_NUMBER   1
#define NTSC_FRAME_RATE 30
#define PAL_FRAME_RATE 25
#define BT829_LOST_LINES    2  // BT829
#define BT829A_LOST_LINES   3   // BT829a


Device::Device( PPORT_CONFIGURATION_INFORMATION ConfigInfo,
                PDEVICE_PARMS pDeviceParms, 
                PUINT puiError) :

        m_pDeviceParms(pDeviceParms),

        // Corresponds to KS_DEFAULTs
        hue(128),
        saturation(128),
        contrast(128),
        brightness(128),
        source(ConTuner),
        VBIEN(FALSE),
        VBIFMT(FALSE),

        // Beware of these hardcoded values

        //Paul:  Setup default for NTSC and PAL
        NTSCDecoderWidth(720),
        NTSCDecoderHeight(240),
        PALDecoderWidth(720),
        PALDecoderHeight(288),
        // Now set via registry
        defaultDecoderWidth(720),
        defaultDecoderHeight(240)
{
    *puiError = 0;

    RegisterB devRegIDCODE (0x17, RO, pDeviceParms);
    RegField devFieldPART_ID (devRegIDCODE, 4, 4);
    RegField devFieldPART_REV (devRegIDCODE, 0, 4);

    m_pDeviceParms->chipID = (int)devFieldPART_ID;
    m_pDeviceParms->chipRev = (int)devFieldPART_REV;

    DBGINFO(("Chip ID: 0x%x\n", m_pDeviceParms->chipID));
    DBGINFO(("Chip revision: 0x%x\n", m_pDeviceParms->chipRev));

    // Bt829 should have a PartID of 1110b (0xe).
    if (m_pDeviceParms->chipID != 0xe)
    {
        DBGERROR(("I2c failure or wrong decoder.\n"));
        *puiError = 1;
        return;
    }

    PDEVICE_DATA_EXTENSION pHwExt = (PDEVICE_DATA_EXTENSION)ConfigInfo->HwDeviceExtension;
    decoder = (Decoder *)   new ((PVOID)&pHwExt->CDecoder) Decoder(m_pDeviceParms);
    scaler =  (Scaler *)    new ((PVOID)&pHwExt->CScaler) Scaler(m_pDeviceParms);
    xbar =    (CrossBar *)  new ((PVOID)&pHwExt->CXbar) CrossBar();

    UseRegistryValues(ConfigInfo);

    // According to Brooktree, 4 is the magic dividing line
    // between 829 and 829a. Apparently, there is an 829b on the
    // horizon, but I don't have the details yet.
    // This is meant to be a kind of fail-safe
/*
    if (pHwExt->chipRev < 4) {
        outputEnablePolarity = 0;
    }
*/
 
    if (defaultDecoderWidth != 360 && defaultDecoderWidth != 720)
    {
        DBGERROR(("Unexpected defaultDecoderWidth: %d.\n", defaultDecoderWidth));
        TRAP();
    }

    destRect = MRect(0, 0, defaultDecoderWidth, defaultDecoderHeight);

    RestoreState();

    // by default, outputs will be tri-stated. Transitioning to the run state will enable it.
    SetOutputEnabled(FALSE);
}

Device::~Device()
{
    delete decoder;
    delete scaler;
    delete xbar;
}

void Device::SaveState()
{
    // save picture attributes
    hue = decoder->GetHue();
    saturation = decoder->GetSaturation();
    contrast =  decoder->GetContrast();
    brightness = decoder->GetBrightness();

    // save video source
    source = GetVideoInput();

    // save configuration of data stream to video port
    isCodeInDataStream = IsCodeInsertionEnabled();
    is16 = Is16BitDataStream();
    
    // save VBI related settings
    VBIEN = IsVBIEN();
    VBIFMT = IsVBIFMT();

    // save scaling dimensions
    scaler->GetDigitalWin(destRect);
}

void Device::RestoreState(DWORD dwStreamsOpen)
{
    Reset();
    
    // (re)initialize image 
    decoder->SetInterlaced(FALSE);
    decoder->SetHue(hue);
    decoder->SetSaturation(saturation);
    decoder->SetContrast(contrast);
    decoder->SetBrightness(brightness);

    // (re)initialize video source
    SetVideoInput(source);

    SetOutputEnablePolarity(m_pDeviceParms->outputEnablePolarity);

    // (re)initialize corresponding xbar setting.
    Route(0, (ULONG)source);

    // (re)initialize configuration of data stream to video port
    SetCodeInsertionEnabled(isCodeInDataStream);
    Set16BitDataStream(is16);

    // restore VBI settings
    SetVBIEN(VBIEN);
    SetVBIFMT(VBIFMT);

    SetVideoDecoderStandard( GetVideoDecoderStandard() );
    // initialize scaling dimensions
    //SetRect(destRect);    Paul:  Use set video decoder standard instead

    if(!dwStreamsOpen)
        SetOutputEnabled(IsOutputEnabled());
}

void Device::SetRect(MRect &rect)
{
    destRect = rect;
    scaler->SetAnalogWin(rect);
    scaler->SetDigitalWin(rect);

    // for Debugging
#ifdef DBG
    scaler->DumpSomeState();
#endif
}

void Device::Reset()
{
    SoftwareReset();
}

int Device::GetDecoderWidth()
{
    MRect tmpRect;
    scaler->GetDigitalWin(tmpRect);

    return tmpRect.right;
}

int Device::GetDecoderHeight()
{
    MRect tmpRect;
    scaler->GetDigitalWin(tmpRect);

    return tmpRect.bottom;
}

int Device::GetDefaultDecoderWidth()
{
    return defaultDecoderWidth;
}

int Device::GetDefaultDecoderHeight()
{
    return defaultDecoderHeight;
}

int Device::GetPartID()
{
  return m_pDeviceParms->chipID;
}

int Device::GetPartRev()
{
  return m_pDeviceParms->chipRev;
}

NTSTATUS
Device::GetRegistryValue(
                   IN HANDLE Handle,
                   IN PWCHAR KeyNameString,
                   IN ULONG KeyNameStringLength,
                   IN PWCHAR Data,
                   IN ULONG DataLength
)
/*++

Routine Description:

    Reads the specified registry value

Arguments:

    Handle - handle to the registry key
    KeyNameString - value to read
    KeyNameStringLength - length of string
    Data - buffer to read data into
    DataLength - length of data buffer

Return Value:

    NTSTATUS returned as appropriate

--*/
{
    NTSTATUS        Status = STATUS_INSUFFICIENT_RESOURCES;
    UNICODE_STRING  KeyName;
    ULONG           Length;
    PKEY_VALUE_FULL_INFORMATION FullInfo;

    RtlInitUnicodeString(&KeyName, KeyNameString);

    Length = sizeof(KEY_VALUE_FULL_INFORMATION) +
        KeyNameStringLength + DataLength;

    FullInfo = (struct _KEY_VALUE_FULL_INFORMATION *)ExAllocatePool(PagedPool, Length);

    if (FullInfo) {
        Status = ZwQueryValueKey(Handle,
                                 &KeyName,
                                 KeyValueFullInformation,
                                 FullInfo,
                                 Length,
                                 &Length);

        if (NT_SUCCESS(Status)) {

            if (DataLength >= FullInfo->DataLength) {
                RtlCopyMemory(Data, ((PUCHAR) FullInfo) + FullInfo->DataOffset, FullInfo->DataLength);

            } else {

                TRAP();
                Status = STATUS_BUFFER_TOO_SMALL;
            }                   // buffer right length

        }                       // if success
        ExFreePool(FullInfo);

    }                           // if fullinfo
    return Status;

}

#define MAX_REG_STRING_LENGTH  128


VOID
Device::UseRegistryValues(PPORT_CONFIGURATION_INFORMATION ConfigInfo)
/*++

Routine Description:

    Reads all registry values for the device

Arguments:

    PhysicalDeviceObject - pointer to the PDO

Return Value:

     None.

--*/

{
    NTSTATUS        Status;
    HANDLE          handle;

    WCHAR   MUX0String[] =              L"MUX0";
    WCHAR   MUX1String[] =              L"MUX1";
    WCHAR   MUX2String[] =              L"MUX2";
    WCHAR   buf[MAX_REG_STRING_LENGTH];

    ASSERT(KeGetCurrentIrql() <= PASSIVE_LEVEL);

    Status = IoOpenDeviceRegistryKey(ConfigInfo->RealPhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);

    //
    // now get all of the registry settings for
    // initializing the decoder
    //

     if (NT_SUCCESS(Status)) {
        // =========================
        // Does NOT check that the registry settings "make sense";
        // e.g., that all three inputs aren't set to SVideo.


        // =========================
        // Do MUX0
        // =========================
        Status = GetRegistryValue(handle,
                                    MUX0String,
                                    sizeof(MUX0String),
                                    buf,
                                    sizeof(buf));

        if ((NT_SUCCESS(Status)) && (buf))
        {
            if (stringsEqual(buf, L"svideo"))
                {xbar->InputPins[0] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_SVideo,     -1, &CrossbarMediums[2]);}
            else if (stringsEqual(buf, L"tuner"))
                {xbar->InputPins[0] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_Tuner,      -1, &CrossbarMediums[1]);}
            else if (stringsEqual(buf, L"composite"))
                {xbar->InputPins[0] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_Composite,  -1, &CrossbarMediums[0]);}
            else if (stringsEqual(buf, L"none"))
            {
                TRAP(); 
            }
            else
            {
                TRAP();
            }
        }
        else
        {
            TRAP();
        }


        // =========================
        // Do MUX1
        // =========================
        Status = GetRegistryValue(handle,
                                    MUX1String,
                                    sizeof(MUX1String),
                                    buf,
                                    sizeof(buf));

        if ((NT_SUCCESS(Status)) && (buf))
        {
            if (stringsEqual(buf, L"svideo"))
                {xbar->InputPins[1] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_SVideo,     -1, &CrossbarMediums[2]);}
            else if (stringsEqual(buf, L"tuner"))
                {xbar->InputPins[1] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_Tuner,      -1, &CrossbarMediums[1]);}
            else if (stringsEqual(buf, L"composite"))
                {xbar->InputPins[1] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_Composite,  -1, &CrossbarMediums[0]);}
            else if (stringsEqual(buf, L"none"))
            {
                TRAP();
            }
            else
            {
                TRAP();
            }
        }
        else
        {
            TRAP();
        }


        // =========================
        // Do MUX2
        // =========================
        Status = GetRegistryValue(handle,
                                    MUX2String,
                                    sizeof(MUX2String),
                                    buf,
                                    sizeof(buf));

        if ((NT_SUCCESS(Status)) && (buf))
        {
            if (stringsEqual(buf, L"svideo"))
                {xbar->InputPins[2] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_SVideo,     -1, &CrossbarMediums[2]);}
            else if (stringsEqual(buf, L"tuner"))
                {xbar->InputPins[2] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_Tuner,      -1, &CrossbarMediums[1]);}
            else if (stringsEqual(buf, L"composite"))
                {xbar->InputPins[2] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_Composite,  -1, &CrossbarMediums[0]);}
            else if (stringsEqual(buf, L"none"))
            {
                TRAP();
            }
            else
            {
                TRAP();
            }
        }
        else
        {
            TRAP();
        }


        // =========================
        // 8 or 16 bit data width
        // =========================

        is16 = FALSE;


        // =========================
        // Control codes embedded in data stream?
        // =========================

        isCodeInDataStream = TRUE;


        //Paul:  If hardcoding, might as well leave this with the constructor
        //defaultDecoderWidth = 720;

        //
        // close the registry handle.
        //

        ZwClose(handle);

    }                           // status = success
}

BOOL Device::stringsEqual(PWCHAR pwc1, PWCHAR pwc2)
{
    UNICODE_STRING us1, us2;
    RtlInitUnicodeString(&us1, pwc1);
    RtlInitUnicodeString(&us2, pwc2);

    // case INsensitive
    return (RtlEqualUnicodeString(&us1, &us2, TRUE));
}
// ==========================================

void Device::GetVideoPortProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSpd = pSrb->CommandData.PropertyInfo;
    ULONG Id  = pSpd->Property->Id;              // index of the property
    ULONG nS  = pSpd->PropertyOutputSize;        // size of data supplied
    ULONG standard = GetVideoDecoderStandard();

    switch (Id)
    {
    case KSPROPERTY_VPCONFIG_NUMCONNECTINFO :
        ASSERT(nS >= sizeof(ULONG));

        // 2 VideoPort connections are possible
        *(PULONG)(pSpd->PropertyInfo) = BT829_VPCONNECTIONS_NUMBER;

        pSrb->ActualBytesTransferred = sizeof(ULONG);
        break;

    case KSPROPERTY_VPCONFIG_GETCONNECTINFO :

        ASSERT(nS >= sizeof(DDVIDEOPORTCONNECT));

        {
            PKSMULTIPLE_DATA_PROP MultiProperty = (PKSMULTIPLE_DATA_PROP)pSpd->Property;

            if (MultiProperty->MultipleItem.Count == BT829_VPCONNECTIONS_NUMBER &&
                MultiProperty->MultipleItem.Size == sizeof(DDVIDEOPORTCONNECT)) {
                
                if (nS >= BT829_VPCONNECTIONS_NUMBER * sizeof(DDVIDEOPORTCONNECT)) {

                    LPDDVIDEOPORTCONNECT pConnectInfo;

                    pConnectInfo = (LPDDVIDEOPORTCONNECT) pSpd->PropertyInfo;

                    // fill in the DDVIDEOPORTCONNECT structure offset 0
                    pConnectInfo->dwSize = sizeof(DDVIDEOPORTCONNECT);
                    pConnectInfo->dwPortWidth = 8;
                    pConnectInfo->guidTypeID = DDVPTYPE_BROOKTREE;
                    pConnectInfo->dwFlags = DDVPCONNECT_INVERTPOLARITY;
                    pConnectInfo->dwReserved1 = 0;

#ifdef BT829_SUPPORT_16BIT
                    // fill in the DDVIDEOPORTCONNECT structure offset 1
                    pConnectInfo ++;
                    pConnectInfo->dwSize = sizeof(DDVIDEOPORTCONNECT);
                    pConnectInfo->guidTypeID = DDVPTYPE_BROOKTREE;
                    pConnectInfo->dwPortWidth = 16;
                    pConnectInfo->dwFlags = DDVPCONNECT_INVERTPOLARITY;
                    pConnectInfo->dwReserved1 = 0;
#endif
                    pSrb->ActualBytesTransferred = BT829_VPCONNECTIONS_NUMBER * sizeof(DDVIDEOPORTCONNECT);
                }
                else {
                    pSrb->Status = STATUS_INVALID_BUFFER_SIZE;
                }
            }
            else {
                pSrb->Status = STATUS_INVALID_PARAMETER;
            }
        }
        break;

    case KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT :
        ASSERT(nS >= sizeof(ULONG));

        *(PULONG)(pSpd->PropertyInfo) = BT829_PIXELFORMATS_NUMBER;

        pSrb->ActualBytesTransferred = sizeof(ULONG);
        break;

    case KSPROPERTY_VPCONFIG_GETVIDEOFORMAT :

        ASSERT(nS >= sizeof(DDPIXELFORMAT));

        {
            PKSMULTIPLE_DATA_PROP MultiProperty = (PKSMULTIPLE_DATA_PROP)pSpd->Property;

            if (MultiProperty->MultipleItem.Count == BT829_PIXELFORMATS_NUMBER &&
                MultiProperty->MultipleItem.Size == sizeof(DDPIXELFORMAT)) {

                if (nS >= BT829_PIXELFORMATS_NUMBER * sizeof(DDPIXELFORMAT)) {

                    ASSERT(BT829_PIXELFORMATS_NUMBER == 1); // as currently implemented, this must be true

                    LPDDPIXELFORMAT pPixelFormat;

                    pPixelFormat = (LPDDPIXELFORMAT) pSpd->PropertyInfo;

                    RtlZeroMemory(pPixelFormat, BT829_PIXELFORMATS_NUMBER * sizeof(DDPIXELFORMAT));

                    // fill in the DDPIXELFORMAT structure
                    pPixelFormat->dwSize = sizeof(DDPIXELFORMAT);
                    pPixelFormat->dwFlags = DDPF_FOURCC;
                    pPixelFormat->dwFourCC = FOURCC_UYVY;
                    pPixelFormat->dwYUVBitCount = 16;
                    pPixelFormat->dwYBitMask = (DWORD)0xFF00FF00;
                    pPixelFormat->dwUBitMask = (DWORD)0x000000FF;
                    pPixelFormat->dwVBitMask = (DWORD)0x00FF0000;
                    pPixelFormat->dwYUVZBitMask = 0;

                    pSrb->ActualBytesTransferred = BT829_PIXELFORMATS_NUMBER * sizeof(DDPIXELFORMAT);
                }
                else {
                    pSrb->Status = STATUS_INVALID_BUFFER_SIZE;
                }
            }
            else {
                pSrb->Status = STATUS_INVALID_PARAMETER;
            }
        }
        break;

    case KSPROPERTY_VPCONFIG_VPDATAINFO :

        ASSERT(nS >= sizeof(KS_AMVPDATAINFO));

        {
            // Clear the portion of the buffer we plan to return
            RtlZeroMemory(pSpd->PropertyInfo, sizeof(KS_AMVPDATAINFO));

            PKS_AMVPDATAINFO pAMVPDataInfo;

            pAMVPDataInfo = (PKS_AMVPDATAINFO) pSpd->PropertyInfo;

            int decoderLostLines = (GetPartRev() >= 4) ?
                BT829A_LOST_LINES : BT829_LOST_LINES;

            // the values are sortof hardcoded for NTSC at this point
            // VBI values will need to be tweaked
            pAMVPDataInfo->dwSize = sizeof(KS_AMVPDATAINFO);

            if ( standard & ( KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_M ) )   // NTSC rectangle?
                pAMVPDataInfo->dwMicrosecondsPerField = 16667;
            else
                pAMVPDataInfo->dwMicrosecondsPerField = 20000;

            pAMVPDataInfo->bEnableDoubleClock = FALSE;
            pAMVPDataInfo->bEnableVACT = FALSE;

            pAMVPDataInfo->lHalfLinesOdd = 0;
            pAMVPDataInfo->lHalfLinesEven = 1;

            pAMVPDataInfo->bFieldPolarityInverted = FALSE;
            pAMVPDataInfo->bDataIsInterlaced = TRUE;
            pAMVPDataInfo->dwNumLinesInVREF = 6 - decoderLostLines;

            pAMVPDataInfo->amvpDimInfo.dwFieldWidth = GetDecoderWidth();
        
            // Beware of hard-coded numbers
            pAMVPDataInfo->amvpDimInfo.dwVBIWidth = VBISamples;

            if ( standard & ( KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_M ) )   // NTSC rectangle?
            {
                pAMVPDataInfo->amvpDimInfo.dwVBIHeight = NTSCVBIEnd - decoderLostLines;
                pAMVPDataInfo->amvpDimInfo.dwFieldHeight =
                    GetDecoderHeight() +
                    pAMVPDataInfo->amvpDimInfo.dwVBIHeight;
                /*
                    (NTSCVBIEnd - 1) -  // the '- 1' makes VBIEnd zero-based
                    decoderLostLines -
                    pAMVPDataInfo->dwNumLinesInVREF;
                */
        
                pAMVPDataInfo->amvpDimInfo.rcValidRegion.top = NTSCVBIEnd - decoderLostLines;
            }
            else
            {
                pAMVPDataInfo->amvpDimInfo.dwVBIHeight = PALVBIEnd - decoderLostLines;
                pAMVPDataInfo->amvpDimInfo.dwFieldHeight =
                    GetDecoderHeight() +
                    pAMVPDataInfo->amvpDimInfo.dwVBIHeight;
                /*
                    (PALVBIEnd - 1) -  // the '- 1' makes VBIEnd zero-based
                    decoderLostLines -
                    pAMVPDataInfo->dwNumLinesInVREF;
                */
        
                pAMVPDataInfo->amvpDimInfo.rcValidRegion.top = PALVBIEnd - decoderLostLines;
            }

            pAMVPDataInfo->amvpDimInfo.rcValidRegion.left = 0;
            pAMVPDataInfo->amvpDimInfo.rcValidRegion.right = pAMVPDataInfo->amvpDimInfo.dwFieldWidth;
            pAMVPDataInfo->amvpDimInfo.rcValidRegion.bottom = pAMVPDataInfo->amvpDimInfo.dwFieldHeight;

            pAMVPDataInfo->dwPictAspectRatioX = 4;
            pAMVPDataInfo->dwPictAspectRatioY = 3;

            pSrb->ActualBytesTransferred = sizeof(KS_AMVPDATAINFO);
        }
        break;

    case KSPROPERTY_VPCONFIG_MAXPIXELRATE :
        ASSERT(nS >= sizeof(KSVPMAXPIXELRATE));

        {
            PKSVPMAXPIXELRATE pKSPixelRate;

            int decoderHeight = GetDecoderHeight();
            int decoderWidth = GetDecoderWidth();

            pKSPixelRate = (PKSVPMAXPIXELRATE) pSpd->PropertyInfo;

            pKSPixelRate->Size.dwWidth = decoderWidth;
            pKSPixelRate->Size.dwHeight = decoderHeight;
            if ( standard & ( KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_M ) )   // NTSC rectangle?
                pKSPixelRate->MaxPixelsPerSecond = decoderWidth * decoderHeight * NTSC_FRAME_RATE;
            else
                pKSPixelRate->MaxPixelsPerSecond = decoderWidth * decoderHeight * PAL_FRAME_RATE;
            pKSPixelRate->Reserved = 0;

            pSrb->ActualBytesTransferred = sizeof(KSVPMAXPIXELRATE);
        }
        break;

    case KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY :
        *(PBOOL)(pSpd->PropertyInfo) = TRUE;
        pSrb->ActualBytesTransferred = sizeof(BOOL);
        break;

    default:
        TRAP();
        pSrb->ActualBytesTransferred = 0;
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        break;
    }
}       

void Device::GetVideoPortVBIProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSpd = pSrb->CommandData.PropertyInfo;
    ULONG Id  = pSpd->Property->Id;              // index of the property
    ULONG nS  = pSpd->PropertyOutputSize;        // size of data supplied
    ULONG standard = GetVideoDecoderStandard();

    switch (Id)
    {
    case KSPROPERTY_VPCONFIG_NUMCONNECTINFO :
        ASSERT(nS >= sizeof(ULONG));

        // 2 VideoPort connections are possible
        *(PULONG)(pSpd->PropertyInfo) = BT829_VPCONNECTIONS_NUMBER;

        pSrb->ActualBytesTransferred = sizeof(ULONG);
        break;

    case KSPROPERTY_VPCONFIG_GETCONNECTINFO :

        ASSERT(nS >= sizeof(DDVIDEOPORTCONNECT));

        {
            PKSMULTIPLE_DATA_PROP MultiProperty = (PKSMULTIPLE_DATA_PROP)pSpd->Property;

            if (MultiProperty->MultipleItem.Count == BT829_VPCONNECTIONS_NUMBER &&
                MultiProperty->MultipleItem.Size == sizeof(DDVIDEOPORTCONNECT)) {
                
                if (nS >= BT829_VPCONNECTIONS_NUMBER * sizeof(DDVIDEOPORTCONNECT)) {

                    LPDDVIDEOPORTCONNECT pConnectInfo;

                    pConnectInfo = (LPDDVIDEOPORTCONNECT) pSpd->PropertyInfo;

                    // fill in the DDVIDEOPORTCONNECT structure offset 0
                    pConnectInfo->dwSize = sizeof(DDVIDEOPORTCONNECT);
                    pConnectInfo->dwPortWidth = 8;
                    pConnectInfo->guidTypeID = DDVPTYPE_BROOKTREE;
                    pConnectInfo->dwFlags = DDVPCONNECT_INVERTPOLARITY;
                    pConnectInfo->dwReserved1 = 0;

#ifdef BT829_SUPPORT_16BIT
                    // fill in the DDVIDEOPORTCONNECT structure offset 1
                    pConnectInfo ++;
                    pConnectInfo->dwSize = sizeof(DDVIDEOPORTCONNECT);
                    pConnectInfo->guidTypeID = DDVPTYPE_BROOKTREE;
                    pConnectInfo->dwPortWidth = 16;
                    pConnectInfo->dwFlags = DDVPCONNECT_INVERTPOLARITY;
                    pConnectInfo->dwReserved1 = 0;
#endif
                    pSrb->ActualBytesTransferred = BT829_VPCONNECTIONS_NUMBER * sizeof(DDVIDEOPORTCONNECT);
                }
                else {
                    pSrb->Status = STATUS_INVALID_BUFFER_SIZE;
                }
            }
            else {
                pSrb->Status = STATUS_INVALID_PARAMETER;
            }
        }
        break;

    case KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT :
        ASSERT(nS >= sizeof(ULONG));

        *(PULONG)(pSpd->PropertyInfo) = BT829_PIXELFORMATS_NUMBER;

        pSrb->ActualBytesTransferred = sizeof(ULONG);
        break;

    case KSPROPERTY_VPCONFIG_GETVIDEOFORMAT :

        ASSERT(nS >= sizeof(DDPIXELFORMAT));

        {
            PKSMULTIPLE_DATA_PROP MultiProperty = (PKSMULTIPLE_DATA_PROP)pSpd->Property;

            if (MultiProperty->MultipleItem.Count == BT829_PIXELFORMATS_NUMBER &&
                MultiProperty->MultipleItem.Size == sizeof(DDPIXELFORMAT)) {
                
                if (nS >= BT829_PIXELFORMATS_NUMBER * sizeof(DDPIXELFORMAT)) {

                    ASSERT(BT829_PIXELFORMATS_NUMBER == 1); // as currently implemented, this must be true

                    LPDDPIXELFORMAT pPixelFormat;

                    pPixelFormat = (LPDDPIXELFORMAT) pSpd->PropertyInfo;

                    RtlZeroMemory(pPixelFormat, BT829_PIXELFORMATS_NUMBER * sizeof(DDPIXELFORMAT));

                    // fill in the DDPIXELFORMAT structure
                    pPixelFormat->dwSize = sizeof(DDPIXELFORMAT);
                    pPixelFormat->dwFlags = DDPF_FOURCC;
                    pPixelFormat->dwFourCC = FOURCC_VBID;
                    pPixelFormat->dwYUVBitCount = 8;

                    pSrb->ActualBytesTransferred = BT829_PIXELFORMATS_NUMBER * sizeof(DDPIXELFORMAT);
                }
                else {
                    pSrb->Status = STATUS_INVALID_BUFFER_SIZE;
                }
            }
            else {
                pSrb->Status = STATUS_INVALID_PARAMETER;
            }
        }
        break;

    case KSPROPERTY_VPCONFIG_VPDATAINFO :

        ASSERT(nS >= sizeof(KS_AMVPDATAINFO));

        {
            // Clear the portion of the buffer we plan to return
            RtlZeroMemory(pSpd->PropertyInfo, sizeof(KS_AMVPDATAINFO));

            PKS_AMVPDATAINFO pAMVPDataInfo;

            pAMVPDataInfo = (PKS_AMVPDATAINFO) pSpd->PropertyInfo;

            int decoderLostLines = (GetPartRev() >= 4) ?
                BT829A_LOST_LINES : BT829_LOST_LINES;

            // the values are sortof hardcoded for NTSC at this point
            // VBI values will need to be tweaked
            pAMVPDataInfo->dwSize = sizeof(KS_AMVPDATAINFO);

            if ( standard & ( KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_M ) )   // NTSC rectangle?
                pAMVPDataInfo->dwMicrosecondsPerField = 16667;
            else
                pAMVPDataInfo->dwMicrosecondsPerField = 20000;

            pAMVPDataInfo->bEnableDoubleClock = FALSE;
            pAMVPDataInfo->bEnableVACT = FALSE;

            pAMVPDataInfo->lHalfLinesOdd = 0;
            pAMVPDataInfo->lHalfLinesEven = 1;

            pAMVPDataInfo->bFieldPolarityInverted = FALSE;
            pAMVPDataInfo->bDataIsInterlaced = TRUE;
            pAMVPDataInfo->dwNumLinesInVREF = 6 - decoderLostLines;

            pAMVPDataInfo->amvpDimInfo.dwFieldWidth = GetDecoderWidth();
            
            // Beware of hard-coded numbers
            pAMVPDataInfo->amvpDimInfo.dwVBIWidth = VBISamples;

            if ( standard & ( KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_M ) )   // NTSC rectangle?
            {
                pAMVPDataInfo->amvpDimInfo.dwVBIHeight = NTSCVBIEnd - decoderLostLines;
                pAMVPDataInfo->amvpDimInfo.dwFieldHeight =
                    GetDecoderHeight() +
                    pAMVPDataInfo->amvpDimInfo.dwVBIHeight;
                /*
                    (NTSCVBIEnd - 1) -  // the '- 1' makes VBIEnd zero-based
                    decoderLostLines -
                    pAMVPDataInfo->dwNumLinesInVREF;
                */
            
                pAMVPDataInfo->amvpDimInfo.rcValidRegion.top = NTSCVBIStart - 1 - decoderLostLines;
            }
            else
            {
                pAMVPDataInfo->amvpDimInfo.dwVBIHeight = PALVBIEnd - decoderLostLines;
                pAMVPDataInfo->amvpDimInfo.dwFieldHeight =
                    GetDecoderHeight() +
                    pAMVPDataInfo->amvpDimInfo.dwVBIHeight;
                /*
                    (PALVBIEnd - 1) -  // the '- 1' makes VBIEnd zero-based
                    decoderLostLines -
                    pAMVPDataInfo->dwNumLinesInVREF;
                */
            
                pAMVPDataInfo->amvpDimInfo.rcValidRegion.top = PALVBIStart - 1 - decoderLostLines;
            }

            pAMVPDataInfo->amvpDimInfo.rcValidRegion.left = 0;
            pAMVPDataInfo->amvpDimInfo.rcValidRegion.right = pAMVPDataInfo->amvpDimInfo.dwVBIWidth;
            pAMVPDataInfo->amvpDimInfo.rcValidRegion.bottom = pAMVPDataInfo->amvpDimInfo.dwVBIHeight;

            pSrb->ActualBytesTransferred = sizeof(KS_AMVPDATAINFO);
        }
        break;

    case KSPROPERTY_VPCONFIG_MAXPIXELRATE :
        ASSERT(nS >= sizeof(KSVPMAXPIXELRATE));

        {
            PKSVPMAXPIXELRATE pKSPixelRate;

            int decoderHeight = GetDecoderHeight();
            int decoderWidth = GetDecoderWidth();

            pKSPixelRate = (PKSVPMAXPIXELRATE) pSpd->PropertyInfo;

            pKSPixelRate->Size.dwWidth = decoderWidth;
            pKSPixelRate->Size.dwHeight = decoderHeight;
            if ( standard & ( KS_AnalogVideo_NTSC_Mask | KS_AnalogVideo_PAL_M ) )   // NTSC rectangle?
                pKSPixelRate->MaxPixelsPerSecond = decoderWidth * decoderHeight * NTSC_FRAME_RATE;
            else
                pKSPixelRate->MaxPixelsPerSecond = decoderWidth * decoderHeight * PAL_FRAME_RATE;
            pKSPixelRate->Reserved = 0;

            pSrb->ActualBytesTransferred = sizeof(KSVPMAXPIXELRATE);
        }
        break;

    case KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY :
        *(PBOOL)(pSpd->PropertyInfo) = FALSE;
        pSrb->ActualBytesTransferred = sizeof(BOOL);
        break;

    default:
        TRAP();
        pSrb->ActualBytesTransferred = 0;
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        break;
    }
}       



void Device::ConfigVPSurfaceParams(PKSVPSURFACEPARAMS pSurfaceParams)
{
    DBGINFO(("VP Surface Params:\n"));
    DBGINFO(("dwPitch    = %d\n",pSurfaceParams->dwPitch));
    DBGINFO(("dwXOrigin  = %d\n",pSurfaceParams->dwXOrigin));
    DBGINFO(("dwYOrigin  = %d\n",pSurfaceParams->dwYOrigin));

    VideoSurfaceOriginX = pSurfaceParams->dwXOrigin;
    VideoSurfaceOriginY = pSurfaceParams->dwYOrigin;
    VideoSurfacePitch = pSurfaceParams->dwPitch;
}



void Device::ConfigVPVBISurfaceParams(PKSVPSURFACEPARAMS pSurfaceParams)
{
    DBGINFO(("VP VBI Surface Params:\n"));
    DBGINFO(("dwPitch    = %d\n",pSurfaceParams->dwPitch));
    DBGINFO(("dwXOrigin  = %d\n",pSurfaceParams->dwXOrigin));
    DBGINFO(("dwYOrigin  = %d\n",pSurfaceParams->dwYOrigin));

    VBISurfaceOriginX = pSurfaceParams->dwXOrigin;
    VBISurfaceOriginY = pSurfaceParams->dwYOrigin;
    VBISurfacePitch = pSurfaceParams->dwPitch;
}


// -------------------------------------------------------------------
// VideoProcAmp functions
// -------------------------------------------------------------------

NTSTATUS Device::SetProcAmpProperty(ULONG Id, LONG Value)
{
    switch (Id) {
        case KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:

            decoder->SetBrightness(Value);
            break;
        
        case KSPROPERTY_VIDEOPROCAMP_CONTRAST:

            decoder->SetContrast(Value);
            break;

        case KSPROPERTY_VIDEOPROCAMP_HUE:

            decoder->SetHue(Value);
            break;

        case KSPROPERTY_VIDEOPROCAMP_SATURATION:

            decoder->SetSaturation(Value);
            break;

        default:
            TRAP();
            return STATUS_NOT_IMPLEMENTED;
            break;
    }

    return STATUS_SUCCESS;
}

NTSTATUS Device::GetProcAmpProperty(ULONG Id, PLONG pValue)
{
    switch (Id) {

        case KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:
            *pValue = decoder->GetBrightness();
            break;
        
        case KSPROPERTY_VIDEOPROCAMP_CONTRAST:
            *pValue = decoder->GetContrast();
            break;

        case KSPROPERTY_VIDEOPROCAMP_HUE:
            *pValue = decoder->GetHue();
            break;

        case KSPROPERTY_VIDEOPROCAMP_SATURATION:
            *pValue = decoder->GetSaturation();
            break;

        default:
            TRAP();
            return STATUS_NOT_IMPLEMENTED;
            break;
        }

    return STATUS_SUCCESS;
}

BOOL Device::SetVideoDecoderStandard(DWORD standard)    //Paul:  Changed
{
    if ( decoder->SetVideoDecoderStandard(standard) )
    {
        switch (standard)
        {
        case KS_AnalogVideo_NTSC_M:
            scaler->VideoFormatChanged( VFormat_NTSC );
            break;
        case KS_AnalogVideo_NTSC_M_J:
            scaler->VideoFormatChanged( VFormat_NTSC_J );
            break;
        case KS_AnalogVideo_PAL_B:
        case KS_AnalogVideo_PAL_D:
        case KS_AnalogVideo_PAL_G:
        case KS_AnalogVideo_PAL_H:
        case KS_AnalogVideo_PAL_I:
            scaler->VideoFormatChanged( VFormat_PAL_BDGHI );    // PAL_BDGHI covers most areas 
            break;
        case KS_AnalogVideo_PAL_M:
            scaler->VideoFormatChanged( VFormat_PAL_M ); 
            break;
        case KS_AnalogVideo_PAL_N:
            scaler->VideoFormatChanged( VFormat_PAL_N_COMB ); 
            break;
        default:    //Paul:  SECAM
            scaler->VideoFormatChanged( VFormat_SECAM );
        }
        //SetRect(destRect);
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\device.h ===
#pragma once

//==========================================================================;
//
//  Device - Declaration of the Bt829 CVideoDecoderDevice
//
//      $Date:   28 Aug 1998 14:44:36  $
//  $Revision:   1.2  $
//    $Author:   Tashjian  $
//
// $Copyright:  (c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "decoder.h"
#include "scaler.h"
#include "xbar.h"
#include "capmain.h"
#include "capdebug.h"
#include "wdmvdec.h"
#include "decdev.h"

class Device: public CVideoDecoderDevice
{
private:
    NTSTATUS GetRegistryValue(HANDLE, PWCHAR, ULONG, PWCHAR, ULONG);
    VOID UseRegistryValues(PPORT_CONFIGURATION_INFORMATION);
    BOOL stringsEqual(PWCHAR, PWCHAR);

    PDEVICE_PARMS   m_pDeviceParms;

    int hue;
    int saturation;
    int contrast;
    int brightness;
    int NTSCDecoderWidth;
    int NTSCDecoderHeight;
    int PALDecoderWidth;
    int PALDecoderHeight;
    int defaultDecoderWidth;
    int defaultDecoderHeight;
    int VBIEN;
    int VBIFMT;
    BOOL isCodeInDataStream;
    BOOL is16;
    MRect destRect;
    Connector source;

    int VBISurfaceOriginX;
    int VBISurfaceOriginY;
    int VBISurfacePitch;
    int VideoSurfaceOriginX;
    int VideoSurfaceOriginY;
    int VideoSurfacePitch;
    
    Decoder *decoder;
    Scaler *scaler;
    CrossBar *xbar;


public:
    Device(PPORT_CONFIGURATION_INFORMATION, 
        PDEVICE_PARMS, 
        PUINT puiError);

    void * operator new(size_t size, void * pAllocation) { return(pAllocation);}
    void operator delete(void * pAllocation) {}

    void SaveState();
    void RestoreState(DWORD dwStreamsOpen = -1);
    void SetRect(MRect &);
    int GetDecoderWidth();
    int GetDecoderHeight();
    int GetDefaultDecoderWidth();
    int GetDefaultDecoderHeight();
    int GetPartID();
    int GetPartRev();

    //
    // --------------- decoder functions
    //

    void SoftwareReset() 
        {decoder->SoftwareReset();}

    void SetOutputEnabled(BOOL b)
        {
            decoder->SetOutputEnabled( b);
        }
    
    BOOL IsOutputEnabled()
        {return decoder->IsOutputEnabled();}


    void GetVideoDecoderCaps(PKSPROPERTY_VIDEODECODER_CAPS_S caps)
        {decoder->GetVideoDecoderCaps(caps);}
    void GetVideoDecoderStatus(PKSPROPERTY_VIDEODECODER_STATUS_S status)
        {decoder->GetVideoDecoderStatus(status);}
    DWORD GetVideoDecoderStandard()
        {return decoder->GetVideoDecoderStandard();}

    BOOL SetVideoDecoderStandard(DWORD standard);
   
    
    void SetHighOdd(BOOL b)
        {decoder->SetHighOdd(b);}

    BOOL IsHighOdd()
        {return decoder->IsHighOdd();}

    ErrorCode SetVideoInput(Connector i)
        {source = i; return decoder->SetVideoInput(i);}

    Connector GetVideoInput()
        {return decoder->GetVideoInput();}


    NTSTATUS GetProcAmpProperty(ULONG, PLONG);
    NTSTATUS SetProcAmpProperty(ULONG, LONG);

    
    void Set16BitDataStream(BOOL b)
        {decoder->Set16BitDataStream(b);}
    
    BOOL Is16BitDataStream()
        {return decoder->Is16BitDataStream();}

    void SetCodeInsertionEnabled(BOOL b)
        {decoder->SetCodeInsertionEnabled(b);}
    
    BOOL IsCodeInsertionEnabled()
        {return decoder->IsCodeInsertionEnabled();}

    void SetOutputEnablePolarity(int i)
        {decoder->SetOutputEnablePolarity(i);}
    
    int GetOutputEnablePolarity()
        {return decoder->GetOutputEnablePolarity();}

    //
    // --------------- scaler functions
    //
    void SetVBIEN(BOOL b)
        {scaler->SetVBIEN(b);}
    
    BOOL IsVBIEN()
        {return scaler->IsVBIEN();}

    void SetVBIFMT(BOOL b)
        {scaler->SetVBIFMT(b);}
    
    BOOL IsVBIFMT()
        {return scaler->IsVBIFMT();}

    //
    // --------------- xbar functions
    //
    BOOL GoodPins(ULONG InPin, ULONG OutPin)
        {return xbar->GoodPins(InPin, OutPin);}

    BOOL TestRoute(ULONG InPin, ULONG OutPin)
        {return xbar->TestRoute(InPin, OutPin);}

    void Route(ULONG OutPin, ULONG InPin)
        {xbar->Route(OutPin, InPin);}

    ULONG GetNoInputs()
        {return xbar->GetNoInputs();}

    ULONG GetNoOutputs()
        {return xbar->GetNoOutputs();}

    ULONG GetPinInfo(KSPIN_DATAFLOW dir, ULONG idx, ULONG &related)
        {return xbar->GetPinInfo(dir, idx, related);}

    ULONG GetRoute(ULONG OutPin)
        {return xbar->GetRoute(OutPin);}

    KSPIN_MEDIUM * GetPinMedium(KSPIN_DATAFLOW dir, ULONG idx)
        {return xbar->GetPinMedium(dir, idx);}

    void Reset();
    ~Device();


    void GetVideoPortProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
    void GetVideoPortVBIProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
    void ConfigVPSurfaceParams(PKSVPSURFACEPARAMS pSurfaceParams);
    void ConfigVPVBISurfaceParams(PKSVPSURFACEPARAMS pSurfaceParams);

    void GetVideoSurfaceOrigin(int* pX, int* pY)
        { *pX = VideoSurfaceOriginX; *pY = VideoSurfaceOriginY; }
    void GetVBISurfaceOrigin(int* pX, int* pY)
        { *pX = VBISurfaceOriginX; *pY = VBISurfaceOriginY; }
};  


typedef struct
{
    CWDMVideoDecoder        CWDMDecoder;
    Device                  CDevice;
    Decoder                 CDecoder;
    Scaler                  CScaler;
    CrossBar                CXbar;
    CI2CScript              CScript;
    DEVICE_PARMS            deviceParms;
} DEVICE_DATA_EXTENSION, * PDEVICE_DATA_EXTENSION;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\mytypes.h ===
#pragma once

//==========================================================================;
//
//	Various declarations
//
//		$Date:   05 Aug 1998 11:31:58  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#ifdef __cplusplus
extern "C" {

#ifndef _STREAM_H
#include "strmini.h"
#endif
#ifndef _KSMEDIA_
#include "ksmedia.h"
#endif
}
#endif


#ifndef __RETCODE_H
#include "retcode.h"
#endif

#include "capdebug.h"

inline void * _cdecl operator new(size_t size)
{
    PVOID p = ExAllocatePool(NonPagedPool, size);
    DBGINFO(("Bt829: Global operator new: %d bytes; address: %x\n", size, p));
#ifdef DBG
    if (!p) {
        TRAP();
    }
#endif      
    return p;
}

inline void _cdecl operator delete(void *p)
{
    DBGINFO(("Bt829: Global operator delete: address: %x\n", p));
    if (p)
    {
        ExFreePool(p);
    }
}


class MSize;
class MRect;

#if NEED_CLIPPING
typedef struct _RGNDATAHEADER
{
    DWORD   dwSize;
    DWORD   iType;
    DWORD   nCount;
    DWORD   nRgnSize;
    MRect    rcBound;
} RGNDATAHEADER, *PRGNDATAHEADER;

typedef struct _RGNDATA
{
    RGNDATAHEADER   rdh;
    char            Buffer[1];
} RGNDATA, *PRGNDATA;

#endif

class  MPoint : public tagPOINT
{
public:
    // Constructors
};

//
// class MSize
// ----- -----
//
class  MSize : public tagSIZE
{
public:
    // Constructors
    MSize()
    {}
    MSize(int dx, int dy)
    {cx = dx; cy = dy;}
};


class  MRect : public tagRECT
{
public:
    // Constructors
    MRect()
    {}
    MRect(int _left, int _top, int _right, int _bottom);
    MRect(const MPoint& origin, const MSize& extent);

    void        Set(int _left, int _top, int _right, int _bottom);

    // Information/access functions(const and non-const)
    const MPoint& TopLeft() const
    {return *(MPoint*)&left;}
    int          Width() const
    {return right-left;}
    int          Height() const
    {return bottom-top;}
    MSize        Size() const
    {return MSize(Width(), Height());}

};

//----------------------------------------------------------------------------
// Inlines
//----------------------------------------------------------------------------
inline void MRect::Set(int _left, int _top, int _right, int _bottom)
{
    left = _left;
    top = _top;
    right = _right;
    bottom = _bottom;
}

inline MRect::MRect(int _left, int _top, int _right, int _bottom)
{
    Set(_left, _top, _right, _bottom);
}
inline MRect::MRect(const MPoint& origin, const MSize& extent)
{
    Set(origin.x, origin.y, origin.x+extent.cx, origin.y+extent.cy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\retcode.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __RETCODE_H
#define __RETCODE_H

/* Type: ErrorCode
 * Purpose: Defines the error codes
 */
typedef enum { Success, Fail } ErrorCode;
#define ERROR_CODE_DEFINED



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\regbase.h ===
#pragma once

//==========================================================================;
//
//	Declaration of the Bt829 Register manipulation classes
//
//		$Date:   05 Aug 1998 11:31:48  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "mytypes.h"

/* Type: AllFs
 * Purpose: To be used as an error return value from register accessing
 *   functions. All bits are set to 1.
 */
const DWORD AllFs = ~0L;

/* Function: ReturnAllFs
 * Purpose: This function is used in the register access methods to indicate
 *   that some sort of error has occured. Used for easing the debugging, as
 *   it contains a macro to print the error if DEBUG is #defined
 */
inline DWORD ReturnAllFs()
{
//    OUTPUT_MESS(ALLFS);
    return  AllFs;
}

/*
 * Type: RegisterType
 * Purpose: A type to differentiate between diferent kinds of registers.
 *   Depending on the type register may not peforms certain operations
 *   RW - read/write, RO - read-only, WO - write-only
*/
typedef enum { RW, RO, WO, RR } RegisterType;

/* Class: RegBase
 * Purpose:
 *   Defines the interface and encapsulates the register access.
 * Attributes:
 *   pBaseAddress_: DWORD, static. Holds the base address of the registers. On the
 *   PCI bus it is a 32 bit memory address. On the ISA bus it is a 16 bit I/O address.
 *   type_: RegisterType - defines the access permission for the register.
 *   dwShadow_: DWORD - a local copy of the register. Used for returning a value
 *   of write-only registers
 * Operations:
 *   operator DWORD(): data access method. Pure virtual
 *   DWORD operator=(DWORD): assignment operator. Pure virtual. This assignment
 *      operator does not return a reference to the class because of the performance reasons
 *   void SetBaseAddress(DWORD)
 *   DWORD GetBaseAddress()
 *   RegisterType GetRegisterType()
 *   void SetShadow(DWORD): assigns a value of a register to a shadow
 *   DWORD GetShadow(): retrieves a value from a shadow
 */
class RegBase
{
    private:
         static DWORD dwBaseAddress_;
         RegisterType type_;
         DWORD        dwShadow_;

         RegBase();

    protected:
         void  SetShadow(DWORD dwValue);
         DWORD GetShadow();
    public:
         RegBase(RegisterType aType) :
            type_(aType), dwShadow_(0)
         {}

         RegBase(RegBase& aReg) :
            type_(aReg.GetRegisterType()), dwShadow_(0)
         {}

         static void SetBaseAddress(DWORD dwBase) { dwBaseAddress_ = dwBase; }
         static LPBYTE GetBaseAddress() { return (LPBYTE)(ULONG_PTR)dwBaseAddress_; }
         RegisterType GetRegisterType() { return type_; }
         virtual operator DWORD() = 0;
         virtual DWORD operator=(DWORD dwValue) = 0;
         virtual ~RegBase() {}
};

/* Method: RegBase::SetShadow
 * Purpose: Used to store the value of a register in the shadow
 * Input: dwValue: DWORD - new value of a register
 * Output: None
 * Note: inline
 */
inline void  RegBase::SetShadow(DWORD dwValue) { dwShadow_ = dwValue; }

/* Method: RegBase::GetShadow
 * Purpose: Used to obtain the last value written to a write-only register
 *    from the shadow
 * Input: None
 * Output: DWORD
 * Note: inline
 */
inline DWORD RegBase::GetShadow() { return dwShadow_; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\register.cpp ===
//==========================================================================;
//
//	Implementation of the Bt829 Register manipulation classes
//
//		$Date:   21 Aug 1998 21:46:42  $
//	$Revision:   1.1  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "register.h"
#include "i2script.h"
#include "capdebug.h"


/* Method: Register::operator DWORD()
 * Purpose: a dummy function. Always returns -1
*/
Register::operator DWORD()
{
   return ReturnAllFs();
}


/* Method: Register::operator=
 * Purpose: a dummy function. Does not perform an assignment. Always returns -1
*/
DWORD Register::operator=(DWORD)
{
   return ReturnAllFs();
}

/* Method: RegisterB::operator DWORD()
 * Purpose: Performs the read from a byte register
*/
RegisterB::operator DWORD()
{
   // if write-only return the shadow
   if (GetRegisterType() == WO)
      return GetShadow();

   // for RO and RW do the actual read
   LPBYTE pRegAddr = GetBaseAddress() + GetOffset();
   // Not really an address; just a number indicating which reg
   return ReadReg((BYTE)pRegAddr);
}


/* Method: RegisterB::operator=
 * Purpose: performs the assignment to a byte register
*/
DWORD RegisterB::operator=(DWORD dwValue)
{
// if a register is read-only nothing is done. This is an error
   if (GetRegisterType() == RO)
      return ReturnAllFs();

   // keep a shadow around
   SetShadow(dwValue);

   LPBYTE pRegAddr = GetBaseAddress() + GetOffset();

   // Not really an address; just a number indicating which reg
   WriteReg((BYTE) pRegAddr, (BYTE)dwValue);

   return dwValue;
}

DWORD RegisterB::ReadReg(BYTE reg)
{
    I2CPacket   i2cPacket;
    BYTE outBuf = reg;
    BYTE inBuf = I2C_STATUS_NOERROR;

    CI2CScript *pI2cScript = m_pDeviceParms->pI2cScript;

    i2cPacket.uchChipAddress = (UCHAR)(m_pDeviceParms->chipAddr);
    i2cPacket.cbReadCount = sizeof(inBuf);
    i2cPacket.cbWriteCount = sizeof(outBuf);
    i2cPacket.puchReadBuffer = &inBuf;
    i2cPacket.puchWriteBuffer = &outBuf;
    i2cPacket.usFlags = I2COPERATION_READ;
    i2cPacket.uchORValue = 0;
    i2cPacket.uchANDValue = 0;

    if (!pI2cScript->LockI2CProviderEx())
    {
        DBGERROR(("Couldn't get I2CProvider.\n"));
        TRAP();
        return ReturnAllFs();
    }
    
    // Now  I know I have I2c services.

    pI2cScript->ExecuteI2CPacket(&i2cPacket);

    pI2cScript->ReleaseI2CProvider();
    if (i2cPacket.uchI2CResult == I2C_STATUS_NOERROR)
    {
        return (DWORD) inBuf;
    }
    else
    {
        TRAP();

        return ReturnAllFs();
    }
}

DWORD RegisterB::WriteReg(BYTE reg, BYTE value)
{
    I2CPacket   i2cPacket;
    BYTE outBuf[2];

    CI2CScript *pI2cScript = m_pDeviceParms->pI2cScript;

    outBuf[0] = reg;
    outBuf[1] = value;
    i2cPacket.uchChipAddress = (UCHAR)(m_pDeviceParms->chipAddr);
    i2cPacket.cbReadCount = 0;
    i2cPacket.cbWriteCount = sizeof(outBuf);
    i2cPacket.puchReadBuffer = NULL;
    i2cPacket.puchWriteBuffer = &outBuf[0];
    i2cPacket.usFlags = I2COPERATION_WRITE;
    i2cPacket.uchORValue = 0;
    i2cPacket.uchANDValue = 0;

    if (!pI2cScript->LockI2CProviderEx())
    {
        DBGERROR(("Bt829: Couldn't get I2CProvider.\n"));
        TRAP();
        return ReturnAllFs();
    }
    // Now  I know I have I2c services.

    pI2cScript->ExecuteI2CPacket(&i2cPacket);

    pI2cScript->ReleaseI2CProvider();

    if (i2cPacket.uchI2CResult == I2C_STATUS_NOERROR)
    {
        return value;
    }
    else
    {
        TRAP();

        return ReturnAllFs();
    }
}


/* Method: RegField::MakeAMask
 * Purpose: Computes a mask used to isolate a field withing a register based
 *   on the width of a field
 */
inline DWORD RegField::MakeAMask()
{
//   compute the mask to apply to the owner register to reset
//   all bits that are part of a field. Mask is based on the size of a field
   return ::MakeAMask(FieldWidth_);
}

/* Method: RegField::operator DWORD()
 * Purpose: Performs the read from a field of register
*/
RegField::operator DWORD()
{
   // if write-only, get the shadow
   if (GetRegisterType() == WO)
      return GetShadow();

   // for RO and RW do the actual read
   // get the register data and move it to the right position
   DWORD dwValue = (Owner_ >> StartBit_);

   DWORD dwMask = MakeAMask();

   return dwValue & dwMask;
}


/* Method: RegField::operator=
 * Purpose: performs the assignment to a field of register
 * Note:
   This function computes the mask to apply to the owner register to reset
   all bits that are part of a field. Mask is based on the start position and size
   Then it calculates the proper value from the passed argument (moves the size
   number of bits to the starting position) and ORs these bits in the owner register.
*/
DWORD RegField::operator=(DWORD dwValue)
{
// if a register is read-only nothing is done. This is an error
   if (GetRegisterType() == RO)
      return ReturnAllFs();

   SetShadow(dwValue);

   // get a mask
   DWORD dwMask = MakeAMask();

   // move mask to a proper position
   dwMask = dwMask << StartBit_;

//   calculate the proper value from the passed argument (move the size
//   number of bits to the starting position)
   DWORD dwFieldValue = dwValue << StartBit_;
   dwFieldValue &= dwMask;

   // do not perform intermediate steps on the owner; rather use a temp and update
   // the owner at once
   DWORD dwRegContent = Owner_;

   // reset the relevant bits
   if (GetRegisterType() == RR)
      dwRegContent = 0;
   else
      dwRegContent &= ~dwMask;

   // OR these bits in the owner register.
   dwRegContent |= dwFieldValue;

   Owner_ = dwRegContent;
   return dwValue;
}


/* Method: CompositeReg::operator DWORD()
 * Purpose: Performs the read from a composite register
*/
CompositeReg::operator DWORD()
{
   // if write-only return the shadow
   if (GetRegisterType() == WO)
      return GetShadow();

// obtain the low and high values
   DWORD dwLowBits  = (DWORD)LSBPart_;
   DWORD dwHighBits = (DWORD)MSBPart_;

   // put high part to the proper place
   dwHighBits <<= LowPartWidth_;

   // done !
   return dwHighBits | dwLowBits;
}


/* Method: CompositeReg::operator=
 * Purpose: performs the assignment to a composite register
*/
DWORD CompositeReg::operator=(DWORD dwValue)
{
// if a register is read-only nothing is done. This is an error
   if (GetRegisterType() == RO)
      return ReturnAllFs();

   // keep a shadow around
   SetShadow(dwValue);
 // compute the mask to apply to the passed value, so it can be...
   DWORD dwMask = ::MakeAMask(LowPartWidth_);

 // ... assigned to the low portion register
   LSBPart_ = dwValue & dwMask;

   // shift is enough to get the high part
   MSBPart_ = (dwValue >> LowPartWidth_);
   return dwValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\register.h ===
#pragma once

//==========================================================================;
//
//	Declarations of the Bt829 Register manipulation classes
//
//		$Date:   21 Aug 1998 21:46:42  $
//	$Revision:   1.1  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#include "regbase.h"
#include "capmain.h"

/* Type: Register
 * Purpose: An intermediate class between the RegBase and actual usable classes.
 *   Actual classes are RegisterB, RegisterW, RegisterDW
 * Attributes:
 *   uOffset_: unsigned int - an offset of the register from the base
 * Operations:
 *   GetOffset(): returns the offset value. Protected
 *   operator DWORD(): data access method. Always returns -1
 *   DWORD operator=(DWORD): assignment operator. Always returns -1
 * Note:
 *   The reason to have operators in this class is for the register field class
 *   to have a member of type 'reference to Register'. Otherwise RegField is not
 *   able to use access methods.
 */
class Register : public RegBase
{
   private:
      unsigned int uOffset_;
      Register();
    protected:

    public:
         unsigned int GetOffset() { return uOffset_; }

         virtual operator DWORD();
      virtual DWORD operator=(DWORD dwValue);

         Register(unsigned int uOff, RegisterType aType) :
            RegBase(aType), uOffset_(uOff) {}
};

/* Type: RegisterB
 * Purpose: A register that performs the BYTE I/O
 * Note:
 *   This class has no additional data members, it just overloads operators
 */
class RegisterB : public Register
{
    private:
         RegisterB();
         DWORD ReadReg(BYTE);
         DWORD WriteReg(BYTE, BYTE);
         PDEVICE_PARMS m_pDeviceParms;
    public:
         virtual operator DWORD();
         virtual DWORD operator=(DWORD dwValue);
         RegisterB(unsigned int uOff, RegisterType aType, PDEVICE_PARMS pDeviceParms) :
            Register(uOff, aType) {m_pDeviceParms = pDeviceParms;};
};


// maximum size of a register in bits
const BYTE MaxWidth = 32;

/* Class: RegField
 * Purpose: This class encapsulates the behaviour of a register which is a set
 *   of bits withing a larger register
 * Attributes:
 *   Owner_: Register & - reference to the register that contains this field.
 *   It is a reference to Register class because actual register can be either one of
 *   byte, word or dword registers.
 *   StartBit_: BYTE - starting position of this field
 *   FieldWidth_: BYTE - width of this field in bits
 * Operations:
 *   operator DWORD(): data access method. Returns a value of the register
 *   DWORD operator=(DWORD): assignment operator. Used to set the register
 *   These operations assume that a parent register has RW attribute set, though
 *   not all register fields of it are read-write. If RW is not used for the parent
 *   this class may be in error.
 * Note: the error handling provided by the class is minimal. It is a responibility
 *   of the user to pass correct parameters to the constructor. The class has
 *   no way of knowing if the correct owning registe passed in is correct,
 *   for example. If starting bit or width is beyond the maximum field width
 *   the mask used to isolate the field will be 0xFFFFFFFF
 */
class RegField : public RegBase
{
   private:
      Register &Owner_;
      BYTE      StartBit_;
      BYTE      FieldWidth_;
      DWORD     MakeAMask();
      RegField();
   public:
      virtual operator DWORD();
      virtual DWORD operator=(DWORD dwValue);
      RegField(Register &AnOwner, BYTE nStart, BYTE nWidth, RegisterType aType) :
         RegBase(aType), Owner_(AnOwner), StartBit_(nStart),
         FieldWidth_(nWidth) {}
      RegField(Register &AnOwner, BYTE nStart, BYTE nWidth) :
         RegBase(AnOwner), Owner_(AnOwner), StartBit_(nStart),
         FieldWidth_(nWidth) {}
};

/* Function: MakeAMask
 * Purpose: Creates a bit mask to be used in different register classes
 * Input:
 *   bWidth: BYTE - width of a mask in bits
 * Output:
 *   DWORD
 * Note: This function is inline
 */
inline DWORD MakeAMask(BYTE bWidth)
{
   return (bWidth >= 32 ? 0 : (DWORD)1 << bWidth) - 1;
}


/* Class: CompositeReg
 * Purpose: This class encapsulates the registers that have their bits in two
 *          different places (registers)
 * Attributes:
 *   LSBPart_:  Register & - least significant bits part of a composite register
 *   HighPart_: RegField & - most significant bits part of a composite register
 *   LowPartWidth_: BYTE - width of the low portion in bits
 * Operations:
 *   operator DWORD(): data access method. Returns a value of the register
 *   DWORD operator=(DWORD): assignment operator. Used to set the register
 * Note: the error handling provided by the class is minimal. It is a responibility
 *   of the user to pass correct parameters to the constructor. The class has
 *   no way of knowing if the correct low and high registers passed in are correct,
 *   for example. If low part size in bits passed in is not less then MaxWidth (32)
 *   the mask used to isolate the low portion will be 0xFFFFFFFF
 */
class CompositeReg : public RegBase
{
   private:
      Register &LSBPart_;
      RegField &MSBPart_;
      BYTE      LowPartWidth_;
      CompositeReg();
   public:
      virtual operator DWORD();
      virtual DWORD operator=(DWORD dwValue);
      CompositeReg(Register &LowReg, BYTE LowWidth, RegField &HighReg, RegisterType aType) :
         RegBase(aType), LSBPart_(LowReg), MSBPart_(HighReg),
         LowPartWidth_(LowWidth) {}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\defaults.h ===
//==========================================================================;
//
//	Default values
//
//		$Date:   18 Mar 1999 14:30:18  $
//	$Revision:   1.1  $
//	  $Author:   KLEBANOV  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

const int NumBuffers = 8;

// Hardcoded for NTSC for now
const int SamplingFrequency = 28636363;
const int NTSCFrameDuration = 333667;
const int NTSCFieldDuration = NTSCFrameDuration/2;

const int NTSCFrameRate = 30;

const int PALFrameDuration = 400000;
const int PALFieldDuration = PALFrameDuration/2;

const int PALFrameRate = 25;

const int DefWidth = 320;
const int DefHeight = 240;

const int QCIFWidth = 176;
const int QCIFHeight = 144;


const int NTSCMaxInWidth = 720;
const int NTSCMinInWidth = 80;

const int NTSCMaxInHeight = 480;
const int NTSCMinInHeight = 60;

const int NTSCMaxOutWidth = 720;	// 320
const int NTSCMinOutWidth = 80;

const int NTSCMaxOutHeight = 240;	// 240
const int NTSCMinOutHeight = 60;

const int PALMaxInWidth = 720;
const int PALMinInWidth = 80;//90;

const int PALMaxInHeight = 480;//576;
const int PALMinInHeight = 60;//72;

const int PALMaxOutWidth = 720;	// 320
const int PALMinOutWidth = 80;//90;

const int PALMaxOutHeight = 240;//288;	// 240
const int PALMinOutHeight = 30;//72;

const int VBISamples  = 800 * 2;

// hack
const int VREFDiscard = 8;

const int NTSCVBIStart    =  10; // inclusive
const int NTSCVBIEnd      =  21; // inclusive
const int NTSCVBILines    = (NTSCVBIEnd - NTSCVBIStart) + 1;

const int PALVBIStart    =  10; // Paultest
const int PALVBIEnd      =  25; // Paultest
const int PALVBILines    = (PALVBIEnd - PALVBIStart) + 1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\scaler.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include "Scaler.h"

#include "capdebug.h"

#include "capmain.h"

#include "defaults.h"

// video information for PAL
VideoInfoStruct NTSCVideoInfo =
{
   730,     // Clkx1_HACTIVE          = 746
   148,     // Clkx1_HDELAY           = 140
   44,      // Min_Pixels             =  44
   240,     // Active_lines_per_field = 240
   144,     // Min_UncroppedPixels    = Min_Pixels + 100
   724,     // Max_Pixels             = ((Clkx1_HACTIVE < 774) ? Clkx1_HACTIVE - 6 : 768)
   32,      // Min_Lines              = (Active_lines_per_field / 16 + 1) * 2
   240,     // Max_Lines              = Active_lines_per_field
   352,     // Max_VFilter1_Pixels    = ((Clkx1_HACTIVE > 796) ? 384 : (Clkx1_HACTIVE * 14 / 29))
   176,     // Max_VFilter2_Pixels    = Clkx1_HACTIVE * 8 / 33
   176,     // Max_VFilter3_Pixels    = Clkx1_HACTIVE * 8 / 33
   240,     // Max_VFilter1_Lines     = Active_lines_per_field
   120,     // Max_VFilter2_Lines     = Active_lines_per_field / 2
   96,      // Max_VFilter3_Lines     = Active_lines_per_field * 2 / 5
};

// video information for PAL
VideoInfoStruct PALVideoInfo = 
{
   914,     // Clkx1_HACTIVE          = 914
   190,     // Clkx1_HDELAY           = 190
   48,      // Min_Pixels             =  48
   284,     // Active_lines_per_field = 284
   148,     // Min_UncroppedPixels    = Min_Pixels + 100
   768,     // Max_Pixels             = ((Clkx1_HACTIVE < 774) ? Clkx1_HACTIVE - 6 : 768)
   36,      // Min_Lines              = (Active_lines_per_field / 16 + 1) * 2
   284,     // Max_Lines              = Active_lines_per_field
   384,     // Max_VFilter1_Pixels    = ((Clkx1_HACTIVE > 796) ? 384 : (Clkx1_HACTIVE * 14 / 29))
   221,     // Max_VFilter2_Pixels    = Clkx1_HACTIVE * 8 / 33
   221,     // Max_VFilter3_Pixels    = Clkx1_HACTIVE * 8 / 33
   284,     // Max_VFilter1_Lines     = Active_lines_per_field
   142,     // Max_VFilter2_Lines     = Active_lines_per_field / 2
   113,     // Max_VFilter3_Lines     = Active_lines_per_field * 2 / 5
};

//===========================================================================
// Bt848 Scaler Class Implementation
//===========================================================================

/////////////////////////////////////////////////////////////////////////////
// Constructor
/////////////////////////////////////////////////////////////////////////////
#define REGALIGNMENT 1

#define offset 0


Scaler::Scaler(PDEVICE_PARMS pDeviceParms):
	regCROP ((0x03 * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	fieldVACTIVE_MSB(regCROP, 4, 2, RW) ,
	fieldHDELAY_MSB(regCROP, 2, 2, RW) ,
	fieldHACTIVE_MSB(regCROP, 0, 2, RW) ,
	regVACTIVE_LO ((0x05 * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	regHDELAY_LO ((0x06 * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	regHACTIVE_LO ((0x07 * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	regHSCALE_HI ((0x08 * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	fieldHSCALE_MSB(regHSCALE_HI, 0, 8, RW) ,
	regHSCALE_LO ((0x09 * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	regSCLOOP ((0x10 * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	fieldHFILT(regSCLOOP, 3, 2, RW) ,
	regVSCALE_HI ((0x13 * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	fieldVSCALE_MSB(regVSCALE_HI, 0, 5, RW) ,
	regVSCALE_LO ((0x14 * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	regVActive(regVACTIVE_LO, 8, fieldVACTIVE_MSB, RW),
	regVScale(regVSCALE_LO, 8, fieldVSCALE_MSB, RW),
	regHDelay(regHDELAY_LO, 8, fieldHDELAY_MSB, RW),
	regHActive(regHACTIVE_LO, 8, fieldHACTIVE_MSB, RW),
	regHScale(regHSCALE_LO, 8, fieldHSCALE_MSB, RW),
	regVTC ((0x1B * REGALIGNMENT) + (offset), RW, pDeviceParms) ,
	fieldVBIEN  (regVTC, 4, 1, RW), 
	fieldVBIFMT (regVTC, 3, 1, RW), 
	fieldVFILT  (regVTC, 0, 2, RW),

   regReverse_CROP (0x03, RW, pDeviceParms),
   fieldVDELAY_MSB(regReverse_CROP, 6, 2, RW),
   regVDELAY_LO (0x04, RW, pDeviceParms),
   regVDelay(regVDELAY_LO, 8, fieldVDELAY_MSB, RW),
   m_videoFormat(VFormat_NTSC), VFilterFlag_(On),
   DigitalWin_(0,0,NTSCMaxOutWidth,NTSCMaxOutHeight)
{
   m_HActive = 0;
   m_pixels = 0;
   m_lines = 0;
   m_VFilter = 0;
}   


/////////////////////////////////////////////////////////////////////////////
// Destructor
/////////////////////////////////////////////////////////////////////////////
Scaler::~Scaler()
{
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::VideoFormatChanged(VideoFormat format)
// Purpose: Set which video format is using
// Input:   Video format -
//            Auto format:          VFormat_AutoDetect
//            NTSC (M):             VFormat_NTSC
//            PAL (B, D, G, H, I):  VFormat_PAL_BDGHI
//            PAL (M):              VFormat_PAL_M
//            PAL(N):               VFormat_PAL_N
//            SECAM:                VFormat_SECAM
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::VideoFormatChanged(VideoFormat format)
{
    m_videoFormat = format;
    Scale(DigitalWin_);
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::Scale(MRect & clientScr)
// Purpose: Perform scaling
// Input:   MRect & clientScr - rectangle to scale to
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::Scale(MRect & clientScr)
{
   switch (m_videoFormat)
   {
   case VFormat_NTSC:
   case VFormat_NTSC_J:
   case VFormat_PAL_M:
       m_ptrVideoIn = &NTSCVideoInfo;   //  set scaling constants for NTSC
       break;
   case VFormat_PAL_BDGHI:
   case VFormat_PAL_N:
   case VFormat_SECAM:
   case VFormat_PAL_N_COMB:
       m_ptrVideoIn = &PALVideoInfo;    // set scaling constants for PAL/SECAM
       if ( m_videoFormat == VFormat_PAL_N_COMB )
       {
           m_ptrVideoIn->Clkx1_HACTIVE = NTSCVideoInfo.Clkx1_HACTIVE;   // p. 26 of BT guide
           m_ptrVideoIn->Clkx1_HDELAY = NTSCVideoInfo.Clkx1_HDELAY;     // empirical
       }

       break;
   }


   // the order of functions calling here is important because some
   // calculations are based on previous results
   SetHActive(clientScr); 
   SetVActive();
   SetVScale(clientScr);
   SetVFilter();
   SetVDelay();
   SetHDelay();
   SetHScale();
   SetHFilter();

}

/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetHActive(MRect & clientScr)
// Purpose: Set HActive register
// Input:   MRect & clientScr - rectangle to scale to
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetHActive(MRect & clientScr)
{
    m_HActive = min(m_ptrVideoIn->Max_Pixels,
                max((WORD)clientScr.Width(), m_ptrVideoIn->Min_Pixels));

    regHActive = m_HActive;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetHDelay()
// Purpose: Set HDelay register
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetHDelay()
{
   // calculations here requires calculation of HActive first!
   m_pixels = m_HActive;
   if (m_pixels < m_ptrVideoIn->Min_UncroppedPixels)
      m_pixels += (WORD) ((m_ptrVideoIn->Min_UncroppedPixels - m_pixels + 9) / 10);

   LONG a = (LONG)m_pixels * (LONG)m_ptrVideoIn->Clkx1_HDELAY;
   LONG b = (LONG)m_ptrVideoIn->Clkx1_HACTIVE * 2L;
   WORD HDelay = (WORD) ((a + (LONG)m_ptrVideoIn->Clkx1_HACTIVE * 2 - 1) / b * 2L);

   // now add the cropping region into HDelay register; i.e. skip some pixels
   // before we start taking them as real image
   HDelay += (WORD)AnalogWin_.left;

   // HDelay must be even or else color would be wrong
   HDelay &= ~01;

   regHDelay = HDelay;

   // since we increase HDelay, we should decrease HActive by the same amount
   m_HActive -= (WORD)AnalogWin_.left;
   regHActive = m_HActive;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetHScale()
// Purpose: Set HScale register
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetHScale()
{
   regHScale = (WORD) ((((LONG)m_ptrVideoIn->Clkx1_HACTIVE * 4096L) /
                                            (LONG)m_pixels) - 4096L);
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetHFilter()
// Purpose: Set HFilt register field
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetHFilter()
{
   if (m_videoFormat != VFormat_SECAM)
      fieldHFILT = HFilter_AutoFormat;
   else  // SECAM
      if (m_pixels < m_ptrVideoIn->Clkx1_HACTIVE / 7)
         fieldHFILT = HFilter_ICON;
      else
         fieldHFILT = HFilter_QCIF;
}         

/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetVScale(MRect & clientScr)
// Purpose: Set VScale register
// Input:   MRect & clientScr - rectangle to scale to
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetVScale(MRect & clientScr)
{
   m_lines = min(m_ptrVideoIn->Max_Lines,
                  max((WORD)clientScr.Height(), m_ptrVideoIn->Min_Lines));

   WORD LPB_VScale_Factor = (WORD) (1 + (m_lines - 1) / m_ptrVideoIn->Active_lines_per_field);

   m_lines = (WORD) ((m_lines + LPB_VScale_Factor - 1) / LPB_VScale_Factor);

   LONG a = (LONG)m_ptrVideoIn->Active_lines_per_field * 512L / (LONG)m_lines;
   WORD VScale = (WORD) ((0x10000L - a + 512L) & 0x1FFFL);
   regVScale = VScale;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetVDelay()
// Purpose: Set VDelay register
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetVDelay()
{
   WORD VDelay, moreDelay;

   // increase VDelay will eliminate garbage lines at top of image
   switch (m_VFilter)
   {
      case 3:
         moreDelay = 4;
         break;

      case 2:
         moreDelay = 2;
         break;
             
      case 1:
      case 0:
      default:
         moreDelay = 0;
         break;
   }

   if ( ( m_videoFormat == VFormat_NTSC ) ||
        ( m_videoFormat == VFormat_NTSC_J ) ||
        ( m_videoFormat == VFormat_PAL_M ) ||
        ( m_videoFormat == VFormat_PAL_N_COMB ) )   // the reason that PAL_N_COMB is here is purely empirical
      VDelay = 0x001A + moreDelay;    // NTSC
   else
      VDelay = 0x0026 + moreDelay;    // PAL/SECAM
                            
   // now add the cropping region into VDelay register; i.e. skip some pixels
   // before we start taking them as real image
   VDelay += (WORD)(((LONG)m_ptrVideoIn->Max_Lines * (LONG)AnalogWin_.top + m_lines - 1) / (LONG)m_lines * 2);

   regVDelay = VDelay;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetVActive()
// Purpose: Set VActive register
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetVActive()
{
   // No calculation needed for VActive register since it based on the UNSCALED image
   if ( ( m_videoFormat == VFormat_NTSC ) ||
        ( m_videoFormat == VFormat_NTSC_J ) ||
        ( m_videoFormat == VFormat_PAL_M ) )
      regVActive = 0x1F4;
   else
      regVActive = 0x238;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetVBIEN(BOOL)
// Purpose: Set VBIEN register field
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetVBIEN(BOOL enable)
{
    if (enable)
    {
        fieldVBIEN = 1;
    }
    else
    {
        fieldVBIEN = 0;
    }
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL void Scaler::IsVBIEN()
// Purpose: Set VBIEN register field
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
BOOL Scaler::IsVBIEN()
{
    if (fieldVBIEN)
        return TRUE;
    else
        return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetVBIFMT(BOOL)
// Purpose: Set VBIFMT register field
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetVBIFMT(BOOL enable)
{
    if (enable)
    {
        fieldVBIFMT = 1;
    }
    else
    {
        fieldVBIFMT = 0;
    }
}


/////////////////////////////////////////////////////////////////////////////
// Method:  BOOL void Scaler::IsVBIFMT()
// Purpose: Set VBIFMT register field
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
BOOL Scaler::IsVBIFMT()
{
    if (fieldVBIFMT)
        return TRUE;
    else
        return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetVFilter()
// Purpose: Set VFilt register field
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetVFilter()
{
   // this is to remove junk lines at the top of video. flag set to off
   // when image hight is above CIF
   if (VFilterFlag_ == Off) {
      fieldVFILT = 0;
      m_VFilter  = 0;
      return;
   }
   if ((m_HActive <= m_ptrVideoIn->Max_VFilter3_Pixels) &&
        (m_lines   <= m_ptrVideoIn->Max_VFilter3_Lines))
      m_VFilter = 3;
   else if ((m_HActive <= m_ptrVideoIn->Max_VFilter2_Pixels) &&
             (m_lines   <= m_ptrVideoIn->Max_VFilter2_Lines))
      m_VFilter = 2;
   else if ((m_HActive <= m_ptrVideoIn->Max_VFilter1_Pixels) &&
             (m_lines   <= m_ptrVideoIn->Max_VFilter1_Lines))
      m_VFilter = 1;
   else
      m_VFilter = 0;

   fieldVFILT = m_VFilter;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::GetDigitalWin(MRect &DigWin) const
// Purpose: Retreives the size of digital window
// Input:   None
// Output:  MRect &DigWin - retrieved value
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::GetDigitalWin(MRect &DigWin) const
{
   DigWin = DigitalWin_;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Scaler::SetDigitalWin(const MRect &DigWin)
// Purpose: Sets the size and location of the digital window
// Input:   const MRect &DigWin - window size to set to
// Output:  None
// Return:  Success or Fail if passed rect is bigger then analog window
// Note:    This function can affect the scaling, so Scale() is called
/////////////////////////////////////////////////////////////////////////////
ErrorCode Scaler::SetDigitalWin(const MRect &DigWin)
{
   // we can not scale up
   if ((DigWin.Height() > AnalogWin_.Height()) ||
        (DigWin.Width() > AnalogWin_.Width()))
      return Fail;

   DigitalWin_ = DigWin;

   // every invocation of SetDigitalWin potentially changes the scaling
   Scale(DigitalWin_);

   return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::GetAnalogWin(MRect &AWin) const
// Purpose: Retreives the size of analog window
// Input:   None
// Output:  MRect &DigWin - retrieved value
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::GetAnalogWin(MRect &AWin) const
{
   AWin = AnalogWin_;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Scaler::SetAnalogWin(const MRect &AWin)
// Purpose: Sets the size and location of the analog window
// Input:   const MRect &AWin - window size to set to
// Output:  None
// Return:  Success or Fail if passed rect is bigger then analog window
/////////////////////////////////////////////////////////////////////////////
ErrorCode Scaler::SetAnalogWin(const MRect &AWin)
{
   AnalogWin_ = AWin;
   return Success;
}

void Scaler::DumpSomeState()
{
    UINT vDelay = regVDelay;
    UINT vActive = regVActive;
    UINT vScale = regVScale;
    UINT hDelay = regHDelay;
    UINT hActive = regHActive;
    UINT hScale = regHScale;

    MRect rect;
    GetDigitalWin(rect);

    DBGINFO(("vDelay = 0x%x\n", vDelay));
    DBGINFO(("vActive = 0x%x\n", vActive));
    DBGINFO(("vScale = 0x%x\n", vScale));
    DBGINFO(("hDelay = 0x%x\n", hDelay));
    DBGINFO(("hActive = 0x%x\n", hActive));
    DBGINFO(("hScale = 0x%x\n", hScale));
    DBGINFO(("top = 0x%x\n", rect.top));
    DBGINFO(("left = 0x%x\n", rect.left));
    DBGINFO(("right = 0x%x\n", rect.right));
    DBGINFO(("bottom = 0x%x\n", rect.bottom));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\viddefs.h ===
#pragma once

//==========================================================================;
//
//	Definitions for video settings.
//
//		$Date:   21 Aug 1998 14:58:10  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;


/* Type: Connector
 * Purpose: Defines a video source
 */
typedef enum { ConComposite, ConTuner, ConSVideo } Connector;

/* Type: State
 * Purpose: used to define on-off operations
 */
typedef enum { Off, On } State;

/* Type: Level
 * Purpose: used to define a pin state
 */
//typedef enum { Low, Hi } Level;

/* Type: Field
 * Purpose: defines fields
 */
typedef enum { VF_Both, VF_Even, VF_Odd } VidField;

/* Type: VideoFormat
 * Purpose: Used to define video format
 */
typedef enum {  VFormat_AutoDetect,
                VFormat_NTSC,
                VFormat_NTSC_J,
                VFormat_PAL_BDGHI,
                VFormat_PAL_M,
                VFormat_PAL_N,
                VFormat_SECAM,
                VFormat_PAL_N_COMB } VideoFormat;

/* Type: LumaRange
 * Purpose: Used to define Luma Output Range
 */
typedef enum { LumaNormal, LumaFull } LumaRange;

/* Type: OutputRounding
 * Purpose: Controls the number of bits output
 */
typedef enum { RND_Normal, RND_6Luma4Chroma, RND_7Luma5Chroma } OutputRounding;

/* Type: ClampLevel
 * Purpose: Defines the clamp levels
 */
typedef enum { ClampLow, ClampMiddle, ClampNormal, ClampHi } ClampLevel;


/*
 * Type: Crystal
 * Purpose: Defines which crystal to use
 */
typedef enum { Crystal_XT0 = 1, Crystal_XT1, Crystal_AutoSelect } Crystal;


/*
 * Type: HoriFilter
 * Purpose: Defines horizontal low-pass filter
 */
typedef enum { HFilter_AutoFormat,
               HFilter_CIF,
               HFilter_QCIF,
               HFilter_ICON } HorizFilter;

/*
 * Type: CoringLevel
 * Purpose: Defines Luma coring level
 */
typedef enum { Coring_None,
               Coring_8,
               Coring_16,
               Coring_32 } CoringLevel;

/*
 * Type: ThreeState
 * Purpose: Defines output three-states for the OE pin
 */
typedef enum { TS_Timing_Data,
               TS_Data,
               TS_Timing_Data_Clock,
               TS_Clock_Data } ThreeState;

/*
 * Type: SCLoopGain
 * Purpose: Defines subcarrier loop gain
 */
typedef enum { SC_Normal, SC_DivBy8, SC_DivBy16, SC_DivBy32 } SCLoopGain;

/*
 * Type: ComparePt
 * Purpose: Defines the majority comparison point for the White Crush Up function
 */
typedef enum { CompPt_3Q, CompPt_2Q, CompPt_1Q, CompPt_Auto } ComparePt;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\strmprop.h ===
//==========================================================================;
//
//  WDM Video Decoder stream properties definitions
//
//      $Date:   17 Aug 1998 14:59:50  $
//  $Revision:   1.0  $
//    $Author:   Tashjian  $
//
// $Copyright:  (c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

#ifdef _STRM_PROP_H_
#pragma message("StrmProp.h INCLUDED MORE THAN ONCE")
#else
#define _STRM_PROP_H_
#endif

// ------------------------------------------------------------------------
// Property set for Video and VBI capture streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoStreamConnectionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSALLOCATOR_FRAMING),            // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
};


DEFINE_KSPROPERTY_TABLE(VideoStreamDroppedFramesProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_DROPPEDFRAMES_CURRENT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinProperty
        sizeof(KSPROPERTY_DROPPEDFRAMES_CURRENT_S),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};

// ------------------------------------------------------------------------
// Array of the property sets supported by Video and VBI capture streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(VideoStreamProperties)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(VideoStreamConnectionProperties),  // PropertiesCount
        VideoStreamConnectionProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_DROPPEDFRAMES,                // Set
        SIZEOF_ARRAY(VideoStreamDroppedFramesProperties),  // PropertiesCount
        VideoStreamDroppedFramesProperties,                // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
};

const ULONG NumVideoStreamProperties =  SIZEOF_ARRAY(VideoStreamProperties);


// ------------------------------------------------------------------------
// Property set for the VideoPort
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoPortConfiguration)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_NUMCONNECTINFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(ULONG),                          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(ULONG),                          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_GETCONNECTINFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSMULTIPLE_DATA_PROP),           // MinProperty
        sizeof(DDVIDEOPORTCONNECT),             // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_SETCONNECTINFO,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(ULONG),                          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_VPDATAINFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KS_AMVPDATAINFO),                // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_MAXPIXELRATE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSVPSIZE_PROP),                  // MinProperty
        sizeof(KSVPMAXPIXELRATE),               // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
#if 0
    // This would be supported if we wanted to be informed of the available formats
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_INFORMVPINPUT,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSMULTIPLE_DATA_PROP),           // MinProperty
        sizeof(DDPIXELFORMAT),                  // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
#endif
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_DDRAWHANDLE,
        (PFNKSHANDLER)FALSE,
        sizeof(KSPROPERTY),
        sizeof(ULONG_PTR),    // could be 0 too
        (PFNKSHANDLER) TRUE,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_VIDEOPORTID,
        (PFNKSHANDLER)FALSE,
        sizeof(KSPROPERTY),
        sizeof(ULONG),    // could be 0 too
        (PFNKSHANDLER) TRUE,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE,
        (PFNKSHANDLER)FALSE,
        sizeof(KSPROPERTY),
        sizeof(ULONG_PTR),    // could be 0 too
        (PFNKSHANDLER) TRUE,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_GETVIDEOFORMAT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSMULTIPLE_DATA_PROP),           // MinProperty
        sizeof(DDPIXELFORMAT),                  // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_SETVIDEOFORMAT,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(ULONG),                          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_INVERTPOLARITY,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        0,                                      // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_SURFACEPARAMS,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSVPSURFACEPARAMS),              // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(BOOL),                           // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_SCALEFACTOR,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KS_AMVPSIZE),                    // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};

DEFINE_KSPROPERTY_SET_TABLE(VideoPortProperties)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_VPConfig,                  // Set
        SIZEOF_ARRAY(VideoPortConfiguration),   // PropertiesCount
        VideoPortConfiguration,                 // PropertyItem
        0,                                      // FastIoCount
        NULL                                    // FastIoTable
    )
};

const ULONG NumVideoPortProperties = SIZEOF_ARRAY(VideoPortProperties);


// ------------------------------------------------------------------------
// Property set for the VideoPort VBI stream
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoPortVBIConfiguration)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_NUMCONNECTINFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(ULONG),                          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(ULONG),                          // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_GETCONNECTINFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSMULTIPLE_DATA_PROP),           // MinProperty
        sizeof(DDVIDEOPORTCONNECT),             // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_SETCONNECTINFO,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(ULONG),                          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_VPDATAINFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KS_AMVPDATAINFO),                // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_MAXPIXELRATE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSVPSIZE_PROP),                  // MinProperty
        sizeof(KSVPMAXPIXELRATE),               // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
#if 0
    // This would be supported if we wanted to be informed of the available formats
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_INFORMVPINPUT,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSMULTIPLE_DATA_PROP),           // MinProperty
        sizeof(DDPIXELFORMAT),                  // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
#endif
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_DDRAWHANDLE,
        (PFNKSHANDLER)FALSE,
        sizeof(KSPROPERTY),
        sizeof(ULONG_PTR),    // could be 0 too
        (PFNKSHANDLER) TRUE,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_VIDEOPORTID,
        (PFNKSHANDLER)FALSE,
        sizeof(KSPROPERTY),
        sizeof(ULONG),    // could be 0 too
        (PFNKSHANDLER) TRUE,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE,
        (PFNKSHANDLER)FALSE,
        sizeof(KSPROPERTY),
        sizeof(ULONG_PTR),    // could be 0 too
        (PFNKSHANDLER) TRUE,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_GETVIDEOFORMAT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSMULTIPLE_DATA_PROP),           // MinProperty
        sizeof(DDPIXELFORMAT),                  // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_SETVIDEOFORMAT,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(ULONG),                          // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_INVERTPOLARITY,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        0,                                      // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_SURFACEPARAMS,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSVPSURFACEPARAMS),              // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(BOOL),                           // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VPCONFIG_SCALEFACTOR,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KS_AMVPSIZE),                    // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};

DEFINE_KSPROPERTY_SET_TABLE(VideoPortVBIProperties)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_VPVBIConfig,               // Set
        SIZEOF_ARRAY(VideoPortVBIConfiguration),// PropertiesCount
        VideoPortVBIConfiguration,              // PropertyItem
        0,                                      // FastIoCount
        NULL                                    // FastIoTable
    )
};

const ULONG NumVideoPortVBIProperties   = SIZEOF_ARRAY(VideoPortVBIProperties);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\strminfo.h ===
#pragma once

//==========================================================================;
//
//	WDM Video Decoder stream informaition defintitions
//
//		$Date:   17 Aug 1998 15:00:10  $
//	$Revision:   1.0  $
//	  $Author:   Tashjian  $
//
// $Copyright:	(c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;


/*
 * When this is set by the driver and passed to the client, this
 * indicates that the video port is capable of treating even fields
 * like odd fields and visa versa.  When this is set by the client,
 * this indicates that the video port should treat even fields like odd
 * fields.
 */
#define DDVPCONNECT_INVERTPOLARITY      0x00000004l

// derived from "fourcc.h"

#define MAKE_FOURCC(ch0, ch1, ch2, ch3)                       \
        ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |    \
        ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24))

#define FOURCC_YUV422   MAKE_FOURCC('S','4','2','2')
#define FOURCC_VBID	    MAKE_FOURCC('V','B','I','D')
#define FOURCC_YUY2     MAKE_FOURCC('Y','U','Y','2')
#define FOURCC_UYVY     MAKE_FOURCC('U','Y','V','Y')
#define FOURCC_YV12     MAKE_FOURCC('Y','V','1','2')
#define FOURCC_YUV12    FOURCC_YV12
#define FOURCC_Y12G     MAKE_FOURCC('Y','1','2','G')
#define FOURCC_YV10     MAKE_FOURCC('Y','V','1','0')
#define FOURCC_YUV10    FOURCC_YV10
#define FOURCC_YVU9     MAKE_FOURCC('Y','V','U','9')
#define FOURCC_IF09     MAKE_FOURCC('I','F','0','9')
#define FOURCC_Y10F     MAKE_FOURCC('Y','1','0','F')
#define FOURCC_Y12F     MAKE_FOURCC('Y','1','2','F')
#define FOURCC_YVUM     MAKE_FOURCC('Y','V','U','M')


//---------------------------------------------------------------------------
// Create an array that holds the list of all of the streams supported
//---------------------------------------------------------------------------

typedef struct _STREAM_OBJECT_INFO {
    BOOLEAN         Dma;        // device uses busmaster DMA for this stream
    BOOLEAN         Pio;        // device uses PIO for this
    ULONG   StreamHeaderMediaSpecific; // Size of media specific per stream header expansion. 
    ULONG   StreamHeaderWorkspace;		// Size of per-stream header workspace.
    BOOLEAN	Allocator;  // Set to TRUE if allocator is needed for this stream.    
    PHW_EVENT_ROUTINE HwEventRoutine;
} STREAM_OBJECT_INFO;


typedef struct _ALL_STREAM_INFO {
    HW_STREAM_INFORMATION   hwStreamInfo;
    STREAM_OBJECT_INFO      hwStreamObjectInfo;
} ALL_STREAM_INFO, *PALL_STREAM_INFO;

extern ALL_STREAM_INFO Streams[];
extern const ULONG NumStreams;

extern KSDATAFORMAT StreamFormatVideoPort;
extern KSDATAFORMAT StreamFormatVideoPortVBI;

extern GUID MY_KSEVENTSETID_VPNOTIFY;
extern GUID MY_KSEVENTSETID_VPVBINOTIFY;

extern KSTOPOLOGY Topology;

BOOL AdapterVerifyFormat(PKSDATAFORMAT, int);
BOOL AdapterCompareGUIDsAndFormatSize(IN PKSDATARANGE DataRange1,
										IN PKSDATARANGE DataRange2,
										BOOL fCompareFormatSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\xbar.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __XBAR_H
#define __XBAR_H

#include "capmain.h"

#include "mediums.h"

struct _XBAR_PIN_DESCRIPTION {
    ULONG PinType;
    ULONG RelatedPinIndex;
    ULONG IsRoutedTo;                 // Index of input pin in use
    KSPIN_MEDIUM Medium;
    _XBAR_PIN_DESCRIPTION(ULONG type, ULONG rel, const KSPIN_MEDIUM * PinMedium);
    _XBAR_PIN_DESCRIPTION(){}
};

inline _XBAR_PIN_DESCRIPTION::_XBAR_PIN_DESCRIPTION(ULONG type, ULONG rel , const KSPIN_MEDIUM * PinMedium) : 
    PinType(type), RelatedPinIndex(rel), IsRoutedTo(0) // , Medium(PinMedium)
{
    Medium = *PinMedium;
}

const ULONG NUMBER_OF_XBAR_OUTPUTS = 1;
const ULONG NUMBER_OF_XBAR_INPUTS = 3;

class CrossBar
{
    friend class Device;

    _XBAR_PIN_DESCRIPTION OutputPins [NUMBER_OF_XBAR_OUTPUTS];
    _XBAR_PIN_DESCRIPTION InputPins [NUMBER_OF_XBAR_INPUTS];

public:
    ULONG GetNoInputs();
    ULONG GetNoOutputs();

    void * operator new(size_t size, void * pAllocation) { return(pAllocation);}
    void operator delete(void * pAllocation) {}

        
    BOOL TestRoute(ULONG InPin, ULONG OutPin);
    ULONG GetPinInfo(KSPIN_DATAFLOW dir, ULONG idx, ULONG &related);
    KSPIN_MEDIUM * GetPinMedium(KSPIN_DATAFLOW dir, ULONG idx);

    void Route(ULONG OutPin, ULONG InPin);
    BOOL GoodPins(ULONG InPin, ULONG OutPin);

    ULONG GetRoute(ULONG OutPin);

    CrossBar();
};

inline CrossBar::CrossBar()
{
    OutputPins [0] = _XBAR_PIN_DESCRIPTION(KS_PhysConn_Video_VideoDecoder, 1 , &CrossbarMediums[3]);
    // InputPins are set in device.cpp
}

inline ULONG CrossBar::GetNoInputs()
{
    return NUMBER_OF_XBAR_INPUTS;
}

inline ULONG CrossBar::GetNoOutputs()
{
    return NUMBER_OF_XBAR_OUTPUTS;
}

inline BOOL CrossBar::GoodPins(ULONG InPin, ULONG OutPin)
{
    return BOOL(InPin < NUMBER_OF_XBAR_INPUTS && OutPin < NUMBER_OF_XBAR_OUTPUTS);
}

inline void CrossBar::Route(ULONG OutPin, ULONG InPin)
{
    OutputPins [OutPin].IsRoutedTo = InPin;
}

inline ULONG CrossBar::GetRoute(ULONG OutPin)
{
    return OutputPins [OutPin].IsRoutedTo;
}

inline KSPIN_MEDIUM * CrossBar::GetPinMedium(KSPIN_DATAFLOW dir, ULONG idx)
{
    _XBAR_PIN_DESCRIPTION *pPinDesc;

    if (dir == KSPIN_DATAFLOW_IN) {
        pPinDesc = InputPins;
    } else {
        pPinDesc = OutputPins;
    }

    return &pPinDesc [idx].Medium;
}

inline ULONG CrossBar::GetPinInfo(KSPIN_DATAFLOW dir, ULONG idx, ULONG &related)
{
    _XBAR_PIN_DESCRIPTION *pPinDesc;

    if (dir == KSPIN_DATAFLOW_IN) {
        pPinDesc = InputPins;
    } else {
        pPinDesc = OutputPins;
    }
    related = pPinDesc [idx].RelatedPinIndex;
    return pPinDesc [idx].PinType;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\strminfo.cpp ===
//==========================================================================;
//
//  WDM Video Decoder stream informaition declarations
//
//      $Date:   17 Aug 1998 15:00:38  $
//  $Revision:   1.0  $
//    $Author:   Tashjian  $
//
// $Copyright:  (c) 1997 - 1998  ATI Technologies Inc.  All Rights Reserved.  $
//
//==========================================================================;

extern "C" {
#include "strmini.h"
#include "ksmedia.h"
#include "math.h"
}

#include "defaults.h"
#include "mediums.h"
#include "StrmInfo.h"
#include "StrmProp.h"
#include "capdebug.h"


// devine MEDIASUBTYPE_UYVY here... can be removed if someday defined in ksmedia.h
#define STATIC_KSDATAFORMAT_SUBTYPE_UYVY\
    0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71  // MEDIASUBTYPE_UYVY
DEFINE_GUIDSTRUCT("59565955-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_UYVY);
#define KSDATAFORMAT_SUBTYPE_UYVY DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_UYVY)


//
// For event handling on the VP stream
//
NTSTATUS STREAMAPI VPStreamEventProc (PHW_EVENT_DESCRIPTOR);

//
// For event handling on the VP VBI stream
//
NTSTATUS STREAMAPI VPVBIStreamEventProc (PHW_EVENT_DESCRIPTOR);


// ------------------------------------------------------------------------
// The master list of all streams supported by this driver
// ------------------------------------------------------------------------

KSEVENT_ITEM VPEventItm[] =
{
    {
        KSEVENT_VPNOTIFY_FORMATCHANGE,
        0,
        0,
        NULL,
        NULL,
        NULL
    }
};

GUID MY_KSEVENTSETID_VPNOTIFY = {STATIC_KSEVENTSETID_VPNotify};

KSEVENT_SET VPEventSet[] =
{
    {
        &MY_KSEVENTSETID_VPNOTIFY,
        SIZEOF_ARRAY(VPEventItm),
        VPEventItm,
    }
};


KSEVENT_ITEM VPVBIEventItm[] =
{
    {
        KSEVENT_VPVBINOTIFY_FORMATCHANGE,
        0,
        0,
        NULL,
        NULL,
        NULL
    }
};

GUID MY_KSEVENTSETID_VPVBINOTIFY = {STATIC_KSEVENTSETID_VPVBINotify};

KSEVENT_SET VPVBIEventSet[] =
{
    {
        &MY_KSEVENTSETID_VPVBINOTIFY,
        SIZEOF_ARRAY(VPVBIEventItm),
        VPVBIEventItm,
    }
};


//---------------------------------------------------------------------------
// All of the video and vbi data formats we might use
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//  Capture Stream Formats
//---------------------------------------------------------------------------
KS_DATARANGE_VIDEO StreamFormatUYVY_Capture_NTSC =
{
    // KSDATARANGE
    {
        sizeof(KS_DATARANGE_VIDEO),     // FormatSize
        0,                                // Flags
        0,//DefWidth * DefHeight * 2,         // SampleSize
        0,                                // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,                 // aka. MEDIATYPE_Video
        STATIC_KSDATAFORMAT_SUBTYPE_UYVY,               // aka. MEDIASUBTYPE_UYVY
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO         // aka. FORMAT_VideoInfo
    },

    TRUE,                                // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,                                // BOOL,  bTemporalCompression (all I frames?)
    0,//KS_VIDEOSTREAM_CAPTURE,              // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                                   // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,      // GUID
        KS_AnalogVideo_NTSC_Mask & ~KS_AnalogVideo_NTSC_433 | KS_AnalogVideo_PAL_60 | KS_AnalogVideo_PAL_M, // AnalogVideoStandard
        {
            NTSCMaxInWidth, NTSCMaxInHeight      // SIZE InputSize
        },
        {
            NTSCMinInWidth, NTSCMinInHeight      // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
        },
        {
            NTSCMaxInWidth, NTSCMaxInHeight      // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
        },
        2,                               // int CropGranularityX;       // granularity of cropping size
        2,                               // int CropGranularityY;
        2,                               // int CropAlignX;             // alignment of cropping rect
        2,                               // int CropAlignY;
        {
            NTSCMinOutWidth, NTSCMinOutHeight    // SIZE MinOutputSize;         // smallest bitmap stream can produce
        },
        {
            NTSCMaxOutWidth, NTSCMaxOutHeight    // SIZE MaxOutputSize;         // largest  bitmap stream can produce
        },      
        80,                              // int OutputGranularityX;     // granularity of output bitmap size
        60,                              // int OutputGranularityY;
        0,                               // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,                               // StretchTapsY
        2,                               // ShrinkTapsX 
        2,                               // ShrinkTapsY 
        (LONGLONG)NTSCFieldDuration,               // LONGLONG MinFrameInterval;  // 100 nS units
        (LONGLONG)NTSCFieldDuration*MAXULONG,   // LONGLONG MaxFrameInterval;
        NTSCFrameRate * 80 * 40 * 2 * 8,            // LONG MinBitsPerSecond;
        NTSCFrameRate * 720 * 480 * 2 * 8           // LONG MaxBitsPerSecond;
    },

    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                          //    RECT            rcSource;          // The bit we really want to use
        0,0,0,0,                          //    RECT            rcTarget;          // Where the video should go
        DefWidth * DefHeight * 2 * NTSCFrameRate,   //    DWORD           dwBitRate;         // Approximate bit data rate
        0L,                               //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
        
        // 30 fps
        NTSCFieldDuration * 2,            //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)
        
        sizeof(KS_BITMAPINFOHEADER),       //    DWORD      biSize;
        DefWidth,                         //    LONG       biWidth;
        DefHeight,                        //    LONG       biHeight;
        1,                                //    WORD       biPlanes;
        16,                               //    WORD       biBitCount;
        FOURCC_UYVY,                      //    DWORD      biCompression;
        DefWidth * DefHeight * 2,         //    DWORD      biSizeImage;
        0,                                //    LONG       biXPelsPerMeter;
        0,                                //    LONG       biYPelsPerMeter;
        0,                                //    DWORD      biClrUsed;
        0                                 //    DWORD      biClrImportant;
    }
};

KS_DATARANGE_VIDEO StreamFormatUYVY_Capture_PAL =
{
    // KSDATARANGE
    {
        sizeof(KS_DATARANGE_VIDEO),     // FormatSize
        0,                                // Flags
        0,//QCIFWidth * QCIFHeight * 2,         // SampleSize
        0,                                // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,                 // aka. MEDIATYPE_Video
        STATIC_KSDATAFORMAT_SUBTYPE_UYVY,               // aka. MEDIASUBTYPE_UYVY
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO         // aka. FORMAT_VideoInfo
    },

    TRUE,                                // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,                                // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE,              // StreamDescriptionFlags (KS_VIDEO_DESC_*)
    0,                                   // MemoryAllocationFlags (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,      // GUID 
        KS_AnalogVideo_PAL_Mask & ~KS_AnalogVideo_PAL_60 & ~KS_AnalogVideo_PAL_M | KS_AnalogVideo_SECAM_Mask | KS_AnalogVideo_NTSC_433, // AnalogVideoStandard
        {
            720, 576        // SIZE InputSize
        },
        {
            QCIFWidth, QCIFHeight        // SIZE MinCroppingSize; smallest rcSrc cropping rect allowed
        },
        {
            QCIFWidth * 4, QCIFHeight * 4        // SIZE MaxCroppingSize; largest rcSrc cropping rect allowed
        },
        1,                               // int CropGranularityX;       // granularity of cropping size
        1,                               // int CropGranularityY;
        1,                               // int CropAlignX;             // alignment of cropping rect
        1,                               // int CropAlignY;
        {
            QCIFWidth, QCIFHeight        // SIZE MinOutputSize;         // smallest bitmap stream can produce
        },
        {
            QCIFWidth * 2, QCIFHeight * 2        // SIZE MaxOutputSize;         // largest  bitmap stream can produce
        },      
        QCIFWidth,                               // int OutputGranularityX;     // granularity of output bitmap size
        QCIFHeight,                               // int OutputGranularityY;
        0,                               // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,                               // StretchTapsY
        2,                               // ShrinkTapsX 
        2,                               // ShrinkTapsY 
        (LONGLONG)PALFieldDuration,               // LONGLONG MinFrameInterval;  // 100 nS units
        (LONGLONG)PALFieldDuration*MAXULONG,   // LONGLONG MaxFrameInterval;
        1  * QCIFWidth * QCIFHeight * 2 * 8,    // LONG MinBitsPerSecond;
        25 * QCIFWidth * QCIFHeight * 16 * 2 * 8     // LONG MaxBitsPerSecond;
    },

    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                          //    RECT            rcSource; // The bit we really want to use
        0,0,0,0,                          //    RECT            rcTarget; // Where the video should go
        QCIFWidth * 4 * QCIFHeight * 2 * 25L, //    DWORD           dwBitRate; // Approximate bit data rate
        0L,                               //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
        
        // 30 fps
        PALFieldDuration * 2,            //    REFERENCE_TIME AvgTimePerFrame;   // Average time per frame (100ns units)
        
        sizeof KS_BITMAPINFOHEADER,       //    DWORD      biSize;
        QCIFWidth * 2,                        //    LONG       biWidth;
        QCIFHeight * 2,                       //    LONG       biHeight;
        1,                                //    WORD       biPlanes;
        16,                               //    WORD       biBitCount;
        FOURCC_UYVY,                      //    DWORD      biCompression;
        QCIFWidth * QCIFHeight * 2 * 4,       //    DWORD      biSizeImage;
        0,                                //    LONG       biXPelsPerMeter;
        0,                                //    LONG       biYPelsPerMeter;
        0,                                //    DWORD      biClrUsed;
        0                                 //    DWORD      biClrImportant;
    }
};


KS_DATARANGE_VIDEO StreamFormatUYVY_Capture_NTSC_QCIF =
{
    // KSDATARANGE
    {
        sizeof(KS_DATARANGE_VIDEO),     // FormatSize
        0,                                // Flags
        QCIFWidth * QCIFHeight * 2,         // SampleSize
        0,                                // Reserved
        STATIC_KSDATAFORMAT_TYPE_VIDEO,                 // aka. MEDIATYPE_Video
        STATIC_KSDATAFORMAT_SUBTYPE_UYVY,               // aka. MEDIASUBTYPE_UYVY
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO         // aka. FORMAT_VideoInfo
    },

    TRUE,                                // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,                                // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_CAPTURE,              // StreamDescriptionFlags (KS_VIDEO_DESC_*)
    0,                                   // MemoryAllocationFlags (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS
    {
        STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,      // GUID 
        KS_AnalogVideo_NTSC_Mask & ~KS_AnalogVideo_NTSC_433 | KS_AnalogVideo_PAL_60 | KS_AnalogVideo_PAL_M, // AnalogVideoStandard
        {
            NTSCMaxInWidth, NTSCMaxInHeight      // SIZE InputSize
        },
        {
            QCIFWidth, QCIFHeight        // SIZE MinCroppingSize; smallest rcSrc cropping rect allowed
        },
        {
            QCIFWidth, QCIFHeight        // SIZE MaxCroppingSize; largest rcSrc cropping rect allowed
        },
        1,                               // int CropGranularityX;       // granularity of cropping size
        1,                               // int CropGranularityY;
        1,                               // int CropAlignX;             // alignment of cropping rect
        1,                               // int CropAlignY;
        {
            QCIFWidth, QCIFHeight        // SIZE MinOutputSize;         // smallest bitmap stream can produce
        },
        {
            QCIFWidth, QCIFHeight        // SIZE MaxOutputSize;         // largest  bitmap stream can produce
        },      
        1,                               // int OutputGranularityX;     // granularity of output bitmap size
        1,                               // int OutputGranularityY;
        0,                               // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,                               // StretchTapsY
        2,                               // ShrinkTapsX 
        2,                               // ShrinkTapsY 
        (LONGLONG)NTSCFieldDuration,               // LONGLONG MinFrameInterval;  // 100 nS units
        (LONGLONG)NTSCFieldDuration*MAXULONG,   // LONGLONG MaxFrameInterval;
        1  * QCIFWidth * QCIFHeight * 2 * 8,    // LONG MinBitsPerSecond;
        30 * QCIFWidth * QCIFHeight * 2 * 8     // LONG MaxBitsPerSecond;
    },

    // KS_VIDEOINFOHEADER (default format)
    {
        0,0,0,0,                          //    RECT            rcSource; // The bit we really want to use
        0,0,0,0,                          //    RECT            rcTarget; // Where the video should go
        QCIFWidth * QCIFHeight * 2 * 30L, //    DWORD           dwBitRate; // Approximate bit data rate
        0L,                               //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
        
        // 30 fps
        NTSCFieldDuration * 2,            //    REFERENCE_TIME AvgTimePerFrame;   // Average time per frame (100ns units)
        
        sizeof KS_BITMAPINFOHEADER,       //    DWORD      biSize;
        QCIFWidth,                        //    LONG       biWidth;
        QCIFHeight,                       //    LONG       biHeight;
        1,                                //    WORD       biPlanes;
        16,                               //    WORD       biBitCount;
        FOURCC_UYVY,                      //    DWORD      biCompression;
        QCIFWidth * QCIFHeight * 2,       //    DWORD      biSizeImage;
        0,                                //    LONG       biXPelsPerMeter;
        0,                                //    LONG       biYPelsPerMeter;
        0,                                //    DWORD      biClrUsed;
        0                                 //    DWORD      biClrImportant;
    }
};

KSDATAFORMAT StreamFormatVideoPort = 
{
    {
        sizeof(KSDATAFORMAT),
        0,
        0,
        0,
        STATIC_KSDATAFORMAT_TYPE_VIDEO,
        STATIC_KSDATAFORMAT_SUBTYPE_VPVideo,
        STATIC_KSDATAFORMAT_SPECIFIER_NONE
    }
};

KS_DATARANGE_VIDEO_VBI StreamFormatVBI_NTSC =
{
    // KSDATARANGE
    {
        {
            sizeof(KS_DATARANGE_VIDEO_VBI),
            0,
            VBISamples * NTSCVBILines,         // SampleSize
            0,                             // Reserved
            { STATIC_KSDATAFORMAT_TYPE_VBI },
            { STATIC_KSDATAFORMAT_SUBTYPE_RAW8 },
            { STATIC_KSDATAFORMAT_SPECIFIER_VBI }
        }
    },
    TRUE,                                // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,                                // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_VBI,                  // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                                   // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS
    {
        { STATIC_KSDATAFORMAT_SPECIFIER_VBI },
        KS_AnalogVideo_NTSC_M,                             // AnalogVideoStandard
        {
            VBISamples, NTSCVBILines  // SIZE InputSize
        },
        {
            VBISamples, NTSCVBILines  // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
        },
        {
            VBISamples, NTSCVBILines  // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
        },
        1,                  // int CropGranularityX;       // granularity of cropping size
        1,                  // int CropGranularityY;
        1,                  // int CropAlignX;             // alignment of cropping rect
        1,                  // int CropAlignY;
        {
            VBISamples, NTSCVBILines  // SIZE MinOutputSize;   // smallest bitmap stream can produce
        },
        {
            VBISamples, NTSCVBILines  // SIZE MaxOutputSize;   // largest  bitmap stream can produce
        },
        1,                  // int OutputGranularityX;     // granularity of output bitmap size
        2,                  // int OutputGranularityY;
        0,                  // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,                  // StretchTapsY
        0,                  // ShrinkTapsX
        0,                  // ShrinkTapsY
        NTSCFieldDuration,  // LONGLONG MinFrameInterval;  // 100 nS units
        NTSCFieldDuration,  // LONGLONG MaxFrameInterval;
        VBISamples * 30 * NTSCVBILines * 2 * 8, // LONG MinBitsPerSecond;
        VBISamples * 30 * NTSCVBILines * 2 * 8  // LONG MaxBitsPerSecond;
    },

    // KS_VBIINFOHEADER (default format)
    {
        NTSCVBIStart,               // StartLine  -- inclusive
        NTSCVBIEnd,                 // EndLine    -- inclusive
        SamplingFrequency,      // SamplingFrequency
        454,                    // MinLineStartTime;    // (uS past HR LE) * 100
        900,                    // MaxLineStartTime;    // (uS past HR LE) * 100

        // empirically discovered
        780,                    // ActualLineStartTime  // (uS past HR LE) * 100

        5902,                   // ActualLineEndTime;   // (uS past HR LE) * 100
        KS_AnalogVideo_NTSC_M,  // VideoStandard;
        VBISamples,             // SamplesPerLine;
        VBISamples,             // StrideInBytes;
        VBISamples * NTSCVBILines   // BufferSize;
    }
};

KSDATAFORMAT StreamFormatVideoPortVBI = 
{
    {
        sizeof(KSDATAFORMAT),
        0,
        0,
        0,
        STATIC_KSDATAFORMAT_TYPE_VIDEO,
        STATIC_KSDATAFORMAT_SUBTYPE_VPVBI,
        STATIC_KSDATAFORMAT_SPECIFIER_NONE
    }
};

static KS_DATARANGE_ANALOGVIDEO StreamFormatAnalogVideo = 
{
    // KS_DATARANGE_ANALOGVIDEO
    {   
        sizeof (KS_DATARANGE_ANALOGVIDEO),      // FormatSize
        0,                                      // Flags
        sizeof (KS_TVTUNER_CHANGE_INFO),        // SampleSize
        0,                                      // Reserved

        STATIC_KSDATAFORMAT_TYPE_ANALOGVIDEO,   // aka MEDIATYPE_AnalogVideo
        STATIC_KSDATAFORMAT_SUBTYPE_NONE,       // ie. Wildcard
        STATIC_KSDATAFORMAT_SPECIFIER_ANALOGVIDEO, // aka FORMAT_AnalogVideo
    },
    // KS_ANALOGVIDEOINFO
    {
        0, 0, 720, 480,         // rcSource;                
        0, 0, 720, 480,         // rcTarget;        
        720,                    // dwActiveWidth;   
        480,                    // dwActiveHeight;  
        NTSCFrameDuration,      // REFERENCE_TIME  AvgTimePerFrame; 
    }
};

//---------------------------------------------------------------------------
//  Capture Stream Formats, Mediums, and PinNames
//---------------------------------------------------------------------------

static PKSDATAFORMAT CaptureStreamFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatUYVY_Capture_NTSC,
    (PKSDATAFORMAT) &StreamFormatUYVY_Capture_NTSC_QCIF,
    (PKSDATAFORMAT) &StreamFormatUYVY_Capture_PAL,
};
#define NUM_CAPTURE_STREAM_FORMATS (SIZEOF_ARRAY (CaptureStreamFormats))

static GUID CaptureStreamPinName = {STATIC_PINNAME_VIDEO_CAPTURE};


//---------------------------------------------------------------------------
//  Video Port Stream Formats, Mediums, and PinNames
//---------------------------------------------------------------------------

static PKSDATAFORMAT VPStreamFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatVideoPort,
};
#define NUM_VP_STREAM_FORMATS (SIZEOF_ARRAY (VPStreamFormats))

static GUID VideoPortPinName = {STATIC_PINNAME_VIDEO_VIDEOPORT};


//---------------------------------------------------------------------------
//  VBI Stream Formats, Mediums, and PinNames
//---------------------------------------------------------------------------

static PKSDATAFORMAT VBIStreamFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatVBI_NTSC,
};
#define NUM_VBI_STREAM_FORMATS (SIZEOF_ARRAY (VBIStreamFormats))

static GUID VBIStreamPinName = {STATIC_PINNAME_VIDEO_VBI};


//---------------------------------------------------------------------------
//  Video Port VBI Stream Formats, Mediums, and PinNames
//---------------------------------------------------------------------------

static PKSDATAFORMAT VPVBIStreamFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatVideoPortVBI,
};
#define NUM_VPVBI_STREAM_FORMATS (SIZEOF_ARRAY (VPVBIStreamFormats))

static GUID VPVBIPinName = {STATIC_PINNAME_VIDEO_VIDEOPORT_VBI};


//---------------------------------------------------------------------------
//  Analog Video Stream Formats, Mediums, and PinNames
//---------------------------------------------------------------------------

static PKSDATAFORMAT AnalogVideoFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatAnalogVideo,
};
#define NUM_ANALOG_VIDEO_FORMATS (SIZEOF_ARRAY (AnalogVideoFormats))

static GUID AnalogVideoStreamPinName = {STATIC_PINNAME_VIDEO_ANALOGVIDEOIN};

ALL_STREAM_INFO Streams [] =
{
    // -----------------------------------------------------------------
    // The Video Capture output stream
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_OUT,                     // DataFlow
            TRUE,                                   // DataAccessible
            NUM_CAPTURE_STREAM_FORMATS,             // NumberOfFormatArrayEntries
            CaptureStreamFormats,                   // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            NumVideoStreamProperties,               // NumStreamPropArrayEntries
            (PKSPROPERTY_SET)VideoStreamProperties, // StreamPropertiesArray
            0,                                      // NumStreamEventArrayEntries;
            0,                                      // StreamEventsArray;
            &CaptureStreamPinName,                  // Category
            &CaptureStreamPinName,                  // Name
            0,                                      // MediumsCount
            NULL,                                   // Mediums
        },

        // STREAM_OBJECT_INFO ------------------------------------------------
        {
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            sizeof (KS_FRAME_INFO),                 // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace 
            TRUE,                                   // Allocator 
            NULL,                                   // HwEventRoutine
        }
    },

    // -----------------------------------------------------------------
    // The Video Port output stream
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_OUT,                     // DataFlow
            TRUE,                                   // DataAccessible.
            NUM_VP_STREAM_FORMATS,                  // NumberOfFormatArrayEntries
            VPStreamFormats,                        // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            NumVideoPortProperties,             // NumStreamPropArrayEntries
            (PKSPROPERTY_SET)VideoPortProperties,   // StreamPropertiesArray
            SIZEOF_ARRAY(VPEventSet),               // NumStreamEventArrayEntries
            VPEventSet,                             // StreamEventsArray
            &VideoPortPinName,                      // Category
            &VideoPortPinName,                      // Name
            0,                                      // MediumsCount
            NULL,                                   // Mediums
        },

        // STREAM_OBJECT_INFO ------------------------------------------------
        {
            FALSE,                                  // Dma
            FALSE,                                   // Pio
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace 
            FALSE,                                  // Allocator 
            VPStreamEventProc,                      // HwEventRoutine;
        }
    },

    // -----------------------------------------------------------------
    // The VBI Capture output stream
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_OUT,                     // DataFlow
            TRUE,                                   // DataAccessible
            NUM_VBI_STREAM_FORMATS,                 // NumberOfFormatArrayEntries
            VBIStreamFormats,                       // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            NumVideoStreamProperties,               // NumStreamPropArrayEntries
            (PKSPROPERTY_SET)VideoStreamProperties, // StreamPropertiesArray
            0,                                      // NumStreamEventArrayEntries;
            0,                                      // StreamEventsArray;
            &VBIStreamPinName,                      // Category
            &VBIStreamPinName,                      // Name
            0,                                      // MediumsCount
            NULL,                                   // Mediums
        },

        // STREAM_OBJECT_INFO ------------------------------------------------
        {
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            sizeof (KS_VBI_FRAME_INFO),             // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace 
            TRUE,                                   // Allocator 
            NULL,                                   // HwEventRoutine
        }
    },

    // -----------------------------------------------------------------
    // The Video Port VBI output stream
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_OUT,                     // DataFlow
            TRUE,                                   // DataAccessible.
            NUM_VPVBI_STREAM_FORMATS,               // NumberOfFormatArrayEntries
            VPVBIStreamFormats,                     // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            NumVideoPortVBIProperties,              // NumStreamPropArrayEntries
            (PKSPROPERTY_SET)VideoPortVBIProperties,// StreamPropertiesArray
            SIZEOF_ARRAY(VPVBIEventSet),            // NumStreamEventArrayEntries
            VPVBIEventSet,                          // StreamEventsArray
            &VPVBIPinName,                          // Category
            &VPVBIPinName,                          // Name
            0,                                      // MediumsCount
            NULL,                                   // Mediums
        },

        // STREAM_OBJECT_INFO ------------------------------------------------
        {
            FALSE,                                  // Dma
            FALSE,                                   // Pio
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace 
            FALSE,                                  // Allocator 
            VPVBIStreamEventProc,                   // HwEventRoutine;
        }
    },

    // -----------------------------------------------------------------
    // The Analog Video Input Stream 
    // -----------------------------------------------------------------
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_IN,                      // DataFlow
            TRUE,                                   // DataAccessible
            NUM_ANALOG_VIDEO_FORMATS,               // NumberOfFormatArrayEntries
            AnalogVideoFormats,                     // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            0,                                      // NumStreamPropArrayEntries
            0,                                      // StreamPropertiesArray
            0,                                      // NumStreamEventArrayEntries;
            0,                                      // StreamEventsArray;
            &AnalogVideoStreamPinName,              // Category
            &AnalogVideoStreamPinName,              // Name
            1,                                      // MediumsCount
            &CrossbarMediums[3],                    // Mediums
        },
           
        // STREAM_OBJECT_INFO ------------------------------------------------
        {
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace 
            FALSE,                                  // Allocator 
            NULL,                                   // HwEventRoutine
        },
    }
};

extern const ULONG NumStreams = SIZEOF_ARRAY(Streams);


//---------------------------------------------------------------------------
// Topology
//---------------------------------------------------------------------------

// Categories define what the device does.

static GUID Categories[] = {
    STATIC_KSCATEGORY_VIDEO,
    STATIC_KSCATEGORY_CAPTURE,
    STATIC_KSCATEGORY_CROSSBAR,
};

#define NUMBER_OF_CATEGORIES  SIZEOF_ARRAY (Categories)

KSTOPOLOGY Topology = {
    NUMBER_OF_CATEGORIES,               // CategoriesCount
    (GUID*) &Categories,                // Categories
    0,                                  // TopologyNodesCount
    NULL,                               // TopologyNodes
    0,                                  // TopologyConnectionsCount
    NULL,                               // TopologyConnections
    NULL,                               // TopologyNodesNames
    0,                                  // Reserved
};



/*
** AdapterCompareGUIDsAndFormatSize()
**
**   Checks for a match on the three GUIDs and FormatSize
**
** Arguments:
**
**         IN DataRange1
**         IN DataRange2
**         BOOL fCompareFormatSize - TRUE when comparing ranges
**                                 - FALSE when comparing formats
**
** Returns:
** 
**   TRUE if all elements match
**   FALSE if any are different
**
** Side Effects:  none
*/

BOOL AdapterCompareGUIDsAndFormatSize(
    IN PKSDATARANGE DataRange1,
    IN PKSDATARANGE DataRange2,
    BOOL fCompareFormatSize
    )
{
    return (
        IsEqualGUID (
            DataRange1->MajorFormat, 
            DataRange2->MajorFormat) &&
        IsEqualGUID (
            DataRange1->SubFormat, 
            DataRange2->SubFormat) &&
        IsEqualGUID (
            DataRange1->Specifier, 
            DataRange2->Specifier) && 
        (fCompareFormatSize ? 
                (DataRange1->FormatSize == DataRange2->FormatSize) : TRUE));
}


/*
** MultiplyCheckOverflow()
**
**   Perform a 32-bit unsigned multiplication with status indicating whether overflow occured.
**
** Arguments:
**
**   a - first operand
**   b - second operand
**   pab - result
**
** Returns:
**
**   TRUE - no overflow
**   FALSE - overflow occurred
**
*/

BOOL
MultiplyCheckOverflow(
    ULONG a,
    ULONG b,
    ULONG *pab
    )
{
    *pab = a * b;
    if ((a == 0) || (((*pab) / a) == b)) {
        return TRUE;
    }
    return FALSE;
}

/*
** AdapterVerifyFormat()
**
**   Checks the validity of a format request by walking through the
**       array of supported KSDATA_RANGEs for a given stream.
**
** Arguments:
**
**   pKSDataFormat - pointer of a KSDATAFORMAT structure.
**   StreamNumber - index of the stream being queried / opened.
**
** Returns:
** 
**   TRUE if the format is supported
**   FALSE if the format cannot be suppored
**
** Side Effects:  none
*/

BOOL AdapterVerifyFormat(PKSDATAFORMAT pKSDataFormatToVerify, int StreamNumber)
{
    BOOL                        fOK = FALSE;
    ULONG                       j;
    ULONG                       NumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;


    //
    // Check that the stream number is valid
    //

    if (StreamNumber >= NumStreams) {
        TRAP();
        return FALSE;
    }
    
    NumberOfFormatArrayEntries = 
            Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

    //
    // Get the pointer to the array of available formats
    //

    pAvailableFormats = Streams[StreamNumber].hwStreamInfo.StreamFormatsArray;

    DBGINFO(("AdapterVerifyFormat, Stream=%d\n", StreamNumber));
    DBGINFO(("FormatSize=%d\n", 
            pKSDataFormatToVerify->FormatSize));
    DBGINFO(("MajorFormat=%x\n", 
            pKSDataFormatToVerify->MajorFormat));

    //
    // Walk the formats supported by the stream
    //

    for (j = 0; j < NumberOfFormatArrayEntries; j++, pAvailableFormats++) {

        // Check for a match on the three GUIDs and format size

        if (!AdapterCompareGUIDsAndFormatSize(
                        pKSDataFormatToVerify, 
                        *pAvailableFormats,
                        FALSE /* CompareFormatSize */)) {
            continue;
        }

        //
        // Now that the three GUIDs match, switch on the Specifier
        // to do a further type-specific check
        //

        // -------------------------------------------------------------------
        // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
        // -------------------------------------------------------------------

        if (IsEqualGUID(pKSDataFormatToVerify->Specifier, KSDATAFORMAT_SPECIFIER_VIDEOINFO) &&
            pKSDataFormatToVerify->FormatSize >= sizeof(KS_DATAFORMAT_VIDEOINFOHEADER)) {
                
            PKS_DATAFORMAT_VIDEOINFOHEADER  pDataFormatVideoInfoHeader = 
                    (PKS_DATAFORMAT_VIDEOINFOHEADER) pKSDataFormatToVerify;
            PKS_VIDEOINFOHEADER  pVideoInfoHdrToVerify = 
                     (PKS_VIDEOINFOHEADER) &pDataFormatVideoInfoHeader->VideoInfoHeader;
            PKS_DATARANGE_VIDEO             pKSDataRangeVideo = (PKS_DATARANGE_VIDEO) *pAvailableFormats;
            KS_VIDEO_STREAM_CONFIG_CAPS    *pConfigCaps = &pKSDataRangeVideo->ConfigCaps;

            // Validate each step of the size calculations for arithmetic overflow,
            // and verify that the specified sizes correlate
            // (with unsigned math, a+b < b iff an arithmetic overflow occured)
            {
                ULONG VideoHeaderSize = pVideoInfoHdrToVerify->bmiHeader.biSize +
                    FIELD_OFFSET(KS_VIDEOINFOHEADER,bmiHeader);
                ULONG FormatSize = VideoHeaderSize +
                    FIELD_OFFSET(KS_DATAFORMAT_VIDEOINFOHEADER,VideoInfoHeader);

                if (VideoHeaderSize < FIELD_OFFSET(KS_VIDEOINFOHEADER,bmiHeader) ||
                    FormatSize < FIELD_OFFSET(KS_DATAFORMAT_VIDEOINFOHEADER,VideoInfoHeader) ||
                    FormatSize > pKSDataFormatToVerify->FormatSize) {

                    fOK = FALSE;
                    break;
                }
            }

            // Validate the image size and dimension parameters
            // (the equivalent of using the KS_DIBSIZE macro)
            {
                ULONG ImageSize = 0;

                if (!MultiplyCheckOverflow(
                    (ULONG)pVideoInfoHdrToVerify->bmiHeader.biWidth,
                    (ULONG)pVideoInfoHdrToVerify->bmiHeader.biBitCount,
                    &ImageSize
                    )) {

                    fOK = FALSE;
                    break;
                }

                // Convert bits to an even multiple of 4 bytes
                ImageSize = ((ImageSize / 8) + 3) & ~3;

                // Now calculate the full size
                if (!MultiplyCheckOverflow(
                    ImageSize,
                    (ULONG)abs(pVideoInfoHdrToVerify->bmiHeader.biHeight),
                    &ImageSize
                    )) {

                    fOK = FALSE;
                    break;
                }

                // Finally, is the specified image size big enough?
                if (pDataFormatVideoInfoHeader->DataFormat.SampleSize < ImageSize ||
                    pVideoInfoHdrToVerify->bmiHeader.biSizeImage < ImageSize
                    ) {

                    fOK = FALSE;
                    break;
                }
            }

            fOK = TRUE;
            break;

        } // End of VIDEOINFOHEADER specifier

        // -------------------------------------------------------------------
        // Specifier FORMAT_VideoInfo for VBIINFOHEADER
        // -------------------------------------------------------------------

        if (IsEqualGUID (pKSDataFormatToVerify->Specifier, KSDATAFORMAT_SPECIFIER_VBI) &&
            pKSDataFormatToVerify->FormatSize >= sizeof(KS_DATAFORMAT_VBIINFOHEADER)) {
                
            PKS_DATAFORMAT_VBIINFOHEADER    pKSVBIDataFormat =
                (PKS_DATAFORMAT_VBIINFOHEADER)pKSDataFormatToVerify;
            PKS_VBIINFOHEADER               pVBIInfoHeader =
                &pKSVBIDataFormat->VBIInfoHeader;

            // Validate the VBI format and sample size parameters
            {
                ULONG SampleSize = 0;

                // Do the StartLine and Endline values make sense?
                if (pVBIInfoHeader->StartLine > pVBIInfoHeader->EndLine ||
                    pVBIInfoHeader->StartLine < (VREFDiscard + 1) ||
                    pVBIInfoHeader->EndLine - (VREFDiscard + 1) > 500
                    ) {

                    fOK = FALSE;
                    break;
                }

                // Calculate the sample size
                if (!MultiplyCheckOverflow(
                    pVBIInfoHeader->EndLine - pVBIInfoHeader->StartLine + 1,
                    pVBIInfoHeader->SamplesPerLine,
                    &SampleSize
                    )) {

                    fOK = FALSE;
                    break;
                }

                // Are the size parameters big enough?
                if (pKSVBIDataFormat->DataFormat.SampleSize < SampleSize ||
                    pVBIInfoHeader->BufferSize < SampleSize
                    ) {

                    fOK = FALSE;
                    break;
                }
            }

            fOK = TRUE;
            break;

        } // End of VBI specifier

        // -------------------------------------------------------------------
        // Specifier FORMAT_AnalogVideo for KS_ANALOGVIDEOINFO
        // -------------------------------------------------------------------

        if (IsEqualGUID (pKSDataFormatToVerify->Specifier, KSDATAFORMAT_SPECIFIER_ANALOGVIDEO) &&
            pKSDataFormatToVerify->FormatSize >= sizeof(KS_DATARANGE_ANALOGVIDEO)) {
      
            fOK = TRUE;
            break;

        } // End of KS_ANALOGVIDEOINFO specifier

        // -------------------------------------------------------------------
        // Specifier STATIC_KSDATAFORMAT_TYPE_VIDEO for Video Port
        // -------------------------------------------------------------------

        if (IsEqualGUID (pKSDataFormatToVerify->Specifier, KSDATAFORMAT_SPECIFIER_NONE) &&
            IsEqualGUID (pKSDataFormatToVerify->SubFormat, KSDATAFORMAT_SUBTYPE_VPVideo)) {

            fOK = TRUE;
            break;
        }  // End of Video port section
        
        // -------------------------------------------------------------------
        // Specifier KSDATAFORMAT_SPECIFIER_NONE for VP VBI
        // -------------------------------------------------------------------

        if (IsEqualGUID (pKSDataFormatToVerify->Specifier, KSDATAFORMAT_SPECIFIER_NONE) &&
            IsEqualGUID (pKSDataFormatToVerify->SubFormat, KSDATAFORMAT_SUBTYPE_VPVBI)) {

            fOK = TRUE;
            break;
        }  // End of VP VBI section
      
    } // End of loop on all formats for this stream
    
    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\scaler.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __SCALER_H
#define __SCALER_H

#include "mytypes.h"

#define HDROP       HANDLE

#include "viddefs.h"

#include "capmain.h"
#include "register.h"

// structure contains video information
struct VideoInfoStruct
{
   WORD Clkx1_HACTIVE;
   WORD Clkx1_HDELAY;
   WORD Min_Pixels;
   WORD Active_lines_per_field;
   WORD Min_UncroppedPixels;
   WORD Max_Pixels;
   WORD Min_Lines;
   WORD Max_Lines;
   WORD Max_VFilter1_Pixels;
   WORD Max_VFilter2_Pixels;
   WORD Max_VFilter3_Pixels;
   WORD Max_VFilter1_Lines;
   WORD Max_VFilter2_Lines;
   WORD Max_VFilter3_Lines;
};


/////////////////////////////////////////////////////////////////////////////
// CLASS Scaler
//
// Description:
//    This class encapsulates the register fields in the scaler portion of
//    the Bt848.
//    A complete set of functions are developed to manipulate all the
//    register fields in the scaler registers for the Bt848.
//
// Methods:
//    See below
//
// Note:
//    For Bt848, instantiate as ...
//       Scaler evenScaler(VF_Even);
//       Scaler oddScaler(VF_Odd);
//
/////////////////////////////////////////////////////////////////////////////

class Scaler
{
    public:
        Scaler(PDEVICE_PARMS);
        ~Scaler();

	void * operator new(size_t size, void * pAllocation) { return(pAllocation);}
	void operator delete(void * pAllocation) {}

		void VideoFormatChanged(VideoFormat);
        void TurnVFilter(State st) { VFilterFlag_ = st; }
                     
        void      Scale(MRect &);
        ErrorCode SetAnalogWin(const MRect &);
        void      GetAnalogWin(MRect &) const;
        ErrorCode SetDigitalWin(const MRect &);
        void      GetDigitalWin(MRect &) const;

        // member functions for VBI support
        virtual void SetVBIEN(BOOL);
        virtual BOOL IsVBIEN();
        virtual void SetVBIFMT(BOOL);
        virtual BOOL IsVBIFMT();

        void      DumpSomeState();

   protected:

		//===========================================================================
		// Scaler registers
		//===========================================================================
		RegisterB regCROP;
		RegField  fieldVDELAY_MSB;
		RegField  fieldVACTIVE_MSB;
		RegField  fieldHDELAY_MSB;
		RegField  fieldHACTIVE_MSB;
		RegisterB regVDELAY_LO;
		RegisterB regVACTIVE_LO;
		RegisterB regHDELAY_LO;
		RegisterB regHACTIVE_LO;
		RegisterB regHSCALE_HI;
		RegField  fieldHSCALE_MSB;
		RegisterB regHSCALE_LO;
		RegisterB regSCLOOP;
		RegField  fieldHFILT;
		RegisterB regVSCALE_HI;
		RegField  fieldVSCALE_MSB;
		RegisterB regVSCALE_LO;
		RegisterB regVTC;
		RegField  fieldVBIEN;
		RegField  fieldVBIFMT;
		RegField  fieldVFILT;
		CompositeReg regVDelay;
		CompositeReg regVActive;
		CompositeReg regVScale;
		CompositeReg regHDelay;
		CompositeReg regHActive;
		CompositeReg regHScale;

		// Since VDelay register in hardware is reversed;
		// i.e. odd reg is really even field and vice versa, need an extra cropping reg
		// for the opposite field
		RegisterB regReverse_CROP;


        VideoInfoStruct * m_ptrVideoIn;
        MRect AnalogWin_;
        MRect DigitalWin_;

        // member functions to set scaling registers
        virtual void SetHActive(MRect &);
        virtual void SetHDelay();
        virtual void SetHScale();
        virtual void SetHFilter();
        virtual void SetVActive();
        virtual void SetVDelay();
        virtual void SetVScale(MRect &);
        virtual void SetVFilter();

    private:
        VideoFormat  m_videoFormat;   // video format

        // this is to battle junk lines at the top of the video
        State VFilterFlag_;

        WORD  m_HActive;  // calcuated intermediate value
        WORD  m_pixels;   // calcuated intermediate value
        WORD  m_lines;    // calcuated intermediate value
        WORD  m_VFilter;  // calcuated intermediate value

};


#endif __SCALER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\bt-829\atibt\xbar.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifdef __cplusplus
extern "C" {
#endif

#include "strmini.h"
#include "ksmedia.h"

#ifdef __cplusplus
}
#endif

#include "capmain.h"
#include "capdebug.h"

#include "device.h"

#include "xbar.h"

BOOL CrossBar::TestRoute(ULONG InPin, ULONG OutPin)
{
   if ((InputPins [InPin].PinType == KS_PhysConn_Video_Tuner ||
        InputPins [InPin].PinType == KS_PhysConn_Video_Composite ||
        InputPins [InPin].PinType == KS_PhysConn_Video_SVideo) &&
        (OutputPins [OutPin].PinType == KS_PhysConn_Video_VideoDecoder)) {
      return TRUE;
   }
   else
      return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\crossbar\atixbar\wdmxbar.h ===
//==========================================================================;
//
//  WDMXBar.H
//  WDM Analog/Video CrossBar MiniDriver. 
//      CWDMAVXBar Class definition.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

#ifndef _WDMXBAR_H_
#define _WDMXBAR_H_

#include "i2script.h"
#include "aticonfg.h"


#define KSPROPERTIES_AVXBAR_NUMBER_SET          1       // CrossBar with no TVAudio
#define KSPROPERTIES_AVXBAR_NUMBER_CROSSBAR     ( KSPROPERTY_CROSSBAR_ROUTE + 1)


typedef struct
{
    UINT                        AudioVideoPinType;
   ULONG                       nRelatedPinNumber;       // for all pins
    ULONG                      nConnectedToPin;        // for output pins only
    PKSPIN_MEDIUM           pMedium;                      // describes hardware connectivity

} XBAR_PIN_INFORMATION, * PXBAR_PIN_INFORMATION;


class CWDMAVXBar
{
public:
    CWDMAVXBar          ( PPORT_CONFIGURATION_INFORMATION pConfigInfo, CI2CScript * pCScript, PUINT puiError);
    ~CWDMAVXBar         ();
    PVOID operator new  ( size_t size_t, PVOID pAllocation);

// Attributes   
private:
    // WDM global topology headers
    GUID                        m_wdmAVXBarTopologyCategory;
    KSTOPOLOGY                  m_wdmAVXBarTopology;
    // WDM global property headers
    KSPROPERTY_ITEM             m_wdmAVXBarPropertiesCrossBar[KSPROPERTIES_AVXBAR_NUMBER_CROSSBAR];
    KSPROPERTY_SET              m_wdmAVXBarPropertySet[KSPROPERTIES_AVXBAR_NUMBER_SET];

    // WDM global stream headers
    HW_STREAM_HEADER            m_wdmAVXBarStreamHeader;

    // configuration properties
    CATIHwConfiguration         m_CATIConfiguration;
    ULONG                       m_nNumberOfVideoInputs;
    ULONG                       m_nNumberOfVideoOutputs;
    ULONG                       m_nNumberOfAudioInputs;
    ULONG                       m_nNumberOfAudioOutputs;

    // power management configuration
    DEVICE_POWER_STATE          m_ulPowerState;

    // pins information
    PKSPIN_MEDIUM               m_pXBarPinsMediumInfo;
    PBOOL                       m_pXBarPinsDirectionInfo;
    PXBAR_PIN_INFORMATION       m_pXBarInputPinsInfo;
    PXBAR_PIN_INFORMATION       m_pXBarOutputPinsInfo;

    // I2C provider properties
    CI2CScript *                m_pI2CScript;

// Implementation
public:
    BOOL        AdapterUnInitialize             ( PHW_STREAM_REQUEST_BLOCK pSrb);
    BOOL        AdapterGetStreamInfo            ( PHW_STREAM_REQUEST_BLOCK pSrb);
    BOOL        AdapterQueryUnload              ( PHW_STREAM_REQUEST_BLOCK pSrb);
    BOOL        AdapterGetProperty              ( PHW_STREAM_REQUEST_BLOCK pSrb);
    BOOL        AdapterSetProperty              ( PHW_STREAM_REQUEST_BLOCK pSrb);
    NTSTATUS    AdapterCompleteInitialization   ( PHW_STREAM_REQUEST_BLOCK pSrb);
    NTSTATUS    AdapterSetPowerState            ( PHW_STREAM_REQUEST_BLOCK pSrb);
    
    // the functions for asynchronous operations completion
    void        UpdateAudioConnectionAfterChange( void);

private:
    void        SetWDMAVXBarKSProperties        ( void);
    void        SetWDMAVXBarKSTopology          ( void);
};


#endif  // _WDMXBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\crossbar\atixbar\atixbar.h ===
//==========================================================================;
//
//	ATIXBar.H
//	WDM Analog/Video CrossBar MiniDriver. 
//		AllInWonder/AllInWonderPro hardware platform. 
//			Main Include Module.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

#ifndef _ATIXBAR_H_
#define _ATIXBAR_H_

#include "wdmxbar.h"
#include "pinmedia.h"

typedef struct
{
	CI2CScript		CScript;
	CWDMAVXBar		CAVXBar;

	PDEVICE_OBJECT	PhysicalDeviceObject;

	// for managing SRB Queue and internal driver synchronization
	BOOL			bSrbInProcess;
	LIST_ENTRY		adapterSrbQueueHead;
	KSPIN_LOCK		adapterSpinLock;

} ADAPTER_DATA_EXTENSION, * PADAPTER_DATA_EXTENSION;


typedef struct
{
	// please, don't move this member from its first place in the structure
	// if you do, change the code to use FIELDOFFSET macro to retrieve pSrb
	// member offset within this structure. The code as it's written assumes
	// LIST_ENTRY * == SRB_DATA_EXTENSION *
	LIST_ENTRY					srbListEntry;
	PHW_STREAM_REQUEST_BLOCK	pSrb;

} SRB_DATA_EXTENSION, * PSRB_DATA_EXTENSION;


/*
	Call-backs from the StreamClass
*/
extern "C"
void STREAMAPI XBarReceivePacket				( PHW_STREAM_REQUEST_BLOCK pSrb);
extern "C"
void STREAMAPI XBarCancelPacket					( PHW_STREAM_REQUEST_BLOCK pSrb);
extern "C" 
void STREAMAPI XBarTimeoutPacket				( PHW_STREAM_REQUEST_BLOCK pSrb);



/*
	Local prototypes
*/
void XBarAdapterInitialize						( PHW_STREAM_REQUEST_BLOCK pSrb);


#endif	// _ATIXBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\tuners\1236\atitunep.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//	ATITuneP.H
//	WDM Tuner MiniDriver. 
//		Philips Tuner. 
//			Main Include Module.
//
//==========================================================================;

#ifndef _ATITUNEP_H_
#define _ATITUNEP_H_

#include "wdmtuner.h"

typedef struct
{
	CI2CScript		CScript;
	CATIWDMTuner	CTuner;

	PDEVICE_OBJECT	PhysicalDeviceObject;

	// for managing SRB Queue and internal driver synchronization
	BOOL			bSrbInProcess;
	LIST_ENTRY		adapterSrbQueueHead;
	KSPIN_LOCK		adapterSpinLock;

} ADAPTER_DATA_EXTENSION, * PADAPTER_DATA_EXTENSION;


typedef struct
{
	// please, don't move this member from its first place in the structure
	// if you do, change the code to use FIELDOFFSET macro to retrieve pSrb
	// member offset within this structure. The code as it's written assumes
	// LIST_ENTRY * == SRB_DATA_EXTENSION *
	LIST_ENTRY					srbListEntry;
	PHW_STREAM_REQUEST_BLOCK	pSrb;

} SRB_DATA_EXTENSION, * PSRB_DATA_EXTENSION;


/*
	Call-backs from the StreamClass
*/
extern "C"
void STREAMAPI TunerReceivePacket				( PHW_STREAM_REQUEST_BLOCK pSrb);
extern "C"
void STREAMAPI TunerCancelPacket				( PHW_STREAM_REQUEST_BLOCK pSrb);
extern "C" 
void STREAMAPI TunerTimeoutPacket				( PHW_STREAM_REQUEST_BLOCK pSrb);



/*
	Local prototypes
*/
void TunerAdapterInitialize						( PHW_STREAM_REQUEST_BLOCK pSrb);


#endif	// _ATITUNEP_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\crossbar\atixbar\atixbar.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//  ATIXBar.CPP
//  WDM Video/Audio CrossBar MiniDriver. 
//      AllInWonder/AllInWonderPro hardware platform.
//          Main Source Module.
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "atixbar.h"
#include "wdmdrv.h"



/*^^*
 *      DriverEntry()
 * Purpose  : Called when an SRB_INITIALIZE_DEVICE request is received
 *
 * Inputs   : PVOID Arg1, PVOID Arg2
 *
 * Outputs  : result of StreamClassregisterAdapter()
 * Author   : IKLEBANOV
 *^^*/
extern "C" 
ULONG DriverEntry ( IN PDRIVER_OBJECT   pDriverObject,
                    IN PUNICODE_STRING  pRegistryPath )
//ULONG DriverEntry( PVOID Arg1, PVOID Arg2)
{
    HW_INITIALIZATION_DATA HwInitData;

    SetMiniDriverDebugLevel( pRegistryPath);
    
    OutputDebugTrace(( "ATIXBar: DriverEntry\n"));
     
    RtlZeroMemory( &HwInitData, sizeof( HwInitData));

    HwInitData.HwInitializationDataSize = sizeof(HwInitData);

    // Entry points for Port Driver

    HwInitData.HwInterrupt                  = NULL; // HwInterrupt;

    HwInitData.HwReceivePacket              = XBarReceivePacket;
    HwInitData.HwCancelPacket               = XBarCancelPacket;
    HwInitData.HwRequestTimeoutHandler      = XBarTimeoutPacket;

    HwInitData.DeviceExtensionSize          = sizeof( ADAPTER_DATA_EXTENSION);
    HwInitData.PerRequestExtensionSize      = sizeof( SRB_DATA_EXTENSION); 
    HwInitData.FilterInstanceExtensionSize  = 0;
    HwInitData.PerStreamExtensionSize       = 0;
    HwInitData.BusMasterDMA                 = FALSE;  
    HwInitData.Dma24BitAddresses            = FALSE;
    HwInitData.BufferAlignment              = 3;
//  HwInitData.TurnOffSynchronization       = FALSE;
    // we turn the synchronization ON. StreamClass is expected to call the MiniDriver
    // at passive level only
    HwInitData.TurnOffSynchronization       = TRUE;
    HwInitData.DmaBufferSize                = 0;

    OutputDebugTrace(( "ATIXBar: StreamClassRegisterAdapter\n"));

//  return( StreamClassRegisterAdapter( Arg1, Arg2, &HwInitData));
    return( StreamClassRegisterAdapter( pDriverObject, pRegistryPath, &HwInitData));
}



/*^^*
 *      XbarReceivePacket()
 * Purpose  : Main entry point for receiving adapter based request SRBs from the Class Driver.
 *              Will always be called at passive level, because the drivers
 *              turned the synchronization ON.
 * Note     : This is an asyncronous entry point. The request only completes when a 
 *              StreamClassDeviceNotification on this SRB, of type  DeviceRequestComplete,
 *              is issued. As soon we're running at passive level, we can do everything 
 *              synchronously during the response to the SRBs with no worry
 *              to block somebody else for a long timer during I2C access
 *
 * Inputs   : PHW_STREAM_REQUEST_BLOCK pSrb : pointer to the current Srb
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
extern "C" 
void STREAMAPI XBarReceivePacket( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    CWDMAVXBar *            pCAVXBar;
    KIRQL                   irqlCurrent;
    PADAPTER_DATA_EXTENSION pPrivateData = ( PADAPTER_DATA_EXTENSION)( pSrb->HwDeviceExtension);
    PSRB_DATA_EXTENSION     pSrbPrivate = ( PSRB_DATA_EXTENSION)( pSrb->SRBExtension);

    // check the device extension pointer
    if(( pPrivateData == NULL) || ( pSrbPrivate == NULL))
    {
        TRAP;
        pSrb->Status = STATUS_INVALID_PARAMETER;
        StreamClassDeviceNotification( DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
    }

    OutputDebugInfo(( "ATIXBar: XBarReceivePacket() SRB = %x\n", pSrb));

    if( pSrb->Command == SRB_INITIALIZE_DEVICE)
    {
        // this is the special case for SRB_INITIALIZE_DEVICE, because
        // no Queue has been initialized yet. Everything we need later on
        // is initialized during this SRB response
        XBarAdapterInitialize( pSrb);

        StreamClassDeviceNotification( DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
        return;
    }

    // the rest of the SRBs are coming after SpinLock and SRBQueue have been initialized
    // during DRB_INITIALIZE_DEVICE SRB response.
    // I'll insert the SRB in the Queue first of all. The processing SRB from the Queue
    // can be triggered by finishing processing and SRB, or by the fact there is no SRB
    // is in process down here
    pSrbPrivate->pSrb = pSrb;

    // Everything we're doing with the Queue has to be protected from being interrupted
    KeAcquireSpinLock( &pPrivateData->adapterSpinLock, &irqlCurrent);
    InsertTailList( &pPrivateData->adapterSrbQueueHead, &pSrbPrivate->srbListEntry);

    if( pPrivateData->bSrbInProcess)
    {
        // there is another SRB being processed, and the new one will be picked up from
        // the Queue when it's its turn.
        KeReleaseSpinLock( &pPrivateData->adapterSpinLock, irqlCurrent);
        return;
    }

    while( !IsListEmpty( &pPrivateData->adapterSrbQueueHead))
    {
        // turn on the semaphore for the others coming after
        pPrivateData->bSrbInProcess = TRUE;

        // be carefull here, if you've changed the place where srbListEntry is defined
        // within the SRB_DATA_EXTENSION structure
        pSrbPrivate = ( PSRB_DATA_EXTENSION)RemoveHeadList( &pPrivateData->adapterSrbQueueHead);
        KeReleaseSpinLock( &pPrivateData->adapterSpinLock, irqlCurrent);

        // here is the place to process the SRB we have retrieved from the Queue
        pSrb = pSrbPrivate->pSrb;
        pPrivateData = ( PADAPTER_DATA_EXTENSION)( pSrb->HwDeviceExtension);
        pCAVXBar = &pPrivateData->CAVXBar;

        ASSERT( pSrb->Status != STATUS_CANCELLED);

        switch( pSrb->Command)
        {
            case SRB_INITIALIZATION_COMPLETE:
                // StreamClass has completed the initialization
                pSrb->Status = pCAVXBar->AdapterCompleteInitialization( pSrb);
                break;

            case SRB_UNINITIALIZE_DEVICE:
                // close the device.  
                pCAVXBar->AdapterUnInitialize( pSrb);
                break;

            case SRB_OPEN_STREAM:
            case SRB_CLOSE_STREAM:
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_GET_STREAM_INFO:
                // return a block describing STREAM_INFO_HEADER and all the streams supported
                pCAVXBar->AdapterGetStreamInfo( pSrb);
                break;

            case SRB_CHANGE_POWER_STATE:
                pSrb->Status = pCAVXBar->AdapterSetPowerState( pSrb);
                break;

            case SRB_GET_DEVICE_PROPERTY:
                if( pCAVXBar->AdapterGetProperty( pSrb))
                    pSrb->Status = STATUS_SUCCESS;
                else
                    pSrb->Status = STATUS_INVALID_PARAMETER;
                break;        

            case SRB_SET_DEVICE_PROPERTY:
                if( pCAVXBar->AdapterSetProperty( pSrb))
                    pSrb->Status = STATUS_SUCCESS;
                else
                    pSrb->Status = STATUS_INVALID_PARAMETER;
                break;

            // We should never get the following since this is a single instance device
            case SRB_OPEN_DEVICE_INSTANCE:
            case SRB_CLOSE_DEVICE_INSTANCE:
                TRAP
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_UNKNOWN_DEVICE_COMMAND:
                // we know we're getting some of these. Why should we?
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            default:
                // TRAP
                // this is a request that we do not understand.  Indicate invalid command and complete the request
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
        }

        StreamClassDeviceNotification( DeviceRequestComplete, pPrivateData, pSrb);

        KeAcquireSpinLock( &pPrivateData->adapterSpinLock, &irqlCurrent);
    }

    // turn off the semaphore to enable the others coming after
    pPrivateData->bSrbInProcess = FALSE;

    KeReleaseSpinLock( &pPrivateData->adapterSpinLock, irqlCurrent);
    // there is no other SRB being processed at this time, let's start processing

}


extern "C" 
void STREAMAPI XBarCancelPacket( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{

    pSrb->Status = STATUS_CANCELLED;
}


extern "C" 
void STREAMAPI XBarTimeoutPacket( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{

    // not sure what to do here.
}


/*^^*
 *      XBarAdapterInitialize()
 * Purpose  : Called when SRB_INITIALIZE_DEVICE SRB is received.
 *              Performs checking of the hardware presence and I2C provider availability.
 *              Sets the hardware in an initial state.
 * Note     : The request does not completed unless we know everything
 *              about the hardware and we are sure it is capable to work in the current configuration.
 *              The hardware Caps are also aquised at this point. As soon this
 *              function is called at passive level, do everything synchronously
 *
 * Inputs   : PHW_STREAM_REQUEST_BLOCK pSrb : pointer to the current Srb
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
void XBarAdapterInitialize( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;
    PADAPTER_DATA_EXTENSION pPrivateData = ( PADAPTER_DATA_EXTENSION)( pConfigInfo->HwDeviceExtension);
    NTSTATUS        ntStatus = STATUS_NO_SUCH_DEVICE;
    CWDMAVXBar *    pCAVXBar;
    CI2CScript *    pCScript = NULL;
    UINT            nErrorCode;

    OutputDebugTrace(( "ATIXBar: XBarAdapterInitialize()\n"));

    ENSURE
    {
        if( pConfigInfo->NumberOfAccessRanges != 0) 
        {
            OutputDebugError(( "ATIXBar: illegal NumberOfAccessRanges = %lx\n", pConfigInfo->NumberOfAccessRanges));
            FAIL;
        }

        // if we have I2CProvider implemented inside the MiniVDD, we have to
        // get a pointer to I2CInterface from the Provider.

        // There is an overloaded operator new provided for the CI2CScript Class.
        pCScript = ( CI2CScript *)new(( PVOID)&pPrivateData->CScript)
                        CI2CScript( pConfigInfo, &nErrorCode);
        if( nErrorCode != WDMMINI_NOERROR)
        {
            OutputDebugError(( "ATIXBar: CI2CScript creation failure = %lx\n", nErrorCode));
            FAIL;
        }
        
        // The CI2CScript object was created successfully.
        // We'll try to allocate I2CProvider here for future possible I2C
        // operations needed at Initialization time.
        if( !pCScript->LockI2CProviderEx())
        {
            OutputDebugError(( "ATIXBar: unable to lock I2CProvider"));
            FAIL;
        }

        // we did lock the provider.
        // There is an overloaded operator new provided for the CWDMAVXBar Class.
        pCAVXBar = ( CWDMAVXBar *)new(( PVOID)&pPrivateData->CAVXBar) CWDMAVXBar( pConfigInfo, pCScript, &nErrorCode);
        if( nErrorCode)
        {
            OutputDebugError(( "ATIXBar: CWDMAVXBar constructor failure = %lx\n", nErrorCode));
            FAIL;
        }

        InitializeListHead ( &pPrivateData->adapterSrbQueueHead);
        KeInitializeSpinLock ( &pPrivateData->adapterSpinLock);

        pPrivateData->PhysicalDeviceObject = pConfigInfo->RealPhysicalDeviceObject;
        // no streams are supported
        pConfigInfo->StreamDescriptorSize = sizeof( HW_STREAM_HEADER);

        OutputDebugTrace(( "XBarAdapterInitialize(): exit\n"));

        ntStatus = STATUS_SUCCESS;

    } END_ENSURE;

    if (pCScript)
        pCScript->ReleaseI2CProvider();

    pSrb->Status = ntStatus;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\crossbar\atixbar\xbarprop.cpp ===
//==========================================================================;
//
//  XBarProp.CPP
//  WDM Audio/Video CrossBar MiniDriver. 
//      AIW hardware platform. 
//          WDM Properties management.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "wdmdrv.h"
#include "atixbar.h"
#include "aticonfg.h"




/*^^*
 *      AdapterGetProperty()
 * Purpose  : Called when SRB_GET_PROPERTY SRB is received.
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : BOOL : returns returns FALSE, if it is not a XBar property
 *              it also returns the required property
 * Author   : IKLEBANOV
 *^^*/
BOOL CWDMAVXBar::AdapterGetProperty( PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSpd = pSrb->CommandData.PropertyInfo;
    ULONG uiPropertyId = pSpd->Property->Id;                // index of the property

    if( !::IsEqualGUID(( const struct _GUID &)PROPSETID_VIDCAP_CROSSBAR, ( const struct _GUID &)pSpd->Property->Set))
        return( FALSE);

    OutputDebugInfo(( "CWDMAVXBar:AdapterGetProperty() Id = %d\n", uiPropertyId));

    switch( uiPropertyId)
    {
    case KSPROPERTY_CROSSBAR_CAPS:
        ASSERT( pSpd->PropertyOutputSize >= sizeof( PKSPROPERTY_CROSSBAR_CAPS_S));
        {
            PKSPROPERTY_CROSSBAR_CAPS_S pAVXBarCaps = ( PKSPROPERTY_CROSSBAR_CAPS_S)pSpd->PropertyInfo;

            // Copy the input property info to the output property info
            ::RtlCopyMemory( pAVXBarCaps, pSpd->Property, sizeof( KSPROPERTY));

            pAVXBarCaps->NumberOfInputs = m_nNumberOfVideoInputs + m_nNumberOfAudioInputs;
            pAVXBarCaps->NumberOfOutputs = m_nNumberOfVideoOutputs + m_nNumberOfAudioOutputs;

        }
        pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_CROSSBAR_CAPS_S);
        break;

    case KSPROPERTY_CROSSBAR_PININFO:
        ASSERT( pSpd->PropertyOutputSize >= sizeof( KSPROPERTY_CROSSBAR_PININFO_S));
        {
            PKSPROPERTY_CROSSBAR_PININFO_S pPinInfo = ( PKSPROPERTY_CROSSBAR_PININFO_S)pSpd->PropertyInfo;
            ULONG nPinIndex;

            // Copy the input property info to the output property info
            ::RtlCopyMemory( pPinInfo, pSpd->Property, sizeof( KSPROPERTY_CROSSBAR_PININFO_S));

            nPinIndex = pPinInfo->Index;

            if( pPinInfo->Direction == KSPIN_DATAFLOW_IN)
            {
                // input pin info is required
                if ( nPinIndex < m_nNumberOfVideoInputs + m_nNumberOfAudioInputs)
                {
                    pPinInfo->RelatedPinIndex = m_pXBarInputPinsInfo[nPinIndex].nRelatedPinNumber;
                    pPinInfo->PinType = m_pXBarInputPinsInfo[nPinIndex].AudioVideoPinType;
                    pPinInfo->Medium  = * m_pXBarInputPinsInfo[nPinIndex].pMedium;
                }
                else
                    return ( FALSE);
            }
            else
            {
                // output pin info is required
                if ( nPinIndex < m_nNumberOfVideoOutputs + m_nNumberOfAudioOutputs)
                {
                    pPinInfo->RelatedPinIndex = m_pXBarOutputPinsInfo[nPinIndex].nRelatedPinNumber;
                    pPinInfo->PinType = m_pXBarOutputPinsInfo[nPinIndex].AudioVideoPinType;
                    pPinInfo->Medium  = * m_pXBarOutputPinsInfo[nPinIndex].pMedium;
                }
                else
                    return ( FALSE);
            }
        }
        pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_CROSSBAR_PININFO_S);
        break;

    case KSPROPERTY_CROSSBAR_CAN_ROUTE:
        ASSERT( pSpd->PropertyOutputSize >= sizeof( KSPROPERTY_CROSSBAR_ROUTE_S));
        {
            PKSPROPERTY_CROSSBAR_ROUTE_S pRouteInfo = ( PKSPROPERTY_CROSSBAR_ROUTE_S)pSpd->PropertyInfo;
            ULONG nInputPin, nOutputPin;
            int nAudioSource;

            // Copy the input property info to the output property info
            ::RtlCopyMemory( pRouteInfo, pSpd->Property, sizeof( KSPROPERTY_CROSSBAR_ROUTE_S));

            nInputPin = pRouteInfo->IndexInputPin;
            nOutputPin = pRouteInfo->IndexOutputPin;

            if( nInputPin != -1)
            {
                if(( nInputPin < ( m_nNumberOfVideoInputs + m_nNumberOfAudioInputs)) && 
                    ( nOutputPin < ( m_nNumberOfVideoOutputs + m_nNumberOfAudioOutputs)))
                {
                    // both input and output pins index are valid
                    if(( m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType <= KS_PhysConn_Video_SCART) &&
                        ( m_pXBarOutputPinsInfo[nOutputPin].AudioVideoPinType <= KS_PhysConn_Video_SCART))
                    {
                        // Video pins connection is required
                        pRouteInfo->CanRoute = ( m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType ==
                            m_pXBarOutputPinsInfo[nOutputPin].AudioVideoPinType);
                    }
                    else    // is video pins connection required?
                    {
                        if(( m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType >= KS_PhysConn_Audio_Tuner) && 
                            ( m_pXBarOutputPinsInfo[nOutputPin].AudioVideoPinType >= KS_PhysConn_Audio_Tuner))
                        {
                            // Audio pins connection is required
                            switch( m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType)
                            {
                            case KS_PhysConn_Audio_Line:
                                nAudioSource = AUDIOSOURCE_LINEIN;
                                break;

                            case KS_PhysConn_Audio_Tuner:
                                nAudioSource = AUDIOSOURCE_TVAUDIO;
                                break;

                            default:
                                TRAP;
                                return( FALSE);
                            }

                            pRouteInfo->CanRoute = m_CATIConfiguration.CanConnectAudioSource( nAudioSource);
                        }
                        else
                            // mixed video - audio connection is required
                            pRouteInfo->CanRoute = FALSE;
                    }
                }
                else    // are the pins index valid?
                {
                    // either input and output pins index is invalid
                    TRAP;
                    OutputDebugError(( "CWDMAVXBar:Get...CAN_ROUTE() InPin = %d, OutPin = %d\n",
                        nInputPin, nOutputPin));
                    return( FALSE);
                }
            }
            else    // if( nInputPin != -1)
            {
                // There is a new notion of nInputPin = -1. It's valid only for Audio muting
                if( nOutputPin < ( m_nNumberOfVideoOutputs + m_nNumberOfAudioOutputs))
                {
                    if( m_pXBarOutputPinsInfo[nOutputPin].AudioVideoPinType >= KS_PhysConn_Audio_Tuner)
                        pRouteInfo->CanRoute = m_CATIConfiguration.CanConnectAudioSource( AUDIOSOURCE_MUTE);
                    else
                        // we support muting for Audio output pin only
                        pRouteInfo->CanRoute = FALSE;
                }
                else
                {
                    // output pin index is invalid
                    TRAP;
                    OutputDebugError(( "CWDMAVXBar:Get...CAN_ROUTE() InPin = %d, OutPin = %d\n",
                        nInputPin, nOutputPin));
                    return( FALSE);
                }
            }
        }
        pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_CROSSBAR_ROUTE_S);
        break;

    case KSPROPERTY_CROSSBAR_ROUTE:
        ASSERT( pSpd->PropertyOutputSize >= sizeof( KSPROPERTY_CROSSBAR_ROUTE_S));
        {
            PKSPROPERTY_CROSSBAR_ROUTE_S pRouteInfo = ( PKSPROPERTY_CROSSBAR_ROUTE_S)pSpd->PropertyInfo;
            ULONG nOutputPin;

            // Copy the input property info to the output property info
            ::RtlCopyMemory( pRouteInfo, pSpd->Property, sizeof( KSPROPERTY_CROSSBAR_ROUTE_S));

            nOutputPin = pRouteInfo->IndexOutputPin;

            if( nOutputPin < m_nNumberOfVideoOutputs + m_nNumberOfAudioOutputs)
                pRouteInfo->IndexInputPin = m_pXBarOutputPinsInfo[nOutputPin].nConnectedToPin;
            else
            {
                TRAP;
                OutputDebugError(( "CWDMAVXBar:Get...ROUTE() OutPin = %d\n",
                    nOutputPin));
                pRouteInfo->IndexInputPin = -1;
            }
        }
        pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_CROSSBAR_ROUTE_S);
        break;

    default:
        TRAP;
        return( FALSE);
    }

    return( TRUE);
}



/*^^*
 *      AdapterSetProperty()
 * Purpose  : Called when SRB_GET_PROPERTY SRB is received.
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : BOOL : returns FALSE, if it is not a XBar property
 *              it also sets the required property
 * Author   : IKLEBANOV
 *^^*/
BOOL CWDMAVXBar::AdapterSetProperty( PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSpd = pSrb->CommandData.PropertyInfo;
    ULONG   uiPropertyId = pSpd->Property->Id;          // index of the property
    BOOL    bResult = TRUE;

    if( !::IsEqualGUID( ( const struct _GUID &)PROPSETID_VIDCAP_CROSSBAR, ( const struct _GUID &)pSpd->Property->Set))
        return( FALSE);

    OutputDebugInfo(( "CWDMAVXBar:AdapterSetProperty() Id = %d\n", uiPropertyId));

    switch( uiPropertyId)
    {
        case KSPROPERTY_CROSSBAR_ROUTE:
            ASSERT( pSpd->PropertyOutputSize >= sizeof( KSPROPERTY_CROSSBAR_ROUTE_S));
            {
                PKSPROPERTY_CROSSBAR_ROUTE_S pRouteInfo = ( PKSPROPERTY_CROSSBAR_ROUTE_S)pSpd->PropertyInfo;
                ULONG nInputPin, nOutputPin;
                int nAudioSource;

                // Copy the input property info to the output property info
                ::RtlCopyMemory( pRouteInfo, pSpd->Property, sizeof( KSPROPERTY_CROSSBAR_ROUTE_S));

                nInputPin = pRouteInfo->IndexInputPin;
                nOutputPin = pRouteInfo->IndexOutputPin;

                if( nInputPin != -1)
                {
                    if(( nInputPin < ( m_nNumberOfVideoInputs + m_nNumberOfAudioInputs)) && 
                        ( nOutputPin < ( m_nNumberOfVideoOutputs + m_nNumberOfAudioOutputs)))
                    {
                        // both input and output pins index are valid
                        if(( m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType <= KS_PhysConn_Video_SCART) &&
                            ( m_pXBarOutputPinsInfo[nOutputPin].AudioVideoPinType <= KS_PhysConn_Video_SCART))
                        {
                            // Video pins connection is required
                            pRouteInfo->CanRoute = ( m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType ==
                                m_pXBarOutputPinsInfo[nOutputPin].AudioVideoPinType);
                        }
                        else    // is video pins connection required?
                        {
                            if(( m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType >= KS_PhysConn_Audio_Tuner) && 
                                ( m_pXBarOutputPinsInfo[nOutputPin].AudioVideoPinType >= KS_PhysConn_Audio_Tuner))
                            {
                                // Audio pins connection is required
                                switch( m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType)
                                {
                                    case KS_PhysConn_Audio_Line:
                                        nAudioSource = AUDIOSOURCE_LINEIN;
                                        break;

                                    case KS_PhysConn_Audio_Tuner:
                                        nAudioSource = AUDIOSOURCE_TVAUDIO;
                                        break;

                                    default:
                                        TRAP;
                                        return( FALSE);
                                }

                                if( m_pXBarOutputPinsInfo[nOutputPin].nConnectedToPin == nInputPin)
                                    // the connection has been made already
                                    pRouteInfo->CanRoute = TRUE;
                                else    // are Audio pins connected already?
                                {
                                    // the connection has to be made
                                    pRouteInfo->CanRoute = m_CATIConfiguration.CanConnectAudioSource( nAudioSource);
                                    if( pRouteInfo->CanRoute)
                                    {
                                        if( m_CATIConfiguration.ConnectAudioSource( m_pI2CScript,
                                                                                    nAudioSource))
                                        {
                                            // update driver state after routing
                                            m_pXBarOutputPinsInfo[nOutputPin].nConnectedToPin = nInputPin;
                                            m_pXBarOutputPinsInfo[nOutputPin].nRelatedPinNumber = m_pXBarInputPinsInfo[nInputPin].nRelatedPinNumber;
                                        }
                                        else
                                            bResult = FALSE;
                                    }
                                }
                            }
                            else
                                // mixed audio - video connection is required, fail
                                pRouteInfo->CanRoute = FALSE;
                        }
                    }
                    else    // are the pins index valid?
                    {
                        // either input and output pins index is invalid
                        TRAP;
                        OutputDebugError(( "CWDMAVXBar:Set...ROUTE() In = %d, Out = %d\n",
                            nInputPin, nOutputPin));
                        return( FALSE);
                    }
                }
                else    // if( nInputPin != -1)
                {
                    // There is a new notion of nInputPin = -1. It's valid only for Audio muting
                    if( nOutputPin < ( m_nNumberOfVideoOutputs + m_nNumberOfAudioOutputs))
                    {
                        if( m_pXBarOutputPinsInfo[nOutputPin].AudioVideoPinType >= KS_PhysConn_Audio_Tuner)
                            if( m_pXBarOutputPinsInfo[nOutputPin].nConnectedToPin == nInputPin)
                                // the connection has been made already
                                pRouteInfo->CanRoute = TRUE;
                            else    // are Audio pins connected already?
                            {
                                // the connection has to be made
                                pRouteInfo->CanRoute = m_CATIConfiguration.CanConnectAudioSource( AUDIOSOURCE_MUTE);
                                if( pRouteInfo->CanRoute)
                                {
                                    if( m_CATIConfiguration.ConnectAudioSource( m_pI2CScript,
                                                                                AUDIOSOURCE_MUTE))
                                    // update driver state after routing
                                        m_pXBarOutputPinsInfo[nOutputPin].nConnectedToPin = nInputPin;
                                    else
                                        bResult = FALSE;
                                }
                            }
                        else
                            // we support muting for Audio output pin only
                            pRouteInfo->CanRoute = FALSE;
                    }
                    else
                    {
                        // output pin index is invalid
                        TRAP;
                        OutputDebugError(( "CWDMAVXBar:Get...CAN_ROUTE() InPin = %d, OutPin = %d\n",
                            nInputPin, nOutputPin));
                        return( FALSE);
                    }
                }
            }

            pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_CROSSBAR_ROUTE_S);
            break;

        default:
            TRAP;
            return( FALSE);
    }

    return( bResult);
}



/*^^*
 *      SetWDMAVXBarKSTopology()
 * Purpose  : Sets the KSTopology structure
 *              Called during CWDMAVXBar class construction time.
 *
 * Inputs   : none
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
void CWDMAVXBar::SetWDMAVXBarKSTopology( void)
{
    GUID wdmXBarTopologyCategory[] =
    {
        STATIC_KSCATEGORY_CROSSBAR
    };
    
    ::RtlCopyMemory( &m_wdmAVXBarTopologyCategory, wdmXBarTopologyCategory, sizeof( wdmXBarTopologyCategory));

    m_wdmAVXBarTopology.CategoriesCount = 1;
    m_wdmAVXBarTopology.Categories = &m_wdmAVXBarTopologyCategory;
    m_wdmAVXBarTopology.TopologyNodesCount = 0;
    m_wdmAVXBarTopology.TopologyNodes = NULL;
    m_wdmAVXBarTopology.TopologyConnectionsCount = 0;
    m_wdmAVXBarTopology.TopologyConnections = NULL;
}



/*^^*
 *      SetWDMAVXBarProperties()
 * Purpose  : Sets the KSProperty structures array
 *              Called during CWDMAVXBar class construction time.
 *
 * Inputs   : none
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
void CWDMAVXBar::SetWDMAVXBarKSProperties( void)
{

    DEFINE_KSPROPERTY_TABLE( wdmAVXBarPropertiesCrossBar)
    {
        DEFINE_KSPROPERTY_ITEM                              
        (
            KSPROPERTY_CROSSBAR_CAPS,                       // 1
            TRUE,                                           // GetSupported or Handler
            sizeof(KSPROPERTY_CROSSBAR_CAPS_S),             // MinProperty
            sizeof(KSPROPERTY_CROSSBAR_CAPS_S),             // MinData
            FALSE,                                          // SetSupported or Handler
            NULL,                                           // Values
            0,                                              // RelationsCount
            NULL,                                           // Relations
            NULL,                                           // SupportHandler
            sizeof( ULONG)                                  // SerializedSize
        ),
        DEFINE_KSPROPERTY_ITEM                              
        (
            KSPROPERTY_CROSSBAR_PININFO,                        // 1
            TRUE,                                           // GetSupported or Handler
            sizeof(KSPROPERTY_CROSSBAR_PININFO_S),          // MinProperty
            sizeof(KSPROPERTY_CROSSBAR_PININFO_S),          // MinData
            FALSE,                                          // SetSupported or Handler
            NULL,                                           // Values
            0,                                              // RelationsCount
            NULL,                                           // Relations
            NULL,                                           // SupportHandler
            0                                               // SerializedSize
        ),
        DEFINE_KSPROPERTY_ITEM                              
        (
            KSPROPERTY_CROSSBAR_CAN_ROUTE,                  // 1
            TRUE,                                           // GetSupported or Handler
            sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),            // MinProperty
            sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),            // MinData
            FALSE,                                          // SetSupported or Handler
            NULL,                                           // Values
            0,                                              // RelationsCount
            NULL,                                           // Relations
            NULL,                                           // SupportHandler
            sizeof( ULONG)                                  // SerializedSize
        ),
        DEFINE_KSPROPERTY_ITEM                              
        (
            KSPROPERTY_CROSSBAR_ROUTE,                      // 1
            TRUE,                                           // GetSupported or Handler
            sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),            // MinProperty
            sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),            // MinData
            TRUE,                                           // SetSupported or Handler
            NULL,                                           // Values
            0,                                              // RelationsCount
            NULL,                                           // Relations
            NULL,                                           // SupportHandler
            sizeof( ULONG)                                  // SerializedSize
        )
    };

    DEFINE_KSPROPERTY_SET_TABLE( wdmAVXBarPropertySet)
    {
        DEFINE_KSPROPERTY_SET
        (
            &PROPSETID_VIDCAP_CROSSBAR,                     // Set
            KSPROPERTIES_AVXBAR_NUMBER_CROSSBAR,            // PropertiesCount
            m_wdmAVXBarPropertiesCrossBar,                  // PropertyItems
            0,                                              // FastIoCount
            NULL                                            // FastIoTable
        )
    };

    ::RtlCopyMemory( m_wdmAVXBarPropertiesCrossBar, wdmAVXBarPropertiesCrossBar, sizeof( wdmAVXBarPropertiesCrossBar));
    ::RtlCopyMemory( &m_wdmAVXBarPropertySet, wdmAVXBarPropertySet, sizeof( wdmAVXBarPropertySet));
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\tuners\1236\atitunep.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//  ATITuneP.CPP
//  WDM Tuner MiniDriver. 
//      Philips Tuner. 
//          Main Source Module.
//
//      $Date:   01 Apr 1998 12:59:30  $
//  $Revision:   1.2  $
//    $Author:   KLEBANOV  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "wdmdrv.h"
#include "atitunep.h"



/*^^*
 *      DriverEntry()
 * Purpose  : Called when an SRB_INITIALIZE_DEVICE request is received
 *
 * Inputs   : PVOID Arg1, PVOID Arg2
 *
 * Outputs  : result of StreamClassregisterAdapter()
 * Author   : IKLEBANOV
 *^^*/
extern "C" 
ULONG DriverEntry ( IN PDRIVER_OBJECT   pDriverObject,
                    IN PUNICODE_STRING  pRegistryPath)
//ULONG DriverEntry( PVOID Arg1, PVOID Arg2)
{
    HW_INITIALIZATION_DATA HwInitData;

    SetMiniDriverDebugLevel( pRegistryPath);
    
    OutputDebugTrace(( "ATITuneP: DriverEntry\n"));
     
    RtlZeroMemory( &HwInitData, sizeof( HwInitData));

    HwInitData.HwInitializationDataSize = sizeof( HwInitData);

    // Entry points for Port Driver

    HwInitData.HwInterrupt                  = NULL; // HwInterrupt;

    HwInitData.HwReceivePacket              = TunerReceivePacket;
    HwInitData.HwCancelPacket               = TunerCancelPacket;
    HwInitData.HwRequestTimeoutHandler      = TunerTimeoutPacket;

    HwInitData.DeviceExtensionSize          = sizeof( ADAPTER_DATA_EXTENSION);
    HwInitData.PerRequestExtensionSize      = sizeof( SRB_DATA_EXTENSION); 
    HwInitData.FilterInstanceExtensionSize  = 0;
    HwInitData.PerStreamExtensionSize       = 0;
    HwInitData.BusMasterDMA                 = FALSE;  
    HwInitData.Dma24BitAddresses            = FALSE;
    HwInitData.BufferAlignment              = 3;
//  HwInitData.TurnOffSynchronization       = FALSE;
    // we turn the synchronization ON. StreamClass is expected to call the MiniDriver
    // at passive level only
    HwInitData.TurnOffSynchronization       = TRUE;
    HwInitData.DmaBufferSize                = 0;

    OutputDebugTrace(( "ATITuneP: StreamClassRegisterAdapter\n"));

//  return( StreamClassRegisterAdapter( Arg1, Arg2, &HwInitData));
    return( StreamClassRegisterAdapter( pDriverObject, pRegistryPath, &HwInitData));
}



/*^^*
 *      TunerReceivePacket()
 * Purpose  : Main entry point for receiving adapter based request SRBs from the Class Driver.
 *              Will always be called at passive level, because the drivers
 *              turned the synchronization ON.
 * Note     : This is an asyncronous entry point. The request only completes when a 
 *              StreamClassDeviceNotification on this SRB, of type  DeviceRequestComplete,
 *              is issued. As soon we're running at passive level, we can do everything 
 *              synchronously during the response to the SRBs with no worry
 *              to block somebody else for a long timer during I2C access
 *
 * Inputs   : PHW_STREAM_REQUEST_BLOCK pSrb : pointer to the current Srb
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
extern "C" 
void STREAMAPI TunerReceivePacket( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    CATIWDMTuner *          pCTuner;
    KIRQL                   irqlCurrent;
    PADAPTER_DATA_EXTENSION pPrivateData = ( PADAPTER_DATA_EXTENSION)( pSrb->HwDeviceExtension);
    PSRB_DATA_EXTENSION     pSrbPrivate = ( PSRB_DATA_EXTENSION)( pSrb->SRBExtension);

    // check the device extension pointer
    if(( pPrivateData == NULL) || ( pSrbPrivate == NULL))
    {
        TRAP;
        pSrb->Status = STATUS_INVALID_PARAMETER;
        StreamClassDeviceNotification( DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
    }

    OutputDebugInfo(( "ATITuneP: TunerReceivePacket() SRB = %x\n", pSrb));

    if( pSrb->Command == SRB_INITIALIZE_DEVICE)
    {
        // this is the special case for SRB_INITIALIZE_DEVICE, because
        // no Queue has been initialized yet. Everything we need later on
        // is initialized during this SRB response
        TunerAdapterInitialize( pSrb);

        StreamClassDeviceNotification( DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
        return;
    }

    // the rest of the SRBs are coming after SpinLock and SRBQueue have been initialized
    // during DRB_INITIALIZE_DEVICE SRB response.
    // I'll insert the SRB in the Queue first of all. The processing SRB from the Queue
    // can be triggered by finishing processing and SRB, or by the fact there is no SRB
    // is in process down here
    pSrbPrivate->pSrb = pSrb;

    // Everything we're doing with the Queue has to be protected from being interrupted
    KeAcquireSpinLock( &pPrivateData->adapterSpinLock, &irqlCurrent);
    InsertTailList( &pPrivateData->adapterSrbQueueHead, &pSrbPrivate->srbListEntry);

    if( pPrivateData->bSrbInProcess)
    {
        // there is another SRB being processed, and the new one will be picked up from
        // the Queue when it's its turn.
        KeReleaseSpinLock( &pPrivateData->adapterSpinLock, irqlCurrent);
        return;
    }

    while( !IsListEmpty( &pPrivateData->adapterSrbQueueHead))
    {
        // turn on the semaphore for the others coming after
        pPrivateData->bSrbInProcess = TRUE;

        // be carefull here, if you've changed the place where srbListEntry is defined
        // within the SRB_DATA_EXTENSION structure
        pSrbPrivate = ( PSRB_DATA_EXTENSION)RemoveHeadList( &pPrivateData->adapterSrbQueueHead);
        KeReleaseSpinLock( &pPrivateData->adapterSpinLock, irqlCurrent);

        // here is the place to process the SRB we have retrieved from the Queue
        pSrb = pSrbPrivate->pSrb;
        pPrivateData = ( PADAPTER_DATA_EXTENSION)( pSrb->HwDeviceExtension);
        pCTuner = &pPrivateData->CTuner;

        ASSERT( pSrb->Status != STATUS_CANCELLED);

        switch( pSrb->Command)
        {
            case SRB_INITIALIZATION_COMPLETE:
                // StreamClass has completed the initialization
                pSrb->Status = pCTuner->AdapterCompleteInitialization( pSrb);
                break;

            case SRB_UNINITIALIZE_DEVICE:
                // close the device.  
                pCTuner->AdapterUnInitialize( pSrb);
                break;

            case SRB_OPEN_STREAM:
            case SRB_CLOSE_STREAM:
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_GET_STREAM_INFO:
                // return a block describing STREAM_INFO_HEADER and all the streams supported
                pCTuner->AdapterGetStreamInfo( pSrb);
                break;

            case SRB_CHANGE_POWER_STATE:
                pSrb->Status = pCTuner->AdapterSetPowerState( pSrb);
                break;

            case SRB_GET_DEVICE_PROPERTY:
                if( pCTuner->AdapterGetProperty( pSrb))
                    pSrb->Status = STATUS_SUCCESS;
                else
                    pSrb->Status = STATUS_INVALID_PARAMETER;
                break;        

            case SRB_SET_DEVICE_PROPERTY:
                if( pCTuner->AdapterSetProperty( pSrb))
                    pSrb->Status = STATUS_SUCCESS;
                else
                    pSrb->Status = STATUS_INVALID_PARAMETER;
                break;

            // We should never get the following since this is a single instance device
            case SRB_OPEN_DEVICE_INSTANCE:
            case SRB_CLOSE_DEVICE_INSTANCE:
                TRAP
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_UNKNOWN_DEVICE_COMMAND:
                // we know we're getting some of these. Why should we?
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            default:
                // TRAP
                // this is a request that we do not understand.  Indicate invalid command and complete the request
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
        }

        StreamClassDeviceNotification( DeviceRequestComplete, pPrivateData, pSrb);

        KeAcquireSpinLock( &pPrivateData->adapterSpinLock, &irqlCurrent);
    }

    // turn off the semaphore to enable the others coming after
    pPrivateData->bSrbInProcess = FALSE;

    KeReleaseSpinLock( &pPrivateData->adapterSpinLock, irqlCurrent);
    // there is no other SRB being processed at this time, let's start processing

}


extern "C" 
void STREAMAPI TunerCancelPacket( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{

    pSrb->Status = STATUS_CANCELLED;
}


extern "C" 
void STREAMAPI TunerTimeoutPacket( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{

    // not sure what to do here.
}


/*^^*
 *      TunerAdapterInitialize()
 * Purpose  : Called when SRB_INITIALIZE_DEVICE SRB is received.
 *              Performs checking of the hardware presence and I2C provider availability.
 *              Sets the hardware in an initial state.
 * Note     : The request does not completed unless we know everything
 *              about the hardware and we are sure it is capable to work in the current configuration.
 *              The hardware Caps are also aquised at this point. As soon this
 *              function is called at passive level, do everything synchronously
 *
 * Inputs   : PHW_STREAM_REQUEST_BLOCK pSrb : pointer to the current Srb
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
void TunerAdapterInitialize( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;
    PADAPTER_DATA_EXTENSION pPrivateData = ( PADAPTER_DATA_EXTENSION)( pConfigInfo->HwDeviceExtension);
    NTSTATUS        ntStatus = STATUS_NO_SUCH_DEVICE;
    CATIWDMTuner *  pCTuner = NULL;
    CI2CScript *    pCScript = NULL;
    UINT            nErrorCode;

    OutputDebugTrace(( "ATITuneP: TunerAdapterInitialize()\n"));

    ENSURE
    {
        if( pConfigInfo->NumberOfAccessRanges != 0) 
        {
            OutputDebugError(( "ATITuneP: illegal NumberOfAccessRanges = %lx\n", pConfigInfo->NumberOfAccessRanges));
            FAIL;
        }

        // if we have I2CProvider implemented inside the MiniVDD, we have to
        // get a pointer to I2CInterface from the Provider.

        // There is an overloaded operator new provided for the CI2CScript Class.
        pCScript = ( CI2CScript *)new(( PVOID)&pPrivateData->CScript)
                        CI2CScript( pConfigInfo, &nErrorCode);
        if( nErrorCode != WDMMINI_NOERROR)
        {
            OutputDebugError(( "ATITuneP: CI2CScript creation failure = %lx\n", nErrorCode));
            FAIL;
        }
        
        // The CI2CScript object was created successfully.
        // We'll try to allocate I2CProvider here for future possible I2C
        // operations needed at Initialization time.
        if( !pCScript->LockI2CProviderEx())
        {
            OutputDebugError(( "ATITuneP: unable to lock I2CProvider"));
            FAIL;
        }

        // we did lock the provider.
        // There is an overloaded operator new provided for the CATIWDMTuner Class.
        pCTuner = ( CATIWDMTuner *)new(( PVOID)&pPrivateData->CTuner) CATIWDMTuner( pConfigInfo, pCScript, &nErrorCode);
        if( nErrorCode)
        {
            OutputDebugError(( "ATITuneP: CATIWDMTuner constructor failure = %lx\n", nErrorCode));
            FAIL;
        }

        InitializeListHead ( &pPrivateData->adapterSrbQueueHead);
        KeInitializeSpinLock ( &pPrivateData->adapterSpinLock);

        pPrivateData->PhysicalDeviceObject = pConfigInfo->RealPhysicalDeviceObject;
        // no streams are supported
        pConfigInfo->StreamDescriptorSize = sizeof( HW_STREAM_HEADER);

        OutputDebugTrace(( "TunerAdapterInitialize(): exit\n"));

        ntStatus = STATUS_SUCCESS;

    } END_ENSURE;

    if ( pCScript )
        pCScript->ReleaseI2CProvider();

    pSrb->Status = ntStatus;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\crossbar\atixbar\wdmxbar.cpp ===
//==========================================================================;
//
//  WDMXBar.CPP
//  WDM Audio/Video CrossBar MiniDriver. 
//      AIW Hardware platform. 
//          CWDMAVXBar class implementation.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "atixbar.h"
#include "wdmdrv.h"
#include "aticonfg.h"



/*^^*
 *      AdapterCompleteInitialization()
 * Purpose  : Called when SRB_COMPLETE_INITIALIZATION SRB is received.
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : BOOL : returns TRUE
 * Author   : IKLEBANOV
 *^^*/
NTSTATUS CWDMAVXBar::AdapterCompleteInitialization( PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PADAPTER_DATA_EXTENSION pPrivateData = ( PADAPTER_DATA_EXTENSION)( pSrb->HwDeviceExtension);
    NTSTATUS                ntStatus;
    ULONG                   nPinsNumber;

    nPinsNumber = m_nNumberOfVideoInputs + m_nNumberOfAudioInputs +
        m_nNumberOfVideoOutputs + m_nNumberOfAudioOutputs;

    ENSURE
    {
        ntStatus = StreamClassRegisterFilterWithNoKSPins( \
                        pPrivateData->PhysicalDeviceObject,     // IN PDEVICE_OBJECT   DeviceObject,
                        &KSCATEGORY_CROSSBAR,                   // IN GUID           * InterfaceClassGUID
                        nPinsNumber,                            // IN ULONG            PinCount,
                        m_pXBarPinsDirectionInfo,               // IN ULONG          * Flags,
                        m_pXBarPinsMediumInfo,                  // IN KSPIN_MEDIUM   * MediumList,
                        NULL);                                  // IN GUID           * CategoryList

        if( !NT_SUCCESS( ntStatus))
            FAIL;

        OutputDebugTrace(( "CWDMAVXBar:AdapterCompleteInitialization() exit\n"));

    } END_ENSURE;

    if( !NT_SUCCESS( ntStatus))
        OutputDebugError(( "CWDMAVXBar:AdapterCompleteInitialization() ntStatus=%x\n", ntStatus));

    return( ntStatus);
}



/*^^*
 *      AdapterUnInitialize()
 * Purpose  : Called when SRB_UNINITIALIZE_DEVICE SRB is received.
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : BOOL : returns TRUE
 * Author   : IKLEBANOV
 *^^*/
BOOL CWDMAVXBar::AdapterUnInitialize( PHW_STREAM_REQUEST_BLOCK pSrb)
{

    OutputDebugTrace(( "CWDMAVXBar:AdapterUnInitialize()\n"));

    if( m_pXBarInputPinsInfo != NULL)
    {
        ::ExFreePool( m_pXBarInputPinsInfo);
        m_pXBarInputPinsInfo = NULL;
    }

    if( m_pXBarPinsMediumInfo != NULL)
    {
        ::ExFreePool( m_pXBarPinsMediumInfo);
        m_pXBarPinsMediumInfo = NULL;
    }

    if( m_pXBarPinsDirectionInfo != NULL)
    {
        ::ExFreePool( m_pXBarPinsDirectionInfo);
        m_pXBarPinsDirectionInfo = NULL;
    }

    pSrb->Status = STATUS_SUCCESS;

    return( TRUE);
}


/*^^*
 *      AdapterGetStreamInfo()
 * Purpose  : Calles during StreamClass initialization procedure to get the information
 *              about data streams exposed by the MiniDriver
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : BOOL : returns TRUE
 * Author   : IKLEBANOV
 *^^*/
BOOL CWDMAVXBar::AdapterGetStreamInfo( PHW_STREAM_REQUEST_BLOCK pSrb)
{
     // pick up the pointer to the stream header data structure
    PHW_STREAM_HEADER pStreamHeader = ( PHW_STREAM_HEADER) \
                                        &( pSrb->CommandData.StreamBuffer->StreamHeader);
     // pick up the pointer to the stream information data structure
    PHW_STREAM_INFORMATION pStreamInfo = ( PHW_STREAM_INFORMATION) \
                                        &( pSrb->CommandData.StreamBuffer->StreamInfo);

    // no streams are supported
    DEBUG_ASSERT( pSrb->NumberOfBytesToTransfer >= sizeof( HW_STREAM_HEADER));

    OutputDebugTrace(( "CWDMAVXBar:AdapterGetStreamInfo()\n"));

    m_wdmAVXBarStreamHeader.NumberOfStreams = 0;
    m_wdmAVXBarStreamHeader.SizeOfHwStreamInformation = sizeof( HW_STREAM_INFORMATION);
    m_wdmAVXBarStreamHeader.NumDevPropArrayEntries = KSPROPERTIES_AVXBAR_NUMBER_SET;
    m_wdmAVXBarStreamHeader.DevicePropertiesArray = m_wdmAVXBarPropertySet;
    m_wdmAVXBarStreamHeader.NumDevEventArrayEntries = 0;
    m_wdmAVXBarStreamHeader.DeviceEventsArray = NULL;
    m_wdmAVXBarStreamHeader.Topology = &m_wdmAVXBarTopology;

    * pStreamHeader = m_wdmAVXBarStreamHeader;

    pSrb->Status = STATUS_SUCCESS;
    return( TRUE);
}


/*^^*
 *      AdapterQueryUnload()
 * Purpose  : Called when the class driver is about to unload the MiniDriver
 *              The MiniDriver checks if any open stream left.
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : BOOL : returns TRUE
 * Author   : IKLEBANOV
 *^^*/
BOOL CWDMAVXBar::AdapterQueryUnload( PHW_STREAM_REQUEST_BLOCK pSrb)
{

    OutputDebugTrace(( "CWDMAVXBar:AdapterQueryUnload()\n"));

    pSrb->Status = STATUS_SUCCESS;

    return( TRUE);
}



/*^^*
 *      operator new
 * Purpose  : CWDMAVXBar class overloaded operator new.
 *              Provides placement for a CWDMAVXBar class object from the PADAPTER_DEVICE_EXTENSION
 *              allocated by the StreamClassDriver for the MiniDriver.
 *
 * Inputs   :   UINT size_t         : size of the object to be placed
 *              PVOID pAllocation   : casted pointer to the CWDMAVXBar allocated data
 *
 * Outputs  : PVOID : pointer of the CWDMAVXBar class object
 * Author   : IKLEBANOV
 *^^*/
PVOID CWDMAVXBar::operator new( size_t size_t,  PVOID pAllocation)
{

    if( size_t != sizeof( CWDMAVXBar))
    {
        OutputDebugTrace(( "CWDMAVXBar: operator new() fails\n"));
        return( NULL);
    }
    else
        return( pAllocation);
}



/*^^*
 *      ~CWDMAVXBar()
 * Purpose  : CWDMAVXBar class destructor.
 *              Frees the allocated memory.
 *
 * Inputs   : none
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
CWDMAVXBar::~CWDMAVXBar()
{

    OutputDebugTrace(( "CWDMAVXBar:~CWDMAVXBar() m_pXBarPinsInfo = %x\n", m_pXBarInputPinsInfo));

    if( m_pXBarInputPinsInfo != NULL)
    {
        ::ExFreePool( m_pXBarInputPinsInfo);
        m_pXBarInputPinsInfo = NULL;
    }
    
    if( m_pXBarPinsMediumInfo != NULL)
    {
        ::ExFreePool( m_pXBarPinsMediumInfo);
        m_pXBarPinsMediumInfo = NULL;
    }

    if( m_pXBarPinsDirectionInfo != NULL)
    {
        ::ExFreePool( m_pXBarPinsDirectionInfo);
        m_pXBarPinsDirectionInfo = NULL;
    }
}



/*^^*
 *      CWDMAVXBar()
 * Purpose  : CWDMAVXBar class constructor.
 *              Performs checking of the hardware presence. Sets the hardware in an initial state.
 *
 * Inputs   :   CI2CScript * pCScript   : pointer to the I2CScript class object
 *              PUINT puiError          : pointer to return a completion error code
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
CWDMAVXBar::CWDMAVXBar( PPORT_CONFIGURATION_INFORMATION pConfigInfo, CI2CScript * pCScript, PUINT puiErrorCode)
    :m_CATIConfiguration( pConfigInfo, pCScript, puiErrorCode)
{
    UINT    uiError;
    ULONG   ulInstance;
    HANDLE  hFolder = NULL;

    OutputDebugTrace(( "CWDMAVXBar:CWDMAVXBar() enter\n"));

    m_pXBarInputPinsInfo = m_pXBarOutputPinsInfo = NULL;
    m_pXBarPinsMediumInfo = NULL;
    m_pXBarPinsDirectionInfo = NULL;
    m_ulPowerState = PowerDeviceD0;

    // error code was caried over from ATIConfiguration class constructor
    uiError = * puiErrorCode;

    ENSURE
    {
        ULONG                   ulNumberOfPins, nPinIndex;
        UINT                    uiTunerId, nIndex;
        UCHAR                   uchTunerAddress;
        KSPIN_MEDIUM            mediumKSPin;
        const KSPIN_MEDIUM *    pMediumKSPin;

        if( uiError != WDMMINI_NOERROR)
            FAIL;

        if( pCScript == NULL)
        {
            uiError = WDMMINI_INVALIDPARAM;
            FAIL;
        }

        // first, find out whether any tuner type is installed. If not, we have only 2 video sources.
        m_CATIConfiguration.GetTunerConfiguration( &uiTunerId, &uchTunerAddress);
        m_nNumberOfVideoInputs = ( uchTunerAddress) ? 3 : 2;
        m_nNumberOfVideoOutputs = m_nNumberOfVideoInputs;

        m_CATIConfiguration.GetAudioProperties( &m_nNumberOfAudioInputs, &m_nNumberOfAudioOutputs);
        if( !uchTunerAddress)
            // if there is no tuner - no TVAudio input
            m_nNumberOfAudioInputs --;  

        ulNumberOfPins = m_nNumberOfAudioInputs + m_nNumberOfVideoInputs + m_nNumberOfVideoOutputs + m_nNumberOfAudioOutputs;
        m_pXBarInputPinsInfo = ( PXBAR_PIN_INFORMATION) \
            ::ExAllocatePool( NonPagedPool, sizeof( XBAR_PIN_INFORMATION) * ulNumberOfPins);
        if( m_pXBarInputPinsInfo == NULL)
        {
            uiError = WDMMINI_ERROR_MEMORYALLOCATION;
            FAIL;
        }

        m_pXBarPinsMediumInfo = ( PKSPIN_MEDIUM) \
            ::ExAllocatePool( NonPagedPool, sizeof( KSPIN_MEDIUM) * ulNumberOfPins);
        if( m_pXBarPinsMediumInfo == NULL)
        {
            uiError = WDMMINI_ERROR_MEMORYALLOCATION;
            FAIL;
        }
        
        m_pXBarPinsDirectionInfo = ( PBOOL) \
            ::ExAllocatePool( NonPagedPool, sizeof( BOOL) * ulNumberOfPins);
        if( m_pXBarPinsDirectionInfo == NULL)
        {
            uiError = WDMMINI_ERROR_MEMORYALLOCATION;
            FAIL;
        }

        m_pI2CScript = pCScript;

        m_pXBarOutputPinsInfo = &m_pXBarInputPinsInfo[m_nNumberOfAudioInputs + m_nNumberOfVideoInputs];

        // Medium pin data has an Instance number inside
        ulInstance = ::GetDriverInstanceNumber( pConfigInfo->RealPhysicalDeviceObject);

        hFolder = ::OpenRegistryFolder( pConfigInfo->RealPhysicalDeviceObject, &UNICODE_WDM_REG_PIN_MEDIUMS);
        
        // initialize video input pins, TVTuner input is always the last one
        for( nIndex = 0; nIndex < m_nNumberOfVideoInputs; nIndex ++)
        {
            switch( nIndex)
            {
                case 0:
                    // Composite
                    m_pXBarInputPinsInfo[nIndex].AudioVideoPinType = KS_PhysConn_Video_Composite;
                    // put the default value for the Medium first
                    ::RtlCopyMemory( &m_pXBarPinsMediumInfo[nIndex], &MEDIUM_WILDCARD, sizeof( KSPIN_MEDIUM));
                    // LineIn is always the first audio pin
                    m_pXBarInputPinsInfo[nIndex].nRelatedPinNumber = m_nNumberOfVideoInputs;
                    break;

                case 1:
                    // SVideo
                    m_pXBarInputPinsInfo[nIndex].AudioVideoPinType = KS_PhysConn_Video_SVideo;
                    // put the default value for the Medium first
                    ::RtlCopyMemory( &m_pXBarPinsMediumInfo[nIndex], &MEDIUM_WILDCARD, sizeof( KSPIN_MEDIUM));
                    // LineIn is always the first audio pin
                    m_pXBarInputPinsInfo[nIndex].nRelatedPinNumber = m_nNumberOfVideoInputs;
                    break;

                case 2:
                    // TVTuner
                    m_pXBarInputPinsInfo[nIndex].AudioVideoPinType = KS_PhysConn_Video_Tuner;
                    // put the default value for the Medium first
                    ::RtlCopyMemory( &m_pXBarPinsMediumInfo[nIndex], &ATIXBarVideoTunerInMedium, sizeof( KSPIN_MEDIUM));
                    // TVAudio is always the last audio pin
                    m_pXBarInputPinsInfo[nIndex].nRelatedPinNumber = m_nNumberOfVideoInputs + m_nNumberOfAudioInputs - 1;
                    break;

                default:
                    TRAP;
                    break;
            }

            // let's put another Medium value from the registry, if present
            if( ::ReadPinMediumFromRegistryFolder( hFolder, nIndex, &mediumKSPin))
                ::RtlCopyMemory( &m_pXBarPinsMediumInfo[nIndex], &mediumKSPin, sizeof( KSPIN_MEDIUM));
            m_pXBarInputPinsInfo[nIndex].pMedium = &m_pXBarPinsMediumInfo[nIndex];
            m_pXBarPinsMediumInfo[nIndex].Id = ulInstance;
            // all the pins here are inputs
            m_pXBarPinsDirectionInfo[nIndex] = FALSE;   
        }

        // initialize audio input pins, TV Audio input is always the last one
        for( nIndex = 0; nIndex < m_nNumberOfAudioInputs; nIndex ++)
        {
            nPinIndex = nIndex + m_nNumberOfVideoInputs;

            switch( nIndex)
            {
                case 0:
                    m_pXBarInputPinsInfo[nPinIndex].AudioVideoPinType = KS_PhysConn_Audio_Line;
                    // put the default value for the Medium first
                    ::RtlCopyMemory( &m_pXBarPinsMediumInfo[nPinIndex], &MEDIUM_WILDCARD, sizeof( KSPIN_MEDIUM));
                    m_pXBarInputPinsInfo[nPinIndex].nRelatedPinNumber = 0;
                    break;


                case 1:
                    m_pXBarInputPinsInfo[nPinIndex].AudioVideoPinType = KS_PhysConn_Audio_Tuner;
                    // put the default value for the Medium first
                    ::RtlCopyMemory( &m_pXBarPinsMediumInfo[nPinIndex], &ATIXBarAudioTunerInMedium, sizeof( KSPIN_MEDIUM));
                    m_pXBarInputPinsInfo[nPinIndex].nRelatedPinNumber = m_nNumberOfVideoInputs - 1;
                    break;

                default:
                    TRAP;
                    break;
            }

            // let's put another Medium value from the registry, if present
            if( ::ReadPinMediumFromRegistryFolder( hFolder, nPinIndex, &mediumKSPin))
                ::RtlCopyMemory( &m_pXBarPinsMediumInfo[nPinIndex], &mediumKSPin, sizeof( KSPIN_MEDIUM));
            m_pXBarInputPinsInfo[nPinIndex].pMedium = &m_pXBarPinsMediumInfo[nPinIndex];
            m_pXBarPinsMediumInfo[nPinIndex].Id = ulInstance;
            // all the pins here are inputs
            m_pXBarPinsDirectionInfo[nPinIndex] = FALSE;
        }

        // initialize outputs video pins, no X-connection for Video
        for( nIndex = 0; nIndex < m_nNumberOfVideoOutputs; nIndex ++)
        {
            nPinIndex = nIndex + m_nNumberOfVideoInputs + m_nNumberOfAudioInputs;
            m_pXBarOutputPinsInfo[nIndex].AudioVideoPinType = m_pXBarInputPinsInfo[nIndex].AudioVideoPinType;
            m_pXBarOutputPinsInfo[nIndex].nConnectedToPin = nIndex;
         m_pXBarOutputPinsInfo[nIndex].nRelatedPinNumber = m_nNumberOfVideoOutputs; // jaybo

            switch( m_pXBarOutputPinsInfo[nIndex].AudioVideoPinType)
            {
                case KS_PhysConn_Video_Tuner:
                    pMediumKSPin = &ATIXBarVideoTunerOutMedium;
                    break;

                case KS_PhysConn_Video_SVideo:
                    pMediumKSPin = &ATIXBarVideoSVideoOutMedium;
                    break;

                case KS_PhysConn_Video_Composite:
                    pMediumKSPin = &ATIXBarVideoCompositeOutMedium;
                    break;

                default:
                    pMediumKSPin = &MEDIUM_WILDCARD;
                    break;
            }
            
            ::RtlCopyMemory( &m_pXBarPinsMediumInfo[nPinIndex], pMediumKSPin, sizeof( KSPIN_MEDIUM));

            // let's put another Medium value from the registry, if present
            if( ::ReadPinMediumFromRegistryFolder( hFolder, nPinIndex, &mediumKSPin))
                ::RtlCopyMemory( &m_pXBarPinsMediumInfo[nPinIndex], &mediumKSPin, sizeof( KSPIN_MEDIUM));

            m_pXBarOutputPinsInfo[nIndex].pMedium = &m_pXBarPinsMediumInfo[nPinIndex];
            m_pXBarPinsMediumInfo[nPinIndex].Id = ulInstance;
            // all the pins here are outputs
            m_pXBarPinsDirectionInfo[nPinIndex] = TRUE;
        }

        // initialize outputs audio pins
        for( nIndex = 0; nIndex < m_nNumberOfAudioOutputs; nIndex ++)
        {
            nPinIndex = nIndex + m_nNumberOfVideoInputs + m_nNumberOfAudioInputs + m_nNumberOfVideoOutputs;

            m_pXBarOutputPinsInfo[nIndex + m_nNumberOfVideoInputs].AudioVideoPinType = KS_PhysConn_Audio_AudioDecoder;

            // put the default value for the Medium first
/*  jaybo
            ::RtlCopyMemory( &m_pXBarPinsMediumInfo[nPinIndex], ATIXBarAudioDecoderOutMedium, sizeof( KSPIN_MEDIUM));
*/
            ::RtlCopyMemory( &m_pXBarPinsMediumInfo[nPinIndex], &MEDIUM_WILDCARD, sizeof( KSPIN_MEDIUM));
            // let's put another Medium value from the registry, if present
            if( ::ReadPinMediumFromRegistryFolder( hFolder, nPinIndex, &mediumKSPin))
                ::RtlCopyMemory( &m_pXBarPinsMediumInfo[nPinIndex], &mediumKSPin, sizeof( KSPIN_MEDIUM));

            m_pXBarOutputPinsInfo[nIndex + m_nNumberOfVideoInputs].nConnectedToPin = ( ULONG)-1;
            m_pXBarOutputPinsInfo[nIndex + m_nNumberOfVideoInputs].nRelatedPinNumber = (ULONG)-1;
            m_pXBarOutputPinsInfo[nIndex + m_nNumberOfVideoInputs].pMedium = &m_pXBarPinsMediumInfo[nPinIndex];
            m_pXBarPinsMediumInfo[nPinIndex].Id = ulInstance;
            // all the pins here are outputs
            m_pXBarPinsDirectionInfo[nPinIndex] = TRUE;

        }

        if( hFolder != NULL)
            ::ZwClose( hFolder);

        // mute the audio as the default power-up behaviour
        m_CATIConfiguration.ConnectAudioSource( m_pI2CScript, AUDIOSOURCE_MUTE);

        // these two functions has to be called after the CWDMAVXBar class object was build on
        // on the stack and copied over into the DeviceExtension
        // This commant was true for the case, where the class object was build on the stack first.
        // There is an overloaded operator new provided for this class, and we can call it from here
        SetWDMAVXBarKSProperties();
        SetWDMAVXBarKSTopology();

        // Set run-time WDM properties at the last

         * puiErrorCode = WDMMINI_NOERROR;
         OutputDebugTrace(( "CWDMAVXBar:CWDMAVXBar() exit\n"));

        return;

    } END_ENSURE;

    * puiErrorCode = uiError;
    OutputDebugError(( "CWDMAVXBar:CWDMAVXBar() Error = %x\n", uiError));
}



/*^^*
 *      AdapterSetPowerState()
 * Purpose  : Sets Power Management state for deviec
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : NTSTATUS as the operation result
 * Author   : TOM
 *^^*/
NTSTATUS CWDMAVXBar::AdapterSetPowerState( PHW_STREAM_REQUEST_BLOCK pSrb)
{
    ULONG               nAudioSource;
    ULONG               nInputPin;
    NTSTATUS            ntStatus;
    UINT                nIndex;
    DEVICE_POWER_STATE  nDeviceState = pSrb->CommandData.DeviceState;

    ntStatus = STATUS_ADAPTER_HARDWARE_ERROR;

    switch( nDeviceState)
    {
        case PowerDeviceD0:
        case PowerDeviceD3:
            if( nDeviceState != m_ulPowerState)
            {
                // if transition form D3 to D0 we have to restore audio connections
                if(( nDeviceState == PowerDeviceD0) && ( m_ulPowerState == PowerDeviceD3))
                {
                    for( nIndex = 0; nIndex < m_nNumberOfAudioOutputs; nIndex ++)
                    {
                        // we need to restore every audio output pin connection,
                        // video output pins are hardwired 
                        nInputPin = m_pXBarOutputPinsInfo[nIndex + m_nNumberOfVideoOutputs].nConnectedToPin;

                        switch( m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType)
                        {
                            case KS_PhysConn_Audio_Line:
                                nAudioSource = AUDIOSOURCE_LINEIN;
                                break;

                            case KS_PhysConn_Audio_Tuner:
                                nAudioSource = AUDIOSOURCE_TVAUDIO;
                                break;

                            case 0xFFFFFFFF:
                                nAudioSource = AUDIOSOURCE_MUTE;
                                return( STATUS_SUCCESS);

                            default:
                                OutputDebugError(( "CWDMAVXBar:AdapterSetPowerState() Audio Pin type=%x\n", m_pXBarInputPinsInfo[nInputPin].AudioVideoPinType));
                                return STATUS_SUCCESS;
                        }

                        if( m_CATIConfiguration.ConnectAudioSource( m_pI2CScript, nAudioSource))
                            ntStatus = STATUS_SUCCESS;
                        else
                        {
                            // error
                            ntStatus = STATUS_ADAPTER_HARDWARE_ERROR;
                            break;
                        }
                    }
                }
                else
                    ntStatus = STATUS_SUCCESS;
                }
            else
                ntStatus = STATUS_SUCCESS;

            m_ulPowerState = nDeviceState;
            break;

        case PowerDeviceUnspecified:
        case PowerDeviceD1:
        case PowerDeviceD2:
            ntStatus = STATUS_SUCCESS;
            break;

        default:
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    return( ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\tuners\1236\tuneprop.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "wdmdrv.h"
#include "atitunep.h"
#include "aticonfg.h"


/*^^*
 *      AdapterGetProperty()
 * Purpose  : Called when SRB_GET_PROPERTY SRB is received.
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : BOOL : returns returns FALSE, if it is not a TVTuner property
 *              it also returns the required property
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::AdapterGetProperty( PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSpd = pSrb->CommandData.PropertyInfo;
    ULONG   uiPropertyId = pSpd->Property->Id;              // index of the property
    BOOL    bResult = FALSE;

    if( !::IsEqualGUID(( const struct _GUID &)PROPSETID_TUNER, ( const struct _GUID &)pSpd->Property->Set))
        return( bResult);

    if(( pSpd == NULL) || ( pSpd->PropertyInfo == NULL))
        return( bResult);
    
    OutputDebugInfo(( "CATIWDMTuner:AdapterGetProperty() Id = %d\n", uiPropertyId));

    bResult = TRUE;

    switch( uiPropertyId)
    {
    case KSPROPERTY_TUNER_CAPS:
        ASSERT( pSpd->PropertyOutputSize >= sizeof( KSPROPERTY_TUNER_CAPS_S));
        {
            KSPIN_MEDIUM NoPinMedium;
            PKSPROPERTY_TUNER_CAPS_S pTunerCaps = ( PKSPROPERTY_TUNER_CAPS_S)pSpd->PropertyInfo;

            // Copy the input property info to the output property info
            ::RtlCopyMemory( pTunerCaps, pSpd->Property, sizeof( KSPROPERTY_TUNER_CAPS_S));

            pTunerCaps->ModesSupported = m_ulSupportedModes;

            NoPinMedium.Set = GUID_NULL;
            NoPinMedium.Id = 0;
            NoPinMedium.Flags = 0;

            switch( m_ulNumberOfPins)
            {
            case 2:
            case 3:
                // TVTuner with TVAudio
/*
                pTunerCaps->VideoMedium = &m_pTVTunerPinsMediumInfo[0];
                pTunerCaps->TVAudioMedium = &m_pTVTunerPinsMediumInfo[1];
                pTunerCaps->RadioAudioMedium = ( m_ulNumberOfPins == 3) ?
                    &m_pTVTunerPinsMediumInfo[2] : NULL;
*/
                pTunerCaps->VideoMedium = m_pTVTunerPinsMediumInfo[0];
                pTunerCaps->TVAudioMedium = m_pTVTunerPinsMediumInfo[1];
                pTunerCaps->RadioAudioMedium = ( m_ulNumberOfPins == 3) ?
                    m_pTVTunerPinsMediumInfo[2] : NoPinMedium;
                break;

            case 1:
                // it can be FM Tuner only.
/*
                pTunerCaps->VideoMedium = NULL;
                pTunerCaps->TVAudioMedium = NULL;
                pTunerCaps->RadioAudioMedium = &m_pTVTunerPinsMediumInfo[0];
*/
                pTunerCaps->VideoMedium = NoPinMedium;
                pTunerCaps->TVAudioMedium = NoPinMedium;
                pTunerCaps->RadioAudioMedium = m_pTVTunerPinsMediumInfo[0];
                break;
            }

            pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_CAPS_S);
        }
        break;

    case KSPROPERTY_TUNER_MODE_CAPS:
        ASSERT( pSpd->PropertyOutputSize >= sizeof( KSPROPERTY_TUNER_MODE_CAPS_S));
        {
            PKSPROPERTY_TUNER_MODE_CAPS_S   pTunerModeCaps = ( PKSPROPERTY_TUNER_MODE_CAPS_S)pSpd->PropertyInfo;
            ULONG                           ulOperationMode = (( PKSPROPERTY_TUNER_MODE_CAPS_S)pSpd->Property)->Mode;

            // Copy the input property info to the output property info
            ::RtlCopyMemory( pTunerModeCaps, pSpd->Property, sizeof( PKSPROPERTY_TUNER_MODE_CAPS_S));

            if( !( ulOperationMode & m_ulSupportedModes))
            {
                TRAP;
                bResult = FALSE;
                break;
            }

            // There is support for TVTuner at this tinme only. It will be enchanced later on to
            // support FM Tuner as well.
            switch( ulOperationMode)
            {
                case KSPROPERTY_TUNER_MODE_TV :
                    ::RtlCopyMemory( &pTunerModeCaps->StandardsSupported, &m_wdmTunerCaps, sizeof( ATI_KSPROPERTY_TUNER_CAPS));
                    break;

                default:
                    bResult = FALSE;
                    break;
            }

            pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_MODE_CAPS_S);
        }
        break;

    case KSPROPERTY_TUNER_MODE:
        ASSERT( pSpd->PropertyOutputSize >= sizeof( KSPROPERTY_TUNER_MODE_S));
        {
            PKSPROPERTY_TUNER_MODE_S pTunerMode = ( PKSPROPERTY_TUNER_MODE_S)pSpd->PropertyInfo;

            // Copy the input property info to the output property info
            ::RtlCopyMemory( pTunerMode, pSpd->Property, sizeof( PKSPROPERTY_TUNER_MODE_S));

            pTunerMode->Mode = m_ulTunerMode;

            pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_MODE_S);
        }
        break;

    case KSPROPERTY_TUNER_STANDARD:
        ASSERT( pSpd->PropertyOutputSize >= sizeof( KSPROPERTY_TUNER_STANDARD_S));
        {
            PKSPROPERTY_TUNER_STANDARD_S pTunerStandard = ( PKSPROPERTY_TUNER_STANDARD_S)pSpd->PropertyInfo;

            // Copy the input property info to the output property info
            ::RtlCopyMemory( pTunerStandard, pSpd->Property, sizeof( KSPROPERTY_TUNER_STANDARD_S));

            pTunerStandard->Standard = m_ulVideoStandard;

            pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_STANDARD_S);
        }
        break;

    case KSPROPERTY_TUNER_FREQUENCY:
        ASSERT( pSpd->PropertyOutputSize >= sizeof( KSPROPERTY_TUNER_FREQUENCY_S));
        {
            PKSPROPERTY_TUNER_FREQUENCY_S pTunerFrequency = ( PKSPROPERTY_TUNER_FREQUENCY_S)pSpd->PropertyInfo;

            // Copy the input property info to the output property info
            ::RtlCopyMemory( pTunerFrequency, pSpd->Property, sizeof( KSPROPERTY_TUNER_FREQUENCY_S));

            pTunerFrequency->Frequency = m_ulTuningFrequency;

            pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_FREQUENCY_S);
        }
        break;

    case KSPROPERTY_TUNER_INPUT:
        ASSERT( pSpd->PropertyOutputSize >= sizeof( KSPROPERTY_TUNER_INPUT_S));
        {
            PKSPROPERTY_TUNER_INPUT_S pTunerInput = ( PKSPROPERTY_TUNER_INPUT_S)pSpd->PropertyInfo;

            // Copy the input property info to the output property info
            ::RtlCopyMemory( pTunerInput, pSpd->Property, sizeof( KSPROPERTY_TUNER_INPUT_S));

            pTunerInput->InputIndex = m_ulTunerInput;

            pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_INPUT_S);
        }
        break;

    case KSPROPERTY_TUNER_STATUS:
        ASSERT( pSpd->PropertyOutputSize >= sizeof( KSPROPERTY_TUNER_STATUS_S));
        {
            BOOL    bBusy;
            LONG    lPLLOffset;
            PKSPROPERTY_TUNER_STATUS_S pTunerStatus = ( PKSPROPERTY_TUNER_STATUS_S)pSpd->PropertyInfo;

            if(( bResult = GetTunerPLLOffsetBusyStatus( &lPLLOffset, &bBusy)))
            {
                OutputDebugInfo(( "CATIWDMTuner:GetStatus() Busy = %d, Quality = %d, Frequency = %ld\n",
                    bBusy, lPLLOffset, m_ulTuningFrequency));

                // Copy the input property info to the output property info
                ::RtlCopyMemory( pTunerStatus, pSpd->Property, sizeof( KSPROPERTY_TUNER_STATUS_S));

                pTunerStatus->Busy = bBusy;
                if( !bBusy)
                {
                    pTunerStatus->PLLOffset = lPLLOffset;
                    pTunerStatus->CurrentFrequency = m_ulTuningFrequency;
                }

                pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_STATUS_S);
            }
            else
            {
                bResult = FALSE;
                OutputDebugError(( "CATIWDMTuner:GetStatus() fails\n"));
            }
        }
        break;

    default:
        TRAP;
        bResult = FALSE;
        break;
    }

    return( bResult);
}



/*^^*
 *      AdapterSetProperty()
 * Purpose  : Called when SRB_GET_PROPERTY SRB is received.
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : BOOL : returns FALSE, if it is not a TVTuner property
 *              it also sets the required property
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::AdapterSetProperty( PHW_STREAM_REQUEST_BLOCK pSrb)
{

    PSTREAM_PROPERTY_DESCRIPTOR pSpd = pSrb->CommandData.PropertyInfo;
    ULONG uiPropertyId = pSpd->Property->Id;            // index of the property

    if( !::IsEqualGUID( ( const struct _GUID &)PROPSETID_TUNER, ( const struct _GUID &)pSpd->Property->Set))
        return( FALSE);

    OutputDebugInfo(( "CATIWDMTuner:AdapterSetProperty() Id = %d\n", uiPropertyId));

    switch( uiPropertyId)
    {
    case KSPROPERTY_TUNER_MODE:
        ASSERT( pSpd->PropertyOutputSize >= sizeof( KSPROPERTY_TUNER_MODE_S));
        {
            ULONG ulModeToSet = (( PKSPROPERTY_TUNER_MODE_S)pSpd->PropertyInfo)->Mode;

            if( ulModeToSet & m_ulSupportedModes)
            {
                if( ulModeToSet != m_ulTunerMode)
                    if( SetTunerMode( ulModeToSet))
                        m_ulTunerMode = ulModeToSet;
            }
            else
                return( FALSE);
        }
        break;

    case KSPROPERTY_TUNER_STANDARD:
        ASSERT( pSpd->PropertyOutputSize >= sizeof( KSPROPERTY_TUNER_STANDARD_S));
        {
            ULONG ulStandardToSet = (( PKSPROPERTY_TUNER_STANDARD_S)pSpd->PropertyInfo)->Standard;

            if( ulStandardToSet & m_wdmTunerCaps.ulStandardsSupported)
            {
                if( ulStandardToSet != m_ulVideoStandard)
                    if( SetTunerVideoStandard( ulStandardToSet))
                        m_ulVideoStandard = ulStandardToSet;
            }
            else
                return( FALSE);
        }
        break;

    case KSPROPERTY_TUNER_FREQUENCY:
        ASSERT( pSpd->PropertyOutputSize >= sizeof( KSPROPERTY_TUNER_FREQUENCY_S));
        {
            ULONG   ulFrequencyToSet = (( PKSPROPERTY_TUNER_FREQUENCY_S)pSpd->PropertyInfo)->Frequency;
            BOOL    bResult = FALSE;

            ENSURE
            {
                if(( ulFrequencyToSet < m_wdmTunerCaps.ulMinFrequency) ||
                    ( ulFrequencyToSet > m_wdmTunerCaps.ulMaxFrequency))
                        FAIL;

                if( ulFrequencyToSet != m_ulTuningFrequency)
                {
                    if( !SetTunerFrequency( ulFrequencyToSet))
                        FAIL;

                    // update driver
                    m_ulTuningFrequency = ulFrequencyToSet;
                }

                bResult = TRUE;

            } END_ENSURE;

            if( !bResult)
            {
                OutputDebugError(( "CATIWDMTuner:SetFrequency() fails Frequency = %ld\n", ulFrequencyToSet));

                return( FALSE);
            }

            OutputDebugInfo(( "CATIWDMTuner:SetFrequency() new TuningFrequency = %ld\n", ulFrequencyToSet));
        }
        break;

    case KSPROPERTY_TUNER_INPUT:
        ASSERT( pSpd->PropertyOutputSize >= sizeof( KSPROPERTY_TUNER_INPUT_S));
        {
            ULONG nInputToSet = (( PKSPROPERTY_TUNER_INPUT_S)pSpd->PropertyInfo)->InputIndex;

            if( nInputToSet < m_wdmTunerCaps.ulNumberOfInputs)
            {
                if( nInputToSet != m_ulTunerInput)
                    if( SetTunerInput( nInputToSet))
                        m_ulTunerInput = nInputToSet;
                    else
                        return( FALSE);
            }
            else
                return( FALSE);
        }
        break;

    default:
        TRAP;
        return( FALSE);
    }

    return( TRUE);
}



/*^^*
 *      SetWDMTunerKSTopology()
 * Purpose  : Sets the KSTopology structure
 *              Called during CWDMTuner class construction time.
 *
 * Inputs   : none
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
void CATIWDMTuner::SetWDMTunerKSTopology( void)
{
    GUID wdmTunerTopologyCategory[] =
    {
        STATIC_KSCATEGORY_TVTUNER
    };
    
    ::RtlCopyMemory( &m_wdmTunerTopologyCategory, wdmTunerTopologyCategory, sizeof( wdmTunerTopologyCategory));

    m_wdmTunerTopology.CategoriesCount = 1;
    m_wdmTunerTopology.Categories = &m_wdmTunerTopologyCategory;
    m_wdmTunerTopology.TopologyNodesCount = 0;
    m_wdmTunerTopology.TopologyNodes = NULL;
    m_wdmTunerTopology.TopologyConnectionsCount = 0;
    m_wdmTunerTopology.TopologyConnections = NULL;
}



/*^^*
 *      SetWDMTunerKSProperties()
 * Purpose  : Sets the KSProperty structures array
 *              Called during CWDMTuner class construction time.
 *
 * Inputs   : none
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
void CATIWDMTuner::SetWDMTunerKSProperties( void)
{

    DEFINE_KSPROPERTY_TABLE( wdmTunerProperties)
    {
        DEFINE_KSPROPERTY_ITEM                              
        (
            KSPROPERTY_TUNER_CAPS,                          // 1
            TRUE,                                           // GetSupported or Handler
            sizeof(KSPROPERTY_TUNER_CAPS_S),                // MinProperty
            sizeof(KSPROPERTY_TUNER_CAPS_S),                // MinData
            FALSE,                                          // SetSupported or Handler
            NULL,                                           // Values
            0,                                              // RelationsCount
            NULL,                                           // Relations
            NULL,                                           // SupportHandler
            0                                               // SerializedSize
        ),
        DEFINE_KSPROPERTY_ITEM                              
        (
            KSPROPERTY_TUNER_MODE_CAPS,                     // 2
            TRUE,                                           // GetSupported or Handler
            sizeof(KSPROPERTY_TUNER_MODE_CAPS_S),           // MinProperty
            sizeof(KSPROPERTY_TUNER_MODE_CAPS_S),           // MinData
            FALSE,                                          // SetSupported or Handler
            NULL,                                           // Values
            0,                                              // RelationsCount
            NULL,                                           // Relations
            NULL,                                           // SupportHandler
            0                                               // SerializedSize
        ),
        DEFINE_KSPROPERTY_ITEM                              
        (
            KSPROPERTY_TUNER_MODE,                          // 3
            TRUE,                                           // GetSupported or Handler
            sizeof(KSPROPERTY_TUNER_MODE_S),                // MinProperty
            sizeof(KSPROPERTY_TUNER_MODE_S),                // MinData
            TRUE,                                           // SetSupported or Handler
            NULL,                                           // Values
            0,                                              // RelationsCount
            NULL,                                           // Relations
            NULL,                                           // SupportHandler
            0                                               // SerializedSize
        ),
        DEFINE_KSPROPERTY_ITEM
        (
            KSPROPERTY_TUNER_STANDARD,                      // 4
            TRUE,                                           // GetSupported or Handler
            sizeof(KSPROPERTY_TUNER_STANDARD_S),            // MinProperty
            sizeof(KSPROPERTY_TUNER_STANDARD_S),            // MinData
            TRUE,                                           // SetSupported or Handler
            NULL,                                           // Values
            0,                                              // RelationsCount
            NULL,                                           // Relations
            NULL,                                           // SupportHandler
            sizeof(KSPROPERTY_TUNER_STANDARD_S)         // SerializedSize
        ),
        DEFINE_KSPROPERTY_ITEM
        (
            KSPROPERTY_TUNER_FREQUENCY,                     // 5
            TRUE,                                           // GetSupported or Handler
            sizeof(KSPROPERTY_TUNER_FREQUENCY_S),           // MinProperty
            sizeof(KSPROPERTY_TUNER_FREQUENCY_S),           // MinData
            TRUE,                                           // SetSupported or Handler
            NULL,                                           // Values
            0,                                              // RelationsCount
            NULL,                                           // Relations
            NULL,                                           // SupportHandler
            sizeof(KSPROPERTY_TUNER_FREQUENCY_S)            // SerializedSize
        ),
        DEFINE_KSPROPERTY_ITEM
        (
            KSPROPERTY_TUNER_INPUT,                         // 6
            TRUE,                                           // GetSupported or Handler
            sizeof(KSPROPERTY_TUNER_INPUT_S),               // MinProperty
            sizeof(KSPROPERTY_TUNER_INPUT_S),               // MinData
            TRUE,                                           // SetSupported or Handler
            NULL,                                           // Values
            0,                                              // RelationsCount
            NULL,                                           // Relations
            NULL,                                           // SupportHandler
            sizeof(KSPROPERTY_TUNER_INPUT_S)                // SerializedSize
        ),
        DEFINE_KSPROPERTY_ITEM
        (
            KSPROPERTY_TUNER_STATUS,                        // 6
            TRUE,                                           // GetSupported or Handler
            sizeof(KSPROPERTY_TUNER_STATUS_S),              // MinProperty
            sizeof(KSPROPERTY_TUNER_STATUS_S),              // MinData
            FALSE,                                          // SetSupported or Handler
            NULL,                                           // Values
            0,                                              // RelationsCount
            NULL,                                           // Relations
            NULL,                                           // SupportHandler
            sizeof(KSPROPERTY_TUNER_STATUS_S)               // SerializedSize
        )
    };

    DEFINE_KSPROPERTY_SET_TABLE( wdmTunerPropertySet)
    {
        DEFINE_KSPROPERTY_SET
        (
            &PROPSETID_TUNER,                               // Set
            KSPROPERTIES_TUNER_LAST,                        // PropertiesCount
            m_wdmTunerProperties,                           // PropertyItems
            0,                                              // FastIoCount
            NULL                                            // FastIoTable
        )
    };

    ::RtlCopyMemory( m_wdmTunerProperties,  wdmTunerProperties, sizeof( wdmTunerProperties));
    ::RtlCopyMemory( &m_wdmTunerPropertySet, wdmTunerPropertySet, sizeof( wdmTunerPropertySet));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\tuners\1236\tunerhdw.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//	TuneProp.H
//	WDM Tuner MiniDriver. 
//		Philips Tuner. 
//			Tuner Hardware access definitions.
//==========================================================================;

#ifndef _TUNERHDW_H_
#define _TUNERHDW_H_


// Special case for Temic Tuner, Channels 63, 64
#define kTemicControl			0x8E34
#define kAirChannel63			0x32B0
#define kAirChannel64			0x3310

// Upper low and upper mid range band definitions
#define kUpperLowBand			0x0CB0
#define kUpperMidBand			0x1F10
#define kUpperLowBand_PALD		0x0CE4
#define kUpperMidBand_PALD		0x1ED4
#define kUpperLowBand_SECAM		0x0CE4
#define kUpperMidBand_SECAM		0x1ED4 
#define kUpperLowBand_ALPS		0x0AD0
#define kUpperMidBand_ALPS		0x1970 

// Low, Mid and High band control definitions
#define kLowBand				0x8EA0
#define kMidBand				0x8E90
#define kHighBand				0x8E30
#define kLowBand_SECAM			0x8EA3
#define kMidBand_SECAM			0x8E93
#define kHighBand_SECAM			0x8E33
#define kLowBand_ALPS			0xC214		// Bigger charge pump current
#define kMidBand_ALPS			0xC212		// Bigger charge pump current
#define kHighBand_ALPS			0xC211		// Bigger charge pump current
#define kLowBand_PALBG			0x8EA1
#define kMidBand_PALBG			0x8E91
#define kHighBand_PALBG			0x8E31
#define kLowBand_NTSC_FM		0x8EA0
#define kMidBand_NTSC_FM		0x8E90
#define kHighBand_NTSC_FM		0x8E30


#endif	// _TUNERHDW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\tuners\1236\wdmtuner.h ===
//==========================================================================;
//
//  WDMTuner.H
//  WDM Tuner MiniDriver. 
//      CWDMTuner Class definition.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

#ifndef _WDMTUNER_H_
#define _WDMTUNER_H_

#include "i2script.h"
#include "aticonfg.h"
#include "pinmedia.h"

#define KSPROPERTIES_TUNER_LAST         ( KSPROPERTY_TUNER_STATUS + 1) 

typedef struct                          // this structure is derived from MS KSPROPERTY_TUNER_CAPS_S
{
    ULONG  ulStandardsSupported;        // KS_AnalogVideo_*
    ULONG  ulMinFrequency;              // Hz
    ULONG  ulMaxFrequency;              // Hz
    ULONG  ulTuningGranularity;         // Hz
    ULONG  ulNumberOfInputs;            // count of inputs
    ULONG  ulSettlingTime;              // milliSeconds
    ULONG  ulStrategy;                  // KS_TUNER_STRATEGY

} ATI_KSPROPERTY_TUNER_CAPS, * PATI_KSPROPERTY_TUNER_CAPS;


class CATIWDMTuner
{
public:
    CATIWDMTuner        ( PPORT_CONFIGURATION_INFORMATION pConfigInfo, CI2CScript * pCScript, PUINT puiErrorCode);
    ~CATIWDMTuner       ();
    PVOID operator new  ( size_t stSize, PVOID pAllocation);

// Attributes   
private:
    // pending device Srb
    PHW_STREAM_REQUEST_BLOCK    m_pPendingDeviceSrb;

    // WDM global topology headers
    GUID                        m_wdmTunerTopologyCategory;
    KSTOPOLOGY                  m_wdmTunerTopology;

    // WDM global property headers
    PKSPIN_MEDIUM               m_pTVTunerPinsMediumInfo;
    PBOOL                       m_pTVTunerPinsDirectionInfo;
    KSPROPERTY_ITEM             m_wdmTunerProperties[KSPROPERTIES_TUNER_LAST];
    KSPROPERTY_SET              m_wdmTunerPropertySet;

    // WDM global stream headers
    HW_STREAM_HEADER            m_wdmTunerStreamHeader;

    // WDM adapter properties
    // configuration properties
    CATIHwConfiguration         m_CATIConfiguration;
    ULONG                       m_ulNumberOfStandards;
    ATI_KSPROPERTY_TUNER_CAPS   m_wdmTunerCaps;
    ULONG                       m_ulVideoStandard;
    ULONG                       m_ulTuningFrequency;
    ULONG                       m_ulSupportedModes;
    ULONG                       m_ulTunerMode;
    ULONG                       m_ulNumberOfPins;
    ULONG                       m_ulTunerInput;
    DEVICE_POWER_STATE          m_ulPowerState;

    // configuration properties
    UINT                        m_uiTunerId;
    ULONG                       m_ulIntermediateFrequency;
    UCHAR                       m_uchTunerI2CAddress;

    // I2C client properties
    CI2CScript *                m_pI2CScript;

// Implementation
public:
    BOOL        AdapterUnInitialize             ( PHW_STREAM_REQUEST_BLOCK pSrb);
    BOOL        AdapterGetStreamInfo            ( PHW_STREAM_REQUEST_BLOCK pSrb);
    BOOL        AdapterQueryUnload              ( PHW_STREAM_REQUEST_BLOCK pSrb);
    BOOL        AdapterGetProperty              ( PHW_STREAM_REQUEST_BLOCK pSrb);
    BOOL        AdapterSetProperty              ( PHW_STREAM_REQUEST_BLOCK pSrb);
    NTSTATUS    AdapterSetPowerState            ( PHW_STREAM_REQUEST_BLOCK pSrb);
    NTSTATUS    AdapterCompleteInitialization   ( PHW_STREAM_REQUEST_BLOCK pSrb);

private:
    BOOL        SetTunerWDMCapabilities         ( UINT uiTunerId);
    void        SetWDMTunerKSProperties         ( void);
    void        SetWDMTunerKSTopology           ( void);

    BOOL        SetTunerVideoStandard           ( ULONG ulStandard);
    BOOL        SetTunerInput                   ( ULONG nInput);
    BOOL        SetTunerFrequency               ( ULONG ulFrequency);
    BOOL        SetTunerMode                    ( ULONG ulModeToSet);

    BOOL        GetTunerPLLOffsetBusyStatus     ( PLONG plPLLOffset, PBOOL pbBusyStatus);

    USHORT      GetTunerControlCode             ( ULONG ulFrequencyDivider);
};


#endif  // _WDMTUNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\tuners\1236\wdmtuner.cpp ===
//==========================================================================;
//
//  WDMTuner.CPP
//  WDM Tuner MiniDriver. 
//      Philips Tuner. 
//          CATIWDMTuner class implementation.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//      $Date:   10 Aug 1999 16:15:44  $
//  $Revision:   1.6  $
//    $Author:   KLEBANOV  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "atitunep.h"
#include "wdmdrv.h"
#include "aticonfg.h"


#define ATI_TVAUDIO_SUPPORT


/*^^*
 *      AdapterCompleteInitialization()
 * Purpose  : Called when SRB_COMPLETE_UNINITIALIZATION SRB is received.
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : BOOL : returns TRUE
 * Author   : IKLEBANOV
 *^^*/
NTSTATUS CATIWDMTuner::AdapterCompleteInitialization( PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PADAPTER_DATA_EXTENSION pPrivateData = ( PADAPTER_DATA_EXTENSION)( pSrb->HwDeviceExtension);
    PDEVICE_OBJECT pDeviceObject = pPrivateData->PhysicalDeviceObject;
    KSPIN_MEDIUM    mediumKSPin;
    NTSTATUS        ntStatus;
    UINT            nIndex;
    HANDLE          hFolder;
    ULONG           ulInstance;

    ENSURE
    {
        nIndex = 0;

        switch( m_ulNumberOfPins)
        {
            case 2:
                // TVTuner with TVAudio
                ::RtlCopyMemory( &m_pTVTunerPinsMediumInfo[nIndex ++], &ATITVTunerVideoOutMedium, sizeof( KSPIN_MEDIUM));
#ifdef ATI_TVAUDIO_SUPPORT
#pragma message ("\n!!! PAY ATTENTION: Tuner PinMedium is compiled with TVAudio support !!!\n")
                ::RtlCopyMemory( &m_pTVTunerPinsMediumInfo[nIndex], &ATITVTunerTVAudioOutMedium, sizeof( KSPIN_MEDIUM));
#else
#pragma message ("\n!!! PAY ATTENTION: Tuner PinMedium is compiled without TVAudio support !!!\n")
                ::RtlCopyMemory( &m_pTVTunerPinsMediumInfo[nIndex ++], &ATIXBarAudioTunerInMedium, sizeof( KSPIN_MEDIUM));
#endif
                break;

            case 3:
                // TVTuner with TVAudio with separate FM Audio output
                ::RtlCopyMemory( &m_pTVTunerPinsMediumInfo[nIndex ++], &ATITVTunerVideoOutMedium, sizeof( KSPIN_MEDIUM));
#ifdef ATI_TVAUDIO_SUPPORT
                ::RtlCopyMemory( &m_pTVTunerPinsMediumInfo[nIndex ++], &ATITVTunerTVAudioOutMedium, sizeof( KSPIN_MEDIUM));
#else
                ::RtlCopyMemory( &m_pTVTunerPinsMediumInfo[nIndex ++], &ATIXBarAudioTunerInMedium, sizeof( KSPIN_MEDIUM));
#endif

            case 1:
                // it can be FM Tuner only.
                ::RtlCopyMemory( &m_pTVTunerPinsMediumInfo[nIndex], &ATITVTunerRadioAudioOutMedium, sizeof( KSPIN_MEDIUM));
                break;
        }

        ulInstance = ::GetDriverInstanceNumber( pDeviceObject);
        hFolder = ::OpenRegistryFolder( pDeviceObject, UNICODE_WDM_REG_PIN_MEDIUMS);

        for( nIndex = 0; nIndex < m_ulNumberOfPins; nIndex ++)
        {
            if( ::ReadPinMediumFromRegistryFolder( hFolder, nIndex, &mediumKSPin))
                ::RtlCopyMemory( &m_pTVTunerPinsMediumInfo[nIndex], &mediumKSPin, sizeof( KSPIN_MEDIUM));
            m_pTVTunerPinsMediumInfo[nIndex].Id = ulInstance;

            // all the possible pins exposed are the outputs
            m_pTVTunerPinsDirectionInfo[nIndex] = TRUE;
        }

        if( hFolder != NULL)
            ::ZwClose( hFolder);

        ntStatus = StreamClassRegisterFilterWithNoKSPins( \
                        pDeviceObject                   ,       // IN PDEVICE_OBJECT   DeviceObject,
                        &KSCATEGORY_TVTUNER,                    // IN GUID           * InterfaceClassGUID
                        m_ulNumberOfPins,                       // IN ULONG            PinCount,
                        m_pTVTunerPinsDirectionInfo,            // IN ULONG          * Flags,
                        m_pTVTunerPinsMediumInfo,               // IN KSPIN_MEDIUM   * MediumList,
                        NULL);                                  // IN GUID           * CategoryList

        if( !NT_SUCCESS( ntStatus))
            FAIL;

        OutputDebugInfo(( "CATIWDMTuner:AdapterCompleteInitialization() exit\n"));

    } END_ENSURE;

    if( !NT_SUCCESS( ntStatus))
        OutputDebugError(( "CATIWDMTuner:AdapterCompleteInitialization() ntStatus=%x\n",    ntStatus));

    return( ntStatus);
}



/*^^*
 *      AdapterUnInitialize()
 * Purpose  : Called when SRB_UNINITIALIZE_DEVICE SRB is received.
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : BOOL : returns TRUE
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::AdapterUnInitialize( PHW_STREAM_REQUEST_BLOCK pSrb)
{

    OutputDebugTrace(( "CATIWDMTuner:AdapterUnInitialize()\n"));

    // just deallocate the any memory was allocated at run-time
    if( m_pTVTunerPinsMediumInfo != NULL)
    {
        ::ExFreePool( m_pTVTunerPinsMediumInfo);
        m_pTVTunerPinsMediumInfo = NULL;
    }

    if( m_pTVTunerPinsDirectionInfo != NULL)
    {
        ::ExFreePool( m_pTVTunerPinsDirectionInfo);
        m_pTVTunerPinsDirectionInfo = NULL;
    }

    pSrb->Status = STATUS_SUCCESS;
    return( TRUE);
}


/*^^*
 *      AdapterGetStreamInfo()
 * Purpose  : fills in HW_STREAM_HEADER for StreamClass driver
 *
 * Inputs   : PHW_STREAM_REQUEST_BLOCK pSrb : pointer to the current Srb
 *
 * Outputs  : BOOL : returns TRUE
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::AdapterGetStreamInfo( PHW_STREAM_REQUEST_BLOCK pSrb)
{
     // pick up the pointer to the stream header data structure
    PHW_STREAM_HEADER pStreamHeader = ( PHW_STREAM_HEADER)&( pSrb->CommandData.StreamBuffer->StreamHeader);

    // no streams are supported
    DEBUG_ASSERT( pSrb->NumberOfBytesToTransfer >= sizeof( HW_STREAM_HEADER));

    OutputDebugTrace(( "CATIWDMTuner:AdapterGetStreamInfo()\n"));

    m_wdmTunerStreamHeader.NumberOfStreams = 0;
    m_wdmTunerStreamHeader.SizeOfHwStreamInformation = sizeof( HW_STREAM_INFORMATION);
    m_wdmTunerStreamHeader.NumDevPropArrayEntries = 1;
    m_wdmTunerStreamHeader.DevicePropertiesArray = &m_wdmTunerPropertySet;
    m_wdmTunerStreamHeader.NumDevEventArrayEntries = 0;
    m_wdmTunerStreamHeader.DeviceEventsArray = NULL;
    m_wdmTunerStreamHeader.Topology = &m_wdmTunerTopology;

    * pStreamHeader = m_wdmTunerStreamHeader;

    pSrb->Status = STATUS_SUCCESS;
    return( TRUE);
}


/*^^*
 *      AdapterQueryUnload()
 * Purpose  : Called when the class driver is about to unload the MiniDriver
 *              The MiniDriver checks if any open stream left.
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : BOOL : returns TRUE
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::AdapterQueryUnload( PHW_STREAM_REQUEST_BLOCK pSrb)
{

    OutputDebugTrace(( "CATIWDMTuner:AdapterQueryUnload()\n"));

    pSrb->Status = STATUS_SUCCESS;
    return( TRUE);
}



/*^^*
 *      operator new
 * Purpose  : CATIWDMTuner class overloaded operator new.
 *              Provides placement for a CATIWDMTuner class object from the PADAPTER_DEVICE_EXTENSION
 *              allocated by the StreamClassDriver for the MiniDriver.
 *
 * Inputs   :   UINT size_t         : size of the object to be placed
 *              PVOID pAllocation   : casted pointer to the CWDMTuner allocated data
 *
 * Outputs  : PVOID : pointer of the CATIWDMTuner class object
 * Author   : IKLEBANOV
 *^^*/
PVOID CATIWDMTuner::operator new( size_t size_t, PVOID pAllocation)
{

    if( size_t != sizeof( CATIWDMTuner))
    {
        OutputDebugError(( "CATIWDMTuner: operator new() fails\n"));
        return( NULL);
    }
    else
        return( pAllocation);
}



/*^^*
 *      ~CATIWDMTuner()
 * Purpose  : CATIWDMTuner class destructor.
 *              Frees the allocated memory.
 *
 * Inputs   : none
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
CATIWDMTuner::~CATIWDMTuner()
{

    OutputDebugTrace(( "CATIWDMTuner:~CATIWDMTuner()\n"));

    if( m_pTVTunerPinsMediumInfo != NULL)
    {
        ::ExFreePool( m_pTVTunerPinsMediumInfo);
        m_pTVTunerPinsMediumInfo = NULL;
    }

    if( m_pTVTunerPinsDirectionInfo != NULL)
    {
        ::ExFreePool( m_pTVTunerPinsDirectionInfo);
        m_pTVTunerPinsDirectionInfo = NULL;
    }
}



/*^^*
 *      CATIWDMTuner()
 * Purpose  : CATIWDMTuner class constructor.
 *              Performs checking of the hardware presence. Sets the hardware in an initial state.
 *
 * Inputs   :   CI2CScript * pCScript   : pointer to the I2CScript class object
 *              PUINT puiError          : pointer to return a completion error code
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
CATIWDMTuner::CATIWDMTuner( PPORT_CONFIGURATION_INFORMATION pConfigInfo, CI2CScript * pCScript, PUINT puiErrorCode)
    :m_CATIConfiguration( pConfigInfo, pCScript, puiErrorCode)
{
    UINT uiError;

    OutputDebugTrace(( "CATIWDMTuner:CATIWDMTuner() enter\n"));

    // error code was carried over from ATIConfiguration class constructor
    uiError = * puiErrorCode;

    m_pTVTunerPinsMediumInfo = NULL;
    m_pTVTunerPinsDirectionInfo = NULL;
    m_ulPowerState = PowerDeviceD0;
    
    ENSURE
    {
        if( uiError != WDMMINI_NOERROR)
            // ATIConfiguration Class object was constructed with an error
            FAIL;

        if( pCScript == NULL)
        {
            uiError = WDMMINI_INVALIDPARAM;
            FAIL;
        }

        if( !m_CATIConfiguration.GetTunerConfiguration( &m_uiTunerId, &m_uchTunerI2CAddress) ||
            ( !m_uchTunerI2CAddress))
        {
            // there was no hardware information found
            uiError = WDMMINI_NOHARDWARE;
            FAIL;
        }

        // Set tuner capabilities ( RO properties) based upon the TunerId
        if( !SetTunerWDMCapabilities( m_uiTunerId) || ( !m_ulNumberOfPins))
        {
            // there is unsupported hardware was found
            uiError = WDMMINI_UNKNOWNHARDWARE;
            FAIL;
        }

        m_pTVTunerPinsMediumInfo = ( PKSPIN_MEDIUM) \
            ::ExAllocatePool( NonPagedPool, sizeof( KSPIN_MEDIUM) * m_ulNumberOfPins);
        if( m_pTVTunerPinsMediumInfo == NULL)
        {
            uiError = WDMMINI_ERROR_MEMORYALLOCATION;
            FAIL;
        }
        
        m_pTVTunerPinsDirectionInfo = ( PBOOL) \
            ::ExAllocatePool( NonPagedPool, sizeof( BOOL) * m_ulNumberOfPins);
        if( m_pTVTunerPinsDirectionInfo == NULL)
        {
            uiError = WDMMINI_ERROR_MEMORYALLOCATION;
            FAIL;
        }

        m_pI2CScript = pCScript;

        SetWDMTunerKSProperties();
        SetWDMTunerKSTopology();

        // Set run-time WDM properties at the last
        m_ulVideoStandard = ( m_ulNumberOfStandards == 1) ?
            // unknown standard or the only one
            m_wdmTunerCaps.ulStandardsSupported : 0x0L;
        m_ulTunerInput = 0L;                // unknown input or the only one
        m_ulTuningFrequency = 0L;           // unknown tuning frequency

#ifndef ATI_TVAUDIO_SUPPORT
        {
            // this code is needed to initilaize TVAudio path off the tuner
            // if there is no separate MiniDriver for TVAudio is assumed
            UINT    uiAudioConfiguration;
            UCHAR   uchAudioI2CAddress;

            if( m_CATIConfiguration.GetAudioConfiguration( &uiAudioConfiguration,
                                                           &uchAudioI2CAddress))
            {
                m_CATIConfiguration.InitializeAudioConfiguration( pCScript,
                                                                  uiAudioConfiguration,
                                                                  uchAudioI2CAddress);
            }
        }
#endif  // ATI_TVAUDIO_SUPPORT

        * puiErrorCode = WDMMINI_NOERROR;

        OutputDebugTrace(( "CATIWDMTuner:CATIWDMTuner() exit\n"));

        return;

    } END_ENSURE;

    * puiErrorCode = uiError;

    OutputDebugError(( "CATIWDMTuner:CATIWDMTuner() Error = %x\n", uiError));
}



/*^^*
 *      SetTunerCapabilities()
 * Purpose  :  Sets the capabilities ( RO properties) based upon the Tuner Id
 *
 * Inputs   :   UINT puiTunerId : Tuner Id
 *
 * Outputs  : returns TRUE, if there is a supported Tuner Id specified;
 *              also sets the following WDM Tuner properities:
 * Author   : IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::SetTunerWDMCapabilities( UINT uiTunerId)
{
    
    ::RtlZeroMemory( &m_wdmTunerCaps, sizeof( ATI_KSPROPERTY_TUNER_CAPS));
    m_ulIntermediateFrequency = 0x0L;

    switch( uiTunerId)
    {
        case 0x01:      // FI1236 NTSC M/N North America
            m_ulNumberOfStandards = 3;
            m_wdmTunerCaps.ulStandardsSupported = KS_AnalogVideo_NTSC_M |
                                                  KS_AnalogVideo_PAL_M |
                                                  KS_AnalogVideo_PAL_N;
            m_wdmTunerCaps.ulNumberOfInputs = 1;
            m_wdmTunerCaps.ulMinFrequency =  54000000L;
            m_wdmTunerCaps.ulMaxFrequency = 801250000L;
            m_ulIntermediateFrequency = 45750000L;
            m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV;
            m_ulNumberOfPins = 2;
                break;

        case 0x02:      // FI1236J NTSC M/N Japan
            m_ulNumberOfStandards = 1;
            m_wdmTunerCaps.ulStandardsSupported = KS_AnalogVideo_NTSC_M_J;
            m_wdmTunerCaps.ulNumberOfInputs = 1;
            m_wdmTunerCaps.ulMinFrequency =  54000000L;
            m_wdmTunerCaps.ulMaxFrequency = 765250000L;
            m_ulIntermediateFrequency = 45750000L; 
            m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV;
            m_ulNumberOfPins = 2;
            break;

        case 0x03:      // FI1216 PAL B/G
            m_ulNumberOfStandards = 2;
            m_wdmTunerCaps.ulStandardsSupported = KS_AnalogVideo_PAL_B  |
                                                  KS_AnalogVideo_PAL_G;
            m_wdmTunerCaps.ulNumberOfInputs = 1;
            m_wdmTunerCaps.ulMinFrequency =  54000000L;
            m_wdmTunerCaps.ulMaxFrequency = 855250000L;
            m_ulIntermediateFrequency = 38900000L; 
            m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV;
            m_ulNumberOfPins = 2;
            break;

        case 0x04:      // FI1246 MK2 PAL I
            m_ulNumberOfStandards = 1;
            m_wdmTunerCaps.ulStandardsSupported = KS_AnalogVideo_PAL_I;
            m_wdmTunerCaps.ulNumberOfInputs = 1;
            m_wdmTunerCaps.ulMinFrequency =  45750000L;
            m_wdmTunerCaps.ulMaxFrequency = 855250000L;
            m_ulIntermediateFrequency = 38900000L; 
            m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV;
            m_ulNumberOfPins = 2;
            break;

        case 0x05:      // FI1216 PAL B/G, SECAM L/L'
            m_ulNumberOfStandards = 3;
            m_wdmTunerCaps.ulStandardsSupported =   KS_AnalogVideo_PAL_B |
                                                    KS_AnalogVideo_PAL_G |
                                                    KS_AnalogVideo_SECAM_L;
            m_wdmTunerCaps.ulNumberOfInputs = 1;
            m_wdmTunerCaps.ulMinFrequency =  54000000L;
            m_wdmTunerCaps.ulMaxFrequency = 855250000L;
            m_ulIntermediateFrequency = 38900000L; 
            m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV;
            m_ulNumberOfPins = 2;
            break;

        case 0x06:      // FR1236MK2 NTSC M/N North America + Japan
            m_ulNumberOfStandards = 4;
            m_wdmTunerCaps.ulStandardsSupported = KS_AnalogVideo_NTSC_M |
                                                  KS_AnalogVideo_PAL_M  |
                                                  KS_AnalogVideo_NTSC_M_J |
                                                  KS_AnalogVideo_PAL_N;
            m_wdmTunerCaps.ulNumberOfInputs = 1;
            m_wdmTunerCaps.ulMinFrequency =  54000000L;
            m_wdmTunerCaps.ulMaxFrequency = 801250000L;
            m_ulIntermediateFrequency = 45750000L; 
            m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV;
            m_ulNumberOfPins = 2;
            break;

        case 0x07:      // FI1256 PAL D/K China
            m_ulNumberOfStandards = 1;
            m_wdmTunerCaps.ulStandardsSupported =   KS_AnalogVideo_PAL_D |
                                                    KS_AnalogVideo_SECAM_D;
            m_wdmTunerCaps.ulNumberOfInputs = 1;
            m_wdmTunerCaps.ulMinFrequency =  48250000L;
            m_wdmTunerCaps.ulMaxFrequency = 855250000L;
            m_ulIntermediateFrequency = 38000000L; 
            m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV;
            m_ulNumberOfPins = 2;
            break;

        case 0x08:      // NTSC North America NEC FM Tuner
            m_ulNumberOfStandards = 3;
            m_wdmTunerCaps.ulStandardsSupported = KS_AnalogVideo_NTSC_M |
                                                  KS_AnalogVideo_PAL_M |
                                                  KS_AnalogVideo_PAL_N;
            m_wdmTunerCaps.ulNumberOfInputs = 2;
            m_wdmTunerCaps.ulMinFrequency =  54000000L;
            m_wdmTunerCaps.ulMaxFrequency = 801250000L;
            m_ulIntermediateFrequency = 45750000L; 
            m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV |
                                 KSPROPERTY_TUNER_MODE_FM_RADIO;
            m_ulNumberOfPins = 2;
            break;

        case 0x10:      // NTSC North America Alps Tuner
        case 0x11:      // NTSC North America Alps Tuner
            m_ulNumberOfStandards = 3;
            m_wdmTunerCaps.ulStandardsSupported = KS_AnalogVideo_NTSC_M |
                                                  KS_AnalogVideo_PAL_M |
                                                  KS_AnalogVideo_PAL_N;
            m_wdmTunerCaps.ulNumberOfInputs = 1;
            m_wdmTunerCaps.ulMinFrequency =  54000000L;
            m_wdmTunerCaps.ulMaxFrequency = 801250000L;
            m_ulIntermediateFrequency = 45750000L; 
            m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV;
            m_ulNumberOfPins = 2;
            break;

        case 0x12:      // NTSC North America Alps Tuner with FM
            m_ulNumberOfStandards = 3;
            m_wdmTunerCaps.ulStandardsSupported = KS_AnalogVideo_NTSC_M |
                                                  KS_AnalogVideo_PAL_M |
                                                  KS_AnalogVideo_PAL_N;
            m_wdmTunerCaps.ulNumberOfInputs = 1;
            m_wdmTunerCaps.ulMinFrequency =  54000000L;
            m_wdmTunerCaps.ulMaxFrequency = 801250000L;
            m_ulIntermediateFrequency = 45750000L; 
            m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV |
                                 KSPROPERTY_TUNER_MODE_FM_RADIO;
            m_ulNumberOfPins = 2;
            break;

        case 0x0D:      // Temic 4006 FN5 PAL B/G + PAL/I + PAL D + SECAM D/K
            m_ulNumberOfStandards = 6;
            m_wdmTunerCaps.ulStandardsSupported =   KS_AnalogVideo_PAL_B    |
                                                    KS_AnalogVideo_PAL_G    |
                                                    KS_AnalogVideo_PAL_I    |
                                                    KS_AnalogVideo_PAL_D    |
                                                    KS_AnalogVideo_SECAM_D  |
                                                    KS_AnalogVideo_SECAM_K;
            m_wdmTunerCaps.ulNumberOfInputs = 1;
            m_wdmTunerCaps.ulMinFrequency =  45000000L;
            m_wdmTunerCaps.ulMaxFrequency = 868000000L;
            m_ulIntermediateFrequency = 38900000L; 
            m_ulSupportedModes = KSPROPERTY_TUNER_MODE_TV;
            m_ulNumberOfPins = 2;
            break;


        default:
            return( FALSE);
    }

    m_ulTunerMode = KSPROPERTY_TUNER_MODE_TV;

    m_wdmTunerCaps.ulTuningGranularity = 62500L;
    m_wdmTunerCaps.ulSettlingTime = 150;
    m_wdmTunerCaps.ulStrategy = KS_TUNER_STRATEGY_PLL;

    return( TRUE);
}



/*^^*
 *      AdapterSetPowerState()
 * Purpose  :   Sets Power Managemeny mode
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  :   NTSTATUS as the result of operation
 * Author   :   TOM
 *^^*/
NTSTATUS CATIWDMTuner::AdapterSetPowerState( PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PADAPTER_DATA_EXTENSION pPrivateData = 
        ( PADAPTER_DATA_EXTENSION)(( PHW_STREAM_REQUEST_BLOCK)pSrb)->HwDeviceExtension;
    CI2CScript *        pCScript    = &pPrivateData->CScript;
    DEVICE_POWER_STATE  nDeviceState = pSrb->CommandData.DeviceState;
    LARGE_INTEGER       liWakeUpTime;
    NTSTATUS            ntStatus;

    m_pPendingDeviceSrb = pSrb;
    ntStatus = STATUS_ADAPTER_HARDWARE_ERROR;

    switch( nDeviceState)
    {
        case PowerDeviceD0:
        case PowerDeviceD3:
            if( nDeviceState != m_ulPowerState)
            {
                m_CATIConfiguration.SetTunerPowerState( m_pI2CScript,
                                        ( nDeviceState == PowerDeviceD0 ? TRUE : FALSE));

                // if transition form D3 to D0 we have to restore frequency
                if(( nDeviceState == PowerDeviceD0) && ( m_ulPowerState == PowerDeviceD3))
                {
                    // we have to wait approx. 10ms for tuner to power up
                    liWakeUpTime.QuadPart = ATIHARDWARE_TUNER_WAKEUP_DELAY;
                    KeDelayExecutionThread( KernelMode, FALSE, &liWakeUpTime);

                    // now we have to restore frequency
                    if( SetTunerFrequency( m_ulTuningFrequency))
                        ntStatus = STATUS_SUCCESS;
                    else
                        ntStatus = STATUS_ADAPTER_HARDWARE_ERROR;
                }
                else
                    ntStatus = STATUS_SUCCESS;

                m_ulPowerState = nDeviceState;
            }
            else
                ntStatus = STATUS_SUCCESS;
            break;

        case PowerDeviceD1:
        case PowerDeviceD2:
            ntStatus = STATUS_SUCCESS;
            break;

        default:
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    return( ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\tuners\1236\tunerhdw.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "wdmdrv.h"
#include "atitunep.h"
#include "aticonfg.h"
#include "tunerhdw.h"


/*^^*
 *		GetTunerPLLOffsetBusyStatus()
 * Purpose	: Returns tuner Busy status and PLLOffset, if the tuner is not busy
 *				The function reads the hardware in order to accomplish the task
 *				The operation might be carried on either synchronously or asynchronously
 * Inputs	:	PLONG plPLLOffset	: a pointer to write a PLLOffset value
 *				PBOOL pbBusyStatus	: a pointer to write a Busy status
 *
 * Outputs	: BOOL : returns TRUE, if the operation succeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::GetTunerPLLOffsetBusyStatus( PLONG plPLLOffset, PBOOL pbBusyStatus)
{
	UCHAR		uchI2CValue;
	I2CPacket	i2cPacket;
	BOOL		bResult;

	i2cPacket.uchChipAddress = m_uchTunerI2CAddress;
	i2cPacket.cbReadCount = 1;
	i2cPacket.cbWriteCount = 0;
	i2cPacket.puchReadBuffer = &uchI2CValue;
	i2cPacket.puchWriteBuffer = NULL;
	i2cPacket.usFlags = 0;

	bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
	if( bResult)
		bResult = ( i2cPacket.uchI2CResult == I2C_STATUS_NOERROR);

	if( bResult)
	{
		* pbBusyStatus = !(( BOOL)( uchI2CValue & 0x40));		// bit 6 - PLL locked indicator
		if( !( * pbBusyStatus))
		{
			uchI2CValue &= 0x07;								// only 3 LSBits are PLLOffset
			// let's map the result into MS defined values from -2 to 2
			* plPLLOffset = uchI2CValue - 2;
		}
	}

	return( bResult);
}



/*^^*
 *		SetTunerMode()
 * Purpose	: Sets one of the possible Tuner modes to operate
 * Inputs	: ULONG ulModeToSet	: an operation mode required to be set
 *
 * Outputs	: BOOL : returns TRUE, if the operation succeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::SetTunerMode( ULONG ulModeToSet)
{

	return( TRUE);
}



/*^^*
 *		SetTunerVideoStandard()
 * Purpose	: Sets one of the possible Tuner standards as an active one
 * Inputs	:	ULONG ulStandard	: a standard required to be set
 *
 * Outputs	: BOOL : returns TRUE, if the operation succeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::SetTunerVideoStandard( ULONG ulStandard)
{

	return( TRUE);
}



/*^^*
 *		SetTunerFrequency()
 * Purpose	: Sets a new Tuner frequency
 *				The operation might be carried on either synchronously or asynchronously
 * Inputs	:	ULONG ulFrequency		: a frequency required to be set
 *
 * Outputs	: BOOL : returns TRUE, if the operation succeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::SetTunerFrequency( ULONG ulFrequency)
{
	ULONG		ulFrequenceDivider;
	USHORT		usControlCode;
	UCHAR		auchI2CBuffer[4];
	I2CPacket	i2cPacket;
	BOOL		bResult;

	ASSERT( m_ulIntermediateFrequency != 0L);
	
	// Set the video carrier frequency by controlling the programmable divider
	// N = ( 16 * ( FreqRF + FreqIntermediate)) / 1000000
	ulFrequenceDivider = ( ulFrequency + m_ulIntermediateFrequency);
	ulFrequenceDivider /= ( 1000000 / 16);

	usControlCode = GetTunerControlCode( ulFrequenceDivider);
	if( !usControlCode)
		return( FALSE);
	
	auchI2CBuffer[0] = ( UCHAR)( ulFrequenceDivider >> 8);
	auchI2CBuffer[1] = ( UCHAR)ulFrequenceDivider;
	auchI2CBuffer[2] = ( UCHAR)( usControlCode >> 8);
	auchI2CBuffer[3] = ( UCHAR)usControlCode;

	i2cPacket.uchChipAddress = m_uchTunerI2CAddress;
	i2cPacket.cbReadCount = 0;
	i2cPacket.cbWriteCount = 4;
	i2cPacket.puchReadBuffer = NULL;
	i2cPacket.puchWriteBuffer = auchI2CBuffer;
	i2cPacket.usFlags = 0;

	bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);

	if( bResult)
		bResult = ( i2cPacket.uchI2CResult == I2C_STATUS_NOERROR) ? TRUE : FALSE;

	return( bResult);
}



/*^^*
 *		SetTunerInput()
 * Purpose	: Sets one of the possible Tuner inputs as an active one
 * Inputs	:	ULONG nInput				: input number required to be set as an active ( begins from 0)
 *
 * Outputs	: BOOL : returns TRUE, if the operation succeded
 * Author	: IKLEBANOV
 *^^*/
BOOL CATIWDMTuner::SetTunerInput( ULONG nInput)
{
	
	// no real things to do at all
	return( TRUE);
}




/*^^*
 *		GetTunerControlCode()
 * Purpose	: Determines the Tuner control code to be send to tuner with a new frequency value
 *
 * Inputs	:	ULONG ulFrequencyDivider	: new frequency divider
 *
 * Outputs	: USHORT : value, the tuner should be programmed, when the new frequency is set
 *				id the is no valid uiTunerId is passed as paramter, 0 is returned
 * Author	: IKLEBANOV
 *^^*/
USHORT CATIWDMTuner::GetTunerControlCode( ULONG ulFrequencyDivider)
{
            
	USHORT	usLowBandFrequencyHigh, usMiddleBandFrequencyHigh;
	USHORT	usLowBandControl, usMiddleBandControl, usHighBandControl;
	USHORT	usControlCode = 0;

	usLowBandFrequencyHigh 		= kUpperLowBand;
	usMiddleBandFrequencyHigh 	= kUpperMidBand;  
	usLowBandControl 			= kLowBand;
	usMiddleBandControl 		= kMidBand;
	usHighBandControl 			= kHighBand;
			
	switch( m_uiTunerId)
	{
		case 0x01 : 	// NTSC N/A
		case 0x02 :		// NTSC Japan
		case 0x06 : 	// NTSC Japan Philips MK2, PAL 
			// these tuners support NTSC standard
			if(( m_ulVideoStandard == KS_AnalogVideo_NTSC_M) &&
			   (( ulFrequencyDivider == kAirChannel63) ||
				( ulFrequencyDivider == kAirChannel64)))
			{
				// special case for TEMIC tuner
				return( kTemicControl);
			}
			break;

		case 0x08 :		// FM Tuner
			usLowBandControl	= kLowBand_NTSC_FM;
			usMiddleBandControl = kMidBand_NTSC_FM;
			usHighBandControl	= kHighBand_NTSC_FM;
			break;
			
		case 0x03 :		// PAL B/G
		case 0x04 :		// PAL I
			break;
			
		case 0x05 : 	// SECAM & PAL B/G
			if ( m_ulVideoStandard == KS_AnalogVideo_SECAM_L)
			{
				usLowBandFrequencyHigh		= kUpperLowBand_SECAM;
				usMiddleBandFrequencyHigh	= kUpperMidBand_SECAM;
				usLowBandControl			= kLowBand_SECAM;
				usMiddleBandControl			= kMidBand_SECAM;
				usHighBandControl			= kHighBand_SECAM;
			}
			else
			{
				usLowBandControl	= kLowBand_PALBG;
				usMiddleBandControl	= kMidBand_PALBG;
				usHighBandControl	= kHighBand_PALBG;
			}
			break;
			
		case 0x07 :		// PAL D China
			usLowBandFrequencyHigh		= kUpperLowBand_PALD;
			usMiddleBandFrequencyHigh	= kUpperMidBand_PALD;
			break;
			
		case 0x10:		// NTSC NA Alps Tuner
		case 0x11:
		case 0x12:
				usLowBandFrequencyHigh		= kUpperLowBand_ALPS;
				usMiddleBandFrequencyHigh	= kUpperMidBand_ALPS;
				usLowBandControl			= kLowBand_ALPS;
				usMiddleBandControl			= kMidBand_ALPS;
				usHighBandControl			= kHighBand_ALPS;
				break;

		case 0x0D:		// PAL B/G + PAL/I + PAL D + SECAM D/K
			break;

		default :
			return( usControlCode);
	}
	
	if( ulFrequencyDivider <= ( ULONG)usLowBandFrequencyHigh)
		usControlCode = usLowBandControl;
	else
	{
		if( ulFrequencyDivider <= ( ULONG)usMiddleBandFrequencyHigh)
			usControlCode = usMiddleBandControl;
		else
			usControlCode = usHighBandControl;
	}

	return( usControlCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\tvaudio\atitvsnd\atitvsnd.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//	ATIVSnd.H
//	WDM TV Audio MiniDriver. 
//		AllInWonder/AllInWonderPro hardware development platform. 
//			Main Include Module.
//
//==========================================================================;

#ifndef _ATITVSND_H_
#define _ATITVSND_H_

#include "wdmtvsnd.h"

typedef struct
{
	CI2CScript		CScript;
	CWDMTVAudio		CTVAudio;

	PDEVICE_OBJECT	PhysicalDeviceObject;

	// for managing SRB Queue and internal driver synchronization
	BOOL			bSrbInProcess;
	LIST_ENTRY		adapterSrbQueueHead;
	KSPIN_LOCK		adapterSpinLock;

} ADAPTER_DATA_EXTENSION, * PADAPTER_DATA_EXTENSION;


typedef struct
{
	// please, don't move this member from its first place in the structure
	// if you do, change the code to use FIELDOFFSET macro to retrieve pSrb
	// member offset within this structure. The code as it's written assumes
	// LIST_ENTRY * == SRB_DATA_EXTENSION *
	LIST_ENTRY					srbListEntry;
	PHW_STREAM_REQUEST_BLOCK	pSrb;

} SRB_DATA_EXTENSION, * PSRB_DATA_EXTENSION;


/*
	Call-backs from the StreamClass
*/
extern "C"
void STREAMAPI TVAudioReceivePacket				( PHW_STREAM_REQUEST_BLOCK pSrb);
extern "C"
void STREAMAPI TVAudioCancelPacket				( PHW_STREAM_REQUEST_BLOCK pSrb);
extern "C" 
void STREAMAPI TVAudioTimeoutPacket				( PHW_STREAM_REQUEST_BLOCK pSrb);



/*
	Local prototypes
*/
void TVAudioAdapterInitialize					( PHW_STREAM_REQUEST_BLOCK pSrb);


#endif	// _ATITVSND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\tvaudio\atitvsnd\atitvsnd.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//  ATITVSnd.CPP
//  WDM TV Audio MiniDriver. 
//      AllInWonder/AllInWonderPro development platform. 
//          Main Source Module.
//
//      $Date:   01 Apr 1998 13:29:14  $
//  $Revision:   1.1  $
//    $Author:   KLEBANOV  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "atitvsnd.h"
#include "wdmdrv.h"



/*^^*
 *      DriverEntry()
 * Purpose  : Called when an SRB_INITIALIZE_DEVICE request is received
 *
 * Inputs   : PVOID Arg1, PVOID Arg2
 *
 * Outputs  : result of StreamClassregisterAdapter()
 * Author   : IKLEBANOV
 *^^*/
extern "C" 
ULONG DriverEntry ( IN PDRIVER_OBJECT   pDriverObject,
                    IN PUNICODE_STRING  pRegistryPath )
{
    HW_INITIALIZATION_DATA HwInitData;

    SetMiniDriverDebugLevel( pRegistryPath);

    OutputDebugTrace(( "ATITVSnd: DriverEntry\n"));
     
    RtlZeroMemory( &HwInitData, sizeof( HwInitData));

    HwInitData.HwInitializationDataSize = sizeof(HwInitData);

    // Entry points for Port Driver

    HwInitData.HwInterrupt                  = NULL; // HwInterrupt;

    HwInitData.HwReceivePacket              = TVAudioReceivePacket;
    HwInitData.HwCancelPacket               = TVAudioCancelPacket;
    HwInitData.HwRequestTimeoutHandler      = TVAudioTimeoutPacket;

    HwInitData.DeviceExtensionSize          = sizeof( ADAPTER_DATA_EXTENSION);
    HwInitData.PerRequestExtensionSize      = sizeof( SRB_DATA_EXTENSION); 
    HwInitData.FilterInstanceExtensionSize  = 0;
    HwInitData.PerStreamExtensionSize       = 0;
    HwInitData.BusMasterDMA                 = FALSE;  
    HwInitData.Dma24BitAddresses            = FALSE;
    HwInitData.BufferAlignment              = 3;
//  HwInitData.TurnOffSynchronization       = FALSE;
    // we turn the synchronization ON. StreamClass is expected to call the MiniDriver
    // at passive level only
    HwInitData.TurnOffSynchronization       = TRUE;
    HwInitData.DmaBufferSize                = 0;

    OutputDebugTrace(( "ATITVSnd: StreamClassRegisterAdapter\n"));

    return( StreamClassRegisterAdapter( pDriverObject, pRegistryPath, &HwInitData));
}



/*^^*
 *      TVAudioReceivePacket()
 * Purpose  : Main entry point for receiving adapter based request SRBs from the Class Driver.
 *              Will always be called at passive level, because the drivers
 *              turned the synchronization ON.
 * Note     : This is an asyncronous entry point. The request only completes when a 
 *              StreamClassDeviceNotification on this SRB, of type  DeviceRequestComplete,
 *              is issued. As soon we're running at passive level, we can do everything 
 *              synchronously during the response to the SRBs with no worry
 *              to block somebody else for a long timer during I2C access
 *
 * Inputs   : PHW_STREAM_REQUEST_BLOCK pSrb : pointer to the current Srb
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
extern "C" 
void STREAMAPI TVAudioReceivePacket( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    CWDMTVAudio *           pCTVAudio;
    KIRQL                   irqlCurrent;
    PADAPTER_DATA_EXTENSION pPrivateData = ( PADAPTER_DATA_EXTENSION)( pSrb->HwDeviceExtension);
    PSRB_DATA_EXTENSION     pSrbPrivate = ( PSRB_DATA_EXTENSION)( pSrb->SRBExtension);

    // check the device extension pointer
    if(( pPrivateData == NULL) || ( pSrbPrivate == NULL))
    {
        TRAP;
        pSrb->Status = STATUS_INVALID_PARAMETER;
        StreamClassDeviceNotification( DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
    }

    OutputDebugInfo(( "ATITVSnd: TVAudioReceivePacket() SRB = %x\n", pSrb));

    if( pSrb->Command == SRB_INITIALIZE_DEVICE)
    {
        // this is the special case for SRB_INITIALIZE_DEVICE, because
        // no Queue has been initialized yet. Everything we need later on
        // is initialized during this SRB response
        TVAudioAdapterInitialize( pSrb);

        StreamClassDeviceNotification( DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb);
        return;
    }

    // the rest of the SRBs are coming after SpinLock and SRBQueue have been initialized
    // during DRB_INITIALIZE_DEVICE SRB response.
    // I'll insert the SRB in the Queue first of all. The processing SRB from the Queue
    // can be triggered by finishing processing and SRB, or by the fact there is no SRB
    // is in process down here
    pSrbPrivate->pSrb = pSrb;

    // Everything we're doing with the Queue has to be protected from being interrupted
    KeAcquireSpinLock( &pPrivateData->adapterSpinLock, &irqlCurrent);
    InsertTailList( &pPrivateData->adapterSrbQueueHead, &pSrbPrivate->srbListEntry);

    if( pPrivateData->bSrbInProcess)
    {
        // there is another SRB being processed, and the new one will be picked up from
        // the Queue when it's its turn.
        KeReleaseSpinLock( &pPrivateData->adapterSpinLock, irqlCurrent);
        return;
    }

    while( !IsListEmpty( &pPrivateData->adapterSrbQueueHead))
    {
        // turn on the semaphore for the others coming after
        pPrivateData->bSrbInProcess = TRUE;

        // be carefull here, if you've changed the place where srbListEntry is defined
        // within the SRB_DATA_EXTENSION structure
        pSrbPrivate = ( PSRB_DATA_EXTENSION)RemoveHeadList( &pPrivateData->adapterSrbQueueHead);
        KeReleaseSpinLock( &pPrivateData->adapterSpinLock, irqlCurrent);

        // here is the place to process the SRB we have retrieved from the Queue
        pSrb = pSrbPrivate->pSrb;
        pPrivateData = ( PADAPTER_DATA_EXTENSION)( pSrb->HwDeviceExtension);
        pCTVAudio = &pPrivateData->CTVAudio;

        ASSERT( pSrb->Status != STATUS_CANCELLED);

        switch( pSrb->Command)
        {
            case SRB_INITIALIZATION_COMPLETE:
                // StreamClass has completed the initialization
                pSrb->Status = pCTVAudio->AdapterCompleteInitialization( pSrb);
                break;

            case SRB_UNINITIALIZE_DEVICE:
                // close the device.  
                pCTVAudio->AdapterUnInitialize( pSrb);
                break;

            case SRB_OPEN_STREAM:
            case SRB_CLOSE_STREAM:
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_GET_STREAM_INFO:
                // return a block describing STREAM_INFO_HEADER and all the streams supported
                pCTVAudio->AdapterGetStreamInfo( pSrb);
                break;

            case SRB_CHANGE_POWER_STATE:
                pSrb->Status = pCTVAudio->AdapterSetPowerState( pSrb);
                break;

            case SRB_GET_DEVICE_PROPERTY:
                if( pCTVAudio->AdapterGetProperty( pSrb))
                    pSrb->Status = STATUS_SUCCESS;
                else
                    pSrb->Status = STATUS_INVALID_PARAMETER;
                break;        

            case SRB_SET_DEVICE_PROPERTY:
                if( pCTVAudio->AdapterSetProperty( pSrb))
                    pSrb->Status = STATUS_SUCCESS;
                else
                    pSrb->Status = STATUS_INVALID_PARAMETER;
                break;

            // We should never get the following since this is a single instance device
            case SRB_OPEN_DEVICE_INSTANCE:
            case SRB_CLOSE_DEVICE_INSTANCE:
                TRAP
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_UNKNOWN_DEVICE_COMMAND:
                // we know we're getting some of these. Why should we?
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            default:
                // TRAP
                // this is a request that we do not understand.  Indicate invalid command and complete the request
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
        }

        StreamClassDeviceNotification( DeviceRequestComplete, pPrivateData, pSrb);

        KeAcquireSpinLock( &pPrivateData->adapterSpinLock, &irqlCurrent);
    }

    // turn off the semaphore to enable the others coming after
    pPrivateData->bSrbInProcess = FALSE;

    KeReleaseSpinLock( &pPrivateData->adapterSpinLock, irqlCurrent);
    // there is no other SRB being processed at this time, let's start processing

}


extern "C" 
void STREAMAPI TVAudioCancelPacket( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{

    pSrb->Status = STATUS_CANCELLED;
}


extern "C" 
void STREAMAPI TVAudioTimeoutPacket( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{

    // not sure what to do here.
}


/*^^*
 *      TVAudioAdapterInitialize()
 * Purpose  : Called when SRB_INITIALIZE_DEVICE SRB is received.
 *              Performs checking of the hardware presence and I2C provider availability.
 *              Sets the hardware in an initial state.
 * Note     : The request does not completed unless we know everything
 *              about the hardware and we are sure it is capable to work in the current configuration.
 *              The hardware Caps are also aquised at this point. As soon this
 *              function is called at passive level, do everything synchronously
 *
 * Inputs   : PHW_STREAM_REQUEST_BLOCK pSrb : pointer to the current Srb
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
void TVAudioAdapterInitialize( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;
    PADAPTER_DATA_EXTENSION pPrivateData = ( PADAPTER_DATA_EXTENSION)( pConfigInfo->HwDeviceExtension);
    NTSTATUS        ntStatus = STATUS_NO_SUCH_DEVICE;
    CWDMTVAudio *   pCTVAudio;
    CI2CScript *    pCScript = NULL;
    UINT            nErrorCode;

    OutputDebugTrace(( "ATITVSnd: TVAudioAdapterInitialize()\n"));

    ENSURE
    {
        if( pConfigInfo->NumberOfAccessRanges != 0) 
        {
            OutputDebugError(( "ATITVSnd: illegal NumberOfAccessRanges = %lx\n", pConfigInfo->NumberOfAccessRanges));
            FAIL;
        }

        // if we have I2CProvider implemented inside the MiniVDD, we have to
        // get a pointer to I2CInterface from the Provider.

        // There is an overloaded operator new provided for the CI2CScript Class.
        pCScript = ( CI2CScript *)new(( PVOID)&pPrivateData->CScript)
                        CI2CScript( pConfigInfo, &nErrorCode);
        if( nErrorCode != WDMMINI_NOERROR)
        {
            OutputDebugError(( "ATITVSnd: CI2CScript creation failure = %lx\n", nErrorCode));
            FAIL;
        }
        
        // The CI2CScript object was created successfully.
        // We'll try to allocate I2CProvider here for future possible I2C
        // operations needed at Initialization time.
        if( !pCScript->LockI2CProviderEx())
        {
            OutputDebugError(( "ATITVSnd: unable to lock I2CProvider"));
            FAIL;
        }

        // we did lock the provider.
        // There is an overloaded operator new provided for the CWDMTVAudio Class.
        pCTVAudio = ( CWDMTVAudio *)new(( PVOID)&pPrivateData->CTVAudio) CWDMTVAudio( pConfigInfo, pCScript, &nErrorCode);
        if( nErrorCode)
        {
            OutputDebugError(( "ATITVSnd: CWDMTVAudio constructor failure = %lx\n", nErrorCode));
            FAIL;
        }

        InitializeListHead ( &pPrivateData->adapterSrbQueueHead);
        KeInitializeSpinLock ( &pPrivateData->adapterSpinLock);

        pPrivateData->PhysicalDeviceObject = pConfigInfo->RealPhysicalDeviceObject;
        // no streams are supported
        pConfigInfo->StreamDescriptorSize = sizeof( HW_STREAM_HEADER);

        OutputDebugTrace(( "TVAudioAdapterInitialize(): exit\n"));

        ntStatus = STATUS_SUCCESS;

    } END_ENSURE;

    if (pCScript)
        pCScript->ReleaseI2CProvider();

    pSrb->Status = ntStatus;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\tvaudio\atitvsnd\tsndhdw.cpp ===
//==========================================================================;
//
//	TSndHdw.CPP
//	WDM TVAudio MiniDriver. 
//		AIW / AIWPro hardware platform. 
//			WDM Properties required hardware settings.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//		$Date:   03 Jun 1999 13:40:00  $
//	$Revision:   1.7  $
//	  $Author:   tom  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "wdmdrv.h"
#include "atitvsnd.h"
#include "aticonfg.h"



/*^^*
 *		GetAudioOperationMode()
 * Purpose	: Called when SRB_GET_PROPERTY SRB SetMode is received. Sets the requested
 *				audio operation mode ( Stereo/SAP). The function will always try to carry the
 *				request on in asynchronous mode. It fails, it will response synchronous mode
 *				of execution.
 *
 * Inputs	:	PULONG pulMode		: the pointer to return current Mode
 *
 * Outputs	: BOOL : returns FALSE, if it is not a XBar property
 *				it also sets the required property
 * Author	: IKLEBANOV
 *^^*/
BOOL CWDMTVAudio::GetAudioOperationMode( PULONG pulAudioMode)
{
	I2CPacket	i2cPacket;
	UCHAR		uchReadValue;
	UCHAR		uchWriteValue;
	BOOL		bResult, bStereoIndicator, bSAPIndicator;
	UCHAR		uchRead16Value[2];
	UCHAR		uchWrite16Value[3];

	if( pulAudioMode == NULL)
		return( FALSE);

	switch( m_uiAudioConfiguration)
	{
		case ATI_AUDIO_CONFIG_1:
		case ATI_AUDIO_CONFIG_5:
			// stereo indication is read back from I2C expander
			if( m_CATIConfiguration.GetTVAudioSignalProperties( m_pI2CScript, 
															    &bStereoIndicator,
															    &bSAPIndicator))
			{
				// language A and mono alsways present
				*pulAudioMode = KS_TVAUDIO_MODE_LANG_A | KS_TVAUDIO_MODE_MONO;
				if( bStereoIndicator)
					*pulAudioMode |= KS_TVAUDIO_MODE_STEREO;
				if( bSAPIndicator)
					*pulAudioMode |= KS_TVAUDIO_MODE_LANG_B;

				bResult = TRUE;
			}
			else
				bResult = FALSE;

			break;

		case ATI_AUDIO_CONFIG_2:
		case ATI_AUDIO_CONFIG_7:
			// Signal properties are read back from the Audio chip itself
			uchWriteValue = 0;				// register 0 should be read
			i2cPacket.uchChipAddress	= m_uchAudioChipAddress;
			i2cPacket.puchWriteBuffer	= &uchWriteValue;
			i2cPacket.puchReadBuffer	= &uchReadValue;
			i2cPacket.cbWriteCount		= 1;
			i2cPacket.cbReadCount		= 1;
			i2cPacket.usFlags			= I2COPERATION_READ;

			m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
			if( i2cPacket.uchI2CResult == I2C_STATUS_NOERROR)
			{
				// language A and mono alsways present
				*pulAudioMode = KS_TVAUDIO_MODE_LANG_A | KS_TVAUDIO_MODE_MONO;
				if( uchReadValue & AUDIO_TDA9850_Indicator_Stereo)
					*pulAudioMode |= KS_TVAUDIO_MODE_STEREO;
				if( uchReadValue & AUDIO_TDA9850_Indicator_SAP)
					*pulAudioMode |= KS_TVAUDIO_MODE_LANG_B;

				bResult = TRUE;
			}
			else
				bResult = FALSE;

			break;

		case ATI_AUDIO_CONFIG_3:
		case ATI_AUDIO_CONFIG_4:
			// Stereo nor SAP are supported
			*pulAudioMode = KS_TVAUDIO_MODE_MONO;
			bResult = TRUE;
			break;

		case ATI_AUDIO_CONFIG_6:
			// Signal properties are read back from the Audio chip itself
			i2cPacket.uchChipAddress	= m_uchAudioChipAddress;
			i2cPacket.puchWriteBuffer	= NULL;
			i2cPacket.puchReadBuffer	= &uchReadValue;
			i2cPacket.cbWriteCount		= 0;
			i2cPacket.cbReadCount		= 1;
			i2cPacket.usFlags			= I2COPERATION_READ;

			m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
			if( i2cPacket.uchI2CResult == I2C_STATUS_NOERROR)
			{
				// mono alsways present
				*pulAudioMode = KS_TVAUDIO_MODE_MONO;
				if( uchReadValue & AUDIO_TDA9851_Indicator_Stereo)
					*pulAudioMode |= KS_TVAUDIO_MODE_STEREO;

				bResult = TRUE;
			}
			else
				bResult = FALSE;

			break;

		case ATI_AUDIO_CONFIG_8:

			i2cPacket.uchChipAddress	= m_uchAudioChipAddress;
			i2cPacket.puchWriteBuffer	= uchWrite16Value;
			i2cPacket.puchReadBuffer	= uchRead16Value;
			i2cPacket.cbWriteCount		= 3;
			i2cPacket.cbReadCount		= 2;
			i2cPacket.usFlags			= I2COPERATION_READ;


			uchWrite16Value[0] = 0x11;
			uchWrite16Value[1] = 0x02;
			uchWrite16Value[2] = 0x00;

			bResult = m_pI2CScript->PerformI2CPacketOperation(&i2cPacket);
			if(bResult)
			{
				if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
					return(FALSE);
			}
			else
				return(FALSE);

			// language A and mono alsways present
			*pulAudioMode = KS_TVAUDIO_MODE_LANG_A | KS_TVAUDIO_MODE_MONO;

			//Determine STEREO/SAP
			
			if(uchRead16Value[0] & 0x40)
				*pulAudioMode |= KS_TVAUDIO_MODE_LANG_B;

			if(uchRead16Value[1] & 0x01)
				*pulAudioMode |= KS_TVAUDIO_MODE_STEREO;

			break;

		default:
			bResult = FALSE;
			break;
	}

	return( bResult);
}



/*^^*
 *		SetAudioOperationMode()
 * Purpose	: Called when SRB_SET_PROPERTY SRB SetMode is received. Sets the requested
 *				audio operation mode ( Stereo/SAP). The function will always try to carry the
 *				request on in asynchronous mode. It fails, it will response synchronous mode
 *				of execution.
 *
 * Inputs	:	ULONG ulModeToSet	: the requested mode to set
 *
 * Outputs	: BOOL : returns FALSE, if it is not a XBar property
 *				it also sets the required property
 * Author	: IKLEBANOV
 *^^*/
BOOL CWDMTVAudio::SetAudioOperationMode( ULONG ulModeToSet)
{
	I2CPacket	i2cPacket;
	USHORT		cbWriteLength;
	UCHAR		auchI2CBuffer[2];
	UCHAR		uchDeviceMode = 0;
	UCHAR		uchWrite16Value[5];
	BOOL		bResult;
	
	switch( m_uiAudioConfiguration)
	{
		case ATI_AUDIO_CONFIG_5:
			// TEA5571
		case ATI_AUDIO_CONFIG_1:
			// TEA5582 can not be forced in mono mode; nothing to do
			m_ulTVAudioMode = ulModeToSet;
			return( TRUE);

		case ATI_AUDIO_CONFIG_2:
		case ATI_AUDIO_CONFIG_7:
			// TDA9850
			if( ulModeToSet & KS_TVAUDIO_MODE_STEREO)
				uchDeviceMode |= AUDIO_TDA9850_Control_Stereo;
			if( ulModeToSet & KS_TVAUDIO_MODE_LANG_B)
				uchDeviceMode |= AUDIO_TDA9850_Control_SAP;

			auchI2CBuffer[0] = AUDIO_TDA9850_Reg_Control3;
			auchI2CBuffer[1] = uchDeviceMode;
			cbWriteLength = 2;		// SubAddress + Control Register value

			break;

		case ATI_AUDIO_CONFIG_6:
			// TDA9851
			uchDeviceMode = TDA9851_AVL_ATTACK_730;
			if( ulModeToSet & KS_TVAUDIO_MODE_STEREO)
				uchDeviceMode |= AUDIO_TDA9851_Control_Stereo;
			auchI2CBuffer[0] = uchDeviceMode;
			cbWriteLength = 1;		// Control Register value
			break;

		case ATI_AUDIO_CONFIG_8:

			if( ulModeToSet & KS_TVAUDIO_MODE_STEREO)
			{
				i2cPacket.uchChipAddress = m_uchAudioChipAddress;
				i2cPacket.cbReadCount = 0;
				i2cPacket.usFlags = I2COPERATION_WRITE;
				i2cPacket.puchWriteBuffer = uchWrite16Value;
				i2cPacket.cbWriteCount = 5;


				//SubAddr 0x10 Reg 0x30 Val 0x2003
				uchWrite16Value[0] = 0x10;
				uchWrite16Value[1] = 0x00;
				uchWrite16Value[2] = 0x30;
				uchWrite16Value[3] = 0x20;
#ifdef	I2S_CAPTURE
#pragma message ("\n!!! PAY ATTENTION: Driver has been build with ITT CHIP I2S CAPTURE CONFIGURED !!!\n")
				uchWrite16Value[4] = 0xe3;
#else
				uchWrite16Value[4] = 0x03;
#endif

				bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
				if(bResult)
				{
					if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
						return(FALSE);
				}
				else
					return(FALSE);

				//SubAddr 0x10 Reg 0x20 Val 0x0020

				uchWrite16Value[0] = 0x10;
				uchWrite16Value[1] = 0x00;
				uchWrite16Value[2] = 0x20;
				uchWrite16Value[3] = 0x00;
				uchWrite16Value[4] = 0x20;

				bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
				if(bResult)
				{
					if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
						return(FALSE);
				}
				else
					return(FALSE);

				//SubAddr 0x12 Reg 0xE Val 0x2403
				uchWrite16Value[0] = 0x12;
				uchWrite16Value[1] = 0x00;
				uchWrite16Value[2] = 0x0e;
				uchWrite16Value[3] = 0x24;
				uchWrite16Value[4] = 0x03;

				bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
				if(bResult)
				{
					if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
						return(FALSE);
				}
				else
					return(FALSE);

				//SubAddr 0x12 Reg 0x08 Val 0x0320
				uchWrite16Value[0] = 0x12;
				uchWrite16Value[1] = 0x00;
				uchWrite16Value[2] = 0x08;
				uchWrite16Value[3] = 0x03;
				uchWrite16Value[4] = 0x20;

				bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
				if(bResult)
				{
					if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
						return(FALSE);
				}
				else
					return(FALSE);

				return(TRUE);
			}

			if(ulModeToSet & KS_TVAUDIO_MODE_MONO) 
			{
			
				if(ulModeToSet & KS_TVAUDIO_MODE_LANG_A)
				{
					i2cPacket.uchChipAddress = m_uchAudioChipAddress;
					i2cPacket.cbReadCount = 0;
					i2cPacket.usFlags = I2COPERATION_WRITE;
					i2cPacket.puchWriteBuffer = uchWrite16Value;
					i2cPacket.cbWriteCount = 5;


					//SubAddr 0x10 Reg 0x30 Val 0x2003
					uchWrite16Value[0] = 0x10;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x30;
					uchWrite16Value[3] = 0x20;
#ifdef	I2S_CAPTURE
#pragma message ("\n!!! PAY ATTENTION: Driver has been build with ITT CHIP I2S CAPTURE CONFIGURED !!!\n")
					uchWrite16Value[4] = 0xe3;
#else
					uchWrite16Value[4] = 0x03;
#endif

					bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x10 Reg 0x20 Val 0x0020

					uchWrite16Value[0] = 0x10;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x20;
					uchWrite16Value[3] = 0x00;
					uchWrite16Value[4] = 0x20;

					bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x12 Reg 0xE Val 0x2403
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x0e;
					uchWrite16Value[3] = 0x24;
					uchWrite16Value[4] = 0x03;

					bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x12 Reg 0x08 Val 0x0330
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x08;
					uchWrite16Value[3] = 0x03;
					uchWrite16Value[4] = 0x30; //Mono

					bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					return(TRUE);
				}


				if( ulModeToSet & KS_TVAUDIO_MODE_LANG_B)
				{

					i2cPacket.uchChipAddress = m_uchAudioChipAddress;
					i2cPacket.cbReadCount = 0;
					i2cPacket.usFlags = I2COPERATION_WRITE;
					i2cPacket.puchWriteBuffer = uchWrite16Value;
					i2cPacket.cbWriteCount = 5;

					//SubAddr 0x10 Reg 0x30 Val 0x2003
					uchWrite16Value[0] = 0x10;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x30;
					uchWrite16Value[3] = 0x20;
#ifdef	I2S_CAPTURE
#pragma message ("\n!!! PAY ATTENTION: Driver has been build with ITT CHIP I2S CAPTURE CONFIGURED !!!\n")
					uchWrite16Value[4] = 0xe3;
#else
					uchWrite16Value[4] = 0x03;
#endif

					bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x10 Reg 0x20 Val 0x0021

					uchWrite16Value[0] = 0x10;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x20;
					uchWrite16Value[3] = 0x00;
					uchWrite16Value[4] = 0x21;

					bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x12 Reg 0xE Val 0x2400
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x0e;
					uchWrite16Value[3] = 0x24;
					uchWrite16Value[4] = 0x00;

					bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);

					//SubAddr 0x12 Reg 0x08 Val 0x0110
					uchWrite16Value[0] = 0x12;
					uchWrite16Value[1] = 0x00;
					uchWrite16Value[2] = 0x08;
					uchWrite16Value[3] = 0x01;
					uchWrite16Value[4] = 0x10;

					bResult = m_pI2CScript->PerformI2CPacketOperation( &i2cPacket);
					if(bResult)
					{
						if( i2cPacket.uchI2CResult != I2CSCRIPT_NOERROR)
							return(FALSE);
					}
					else
						return(FALSE);


					return(TRUE);
				}
			}

			return(FALSE);


		default:
			return( FALSE);
	}

	i2cPacket.uchChipAddress = m_uchAudioChipAddress;
	i2cPacket.cbReadCount = 0;
	i2cPacket.cbWriteCount = cbWriteLength;
	i2cPacket.puchReadBuffer = NULL;
	i2cPacket.puchWriteBuffer = auchI2CBuffer;
	i2cPacket.usFlags = 0;

	// synchronous mode of operation
	return( m_pI2CScript->PerformI2CPacketOperation( &i2cPacket));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\tvaudio\atitvsnd\tsndprop.cpp ===
//==========================================================================;
//
//  TSndProp.CPP
//  WDM TVAudio MiniDriver. 
//      AIW / AIWPro hardware platform. 
//          WDM Properties management.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//      $Date:   30 Jul 1998 17:36:30  $
//  $Revision:   1.2  $
//    $Author:   KLEBANOV  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "wdmdrv.h"
#include "atitvsnd.h"
#include "aticonfg.h"




/*^^*
 *      AdapterGetProperty()
 * Purpose  : Called when SRB_GET_PROPERTY SRB is received.
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : BOOL : returns returns FALSE, if it is not a Tv Audio property
 *              it also returns the required property
 * Author   : IKLEBANOV
 *^^*/
BOOL CWDMTVAudio::AdapterGetProperty( PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSpd = pSrb->CommandData.PropertyInfo;
    ULONG uiPropertyId = pSpd->Property->Id;                // index of the property
    ULONG nPropertyOutSize = pSpd->PropertyOutputSize;      // size of data requested

    if( !::IsEqualGUID(( const struct _GUID &)PROPSETID_VIDCAP_TVAUDIO, ( const struct _GUID &)pSpd->Property->Set))
        return( FALSE);

    OutputDebugInfo(( "CWDMAVXBar:AdapterGetProperty() Id = %d\n", uiPropertyId));

    switch( uiPropertyId)
    {
    case KSPROPERTY_TVAUDIO_CAPS:
        ASSERT( nPropertyOutSize >= sizeof( KSPROPERTY_TVAUDIO_CAPS_S));
        {
            PKSPROPERTY_TVAUDIO_CAPS_S pTVAudioCaps = ( PKSPROPERTY_TVAUDIO_CAPS_S)pSpd->PropertyInfo;

            // Copy the input property info to the output property info
            ::RtlCopyMemory( pTVAudioCaps, pSpd->Property, sizeof( KSPROPERTY_TVAUDIO_CAPS_S));
            
            pTVAudioCaps->Capabilities = m_ulModesSupported;
            pTVAudioCaps->InputMedium = m_wdmTVAudioPinsMediumInfo[0];
            pTVAudioCaps->OutputMedium = m_wdmTVAudioPinsMediumInfo[1];
        }

        pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TVAUDIO_CAPS_S);
        break;

    case KSPROPERTY_TVAUDIO_MODE:
        ASSERT( nPropertyOutSize >= sizeof( KSPROPERTY_TVAUDIO_S));
        {
            PKSPROPERTY_TVAUDIO_S   pTVAudioMode = ( PKSPROPERTY_TVAUDIO_S)pSpd->PropertyInfo;

            // Copy the input property info to the output property info
            ::RtlCopyMemory( pTVAudioMode, pSpd->Property, sizeof( KSPROPERTY_TVAUDIO_S));
        
            // GetMode returns the mode the device was set up with,  not the current read back from
            // the device itself ( current AudioSignal Properties)
            pTVAudioMode->Mode = m_ulTVAudioMode;
            pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TVAUDIO_S);
        }
        break;

    case KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES:
        ASSERT( nPropertyOutSize >= sizeof( KSPROPERTY_TVAUDIO_S));
        {
            ULONG                   ulAudioMode;
            PKSPROPERTY_TVAUDIO_S   pTVAudioMode = ( PKSPROPERTY_TVAUDIO_S)pSpd->PropertyInfo;

            // Copy the input property info to the output property info
            ::RtlCopyMemory( pTVAudioMode, pSpd->Property, sizeof( KSPROPERTY_TVAUDIO_S));

            if( !GetAudioOperationMode( &ulAudioMode))
                return( FALSE);

            m_ulTVAudioSignalProperties = ulAudioMode;
            pTVAudioMode->Mode = ulAudioMode;
            pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TVAUDIO_S);
        }
        break;

    default:
        TRAP;
        return( FALSE);
    }

    return( TRUE);
}



/*^^*
 *      AdapterSetProperty()
 * Purpose  : Called when SRB_GET_PROPERTY SRB is received.
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : BOOL : returns FALSE, if it is not a TV Audio property
 *              it also sets the required property
 * Author   : IKLEBANOV
 *^^*/
BOOL CWDMTVAudio::AdapterSetProperty( PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAM_PROPERTY_DESCRIPTOR pSpd = pSrb->CommandData.PropertyInfo;
    ULONG uiPropertyId = pSpd->Property->Id;            // index of the property

    if( !::IsEqualGUID( ( const struct _GUID &)PROPSETID_VIDCAP_TVAUDIO, ( const struct _GUID &)pSpd->Property->Set))
        return( FALSE);

    OutputDebugInfo(( "CWDMAVXBar:AdapterSetProperty() Id = %d\n", uiPropertyId));

    switch( uiPropertyId)
    {
    case KSPROPERTY_TVAUDIO_MODE:
        ASSERT( pSpd->PropertyOutputSize >= sizeof( KSPROPERTY_TVAUDIO_S));
        {
            ULONG ulModeToSet = (( PKSPROPERTY_TVAUDIO_S)pSpd->PropertyInfo)->Mode;

            if( ulModeToSet == ( ulModeToSet & m_ulModesSupported))
            {
                // every mode we're asked to set is supported
                if( ulModeToSet != m_ulTVAudioMode)
                {
                    if( !SetAudioOperationMode( ulModeToSet))
                        return( FALSE);
                    else
                        // update the driver
                        m_ulTVAudioMode = ulModeToSet;
                }
            }
            else
                return( FALSE);
        }
        break;

    default:
        TRAP;
        return( FALSE);
    }

    return( TRUE);
}



/*^^*
 *      SetWDMTVAudioKSTopology()
 * Purpose  : Sets the KSTopology structure
 *              Called during CWDMTVAudio class construction time.
 *
 * Inputs   : none
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
void CWDMTVAudio::SetWDMTVAudioKSTopology( void)
{
    GUID wdmTVAudioTopologyCategory[] =
    {
        STATIC_KSCATEGORY_TVAUDIO
    };
    
    ::RtlCopyMemory( &m_wdmTVAudioTopologyCategory, wdmTVAudioTopologyCategory, sizeof( wdmTVAudioTopologyCategory));

    m_wdmTVAudioTopology.CategoriesCount = 1;
    m_wdmTVAudioTopology.Categories = &m_wdmTVAudioTopologyCategory;
    m_wdmTVAudioTopology.TopologyNodesCount = 0;
    m_wdmTVAudioTopology.TopologyNodes = NULL;
    m_wdmTVAudioTopology.TopologyConnectionsCount = 0;
    m_wdmTVAudioTopology.TopologyConnections = NULL;
}



/*^^*
 *      SetWDMTVAudioKSProperties()
 * Purpose  : Sets the KSProperty structures array
 *              Called during CWDMTVAudio class construction time.
 *
 * Inputs   : none
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
void CWDMTVAudio::SetWDMTVAudioKSProperties( void)
{

    DEFINE_KSPROPERTY_TABLE( wdmTVAudioProperties)
    {
        DEFINE_KSPROPERTY_ITEM
        (
            KSPROPERTY_TVAUDIO_CAPS,
            TRUE,                                   // GetSupported or Handler
            sizeof( KSPROPERTY_TVAUDIO_CAPS_S),     // MinProperty
            sizeof( KSPROPERTY_TVAUDIO_CAPS_S),     // MinData
            FALSE,                                  // SetSupported or Handler
            NULL,                                   // Values
            0,                                      // RelationsCount
            NULL,                                   // Relations
            NULL,                                   // SupportHandler
            0                                       // SerializedSize
        ),

        DEFINE_KSPROPERTY_ITEM
        (
            KSPROPERTY_TVAUDIO_MODE,
            TRUE,                                   // GetSupported or Handler
            sizeof( KSPROPERTY_TVAUDIO_S),          // MinProperty
            sizeof( KSPROPERTY_TVAUDIO_S),          // MinData
            TRUE,                                   // SetSupported or Handler
            NULL,                                   // Values
            0,                                      // RelationsCount
            NULL,                                   // Relations
            NULL,                                   // SupportHandler
            0                                       // SerializedSize
        ),

        DEFINE_KSPROPERTY_ITEM
        (
            KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES,
            TRUE,                                   // GetSupported or Handler
            sizeof( KSPROPERTY_TVAUDIO_S),          // MinProperty
            sizeof( KSPROPERTY_TVAUDIO_S),          // MinData
            FALSE,                                  // SetSupported or Handler
            NULL,                                   // Values
            0,                                      // RelationsCount
            NULL,                                   // Relations
            NULL,                                   // SupportHandler
            0                                       // SerializedSize
        )
    };

    DEFINE_KSPROPERTY_SET_TABLE( wdmTVAudioPropertySet)
    {
        DEFINE_KSPROPERTY_SET
        (
            &PROPSETID_VIDCAP_TVAUDIO,                      // Set
            KSPROPERTIES_TVAUDIO_NUMBER,                    // PropertiesCount
            m_wdmTVAudioProperties,                         // PropertyItems
            0,                                              // FastIoCount
            NULL                                            // FastIoTable
        )
    };

    ::RtlCopyMemory( &m_wdmTVAudioProperties, wdmTVAudioProperties, sizeof( wdmTVAudioProperties));
    ::RtlCopyMemory( &m_wdmTVAudioPropertySet, wdmTVAudioPropertySet, sizeof( wdmTVAudioPropertySet));
}



/*^^*
 *      SetWDMTVAudioKSEvents()
 * Purpose  : Sets the KSEvent structures array
 *              Called during CWDMTVAudio class construction time.
 *
 * Inputs   : none
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
void CWDMTVAudio::SetWDMTVAudioKSEvents( void)
{
    PKSEVENT_ITEM pKSEventItem = &m_wdmTVAudioEvents[0];

    pKSEventItem->EventId = KSEVENT_TVAUDIO_CHANGED;
    pKSEventItem->DataInput = pKSEventItem->ExtraEntryData = 0;
    pKSEventItem->AddHandler = NULL;
    pKSEventItem->RemoveHandler = NULL;
    pKSEventItem->SupportHandler = NULL;
    
    m_wdmTVAudioEventsSet[0].Set = &KSEVENTSETID_VIDCAP_TVAUDIO;
    m_wdmTVAudioEventsSet[0].EventsCount = 0;
    m_wdmTVAudioEventsSet[0].EventItem = pKSEventItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\tvaudio\atitvsnd\wdmtvsnd.cpp ===
//==========================================================================;
//
//  WDMTVSnd.CPP
//  WDM TVAudio MiniDriver. 
//      AllInWonder / AIWPro Hardware platform. 
//          CWDMTVAudio class implementation.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//      $Date:   23 Nov 1998 13:22:00  $
//  $Revision:   1.4  $
//    $Author:   minyailo  $
//
//==========================================================================;

extern "C"
{
#include "strmini.h"
#include "ksmedia.h"

#include "wdmdebug.h"
}

#include "atitvsnd.h"
#include "wdmdrv.h"
#include "aticonfg.h"


/*^^*
 *      AdapterCompleteInitialization()
 * Purpose  : Called when SRB_COMPLETE_UNINITIALIZATION SRB is received.
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : BOOL : returns TRUE
 * Author   : IKLEBANOV
 *^^*/
NTSTATUS CWDMTVAudio::AdapterCompleteInitialization( PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PADAPTER_DATA_EXTENSION pPrivateData = ( PADAPTER_DATA_EXTENSION)( pSrb->HwDeviceExtension);
    PDEVICE_OBJECT  pDeviceObject = pPrivateData->PhysicalDeviceObject;
    KSPIN_MEDIUM    mediumKSPin;
    NTSTATUS        ntStatus;
    UINT            nIndex;
    HANDLE          hFolder;
    ULONG           ulInstance;

    ENSURE
    {
        nIndex = 0;

        ulInstance = ::GetDriverInstanceNumber( pDeviceObject);
        hFolder = ::OpenRegistryFolder( pDeviceObject, UNICODE_WDM_REG_PIN_MEDIUMS);

        // put the hardcoded Medium values first
        ::RtlCopyMemory( &m_wdmTVAudioPinsMediumInfo[0], &ATITVAudioInMedium, sizeof( KSPIN_MEDIUM));
        ::RtlCopyMemory( &m_wdmTVAudioPinsMediumInfo[1], &ATITVAudioOutMedium, sizeof( KSPIN_MEDIUM));

        for( nIndex = 0; nIndex < WDMTVAUDIO_PINS_NUMBER; nIndex ++)
        {
            if( ::ReadPinMediumFromRegistryFolder( hFolder, nIndex, &mediumKSPin))
                ::RtlCopyMemory( &m_wdmTVAudioPinsMediumInfo[nIndex], &mediumKSPin, sizeof( KSPIN_MEDIUM));
            m_wdmTVAudioPinsMediumInfo[nIndex].Id = ulInstance;
        }

        m_wdmTVAudioPinsDirectionInfo[0] = FALSE;
        m_wdmTVAudioPinsDirectionInfo[1] = TRUE;

        if( hFolder != NULL)
            ::ZwClose( hFolder);

        ntStatus = StreamClassRegisterFilterWithNoKSPins( \
                        pDeviceObject,                          // IN PDEVICE_OBJECT   DeviceObject,
                        &KSCATEGORY_TVAUDIO,                    // IN GUID           * InterfaceClassGUID
                        WDMTVAUDIO_PINS_NUMBER,                 // IN ULONG            PinCount,
                        m_wdmTVAudioPinsDirectionInfo,          // IN ULONG          * Flags,
                        m_wdmTVAudioPinsMediumInfo,             // IN KSPIN_MEDIUM   * MediumList,
                        NULL);                                  // IN GUID           * CategoryList

        if( !NT_SUCCESS( ntStatus))
            FAIL;

        OutputDebugTrace(( "CATIWDMTVAudio:AdapterCompleteInitialization() exit\n"));

    } END_ENSURE;

    if( !NT_SUCCESS( ntStatus))
        OutputDebugError(( "CATIWDMTVAudio:AdapterCompleteInitialization() ntStatus=%x\n",
            ntStatus));

    return( ntStatus);
}



/*^^*
 *      AdapterUnInitialize()
 * Purpose  : Called when SRB_UNINITIALIZE_DEVICE SRB is received.
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : BOOL : returns TRUE
 * Author   : IKLEBANOV
 *^^*/
BOOL CWDMTVAudio::AdapterUnInitialize( PHW_STREAM_REQUEST_BLOCK pSrb)
{

    OutputDebugTrace(( "CWDMTVAudio:AdapterUnInitialize()\n"));

    pSrb->Status = STATUS_SUCCESS;

    return( TRUE);
}


/*^^*
 *      AdapterGetStreamInfo()
 * Purpose  : 
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : BOOL : returns TRUE
 * Author   : IKLEBANOV
 *^^*/
BOOL CWDMTVAudio::AdapterGetStreamInfo( PHW_STREAM_REQUEST_BLOCK pSrb)
{
     // pick up the pointer to the stream header data structure
    PHW_STREAM_HEADER pStreamHeader = ( PHW_STREAM_HEADER) \
                                        &( pSrb->CommandData.StreamBuffer->StreamHeader);
     // pick up the pointer to the stream information data structure
    PHW_STREAM_INFORMATION pStreamInfo = ( PHW_STREAM_INFORMATION) \
                                        &( pSrb->CommandData.StreamBuffer->StreamInfo);

    // no streams are supported
    DEBUG_ASSERT( pSrb->NumberOfBytesToTransfer >= sizeof( HW_STREAM_HEADER));

    OutputDebugTrace(( "CWDMTVAudio:AdapterGetStreamInfo()\n"));

    m_wdmTVAudioStreamHeader.NumberOfStreams = 0;
    m_wdmTVAudioStreamHeader.SizeOfHwStreamInformation = sizeof( HW_STREAM_INFORMATION);
    m_wdmTVAudioStreamHeader.NumDevPropArrayEntries = KSPROPERTIES_TVAUDIO_NUMBER_SET;
    m_wdmTVAudioStreamHeader.DevicePropertiesArray = m_wdmTVAudioPropertySet;
    m_wdmTVAudioStreamHeader.NumDevEventArrayEntries = KSEVENTS_TVAUDIO_NUMBER_SET;
    m_wdmTVAudioStreamHeader.DeviceEventsArray = m_wdmTVAudioEventsSet;
    m_wdmTVAudioStreamHeader.Topology = &m_wdmTVAudioTopology;

    * pStreamHeader = m_wdmTVAudioStreamHeader;

    pSrb->Status = STATUS_SUCCESS;

    return( TRUE);
}


/*^^*
 *      AdapterQueryUnload()
 * Purpose  : Called when the class driver is about to unload the MiniDriver
 *              The MiniDriver checks if any open stream left.
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *
 * Outputs  : BOOL : returns TRUE
 * Author   : IKLEBANOV
 *^^*/
BOOL CWDMTVAudio::AdapterQueryUnload( PHW_STREAM_REQUEST_BLOCK pSrb)
{

    OutputDebugTrace(( "CWDMTVAudio:AdapterQueryUnload()\n"));

    pSrb->Status = STATUS_SUCCESS;

    return( TRUE);
}



/*^^*
 *      operator new
 * Purpose  : CWDMTVAudio class overloaded operator new.
 *              Provides placement for a CWDMTVAudio class object from the PADAPTER_DEVICE_EXTENSION
 *              allocated by the StreamClassDriver for the MiniDriver.
 *
 * Inputs   :   UINT size_t         : size of the object to be placed
 *              PVOID pAllocation   : casted pointer to the CWDMTVAudio allocated data
 *
 * Outputs  : PVOID : pointer of the CWDMTVAudio class object
 * Author   : IKLEBANOV
 *^^*/
PVOID CWDMTVAudio::operator new( size_t stSize,  PVOID pAllocation)
{

    if( stSize != sizeof( CWDMTVAudio))
    {
        OutputDebugError(( "CWDMTVAudio: operator new() fails\n"));
        return( NULL);
    }
    else
        return( pAllocation);
}



/*^^*
 *      CWDMTVAudio()
 * Purpose  : CWDMTVAudio class constructor.
 *              Performs checking of the hardware presence. Sets the hardware in an initial state.
 *
 * Inputs   :   CI2CScript * pCScript   : pointer to the I2CScript class object
 *              PUINT puiError          : pointer to return a completion error code
 *
 * Outputs  : none
 * Author   : IKLEBANOV
 *^^*/
CWDMTVAudio::CWDMTVAudio( PPORT_CONFIGURATION_INFORMATION pConfigInfo, CI2CScript * pCScript, PUINT puiErrorCode)
    :m_CATIConfiguration( pConfigInfo, pCScript, puiErrorCode)
{
    UINT uiError;

    OutputDebugTrace(( "CWDMTVAudio:CWDMTVAudio() enter\n"));

    m_ulModesSupported = KS_TVAUDIO_MODE_MONO;
    
    // error code was carried over from ATIConfiguration class constructor
    uiError = * puiErrorCode;

    ENSURE
    {
        UINT    uiAudioConfigurationId;
        UCHAR   uchAudioChipAddress;

        if( uiError != WDMMINI_NOERROR)
            FAIL;

        if( pCScript == NULL)
        {
            uiError = WDMMINI_INVALIDPARAM;
            FAIL;
        }

        if( !m_CATIConfiguration.GetAudioConfiguration( &uiAudioConfigurationId, &uchAudioChipAddress))
        {
            uiError = WDMMINI_UNKNOWNHARDWARE;
            FAIL;
        }

        m_uiAudioConfiguration = uiAudioConfigurationId;
        m_uchAudioChipAddress = uchAudioChipAddress;

        if( !m_CATIConfiguration.InitializeAudioConfiguration( pCScript,
                                                               uiAudioConfigurationId,
                                                               uchAudioChipAddress))
        {
            uiError = WDMMINI_HARDWAREFAILURE;
            FAIL;
        }

        switch( uiAudioConfigurationId)
        {
            case ATI_AUDIO_CONFIG_1:
                m_ulModesSupported |= KS_TVAUDIO_MODE_STEREO;
                break;

            case ATI_AUDIO_CONFIG_2:
            case ATI_AUDIO_CONFIG_7:
                m_ulModesSupported |= KS_TVAUDIO_MODE_STEREO |
                    KS_TVAUDIO_MODE_LANG_A | KS_TVAUDIO_MODE_LANG_B;
                break;

            case ATI_AUDIO_CONFIG_5:
            case ATI_AUDIO_CONFIG_6:
                m_ulModesSupported |= KS_TVAUDIO_MODE_STEREO;
                break;

            case ATI_AUDIO_CONFIG_8:
                m_ulModesSupported |= KS_TVAUDIO_MODE_STEREO |
                    KS_TVAUDIO_MODE_LANG_A | KS_TVAUDIO_MODE_LANG_B;
                break;

            case ATI_AUDIO_CONFIG_3:
            case ATI_AUDIO_CONFIG_4:
            default:
                break;
        }

        // set stereo mode as the power up default, if supported
        m_ulTVAudioMode = ( m_ulModesSupported & KS_TVAUDIO_MODE_STEREO) ?
            KS_TVAUDIO_MODE_STEREO : KS_TVAUDIO_MODE_MONO;
        if( m_ulModesSupported & KS_TVAUDIO_MODE_LANG_A)
            m_ulTVAudioMode |= KS_TVAUDIO_MODE_LANG_A;

        // these two functions has to be called after the CWDMTVAudio class object was build on
        // on the stack and copied over into the DeviceExtension
        // This comment was true for the case, where the class object was build on the stack first.
        // There is an overloaded operator new provided for this class, and we can call it from here
        SetWDMTVAudioKSProperties();
        SetWDMTVAudioKSTopology();

        m_pI2CScript = pCScript;

         * puiErrorCode = WDMMINI_NOERROR;
         OutputDebugTrace(( "CWDMTVAudio:CWDMTVAudio() exit\n"));

        return;

    } END_ENSURE;

    * puiErrorCode = uiError;

    OutputDebugError(( "CWDMTVAudio:CWDMTVAudio() Error = %x\n", uiError));
}



/*^^*
 *      AdapterSetPowerState()
 * Purpose  : Sets Power Management state for deviec
 *
 * Inputs   :   PHW_STREAM_REQUEST_BLOCK pSrb   : pointer to the current Srb
 *              PBOOL pbSynchronous             : pointer to return Synchronous/Asynchronous flag
 *
 * Outputs  : NTSTATUS as the operation result
 * Author   : IKLEBANOV
 *^^*/
NTSTATUS CWDMTVAudio::AdapterSetPowerState( PHW_STREAM_REQUEST_BLOCK pSrb)
{
    DEVICE_POWER_STATE  nDeviceState = pSrb->CommandData.DeviceState;
    NTSTATUS            ntStatus;

    switch( nDeviceState)
    {
        case PowerDeviceD0:
        case PowerDeviceD3:
            // if transition form D3 to D0 we have to restore audio connections
            if(( nDeviceState == PowerDeviceD0) && ( m_ulPowerState == PowerDeviceD3))
            {
                if( SetAudioOperationMode( m_ulTVAudioMode))
                    ntStatus = STATUS_SUCCESS;
                else
                    ntStatus = STATUS_ADAPTER_HARDWARE_ERROR;
            }
            else
                ntStatus = STATUS_SUCCESS;

            m_ulPowerState = nDeviceState;
            break;

        case PowerDeviceD1:
        case PowerDeviceD2:
            ntStatus = STATUS_SUCCESS;
            break;

        default:
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    return( ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\atiwdm\tvaudio\atitvsnd\wdmtvsnd.h ===
//==========================================================================;
//
//	WDMTVSnd.H
//	WDM TVAudio MiniDriver. 
//		CWDMTVAudio Class definition.
//  Copyright (c) 1996 - 1997  ATI Technologies Inc.  All Rights Reserved.
//
//==========================================================================;

#ifndef _WDMTVSND_H_
#define _WDMTVSND_H_

#include "i2script.h"
#include "aticonfg.h"
#include "pinmedia.h"


#define WDMTVAUDIO_PINS_NUMBER					2		// 1 input and 1 output

#define	KSPROPERTIES_TVAUDIO_NUMBER_SET			1
#define KSPROPERTIES_TVAUDIO_NUMBER				( KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES + 1)

#define	KSEVENTS_TVAUDIO_NUMBER_SET				1
#define KSEVENTS_TVAUDIO_NUMBER					1


class CWDMTVAudio
{
public:
	CWDMTVAudio			( PPORT_CONFIGURATION_INFORMATION pConfigInfo, CI2CScript * pCScript, PUINT puiError);
	PVOID operator new	( size_t stSize, PVOID pAllocation);

// Attributes	
private:
	// WDM global topology headers
	GUID						m_wdmTVAudioTopologyCategory;
	KSTOPOLOGY					m_wdmTVAudioTopology;
	// WDM global pins Medium information
	KSPIN_MEDIUM				m_wdmTVAudioPinsMediumInfo[WDMTVAUDIO_PINS_NUMBER];
	BOOL						m_wdmTVAudioPinsDirectionInfo[WDMTVAUDIO_PINS_NUMBER];
	// WDM global property headers
	KSPROPERTY_ITEM				m_wdmTVAudioProperties[KSPROPERTIES_TVAUDIO_NUMBER];
	KSPROPERTY_SET				m_wdmTVAudioPropertySet[KSPROPERTIES_TVAUDIO_NUMBER_SET];

	// WDM global event properties
	KSEVENT_ITEM				m_wdmTVAudioEvents[KSEVENTS_TVAUDIO_NUMBER];
	KSEVENT_SET					m_wdmTVAudioEventsSet[KSEVENTS_TVAUDIO_NUMBER_SET];

	// WDM global stream headers
	HW_STREAM_HEADER			m_wdmTVAudioStreamHeader;

	// I2C provider properties
	CI2CScript *				m_pI2CScript;

	// Configurations
	CATIHwConfiguration			m_CATIConfiguration;
	ULONG						m_ulModesSupported;
	UINT						m_uiAudioConfiguration;
	UCHAR						m_uchAudioChipAddress;

	// Run-time properties
	ULONG						m_ulTVAudioMode;
	ULONG						m_ulTVAudioSignalProperties;

	DEVICE_POWER_STATE			m_ulPowerState;

// Implementation
public:
	BOOL		AdapterUnInitialize				( PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL		AdapterGetStreamInfo			( PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL		AdapterQueryUnload				( PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL		AdapterGetProperty				( PHW_STREAM_REQUEST_BLOCK pSrb);
	BOOL		AdapterSetProperty				( PHW_STREAM_REQUEST_BLOCK pSrb);
	NTSTATUS	AdapterCompleteInitialization	( PHW_STREAM_REQUEST_BLOCK pSrb);
	NTSTATUS	AdapterSetPowerState			( PHW_STREAM_REQUEST_BLOCK pSrb);

private:
	void		SetWDMTVAudioKSEvents			( void);
	void		SetWDMTVAudioKSProperties		( void);
	void		SetWDMTVAudioKSTopology			( void);

	BOOL		SetAudioOperationMode			( ULONG ulModeToSet);
	BOOL		GetAudioOperationMode			( PULONG pulMode);
};



#endif	// _WDMTVSND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\avcstrm\filter.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    filter.h

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include "strmini.h"  // Stream class header file

#include "1394.h"
#include "61883.h"
#include "avc.h"
#include "avcstrm.h"
#include "avcdefs.h"  

//
// If this driver is going to be a filter in the paging, hibernation, or dump
// file path, then HANDLE_DEVICE_USAGE should be defined.
//
// #define HANDLE_DEVICE_USAGE

enum deviceState {
        STATE_INITIALIZED,
        STATE_STARTING,
        STATE_STARTED,
        STATE_START_FAILED,
        STATE_STOPPED,  // implies device was previously started successfully
        STATE_SUSPENDED,
        STATE_REMOVING,
        STATE_REMOVED
};


/*
 *  Memory tag for memory blocks allocated by this driver
 *  (used in ExAllocatePoolWithTag() call).
 *  This DWORD appears as "Filt" in a little-endian memory byte dump.
 *
 *  NOTE:  PLEASE change this value to be unique for your driver!  Otherwise,
 *  your allocations will show up with every other driver that uses 'tliF' as
 *  an allocation tag.
 *  
 */
#define FILTER_TAG (ULONG)'SCVA'

#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, FILTER_TAG)



#define DEVICE_EXTENSION_SIGNATURE 'SCVA'

#define MAX_STREAMS_PER_DEVICE    4  // We probably run out of bandwidth after this.

typedef struct DEVICE_EXTENSION {

    /*
     *  Stream extension; we can support up to MAX_STREAMS_PER_DEVICE streams.
     */
    ULONG  NumberOfStreams;  // [0..MAX_STREAMS_PER_DEVICE-1]
    ULONG  NextStreamIndex;  // [0..MAX_STREAMS_PER_DEVICE-1] and can wrap arond as long as NumberOfStreams is < MAX_STREAMS_PER_DEVICE
    PAVC_STREAM_EXTENSION pAVCStrmExt[MAX_STREAMS_PER_DEVICE];

    /*
     *  Memory signature of a device extension, for debugging.
     */
    ULONG signature;

    /*
     *  Plug-and-play state of this device object.
     */
    enum deviceState state;

    /*
     *  The device object that this filter driver created.
     */
    PDEVICE_OBJECT filterDevObj;

    /*
     *  The device object created by the next lower driver.
     */
    PDEVICE_OBJECT physicalDevObj;

    /*
     *  The device object at the top of the stack that we attached to.
     *  This is often (but not always) the same as physicalDevObj.
     */
    PDEVICE_OBJECT topDevObj;

    /*
     *  deviceCapabilities includes a
     *  table mapping system power states to device power states.
     */
    DEVICE_CAPABILITIES deviceCapabilities;

    /*
     *  pendingActionCount is used to keep track of outstanding actions.
     *  removeEvent is used to wait until all pending actions are
     *  completed before complete the REMOVE_DEVICE IRP and let the
     *  driver get unloaded.
     */
    LONG pendingActionCount;
    KEVENT removeEvent;

#ifdef HANDLE_DEVICE_USAGE
    /*
     *  Keep track of the number of paging/hibernation/crashdump
     *  files that are opened on this device.
     */
    ULONG  pagingFileCount, hibernationFileCount, crashdumpFileCount;
    KEVENT deviceUsageNotificationEvent;
    PVOID  pagingPathUnlockHandle;  /* handle to lock certain code as non-pageable */

    /*
     *  Also, might need to lock certain driver code as non-pageable, based on
     *  initial conditions (as opposed to paging-file considerations).
     */
    PVOID  initUnlockHandle;
    ULONG  initialFlags;
#endif // HANDLE_DEVICE_USAGE 

};


#if DBG
    #define _DRIVERNAME_ "AVCStrm"

    // PnP: loading, power state, surprise removal, device SRB
    #define TL_PNP_MASK         0x0000000F
    #define TL_PNP_INFO         0x00000001
    #define TL_PNP_TRACE        0x00000002
    #define TL_PNP_WARNING      0x00000004
    #define TL_PNP_ERROR        0x00000008

    // Connection, plug and 61883 info (get/set)
    #define TL_61883_MASK       0x000000F0
    #define TL_61883_INFO       0x00000010
    #define TL_61883_TRACE      0x00000020
    #define TL_61883_WARNING    0x00000040
    #define TL_61883_ERROR      0x00000080

    // Data
    #define TL_CIP_MASK         0x00000F00
    #define TL_CIP_INFO         0x00000100
    #define TL_CIP_TRACE        0x00000200
    #define TL_CIP_WARNING      0x00000400
    #define TL_CIP_ERROR        0x00000800

    // AVC commands
    #define TL_FCP_MASK         0x0000F000
    #define TL_FCP_INFO         0x00001000
    #define TL_FCP_TRACE        0x00002000
    #define TL_FCP_WARNING      0x00004000
    #define TL_FCP_ERROR        0x00008000

    // Stream (data intersection, open/close, stream state (get/set))
    #define TL_STRM_MASK        0x000F0000
    #define TL_STRM_INFO        0x00010000
    #define TL_STRM_TRACE       0x00020000
    #define TL_STRM_WARNING     0x00040000
    #define TL_STRM_ERROR       0x00080000

    // clock and clock event
    #define TL_CLK_MASK         0x00F00000
    #define TL_CLK_INFO         0x00100000
    #define TL_CLK_TRACE        0x00200000
    #define TL_CLK_WARNING      0x00400000
    #define TL_CLK_ERROR        0x00800000


    extern ULONG AVCStrmTraceMask;
    extern ULONG AVCStrmAssertLevel;

    #define ENTER(ModName)
    #define EXIT(ModName,Status)

    #define TRACE( l, x )                       \
        if( (l) & AVCStrmTraceMask ) {              \
            KdPrint( (_DRIVERNAME_ ": ") );     \
            KdPrint( x );                       \
        }

    #ifdef ASSERT
    #undef ASSERT
    #endif
    #define ASSERT( exp ) \
        if (AVCStrmAssertLevel && !(exp)) \
            RtlAssert( #exp, __FILE__, __LINE__, NULL )


#else

    #define ENTER(ModName)
    #define EXIT(ModName,Status) 
    #define TRACE( l, x )

#endif


/*
 *  Function externs
 */
NTSTATUS    DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
NTSTATUS    VA_AddDevice(IN PDRIVER_OBJECT driverObj, IN PDEVICE_OBJECT pdo);
VOID        VA_DriverUnload(IN PDRIVER_OBJECT DriverObject);
NTSTATUS    VA_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    VA_PnP(struct DEVICE_EXTENSION *devExt, PIRP irp);
#ifdef HANDLE_DEVICE_USAGE
NTSTATUS    VA_DeviceUsageNotification(struct DEVICE_EXTENSION *devExt, PIRP irp);
#endif // HANDLE_DEVICE_USAGE 
NTSTATUS    VA_Power(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    VA_PowerComplete(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS    GetDeviceCapabilities(struct DEVICE_EXTENSION *devExt);
NTSTATUS    CallNextDriverSync(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp);
NTSTATUS    CallDriverSyncCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID Context);
VOID        IncrementPendingActionCount(struct DEVICE_EXTENSION *devExt);
VOID        DecrementPendingActionCount(struct DEVICE_EXTENSION *devExt);
NTSTATUS    QueryDeviceKey(HANDLE Handle, PWCHAR ValueNameString, PVOID Data, ULONG DataLength);
VOID        RegistryAccessSample(struct DEVICE_EXTENSION *devExt, PDEVICE_OBJECT devObj);

NTSTATUS
AvcStrm_IoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\avcstrm\filter.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    filter.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/


#include "filter.h"

#ifdef TIME_BOMB
#include "..\..\inc\timebomb.c"
#endif

#if DBG
#define TraceMaskCheckIn  TL_PNP_ERROR | TL_STRM_ERROR

#define TraceMaskDefault  TL_PNP_ERROR   | TL_PNP_WARNING \
                          | TL_61883_ERROR | TL_61883_WARNING \
                          | TL_CIP_ERROR  \
                          | TL_FCP_ERROR  \
                          | TL_STRM_ERROR  | TL_STRM_WARNING \
                          | TL_CLK_ERROR

#define TraceMaskDebug  TL_PNP_ERROR  | TL_PNP_WARNING \
                          | TL_61883_ERROR| TL_61883_WARNING \
                          | TL_CIP_ERROR  \
                          | TL_FCP_ERROR  | TL_FCP_WARNING \
                          | TL_STRM_ERROR | TL_STRM_WARNING \
                          | TL_CLK_ERROR


ULONG AVCStrmTraceMask = TraceMaskCheckIn;
ULONG AVCStrmAssertLevel = 1;
#endif

#ifdef ALLOC_PRAGMA
        // #pragma alloc_text(INIT, DriverEntry)  // Comment out or facing Win9x loader bug
        #pragma alloc_text(PAGE, VA_AddDevice)
        #pragma alloc_text(PAGE, VA_DriverUnload)
#endif



NTSTATUS DriverEntry(
                        IN PDRIVER_OBJECT DriverObject, 
                        IN PUNICODE_STRING RegistryPath
                    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    ULONG i;

    PAGED_CODE();

    TRACE(TL_PNP_ERROR,("<<<<<<< AVCStrm.sys: %s; %s; %x %x >>>>>>>>\n", 
        __DATE__, __TIME__, DriverObject, RegistryPath));

#ifdef TIME_BOMB
    if (HasEvaluationTimeExpired()) {
        TRACE(TL_PNP_ERROR, ("Evaluation period expired!") );
        return STATUS_EVALUATION_EXPIRATION;
    }
#endif

    TRACE(TL_PNP_ERROR,("===================================================================\n"));
    TRACE(TL_PNP_ERROR,("AVCStrmTraceMask=0x%.8x = 0x[7][6][5][4][3][2][1][0] where\n", AVCStrmTraceMask));
    TRACE(TL_PNP_ERROR,("\n"));
    TRACE(TL_PNP_ERROR,("PNP:   [0]:Loading, power state, surprise removal, device SRB..etc.\n"));
    TRACE(TL_PNP_ERROR,("61883: [1]:Plugs, connection, CMP info and call to 61883.\n"));
    TRACE(TL_PNP_ERROR,("CIP:   [2]:Isoch data transfer.\n"));
    TRACE(TL_PNP_ERROR,("AVC:   [3]:AVC commands.\n"));
    TRACE(TL_PNP_ERROR,("Stream:[4]:Data intersec, open/close,.state, property etc.\n"));
    TRACE(TL_PNP_ERROR,("Clock: [5]:Clock (event and signal)etc.\n"));
    TRACE(TL_PNP_ERROR,("===================================================================\n"));
    TRACE(TL_PNP_ERROR,("dd avcstrm!AVCStrmTraceMask L1\n"));
    TRACE(TL_PNP_ERROR,("e avcstrm!AVCStrmTraceMask <new value> <enter>\n"));
    TRACE(TL_PNP_ERROR,("<for each nibble: ERROR:8, WARNING:4, TRACE:2, INFO:1, MASK:f>\n"));
    TRACE(TL_PNP_ERROR,("===================================================================\n\n"));


    /*
     *  Route all IRPs on device objects created by this driver
     *  to our IRP dispatch routine.
     */
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++){
        DriverObject->MajorFunction[i] = VA_Dispatch; 
    }

    DriverObject->DriverExtension->AddDevice = VA_AddDevice;
    DriverObject->DriverUnload = VA_DriverUnload;

    return STATUS_SUCCESS;
}


NTSTATUS VA_AddDevice(
                        IN PDRIVER_OBJECT driverObj, 
                        IN PDEVICE_OBJECT physicalDevObj
                     )
/*++

Routine Description:

    The PlugPlay subsystem is handing us a brand new 
    PDO (Physical Device Object), for which we
    (by means of INF registration) have been asked to filter.

    We need to determine if we should attach or not.
    Create a filter device object to attach to the stack
    Initialize that device object
    Return status success.

    Remember: we can NOT actually send ANY non pnp IRPS to the given driver
    stack, UNTIL we have received an IRP_MN_START_DEVICE.

Arguments:

    driverObj - pointer to a device object.

    physicalDevObj -    pointer to a physical device object pointer 
                        created by the  underlying bus driver.

Return Value:

    NT status code.

--*/

{
    NTSTATUS status;
    PDEVICE_OBJECT filterDevObj = NULL;
    
    PAGED_CODE();

    TRACE(TL_PNP_WARNING,("VA_AddDevice: drvObj=%ph, pdo=%ph\n", driverObj, physicalDevObj)); 

    status = IoCreateDevice(    driverObj, 
                                sizeof(struct DEVICE_EXTENSION),
                                NULL,           // name for this device
                                FILE_DEVICE_UNKNOWN, 
                                FILE_AUTOGENERATED_DEVICE_NAME,                // device characteristics
                                FALSE,          // not exclusive
                                &filterDevObj); // our device object

    if (NT_SUCCESS(status)){
        struct DEVICE_EXTENSION *devExt;

        ASSERT(filterDevObj);

        /*
         *  Initialize device extension for new device object
         */
        devExt = (struct DEVICE_EXTENSION *)filterDevObj->DeviceExtension;
        RtlZeroMemory(devExt, sizeof(struct DEVICE_EXTENSION));
        devExt->signature = DEVICE_EXTENSION_SIGNATURE;
        devExt->state = STATE_INITIALIZED;
        devExt->filterDevObj = filterDevObj;
        devExt->physicalDevObj = physicalDevObj;
        
        devExt->pendingActionCount = 0;
        KeInitializeEvent(&devExt->removeEvent, NotificationEvent, FALSE);
#ifdef HANDLE_DEVICE_USAGE
        KeInitializeEvent(&devExt->deviceUsageNotificationEvent, SynchronizationEvent, TRUE);
#endif // HANDLE_DEVICE_USAGE

        /*
         *  Attach the new device object to the top of the device stack.
         */
        devExt->topDevObj = IoAttachDeviceToDeviceStack(filterDevObj, physicalDevObj);

        ASSERT(devExt->topDevObj);
        TRACE(TL_PNP_WARNING,("created filterDevObj %ph attached to %ph.\n", filterDevObj, devExt->topDevObj));


        //
        // As a filter driver, we do not want to change the power or I/O
        // behavior of the driver stack in any way.  Recall that a filter
        // driver should "appear" the same (almost) as the underlying device.
        // Therefore we must copy some bits from the device object _directly_
        // below us in the device stack (notice: DON'T copy from the PDO!)
        //


        /* Various I/O-related flags which should be maintained */
        /* (copy from lower device object) */
        filterDevObj->Flags |=
            (devExt->topDevObj->Flags & (DO_BUFFERED_IO | DO_DIRECT_IO));

        /* Various Power-related flags which should be maintained */
        /* (copy from lower device object) */
        filterDevObj->Flags |= (devExt->topDevObj->Flags &
            (DO_POWER_INRUSH | DO_POWER_PAGABLE /*| DO_POWER_NOOP*/)); 

#ifdef HANDLE_DEVICE_USAGE
        //
        // To determine whether some of our routines should initially be
        // pageable, we must consider the DO_POWER_xxxx flags of the
        // device object directly below us in the device stack.
        //
        // * We make ourselves pageable if:
        //     - that devobj has its PAGABLE bit set (so we know our power
        //       routines won't be called at DISPATCH_LEVEL)
        // -OR-
        //     - that devobj has its NOOP bit set (so we know we won't be
        //       participating in power-management at all).  NOTE, currently
        //       DO_POWER_NOOP is not implemented.
        //
        // * Otherwise, we make ourselves non-pageable because either:
        //     - that devobj has its INRUSH bit set (so we also have to be
        //       INRUSH, and code that handles INRUSH irps can't be pageable)
        // -OR-
        //     - that devobj does NOT have its PAGABLE bit set (and NOOP isn't
        //       set, so some of our code might be called at DISPATCH_LEVEL)
        //
        if ((devExt->topDevObj->Flags & DO_POWER_PAGABLE)
             /*|| (devExt->topDevObj->Flags & DO_POWER_NOOP)*/)
        {
            // We're initially pageable.
            //
            // Don't need to do anything else here, for now.
        }
        else
        {
            // We're initially non-pageable.
            //
            // We need to lock-down the code for all routines
            // that could be called at IRQL >= DISPATCH_LEVEL.
            TRACE(TL_STRM_TRACE,("LOCKing some driver code (non-pageable) (b/c init conditions)\n" ));
            devExt->initUnlockHandle = MmLockPagableCodeSection( VA_Power );  // some func that's inside the code section that we want to lock
            ASSERT( NULL != devExt->initUnlockHandle );
        }

        /*
         *  Remember our initial flag settings.
         *  (Need remember initial settings to correctly handle
         *  setting of PAGABLE bit later.)
         */
        devExt->initialFlags = filterDevObj->Flags & ~DO_DEVICE_INITIALIZING;
#endif // HANDLE_DEVICE_USAGE

        /*
         *  Clear the initializing bit from the new device object's flags.
         *  NOTE: must not do this until *after* setting DO_POWER_xxxx flags
         */
        filterDevObj->Flags &= ~DO_DEVICE_INITIALIZING;

        /*
         *  This is a do-nothing call to a sample function which
         *  demonstrates how to read the device's registry area.
         *  Note that you cannot make this call on devExt->filterDevObj
         *  because a filter device object does not have a devNode.
         *  We pass devExt->physicalDevObj, which is the device object
         *  for which this driver is a filter driver.
         */
        RegistryAccessSample(devExt, devExt->physicalDevObj);
    } 

    ASSERT(NT_SUCCESS(status));
    return status;
}


VOID VA_DriverUnload(IN PDRIVER_OBJECT DriverObject)
/*++

Routine Description:

    Free all the allocated resources, etc.

    Note:  Although the DriverUnload function often does nothing,
           the driver must set a DriverUnload function in 
           DriverEntry; otherwise, the kernel will never unload
           the driver.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    PAGED_CODE();

    TRACE(TL_PNP_WARNING,("VA_DriverUnload\n")); 
}


NTSTATUS VA_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    Common entrypoint for all Io Request Packets

Arguments:

    DeviceObject - pointer to a device object.
    Irp - Io Request Packet

Return Value:

    NT status code.

--*/

{
    struct DEVICE_EXTENSION *devExt;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN passIrpDown = TRUE;
    UCHAR majorFunc, minorFunc;
    NTSTATUS status;

    devExt = DeviceObject->DeviceExtension;
    ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Get major/minor function codes in private variables
     *  so we can access them after the IRP is completed.
     */
    majorFunc = irpSp->MajorFunction;
    minorFunc = irpSp->MinorFunction;

    TRACE(TL_PNP_TRACE,("VA_Dispatch: majorFunc=%d, minorFunc=%d\n", 
            (ULONG)majorFunc, (ULONG)minorFunc)); 

    /*
     *  For all IRPs except REMOVE, we increment the PendingActionCount
     *  across the dispatch routine in order to prevent a race condition with
     *  the REMOVE_DEVICE IRP (without this increment, if REMOVE_DEVICE
     *  preempted another IRP, device object and extension might get
     *  freed while the second thread was still using it).
     */
    if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE))){
        IncrementPendingActionCount(devExt);
    }

    if ((majorFunc != IRP_MJ_PNP) &&
        (majorFunc != IRP_MJ_CLOSE) &&
        (majorFunc != IRP_MJ_INTERNAL_DEVICE_CONTROL) &&
        ((devExt->state == STATE_REMOVING) ||
         (devExt->state == STATE_REMOVED))){

        /*
         *  While the device is being removed, 
         *  we only pass down the PNP and CLOSE IRPs.
         *  We fail all other IRPs.
         */
        status = Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        passIrpDown = FALSE;
        TRACE(TL_PNP_WARNING,("Dev is removing/removed: majorFunc:%x; DevExt->state:%d\n", majorFunc, devExt->state ));
    }
    else {
        switch (majorFunc){

            case IRP_MJ_PNP:
                status = VA_PnP(devExt, Irp);
                passIrpDown = FALSE;
                break;

            case IRP_MJ_POWER:
                status = VA_Power(devExt, Irp);
                passIrpDown = FALSE;
                break;

            case IRP_MJ_DEVICE_CONTROL:  // Resue the user IRP
                TRACE(TL_PNP_ERROR,("IRP_MJ_DEVICE_CONTROL: Irp:%x\n", Irp));
                break;

            case IRP_MJ_INTERNAL_DEVICE_CONTROL: 
                switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
                {
                case IOCTL_AVCSTRM_CLASS:   
                    status = AvcStrm_IoControl(DeviceObject, Irp);
                    passIrpDown = FALSE;  // Completed or marked pending in AvcStrm_IoControl().
                    break;  // to decrement pending action count
                default:
                    TRACE(TL_PNP_TRACE,("IRP_MJ_INTERNAL_DEVICE_CONTROL: IoControlCode:%x; !Support by AVCStrm; Pass it down.\n", irpSp->Parameters.DeviceIoControl.IoControlCode));
                    break;
                }

            case IRP_MJ_CREATE:
            case IRP_MJ_CLOSE:
            case IRP_MJ_SYSTEM_CONTROL:
            default:
                /*
                 *  For unsupported IRPs, we simply send the IRP
                 *  down the driver stack.
                 */
                break;
        }
    }

    if (passIrpDown){
        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = IoCallDriver(devExt->topDevObj, Irp);
    }

    /*
     *  Balance the increment to PendingActionCount above.
     */
    if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE))){
        DecrementPendingActionCount(devExt);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\avcstrm\avcdefs.h ===
//
// Differnt level of WDM supports may use different API
//
// e.g. MmGetSystemAddressForMdl (win9x) 
//          Return NULL for Win9x; bugcheck for Win2000 if NULL would have returned.
//
//      MmGetSystemAddressForMdlSafe (win2000)
//          Not supported in Win9x or Millen
//
// This is defined in SOURCES file.


#define NUM_BUF_ATTACHED_THEN_ISOCH         4   // number of buffers attached before streaming and also as the water mark.


//
// These definition and macros are used to calculate the picture numbers.
// With OHCI spec, the data is returned with the 16bit Cycle time, which includes
// 3 bits of SecondCount and 13 bits of the CycleCount.  This "timer" will wrap in 8 seconds.
//
#define TIME_PER_CYCLE     1250   // One 1394 cycle; unit = 100 nsec
#define CYCLES_PER_SECOND  8000
#define MAX_SECOND_COUNTS     7   // The returned CycleTime contains 3 bits of SecondCount; that is 0..7
#define MAX_CYCLES        (MAX_SECOND_COUNTS + 1) * CYCLES_PER_SECOND    // 0..MAX_CYCLES-1
#define MAX_CYCLES_TIME   (MAX_CYCLES * TIME_PER_CYCLE)                  // unit = 100nsec

#define VALIDATE_CYCLE_COUNTS(CT) ASSERT(CT.CL_SecondCount <= 7 && CT.CL_CycleCount < CYCLES_PER_SECOND && CT.CL_CycleOffset == 0);

#define CALCULATE_CYCLE_COUNTS(CT) (CT.CL_SecondCount * CYCLES_PER_SECOND + CT.CL_CycleCount);

#define CALCULATE_DELTA_CYCLE_COUNT(prev, now) ((now > prev) ? now - prev : now + MAX_CYCLES - prev)

//
// Return avg time per frame in the unit of 100 nsec; 
// for calculation accuracy using only integer calculation, 
// we should do do multimplcation before division.
// That is why the application can request to get numerator and denominator separately.
// 
#define GET_AVG_TIME_PER_FRAME(format)       ((format == AVCSTRM_FORMAT_SDDV_NTSC) ? (1001000/3)  : FRAME_TIME_PAL)
#define GET_AVG_TIME_PER_FRAME_NUM(format)   ((format == AVCSTRM_FORMAT_SDDV_NTSC) ? 1001000      : 400000)
#define GET_AVG_TIME_PER_FRAME_DENOM(format) ((format == AVCSTRM_FORMAT_SDDV_NTSC) ? 3            : 1)


#define GET_NUM_PACKETS_PER_FRAME(format)       ((format == AVCSTRM_FORMAT_SDDV_NTSC) ? 4004/15 /* 100100/375 */ : MAX_SRC_PACKETS_PER_PAL_FRAME)
#define GET_NUM_PACKETS_PER_FRAME_NUM(format)   ((format == AVCSTRM_FORMAT_SDDV_NTSC) ? 4004                     : MAX_SRC_PACKETS_PER_PAL_FRAME)
#define GET_NUM_PACKETS_PER_FRAME_DENOM(format) ((format == AVCSTRM_FORMAT_SDDV_NTSC) ? 15                       : 1)


//
// Structure used to keep track of and to perform stream data queuing
//
typedef struct _AVC_STREAM_DATA_STRUCT {

    ULONG  SizeOfThisPacket;

    //
    // Frame size is calculated based on
    //    CIP_DBS * 4 * (CIP_FN==0? 1 : (CIP_FN==1 ? 2 : (CIP_FN==2 ? 4 : 8)))
    //
    ULONG  SourcePacketSize;

    //
    // Frame size is calculated based on
    //    SourcePacketSize * SRC_PACKETS_PER_***
    //
    ULONG  FrameSize;

    //
    //  Current stream time
    //
    LONGLONG CurrentStreamTime;
    ULONG  LastCycleCount;  // Used only for MPEG2TS stream

    //
    // Statistic of the frame information since last start stream
    // PictureNumber = FramesProcessed + FramesDropped + cndSRBCancelled.
    //    
    LONGLONG  PictureNumber;     
    LONGLONG  FramesProcessed;   // Frame made it to 1394 serial bus.
    LONGLONG  FramesDropped;

#if DBG
    LONGLONG  FramesAttached;
#endif

    LONGLONG  cntFrameCancelled;

    //
    // Count number of Data IRP received
    //
    LONGLONG  cntDataReceived;

    //
    // Count and list for the attach list
    //
    LONG       cntDataAttached;
    LIST_ENTRY DataAttachedListHead;

    //
    // Count and list for the SRB list
    //
    LONG       cntDataQueued;        // Used only with SRB_WRITE_DATA
    LIST_ENTRY DataQueuedListHead;   // Used only with SRB_WRITE_DATA

    //
    // Count and list for the detach list
    //
    LONG       cntDataDetached;
    LIST_ENTRY DataDetachedListHead;

    //
    // Lock to serialize attach and detach of list
    //
    KSPIN_LOCK DataListLock;

    //
    // Memory blocked allocated at passive level for queuing data IOs.
    //
    PBYTE pMemoryBlock;

    //
    // Signalled when there is no more attach frame; mainoy used to guarantee that all
    // data attached are transmitted before isoch is stopped for transmitting data
    // from PC to AVC device.
    //  
    KEVENT hNoAttachEvent;


} AVC_STREAM_DATA_STRUCT, * PAVC_STREAM_DATA_STRUCT;


typedef struct DEVICE_EXTENSION;

//
// An AVC stream extension is created per stream opened.  This will be returned to the caller,
// when it will be used as the context (like a HANDLE) for subsequent call.
// The allocation will include
//
//     AVC_STREAM_EXTENSION
//     AV1394_FORMAT_INFO
//     AV_CLIENT_REQ
//
typedef struct _AVC_STREAM_EXTENSION {

    ULONG  SizeOfThisPacket;

    //
    // This driver's device extension
    //
    struct DEVICE_EXTENSION  * pDevExt;

    //
    // Data flow direction
    //
    KSPIN_DATAFLOW  DataFlow;  // Determine in or output pin

    //
    // Holds state
    //
    KSSTATE StreamState;

    //
    // This flag indicate if isoch is TALK/LISTEN or STOPPED
    //
    BOOLEAN IsochIsActive;  // Close associated with StreamState

    //
    // Abstrction i/oPCR of an AVC device and PC itself as a plug handles
    // Connection handle is used when two plugs are connected.
    // 
    HANDLE  hPlugRemote;  // Target (DVCR,D-VHS) device plug;
    HANDLE  hPlugLocal;   //.Local i/oPCR;
    HANDLE  hConnect;     // Connect two plugs

    //
    // Structure for specifing an AVC stream
    //
    PAVCSTRM_FORMAT_INFO  pAVCStrmFormatInfo;

    //
    // Structure for data flow control (IsochActive, IOQueues..etc)
    //
    PAVC_STREAM_DATA_STRUCT pAVCStrmDataStruc;

    //
    // Synchronizing setting stream control and processing data
    //
    KMUTEX  hMutexControl;


    //
    // Synchronize sharing the below AV_61883_REQUEST structure
    // Since all the stream control are synchronouse so we can use the same 
    // AV61883Req structure to issue 61883 request
    //
    KMUTEX  hMutexAVReq;
    PIRP  pIrpAVReq;
    AV_61883_REQUEST  AVReq;


    //
    // Counter used to indicate starting of an work item to cancel 
    //
    LONG lAbortToken;

    //
    // Hold the work item
    //
#ifdef USE_WDM110  // Win2000 code base
    PIO_WORKITEM       pIoWorkItem;
#else
    WORK_QUEUE_ITEM    IoWorkItem;
#endif

    //
    // TO signal that an work item is completed.
    //
    KEVENT hAbortDoneEvent;

    //
    // Cached plug state (these are dynamic values)
    //
    CMP_GET_PLUG_STATE  RemotePlugState;

#ifdef NT51_61883
    //
    // Cyclic cycle count of last DV frame
    //
    ULONG  CycleCount16bits;
#endif  // NT51_61883

    //
    // Keep track of the last system time when the stream time was updated.
    // This is used to calibrate the current stream time when it is queries.
    //
    ULONGLONG LastSystemTime;


    //
    // Discontinuity is introduced when traistioning from RUN->PAUSE->RUN.
    // The stream time will not increment in PAUSE state but system time (1394 CycleTime) does.
    //
    BOOL  b1stNewFrameFromPauseState;

} AVC_STREAM_EXTENSION, *PAVC_STREAM_EXTENSION;


//
// Valid data entry states for a data request and they
// can be Or'ed to show their code path.
//
// Examples of different possible code path: 
//
//    (A) Attached -> Pending -> Callback -> Completed 
//    (B) Callback -> Attached -> Completed
//    (C) Attached -> Cancelled -> Completed
//

enum DATA_ENTRY_STATE {
    DE_PREPARED                     = 0x01,
    DE_IRP_LOWER_ATTACHED_COMPLETED = 0x02,
    DE_IRP_UPPER_PENDING_COMPLETED  = 0x04,
    DE_IRP_LOWER_CALLBACK_COMPLETED = 0x08,
    DE_IRP_UPPER_COMPLETED          = 0x10,    
    DE_IRP_ERROR                    = 0x20,    
    DE_IRP_CANCELLED                = 0x40,    
};

#define IsStateSet(state, bitmask) ((state & (bitmask)) == bitmask)

//
// This is the data entry used to attach a frame 
//
typedef struct _AVCSTRM_DATA_ENTRY {

    LIST_ENTRY  ListEntry;

    // 
    // Keep track of data entry state
    //
    enum DATA_ENTRY_STATE  State;

    //
    // IRP from client of upper layer
    //
    PIRP  pIrpUpper;

    //
    // Clock provider information
    //
    BOOL  ClockProvider;  // Client is a clock provider?
    HANDLE  ClockHandle;  // This is used only if !ClockProvider; it is possible that there is no clock used.

    //
    // Contain information about this streaming buffer
    //
    PKSSTREAM_HEADER  StreamHeader;

    //
    // Frame buffer
    //
    PVOID  FrameBuffer;

    //
    // Stream extension (Context) of the stream of this frame 
    //
    PAVC_STREAM_EXTENSION  pAVCStrmExt;
   
#if DBG
    //
    // Add debug related info here
    //
    LONGLONG  FrameNumber;
#endif

    //
    // 61883 CIP frame structure
    //
    struct _CIP_FRAME *  Frame;

    //
    // IRP used to send to 61883 (lower layer) for AV request, such as attach and release
    //
    PIRP  pIrpLower;

    //
    // Use to send 61883 AV data request
    //
    AV_61883_REQUEST  AVReq;

} AVCSTRM_DATA_ENTRY, *PAVCSTRM_DATA_ENTRY;



//
// To open a stream.
//    A context is created and return to the caller.  This context is need for all 
//    stream operation.
//

NTSTATUS
AVCStreamOpen(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN OUT AVCSTRM_OPEN_STRUCT * pOpenStruct
    );


// To Close a stram.
NTSTATUS
AVCStreamClose(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );

//
// Process stream control
// 
NTSTATUS
AVCStreamControlGetState(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    OUT KSSTATE * pKSState
    );
NTSTATUS
AVCStreamControlSetState(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN KSSTATE KSState
    );

NTSTATUS
AVCStreamControlGetProperty(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD  // BUGBUG StreamClass specific
    );
NTSTATUS
AVCStreamControlSetProperty(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD  // BUGBUG StreamClass specific
    );


// Process SRB_READ/WRITE_DATA; this is the only IRPs that will operate asychronously 
// with. and STATUS_PENDING is returned.  
NTSTATUS
AVCStreamRead(
    IN PIRP  pIrpUpper,
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN AVCSTRM_BUFFER_STRUCT  * pBufferStruct
    );

NTSTATUS
AVCStreamWrite(
    IN PIRP  pIrpUpper,
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN AVCSTRM_BUFFER_STRUCT  * pBufferStruct
    );

/*
  This will stop streaming and cancel all pending data irps. This is typically used
  to cancel all Irps.  To cancel a single Irp, use IoCancelIrp().
 */
NTSTATUS
AVCStreamAbortStreaming(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );

/*
 Process surprise removal of a device
 */
NTSTATUS
AVCStreamSurpriseRemoval(
    IN struct DEVICE_EXTENSION * pDevExt  
    );

////////////////////////////////
// AvcUtil.c function prototypes
////////////////////////////////

ULONGLONG 
GetSystemTime(
    )
    ;

NTSTATUS
AVCStrmAttachFrameCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PAVCSTRM_DATA_ENTRY  pDataEntry
    );

VOID
AVCStrmFormatAttachFrame(
    IN KSPIN_DATAFLOW  DataFlow,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN AVCSTRM_FORMAT AVCStrmFormat,
    IN PAV_61883_REQUEST  pAVReq,
    IN PAVCSTRM_DATA_ENTRY  pDataEntry,
    IN ULONG  ulSourcePacketSize,    // Packet length in bytes
    IN ULONG  ulFrameSize,           // Buffer size; may contain one or multiple source packets
    IN PIRP  pIrpUpper,
    IN PKSSTREAM_HEADER  StreamHeader,
    IN PVOID  FrameBuffer
    );

NTSTATUS
AVCStrmGetPlugHandle(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );

NTSTATUS
AVCStrmGetPlugState(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );

NTSTATUS 
AVCStrmGetConnectionProperty(
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    PULONG pulActualBytesTransferred
    );

NTSTATUS
AVCStrmGetDroppedFramesProperty(  
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    PULONG pulBytesTransferred
    );

NTSTATUS
AVCStrmMakeConnection(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );

NTSTATUS
AVCStrmBreakConnection(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );

NTSTATUS
AVCStrmStartIsoch(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );
NTSTATUS
AVCStrmStopIsoch(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );
VOID
AVCStrmWaitUntilAttachedAreCompleted(
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );
NTSTATUS
AVCStrmAllocateQueues(
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN KSPIN_DATAFLOW  DataFlow,
    IN PAVC_STREAM_DATA_STRUCT pDataStruc,
    PAVCSTRM_FORMAT_INFO  pAVCStrmFormatInfo
    );
NTSTATUS
AVCStrmFreeQueues(
    IN PAVC_STREAM_DATA_STRUCT pDataStruc
    );

NTSTATUS
AVCStrmCancelIO(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );

NTSTATUS
AVCStrmValidateFormat(
    PAVCSTRM_FORMAT_INFO  pAVCFormatInfo
    );

void
AVCStrmAbortStreamingWorkItemRoutine(
#ifdef USE_WDM110  // Win2000 code base
    // Extra parameter if using WDM10
    PDEVICE_OBJECT DeviceObject,
#endif
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\avcstrm\avcutil.c ===
/*++

Copyright (C) 1999  Microsoft Corporation

Module Name: 

    avcutil.c

Abstract

    MS AVC streaming utility functions

Author:

    Yee Wu    03/17/2000

Revision    History:
Date        Who         What
----------- --------- ------------------------------------------------------------
03/17/2000  YJW         created
--*/

 
#include "filter.h"
#include "ksmedia.h" // KSPROERTY_DROPPEDFRAMES_CURRENT


/************************************
 * Synchronous IOCall to lower driver
 ************************************/

NTSTATUS
IrpSynchCR(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PKEVENT          Event
    )
{
    ENTER("IrpSynchCR");

    KeSetEvent(Event, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
} // IrpSynchCR


NTSTATUS
SubmitIrpSynch(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP  pIrp,
    IN PAV_61883_REQUEST pAVReq
    )
{
    NTSTATUS  Status;
    KEVENT   Event;
    PIO_STACK_LOCATION  NextIrpStack;
  
    ENTER("SubmitIrpSynch");
    Status = STATUS_SUCCESS;;

    NextIrpStack = IoGetNextIrpStackLocation(pIrp);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_61883_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = pAVReq;

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    IoSetCompletionRoutine( 
        pIrp,
        IrpSynchCR,
        &Event,
        TRUE,
        TRUE,
        TRUE
        );

    Status = 
        IoCallDriver(
            DeviceObject,
            pIrp
            );

    if (Status == STATUS_PENDING) {
        
        TRACE(TL_PNP_INFO,("Irp is pending...\n"));
                
        if(KeGetCurrentIrql() < DISPATCH_LEVEL) {
            KeWaitForSingleObject( 
                &Event,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );
            TRACE(TL_PNP_TRACE,("Irp returned; IoStatus.Status %x\n", pIrp->IoStatus.Status));
            Status = pIrp->IoStatus.Status;  // Final status
  
        }
        else {
            ASSERT(FALSE && "Pending but in DISPATCH_LEVEL!");
            return Status;
        }
    }

    EXIT("SubmitIrpSynch", Status);
    return Status;
} // SubmitIrpSynchAV




/****************************
 * Control utility functions
 ****************************/

NTSTATUS
AVCStrmGetPlugHandle(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    )
{
    NTSTATUS Status;
    PAV_61883_REQUEST  pAVReq;

    PAGED_CODE();
    ENTER("AVCStrmGetPlugHandle");

    Status = STATUS_SUCCESS;

    // Claim ownership of hMutexAVReqIsoch
    KeWaitForMutexObject(&pAVCStrmExt->hMutexAVReq, Executive, KernelMode, FALSE, NULL);

    pAVReq = &pAVCStrmExt->AVReq;
    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_GetPlugHandle);
    pAVReq->GetPlugHandle.PlugNum = 0;
    pAVReq->GetPlugHandle.hPlug   = 0;
    pAVReq->GetPlugHandle.Type    = pAVCStrmExt->DataFlow == KSPIN_DATAFLOW_OUT ? CMP_PlugOut : CMP_PlugIn;

    Status = SubmitIrpSynch(DeviceObject, pAVCStrmExt->pIrpAVReq, pAVReq);

    if(!NT_SUCCESS(Status)) {
        TRACE(TL_61883_ERROR,("GetPlugHandle: Failed:%x\n", Status));
        ASSERT(NT_SUCCESS(Status));
        pAVCStrmExt->hPlugRemote = NULL;               
    }
    else {
        TRACE(TL_61883_TRACE,("GetPlugHandle:hPlug:%x\n", pAVReq->GetPlugHandle.hPlug));
        pAVCStrmExt->hPlugRemote = pAVReq->GetPlugHandle.hPlug;          
    }

    KeReleaseMutex(&pAVCStrmExt->hMutexAVReq, FALSE);


    EXIT("AVCStrmGetPlugHandle", Status);
    return Status;
}

NTSTATUS
AVCStrmGetPlugState(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    )
/*++

Routine Description:

    Ask 61883.sys for the plug state.
 
Arguments:

Return Value:

    Nothing

--*/
{
    NTSTATUS Status;
    PAV_61883_REQUEST  pAVReq;

    PAGED_CODE();
    ENTER("AVCStrmGetPlugState");

    Status = STATUS_SUCCESS;

    //
    // Check only requirement: hConnect
    //
    if(pAVCStrmExt->hPlugRemote == NULL) {
        TRACE(TL_STRM_ERROR,("GetPlugState: hPlugRemote is NULL.\n")); 
        ASSERT(pAVCStrmExt->hPlugRemote != NULL);
        return STATUS_UNSUCCESSFUL;
    }

    // Claim ownership of hMutexAVReqIsoch
    KeWaitForMutexObject(&pAVCStrmExt->hMutexAVReq, Executive, KernelMode, FALSE, NULL);

    pAVReq = &pAVCStrmExt->AVReq;
    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_GetPlugState);
    pAVReq->GetPlugState.hPlug = pAVCStrmExt->hPlugRemote;

    Status = 
        SubmitIrpSynch( 
            DeviceObject,
            pAVCStrmExt->pIrpAVReq,
            pAVReq
            );

    if(!NT_SUCCESS(Status)) {
        TRACE(TL_61883_ERROR,("GetPlugState Failed %x\n", Status));
    }
    else {
        // Cache plug state (note: these are dynamic values)
        pAVCStrmExt->RemotePlugState = pAVReq->GetPlugState;

        TRACE(TL_61883_TRACE,("GetPlugState: ST %x; State %x; DRate %d; Payld %d; BCCnt %d; PPCnt %d\n", 
            pAVReq->Flags ,
            pAVReq->GetPlugState.State,
            pAVReq->GetPlugState.DataRate,
            pAVReq->GetPlugState.Payload,
            pAVReq->GetPlugState.BC_Connections,
            pAVReq->GetPlugState.PP_Connections
            ));
    }

    KeReleaseMutex(&pAVCStrmExt->hMutexAVReq, FALSE);

    EXIT("AVCStrmGetPlugState", Status);
    return Status;
}



NTSTATUS
AVCStrmMakeConnection(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    )
/*++

Routine Description:

    Make an isoch connection.

--*/
{
    NTSTATUS Status;
    PAV_61883_REQUEST  pAVReq;
    PAVCSTRM_FORMAT_INFO  pAVCStrmFormatInfo;

    PAGED_CODE();
    ENTER("AVCStrmMakeConnection");

    // Claim ownership of hMutexAVReqIsoch
    KeWaitForMutexObject(&pAVCStrmExt->hMutexAVReq, Executive, KernelMode, FALSE, NULL);

    TRACE(TL_61883_TRACE,("MakeConnect: State:%d; hConnect:%x\n", pAVCStrmExt->StreamState, pAVCStrmExt->hConnect));
    if(pAVCStrmExt->hConnect) {
        KeReleaseMutex(&pAVCStrmExt->hMutexAVReq, FALSE);
        return STATUS_SUCCESS;
    }

    Status = STATUS_SUCCESS;

    pAVCStrmFormatInfo = pAVCStrmExt->pAVCStrmFormatInfo;
    pAVReq = &pAVCStrmExt->AVReq;
    INIT_61883_HEADER(pAVReq, Av61883_Connect);
    pAVReq->Connect.Type = CMP_PointToPoint;  // !!

    // see which way we the data will flow...
    if(pAVCStrmExt->DataFlow == KSPIN_DATAFLOW_OUT) {
        // Remote(oPCR)->Local(iPCR)
        pAVReq->Connect.hOutputPlug      = pAVCStrmExt->hPlugRemote;
        pAVReq->Connect.hInputPlug       = pAVCStrmExt->hPlugLocal;
        // Other parameters !!

    } else {
        // Remote(iPCR)<-Local(oPCR)
        pAVReq->Connect.hOutputPlug      = pAVCStrmExt->hPlugLocal;
        pAVReq->Connect.hInputPlug       = pAVCStrmExt->hPlugRemote;

        pAVReq->Connect.Format.FMT       = (UCHAR) pAVCStrmFormatInfo->cipHdr2.FMT;  // From AV/C in/outpug plug signal format status cmd
        // 00 for NTSC, 80 for PAL; set the 50/60 bit  
        // From AV/C in/outpug plug signal format status cmd         
        pAVReq->Connect.Format.FDF_hi    = 
            ((UCHAR) pAVCStrmFormatInfo->cipHdr2.F5060_OR_TSF << 7) |
            ((UCHAR) pAVCStrmFormatInfo->cipHdr2.STYPE << 2) |
            ((UCHAR) pAVCStrmFormatInfo->cipHdr2.RSV);

        //
        // 16bit SYT field = 4BitCycleCount:12BitCycleOffset;
        // Will be set by 61883
        //
        pAVReq->Connect.Format.FDF_mid   = 0;  
        pAVReq->Connect.Format.FDF_lo    = 0;
    
        //
        // Constants depend on the A/V data format (in or out plug format)
        //
        pAVReq->Connect.Format.bHeader   = (BOOL)  pAVCStrmFormatInfo->cipHdr1.SPH;
        pAVReq->Connect.Format.Padding   = (UCHAR) pAVCStrmFormatInfo->cipHdr1.QPC;
        pAVReq->Connect.Format.BlockSize = (UCHAR) pAVCStrmFormatInfo->cipHdr1.DBS; 
        pAVReq->Connect.Format.Fraction  = (UCHAR) pAVCStrmFormatInfo->cipHdr1.FN;
    }

    pAVReq->Connect.Format.BlockPeriod = pAVCStrmFormatInfo->BlockPeriod;

    TRACE(TL_61883_TRACE,("Connect:hOutPlg:%x<->hInPlug:%x; cipQuad2[%.2x:%.2x:%.2x:%.2x]; BlkSz %d; SrcPkt %d; AvgTm %d, BlkPrd %d\n", 
        pAVReq->Connect.hOutputPlug,
        pAVReq->Connect.hInputPlug,
        pAVReq->Connect.Format.FMT,
        pAVReq->Connect.Format.FDF_hi,
        pAVReq->Connect.Format.FDF_mid,
        pAVReq->Connect.Format.FDF_lo,
        pAVReq->Connect.Format.BlockSize,
        pAVCStrmFormatInfo->SrcPacketsPerFrame,
        pAVCStrmFormatInfo->AvgTimePerFrame,
        pAVReq->Connect.Format.BlockPeriod
        ));

    Status = 
        SubmitIrpSynch( 
            DeviceObject,
            pAVCStrmExt->pIrpAVReq,
            pAVReq
            );

    if(!NT_SUCCESS(Status)) {
        TRACE(TL_61883_ERROR,("Connect Failed = 0x%x\n", Status));     
        pAVCStrmExt->hConnect = NULL;
    }
    else {
        TRACE(TL_61883_TRACE,("hConnect = 0x%x\n", pAVReq->Connect.hConnect));
        pAVCStrmExt->hConnect = pAVReq->Connect.hConnect;
    }

    KeReleaseMutex(&pAVCStrmExt->hMutexAVReq, FALSE);

    EXIT("AVCStrmMakeConnection", Status);
    return Status;
}

NTSTATUS
AVCStrmBreakConnection(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    )
/*++

Routine Description:

    Break the isoch connection.

--*/
{
    NTSTATUS Status;
    PAV_61883_REQUEST  pAVReq;
#if DBG
    PAVC_STREAM_DATA_STRUCT pDataStruc;
#endif
    PAGED_CODE();
    ENTER("AVCStrmBreakConnection");

    // Claim ownership of hMutexAVReqIsoch
    KeWaitForMutexObject(&pAVCStrmExt->hMutexAVReq, Executive, KernelMode, FALSE, NULL);

    TRACE(TL_STRM_TRACE,("BreakConnect: State:%d; hConnect:%x\n", pAVCStrmExt->StreamState, pAVCStrmExt->hConnect));
    if(!pAVCStrmExt->hConnect) {
        KeReleaseMutex(&pAVCStrmExt->hMutexAVReq, FALSE);
        return STATUS_SUCCESS;
    }

    Status = STATUS_SUCCESS;

#if DBG
    pDataStruc = pAVCStrmExt->pAVCStrmDataStruc;
#endif
    pAVReq = &pAVCStrmExt->AVReq;
    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_Disconnect);
    pAVReq->Disconnect.hConnect = pAVCStrmExt->hConnect;
    
    Status = 
        SubmitIrpSynch( 
            DeviceObject,
            pAVCStrmExt->pIrpAVReq,
            pAVReq
            );

    // This could be caused that the connection was not P2P, and 
    // it tried to disconnect.
    if(!NT_SUCCESS(Status) || Status == STATUS_NO_SUCH_DEVICE) {
        TRACE(TL_61883_ERROR,("Disconnect Failed:%x; AvReq->ST %x\n", Status, pAVReq->Flags  ));
    } else {
        TRACE(TL_61883_TRACE,("Disconnect suceeded; ST %x; AvReq->ST %x\n", Status, pAVReq->Flags  ));
    }

    TRACE(TL_STRM_WARNING,("*** DisConn St:%x; Stat: DataRcved:%d; [Pic# =? Prcs:Drp:Cncl] [%d ?=%d+%d+%d]\n", 
        Status, 
        (DWORD) pDataStruc->cntDataReceived,
        (DWORD) pDataStruc->PictureNumber,
        (DWORD) pDataStruc->FramesProcessed, 
        (DWORD) pDataStruc->FramesDropped,
        (DWORD) pDataStruc->cntFrameCancelled
        ));

    // We will not have another chance to reconnect it so we assume it is disconnected.
    pAVCStrmExt->hConnect = NULL;    

    KeReleaseMutex(&pAVCStrmExt->hMutexAVReq, FALSE);


    EXIT("AVCStrmBreakConnection", Status);
    return Status;
}

NTSTATUS
AVCStrmStartIsoch(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    )
/*++

Routine Description:

    Start streaming.

--*/
{
    NTSTATUS Status;
    PAVC_STREAM_DATA_STRUCT pDataStruc;
    PAGED_CODE();
    ENTER("AVCStrmStartIsoch");


    // Claim ownership of hMutexAVReqIsoch
    KeWaitForMutexObject(&pAVCStrmExt->hMutexAVReq, Executive, KernelMode, FALSE, NULL);

    if(pAVCStrmExt->IsochIsActive) {
        TRACE(TL_STRM_WARNING,("Isoch already active!"));
        KeReleaseMutex(&pAVCStrmExt->hMutexAVReq, FALSE);
        return STATUS_SUCCESS;
    }

    if(!pAVCStrmExt->hConnect) {
        ASSERT(pAVCStrmExt->hConnect && "Cannot start isoch while graph is not connected!\n");
        KeReleaseMutex(&pAVCStrmExt->hMutexAVReq, FALSE);
        return STATUS_INVALID_PARAMETER;
    }

    Status = STATUS_SUCCESS;
    pDataStruc = pAVCStrmExt->pAVCStrmDataStruc;

    TRACE(TL_61883_TRACE,("StartIsoch: flow %d; AQD [%d:%d:%d]\n", pAVCStrmExt->DataFlow, pDataStruc->cntDataAttached, pDataStruc->cntDataQueued, pDataStruc->cntDataDetached));


    RtlZeroMemory(&pAVCStrmExt->AVReq, sizeof(AV_61883_REQUEST));
    if(pAVCStrmExt->DataFlow == KSPIN_DATAFLOW_OUT) {
        INIT_61883_HEADER(&pAVCStrmExt->AVReq, Av61883_Listen);
        pAVCStrmExt->AVReq.Listen.hConnect = pAVCStrmExt->hConnect;
    } else {
        INIT_61883_HEADER(&pAVCStrmExt->AVReq, Av61883_Talk);
        pAVCStrmExt->AVReq.Talk.hConnect = pAVCStrmExt->hConnect;
        if(pAVCStrmExt->pAVCStrmFormatInfo->AVCStrmFormat == AVCSTRM_FORMAT_MPEG2TS) 
            pAVCStrmExt->AVReq.Flags = CIP_TALK_DOUBLE_BUFFER | CIP_TALK_USE_SPH_TIMESTAMP;
    }

    Status = 
        SubmitIrpSynch( 
            DeviceObject,
            pAVCStrmExt->pIrpAVReq,
            &pAVCStrmExt->AVReq
            );

    if (NT_SUCCESS(Status)) {
        pAVCStrmExt->IsochIsActive = TRUE;
        TRACE(TL_61883_TRACE,("Av61883_%s; Status %x; Streaming...\n", (pAVCStrmExt->DataFlow == KSPIN_DATAFLOW_OUT ? "Listen" : "Talk"), Status));
    }
    else {
        TRACE(TL_61883_ERROR,("Av61883_%s; failed %x\n", (pAVCStrmExt->DataFlow == KSPIN_DATAFLOW_OUT ? "Listen" : "Talk"), Status));
        ASSERT(NT_SUCCESS(Status) && "Start isoch failed!");
    }

    KeReleaseMutex(&pAVCStrmExt->hMutexAVReq, FALSE);

    
    EXIT("AVCStrmStartIsoch", Status);
    return Status;
}


//
// This wait is based on testing transmitting MPEG2TS data with up to 32 date request.
// Each data request has 256 MPEG2TS data packets.  There is a slow motion mode,
// and it may take longer for video to be transmitted in the slow motion mode.
//
#define MAX_ATTACH_WAIT  50000000   // max wait time in seconds

VOID
AVCStrmWaitUntilAttachedAreCompleted(
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    )
{
    KIRQL oldIrql;
    PAVC_STREAM_DATA_STRUCT pDataStruc;

    pDataStruc = pAVCStrmExt->pAVCStrmDataStruc;

    //
    // Wait until attached data to complete transmission before aborting (cancel) them
    //
    KeAcquireSpinLock(&pDataStruc->DataListLock, &oldIrql);
    if(   pAVCStrmExt->DataFlow == KSPIN_DATAFLOW_IN 
       && pDataStruc->cntDataAttached > 0
        ) {
        LARGE_INTEGER tmMaxWait;
        NTSTATUS StatusWait;
#if DBG
        ULONGLONG tmStart;
#endif
        TRACE(TL_STRM_TRACE,("StopIsoch: MaxWait %d (msec) for %d data buffer to finished transmitting!\n", 
            MAX_ATTACH_WAIT/10000, pDataStruc->cntDataAttached));
        //
        // This event will be signalled when all attach buffers are returned.
        // It is protected by Spinlock for common data pDataStruc->cntDataAttached.
        //
        KeClearEvent(&pDataStruc->hNoAttachEvent);
#if DBG        
        tmStart = GetSystemTime();
#endif
        KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql);

        tmMaxWait = RtlConvertLongToLargeInteger(-(MAX_ATTACH_WAIT));
        StatusWait = 
            KeWaitForSingleObject( 
                &pDataStruc->hNoAttachEvent,
                Executive,
                KernelMode,
                FALSE,
                &tmMaxWait
                );
               
        if(StatusWait == STATUS_TIMEOUT) {
            TRACE(TL_STRM_ERROR,("TIMEOUT (%d msec) on hNoAttachEvent! DataRcv:%d; AQD [%d:%d:%d]\n", 
                (DWORD) (GetSystemTime()-tmStart)/10000,
                (DWORD) pDataStruc->cntDataReceived,
                pAVCStrmExt->pAVCStrmDataStruc->cntDataAttached,
                pAVCStrmExt->pAVCStrmDataStruc->cntDataQueued,
                pAVCStrmExt->pAVCStrmDataStruc->cntDataDetached
                ));
        } else {
            TRACE(TL_STRM_WARNING,("Status:%x; (%d msec) on hNoAttachEvent. DataRcv:%d; AQD [%d:%d:%d]\n", 
                StatusWait, 
                (DWORD) (GetSystemTime()-tmStart)/10000,
                (DWORD) pDataStruc->cntDataReceived,
                pAVCStrmExt->pAVCStrmDataStruc->cntDataAttached,
                pAVCStrmExt->pAVCStrmDataStruc->cntDataQueued,
                pAVCStrmExt->pAVCStrmDataStruc->cntDataDetached
                ));
        }
        
    } else {
        KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql);
    }
}


NTSTATUS
AVCStrmStopIsoch(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    )
/*++

Routine Description:

    Stop streaming.

--*/
{
    NTSTATUS Status;
    PAVC_STREAM_DATA_STRUCT pDataStruc;


    PAGED_CODE();
    ENTER("AVCStrmStopIsoch");


    // Claim ownership of hMutexAVReqIsoch
    KeWaitForMutexObject(&pAVCStrmExt->hMutexAVReq, Executive, KernelMode, FALSE, NULL);

    if(!pAVCStrmExt->IsochIsActive) {
        TRACE(TL_STRM_WARNING|TL_61883_WARNING,("Isoch already not active!"));
        KeReleaseMutex(&pAVCStrmExt->hMutexAVReq, FALSE);
        return STATUS_SUCCESS;
    }

    if(!pAVCStrmExt->hConnect) {
        ASSERT(pAVCStrmExt->hConnect && "Cannot stop isoch while graph is not connected!\n");
        KeReleaseMutex(&pAVCStrmExt->hMutexAVReq, FALSE);
        return STATUS_INVALID_PARAMETER;
    }

    Status = STATUS_SUCCESS;
    pDataStruc = pAVCStrmExt->pAVCStrmDataStruc;

    TRACE(TL_STRM_TRACE,("IsochSTOP; flow %d; AQD [%d:%d:%d]\n", pAVCStrmExt->DataFlow, pDataStruc->cntDataAttached, pDataStruc->cntDataQueued, pDataStruc->cntDataDetached));

    RtlZeroMemory(&pAVCStrmExt->AVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(&pAVCStrmExt->AVReq, Av61883_Stop);
    pAVCStrmExt->AVReq.Listen.hConnect = pAVCStrmExt->hConnect;

    Status = 
        SubmitIrpSynch( 
            DeviceObject,
            pAVCStrmExt->pIrpAVReq,
            &pAVCStrmExt->AVReq
            );

    if (NT_SUCCESS(Status) || Status == STATUS_NO_SUCH_DEVICE) {
        TRACE(TL_61883_TRACE,("Av61883_%s; Status %x; Stopped...\n", (pAVCStrmExt->DataFlow == KSPIN_DATAFLOW_OUT ? "Listen" : "Talk"), Status));
    } else {
        TRACE(TL_61883_ERROR,("Av61883_%s; failed %x\n", (pAVCStrmExt->DataFlow == KSPIN_DATAFLOW_OUT ? "Listen" : "Talk"), Status));
        ASSERT(NT_SUCCESS(Status) && "Stop isoch failed!");
    }

    // Assume isoch is stopped regardless of the return status.
    pAVCStrmExt->IsochIsActive = FALSE;

    KeReleaseMutex(&pAVCStrmExt->hMutexAVReq, FALSE);

    EXIT("AVCStrmStopIsoch", Status);
    return Status;
}


/******************************
 * Streaming utility funcrtions
 *******************************/

//
// GetSystemTime in 100 nS units
//

ULONGLONG GetSystemTime()
{

    LARGE_INTEGER rate, ticks;

    ticks = KeQueryPerformanceCounter(&rate);

    return (KSCONVERT_PERFORMANCE_TIME(rate.QuadPart, ticks));
}


///
// The "signature" of the header section of Seq0 of incoming source packets:
//
// "Blue" book, Part2, 11.4 (page 50); Figure 66, table 36 (page 111)
//
// ID0 = {SCT2,SCT1,SCT0,RSV,Seq3,Seq2,Seq1,Seq0} 
//
//     SCT2-0 = {0,0,0} = Header Section Type
//     RSV    = {1}
//     Seq3-0 = {1,1,1,1} for NoInfo or {0,0,0,} for Sequence 0
//
// ID1 = {DSeq3-0, 0, RSV, RSV, RSV} 
//     DSeq3-0 = {0, 0, 0, 0} = Beginning of a DV frame
//
// ID2 = {DBN7,DBN6,DBN5,DBN4,DBN3,DBN2,DBN1,DBN0}
//     DBB7-0 = {0,0,0,0,0,0,0,0,0} = Beginning of a DV frame
//

#define DIF_BLK_ID0_SCT_MASK       0xe0 // 11100000b; Section Type (SCT)2-0 are all 0's for the Header section
#define DIF_BLK_ID1_DSEQ_MASK      0xf0 // 11110000b; DIF Sequence Number(DSEQ)3-0 are all 0's 
#define DIF_BLK_ID2_DBN_MASK       0xff // 11111111b; Data Block Number (DBN)7-0 are all 0's 

#define DIF_HEADER_DSF             0x80 // 10000000b; DSF=0; 10 DIF Sequences (525-60)
                                        //            DSF=1; 12 DIF Sequences (625-50)

#define DIF_HEADER_TFn             0x80 // 10000000b; TFn=0; DIF bloick of area N are transmitted in the current DIF sequence.
                                        //            TFn=1; DIF bloick of area N are NOT transmitted in the current DIF sequence.


ULONG
AVCStrmDVReadFrameValidate(           
    IN PCIP_VALIDATE_INFO  pInfo
    )
/*++

Routine Description:

   Used to validate the header section of a frame. so 61883 will start filling data for a DVFrame.
   Note: This routine apply only to DV ONLY.

Return

    0  verified
    1: invallid

--*/
{
    if(pInfo->Packet) {        

        //
        // Detect header 0 signature.
        //
        if(
             (pInfo->Packet[0] & DIF_BLK_ID0_SCT_MASK)  == 0 
          && (pInfo->Packet[1] & DIF_BLK_ID1_DSEQ_MASK) == 0 
          && (pInfo->Packet[2] & DIF_BLK_ID2_DBN_MASK)  == 0 
          ) {
                
            // Check TF1, TF2, and  TF3:  1: not transmitted; 0:transmitted
            // TF1:Audio; TF2:Video; TF3:Subcode; they all need to be 0 to be valid.
            if((pInfo->Packet[5] & 0x80) ||
               (pInfo->Packet[6] & 0x80) ||
               (pInfo->Packet[7] & 0x80) 
               ) {
                TRACE(TL_CIP_TRACE,("inv src pkts; [%x %x %d %x], [%x   %x %x %x]\n", 
                    pInfo->Packet[0],
                    pInfo->Packet[1],
                    pInfo->Packet[2],
                    pInfo->Packet[3],
                    pInfo->Packet[4],
                    pInfo->Packet[5],
                    pInfo->Packet[6],
                    pInfo->Packet[7]
                    ));
                // Valid header but DIF block for this area is not transmitted.
                // Some DV (such as DVCPro) may wait untill its "mecha and servo" to be stable to make these valid.
                // This should happen if a graph is in run state before a tape is played (and stablized).
                return 1;
            }
            return 0;
        }
        else {
            return 1;
        }
    }
    else {
        TRACE(TL_CIP_ERROR,("Validate: invalid SrcPktSeq; Packet %x\n", pInfo->Packet)); 
        return 1;
    }
} // DVReadFrameValidate

NTSTATUS
AVCStrmProcessReadComplete(
    PAVCSTRM_DATA_ENTRY  pDataEntry,
    PAVC_STREAM_EXTENSION  pAVCStrmExt,
    PAVC_STREAM_DATA_STRUCT  pDataStruc
    )
/*++

Routine Description:

    Process the data read completion.   

--*/
{
    PKSSTREAM_HEADER  pStrmHeader;
    LONGLONG  LastPictureNumber;
    NTSTATUS Status = STATUS_SUCCESS;

    pStrmHeader = pDataEntry->StreamHeader;
    ASSERT(pStrmHeader->Size >= sizeof(KSSTREAM_HEADER));


    // Check CIP_STATUS from 61883
    // CIP_STATUS_CORRUPT_FRAME (0x00000001)
    if(pDataEntry->Frame->Status & CIP_STATUS_CORRUPT_FRAME) {
        TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("CIP_STATUS_CORRUPT_FRAME\n"));
        pStrmHeader->OptionsFlags = 0;
        Status = STATUS_SUCCESS; // Success but no data !
        pStrmHeader->DataUsed = 0;
        pDataStruc->PictureNumber++;  pDataStruc->FramesProcessed++;
    }
    else
    // CIP_STATUS_SUCCESS       (0x00000000)
    // CIP_STATUS_FIRST_FRAME   (0x00000002)
    if(pDataEntry->Frame->Status == CIP_STATUS_SUCCESS ||
       pDataEntry->Frame->Status & CIP_STATUS_FIRST_FRAME)   {

        // Only increment FramesProcessed if it is a valid frame;
        pDataStruc->FramesProcessed++;
        Status = STATUS_SUCCESS;

        pStrmHeader->OptionsFlags = KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT;

#ifdef NT51_61883
        pStrmHeader->DataUsed     = pDataEntry->Frame->CompletedBytes; 
#else
        pStrmHeader->DataUsed     = pAVCStrmExt->pAVCStrmDataStruc->FrameSize;               
#endif

        // This subunit driver is a Master clock
       if (pDataEntry->ClockProvider) {
#ifdef NT51_61883
            ULONG  ulDeltaCycleCounts;

            // If not the first frame. we will calculate the drop frame information.
            if(pAVCStrmExt->b1stNewFrameFromPauseState) { 
                // Default number of packets for a DV frame
                if(pDataStruc->FramesProcessed > 1)  // PAUSE->RUN->PAUSE->RUN case; no increase for the 1st frame.
                    pDataStruc->CurrentStreamTime += pAVCStrmExt->pAVCStrmFormatInfo->AvgTimePerFrame;
                pAVCStrmExt->b1stNewFrameFromPauseState = FALSE;                

            } else {           
                ULONG ulCycleCount16bits;

                // Calculate skipped 1394 cycle from the returned CycleTime
                VALIDATE_CYCLE_COUNTS(pDataEntry->Frame->Timestamp);
                ulCycleCount16bits = CALCULATE_CYCLE_COUNTS(pDataEntry->Frame->Timestamp);
                ulDeltaCycleCounts = CALCULATE_DELTA_CYCLE_COUNT(pAVCStrmExt->CycleCount16bits, ulCycleCount16bits); 

                // Adjust to max allowable gap to the max elapsed time of the CycleTime returned by OHCI 1394.
                if(ulDeltaCycleCounts > MAX_CYCLES)
                    ulDeltaCycleCounts = MAX_CYCLES;
    
                // There are two cases for drop frames: (1) Starve of buffer; (2) no data
                // If there is starving, status will be CIP_STATUS_FIRST_FRAME.  
                if(pDataEntry->Frame->Status & CIP_STATUS_FIRST_FRAME)   {
                    // Convert packets (cycles) to time in 100 nanosecond unit; (one cycle = 1250 * 100 nsec)
                    // We could use the skip frame, but CycleCount is more accurate.
                    pDataStruc->CurrentStreamTime += ulDeltaCycleCounts * TIME_PER_CYCLE;   // Use cycle count to be precise.                 
                } else {
                    // Ignore all "drop frames" in the "no data" case
                    if(ulDeltaCycleCounts * TIME_PER_CYCLE > pAVCStrmExt->pAVCStrmFormatInfo->AvgTimePerFrame)
                        // There might be some frame(s) skipped due to no data or tape stopped playing, we skip this skipped data.
                        pDataStruc->CurrentStreamTime += pAVCStrmExt->pAVCStrmFormatInfo->AvgTimePerFrame;
                    else 
                        pDataStruc->CurrentStreamTime += ulDeltaCycleCounts * TIME_PER_CYCLE;   // Use cycle count to be precise.                 
                } 
            }

            // StreamTime start with 0; 
            pStrmHeader->PresentationTime.Time = pDataStruc->CurrentStreamTime;

            // Use to adjust the queried stream time
            pAVCStrmExt->LastSystemTime = GetSystemTime();

            // Cache current CycleCount
            pAVCStrmExt->CycleCount16bits = CALCULATE_CYCLE_COUNTS(pDataEntry->Frame->Timestamp);

#else   // NT51_61883
            // This is the old way when 61883 was not returning the correct CycleTime.
            // This is the old way when 61883 was not returning the correct CycleTime.
            pStrmHeader->PresentationTime.Time = pDataStruc->CurrentStreamTime;            
            pAVCStrmExt->LastSystemTime = GetSystemTime();  // Use to adjust the queried stream time
            pDataStruc->CurrentStreamTime += pAVCStrmExt->pAVCStrmFormatInfo->AvgTimePerFrame;
#endif  // NT51_61883

        // no Clock so "free flowing!"
        } else {
            pStrmHeader->PresentationTime.Time = 0;
        }

        // Put in Timestamp info depending on clock provider            
        pStrmHeader->PresentationTime.Numerator   = 1;
        pStrmHeader->PresentationTime.Denominator = 1;

        // Only if there is a clock, presentation time and drop frames information are set.
        //  Acoording to DDK:
        //  The PictureNumber member count represents the idealized count of the current picture, 
        //  which is calculated in one of two ways: 
        // ("Other" clock) Measure the time since the stream was started and divide by the frame duration. 
        // (MasterClock) Add together the count of frames captured and the count of frame dropped. 
        //
        // Here, we know the current stream time, and the picture number is calculated from that.
        //
       
        if(pDataEntry->ClockProvider) {

            pStrmHeader->Duration = 
                pAVCStrmExt->pAVCStrmFormatInfo->AvgTimePerFrame;

            pStrmHeader->OptionsFlags |= 
                (KSSTREAM_HEADER_OPTIONSF_TIMEVALID |     // pStrmHeader->PresentationTime.Time is valid
                 KSSTREAM_HEADER_OPTIONSF_DURATIONVALID); 

            if(pDataEntry->Frame->Status & CIP_STATUS_FIRST_FRAME) 
                pStrmHeader->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;            

            // Calculate picture number and dropped frame;
            // For NTSC, it could be 267 or 266 packet time per frame. Since integer calculation will round, 
            // we will add a packet time (TIME_PER_CYCLE = 125 us = 1250 100nsec) to that.This is only used for calculation.
            LastPictureNumber = pDataStruc->PictureNumber;  
            pDataStruc->PictureNumber = 
                1 +   // Picture number start with 1.but PresetationTime start with 0.
                (pStrmHeader->PresentationTime.Time + TIME_PER_CYCLE)
                * (LONGLONG) GET_AVG_TIME_PER_FRAME_DENOM(pAVCStrmExt->pAVCStrmFormatInfo->AVCStrmFormat) 
                / (LONGLONG) GET_AVG_TIME_PER_FRAME_NUM(pAVCStrmExt->pAVCStrmFormatInfo->AVCStrmFormat);

            if(pDataStruc->PictureNumber > LastPictureNumber+1) {
                pStrmHeader->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;  // If there is a skipped frame, set the discontinuity flag
                TRACE(TL_CIP_WARNING,("Discontinuity: LastPic#:%d; Pic#%d; PresTime:%d;\n", (DWORD) LastPictureNumber, (DWORD) pDataStruc->PictureNumber, (DWORD) pStrmHeader->PresentationTime.Time));
            }

            if(pDataStruc->PictureNumber <= LastPictureNumber) {
                TRACE(TL_STRM_TRACE|TL_CIP_TRACE,("Same pic #:%d; LastPic:%d; tmPres:%d; OptionFlags:%x\n", 
                    (DWORD) pDataStruc->PictureNumber, 
                    (DWORD) LastPictureNumber, 
                    (DWORD) pStrmHeader->PresentationTime.Time,
                    pStrmHeader->OptionsFlags));
                pDataStruc->PictureNumber = LastPictureNumber + 1;  // Picture number must progress !!!!
            }

            pDataStruc->FramesDropped = pDataStruc->PictureNumber - pDataStruc->FramesProcessed;

        // no Clock so "free flowing!"
        } else {
            pStrmHeader->Duration = 0;  // No clock so not valid.
            pDataStruc->PictureNumber++;
            TRACE(TL_STRM_TRACE,("No clock: PicNum:%d\n", (DWORD) pDataStruc->PictureNumber));
        }
    }
    else {
        // 61883 has not defined this yet!         
        pStrmHeader->OptionsFlags = 0;
        Status = STATUS_SUCCESS;
        pStrmHeader->DataUsed = 0;
        pDataStruc->PictureNumber++;  pDataStruc->FramesProcessed++;
        TRACE(TL_STRM_ERROR|TL_CIP_ERROR,("Unexpected Frame->Status %x\n", pDataEntry->Frame->Status));
        ASSERT(FALSE && "Unknown pDataEntry->Frame->Status");
    }

#if 0
    // For VidOnly which uses VideoInfoHeader and has 
    // an extended frame information (KS_FRAME_INFO) appended to KSSTREAM_HEADER
    if(pStrmHeader->Size >= (sizeof(KSSTREAM_HEADER) + sizeof(PKS_FRAME_INFO)) ) {
        pFrameInfo = (PKS_FRAME_INFO) (pStrmHeader + 1);
        pFrameInfo->ExtendedHeaderSize = sizeof(KS_FRAME_INFO);
        pFrameInfo->PictureNumber = pDataStruc->PictureNumber;
        pFrameInfo->DropCount     = pDataStruc->FramesDropped;
        pFrameInfo->dwFrameFlags  = 
            KS_VIDEO_FLAG_FRAME |     // Complete frame
            KS_VIDEO_FLAG_I_FRAME;    // Every DV frame is an I frame
    }
#endif

#if DBG
    // Validate that the data is return in the right sequence
    if(pDataEntry->FrameNumber != pDataStruc->FramesProcessed) {
        TRACE(TL_STRM_ERROR|TL_CIP_ERROR,("ProcessRead: OOSequence %d != %d\n",  (DWORD) pDataEntry->FrameNumber, (DWORD) pDataStruc->FramesProcessed));
    };
#endif

    return Status;
}

ULONG
AVCStrmCompleteRead(
    PCIP_NOTIFY_INFO     pInfo
    )
/*++

Routine Description:

    61883 has completed receiving data and callback to us to complete.   

--*/
{
    PAVCSTRM_DATA_ENTRY  pDataEntry;
    PAVC_STREAM_EXTENSION  pAVCStrmExt;
    PAVC_STREAM_DATA_STRUCT  pDataStruc;
    KIRQL oldIrql;


    // Callback and in DISPATCH_LEVEL
    // The called might have acquired spinlock as well!

    TRACE(TL_STRM_INFO,("CompleteRead: pInfo:%x\n", pInfo));

    pDataEntry = pInfo->Context;

    if(!pDataEntry) {     
        ASSERT(pDataEntry && "Context is NULL!\n");
        return 1;
    }
    pAVCStrmExt = pDataEntry->pAVCStrmExt;
    if(!pAVCStrmExt) {
        ASSERT(pAVCStrmExt && "pAVCStrmExt is NULL\n");
        return 1;
    }    
    pDataStruc = pAVCStrmExt->pAVCStrmDataStruc;
    if(!pDataStruc) {
        ASSERT(pDataStruc && "pDataStruc is NULL\n");
        return 1;
    }

    KeAcquireSpinLock(&pDataStruc->DataListLock, &oldIrql);

#if DBG
    // It is possible that a buffer is completed before it is return from IoCallDriver to attach this buffer.
    if(!IsStateSet(pDataEntry->State, DE_IRP_LOWER_ATTACHED_COMPLETED)) {

        TRACE(TL_STRM_WARNING,("AVCStrmCompleteRead: pDataEntry:%x not yet attached but completed.\n", pDataEntry));
        
        //
        // This irp will be completed from its IoCallDriver to attach this frame.
        //
     } 
#endif

    // Can the cancel routione is ahead of us? Error condition.
    if(pDataStruc->cntDataAttached <= 0) {
        TRACE(TL_STRM_ERROR|TL_CIP_ERROR,("AVCStrmCompleteRead:pAVCStrmExt:%x, pDataEntry:%x, AQD[%d:%d:%d]\n", 
            pAVCStrmExt, pDataEntry, pDataStruc->cntDataAttached, pDataStruc->cntDataQueued,pDataStruc->cntDataDetached));
        KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql); 
        return 1;  
    }

    //
    // Process this completion based on the return status from 61883
    //
    pDataEntry->pIrpUpper->IoStatus.Status = 
        AVCStrmProcessReadComplete(
            pDataEntry,
            pAVCStrmExt,
            pDataStruc
            );

    //
    // There are two possible ways to complete the data request:
    //
    // (A) Normal case:       attach data request (pIrpLower), attached completed, notify callback (here), and completion (pIrpUpper)
    // (B) Rare/stress case:  attach data request (pIrpLower), notify callback (here), attach complete (pIrpLower), and complete (pIrpUpper)
    //

    pDataEntry->State |= DE_IRP_LOWER_CALLBACK_COMPLETED;

    //
    // Case (A): If DE_IRP_LOWER_CALLBACK_COMPLETED is set and pIrpUpper is marked pending, complete the UpperIrp.
    //
  
    if(IsStateSet(pDataEntry->State, DE_IRP_LOWER_ATTACHED_COMPLETED)) {

        if(IsStateSet(pDataEntry->State, DE_IRP_UPPER_PENDING_COMPLETED)) {

            //
            // This is the normal case: attached, IoMarkPending, then complete in the callback routine.
            //

            IoCompleteRequest( pDataEntry->pIrpUpper, IO_NO_INCREMENT );  pDataEntry->State |= DE_IRP_UPPER_COMPLETED;

            //
            // Transfer from attach to detach list
            //

            RemoveEntryList(&pDataEntry->ListEntry); InterlockedDecrement(&pDataStruc->cntDataAttached); 
#if DBG
            if(pDataStruc->cntDataAttached < 0) {
                TRACE(TL_STRM_ERROR|TL_CIP_ERROR,("pDataStruc:%x; pDataEntry:%x\n", pDataStruc, pDataEntry));        
                ASSERT(pDataStruc->cntDataAttached >= 0);  
            }
#endif
            InsertTailList(&pDataStruc->DataDetachedListHead, &pDataEntry->ListEntry);  InterlockedIncrement(&pDataStruc->cntDataDetached);

            //
            // pDataEntry should not be referenced after this.
            //

        } else {

            TRACE(TL_STRM_TRACE,("Watch out! pDataEntry:%x in between attach complete and IoMarkIrpPending!\n", pDataEntry));        

            //
            // Case (B): Complete IrpUpper when return to IoCallDriver(IrpLower)            
            // Note: The IrpLower has not called IoMarkIrpPending().  (Protected with spinlock)
            //
        }

    } else {

        //
        // Case (B): Complete IrpUpper when return to IoCallDriver(IrpLower) 
        //
    }
 
    KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql); 

    return 0;
} // AVCStrmCompleteRead

#if DBG
PAVCSTRM_DATA_ENTRY  pLastDataEntry;
LONGLONG  LastFrameNumber;
#endif

ULONG
AVCStrmCompleteWrite(
    PCIP_NOTIFY_INFO     pInfo
    )
/*++

Routine Description:

    61883 has completed receiving data and callback to us to complete.   

--*/
{
    PAVCSTRM_DATA_ENTRY  pDataEntry;
    PAVC_STREAM_EXTENSION  pAVCStrmExt;
    PAVC_STREAM_DATA_STRUCT  pDataStruc;
    NTSTATUS  irpStatus;
    KIRQL oldIrql;


    // Callback and in DISPATCH_LEVEL
    // The called might have acquired spinlock as well!

    TRACE(TL_STRM_INFO,("CompleteWrite: pInfo:%x\n", pInfo));

    pDataEntry = pInfo->Context;

    if(!pDataEntry) {     
        ASSERT(pDataEntry && "Context is NULL!\n");
        return 1;
    }
    pAVCStrmExt = pDataEntry->pAVCStrmExt;
    if(!pAVCStrmExt) {
        ASSERT(pAVCStrmExt && "pAVCStrmExt is NULL\n");
        return 1;
    }    
    pDataStruc = pAVCStrmExt->pAVCStrmDataStruc;
    if(!pDataStruc) {
        ASSERT(pDataStruc && "pDataStruc is NULL\n");
        return 1;
    }

#if 0  // Must complete it!
    // If isoch is not active, then we are in the process of stopping; Let this be cancellable.
    if(!pAVCStrmExt->IsochIsActive) {   
        TRACE(TL_STRM_ERROR,("AVCStrmCompleteRead: IsochActive:%d; pDataEntry:%x\n", pAVCStrmExt->IsochIsActive, pDataEntry));        
        ASSERT(pAVCStrmExt->IsochIsActive);
        return 1;
    }
#endif

    irpStatus = STATUS_SUCCESS;
    KeAcquireSpinLock(&pDataStruc->DataListLock, &oldIrql);

#if DBG
    // It is possible that a buffer is completed before it is return from IoCallDriver to attach this buffer.
    if(!IsStateSet(pDataEntry->State, DE_IRP_LOWER_ATTACHED_COMPLETED)) {

        TRACE(TL_STRM_WARNING,("CompleteWrite: pDataEntry:%x not yet attached but completed.\n", pDataEntry));

        //
        // This irp will be completed from its IoCallDriver to attach this frame.
        //
    } 
#endif

    // Can the cancel routione is ahead of us? Error condition.
    if(pDataStruc->cntDataAttached <= 0) {
        TRACE(TL_STRM_ERROR|TL_CIP_ERROR,("AVCStrmCompleteWrite:pAVCStrmExt:%x, pDataEntry:%x, AQD[%d:%d:%d]\n", 
            pAVCStrmExt, pDataEntry, pDataStruc->cntDataAttached, pDataStruc->cntDataQueued,pDataStruc->cntDataDetached));
        KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql); 
        return 1;  
    }


    //
    // Process according to status for the frame 
    //
    if(pDataEntry->Frame->Status & CIP_STATUS_CORRUPT_FRAME) {
        pDataStruc->FramesProcessed++;
        TRACE(TL_CIP_ERROR,("CIP_STATUS_CORRUPT_FRAME; pIrpUpper:%x; pIrpLower:%x\n", pDataEntry->pIrpUpper, pDataEntry->pIrpLower));
    } else 
    if(pDataEntry->Frame->Status == CIP_STATUS_SUCCESS ||
       pDataEntry->Frame->Status &  CIP_STATUS_FIRST_FRAME) {
#if DBG
        if(pDataEntry->Frame->Status & CIP_STATUS_FIRST_FRAME)
            TRACE(TL_CIP_TRACE,("CIP_STATUS_FIRST_FRAME; pIrpUpper:%x; pIrpLower:%x\n", pDataEntry->pIrpUpper, pDataEntry->pIrpLower));
#endif
        pDataStruc->FramesProcessed++;
    } else {
        pDataStruc->FramesProcessed++;
        TRACE(TL_CIP_ERROR,("Unknown Status:%x\n", pDataEntry->Frame->Status));      
    }

    pDataStruc->PictureNumber++;


#if DBG
    //
    // Validate that the data is return in the right sequence
    //
    if(pDataEntry->FrameNumber != pDataStruc->FramesProcessed) {
        TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("CompleteWrite: OOSequence FrameNum:%d != FrameProcessed:%d;  pIrpUpper:%x; pIrpLower:%x; Last(%d:%x,%x)\n",  
            (DWORD) pDataEntry->FrameNumber, (DWORD) pDataStruc->FramesProcessed,
            pDataEntry->pIrpUpper, pDataEntry->pIrpLower,
            (DWORD) pLastDataEntry->FrameNumber, pLastDataEntry->pIrpUpper, pLastDataEntry->pIrpLower
            ));
        // ASSERT(pDataEntry->FrameNumber == pDataStruc->FramesProcessed);
    };
    pLastDataEntry = pDataEntry;
    LastFrameNumber = pDataEntry->FrameNumber;
#endif

    //
    // There are two possible ways to complete the data request:
    //
    // (A) Normal case:       attach data request (pIrpLower), attached completed, notify callback (here), and completion (pIrpUpper)
    // (B) Rare/stress case:  attach data request (pIrpLower), notify callback (here), attach complete (pIrpLower), and complete (pIrpUpper)
    //

    pDataEntry->pIrpUpper->IoStatus.Status = irpStatus;     

    pDataEntry->State |= DE_IRP_LOWER_CALLBACK_COMPLETED;

    //
    // Case (A): If DE_IRP_LOWER_CALLBACK_COMPLETED is set and pIrpUpper is marked pending, complete the UpperIrp.
    //
  
    if(IsStateSet(pDataEntry->State, DE_IRP_LOWER_ATTACHED_COMPLETED)) {

        if(IsStateSet(pDataEntry->State, DE_IRP_UPPER_PENDING_COMPLETED)) {

            //
            // This is the normal case: attached, IoMarkPending, then complete in the callback routine.
            //

            IoCompleteRequest( pDataEntry->pIrpUpper, IO_NO_INCREMENT );  pDataEntry->State |= DE_IRP_UPPER_COMPLETED;

            //
            // Transfer from attach to detach list
            //

            RemoveEntryList(&pDataEntry->ListEntry); InterlockedDecrement(&pDataStruc->cntDataAttached);        

            //
            // Signal when there is no more data buffer attached.
            //
            if(pDataStruc->cntDataAttached == 0) 
                KeSetEvent(&pDataStruc->hNoAttachEvent, 0, FALSE);  

#if DBG
            if(pDataStruc->cntDataAttached < 0) {
                TRACE(TL_STRM_ERROR|TL_CIP_ERROR,("pDataStruc:%x; pDataEntry:%x\n", pDataStruc, pDataEntry));        
                ASSERT(pDataStruc->cntDataAttached >= 0);  
            }
#endif
            InsertTailList(&pDataStruc->DataDetachedListHead, &pDataEntry->ListEntry);  InterlockedIncrement(&pDataStruc->cntDataDetached);

            //
            // pDataEntry should not be referenced after this.
            //

        } else {

            TRACE(TL_STRM_TRACE,("Watch out! pDataEntry:%x in between attach complete and IoMarkIrpPending!\n", pDataEntry));        

            //
            // Case (B): Complete IrpUpper when return to IoCallDriver(IrpLower);
            // Note: The IrpLower has not called IoMarkIrpPending().  (Protected with spinlock)
            //
        }

    } else {

        //
        // Case (B): Complete IrpUpper when return to IoCallDriver(IrpLower) 
        //
    }

    KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql); 

    return 0;
} // AVCStrmCompleteWrite



NTSTATUS
AVCStrmAttachFrameCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PAVCSTRM_DATA_ENTRY  pDataEntry
    )
/*++

Routine Description:

    Completion routine for attaching a data request to 61883.

--*/
{
    PAVC_STREAM_EXTENSION  pAVCStrmExt;
    PAVC_STREAM_DATA_STRUCT  pDataStruc;
    KIRQL oldIrql;

    PAGED_CODE();

    pAVCStrmExt = pDataEntry->pAVCStrmExt;
    pDataStruc = pAVCStrmExt->pAVCStrmDataStruc;

    KeAcquireSpinLock(&pDataStruc->DataListLock, &oldIrql);

    //
    // Check for possible attaching data request error
    //

    if(!NT_SUCCESS(pIrp->IoStatus.Status)) {

        TRACE(TL_STRM_ERROR|TL_CIP_ERROR,("AttachFrameCR: pDataEntry:%x; pIrp->IoStatus.Status:%x (Error!)\n", pDataEntry, pIrp->IoStatus.Status));
        ASSERT(NT_SUCCESS(pIrp->IoStatus.Status)); 
        
        pDataEntry->State |= DE_IRP_ERROR;

        //
        // If attach data request has failed, we complete the pIrpUpper with this error.
        //
        pDataEntry->pIrpUpper->IoStatus.Status = pIrp->IoStatus.Status; // or should we cancel (STATUS_CANCELLED) it?
        IoCompleteRequest( pDataEntry->pIrpUpper, IO_NO_INCREMENT );   pDataEntry->State |= DE_IRP_UPPER_COMPLETED;

        //
        // Transfer from attach to detach list 
        //
        RemoveEntryList(&pDataEntry->ListEntry); InterlockedDecrement(&pDataStruc->cntDataAttached); 

        //
        // Signal completion event when all attached are completed.
        //
        if(pAVCStrmExt->DataFlow != KSPIN_DATAFLOW_IN && pDataStruc->cntDataAttached == 0) 
            KeSetEvent(&pDataStruc->hNoAttachEvent, 0, FALSE); 
       
        ASSERT(pDataStruc->cntDataAttached >= 0);  
        InsertTailList(&pDataStruc->DataDetachedListHead, &pDataEntry->ListEntry); InterlockedIncrement(&pDataStruc->cntDataDetached);

        //
        // No additional processing when return to IoCallDriver() with the error pIrp->IoStatus.Status.
        //
        
        KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql);   
        return STATUS_MORE_PROCESSING_REQUIRED;        
    }

#if DBG
    //
    // Validate that the data is attached in the right sequence
    //
    pDataStruc->FramesAttached++;
    if(pDataEntry->FrameNumber != pDataStruc->FramesAttached) {
        TRACE(TL_STRM_WARNING|TL_CIP_WARNING,("Attached completed OOSequence FrameNum:%d != FrameAttached:%d;  pIrpUpper:%x; pIrpLower:%x; Last(%d:%x,%x)\n",  
            (DWORD) pDataEntry->FrameNumber, (DWORD) pDataStruc->FramesAttached
            ));
        // ASSERT(pDataEntry->FrameNumber == pDataStruc->FramesAttached);
    };
#endif

    //
    // Attached data reuqest to 61883 is completed (note: however, we do not know if callback is called.)
    //
    pDataEntry->State |= DE_IRP_LOWER_ATTACHED_COMPLETED;

    KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql); 

    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
AVCStrmFormatAttachFrame(
    IN KSPIN_DATAFLOW  DataFlow,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN AVCSTRM_FORMAT AVCStrmFormat,
    IN PAV_61883_REQUEST  pAVReq,
    IN PAVCSTRM_DATA_ENTRY  pDataEntry,
    IN ULONG  ulSourcePacketSize,    // Packet length in bytes
    IN ULONG  ulFrameSize,           // Buffer size; may contain one or multiple source packets
    IN PIRP  pIrpUpper,
    IN PKSSTREAM_HEADER  StreamHeader,
    IN PVOID  FrameBuffer
    )
/*++

Routine Description:

    Format an attach frame request.

--*/
{
    InitializeListHead(&pDataEntry->ListEntry);

    // A DataEntry must be previously completed!
    ASSERT(IsStateSet(pDataEntry->State, DE_IRP_UPPER_COMPLETED) && "Reusing a data entry that was not completed!");

    pDataEntry->State        = DE_PREPARED;   // Initial state of a resued DataEntry (start over!)

    pDataEntry->pAVCStrmExt  = pAVCStrmExt;
    pDataEntry->pIrpUpper    = pIrpUpper;
    pDataEntry->StreamHeader = StreamHeader;
    pDataEntry->FrameBuffer  = FrameBuffer;

    ASSERT(pDataEntry->FrameBuffer != NULL);

    pDataEntry->Frame->pNext   = NULL;
    pDataEntry->Frame->Status  = 0;
    pDataEntry->Frame->Packet  = (PUCHAR) FrameBuffer;

#if DBG
    pDataEntry->FrameNumber    = pAVCStrmExt->pAVCStrmDataStruc->cntDataReceived;
#endif

    pDataEntry->Frame->Flags   = 0;

    if(DataFlow == KSPIN_DATAFLOW_OUT) {

        // DV needs validation to determine the header section as the start of a DV frame
        if(AVCStrmFormat == AVCSTRM_FORMAT_SDDV_NTSC  ||
           AVCStrmFormat == AVCSTRM_FORMAT_SDDV_PAL   ||
           AVCStrmFormat == AVCSTRM_FORMAT_HDDV_NTSC  ||
           AVCStrmFormat == AVCSTRM_FORMAT_HDDV_PAL   ||
           AVCStrmFormat == AVCSTRM_FORMAT_SDLDV_NTSC ||
           AVCStrmFormat == AVCSTRM_FORMAT_SDLDV_PAL ) {
            pDataEntry->Frame->pfnValidate = AVCStrmDVReadFrameValidate;   // use to validate the 1st source packet

#ifdef NT51_61883
            //
            // Set CIP_USE_SOURCE_HEADER_TIMESTAMP to get 25 bit CycleTime from source packet header 
            // (13CycleCount:12CycleOffset)
            // Do not set this to get 16 bit CycleTime from isoch packet (3 SecondCount:13CycleCount)
            // 
            pDataEntry->Frame->Flags       |= ( CIP_VALIDATE_FIRST_SOURCE  
                                              | CIP_RESET_FRAME_ON_DISCONTINUITY);  // Reset buffer pointer when encounter discontinuity
#endif
        } else {
            // MPEG2 specific flags
            pDataEntry->Frame->pfnValidate = NULL;

            if(pAVCStrmExt->pAVCStrmFormatInfo->OptionFlags & AVCSTRM_FORMAT_OPTION_STRIP_SPH)
                pDataEntry->Frame->Flags   |= CIP_STRIP_SOURCE_HEADER;
        }

        pDataEntry->Frame->ValidateContext = pDataEntry;  
        pDataEntry->Frame->pfnNotify       = AVCStrmCompleteRead;
    } 
    else {
        // DV needs validation to determine the header section as the start of a DV frame
        if(AVCStrmFormat == AVCSTRM_FORMAT_SDDV_NTSC  ||
           AVCStrmFormat == AVCSTRM_FORMAT_SDDV_PAL   ||
           AVCStrmFormat == AVCSTRM_FORMAT_HDDV_NTSC  ||
           AVCStrmFormat == AVCSTRM_FORMAT_HDDV_PAL   ||
           AVCStrmFormat == AVCSTRM_FORMAT_SDLDV_NTSC ||
           AVCStrmFormat == AVCSTRM_FORMAT_SDLDV_PAL ) {

            pDataEntry->Frame->Flags   |= CIP_DV_STYLE_SYT;
        } 
        else {
            // MPEG2 specific flag
        }

        pDataEntry->Frame->pfnValidate     = NULL;
        pDataEntry->Frame->ValidateContext = NULL;
        pDataEntry->Frame->pfnNotify       = AVCStrmCompleteWrite;
    }
    pDataEntry->Frame->NotifyContext       = pDataEntry;

    //
    // Av61883_AttachFrames
    //
    RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
    INIT_61883_HEADER(pAVReq, Av61883_AttachFrame);
    pAVReq->AttachFrame.hConnect     = pAVCStrmExt->hConnect;
    pAVReq->AttachFrame.FrameLength  = ulFrameSize;
    pAVReq->AttachFrame.SourceLength = ulSourcePacketSize;
    pAVReq->AttachFrame.Frame        = pDataEntry->Frame;

    TRACE(TL_STRM_TRACE,("DataFlow:%d; pDataEntry:%x; pIrpUp:%x; hConnect:%x; FrameSz:%d; SrcPktSz:%d; Frame:%x;\n pfnVldt:(%x, %x); pfnNtfy:(%x, %x) \n", DataFlow, 
        pDataEntry, pIrpUpper, pAVCStrmExt->hConnect, ulFrameSize, ulSourcePacketSize, pDataEntry->Frame,
        pAVReq->AttachFrame.Frame->pfnValidate, pAVReq->AttachFrame.Frame->ValidateContext,
        pAVReq->AttachFrame.Frame->pfnNotify,   pAVReq->AttachFrame.Frame->NotifyContext));

    ASSERT(pAVCStrmExt->hConnect);
}


NTSTATUS
AVCStrmCancelOnePacketCR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrpLower,
    IN PAVCSTRM_DATA_ENTRY pDataEntry
    )
/*++

Routine Description:

    Completion routine for detach an isoch descriptor associate with a pending IO.
    Will cancel the pending IO here if detaching descriptor has suceeded.

--*/
{
    PAVC_STREAM_EXTENSION  pAVCStrmExt;
    PAVC_STREAM_DATA_STRUCT  pDataStruc;
    KIRQL  oldIrql;

    ENTER("AVCStrmCancelOnePacketCR");

    if(!pDataEntry) {
        ASSERT(pDataEntry);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    pAVCStrmExt = pDataEntry->pAVCStrmExt;
    ASSERT(pAVCStrmExt);
    pDataStruc = pAVCStrmExt->pAVCStrmDataStruc;
    ASSERT(pDataStruc);

    KeAcquireSpinLock(&pDataStruc->DataListLock, &oldIrql);

    if(!NT_SUCCESS(pIrpLower->IoStatus.Status)) {

        TRACE(TL_STRM_ERROR|TL_CIP_ERROR,("CancelOnePacketCR: pIrpLower->IoStatus.Status %x (Error!)\n", pIrpLower->IoStatus.Status));
        ASSERT(pIrpLower->IoStatus.Status != STATUS_NOT_FOUND);  // Catch lost packet!

        pDataEntry->State |= DE_IRP_ERROR;

        //
        // Even though there is an error, but we have a valid DataEntry.
        // Go ahead complete and cancel it.
        //
    }

#ifdef NT51_61883

    //
    // Special case for MPEG2TS data since a data buffer contains multiple data packets 
    // (188*N or 192*N) in one data buffer.  The first cancelled buffer may contain valid 
    // data packet that an application will need to completely present a video frame.
    // So instead of cancelling it, it will be completed.
    //
    if(   pAVCStrmExt->pAVCStrmFormatInfo->AVCStrmFormat == AVCSTRM_FORMAT_MPEG2TS 
       && pDataEntry->Frame->CompletedBytes) {   

        pDataEntry->pIrpUpper->IoStatus.Status = 
            AVCStrmProcessReadComplete(
                pDataEntry,
                pAVCStrmExt,
                pDataStruc
                ); 

        //
        // CompletedBytes should be multiple of 188 or 192 bytes
        //
        ASSERT(pDataEntry->Frame->CompletedBytes % \
            ((pAVCStrmExt->pAVCStrmFormatInfo->OptionFlags & AVCSTRM_FORMAT_OPTION_STRIP_SPH) ? 188 : 192) == 0);
        
        TRACE(TL_PNP_ERROR,("pDataEntry:%x; Cancelled buffer (MPEG2TS) has %d bytes; Status:%x\n",
            pDataEntry, pDataEntry->Frame->CompletedBytes, pIrpLower->IoStatus.Status, pDataEntry->pIrpUpper->IoStatus.Status));        

    } else {
        pDataStruc->cntFrameCancelled++;
        pDataEntry->pIrpUpper->IoStatus.Status = STATUS_CANCELLED;

        TRACE(TL_CIP_TRACE,("pDataEntry:%x; Cancelled buffer (MPEG2TS) has %d bytes; Status:%x\n",
            pDataEntry, pDataEntry->Frame->CompletedBytes, pIrpLower->IoStatus.Status, pDataEntry->pIrpUpper->IoStatus.Status));        
    }

#else 

    pDataStruc->cntFrameCancelled++;
    pDataEntry->pIrpUpper->IoStatus.Status = STATUS_CANCELLED;

#endif 

    IoCompleteRequest(pDataEntry->pIrpUpper, IO_NO_INCREMENT);  pDataEntry->State |= DE_IRP_UPPER_COMPLETED;
    pDataEntry->State |= DE_IRP_CANCELLED;

    pDataEntry->pIrpUpper = NULL;  // No more access of this!
 
    //
    // Note: pDataEntry is already dequed from DataAttachList
    //
    InsertTailList(&pDataStruc->DataDetachedListHead, &pDataEntry->ListEntry); InterlockedIncrement(&pDataStruc->cntDataDetached);
    KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql); 

    EXIT("AVCStrmCancelOnePacketCR", STATUS_MORE_PROCESSING_REQUIRED);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
AVCStrmCancelIO(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    )
/*++

Routine Description:

    Cancel all pending IOs

--*/
{
    NTSTATUS  Status;
    PAVC_STREAM_DATA_STRUCT  pDataStruc;
    KIRQL  oldIrql;
    PAVCSTRM_DATA_ENTRY  pDataEntry;
    PAV_61883_REQUEST  pAVReq;
    PIO_STACK_LOCATION  NextIrpStack;

   
    PAGED_CODE();
    ENTER("AVCStrmCancelIO");

    Status = STATUS_SUCCESS;

    if(pAVCStrmExt->IsochIsActive) {

        TRACE(TL_STRM_WARNING,("Isoch is active while trying to cancel IO!\n"));
        // Try stop isoch and continue if success!
        Status = AVCStrmStopIsoch(DeviceObject, pAVCStrmExt);
        if(!NT_SUCCESS(Status) && Status != STATUS_NO_SUCH_DEVICE) {
            TRACE(TL_STRM_ERROR,("Isoch stop failed! Cannnot cancelIO while isoch active.\n"));
            return Status;
        }
    }

    //
    // Guard againt data attach completion
    //
    KeWaitForMutexObject(&pAVCStrmExt->hMutexControl, Executive, KernelMode, FALSE, NULL);


    //
    // Cancel all pending IOs
    //
    pDataStruc = pAVCStrmExt->pAVCStrmDataStruc;
    TRACE(TL_STRM_WARNING,("CancelIO Starting: pDataStruc:%x; AQD [%d:%d:%d]\n", pDataStruc,
        pDataStruc->cntDataAttached, pDataStruc->cntDataQueued, pDataStruc->cntDataDetached));

    KeAcquireSpinLock(&pDataStruc->DataListLock, &oldIrql);
    while (!IsListEmpty(&pDataStruc->DataAttachedListHead)) {
        pDataEntry = (PAVCSTRM_DATA_ENTRY) \
            RemoveHeadList(&pDataStruc->DataAttachedListHead); InterlockedDecrement(&pDataStruc->cntDataAttached);
#if DBG
        if(!IsStateSet(pDataEntry->State, DE_IRP_LOWER_ATTACHED_COMPLETED)) {
            TRACE(TL_STRM_ERROR|TL_CIP_ERROR,("CancelIO: pDataEntry:%x\n", pDataEntry));
            // Must be already attached in order to cancel it.
            ASSERT(IsStateSet(pDataEntry->State, DE_IRP_LOWER_ATTACHED_COMPLETED));
        }
#endif
        KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql);

        // Issue 61883 request to cancel this attach
        pAVReq = &pDataEntry->AVReq;
        RtlZeroMemory(pAVReq, sizeof(AV_61883_REQUEST));
        INIT_61883_HEADER(pAVReq, Av61883_CancelFrame);

        pAVReq->CancelFrame.hConnect = pAVCStrmExt->hConnect;
        pAVReq->CancelFrame.Frame    = pDataEntry->Frame;
        TRACE(TL_STRM_TRACE,("Canceling AttachList: pAvReq %x; pDataEntry:%x\n", pAVReq, pDataEntry));

        NextIrpStack = IoGetNextIrpStackLocation(pDataEntry->pIrpLower);
        NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_61883_CLASS;
        NextIrpStack->Parameters.Others.Argument1 = pAVReq;

        IoSetCompletionRoutine( 
            pDataEntry->pIrpLower,
            AVCStrmCancelOnePacketCR,
            pDataEntry,
            TRUE,
            TRUE,
            TRUE
            );

        Status = 
            IoCallDriver(
                DeviceObject,
                pDataEntry->pIrpLower
                );

        ASSERT(Status == STATUS_PENDING || Status == STATUS_SUCCESS || Status == STATUS_NO_SUCH_DEVICE); 

        KeAcquireSpinLock(&pDataStruc->DataListLock, &oldIrql);
    } // while
    KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql);

    TRACE(TL_61883_TRACE,("CancelIO complete: pDataStruc:%x; AQD [%d:%d:%d]\n", pDataStruc,
        pDataStruc->cntDataAttached, pDataStruc->cntDataQueued, pDataStruc->cntDataDetached));

    //
    // Guard against data attach completion
    //
    KeReleaseMutex(&pAVCStrmExt->hMutexControl, FALSE);


    EXIT("AVCStrmCancelIO", Status);
    return Status;
}

NTSTATUS
AVCStrmValidateFormat(
    PAVCSTRM_FORMAT_INFO  pAVCFormatInfo
    )
/*++

Routine Description:

    Validate AVC format information.

--*/
{
    NTSTATUS Status;
    PAGED_CODE();

    Status = STATUS_SUCCESS;

    if(pAVCFormatInfo->SizeOfThisBlock != sizeof(AVCSTRM_FORMAT_INFO)) {
        TRACE(TL_STRM_ERROR,("pAVCFormatInfo:%x; SizeOfThisBlock:%d != %d\n", pAVCFormatInfo, pAVCFormatInfo->SizeOfThisBlock, sizeof(AVCSTRM_FORMAT_INFO)));
        ASSERT((pAVCFormatInfo->SizeOfThisBlock == sizeof(AVCSTRM_FORMAT_INFO)) && "Invalid format info parameter!");
        return STATUS_INVALID_PARAMETER;
    }

    TRACE(TL_STRM_TRACE|TL_CIP_TRACE,("ValidateFormat: pAVCFormatInfo:%x; idx:%d; SrcPkt:%d; RcvBuf:%d; XmtBuf:%d; Strip:%d; AvgTm:%d; BlkPeriod:%d\n",
        pAVCFormatInfo,
        pAVCFormatInfo->AVCStrmFormat,
        pAVCFormatInfo->SrcPacketsPerFrame,
        pAVCFormatInfo->NumOfRcvBuffers,
        pAVCFormatInfo->NumOfXmtBuffers,
        pAVCFormatInfo->OptionFlags,
        pAVCFormatInfo->AvgTimePerFrame,
        pAVCFormatInfo->BlockPeriod
        ));

    TRACE(TL_STRM_TRACE|TL_CIP_TRACE,("ValidateFormat: cip1(DBS:%d, FN:%x); cip2(FMT:%x, 50_60:%x, STYPE:%x, SYT:%x)\n",
        pAVCFormatInfo->cipHdr1.DBS,
        pAVCFormatInfo->cipHdr1.FN,
        pAVCFormatInfo->cipHdr2.FMT,
        pAVCFormatInfo->cipHdr2.F5060_OR_TSF,
        pAVCFormatInfo->cipHdr2.STYPE,
        pAVCFormatInfo->cipHdr2.SYT
        ));

    if(pAVCFormatInfo->SrcPacketsPerFrame == 0 ||
       (pAVCFormatInfo->NumOfRcvBuffers == 0 && pAVCFormatInfo->NumOfXmtBuffers == 0) ||
       // pAVCFormatInfo->AvgTimePerFrame == 0 ||
       pAVCFormatInfo->BlockPeriod == 0 ||
       pAVCFormatInfo->cipHdr1.DBS == 0 
       ) {
        TRACE(TL_STRM_ERROR,("ValidateFormat: Invalid parametert!\n"));
        return STATUS_INVALID_PARAMETER;
    }

    return Status;
}

NTSTATUS
AVCStrmAllocateQueues(
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN KSPIN_DATAFLOW  DataFlow,
    IN PAVC_STREAM_DATA_STRUCT pDataStruc,
    PAVCSTRM_FORMAT_INFO  pAVCStrmFormatInfo
    )
/*++

Routine Description:

    Preallocated all nodes for the data queuding.

--*/
{
    ULONG ulNumberOfNodes;
    ULONG ulSizeOfOneNode;  // Might combine multiple structures
    ULONG ulSizeAllocated;
    PBYTE pMemoryBlock;
    PAVCSTRM_DATA_ENTRY pDataEntry;
    ULONG  i;
    PCIP_HDR1 pCipHdr1;

    PAGED_CODE();
    ENTER("AVCStrmAllocateQueues");

    //
    // Pre-allcoate PC resource
    //
    ulNumberOfNodes = DataFlow == KSPIN_DATAFLOW_OUT ? \
        pAVCStrmFormatInfo->NumOfRcvBuffers : pAVCStrmFormatInfo->NumOfXmtBuffers;
    ASSERT(ulNumberOfNodes > 0);
    ulSizeOfOneNode = sizeof(AVCSTRM_DATA_ENTRY) + sizeof(struct _CIP_FRAME);
    ulSizeAllocated = ulNumberOfNodes * ulSizeOfOneNode;

    pMemoryBlock = ExAllocatePool(NonPagedPool, ulSizeAllocated);
    if(!pMemoryBlock) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(pMemoryBlock, ulSizeAllocated);

    // Initialize data IO structure

    InitializeListHead(&pDataStruc->DataAttachedListHead);
    InitializeListHead(&pDataStruc->DataQueuedListHead);
    InitializeListHead(&pDataStruc->DataDetachedListHead);
    KeInitializeSpinLock(&pDataStruc->DataListLock);

    KeInitializeEvent(&pDataStruc->hNoAttachEvent, NotificationEvent, FALSE);

    // Cache it for freeing purpose;
    pDataStruc->pMemoryBlock = pMemoryBlock;

    pDataEntry = (PAVCSTRM_DATA_ENTRY) pMemoryBlock;

    for (i=0; i < ulNumberOfNodes; i++) {
        ((PBYTE) pDataEntry->Frame) = ((PBYTE) pDataEntry) + sizeof(AVCSTRM_DATA_ENTRY);
        pDataEntry->pIrpLower = IoAllocateIrp(pDevExt->physicalDevObj->StackSize, FALSE);
        if(!pDataEntry->pIrpLower) {
            while(!IsListEmpty(&pDataStruc->DataDetachedListHead)) {
                pDataEntry = (PAVCSTRM_DATA_ENTRY) \
                    RemoveHeadList(&pDataStruc->DataDetachedListHead); InterlockedDecrement(&pDataStruc->cntDataDetached);
                if(pDataEntry->pIrpLower) {
                    IoFreeIrp(pDataEntry->pIrpLower);  pDataEntry->pIrpLower = NULL;
                }
            }
            ExFreePool(pMemoryBlock); pMemoryBlock = NULL;
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        pDataEntry->State = DE_IRP_UPPER_COMPLETED;  // Inital state
        InsertTailList(&pDataStruc->DataDetachedListHead, &pDataEntry->ListEntry); InterlockedIncrement(&pDataStruc->cntDataDetached);
        ((PBYTE) pDataEntry) += ulSizeOfOneNode;
    }

    pCipHdr1 = &pAVCStrmFormatInfo->cipHdr1;
    // Calculate source packet size (if strip header, 4 bytes less).
    pDataStruc->SourcePacketSize = \
        pCipHdr1->DBS * 4 * (1 << pCipHdr1->FN) - \
        ((pAVCStrmFormatInfo->OptionFlags & AVCSTRM_FORMAT_OPTION_STRIP_SPH) ? 4 : 0);

    pDataStruc->FrameSize = \
        pDataStruc->SourcePacketSize * pAVCStrmFormatInfo->SrcPacketsPerFrame; 

    TRACE(TL_STRM_TRACE,("DBS:%d; FN:%d; SrcPktSz:%d; SrcPktPerFrame:%d; FrameSize:%d\n", 
        pCipHdr1->DBS, pCipHdr1->FN, 
        pDataStruc->SourcePacketSize, pAVCStrmFormatInfo->SrcPacketsPerFrame,
        pDataStruc->FrameSize
        ));

    TRACE(TL_STRM_TRACE,("pDataStruc:%x; A(%d,%x); Q(%d,%x); D(%d,%x)\n", pDataStruc, 
        pDataStruc->cntDataAttached, &pDataStruc->DataAttachedListHead,
        pDataStruc->cntDataQueued,   &pDataStruc->DataQueuedListHead,
        pDataStruc->cntDataDetached, &pDataStruc->DataDetachedListHead
        ));

    return STATUS_SUCCESS;
}


NTSTATUS
AVCStrmFreeQueues(
    IN PAVC_STREAM_DATA_STRUCT pDataStruc
    )
/*++

Routine Description:

    Free nodes preallocated.

--*/
{
    PAVCSTRM_DATA_ENTRY pDataEntry;

    PAGED_CODE();
    ENTER("AVCStrmFreeQueues");

    while(!IsListEmpty(&pDataStruc->DataAttachedListHead)) {
        pDataEntry = (PAVCSTRM_DATA_ENTRY) \
            RemoveHeadList(&pDataStruc->DataAttachedListHead); InterlockedDecrement(&pDataStruc->cntDataAttached);
        if(pDataEntry->pIrpLower) {
            IoFreeIrp(pDataEntry->pIrpLower);  pDataEntry->pIrpLower = NULL;
        }
    }

    if(pDataStruc->cntDataAttached == 0) {
        ExFreePool(pDataStruc->pMemoryBlock); pDataStruc->pMemoryBlock = NULL;
        return STATUS_SUCCESS;
    } else {
        TRACE(TL_STRM_ERROR,("FreeQueue: pDataStruc:%x, cntDataAttached:%x\n", pDataStruc, pDataStruc->cntDataAttached));
        ASSERT(pDataStruc->cntDataAttached == 0);
        return STATUS_UNSUCCESSFUL;
    }
}

void
AVCStrmAbortStreamingWorkItemRoutine(
#ifdef USE_WDM110  // Win2000 code base
    // Extra parameter if using WDM10
    PDEVICE_OBJECT DeviceObject,
#endif
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    )
/*++

Routine Description:

   This work item routine will stop streaming and cancel all IOs while running at PASSIVE level.

--*/
{
    PAGED_CODE();
    ENTER("AVCStrmAbortStreamingWorkItemRoutine");


    TRACE(TL_STRM_WARNING,("CancelWorkItem: StreamState:%d; lCancel:%d\n", pAVCStrmExt->StreamState, pAVCStrmExt->lAbortToken));
    ASSERT(pAVCStrmExt->lAbortToken == 1);
#ifdef USE_WDM110  // Win2000 code base
    ASSERT(pAVCStrmExt->pIoWorkItem);
#endif

    if(pAVCStrmExt->StreamState == KSSTATE_STOP) {
        ASSERT(pAVCStrmExt->StreamState == KSSTATE_STOP && "CancelWorkItem: Stream is already stopped!\n");
        goto Done;
    }

    // Cancel all pending IOs
    AVCStrmCancelIO(pAVCStrmExt->pDevExt->physicalDevObj, pAVCStrmExt);

Done:

#ifdef USE_WDM110  // Win2000 code base
    // Release work item and release the cancel token
    IoFreeWorkItem(pAVCStrmExt->pIoWorkItem);  pAVCStrmExt->pIoWorkItem = NULL; 
#endif

    // Release token and indicate abort has completed.
    InterlockedExchange(&pAVCStrmExt->lAbortToken, 0);
    KeSetEvent(&pAVCStrmExt->hAbortDoneEvent, 0, FALSE);
}


/*****************************
 * Property utility funcrtions
 *****************************/

NTSTATUS 
AVCStrmGetConnectionProperty(
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    PULONG pulActualBytesTransferred
    )
/*++

Routine Description:

    Handles KS_PROPERTY_CONNECTION* request.  For now, only ALLOCATORFRAMING and
    CONNECTION_STATE are supported.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();
    ENTER("AVCStrmGetConnectionProperty");


    TRACE(TL_STRM_TRACE,("GetConnectionProperty:  entered ...\n"));

    switch (pSPD->Property->Id) {

    case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:
        if (pDevExt != NULL && pDevExt->NumberOfStreams)  {
            PKSALLOCATOR_FRAMING pFraming = (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;
            
            pFraming->RequirementsFlags =
                KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
                KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
            pFraming->PoolType = NonPagedPool;

            pFraming->Frames = \
                pAVCStrmExt->DataFlow == KSPIN_DATAFLOW_OUT ? \
                pAVCStrmExt->pAVCStrmFormatInfo->NumOfRcvBuffers : \
                pAVCStrmExt->pAVCStrmFormatInfo->NumOfXmtBuffers;

            // Note:  we'll allocate the biggest frame.  We need to make sure when we're
            // passing the frame back up we also set the number of bytes in the frame.
            pFraming->FrameSize = pAVCStrmExt->pAVCStrmDataStruc->FrameSize;
            pFraming->FileAlignment = 0; // FILE_LONG_ALIGNMENT;
            pFraming->Reserved = 0;
            *pulActualBytesTransferred = sizeof (KSALLOCATOR_FRAMING);

            TRACE(TL_STRM_TRACE,("*** AllocFraming: cntStrmOpen:%d; Frames %d; size:%d\n", \
                pDevExt->NumberOfStreams, pFraming->Frames, pFraming->FrameSize));
        } else {
            TRACE(TL_STRM_ERROR,("*** AllocFraming: pDevExt:%x; cntStrmOpen:%d\n", pDevExt, pDevExt->NumberOfStreams));
            Status = STATUS_INVALID_PARAMETER;
        }
        break;
        
    default:
        *pulActualBytesTransferred = 0;
        Status = STATUS_NOT_SUPPORTED;
        ASSERT(pSPD->Property->Id == KSPROPERTY_CONNECTION_ALLOCATORFRAMING);
        break;
    }

    TRACE(TL_STRM_TRACE,("GetConnectionProperty:  exit.\n"));
    return Status;
}


NTSTATUS
AVCStrmGetDroppedFramesProperty(  
    IN struct DEVICE_EXTENSION  * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    PSTREAM_PROPERTY_DESCRIPTOR pSPD,
    PULONG pulBytesTransferred
    )
/*++

Routine Description:

    Return the dropped frame information while captureing.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
  
    PAGED_CODE();
    ENTER("AVCStrmGetDroppedFramesProperty");

    switch (pSPD->Property->Id) {

    case KSPROPERTY_DROPPEDFRAMES_CURRENT:
         {

         PKSPROPERTY_DROPPEDFRAMES_CURRENT_S pDroppedFrames = 
                     (PKSPROPERTY_DROPPEDFRAMES_CURRENT_S) pSPD->PropertyInfo;
         
         pDroppedFrames->AverageFrameSize = pAVCStrmExt->pAVCStrmDataStruc->FrameSize;
         pDroppedFrames->PictureNumber    = pAVCStrmExt->pAVCStrmDataStruc->PictureNumber;         
         pDroppedFrames->DropCount        = pAVCStrmExt->pAVCStrmDataStruc->FramesDropped;    // For transmit, this value includes both dropped and repeated.
         TRACE(TL_STRM_TRACE,("*DroppedFP: Pic#(%d), Drp(%d)\n", (LONG) pDroppedFrames->PictureNumber, (LONG) pDroppedFrames->DropCount));
               
         *pulBytesTransferred = sizeof (KSPROPERTY_DROPPEDFRAMES_CURRENT_S);
         Status = STATUS_SUCCESS;
         }
         break;

    default:
        *pulBytesTransferred = 0;
        Status = STATUS_NOT_SUPPORTED;
        ASSERT(pSPD->Property->Id == KSPROPERTY_DROPPEDFRAMES_CURRENT);
        break;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\avcstrm\sources.inc ===
#############################################################################
#
#       Confidential Microsoft
#       Copyright (C) Microsoft Corporation 2000-2001
#       All Rights Reserved.
#                                                                          
#       Sources for AVC streaming filter driver
#
##########################################################################
TARGETNAME=avcstrm
TARGETPATH=obj
TARGETTYPE=DRIVER
DRIVERTYPE=WDM

MSC_WARNING_LEVEL=-W3 -WX
USE_MAPSYM       = 1

INCLUDES= \
    $(MULTIMEDIA_INC_PATH)

TARGETLIBS= \
    $(DDK_LIB_PATH)\ksguid.lib

SOURCES= \
    filter.c \
    stream.c \
    avcutil.c \
    pnp.c \
    power.c \
    util.c \
    filter.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\avcstrm\power.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    power.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"


#ifdef ALLOC_PRAGMA
    #ifdef HANDLE_DEVICE_USAGE
        #pragma alloc_text(PAGEPOWR, VA_Power)
    #endif // HANDLE_DEVICE_USAGE
#endif


NTSTATUS VA_Power(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

    Dispatch routine for Power IRPs (MajorFunction == IRP_MJ_Power)


    Note:
        If HANDLE_DEVICE_USAGE is defined     
     
           This function may or may not be locked down, depending on the lower
           device object and if the device is in the paging path, so we can't
           use the PAGED_CODE() macro.  Furthermore, we can't use PagedPool. 
           
        Otherwise

            This function is left locked down.        

Arguments:

    devExt - device extension for targetted device object
    irp - Io Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    irpSp = IoGetCurrentIrpStackLocation(irp);

    TRACE(TL_PNP_WARNING,("VA_Power, minorFunc = %d ", (ULONG)irpSp->MinorFunction)); 


    switch (irpSp->MinorFunction){

        case IRP_MN_SET_POWER:

            switch (irpSp->Parameters.Power.Type) {

                case SystemPowerState:
                    /*
                     *  For system power states, just pass the IRP down.
                     */
                    break;

                case DevicePowerState:

                    switch (irpSp->Parameters.Power.State.DeviceState) {

                        case PowerDeviceD0:
                            /*
                             *  Resume from APM Suspend
                             *
                             *  Do nothing here; 
                             *  Send down the read IRPs in the completion
                             *  routine for this (the power) IRP.
                             */
                            break;

                        case PowerDeviceD1:
                        case PowerDeviceD2:
                        case PowerDeviceD3:
                            /*
                             *  Suspend
                             */
                            if (devExt->state == STATE_STARTED){
                                devExt->state = STATE_SUSPENDED;
                            }
                            break;

                    }
                    break;

            }
            break;

    }


    /*
     *  Send the IRP down the driver stack,
     *  using PoCallDriver (not IoCallDriver, as for non-power irps).
     */
    IncrementPendingActionCount(devExt);
    IoCopyCurrentIrpStackLocationToNext(irp);
    IoSetCompletionRoutine( irp, 
                            VA_PowerComplete, 
                            (PVOID)devExt,  // context
                            TRUE, 
                            TRUE, 
                            TRUE);
    status = PoCallDriver(devExt->topDevObj, irp);



    return status;
}


NTSTATUS VA_PowerComplete(
                            IN PDEVICE_OBJECT devObj, 
                            IN PIRP irp, 
                            IN PVOID context)
/*++

Routine Description:

      Completion routine for Power IRPs (MajorFunction == IRP_MJ_Power)

Arguments:

    devObj - targetted device object
    irp - Io Request Packet
    context - context value passed to IoSetCompletionRoutine by VA_Power

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    struct DEVICE_EXTENSION *devExt = (struct DEVICE_EXTENSION *)context;

    ASSERT(devExt);
    ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE); 

    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also.
     */
    if (irp->PendingReturned){
        IoMarkIrpPending(irp);
    }

    irpSp = IoGetCurrentIrpStackLocation(irp);
    ASSERT(irpSp->MajorFunction == IRP_MJ_POWER);

    if (NT_SUCCESS(irp->IoStatus.Status)){
        switch (irpSp->MinorFunction){

            case IRP_MN_SET_POWER:

                switch (irpSp->Parameters.Power.Type){

                    case DevicePowerState:
                        switch (irpSp->Parameters.Power.State.DeviceState){
                            case PowerDeviceD0:
                                if (devExt->state == STATE_SUSPENDED){
                                    devExt->state = STATE_STARTED;
                                }
                                break;
                        }
                        break;

                }
                break;
        }

    }
    
    
    /*
     *  Whether we are completing or relaying this power IRP,
     *  we must call PoStartNextPowerIrp.
     */
    PoStartNextPowerIrp(irp);

    /*
     *  Decrement the pendingActionCount, which we incremented in VA_Power.
     */
    DecrementPendingActionCount(devExt);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\avcstrm\pnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pnp.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, VA_PnP)
        #pragma alloc_text(PAGE, GetDeviceCapabilities)
        #ifdef HANDLE_DEVICE_USAGE
            #pragma alloc_text(PAGE, VA_DeviceUsageNotification)
        #endif // HANDLE_DEVICE_USAGE
#endif

            
NTSTATUS VA_PnP(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

    Dispatch routine for PnP IRPs (MajorFunction == IRP_MJ_PNP)

Arguments:

    devExt - device extension for the targetted device object
    irp - IO Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN completeIrpHere = FALSE;
    BOOLEAN justReturnStatus = FALSE;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    TRACE(TL_PNP_TRACE,("VA_PnP, minorFunc = %d \n", (ULONG)irpSp->MinorFunction)); 

    switch (irpSp->MinorFunction){

    case IRP_MN_START_DEVICE:
        TRACE(TL_PNP_WARNING,("START_DEVICE\n")); 

        devExt->state = STATE_STARTING;

        /*
         *  First, send the START_DEVICE irp down the stack
         *  synchronously to start the lower stack.
         *  We cannot do anything with our device object
         *  before propagating the START_DEVICE this way.
         */
        IoCopyCurrentIrpStackLocationToNext(irp);
        status = CallNextDriverSync(devExt, irp);

        if (NT_SUCCESS(status)){
            /*
             *  Now that the lower stack is started,
             *  do any initialization required by this device object.
             */
            status = GetDeviceCapabilities(devExt);
            if (NT_SUCCESS(status)){
                devExt->state = STATE_STARTED;
            }
            else {
                devExt->state = STATE_START_FAILED;
            }
        }
        else {
            devExt->state = STATE_START_FAILED;
        }
        completeIrpHere = TRUE;
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
        TRACE(TL_PNP_WARNING,("QUERY_STOP_DEVICE (%d)or QUERY_REMOVE_DEVICE(%d)\n", IRP_MN_QUERY_STOP_DEVICE, IRP_MN_QUERY_REMOVE_DEVICE)); 
#ifdef HANDLE_DEVICE_USAGE
        //
        // Need to fail these IRPs if a paging, hibernation, or crashdump
        // file is currently open on this device
        //
        if(    devExt->pagingFileCount      != 0
            || devExt->hibernationFileCount != 0
            || devExt->crashdumpFileCount   != 0 )
        {
            // Fail the IRP
            TRACE(TL_PNP_WARNING,("Failing QUERY_(STOP,REMOVE)_DEVICE request b/c \n"
                     "paging, hiber, or crashdump file is present on device." ));
            status = STATUS_UNSUCCESSFUL;
            completeIrpHere = TRUE;
        }
        else
        {
            // We'll just pass this IRP down the driver stack.  But
            // first, must change the IRP's status to STATUS_SUCCESS
            // (default is STATUS_NOT_SUPPORTED)
            irp->IoStatus.Status = STATUS_SUCCESS;
        }
#else
        /*
         *  We will pass this IRP down the driver stack.
         *  However, we need to change the default status
         *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
         */
        irp->IoStatus.Status = STATUS_SUCCESS;
#endif

        break;

    case IRP_MN_STOP_DEVICE:
        TRACE(TL_PNP_WARNING,("STOP_DEVICE\n")); 
        if (devExt->state == STATE_SUSPENDED){
            status = STATUS_DEVICE_POWER_FAILURE;
            completeIrpHere = TRUE;
        }
        else {
            /*
             *  Only set state to STOPPED if the device was
             *  previously started successfully.
             */
            if (devExt->state == STATE_STARTED){
                devExt->state = STATE_STOPPED;
            }
        }
        break;
  

    case IRP_MN_SURPRISE_REMOVAL:  // Win2000 code base only
        TRACE(TL_PNP_WARNING,("SURPRISE_REMOVAL\n")); 

        /*
         *  We will pass this IRP down the driver stack.
         *  However, we need to change the default status
         *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
         */
        irp->IoStatus.Status = STATUS_SUCCESS;

        /*
         *  For now just set the STATE_REMOVING state so that
         *  we don't do any more IO.  We are guaranteed to get
         *  IRP_MN_REMOVE_DEVICE soon; we'll do the rest of
         *  the remove processing there.
         */

        devExt->state = STATE_REMOVING;

        /*
         * Clean up and make sure to cancel pending request
         */

        AVCStreamSurpriseRemoval(devExt);


        break;

    case IRP_MN_REMOVE_DEVICE:
        /*
         *  Check the current state to guard against multiple
         *  REMOVE_DEVICE IRPs.
         */
        TRACE(TL_PNP_WARNING,("REMOVE_DEVICE\n")); 
        if (devExt->state != STATE_REMOVED){

            devExt->state = STATE_REMOVED;

            /*
             * Clean up and make sure to cancel pending request
             * Note: there is no IRP_MN_SURPRISE_REMOVAL for Win9X
             */

            AVCStreamSurpriseRemoval(devExt);


            /*
             *  Send the REMOVE IRP down the stack asynchronously.
             *  Do not synchronize sending down the REMOVE_DEVICE
             *  IRP, because the REMOVE_DEVICE IRP must be sent
             *  down and completed all the way back up to the sender
             *  before we continue.
             */
            IoCopyCurrentIrpStackLocationToNext(irp);
            status = IoCallDriver(devExt->topDevObj, irp);
            justReturnStatus = TRUE;

            TRACE(TL_PNP_WARNING,("REMOVE_DEVICE - waiting for %d irps to complete...\n",
                    devExt->pendingActionCount));  

            /*
             *  We must for all outstanding IO to complete before
             *  completing the REMOVE_DEVICE IRP.
             *
             *  First do an extra decrement on the pendingActionCount.
             *  This will cause pendingActionCount to eventually
             *  go to -1 once all asynchronous actions on this
             *  device object are complete.
             *  Then wait on the event that gets set when the
             *  pendingActionCount actually reaches -1.
             */
            DecrementPendingActionCount(devExt);
            KeWaitForSingleObject(  &devExt->removeEvent,
                                    Executive,      // wait reason
                                    KernelMode,
                                    FALSE,          // not alertable
                                    NULL );         // no timeout

            TRACE(TL_PNP_WARNING,("REMOVE_DEVICE - ... DONE waiting. \n")); 

#ifdef HANDLE_DEVICE_USAGE
            /*
             *  If we locked-down certain paged code sections earlier
             *  because of this device, then need to unlock them now
             *  (before calling IoDeleteDevice)
             */
            if( NULL != devExt->pagingPathUnlockHandle )
            {
                TRACE(TL_PNP_WARNING,("UNLOCKing some driver code (non-pageable) (b/c paging path)\n" ));
                MmUnlockPagableImageSection( devExt->pagingPathUnlockHandle );
                devExt->pagingPathUnlockHandle = NULL;
            }

            if( NULL != devExt->initUnlockHandle )
            {
                TRACE(TL_PNP_WARNING,("UNLOCKing some driver code (non-pageable) (b/c init conditions)\n" ));
                MmUnlockPagableImageSection( devExt->initUnlockHandle );
                devExt->initUnlockHandle = NULL;
            }
#endif // HANDLE_DEVICE_USAGE

            /*
             *  Detach our device object from the lower 
             *  device object stack.
             */
            IoDetachDevice(devExt->topDevObj);

            /*
             *  Delete our device object.
             *  This will also delete the associated device extension.
             */
            IoDeleteDevice(devExt->filterDevObj);
        }
        break;

#ifdef HANDLE_DEVICE_USAGE
    case IRP_MN_DEVICE_USAGE_NOTIFICATION:


        //
        // Make sure the Type of this UsageNotification is one that we handle
        //
        if(    irpSp->Parameters.UsageNotification.Type != DeviceUsageTypePaging
            && irpSp->Parameters.UsageNotification.Type != DeviceUsageTypeHibernation
            && irpSp->Parameters.UsageNotification.Type != DeviceUsageTypeDumpFile )
        {
            break; // out of the big switch statement (and just forward this IRP)
        }

        status = VA_DeviceUsageNotification(devExt, irp);
        justReturnStatus = TRUE;
        break;
#endif // HANDLE_DEVICE_USAGE

#ifdef HANDLE_DEVICE_USAGE
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
        //
        // If a paging, hibernation, or crashdump file is currently open
        // on this device, must set NOT_DISABLEABLE flag in DeviceState
        //
        if(    devExt->pagingFileCount      != 0
            || devExt->hibernationFileCount != 0
            || devExt->crashdumpFileCount   != 0  )
        {
            // Mark the device as not disableable
            PPNP_DEVICE_STATE pDeviceState;
            pDeviceState = (PPNP_DEVICE_STATE) &irp->IoStatus.Information;
            *pDeviceState |= PNP_DEVICE_NOT_DISABLEABLE;
        }

        //
        // We _did_ handle this IRP (as best we could), so set IRP's
        // status to STATUS_SUCCESS (default is STATUS_NOT_SUPPORTED)
        // before passing it down the driver stack
        //
        irp->IoStatus.Status = STATUS_SUCCESS;

        break;
#endif // HANDLE_DEVICE_USAGE

    case IRP_MN_QUERY_DEVICE_RELATIONS:
        TRACE(TL_PNP_WARNING,("QUERY_DEVICE_RELATIONS\n"));
        break;
    default:
        TRACE(TL_PNP_WARNING,("Unprocessed PnP minorFunc (%d)\n", irpSp->MinorFunction));
        break;


    }

    if (justReturnStatus){
        /*
         *  We've already sent this IRP down the stack.
         */
        TRACE(TL_PNP_WARNING,("VA_PnP: St:%x; minor:%d; Already sent down the irp.\n", status, (ULONG)irpSp->MinorFunction));
    }
    else if (completeIrpHere){
        TRACE(TL_PNP_WARNING,("VA_PnP: St:%x; minor:%d; Completed Status:%x\n", status, (ULONG)irpSp->MinorFunction, status));
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
    else {
        TRACE(TL_PNP_WARNING,("VA_PnP: ST:%x; minor:%d; Pass down irp:%x; devObj:%x\n", status, (ULONG)irpSp->MinorFunction, irp, devExt->topDevObj));
        IoCopyCurrentIrpStackLocationToNext(irp);
        status = IoCallDriver(devExt->topDevObj, irp);
    }

    EXIT("VA_PnP",status);

    return status;
}

#ifdef HANDLE_DEVICE_USAGE
NTSTATUS
VA_DeviceUsageNotification(struct DEVICE_EXTENSION *devExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    BOOLEAN fSetPagable = FALSE;  // whether we set the PAGABLE bit
                                  /// before we passed-on this IRP

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    TRACE(TL_PNP_WARNING,("DEVICE_USAGE_NOTIFICATION (Type==%d , InPath==%d)\n"
             , irpSp->Parameters.UsageNotification.Type
             , irpSp->Parameters.UsageNotification.InPath
          ));
    TRACE(TL_PNP_WARNING,("    [devExt=0x%08X fltrDevObj=0x%08X]\n", devExt, devExt->filterDevObj ));

    //
    // Wait on the paging path event (to prevent several instances of
    // this IRP from being processed at once)
    //
    status = KeWaitForSingleObject( &devExt->deviceUsageNotificationEvent
                                    , Executive    // wait reason
                                    , KernelMode
                                    , FALSE        // not alertable
                                    , NULL         // no timeout
                                  );


    /*
     * IMPORTANT NOTE: When to modify our DO_POWER_PAGABLE bit depends
     * on whether it needs to be set or cleared.  If the IRP indicates
     * our PAGABLE bit should be set, then we must set it _before_
     * forwarding the IRP down the driver stack (and possibly clear it
     * afterward, if lower drivers fail the IRP).  But if the IRP
     * indicates that our PAGABLE bit should be cleared, then we must
     * first forward the IRP to lower drivers, and then clear our bit
     * only if the lower drivers return STATUS_SUCCESS.
     */

    //
    // If removing last paging file from this device...
    //
    if(    irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging
        && !irpSp->Parameters.UsageNotification.InPath
        && devExt->pagingFileCount == 1       )
    {
        //
        // Set DO_POWER_PAGABLE bit (if it was set at startup).
        // If lower drivers fail this IRP, we'll clear it later.
        //
        TRACE(TL_PNP_WARNING,("Removing last paging file...\n" ));

        if( devExt->initialFlags & DO_POWER_PAGABLE )
        {
            TRACE(TL_PNP_WARNING,( "...so RE-setting PAGABLE bit\n" ));
            devExt->filterDevObj->Flags |= DO_POWER_PAGABLE;
            fSetPagable = TRUE;
        }
        else
        {
            TRACE(TL_PNP_WARNING,( "...but PAGABLE bit wasn't set initially, so not setting it now.\n" ));
        }

    }


    //
    // Forward the irp synchronously
    //
    IoCopyCurrentIrpStackLocationToNext( irp );
    status = CallNextDriverSync( devExt, irp );


    //
    // Now deal with the failure and success cases.
    //
    if( ! NT_SUCCESS(status) )
    {
        //
        // Lower drivers failed the IRP, so _undo_ any changes we
        // made before passing-on the IRP to those drivers.
        //
        if( fSetPagable )
        {
            TRACE(TL_PNP_WARNING,("IRP was failed, so UN-setting PAGABLE bit\n" ));
            devExt->filterDevObj->Flags &= ~DO_POWER_PAGABLE;
        }
    }
    else
    {
        //
        // Lower drivers returned SUCCESS, so we can do everything
        // that must be done in response to this IRP...
        //

        switch( irpSp->Parameters.UsageNotification.Type )
        {
        case DeviceUsageTypeHibernation:

            // Adjust counter
            IoAdjustPagingPathCount( &devExt->hibernationFileCount,
                                     irpSp->Parameters.UsageNotification.InPath );
            TRACE(TL_PNP_WARNING,("Num. Hibernation files is now %d\n", devExt->hibernationFileCount ));
            ASSERT( devExt->hibernationFileCount >= 0 );
            break;

        case DeviceUsageTypeDumpFile:
            
            // Adjust counter
            IoAdjustPagingPathCount( &devExt->crashdumpFileCount,
                                     irpSp->Parameters.UsageNotification.InPath );
            TRACE(TL_PNP_WARNING,("Num. Crashdump files is now %d\n", devExt->crashdumpFileCount ));
            ASSERT( devExt->crashdumpFileCount >= 0 );
            break;

        case DeviceUsageTypePaging:
            
            // Adjust counter
            IoAdjustPagingPathCount( &devExt->pagingFileCount,
                                     irpSp->Parameters.UsageNotification.InPath );
            TRACE(TL_PNP_WARNING,("Num. Paging files is now %d\n", devExt->pagingFileCount ));
            ASSERT( devExt->pagingFileCount >= 0 );

            //
            // If we've just switched between being pageable<->nonpageable...
            //
            if(    irpSp->Parameters.UsageNotification.InPath
                && devExt->pagingFileCount == 1  )
            {
                //
                // Just added a paging file, so clear the PAGABLE
                // flag, and lock-down the code for all routines
                // that could be called at IRQL >= DISPATCH_LEVEL
                // (so that they're _non-pageable_).
                //
                TRACE(TL_PNP_WARNING,("Just added first paging file...\n" ));
                TRACE(TL_PNP_WARNING,("...so clearing PAGABLE bit\n" ));
                devExt->filterDevObj->Flags &= ~DO_POWER_PAGABLE;

                TRACE(TL_PNP_WARNING,("LOCKing some driver code (non-pageable) (b/c paging path)\n" ));
                devExt->pagingPathUnlockHandle = MmLockPagableCodeSection( VA_Power );  // some func that's inside the code section that we want to lock
                ASSERT( NULL != devExt->pagingPathUnlockHandle );
            }
            else if (    !irpSp->Parameters.UsageNotification.InPath
                      && devExt->pagingFileCount == 0  )
            {
                //
                // Just removed the last paging file, but we
                // already set the PAGABLE flag (if necessary)
                // before forwarding IRP, so just remove the
                // _paging-path_ lock from this driver. (NOTE:
                // initial-condition lock might still be in place,
                // but that's what we want.)
                //
                TRACE(TL_PNP_WARNING,("UNLOCKing some driver code (pageable) (b/c paging path)\n" ));
                ASSERT( NULL != devExt->pagingPathUnlockHandle );
                MmUnlockPagableImageSection( devExt->pagingPathUnlockHandle );
                devExt->pagingPathUnlockHandle = NULL;
            }
            break;

        default:
            ASSERT( FALSE );  // should never get here (b/c checked for invalid Type earlier)

        } //END: switch on Type of special-file


        //
        // Invalidate state, so that certain flags will get updated
        //
        IoInvalidateDeviceState( devExt->physicalDevObj );

    }//END: handling of irp success/failure cases


    //
    // Set event so that the next DEVICE_USAGE_NOTIFICATION IRP that
    // comes along can be processed.
    //
    KeSetEvent( &devExt->deviceUsageNotificationEvent
                , IO_NO_INCREMENT
                , FALSE
              );

    //
    // Complete the irp
    //
    IoCompleteRequest( irp, IO_NO_INCREMENT );
    return status;
}
#endif // HANDLE_DEVICE_USAGE



NTSTATUS GetDeviceCapabilities(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

    Function retrieves the DEVICE_CAPABILITIES descriptor from the device

Arguments:

    devExt - device extension for targetted device object

Return Value:

    NT status code

--*/
{
    NTSTATUS status;
    PIRP irp;

    PAGED_CODE();

    irp = IoAllocateIrp(devExt->topDevObj->StackSize, FALSE);
    if (irp){
        PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(irp);

        // must initialize DeviceCapabilities before sending...
        RtlZeroMemory(  &devExt->deviceCapabilities, 
                        sizeof(DEVICE_CAPABILITIES));
        devExt->deviceCapabilities.Size = sizeof(DEVICE_CAPABILITIES);
        devExt->deviceCapabilities.Version = 1;
        devExt->deviceCapabilities.Address = -1;
        devExt->deviceCapabilities.UINumber= -1;


        // setup irp stack location...
        nextSp->MajorFunction = IRP_MJ_PNP;
        nextSp->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
        nextSp->Parameters.DeviceCapabilities.Capabilities = 
                        &devExt->deviceCapabilities;

        /*
         *  For any IRP you create, you must set the default status
         *  to STATUS_NOT_SUPPORTED before sending it.
         */
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        status = CallNextDriverSync(devExt, irp);

        IoFreeIrp(irp);
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\audio.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Audio.h 1.3 1998/04/29 22:43:26 tomz Exp $

#ifndef __AUDIO_H
#define __AUDIO_H

//---------------------------------------- 
// Audio Source Value definitions
//---------------------------------------- 
#define AUDIO_SOURCE_CDROM            0x00
#define AUDIO_SOURCE_EXTAUDIO         0x01
#define AUDIO_SOURCE_TVTUNER          0x02
#define AUDIO_SOURCE_MUTE             0x03

#endif // __AUDIO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\avcstrm\stream.c ===
/*++

Copyright (C) 1999  Microsoft Corporation

Module Name: 

    stream.c

Abstract

    MS AVC streaming filter driver

Author:

    Yee Wu    01/27/2000

Revision    History:
Date        Who         What
----------- --------- ------------------------------------------------------------
01/27/2000  YJW         created
--*/

 
#include "filter.h"
#include "ksmedia.h"


NTSTATUS
AVCStreamOpen(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN OUT AVCSTRM_OPEN_STRUCT * pOpenStruct
    )
/*++

Routine Description:

    Open a stream for a client based on the information in the OpenStruct.

Arguments:

    Irp -
        The irp client sent us.

    pDevExt -
        This driver's extension.

    pOpenStruct-
        Strcture contains information on how to open this stream.
        The stream context allocated will be returned and this will be the context 
        to be passed for subsequent call.

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER
        STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS Status;
    ULONG ulSizeAllocated;
    PAVC_STREAM_EXTENSION pAVCStrmExt;


    PAGED_CODE();
    ENTER("AVCStreamOpen");


    Status = STATUS_SUCCESS;

    // Validate open structures.
    if(pOpenStruct == NULL) 
        return STATUS_INVALID_PARAMETER;
    if(pOpenStruct->AVCFormatInfo == NULL)
        return STATUS_INVALID_PARAMETER;

    // Validate open format.
    if(STATUS_SUCCESS != AVCStrmValidateFormat(pOpenStruct->AVCFormatInfo)) {
        TRACE(TL_STRM_ERROR,("StreamOpen: pAVCFormatInfo:%x; contain invalid data\n", pOpenStruct->AVCFormatInfo ));
        ASSERT(FALSE && "AVCFormatInfo contain invalid parameter!");
        return STATUS_INVALID_PARAMETER;
    }

    // If supported, open a stream based on this stream information.
    // Allocate a contiguous data strcutre for a 
    ulSizeAllocated = 
        sizeof(AVC_STREAM_EXTENSION) +
        sizeof(AVCSTRM_FORMAT_INFO) +
        sizeof(AVC_STREAM_DATA_STRUCT);

    pAVCStrmExt = (PAVC_STREAM_EXTENSION) ExAllocatePool(NonPagedPool, ulSizeAllocated);
    if(NULL == pAVCStrmExt) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize stream extension:
    //    Copy the stream format information which is continuation of the stream extension.
    //
    RtlZeroMemory(pAVCStrmExt, ulSizeAllocated);
    pAVCStrmExt->SizeOfThisPacket = sizeof(AVC_STREAM_EXTENSION);

    (PBYTE) pAVCStrmExt->pAVCStrmFormatInfo = ((PBYTE) pAVCStrmExt) + sizeof(AVC_STREAM_EXTENSION);
    RtlCopyMemory(pAVCStrmExt->pAVCStrmFormatInfo, pOpenStruct->AVCFormatInfo, sizeof(AVCSTRM_FORMAT_INFO));

    (PBYTE) pAVCStrmExt->pAVCStrmDataStruc  = ((PBYTE) pAVCStrmExt->pAVCStrmFormatInfo) + sizeof(AVCSTRM_FORMAT_INFO);
    pAVCStrmExt->pAVCStrmDataStruc->SizeOfThisPacket = sizeof(AVC_STREAM_DATA_STRUCT);

    TRACE(TL_STRM_TRACE,("pAVCStrmExt:%x; pAVCStrmFormatInfo:%x; pAVCStrmDataStruc:%x\n", pAVCStrmExt, pAVCStrmExt->pAVCStrmFormatInfo, pAVCStrmExt->pAVCStrmDataStruc));

    pAVCStrmExt->hPlugLocal     = pOpenStruct->hPlugLocal;
    pAVCStrmExt->DataFlow       = pOpenStruct->DataFlow;
    pAVCStrmExt->StreamState    = KSSTATE_STOP;
    pAVCStrmExt->IsochIsActive  = FALSE;

    // Mutext for serialize setting stream state and accepting data packet 
    KeInitializeMutex(&pAVCStrmExt->hMutexControl, 0); 

    // Allocate resource for the common Request structure
    pAVCStrmExt->pIrpAVReq = IoAllocateIrp(pDevExt->physicalDevObj->StackSize, FALSE);
    if(!pAVCStrmExt->pIrpAVReq) {
        ExFreePool(pAVCStrmExt);  pAVCStrmExt = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    KeInitializeMutex(&pAVCStrmExt->hMutexAVReq, 0);
    KeInitializeEvent(&pAVCStrmExt->hAbortDoneEvent, NotificationEvent, TRUE);   // Signal!
    pAVCStrmExt->pDevExt = pDevExt;

    //
    // Get target device's plug handle
    //
    if(!NT_SUCCESS(Status = 
        AVCStrmGetPlugHandle(
            pDevExt->physicalDevObj,
            pAVCStrmExt
            ))) {
        IoFreeIrp(pAVCStrmExt->pIrpAVReq);  pAVCStrmExt->pIrpAVReq = NULL;
        ExFreePool(pAVCStrmExt);  pAVCStrmExt = NULL;
        return Status;
    }

    //
    // Set stream state related flags
    //
    pAVCStrmExt->b1stNewFrameFromPauseState = TRUE;


    // Allocate PC resources
    //     Queues
    //
    if(!NT_SUCCESS(Status = 
        AVCStrmAllocateQueues(
            pDevExt,
            pAVCStrmExt,
            pAVCStrmExt->DataFlow,
            pAVCStrmExt->pAVCStrmDataStruc,
            pAVCStrmExt->pAVCStrmFormatInfo
            ))) {
        IoFreeIrp(pAVCStrmExt->pIrpAVReq);  pAVCStrmExt->pIrpAVReq = NULL;
        ExFreePool(pAVCStrmExt);  pAVCStrmExt = NULL;
        return Status;
    }

    // Return stream extension
    pOpenStruct->AVCStreamContext = pAVCStrmExt;
    TRACE(TL_STRM_TRACE,("Open: AVCStreamContext:%x\n", pOpenStruct->AVCStreamContext));

    // Cache it. This stream extension will be the context that will be
    // check when we are asked to provide service.
    pDevExt->NumberOfStreams++;  pDevExt->pAVCStrmExt[pDevExt->NextStreamIndex] = pAVCStrmExt;
    pDevExt->NextStreamIndex = ((pDevExt->NextStreamIndex + 1) % MAX_STREAMS_PER_DEVICE);

    return Status;
}

NTSTATUS
AVCStreamClose(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    )
/*++

Routine Description:

    Close a stream.

Arguments:

    Irp -
        The irp client sent us.

    pDevExt -
        This driver's extension.

    pAVCStrmExt -
        The stream context created when a stream is open.

    pOpenStruct-
        Strcture contains information on how to open this stream.
        The stream context allocated will be returned and this will be the context 
        to be passed for subsequent call.

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS  Status;
    BOOL  Found;
    ULONG  i;

    PAGED_CODE();
    ENTER("AVCStreamClose");

    Status = STATUS_SUCCESS;

    Found = FALSE;
    for (i=0; i < MAX_STREAMS_PER_DEVICE; i++) {
        // Free stream extension
        if(pDevExt->pAVCStrmExt[i] == pAVCStrmExt) {
            Found = TRUE;
            break;
        }
    }

    if(!Found) {
        TRACE(TL_STRM_ERROR,("AVCStreamClose: pAVCStrmExt %x not found; pDevExt:%x\n", pAVCStrmExt, pDevExt));
        ASSERT(Found && "pAVCStrmExt not found!\n");
        return STATUS_INVALID_PARAMETER;
    }


    // Stop stream if not already
    if(pAVCStrmExt->StreamState != KSSTATE_STOP) {
        // Stop isoch if necessary and then Cancel all pending IOs
        AVCStrmCancelIO(pDevExt->physicalDevObj, pAVCStrmExt);
    }

    // Free queue allocated if they are not being used.
    if(NT_SUCCESS(Status = AVCStrmFreeQueues(pAVCStrmExt->pAVCStrmDataStruc))) {
        ExFreePool(pAVCStrmExt); pDevExt->pAVCStrmExt[i] = NULL;  pDevExt->NumberOfStreams--;
    } else {
        TRACE(TL_STRM_ERROR,("*** StreamClose: AVCStrmExt is not freed!\n"));
    }

    return Status;
}

NTSTATUS
AVCStreamControlGetState(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    OUT KSSTATE * pKSState
    )
/*++

Routine Description:

    Get current stream state

Arguments:

    Irp -
        The irp client sent us.

    pDevExt -
        This driver's extension.

    pAVCStrmExt -
        The stream context created when a stream is open.

    pKSState -
        Get current stream state and return.

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS Status;
    PAGED_CODE();
    ENTER("AVCStreamControlGetState");

    Status = STATUS_SUCCESS;

    *pKSState = pAVCStrmExt->StreamState;
    return Status;
}

NTSTATUS
AVCStreamControlSetState(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN KSSTATE KSState
    )
/*++

Routine Description:

    Set to a new stream state

Arguments:

    Irp -
        The irp client sent us.

    pDevExt -
        This driver's extension.

    pAVCStrmExt -
        The stream context created when a stream is open.

    pKSState -
        Get current stream state.

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS Status;
    PAGED_CODE();
    ENTER("AVCStreamControlSetState");

    TRACE(TL_STRM_WARNING,("Set stream state %d -> %d\n", pAVCStrmExt->StreamState, KSState));
    if(pAVCStrmExt->StreamState == KSState) 
        return STATUS_SUCCESS;

    Status = STATUS_SUCCESS;

    switch (KSState) {
    case KSSTATE_STOP:

        if(pAVCStrmExt->StreamState != KSSTATE_STOP) { 
            KeWaitForMutexObject(&pAVCStrmExt->hMutexControl, Executive, KernelMode, FALSE, NULL);
            // Once this is set, data stream will reject SRB_WRITE/READ_DATA
            pAVCStrmExt->StreamState = KSSTATE_STOP;
            KeReleaseMutex(&pAVCStrmExt->hMutexControl, FALSE);

            // Cancel all pending IOs
            AVCStrmCancelIO(pDevExt->physicalDevObj, pAVCStrmExt);

            // Breeak Isoch connection
            AVCStrmBreakConnection(pDevExt->physicalDevObj, pAVCStrmExt);
        }
        break;

    case KSSTATE_ACQUIRE:

        // Get Isoch resource
        if(pAVCStrmExt->StreamState == KSSTATE_STOP) {
            //
            // Reset values.for the case that the graph restart 
            //
            pAVCStrmExt->pAVCStrmDataStruc->CurrentStreamTime  = 0;
            pAVCStrmExt->pAVCStrmDataStruc->FramesProcessed    = 0;
            pAVCStrmExt->pAVCStrmDataStruc->FramesDropped      = 0;
            pAVCStrmExt->pAVCStrmDataStruc->cntFrameCancelled  = 0;
#if DBG
            pAVCStrmExt->pAVCStrmDataStruc->FramesAttached     = 0;
#endif

            pAVCStrmExt->pAVCStrmDataStruc->cntDataReceived    = 0;
            // All the list should be initialized (count:0, and List is empty)
            TRACE(TL_STRM_TRACE,("Set to ACQUIRE state: flow %d; AQD [%d:%d:%d]\n", pAVCStrmExt->DataFlow, 
                pAVCStrmExt->pAVCStrmDataStruc->cntDataAttached, pAVCStrmExt->pAVCStrmDataStruc->cntDataQueued, pAVCStrmExt->pAVCStrmDataStruc->cntDataDetached));
            ASSERT(pAVCStrmExt->pAVCStrmDataStruc->cntDataAttached == 0 && IsListEmpty(&pAVCStrmExt->pAVCStrmDataStruc->DataAttachedListHead));
            ASSERT(pAVCStrmExt->pAVCStrmDataStruc->cntDataQueued   == 0 && IsListEmpty(&pAVCStrmExt->pAVCStrmDataStruc->DataQueuedListHead));
            ASSERT(pAVCStrmExt->pAVCStrmDataStruc->cntDataDetached  > 0 && !IsListEmpty(&pAVCStrmExt->pAVCStrmDataStruc->DataDetachedListHead));
            // Cannot stream using previous stream data !!!
            if(pAVCStrmExt->pAVCStrmDataStruc->cntDataAttached != 0 ||  // Stale data ??
               pAVCStrmExt->pAVCStrmDataStruc->cntDataQueued   != 0 ||  // NO data unil PAUSE ??
               pAVCStrmExt->pAVCStrmDataStruc->cntDataDetached == 0) {  // NO avaialble queue ?
                TRACE(TL_STRM_ERROR,("Set to ACQUIRE State: queues not empty (stale data?); Failed!\n"));
                return STATUS_UNSUCCESSFUL;
            }
            
            //
            // Make connection
            //
            Status = 
                AVCStrmMakeConnection(
                    pDevExt->physicalDevObj,
                    pAVCStrmExt
                    );

            if(!NT_SUCCESS(Status)) {

                TRACE(TL_STRM_ERROR,("Acquire failed:%x\n", Status));
                ASSERT(NT_SUCCESS(Status));

                //
                // Change to generic insufficient resource status.
                //
                Status = STATUS_INSUFFICIENT_RESOURCES;

                //
                // Note: even setting to this state failed, KSSTATE_PAUSE will still be called;
                // Since hConnect is NULL, STATUS_INSUFFICIENT_RESOURCES will be returned.
                //
            }
            else {
                //
                // Can verify connection by query the plug state 
                //            
                Status = 
                    AVCStrmGetPlugState(
                        pDevExt->physicalDevObj,
                        pAVCStrmExt
                        );
                if(NT_SUCCESS(Status)) {
                    ASSERT(pAVCStrmExt->RemotePlugState.BC_Connections == 1 || pAVCStrmExt->RemotePlugState.PP_Connections > 0);
                }
                else {
                    ASSERT(NT_SUCCESS(Status) && "Failed to get Plug State");
                }
            }
        }
        break;

    case KSSTATE_PAUSE:

        if(pAVCStrmExt->hConnect == NULL) {
            // Cannot stream without connection!  
            // failed to get hConnect at ACQUIRE state.
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
           
        // The system time (1394 CycleTime) will reset when enter PAUSE state.        
        if(pAVCStrmExt->StreamState != KSSTATE_PAUSE) {
            pAVCStrmExt->b1stNewFrameFromPauseState = TRUE;
            pAVCStrmExt->pAVCStrmDataStruc->PictureNumber = 0;
        }
            

        if(pAVCStrmExt->StreamState == KSSTATE_ACQUIRE || 
           pAVCStrmExt->StreamState == KSSTATE_STOP)   {             
 
        } 
        else if (pAVCStrmExt->StreamState == KSSTATE_RUN) {

            //
            // Stop isoch transfer            
            //          
            AVCStrmStopIsoch(pDevExt->physicalDevObj, pAVCStrmExt);
        }
        break;

    case KSSTATE_RUN:

        // Even there is no attach data request,
        // 61883 has its own buffers so isoch can start now.
        Status = 
            AVCStrmStartIsoch(
                pDevExt->physicalDevObj,
                pAVCStrmExt
                );
        ASSERT(NT_SUCCESS(Status));
        
        pAVCStrmExt->LastSystemTime = GetSystemTime();

        break;

    default:
        Status = STATUS_NOT_SUPPORTED;
    }

    if(NT_SUCCESS(Status)) 
        pAVCStrmExt->StreamState = KSState;

    return Status;
}

#if 0
NTSTATUS
AVCStreamControlGetProperty(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD  // BUGBUG StreamClass specific
    )
/*++

Routine Description:

    Get control property

Arguments:

    Irp -
        The irp client sent us.

    pDevExt -
        This driver's extension.

    pAVCStrmExt -
        The stream context created when a stream is open.

    pSPD -
        Stream property descriptor

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS  Status;
    ULONG  ulActualBytesTransferred;
    PAGED_CODE();
    ENTER("AVCStreamControlGetProperty");


    Status = STATUS_NOT_SUPPORTED;

    if(IsEqualGUID (&KSPROPSETID_Connection, &pSPD->Property->Set)) {

        Status = 
            AVCStrmGetConnectionProperty(
                pDevExt,
                pAVCStrmExt,
                pSPD,
                &ulActualBytesTransferred
                );
    } 
    else if (IsEqualGUID (&PROPSETID_VIDCAP_DROPPEDFRAMES, &pSPD->Property->Set)) {

        Status = 
            AVCStrmGetDroppedFramesProperty(
                pDevExt,
                pAVCStrmExt,
                pSPD,
                &ulActualBytesTransferred
                );
    } 

    return Status;
}

NTSTATUS
AVCStreamControlSetProperty(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN PSTREAM_PROPERTY_DESCRIPTOR pSPD  // BUGBUG StreamClass specific
    )
/*++

Routine Description:

    Set control property

Arguments:

    Irp -
        The irp client sent us.

    pDevExt -
        This driver's extension.

    pAVCStrmExt -
        The stream context created when a stream is open.

    pSPD -
        Stream property descriptor

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS Status;
    PAGED_CODE();
    ENTER("AVCStreamControlSetProperty");

    Status = STATUS_NOT_SUPPORTED;

    return Status;
}
#endif

NTSTATUS
AVCStreamRead(
    IN PIRP  pIrpUpper,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN AVCSTRM_BUFFER_STRUCT  * pBufferStruct
    )
/*++

Routine Description:

    Submit a read buffer to be filled.

Arguments:

    Irp -
        The irp client sent us.

    pDevExt -
        This driver's extension.

    pAVCStrmExt -
        The stream context created when a stream is open.

    BufferStruct -
        Buffer structure

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    PAVC_STREAM_DATA_STRUCT  pDataStruc;
    KIRQL  oldIrql;
    PIO_STACK_LOCATION  NextIrpStack;
    NTSTATUS  Status;
    PAVCSTRM_DATA_ENTRY  pDataEntry;


    PAGED_CODE();
    ENTER("AVCStreamRead");

    // Cancel data request if device is being removed.
    if(   pDevExt->state == STATE_REMOVING
       || pDevExt->state == STATE_REMOVED) {
        TRACE(TL_STRM_WARNING,("Read: device is remvoved; cancel read/write request!!\n"));
        Status = STATUS_DEVICE_REMOVED;  goto DoneStreamRead;
    }

    // If we are in the abort state, we will reject incoming data request.
    if(pAVCStrmExt->lAbortToken) {
        TRACE(TL_STRM_WARNING,("Read: aborting a stream; stop receiving data reqest!!\n"));
        Status = STATUS_CANCELLED;  goto DoneStreamRead;
    }

    // Validate basic parameters
    if(pAVCStrmExt->DataFlow != KSPIN_DATAFLOW_OUT) {
        TRACE(TL_STRM_ERROR,("Read: invalid Wrong data flow (%d) direction!!\n", pAVCStrmExt->DataFlow));
        Status = STATUS_INVALID_PARAMETER;  goto DoneStreamRead;
    }
    pDataStruc = pAVCStrmExt->pAVCStrmDataStruc;
    if(!pDataStruc) {
        TRACE(TL_STRM_ERROR,("Read: invalid pDataStruc:%x\n", pDataStruc));
        Status = STATUS_INVALID_PARAMETER;  goto DoneStreamRead;
    }
    if(pBufferStruct->StreamHeader->FrameExtent < pDataStruc->FrameSize) {
        TRACE(TL_STRM_ERROR,("Read: invalid buffer size:%d < FrameSize:%d\n", pBufferStruct->StreamHeader->FrameExtent, pDataStruc->FrameSize));
        Status = STATUS_INVALID_PARAMETER;  goto DoneStreamRead;
    }
    if(!pBufferStruct->FrameBuffer) {
        TRACE(TL_STRM_ERROR,("Read: invalid FrameBuffer:%x\n", pBufferStruct->FrameBuffer));
        Status = STATUS_INVALID_PARAMETER;  goto DoneStreamRead;
    }

    // Only accept read requests when in either the Pause or Run state and is connected.
    if( pAVCStrmExt->StreamState == KSSTATE_STOP       ||
        pAVCStrmExt->StreamState == KSSTATE_ACQUIRE    ||
        pAVCStrmExt->hConnect == NULL        
        ) {
        TRACE(TL_STRM_WARNING,("Read: StrmSt:%d and Connected:%x!!\n", pAVCStrmExt->StreamState, pAVCStrmExt->hConnect));
        Status = STATUS_CANCELLED;  goto DoneStreamRead;
    }


    KeAcquireSpinLock(&pDataStruc->DataListLock, &oldIrql);
    if(IsListEmpty(&pDataStruc->DataDetachedListHead)) {      
        TRACE(TL_STRM_ERROR,("Read:no detached buffers!\n"));
        ASSERT(!IsListEmpty(&pDataStruc->DataDetachedListHead));
        KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql);  
        Status = STATUS_INSUFFICIENT_RESOURCES;  goto DoneStreamRead;
    }

    pDataEntry = (PAVCSTRM_DATA_ENTRY) 
        RemoveHeadList(&pDataStruc->DataDetachedListHead); InterlockedDecrement(&pDataStruc->cntDataDetached);

    pDataStruc->cntDataReceived++;

    //
    // Format an attach frame request
    //
    AVCStrmFormatAttachFrame(
        pAVCStrmExt->DataFlow,
        pAVCStrmExt,
        pAVCStrmExt->pAVCStrmFormatInfo->AVCStrmFormat,
        &pDataEntry->AVReq,
        pDataEntry,
        pDataStruc->SourcePacketSize,
        pDataStruc->FrameSize,
        pIrpUpper,
        pBufferStruct->StreamHeader,
        pBufferStruct->FrameBuffer
        );

    // Client's clock information
    pDataEntry->ClockProvider = pBufferStruct->ClockProvider;
    pDataEntry->ClockHandle   = pBufferStruct->ClockHandle;

    // Add this to the attached list before it is completed since
    // the completion callback can be called before the IRP completion rooutine!
    InsertTailList(&pDataStruc->DataAttachedListHead, &pDataEntry->ListEntry); InterlockedIncrement(&pDataStruc->cntDataAttached);
    KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql);        

    NextIrpStack = IoGetNextIrpStackLocation(pDataEntry->pIrpLower);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_61883_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = &pDataEntry->AVReq;

    IoSetCompletionRoutine(
        pDataEntry->pIrpLower, 
        AVCStrmAttachFrameCR, 
        pDataEntry,   // Context
        TRUE,   // Success
        TRUE,   // Error
        TRUE    // Cancel
        );

    pDataEntry->pIrpLower->IoStatus.Status = STATUS_SUCCESS;  // Initialize it 

    if(!NT_SUCCESS(Status = IoCallDriver( 
        pDevExt->physicalDevObj,
        pDataEntry->pIrpLower
        ))) {

        //
        // Completion routine should have take care of this.
        //

        return Status;
    }


    //
    // Check the flag in pDataEntry to know the status of the IRP.
    //

    KeAcquireSpinLock(&pDataStruc->DataListLock, &oldIrql);

    ASSERT(IsStateSet(pDataEntry->State, DE_IRP_LOWER_ATTACHED_COMPLETED));  // Must be attached

    if(IsStateSet(pDataEntry->State, DE_IRP_LOWER_CALLBACK_COMPLETED)) {

        if(IsStateSet(pDataEntry->State, DE_IRP_UPPER_COMPLETED)) {

            //
            // How does this happen?  It should be protected by spinlock! Assert() to understand!
            //
            TRACE(TL_STRM_ERROR,("Watch out! Read: pDataEntry:%x\n", pDataEntry));        

            ASSERT(!IsStateSet(pDataEntry->State, DE_IRP_UPPER_COMPLETED)); 
        }
        else {

            IoCompleteRequest( pDataEntry->pIrpUpper, IO_NO_INCREMENT );  pDataEntry->State |= DE_IRP_UPPER_COMPLETED;

            //
            // Transfer from attach to detach list
            //
            RemoveEntryList(&pDataEntry->ListEntry); InterlockedDecrement(&pDataStruc->cntDataAttached);        
#if DBG
            if(pDataStruc->cntDataAttached < 0) {
                TRACE(TL_STRM_ERROR,("Read: pDataStruc:%x; pDataEntry:%x\n", pDataStruc, pDataEntry));        
                ASSERT(pDataStruc->cntDataAttached >= 0);  
            }
#endif
            InsertTailList(&pDataStruc->DataDetachedListHead, &pDataEntry->ListEntry); InterlockedIncrement(&pDataStruc->cntDataDetached);
        }
    }
    else {

        //
        // Normal case: IrpUpper will be pending until the callback routine is called or cancelled.
        //

        IoMarkIrpPending(pDataEntry->pIrpUpper);  pDataEntry->State |= DE_IRP_UPPER_PENDING_COMPLETED;

        Status = STATUS_PENDING; // This will be returned to IoCallDriver() from the client.
    }

    KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql);        


    EXIT("AVCStreamRead", Status);

    //
    // If the data was attached siccessful, we must return STATUS_PENDING
    //
    return Status;

DoneStreamRead:

    // Note: pDataStruc and pDataEntry may not be valid!
    pIrpUpper->IoStatus.Status = Status;
    IoCompleteRequest( pIrpUpper, IO_NO_INCREMENT );        

    EXIT("AVCStreamRead", Status);

    return Status;
}

#if DBG
typedef union {
    CYCLE_TIME CycleTime;
    ULONG ulCycleTime;
    } U_CYCLE_TIME, * PU_CYCLE_TIME;
#endif

NTSTATUS
AVCStreamWrite(
    IN PIRP  pIrpUpper,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt,
    IN AVCSTRM_BUFFER_STRUCT  * pBufferStruct
    )
/*++

Routine Description:

    Submit a write buffer to be transmitted.

Arguments:

    Irp -
        The irp client sent us.

    pDevExt -
        This driver's extension.

    pAVCStrmExt -
        The stream context created when a stream is open.

    BufferStruct -
        Buffer structure

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    PAVC_STREAM_DATA_STRUCT  pDataStruc;
    KIRQL  oldIrql;
    PIO_STACK_LOCATION  NextIrpStack;
    NTSTATUS  Status;
    PAVCSTRM_DATA_ENTRY  pDataEntry;

    PAGED_CODE();
    ENTER("AVCStreamWrite");

    // Cancel data request if device is being removed.
    if(   pDevExt->state == STATE_REMOVING
       || pDevExt->state == STATE_REMOVED) {
        TRACE(TL_STRM_WARNING,("Write: device is remvoved; cancel read/write request!!\n"));
        Status = STATUS_DEVICE_REMOVED;  goto DoneStreamWrite;
    }

    // If we are in the abort state, we will reject incoming data request.
    if(pAVCStrmExt->lAbortToken) {
        TRACE(TL_STRM_WARNING,("Write: aborting a stream; stop receiving data reqest!!\n"));
        Status = STATUS_CANCELLED;  goto DoneStreamWrite;
    }

    // Validate basic parameters
    if(pAVCStrmExt->DataFlow != KSPIN_DATAFLOW_IN) {
        TRACE(TL_STRM_ERROR,("Write: invalid Wrong data flow (%d) direction!!\n", pAVCStrmExt->DataFlow));
        Status = STATUS_INVALID_PARAMETER;  goto DoneStreamWrite;
    }
    pDataStruc = pAVCStrmExt->pAVCStrmDataStruc;
    if(!pDataStruc) {
        TRACE(TL_STRM_ERROR,("Write: invalid pDataStruc:%x\n", pDataStruc));
        Status = STATUS_INVALID_PARAMETER;  goto DoneStreamWrite;
    }

    // The client should take care of END OF stream buffer;
    // If we get this flag, we will ignore it for now.
    if((pBufferStruct->StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM)) {
        TRACE(TL_STRM_TRACE,("Write: End of stream\n"));

        // Wait until all transmit are completed.
        AVCStrmWaitUntilAttachedAreCompleted(pAVCStrmExt);

        Status = STATUS_SUCCESS;  goto DoneStreamWrite;
    }

    // The client should take care of format change;
    // If we get this flag, we will ignore it for now.
    if((pBufferStruct->StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED)) {
        TRACE(TL_STRM_WARNING,("Write: Format change reuqested\n"));
        Status = STATUS_SUCCESS;  goto DoneStreamWrite;
    }

    if(pBufferStruct->StreamHeader->FrameExtent < pDataStruc->FrameSize) {
        TRACE(TL_STRM_ERROR,("Write: invalid buffer size:%d < FrameSize:%d\n", pBufferStruct->StreamHeader->FrameExtent, pDataStruc->FrameSize));
        Status = STATUS_INVALID_PARAMETER;  goto DoneStreamWrite;
    }
    if(!pBufferStruct->FrameBuffer) {
        TRACE(TL_STRM_ERROR,("Write: invalid FrameBuffer:%x\n", pBufferStruct->FrameBuffer));
        Status = STATUS_INVALID_PARAMETER;  goto DoneStreamWrite;
    }

    // Only accept write requests when in either the Pause or Run state and is connected.
    if( pAVCStrmExt->StreamState == KSSTATE_STOP       ||
        pAVCStrmExt->StreamState == KSSTATE_ACQUIRE    ||
        pAVCStrmExt->hConnect == NULL
        ) {
        TRACE(TL_STRM_ERROR,("Write: StrmSt:%d or hConnect:%x!!\n", pAVCStrmExt->StreamState, pAVCStrmExt->hConnect));
        Status = STATUS_CANCELLED;  goto DoneStreamWrite;
    }

#if DBG
#define MASK_LOWER_25BIT  0x01ffffff
    if(pAVCStrmExt->pAVCStrmFormatInfo->AVCStrmFormat == AVCSTRM_FORMAT_MPEG2TS) {
        U_CYCLE_TIME TimeStamp25Bits;
        TimeStamp25Bits.ulCycleTime = *((PDWORD) pBufferStruct->FrameBuffer);
        TimeStamp25Bits.ulCycleTime = bswap(TimeStamp25Bits.ulCycleTime);
        TRACE(TL_CIP_TRACE,("\t%d \t%d \t%d \t%x \t%d \t%d\n", 
            (DWORD) pDataStruc->cntDataReceived, 
            pDataStruc->FrameSize,
            pDataStruc->SourcePacketSize,
            TimeStamp25Bits.ulCycleTime & MASK_LOWER_25BIT,
            TimeStamp25Bits.CycleTime.CL_CycleCount, 
            TimeStamp25Bits.CycleTime.CL_CycleOffset));   
    }
#endif

    KeAcquireSpinLock(&pDataStruc->DataListLock, &oldIrql);
    if(IsListEmpty(&pDataStruc->DataDetachedListHead)) {
        KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql);        
        TRACE(TL_STRM_ERROR,("Write:no detached buffers!\n"));
        ASSERT(!IsListEmpty(&pDataStruc->DataDetachedListHead));
        Status = STATUS_INSUFFICIENT_RESOURCES;  goto DoneStreamWrite;
    }

#if DBG
    //
    // For write operation, DataUsed <= FrameSize <= FrameExt
    //
    if(pBufferStruct->StreamHeader->DataUsed < pDataStruc->FrameSize) {
        // Jut to detect if this ever happen.
        TRACE(TL_PNP_ERROR,("**** Write: DataUsed:%d < FrameSize:%d; DataRcv:%d; AQD [%d:%d:%d]\n", 
            pBufferStruct->StreamHeader->DataUsed, pDataStruc->FrameSize,
            (DWORD) pDataStruc->cntDataReceived,
            pAVCStrmExt->pAVCStrmDataStruc->cntDataAttached,
            pAVCStrmExt->pAVCStrmDataStruc->cntDataQueued,
            pAVCStrmExt->pAVCStrmDataStruc->cntDataDetached
            ));
    }
#endif


    pDataEntry = (PAVCSTRM_DATA_ENTRY) 
        RemoveHeadList(&pDataStruc->DataDetachedListHead); InterlockedDecrement(&pDataStruc->cntDataDetached);

    pDataStruc->cntDataReceived++;

    //
    // Format an attach frame request
    //
    AVCStrmFormatAttachFrame(
        pAVCStrmExt->DataFlow,
        pAVCStrmExt,
        pAVCStrmExt->pAVCStrmFormatInfo->AVCStrmFormat,
        &pDataEntry->AVReq,
        pDataEntry,
        pDataStruc->SourcePacketSize,
#if 0
        pDataStruc->FrameSize,
#else
        pBufferStruct->StreamHeader->DataUsed,  // For write operation, DataUsed <= FrameSize <= FrameExt
#endif
        pIrpUpper,
        pBufferStruct->StreamHeader,
        pBufferStruct->FrameBuffer
        );

    // Client's clock information
    pDataEntry->ClockProvider = pBufferStruct->ClockProvider;
    pDataEntry->ClockHandle   = pBufferStruct->ClockHandle;

    // Add this to the attached list before it is completed since
    // the completion callback can be called before the IRP completion rooutine!
    InsertTailList(&pDataStruc->DataAttachedListHead, &pDataEntry->ListEntry); InterlockedIncrement(&pDataStruc->cntDataAttached);
    KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql);        

    NextIrpStack = IoGetNextIrpStackLocation(pDataEntry->pIrpLower);
    NextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_61883_CLASS;
    NextIrpStack->Parameters.Others.Argument1 = &pDataEntry->AVReq;

    IoSetCompletionRoutine(
        pDataEntry->pIrpLower, 
        AVCStrmAttachFrameCR, 
        pDataEntry, 
        TRUE, 
        TRUE, 
        TRUE
        );

    IoSetCancelRoutine(
        pDataEntry->pIrpLower,
        NULL
        );

    pDataEntry->pIrpLower->IoStatus.Status = STATUS_SUCCESS;  // Initialize it 

    if(!NT_SUCCESS(Status = IoCallDriver( 
        pDevExt->physicalDevObj,
        pDataEntry->pIrpLower
        ))) {

        //
        // Completion routine should have take care of this.
        //

        return Status;
    }


    //
    // Check the flag in pDataEntry to know the status of the IRP.
    //

    KeAcquireSpinLock(&pDataStruc->DataListLock, &oldIrql);

    ASSERT(IsStateSet(pDataEntry->State, DE_IRP_LOWER_ATTACHED_COMPLETED));  // Must be attached

    if(IsStateSet(pDataEntry->State, DE_IRP_LOWER_CALLBACK_COMPLETED)) {

        if(IsStateSet(pDataEntry->State, DE_IRP_UPPER_COMPLETED)) {

            //
            // How does this happen?  It should be protected by spinlock! Assert() to understand!
            //
            TRACE(TL_STRM_ERROR,("Watch out! Write: pDataEntry:%x\n", pDataEntry));        

            ASSERT(!IsStateSet(pDataEntry->State, DE_IRP_UPPER_COMPLETED)); 
        }
        else {

            IoCompleteRequest( pDataEntry->pIrpUpper, IO_NO_INCREMENT );  pDataEntry->State |= DE_IRP_UPPER_COMPLETED;

            //
            // Transfer from attach to detach list
            //
            RemoveEntryList(&pDataEntry->ListEntry); InterlockedDecrement(&pDataStruc->cntDataAttached);        

            //
            // Signal when there is no more data buffer attached.
            //
            if(pDataStruc->cntDataAttached == 0) 
                KeSetEvent(&pDataStruc->hNoAttachEvent, 0, FALSE); 

#if DBG
            if(pDataStruc->cntDataAttached < 0) {
                TRACE(TL_STRM_ERROR,("Write: pDataStruc:%x; pDataEntry:%x\n", pDataStruc, pDataEntry));        
                ASSERT(pDataStruc->cntDataAttached >= 0);  
            }
#endif
            InsertTailList(&pDataStruc->DataDetachedListHead, &pDataEntry->ListEntry); InterlockedIncrement(&pDataStruc->cntDataDetached);
        }
    }
    else {

        //
        // Normal case: IrpUpper will be pending until the callback routine is called or cancelled.
        //

        IoMarkIrpPending(pDataEntry->pIrpUpper);  pDataEntry->State |= DE_IRP_UPPER_PENDING_COMPLETED;

        Status = STATUS_PENDING; // This will be returned to IoCallDriver() from the client.
    }

    KeReleaseSpinLock(&pDataStruc->DataListLock, oldIrql);     

    EXIT("AVCStreamWrite", Status);

    //
    // If the data was attached siccessful, we must return STATUS_PENDING
    //
    return Status;

DoneStreamWrite:

    // Note: pDataStruc and pDataEntry may not be valid!
    pIrpUpper->IoStatus.Status = Status;
    IoCompleteRequest( pIrpUpper, IO_NO_INCREMENT );        

    EXIT("AVCStreamWrite", Status);

    return Status;
}


NTSTATUS
AVCStreamAbortStreaming(
    IN PIRP  pIrp,  // The Irp from its client
    IN struct DEVICE_EXTENSION * pDevExt,
    IN PAVC_STREAM_EXTENSION  pAVCStrmExt
    )
/*++

Routine Description:

    This routine could be called at DISPATCH_LEVEL so it will create a work item 
    to stop isoch and then cancel all pennding buffers.
    To cancel each individual buffer, IoCancelIrp() should be used..

Arguments:

    Irp -
        The irp client sent us.

    pDevExt -
        This driver's extension.

    pAVCStrmExt -
        The stream context created when a stream is open.

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS Status;
    PAGED_CODE();
    ENTER("AVCStreamAbortStreaming");

    TRACE(TL_STRM_WARNING,("AbortStreaming: Active:%d; State:%d\n", pAVCStrmExt->IsochIsActive, pAVCStrmExt->StreamState));

    // Claim this token
    if(InterlockedExchange(&pAVCStrmExt->lAbortToken, 1) == 1) {
        TRACE(TL_STRM_WARNING,("AbortStreaming: One already issued.\n"));
        return STATUS_SUCCESS;  
    }

    Status = STATUS_SUCCESS;

#ifdef USE_WDM110  // Win2000 code base
    ASSERT(pAVCStrmExt->pIoWorkItem == NULL);  // Have not yet queued work item.

    // We will queue work item to stop and cancel all SRBs
    if(pAVCStrmExt->pIoWorkItem = IoAllocateWorkItem(pDevExt->physicalDevObj)) { 

        // Set to non-signal
        KeClearEvent(&pAVCStrmExt->hAbortDoneEvent);  // Before queuing; just in case it return the work item is completed.
        IoQueueWorkItem(
            pAVCStrmExt->pIoWorkItem,
            AVCStrmAbortStreamingWorkItemRoutine,
            DelayedWorkQueue, // CriticalWorkQueue 
            pAVCStrmExt
            );

#else              // Win9x code base
    ExInitializeWorkItem( &pAVCStrmExt->IoWorkItem, AVCStrmAbortStreamingWorkItemRoutine, pAVCStrmExt);
    if(TRUE) {

        // Set to non-signal
        KeClearEvent(&pAVCStrmExt->hAbortDoneEvent);  // Before queuing; just in case it return the work item is completed.

        ExQueueWorkItem( 
            &pAVCStrmExt->IoWorkItem,
            DelayedWorkQueue // CriticalWorkQueue 
            ); 
#endif

        TRACE(TL_STRM_TRACE,("AbortStreaming: CancelWorkItm queued; Pic#:%d;Prc:%d;;Drop:%d; AQD [%d:%d:%d]\n",
            (DWORD) pAVCStrmExt->pAVCStrmDataStruc->PictureNumber,
            (DWORD) pAVCStrmExt->pAVCStrmDataStruc->FramesProcessed, 
            (DWORD) pAVCStrmExt->pAVCStrmDataStruc->FramesDropped,
            pAVCStrmExt->pAVCStrmDataStruc->cntDataAttached,
            pAVCStrmExt->pAVCStrmDataStruc->cntDataQueued,
            pAVCStrmExt->pAVCStrmDataStruc->cntDataDetached
            ));

    } 
#ifdef USE_WDM110  // Win2000 code base
    else {
        Status = STATUS_INSUFFICIENT_RESOURCES;  // Only reason IoAllocateWorkItem can fail.
        InterlockedExchange(&pAVCStrmExt->lAbortToken, 0);
        ASSERT(pAVCStrmExt->pIoWorkItem && "IoAllocateWorkItem failed.\n");
    }
#endif

#define MAX_ABORT_WAIT  50000000   // max wait time (100nsec unit)

    if(NT_SUCCESS(Status)) {

        NTSTATUS StatusWait;
        LARGE_INTEGER tmMaxWait;

        tmMaxWait = RtlConvertLongToLargeInteger(-(MAX_ABORT_WAIT));

        //
        // Wait with timeout until the work item has completed.
        //
        StatusWait = 
            KeWaitForSingleObject( 
                &pAVCStrmExt->hAbortDoneEvent,
                Executive,
                KernelMode,
                FALSE,
                &tmMaxWait
                );

        TRACE(TL_STRM_ERROR,("**WorkItem completed! StatusWait:%x; pAVStrmExt:%x; AQD [%d:%d:%d]\n",
            StatusWait, pAVCStrmExt,
            pAVCStrmExt->pAVCStrmDataStruc->cntDataAttached,
            pAVCStrmExt->pAVCStrmDataStruc->cntDataQueued,
            pAVCStrmExt->pAVCStrmDataStruc->cntDataDetached
            ));

        ASSERT(StatusWait == STATUS_SUCCESS);
    }

    return Status;
}


NTSTATUS
AVCStreamSurpriseRemoval(
    IN struct DEVICE_EXTENSION * pDevExt  
    )
/*++

Routine Description:

    This routine is called when this device is being surprise removed 
    with IRP_MN_SURPRISE_REMOVAL. We need to clean up and cancel any 
    pending request before passing irp down to lower driver.

Arguments:

    pDevExt -
        This driver's extension.

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i;    

    for (i=0; i < pDevExt->NumberOfStreams; i++) {
        if(pDevExt->pAVCStrmExt[i]) {
            if(pDevExt->pAVCStrmExt[i]->lAbortToken == 1) {
                PAVC_STREAM_EXTENSION  pAVCStrmExt = pDevExt->pAVCStrmExt[i];
#if DBG
                ULONGLONG tmStart = GetSystemTime();
#endif
                KeWaitForSingleObject( 
                    &pAVCStrmExt->hAbortDoneEvent,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL
                    );         
                TRACE(TL_PNP_WARNING,("** Waited %d for AbortStream to complete\n", (DWORD) (GetSystemTime() - tmStart) ));                    
            } 

            //
            // Since we are already removed, go ahead and break the connection.
            //
            AVCStrmBreakConnection(pDevExt->physicalDevObj, pDevExt->pAVCStrmExt[i]);
        }
    }

    return Status;
}

NTSTATUS
AVCStrmValidateStreamRequest(
    struct DEVICE_EXTENSION *pDevExt,
    PAVC_STREAM_REQUEST_BLOCK pAVCStrmReqBlk
    )
/*++

Routine Description:

    Validate the StreamIndex of an AVC Stream Extension according to a AVC Stream function.

Arguments:

    pDevExt -
        This driver's extension.

    pAVCStrmReqBlk -
        AVC Stream reuqest block.

Return Value:

    Status
        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS Status;
    
    PAGED_CODE();
    ENTER("AVCStrmValidateStreamRequest");
    
    Status = STATUS_SUCCESS;

    // Validate pointer
    if(!pAVCStrmReqBlk)
        return STATUS_INVALID_PARAMETER;  

    // Validate block size
    if(pAVCStrmReqBlk->SizeOfThisBlock != sizeof(AVC_STREAM_REQUEST_BLOCK))
        return STATUS_INVALID_PARAMETER;
    
#if 0
    // Validate version supported
    if(   pAVCStrmReqBlk->Version != '15TN' 
       && pAVCStrmReqBlk->Version != ' 8XD'
       )
        return STATUS_INVALID_PARAMETER;
#endif

    if(pAVCStrmReqBlk->Function == AVCSTRM_OPEN) {
        if(pDevExt->NumberOfStreams >= MAX_STREAMS_PER_DEVICE) {
            ASSERT(pDevExt->NumberOfStreams < MAX_STREAMS_PER_DEVICE && "AVCStreamOpen: Too many stream open!\n");
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        if(pAVCStrmReqBlk->AVCStreamContext == NULL) {
            ASSERT(pAVCStrmReqBlk->AVCStreamContext != NULL && "Invalid pAVCStrmExt\n");
            return STATUS_INVALID_PARAMETER;    
        }

        // To be more robust, we may need to make sure this is 
        // one of the cached stream extension created by us.
        // ......
    }

    return Status;
}

NTSTATUS
AvcStrm_IoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    struct DEVICE_EXTENSION *pDevExt;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN passIrpDown = TRUE;
    NTSTATUS Status;
    PAVC_STREAM_REQUEST_BLOCK pAvcStrmIrb;

    PAGED_CODE();
    ENTER("AvcStrm_IoControl");


    Status = STATUS_SUCCESS;
    pDevExt = DeviceObject->DeviceExtension;
    ASSERT(pDevExt->signature == DEVICE_EXTENSION_SIGNATURE);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    pAvcStrmIrb = irpSp->Parameters.Others.Argument1;

    // Validate the stream context
    if(!NT_SUCCESS(Status = 
        AVCStrmValidateStreamRequest(
            pDevExt, 
            pAvcStrmIrb))) {

        goto DoneIoControl;
    }

    switch(pAvcStrmIrb->Function) {
    case AVCSTRM_OPEN:
        Status = AVCStreamOpen(
            Irp,
            pDevExt,
            &pAvcStrmIrb->CommandData.OpenStruct
            );
        break;
    case AVCSTRM_CLOSE:
        Status = AVCStreamClose(
            Irp,
            pDevExt,
            (PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext
            );
         break;


    case AVCSTRM_GET_STATE:
        Status = AVCStreamControlGetState(
            Irp,
            pDevExt,
            (PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext,
            &pAvcStrmIrb->CommandData.StreamState
            );
         break;
    case AVCSTRM_SET_STATE:
        Status = AVCStreamControlSetState(
            Irp,
            pDevExt,
            (PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext,
            pAvcStrmIrb->CommandData.StreamState
            );
         break;

#if 0  // Later...
    case AVCSTRM_GET_PROPERTY:
        Status = AVCStreamControlGetProperty(
            Irp,
            pDevExt,
            (PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext,
            pAvcStrmIrb->CommandData.PropertyDescriptor
            );
         break;
    case AVCSTRM_SET_PROPERTY:
        Status = AVCStreamControlSetProperty(
            Irp,
            pDevExt,
            (PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext,
            pAvcStrmIrb->CommandData.PropertyDescriptor
            );
         break;
#endif

    case AVCSTRM_READ:
        // Mutex with Cancel or setting to stop state.
        KeWaitForMutexObject(&((PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext)->hMutexControl, Executive, KernelMode, FALSE, NULL);
        Status = AVCStreamRead(
            Irp,
            pDevExt,
            (PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext,
            &pAvcStrmIrb->CommandData.BufferStruct
            );
        KeReleaseMutex(&((PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext)->hMutexControl, FALSE);
        return Status;
        break;
    case AVCSTRM_WRITE:
        KeWaitForMutexObject(&((PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext)->hMutexControl, Executive, KernelMode, FALSE, NULL);
        Status = AVCStreamWrite(
            Irp,
            pDevExt,
            (PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext,
            &pAvcStrmIrb->CommandData.BufferStruct
            );
        KeReleaseMutex(&((PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext)->hMutexControl, FALSE);
        return Status;
        break;


    case AVCSTRM_ABORT_STREAMING:
        Status = AVCStreamAbortStreaming(
            Irp,
            pDevExt,
            (PAVC_STREAM_EXTENSION) pAvcStrmIrb->AVCStreamContext
            );
        break;


    default:
        Status = STATUS_INVALID_PARAMETER;
        break;
    }

DoneIoControl:

#if DBG
    if(!NT_SUCCESS(Status)) {
        TRACE(TL_PNP_WARNING,("Av_IoControl return Status:%x\n", Status));
    }
#endif

    if (Status == STATUS_PENDING) {
        TRACE(TL_PNP_TRACE,("Av_IoControl: returning STATUS_PENDING."));
        IoMarkIrpPending(Irp);        
    } else {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\bt848api.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Bt848api.cpp 1.2 1998/04/29 22:43:26 tomz Exp $

#include "device.h"
#include "audio.h"


void PsDevice::EnableAudio( State s )
{
   SetGPOE( 0x0000000FL );
   if ( s == On )
      SetGPDATABits( 0, 1, AUDIO_SOURCE_TVTUNER, 0 );
   else
      SetGPDATABits( 0, 1, AUDIO_SOURCE_EXTAUDIO, 0 );
}      

/////////////////////////////////////////////////////////////////////////////
// I2C DATA/CONTROL REGISTER API
/////////////////////////////////////////////////////////////////////////////

bool PsDevice::I2CIsInitOK( void )
{
   return i2c.IsInitOK();
}

#ifdef	HARDWAREI2C
//---------------------------------------------------------------------------
ErrorCode PsDevice::I2CInitHWMode( long freq )
{
   return i2c.I2CInitHWMode( freq );
}

//---------------------------------------------------------------------------
void PsDevice::I2CSetFreq( long freq )
{
   i2c.I2CSetFreq( freq );
}

//---------------------------------------------------------------------------
int PsDevice::I2CReadDiv( void )
{
   return i2c.I2CReadDiv();
}

//---------------------------------------------------------------------------
ErrorCode PsDevice::I2CHWRead( BYTE address, BYTE *value )
{
   return i2c.I2CHWRead( address, value );
}

//---------------------------------------------------------------------------
ErrorCode PsDevice::I2CHWWrite2( BYTE address, BYTE value1 )
{
   return i2c.I2CHWWrite2( address, value1 );
}

//---------------------------------------------------------------------------
ErrorCode PsDevice::I2CHWWrite3( BYTE address, BYTE value1, BYTE value2 )
{
   return i2c.I2CHWWrite3( address, value1, value2 );
}

//---------------------------------------------------------------------------
int PsDevice::I2CReadSync( void )
{
   return i2c.I2CReadSync();
}

#endif

//---------------------------------------------------------------------------
int PsDevice::I2CGetLastError( void )
{
   return i2c.I2CGetLastError();
}

#ifdef HAUPPAUGEI2CPROVIDER
ErrorCode PsDevice::I2CInitSWMode( long freq )
{
   return i2c.I2CInitSWMode( freq );
}

ErrorCode PsDevice::I2CSWStart( void )
{
   return i2c.I2CSWStart();
}

ErrorCode PsDevice::I2CSWStop( void )
{
   return i2c.I2CSWStop();
}
 
ErrorCode PsDevice::I2CSWRead( BYTE * value )
{
   return i2c.I2CSWRead( value );
}

ErrorCode PsDevice::I2CSWWrite( BYTE value )
{
   return i2c.I2CSWWrite( value );
}

ErrorCode PsDevice::I2CSWSendACK( void )
{
   return i2c.I2CSWSendACK();
}

ErrorCode PsDevice::I2CSWSendNACK( void )
{
   return i2c.I2CSWSendNACK();
}

//   ErrorCode PsDevice::I2CSWSetSCL( Level );
//   int       PsDevice::I2CSWReadSCL( void );
//   ErrorCode PsDevice::I2CSWSetSDA( Level );
//   int       PsDevice::I2CSWReadSDA( void );

#endif

/////////////////////////////////////////////////////////////////////////////
// GPIO, GPOE, GPIE, and GPDATA REGISTER API
/////////////////////////////////////////////////////////////////////////////

bool PsDevice::GPIOIsInitOK( void )
{
   return gpio.IsInitOK();
}

//---------------------------------------------------------------------------
void PsDevice::SetGPCLKMODE( State s )
{
   gpio.SetGPCLKMODE( s );
}

//---------------------------------------------------------------------------
int PsDevice::GetGPCLKMODE( void )
{
   return gpio.GetGPCLKMODE();
}

//---------------------------------------------------------------------------
void PsDevice::SetGPIOMODE( GPIOMode mode )
{
   gpio.SetGPIOMODE( mode );
}

//---------------------------------------------------------------------------
int PsDevice::GetGPIOMODE( void )
{
   return gpio.GetGPIOMODE();
}

//---------------------------------------------------------------------------
void PsDevice::SetGPWEC( State s )
{
   gpio.SetGPWEC( s );
}

//---------------------------------------------------------------------------
int PsDevice::GetGPWEC( void )
{
   return gpio.GetGPWEC();
}

//---------------------------------------------------------------------------
void PsDevice::SetGPINTI( State s )
{
   gpio.SetGPINTI( s );
}

//---------------------------------------------------------------------------
int PsDevice::GetGPINTI( void )
{
   return gpio.GetGPINTI();
}

//---------------------------------------------------------------------------
void PsDevice::SetGPINTC( State s )
{
   gpio.SetGPINTC( s );
}

//---------------------------------------------------------------------------
int PsDevice::GetGPINTC( void )
{
   return gpio.GetGPINTC();
}

//---------------------------------------------------------------------------
ErrorCode PsDevice::SetGPOEBit( int bit, State s )
{
   return gpio.SetGPOE( bit, s );
}

//---------------------------------------------------------------------------
void PsDevice::SetGPOE( DWORD value )
{
   gpio.SetGPOE( value );
}

//---------------------------------------------------------------------------
int PsDevice::GetGPOEBit( int bit )
{
   return gpio.GetGPOE( bit );
}

//---------------------------------------------------------------------------
DWORD PsDevice::GetGPOE( void )
{
   return gpio.GetGPOE();
}

//---------------------------------------------------------------------------
ErrorCode PsDevice::SetGPIEBit( int bit , State s )
{
   return gpio.SetGPIE( bit, s );
}

//---------------------------------------------------------------------------
void PsDevice::SetGPIE( DWORD value )
{
   gpio.SetGPIE( value );
}

//---------------------------------------------------------------------------
int PsDevice::GetGPIEBit( int bit )
{
   return gpio.GetGPIE( bit );
}

//---------------------------------------------------------------------------
DWORD PsDevice::GetGPIE( void )
{
   return gpio.GetGPIE();
}

//---------------------------------------------------------------------------
ErrorCode PsDevice::SetGPDATA( GPIOReg *data, int size, int offset )
{
   return gpio.SetGPDATA( data, size, offset );
}

//---------------------------------------------------------------------------
ErrorCode PsDevice::GetGPDATA( GPIOReg *data, int size, int offset )
{
   return gpio.GetGPDATA( data, size, offset );
}

//---------------------------------------------------------------------------
ErrorCode PsDevice::SetGPDATABits( int fromBit, int toBit, DWORD value, int offset )
{
   return gpio.SetGPDATA( fromBit, toBit, value, offset );
}

//---------------------------------------------------------------------------
ErrorCode PsDevice::GetGPDATABits( int fromBit, int toBit, DWORD *value, int offset )
{
   return gpio.GetGPDATA( fromBit, toBit, value, offset );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\avcstrm\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, CallNextDriverSync)
        #pragma alloc_text(PAGE, CallDriverSync)
        #pragma alloc_text(PAGE, QueryDeviceKey)
        #pragma alloc_text(PAGE, RegistryAccessSample)
#endif


NTSTATUS CallNextDriverSync(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

        Pass the IRP down to the next device object in the stack
        synchronously, and bump the pendingActionCount around
        the call to prevent the current device object from getting
        removed before the IRP completes.

Arguments:

    devExt - device extension of one of our device objects
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    IncrementPendingActionCount(devExt);
    status = CallDriverSync(devExt->topDevObj, irp);
    DecrementPendingActionCount(devExt);

    return status;
}



NTSTATUS CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp)
/*++

Routine Description:

      Call IoCallDriver to send the irp to the device object;
      then, synchronize with the completion routine.
      When CallDriverSync returns, the action has completed
      and the irp again belongs to the current driver.

      NOTE:  In order to keep the device object from getting freed
             while this IRP is pending, you should call
             IncrementPendingActionCount() and 
             DecrementPendingActionCount()
             around the CallDriverSync call.

Arguments:

    devObj - targetted device object
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine( irp, 
                            CallDriverSyncCompletion, 
                            &event,     // context
                            TRUE, TRUE, TRUE);

    status = IoCallDriver(devObj, irp);

    KeWaitForSingleObject(  &event,
                            Executive,      // wait reason
                            KernelMode,
                            FALSE,          // not alertable
                            NULL );         // no timeout

    status = irp->IoStatus.Status;

    ASSERT(NT_SUCCESS(status));

    return status;
}


NTSTATUS CallDriverSyncCompletion(
                                    IN PDEVICE_OBJECT devObjOrNULL, 
                                    IN PIRP irp, 
                                    IN PVOID context)
/*++

Routine Description:

      Completion routine for CallDriverSync.

Arguments:

    devObjOrNULL - 
            Usually, this is this driver's device object.
             However, if this driver created the IRP, 
             there is no stack location in the IRP for this driver;
             so the kernel has no place to store the device object;
             ** so devObj will be NULL in this case **.

    irp - completed Io Request Packet
    context - context passed to IoSetCompletionRoutine by CallDriverSync. 

    
Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    PKEVENT event = context;

    ASSERT(irp->IoStatus.Status != STATUS_IO_TIMEOUT);

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



VOID IncrementPendingActionCount(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

      Increment the pendingActionCount for a device object.
      This keeps the device object from getting freed before
      the action is completed.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(devExt->pendingActionCount >= 0);
    InterlockedIncrement(&devExt->pendingActionCount);    
}



VOID DecrementPendingActionCount(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

      Decrement the pendingActionCount for a device object.
      This is called when an asynchronous action is completed
      AND ALSO when we get the REMOVE_DEVICE IRP.
      If the pendingActionCount goes to -1, that means that all
      actions are completed and we've gotten the REMOVE_DEVICE IRP;
      in this case, set the removeEvent event so we can finish
      unloading.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(devExt->pendingActionCount >= 0);
    InterlockedDecrement(&devExt->pendingActionCount);    

    if (devExt->pendingActionCount < 0){
        /*
         *  All pending actions have completed and we've gotten
         *  the REMOVE_DEVICE IRP.
         *  Set the removeEvent so we'll stop waiting on REMOVE_DEVICE.
         */
        ASSERT((devExt->state == STATE_REMOVING) || 
               (devExt->state == STATE_REMOVED));
        KeSetEvent(&devExt->removeEvent, 0, FALSE);
    }
}


NTSTATUS
QueryDeviceKey (
    IN  HANDLE  Handle,
    IN  PWCHAR  ValueNameString,
    OUT PVOID   Data,
    IN  ULONG   DataLength
    )
/*++

Routine Description:

    Retrieve the data associated with a specified registry value.

Arguments:

    Handle - handle of key for which value entry is to be read
    ValueNameString - name of value whose data is to be retrieved
    Data - buffer to receive the data
    DataLength - length of data buffer

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    UNICODE_STRING  valueName;
    ULONG           length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;

    PAGED_CODE();

    RtlInitUnicodeString (&valueName, ValueNameString);

    length = sizeof (KEY_VALUE_FULL_INFORMATION)
           + valueName.MaximumLength
           + DataLength;

    fullInfo = ExAllocatePool (PagedPool, length);

    if (fullInfo) {
        status = ZwQueryValueKey (Handle,
                                  &valueName,
                                  KeyValueFullInformation,
                                  fullInfo,
                                  length,
                                  &length);

        if (NT_SUCCESS (status)) {
            ASSERT (DataLength == fullInfo->DataLength);
            RtlCopyMemory (Data,
                           ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                           fullInfo->DataLength);
        }

        ExFreePool (fullInfo);
    } else {
        status = STATUS_NO_MEMORY;
    }

    return status;
}


VOID RegistryAccessSample(struct DEVICE_EXTENSION *devExt,
                          PDEVICE_OBJECT devObj)
/*++

Routine Description:

    SAMPLE showing how to access the device-specific registry key 

Arguments:

    devExt - device extension (for our _filter_ device object)
    devObj - device object pointer
             NOTE: This must not be the functional device object
                   created by this filter driver, because that
                   device object does not have a devnode area
                   in the registry; pass the device object of
                   the device object for which this driver is
                   a filter.  This is the device object passed
                   to VA_AddDevice.

Return Value:

    VOID

--*/
{
    NTSTATUS status;
    HANDLE hRegDevice;

    PAGED_CODE();

    status = IoOpenDeviceRegistryKey(   devObj, 
                                        PLUGPLAY_REGKEY_DEVICE, 
                                        KEY_READ, 
                                        &hRegDevice);

    if (NT_SUCCESS(status)){
        ULONG value, otherValue;

        if (NT_SUCCESS(QueryDeviceKey( hRegDevice,
                                       L"SampleFilterParam",
                                       &value,
                                       sizeof(value)))) {
            //
            // Perform whatever operation is necessary 
            //
        }

        if (NT_SUCCESS(QueryDeviceKey( hRegDevice,
                                       L"SampleFilterParam2",
                                       &otherValue,
                                       sizeof(otherValue)))) {
            //
            // Perform whatever operation is necessary 
            //
        }

        ZwClose(hRegDevice);
    }
    else {
        TRACE(TL_PNP_ERROR,("IoOpenDeviceRegistryKey failed with %xh.", status));
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\capdebug.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Capdebug.h 1.9 1998/05/07 15:23:25 tomz Exp $

//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;


#ifndef __CAPDEBUG_H
#define __CAPDEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

   #include <stdio.h>

#ifdef __cplusplus
}
#endif

#if DBG
   extern "C" void MyDebugPrint(long DebugPrintLevel, char * DebugMessage, ... );
   #define  DebugOut(x) MyDebugPrint x
   #define TRACE_CALLS  0
#else
   #define  DebugOut(x)
   #define TRACE_CALLS  0
#endif

#define DUMP(v) DebugOut((0, "--- " #v " = %d\n", v));
#define DUMPX(v) DebugOut((0, "--- " #v " = 0x%x\n", v));
   
#if TRACE_CALLS
   class Trace {
   public:
      char    *psz;       // string to be printed
      Trace(char *pszFunc);
      ~Trace();
   };
#else
   class Trace {
   public:
      Trace(char *pszFunc) {};
      ~Trace() {};
   };
#endif

#endif // __CAPDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\capmain.c ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Capmain.c 1.19 1998/05/11 23:59:54 tomz Exp $

//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#define INITGUID
#define BT848_MEDIUMS

#ifdef __cplusplus
extern "C" {
#endif
#include "strmini.h"
#include "ksmedia.h"
#ifdef __cplusplus
}
#endif

#include "device.h"
#include "capmain.h"
#include "capstrm.h"
#include "capdebug.h"
#include "capprop.h"

LONG  PinTypes_ [MaxInpPins]; // just allocate maximum possible
DWORD xtals_ [2]; // no more than 2 xtals

extern PsDevice *gpPsDevice;
extern BYTE     *gpjBaseAddr;
extern VOID     *gpHwDeviceExtension;

void AdapterFormatFromRange( IN PHW_STREAM_REQUEST_BLOCK pSrb );
VOID ReadRegistryValues( IN PDEVICE_OBJECT PhysicalDeviceObject );
inline void CompleteDeviceSRB( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb );

extern DWORD GetSizeHwDeviceExtension( );
extern DWORD GetSizeStreamEx( );
extern PsDevice *GetCurrentDevice( );
extern void SetCurrentDevice( PsDevice *dev );

extern BYTE *GetBase();
extern void SetBase(BYTE *base);

PHW_STREAM_REQUEST_BLOCK StreamIdxToSrb[4];

void CheckSrbStatus( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   VideoStream StreamNumber = (VideoStream)pSrb->StreamObject->StreamNumber;

   DebugOut((1, "  *** completing pSrb(%x) strm(%d) status(%x)\n", pSrb, StreamNumber, pSrb->Status ));

   switch ( pSrb->Status )
   {
   case STATUS_SUCCESS:
   case STATUS_CANCELLED:
      break;
   default:
      DebugOut((0, "*** pSrb->Status = %x\n", pSrb->Status ));
      DEBUG_BREAKPOINT();
   }
}

/* Function: GetRequestedSize
 * Purpose: Figures out what the image size should be
 * Input: vidHdr: KS_VIDEOINFOHEADER &
 *   size: MSize &
 * Output: None
*/
void GetRequestedSize2( const KS_VIDEOINFOHEADER2 &vidHdr, MSize &size )
{
   Trace t("GetRequestedSize()");

   size.Set( vidHdr.bmiHeader.biWidth, abs(vidHdr.bmiHeader.biHeight) );

   MRect dst( vidHdr.rcTarget );
   // if writing to a DD surface maybe ?
   if ( !dst.IsNull() && !dst.IsEmpty() )
      size.Set( dst.Width(), dst.Height() );
}

void GetRequestedSize( const KS_VIDEOINFOHEADER &vidHdr, MSize &size )
{
   Trace t("GetRequestedSize()");

   size.Set( vidHdr.bmiHeader.biWidth, abs(vidHdr.bmiHeader.biHeight) );

   MRect dst( vidHdr.rcTarget );
   // if writing to a DD surface maybe ?
   if ( !dst.IsNull() && !dst.IsEmpty() )
      size.Set( dst.Width(), dst.Height() );
}

/* Function: VerifyVideoStream
 * Purpose: Checks the paramaters passed in for opening steam
 * Input: vidHDR: KS_DATAFORMAT_VIDEOINFOHEADER
 * Output: Success or Fail
 */
ErrorCode VerifyVideoStream( const KS_DATAFORMAT_VIDEOINFOHEADER &vidHDR )
{
   Trace t("VerifyVideoStream()");

   // [WRK] - add guid for VideoInfoHeader2

   // simply verify that major and format are of video nature...
   if ( IsEqualGUID( vidHDR.DataFormat.MajorFormat, KSDATAFORMAT_TYPE_VIDEO ) &&
        IsEqualGUID( vidHDR.DataFormat.Specifier, KSDATAFORMAT_SPECIFIER_VIDEOINFO ) ) {

      MSize size;
      GetRequestedSize( vidHDR.VideoInfoHeader, size );
      // ... and here see if the subtype is one of those supported by us
      ColorSpace tmpCol( vidHDR.DataFormat.SubFormat );
      MRect dst( vidHDR.VideoInfoHeader.rcTarget );

      // make sure the dimentions are acceptable
      if ( tmpCol.IsValid() && tmpCol.CheckDimentions( size ) &&
         tmpCol.CheckLeftTop( dst.TopLeft() ) ) {
         DebugOut((1, "VerifyVideoStream succeeded\n"));
         return Success;
      }
   }
   DebugOut((0, "VerifyVideoStream failed\n"));
   return Fail;
}

ErrorCode VerifyVideoStream2( const KS_DATAFORMAT_VIDEOINFOHEADER2 &vidHDR )
{
   Trace t("VerifyVideoStream2()");

   // [WRK] - add guid for VideoInfoHeader2

   // simply verify that major and format are of video nature...
   if ( IsEqualGUID( vidHDR.DataFormat.MajorFormat, KSDATAFORMAT_TYPE_VIDEO ) &&
        IsEqualGUID( vidHDR.DataFormat.Specifier, KSDATAFORMAT_SPECIFIER_VIDEOINFO2 ) ) {

      MSize size;
      GetRequestedSize2( vidHDR.VideoInfoHeader2, size );
      // ... and here see if the subtype is one of those supported by us
      ColorSpace tmpCol( vidHDR.DataFormat.SubFormat );
      MRect dst( vidHDR.VideoInfoHeader2.rcTarget );

      // make sure the dimentions are acceptable
      if ( tmpCol.IsValid() && tmpCol.CheckDimentions( size ) &&
         tmpCol.CheckLeftTop( dst.TopLeft() ) ) {
         DebugOut((1, "VerifyVideoStream2 succeeded\n"));
         return Success;
      }
   }
   DebugOut((0, "VerifyVideoStream2 failed\n"));
   return Fail;
}

/* Function: VerifyVBIStream
 * Purpose: Checks that VBI stream info during open is correct
 * Input: rKSDataFormat: KS_DATAFORMAT &
 * Output: ErrorCode
 */
ErrorCode VerifyVBIStream( const KS_DATAFORMAT_VBIINFOHEADER &rKSDataFormat )
{
   Trace t("VerifyVBIStream()");

   if ( IsEqualGUID( rKSDataFormat.DataFormat.MajorFormat, KSDATAFORMAT_TYPE_VBI ) &&
        IsEqualGUID( rKSDataFormat.DataFormat.Specifier,
        KSDATAFORMAT_SPECIFIER_VBI ) &&
        rKSDataFormat.VBIInfoHeader.StartLine == VBIStart &&
        rKSDataFormat.VBIInfoHeader.EndLine   == VBIEnd   &&
        rKSDataFormat.VBIInfoHeader.SamplesPerLine == VBISamples )
      return Success;
   return Fail;
}

/*
** DriverEntry()
**
**   This routine is called when an SRB_INITIALIZE_DEVICE request is received
**
** Arguments:
**
**   Context1 and Context2
**
** Returns:
**
**   Results of StreamClassRegisterAdapter()
**
** Side Effects:  none
*/

extern "C" ULONG DriverEntry( PVOID Arg1, PVOID Arg2 )
{
   Trace t("DriverEntry()");

   //
   // Entry points for Port Driver
   //
   HW_INITIALIZATION_DATA  HwInitData;
   RtlZeroMemory( &HwInitData, sizeof( HwInitData ));
   HwInitData.HwInitializationDataSize = sizeof( HwInitData );

   HwInitData.HwInterrupt              = (PHW_INTERRUPT)&HwInterrupt;

   HwInitData.HwReceivePacket          = &AdapterReceivePacket;
   HwInitData.HwCancelPacket           = &AdapterCancelPacket;
   HwInitData.HwRequestTimeoutHandler  = &AdapterTimeoutPacket;

   HwInitData.DeviceExtensionSize      = GetSizeHwDeviceExtension( );
   HwInitData.PerRequestExtensionSize  = sizeof(SRB_EXTENSION);
   HwInitData.FilterInstanceExtensionSize = 0;
   // double to support alternating/interleaved
   HwInitData.PerStreamExtensionSize   = GetSizeStreamEx( );
   HwInitData.BusMasterDMA             = true;
   HwInitData.Dma24BitAddresses        = FALSE;
   HwInitData.BufferAlignment          = 4;
   HwInitData.TurnOffSynchronization   = FALSE;
   HwInitData.DmaBufferSize            = RISCProgramsSize;

   return (StreamClassRegisterAdapter(Arg1, Arg2,&HwInitData));
}

/******************************************************************************

                   Adapter Based Request Handling Routines

******************************************************************************/
/*
** HwInitialize()
**
**   This routine is called when an SRB_INITIALIZE_DEVICE request is received
**
** Arguments:
**
**   pSrb - pointer to stream request block for the Initialize command
**
** Returns:
**
** Side Effects:  none
*/
BOOLEAN HwInitialize( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("HwInitialize()");

   DebugOut((1, "HwInitialize()\n"));

   // initialize ourselves

   PPORT_CONFIGURATION_INFORMATION ConfigInfo = 
      pSrb->CommandData.ConfigInfo;

   gpHwDeviceExtension = ConfigInfo->HwDeviceExtension;
   DebugOut((0, "*** gpHwDeviceExtension = %x\n", gpHwDeviceExtension));

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) gpHwDeviceExtension;

   DWORD dwBase = ConfigInfo->AccessRanges[0].RangeStart.LowPart;
   SetBase((BYTE *)dwBase);

   if ( ConfigInfo->NumberOfAccessRanges != 1 ) {
      DebugOut((1, "illegal config info\n"));
      pSrb->Status = STATUS_NO_SUCH_DEVICE;
   }

   // read info from the registry
   ReadXBarRegistryValues( ConfigInfo->PhysicalDeviceObject );
   ReadXTalRegistryValues( ConfigInfo->PhysicalDeviceObject );
   ReadTunerRegistryValues( ConfigInfo->PhysicalDeviceObject );

   HwDeviceExtension->psdevice =
      new ( &(HwDeviceExtension->psdevicemem) ) PsDevice( dwBase );

   DebugOut((0, "psdevice = %x\n", HwDeviceExtension->psdevice ));
   DebugOut((0, "&psdevicemem = %x\n", &HwDeviceExtension->psdevicemem ));

   PsDevice *adapter = HwDeviceExtension->psdevice;

   // save for later use when phys address if obtained
   SetCurrentDevice( adapter );

   // make sure initialization is successful
   if ( !adapter->InitOK() ) {
      DebugOut((1, "Error initializing\n"));
      pSrb->Status = STATUS_INSUFFICIENT_RESOURCES;
   }

   // save our PDO
   adapter->PDO = ConfigInfo->PhysicalDeviceObject;

   ConfigInfo->StreamDescriptorSize = sizeof( HW_STREAM_HEADER ) +
      DRIVER_STREAM_COUNT * sizeof( HW_STREAM_INFORMATION );

   DebugOut((1, "Exit : HwInitialize()\n"));

   // go to usual priority, completing the SRB at the same time
   StreamClassCallAtNewPriority( pSrb->StreamObject, HwDeviceExtension, LowToHigh,
      PHW_PRIORITY_ROUTINE( CompleteDeviceSRB ), pSrb );

   return (TRUE);
}

/*
** HwUnInitialize()
**
**   This routine is called when an SRB_UNINITIALIZE_DEVICE request is received
**
** Arguments:
**
**   pSrb - pointer to stream request block for the UnInitialize command
**
** Returns:
**
** Side Effects:  none
*/
void HwUnInitialize( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("HwUnInitialize()");

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   DebugOut((0, "HwUnInitialize - pSrb(%x)\n", pSrb));

   PsDevice *adapter = HwDeviceExtension->psdevice;
   adapter->~PsDevice();
}

/*
** AdapterOpenStream()
**
**   This routine is called when an OpenStream SRB request is received
**
** Arguments:
**
**   pSrb - pointer to stream request block for the Open command
**
** Returns:
**
** Side Effects:  none
*/

VOID AdapterOpenStream( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("AdapterOpenStream()");

   //
   // the stream extension structure is allocated by the stream class driver
   //

   // retrieve the device object pointer
   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   VideoStream StreamNumber = (VideoStream)pSrb->StreamObject->StreamNumber;
   StreamIdxToSrb[StreamNumber] = pSrb;

   DebugOut((1, "AdapterOpenStream(%d) - pSrb(%x)\n", StreamNumber, pSrb));

   // [STRM] [!!!]
   //if ( !( StreamNumber >= VS_Field1 && StreamNumber <= DRIVER_STREAM_COUNT ) ) {
   //   pSrb->Status = STATUS_INVALID_PARAMETER; // ?change to the proper error code?
   //   return;
   //}
   
   if ( StreamNumber == STREAM_IDX_ANALOG )   // [TMZ] [!!] was 3
   {
      pSrb->StreamObject->ReceiveDataPacket    = AnalogReceiveDataPacket;
      pSrb->StreamObject->ReceiveControlPacket = AnalogReceiveCtrlPacket;
      return; // nothing to do for the analog stream
   }
   PSTREAMEX pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
   RtlZeroMemory( &pStrmEx->FrameInfo, sizeof( pStrmEx->FrameInfo ) );
   pStrmEx->StreamNumber = StreamNumber;

   // size of the media specific data
   UINT MediaSpecific = sizeof( KS_FRAME_INFO );

   // Always open VBI stream as Alternating fields
   if ( StreamNumber == STREAM_IDX_VBI ) 
	{
      const KS_DATAFORMAT_VBIINFOHEADER &rKSVBIDataFormat =
         *(PKS_DATAFORMAT_VBIINFOHEADER) pSrb->CommandData.OpenFormat;

      if ( VerifyVBIStream( rKSVBIDataFormat ) != Success )
		{
         DebugOut((0, "*** VerifyVBIStream failed - aborting\n"));
         pSrb->Status = STATUS_INVALID_PARAMETER; // ?change to the proper error code?
         return;
      }
      if ( adapter->OpenVBIChannel( pStrmEx ) != Success )
      {
         DebugOut((0, "*** OpenVBIChannel failed - aborting\n"));
         pSrb->Status = STATUS_INVALID_PARAMETER; // ?change to the proper error code?
         return;
      }

      VBIAlterChannel *chan = (VBIAlterChannel *)pStrmEx->videochannel;
      //chan->pStrmEx = pStrmEx;
      chan->SetVidHdr( rKSVBIDataFormat );

      MediaSpecific = sizeof( KS_VBI_FRAME_INFO );

   } 
	else 
	{

      // is it where the size, fourcc, etc. are specified ? they should be settable
      // via properies sets
      const KS_DATAFORMAT_VIDEOINFOHEADER &rKSDataFormat = *(PKS_DATAFORMAT_VIDEOINFOHEADER) pSrb->CommandData.OpenFormat;
      const KS_VIDEOINFOHEADER &rVideoInfoHdrRequested = rKSDataFormat.VideoInfoHeader;
      const KS_DATAFORMAT_VIDEOINFOHEADER2 &rKSDataFormat2 = *(PKS_DATAFORMAT_VIDEOINFOHEADER2) pSrb->CommandData.OpenFormat;
      const KS_VIDEOINFOHEADER2 &rVideoInfoHdrRequested2 = rKSDataFormat2.VideoInfoHeader2;

      DebugOut((1, "AdapterOpenStream\n"));
      if ( IsEqualGUID( rKSDataFormat.DataFormat.Specifier, KSDATAFORMAT_SPECIFIER_VIDEOINFO ) ) 
		{
			DebugOut((1, "StreamNumber=%d\n", pSrb->StreamObject->StreamNumber));
			DebugOut((1, "FormatSize=%d\n", rKSDataFormat.DataFormat.FormatSize));
			DebugOut((1, "MajorFormat=%x\n", rKSDataFormat.DataFormat.MajorFormat));
			DebugOut((1, "pVideoInfoHdrRequested=%x\n", &rVideoInfoHdrRequested));
			DebugOut((1, "Bpp =%d\n", rVideoInfoHdrRequested.bmiHeader.biBitCount ) );
			DebugOut((1, "Width =%d\n", rVideoInfoHdrRequested.bmiHeader.biWidth));
			DebugOut((1, "Height =%d\n", rVideoInfoHdrRequested.bmiHeader.biHeight));
			DebugOut((1, "biSizeImage =%d\n", rVideoInfoHdrRequested.bmiHeader.biSizeImage));
			if ( VerifyVideoStream( rKSDataFormat ) != Success ) 
			{
				pSrb->Status = STATUS_INVALID_PARAMETER; // ?change to the proper error code?
				return;
			}
		}
		else
		{
			DebugOut((1, "StreamNumber=%d\n", pSrb->StreamObject->StreamNumber));
			DebugOut((1, "FormatSize=%d\n", rKSDataFormat2.DataFormat.FormatSize));
			DebugOut((1, "MajorFormat=%x\n", rKSDataFormat2.DataFormat.MajorFormat));
			DebugOut((1, "pVideoInfoHdrRequested2=%x\n", &rVideoInfoHdrRequested2));
			DebugOut((1, "Bpp =%d\n", rVideoInfoHdrRequested2.bmiHeader.biBitCount ) );
			DebugOut((1, "Width =%d\n", rVideoInfoHdrRequested2.bmiHeader.biWidth));
			DebugOut((1, "Height =%d\n", rVideoInfoHdrRequested2.bmiHeader.biHeight));
			DebugOut((1, "biSizeImage =%d\n", rVideoInfoHdrRequested2.bmiHeader.biSizeImage));
			if ( VerifyVideoStream2( rKSDataFormat2 ) != Success ) 
			{
				pSrb->Status = STATUS_INVALID_PARAMETER; // ?change to the proper error code?
				return;
			}
		}

      // at this point have to see what type of channel is to be opened:
      // single field, alternating or interleaved
      // algorithm is like this:
      // 1. look at the video format Specifier guid. If it's a infoheader2, it
      //    will tell us type of stream to open.
      // 2. else look at the vertical size to decide single field vs. interleaved

      if ( IsEqualGUID( rKSDataFormat.DataFormat.Specifier, KSDATAFORMAT_SPECIFIER_VIDEOINFO ) ) 
		{

         MSize size;

         GetRequestedSize( rVideoInfoHdrRequested, size );

         // different video standards have different vertical sizes
         int threshold = adapter->GetFormat() == VFormat_NTSC ? 240 : 288;

         if ( size.cy > threshold ) 
			{
            if ( adapter->OpenInterChannel( pStrmEx, StreamNumber ) != Success ) 
				{
               pSrb->Status = STATUS_INVALID_PARAMETER; // ?change to the proper error code?
               return;
            }
         } 
			else 
			{
            if ( adapter->OpenChannel( pStrmEx, StreamNumber ) != Success ) 
				{
               pSrb->Status = STATUS_INVALID_PARAMETER; // ?change to the proper error code?
               return;
            }
         }
			VideoChannel *chan = (VideoChannel *)pStrmEx->videochannel;
         //chan->pStrmEx = pStrmEx;
			chan->SetVidHdr( rVideoInfoHdrRequested );
      }
      else if ( IsEqualGUID( rKSDataFormat2.DataFormat.Specifier, KSDATAFORMAT_SPECIFIER_VIDEOINFO2 ) ) 
		{
         MSize size;
         GetRequestedSize2( rVideoInfoHdrRequested2, size );

         // different video standards have different vertical sizes
         int threshold = adapter->GetFormat() == VFormat_NTSC ? 240 : 288;

         if ( size.cy > threshold ) 
			{
            if ( adapter->OpenInterChannel( pStrmEx, StreamNumber ) != Success ) 
				{
               pSrb->Status = STATUS_INVALID_PARAMETER; // ?change to the proper error code?
               return;
            }
         } 
			else 
			{
            if ( adapter->OpenChannel( pStrmEx, StreamNumber ) != Success ) 
				{
               pSrb->Status = STATUS_INVALID_PARAMETER; // ?change to the proper error code?
               return;
            }
         }
			VideoChannel *chan = (VideoChannel *)pStrmEx->videochannel;
         //chan->pStrmEx = pStrmEx;
			chan->SetVidHdr2( rVideoInfoHdrRequested2 );
      } 
		else 
		{
         if ( adapter->OpenInterChannel( pStrmEx, StreamNumber ) != Success ) 
			{
            pSrb->Status = STATUS_INVALID_PARAMETER; // ?change to the proper error code?
            return;
         }
         if ( adapter->OpenAlterChannel( pStrmEx, StreamNumber ) != Success ) 
			{
            pSrb->Status = STATUS_INVALID_PARAMETER; // ?change to the proper error code?
            return;
         }
         // [WRK] - check the height of the image for alter channel !> threshold
			VideoChannel *chan = (VideoChannel *)pStrmEx->videochannel;
         //chan->pStrmEx = pStrmEx;
			chan->SetVidHdr( rVideoInfoHdrRequested );
      }
   }

#ifdef ENABLE_DDRAW_STUFF
	//TODO: should we check to see what kind of stream type this is?
	if( OpenKernelDirectDraw( pSrb ) )
	{
		OpenKernelDDrawSurfaceHandle( pSrb );
		RegisterForDirectDrawEvents( pSrb ); 
	}
#endif

   // the structure of the driver is such that a single callback could be used
   // for all stream requests. But the code below could be used to supply
   // different entry points for different streams
   pSrb->StreamObject->ReceiveDataPacket    = VideoReceiveDataPacket;
   pSrb->StreamObject->ReceiveControlPacket = VideoReceiveCtrlPacket;

   pSrb->StreamObject->Dma = true;

   pSrb->StreamObject->Allocator = Streams[StreamNumber].hwStreamObject.Allocator;

   //
   // The PIO flag must be set when the mini driver will be accessing the data
   // buffers passed in using logical addressing
   //

   pSrb->StreamObject->Pio = true;
   pSrb->StreamObject->StreamHeaderMediaSpecific = MediaSpecific;
   pSrb->StreamObject->HwClockObject.ClockSupportFlags = 0;
   pSrb->StreamObject->HwClockObject.HwClockFunction = 0;

   DebugOut((1, "AdapterOpenStream Exit\n"));
}

/*
** AdapterCloseStream()
**
**   Close the requested data stream
**
** Arguments:
**
**   pSrb the request block requesting to close the stream
**
** Returns:
**
** Side Effects:  none
*/

VOID AdapterCloseStream( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("AdapterCloseStream()");

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;
   VideoChannel *chan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;
   VideoStream StreamNumber = (VideoStream)pSrb->StreamObject->StreamNumber;

   DebugOut((1, "AdapterCloseStream(%d) - pSrb(%x)\n", StreamNumber, pSrb));

   if ( !( StreamNumber >= 0 && StreamNumber < DRIVER_STREAM_COUNT ) ) {
      DebugOut((0, "   AdapterCloseStream - failed to close stream %d\n", StreamNumber));
      DEBUG_BREAKPOINT();
      pSrb->Status = STATUS_INVALID_PARAMETER; // ?change to the proper error code?
      return;
   }
   if ( StreamNumber == STREAM_IDX_ANALOG ) // nothing to close for analog
   {
      DebugOut((1, "   AdapterCloseStream - doing nothing, stream (%d) was assumed to be analog\n", StreamNumber));
      return;
   }
#ifdef ENABLE_DDRAW_STUFF
	//TODO: should we check to see what kind of stream type this is?
	UnregisterForDirectDrawEvents( pSrb );
	CloseKernelDDrawSurfaceHandle( pSrb );
	CloseKernelDirectDraw( pSrb );
#endif

   // CloseChannel() has a bit of ugly code to take care of paired channels
   adapter->CloseChannel( chan );
}

/*
** AdapterStreamInfo()
**
**   Returns the information of all streams that are supported by the
**   mini-driver
**
** Arguments:
**
**   pSrb - Pointer to the STREAM_REQUEST_BLOCK
**        pSrb->HwDeviceExtension - will be the hardware device extension for
**                                  as initialised in HwInitialise
**
** Returns:
**
** Side Effects:  none
*/

VOID AdapterStreamInfo( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("AdapterStreamInfo()");

   //
   // pick up the pointer to header which preceeds the stream info structs
   //

   PHW_STREAM_HEADER pstrhdr =
      (PHW_STREAM_HEADER)&(pSrb->CommandData.StreamBuffer->StreamHeader);

   //
   // pick up the pointer to the stream information data structure
   //

   PHW_STREAM_INFORMATION pstrinfo =
       (PHW_STREAM_INFORMATION)&(pSrb->CommandData.StreamBuffer->StreamInfo);

   //
   // verify that the buffer is large enough to hold our return data
   //
   DEBUG_ASSERT( pSrb->NumberOfBytesToTransfer >=
      sizeof( HW_STREAM_HEADER ) +
      sizeof( HW_STREAM_INFORMATION ) * DRIVER_STREAM_COUNT );


     //
     // Set the header
     //
   StreamHeader.NumDevPropArrayEntries = NUMBER_OF_ADAPTER_PROPERTY_SETS;
   StreamHeader.DevicePropertiesArray  = (PKSPROPERTY_SET) AdapterPropertyTable;
   *pstrhdr = StreamHeader;

   //
   // stuff the contents of each HW_STREAM_INFORMATION struct
   //

   for ( int j = 0; j < DRIVER_STREAM_COUNT; j++ ) {
      *pstrinfo++ = Streams[j].hwStreamInfo;
   }

}
#ifdef HAUPPAUGEI2CPROVIDER

// new private members of PsDevice for Hauppauge I2C Provider:
//    LARGE_INTEGER LastI2CAccessTime;
//    DWORD       dwExpiredCookie = 0;
//
//

/* Method: PsDevice::I2COpen
 * Purpose: Tries to allocate I2C port to the caller
 */
NTSTATUS STDMETHODCALLTYPE PsDevice::I2COpen( PDEVICE_OBJECT pdo, ULONG ToOpen, PI2CControl ctrl )
{
   Trace t("PsDevice::I2COpen()");

   DebugOut((1, "*** pdo->DeviceExtension = %x\n", pdo->DeviceExtension));
   
   LARGE_INTEGER CurTime;

   // need a way to obtain the device pointer
   PsDevice *adapter = GetCurrentDevice();

   KeQuerySystemTime( &CurTime );

   ctrl->Status = I2C_STATUS_NOERROR;

   // cookie is not NULL if I2C is open
   if ( ToOpen && adapter->dwCurCookie_ ) {
//   Check time stamp against current time to detect if current Cookie has timed out.
//    If it has remember the last timed out cookie and grant the new requestor access.
      if ( ( adapter->dwI2CClientTimeout != 0 ) && ( (CurTime - adapter->LastI2CAccessTime) >  adapter->dwI2CClientTimeout ) ) {
         adapter->dwExpiredCookie = adapter->dwCurCookie_;
      } else {
         ctrl->dwCookie = 0;
         return STATUS_INVALID_HANDLE;
     }
   }

   // want to close ?
   if ( !ToOpen ) {
      if ( adapter->dwCurCookie_ == ctrl->dwCookie ) {
         adapter->dwCurCookie_ = 0;
         ctrl->dwCookie = 0;
         return STATUS_SUCCESS;
      } else {
         if ( (adapter->dwExpiredCookie != 0 ) && (adapter->dwExpiredCookie == ctrl->dwCookie ) ) {
            ctrl->Status = I2C_STATUS_ERROR;
         } else {
            ctrl->dwCookie = 0;
            ctrl->Status = I2C_STATUS_NOERROR;
         }
         return STATUS_INVALID_HANDLE;
      }
   }

   adapter->dwCurCookie_ = CurTime.LowPart;
   adapter->LastI2CAccessTime = CurTime;
   ctrl->dwCookie = adapter->dwCurCookie_;
   ctrl->ClockRate = 100000;

   return STATUS_SUCCESS;
}

NTSTATUS STDMETHODCALLTYPE PsDevice::I2CAccess( PDEVICE_OBJECT pdo, PI2CControl ctrl )
{
   Trace t("PsDevice::I2CAccess()");

   DebugOut((1, "*** pdo->DeviceExtension = %x\n", pdo->DeviceExtension));
   
   ErrorCode error;
   PsDevice *adapter = GetCurrentDevice();

   ctrl->Status = I2C_STATUS_NOERROR;

   if ( ctrl->dwCookie != adapter->dwCurCookie_ ) {
      if ( (adapter->dwExpiredCookie != 0 ) && (adapter->dwExpiredCookie == ctrl->dwCookie ) )
         ctrl->Status = I2C_STATUS_ERROR;
      else
         ctrl->Status = I2C_STATUS_NOERROR;
      return STATUS_INVALID_HANDLE;
   }

// Record time of this transaction to enable checking for timeout
   KeQuerySystemTime( &adapter->LastI2CAccessTime );

// Check for valid combinations of I2C command & flags

   switch( ctrl->Command ) {
   case I2C_COMMAND_NULL:
     if ( ( ctrl->Flags & ~(I2C_FLAGS_START | I2C_FLAGS_STOP) ) ||
           ( ( ctrl->Flags & (I2C_FLAGS_START | I2C_FLAGS_STOP) ) == (I2C_FLAGS_START | I2C_FLAGS_STOP) ) ) {
        // Illegal combination of Command & Flags
        return STATUS_INVALID_PARAMETER;
     }
     if ( ctrl->Flags & I2C_FLAGS_START ) {
         if ( adapter->I2CSWStart() ) {
            ctrl->Status = I2C_STATUS_ERROR;
           return STATUS_SUCCESS;
         }
      }
     if ( ctrl->Flags & I2C_FLAGS_STOP ) {
         if ( adapter->I2CSWStop() ) {
            ctrl->Status = I2C_STATUS_ERROR;
           return STATUS_SUCCESS;
         }
      }
      break;

   case I2C_COMMAND_READ:
     if ( ctrl->Flags & ~(I2C_FLAGS_STOP | I2C_FLAGS_ACK) ) {
        // Illegal combination of Command & Flags
        return STATUS_INVALID_PARAMETER;
     }
      if ( adapter->I2CSWRead( &ctrl->Data ) ) {
            ctrl->Status = I2C_STATUS_ERROR;
           return STATUS_SUCCESS;
      }
     if ( ctrl->Flags & I2C_FLAGS_ACK ) {
         if ( adapter->I2CSWSendACK() ) {
            ctrl->Status = I2C_STATUS_ERROR;
           return STATUS_SUCCESS;
         }
     } else {
         if ( adapter->I2CSWSendNACK() ) {
            ctrl->Status = I2C_STATUS_ERROR;
           return STATUS_SUCCESS;
         }
      }
     if ( ctrl->Flags & I2C_FLAGS_STOP ) {
         if ( adapter->I2CSWStop() ) {
            ctrl->Status = I2C_STATUS_ERROR;
           return STATUS_SUCCESS;
         }
      }
     break;

   case I2C_COMMAND_WRITE:
     if ( ctrl->Flags & ~(I2C_FLAGS_START | I2C_FLAGS_STOP | I2C_FLAGS_ACK | I2C_FLAGS_DATACHAINING) ) {
        // Illegal combination of Command & Flags
        return STATUS_INVALID_PARAMETER;
     }
     if ( ctrl->Flags & I2C_FLAGS_DATACHAINING ) {
         if ( adapter->I2CSWStop() ) {
            ctrl->Status = I2C_STATUS_ERROR;
           return STATUS_SUCCESS;
         }
         if ( adapter->I2CSWStart() ) {
            ctrl->Status = I2C_STATUS_ERROR;
           return STATUS_SUCCESS;
         }
      }
     if ( ctrl->Flags & I2C_FLAGS_START ) {
         if ( adapter->I2CSWStart() ) {
            ctrl->Status = I2C_STATUS_ERROR;
           return STATUS_SUCCESS;
         }
      }
      error = adapter->I2CSWWrite(ctrl->Data);

      switch ( error ) {

     case I2CERR_NOACK:
         if ( ctrl->Flags & I2C_FLAGS_ACK ) {
            ctrl->Status = I2C_STATUS_ERROR;
           return STATUS_SUCCESS;
         }
       break;

     case I2CERR_OK:
         if ( ( ctrl->Flags & I2C_FLAGS_ACK ) == 0 ) {
            ctrl->Status = I2C_STATUS_ERROR;
           return STATUS_SUCCESS;
         }
       break;

      default:
         ctrl->Status = I2C_STATUS_ERROR;
         return STATUS_SUCCESS;
      }

     if ( ctrl->Flags & I2C_FLAGS_STOP ) {
         if ( adapter->I2CSWStop() ) {
            ctrl->Status = I2C_STATUS_ERROR;
           return STATUS_SUCCESS;
         }
      }
     break;

   case I2C_COMMAND_STATUS:
     // Flags are ignored
     return STATUS_NOT_IMPLEMENTED;

   case I2C_COMMAND_RESET:
        // Flags are ignored
      if ( adapter->I2CSWStart() ) {
         ctrl->Status = I2C_STATUS_ERROR;
        return STATUS_SUCCESS;
      }
      if ( adapter->I2CSWStop() ) {
         ctrl->Status = I2C_STATUS_ERROR;
        return STATUS_SUCCESS;
      }
     break;

   default:
     return STATUS_INVALID_PARAMETER;
   }
   return STATUS_SUCCESS;
}

#else


/* Method: PsDevice::I2COpen
 * Purpose: Tries to allocate I2C port to the caller
 */
NTSTATUS STDMETHODCALLTYPE PsDevice::I2COpen( PDEVICE_OBJECT pdo, ULONG ToOpen,
   PI2CControl ctrl )
{
   Trace t("PsDevice::I2COpen()");

   DebugOut((1, "*** pdo->DeviceExtension = %x\n", pdo->DeviceExtension));
   
   // need a way to obtain the device pointer
   PsDevice *adapter = GetCurrentDevice();

   // cookie is not NULL if I2C is open
   if ( ToOpen && adapter->dwCurCookie_ ) {
      ctrl->Flags = I2C_STATUS_BUSY;
      return STATUS_DEVICE_BUSY;
   }

   // want to close ?
   if ( !ToOpen )
      if ( adapter->dwCurCookie_ == ctrl->dwCookie ) {
         adapter->dwCurCookie_ = 0;
         return STATUS_SUCCESS;
      } else {
         ctrl->Flags = I2C_STATUS_BUSY;
         return STATUS_DEVICE_BUSY;
      }

   // now we are opening
   LARGE_INTEGER CurTime;
   KeQuerySystemTime( &CurTime );

   adapter->dwCurCookie_ = CurTime.LowPart;
   ctrl->dwCookie = adapter->dwCurCookie_;
   ctrl->ClockRate = 100000;

   return STATUS_SUCCESS;
}

NTSTATUS STDMETHODCALLTYPE PsDevice::I2CAccess( PDEVICE_OBJECT pdo , PI2CControl ctrl )
{
   Trace t("PsDevice::I2CAccess()");

   DebugOut((1, "*** pdo->DeviceExtension = %x\n", pdo->DeviceExtension));
   
   PsDevice *adapter = GetCurrentDevice();

   if ( ctrl->dwCookie != adapter->dwCurCookie_ ) {
      ctrl->Flags = I2C_STATUS_BUSY;
      return I2C_STATUS_BUSY;
   }

   ctrl->Flags = I2C_STATUS_NOERROR;

  // 848 I2C API currently needs to have an address for both write and read
  // commands. So, if START flag is set an address is passed. Cache it and use
  // later
   switch ( ctrl->Command ) {
   case I2C_COMMAND_READ:
      // got 'write' command first ( with the address )
      if ( adapter->I2CHWRead( adapter->GetI2CAddress(), &ctrl->Data ) != Success )
         ctrl->Flags = I2C_STATUS_ERROR;
      break;
   case I2C_COMMAND_WRITE:
      if ( ctrl->Flags & I2C_FLAGS_START ) {
         adapter->StoreI2CAddress( ctrl->Data );
      } else
         adapter->I2CHWWrite2( adapter->GetI2CAddress(), ctrl->Data );
      break;
   case I2C_COMMAND_STATUS:
      if ( adapter->I2CGetLastError() != I2CERR_OK )
         ctrl->Flags = I2C_STATUS_ERROR;
      break;
   case I2C_COMMAND_RESET:
      adapter->I2CInitHWMode( 100000 );    // assume frequency = 100Khz
      break;
   }
   return STATUS_SUCCESS;
}

#endif

void  HandleIRP( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("HandleIRP()");

   DebugOut((1, "HandleIRP(%x)\n", pSrb));

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   PIRP Irp = pSrb->Irp;
   PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation( Irp );
   switch ( IrpStack->MajorFunction ) {
   case IRP_MJ_PNP:
      if ( IrpStack->MinorFunction == IRP_MN_QUERY_INTERFACE ) {

         if ( IsEqualGUID( *IrpStack->Parameters.QueryInterface.InterfaceType,
              GUID_I2C_INTERFACE ) &&
              IrpStack->Parameters.QueryInterface.Size >= sizeof( I2CINTERFACE ) ) {

            IrpStack->Parameters.QueryInterface.InterfaceType = &GUID_I2C_INTERFACE;
            IrpStack->Parameters.QueryInterface.Size = sizeof( I2CINTERFACE );
            IrpStack->Parameters.QueryInterface.Version = 1;
            I2CINTERFACE *i2ciface =
            (I2CINTERFACE *)IrpStack->Parameters.QueryInterface.Interface;
            i2ciface->i2cOpen   = &PsDevice::I2COpen;
            i2ciface->i2cAccess = &PsDevice::I2CAccess;
            IrpStack->Parameters.QueryInterface.InterfaceSpecificData = 0;

            // complete the irp
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );

            break;
         } else {
            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER_1;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
         }
      }
   default:
       pSrb->Status = STATUS_NOT_SUPPORTED;
   }
}

/** CompleteInitialization()
**
**   This routine is called when an SRB_COMPLETE_INITIALIZATION request is received
**
** Arguments:
**
**   pSrb - pointer to stream request block
**
** Returns:
**
** Side Effects:  none
*/
void STDMETHODCALLTYPE CompleteInitialization( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("CompleteInitialization()");

   NTSTATUS                Status;
   
   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

    // Create the Registry blobs that DShow uses to create
    // graphs via Mediums

    Status = StreamClassRegisterFilterWithNoKSPins (
                    adapter->PDO,                   // IN PDEVICE_OBJECT   DeviceObject,
                    &KSCATEGORY_TVTUNER,            // IN GUID           * InterfaceClassGUID,
                    SIZEOF_ARRAY (TVTunerMediums),  // IN ULONG            PinCount,
                    TVTunerPinDirection,            // IN ULONG          * Flags,
                    TVTunerMediums,                 // IN KSPIN_MEDIUM   * MediumList,
                    NULL                            // IN GUID           * CategoryList
            );

    Status = StreamClassRegisterFilterWithNoKSPins (
                    adapter->PDO,                   // IN PDEVICE_OBJECT   DeviceObject,
                    &KSCATEGORY_CROSSBAR,           // IN GUID           * InterfaceClassGUID,
                    SIZEOF_ARRAY (CrossbarMediums), // IN ULONG            PinCount,
                    CrossbarPinDirection,           // IN ULONG          * Flags,
                    CrossbarMediums,                // IN KSPIN_MEDIUM   * MediumList,
                    NULL                            // IN GUID           * CategoryList
            );

    // Register the TVAudio decoder

    Status = StreamClassRegisterFilterWithNoKSPins (
                    adapter->PDO,                   // IN PDEVICE_OBJECT   DeviceObject,
                    &KSCATEGORY_TVAUDIO,            // IN GUID           * InterfaceClassGUID,
                    SIZEOF_ARRAY (TVAudioMediums),  // IN ULONG            PinCount,
                    TVAudioPinDirection,            // IN ULONG          * Flags,
                    TVAudioMediums,                 // IN KSPIN_MEDIUM   * MediumList,
                    NULL                            // IN GUID           * CategoryList
            );

    // Register the Capture filter
    // Note:  This should be done automatically be MSKsSrv.sys,
    // when that component comes on line (if ever) ...

    Status = StreamClassRegisterFilterWithNoKSPins (
                    adapter->PDO,                   // IN PDEVICE_OBJECT   DeviceObject,
                    &KSCATEGORY_CAPTURE,            // IN GUID           * InterfaceClassGUID,
                    SIZEOF_ARRAY (CaptureMediums),  // IN ULONG            PinCount,
                    CapturePinDirection,            // IN ULONG          * Flags,
                    CaptureMediums,                 // IN KSPIN_MEDIUM   * MediumList,
                    CaptureCategories               // IN GUID           * CategoryList
            );


   // go to usual priority, completing the SRB at the same time
   StreamClassCallAtNewPriority( pSrb->StreamObject, HwDeviceExtension, LowToHigh,
      PHW_PRIORITY_ROUTINE( CompleteDeviceSRB ), pSrb );
}


/*
** AdapterReceivePacket()
**
**   Main entry point for receiving adapter based request SRBs.  This routine
**   will always be called at High Priority.
**
**   Note: This is an asyncronous entry point.  The request does not complete
**         on return from this function, the request only completes when a
**         StreamClassDeviceNotification on this request block, of type
**         DeviceRequestComplete, is issued.
**
** Arguments:
**
**   pSrb - Pointer to the STREAM_REQUEST_BLOCK
**        pSrb->HwDeviceExtension - will be the hardware device extension for
**                                  as initialised in HwInitialise
**
** Returns:
**
** Side Effects:  none
*/

VOID STREAMAPI AdapterReceivePacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{

      Trace t("AdapterReceivePacket()");

   BOOL CompleteRequestSynchronously = TRUE;

   //default to success
   pSrb->Status = STATUS_SUCCESS;

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;
   
   //
   // determine the type of packet.
   //

   DebugOut((1, "'AdapterReceivePacket(%x) cmd(%x)\n", pSrb, pSrb->Command));

   switch ( pSrb->Command )  {
   case SRB_INITIALIZE_DEVICE:
      DebugOut((1, "   SRB_INITIALIZE_DEVICE\n"));

      CompleteRequestSynchronously = FALSE;
      // have to schedule a low priority call to open the device because
      // registry functions are used during initialization

      StreamClassCallAtNewPriority( pSrb->StreamObject, pSrb->HwDeviceExtension,
         Low, PHW_PRIORITY_ROUTINE( HwInitialize ), pSrb );

      break;

   case SRB_UNINITIALIZE_DEVICE:
      DebugOut((1, "   SRB_UNINITIALIZE_DEVICE\n"));

      // close the device.

      HwUnInitialize(pSrb);

      break;

   case SRB_OPEN_STREAM:
      DebugOut((1, "   SRB_OPEN_STREAM\n"));

      // open a stream

      AdapterOpenStream( pSrb );

      break;

   case SRB_CLOSE_STREAM:
      DebugOut((1, "   SRB_CLOSE_STREAM\n"));

      // close a stream

      AdapterCloseStream( pSrb );

      break;

   case SRB_GET_STREAM_INFO:
      DebugOut((1, "   SRB_GET_STREAM_INFO\n"));

      //
      // return a block describing all the streams
      //

      AdapterStreamInfo(pSrb);

      break;

   case SRB_GET_DEVICE_PROPERTY:
      DebugOut((1, "   SRB_GET_DEVICE_PROPERTY\n"));
      AdapterGetProperty( pSrb );
      break;

   case SRB_SET_DEVICE_PROPERTY:
      DebugOut((1, "   SRB_SET_DEVICE_PROPERTY\n"));
      AdapterSetProperty( pSrb );
      break;

   case SRB_GET_DATA_INTERSECTION:
      DebugOut((1, "   SRB_GET_DATA_INTERSECTION\n"));

      //
      // Return a format, given a range
      //

      AdapterFormatFromRange( pSrb );

      break;
    case SRB_INITIALIZATION_COMPLETE:
      DebugOut((1, "   SRB_INITIALIZATION_COMPLETE\n"));

        //
        // Stream class has finished initialization.
        // Now create DShow Medium interface BLOBs.
        // This needs to be done at low priority since it uses the registry, so use a callback
        //
        CompleteRequestSynchronously = FALSE;

        StreamClassCallAtNewPriority( NULL /*pSrb->StreamObject*/, pSrb->HwDeviceExtension,
            Low, PHW_PRIORITY_ROUTINE( CompleteInitialization), pSrb );

        break;

   case SRB_PAGING_OUT_DRIVER:
      if ( (*(DWORD*)(gpjBaseAddr+0x10c) & 3) || (*(DWORD*)(gpjBaseAddr+0x104)) )
      {
         DebugOut((0,  "   ****** SRB_PAGING_OUT_DRIVER ENB(%x) MSK(%x)\n",
                     *(DWORD*)(gpjBaseAddr+0x10c) & 3,
                     *(DWORD*)(gpjBaseAddr+0x104)
         ));

         *(DWORD*)(gpjBaseAddr+0x10c) &= ~3;    // disable interrupts   [TMZ] [!!!]
         *(DWORD*)(gpjBaseAddr+0x104) = 0;      // disable interrupts   [TMZ] [!!!]
      }
      break;

   case SRB_UNKNOWN_DEVICE_COMMAND:
      DebugOut((1, "   SRB_UNKNOWN_DEVICE_COMMAND\n"));
      HandleIRP( pSrb );
      break;

    // We should never get the following 2 since this is a single instance
    // device
   case SRB_OPEN_DEVICE_INSTANCE:
   case SRB_CLOSE_DEVICE_INSTANCE:
   default:
       //
       // this is a request that we do not understand.  Indicate invalid
       // command and complete the request
       //

       DebugOut((0, "SRB(%x) not recognized by this driver\n", pSrb->Command));
       pSrb->Status = STATUS_NOT_IMPLEMENTED;
   }

   //
   // Most, but not all SRBs are handled synchronously here
   //

   if ( CompleteRequestSynchronously )  {
      CompleteDeviceSRB( pSrb );
   }
}

/*
** AdapterCancelPacket()
**
**   Request to cancel a packet that is currently in process in the minidriver
**
** Arguments:
**
**   pSrb - pointer to request packet to cancel
**
** Returns:
**
** Side Effects:  none
*/

VOID STREAMAPI AdapterCancelPacket( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("AdapterCancelPacket()");

   VideoStream StreamNumber = (VideoStream)pSrb->StreamObject->StreamNumber;

   DebugOut((1, "AdapterCancelPacket - pSrb(%x) strm(%d)\n", pSrb, StreamNumber));

   VideoChannel *chan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;

   pSrb->Status = STATUS_CANCELLED;
   
   //
   // it is necessary to call the request back correctly.  Determine which
   // type of command it is
   //

   switch ( pSrb->Flags & (SRB_HW_FLAGS_DATA_TRANSFER | SRB_HW_FLAGS_STREAM_REQUEST ) ) {
   //
   // find all stream commands, and do stream notifications
   //

   case SRB_HW_FLAGS_STREAM_REQUEST | SRB_HW_FLAGS_DATA_TRANSFER:
      DebugOut((1, "   Canceling data SRB\n" ) );
//      adapter->Stop( *chan );  [!!!] [TMZ] [???] why is this commented out???
      
      if (!chan->RemoveSRB( pSrb ))
      {
         DebugOut((0, "   Canceling data SRB failed\n"));
         DEBUG_BREAKPOINT();
      }
      break;
   case SRB_HW_FLAGS_STREAM_REQUEST:
      DebugOut((1, "   Canceling control SRB\n" ) );
      CheckSrbStatus( pSrb );
      StreamClassStreamNotification( ReadyForNextStreamControlRequest,
         pSrb->StreamObject );
      StreamClassStreamNotification( StreamRequestComplete,
         pSrb->StreamObject, pSrb );
      break;
   default:
      //
      // this must be a device request.  Use device notifications
      //
      DebugOut((1, "   Canceling SRB per device request\n" ) );
      StreamClassDeviceNotification( ReadyForNextDeviceRequest,
         pSrb->HwDeviceExtension );

      StreamClassDeviceNotification( DeviceRequestComplete,
         pSrb->HwDeviceExtension, pSrb );
   }
}

/*
** AdapterTimeoutPacket()
**
**   This routine is called when a packet has been in the minidriver for
**   too long.  The adapter must decide what to do with the packet
**
** Arguments:
**
**   pSrb - pointer to the request packet that timed out
**
** Returns:
**
** Side Effects:  none
*/

VOID STREAMAPI AdapterTimeoutPacket( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("AdapterTimeoutPacket()");

   DebugOut((0, "AdapterTimeoutPacket (incomplete) - pSrb(%x)\n", pSrb));

   // [TMZ] Fix this
   #if SHOW_BUILD_MSGS
      #pragma message("*** AdapterTimeoutPacket needs to be completed")
   #endif

   DebugOut((0, "   pSrb->Flags = %x\n", pSrb->Flags));

   if ( pSrb->Flags & SRB_HW_FLAGS_STREAM_REQUEST )
   {
      DebugOut((0, "                 SRB_HW_FLAGS_STREAM_REQUEST\n"));
   }
   if ( pSrb->Flags & SRB_HW_FLAGS_DATA_TRANSFER )
   {
      DebugOut((0, "                 SRB_HW_FLAGS_DATA_TRANSFER\n"));
   }

   //
   // if we timeout while playing, then we need to consider this
   // condition an error, and reset the hardware, and reset everything
   // as well as cancelling this and all requests
   //


   //
   // if we are not playing, and this is a CTRL request, we still
   // need to reset everything as well as cancelling this and all requests
   //

   //
   // if this is a data request, and the device is paused, we probably have
   // run out of data buffer, and need more time, so just reset the timer,
   // and let the packet continue
   //

   pSrb->TimeoutCounter = pSrb->TimeoutOriginal;
}

/*
** HwInterrupt()
**
**   Routine is called when an interrupt at the IRQ level specified by the
**   ConfigInfo structure passed to the HwInitialize routine is received.
**
**   Note: IRQs may be shared, so the device should ensure the IRQ received
**         was expected
**
** Arguments:
**
**  pHwDevEx - the device extension for the hardware interrupt
**
** Returns:
**
** Side Effects:  none
*/

BOOLEAN HwInterrupt( IN PHW_DEVICE_EXTENSION HwDeviceExtension )
{
   Trace t("HwInterrupt()");
   DebugOut((1, "HwInterrupt called by system\n"));
   PsDevice *adapter = (PsDevice *)(HwDeviceExtension->psdevice);
   BOOLEAN b = adapter->Interrupt();
   return( b );
}

/* Function: CompleteDeviceSRB
 * Purpose: Called to complete a device SRB
 * Input: pSrb
 */
inline void CompleteDeviceSRB( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("CompleteDeviceSRB()");
   StreamClassDeviceNotification( DeviceRequestComplete, pSrb->HwDeviceExtension, pSrb );
   StreamClassDeviceNotification( ReadyForNextDeviceRequest, pSrb->HwDeviceExtension );
}

/*
** AdapterCompareGUIDsAndFormatSize()
**
**   Checks for a match on the three GUIDs and FormatSize
**
** Arguments:
**
**         IN DataRange1
**         IN DataRange2
**
** Returns:
**
**   TRUE if all elements match
**   FALSE if any are different
**
** Side Effects:  none
*/

bool AdapterCompareGUIDsAndFormatSize( IN const PKSDATARANGE DataRange1,
   IN const PKSDATARANGE DataRange2 )
{
   Trace t("AdapterCompareGUIDsAndFormatSize()");

   bool bCheckSize = false;

#if 1 // use old guid verify
   return (
      IsEqualGUID( DataRange1->MajorFormat, DataRange2->MajorFormat ) &&
      IsEqualGUID( DataRange1->SubFormat,   DataRange2->SubFormat   ) &&
      IsEqualGUID( DataRange1->Specifier,   DataRange2->Specifier   ) &&
      ( DataRange1->FormatSize == DataRange2->FormatSize ) );
#else // use new guid verify from cc decoder
   bool rval = false;

   if ( IsEqualGUID(DataRange1->MajorFormat, KSDATAFORMAT_TYPE_WILDCARD)
     || IsEqualGUID(DataRange2->MajorFormat, KSDATAFORMAT_TYPE_WILDCARD)
     || IsEqualGUID(DataRange1->MajorFormat, DataRange2->MajorFormat) )
   {
      if ( !IsEqualGUID(DataRange1->MajorFormat, DataRange2->MajorFormat) )
      {
         DebugOut((0, "Match 1\n" ));
      }

      if ( IsEqualGUID(DataRange1->SubFormat, KSDATAFORMAT_SUBTYPE_WILDCARD)
        || IsEqualGUID(DataRange2->SubFormat, KSDATAFORMAT_SUBTYPE_WILDCARD)
        || IsEqualGUID(DataRange1->SubFormat, DataRange2->SubFormat) )
      {
         if ( !IsEqualGUID(DataRange1->SubFormat, DataRange2->SubFormat) )
         {
            DebugOut((0, "Match 2\n" ));
         }

         if ( IsEqualGUID(DataRange1->Specifier, KSDATAFORMAT_SPECIFIER_WILDCARD)
           || IsEqualGUID(DataRange2->Specifier, KSDATAFORMAT_SPECIFIER_WILDCARD)
           || IsEqualGUID(DataRange1->Specifier, DataRange2->Specifier) )
         {
            if ( !IsEqualGUID(DataRange1->Specifier, DataRange2->Specifier) )
            {
               DebugOut((0, "Match 3\n" ));
            }

            if ( !bCheckSize || DataRange1->FormatSize == DataRange2->FormatSize)
            {
               DebugOut((0, "Victory !!!\n" ));
               rval = true;
            }
            else
            {
               DebugOut((0, "FormatSize Mismatch\n" ));
            }
         }
         else
         {
            DebugOut((0, "Specifier Mismatch\n" ));
         }
      }
      else
      {
         DebugOut((0, "SubFormat Mismatch\n" ));
      }
   }
   else
   {
      DebugOut((0, "MajorFormat Mismatch\n" ));
   }

   DebugOut((0, "CompareGUIDsAndFormatSize(\n"));
   DebugOut((0, "   DataRange1=%x\n", DataRange1));
   DebugOut((0, "   DataRange2=%x\n", DataRange2));
   DebugOut((0, "   bCheckSize=%s\n", bCheckSize ? "TRUE":"FALSE"));
   DebugOut((0, ")\n"));
   DebugOut((0, "returning %s\n", rval? "TRUE":"FALSE"));

   return rval;
#endif
}

/*
** AdapterFormatFromRange()
**
**   Returns a DATAFORMAT from a DATARANGE
**
** Arguments:
**
**         IN PHW_STREAM_REQUEST_BLOCK pSrb
**
** Returns:
**
**   TRUE if the format is supported
**   FALSE if the format cannot be suppored
**
** Side Effects:  none
*/
void AdapterFormatFromRange( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("AdapterFormatFromRange()");

   PSTREAM_DATA_INTERSECT_INFO IntersectInfo;
   PKSDATARANGE                DataRange;
   ULONG                       FormatSize=0;
   ULONG                       StreamNumber;
   ULONG                       j;
   ULONG                       NumberOfFormatArrayEntries;
   PKSDATAFORMAT               *pAvailableFormats;

   IntersectInfo = pSrb->CommandData.IntersectInfo;
   StreamNumber = IntersectInfo->StreamNumber;
   DataRange = IntersectInfo->DataRange;

   //
   // Check that the stream number is valid
   //

   if( StreamNumber >= DRIVER_STREAM_COUNT ) 
	{
      pSrb->Status = STATUS_NOT_IMPLEMENTED;
      return;
   }

   NumberOfFormatArrayEntries =
           Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

   //
   // Get the pointer to the array of available formats
   //

   pAvailableFormats = Streams[StreamNumber].hwStreamInfo.StreamFormatsArray;

   //
   // Is the caller trying to get the format, or the size of the format?
   //

   bool OnlyWantsSize = (IntersectInfo->SizeOfDataFormatBuffer == sizeof( ULONG ) );

   //
   // Walk the formats supported by the stream searching for a match
   // of the three GUIDs which together define a DATARANGE
   //

   for ( j = 0; j < NumberOfFormatArrayEntries; j++, pAvailableFormats++ ) 
	{

      if ( !AdapterCompareGUIDsAndFormatSize( DataRange, *pAvailableFormats ) ) 
		{
          continue;
      }

      //
      // Now that the three GUIDs match, switch on the Specifier
      // to do a further type specific check
      //

      // -------------------------------------------------------------------
      // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
      // -------------------------------------------------------------------

      if ( IsEqualGUID( DataRange->Specifier, KSDATAFORMAT_SPECIFIER_VIDEOINFO ) ) 
		{

         PKS_DATARANGE_VIDEO DataRangeVideoToVerify = (PKS_DATARANGE_VIDEO)DataRange;
         PKS_DATARANGE_VIDEO DataRangeVideo = (PKS_DATARANGE_VIDEO)*pAvailableFormats;

         //
         // Check that the other fields match
         //
         if ( (DataRangeVideoToVerify->bFixedSizeSamples      != DataRangeVideo->bFixedSizeSamples)      ||
              (DataRangeVideoToVerify->bTemporalCompression   != DataRangeVideo->bTemporalCompression)   ||
              (DataRangeVideoToVerify->StreamDescriptionFlags != DataRangeVideo->StreamDescriptionFlags) ||
              (DataRangeVideoToVerify->MemoryAllocationFlags  != DataRangeVideo->MemoryAllocationFlags)  ||
              (RtlCompareMemory( &DataRangeVideoToVerify->ConfigCaps,
                 &DataRangeVideo->ConfigCaps,
                 sizeof( KS_VIDEO_STREAM_CONFIG_CAPS ) ) !=
                 sizeof( KS_VIDEO_STREAM_CONFIG_CAPS ) ) ) 
			{
            DebugOut(( 1, "AdapterFormatFromRange(): at least one field does not match\n" ));
            continue;
         }

         // MATCH FOUND!
         FormatSize = sizeof( KSDATAFORMAT ) +
            KS_SIZE_VIDEOHEADER( &DataRangeVideoToVerify->VideoInfoHeader );

         if ( OnlyWantsSize )
			{
            break;
			}

         // Caller wants the full data format
         if ( IntersectInfo->SizeOfDataFormatBuffer < FormatSize ) 
			{
            DebugOut(( 1, "AdapterFormatFromRange(): STATUS_BUFFER_TOO_SMALL\n" ));
            pSrb->Status = STATUS_BUFFER_TOO_SMALL;
            return;
         }

         // Copy over the KSDATAFORMAT, followed by the
         // actual VideoInfoHeader
         PKS_DATAFORMAT_VIDEOINFOHEADER InterVidHdr =
            (PKS_DATAFORMAT_VIDEOINFOHEADER)IntersectInfo->DataFormatBuffer;

         RtlCopyMemory( &InterVidHdr->DataFormat,
            &DataRangeVideoToVerify->DataRange, sizeof( KSDATARANGE ) );

         ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;

         RtlCopyMemory( &InterVidHdr->VideoInfoHeader,
            &DataRangeVideoToVerify->VideoInfoHeader,
            KS_SIZE_VIDEOHEADER( &DataRangeVideoToVerify->VideoInfoHeader ) );


         // report back the omage size as we know it
         KS_VIDEOINFOHEADER &vidHDR = DataRangeVideoToVerify->VideoInfoHeader;

         #ifdef HACK_FUDGE_RECTANGLES
            // [!!!] [TMZ] - hack
            if( vidHDR.rcTarget.bottom == 0 ) 
				{
               vidHDR.rcTarget.left    = 0;
               vidHDR.rcTarget.top     = 0;
               vidHDR.rcTarget.right   = vidHDR.bmiHeader.biWidth;
               vidHDR.rcTarget.bottom  = abs(vidHDR.bmiHeader.biHeight);
            }
            if( InterVidHdr->VideoInfoHeader.rcTarget.bottom == 0 ) 
				{
               InterVidHdr->VideoInfoHeader.rcTarget.left    = 0;
               InterVidHdr->VideoInfoHeader.rcTarget.top     = 0;
               InterVidHdr->VideoInfoHeader.rcTarget.right   = vidHDR.bmiHeader.biWidth;
               InterVidHdr->VideoInfoHeader.rcTarget.bottom  = abs(vidHDR.bmiHeader.biHeight);
            }
         #endif

         MSize			size;
         GetRequestedSize( vidHDR, size );

         ColorSpace	tmpCol( DataRange->SubFormat );
         MRect			dst( vidHDR.rcTarget );

         // make sure the dimentions are acceptable
         if ( tmpCol.IsValid() && tmpCol.CheckDimentions( size ) &&
              tmpCol.CheckLeftTop( dst.TopLeft() ) ) 
			{
            // if width is different, use it ( in bytes ) to calculate the size
            if ( vidHDR.bmiHeader.biWidth != size.cx )
				{
               InterVidHdr->VideoInfoHeader.bmiHeader.biSizeImage =
                  vidHDR.bmiHeader.biWidth * abs(vidHDR.bmiHeader.biHeight);
				}
            else
				{
               InterVidHdr->VideoInfoHeader.bmiHeader.biSizeImage = size.cx *
                  tmpCol.GetBitCount() * abs(vidHDR.bmiHeader.biHeight) / 8;
				}

            DebugOut((1, "InterVidHdr->VideoInfoHeader.bmiHeader.biSizeImage = %d\n", InterVidHdr->VideoInfoHeader.bmiHeader.biSizeImage));
            break;
         } 
			else 
			{
            pSrb->Status = STATUS_BUFFER_TOO_SMALL;
            DebugOut((1, "AdapterFormatFromRange: Buffer too small\n"));
            return;
         }
      } // End of VIDEOINFOHEADER specifier

      // -------------------------------------------------------------------
      // Specifier FORMAT_VideoInfo2 for VIDEOINFOHEADER2
      // -------------------------------------------------------------------
      else if ( IsEqualGUID( DataRange->Specifier, KSDATAFORMAT_SPECIFIER_VIDEOINFO2 ) ) 
		{

         PKS_DATARANGE_VIDEO2 DataRangeVideoToVerify = (PKS_DATARANGE_VIDEO2) DataRange;
         PKS_DATARANGE_VIDEO2 DataRangeVideo = (PKS_DATARANGE_VIDEO2) *pAvailableFormats;

         //
         // Check that the other fields match
         //
         if ( (DataRangeVideoToVerify->bFixedSizeSamples      != DataRangeVideo->bFixedSizeSamples)      ||
              (DataRangeVideoToVerify->bTemporalCompression   != DataRangeVideo->bTemporalCompression)   ||
              (DataRangeVideoToVerify->StreamDescriptionFlags != DataRangeVideo->StreamDescriptionFlags) ||
              (DataRangeVideoToVerify->MemoryAllocationFlags  != DataRangeVideo->MemoryAllocationFlags)  ||
              (RtlCompareMemory( &DataRangeVideoToVerify->ConfigCaps,
                 &DataRangeVideo->ConfigCaps,
                 sizeof( KS_VIDEO_STREAM_CONFIG_CAPS ) ) !=
                 sizeof( KS_VIDEO_STREAM_CONFIG_CAPS ) ) ) 
			{
            DebugOut(( 1, "AdapterFormatFromRange(): at least one field does not match\n" ));
            continue;
         }

         // MATCH FOUND!
         FormatSize = sizeof( KSDATAFORMAT ) +
            KS_SIZE_VIDEOHEADER2( &DataRangeVideoToVerify->VideoInfoHeader );

         if ( OnlyWantsSize )
			{
            break;
			}

         // Caller wants the full data format
         if ( IntersectInfo->SizeOfDataFormatBuffer < FormatSize ) 
			{
            DebugOut(( 1, "AdapterFormatFromRange(): STATUS_BUFFER_TOO_SMALL\n" ));
            pSrb->Status = STATUS_BUFFER_TOO_SMALL;
            return;
         }

         // Copy over the KSDATAFORMAT, followed by the
         // actual VideoInfoHeader
         PKS_DATAFORMAT_VIDEOINFOHEADER2 InterVidHdr =
            (PKS_DATAFORMAT_VIDEOINFOHEADER2)IntersectInfo->DataFormatBuffer;

         RtlCopyMemory( &InterVidHdr->DataFormat,
            &DataRangeVideoToVerify->DataRange, sizeof( KSDATARANGE ) );

         ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;

         RtlCopyMemory( &InterVidHdr->VideoInfoHeader2,
            &DataRangeVideoToVerify->VideoInfoHeader,
            KS_SIZE_VIDEOHEADER2( &DataRangeVideoToVerify->VideoInfoHeader ) );


         // report back the omage size as we know it
         KS_VIDEOINFOHEADER2 &vidHDR = DataRangeVideoToVerify->VideoInfoHeader;

         #ifdef HACK_FUDGE_RECTANGLES
            // [!!!] [TMZ] - hack
            if( vidHDR.rcTarget.bottom == 0 ) 
				{
               vidHDR.rcTarget.left    = 0;
               vidHDR.rcTarget.top     = 0;
               vidHDR.rcTarget.right   = vidHDR.bmiHeader.biWidth;
               vidHDR.rcTarget.bottom  = abs(vidHDR.bmiHeader.biHeight);
            }
            if( InterVidHdr->VideoInfoHeader.rcTarget.bottom == 0 ) 
				{
               InterVidHdr->VideoInfoHeader.rcTarget.left    = 0;
               InterVidHdr->VideoInfoHeader.rcTarget.top     = 0;
               InterVidHdr->VideoInfoHeader.rcTarget.right   = vidHDR.bmiHeader.biWidth;
               InterVidHdr->VideoInfoHeader.rcTarget.bottom  = abs(vidHDR.bmiHeader.biHeight);
            }
         #endif

         MSize			size;
         GetRequestedSize2( vidHDR, size );

         ColorSpace	tmpCol( DataRange->SubFormat );
         MRect			dst( vidHDR.rcTarget );

         // make sure the dimentions are acceptable
         if ( tmpCol.IsValid() && tmpCol.CheckDimentions( size ) &&
              tmpCol.CheckLeftTop( dst.TopLeft() ) ) 
			{
            // if width is different, use it ( in bytes ) to calculate the size
            if ( vidHDR.bmiHeader.biWidth != size.cx )
				{
               InterVidHdr->VideoInfoHeader2.bmiHeader.biSizeImage =
                  vidHDR.bmiHeader.biWidth * abs(vidHDR.bmiHeader.biHeight);
				}
            else
				{
               InterVidHdr->VideoInfoHeader2.bmiHeader.biSizeImage = size.cx *
                  tmpCol.GetBitCount() * abs(vidHDR.bmiHeader.biHeight) / 8;
				}

            DebugOut((1, "InterVidHdr->VideoInfoHeader2.bmiHeader.biSizeImage = %d\n", InterVidHdr->VideoInfoHeader2.bmiHeader.biSizeImage));
            break;
         } 
			else 
			{
            pSrb->Status = STATUS_BUFFER_TOO_SMALL;
            DebugOut((1, "AdapterFormatFromRange: Buffer too small\n"));
            return;
         }
      } // End of VIDEOINFOHEADER2 specifier

      // -------------------------------------------------------------------
      // Specifier FORMAT_AnalogVideo for KS_ANALOGVIDEOINFO
      // -------------------------------------------------------------------

      else if ( IsEqualGUID( DataRange->Specifier, KSDATAFORMAT_SPECIFIER_ANALOGVIDEO ) ) 
		{

            //
            // For analog video, the DataRange and DataFormat
            // are identical, so just copy the whole structure
            //

            PKS_DATARANGE_ANALOGVIDEO pDataRangeVideo =
               (PKS_DATARANGE_ANALOGVIDEO) *pAvailableFormats;

            // MATCH FOUND!
            FormatSize = sizeof( KS_DATARANGE_ANALOGVIDEO );

            if ( OnlyWantsSize )
				{
               break;
				}

            // Caller wants the full data format
            if ( IntersectInfo->SizeOfDataFormatBuffer < FormatSize ) 
				{
               pSrb->Status = STATUS_BUFFER_TOO_SMALL;
					DebugOut((1, "AdapterFormatFromRange: Buffer too small\n"));
               return;
            }
            RtlCopyMemory( IntersectInfo->DataFormatBuffer,
               pDataRangeVideo, sizeof( KS_DATARANGE_ANALOGVIDEO ) );

            ((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;

            break;

      } 
		else 
		{
			if ( IsEqualGUID( DataRange->Specifier, KSDATAFORMAT_SPECIFIER_VBI ) ) 
			{
				PKS_DATARANGE_VIDEO_VBI pDataRangeVBI =
				(PKS_DATARANGE_VIDEO_VBI)*pAvailableFormats;

				FormatSize = sizeof( KS_DATAFORMAT_VBIINFOHEADER );

				if ( OnlyWantsSize )
				{
					break;
				}

				// Caller wants the full data format
				if ( IntersectInfo->SizeOfDataFormatBuffer < FormatSize ) 
				{
					pSrb->Status = STATUS_BUFFER_TOO_SMALL;
					DebugOut((1, "AdapterFormatFromRange: Buffer too small\n"));
					return;
				}
				// Copy over the KSDATAFORMAT, followed by the
				// actual VideoInfoHeader
				PKS_DATAFORMAT_VBIINFOHEADER InterVBIHdr =
					(PKS_DATAFORMAT_VBIINFOHEADER)IntersectInfo->DataFormatBuffer;

				RtlCopyMemory( &InterVBIHdr->DataFormat,
					&pDataRangeVBI->DataRange, sizeof( KSDATARANGE ) );

				((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;

				RtlCopyMemory( &InterVBIHdr->VBIInfoHeader,
					&pDataRangeVBI->VBIInfoHeader, sizeof( KS_VBIINFOHEADER ) );

				break;
			} 
			else 
			{
				DebugOut(( 0, "AdapterFormatFromRange: STATUS_NO_MATCH\n" ));
				pSrb->Status = STATUS_NO_MATCH;
				return;
			}
		}

   } // End of loop on all formats for this stream

   if ( OnlyWantsSize ) 
	{
		DebugOut(( 2, "AdapterFormatFromRange: only wants size\n" ));
		*(PULONG) IntersectInfo->DataFormatBuffer = FormatSize;
		pSrb->ActualBytesTransferred = sizeof( ULONG );
		return;
   }
   pSrb->ActualBytesTransferred = FormatSize;
	DebugOut(( 2, "AdapterFormatFromRange: done\n" ));

   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\capprop.c ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Capprop.c 1.14 1998/05/13 14:44:20 tomz Exp $

//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;


#ifdef __cplusplus
extern "C" {
#endif

#include "strmini.h"
#include "ksmedia.h"

#ifdef __cplusplus
}
#endif

#include "device.h"

#include "capdebug.h"
#include "capprop.h"
#include "capmain.h"

extern PsDevice *gpPsDevice;

bool CrossBar::TestRoute( int InPin, int OutPin )
{
   Trace t("CrossBar::TestRoute()");

   // JBC 4/1/98 Handle Input Pin = -1 for Audio Mute case
   if ( InPin == -1 && (OutputPins [OutPin].PinType >= KS_PhysConn_Audio_Tuner)) {	// JBC 4/1/98
      return true;
   }
   if ((InputPins [InPin].PinType >= KS_PhysConn_Audio_Tuner) &&  // 0x1000 first audio pin // JBC 4/1/98
       (OutputPins [OutPin].PinType >= KS_PhysConn_Audio_Tuner)) {					// JBC 4/1/98
      return true;
   }
   else {
      if ((InputPins [InPin].PinType >= KS_PhysConn_Video_Tuner) &&
		  (InputPins [InPin].PinType < KS_PhysConn_Audio_Tuner) &&		// JBC 4/1/98
          (OutputPins [OutPin].PinType < KS_PhysConn_Audio_Tuner)) {
         DebugOut((1, "TestRoute(%d,%d) = true\n", InPin, OutPin));
		 return true;
      } else {
		 return false;
      }
   }
}

// -------------------------------------------------------------------
// XBar Property Set functions
// -------------------------------------------------------------------

//
// The only property to set on the XBar selects the input to use
//

/* Method: AdapterGetCrossbarProperty
 * Purpose:
 */
VOID AdapterSetCrossbarProperty( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("AdapterSetCrossbarProperty()");

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
   ULONG Id  = pSPD->Property->Id;              // index of the property
   ULONG nS  = pSPD->PropertyOutputSize;        // size of data supplied

   switch ( Id ) {
   case KSPROPERTY_CROSSBAR_ROUTE:
      {
		  PKSPROPERTY_CROSSBAR_ROUTE_S  pRoute =
            (PKSPROPERTY_CROSSBAR_ROUTE_S)pSPD->PropertyInfo;

         ASSERT (nS >= sizeof (KSPROPERTY_CROSSBAR_ROUTE_S));

         // Copy the input property info to the output property info
         RtlCopyMemory( pRoute, pSPD->Property,
           sizeof( KSPROPERTY_CROSSBAR_ROUTE_S ) );

         int InPin, OutPin;
         InPin  = pRoute->IndexInputPin;
         OutPin = pRoute->IndexOutputPin;

         DebugOut((1, "*** KSPROPERTY_CROSSBAR_ROUTE(%d,%d)\n", InPin, OutPin));

         if ( adapter->xBar.GoodPins( InPin, OutPin ) ) {
            
            DebugOut((1, "*** xBar.GoodPins succeeded\n"));

            if ( adapter->xBar.TestRoute( InPin, OutPin ) ) {
               DebugOut((1, "*** xBar.TestRoute succeeded\n"));
               pRoute->CanRoute = true;
               // JBC 4/1/98 What happens when we call setconnector for audio pins?
			      if (OutPin == 0 )	// JBC 4/1/98 Check for Video Vs Audio pins settings
               {
                  // Video out
				      adapter->SetConnector( adapter->xBar.GetPinNo( InPin ) + 1 ); // our connectors are 1-based
               }
               else
               {
                  // Audio out
                  if ( InPin == -1 ) // then mute
                  {
                     gpPsDevice->EnableAudio( Off );
                  }
                  else
                  {
                     gpPsDevice->EnableAudio( On );
                  }
               }
			      // this just sets the association
               adapter->xBar.Route( OutPin, InPin );
            } else {											// JBC 3/31/98 add curly braces
               DebugOut((1, "*** xBar.TestRoute failed\n"));
               pRoute->CanRoute = false;
			}
		} else {												// JBC 3/31/98 add curly braces
            DebugOut((1, "*** xBar.GoodPins failed\n"));
            pRoute->CanRoute = 0;
		}
	  }
      pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_CROSSBAR_ROUTE_S );
      break;
   default:
      break;
   }
   pSrb->Status = STATUS_SUCCESS;
}

/* Method: AdapterGetCrossbarProperty
 * Purpose:
 */
VOID AdapterGetCrossbarProperty( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("AdapterGetCrossbarProperty()");

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
   ULONG Id = pSPD->Property->Id;              // index of the property
//   PLONG pL = (PLONG) pSPD->PropertyInfo;     // pointer to the data
   ULONG nS = pSPD->PropertyOutputSize;        // size of data supplied

   // Property set specific structure

   switch ( Id ) {
   case KSPROPERTY_CROSSBAR_CAPS:                  // R
      if ( nS >= sizeof( KSPROPERTY_CROSSBAR_CAPS_S ) ) {

         PKSPROPERTY_CROSSBAR_CAPS_S  pCaps =
            (PKSPROPERTY_CROSSBAR_CAPS_S)pSPD->PropertyInfo;

         // Copy the input property info to the output property info
         RtlCopyMemory( pCaps, pSPD->Property,
            sizeof( KSPROPERTY_CROSSBAR_CAPS_S ) );

         pCaps->NumberOfInputs  = adapter->xBar.GetNoInputs();
         pCaps->NumberOfOutputs = adapter->xBar.GetNoOutputs();

         pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_CROSSBAR_CAPS_S );
      }
      break;
   case KSPROPERTY_CROSSBAR_CAN_ROUTE:
      DebugOut((1, "*** KSPROPERTY_CROSSBAR_CAN_ROUTE\n"));

      if ( nS >= sizeof( KSPROPERTY_CROSSBAR_ROUTE_S ) ) {

         PKSPROPERTY_CROSSBAR_ROUTE_S  pRoute =
            (PKSPROPERTY_CROSSBAR_ROUTE_S)pSPD->PropertyInfo;

         // Copy the input property info to the output property info
         RtlCopyMemory( pRoute, pSPD->Property,
            sizeof( KSPROPERTY_CROSSBAR_ROUTE_S ) );

         int InPin, OutPin;
         InPin  = pRoute->IndexInputPin;
         OutPin = pRoute->IndexOutputPin;

         if ( adapter->xBar.GoodPins( InPin, OutPin ) ) {
            DebugOut((1, "*** xBar.GoodPins succeeded\n"));
            pRoute->CanRoute = adapter->xBar.TestRoute( InPin, OutPin );
         } else {
            DebugOut((1, "*** xBar.GoodPins failed\n"));
            pRoute->CanRoute = FALSE;
         }
         pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_CROSSBAR_ROUTE_S );
      }
      break;
   case KSPROPERTY_CROSSBAR_ROUTE:
      DebugOut((1, "*** KSPROPERTY_CROSSBAR_ROUTE\n"));

      if ( nS >= sizeof( KSPROPERTY_CROSSBAR_ROUTE_S ) ) {

         PKSPROPERTY_CROSSBAR_ROUTE_S  pRoute =
            (PKSPROPERTY_CROSSBAR_ROUTE_S)pSPD->PropertyInfo;

         // Copy the input property info to the output property info
         RtlCopyMemory( pRoute, pSPD->Property,
            sizeof( KSPROPERTY_CROSSBAR_ROUTE_S ) );

         int OutPin = pRoute->IndexOutputPin;

         if ( OutPin < adapter->xBar.GetNoOutputs() ) {
            DebugOut((1, "*** xBar.GetRoute(%d) called\n", OutPin));
            pRoute->IndexInputPin = adapter->xBar.GetRoute( OutPin );
         }
         else {
            pRoute->IndexInputPin = (DWORD) -1;
         }

         DebugOut((1, "*** pRoute->IndexInputPin = %d\n", pRoute->IndexInputPin));

         pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_CROSSBAR_ROUTE_S );
      }
      break;
   case KSPROPERTY_CROSSBAR_PININFO:                     // R
      if ( nS >= sizeof( KSPROPERTY_CROSSBAR_PININFO_S ) ) {

         PKSPROPERTY_CROSSBAR_PININFO_S  pPinInfo =
            (PKSPROPERTY_CROSSBAR_PININFO_S)pSPD->PropertyInfo;

         // Copy the input property info to the output property info
         RtlCopyMemory( pPinInfo, pSPD->Property,
            sizeof( KSPROPERTY_CROSSBAR_PININFO_S ) );

         pPinInfo->PinType = adapter->xBar.GetPinInfo( pPinInfo->Direction,
            pPinInfo->Index,
            pPinInfo->RelatedPinIndex,
            &(pPinInfo->Medium));

         pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_CROSSBAR_PININFO_S );
      }
   break;
   default:
       pSrb->ActualBytesTransferred = 0;
       break;
   }
   pSrb->Status = STATUS_SUCCESS;
}

// -------------------------------------------------------------------
// TVTuner Property Set functions
// -------------------------------------------------------------------
void AdapterSetTunerProperty( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("AdapterSetTunerProperty()");

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
   ULONG Id = pSPD->Property->Id;       // index of the property
   PVOID pV = pSPD->PropertyInfo;       // pointer to the data
   ULONG nS = pSPD->PropertyOutputSize; // size of data returned

   ASSERT( nS >= sizeof( ULONG ) );

   switch ( Id ) {
   case KSPROPERTY_TUNER_FREQUENCY:
      {
         PKSPROPERTY_TUNER_FREQUENCY_S pFreq =
            (PKSPROPERTY_TUNER_FREQUENCY_S)pV;
         adapter->SetChannel( pFreq->Frequency );
      }
      break;
   case KSPROPERTY_TUNER_MODE:
      {
         PKSPROPERTY_TUNER_MODE_S pMode =
            (PKSPROPERTY_TUNER_MODE_S)pV;
         ASSERT (pMode->Mode == KSPROPERTY_TUNER_MODE_TV);
      }
      break;
   default:
      // do not process input and standard as we don't have a choice of them
      break;
   }
   pSrb->Status = STATUS_SUCCESS;
}

void AdapterGetTunerProperty( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("AdapterGetTunerProperty()");

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
   ULONG Id = pSPD->Property->Id;        // index of the property
   PVOID pV = pSPD->PropertyInfo;        // pointer to the data
   ULONG nS = pSPD->PropertyOutputSize;  // size of data supplied

   ASSERT (nS >= sizeof (LONG));
   pSrb->ActualBytesTransferred = 0;

   switch ( Id ) {
   case KSPROPERTY_TUNER_CAPS:
      {
         PKSPROPERTY_TUNER_CAPS_S pCaps =
            (PKSPROPERTY_TUNER_CAPS_S)pSPD->Property;
         ASSERT (nS >= sizeof( KSPROPERTY_TUNER_CAPS_S ) );

         // now work with the output buffer
         pCaps =(PKSPROPERTY_TUNER_CAPS_S)pV;

         pCaps->ModesSupported = KSPROPERTY_TUNER_MODE_TV;
         pCaps->VideoMedium = TVTunerMediums[0];
         pCaps->TVAudioMedium = TVTunerMediums[1];
         pCaps->RadioAudioMedium.Set = GUID_NULL;   // No separate radio audio pin
         pCaps->RadioAudioMedium.Id = 0;
         pCaps->RadioAudioMedium.Flags = 0;

         pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_CAPS_S );
      }
      break;
   case KSPROPERTY_TUNER_MODE:
      {
         PKSPROPERTY_TUNER_MODE_S pMode =
            (PKSPROPERTY_TUNER_MODE_S)pV;
         ASSERT (nS >= sizeof( KSPROPERTY_TUNER_MODE_S ) );
         pMode->Mode = KSPROPERTY_TUNER_MODE_TV;

         pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_MODE_S);
      }
      break;
   case KSPROPERTY_TUNER_MODE_CAPS:
      {
         PKSPROPERTY_TUNER_MODE_CAPS_S pCaps =
            (PKSPROPERTY_TUNER_MODE_CAPS_S)pSPD->Property;
         ASSERT (nS >= sizeof( KSPROPERTY_TUNER_MODE_CAPS_S ) );

         ASSERT (pCaps->Mode == KSPROPERTY_TUNER_MODE_TV);

         // now work with the output buffer
         pCaps =(PKSPROPERTY_TUNER_MODE_CAPS_S)pV;

         //
         // List the formats actually supported by this tuner
         //

         pCaps->StandardsSupported = adapter->GetSupportedStandards();

         //
         // Get the min and max frequencies supported
         //

         pCaps->MinFrequency =  55250000L;
         pCaps->MaxFrequency = 997250000L;

         //
         // What is the frequency step size?
         //

         pCaps->TuningGranularity = 62500L;

         //
         // How many inputs are on the tuner?
         //

         pCaps->NumberOfInputs = 1;

         //
         // What is the maximum settling time in milliseconds?
         //

         pCaps->SettlingTime = 150;

         //
         // Strategy defines how the tuner knows when it is in tune:
         //
         // KS_TUNER_STRATEGY_PLL (Has PLL offset information)
         // KS_TUNER_STRATEGY_SIGNAL_STRENGTH (has signal strength info)
         // KS_TUNER_STRATEGY_DRIVER_TUNES (driver handles all fine tuning)
         //

         pCaps->Strategy = KS_TUNER_STRATEGY_PLL;

         pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_MODE_CAPS_S );
      }
      break;
   case KSPROPERTY_TUNER_STATUS:
      // Return the status of the tuner

      // PLLOffset is in units of TuningGranularity 
      // SignalStrength is 0 to 100
      // Set Busy to 1 if tuning is still in process

      {
         PKSPROPERTY_TUNER_STATUS_S pStat =
            (PKSPROPERTY_TUNER_STATUS_S)pSPD->Property;
         ASSERT( nS >= sizeof( KSPROPERTY_TUNER_STATUS_S ) );

         // typedef struct {
         //     KSPROPERTY Property;
         //     ULONG  CurrentFrequency;            // Hz
         //     ULONG  PLLOffset;                   // if Strategy.KS_TUNER_STRATEGY_PLL
         //     ULONG  SignalStrength;              // if Stretegy.KS_TUNER_STRATEGY_SIGNAL_STRENGTH
         //     ULONG  Busy;                        // TRUE if in the process of tuning
         // } KSPROPERTY_TUNER_STATUS_S, *PKSPROPERTY_TUNER_STATUS_S;

         // now work with the output buffer
         pStat = PKSPROPERTY_TUNER_STATUS_S( pV );
         pStat->PLLOffset = adapter->GetPllOffset( &pStat->Busy,
            pStat->CurrentFrequency );

         pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_STATUS_S );
      }
      break;
   case KSPROPERTY_TUNER_STANDARD:
      {
         PKSPROPERTY_TUNER_STANDARD_S pStd =
            (PKSPROPERTY_TUNER_STANDARD_S)pSPD->Property;
         ASSERT( nS >= sizeof( KSPROPERTY_TUNER_STANDARD_S ) );

         // now work with the output buffer
         pStd = PKSPROPERTY_TUNER_STANDARD_S( pV );

         pStd->Standard = KS_AnalogVideo_NTSC_M; // our TEMIC tuner supports this only
         pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_STANDARD_S );
      }
      break;
   case KSPROPERTY_TUNER_INPUT:
      {
         PKSPROPERTY_TUNER_INPUT_S pIn =
            (PKSPROPERTY_TUNER_INPUT_S)pSPD->Property;
         ASSERT( nS >= sizeof( KSPROPERTY_TUNER_INPUT_S ) );

         // now work with the output buffer
         pIn = PKSPROPERTY_TUNER_INPUT_S( pV );

         // What is the currently selected input?
         pIn->InputIndex = 0;
         pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_TUNER_INPUT_S );
      }
      break;
   default:
       break;
   }
   pSrb->Status = STATUS_SUCCESS;
}

// -------------------------------------------------------------------
// VideoProcAmp functions
// -------------------------------------------------------------------

VOID AdapterSetVideoProcAmpProperty( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("AdapterSetVideoProcAmpProperty()");

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
   ULONG Id = pSPD->Property->Id;              // index of the property
   PKSPROPERTY_VIDEOPROCAMP_S pS = (PKSPROPERTY_VIDEOPROCAMP_S) pSPD->PropertyInfo;    // pointer to the data

   ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_VIDEOPROCAMP_S));

   switch ( Id ) {
   case KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:
      adapter->SetBrightness( pS->Value );
      break;
   case KSPROPERTY_VIDEOPROCAMP_CONTRAST:
      adapter->SetContrast( pS->Value );
      break;
   case KSPROPERTY_VIDEOPROCAMP_HUE:
      adapter->SetHue( pS->Value );
      break;
   case KSPROPERTY_VIDEOPROCAMP_SATURATION:
      adapter->SetSaturation( pS->Value );
      break;
   default:
      break;
   }
   pSrb->Status = STATUS_SUCCESS;
}

/* Method: AdapterGetVideoProcAmpProperty
 * Purpose: Gets various video procamp properties
 */
VOID AdapterGetVideoProcAmpProperty( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("AdapterGetVideoProcAmpProperty()");

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
   ULONG Id = pSPD->Property->Id;              // index of the property
   PKSPROPERTY_VIDEOPROCAMP_S pS = (PKSPROPERTY_VIDEOPROCAMP_S) pSPD->PropertyInfo;    // pointer to the data

   ASSERT( pSPD->PropertyOutputSize >= sizeof( KSPROPERTY_VIDEOPROCAMP_S ) );

   switch ( Id ) {
   case KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS:
      pS->Value = adapter->GetBrightness();
		pS->Flags = pS->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
      break;
   case KSPROPERTY_VIDEOPROCAMP_CONTRAST:
      pS->Value = adapter->GetContrast();
		pS->Flags = pS->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
      break;
   case KSPROPERTY_VIDEOPROCAMP_HUE:
      pS->Value = adapter->GetHue();
		pS->Flags = pS->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
      break;
   case KSPROPERTY_VIDEOPROCAMP_SATURATION:
      pS->Value = adapter->GetSaturation();
		pS->Flags = pS->Capabilities = KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL;
      break;
   default:
      DebugOut((1, "*** AdapterGetVideoProcAmpProperty - KSPROPERTY_??? (%d) ***\n", Id));
   }
   pSrb->ActualBytesTransferred = sizeof( KSPROPERTY_VIDEOPROCAMP_S );
   pSrb->Status = STATUS_SUCCESS;
}

/* Method: AdapterSetVideoDecProperty
 * Purpose: Manipulates various video decoder properties
 * Input: SRB
 * Output: None
 */
void AdapterSetVideoDecProperty( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("AdapterSetVideoDecProperty()");

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
   ULONG Id = pSPD->Property->Id;              // index of the property

   switch ( Id ) {
   case KSPROPERTY_VIDEODECODER_STANDARD: {
         PKSPROPERTY_VIDEODECODER_S pVDecStd =
            (PKSPROPERTY_VIDEODECODER_S)pSPD->PropertyInfo;
         adapter->SetFormat( pVDecStd->Value );
      }
      break;
   case KSPROPERTY_VIDEODECODER_STATUS:
      break;
   }
}

/* Method: AdapterGetVideoDecProperty
 * Purpose: Obtains various video decoder properties
 * Input: SRB
 * Output: None
 */
void AdapterGetVideoDecProperty( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("AdapterGetVideoDecProperty()");
   
   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
   ULONG Id = pSPD->Property->Id;              // index of the property

   switch ( Id ) {
   case KSPROPERTY_VIDEODECODER_CAPS: {
         PKSPROPERTY_VIDEODECODER_CAPS_S pVDecCaps =
            (PKSPROPERTY_VIDEODECODER_CAPS_S)pSPD->PropertyInfo;
         pVDecCaps->StandardsSupported = KS_AnalogVideo_NTSC_M;
         pVDecCaps->Capabilities = 
             // KS_VIDEODECODER_FLAGS_CAN_DISABLE_OUTPUT | 
                KS_VIDEODECODER_FLAGS_CAN_USE_VCR_LOCKING |
                KS_VIDEODECODER_FLAGS_CAN_INDICATE_LOCKED;
         pVDecCaps->SettlingTime = 10;    // How long to delay after tuning
                                          // before locked indicator is valid
         pVDecCaps-> HSyncPerVSync = 6;   // HSync per VSync
         pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_CAPS_S);
      }
      break;
   case KSPROPERTY_VIDEODECODER_STANDARD: {
         // Return the currently active analog video mode
         PKSPROPERTY_VIDEODECODER_S pVDecStd =
            (PKSPROPERTY_VIDEODECODER_S)pSPD->PropertyInfo;
         //pVDecStd->Value = GetSupportedStandards();
         pVDecStd->Value = KS_AnalogVideo_NTSC_M;
         pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_S);
      }
      break;
   case KSPROPERTY_VIDEODECODER_STATUS: {
         PKSPROPERTY_VIDEODECODER_STATUS_S pVDecStat =
            (PKSPROPERTY_VIDEODECODER_STATUS_S)pSPD->PropertyInfo;
         pVDecStat->NumberOfLines = adapter->GetFormat() == VFormat_NTSC ? 525 : 625;
         pVDecStat->SignalLocked = adapter->CaptureContrll_.PsDecoder_.IsDeviceInHLock();
         pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_VIDEODECODER_S);
      }
      break;
   default:
      DebugOut((1, "*** AdapterGetVideoDecProperty - KSPROPERTY_??? (%d) ***\n", Id));
   }
}
// -------------------------------------------------------------------
// TVAudio functions
// -------------------------------------------------------------------

/*
** AdapterSetTVAudioProperty ()
**
**    Handles Set operations on the TVAudio property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

ULONG gTVAudioMode = 0;
VOID 
AdapterSetTVAudioProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property

    switch (Id) {

    case KSPROPERTY_TVAUDIO_MODE:
    {
        PKSPROPERTY_TVAUDIO_S pS = (PKSPROPERTY_TVAUDIO_S) pSPD->PropertyInfo;    
        gTVAudioMode = pS->Mode;
    }
    break;

    default:
        break;
    }
}

/*
** AdapterGetTVAudioProperty ()
**
**    Handles Get operations on the TVAudio property set.
**      Testcap uses this for demo purposes only.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID 
AdapterGetTVAudioProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property

    switch (Id) {

    case KSPROPERTY_TVAUDIO_CAPS:
    {
        DebugOut((1, "KSPROPERTY_TVAUDIO_CAPS\n"));

        PKSPROPERTY_TVAUDIO_CAPS_S pS = (PKSPROPERTY_TVAUDIO_CAPS_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_TVAUDIO_CAPS_S));
        
        pS->InputMedium  = TVAudioMediums[0];
        pS->InputMedium.Id = 0; //(ULONG) pHwDevExt;  // Multiple instance support
        pS->OutputMedium = TVAudioMediums[1];
        pS->OutputMedium.Id = 0; //(ULONG) pHwDevExt;  // Multiple instance support

        // Report all of the possible audio decoding modes the hardware is capabable of
        pS->Capabilities = KS_TVAUDIO_MODE_MONO   |
                           KS_TVAUDIO_MODE_STEREO |
                           KS_TVAUDIO_MODE_LANG_A |
                           KS_TVAUDIO_MODE_LANG_B ;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_TVAUDIO_CAPS_S);
    }
    break;
        
    case KSPROPERTY_TVAUDIO_MODE:
    {
        DebugOut((1, "KSPROPERTY_TVAUDIO_MODE\n"));
        PKSPROPERTY_TVAUDIO_S pS = (PKSPROPERTY_TVAUDIO_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_TVAUDIO_S));
        // Report the currently selected mode
        pS->Mode = gTVAudioMode;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_TVAUDIO_S);
    }
    break;

    case KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES:
    {
        DebugOut((1, "KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES\n"));
        PKSPROPERTY_TVAUDIO_S pS = (PKSPROPERTY_TVAUDIO_S) pSPD->PropertyInfo;    // pointer to the data

        ASSERT (pSPD->PropertyOutputSize >= sizeof (KSPROPERTY_TVAUDIO_S));
        // Report which audio modes could potentially be selected right now
        pS->Mode = KS_TVAUDIO_MODE_MONO   |
                   KS_TVAUDIO_MODE_STEREO |
                   KS_TVAUDIO_MODE_LANG_A ;

        pSrb->ActualBytesTransferred = sizeof (KSPROPERTY_TVAUDIO_S);
    }
    break;
    
    default:
        DebugOut((0, "default - unrecognized (%x)\n", Id));
        break;
    }
}

/* Method: AdapterSetProperty
 * Purpose: Selects which adapter property to set
 */
VOID AdapterSetProperty( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("AdapterSetProperty()");

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

   if ( IsEqualGUID( PROPSETID_VIDCAP_CROSSBAR, pSPD->Property->Set ) )  {
      AdapterSetCrossbarProperty( pSrb );
   } else if ( IsEqualGUID( PROPSETID_TUNER, pSPD->Property->Set ) )  {
      AdapterSetTunerProperty( pSrb );
   } else if ( IsEqualGUID( PROPSETID_VIDCAP_VIDEOPROCAMP, pSPD->Property->Set ) )  {
      AdapterSetVideoProcAmpProperty( pSrb );
   } else if ( IsEqualGUID( PROPSETID_VIDCAP_VIDEODECODER, pSPD->Property->Set ) )  {
      AdapterSetVideoDecProperty( pSrb );
   } else if (IsEqualGUID( PROPSETID_VIDCAP_TVAUDIO, pSPD->Property->Set))  {
      AdapterSetTVAudioProperty( pSrb );
   } else {
      DebugOut((0, "AdapterSetProperty unrecognized GUID: pSrb(%x), pSPD->Property->Set(%x)\n", pSrb, pSPD->Property->Set));
   }
}

/* Method: AdapterGetProperty
 * Purpose: Selects which adapter property to get
 */
VOID AdapterGetProperty( PHW_STREAM_REQUEST_BLOCK pSrb )

{
   Trace t("AdapterGetProperty()");

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

   if ( IsEqualGUID( PROPSETID_VIDCAP_CROSSBAR, pSPD->Property->Set ) )  {
      AdapterGetCrossbarProperty( pSrb );
   } else if ( IsEqualGUID( PROPSETID_TUNER, pSPD->Property->Set ) )  {
      AdapterGetTunerProperty( pSrb );
   } else if ( IsEqualGUID( PROPSETID_VIDCAP_VIDEOPROCAMP, pSPD->Property->Set ) )  {
      AdapterGetVideoProcAmpProperty( pSrb );
   } else if ( IsEqualGUID( PROPSETID_VIDCAP_VIDEODECODER, pSPD->Property->Set ) )  {
      AdapterGetVideoDecProperty( pSrb );
   } else if (IsEqualGUID( PROPSETID_VIDCAP_TVAUDIO, pSPD->Property->Set))  {
      AdapterGetTVAudioProperty( pSrb );
   } else {
      DebugOut((0, "AdapterGetProperty unrecognized GUID: pSrb(%x), pSPD->Property->Set(%x)\n", pSrb, pSPD->Property->Set));
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\capmain.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Capmain.h 1.9 1998/05/11 23:59:56 tomz Exp $

//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __CAPMAIN_H__
#define __CAPMAIN_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include "device.h"

//	adapted from ksmedia.h
#define KS_SIZE_PREHEADER2 (FIELD_OFFSET(KS_VIDEOINFOHEADER2,bmiHeader))
#define KS_SIZE_VIDEOHEADER2(pbmi) ((pbmi)->bmiHeader.biSize + KS_SIZE_PREHEADER2)


/*****************************************************************************
*
* The following structures are samples of information that could be used in
* a device extension structure
*
*****************************************************************************/

//
// definition of the full HW device extension structure This is the structure
// that will be allocated in HW_INITIALIZATION by the stream class driver
// Any information that is used in processing a device request (as opposed to
// a STREAM based request) should be in this structure.  A pointer to this
// structure will be passed in all requests to the minidriver. (See
// HW_STREAM_REQUEST_BLOCK in STRMINI.H)
//

typedef struct _HW_DEVICE_EXTENSION {
   PsDevice *psdevice;
   //PULONG                   ioBaseLocal;                // board base address
   //USHORT                   Irq;                        // irq level
   //PHW_STREAM_REQUEST_BLOCK pCurSrb;       // current device request in progress

   // The following will be the memory where we store or PsDevice class instance
   // This must be last
   DWORD psdevicemem[1];
} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

//
// this structure is our per stream extension structure.  This stores
// information that is relevant on a per stream basis.  Whenever a new stream
// is opened, the stream class driver will allocate whatever extension size
// is specified in the HwInitData.PerStreamExtensionSize.
//

typedef union {
   KS_FRAME_INFO     VideoFrameInfo;
   KS_VBI_FRAME_INFO VbiFrameInfo;
} ALL_FRAME_INFO;

typedef struct _STREAMEX {

   PVOID          videochannel;
   ALL_FRAME_INFO FrameInfo;
   ULONG          StreamNumber;
   //KS_VIDEOINFOHEADER         *pVideoInfoHeader;  // format (variable size!)
   //KSSTATE                     KSState;        // Run, Stop, Pause
   //BOOLEAN                     fStreamOpen;    // TRUE if stream is open
   //STREAM_SYSTEM_TIME          videoSTC;       // current video presentation time
   //PHW_STREAM_REQUEST_BLOCK    pCurrentSRB;    // video request in progress
   //PVOID                       pDMABuf;        // pointer to the video DMA buffer
   //STREAM_PHYSICAL_ADDRESS     pPhysDmaBuf;    // physical address of DMA buffer
   //ULONG                       cDmaBuf;        // size of DMA buffer
   //KSSTATE                     DeviceState;    // current device state
   //BOOLEAN                     IRQExpected;    // IRQ expected

   // The following will be the memory where we store or PsDevice class instance
   // This must be last
   DWORD    videochannelmem[1];
} STREAMEX, *PSTREAMEX;

 
//
// this structure defines the per request extension.  It defines any storage
// space that the min driver may need in each request packet.
//

typedef struct _SRB_EXTENSION {
    LIST_ENTRY                  ListEntry;
    PHW_STREAM_REQUEST_BLOCK    pSrb;
    HANDLE                      hUserSurfaceHandle;      // DDraw
    HANDLE                      hKernelSurfaceHandle;    // DDraw
} SRB_EXTENSION, * PSRB_EXTENSION;


/*****************************************************************************
*
* the following section defines prototypes for the minidriver initialization
* routines
*
******************************************************************************/

//
// DriverEntry:
//
// This routine is called when the mini driver is first loaded.  The driver
// should then call the StreamClassRegisterAdapter function to register with
// the stream class driver
//

ULONG DriverEntry (PVOID Context1, PVOID Context2);

//
// This routine is called by the stream class driver with configuration
// information for an adapter that the mini driver should load on.  The mini
// driver should still perform a small verification to determine that the
// adapter is present at the specified addresses, but should not attempt to
// find an adapter as it would have with previous NT miniports.
//
// All initialization of the adapter should also be performed at this time.
//

BOOLEAN HwInitialize (IN OUT PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This routine is called when the system is going to remove or disable the
// device.
//
// The mini-driver should free any system resources that it allocated at this
// time.  Note that system resources allocated for the mini-driver by the
// stream class driver will be free'd by the stream driver, and should not be
// free'd in this routine.  (Such as the HW_DEVICE_EXTENSION)
//

BOOLEAN HwUnInitialize ( IN PVOID DeviceExtension);


BOOLEAN HwQueryUnload ( IN PVOID DeviceExtension);


//
// This is the prototype for the Hardware Interrupt Handler.  This routine
// will be called whenever the minidriver receives an interrupt
//

BOOLEAN HwInterrupt ( IN PHW_DEVICE_EXTENSION pDeviceExtension );

//
// This is the prototype for the stream enumeration function.  This routine
// provides the stream class driver with the information on data stream types
// supported
//

VOID AdapterStreamInfo(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the stream open function
//

VOID AdapterOpenStream(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the stream close function
//

VOID AdapterCloseStream(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the AdapterReceivePacket routine.  This is the
// entry point for command packets that are sent to the adapter (not to a
// specific open stream)
//

VOID STREAMAPI AdapterReceivePacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

//
// This is the protoype for the cancel packet routine.  This routine enables
// the stream class driver to cancel an outstanding packet.
//

VOID STREAMAPI AdapterCancelPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

//
// This is the packet timeout function.  The adapter may choose to ignore a
// packet timeout, or rest the adapter and cancel the requests, as required.
//

VOID STREAMAPI AdapterTimeoutPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

//
// prototypes for data handling routines
//

VOID STREAMAPI VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VideoReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AnalogReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI AnalogReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
void EnableIRQ(PHW_STREAM_OBJECT pstrm);
void DisableIRQ(PHW_STREAM_OBJECT pstrm);

//
// prototypes for properties and states
//

//VOID SetVideoState(PHW_STREAM_REQUEST_BLOCK pSrb);
void GetVidLvl(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID GetVideoProperty(PHW_STREAM_REQUEST_BLOCK pSrb);


#ifdef ENABLE_DDRAW_STUFF
   DWORD FAR PASCAL DirectDrawEventCallback( DWORD, PVOID, DWORD, DWORD );
   BOOL RegisterForDirectDrawEvents( PHW_STREAM_REQUEST_BLOCK );
   BOOL UnregisterForDirectDrawEvents( PHW_STREAM_REQUEST_BLOCK );
   BOOL OpenKernelDirectDraw( PHW_STREAM_REQUEST_BLOCK );
   BOOL CloseKernelDirectDraw( PHW_STREAM_REQUEST_BLOCK );
   BOOL IsKernelLockAndFlipAvailable( PHW_STREAM_REQUEST_BLOCK );
   BOOL OpenKernelDDrawSurfaceHandle( IN PHW_STREAM_REQUEST_BLOCK );
   BOOL CloseKernelDDrawSurfaceHandle( IN PHW_STREAM_REQUEST_BLOCK );
   BOOL FlipOverlay( HANDLE, HANDLE, HANDLE );
#endif


#ifdef    __cplusplus
}
#endif // __cplusplus

#endif //__CAPMAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\bt848api.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Bt848api.h 1.2 1998/04/29 22:43:26 tomz Exp $

#ifndef __BT848API_H
#define __BT848API_H


#ifndef BYTE
   typedef unsigned char       BYTE;
#endif

#include "viddefs.h"
#include "retcode.h"


//===========================================================================
// BT848 DLL API Header File
//===========================================================================

#ifdef __cplusplus
extern "C"
{
#endif

//---------------------------------------------------------------------------
// I2C DATA/CONTROL REGISTER API
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//  Method:  bool I2CIsInitOK( void )
//  Purpose: Check if I2C is initialized successfully
//  Input:   None
//  Output:  None
//  Return:  true or false
/////////////////////////////////////////////////////////////////////////////
bool      I2CIsInitOK( void );

/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2CInitHWMode( long freq )
//  Purpose: Initialize I2C for hardware control of SCL and SDA
//  Input:   long freq - frequency (hz) to run SCL at
//  Output:  None
//  Return:  None
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2CInitHWMode( long freq );

/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2CInitSWMode( long freq )
//  Purpose: Initialize I2C for software control of SCL and SDA
//  Input:   long freq - frequency (hz) to run SCL at
//  Output:  None
//  Return:  None
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2CInitSWMode( long freq );

/////////////////////////////////////////////////////////////////////////////
//  Method:  void I2CSetFreq( long freq )
//  Purpose: Set frequency for SCL
//  Input:   long freq - frequency (hz) to run SCL at. (137.5khz to 2.0625Mhz)
//             PCI frequency 33Mhz: SCL = (412.50Khz to 33.81Khz)
//                           25Mhz: SCL = (312.50Khz to 25.61Khz)
//  Output:  None
//  Return:  None
/////////////////////////////////////////////////////////////////////////////
void      I2CSetFreq( long freq );

/////////////////////////////////////////////////////////////////////////////
//  Method:  int I2CReadDiv( void )
//  Purpose: Obtain value of programmable divider
//  Input:   None
//  Output:  None
//  Return:  Value of programmable divider
/////////////////////////////////////////////////////////////////////////////
int       I2CReadDiv( void );

/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2CHWRead( BYTE address, BYTE *value )
//  Purpose: Perform a hardware read from the I2C
//  Input:   int address - address to be read from
//  Output:  int *value  - retrieved value
//  Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2CHWRead( BYTE address, BYTE *value );

/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2CHWWrite2( BYTE address, BYTE value1 )
//  Purpose:  Perform a hardware write of two bytes to the I2C
//  Input:   int address - address to be written to
//           int value1  - value of 2nd byte to be written
//  Output:  None
//  Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2CHWWrite2( BYTE address, BYTE value1 );

/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2CHWWrite3( BYTE address, BYTE value1, BYTE value2 )
//  Purpose: Perform a hardware write of three bytes to the I2C
//  Input:   int address - address to be written to
//           int value1  - value of 2nd byte to be written
//           int value2  - value of 3rd byte to be written
//  Output:  None
//  Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2CHWWrite3( BYTE address, BYTE value1, BYTE value2 );

/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2CSetSync( State sync )
//  Purpose: Set I2C sync value
//  Input:   sync: On  - allow slave to insert wait states
//                 Off - slave cannot insert wait states
//  Output:  None
//  Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2CSetSync( State sync );

/////////////////////////////////////////////////////////////////////////////
//  Method:  int I2CReadSync( void )
//  Purpose: Read I2C sync value
//  Input:   None
//  Output:  None
//  Return:  Sync value
/////////////////////////////////////////////////////////////////////////////
int       I2CReadSync( void );

/////////////////////////////////////////////////////////////////////////////
//  Method:  int I2CGetLastError( void )
//  Purpose: Obtain last error number
//  Input:   None
//  Output:  None
//  Return:  Last error number
/////////////////////////////////////////////////////////////////////////////
int       I2CGetLastError( void );


#ifdef __cplusplus
}
#endif

#endif // __BT848API_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\capprop.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Capprop.h 1.5 1998/04/29 22:43:29 tomz Exp $

//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

//
// Property set for the Video Crossbar
//

#include "mytypes.h"

DEFINE_KSPROPERTY_TABLE(XBarProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_CAPS,   // PropertyId
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_CAPS_S),    // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_CAPS_S),    // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_CAN_ROUTE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_ROUTE,
        true,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_ROUTE_S),    // MinData
        true,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CROSSBAR_PININFO,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_CROSSBAR_PININFO_S),    // MinProperty
        sizeof(KSPROPERTY_CROSSBAR_PININFO_S),    // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    )
};

#if 1
//
// Property set for the TVTuner
//

DEFINE_KSPROPERTY_TABLE(TVTunerProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_CAPS_S),        // MinProperty
        sizeof(KSPROPERTY_TUNER_CAPS_S),        // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_MODE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_MODE_S),        // MinProperty
        sizeof(KSPROPERTY_TUNER_MODE_S),        // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_MODE_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_MODE_CAPS_S),   // MinProperty
        sizeof(KSPROPERTY_TUNER_MODE_CAPS_S),   // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_STANDARD,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_STANDARD_S),    // MinProperty
        sizeof(KSPROPERTY_TUNER_STANDARD_S),    // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_FREQUENCY,
        FALSE,                                  // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_FREQUENCY_S),   // MinProperty
        sizeof(KSPROPERTY_TUNER_FREQUENCY_S),   // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_INPUT,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_INPUT_S),       // MinProperty
        sizeof(KSPROPERTY_TUNER_INPUT_S),       // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TUNER_STATUS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TUNER_STATUS_S),      // MinProperty
        sizeof(KSPROPERTY_TUNER_STATUS_S),      // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    )
};
#endif

// ------------------------------------------------------------------------
// Property set for the TVAudio
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(TVAudioProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TVAUDIO_CAPS,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TVAUDIO_CAPS_S),      // MinProperty
        sizeof(KSPROPERTY_TVAUDIO_CAPS_S),      // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TVAUDIO_MODE,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TVAUDIO_S),           // MinProperty
        sizeof(KSPROPERTY_TVAUDIO_S),           // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY_TVAUDIO_S),           // MinProperty
        sizeof(KSPROPERTY_TVAUDIO_S),           // MinData
        FALSE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
};

// ------------------------------------------------------------------------
// Property set for VideoProcAmp
// ------------------------------------------------------------------------

//
// First define all of the ranges and stepping values
//

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG BrightnessRangeAndStep [] =
{
   {
      10000 / 10,         // SteppingDelta (range / steps)
      0,                  // Reserved
      {
         {
            0,                  // Minimum in (IRE * 100) units
            10000               // Maximum in (IRE * 100) units
         }
      }
   }
};

static const ULONG BrightnessDefault = 5000;

static KSPROPERTY_MEMBERSLIST BrightnessMembersList [] =
{
   {
      {
          KSPROPERTY_MEMBER_RANGES,
          sizeof (BrightnessRangeAndStep),
          SIZEOF_ARRAY (BrightnessRangeAndStep),
          0
      },
      (PVOID) BrightnessRangeAndStep
   },
   {
     {
         KSPROPERTY_MEMBER_VALUES,
         sizeof( BrightnessDefault ),
         sizeof( BrightnessDefault ),
         KSPROPERTY_MEMBER_FLAG_DEFAULT
     },
     (PVOID) &BrightnessDefault
   }
};

static KSPROPERTY_VALUES BrightnessValues =
{
   {
      {
         STATICGUIDOF( KSPROPTYPESETID_General ),
         VT_I4,
         0
      }
   },
   SIZEOF_ARRAY( BrightnessMembersList ),
   BrightnessMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG ContrastRangeAndStep [] =
{
   {
      10000 / 256,        // SteppingDelta (range / steps)
      0,                  // Reserved
      {
         {
            0,                  // Minimum in (gain * 100) units
            10000               // Maximum in (gain * 100) units
         }
      }
   }
};

static const ULONG ContrastDefault = 5000;

static KSPROPERTY_MEMBERSLIST ContrastMembersList [] =
{
   {
      {
         KSPROPERTY_MEMBER_RANGES,
         sizeof( ContrastRangeAndStep ),
         SIZEOF_ARRAY( ContrastRangeAndStep ),
         0
      },
      (PVOID) ContrastRangeAndStep
   },
   {
     {
         KSPROPERTY_MEMBER_VALUES,
         sizeof( ContrastDefault ),
         sizeof( ContrastDefault ),
         KSPROPERTY_MEMBER_FLAG_DEFAULT
     },
     (PVOID) &ContrastDefault
   }
};

static KSPROPERTY_VALUES ContrastValues =
{
   {
      {
         STATICGUIDOF( KSPROPTYPESETID_General ),
         VT_I4,
         0
      }
   },
   SIZEOF_ARRAY( ContrastMembersList ),
   ContrastMembersList
};

// ------------------------------------------------------------------------
static KSPROPERTY_STEPPING_LONG HueRangeAndStep [] =
{
   {
      10000 / 256,        // SteppingDelta (range / steps)
      0,                  // Reserved
      {
         {
            0,                  // Minimum in (gain * 100) units
            10000               // Maximum in (gain * 100) units
         }
      }
   }
};

static const ULONG HueDefault = 5000;

static KSPROPERTY_MEMBERSLIST HueMembersList [] =
{
   {
      {
         KSPROPERTY_MEMBER_RANGES,
         sizeof( HueRangeAndStep ),
         SIZEOF_ARRAY( HueRangeAndStep ),
         0
      },
      (PVOID) HueRangeAndStep
   },
   {
     {
         KSPROPERTY_MEMBER_VALUES,
         sizeof( HueDefault ),
         sizeof( HueDefault ),
         KSPROPERTY_MEMBER_FLAG_DEFAULT
     },
     (PVOID) &HueDefault
   }
};

static KSPROPERTY_VALUES HueValues =
{
   {
      {
         STATICGUIDOF( KSPROPTYPESETID_General ),
         VT_I4,
         0
      }
   },
   SIZEOF_ARRAY( HueMembersList ),
   HueMembersList
};

static KSPROPERTY_STEPPING_LONG SaturationRangeAndStep [] =
{
   {
      10000 / 256,        // SteppingDelta (range / steps)
      0,                  // Reserved
      {
         {
            0,                  // Minimum in (gain * 100) units
            10000               // Maximum in (gain * 100) units
         }
      }
   }
};

static const ULONG SaturationDefault = 5000;

static KSPROPERTY_MEMBERSLIST SaturationMembersList [] =
{
   {
      {
         KSPROPERTY_MEMBER_RANGES,
         sizeof( SaturationRangeAndStep ),
         SIZEOF_ARRAY( SaturationRangeAndStep ),
         0
      },
      (PVOID) SaturationRangeAndStep
   },
   {
     {
         KSPROPERTY_MEMBER_VALUES,
         sizeof( SaturationDefault ),
         sizeof( SaturationDefault ),
         KSPROPERTY_MEMBER_FLAG_DEFAULT
     },
     (PVOID) &SaturationDefault
   }
};

static KSPROPERTY_VALUES SaturationValues =
{
   {
      {
         STATICGUIDOF( KSPROPTYPESETID_General ),
         VT_I4,
         0
      }
   },
   SIZEOF_ARRAY( SaturationMembersList ),
   SaturationMembersList
};


// ------------------------------------------------------------------------
DEFINE_KSPROPERTY_TABLE(VideoProcAmpProperties)
{
   DEFINE_KSPROPERTY_ITEM
   (
      KSPROPERTY_VIDEOPROCAMP_CONTRAST,
      TRUE,                                   // GetSupported or Handler
      sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
      sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
      TRUE,                                   // SetSupported or Handler
      &ContrastValues,                        // Values
      0,                                      // RelationsCount
      NULL,                                   // Relations
      NULL,                                   // SupportHandler
      sizeof(ULONG)                           // SerializedSize
   ),
   DEFINE_KSPROPERTY_ITEM
   (
      KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,
      TRUE,                                   // GetSupported or Handler
      sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
      sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
      TRUE,                                   // SetSupported or Handler
      &BrightnessValues,                      // Values
      0,                                      // RelationsCount
      NULL,                                   // Relations
      NULL,                                   // SupportHandler
      sizeof(ULONG)                           // SerializedSize
   ),
   DEFINE_KSPROPERTY_ITEM
   (
      KSPROPERTY_VIDEOPROCAMP_HUE,
      TRUE,                                   // GetSupported or Handler
      sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
      sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
      TRUE,                                   // SetSupported or Handler
      &HueValues,                             // Values
      0,                                      // RelationsCount
      NULL,                                   // Relations
      NULL,                                   // SupportHandler
      sizeof( ULONG )                         // SerializedSize
   ),
   DEFINE_KSPROPERTY_ITEM
   (
      KSPROPERTY_VIDEOPROCAMP_SATURATION,
      TRUE,                                   // GetSupported or Handler
      sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinProperty
      sizeof(KSPROPERTY_VIDEOPROCAMP_S),      // MinData
      TRUE,                                   // SetSupported or Handler
      &SaturationValues,                      // Values
      0,                                      // RelationsCount
      NULL,                                   // Relations
      NULL,                                   // SupportHandler
      sizeof( ULONG )                         // SerializedSize
   )
};

// Analog Video Decoder Properties
DEFINE_KSPROPERTY_TABLE( VideoDecProperties )
{
   DEFINE_KSPROPERTY_ITEM
   (
      KSPROPERTY_VIDEODECODER_CAPS,
      true,                                   // GetSupported or Handler
      sizeof(KSPROPERTY_VIDEODECODER_CAPS_S), // MinProperty
      sizeof(KSPROPERTY_VIDEODECODER_CAPS_S), // MinData
      false,                                   // SetSupported or Handler
      NULL,                                   // Values
      0,                                      // RelationsCount
      NULL,                                   // Relations
      NULL,                                   // SupportHandler
      sizeof( ULONG )                         // SerializedSize
   ),
   DEFINE_KSPROPERTY_ITEM
   (
      KSPROPERTY_VIDEODECODER_STANDARD,
      true,                                   // GetSupported or Handler
      sizeof(KSPROPERTY_VIDEODECODER_S), // MinProperty
      sizeof(KSPROPERTY_VIDEODECODER_S), // MinData
      true,                                   // SetSupported or Handler
      NULL,                                   // Values
      0,                                      // RelationsCount
      NULL,                                   // Relations
      NULL,                                   // SupportHandler
      sizeof( ULONG )                         // SerializedSize
   ),
   DEFINE_KSPROPERTY_ITEM
   (
      KSPROPERTY_VIDEODECODER_STATUS,
      true,                                   // GetSupported or Handler
      sizeof(KSPROPERTY_VIDEODECODER_STATUS_S), // MinProperty
      sizeof(KSPROPERTY_VIDEODECODER_STATUS_S), // MinData
      true,                                   // SetSupported or Handler
      NULL,                                   // Values
      0,                                      // RelationsCount
      NULL,                                   // Relations
      NULL,                                   // SupportHandler
      sizeof( ULONG )                         // SerializedSize
   )
};

//
// All of the property sets supported by the adapter
//

DEFINE_KSPROPERTY_SET_TABLE(AdapterPropertyTable)
{
    DEFINE_KSPROPERTY_SET
    (
        &PROPSETID_VIDCAP_CROSSBAR,               // Set
        SIZEOF_ARRAY(XBarProperties),                   // PropertiesCount
        XBarProperties,                                 // PropertyItem
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    (
        &PROPSETID_TUNER,
        SIZEOF_ARRAY(TVTunerProperties),
        TVTunerProperties,
        0,
        NULL
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &PROPSETID_VIDCAP_TVAUDIO,
        SIZEOF_ARRAY(TVAudioProperties),
        TVAudioProperties,
        0, 
        NULL
    ),
    DEFINE_KSPROPERTY_SET
    (
        &PROPSETID_VIDCAP_VIDEOPROCAMP,
        SIZEOF_ARRAY(VideoProcAmpProperties),
        VideoProcAmpProperties,
        0,
        NULL
    ),
    DEFINE_KSPROPERTY_SET
    (
        &PROPSETID_VIDCAP_VIDEODECODER,
        SIZEOF_ARRAY(VideoDecProperties),
        VideoDecProperties,
        0,
        NULL
    )
};

#define NUMBER_OF_ADAPTER_PROPERTY_SETS (SIZEOF_ARRAY (AdapterPropertyTable))



VOID AdapterSetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID AdapterGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\bti2c.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Bti2c.h 1.4 1998/04/29 22:43:27 tomz Exp $

#ifndef __I2C_H
#define __I2C_H

#include "regField.h"
#include "viddefs.h"
#include "retcode.h"
#include "i2cerr.h"


//#define HAUPPAUGEI2CPROVIDER


#ifdef HAUPPAUGEI2CPROVIDER
//	#include "hcwWDM.h"

// Need to define for brooktree i2c calls
/* Type: Level
 * Purpose: used to define a pin state
 */
typedef enum { LevelLow, LevelHi } Level;

#endif

/////////////////////////////////////////////////////////////////////////////
// CLASS I2C
//
// Description:
//    This class encapsulates the register fields in the I2C register of the
//    Bt848. A complete set of functions are developed to manipulate all the
//    register fields in the I2C for the Bt848.
//
/////////////////////////////////////////////////////////////////////////////

class I2C
{
private:
   // define which mode the I2C is selected
   enum I2CMode { I2CMode_None, I2CMode_HW, I2CMode_SW };
   
   bool    initOK;      // initialization is successful?
   DWORD   cycle;       // software control of frequency
   int     errNum;      // error number
   I2CMode mode;        // which mode the I2C is running in

//**************************************************************************
//	Structures
//**************************************************************************
union shadow
{
   struct _i2c_reg    // I2C register structure
   {
      unsigned int sda:1;
      unsigned int scl:1;
      unsigned int w3b:1;
      unsigned int sync:1;
      unsigned int div:4;
      unsigned int byte2:8;
      unsigned int byte1:8;
      unsigned int addr_rw:8;
   } i2cShadow;
   DWORD Initer;
} sh;

protected:
   RegisterDW decRegINT_STAT;
   RegField decFieldI2CDONE;
   RegField decFieldRACK;
   RegisterDW decRegI2C;
   RegField decFieldI2CDB0;
   RegField decFieldI2CDB1;
   RegField decFieldI2CDB2;
   RegField decFieldI2CDIV;
   RegField decFieldSYNC;
   RegField decFieldW3B;
   RegField decFieldSCL;
   RegField decFieldSDA;

public:
   // constructor and destructor
	I2C( void );
	~I2C();

   // member functions
   bool      IsInitOK( void );
#ifdef	HARDWAREI2C
   ErrorCode I2CInitHWMode( long freq );
   int       I2CReadDiv( void );
   ErrorCode I2CHWRead( BYTE address, BYTE *value );
   ErrorCode I2CHWWrite2( BYTE address, BYTE value1 );
   ErrorCode I2CHWWrite3( BYTE address, BYTE value1, BYTE value2 );
   ErrorCode I2CSetSync( State );
   int       I2CReadSync( void );
#endif
   void      I2CSetFreq( long freq );
   int       I2CGetLastError( void );
#ifdef HAUPPAUGEI2CPROVIDER
   ErrorCode I2CInitSWMode( long freq );
   ErrorCode I2CSWStart( void );
   ErrorCode I2CSWStop( void );
   ErrorCode I2CSWRead( BYTE * value );
   ErrorCode I2CSWWrite( BYTE value );
   ErrorCode I2CSWSendACK( void );
   ErrorCode I2CSWSendNACK( void );
   ErrorCode I2CSWSetSCL( Level );
   int       I2CSWReadSCL( void );
   ErrorCode I2CSWSetSDA( Level );
   int       I2CSWReadSDA( void );
#endif

private:
   void      I2CResetShadow( void );      // reset register shadow
   ErrorCode I2CHWWaitUntilDone( int );   // wait until I2C completes operation
   bool      I2CHWIsDone( void );         // check interrupt bit for operation done
   bool      I2CHWReceivedACK( void );    // check interrupt bit for received ACK
   void      I2CSWBitDelay( void );       // insert delay to simulate frequency
   ErrorCode I2CSWWaitForACK( void );     // wait for ACK from receiver using software
};


#endif // __I2C_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\capstrm.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Capstrm.h 1.14 1998/05/01 05:05:10 tomz Exp $

//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __CAPSTRM_H__
#define __CAPSTRM_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


//---------------------------------------------------------------------------
// All of the data formats we might use
//---------------------------------------------------------------------------

#include "rgb24fmt.h"
#include "rgb16fmt.h"
#include "yuvfmt.h"
#include "vbifmt.h"

//---------------------------------------------------------------------------
//  Stream 0 (Capture) Formats
//---------------------------------------------------------------------------

PKSDATAFORMAT Stream0Formats[] =
{
   // prefer RGB first for capture
   
   (PKSDATAFORMAT) &StreamFormatRGB555,
   //(PKSDATAFORMAT) &StreamFormatRGB565,
   (PKSDATAFORMAT) &StreamFormatRGB24Bpp,

   (PKSDATAFORMAT) &StreamFormatYUY2
   //(PKSDATAFORMAT) &StreamFormatYVYU,
   //(PKSDATAFORMAT) &StreamFormatUYVY,
   //(PKSDATAFORMAT) &StreamFormatYVU9
};
#define NUM_STREAM_0_FORMATS (sizeof (Stream0Formats) / sizeof (PKSDATAFORMAT))

//---------------------------------------------------------------------------
//  Stream 1 (Preview) Formats
//---------------------------------------------------------------------------

PKSDATAFORMAT Stream1Formats[] =
{
   // prefer YUV first for preview
#if 0
	//TODO: leave VIDEOINFOHEADER2 out for now
   (PKSDATAFORMAT) &StreamFormat2YUY2,
   (PKSDATAFORMAT) &StreamFormat2RGB555,
   (PKSDATAFORMAT) &StreamFormat2RGB24Bpp,
#else
   (PKSDATAFORMAT) &StreamFormatYUY2,
   (PKSDATAFORMAT) &StreamFormatRGB555,
   (PKSDATAFORMAT) &StreamFormatRGB24Bpp
#endif
   //(PKSDATAFORMAT) &StreamFormatYVYU,
   //(PKSDATAFORMAT) &StreamFormatUYVY,
   //(PKSDATAFORMAT) &StreamFormatYVU9,
   //(PKSDATAFORMAT) &StreamFormatRGB565,
};
#define NUM_STREAM_1_FORMATS (sizeof (Stream1Formats) / sizeof (PKSDATAFORMAT))

//---------------------------------------------------------------------------
//  VBI Stream Formats
//---------------------------------------------------------------------------

PKSDATAFORMAT VBIStreamFormats[] =
{
   (PKSDATAFORMAT) &StreamFormatVBI
};

#define NUM_VBI_FORMATS (sizeof (VBIStreamFormats) / sizeof (PKSDATAFORMAT))

//---------------------------------------------------------------------------
//  Analog Video Stream Formats
//---------------------------------------------------------------------------

static KS_DATARANGE_ANALOGVIDEO StreamFormatAnalogVideo =
{
   // KS_DATARANGE_ANALOGVIDEO
   {
      {
         sizeof( KS_DATARANGE_ANALOGVIDEO ),
         0,
         sizeof (KS_TVTUNER_CHANGE_INFO),        // SampleSize
         0,
         { 0x482dde1, 0x7817, 0x11cf, { 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65 } },  // MEDIATYPE_AnalogVideo
         { 0x482dde2, 0x7817, 0x11cf, { 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65 } },  // WILDCARD
         { 0x482dde0, 0x7817, 0x11cf, { 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65 } }  // FORMAT_AnalogVideo
      }
   },
   // KS_ANALOGVIDEOINFO
   {
      { 0, 0, 720, 480 },         // rcSource;
      { 0, 0, 720, 480 },         // rcTarget;
      720,                    // dwActiveWidth;
      480,                    // dwActiveHeight;
      0,                      // REFERENCE_TIME  AvgTimePerFrame;
   }
};

static PKSDATAFORMAT AnalogVideoFormats[] =
{
   (PKSDATAFORMAT) &StreamFormatAnalogVideo,
};
#define NUM_ANALOG_VIDEO_FORMATS SIZEOF_ARRAY( AnalogVideoFormats )

// ------------------------------------------------------------------------
// Property set for all video capture streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE( VideoStreamConnectionProperties )
{
   DEFINE_KSPROPERTY_ITEM
   (
      KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
      TRUE,                                   // GetSupported or Handler
      sizeof( KSPROPERTY ),                   // MinProperty
      sizeof( KSALLOCATOR_FRAMING ),          // MinData
      FALSE,                                  // SetSupported or Handler
      NULL,                                   // Values
      0,                                      // RelationsCount
      NULL,                                   // Relations
      NULL,                                   // SupportHandler
      sizeof( ULONG )                         // SerializedSize
   )
};


// ------------------------------------------------------------------------
// Array of all of the property sets supported by video streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE( VideoStreamProperties )
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Connection,                          // Set
        SIZEOF_ARRAY( VideoStreamConnectionProperties ),  // PropertiesCount
        VideoStreamConnectionProperties,                  // PropertyItem
        0,                                                // FastIoCount
        NULL                                              // FastIoTable
    )
};

#define NUMBER_VIDEO_STREAM_PROPERTIES (SIZEOF_ARRAY(VideoStreamProperties))


//---------------------------------------------------------------------------
// Create an array that holds the list of all of the streams supported
//---------------------------------------------------------------------------

typedef struct _ALL_STREAM_INFO {
    HW_STREAM_INFORMATION   hwStreamInfo;
    HW_STREAM_OBJECT        hwStreamObject;
} ALL_STREAM_INFO, *PALL_STREAM_INFO;

ALL_STREAM_INFO Streams [] =
{
   // -----------------------------------------------------------------
   // Stream 0
   // -----------------------------------------------------------------

   // HW_STREAM_INFORMATION -------------------------------------------
   {
      {
         1,                                              // NumberOfPossibleInstances
         KSPIN_DATAFLOW_OUT,                             // DataFlow
         TRUE,                                           // DataAccessible
         NUM_STREAM_0_FORMATS,                           // NumberOfFormatArrayEntries
         Stream0Formats,                                 // StreamFormatsArray
         {
            0,                                              // ClassReserved[0]
            0,                                              // ClassReserved[1]
            0,                                              // ClassReserved[2]
            0                                               // ClassReserved[3]
         },
         NUMBER_VIDEO_STREAM_PROPERTIES,                 // NumStreamPropArrayEntries
         (PKSPROPERTY_SET)VideoStreamProperties,         // StreamPropertiesArray
         0,                                              // NumStreamEventArrayEntries;
         0,                                              // StreamEventsArray;
         (GUID *) &PINNAME_VIDEO_CAPTURE,                // Category
         (GUID *) &PINNAME_VIDEO_CAPTURE,                // Name
         1,                                              // MediumsCount
         &CaptureMediums[0],                             // Mediums
      },
		// HW_STREAM_OBJECT ------------------------------------------------
		{
			sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
			0,                                      // StreamNumber
			0,                                      // HwStreamExtension
			VideoReceiveDataPacket,                 // HwReceiveDataPacket
			VideoReceiveCtrlPacket,                 // HwReceiveControlPacket
			{ NULL, 0 },                            // HW_CLOCK_OBJECT
			FALSE,                                  // Dma
			TRUE,                                   // Pio
			NULL,                                   // HwDeviceExtension
			sizeof (KS_FRAME_INFO),                 // StreamHeaderMediaSpecific
			0,                                      // StreamHeaderWorkspace 
			TRUE,                                  // Allocator 
			NULL,                                   // HwEventRoutine
			{ 0, 0 },                               // Reserved[2]
		},            
   },

   // -----------------------------------------------------------------
   // Stream 1
   // -----------------------------------------------------------------

   // HW_STREAM_INFORMATION -------------------------------------------
   {
      {
         1,                                              // NumberOfPossibleInstances
         KSPIN_DATAFLOW_OUT,                             // DataFlow
         TRUE,                                           // DataAccessible
         NUM_STREAM_1_FORMATS,                           // NumberOfFormatArrayEntries
         Stream1Formats,                                 // StreamFormatsArray
         {
            0,                                              // ClassReserved[0]
            0,                                              // ClassReserved[1]
            0,                                              // ClassReserved[2]
            0                                               // ClassReserved[3]
         },
         NUMBER_VIDEO_STREAM_PROPERTIES,                 // NumStreamPropArrayEntries
         (PKSPROPERTY_SET)VideoStreamProperties,         // StreamPropertiesArray
         0,                                              // NumStreamEventArrayEntries;
         0,                                              // StreamEventsArray;
         //(GUID *) &PINNAME_VIDEO_VIDEOPORT,                // Category
         //(GUID *) &PINNAME_VIDEO_VIDEOPORT,                // Name
         (GUID *) &PINNAME_VIDEO_PREVIEW,                // Category
         (GUID *) &PINNAME_VIDEO_PREVIEW,                // Name
         1,                                              // MediumsCount
         &CaptureMediums[1],                             // Mediums
      },
		// HW_STREAM_OBJECT ------------------------------------------------
		{
			sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
			1,                                      // StreamNumber
			0,                                      // HwStreamExtension
			VideoReceiveDataPacket,                 // HwReceiveDataPacket
			VideoReceiveCtrlPacket,                 // HwReceiveControlPacket
			{ NULL, 0 },                            // HW_CLOCK_OBJECT
			FALSE,                                  // Dma
			TRUE,                                   // Pio
			0,                                      // HwDeviceExtension
			sizeof (KS_FRAME_INFO),                 // StreamHeaderMediaSpecific
			0,                                      // StreamHeaderWorkspace 
			TRUE,                                  // Allocator 
			NULL,                                   // HwEventRoutine
			{ 0, 0 },                               // Reserved[2]
		},

   },
   // -----------------------------------------------------------------
   // VBI Stream 
   // -----------------------------------------------------------------

   // HW_STREAM_INFORMATION -------------------------------------------
   {
      {
         1,                                              // NumberOfPossibleInstances
         KSPIN_DATAFLOW_OUT,                             // DataFlow
         TRUE,                                           // DataAccessible
         NUM_VBI_FORMATS,                                // NumberOfFormatArrayEntries
         VBIStreamFormats,                               // StreamFormatsArray
         {
            0,                                           // ClassReserved[0]
            0,                                           // ClassReserved[1]
            0,                                           // ClassReserved[2]
            0                                            // ClassReserved[3]
         },
/*[TMZ]*/         NUMBER_VIDEO_STREAM_PROPERTIES,                 // NumStreamPropArrayEntries
/*[TMZ]*/         (PKSPROPERTY_SET)VideoStreamProperties,         // StreamPropertiesArray
         0,                                              // NumStreamEventArrayEntries;
         0,                                              // StreamEventsArray;
#if 1 // [TMZ] [!!!] [HACK] - ALLOW_VBI_PIN
         (GUID *) &PINNAME_VIDEO_VBI,                    // Category
         (GUID *) &PINNAME_VIDEO_VBI,                    // Name
#else
         (GUID *) &PINNAME_VIDEO_STILL,                // Category
         (GUID *) &PINNAME_VIDEO_STILL,                // Name
#endif
         0, //1,                                              // MediumsCount
         NULL, //&CaptureMediums[2],                             // Mediums
      },
		// HW_STREAM_OBJECT ------------------------------------------------
		{
			sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
			2,                                      // StreamNumber
			0,                                      // HwStreamExtension
			VideoReceiveDataPacket,                 // HwReceiveDataPacket
			VideoReceiveCtrlPacket,                 // HwReceiveControlPacket
			{ NULL, 0 },                            // HW_CLOCK_OBJECT
			FALSE,                                  // Dma
			TRUE,                                   // Pio
			0,                                      // HwDeviceExtension
			sizeof (KS_VBI_FRAME_INFO),             // StreamHeaderMediaSpecific
			0,                                      // StreamHeaderWorkspace 
			TRUE,                                   // Allocator 
			NULL,                                   // HwEventRoutine
			{ 0, 0 },                               // Reserved[2]
		}

   },
   // -----------------------------------------------------------------
   // Analog Video Input Stream
   // -----------------------------------------------------------------

   // HW_STREAM_INFORMATION -------------------------------------------
   {
      {
         1,                                      // NumberOfPossibleInstances
         KSPIN_DATAFLOW_IN,                      // DataFlow
         TRUE,                                   // DataAccessible
         NUM_ANALOG_VIDEO_FORMATS,               // NumberOfFormatArrayEntries
         AnalogVideoFormats,                     // StreamFormatsArray
         {
            0,                                   // ClassReserved[0]
            0,                                   // ClassReserved[1]
            0,                                   // ClassReserved[2]
            0                                    // ClassReserved[3]
         },
         0,                                      // NumStreamPropArrayEntries
         0,                                      // StreamPropertiesArray
         0,                                      // NumStreamEventArrayEntries;
         0,                                      // StreamEventsArray;
         (GUID *) &PINNAME_VIDEO_ANALOGVIDEOIN,  // Category
         (GUID *) &PINNAME_VIDEO_ANALOGVIDEOIN,  // Name
         1,                                      // MediumsCount
         &CaptureMediums[3],                     // Mediums
      },
		// HW_STREAM_OBJECT ------------------------------------------------
		{
			sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
			3,                                      // StreamNumber
			0,                                      // HwStreamExtension
			VideoReceiveDataPacket,				       // HwReceiveDataPacket
			VideoReceiveCtrlPacket,			          // HwReceiveControlPacket
			{ NULL, 0 },                            // HW_CLOCK_OBJECT
			FALSE,                                  // Dma
			TRUE,                                   // Pio
			0,                                      // HwDeviceExtension
			0,                                      // StreamHeaderMediaSpecific
			0,                                      // StreamHeaderWorkspace 
			TRUE,                                   // Allocator 
			NULL,                                   // HwEventRoutine
			{ 0, 0 },                               // Reserved[2]
		}
   }

};


#define DRIVER_STREAM_COUNT (sizeof (Streams) / sizeof (ALL_STREAM_INFO))


//---------------------------------------------------------------------------
// Topology
//---------------------------------------------------------------------------

// Categories define what the device does.

static GUID Categories[] = {
    { STATIC_KSCATEGORY_VIDEO },
    { STATIC_KSCATEGORY_CAPTURE },
    { STATIC_KSCATEGORY_TVTUNER },
    { STATIC_KSCATEGORY_CROSSBAR },
    { STATIC_KSCATEGORY_TVAUDIO }
};

#define NUMBER_OF_CATEGORIES  SIZEOF_ARRAY (Categories)

static KSTOPOLOGY Topology = {
   NUMBER_OF_CATEGORIES,
   (GUID*) &Categories,
   0,
   NULL,
   0,
   NULL
};

//---------------------------------------------------------------------------
// The Main stream header
//---------------------------------------------------------------------------

static HW_STREAM_HEADER StreamHeader = 
{
   DRIVER_STREAM_COUNT,                // NumberOfStreams
   sizeof( HW_STREAM_INFORMATION ),    // Future proofing
   0,                                  // NumDevPropArrayEntries set at init time
   NULL,                               // DevicePropertiesArray  set at init time
   0,                                  // NumDevEventArrayEntries;
   NULL,                               // DeviceEventsArray;
   &Topology                           // Pointer to Device Topology
};


#ifdef    __cplusplus
}
#endif // __cplusplus

#endif // __CAPSTRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\colfrmat.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Colfrmat.h 1.4 1998/04/29 22:43:30 tomz Exp $

#ifndef __COLFRMAT_H
#define __COLFRMAT_H


/* Type: ColorFormat
 * Purpose: Enumerates all possible color formats that BtPisces can produce
 */

#ifdef DOCUMENTATION
   Color Format Register Settings

   0000 = RGB32
   0001 = RGB24
   0010 = RGB16
   0011 = RGB15
   0100 = YUY2 4:2:2
   0101 = BtYUV 4:1:1
   0110 = Y8
   0111 = RGB8 (Dithered)
   1000 = YCrCb 4:2:2 Planar
   1001 = YCrCb 4:1:1 Planar
   1010 = Reserved
   1011 = Reserved
   1100 = Reserved
   1101 = Reserved
   1110 = Raw 8X Data
   1111 = Reserved
#endif

typedef enum
{
   CF_BelowRange = -1, CF_RGB32, CF_RGB24, CF_RGB16, CF_RGB15, CF_YUY2,
   CF_BTYUV, CF_Y8, CF_RGB8, CF_PL_422, CF_PL_411, CF_YUV9, CF_YUV12, CF_VBI,
   CF_UYVY, CF_RAW = 0x0E, CF_I420, CF_AboveRange
} ColFmt;


#endif // __COLFRMAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\capvideo.c ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Capvideo.c 1.11 1998/05/08 00:11:02 tomz Exp $

//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

extern "C" {
#include "strmini.h"
#include "ksmedia.h"
#include "ddkmapi.h"
}

#include "capdebug.h"
#include "device.h"
#include "capmain.h"

#define DD_OK 0

ErrorCode VerifyVideoStream( const KS_DATAFORMAT_VIDEOINFOHEADER &vidHDR );
ErrorCode VerifyVideoStream2( const KS_DATAFORMAT_VIDEOINFOHEADER2 &vidHDR );
ErrorCode VerifyVBIStream( const KS_DATAFORMAT_VBIINFOHEADER &rKSDataFormat );

void CheckSrbStatus( PHW_STREAM_REQUEST_BLOCK pSrb );

// notify class we are ready to rock
void STREAMAPI StreamCompleterData( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("StreamCompleterData()");

   DebugOut((1, "*** 1 *** completing SRB %x\n", pSrb));
   CheckSrbStatus( pSrb );
   StreamClassStreamNotification( StreamRequestComplete, pSrb->StreamObject, pSrb );
   StreamClassStreamNotification( ReadyForNextStreamDataRequest, pSrb->StreamObject );
}

// notify class we are ready to rock
void STREAMAPI StreamCompleterControl( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("StreamCompleterControl()");

   CheckSrbStatus( pSrb );
   StreamClassStreamNotification( StreamRequestComplete, pSrb->StreamObject, pSrb );
   StreamClassStreamNotification( ReadyForNextStreamControlRequest, pSrb->StreamObject );
}

/* Function: ProposeDataFormat
 * Purpose: Verifies that data format can be supported
 * Input: SRB
 */
void ProposeDataFormat( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("ProposeDataFormat()");

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   VideoStream StreamNumber = (VideoStream)pSrb->StreamObject->StreamNumber;

   if ( StreamNumber == STREAM_IDX_VBI ) {
      const KS_DATAFORMAT_VBIINFOHEADER &rKSVBIDataFormat =
         *(PKS_DATAFORMAT_VBIINFOHEADER) pSrb->CommandData.OpenFormat;
      if ( VerifyVBIStream( rKSVBIDataFormat ) != Success )
         pSrb->Status = STATUS_INVALID_PARAMETER;
      return;
   }
   const KS_DATAFORMAT_VIDEOINFOHEADER &rKSDataFormat =
      *(PKS_DATAFORMAT_VIDEOINFOHEADER) pSrb->CommandData.OpenFormat;
   const KS_DATAFORMAT_VIDEOINFOHEADER2 &rKSDataFormat2 =
      *(PKS_DATAFORMAT_VIDEOINFOHEADER2) pSrb->CommandData.OpenFormat;

   DebugOut((1, "Proposed Data format\n"));
   if ( VerifyVideoStream( rKSDataFormat ) != Success )
	{
	   if ( VerifyVideoStream2( rKSDataFormat2 ) != Success )
		{
			pSrb->Status = STATUS_INVALID_PARAMETER;
		}
		else
		{
	      pSrb->ActualBytesTransferred = sizeof( KS_DATAFORMAT_VIDEOINFOHEADER2 );
		}
	}
   else
	{
      pSrb->ActualBytesTransferred = sizeof( KS_DATAFORMAT_VIDEOINFOHEADER );
	}
}

/***************************************************************************

                    Data Packet Handling Routines

***************************************************************************/

/*
** VideoReceiveDataPacket()
**
**   Receives Video data packet commands
**
** Arguments:
**
**   pSrb - Stream request block for the Video device
**
** Returns:
**
** Side Effects:  none
*/

void MockStampVBI( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   PKSSTREAM_HEADER  pDataPacket = pSrb->CommandData.DataBufferArray;

   pDataPacket->PresentationTime.Numerator = 1;
   pDataPacket->PresentationTime.Denominator = 1;
   
   pDataPacket->OptionsFlags &= ~KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;
   pDataPacket->OptionsFlags &= ~KSSTREAM_HEADER_OPTIONSF_TIMEVALID;
   pDataPacket->OptionsFlags &= ~KS_VBI_FLAG_TVTUNER_CHANGE;
   pDataPacket->OptionsFlags &= ~KS_VBI_FLAG_VBIINFOHEADER_CHANGE;
   pDataPacket->PresentationTime.Time = 0;
   pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT;
   pSrb->Status = STATUS_SUCCESS;

   CheckSrbStatus( pSrb );
   StreamClassStreamNotification( StreamRequestComplete, pSrb->StreamObject, pSrb );
}

VOID STREAMAPI VideoReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("VideoReceiveDataPacket()");

   VideoChannel *chan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;
   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;
   VideoStream StreamNumber = (VideoStream)pSrb->StreamObject->StreamNumber;

   //
   // make sure we have a device extension
   //
   DEBUG_ASSERT((ULONG)adapter);

   // default to success
   pSrb->Status = STATUS_SUCCESS;

   //
   // determine the type of packet.
   //

   DebugOut((1, "VideoReceiveDataPacket(%x) cmd(%x)\n", pSrb, pSrb->Command));

   switch ( pSrb->Command ) {
   case SRB_READ_DATA:
      //
      // remember the current srb
      //
      DebugOut((1, "PsDevice::VideoReceiveDataPacket - SRB_READ_DATA\n"));
      chan->SetSRB( pSrb );
      adapter->AddBuffer( *chan, pSrb );
      break;
   default:
      //
      // invalid / unsupported command. Fail it as such
      //
      DebugOut((1, "PsDevice::VideoReceiveDataPacket - unknown command(%x)\n", pSrb->Command));
      pSrb->Status = STATUS_NOT_IMPLEMENTED;
      StreamCompleterData( pSrb );
   }
}

/*
** VideoReceiveCtrlPacket()
**
**   Receives packet commands that control the Video stream
**
** Arguments:
**
**   pSrb - The stream request block for the Video stream
**
** Returns:
**
** Side Effects:  none
*/

VOID STREAMAPI VideoReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("VideoReceiveCtrlPacket()");

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   DEBUG_ASSERT((ULONG)adapter);

   // default to success
   pSrb->Status = STATUS_SUCCESS;
   //
   // determine the type of packet.
   //

   DebugOut((1, "VideoReceiveCtrlPacket(%x) cmd(%x)\n", pSrb, pSrb->Command));

   int Command = pSrb->Command;
   switch ( Command ) {
   case SRB_SET_STREAM_STATE:
     adapter->SetVideoState( pSrb );
     break;
   case SRB_GET_STREAM_STATE:
     adapter->GetVideoState( pSrb );
     break;
   case SRB_PROPOSE_DATA_FORMAT:
      DebugOut((1, "Propose Data Format\n"));
      ProposeDataFormat( pSrb );
      break;

   case SRB_SET_DATA_FORMAT:
      DebugOut((1, "Set Data Format\n"));
      // should re-validate just in case ?
      adapter->ProcessSetDataFormat( pSrb );
      break;

   case SRB_GET_STREAM_PROPERTY:
      adapter->GetStreamProperty( pSrb );
      break;
   case SRB_SET_STREAM_PROPERTY:
      DebugOut(( 0, "SRB_SET_STREAM_PROPERTY\n" ));
      break;
/*
   case SRB_OPEN_MASTER_CLOCK:
   case SRB_CLOSE_MASTER_CLOCK:
      //
      // This stream is being selected to provide a Master clock
      //
      adapter->SetClockMaster( pSrb );
      break;
*/
   case SRB_INDICATE_MASTER_CLOCK:
      //
      // Assigns a clock to a stream
      //
      adapter->SetClockMaster( pSrb );
      break;
   default:

     //
     // invalid / unsupported command. Fail it as such
     //

     pSrb->Status = STATUS_NOT_IMPLEMENTED;
     break;
   }
   if ( Command != SRB_SET_STREAM_STATE && 
        Command != SRB_SET_STREAM_PROPERTY &&
        Command != SRB_SET_DATA_FORMAT )
      StreamCompleterControl( pSrb );
}

/*
** GetVideoState()
**
**    Gets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID PsDevice::GetVideoState( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("PsDevice::GetVideoState()");

   VideoChannel *chan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;

   pSrb->Status = STATUS_SUCCESS;

   pSrb->CommandData.StreamState = chan->GetKSState();
   pSrb->ActualBytesTransferred = sizeof (KSSTATE);

   // A very odd rule:
   // When transitioning from stop to pause, DShow tries to preroll
   // the graph.  Capture sources can't preroll, and indicate this
   // by returning VFW_S_CANT_CUE in user mode.  To indicate this
   // condition from drivers, they must return ERROR_NO_DATA_DETECTED
   //
   // [TMZ] JayBo says KSSTATE_ACQUIRE should return success 

   if (pSrb->CommandData.StreamState == KSSTATE_PAUSE) {
      pSrb->Status = STATUS_NO_DATA_DETECTED;
   }
}

/*
** SetVideoState()
**
**    Sets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID PrintState(StreamState st)
{
   switch( st ) {
      case Started:
         DebugOut((1, "*** Streamstate was STARTED\n"));
         break;
      case Created:
         DebugOut((1, "*** Streamstate was CREATED\n"));
         break;
      case Paused:
         DebugOut((1, "*** Streamstate was PAUSED\n"));
         break;
      case Open:
         DebugOut((1, "*** Streamstate was OPEN\n"));
         break;
      default:
         DebugOut((1, "*** Streamstate was ??? (%x)\n", st));
         break;
   }
}   

VOID PsDevice::SetVideoState( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("PsDevice::SetVideoState()");

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   VideoChannel *chan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;
   VideoStream StreamNumber = (VideoStream)pSrb->StreamObject->StreamNumber;

   //
   // determine which new state is requested
   //
   pSrb->Status = STATUS_SUCCESS;
   chan->SetKSState( pSrb->CommandData.StreamState );
   
   switch ( pSrb->CommandData.StreamState ) {
   case KSSTATE_ACQUIRE:   // Documented as "same as pause for most minidrivers"
      DebugOut((1, "*** KSSTATE_ACQUIRE(%d) state(%d) falling through to PAUSE\n", StreamNumber, chan->GetState()));
   case KSSTATE_PAUSE:
      // PrintState(chan->GetState());

      DebugOut((1, "*** KSSTATE_PAUSE(%d) state(%d)\n", StreamNumber, chan->GetState()));

      switch ( chan->GetState() ) {
      case Started:
         if ( StreamNumber == 2 )
         {
            DebugOut((1, "#############################################################\n"));
            DebugOut((1, "About to pause channel %d\n", StreamNumber ));
            //adapter->CaptureContrll_.DumpRiscPrograms();
         }

         Pause( *chan ); // intentional fall-through
         
         if ( StreamNumber == 2 )
         {
            DebugOut((1, "Done pausing channel %d\n", StreamNumber ));
            DebugOut((1, "#############################################################\n"));
            //adapter->CaptureContrll_.DumpRiscPrograms();
         }
      case Created:
      case Paused:          // 2 PAUSE in a row; ignore
         StreamCompleterControl( pSrb );
         break;
      case Open:
         StreamClassCallAtNewPriority( pSrb->StreamObject, HwDeviceExtension, Low,
            PHW_PRIORITY_ROUTINE( CreateVideo ), pSrb );
         break;
      }
      break;

   case KSSTATE_STOP:
      // PrintState(chan->GetState());

      DebugOut((1, "*** KSSTATE_STOP(%d) state(%d)\n", StreamNumber, chan->GetState()));

      //
      // stop the video
      //
      switch ( chan->GetState() ) {
      default:
         if ( StreamNumber == 2 )
         {
            DebugOut((1, "'#############################################################\n"));
            DebugOut((1, "'About to pause channel %d\n", StreamNumber ));
            //adapter->CaptureContrll_.DumpRiscPrograms();
         }

         Pause( *chan ); // intentional fall-through
         
         if ( StreamNumber == 2 )
         {
            DebugOut((1, "'Done pausing channel %d\n", StreamNumber ));
            DebugOut((1, "'#############################################################\n"));
            //adapter->CaptureContrll_.DumpRiscPrograms();
         }
      case Paused:
      case Created:
         StreamClassCallAtNewPriority( pSrb->StreamObject, HwDeviceExtension, Low,
            PHW_PRIORITY_ROUTINE( DestroyVideo ), pSrb );
         break;
      }
      break;

   case KSSTATE_RUN: {
         // PrintState(chan->GetState());
      {
      VideoStream nStreamNumber = (VideoStream)pSrb->StreamObject->StreamNumber;
      DebugOut((1, "*** KSSTATE_RUN(%d)\n", nStreamNumber));
      }

         //
         // play the video
         //
         StreamState st = chan->GetState();
         if ( st != Created && st != Paused ) {
            DebugOut((1, "*** KSSTATE_RUN Error (st == %d)\n", st));
            pSrb->Status = STATUS_IO_DEVICE_ERROR;
         } else {
            Start( *chan );
         }

         StreamCompleterControl( pSrb );
      }
      break;
   default:
      DebugOut((0, "*** KSSTATE_??? (%x)\n", pSrb->CommandData.StreamState));

      pSrb->Status = STATUS_SUCCESS;
      StreamCompleterControl( pSrb );
      break;
   }
   // when going to paused mode from open and stopping, notification is done in callback
}

/* Method: PsDevice::StartVideo
 * Purpose: Starts a stream
 * Input: pSrb
 */
void STREAMAPI PsDevice::StartVideo( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("PsDevice::StartVideo()");

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   VideoChannel *chan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;

   // restart the stream
   adapter->Start( *chan );
   adapter->Pause( *chan );
   
   // finally, can complete the SET dataformat SRB
   // StreamCompleterControl( pSrb );

   // cannot call any other class' services; have to schedule a callback
   StreamClassCallAtNewPriority( pSrb->StreamObject, HwDeviceExtension, LowToHigh,
      PHW_PRIORITY_ROUTINE( StreamCompleterControl ), pSrb );
}

/* Method: PsDevice::CreateVideo
 * Purpose: Starts a stream
 * Input: pSrb
 */
void STREAMAPI PsDevice::CreateVideo( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("PsDevice::CreateVideo()");

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   VideoChannel *chan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;

   if ( adapter->Create( *chan ) != Success )
      pSrb->Status = STATUS_IO_DEVICE_ERROR;

   // cannot call any other class' services; have to schedule a callback
   StreamClassCallAtNewPriority( pSrb->StreamObject, HwDeviceExtension, LowToHigh,
      PHW_PRIORITY_ROUTINE( StreamCompleterControl ), pSrb );
}

/* Method: PsDevice::DestroyVideo
 * Purpose: Called at low priority to stop video and free the resources
 */
void STREAMAPI PsDevice::DestroyVideoNoComplete( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("PsDevice::DestroyVideoNoComplete()");

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   VideoChannel *chan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;

   // have all resources freed
   adapter->Stop( *chan );

   // set new format
   KS_DATAFORMAT_VIDEOINFOHEADER &rDataVideoInfHdr =
      *(PKS_DATAFORMAT_VIDEOINFOHEADER) pSrb->CommandData.OpenFormat;
   KS_DATAFORMAT_VIDEOINFOHEADER2 &rDataVideoInfHdr2 =
      *(PKS_DATAFORMAT_VIDEOINFOHEADER2) pSrb->CommandData.OpenFormat;

   if ( IsEqualGUID( rDataVideoInfHdr.DataFormat.Specifier, KSDATAFORMAT_SPECIFIER_VIDEOINFO ) ) 
	{
	   chan->SetVidHdr( rDataVideoInfHdr.VideoInfoHeader );
	}
	else
	{
	   chan->SetVidHdr2( rDataVideoInfHdr2.VideoInfoHeader2 );
	}

   // re-create the stream
   if ( adapter->Create( *chan ) != Success ) {
      pSrb->Status = STATUS_IO_DEVICE_ERROR;
      StreamCompleterControl( pSrb );
   } else  {

      DebugOut((1, "1 pSrb = %lx\n", pSrb));
      DebugOut((1, "1 pSrb->StreamObject = %lx\n", pSrb->StreamObject));
      DebugOut((1, "1 chan = %lx\n", chan));
      DebugOut((1, "1 HwStreamExtension = %lx\n", pSrb->StreamObject->HwStreamExtension));

      // we're already at low priority ???
      //   StreamClassCallAtNewPriority( pSrb->StreamObject, HwDeviceExtension, Low,
      //      PHW_PRIORITY_ROUTINE( StartVideo ), pSrb );
      // StartVideo( pSrb);

      // cannot call any other class' services; have to schedule a callback
      StreamClassCallAtNewPriority( pSrb->StreamObject, HwDeviceExtension, LowToHigh,
         PHW_PRIORITY_ROUTINE( StreamCompleterControl ), pSrb );
   }
}

/* Method: PsDevice::DestroyVideo
 * Purpose: Called at low priority to stop video and free the resources
 */
void STREAMAPI PsDevice::DestroyVideo( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("PsDevice::DestroyVideo()");

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;

   VideoChannel *chan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;

   adapter->Stop( *chan );

   // cannot call any other class' services; have to schedule a callback
   StreamClassCallAtNewPriority( pSrb->StreamObject, HwDeviceExtension, LowToHigh,
      PHW_PRIORITY_ROUTINE( StreamCompleterControl ), pSrb );
}

/*
** VideoGetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/
void PsDevice::GetStreamProperty( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("PsDevice::GetStreamProperty()");

   PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

   if ( IsEqualGUID( KSPROPSETID_Connection, pSPD->Property->Set ) ) {
      GetStreamConnectionProperty( pSrb );
   } else {
      pSrb->Status = STATUS_NOT_IMPLEMENTED;
   }
}

/* Method: PsDevice::ProcessSetDataFormat
 * Purpose: Implements SET KSPROPERTY_CONNECTION_DATAFORMAT
 * Input: chan: VideoChannel &
 *   VidInfHdr: KS_VIDEOINFOHEADER &
 */
void PsDevice::ProcessSetDataFormat( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("PsDevice::ProcessSetDataFormat()");
   
   VideoChannel *chan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;

   // have to stop first
   Pause( *chan );

   // destroy at low prioriy
   StreamClassCallAtNewPriority( pSrb->StreamObject, pSrb->HwDeviceExtension, Low,
      PHW_PRIORITY_ROUTINE( DestroyVideoNoComplete ), pSrb );
}

/* Method: PsDevice::GetStreamConnectionProperty
 * Purpose: Obtains allocator and state properties
 */
void PsDevice::GetStreamConnectionProperty( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("PsDevice::GetStreamConnectionProperty()");

   VideoChannel *chan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;
   PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
   ULONG Id = pSPD->Property->Id;              // index of the property

   switch ( Id ) {
   case KSPROPERTY_CONNECTION_ALLOCATORFRAMING: {


		   //KdPrint(( "KSPROPERTY_CONNECTION_ALLOCATORFRAMING\n" ));


         PKSALLOCATOR_FRAMING Framing = (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;
         Framing->RequirementsFlags   =
            KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY |
            KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
            KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY;
         Framing->PoolType = NonPagedPool;

			//KdPrint(( "Framing->Frames == 0x%08X\n", Framing->Frames ));
			if( (VideoStream)pSrb->StreamObject->StreamNumber == STREAM_IDX_VBI ) 
			{
	         Framing->Frames = 8;
			}
			else
			{
				//if( Framing->Frames == 0 )
				//{
		      //   Framing->Frames = 1;
				//}
				//else
				//{
		         Framing->Frames = 3;
				//}
			}
			if( chan->IsVideoInfo2() )
			{
				Framing->FrameSize = chan->GetVidHdr2()->bmiHeader.biSizeImage;
			}
			else
			{
				Framing->FrameSize = chan->GetVidHdr()->bmiHeader.biSizeImage;
			}
         Framing->FileAlignment = 0;//FILE_QUAD_ALIGNMENT;// PAGE_SIZE - 1;
         Framing->Reserved = 0;
         pSrb->ActualBytesTransferred = sizeof( KSALLOCATOR_FRAMING );
      }
      break;
   default:
      break;
   }
}

void PsDevice::SetClockMaster( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("PsDevice::SetClockMaster()");

   VideoChannel *chan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;
   chan->SetClockMaster( pSrb->CommandData.MasterClockHandle );
}

/* Method: AnalogReceiveDataPacket
 * Purpose: Receives data packets for analog stream ( tuner change notifications )
 * Input: SRB
 */
VOID STREAMAPI AnalogReceiveDataPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("AnalogReceiveDataPacket()");

   pSrb->Status = STATUS_SUCCESS;

   PHW_DEVICE_EXTENSION HwDeviceExtension =
      (PHW_DEVICE_EXTENSION) pSrb->HwDeviceExtension;

   PsDevice *adapter = HwDeviceExtension->psdevice;
   
   DebugOut((1, "AnalogReceiveDataPacket(%x) cmd(%x)\n", pSrb, pSrb->Command));

   switch ( pSrb->Command ) {
   case SRB_READ_DATA:
      break;
   case SRB_WRITE_DATA:
      //
      // This data packet contains the channel change information
      // passed on the AnalogVideoIn
      //
      if ( pSrb->CommandData.DataBufferArray->FrameExtent ==
           sizeof( KS_TVTUNER_CHANGE_INFO ) )
         adapter->ChangeNotifyChannels( pSrb );
      break;
    default:
      //
      // invalid / unsupported command. Fail it as such
      //
      pSrb->Status = STATUS_NOT_IMPLEMENTED;
   }
   StreamCompleterData( pSrb );
}

/* Method: AnalogReceiveCtrlPacket
 * Purpose: Receives control packets for analog stream ( are there any ? )
 * Input: SRB
 */
VOID STREAMAPI AnalogReceiveCtrlPacket( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("AnalogReceiveCtrlPacket()");

   DebugOut((1, "AnalogReceiveCtrlPacket(%x) cmd(%x)\n", pSrb, pSrb->Command));

   pSrb->Status = STATUS_SUCCESS;
   StreamCompleterControl( pSrb );
}


#ifdef ENABLE_DDRAW_STUFF

DWORD FAR PASCAL 
DirectDrawEventCallback( DWORD dwEvent, PVOID pContext, DWORD dwParam1, DWORD dwParam2 )
{
	switch( dwEvent )
	{
		case DDNOTIFY_PRERESCHANGE:
			{
			VideoChannel*			pChan = (VideoChannel*)pContext;
			KdPrint(( "DDNOTIFY_PRERESCHANGE; stream = %d\n", pChan->pSRB_->StreamObject->StreamNumber ));
			pChan->bPreEventOccurred = TRUE;
			}
			break;
		case DDNOTIFY_POSTRESCHANGE:
			{
			VideoChannel*			pChan = (VideoChannel*)pContext;
			KdPrint(( "DDNOTIFY_POSTRESCHANGE; stream = %d\n", pChan->pSRB_->StreamObject->StreamNumber ));
			pChan->bPostEventOccurred = TRUE;
			KdPrint(( "before Attempted Renegotiation due to DDNOTIFY_POSTRESCHANGE\n" ));
			//               AttemptRenegotiation(pStrmEx);
			KdPrint(( "after Attempted Renegotiation due to DDNOTIFY_POSTRESCHANGE\n" ));
			}
			break;
		case DDNOTIFY_PREDOSBOX:
			{
			VideoChannel*			pChan = (VideoChannel*)pContext;
			KdPrint(( "DDNOTIFY_PREDOSBOX; stream = %d\n", pChan->pSRB_->StreamObject->StreamNumber ));
			pChan->bPreEventOccurred = TRUE;
			}
			break;
		case DDNOTIFY_POSTDOSBOX:
			{
			VideoChannel*			pChan = (VideoChannel*)pContext;
			KdPrint(( "DDNOTIFY_POSTDOSBOX; stream = %d\n", pChan->pSRB_->StreamObject->StreamNumber ));
			pChan->bPostEventOccurred = TRUE;
			KdPrint(( "before Attempted Renegotiation due to DDNOTIFY_POSTDOSBOX\n" ));
			//               AttemptRenegotiation(pStrmEx);
			KdPrint(( "after Attempted Renegotiation due to DDNOTIFY_POSTDOSBOX\n" ));
			}
			break;
		case DDNOTIFY_CLOSEDIRECTDRAW:
			{
			VideoChannel*			pChan = (VideoChannel*)pContext;
			KdPrint(( "DDNOTIFY_CLOSEDIRECTDRAW\n" ));
			pChan->hKernelDirectDrawHandle = 0;
			pChan->hUserDirectDrawHandle = 0;
			}
			break;
		case DDNOTIFY_CLOSESURFACE:
			{
			VideoChannel*			pChan = (VideoChannel*)pContext;
			PSRB_EXTENSION			pSrbExt = (PSRB_EXTENSION)pChan->pSRB_->SRBExtension;
			KdPrint(( "DDNOTIFY_CLOSESURFACE\n" ));
			pSrbExt->hKernelSurfaceHandle = 0;
			}
			break;
		default:
			KdPrint(( "unknown/unhandled ddraw event\n" ));
			break;
	}
	return 0;
}

BOOL RegisterForDirectDrawEvents( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION	pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	DDREGISTERCALLBACK	ddRegisterCallback;
	DWORD						ddOut;
   VideoChannel*        pChan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;

	KdPrint(( "stream %d registering for DirectDraw events\n", pSrb->StreamObject->StreamNumber ));

	// =============== DDEVENT_PRERESCHANGE ===============
	RtlZeroMemory( &ddRegisterCallback, sizeof(ddRegisterCallback) );
	RtlZeroMemory( &ddOut, sizeof(ddOut) );

	ddRegisterCallback.hDirectDraw = pChan->hKernelDirectDrawHandle;
	ddRegisterCallback.dwEvents = DDEVENT_PRERESCHANGE;
	ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
	ddRegisterCallback.pContext = pChan;

	DxApi( DD_DXAPI_REGISTER_CALLBACK, (DWORD) &ddRegisterCallback, sizeof(ddRegisterCallback), (DWORD)&ddOut, sizeof(ddOut) );

	if( ddOut != DD_OK ) 
	{
		KdPrint(( "DD_DXAPI_REGISTER_CALLBACK failed.\n" ));
		return FALSE;
	}

	// =============== DDEVENT_POSTRESCHANGE ==============
	RtlZeroMemory( &ddRegisterCallback, sizeof(ddRegisterCallback) );
	RtlZeroMemory( &ddOut, sizeof(ddOut) );

	ddRegisterCallback.hDirectDraw = pChan->hKernelDirectDrawHandle;
	ddRegisterCallback.dwEvents = DDEVENT_POSTRESCHANGE;
	ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
	ddRegisterCallback.pContext = pChan;

	DxApi(DD_DXAPI_REGISTER_CALLBACK, (DWORD) &ddRegisterCallback, sizeof(ddRegisterCallback), (DWORD)&ddOut, sizeof(ddOut) );

	if( ddOut != DD_OK ) 
	{
		KdPrint(( "DD_DXAPI_REGISTER_CALLBACK failed.\n" ));
		return FALSE;
	}

	// =============== DDEVENT_PREDOSBOX =================
	RtlZeroMemory( &ddRegisterCallback, sizeof(ddRegisterCallback) );
	RtlZeroMemory( &ddOut, sizeof(ddOut) );

	ddRegisterCallback.hDirectDraw = pChan->hKernelDirectDrawHandle;
	ddRegisterCallback.dwEvents = DDEVENT_PREDOSBOX;
	ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
	ddRegisterCallback.pContext = pChan;

	DxApi( DD_DXAPI_REGISTER_CALLBACK, (DWORD) &ddRegisterCallback, sizeof(ddRegisterCallback), (DWORD)&ddOut, sizeof(ddOut) );

	if( ddOut != DD_OK ) 
	{
		KdPrint(( "DD_DXAPI_REGISTER_CALLBACK failed.\n" ));
		return FALSE;
	}

	// =============== DDEVENT_POSTDOSBOX ================
	RtlZeroMemory( &ddRegisterCallback, sizeof(ddRegisterCallback) );
	RtlZeroMemory( &ddOut, sizeof(ddOut) );

	ddRegisterCallback.hDirectDraw = pChan->hKernelDirectDrawHandle;
	ddRegisterCallback.dwEvents = DDEVENT_POSTDOSBOX;
	ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
	ddRegisterCallback.pContext = pChan;

	DxApi( DD_DXAPI_REGISTER_CALLBACK, (DWORD) &ddRegisterCallback, sizeof(ddRegisterCallback), (DWORD)&ddOut, sizeof(ddOut) );

	if( ddOut != DD_OK ) 
	{
		KdPrint(( "DD_DXAPI_REGISTER_CALLBACK failed.\n" ));
		return FALSE;
	}
	pChan->bKernelDirectDrawRegistered = TRUE;

	return TRUE;
}

BOOL UnregisterForDirectDrawEvents( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	PHW_DEVICE_EXTENSION	pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
	DDREGISTERCALLBACK	ddRegisterCallback;
	DWORD						ddOut;
   VideoChannel*        pChan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;

	KdPrint(( "stream %d un-registering for DirectDraw events\n", pSrb->StreamObject->StreamNumber ));

	// =============== DDEVENT_PRERESCHANGE ===============
	RtlZeroMemory( &ddRegisterCallback, sizeof(ddRegisterCallback) );
	RtlZeroMemory( &ddOut, sizeof(ddOut) );

	ddRegisterCallback.hDirectDraw = pChan->hKernelDirectDrawHandle;
	ddRegisterCallback.dwEvents = DDEVENT_PRERESCHANGE;
	ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
	ddRegisterCallback.pContext = pChan;

	DxApi( DD_DXAPI_UNREGISTER_CALLBACK, (DWORD) &ddRegisterCallback, sizeof(ddRegisterCallback), (DWORD)&ddOut, sizeof(ddOut));

	if( ddOut != DD_OK ) 
	{
		KdPrint(( "DD_DXAPI_UNREGISTER_CALLBACK failed.\n" ));
		return FALSE;
	}

	// =============== DDEVENT_POSTRESCHANGE ==============
	RtlZeroMemory( &ddRegisterCallback, sizeof(ddRegisterCallback) );
	RtlZeroMemory( &ddOut, sizeof(ddOut) );

	ddRegisterCallback.hDirectDraw = pChan->hKernelDirectDrawHandle;
	ddRegisterCallback.dwEvents = DDEVENT_POSTRESCHANGE;
	ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
	ddRegisterCallback.pContext = pChan;

	DxApi( DD_DXAPI_UNREGISTER_CALLBACK, (DWORD) &ddRegisterCallback, sizeof(ddRegisterCallback), (DWORD)&ddOut, sizeof(ddOut) );

	if( ddOut != DD_OK ) 
	{
		KdPrint(( "DD_DXAPI_UNREGISTER_CALLBACK failed.\n" ));
		return FALSE;
	}

	// =============== DDEVENT_PREDOSBOX ==================
	RtlZeroMemory( &ddRegisterCallback, sizeof(ddRegisterCallback) );
	RtlZeroMemory( &ddOut, sizeof(ddOut) );

	ddRegisterCallback.hDirectDraw = pChan->hKernelDirectDrawHandle;
	ddRegisterCallback.dwEvents = DDEVENT_PREDOSBOX;
	ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
	ddRegisterCallback.pContext = pChan;

	DxApi( DD_DXAPI_UNREGISTER_CALLBACK, (DWORD) &ddRegisterCallback, sizeof(ddRegisterCallback), (DWORD)&ddOut, sizeof(ddOut) );

	if( ddOut != DD_OK ) 
	{
		KdPrint(( "DD_DXAPI_UNREGISTER_CALLBACK failed.\n" ));
		return FALSE;
	}

	// =============== DDEVENT_POSTDOSBOX =================
	RtlZeroMemory( &ddRegisterCallback, sizeof(ddRegisterCallback) );
	RtlZeroMemory( &ddOut, sizeof(ddOut) );

	ddRegisterCallback.hDirectDraw = pChan->hKernelDirectDrawHandle;
	ddRegisterCallback.dwEvents = DDEVENT_POSTDOSBOX;
	ddRegisterCallback.pfnCallback = DirectDrawEventCallback;
	ddRegisterCallback.pContext = pChan;

	DxApi( DD_DXAPI_UNREGISTER_CALLBACK, (DWORD) &ddRegisterCallback, sizeof(ddRegisterCallback), (DWORD)&ddOut, sizeof(ddOut) );

	if( ddOut != DD_OK ) 
	{
		KdPrint(( "DD_DXAPI_UNREGISTER_CALLBACK failed.\n" ));
		return FALSE;
	}
	pChan->bKernelDirectDrawRegistered = FALSE;

	return TRUE;
}


BOOL OpenKernelDirectDraw( PHW_STREAM_REQUEST_BLOCK pSrb )
{
	/*
   VideoChannel*        pChan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;

	if( pChan->hUserDirectDrawHandle != 0 ) 
	{
		DDOPENDIRECTDRAWIN  ddOpenIn;
		DDOPENDIRECTDRAWOUT ddOpenOut;

		ASSERT( pChan->hKernelDirectDrawHandle == 0 );

		KdPrint(( "stream %d getting kernel ddraw handle\n", pSrb->StreamObject->StreamNumber ));

		RtlZeroMemory( &ddOpenIn, sizeof(ddOpenIn) );
		RtlZeroMemory( &ddOpenOut, sizeof(ddOpenOut) );

		ddOpenIn.dwDirectDrawHandle = (DWORD)pChan->hUserDirectDrawHandle;
		ddOpenIn.pfnDirectDrawClose = DirectDrawEventCallback;
		ddOpenIn.pContext = pChan;

		DxApi( DD_DXAPI_OPENDIRECTDRAW, (DWORD)&ddOpenIn, sizeof(ddOpenIn), (DWORD)&ddOpenOut, sizeof(ddOpenOut) );

		if( ddOpenOut.ddRVal != DD_OK ) 
		{
			KdPrint(( "DD_DXAPI_OPENDIRECTDRAW failed.\n" ));
		}
		else 
		{
			pChan->hKernelDirectDrawHandle = ddOpenOut.hDirectDraw;
			return TRUE;
		}
	}
	*/
	return FALSE;
}
    

BOOL CloseKernelDirectDraw( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   VideoChannel*        pChan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;
	/*
	if( pChan->hKernelDirectDrawHandle != 0 ) 
	{
		DWORD				ddOut;
		DDCLOSEHANDLE	ddClose;
		KdPrint(( "stream %d CloseKernelDirectDraw\n", pSrb->StreamObject->StreamNumber ));
		ddClose.hHandle = pChan->hKernelDirectDrawHandle;

		DxApi( DD_DXAPI_CLOSEHANDLE, (DWORD)&ddClose, sizeof(ddClose), (DWORD) &ddOut, sizeof(ddOut) );

		pChan->hKernelDirectDrawHandle = 0;

		if( ddOut != DD_OK ) 
		{
			KdPrint(( "CloseKernelDirectDraw FAILED.\n" ));
			return FALSE;
		}
	}
	*/
	return TRUE;
}

BOOL IsKernelLockAndFlipAvailable( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   VideoChannel*        pChan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;
	if( pChan->hKernelDirectDrawHandle != 0 ) 
	{
		DDGETKERNELCAPSOUT ddGetKernelCapsOut;
		KdPrint(( "stream %d getting Kernel Caps\n", pSrb->StreamObject->StreamNumber ));

		RtlZeroMemory( &ddGetKernelCapsOut, sizeof(ddGetKernelCapsOut) );

		DxApi( 
				DD_DXAPI_GETKERNELCAPS, 
				(DWORD) &pChan->hKernelDirectDrawHandle, 
				sizeof(pChan->hKernelDirectDrawHandle), 
				(DWORD)&ddGetKernelCapsOut, 
				sizeof(ddGetKernelCapsOut)
				);

		if( ddGetKernelCapsOut.ddRVal != DD_OK ) 
		{
			//KdPrint(( "DDGETKERNELCAPSOUT failed.\n" ));
		}
		else 
		{
			//KdPrint(( "stream %d KernelCaps = %x\n", pSrb->StreamObject->StreamNumber, ddGetKernelCapsOut.dwCaps ));
			// TODO:, check the flags here
			// if (ddGetKernelCapsOut.dwCaps & ???)
			return TRUE;
		}
	}
	return FALSE;
}


BOOL OpenKernelDDrawSurfaceHandle( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{    
   VideoChannel*        pChan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;
	PSRB_EXTENSION		pSrbExt = (PSRB_EXTENSION)pSrb->SRBExtension;

	ASSERT( pChan->hKernelDirectDrawHandle != 0 );
	ASSERT( pSrbExt->hUserSurfaceHandle != 0 );

	if( pSrbExt->hUserSurfaceHandle == 0 ) 
	{
		DDOPENSURFACEIN	ddOpenSurfaceIn;
		DDOPENSURFACEOUT	ddOpenSurfaceOut;

		//KdPrint(( "stream %d getting Kernel surface handle\n", pSrb->StreamObject->StreamNumber ));

		RtlZeroMemory( &ddOpenSurfaceIn, sizeof(ddOpenSurfaceIn) );
		RtlZeroMemory( &ddOpenSurfaceOut, sizeof(ddOpenSurfaceOut) );

		ddOpenSurfaceIn.hDirectDraw = pChan->hUserDirectDrawHandle;
		ddOpenSurfaceIn.pfnSurfaceClose = DirectDrawEventCallback;
		ddOpenSurfaceIn.pContext = pSrb;

		ddOpenSurfaceIn.dwSurfaceHandle = (DWORD)pSrbExt->hUserSurfaceHandle;

		DxApi( DD_DXAPI_OPENSURFACE, (DWORD)&ddOpenSurfaceIn, sizeof(ddOpenSurfaceIn), (DWORD)&ddOpenSurfaceOut, sizeof(ddOpenSurfaceOut) );

		if( ddOpenSurfaceOut.ddRVal != DD_OK ) 
		{
			pSrbExt->hKernelSurfaceHandle = 0;
			//KdPrint(( "DD_DXAPI_OPENSURFACE failed.\n" ));
		}
		else 
		{
			pSrbExt->hKernelSurfaceHandle = ddOpenSurfaceOut.hSurface;
			return TRUE;
		}
	}
	return FALSE;
}


BOOL CloseKernelDDrawSurfaceHandle( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
   VideoChannel*     pChan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;
	PSRB_EXTENSION		pSrbExt = (PSRB_EXTENSION)pSrb->SRBExtension;

	ASSERT( pChan->hKernelDirectDrawHandle != 0 );
	ASSERT( pSrbExt->hUserSurfaceHandle != 0 );
	ASSERT( pSrbExt->hKernelSurfaceHandle != 0 );

	if( pSrbExt->hKernelSurfaceHandle != 0 ) 
	{
		DWORD				ddOut;
		DDCLOSEHANDLE	ddClose;

		//KdPrint(( "stream %d ReleaseKernelDDrawSurfaceHandle\n", pSrb->StreamObject->StreamNumber ));

		ddClose.hHandle = pSrbExt->hKernelSurfaceHandle;

		DxApi( DD_DXAPI_CLOSEHANDLE, (DWORD)&ddClose, sizeof(ddClose), (DWORD) &ddOut, sizeof(ddOut) );

		pSrbExt->hKernelSurfaceHandle = 0;  // what else can we do?

		if( ddOut != DD_OK ) 
		{
			//KdPrint(( "ReleaseKernelDDrawSurfaceHandle() FAILED.\n" ));
			return FALSE;
		}
		else 
		{
			return TRUE;
		}
	}
	return FALSE;
}

BOOL FlipOverlay( HANDLE hDirectDraw, HANDLE hCurrentSurface, HANDLE hTargetSurface )
{
	DDFLIPOVERLAY		ddFlipOverlay;
	DWORD					ddOut;

	RtlZeroMemory( &ddFlipOverlay, sizeof(ddFlipOverlay) );
	ddFlipOverlay.hDirectDraw = hDirectDraw;
	ddFlipOverlay.hCurrentSurface = hCurrentSurface;
	ddFlipOverlay.hTargetSurface = hTargetSurface;
	ddFlipOverlay.dwFlags = 0;

	DxApi( DD_DXAPI_FLIP_OVERLAY, (DWORD)&ddFlipOverlay, sizeof(ddFlipOverlay), (DWORD)&ddOut, sizeof(ddOut) );

	if( ddOut != DD_OK ) 
	{
		//KdPrint(( "FlipOverlay() FAILED.\n" ));
		return FALSE;
	}
	else 
	{
		return TRUE;
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\command.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Command.cpp 1.4 1998/04/29 22:43:30 tomz Exp $

#include "command.h"
#ifndef __PHYSADDR_H
#include "physaddr.h"
#endif

BYTE Command::InstrSize_ [] =
{
   2, 1, 1, 2, 2, 5, 2, 3, 0xFF
};

BYTE Command::InstrNumber_ [] =
{
 8, 0, 1, 8, 8, 2, 8, 3, 4, 5, 6, 7
};

/* Method: Command::CreateCommand
 * Purpose: Compiles an instruction based on the input
 * Input: lpDst: PVOID - pointer to the instruction
 *   Instr: Instruction - opcode
 *   awByteCnt: WORD [] - array of byte counts for various instructions
 *   adwAddress: DWORD [] - array of addresses for various instructions
 *   SOL: bool - value of the SOL bit
 *   EOL: bool - value of the EOL bit
 *   Intr: bool - value of the interrupt bit
 */
LPVOID Command::Create(
   LPVOID lpDst, Instruction Instr, WORD awByteCnt [], DWORD adwAddress [],
    bool, bool SOL, bool EOL, bool Intr )
{
   // this is to be retrieved later to set EOL bit when instructions are split
   // due to the non-contiguous physical memory
   pdwInstrAddr_ = (PDWORD)lpDst;

   ThisInstr_ = Instr;

   DWORD dwAssembly [5]; // maximum instruction size

   // get pointer to the first dword of a command
   LPFIRSTDWORD lpFD = (LPFIRSTDWORD)dwAssembly;

   lpFD->Initer = 0; // virgin out the command

   // bingo - started new command
   lpFD->Gen.OpCode = Instr;

   // set all the flags
   lpFD->Gen.SOL = SOL;
   lpFD->Gen.EOL = EOL;
   lpFD->Gen.IRQ = Intr;

   switch ( Instr ) {
   case WRIT:  // this command needs target address and byte count
      dwAssembly [1] = adwAddress [0]; // next DWORD is an address
      lpFD->Gen.ByteCount = awByteCnt [0];
      break;
   case SKIP: // these pair is interested in byte count only
   case WRITEC:
      lpFD->Gen.ByteCount = awByteCnt [0];
      break;
   case JUMP: // this command cares about target address only
      dwAssembly [1] = adwAddress [0];
      break;
   case SYNC:
      break;
   case WRITE123: // need everything here...
      lpFD->Gen.ByteCount = awByteCnt [0];
      LPFIRSTDWORD( &dwAssembly [1] )->CRByteCounts.ByteCountCb = awByteCnt [1];
      LPFIRSTDWORD( &dwAssembly [1] )->CRByteCounts.ByteCountCr = awByteCnt [2];
      dwAssembly [2] = adwAddress [0]; // third DWORD is an Y address
      dwAssembly [3] = adwAddress [1]; // third DWORD is an Cb address
      dwAssembly [4] = adwAddress [2]; // third DWORD is an Cr address
      break;
   case SKIP123:
      lpFD->Gen.ByteCount = awByteCnt [0];
      LPFIRSTDWORD( &dwAssembly [1] )->Gen.ByteCount = awByteCnt [1]; // second byte count is in DWORD #2
      break;
   case WRITE1S23: // this command needs Y byte count and dest. address
      lpFD->Gen.ByteCount = awByteCnt [0];
      LPFIRSTDWORD( &dwAssembly [1] )->CRByteCounts.ByteCountCb = awByteCnt [1];
      LPFIRSTDWORD( &dwAssembly [1] )->CRByteCounts.ByteCountCr = awByteCnt [2];
      dwAssembly [2] = adwAddress [0]; // third DWORD is an address
      break;
   default:
      return (LPVOID)-1;
   }
   RtlCopyMemory( lpDst, dwAssembly, GetInstrSize() * sizeof( DWORD ) );
   
   PDWORD pdwRet = (PDWORD)lpDst + GetInstrSize();
   *pdwRet = PROGRAM_TERMINATOR;
   return pdwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\compreg.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Compreg.cpp 1.3 1998/04/29 22:43:31 tomz Exp $

#include "compreg.h"

/* Method: CompositeReg::operator DWORD()
 * Purpose: Performs the read from a composite register
*/
CompositeReg::operator DWORD()
{
   // if write-only return the shadow
   if ( GetRegisterType() == WO )
      return GetShadow();

// obtain the low and high values
   DWORD dwLowBits  = (DWORD)LSBPart_;
   DWORD dwHighBits = (DWORD)MSBPart_;

   // put high part to the proper place
   dwHighBits <<= LowPartWidth_;

   // done !
   return dwHighBits | dwLowBits;
}


/* Method: CompositeReg::operator=
 * Purpose: performs the assignment to a composite register
*/
DWORD CompositeReg::operator=( DWORD dwValue )
{
// if a register is read-only nothing is done. This is an error
   if ( GetRegisterType() == RO )
      return ReturnAllFs();

   // keep a shadow around
   SetShadow( dwValue );
 // compute the mask to apply to the passed value, so it can be...
   DWORD dwMask = ::MakeAMask( LowPartWidth_ );

 // ... assigned to the low portion register
   LSBPart_ = dwValue & dwMask;

   // shift is enough to get the high part
   MSBPart_ = ( dwValue >> LowPartWidth_ );
   return dwValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\colspace.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Colspace.h 1.3 1998/04/29 22:43:30 tomz Exp $

#ifndef __COLSPACE_H
#define __COLSPACE_H

#ifndef __MYTYPES_H
#include "mytypes.h"
#endif

typedef DWORD           FOURCC;          /*a four character code */
   /* constants for the biCompression field from windows.h*/
   #define BI_RGB        0L
   #define BI_RLE8       1L
   #define BI_RLE4       2L
   #define BI_BITFIELDS  3L

#ifndef __COLFRMAT_H
#include "colfrmat.h"
#endif


/* Class: ColorSpace:
 * Purpose: This class provides the functionality of the BtPisces color
 *   space converter
 * Attributes: CurColor_: ColFmt - current color format
 * Operations:
      SetColorFormat( ColFmt aColor ): - this method sets the color format
      ColFmt GetColorFormat(): - this method returns the current color format
      BYTE GetBitCount(): - this method returns number of bpp for the current
         color format.
 */
class ColorSpace
{
   private:
      ColFmt CurColor_;
      static const BYTE BitCount_ [];
      static const BYTE XRestriction_ [];
      static const BYTE YRestriction_ [];
      static const BYTE YPlaneBitCount_ [];
      static const FOURCC FourccArr_ [];
      static const GUID *VideoGUIDs [];
      ColorSpace();
   public:
      void   SetColorFormat( ColFmt aColor ) { CurColor_ = aColor; }
      DWORD  GetBitCount() const;
      DWORD  GetPitchBpp() const;
      FOURCC GetFourcc() const;
      bool   CheckDimentions( const SIZE &aSize ) const;
      bool   CheckLeftTop( const MPoint &aSize ) const;        

      ColorSpace( ColFmt aColForm ) : CurColor_( aColForm ) {}
      ColorSpace( FOURCC fcc, int bitCount );
      ColorSpace( const GUID &guid );

      ColFmt GetColorFormat() const;

      bool IsValid()
      { return bool( CurColor_ > CF_BelowRange && CurColor_ < CF_AboveRange ); }
};

/* Method: ColorSpace::GetBitCount
 * Purpose: Returns number of bpp for a given color
 */
inline DWORD ColorSpace::GetBitCount() const { return BitCount_ [CurColor_]; }

/* Method: ColorSpace::GetPitchBpp
 * Purpose: Used to calculate pitch of data buffers. Most useful for planar modes
 *   where bpp used for pitch calculation is different from 'real' bpp of a
 *   data format
 */
inline DWORD ColorSpace::GetPitchBpp() const { return YPlaneBitCount_ [CurColor_]; }

/* Method: ColorSpace::GetColorFormat
 * Purpose: a query function
 */
inline ColFmt ColorSpace::GetColorFormat() const { return CurColor_; }

/* Method: ColorSpace::GetFourcc
 * Purpose: returns a FOURCC corresponding to the current color format
 */
inline FOURCC ColorSpace::GetFourcc() const { return FourccArr_ [CurColor_]; }


/* Function: IsDivisible
 * Purpose: This function checks that the first value passed in is
 *   evenly divisible by the second
 * Input: ToCheck: int - value to be checked
 *        Divisor: int
 * Output: bool
 * Note: The function assumes Divisor is a power of 2
 */
inline bool IsDivisible( int ToCheck, int Divisor )
{
   return bool( !( ToCheck & ( Divisor - 1 ) ) );
}

#endif __COLSPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\chanifac.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Chanifac.h 1.3 1998/04/29 22:43:30 tomz Exp $

#ifndef __CHANIFACE_H
#define __CHANIFACE_H


/* Class: ChanIface
 * Purpose: Defines interface between CaptureChip class and VxDVideoChannel class
 * Attributes:
 * Operations:
 *   virtual void Notify() - called by CaptureChip to report an interrupt
 */
class ChanIface
{
   public:
      virtual void Notify( PVOID, bool skipped ) {}
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\command.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Command.h 1.4 1998/04/29 22:43:31 tomz Exp $

#ifndef __COMMAND_H
#define __COMMAND_H

#ifndef __MEM_H
#include <memory.h>
#endif

#include "mytypes.h"

#define PROGRAM_TERMINATOR 0xa5a5a5a5

/* Type: Instruction
 * Purpose: enumerates all RISC commands
 */
typedef enum
{
   WRIT    = 0x01, SKIP = 0x02, WRITEC   = 0x05,
   JUMP    = 0x07, SYNC = 0x08, WRITE123 = 0x09,
   SKIP123 = 0x0A, WRITE1S23 = 0x0B, Reserved = 0xFF
} Instruction;

/* Type: SyncCode
 * Purpose: enumerates all sync codes coming out of decoder
*/
typedef enum
{
   SC_FM1 = 0x6, SC_FM3 = 0xE, SC_VRE = 0x4,
   SC_VRO = 0xC, SC_RESYNC = 1, SC_Reserved = 0xFF
} SyncCode;

/* Class: Command
 * Purpose: This class represents a RISC instruction in a more convenient form
 * Attributes:
 * Operations:
 */
class Command
{
   public:
      typedef union tag {
         struct {
            unsigned int   ByteCount   : 12;
            unsigned int   BE_Res      : 4;
            unsigned int   StatusSet   : 4;
            unsigned int   StatusReset : 4;
            unsigned int   IRQ         : 1;
            unsigned int   Reserved    : 1;
            unsigned int   EOL         : 1;
            unsigned int   SOL         : 1;
            unsigned int   OpCode      : 4;
         } Gen;
         struct {
            unsigned int   Status      : 4;
            unsigned int   Res1        : 11;
            unsigned int   Resync      : 1;
            unsigned int   StatusSet   : 4;
            unsigned int   StatusReset : 4;
            unsigned int   IRQ         : 1;
            unsigned int   Res2        : 1;
            unsigned int   EOL         : 1;
            unsigned int   SOL         : 1;
            unsigned int   OpCode      : 4;
         } Sync;

         struct {
            unsigned int   ByteCountCb : 12;
            unsigned int   skip        :  4;
            unsigned int   ByteCountCr : 12;
         } CRByteCounts;

         DWORD            Initer; // used to zero out all the fields

      } FIRSTDWORD, *LPFIRSTDWORD;

   private:
      Instruction ThisInstr_;

      static BYTE InstrSize_   [];
      static BYTE InstrNumber_ [];

      PDWORD      pdwInstrAddr_;

   public:
      Instruction GetInstr() { return ThisInstr_; }
      PDWORD GetInstrAddr() { return pdwInstrAddr_; }

      BYTE GetInstrSize() { return InstrSize_ [InstrNumber_ [ThisInstr_] ]; }

      BYTE GetInstrSize( Instruction inst )
      { return InstrSize_ [InstrNumber_ [inst] ]; }

      LPVOID Create( LPVOID lpDst, Instruction Instr, WORD wByteCnt [],
         DWORD dwAddress [], bool SafetyDevice = true,
         bool SOL = true, bool EOL = true, bool Intr = false );

      // start/end of line control
      void SetSOL( PVOID lpFD ) { ((LPFIRSTDWORD)lpFD)->Gen.SOL = 1; }
      void ResetSOL( PVOID lpFD ) { ((LPFIRSTDWORD)lpFD)->Gen.SOL = 0; }

      void SetEOL( PVOID lpFD ) { ((LPFIRSTDWORD)lpFD)->Gen.EOL = 1; }
      void ResetEOL( PVOID lpFD ) { ((LPFIRSTDWORD)lpFD)->Gen.EOL = 0; }

      void SetIRQ( PVOID lpFD ) { ((LPFIRSTDWORD)lpFD)->Gen.IRQ = 1; }
      void ResetIRQ( PVOID lpFD ) { ((LPFIRSTDWORD)lpFD)->Gen.IRQ = 0; }

      void SetStatus( PVOID lpFD, int s )
      {
       ((LPFIRSTDWORD)lpFD)->Gen.StatusSet = s;
       ((LPFIRSTDWORD)lpFD)->Gen.StatusReset = 0;
      }

      void ResetStatus( PVOID lpFD, int s )
      {
       ((LPFIRSTDWORD)lpFD)->Gen.StatusReset = s;
       ((LPFIRSTDWORD)lpFD)->Gen.StatusSet = 0;
      }

      void SetToCount( PVOID lpFD )
      {
       ((LPFIRSTDWORD)lpFD)->Gen.StatusReset = 0xF;
       ((LPFIRSTDWORD)lpFD)->Gen.StatusSet   = 0xF;
      }

      // eol/sol query
      bool IsEOL( PVOID lpFD ) { return bool( ((LPFIRSTDWORD)lpFD)->Gen.EOL ); }
      bool IsSOL( PVOID lpFD ) { return bool( ((LPFIRSTDWORD)lpFD)->Gen.SOL ); }
      bool IsIRQ( PVOID lpFD ) { return bool( ((LPFIRSTDWORD)lpFD)->Gen.IRQ ); }
      WORD GetStatus( PVOID lpFD )
      {
         return WORD( ( ((LPFIRSTDWORD)lpFD)->Gen.StatusSet << 4 ) |
                  ((LPFIRSTDWORD)lpFD)->Gen.StatusReset );
      }

      WORD GetSyncStatus( PVOID lpFD )
      { return (WORD)((LPFIRSTDWORD)lpFD)->Sync.Status; }

      void SetSync( PVOID lpFD, SyncCode eACode, bool Resync = false ) {
         ((LPFIRSTDWORD)lpFD)->Sync.Status = eACode;
         ((LPFIRSTDWORD)lpFD)->Sync.Resync = Resync;
      }
      void SetResync( PVOID lpFD, bool val )
      { ((LPFIRSTDWORD)lpFD)->Sync.Resync = val; }

      bool GetResync( PVOID lpFD )
      { return bool( ((LPFIRSTDWORD)lpFD)->Sync.Resync ); }

      Command(){}//  { Init();  }
      Command( Instruction instr ) : ThisInstr_( instr ) {}
};

#endif __COMMAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\colspace.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Colspace.cpp 1.7 1998/04/29 22:43:30 tomz Exp $

#define INITGUID
#include "colspace.h"
#include "fourcc.h"
#include "defaults.h"
#include "uuids.h"


BYTE const ColorSpace::BitCount_ [] =
{
// RGB32 RGB24 RGB16 RGB15 YUY2 BTYUV Y8 RGB8 PL_422 PL_411 YUV9 YUV12 VBI UYVY RAW I420
   32,   24,   16,   16,   16,  12,   8, 8,   16,    12,    9,   12,    8, 16,  8,  12
};

BYTE const ColorSpace::YPlaneBitCount_ [] =
{
// RGB32 RGB24 RGB16 RGB15 YUY2 BTYUV Y8 RGB8 PL_422 PL_411 YUV9 YUV12 VBI UYVY RAW I420
   32,   24,   16,   16,   16,  12,   8, 8,   8,     8,     8,   8,     8, 16,  8,  8
};

BYTE const ColorSpace::XRestriction_ [] =
{
   1,    1,    1,    1,   2,    4,    1, 1,   8,     16,    16,  8,    2,  4,   1,  8
};

BYTE const ColorSpace::YRestriction_ [] =
{
   2,    2,    2,    2,   2,    2,    2, 2,   2,     2,     4,    2,   2,  2,   2,  2
};

FOURCC const ColorSpace::FourccArr_ [] =
{
// 32      24      16            15
   BI_RGB, BI_RGB, BI_RGB, BI_RGB, FCC_YUY2, FCC_Y41P, FCC_Y8, BI_RGB,
   FCC_422, FCC_411, FCC_YVU9, FCC_YV12, FCC_VBI, FCC_UYVY, FCC_RAW, FCC_I420
};

const GUID *ColorSpace::VideoGUIDs [] =
{
   &MEDIASUBTYPE_RGB32, &MEDIASUBTYPE_RGB24, &MEDIASUBTYPE_RGB565,   &MEDIASUBTYPE_RGB555,
   &MEDIASUBTYPE_YUY2,  &MEDIASUBTYPE_Y41P,  NULL,                   NULL,
   NULL,                &MEDIASUBTYPE_Y411,  &MEDIASUBTYPE_YVU9,     NULL,
   NULL,                &MEDIASUBTYPE_UYVY,  NULL,                   NULL
};

void DumpGUID(const GUID guid)
{
   DebugOut(( 1, "Guid = %08x-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x\n",
         guid.Data1, guid.Data2, guid.Data3,
         guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],
         guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]
   ));
}

/* Constructor: ColorSpace::ColorSpace
 * Input: fcc: FOURCC
 */
ColorSpace::ColorSpace( FOURCC fcc, int bitCount ) : CurColor_( CF_BelowRange )
{
   DebugOut((1, "ColorSpace(%x, %d, ('%c%c%c%c'))\n", 
      fcc, 
      bitCount,
      fcc & 0xff,
      (fcc >> 8) & 0xff,
      (fcc >> 16) & 0xff,
      (fcc >> 24) & 0xff
   ));

   switch( fcc ) {
   case BI_RGB:
      switch ( bitCount ) {
      default: 
      case 8:  CurColor_ = CF_RGB8;    break;
      case 16: CurColor_ = CF_RGB15;   break;
      case 24: CurColor_ = CF_RGB24;   break;
      case 32: CurColor_ = CF_RGB32;   break;
      }
      break;
   case BI_RLE8:
   case BI_RLE4:
   case BI_BITFIELDS:
   case 0xe436eb7b:// ???
   case FCC_YUY2:
   case FCC_Y41P:
   case FCC_Y8:
   case FCC_422:
   case FCC_411:
   case FCC_YVU9:
   case FCC_YV12:
   case FCC_VBI:
   case FCC_UYVY:
   case FCC_RAW:
   case FCC_I420:
   default:
         for ( int fccArrIdx = CF_RGB32; fccArrIdx < CF_AboveRange; fccArrIdx++ )
            if ( fcc == FourccArr_ [fccArrIdx] ) {
               CurColor_ = (ColFmt)fccArrIdx;
               break;
            }
         break;
   }
   DebugOut((1, "*** CurColor_ set to %d\n", CurColor_));
}

/* Constructor: ColorSpace::ColorSpace
 * Input: guid: const GUID &
 */
ColorSpace::ColorSpace( const GUID &guid ) : CurColor_( CF_BelowRange )
{
   DebugOut((1, "**************************************\n"));
   DebugOut((1, "Looking for the following guid\n"));
   DumpGUID(guid);
   DebugOut((1, "---\n"));

   for ( int idx = CF_RGB32; idx < CF_AboveRange; idx++ ) {
      DumpGUID(*VideoGUIDs [idx]);
      if ( VideoGUIDs [idx] && IsEqualGUID( guid, *VideoGUIDs [idx] ) ) {
         CurColor_ = (ColFmt)idx;
         break;
      }
   }
}

/* Method: ColorSpace::CheckDimentions
 * Purpose: This functions checks that the size of a buffer corresponds to the
 *   restrictions imposed by a color format
 * Input: size: reference to SIZE structure
 * Output: bool: True or False
 */
bool ColorSpace::CheckDimentions( const SIZE &size ) const
{
   return  bool( CurColor_ > CF_BelowRange && CurColor_ < CF_AboveRange &&
                 IsDivisible( size.cx, XRestriction_ [CurColor_] ) &&
                 IsDivisible( size.cy, YRestriction_ [CurColor_] )  );//&&
//                 size.cx >= MinOutWidth && size.cx <= MaxOutWidth &&
//                 size.cy >= MinOutHeight && size.cy <= MaxOutHeight );
}

/* Method: ColorSpace::CheckLeftTop
 * Purpose: This functions checks that the left top corner of a buffer
 * corresponds to the restrictions imposed by a color format
 * Input: lt: const reference to MPoint structure
 * Output: bool: true or false
 */
bool ColorSpace::CheckLeftTop( const MPoint &lt ) const
{
   return bool( !( lt.x & 3 ) && !( lt.y & 1 ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\declare.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Declare.h 1.3 1998/04/29 22:43:31 tomz Exp $

#ifndef __DECLARE_H
#define __DECLARE_H

RegisterB decRegSTATUS;
RegField  decFieldPRES;
RegField  decFieldHLOC;
RegField  decFieldEVENFIELD;
RegField  decFieldNUML;
RegField  decFieldCSEL;
RegField  decFieldSTATUS_RES;
RegField  decFieldLOF;
RegField  decFieldCOF;
RegisterB decRegIFORM;
RegField  decFieldHACTIVE;
RegField  decFieldMUXSEL;
RegField  decFieldXTSEL;
RegField  decFieldFORMAT;
RegisterB decRegTDEC;
RegField  decFieldDEC_FIELD;
RegField  decFieldDEC_FIELDALIGN;
RegField  decFieldDEC_RAT;
RegisterB decRegBRIGHT;
RegisterB decRegMISCCONTROL;
RegField  decFieldLNOTCH;
RegField  decFieldCOMP;
RegField  decFieldLDEC;
RegField  decFieldCBSENSE;
RegField  decFieldMISCCONTROL_RES;
RegField  decFieldCON_MSB;
RegField  decFieldSAT_U_MSB;
RegField  decFieldSAT_V_MSB;
RegisterB decRegCONTRAST_LO;
RegisterB decRegSAT_U_LO;
RegisterB decRegSAT_V_LO;
RegisterB decRegHUE;
RegisterB decRegSCLOOP;
RegField  decFieldCAGC;
RegField  decFieldCKILL;
RegField  decFieldHFILT;
RegisterB decRegWC_UP;
RegisterB decRegOFORM;
RegField  decFieldRANGE;
RegField  decFieldCORE;
RegisterB decRegVSCALE_HI;
RegField  decFieldYCOMB;
RegField  decFieldCOMB;
RegField  decFieldINT;
RegisterB decRegTEST;
RegisterB decRegADELAY;
RegisterB decRegBDELAY;
RegisterB decRegADC;
RegField  decFieldSYNC_T;
RegField  decFieldAGC_EN;
RegField  decFieldCLK_SLEEP;
RegField  decFieldY_SLEEP;
RegField  decFieldC_SLEEP;
RegField  decFieldCRUSH;
RegisterB decRegVTC;
RegField  decFieldHSFMT;
RegisterB decRegWC_DN;
RegisterB decRegSRESET;
RegisterB decRegODD_MISCCONTROL;
RegField  decFieldODD_LNOTCH;
RegField  decFieldODD_COMP;
RegField  decFieldODD_LDEC;
RegField  decFieldODD_CBSENSE;
RegField  decFieldODD_MISCCONTROL_RES;
RegField  decFieldODD_CON_MSB;
RegField  decFieldODD_SAT_U_MSB;
RegField  decFieldODD_SAT_V_MSB;
RegisterB decRegODD_SCLOOP;
RegField  decFieldODD_CAGC;
RegField  decFieldODD_CKILL;
RegField  decFieldODD_HFILT;
RegisterB decRegODD_VSCALE_HI;
RegField  decFieldODD_YCOMB;
RegField  decFieldODD_COMB;
RegField  decFieldODD_INT;
RegisterB decRegODD_VTC;
RegField  decFieldODD_HSFMT;

#endif   // __DECLARE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\constr.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Constr.h 1.3 1998/04/29 22:43:31 tomz Exp $

#ifndef __CONSTR_H
#define __CONSTR_H

#define CONSTRUCT_REGISTERS \
decRegSTATUS ( ( (0x00 + 0) * 4) + 0, RW ) ,\
decFieldPRES( decRegSTATUS, 7, 1, RW) ,\
decFieldHLOC( decRegSTATUS, 6, 1, RW) ,\
decFieldEVENFIELD( decRegSTATUS, 5, 1, RW) ,\
decFieldNUML( decRegSTATUS, 4, 1, RW) ,\
decFieldCSEL( decRegSTATUS, 3, 1, RW) ,\
decFieldSTATUS_RES( decRegSTATUS, 2, 1, RW) ,\
decFieldLOF( decRegSTATUS, 1, 1, RW) ,\
decFieldCOF( decRegSTATUS, 0, 1, RW) ,\
decRegIFORM ( ( (0x01 + 0) * 4) + 0, RW ) ,\
decFieldHACTIVE( decRegIFORM, 7, 1, RW) ,\
decFieldMUXSEL( decRegIFORM, 5, 2, RW) ,\
decFieldXTSEL( decRegIFORM, 3, 2, RW) ,\
decFieldFORMAT( decRegIFORM, 0, 3, RW) ,\
decRegTDEC ( ( (0x02 + 0) * 4) + 0, RW ) ,\
decFieldDEC_FIELD( decRegTDEC, 7, 1, RW) ,\
decFieldDEC_FIELDALIGN( decRegTDEC, 6, 1, RW) ,\
decFieldDEC_RAT( decRegTDEC, 0, 6, RW) ,\
decRegBRIGHT ( ( (0x0A + 0) * 4) + 0, RW ) ,\
decRegMISCCONTROL ( ( (0x0B + 0) * 4) + 0, RW ) ,\
decFieldLNOTCH( decRegMISCCONTROL, 7, 1, RW) ,\
decFieldCOMP( decRegMISCCONTROL, 6, 1, RW) ,\
decFieldLDEC( decRegMISCCONTROL, 5, 1, RW) ,\
decFieldCBSENSE( decRegMISCCONTROL, 4, 1, RW) ,\
decFieldMISCCONTROL_RES( decRegMISCCONTROL, 3, 1, RW) ,\
decFieldCON_MSB( decRegMISCCONTROL, 2, 1, RW) ,\
decFieldSAT_U_MSB( decRegMISCCONTROL, 1, 1, RW) ,\
decFieldSAT_V_MSB( decRegMISCCONTROL, 0, 1, RW) ,\
decRegCONTRAST_LO ( ( (0x0C + 0) * 4) + 0, RW ) ,\
decRegSAT_U_LO ( ( (0x0D + 0) * 4) + 0, RW ) ,\
decRegSAT_V_LO ( ( (0x0E + 0) * 4) + 0, RW ) ,\
decRegHUE ( ( (0x0F + 0) * 4) + 0, RW ) ,\
decRegSCLOOP ( ( (0x10 + 0) * 4) + 0, RW ) ,\
decFieldCAGC( decRegSCLOOP, 6, 1, RW) ,\
decFieldCKILL( decRegSCLOOP, 5, 1, RW) ,\
decFieldHFILT( decRegSCLOOP, 3, 2, RW) ,\
decRegWC_UP( ( (0x11 + 0) * 4) + 0, RW ) ,\
decRegOFORM ( ( (0x12 + 0) * 4) + 0, RW ) ,\
decFieldRANGE( decRegOFORM, 7, 1, RW) ,\
decFieldCORE( decRegOFORM, 5, 2, RW) ,\
decRegVSCALE_HI ( ( (0x13 + 0) * 4) + 0, RW ) ,\
decFieldYCOMB( decRegVSCALE_HI, 7, 1, RW) ,\
decFieldCOMB( decRegVSCALE_HI, 6, 1, RW) ,\
decFieldINT( decRegVSCALE_HI, 5, 1, RW) ,\
decRegTEST ( ( (0x15 + 0) * 4) + 0, RW ) ,\
decRegADELAY ( ( (0x18 + 0) * 4) + 0, RW ) ,\
decRegBDELAY ( ( (0x19 + 0) * 4) + 0, RW ) ,\
decRegADC ( ( (0x1A + 0) * 4) + 0, RW ) ,\
decFieldSYNC_T( decRegADC, 5, 1, RW) ,\
decFieldAGC_EN( decRegADC, 4, 1, RW) ,\
decFieldCLK_SLEEP( decRegADC, 3, 1, RW) ,\
decFieldY_SLEEP( decRegADC, 2, 1, RW) ,\
decFieldC_SLEEP( decRegADC, 1, 1, RW) ,\
decFieldCRUSH( decRegADC, 0, 1, RW), \
decRegVTC ( ( (0x1B + 0) * 4) + 0, RW ) ,\
decFieldHSFMT( decRegVTC, 7, 1, RW) ,\
decRegWC_DN( ( (0x1E + 0) * 4) + 0, RW ) ,\
decRegSRESET ( ( (0x1F + 0) * 4) + 0, RW ) ,\
decRegODD_MISCCONTROL ( ( (0x0B + -0x03) * 4) + 0x8C, RW ) ,\
decFieldODD_LNOTCH( decRegODD_MISCCONTROL, 7, 1, RW) ,\
decFieldODD_COMP( decRegODD_MISCCONTROL, 6, 1, RW) ,\
decFieldODD_LDEC( decRegODD_MISCCONTROL, 5, 1, RW) ,\
decFieldODD_CBSENSE( decRegODD_MISCCONTROL, 4, 1, RW) ,\
decFieldODD_MISCCONTROL_RES( decRegODD_MISCCONTROL, 3, 1, RW) ,\
decFieldODD_CON_MSB( decRegODD_MISCCONTROL, 2, 1, RW) ,\
decFieldODD_SAT_U_MSB( decRegODD_MISCCONTROL, 1, 1, RW) ,\
decFieldODD_SAT_V_MSB( decRegODD_MISCCONTROL, 0, 1, RW) ,\
decRegODD_SCLOOP ( ( (0x10 + -0x03) * 4) + 0x8C, RW ) ,\
decFieldODD_CAGC( decRegODD_SCLOOP, 6, 1, RW) ,\
decFieldODD_CKILL( decRegODD_SCLOOP, 5, 1, RW) ,\
decFieldODD_HFILT( decRegODD_SCLOOP, 3, 2, RW) ,\
decRegODD_VSCALE_HI ( ( (0x13 + -0x03) * 4) + 0x8C, RW ) ,\
decFieldODD_YCOMB( decRegODD_VSCALE_HI, 7, 1, RW) ,\
decFieldODD_COMB( decRegODD_VSCALE_HI, 6, 1, RW) ,\
decFieldODD_INT( decRegODD_VSCALE_HI, 5, 1, RW) ,\
decRegODD_VTC ( ( (0x1B + -0x03) * 4) + 0x8C, RW ) ,\
decFieldODD_HSFMT( decRegODD_VTC, 7, 1, RW)

#endif   // __CONSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\dcdrvals.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Dcdrvals.h 1.3 1998/04/29 22:43:31 tomz Exp $

#ifndef __DCDRVALS_H
#define __DCDRVALS_H

#ifdef __cplusplus

const int HueMin = -90;
const int HueMax = 90;
const int HueDef = 0;

const int SatMinNTSC = 0;
const int SatMaxNTSC = 0x1FF;
const int SatDefNTSC = 0xFE;

const int SatMinSECAM = 0;
const int SatMaxSECAM = 0x1FF;
const int SatDefSECAM = 0x87;

const int ConMin = 0;
const int ConMax = 236;
const int ConDef = 100;

const int BrtMin = -50;
const int BrtMax = 50;
const int BrtDef = 0;

const int ParamMin = 0;
const int ParamMax = 10000;
const int ParamDef = 5000;

#else
#define HueMin -90
#define HueMax 90
#define HueDef 0

#define SatMinNTSC 0
#define SatMaxNTSC 0x1FF
#define SatDefNTSC 0xFE

#define SatMinSECAM 0
#define SatMaxSECAM 0x1FF
#define SatDefSECAM 0x87

#define ConMin 0
#define ConMax 236
#define ConDef 100

#define BrtMin -50
#define BrtMax 50
#define BrtDef 0

#define ParamMin 0
#define ParamMax 255
#define ParamDef 128

#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\compreg.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Compreg.h 1.3 1998/04/29 22:43:31 tomz Exp $

#ifndef __COMPREG_H
#define __COMPREG_H

#ifndef __REGFIELD_H
#include "regfield.h"
#endif

/* Class: CompositeReg
 * Purpose: This class encapsulates the registers that have their bits in two
 *          different places ( registers )
 * Attributes:
 *   LSBPart_:  Register & - least significant bits part of a composite register
 *   HighPart_: RegField & - most significant bits part of a composite register
 *   LowPartWidth_: BYTE - width of the low portion in bits
 * Operations:
 *   operator DWORD(): data access method. Returns a value of the register
 *   DWORD operator=( DWORD ): assignment operator. Used to set the register
 * Note: the error handling provided by the class is minimal. It is a responibility
 *   of the user to pass correct parameters to the constructor. The class has
 *   no way of knowing if the correct low and high registers passed in are correct,
 *   for example. If low part size in bits passed in is not less then MaxWidth ( 32 )
 *   the mask used to isolate the low portion will be 0xFFFFFFFF
 */
class CompositeReg : public RegBase
{
   private:
      Register &LSBPart_;
      RegField &MSBPart_;
      BYTE      LowPartWidth_;
      CompositeReg();
   public:
      virtual operator DWORD();
      virtual DWORD operator=( DWORD dwValue );
      CompositeReg( Register &LowReg, BYTE LowWidth, RegField &HighReg, RegisterType aType ) :
         RegBase( aType ), LSBPart_( LowReg ), MSBPart_( HighReg ),
         LowPartWidth_( LowWidth ) {}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\decoder.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Decoder.cpp 1.5 1998/04/29 22:43:31 tomz Exp $

#include "mytypes.h"
#include "Scaler.h"
#include "decoder.h"
#include "constr.h"
#include "dcdrvals.h"

#define CON_vs_BRI   // HW does contrast incorrectly, try to adjust in SW


//===========================================================================
// Bt848 Decoder Class Implementation
//===========================================================================

/////////////////////////////////////////////////////////////////////////////
// Constructor
/////////////////////////////////////////////////////////////////////////////
Decoder::Decoder( DWORD *xtals ) :
   // init register min, max, default
   m_regHue( HueMin, HueMax, HueDef ),
   m_regSaturationNTSC( SatMinNTSC, SatMaxNTSC, SatDefNTSC ),
   m_regSaturationSECAM( SatMinSECAM, SatMaxSECAM, SatDefSECAM ),
   m_regContrast( ConMin, ConMax, ConDef ),
   m_regBrightness( BrtMin, BrtMax, BrtDef ),
   m_param( ParamMin, ParamMax, ParamDef ),
   CONSTRUCT_REGISTERS
{
   Xtals_ [0] = *xtals;
   Xtals_ [1] = *(xtals + 1 );

   // need to set this to 0x4F
   decRegWC_UP = 0x4F;
   // and this one to 0x7F to make sure CRUSH bit works
   decRegWC_DN = 0x7F;

   // HACTIVE should always be 0
   decFieldHACTIVE = 0;

   // HSFMT (odd and even) should always be 0
   decFieldHSFMT = decFieldODD_HSFMT = 0;

   // Instead of using default values, set some registers fields to optimum values
   SetLumaDecimation( true );
   SetChromaAGC( true );
   SetLowColorAutoRemoval( true );
   SetAdaptiveAGC( false );

   // for contrast adjustment purpose
   regBright = 0x00;     // brightness register value before adjustment
   regContrast = 0xD8;   // contrast register value before adjustment

   // Initialize these Values so we can Get the correct property values		jbc 3/13/98
   // Perhaps get should read the actual values set in the decoder but this is quick and works for now
   // [!!!] 
   m_briParam = 5000;				// jbc 3/13/98
   m_satParam = 5000;				// jbc 3/13/98
   m_conParam = 5000;				// jbc 3/13/98
   m_hueParam = 5000;				// jbc 3/13/98
};

/////////////////////////////////////////////////////////////////////////////
// Destructor
/////////////////////////////////////////////////////////////////////////////
Decoder::~Decoder()
{
}


//===== Device Status register ==============================================

/////////////////////////////////////////////////////////////////////////////
// Method:  BYTE Decoder::GetDeviceStatusReg( void )
// Purpose: Obtain device status register value
// Input:   None
// Output:  None
// Return:  value of status register in BYTE
/////////////////////////////////////////////////////////////////////////////
BYTE Decoder::GetDeviceStatusReg( void )
{
	BYTE status = (BYTE)decRegSTATUS;
	decRegSTATUS = 0x00;
   return status;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsVideoPresent( void )
// Purpose: Detect if video is present
// Input:   None
// Output:  None
// Return:  true if video present; else false
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsVideoPresent( void )
{
  return (bool) (decFieldPRES == 1);
}


/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsDeviceInHLock( void )
// Purpose: Detect if device is in H-lock
// Input:   None
// Output:  None
// Return:  true if device in H-lock; else false
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsDeviceInHLock( void )
{
  return (bool) (decFieldHLOC == 1);
}


/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsEvenField( void )
// Purpose: Reflect whether an even or odd field is being decoded
// Input:   None
// Output:  None
// Return:  true if even field; else false
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsEvenField( void )
{
  return (bool) (decFieldEVENFIELD == 1);
}


/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::Is525LinesVideo( void )
// Purpose: Check to see if we are dealing with 525 lines video signal
// Input:   None
// Output:  None
// Return:  true if 525 lines detected; else false (assume 625 lines)
/////////////////////////////////////////////////////////////////////////////
bool Decoder::Is525LinesVideo( void )
{
  return (bool) (decFieldNUML == 0);  //525
}

/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsCrystal0Selected( void )
// Purpose: Reflect whether XTAL0 or XTAL1 is selected
// Input:   None
// Output:  None
// Return:  true if XTAL0 selected; else false (XTAL1 selected)
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsCrystal0Selected( void )
{
  return (bool) (decFieldCSEL == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsLumaOverflow( void )
// Purpose: Indicates if luma ADC overflow
// Input:   None
// Output:  None
// Return:  true if luma ADC overflow; else false
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsLumaOverflow( void )
{
  return (bool) (decFieldLOF == 1);
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::ResetLumaOverflow( void )
// Purpose: Reset luma ADC overflow bit
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::ResetLumaOverflow( void )
{
  decFieldLOF = 0;  // write to it will reset the bit
}

/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsChromaOverflow( void )
// Purpose: Indicates if chroma ADC overflow
// Input:   None
// Output:  None
// Return:  true if chroma ADC overflow; else false
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsChromaOverflow( void )
{
  return (bool) (decFieldCOF == 1);
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::ResetChromaOverflow( void )
// Purpose: Reset chroma ADC overflow bit
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::ResetChromaOverflow( void )
{
  decFieldCOF = 0;  // write to it will reset the bit
}


//===== Input Format register ===============================================

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetVideoInput( Connector source )
// Purpose: Select which connector as input
// Input:   Connector source - SVideo, Tuner, Composite
// Output:  None
// Return:  Fail if error in parameter, else Success
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetVideoInput( Connector source )
{
  if ( ( source != ConSVideo ) &&
       ( source != ConTuner ) &&
       ( source != ConComposite ) )
    return Fail;

  decFieldMUXSEL = source;

  // set to composite or Y/C component video depends on video source
  SetCompositeVideo( ( source == ConSVideo ) ? false : true );
  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetVideoInput( void )
// Purpose: Get which connector is input
// Input:   None
// Output:  None
// Return:  Video source - SVideo, Tuner, Composite
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetVideoInput( void )
{
  return ((int)decFieldMUXSEL);
}

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetCrystal( Crystal crystalNo )
// Purpose: Select which crystal as input
// Input:   Crystal crystalNo:
//            XT0         - Crystal_XT0
//            XT1         - Crystal_XT1
//            Auto select - Crystal_AutoSelect
// Output:  None
// Return:  Fail if error in parameter, else Success
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetCrystal( Crystal crystalNo )
{
  if ( ( crystalNo < Crystal_XT0 ) || ( crystalNo >  Crystal_AutoSelect ) )
    return Fail;

  decFieldXTSEL = crystalNo;
  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetCrystal( void )
// Purpose: Get which crystal is input
// Input:   None
// Output:  None
// Return:   Crystal Number:
//            XT0         - Crystal_XT0
//            XT1         - Crystal_XT1
//            Auto select - Crystal_AutoSelect
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetCrystal( void )
{
  return ((int)decFieldXTSEL);
}


/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetVideoFormat( VideoFormat format )
// Purpose: Set video format
// Input:   Video format -
//            Auto format:          VFormat_AutoDetect
//            NTSC (M):             VFormat_NTSC
//            PAL (B, D, G, H, I):  VFormat_PAL_BDGHI
//            PAL (M):              VFormat_PAL_M
//            PAL(N):               VFormat_PAL_N
//            SECAM:                VFormat_SECAM
// Output:  None
// Return:  Fail if error in parameter, else Success
// Notes:   Available video formats are: NTSC, PAL(B, D, G, H, I), PAL(M),
//                                       PAL(N), SECAM
//          This function also sets the AGCDelay (ADELAY) and BrustDelay
//          (BDELAY) registers
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetVideoFormat( VideoFormat format )
{
  if ( (format <  VFormat_AutoDetect)  ||
       (format >  VFormat_SECAM)       ||
       (format == VFormat_Reserved2) )
    return Fail;

  switch (format)
  {
    case VFormat_NTSC:
      decFieldFORMAT = format;
  		decRegADELAY = 0x68;
  		decRegBDELAY = 0x5D;
      SetChromaComb( true );        // enable chroma comb
      SelectCrystal( NTSC_xtal );         // select NTSC crystal
      break;
    case VFormat_PAL_BDGHI:
    case VFormat_PAL_M:
    case VFormat_PAL_N:
      decFieldFORMAT = format;
      decRegADELAY = 0x7F;
      decRegBDELAY = 0x72;
      SetChromaComb( true );        // enable chroma comb
      SelectCrystal( PAL_xtal );         // select PAL crystal
      break;
    case VFormat_SECAM:
      decFieldFORMAT = format;
      decRegADELAY = 0x7F;
      decRegBDELAY = 0xA0;
      SetChromaComb( false );       // disable chroma comb
      SelectCrystal( PAL_xtal );         // select PAL crystal
      break;
    default: // VFormat_AutoDetect
      // auto format detect by examining the number of lines
      if ( Decoder::Is525LinesVideo() ) // lines == 525 -> NTSC
        Decoder::SetVideoFormat( VFormat_NTSC );
      else  // lines == 625 -> PAL/SECAM
        Decoder::SetVideoFormat( VFormat_PAL_BDGHI );    // PAL_BDGHI covers most areas 
  }

  SetSaturation( m_satParam );
  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetVideoFormat( void )
// Purpose: Obtain video format
// Input:   None
// Output:  None
// Return:  Video format
//            Auto format:          VFormat_AutoDetect
//            NTSC (M):             VFormat_NTSC
//            PAL (B, D, G, H, I):  VFormat_PAL_BDGHI
//            PAL (M):              VFormat_PAL_M
//            PAL(N):               VFormat_PAL_N
//            SECAM:                VFormat_SECAM
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetVideoFormat( void )
{
   BYTE bFormat = (BYTE)decFieldFORMAT;
   if ( !bFormat ) // autodetection enabled
      return Is525LinesVideo() ? VFormat_NTSC : VFormat_SECAM;
   else
     return bFormat;
}


//===== Temporal Decimation register ========================================

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetRate( bool fields, VidField even, int rate )
// Purpose: Set frames or fields rate
// Input:   bool fields   - true for fields, false for frames
//          VidField even - true to start decimation with even field, false odd
//          int  rate     - decimation rate: frames (1-50/60); fields(1-25/30)
// Output:  None
// Return:  Fail if error in parameter, else Success
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetRate( bool fields, VidField vf, int rate )
{
  int nMax;
  if ( Is525LinesVideo() == true )
    nMax = 30;  // NTSC
  else
    nMax = 25;  // PAL/SECAM

  // if setting frame rate, double the max value
  if ( fields == false )
    nMax *= 2;

  if ( rate < 0 || rate > nMax )
    return Fail;

  decFieldDEC_FIELD = (fields == false) ? Off : On;
  decFieldDEC_FIELDALIGN = (vf == VF_Even) ? On : Off;
  int nDrop = (BYTE) nMax - rate;
  decFieldDEC_RAT = (BYTE) (fields == false) ? nDrop : nDrop * 2;

  return Success;
}


//===== Brightness Control register =========================================

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetBrightness( int param )
// Purpose: Set video brightness
// Input:   int param - parameter value (0-255; default 128)
// Output:  None
// Return:  Fail if error in parameter, else Success
// Note:    See IsAdjustContrast() for detailed description of the contrast
//          adjustment calculation
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetBrightness( int param )
{
  if( m_param.OutOfRange( param ) )
    return Fail;

  // perform mapping to our range
  int mapped;
  if ( Mapping( param, m_param, &mapped, m_regBrightness ) == Fail )
    return Fail;

  m_briParam = (WORD)param;

  // calculate brightness value
  int value = (128 * mapped) / m_regBrightness.Max() ;

  // need to limit the value to 0x7F (+50%) because 0x80 is -50%!
  if (( mapped > 0 ) && ( value == 0x80 ))
    value = 0x7F;

  // perform adjustment of brightness register if adjustment is needed
  if ( IsAdjustContrast() )
  {
    regBright = value;   // brightness value before adjustment

    long A = (long)regBright * (long)0xD8;
    long B = 64 * ( (long)0xD8 - (long)regContrast );
    long temp = 0x00;
    if ( regContrast != 0 )  // already limit contrast > zero; just in case here
       temp = ( ( A + B ) / (long)regContrast );
    temp = ( temp < -128 ) ? -128 : ( ( temp > 127 ) ? 127 : temp );
    value = (BYTE)temp;

  }

  decRegBRIGHT = (BYTE)value;

  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetBrightness( void )
// Purpose: Obtain brightness value
// Input:   None
// Output:  None
// Return:  Brightness parameter (0-255)
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetBrightness( void )
{
  return m_briParam;
}


//===== Miscellaneous Control register (E_CONTROL, O_CONTROL) ===============

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetLumaNotchFilter( bool mode )
// Purpose: Enable/Disable luma notch filter
// Input:   bool mode - true = Enable; false = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetLumaNotchFilter( bool mode )
{
  decFieldLNOTCH = decFieldODD_LNOTCH = (mode == false) ? On : Off;  // reverse
}


/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsLumaNotchFilter( void )
// Purpose: Check if luma notch filter is enable or disable
// Input:   None
// Output:  None
// Return:  true = Enable; false = Disable
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsLumaNotchFilter( void )
{
  return (decFieldLNOTCH == Off) ? true : false;  // reverse
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetCompositeVideo( bool mode )
// Purpose: Select composite or Y/C component video
// Input:   bool mode - true = Composite; false = Y/C Component
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetCompositeVideo( bool mode )
{
  if ( mode == true )
  {
    // composite video
    decFieldCOMP = decFieldODD_COMP = Off;
    Decoder::SetChromaADC( false );  // disable chroma ADC
    Decoder::SetLumaNotchFilter( true );  // enable luma notch filter
  }
  else
  {
    // Y/C Component video
    decFieldCOMP = decFieldODD_COMP = On;
    Decoder::SetChromaADC( true );  // enable chroma ADC
    Decoder::SetLumaNotchFilter( false );  // disable luma notch filter
  }
}


/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsCompositeVideo( void )
// Purpose: Check if selected composite or Y/C component video
// Input:   None
// Output:  None
// Return:  true = Composite; false = Y/C Component
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsCompositeVideo( void )
{
  return (decFieldCOMP == Off) ? true : false;  // reverse
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetLumaDecimation( bool mode )
// Purpose: Enable/Disable luma decimation filter
// Input:   bool mode - true = Enable; false = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetLumaDecimation( bool mode )
{
   // value of 0 turns the decimation on
   decFieldLDEC = decFieldODD_LDEC = (mode == true) ? 0 : 1;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsLumaDecimation( void )
// Purpose: Check if luma decimation filter is enable or disable
// Input:   None
// Output:  None
// Return:  true = Enable; false = Disable
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsLumaDecimation( void )
{
  return (decFieldLDEC == Off) ? true : false;  // reverse
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetCbFirst( bool mode )
// Purpose: Control whether the first pixel of a line is a Cb or Cr pixel
// Input:   bool mode - true = Normal Cb, Cr order, false = Invert Cb, Cr order
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetCbFirst( bool mode )
{
  decFieldCBSENSE = decFieldODD_CBSENSE = (mode == false) ? On : Off;  // reverse
}


/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsCbFirst( void )
// Purpose: Check if the first pixel of a line is a Cb or Cr pixel
// Input:   None
// Output:  None
// Return:  true = Normal Cb, Cr order, false = Invert Cb, Cr order
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsCbFirst( void )
{
  return (decFieldCBSENSE == Off) ? true : false;  // reverse
}


//===== Luma Gain register (CON_MSB, CONTRAST_LO) ===========================

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetContrast( int param )
// Purpose: Set video contrast
// Input:   int param - parameter value (0-255; default 128)
// Output:  None
// Return:  Fail if error in parameter, else Success
// Note:    See IsAdjustContrast() for detailed description of the contrast
//          adjustment calculation
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetContrast( int param )
{
  if( m_param.OutOfRange( param ) )
    return Fail;

  bool adjustContrast = IsAdjustContrast(); // is contrast need to be adjusted

  // if adjust contrast is needed, make sure contrast reg value != 0
  if ( adjustContrast )
    m_regContrast = CRegInfo( 1, ConMax, ConDef );

  // perform mapping to our range
  int mapped;
  if ( Mapping( param, m_param, &mapped, m_regContrast ) == Fail )
    return Fail;

  m_conParam = (WORD)param;

  // calculate contrast
  DWORD value =  (DWORD)0x1FF * (DWORD)mapped;
  value /= (DWORD)m_regContrast.Max();
  if ( value > 0x1FF )
    value = 0x1FF;

  // contrast is set by a 9 bit value; set LSB first
  decRegCONTRAST_LO = value;

  // now set the Miscellaneous Control Register CON_V_MSB to the 9th bit value
  decFieldCON_MSB = decFieldODD_CON_MSB = ( (value & 0x0100) ? On : Off );

  // perform adjustment of brightness register if adjustment is needed
  if ( adjustContrast )
  {
    regContrast = (WORD)value;    // contrast value

    long A = (long)regBright * (long)0xD8;
    long B = 64 * ( (long)0xD8 - (long)regContrast );
    long temp = 0x00;
    if ( regContrast != 0 )  // already limit contrast > zero; just in case here
       temp = ( ( A + B ) / (long)regContrast );
    temp = ( temp < -128 ) ? -128 : ( ( temp > 127 ) ? 127 : temp );
    decRegBRIGHT = (BYTE)temp;

  }

  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetContrast( void )
// Purpose: Obtain contrast value
// Input:   None
// Output:  None
// Return:  Contrast parameter (0-255)
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetContrast( void )
{
  return m_conParam;
}


//===== Chroma Gain register (SAT_U_MSB, SAT_V_MSB, SAT_U_LO, SAT_V_LO) =====

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetSaturation( int param )
// Purpose: Set color saturation by modifying U and V values
// Input:   int param - parameter value (0-255; default 128)
// Output:  None
// Return:  Fail if error in parameter, else Success
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetSaturation( int param )
{
  if( m_param.OutOfRange( param ) )
    return Fail;

  // color saturation is controlled by two nine bit values:
  // ChromaU & ChromaV
  // To maintain normal color balance, the ratio between the 2 register
  // values should be kept at the power-up default ratio

  // Note that U & V values for NTSC and PAL are the same, SECAM is different

  WORD nominalNTSC_U = 0xFE;     // nominal value (i.e. 100%) for NTSC/PAL
  WORD nominalNTSC_V = 0xB4;
  WORD nominalSECAM_U = 0x87;    // nominal value (i.e. 100%) for SECAM
  WORD nominalSECAM_V = 0x85;

  CRegInfo regSat;               // selected saturation register; NTSC/PAL or SECAM
  WORD nominal_U, nominal_V;     // selected nominal U and V value; NTSC/PAL or SECAM

  // select U & V values of either NTSC/PAL or SECAM to be used for calculation
  if ( GetVideoFormat() == VFormat_SECAM )
  {
    nominal_U = nominalSECAM_U;
    nominal_V = nominalSECAM_V;
    regSat = m_regSaturationSECAM;
  }
  else
  {
    nominal_U = nominalNTSC_U;
    nominal_V = nominalNTSC_V;
    regSat = m_regSaturationNTSC;
  }

  // perform mapping to our range
  int mapped;
  if ( Mapping( param, m_param, &mapped, regSat ) == Fail )
    return Fail;

  m_satParam = (WORD)param;

  WORD max_nominal = max( nominal_U, nominal_V );

  // calculate U and V values
  WORD Uvalue = (WORD) ( (DWORD)mapped * (DWORD)nominal_U / (DWORD)max_nominal );
  WORD Vvalue = (WORD) ( (DWORD)mapped * (DWORD)nominal_V / (DWORD)max_nominal );

  // set U
  decRegSAT_U_LO = Uvalue;

  // now set the Miscellaneous Control Register SAT_U_MSB to the 9th bit value
  decFieldSAT_U_MSB = decFieldODD_SAT_U_MSB = ( (Uvalue & 0x0100) ? On : Off );

  // set V
  decRegSAT_V_LO = Vvalue;

  // now set the Miscellaneous Control Register SAT_V_MSB to the 9th bit value
  decFieldSAT_V_MSB = decFieldODD_SAT_V_MSB = ( (Vvalue & 0x0100) ? On : Off );

  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetSaturation( void )
// Purpose: Obtain saturation value
// Input:   None
// Output:  None
// Return:  Saturation parameter (0-255)
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetSaturation( void )
{
  return m_satParam;
}


//===== Hue Control register (HUE) ==========================================

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetHue( int param )
// Purpose: Set video hue
// Input:   int param - parameter value (0-255; default 128)
// Output:  None
// Return:  Fail if error in parameter, else Success
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetHue( int param )
{
  if( m_param.OutOfRange( param ) )
    return Fail;

  // perform mapping to our range
  int mapped;
  if ( Mapping( param, m_param, &mapped, m_regHue ) == Fail )
    return Fail;

  m_hueParam = (WORD)param;

  int value = (-128 * mapped) / m_regHue.Max();

  if (value > 127)
    value = 127;
  else if (value < -128)
    value = -128;

  decRegHUE = value;

  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetHue( void )
// Purpose: Obtain hue value
// Input:   None
// Output:  None
// Return:  Hue parameter (0-255)
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetHue( void )
{
  return m_hueParam;
}


//===== SC Loop Control register (E_SCLOOP, O_SCLOOP) =======================

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetChromaAGC( bool mode )
// Purpose: Enable/Disable Chroma AGC compensation
// Input:   bool mode - true = Enable, false = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetChromaAGC( bool mode )
{
  decFieldCAGC = decFieldODD_CAGC = (mode == false) ? Off : On;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsChromaAGC( void )
// Purpose: Check if Chroma AGC compensation is enable or disable
// Input:   None
// Output:  None
// Return:  true = Enable, false = Disable
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsChromaAGC( void )
{
  return (decFieldCAGC == On) ? true : false;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetLowColorAutoRemoval( bool mode )
// Purpose: Enable/Disable low color detection and removal
// Input:   bool mode - true = Enable, false = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetLowColorAutoRemoval( bool mode )
{
  decFieldCKILL = decFieldODD_CKILL = (mode == false) ? Off : On;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsLowColorAutoRemoval( void )
// Purpose: Check if low color detection and removal is enable or disable
// Input:   None
// Output:  None
// Return:  true = Enable, false = Disable
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsLowColorAutoRemoval( void )
{
  return (decFieldCKILL == On) ? true : false;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetHorizontalFilter( HorizFilter hFilter )
// Purpose: Control the configuration of the optional 6-tap Horizontal Low-Pass filter
// Input:   HoriFilter hFilter:
//            Auto Format - HFilter_AutoFormat
//            CIF         - HFilter_CIF
//            QCIF        - HFilter_QCIF
//            ICON        - HFilter_ICON
// Output:  None
// Return:  Fail if error in parameter, else Success
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetHorizontalFilter( HorizFilter hFilter )
{
  if ( (hFilter < HFilter_AutoFormat) ||
       (hFilter > HFilter_ICON) )
    return Fail;

  decFieldHFILT = decFieldODD_HFILT = hFilter;
  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetHorizontalFilter( void )
// Purpose: Get the configuration of the optional 6-tap Horizontal Low-Pass filter
// Input:   None
// Output:  None
// Return:  Which filter is using:
//            Auto Format - HFilter_AutoFormat
//            CIF         - HFilter_CIF
//            QCIF        - HFilter_QCIF
//            ICON        - HFilter_ICON
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetHorizontalFilter( void )
{
  return ((int)decFieldHFILT);
}


//===== Output Format register (OFORM) ======================================

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetFullOutputRange( bool mode )
// Purpose: Enable/Disable full output range
// Input:   bool mode - true = Enable, false = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetFullOutputRange( bool mode )
{
  decFieldRANGE = (mode == false) ? Off : On;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsFullOutputRange( void )
// Purpose: Check if full output range is enable or disable
// Input:   None
// Output:  None
// Return:  true = Enable, false = Disable
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsFullOutputRange( void )
{
  return (decFieldRANGE == On) ? true : false;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::SetLumaCoring( CoringLevel cLevel )
// Purpose: Set luminance level such that luminance signal is truncated to zero
//          if below this level
// Input:   CoringLevel cLevel -
//            Coring_None: no coring
//            Coring_8:    8
//            Coring_16:   16
//            Coring_32:   32
// Output:  None
// Return:  Fail if error in parameter, else Success
/////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::SetLumaCoring( CoringLevel cLevel )
{
  if ( ( cLevel < Coring_None) || ( cLevel > Coring_32 ) )
    return Fail;

  decFieldCORE = cLevel;
  return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetLumaCoring( void )
// Purpose: Get luminance level such that luminance signal is truncated to zero
//          if below this level
// Input:   None
// Output:  None
// Return:  Luma coring level -
//            Coring_None: no coring
//            Coring_8:    8
//            Coring_16:   16
//            Coring_32:   32
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetLumaCoring( void )
{
  return ((int)decFieldCORE);
}


//===== Vertical Scaling register (E_VSCALE_HI, O_VSCALE_HI) ================

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetChromaComb( bool mode )
// Purpose: Enable/Disable chroma comb
// Input:   bool mode - true = Enable, false = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetChromaComb( bool mode )
{
  decFieldCOMB = (mode == false) ? Off : On;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsChromaComb( void )
// Purpose: Check if chroma comb is enable or disable
// Input:   None
// Output:  None
// Return:  true = Enable, false = Disable
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsChromaComb( void )
{
  return (decFieldCOMB == On) ? true : false;
}
   
//===== AGC Delay register (ADELAY) =========================================

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetAGCDelay( BYTE value )
// Purpose: Set AGC Delay register
// Input:   Value to be set to
// Output:  None
// Return:  None
// NOTE:    This function set the AGC Delay register to the specified value.
//          No calculation is involved.
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetAGCDelay( BYTE value )
{
  // [!!!] this was considered suspicious by someone...
  //#pragma message ("IS THIS GOOD?? ")
  decRegADELAY = value;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetAGCDelay( void )
// Purpose: Get AGC Delay register
// Input:   None
// Output:  None
// Return:  Register value
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetAGCDelay( void )
{
  return ((int)decRegADELAY);
}


//===== Burst Delay register (BDELAY) =========================================

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetBurstDelay( BYTE value )
// Purpose: Set Burst Delay register
// Input:   Value to be set to
// Output:  None
// Return:  None
// NOTE:    This function set the Burst Delay register to the specified value.
//          No calculation is involved.
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetBurstDelay( BYTE value )
{
  // [!!!] this was considered suspicious by someone...
  //#pragma message ("IS THIS GOOD?? ")
  decRegBDELAY = value;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  int Decoder::GetBurstDelay( void )
// Purpose: Get Burst Delay register
// Input:   None
// Output:  None
// Return:  Register value
/////////////////////////////////////////////////////////////////////////////
int Decoder::GetBurstDelay( void )
{
  return ((int)decRegBDELAY);
}


//===== ADC Interface register (ADC) =========================================

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetAnalogThresholdLow( bool mode )
// Purpose: Define high/low threshold level below which SYNC signal can be detected
// Input:   bool mode - true = low threshold (~75mV), false = high threshold (~125mV)
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetAnalogThresholdLow( bool mode )
{
  decFieldSYNC_T = (mode == false) ? Off : On;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsAnalogThresholdLow( void )
// Purpose: Check if high or low threshold level below which SYNC signal can be detected
// Input:   None
// Output:  None
// Return:  true = low threshold (~75mV), false = high threshold (~125mV)
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsAnalogThresholdLow( void )
{
  return (decFieldSYNC_T == On) ? true : false;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetAGCFunction( bool mode )
// Purpose: Enable/Disable AGC function
// Input:   bool mode - true = Enable, false = Disable
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetAGCFunction( bool mode )
{
  decFieldAGC_EN = (mode == false) ? On : Off; // reverse
}


/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsAGCFunction( void )
// Purpose: Check if AGC function is enable or disable
// Input:   None
// Output:  None
// Return:  true = Enable, false = Disable
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsAGCFunction( void )
{
  return (decFieldAGC_EN == Off) ? true : false;   // reverse
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::PowerDown( bool mode )
// Purpose: Select normal or shut down clock operation
// Input:   bool mode - true = shut down, false = normal operation
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::PowerDown( bool mode )
{
  decFieldCLK_SLEEP = (mode == false) ? Off : On;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsPowerDown( void )
// Purpose: Check if clock operation has been shut down
// Input:   None
// Output:  None
// Return:  true = shut down, false = normal operation
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsPowerDown( void )
{
  return (decFieldCLK_SLEEP == On) ? true : false;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetLumaADC( bool mode )
// Purpose: Select normal or sleep Y ADC operation
// Input:   bool mode - true = normal, false = sleep
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetLumaADC( bool mode )
{
  decFieldY_SLEEP = (mode == false) ? On : Off; // reverse
}


/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsLumaADC( void )
// Purpose: Check if Y ADC operation is in normal operation or sleeping
// Input:   None
// Output:  None
// Return:  true = normal, false = sleep
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsLumaADC( void )
{
  return (decFieldY_SLEEP == Off) ? true : false;  // reverse
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetChromaADC( bool mode )
// Purpose: Select normal or sleep C ADC operation
// Input:   bool mode - true = normal, false = sleep
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SetChromaADC( bool mode )
{
  decFieldC_SLEEP = (mode == false) ? On : Off; // reverse
}


/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsChromaADC( void )
// Purpose: Check if C ADC operation is in normal operation or sleeping
// Input:   None
// Output:  None
// Return:  true = normal, false = sleep
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsChromaADC( void )
{
  return (decFieldC_SLEEP == Off) ? true : false; // reverse
}


/*^^////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SetAdaptiveAGC( bool mode )
// Purpose: Set adaptive or non-adaptive AGC operation
// Input:   bool mode - true = Adaptive, false = Non-adaptive
// Output:  None
// Return:  None
*////////////////////////////////////////////////////////////////////////////
void Decoder::SetAdaptiveAGC( bool mode )
{
   decFieldCRUSH = (mode == false) ? Off : On;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsAdaptiveAGC( void )
// Purpose: Check if adaptive or non-adaptive AGC operation is selected
// Input:   None
// Output:  None
// Return:  true = Adaptive, false = Non-adaptive
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsAdaptiveAGC( void )
{
  return (decFieldCRUSH == On) ? true : false;
}


//===== Software Reset register (SRESET) ====================================

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SoftwareReset( void )
// Purpose: Perform software reset; all registers set to default values
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Decoder::SoftwareReset( void )
{
  decRegSRESET = 0x00;  // write any value will do
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void Decoder::SelectCrystal( char useCrystal )
// Purpose: Select correct crystal for NTSC or PAL
// Input:   char useCrystal - 'N' for NTSC; 'P' for PAL
// Output:  None
// Return:  None
// NOTE:    Assume at most 2 crystals installed in hardware. i.e. 1 for NTSC
//          and the other for PAL/SECAM.
//          If there is only 1 crystal exists (which must be crystal XT0),
//          do nothing since it is already selected.
/////////////////////////////////////////////////////////////////////////////
void Decoder::SelectCrystal( int useCrystal )
{
   if ( Xtals_ [0] && Xtals_ [1] ) {           

      // compare with what we want to use
      if ( (  IsCrystal0Selected() && ( Xtals_ [0] != (DWORD) useCrystal ) ) ||
           ( !IsCrystal0Selected() && ( Xtals_ [0] == (DWORD) useCrystal ) ) )
         // need to change crystal
         SetCrystal( IsCrystal0Selected() ? Crystal_XT1 : Crystal_XT0 );
   }
}

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Decoder::Mapping( int fromValue, CRegInfo fromRange,
//                                           int * toValue, CRegInfo toRange )
// Purpose: Map a value in certain range to a value in another range
// Input:   int fromValue - value to be mapped from
//          CRegInfo fromRange - range of value mapping from
//          CRegInfo toRange   - range of value mapping to
// Output:  int * toValue - mapped value
// Return:  Fail if error in parameter, else Success
// Comment: No range checking is performed here. Assume parameters are in
//          valid ranges.
//          The mapping function does not assume default is always the mid
//          point of the whole range. It only assumes default values of the
//          two ranges correspond to each other.
//
// The mapping formula is:
//
//   For fromRange.Min() <= fromValue <= fromRange.Default():
//
//  fromValue * (toRange.Default() - toRange.Min())
//  ------------------------------------------------ + toRange.Min()
//        fromRange.Default() - fromRange.Min()
//
//   For fromRange.Default() < fromValue <= fromRange.Max():
//
//  (fromValue - fromRange.Default()) * (toRange.Max() - toRange.Default())
//  --------------------------------------------------------------------- + toRange.Default()
//                       fromRange.Max() - fromRange.Default()
//
////////////////////////////////////////////////////////////////////////////
ErrorCode Decoder::Mapping( int fromValue, CRegInfo fromRange,
   int * toValue, CRegInfo toRange )
{
   // calculate intermediate values
   DWORD ToLowRange    = toRange.Default() - toRange.Min();
   DWORD FromLowRange  = fromRange.Default() - fromRange.Min();
   DWORD ToHighRange   = toRange.Max() - toRange.Default();
   DWORD FromHighRange = fromRange.Max() - fromRange.Default();

   // prevent divide by zero
   if ( !FromLowRange || !FromHighRange )
      return ( Fail );

   // perform mapping
   if ( fromValue <= fromRange.Default() )
      *toValue = (int) (DWORD)fromValue * ToLowRange / FromLowRange +
         (DWORD)toRange.Min();
   else
      *toValue = (int) ( (DWORD)fromValue - (DWORD)fromRange.Default() ) *
         ToHighRange / FromHighRange + (DWORD)toRange.Default();

   return ( Success );
}


/////////////////////////////////////////////////////////////////////////////
// Method:  bool Decoder::IsAdjustContrast( void )
// Purpose: Check registry key whether adjust contrast is needed
// Input:   None
// Output:  None
// Return:  true = adjust contrast, false = don't adjust contrast
// Note:    If adjust contrast is turn on, brightness register value will be
//          adjusted such that it remains a constant after the calculation
//          performed by the hardware.
//
//          The formula is:
//             To keep brightness constant (i.e. not affect by changing contrast)
//             set brightness to B/(C/C0)
//             where B is value of brightness before adjustment
//                   C is contrast value
//                   C0 is nominal contrast value (0xD8)
//
//             To adjust the contrast level such that it is at the middle of
//             black and white: set brightness to (B * C0 + 64 * (C0 - C))/C
//             (this is what Intel wants)
//
//             Currently there is still limitation of how much adjustment
//             can be performed. For example, if brightness is already high,
//             (i.e. brightness reg value close to 0x7F), lowering contrast
//             until a certain level will have no adjustment effect on brightness.
//             In fact, it would even bring down brightness to darkness.
//
//             Example 1: if brightness is at nominal value (0x00), contrast can
//                        only go down to 0x47 (brightness adjustment is already
//                        at max of 0x7F) before it starts affecting brightness
//                        which takes it darkness.
//             Example 2: if brightness is at nominal value (0x00), contrast can
//                        go all the way up with brightness adjusted correctly.
//                        However, the max adjustment used is only 0xDC and
//                        the max adjustment we can use is 0x&F.
//             Example 3: if brightness is at max (0x7F), lowering contrast
//                        cannot be compensated by adjusting brightness anymore.
//                        The result is gradually taking brightness to darkness.
//             Example 4: if brightness is at min (0x80), lowering contrast has
//                        no visual effect. Bringing contrast to max is using
//                        0xA5 in brightness for compensation.
//
//             One last note, the center is defined as the middle of the
//             gamma adjusted luminance level. Changing it to use the middle of
//             the linear (RGB) luminance level is possible.
/////////////////////////////////////////////////////////////////////////////
bool Decoder::IsAdjustContrast( void )
{
   return false;
/*
   // locate adjust contrast information in the registry
   // the key to look for in registry is:
   //    Bt848\AdjustContrast - 0 = don't adjust contrast
   //                           1 = adjust contrast

   VRegistryKey vkey( PRK_CLASSES_ROOT, "Bt848" );

   // make sure the key exists
   if ( vkey.lastError() == ERROR_SUCCESS )
   {
      char * adjustContrastKey = "AdjustContrast";
      char   key[3];
      DWORD  keyLen = 2;    // need only first char; '0' or '1'

      // get the registry value and check it, if exist
      if ( ( vkey.getSubkeyValue( adjustContrastKey, key, (DWORD *)&keyLen ) ) &&
           ( key[0] == '1' ) )
         return ( true );
   }
   return ( false );
*/
}

/* Function: SelectFlags
 * Purpose: Selects video standard flags
 * Input: val: DWORD - value to switch on
 *   flags: LONG & - flags fo here
 * Output: None
 */
void SelectFlags( DWORD val, LONG &flags )
{
   switch ( val ) {
   case NTSC_xtal:
      flags |= KS_AnalogVideo_NTSC_M;
      break;
   case PAL_xtal:
      flags |= KS_AnalogVideo_PAL_M   | KS_AnalogVideo_PAL_N    |
               KS_AnalogVideo_PAL_B   | KS_AnalogVideo_PAL_D    |
               KS_AnalogVideo_PAL_H   | KS_AnalogVideo_PAL_I    |
               KS_AnalogVideo_SECAM_B | KS_AnalogVideo_SECAM_D  |
               KS_AnalogVideo_SECAM_G | KS_AnalogVideo_SECAM_H  |
               KS_AnalogVideo_SECAM_K | KS_AnalogVideo_SECAM_K1 |
               KS_AnalogVideo_SECAM_L;
      break;
   }
}

/* Method: Decoder::GetSupportedStandards
 * Purpose: Returns supported standards
 * Input: None
 * Output: LONG: standard flags
 */
LONG Decoder::GetSupportedStandards()
{
   LONG standards =0;

   SelectFlags( Xtals_ [0], standards );
   SelectFlags( Xtals_ [1], standards );
   return standards;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\decoder.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Decoder.h 1.2 1998/04/29 22:43:32 tomz Exp $

#ifndef __DECODER_H
#define __DECODER_H

#include "regField.h"
#include "viddefs.h"
#include "retcode.h"

const int PAL_xtal  = 35;
const int NTSC_xtal = 28;

/////////////////////////////////////////////////////////////////////////////
// CLASS CRegInfo
//
// Description:
//    Provides min, max, and default values for a register. To use this class,
//    user will declare an object of this class and provide min, max and default
//    values of the register.
//
// Attributes:
//    int intMin - minumum value
//    int intMax - maximum value
//    int intDefault - default value
//
// Methods:
//    Min() : return minimum value of the register
//    Max() : return maximum value of the register
//    Default(): return default value of the register
//    OutOfRange() : check if an value is out of range
//
/////////////////////////////////////////////////////////////////////////////
class CRegInfo
{
   int intMin;       // minumum value
   int intMax;       // maximum value
   int intDefault;   // default value

public:
   CRegInfo( void )
   {
      intMin = 0;
      intMax = 0;
      intDefault = 0;
   }

   CRegInfo( int min, int max, int def )
   {
      intMin = min;
      intMax = max;
      intDefault = def;
   }

   // return min, max and default value of a register
   inline int Min( void ) const { return intMin; }
   inline int Max( void ) const { return intMax; }
   inline int Default( void ) const { return intDefault; }

   // check if an value is out of range of a register
   inline bool OutOfRange( int x )
   {
      if( (x > intMax) || (x < intMin) )
         return true;
      return false;
   }
};


/////////////////////////////////////////////////////////////////////////////
// CLASS Decoder
//
// Description:
//    This class encapsulates the register fields in the decoder portion of
//    the Bt848.
//    A complete set of functions are developed to manipulate all the
//    register fields in the decoder for the Bt848.
//    For Read-Write register field, "Set..." function is provided to modify
//    the content of the reigster field. And either "Get..." (for more
//    than 1 bit) or "Is..." (for 1 bit) function is provided to obtain the
//    value of the register field.
//    For Read-Only register field, only "Get..." (for more than 1 bit) or
//    "Is..." (for 1 bit) function is provided to obtain the content of the
//    register field.
//    When there are odd-field complements to the even-field register field,
//    same value is set to both odd and even register fields.
//    Several direct register content modifying/retrieval functions are
//    implemented for direct access to the register contents. They were
//    originally developed for testing purpose only. They are retained in the
//    class for convenience only and usage of these functions must be very cautious.
//
// Methods:
//    See below
//
// Note: 1) Scaling registers are not implemented.
//       2) Odd-fields are set to the same value as the even-field registers
/////////////////////////////////////////////////////////////////////////////

class Decoder
{
protected:
	#include "Declare.h"

   // used for checking if parameter out of register's range
	CRegInfo m_regHue, m_regSaturationNTSC, m_regSaturationSECAM,
            m_regContrast,	m_regBrightness;

   // used for checking parameter range
   CRegInfo m_param;

   // value set to after calculations
	WORD m_satParam, m_conParam, m_hueParam, m_briParam;

   // to be used to adjust contrast
   int  regBright;      // brightness register value before adjustment
   WORD regContrast;    // contrast register value before adjustment
   DWORD Xtals_ [2];
public:
   // constructor and destructor
	Decoder( DWORD *xtals );
	~Decoder();

   // Device Status register (DSTATUS)
   virtual BYTE      GetDeviceStatusReg( void );
   virtual bool      IsVideoPresent( void );
   virtual bool      IsDeviceInHLock( void );
   virtual bool      IsEvenField( void );
   virtual bool      Is525LinesVideo( void );
   virtual bool      IsCrystal0Selected( void );
   virtual bool      IsLumaOverflow( void );
   virtual void      ResetLumaOverflow( void );
   virtual bool      IsChromaOverflow( void );
   virtual void      ResetChromaOverflow( void );

   // Input Format register (IFORM)
   virtual ErrorCode SetVideoInput( Connector );
   virtual int       GetVideoInput( void );
   virtual ErrorCode SetCrystal( Crystal );
   virtual int       GetCrystal( void );
   virtual ErrorCode SetVideoFormat( VideoFormat );
   virtual int       GetVideoFormat( void );

   // Temporal Decimation register (TDEC)
   virtual ErrorCode SetRate( bool, VidField, int );

   // Brightness Control register (BRIGHT)
   virtual ErrorCode SetBrightness( int );
   virtual int       GetBrightness( void );

   // Miscellaneous Control register (E_CONTROL, O_CONTROL)
   virtual void      SetLumaNotchFilter( bool );
   virtual bool      IsLumaNotchFilter( void );
   virtual void      SetCompositeVideo( bool );
   virtual bool      IsCompositeVideo( void );
   virtual void      SetLumaDecimation( bool );
   virtual bool      IsLumaDecimation( void );
   virtual void      SetCbFirst( bool );
   virtual bool      IsCbFirst( void );

   // Luma Gain register (CON_MSB, CONTRAST_LO)
   virtual ErrorCode SetContrast( int );
   virtual int       GetContrast( void );

   // Chroma Gain register (SAT_U_MSB, SAT_V_MSB, SAT_U_LO, SAT_V_LO)
   virtual ErrorCode SetSaturation( int );
   virtual int       GetSaturation( void );

   // Hue Control register (HUE)
   virtual ErrorCode SetHue( int );
   virtual int       GetHue( void );

   // SC Loop Control register (E_SCLOOP, O_SCLOOP)
   virtual void      SetChromaAGC( bool );
   virtual bool      IsChromaAGC( void );
   virtual void      SetLowColorAutoRemoval( bool );
   virtual bool      IsLowColorAutoRemoval( void );
   virtual ErrorCode SetHorizontalFilter( HorizFilter );
   virtual int       GetHorizontalFilter( void );

   // Output Format register (OFORM)
   virtual void      SetFullOutputRange( bool );
   virtual bool      IsFullOutputRange( void );
   virtual ErrorCode SetLumaCoring( CoringLevel );
   virtual int       GetLumaCoring( void );

   // Vertical Scaling register (E_VSCALE_HI, O_VSCALE_HI)
   virtual void      SetChromaComb( bool );
   virtual bool      IsChromaComb( void );

   // AGC Delay register (ADELAY)
   virtual void      SetAGCDelay( BYTE );
   virtual int       GetAGCDelay( void );

   // Burst Delay register (BDELAY)
   virtual void      SetBurstDelay( BYTE );
   virtual int       GetBurstDelay( void );

   // ADC Interface register (ADC)
   virtual void      SetAnalogThresholdLow( bool );
   virtual bool      IsAnalogThresholdLow( void );
   virtual void      SetAGCFunction( bool );
   virtual bool      IsAGCFunction( void );
   virtual void      PowerDown( bool );
   virtual bool      IsPowerDown( void );
   virtual void      SetLumaADC( bool );
   virtual bool      IsLumaADC( void );
   virtual void      SetChromaADC( bool );
   virtual bool      IsChromaADC( void );
   virtual void      SetAdaptiveAGC( bool );
   virtual bool      IsAdaptiveAGC( void );

   // Software Reset register (SRESET)
   virtual void      SoftwareReset( void );

   virtual LONG      GetSupportedStandards();

protected:
   // mapping function
   virtual ErrorCode Mapping( int, CRegInfo, int *, CRegInfo );

   // check registry key value to determine if contrast should be adjusted
   virtual bool IsAdjustContrast( void );

private:
   void              SelectCrystal( int );

};

#endif // __DECODER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\device.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Device.cpp 1.18 1998/05/13 14:44:33 tomz Exp $

#include "device.h"
#include "capmain.h"

const I2C_Offset = 0x110;
const GPIO_Cntl_Offset  = 0x10D;
const GPIO_OutputOffset = 0x118;
const GPIO_DataOffset   = 0x200;


// Global functions/data exposing public class info to the "C" modules

PsDevice *gpPsDevice = NULL;
BYTE     *gpjBaseAddr = NULL;
VOID     *gpHwDeviceExtension = NULL;

DWORD GetSizeHwDeviceExtension( )
{
   return ( sizeof( HW_DEVICE_EXTENSION ) + sizeof( PsDevice ));
}

DWORD GetSizeStreamEx( )
{
   // return the size of the largest possible channel object

   DWORD dwMax = sizeof( VBIChannel );
   dwMax = max( dwMax, sizeof( AlterVideoChannel<VBIChannel> )); 
   dwMax = max( dwMax, sizeof( InterVideoChannel )); 

   DWORD dwReq = 2 * dwMax;   // paired stuff has two of them together

   dwReq += sizeof( STREAMEX );
   return ( dwReq );
}

/* Function: GetDeviceExt
 * Purpose: Used in creation of risc programs to obtain physical addresses
*/
PsDevice *GetCurrentDevice()
{
   // This is only used for I2C stuff.  Remove this ASAP.
   return gpPsDevice;
}

/* Function: SetCurrentDevice
 * Purpose: Remembers the currently active device
 * Input: PsDevice *
 * Output: None
 */
void SetCurrentDevice( PsDevice *dev )
{
   // This is only used for I2C stuff.  Remove this ASAP.
   gpPsDevice = dev;
}

/* Function: GetBase
 * Purpose: Returns the base address of the currently active device
 * Input: None
 * Output: LPBYTE
 */
BYTE *GetBase()
{
   return gpjBaseAddr;
}

/* Function: SetBase
 * Purpose: Remembers the base address of the currently active device
 * Input: None
 * Output: LPBYTE
 */
void SetBase(BYTE *base)
{
   gpjBaseAddr = base;
}





PsDevice::PsDevice( DWORD dwBase ) : 
   BaseAddress_( (LPBYTE)dwBase ),
   LastFreq_( 0 ),
   dwCurCookie_( 0 ), 
   I2CAddr_( 0 ), 
   xBar( PinTypes_ ), 
   CaptureContrll_( xtals_ )
{
   SetCurrentDevice ( this );

   for ( int i = 0; i < (sizeof(videochannels)/sizeof(videochannels[0])); i++ ) {
      videochannels [i] = 0;
   }
   I2CIsInitOK();
#ifdef   HARDWAREI2C
   I2CInitHWMode( 100000 );    // assume frequency = 100Khz
#else
   I2CInitSWMode( 100000 );    // assume frequency = 100Khz
   I2CSWStart();
   I2CSWStop();
#endif
   GPIOIsInitOK();
   DebugOut((0, "*** Base Address = %x\n", BaseAddress_));
}

PsDevice::~PsDevice()
{
   for ( int i = 0; i < (sizeof(videochannels)/sizeof(videochannels[0])); i++ ) {
      VideoChannel *pvcTemp = videochannels [i];
      videochannels [i] = NULL;
      delete pvcTemp;
   }
}

/* Method: PsDevice::AddBuf
 * Purpose: Adds next buffer to be used to the queue
 * Input: VideoChan: VxDVideoChannel &
 *   pBufAddr: PVOID - address of the next buffer
 * Output: None
 */
void PsDevice::AddBuffer( VideoChannel &VideoChan, PHW_STREAM_REQUEST_BLOCK pSrb )
{
   // bogus channel, bye-bye
   if ( !IsOurChannel( VideoChan ) ) {
      DebugOut((0, "PsDevice::Addbuffer - not our channel (pSrb=%x) (&VideoChan=%x)\n", pSrb, &VideoChan ) );
      return;
   }
   DebugOut((1, "PsDevice::Addbuffer - adding (pSrb=%x) (&VideoChan=%x)\n", pSrb, &VideoChan ) );
   VideoChan.AddSRB( pSrb );
}

void PsDevice::Start( VideoChannel &VidChan )
{
   VidChan.Start();
}

void PsDevice::Pause( VideoChannel &VidChan )
{
   *(DWORD*)(gpjBaseAddr+0x10c) &= ~3;    // disable interrupts   [TMZ] [!!!]

   // [TMZ] [!!!]
   for ( int i = 0; i < (sizeof(videochannels)/sizeof(videochannels[0])); i++ )
   {
      if ( videochannels[i] == &VidChan )
      {
         DebugOut((1, "'PsDevice::Pause called on videochannels[%d]\n", i));
      }
   }
   VidChan.Pause();
}

/* Method: PsDevice::Create
 * Purpose: Calls into the channel ( stream ) to create RISC programs for it.
 * Input: VideoChan: VxDVideoChannel &
 *   Parms: StartParms &, parameters to create stream with
 * Output: ErrorCode
 */
ErrorCode PsDevice::Create( VideoChannel &VidChan )
{
   return VidChan.Create();
}

/* Method: PsDevice::Stop
 * Purpose: Adds next buffer to be used to the queue
 * Input: VideoChan: VxDVideoChannel &
 * Output: None
 */
void PsDevice::Stop( VideoChannel &VidChan )
{
   *(DWORD*)(gpjBaseAddr+0x10c) &= ~3;    // disable interrupts   [TMZ] [!!!]

   VidChan.Stop();
}

#if NEED_CLIPPING
/* Method: PsDevice::SetClipping
 * Purpose: Propagates the call down a video channel
 * Input: VideoChan: VxDVideoChannel & - reference
 *   dwData: DWORD - a pointer to RGNDATA in reality
 * Output: None
 */
void PsDevice::SetClipping( VideoChannel &VidChan, const RGNDATA & rgnData )
{
   if ( !rgnData.rdh.nCount )
      return;

   if ( FullSizeChannel_ ) {
      // have to decrese hight of all rectangles in half and decrease top in half

      unsigned i;
      for ( i = 0; i < rgnData.rdh.nCount; i++ ) {
         TRect *lpR = (TRect *)rgnData.Buffer + i;

         // make all even
         lpR->top++;
         lpR->top &= ~1;

         lpR->bottom++;
         lpR->bottom &= ~1;

         lpR->top    /= 2;
         lpR->bottom /= 2;
      }
      FullSizeChannel_->SetClipping( rgnData );
      SlaveChannel_   ->SetClipping( rgnData );
   } else
      VidChan.SetClipping( rgnData );
}
#endif

/* Method: PsDevice::IsVideoChannel
 * Purpose:
 */
bool PsDevice::IsVideoChannel( VideoChannel &aChan )
{
   return bool( &aChan == videochannels [VS_Field1] || &aChan == videochannels [VS_Field2] );
}

/* Method: PsDevice::IsVBIChannel
 * Purpose:
 */
bool PsDevice::IsVBIChannel( VideoChannel &aChan )
{
   return bool( &aChan == videochannels [VS_VBI1] || &aChan == videochannels [VS_VBI2] );
}

/* Method: PsDevice::IsOurChannel
 * Purpose: Verifies the channel
 * Input: aChan: VideoChannel &, reference to a channel
 * Output: true if our, false otherwise
 */
bool PsDevice::IsOurChannel( VideoChannel &aChan )
{
   return IsVideoChannel( aChan ) || IsVBIChannel( aChan );
}

/* Method: PsDevice::DoOpen
 * Purpose: This function performs opening of a video channel
 * Input: st: VideoStream, stream to open
 * Output: ErrorCode
 */
ErrorCode PsDevice::DoOpen( VideoStream st )
{
   DebugOut((1, "PsDevice::DoOpen(%d)\n", st));

   if ( !videochannels [st] )
   {
      DebugOut((1, "   PsDevice::DoOpen(%d) failed - videochannel not created\n", st));
      return Fail;
   }
   videochannels [st]->Init( &CaptureContrll_ );
   if ( videochannels [st]->OpenChannel() != Success ) {
      DebugOut((1, "   PsDevice::DoOpen(%d) failed - videochannel open failed\n", st));
      VideoChannel *pvcTemp = videochannels [st];
      videochannels [st] = NULL;
      delete pvcTemp;
      return Fail;
   }
   return Success;
}

/* Method: PsDevice::OpenChannel
 * Purpose: This function opens a channel requested by the capture driver
 * Input: hVM: VMHANDLE - handle of the VM making a call
 *   pRegs: CLIENT_STRUCT * - pointer to the structure with VM's registers
 * Output: None
 */
ErrorCode PsDevice::OpenChannel( PVOID pStrmEx, VideoStream st )
{
   PVOID addr = &((PSTREAMEX)pStrmEx)->videochannelmem[0];
   ((PSTREAMEX)pStrmEx)->videochannel = addr;

   DebugOut((1, "PsDevice::OpenChannel(%x,%d)\n", addr, st));
   if ( videochannels [st] )
   {
      DebugOut((1, "   PsDevice::OpenChannel(%x,%d) failed - already open\n", addr, st));
      return Fail;
   }
   videochannels[st] = new( addr ) VideoChannel( st );
   videochannels[st]->SetStrmEx( pStrmEx ) ;

   DebugOut((1, "   PsDevice::OpenChannel(%x,%d), videochannels[%d] = %x\n", addr, st, st, videochannels[st]));

   return DoOpen( st );
}

/* Method: PsDevice::OpenInterChannel
 * Purpose: This function opens video channel that produces interleaved fields
 * Input: addr: PVOID, address for the palcement new
 *   st: VideoStream, stream to open ( VBI or video )
 * Output: None
 */
ErrorCode PsDevice::OpenInterChannel( PVOID pStrmEx, VideoStream st )
{
   PVOID addr = &((PSTREAMEX)pStrmEx)->videochannelmem[0];
   ((PSTREAMEX)pStrmEx)->videochannel = addr;

   DebugOut((1, "PsDevice::OpenInterChannel(%x,%d)\n", addr, st));
   // only odd channel can be paired
   if ( !( st & 1 ) || videochannels [st] || videochannels [st-1] )
   {
      DebugOut((1, "   PsDevice::OpenInterChannel(%x,%d) failed - stream not odd or already open\n", addr, st));
      return Fail;
   }
   if ( OpenChannel( (PBYTE)addr + sizeof( InterVideoChannel ), VideoStream( st - 1 ) ) == Success )
   {
      videochannels[st] = new( addr ) InterVideoChannel( st, *videochannels [st-1] );
      videochannels[st]->SetStrmEx( pStrmEx ) ;

      if ( DoOpen( st ) != Success )
      {
         DebugOut((1, "   PsDevice::OpenInterChannel(%x,%d) failed - DoOpen failed\n", addr, st));
         CloseChannel( videochannels [st-1] );
         return Fail;
      }
   }
   else
   {
      DebugOut((1, "   PsDevice::OpenInterChannel(%x,%d) failed - OpenChannel failed\n", addr, st));
      return Fail;
   }
   return Success;
}

/* Method: PsDevice::OpenAlterChannel
 * Purpose: This function opens video channel that produces alternating fields
 * Input: addr: PVOID, address for the palcement new
 *   st: VideoStream, stream to open ( VBI or video )
 * Output: None
 */
ErrorCode PsDevice::OpenAlterChannel( PVOID pStrmEx, VideoStream st )
{
   PVOID addr = &((PSTREAMEX)pStrmEx)->videochannelmem[0];
   ((PSTREAMEX)pStrmEx)->videochannel = addr;

   DebugOut((1, "PsDevice::OpenAlterChannel(%x,%d)\n", addr, st));
   // only odd channel can be paired
   if ( !( st & 1 ) || videochannels [st] || videochannels [st-1] )
   {
      DebugOut((1, "   PsDevice::OpenAlterChannel(%x,%d) failed - stream not odd or already open\n", addr, st));
      return Fail;
   }
   if ( OpenChannel( (PBYTE)addr + sizeof( AlterVideoChannel<VideoChannel> ), VideoStream( st -1 ) ) == Success )
   {
      videochannels[st] = new( addr ) AlterVideoChannel<VideoChannel>( st, *videochannels [st-1] );
      videochannels[st]->SetStrmEx( pStrmEx ) ;
      videochannels[st-1]->SetStrmEx( pStrmEx ) ;

      if ( DoOpen( st ) != Success )
      {
         DebugOut((1, "   PsDevice::OpenAlterChannel(%x,%d) failed - DoOpen failed\n", addr, st));
         CloseChannel( videochannels [st-1] );
         return Fail;
      }
   }
   else
   {
      DebugOut((1, "   PsDevice::OpenAlterChannel(%x,%d) failed - OpenChannel failed\n", addr, st));
      return Fail;
   }
   return Success;
}

/* Method: PsDevice::OpenVBIChannel
 * Purpose: This function opens video channel that produces alternating fields
 * Input: addr: PVOID, address for the palcement new
 *   st: VideoStream, stream to open ( VBI or video )
 * Output: None
 */
ErrorCode PsDevice::OpenVBIChannel( PVOID pStrmEx )
{
   PVOID addr = &((PSTREAMEX)pStrmEx)->videochannelmem[0];
   ((PSTREAMEX)pStrmEx)->videochannel = addr;

   DebugOut((1, "PsDevice::OpenVBIChannel(%x)\n", addr));
   if ( videochannels [VS_VBI1] || videochannels [VS_VBI2] )
   {
      DebugOut((1, "   PsDevice::OpenVBIChannel(%x) failed - already open\n", addr));
      return Fail;
   }

   VBIChannel *tmp = new( (PBYTE)addr + sizeof( VBIAlterChannel ) ) VBIChannel( VS_VBI1 );
   videochannels [VS_VBI1] = tmp;
   DebugOut((1, "   PsDevice::OpenVBIChannel(%x), videochannels[VS_VBI1(%d)] = %x\n", addr, VS_VBI1, videochannels[VS_VBI1]));

   if ( !tmp )
   {
      DebugOut((1, "   PsDevice::OpenVBIChannel(%x) failed - new VBIChannel failed\n", addr));
      return Fail;
   }

   if ( DoOpen( VS_VBI1 ) != Success )
   {
      DebugOut((1, "   PsDevice::OpenVBIChannel(%x) failed - DoOpen(VS_VBI1) failed\n", addr));
      return Fail;
   }

   videochannels [VS_VBI2] = new( addr ) VBIAlterChannel( VS_VBI2, *tmp );
   DebugOut((1, "   PsDevice::OpenVBIChannel(%x), videochannels[VS_VBI2(%d)] = %x\n", addr, VS_VBI2, videochannels[VS_VBI2]));

   if (!videochannels [VS_VBI2])
   {
      DebugOut((1, "   PsDevice::OpenVBIChannel(%x) failed - new VBIAlterChannel failed\n", addr));
      return Fail;
   }

   if ( DoOpen( VS_VBI2 ) != Success )
   {
     DebugOut((1, "   PsDevice::OpenVBIChannel(%x) failed - DoOpen(VS_VBI1) failed\n", addr));
     CloseChannel( videochannels [VS_VBI1] );
     return Fail;
   }

   videochannels[VS_VBI1]->SetStrmEx( pStrmEx ) ;
   videochannels[VS_VBI2]->SetStrmEx( pStrmEx ) ;

   return Success;
}

/* Method: PsDevice::CloseChannel
 * Purpose: Closes a video channel
 * Input: ToClose: VideoChannel *
 * Output: None
 */
void PsDevice::CloseChannel( VideoChannel *ToClose )
{
   *(DWORD*)(gpjBaseAddr+0x10c) &= ~3;    // disable interrupts   [TMZ] [!!!]

   DebugOut((1, "PsDevice::CloseChannel(%x)\n", ToClose));

   if ( IsOurChannel( *ToClose ) )
   {
      // this is a bit ugly solution to make CLOSE_STREAM SRB clean
      if ( ToClose->GetStreamType() == Single )
      {
         VideoStream st = ToClose->GetStreamID();
         DebugOut((1, "   PsDevice::CloseChannel(%x) - closing single channel (stream == %d)\n", ToClose, st));
         VideoChannel * pvcTemp = videochannels [st];
         videochannels [st] = NULL;
         delete pvcTemp;
      }
      else
      {
         DebugOut((1, "   PsDevice::CloseChannel(%x) - closing paired channel\n", ToClose));
         ClosePairedChannel( ToClose );
      }
   }
   else
   {
      DebugOut((1, "   PsDevice::CloseChannel(%x) ignored - not our channel\n", ToClose));
   }
}

/* Method: PsDevice::ClosePairedChannel
 * Purpose: This function opens a channel requested by the capture driver
 * Input: hVM: VMHANDLE - handle of the VM making a call
 *   pRegs: CLIENT_STRUCT * - pointer to the structure with VM's registers
 * Output: None
 */
void PsDevice::ClosePairedChannel( VideoChannel *ToClose )
{
   *(DWORD*)(gpjBaseAddr+0x10c) &= ~3;    // disable interrupts   [TMZ] [!!!]

   DebugOut((1, "PsDevice::ClosePairedChannel(%x)\n", ToClose));

   if ( IsOurChannel( *ToClose ) )
   {
      VideoStream st = ToClose->GetStreamID();
      DebugOut((1, "   PsDevice::ClosePairedChannel(%x) - closing paired channel (stream == %d)\n", ToClose, st));
      DebugOut((1, "   PsDevice::ClosePairedChannel(%x) - streams[%d] = %x\n", ToClose, st, videochannels[st]));
      DebugOut((1, "   PsDevice::ClosePairedChannel(%x) - streams[%d] = %x\n", ToClose, st-1, videochannels[st-1]));

      VideoChannel *pvcTemp;
      
      pvcTemp = videochannels [st];
      videochannels [st] = NULL;
      delete pvcTemp;

      pvcTemp = videochannels [st-1];
      videochannels [st-1] = NULL;
      delete pvcTemp;
   }
   else
   {
      DebugOut((1, "   PsDevice::ClosePairedChannel(%x) ignored - not our channel\n", ToClose));
   }
}

/* Method: PsDevice::SetSaturation
 * Purpose:
 * Input:
 * Output: None
 */
void PsDevice::SetSaturation( LONG Data )
{
   CaptureContrll_.SetSaturation( Data );
}

/* Method: PsDevice::SetHue
 * Purpose:
 * Input:
 * Output: None
 */
void PsDevice::SetHue( LONG Data )
{
   CaptureContrll_.SetHue( Data );
}

/* Method: PsDevice::SetBrightness
 * Purpose:
 * Input:
 * Output: None
 */
void PsDevice::SetBrightness( LONG Data )
{
   CaptureContrll_.SetBrightness( Data );
}

/* Method: PsDevice::SetSVideo
 * Purpose:
 * Input:
 * Output: None
 */
void PsDevice::SetSVideo( LONG Data )
{
   CaptureContrll_.SetSVideo( Data );
}

/* Method: PsDevice::SetContrast
 * Purpose:
 * Input:
 * Output: None
 */
void PsDevice::SetContrast( LONG Data )
{
   CaptureContrll_.SetContrast( Data );
}

/* Method: PsDevice::SetFormat
 * Purpose:
 * Input:
 * Output: None
 */
void PsDevice::SetFormat( LONG Data )
{
   CaptureContrll_.SetFormat( Data );
   // notify all video channels that video timing has changed
   LONG time = Data == KS_AnalogVideo_NTSC_M ? 333667 : 400000;
   for ( int i = 0; i < (sizeof(videochannels)/sizeof(videochannels[0])); i++ )
   {
      if ( videochannels [i] )
      {
         DebugOut((1, "PsDevice::SetFormat(%d) SetTimePerFrame on videochannels[%d]\n", Data, i));
         videochannels [i]->SetTimePerFrame( time );
      }
   }
}

/* Method: PsDevice::SetConnector
 * Purpose:
 * Input:
 * Output: None
 */
void PsDevice::SetConnector( LONG Data )
{
   CaptureContrll_.SetConnector( Data );
}

/* Method: PsDevice::GetSaturation
 * Purpose:
 * Input: pData: PLONG
 * Output: None
 */
LONG PsDevice::GetSaturation()
{
   return CaptureContrll_.GetSaturation();
}

/* Method: PsDevice::GetHue
 * Purpose:
 * Input: pData: PLONG
 * Output: None
 */
LONG PsDevice::GetHue()
{
   return CaptureContrll_.GetHue();
}

/* Method: PsDevice::GetBrightness
 * Purpose:
 * Input: pData: PLONG
 * Output: None
 */
LONG PsDevice::GetBrightness()
{
   return CaptureContrll_.GetBrightness();
}

/* Method: PsDevice::GetSVideo
 * Purpose:
 * Input: pData: PLONG
 * Output: None
 */
LONG PsDevice::GetSVideo()
{
   return CaptureContrll_.GetSVideo();
}

/* Method: PsDevice::GetContrast
 * Purpose:
 * Input: pData: PLONG
 * Output: None
 */
LONG PsDevice::GetContrast()
{
   return CaptureContrll_.GetContrast();
}

/* Method: PsDevice::GetFormat
 * Purpose:
 * Input: pData: PLONG
 * Output: None
 */
LONG PsDevice::GetFormat()
{
   return CaptureContrll_.GetFormat();
}

/* Method: PsDevice::GetConnector
 * Purpose:
 * Input: pData: PLONG
 * Output: None
 */
LONG PsDevice::GetConnector()
{
   return CaptureContrll_.GetConnector();
}

/* Method: PsDevice::ChangeNotifyChannels
 * Purpose: Invoked to notify channels of some global changes
 */                         
void PsDevice::ChangeNotifyChannels( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
   // We should only do this once per "system" stream.
   // Video streams don't seem to care.
   // That just leaves one VBI notification required
   
   videochannels [VS_VBI1]->ChangeNotification( pSrb );
}

/* Method: PsDevice::GetSupportedStandards
 * Purpose: Obtains video standards device can support
 * Input: None
 * Output: LONG
 */
LONG PsDevice::GetSupportedStandards()
{
   return CaptureContrll_.GetSupportedStandards();
}

bool PsDevice::InitOK()
{
   return CaptureContrll_.InitOK();
}

#ifndef	HARDWAREI2C

//===========================================================================
// Bt848 software I2C stuff
//===========================================================================

/*
 * If we build with software I2C then these routines fake the Hardware I2C routines
 * so the tuner code keeps working
 */

ErrorCode PsDevice::I2CHWRead( BYTE address, BYTE *value )
{
    ErrorCode error;

    error = I2CSWStart();
    if(error) {
        return error;
    }
    
    error = I2CSWWrite( address | 0x01 );
    if(error) {
        return error;
    }

    error = I2CSWRead( value );
    if(error) {
       return error;
    }
        
   	error = I2CSWSendNACK();
   	if(error) {
       	return error;
    }

   	error = I2CSWStop();

   	return error;
}


ErrorCode PsDevice::I2CHWWrite3( BYTE address, BYTE value1, BYTE value2 )
{
    ErrorCode error;

    error = I2CSWStart();
    if(error) {
        return error;
    }
    
    error = I2CSWWrite( address );
    if(error) {
        return error;
    }

    error = I2CSWWrite( value1 );
    if(error) {
        return error;
    }

    error = I2CSWWrite( value2 );
    if(error) {
        return error;
    }
    
   	error = I2CSWStop();
   	return error;
}

#endif



//////////////////////////////////////////////////////////////////


#ifdef __cplusplus
extern "C" {
#endif

   #include <stdarg.h>

#ifdef __cplusplus
}
#endif

// #include "capdebug.h"

#define  DEBUG_PRINT_PREFIX   "   ---: "
// #define  DEBUG_PRINT_PREFIX   "bt848wdm: "

long DebugLevel = 0;
BOOL bNewLine = TRUE;

extern "C" void MyDebugPrint(long DebugPrintLevel, char * DebugMessage, ... )
{
   if (DebugPrintLevel <= DebugLevel)
   {
       char debugPrintBuffer[256] ;

       va_list marker;
       va_start( marker, DebugMessage );     // Initialize variable arguments.
       vsprintf( debugPrintBuffer,
                 DebugMessage,
                 marker );

       if( bNewLine )
       {
          DbgPrint(("%s", DEBUG_PRINT_PREFIX));
       }
       
       DbgPrint((debugPrintBuffer));

       if( debugPrintBuffer[strlen(debugPrintBuffer)-1] == '\n')
       {
          bNewLine = TRUE;
       }
       else
       {
          bNewLine = FALSE;
       }

       va_end( marker );                     // Reset variable arguments.
   }
}

#if TRACE_CALLS
   #define MAX_TRACE_DEPTH 10
   unsigned long ulTraceDepth = 0;
   char achIndentBuffer[100];

   char * IndentStr( )
   {
      unsigned long ul = ulTraceDepth < MAX_TRACE_DEPTH ? ulTraceDepth : MAX_TRACE_DEPTH;
      unsigned long x;
      char * lpszBuf = achIndentBuffer;
      for( x = 0; x < ul; x++)
      {
         // indent two spaces per depth increment
         *lpszBuf++ = ' ';
         *lpszBuf++ = ' ';
      }
      sprintf (lpszBuf, "[%lu]", ulTraceDepth);
      return( achIndentBuffer );

   }

   Trace::Trace(char *pszFunc)
   {
      psz = pszFunc;
      DebugOut((0, "%s %s\n", IndentStr(), psz));
      ulTraceDepth++;
   }
   Trace::~Trace()
   {
      ulTraceDepth--;
      // DebugOut((0, "%s %s\n", IndentStr(), psz));
   }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\defaults.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Defaults.h 1.4 1998/04/29 22:43:32 tomz Exp $

#ifndef __DEFAULTS_H
#define __DEFAULTS_H

const int DefWidth = 320;
const int DefHeight = 240;

const int MaxInWidth = 720;
const int MinInWidth = 80;

const int MaxInHeight = 480;
const int MinInHeight = 60;

const int MaxOutWidth = 720;
const int MinOutWidth = 80;

const int MaxOutHeight = 480;
const int MinOutHeight = 60;

//--------------------------------------
const int VBISamples  = 800 * 2;
//const int VBISamples  = 768 * 2;
//--------------------------------------

const int VBIStart    =  10;
const int VBIEnd      =  21;
const int VBILines    = VBIEnd - VBIStart + 1;
const int VBISampFreq = 28636363;

const DWORD MaxVidProgSize   = 288 * 5 * sizeof( DWORD );// max size of a planar program
const DWORD MaxVidCrossings  = 720 *  288 * 3 / PAGE_SIZE; // worst case buffer layout
const DWORD MaxVidSize       = MaxVidProgSize + MaxVidCrossings * 5 * sizeof( DWORD );

const DWORD MaxVBIProgSize   = VBILines * 2 * sizeof( DWORD );
const DWORD MaxVBICrossings  = VBISamples * VBILines / PAGE_SIZE;
const DWORD MaxVBISize       = MaxVBIProgSize + MaxVBICrossings * 5 * sizeof( DWORD );

const DWORD MaxHelpers       = 13;
// 2 fields, 2 programs per field + skippers
const DWORD VideoOffset      = MaxVBISize * 2 * 2 + MaxVBISize * MaxHelpers;

const DWORD RISCProgramsSize = // total memory needed for all risc programs
   ( MaxVidSize * 2 + MaxVBISize * 2 ) * 2 + MaxVBISize * MaxHelpers; // skippers
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\fourcc.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Fourcc.h 1.4 1998/04/29 22:43:33 tomz Exp $

#ifndef __FOURCC_H
#define __FOURCC_H

// copied from mmsystem.h
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                                \
                ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
                ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )


#define FCC_YUY2    mmioFOURCC( 'Y', 'U', 'Y', '2' )
#define FCC_Y41P    mmioFOURCC( 'Y', '4', '1', 'P' )
#define FCC_Y8      mmioFOURCC( 'Y', '8', ' ', ' ' )
#define FCC_422     mmioFOURCC( '4', '2', '2', ' ' )
#define FCC_411     mmioFOURCC( '4', '1', '1', ' ' )
#define FCC_YVU9    mmioFOURCC( 'Y', 'V', 'U', '9' )
#define FCC_YV12    mmioFOURCC( 'Y', 'V', '1', '2' )
#define FCC_VBI     0xf72a76e0L  //mmioFOURCC( 'V', 'B', 'I', ' ' )
#define FCC_UYVY    mmioFOURCC( 'U', 'Y', 'V', 'Y' )
#define FCC_RAW     mmioFOURCC( 'R', 'A', 'W', ' ' )
#define FCC_I420    mmioFOURCC( 'I', '4', '2', '0' )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\gpio.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Gpio.cpp 1.2 1998/04/29 22:43:33 tomz Exp $

#include "gpio.h"

/////////////////////////////////////////////////////////////////////////////
// Constructor
/////////////////////////////////////////////////////////////////////////////
GPIO::GPIO( void ) :
   // construct all GPIO related register and register fields
   decRegGPIO ( 0x10C, RW ),               // GPIO register
   decFieldGPCLKMODE( decRegGPIO, 10, 1, RW ),
   decFieldGPIOMODE( decRegGPIO, 11, 2, RW ),
   decFieldGPWEC( decRegGPIO, 13, 1, RW ),
   decFieldGPINTI( decRegGPIO, 14, 1, RW ),
   decFieldGPINTC( decRegGPIO, 15, 1, RW ),
   decRegGPOE( 0x118, RW ),                // GPOE register
   decRegGPIE( 0x11C, RW ),                // GPIE register
   decRegGPDATA( 0x200, WO ),            // GPDATA register
   initOK( false )
{
   initOK = true;
}

/////////////////////////////////////////////////////////////////////////////
// Destructor
/////////////////////////////////////////////////////////////////////////////
GPIO::~GPIO()
{
}

/////////////////////////////////////////////////////////////////////////////
// Method:  bool GPIO::IsInitOK( void )
// Purpose: Check if GPIO is initialized successfully
// Input:   None
// Output:  None
// Return:  true or false
/////////////////////////////////////////////////////////////////////////////
bool GPIO::IsInitOK( void )
{
   return( initOK );
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void GPIO::SetGPCLKMODE( State s )
// Purpose: Set or clear GPCLKMODE
// Input:   State s - On to set; Off to clear
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void GPIO::SetGPCLKMODE( State s )
{
   decFieldGPCLKMODE = s;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  int GPIO::GetGPCLKMODE( void )
// Purpose: Get value of GPCLKMODE
// Input:   None
// Output:  None
// Return:  int - On (1) or Off (0)
/////////////////////////////////////////////////////////////////////////////
int GPIO::GetGPCLKMODE( void )
{
   return ( decFieldGPCLKMODE );
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void GPIO::SetGPIOMODE( GPIOMode mode )
// Purpose: Set GPIO mode
// Input:   GPIOMode mode - GPIO_NORMAL, GPIO_SPI_OUTPUT, GPIO_SPI_INPUT,
//                          GPIO_DEBUG_TEST
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void GPIO::SetGPIOMODE( GPIOMode mode )
{
   decFieldGPIOMODE = mode;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  int GPIO::GetGPIOMODE( void )
// Purpose: Get GPIO mode
// Input:   None
// Output:  None
// Input:   int - GPIO_NORMAL, GPIO_SPI_OUTPUT, GPIO_SPI_INPUT, GPIO_DEBUG_TEST
/////////////////////////////////////////////////////////////////////////////
int GPIO::GetGPIOMODE( void )
{
   return( decFieldGPIOMODE );
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void GPIO::SetGPWEC( State s )
// Purpose: Set or clear GPWEC
// Input:   State s - On to set; Off to clear
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void GPIO::SetGPWEC( State s )
{
   decFieldGPWEC = s;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  int GPIO::GetGPWEC( void )
// Purpose: Get value of GPWEC
// Input:   None
// Output:  None
// Return:  int - On (1) or Off (0)
/////////////////////////////////////////////////////////////////////////////
int GPIO::GetGPWEC( void )
{
   return ( decFieldGPWEC );
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void GPIO::SetGPINTI( State s )
// Purpose: Set or clear GPINTI
// Input:   State s - On to set; Off to clear
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void GPIO::SetGPINTI( State s )
{
   decFieldGPINTI = s;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  int GPIO::GetGPINTI( void )
// Purpose: Get value of GPINTI
// Input:   None
// Output:  None
// Return:  int - On (1) or Off (0)
/////////////////////////////////////////////////////////////////////////////
int GPIO::GetGPINTI( void )
{
   return ( decFieldGPINTI );
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void GPIO::SetGPINTC( State s )
// Purpose: Set or clear GPINTC
// Input:   State s - On to set; Off to clear
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void GPIO::SetGPINTC( State s )
{
   decFieldGPINTC = s;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  int GPIO::GetGPINTC( void )
// Purpose: Get value of GPINTC
// Input:   None
// Output:  None
// Return:  int - On (1) or Off (0)
/////////////////////////////////////////////////////////////////////////////
int GPIO::GetGPINTC( void )
{
   return ( decFieldGPINTC );
}

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode GPIO::SetGPOE( int bit, State s )
// Purpose: Set or clear a bit in GPOE
// Input:   int bit - bit to be set or clear
//          State s - On to set; Off to clear
// Output:  None
// Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode GPIO::SetGPOE( int bit, State s )
{
   // range checking
   if ( ( bit < 0 ) || ( bit > MAX_GPIO_BIT ) )
      return ( Fail );

   RegField decFieldTemp( decRegGPOE, (BYTE)bit, 1, RW );   // create a reg field
   decFieldTemp = s;

   return ( Success );
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void GPIO::SetGPOE( DWORD value )
// Purpose: Set GPOE value
// Input:   DWORD value - value to be set to
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void GPIO::SetGPOE( DWORD value )
{
   decRegGPOE = ( value & 0x00FFFFFFL );     // bits [23:0]
}

/////////////////////////////////////////////////////////////////////////////
// Method:  int GPIO::GetGPOE( int bit )
// Purpose: Get value of a bit in GPOE
// Input:   int bit - bit to get value from
// Output:  None
// Return:  int - On (1), Off (0), or -1 for parameter error
/////////////////////////////////////////////////////////////////////////////
int GPIO::GetGPOE( int bit )
{
   // range checking
   if ( ( bit < 0 ) || ( bit > MAX_GPIO_BIT ) )
      return ( -1 );

   RegField decFieldTemp( decRegGPOE, (BYTE)bit, 1, RW );   // create a reg field
   return( decFieldTemp );
}

/////////////////////////////////////////////////////////////////////////////
// Method:  DWORD GPIO::GetGPOE( void )
// Purpose: Get value of GPOE
// Input:   None
// Output:  None
// Return:  Content of GPOE (DWORD)
/////////////////////////////////////////////////////////////////////////////
DWORD GPIO::GetGPOE( void )
{
   return ( decRegGPOE & 0x00FFFFFFL );
}

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode GPIO::SetGPIE( int bit, State s )
// Purpose: Set or clear a bit in GPIE
// Input:   int bit - bit to be set or clear
//          State s - On to set; Off to clear
// Output:  None
// Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode GPIO::SetGPIE( int bit, State s )
{
   // range checking
   if ( ( bit < 0 ) || ( bit > MAX_GPIO_BIT ) )
      return ( Fail );

   RegField decFieldTemp( decRegGPIE, (BYTE)bit, 1, RW );   // create a reg field
   decFieldTemp = s;

   return ( Success );
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void GPIO::SetGPIE( DWORD value )
// Purpose: Set GPIE value
// Input:   DWORD value - value to be set to
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void GPIO::SetGPIE( DWORD value )
{
   decRegGPIE = ( value & 0x00FFFFFFL );     // bits [23:0]
}

/////////////////////////////////////////////////////////////////////////////
// Method:  int GPIO::GetGPIE( int bit )
// Purpose: Get value of a bit in GPIE
// Input:   int bit - bit to get value from
// Output:  None
// Return:  int - On (1), Off (0), or -1 for parameter error
/////////////////////////////////////////////////////////////////////////////
int GPIO::GetGPIE( int bit )
{
   // range checking
   if ( ( bit < 0 ) || ( bit > MAX_GPIO_BIT ) )
      return ( -1 );

   RegField decFieldTemp( decRegGPIE, (BYTE)bit, 1, RW );   // create a reg field
   return( decFieldTemp );
}

/////////////////////////////////////////////////////////////////////////////
// Method:  DWORD GPIO::GetGPIE( void )
// Purpose: Get value of GPIE
// Input:   None
// Output:  None
// Return:  Content of GPIE (DWORD)
/////////////////////////////////////////////////////////////////////////////
DWORD GPIO::GetGPIE( void )
{
   return ( decRegGPIE & 0x00FFFFFFL );
}

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode GPIO::SetGPDATA( GPIOReg * data, int size, int offset )
// Purpose: Set GPDATA registers contents
// Input:   GPIOReg * data - ptr to data to be copied from
//          int size       - number of registers to be copied; max is 64
//          int offset     - how many registers to skip (default = 0)
// Output:  None
// Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode GPIO::SetGPDATA( GPIOReg * data, int size, int offset )
{
   // check size and offset for out of bound
   if ( ( offset < 0 ) || ( size < 0 ) || ( size + offset > MAX_GPDATA_SIZE ) )
      return ( Fail );

   // point to offseted register
   GPIOReg * p = (GPIOReg *)((char *)decRegGPDATA.GetBaseAddress() +
                             decRegGPDATA.GetOffset() +
                             offset * sizeof( GPIOReg ));   // pts to offseted register
   memcpy( p, data, size * sizeof( GPIOReg ) );
   return ( Success );
}

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode GPIO::GetGPDATA( GPIOReg * data, int size, int offset )
// Purpose: Get GPDATA registers contents
// Input:   GPIOReg * data - ptr to data to be copied to
//          int size       - number of registers to be copied; max is 64
//          int offset     - how many registers to skip (default = 0)
// Output:  None
// Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode GPIO::GetGPDATA( GPIOReg * data, int size, int offset )
{
   // check size and offset for out of bound
   if ( ( offset < 0 ) || ( size < 0 ) || ( size + offset > MAX_GPDATA_SIZE ) )
      return ( Fail );

   // point to offseted register
   GPIOReg * p = (GPIOReg *)((char *)decRegGPDATA.GetBaseAddress() +
                             decRegGPDATA.GetOffset() +
                             offset * sizeof( GPIOReg ));   // pts to offseted register
   memcpy( data, p, size * sizeof( GPIOReg ) );
   return ( Success );
}


/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode GPIO::SetGPDATA( int fromBit, int toBit,
//                                     DWORD value, int offset )
// Purpose: Set GPDATA contents with specified range of bits
// Input:   int fromBit - starting bit
//          int toBit   - ending bit
//          DWORD value - value to set to
//          int offset  - how many registers to skip (default = 0)
// Output:  None
// Return:  Success or Fail
// Comment: By specifying a range of bits to be set, it allows a portion of
//          the GDATA register to be modified. For example,
//             SetGPDATA( 8, 10, 5, 0 )
//          would set the first GPDATA register's [10:8] to value 0x101
/////////////////////////////////////////////////////////////////////////////
ErrorCode GPIO::SetGPDATA( int fromBit, int toBit, DWORD value, int offset )
{
   // check size and offset for out of bound
   if ( ( fromBit < 0 ) || ( fromBit > MAX_GPIO_BIT ) ||
        ( toBit   < 0 ) || ( toBit   > MAX_GPIO_BIT ) || ( fromBit > toBit ) ||
        ( offset  < 0 ) || ( offset  > MAX_GPDATA_SIZE ) )
      return ( Fail );

   // make sure value can "fit" into range of bits specified
   if ( value >= (DWORD) ( 0x00000001L << ( toBit - fromBit + 1 ) ) )
      return ( Fail );

   RegisterDW reg( decRegGPDATA.GetOffset() + offset * sizeof( GPIOReg ), RW );
   RegField field( reg, (BYTE)fromBit, (BYTE)(toBit - fromBit + 1), RW );
   field = value;

   return ( Success );
}


/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode GPIO::GetGPDATA( int fromBit, int toBit,
//                                     DWORD * value, int offset )
// Purpose: Get GPDATA contents with specified range of bits
// Input:   int fromBit - starting bit
//          int toBit   - ending bit
//          int offset  - how many registers to skip (default = 0)
// Output:  DWORD * value - value retrieved
// Return:  Success or Fail
// Comment: By specifying a range of bits to be set, it allows a portion of
//          the GDATA register to be retrieved. For example,
//             GetGPDATA( 8, 10, &data, 0 )
//          would set *data to the first GPDATA register's [10:8] content
/////////////////////////////////////////////////////////////////////////////
ErrorCode GPIO::GetGPDATA( int fromBit, int toBit, DWORD * value, int offset )
{
   // check size and offset for out of bound
   if ( ( fromBit < 0 ) || ( fromBit > MAX_GPIO_BIT ) ||
        ( toBit   < 0 ) || ( toBit   > MAX_GPIO_BIT ) || ( fromBit > toBit ) ||
        ( offset  < 0 ) || ( offset  > MAX_GPDATA_SIZE ) )
      return ( Fail );

   RegisterDW reg( decRegGPDATA.GetOffset() + offset * sizeof( GPIOReg ), RW );
   RegField field( reg, (BYTE)fromBit, (BYTE)(toBit - fromBit + 1), RW );
   *value = field;

   return ( Success );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\distr.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Distr.cpp 1.2 1998/04/29 22:43:33 tomz Exp $

#include "mytypes.h"
#define label( x ) } x: _asm {

void CreateDistribution( WORD OrigFPS, WORD NeededFPS, PWORD lpwDistribution )
{
    _asm {
                push    edi

                mov     edi, dword ptr lpwDistribution
//                mov     es,  word ptr lpwPixWidthMap+2
                mov     ax, NeededFPS
                shl     eax, 16
                movzx   ecx, word ptr OrigFPS
                or      cx, cx
                jz      short end
                xor     edx, edx
                div     ecx
                mov     ebx, eax
                mov     eax, 8000H
label( L1 )     and     eax, 0FFFFh
                add     eax, ebx
                shld    edx, eax, 16
                mov     [edi], dx
                add     edi,2
                dec     cx
                jnz     short L1

label( end )
                pop     edi
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\gpiotype.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Gpiotype.h 1.2 1998/04/29 22:43:33 tomz Exp $

#ifndef __GPIOTYPE_H
#define __GPIOTYPE_H


//===========================================================================
// TYPEDEFS for GPIO
//===========================================================================

// GPIO modes
typedef enum { GPIO_NORMAL,
               GPIO_SPI_OUTPUT,
               GPIO_SPI_INPUT,
               GPIO_DEBUG_TEST } GPIOMode;

typedef DWORD GPIOReg;    // GPIO register type

#endif // __GPIOTYPE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\device.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Device.h 1.10 1998/05/11 20:27:07 tomz Exp $

#ifndef __DEVICE_H
#define __DEVICE_H

#ifdef __cplusplus
extern "C" {
#endif
#ifndef  _STREAM_H
#include "strmini.h"
#endif
#ifdef __cplusplus
}
#endif

#ifndef __PISCES_H
#include "pisces.h"
#endif

#ifndef __MYTYPES_H
#include "mytypes.h"
#endif

#ifndef __VIDCH_H
#include "vidch.h"
#endif

#ifndef __I2C_H
#include "bti2c.h"
#endif

#ifndef __GPIO_H
#include "gpio.h"
#endif

#include "xbar.h"

#ifndef __I2C_H__
#include <i2cgpio.h>
#endif


#define TUNER_BRAND_TEMIC     1
#define TUNER_BRAND_PHILIPS   2
#define TUNER_BRAND_ALPS      3

typedef struct _TUNER_INFO
{
   ULONG TunerBrand;          // Brand of tuner
   BYTE  TunerI2CAddress;     // I2C address for Temic tuner
   WORD  TunerBandCtrlLow;    // Ctrl code for VHF low
   WORD  TunerBandCtrlMid;    // Ctrl code for VHF high
   WORD  TunerBandCtrlHigh;   // Ctrl code for UHF
} TUNER_INFO, *PTUNER_INFO;

extern LONG  PinTypes_ []; // just allocate maximum possible
extern DWORD xtals_ []; // no more than 2 xtals
extern TUNER_INFO TunerInfo;

void ReadXBarRegistryValues( IN PDEVICE_OBJECT PhysicalDeviceObject );
void ReadXTalRegistryValues( IN PDEVICE_OBJECT PhysicalDeviceObject );
void ReadTunerRegistryValues( IN PDEVICE_OBJECT PhysicalDeviceObject );

VOID AdapterSetCrossbarProperty( PHW_STREAM_REQUEST_BLOCK pSrb );
VOID AdapterGetCrossbarProperty( PHW_STREAM_REQUEST_BLOCK pSrb );

void AdapterSetVideoProcAmpProperty( PHW_STREAM_REQUEST_BLOCK pSrb );
void AdapterGetVideoProcAmpProperty( PHW_STREAM_REQUEST_BLOCK pSrb );

void AdapterSetVideoDecProperty( PHW_STREAM_REQUEST_BLOCK pSrb );
void AdapterGetVideoDecProperty( PHW_STREAM_REQUEST_BLOCK pSrb );

void AdapterSetTunerProperty( PHW_STREAM_REQUEST_BLOCK pSrb );
void AdapterGetTunerProperty( PHW_STREAM_REQUEST_BLOCK pSrb );

void AdapterSetTVAudioProperty( PHW_STREAM_REQUEST_BLOCK pSrb );
void AdapterGetTVAudioProperty( PHW_STREAM_REQUEST_BLOCK pSrb );

void HandleIRP( PHW_STREAM_REQUEST_BLOCK pSrb );


// Forward declarations

class PsDevice;

extern void SetCurrentDevice( PsDevice *dev );
extern BYTE *GetBase();
extern void SetBase(BYTE *base);

/* Class: PsDevice
 * Purpose: This is the class that encapsulates the adapter in the WDM model.
*/
class PsDevice
{

public:

   PsDevice( DWORD dwBase );
   ~PsDevice();

   void *operator new( size_t, void *buf ) { return buf; }
   void operator delete( void *, size_t ) {}

   LPBYTE GetBaseAddress() { return BaseAddress_; }
   bool InitOK();

   PDEVICE_OBJECT PDO;   // Physical Device Object
   State Interrupt() { return CaptureContrll_.Interrupt(); }

   ErrorCode OpenChannel( PVOID pStrmEx, VideoStream st );
   void CloseChannel( VideoChannel *ToClose );

   ErrorCode OpenInterChannel( PVOID pStrmEx, VideoStream st );
   ErrorCode OpenAlterChannel( PVOID pStrmEx, VideoStream st );
   ErrorCode OpenVBIChannel( PVOID pStrmEx );
   void      ClosePairedChannel( VideoChannel *ToClose );

   bool IsVideoChannel( VideoChannel &aChan );
   bool IsVBIChannel( VideoChannel &aChan );
   bool IsOurChannel( VideoChannel &aChan );


   ErrorCode DoOpen( VideoStream st );

   void AddBuffer( VideoChannel &aChan, PHW_STREAM_REQUEST_BLOCK );
   ErrorCode Create( VideoChannel &VidChan );
   void Start( VideoChannel &VidChan );
   void Stop( VideoChannel &VidChan );
   void Pause( VideoChannel &VidChan );

   void EnableAudio( State s );

   void SetVideoState( PHW_STREAM_REQUEST_BLOCK pSrb );
   void GetVideoState( PHW_STREAM_REQUEST_BLOCK pSrb );
   void SetClockMaster( PHW_STREAM_REQUEST_BLOCK pSrb );

   // tuner methods
   void SetChannel( long lFreq );
   int GetPllOffset( PULONG busy, ULONG &lastFreq );

   I2C      i2c;
   GPIO     gpio;
   BtPisces CaptureContrll_;
   CrossBar xBar;

   void SetSaturation( LONG Data );
   void SetHue( LONG Data );
   void SetBrightness( LONG Data );
   void SetSVideo( LONG Data );
   void SetContrast( LONG Data );
   void SetFormat( LONG Data );
   void SetConnector( LONG Data );

   LONG GetSaturation();
   LONG GetHue();
   LONG GetBrightness();
   LONG GetSVideo();
   LONG GetContrast();
   LONG GetFormat();
   LONG GetConnector();

public:

      // this should be before the capture controller, as CapCtrl uses the base address
      LPBYTE         BaseAddress_;

      VideoChannel   *videochannels [4];

      long LastFreq_;


      DWORD    dwCurCookie_;

      BYTE     I2CAddr_;

#ifdef	HAUPPAUGEI2CPROVIDER
// new private members of PsDevice for Hauppauge I2C Provider:
      LARGE_INTEGER LastI2CAccessTime;
      DWORD         dwExpiredCookie;
      DWORD         dwI2CClientTimeout;
#endif


   static void STREAMAPI CreateVideo( PHW_STREAM_REQUEST_BLOCK pSrb );
   static void STREAMAPI DestroyVideo( PHW_STREAM_REQUEST_BLOCK pSrb );

   static void STREAMAPI DestroyVideoNoComplete( PHW_STREAM_REQUEST_BLOCK pSrb );
   static void STREAMAPI StartVideo( PHW_STREAM_REQUEST_BLOCK pSrb );

   // tuner and video standard notifications are handled here
   void ChangeNotifyChannels( IN PHW_STREAM_REQUEST_BLOCK pSrb );
   
   static NTSTATUS STDMETHODCALLTYPE I2COpen( PDEVICE_OBJECT, ULONG, PI2CControl );
   static NTSTATUS STDMETHODCALLTYPE I2CAccess( PDEVICE_OBJECT, PI2CControl );

   // callbacks

          LONG GetSupportedStandards();
          
          void GetStreamProperty( PHW_STREAM_REQUEST_BLOCK pSrb );
          void SetStreamProperty( PHW_STREAM_REQUEST_BLOCK pSrb );
          void GetStreamConnectionProperty( PHW_STREAM_REQUEST_BLOCK pSrb );

          void ProcessSetDataFormat( PHW_STREAM_REQUEST_BLOCK pSrb );

      //void *operator new( size_t, void *buf ) { return buf; }
      //void operator delete( void *, size_t ) {}

   // I2C API
   bool I2CIsInitOK( void );

#ifdef	HARDWAREI2C
   ErrorCode I2CInitHWMode( long freq );

   void I2CSetFreq( long freq );

   int I2CReadDiv( void );

   ErrorCode I2CHWRead( BYTE address, BYTE *value );
   ErrorCode I2CHWWrite2( BYTE address, BYTE value1 );
   ErrorCode I2CHWWrite3( BYTE address, BYTE value1, BYTE value2 );
   int I2CReadSync( void );
#else
// tuner.cpp contains code to fake these using Software I2C just
// to make the older tuner code work until it is seperated out
   ErrorCode I2CHWRead( BYTE address, BYTE *value );
   ErrorCode I2CHWWrite3( BYTE address, BYTE value1, BYTE value2 );
#endif	           

   int I2CGetLastError( void );

   void StoreI2CAddress( BYTE addr );
   BYTE GetI2CAddress();

#ifdef HAUPPAUGEI2CPROVIDER
   ErrorCode I2CInitSWMode( long freq );
   ErrorCode I2CSWStart( void );
   ErrorCode I2CSWStop( void );
   ErrorCode I2CSWRead( BYTE * value );
   ErrorCode I2CSWWrite( BYTE value );
   ErrorCode I2CSWSendACK( void );
   ErrorCode I2CSWSendNACK( void );
//   ErrorCode I2CSWSetSCL( Level );
//   int       I2CSWReadSCL( void );
//   ErrorCode I2CSWSetSDA( Level );
//   int       I2CSWReadSDA( void );
#endif

   // GPIO API
   bool GPIOIsInitOK( void );
   void SetGPCLKMODE( State s );
   int GetGPCLKMODE( void );
   void SetGPIOMODE( GPIOMode mode );
   int GetGPIOMODE( void );
   void SetGPWEC( State s );
   int GetGPWEC( void );
   void SetGPINTI( State s );
   int GetGPINTI( void );
   void SetGPINTC( State s );
   int GetGPINTC( void );
   ErrorCode SetGPOEBit( int bit, State s );
   void SetGPOE( DWORD value );
   int GetGPOEBit( int bit );
   DWORD GetGPOE( void );
   ErrorCode SetGPIEBit( int bit , State s );
   void SetGPIE( DWORD value );
   int GetGPIEBit( int bit );
   DWORD GetGPIE( void );
   ErrorCode SetGPDATA( GPIOReg *data, int size, int offset );
   ErrorCode GetGPDATA( GPIOReg *data, int size, int offset );
   ErrorCode SetGPDATABits( int fromBit, int toBit, DWORD value, int offset );
   ErrorCode GetGPDATABits( int fromBit, int toBit, DWORD *value, int offset );
};


inline  void PsDevice::StoreI2CAddress( BYTE addr )
{
   I2CAddr_ = addr;
}

inline BYTE PsDevice::GetI2CAddress()
{
   return I2CAddr_;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\field.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Field.h 1.12 1998/05/08 18:18:51 tomz Exp $

#ifndef __FIELD_H
#define __FIELD_H

/* Type: VideoStream
 * Purpose: Identifies a video stream channel
 * Note: Not all of these are used today. It should be a fairly minor job to
 *   start using them, though
 */
typedef enum
{
   VS_Below = -1,
   VS_Field1, VS_Field2, VS_VBI1, VS_VBI2, VS_Analog, VS_CC, VS_EDS,
   VS_Raw,
   VS_Above
} VideoStream;

#define STREAM_IDX_CAPTURE 0
#define STREAM_IDX_PREVIEW 1
#define STREAM_IDX_VBI     2
#define STREAM_IDX_ANALOG  3


#include "mytypes.h"
#include "scaler.h"
#include "pscolspc.h"
#include "viddefs.h"
#include "queue.h"
#include "preg.h"
#include "chanifac.h"

const MaxProgsForField  = 2;

typedef Queue<DataBuf> VidBufQueue;

/* Class: Field
 * Purpose: Encapsulates the operation of a single video field provided by BtPisces
 * Attributes:
 * Operations:
 */

extern "C" VOID STREAMAPI AdapterCancelPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

class Field
{
   private:
      PsColorSpace  LocalColSpace_;
      VidBufQueue   *BufQue_;
      DWORD         dwPitch_;
      bool          Started_;
      int           SkipCount_;
      long          TimePerFrame_;
      LONGLONG      LapsedTime_;
      LONG          FrameTiming_;
      VideoStream   VidStrm_;

      // used to notify video channel
      ChanIface    *callback_;

      bool          Paired_;
      bool          ready_;

      // this is used by the video channel to report timestamps
      LONGLONG      InterruptCounter_;
      LONGLONG      FrameCounter_;

      RegField      &CaptureEnable_;

   public:

      bool         Interrupt_;

      Field( RegField &CapEn, RegBase *ColReg, RegBase *WordSwap,
         RegBase *ByteSwap );
      virtual ~Field() {}

      inline void CancelSrbList( )
      {
         while( !BufQue_->IsEmpty( ) )
         {
            DataBuf buf = BufQue_->Get();
            AdapterCancelPacket( buf.pSrb_ );
         }

         BufQue_->Flush();
      }

      void Notify( PVOID pTag, bool skipped )
         { if ( callback_ ) callback_->Notify( pTag, skipped ); }

      void SetStreamID( VideoStream );
      VideoStream GetStreamID();

      void ResetCounters();

      virtual ErrorCode SetAnalogWindow( MRect &r ) = 0;
      virtual void      GetAnalogWindow( MRect &r ) = 0;

      virtual ErrorCode SetDigitalWindow( MRect &r ) = 0;
      virtual void      GetDigitalWindow( MRect &r ) = 0;

      void  SetBufPitch( DWORD dwP ) { 
         dwPitch_ = dwP;
         DebugOut((1, "SetBufPitch(%d)\n", dwPitch_));
      }
      DWORD GetBufPitch()            { return dwPitch_; }

      virtual void  SetColorFormat( ColFmt aColor )
      { LocalColSpace_.SetColorFormat( aColor ); }

      virtual ColFmt  GetColorFormat()
      { return LocalColSpace_.GetColorFormat(); }

      DataBuf GetNextBuffer();

      void SetFrameRate( long time );
      void SetPaired( bool p );
      bool GetPaired();

      void SetReady( bool flag );
      bool GetReady();

      void SetBufQuePtr( VidBufQueue *pQ ) { BufQue_ = pQ; }
      VidBufQueue &GetCurrentQue() { return *BufQue_; }

      void SetCallback( ChanIface *iface ) { callback_ = iface;}

      State  Start();
      void   Stop();
      bool   IsStarted() { return Started_; }

      State  Skip();

      // called by the BtPiscess::ProcessRISCIntr()
      void GotInterrupt() { InterruptCounter_++; }

      void GetCounters( LONGLONG &FrameNo, LONGLONG &drop );

      void SetStandardTiming( LONG t );
      LONG GetStandardTiming();

};

/* Class: FieldWithScaler
 * Purpose: Adds scaling capability to a field
 * Attributes:
 * Operations:
 */
class FieldWithScaler : public Field
{
   private:
      Scaler LocalScaler_;

   public:
      FieldWithScaler( RegField &CapEn, VidField field, RegBase *ColReg,
         RegBase *WordSwap, RegBase *ByteSwap ) : LocalScaler_( field ),
      Field( CapEn, ColReg, WordSwap, ByteSwap ) {}

      virtual ErrorCode SetAnalogWindow( MRect &r ) { return LocalScaler_.SetAnalogWin( r ); }
      virtual void      GetAnalogWindow( MRect &r ) { LocalScaler_.GetAnalogWin( r ); }

      virtual ErrorCode SetDigitalWindow( MRect &r ) { return LocalScaler_.SetDigitalWin( r ); }
      virtual void      GetDigitalWindow( MRect &r ) { LocalScaler_.GetDigitalWin( r ); }

      void VideoFormatChanged( VideoFormat format );
      void TurnVFilter( State s );
};

/* Class: VBIField
 * Purpose: Encapsulates the operation of a VBI data 'field'
 * Attributes:
 * Operations:
 */
class VBIField : public Field
{
   private:
      DECLARE_VBIPACKETSIZE;
      DECLARE_VBIDELAY;

      MRect AnalogWin_;
      MRect DigitalWin_;

   public:
      VBIField( RegField &CapEn ) : Field( CapEn, NULL, NULL, NULL ),
      CONSTRUCT_VBIPACKETSIZE, CONSTRUCT_VBIDELAY
      {}

      virtual void  SetColorFormat( ColFmt ) {}
      virtual ColFmt  GetColorFormat() { return CF_VBI; };

      virtual ErrorCode SetAnalogWindow( MRect &r ) { AnalogWin_ = r; return Success; }
      virtual void      GetAnalogWindow( MRect &r ) { r = AnalogWin_; }

      virtual ErrorCode SetDigitalWindow( MRect &r )
      {
         DigitalWin_ = r;
         DWORD dwNoOfDWORDs = r.Width() / 4;
//         SetBufPitch( r.Width() * ColorSpace( CF_VBI ).GetBitCount() / 8 );
         VBI_PKT_LO = (BYTE)dwNoOfDWORDs;
         VBI_PKT_HI = dwNoOfDWORDs > 0xff; // set the 9th bit
         VBI_HDELAY = r.left;
         return Success;
      }
      virtual void  GetDigitalWindow( MRect &r ) { r = DigitalWin_; }

      ~VBIField() {}
};

inline Field::Field( RegField &CapEn, RegBase *ColReg, RegBase *WordSwap,
   RegBase *ByteSwap ) : SkipCount_( 0 ), CaptureEnable_( CapEn ),
   LocalColSpace_( CF_RGB32, *ColReg, *WordSwap, *ByteSwap ),
   Started_( false ), callback_( NULL ), BufQue_( NULL ), dwPitch_( 0 ),
   TimePerFrame_( 333667 ), LapsedTime_( 0 ),InterruptCounter_( 0 ),
   FrameCounter_( 0 ), Interrupt_( true ), FrameTiming_( 333667 )
{
   
}

/* Method: Field::SetFrameRate
 * Purpose: Sets frame rate
 * Input: time: long, time in 100s nanoseconds per frame
 */
inline void Field::SetFrameRate( long time )
{
   TimePerFrame_ = time;

   // this is needed to make sure very first get returns a buffer
   LapsedTime_ = time;
}

inline void Field::SetStreamID( VideoStream st )
{
   VidStrm_ = st;
}

inline VideoStream Field::GetStreamID()
{
   return VidStrm_;
}

inline void Field::SetPaired( bool p )
{
   Paired_ = p;
}

inline bool Field::GetPaired()
{
   return Paired_;
}

inline void Field::GetCounters( LONGLONG &FrameNo, LONGLONG &drop )
{
   // Frame number is what frame index we should be on.
   // Use interrupt count, not just frames returned.
   FrameNo = InterruptCounter_;

   // Drop count = number of interrupts - number of completed buffers
   drop = InterruptCounter_ - FrameCounter_;
   
   if ( drop > 0 )
   {
      drop--;

      // We've reported the drops, so show frame count as caught
      // up to interrupt count
      FrameCounter_ += drop;
      DebugOut((1, "%d,", drop));
   }
   else if ( drop < 0 )
   {
     DebugOut((1, "*** %d ***,", drop));
   }
   else
   {
      DebugOut((1, "0,"));
   }
}

inline void Field::ResetCounters()
{
   FrameCounter_ = InterruptCounter_ = 0;
}

inline void Field::SetReady( bool flag )
{
   ready_ = flag;
}

inline bool Field::GetReady()
{
   return ready_;
}

inline void Field::SetStandardTiming( LONG t )
{
   FrameTiming_ = t;
}

inline LONG Field::GetStandardTiming()
{
   return FrameTiming_;
}

/* Method: Field::GetNextBuffer
 * Purpose: Returns next buffer from the queue, if time is correct for it.
 * Input: None
 */
inline DataBuf Field::GetNextBuffer()
{
   // that's how long it takes to capture a frame of video
   LapsedTime_ += GetStandardTiming();
   DataBuf buf;

   // [TMZ] [!!!] - hack, disable wait 'cause it doesn't work

   //if ( LapsedTime_ >= TimePerFrame_ ) {
   if ( 1 ) {

      // have to increment the frame number if we want that frame only
      if ( IsStarted() ) {
         GotInterrupt();
      }

//#define  FORCE_BUFFER_SKIP_TESTING
#ifdef   FORCE_BUFFER_SKIP_TESTING
      static int iTestSkip = 0;
      BOOL bEmpty = BufQue_->IsEmpty();
      DebugOut((0, "Queue(%x) bEmpty = %d\n", BufQue_, bEmpty));
      if ( iTestSkip++ & 1 ) {
         // Every other query should look like the buffer is empty.
         bEmpty = TRUE;
         DebugOut((1, "  [override] set bEmpty = %d\n", bEmpty));
      }
      if ( !bEmpty ) {
         buf = BufQue_->Get();
         DebugOut((1, "  GotBuf addr %X\n", buf.pData_ ) );
         LapsedTime_ = 0;
         FrameCounter_++;
      } else {
         DebugOut((1, "  No buffer in que at %d\n",LapsedTime_));
         if ( !IsStarted() ) {
            InterruptCounter_--;
            FrameCounter_--;
         }
      }
#else
      if ( !BufQue_->IsEmpty() ) {
         buf = BufQue_->Get();
         DebugOut((1, "GotBuf addr %X\n", buf.pData_ ) );
         LapsedTime_ = 0;
         FrameCounter_++;
      } else {
         DebugOut((1, "No buffer in que at %d\n",LapsedTime_));
         if ( !IsStarted() ) {
            InterruptCounter_--;
            FrameCounter_--;
         }
      }
#endif
   }
   DebugOut((1, "returning buf {pSrb=%x, pData=%x}\n", buf.pSrb_, buf.pData_ ) );
   return buf;
}

/* Method: Field::Start
 * Purpose: Initiates the data flow out of decoder into the FIFO
 * Input: None
 * Output: State: Off if channel was off; On if channel was on
 */
inline State Field::Start()
{
   Trace t("Field::Start()");

   Started_ = true;
   State RetVal = SkipCount_ >= MaxProgsForField ? Off : On;
   SkipCount_--;
   if ( SkipCount_ < 0 )
      SkipCount_ = 0;
   CaptureEnable_ = On;
   return RetVal;
}

inline  void  Field::Stop()
{
   Trace t("Field::Stop()");

   Started_ = false;
   CaptureEnable_ = Off;
   LapsedTime_ = TimePerFrame_;
}

/* Method: Field::Skip
 * Purpose: Increments the skip count and stops the data flow if it exceeds the max
 * Input: None
 * Output: State: Off if channel is stopped; On if channel remains running
 */
inline State Field::Skip()
{
   Trace t("Field::Skip()");

   SkipCount_++;
   if ( SkipCount_ >= MaxProgsForField ) {
      Stop();
      return Off;
   }
   return On;
}

inline void FieldWithScaler::VideoFormatChanged( VideoFormat format )
{
   LocalScaler_.VideoFormatChanged( format );
}

inline void FieldWithScaler::TurnVFilter( State s )
{
   LocalScaler_.TurnVFilter( s );
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\i2c.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/I2c.cpp 1.6 1998/05/08 18:18:52 tomz Exp $

//===========================================================================
// I2C DATA/CONTROL REGISTER API
//===========================================================================
										     
#include "bti2c.h"	  

//**************************************************************************
//	DEFINES
//**************************************************************************
#define I2C_WRITE         0         // write operation
#define I2C_READ          1         // read operation

#define PCI_FREQ          33000000L // frequency for PCI in hz
#define I2CDIV_MAX        15        // I2C maximum divider

#define TIMEOUT           500       // timeout value (500ms) to wait for an I2C operation
                                    // passing 3 values to I2C takes ~450ms

#ifdef HAUPPAUGEI2CPROVIDER
extern "C" ULONG GetTickCount( void );
#endif

// Let me know at compile time what i2c setup I'm building
#if SHOW_BUILD_MSGS
   #ifdef HAUPPAUGEI2CPROVIDER
      #pragma message("*** using 'Hauppauge' i2c code")
   #else
      #pragma message("*** not using 'Hauppauge' i2c code")
   #endif

   #ifdef HARDWAREI2C
      #pragma message("*** using hardware i2c code")
   #else
      #pragma message("*** not using hardware i2c code")
   #endif
#endif

//===========================================================================
// Bt848 I2C Class Implementation
//===========================================================================

/////////////////////////////////////////////////////////////////////////////
// Constructor
/////////////////////////////////////////////////////////////////////////////
I2C::I2C( void ) :
   // construct I2C register and register fields
   decRegINT_STAT ( 0x100, RW ),    // Interrupt Status register
   decFieldI2CDONE( decRegINT_STAT, 8, 1, RR ),
   decFieldRACK( decRegINT_STAT, 25, 1, RO ),
   decRegI2C ( 0x110, RW ),              // I2C Data/Control register
   decFieldI2CDB0( decRegI2C, 24, 8, RW ),
   decFieldI2CDB1( decRegI2C, 16, 8, RW ),
   decFieldI2CDB2( decRegI2C,  8, 8, RW ),
   decFieldI2CDIV( decRegI2C,  4, 4, RW),
   decFieldSYNC( decRegI2C, 3, 1, RW),
   decFieldW3B( decRegI2C, 2, 1, RW),
   decFieldSCL( decRegI2C, 1, 1, RW),
   decFieldSDA( decRegI2C, 0, 1, RW)
{
   initOK = false;
   cycle  = 0L;
   errNum = I2CERR_OK;
   mode   = I2CMode_None;
}

/////////////////////////////////////////////////////////////////////////////
// Destructor
/////////////////////////////////////////////////////////////////////////////
I2C::~I2C()
{
}


/////////////////////////////////////////////////////////////////////////////
//  Method:  bool I2C::IsInitOK( void )
//  Purpose: Check if I2C is initialized successfully
//  Input:   None
//  Output:  None
//  Return:  true or false
/////////////////////////////////////////////////////////////////////////////
bool I2C::IsInitOK( void )
{
   // initialize I2C register shadow
   I2CResetShadow();

   initOK = true;
   return( initOK );
}

#ifdef	HARDWAREI2C                                                         
/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2C::I2CInitHWMode( long freq )
//  Purpose: Initialize I2C for hardware control of SCL and SDA
//  Input:   long freq - frequency (hz) to run SCL at
//  Output:  None
//  Return:  None
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2C::I2CInitHWMode( long freq )
{
   // initialization was successful?
   if ( initOK != true )
   {
      errNum = I2CERR_INIT;
      return Fail;
   }
   
   // initialize I2C register shadow
   I2CResetShadow();

   decFieldSCL = sh.i2cShadow.scl = 1;   // must be 1 for hardware mode
   decFieldSDA = sh.i2cShadow.sda = 1;   // must be 1 for hardware mode

   I2CSetFreq( freq );   // set frequency for hardware control

   // I2C is running hardware mode
   mode = I2CMode_HW;
   return Success;
}
#endif

/////////////////////////////////////////////////////////////////////////////
//  Method:  void I2C::I2CSetFreq( long freq )
//  Purpose: Set frequency for SCL
//  Input:   long freq - frequency (hz) to run SCL at. (137.5khz to 2.0625Mhz)
//             PCI frequency 33Mhz: SCL = (412.50Khz to 33.81Khz)
//                           25Mhz: SCL = (312.50Khz to 25.61Khz)
//  Output:  None
//  Return:  None
/////////////////////////////////////////////////////////////////////////////
void I2C::I2CSetFreq( long freq )
{
	unsigned int i2cdiv;

	// avoid division errors
	if( freq > 1 )
		i2cdiv = (unsigned int) (PCI_FREQ / (64 * freq));
	else
		i2cdiv = 0;

	if( i2cdiv > I2CDIV_MAX )
		i2cdiv = I2CDIV_MAX;

	decFieldI2CDIV = sh.i2cShadow.div = i2cdiv;
}

#ifdef	HARDWAREI2C                                                         

/////////////////////////////////////////////////////////////////////////////
//  Method:  int I2C::I2CReadDiv( void )
//  Purpose: Obtain value of programmable divider
//  Input:   None
//  Output:  None
//  Return:  Value of programmable divider
/////////////////////////////////////////////////////////////////////////////
int I2C::I2CReadDiv( void )
{
	return decFieldI2CDIV;
}

/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2C::I2CHWRead( BYTE address, BYTE *value )
//  Purpose: Perform a hardware read from the I2C
//  Input:   int address - address to be read from
//  Output:  int *value  - retrieved value
//  Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2C::I2CHWRead( BYTE address, BYTE *value )
{
   // check if correct mode is selected
   if ( mode != I2CMode_HW )
   {
      errNum = I2CERR_MODE;
      return Fail;
   }

   shadow::_i2c_reg i2cTemp = sh.i2cShadow;   // obtain previous settings that didn't change

   // see above for reasons of doing all these.
   i2cTemp.addr_rw = address | I2C_READ;
   i2cTemp.byte1   = 0;
   i2cTemp.byte2   = 0;
   i2cTemp.w3b     = 0;

   decRegI2C = *(DWORD *)&i2cTemp;

   if ( I2CHWWaitUntilDone( TIMEOUT ) == Fail )
   {
      errNum = I2CERR_TIMEOUT;
      return Fail;
   }

   *value = (BYTE) decFieldI2CDB2;   // returned value is in 3rd byte

   if ( I2CHWReceivedACK() == true )
      return Success;
   else
   {
      errNum = I2CERR_NOACK;
      return Fail;
   }
}

/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2C::I2CHWWrite2( BYTE address, BYTE value1 )
//  Purpose:  Perform a hardware write of two bytes to the I2C
//  Input:   int address - address to be written to
//           int value1  - value of 2nd byte to be written
//  Output:  None
//  Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2C::I2CHWWrite2( BYTE address, BYTE value1 )
{
   // check if correct mode is selected
   if ( mode != I2CMode_HW )
   {
      errNum = I2CERR_MODE;
      return Fail;
   }
   
   shadow::_i2c_reg i2cTemp = sh.i2cShadow;   // obtain previous settings that didn't change

   // see above for reasons of doing all these.
	i2cTemp.addr_rw = address | I2C_WRITE;
	i2cTemp.byte1   = value1;
	i2cTemp.byte2   = 0;
	i2cTemp.w3b     = 0;

   decRegI2C = *(DWORD *)&i2cTemp;

   if ( I2CHWWaitUntilDone( TIMEOUT ) == Fail )
   {
      errNum = I2CERR_TIMEOUT;
      return Fail;
   }

   if ( I2CHWReceivedACK() == true )
      return Success;
   else
   {
      errNum = I2CERR_NOACK;
      return Fail;
   }
}

/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2C::I2CHWWrite3( BYTE address, BYTE value1, BYTE value2 )
//  Purpose: Perform a hardware write of three bytes to the I2C
//  Input:   int address - address to be written to
//           int value1  - value of 2nd byte to be written
//           int value2  - value of 3rd byte to be written
//  Output:  None
//  Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2C::I2CHWWrite3( BYTE address, BYTE value1, BYTE value2 )
{
   // check if correct mode is selected
   if ( mode != I2CMode_HW )
   {
      errNum = I2CERR_MODE;
      return Fail;
   }
   
   shadow::_i2c_reg i2cTemp = sh.i2cShadow;   // obtain previous settings that didn't change

   // see above for reasons of doing all these.
	i2cTemp.addr_rw = address | I2C_WRITE;
	i2cTemp.byte1   = value1;
	i2cTemp.byte2   = value2;
	i2cTemp.w3b     = 1;

   decRegI2C = *(DWORD *)&i2cTemp;

	if ( I2CHWWaitUntilDone( TIMEOUT ) == Fail )
   {
      errNum = I2CERR_TIMEOUT;
      return Fail;
   }

   if ( I2CHWReceivedACK() == true )
      return Success;
   else
   {
      errNum = I2CERR_NOACK;
      return Fail;
   }
}



/////////////////////////////////////////////////////////////////////////////
//  Method:  int I2C::I2CReadSync( void )
//  Purpose: Read I2C sync value
//  Input:   None
//  Output:  None
//  Return:  Sync value
/////////////////////////////////////////////////////////////////////////////
int I2C::I2CReadSync( void )
{
   return decFieldSYNC;
}

#endif

/////////////////////////////////////////////////////////////////////////////
//  Method:  int I2C::I2CGetLastError( void )
//  Purpose: Obtain last I2C error number
//  Input:   None
//  Output:  None
//  Return:  Last I2C error number
/////////////////////////////////////////////////////////////////////////////
int I2C::I2CGetLastError( void )
{
   return errNum;
}

//============================================================================
// Following functions are used internally
//============================================================================

/////////////////////////////////////////////////////////////////////////////
//  Method:  void I2C::I2CResetShadow( void )
//  Purpose: Reset register shadow
//  Input:   int maxWait - maximum waiting time in milliseconds
//  Output:  None
//  Return:  Success if done; Fail if timeout
/////////////////////////////////////////////////////////////////////////////
void I2C::I2CResetShadow( void )
{
   // initialize I2C register shadow
   sh.Initer = 0;
}
   
/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2C::I2CHWWaitUntilDone( int maxWait )
//  Purpose: Wait for hardware I2C to finish
//  Input:   int maxWait - maximum waiting time in milliseconds
//  Output:  None
//  Return:  Success if done; Fail if timeout
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2C::I2CHWWaitUntilDone( int maxWait )
{
//   DWORD startTime = GetTickCount();

   // loop until either I2CDONE is set or timeout
   while (1)
   {
      if ( I2CHWIsDone() == true )
         return Success;
#if 0
      // timeout?
      if ( GetTickCount() - startTime > (DWORD)maxWait )
      {
         errNum = I2CERR_TIMEOUT;
         return Fail;
      }
#endif
   }
}

/////////////////////////////////////////////////////////////////////////////
//  Method:  bool I2C::I2CHWIsDone( void )
//  Purpose: Determine if I2C has finished a read or write operation by
//           checking the I2CDONE bit in the interrupt status register
//  Input:   None
//  Output:  None
//  Return:  true if done; else false
/////////////////////////////////////////////////////////////////////////////
bool I2C::I2CHWIsDone( void )
{
   if ( decFieldI2CDONE != 0 )
   {
      // Need to clear the bit when it is set; don't want to alter any other bits
      // Writing a 1 to the bit clears it.
      decFieldI2CDONE = 1;
      return true;
   }
   else
      return false;
}

/////////////////////////////////////////////////////////////////////////////
//  Method:  bool I2C::I2CHWReceivedACK( void )
//  Purpose: Determine if ACK is receieved
//  Input:   None
//  Output:  None
//  Return:  true if ACK received; else false
/////////////////////////////////////////////////////////////////////////////
bool I2C::I2CHWReceivedACK( void )
{
   return ( ( decFieldRACK != 0 ) ? true : false );
}

#ifdef HAUPPAUGEI2CPROVIDER
/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2C::I2CInitSWMode( long freq )
//  Purpose: Initialize I2C for software control of SCL and SDA
//  Input:   long freq - frequency (hz) to run SCL at
//  Output:  None
//  Return:  None
//  Note:    After calling I2CIsInitOK(), application should call this
//           function and check for return value is Success before starting
//           software communication.
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2C::I2CInitSWMode( long freq )
{
   // initialization was successful?
   if ( initOK != true )
   {
      errNum = I2CERR_INIT;
      return Fail;
   }

   // initialize I2C register shadow
   I2CResetShadow();

	decFieldSCL = sh.i2cShadow.scl = 1;
	decFieldSDA = sh.i2cShadow.sda = 1;

	I2CSetFreq( 0 );        // set frequency to 0 for software control

   // need to calibrate in order to generate the correct clock cycle
   // the approach is to calculate how many dummy loop we need in order to
   // generate a cycle that is 2 * freq * 1000 Hz
   cycle  = 10000L;        // use a large number to start
   DWORD elapsed = 0L;
   while ( elapsed < 5 )      // loop until delay is long enough for calculation
   {
      cycle *= 10;
      DWORD start = GetTickCount();
      for ( volatile DWORD i = cycle; i > 0; i-- )
         ;
      elapsed = GetTickCount() - start;
   }
   if ( freq > 1 )
      cycle = cycle / elapsed * 1000L / freq / 2;
      
   // I2C is running software mode
   mode = I2CMode_SW;
   return Success;
}

/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2C::I2CSWStart( void )
//  Purpose: Generate START condition using software control
//  Input:   None
//  Output:  None
//  Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2C::I2CSWStart( void )
{
   // check if correct mode is selected
   if ( mode != I2CMode_SW )
   {
      errNum = I2CERR_MODE;
      return Fail;
   }
   
   // SendStart - send an I2c start
   // i.e. SDA 1 -> 0 with SCL = 1

   if ( I2CSWSetSDA( LevelHi )  != Success ) { errNum = I2CERR_SDA; return Fail; }
   if ( I2CSWSetSCL( LevelHi )  != Success ) { errNum = I2CERR_SCL; return Fail; }
   if ( I2CSWSetSDA( LevelLow ) != Success ) { errNum = I2CERR_SDA; return Fail; }
   if ( I2CSWSetSCL( LevelLow ) != Success ) { errNum = I2CERR_SCL; return Fail; }
   return Success;
}                  

/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2C::I2CSWStop( void )
//  Purpose: Generate STOP condition using software control
//  Input:   None
//  Output:  None
//  Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2C::I2CSWStop( void )
{
   // check if correct mode is selected
   if ( mode != I2CMode_SW )
   {
      errNum = I2CERR_MODE;
      return Fail;
   }
   
   // SendStop - sends an I2C stop, releasing the bus.
   // i.e. SDA 0 -> 1 with SCL = 1

   if ( I2CSWSetSCL( LevelLow ) != Success ) { errNum = I2CERR_SCL; return Fail; }
   if ( I2CSWSetSDA( LevelLow ) != Success ) { errNum = I2CERR_SDA; return Fail; }
   if ( I2CSWSetSCL( LevelHi )  != Success ) { errNum = I2CERR_SCL; return Fail; }
   if ( I2CSWSetSDA( LevelHi )  != Success ) { errNum = I2CERR_SDA; return Fail; }
   return Success;
}

/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2C::I2CSWRead( BYTE * value )
//  Purpose: Read a byte from the slave
//  Input:   None
//  Output:  BYTE * value - byte read from slave
//  Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2C::I2CSWRead( BYTE * value )
{
   // check if correct mode is selected
   if ( mode != I2CMode_SW )
   {
      errNum = I2CERR_MODE;
      return Fail;
   }
   
   *value = 0x00;   

   // read 8 bits from I2c into Accumulator
   for( BYTE mask = 0x80; mask > 0; mask = (BYTE)( mask >> 1 ) )
   {
      if ( I2CSWSetSCL( LevelLow ) != Success ) { errNum = I2CERR_SCL; return Fail; }
      if ( I2CSWSetSCL( LevelHi )  != Success ) { errNum = I2CERR_SCL; return Fail; }
      if ( I2CSWReadSDA() == TRUE )
         *value = (BYTE)( *value | mask ); // set the bit
   }
   return Success;
}

/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2C::I2CSWWrite( BYTE value )
//  Purpose: Write a byte to the slave
//  Input:   BYTE value - byte to be written to slave
//  Output:  None
//  Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2C::I2CSWWrite( BYTE value )
{
   // check if correct mode is selected
   if ( mode != I2CMode_SW )
   {
      errNum = I2CERR_MODE;
      return Fail;
   }

   // generate bit patterns by setting SCL and SDA lines
   for ( BYTE mask = 0x80; mask > 0; mask = (BYTE)(mask >> 1) )
   {                                          
      if ( I2CSWSetSCL( LevelLow ) != Success ) { errNum = I2CERR_SCL; return Fail; }

      // Send one data bit.
      if ( value & mask ) // Put data bit on pin.
      {
         if ( I2CSWSetSDA( LevelHi ) != Success ) { errNum = I2CERR_SDA; return Fail; }
      }
      else 
      {
         if ( I2CSWSetSDA( LevelLow ) != Success ) { errNum = I2CERR_SDA; return Fail; }
      }
          
      if ( I2CSWSetSCL( LevelHi ) != Success ) { errNum = I2CERR_SCL; return Fail; }
   }

   return I2CSWWaitForACK();
}

/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2C::I2CSWSendACK( void )
//  Purpose: Send ACK to slave
//  Input:   None
//  Output:  None
//  Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2C::I2CSWSendACK( void )
{
   // check if correct mode is selected
   if ( mode != I2CMode_SW )
   {
      errNum = I2CERR_MODE;
      return Fail;
   }
   
   // Generate ACK signal
   // i.e. SDA = 0 with SCL = 1

   if ( I2CSWSetSCL( LevelLow ) != Success ) { errNum = I2CERR_SCL; return Fail; }
   if ( I2CSWSetSDA( LevelLow ) != Success ) { errNum = I2CERR_SDA; return Fail; }
   if ( I2CSWSetSCL( LevelHi )  != Success ) { errNum = I2CERR_SCL; return Fail; }
   if ( I2CSWSetSCL( LevelLow ) != Success ) { errNum = I2CERR_SCL; return Fail; }
   if ( I2CSWSetSDA( LevelHi )  != Success ) { errNum = I2CERR_SDA; return Fail; }
   return Success;
}                  

/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2C::I2CSWSendNACK( void )
//  Purpose: Send NACK to slave
//  Input:   None
//  Output:  None
//  Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2C::I2CSWSendNACK( void )
{
   // check if correct mode is selected
   if ( mode != I2CMode_SW )
   {
      errNum = I2CERR_MODE;
      return Fail;
   }
   
   // Generate NACK signal
   // i.e. SDA = 1 with SCL = 1

   if ( I2CSWSetSCL( LevelLow ) != Success ) { errNum = I2CERR_SCL; return Fail; }
   if ( I2CSWSetSDA( LevelHi )  != Success ) { errNum = I2CERR_SDA; return Fail; }
   if ( I2CSWSetSCL( LevelHi )  != Success ) { errNum = I2CERR_SCL; return Fail; }
   if ( I2CSWSetSCL( LevelLow ) != Success ) { errNum = I2CERR_SCL; return Fail; }
   if ( I2CSWSetSDA( LevelLow ) != Success ) { errNum = I2CERR_SDA; return Fail; }
   return Success;
}                  

/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2C::I2CSWSetSCL( Level scl )
//  Purpose: Set software SCL value
//  Input:   Level scl - Hi releases the SCL output; Low forces the SCL output low
//  Output:  None
//  Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2C::I2CSWSetSCL( Level scl )
{
   // check if correct mode is selected
   if ( mode != I2CMode_SW )
   {
      errNum = I2CERR_MODE;
      return Fail;
   }
   
	sh.i2cShadow.scl = scl;
   decRegI2C = *(DWORD *)&(sh.i2cShadow);

   // loop until SCL really changes or timeout
   DWORD maxWait = 500; // 500 mSec
   DWORD startTime = GetTickCount();
  
   while (1)
   {
      // has SCL changed yet?
      if ( I2CSWReadSCL() == scl )
         break;

      // timeout?
      if ( GetTickCount() - startTime > (DWORD)maxWait )
      {
         errNum = I2CERR_TIMEOUT;
         return Fail;
      }
   }

   I2CSWBitDelay();
   return Success;
}

/////////////////////////////////////////////////////////////////////////////
//  Method:  int I2C::I2CSWReadSCL( void )
//  Purpose: Read software SCL value
//  Input:   None
//  Output:  None
//  Return:  SCL value
/////////////////////////////////////////////////////////////////////////////
int I2C::I2CSWReadSCL( void )
{
	return decFieldSCL;
}

/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2C::I2CSWSetSDA( Level sda )
//  Purpose: Set software SDA value
//  Input:   Level sda - Hi releases the SDA output; Low forces the SDA output low
//  Output:  None
//  Return:  Success or Fail
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2C::I2CSWSetSDA( Level sda )
{
   // check if correct mode is selected
   if ( mode != I2CMode_SW )
   {
      errNum = I2CERR_MODE;
      return Fail;
   }
   
	sh.i2cShadow.sda = sda;
   decRegI2C = *(DWORD *)&(sh.i2cShadow);

   I2CSWBitDelay();
   return Success;
}

/////////////////////////////////////////////////////////////////////////////
//  Method:  int I2C::I2CSWReadSDA( void )
//  Purpose: Read software SDA value
//  Input:   None
//  Output:  None
//  Return:  SDA value
/////////////////////////////////////////////////////////////////////////////
int I2C::I2CSWReadSDA( void )
{
	return decFieldSDA;
}


/////////////////////////////////////////////////////////////////////////////
//  Method:  void I2C::I2CSWBitDelay( void )
//  Purpose: Insures minimum high and low clock times on I2C bus.
//  Input:   None
//  Output:  None
//  Return:  None
//  Note:    This routine must be tuned for the desired frequency.
/////////////////////////////////////////////////////////////////////////////
void I2C::I2CSWBitDelay( void )
{
  //  unsigned int n;
  volatile DWORD i ;
  for ( i = cycle; i > 0; i-- )
    ;
}

/////////////////////////////////////////////////////////////////////////////
//  Method:  ErrorCode I2C::I2CSWWaitForACK( void )
//  Purpose: Determine if ACK is receieved in software mode
//  Input:   None
//  Output:  None
//  Return:  Success if ACK received; Fail if timeout
/////////////////////////////////////////////////////////////////////////////
ErrorCode I2C::I2CSWWaitForACK( void )
{
   if ( I2CSWSetSCL( LevelLow ) != Success ) { errNum = I2CERR_SCL; return Fail; }
   if ( I2CSWSetSDA( LevelHi )  != Success ) { errNum = I2CERR_SDA; return Fail; }

   // loop until either ACK or timeout
   DWORD maxWait = 500; // 500 mSec
   DWORD startTime = GetTickCount();

   while (1)
   {
      // SDA pin == 0 means the slave ACK'd
      if ( I2CSWReadSDA() == 0 )
      {
         if ( I2CSWSetSCL( LevelHi )  != Success ) { errNum = I2CERR_SCL; return Fail; }
         if ( I2CSWSetSCL( LevelLow ) != Success ) { errNum = I2CERR_SCL; return Fail; }
         return Success;
      }

      // timeout?
      if ( GetTickCount() - startTime > (DWORD)maxWait )
      {
         if ( I2CSWStop() != Success ) return Fail;
         errNum = I2CERR_TIMEOUT;
         return Fail;
      }
   } // while
}


//
// GetSystemTime in 100 nS units
//

ULONGLONG GetSystemTime()
{
    ULONGLONG ticks;
    ULONGLONG rate;

    ticks = (ULONGLONG)KeQueryPerformanceCounter((PLARGE_INTEGER)&rate).QuadPart;

    //
    // convert from ticks to 100ns clock
    //

    ticks = (ticks & 0xFFFFFFFF00000000) / rate * 10000000 +
            (ticks & 0xFFFFFFFF) * 10000000 / rate;

    return(ticks);

}

extern "C" ULONG GetTickCount( void )
{
	return (ULONG)( GetSystemTime() / 10000 );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\i2cerr.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/I2cerr.h 1.2 1998/04/29 22:43:34 tomz Exp $

#ifndef __I2CERR_H
#define __I2CERR_H

const int I2CERR_OK        = 0;     // no error
const int I2CERR_INIT      = 1;     // error in initialization
const int I2CERR_MODE      = 2;     // invalid I2C mode (must be either HW or SW)
const int I2CERR_NOACK     = 3;     // no ACK received from slave
const int I2CERR_TIMEOUT   = 4;     // timeout error
const int I2CERR_SCL       = 5;     // unable to change SCL line
const int I2CERR_SDA       = 6;     // unable to change SDA line

#endif   // __I2CERR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\gpio.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Gpio.h 1.2 1998/04/29 22:43:33 tomz Exp $


#ifndef __GPIO_H
#define __GPIO_H

#include "regField.h"
#include "viddefs.h"
#include "gpiotype.h"
#include "retcode.h"


//===========================================================================
// Constants
//===========================================================================
const int MAX_GPDATA_SIZE = 64;   // maximum number of DWORDs in GPDATA
const int MAX_GPIO_BIT    = 23;   // maximum bit number for GPIO registers


/////////////////////////////////////////////////////////////////////////////
// CLASS GPIO
//
// Description:
//    This class encapsulates the register fields in the GPIO register of the
//    Bt848. A complete set of functions are developed to manipulate all the
//    register fields in the GPIO for the Bt848.
//
/////////////////////////////////////////////////////////////////////////////

class GPIO
{
private:
   bool initOK;

public:
   //  Constructor
   GPIO( void );
   ~GPIO();

   // Member functions
   bool      IsInitOK( void );
   void      SetGPCLKMODE( State );
   int       GetGPCLKMODE( void );
   void      SetGPIOMODE( GPIOMode );
   int       GetGPIOMODE( void );
   void      SetGPWEC( State );
   int       GetGPWEC( void );
   void      SetGPINTI( State );
   int       GetGPINTI( void );
   void      SetGPINTC( State );
   int       GetGPINTC( void );
   ErrorCode SetGPOE( int, State );
   void      SetGPOE( DWORD );
   int       GetGPOE( int );
   DWORD     GetGPOE( void );
   ErrorCode SetGPIE( int, State );
   void      SetGPIE( DWORD );
   int       GetGPIE( int );
   DWORD     GetGPIE( void );
   ErrorCode SetGPDATA( GPIOReg *, int, int offset = 0 );
   ErrorCode GetGPDATA( GPIOReg *, int, int offset = 0 );
   ErrorCode SetGPDATA( int, int, DWORD, int offset = 0 );
   ErrorCode GetGPDATA( int, int, DWORD *, int offset = 0 );

protected:
   RegisterW decRegGPIO;
   RegField decFieldGPCLKMODE;
   RegField decFieldGPIOMODE;
   RegField decFieldGPWEC;
   RegField decFieldGPINTI;
   RegField decFieldGPINTC;
   RegisterDW decRegGPOE;
   RegisterDW decRegGPIE;
   RegisterDW decRegGPDATA;
 
};

#endif  // __GPIO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\ourcrt.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Ourcrt.cpp 1.2 1998/04/29 22:43:34 tomz Exp $

//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifdef __cplusplus
extern "C" {

#include "strmini.h"
#include "ksmedia.h"
}
#endif

extern "C" const int _fltused = 0;

/*
 * This function serves to avoid linking CRT code
 */

int __cdecl  _purecall(void)
{
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\pisces.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Pisces.cpp 1.15 1998/05/04 23:48:53 tomz Exp $

#include "pisces.h"
#include <stdlib.h>

/*
*/
BtPisces::BtPisces( DWORD *xtals ) : Engine_(), Inited_( false ),
   Even_( CAPTURE_EVEN, VF_Even,&COLOR_EVEN, &WSWAP_EVEN, &BSWAP_EVEN ),
   Odd_( CAPTURE_ODD, VF_Odd, &COLOR_ODD, &WSWAP_ODD, &BSWAP_ODD ),
   VBIE_( CAPTURE_VBI_EVEN ), VBIO_( CAPTURE_VBI_ODD ), Update_( false ),
   nSkipped_( 0 ), Paused_( false ), 

   Starter_(       ),
   SyncEvenEnd1_(  ),
   SyncEvenEnd2_(  ),
   SyncOddEnd1_(   ),
   SyncOddEnd2_(   ),
   PsDecoder_( xtals ),
   dwPlanarAdjust_( 0 ),
   CONSTRUCT_COLORCONTROL,
   CONSTRUCT_INTERRUPTSTATUS,
   CONSTRUCT_INTERRUPTMASK,
   CONSTRUCT_CONTROL,
   CONSTRUCT_CAPTURECONTROL,
   CONSTRUCT_COLORFORMAT,
   CONSTRUCT_GPIOOUTPUTENABLECONTROL,
   CONSTRUCT_GPIODATAIO
{
   Trace t("BtPisces::BtPisces()");
   Init();
}

BtPisces::~BtPisces()
{
   Trace t("BtPisces::~BtPisces()");

   Engine_.Stop();
   InterruptMask = 0;
   InterruptStatus = AllFs;

   // prevent risc program destructor from gpf-ing
   SyncEvenEnd1_.SetParent( NULL );
   SyncEvenEnd2_.SetParent( NULL );
   SyncOddEnd1_.SetParent( NULL );
   SyncOddEnd2_.SetParent( NULL );

   // free the association array now
   int ArrSize = sizeof( InterruptToIdx_ ) / sizeof( InterruptToIdx_ [0] );
   while ( --ArrSize >= 0 )
      delete InterruptToIdx_ [ArrSize];
   // now is the Skippers_' turn
   ArrSize = sizeof( Skippers_ ) / sizeof( Skippers_ [0] );
   while ( --ArrSize >= 0 )
      delete Skippers_ [ArrSize];

}


/* Method: BtPisces::GetIdxFromStream
 * Purpose: Returns starting index in the program array for a field
 * Input: aStream: StreamInfo & - reference
 * Output: int : Index
 */
int BtPisces::GetIdxFromStream( Field &aStream )
{
   Trace t("BtPisces::GetIdxFromStream()");

   switch ( aStream.GetStreamID() ) {
   case VS_Field1:
      return OddStartLocation;
   case VS_Field2:
      return EvenStartLocation;
   case VS_VBI1:
      return VBIOStartLocation;
   case VS_VBI2:
      return VBIEStartLocation;
   default:
      return 0;
   }
}

/* Method: BtPisces::CreateSyncCodes
 * Purpose: Creates the risc programs with sync codes needed between data risc
 *   programs
 * Input: None
 * Output: ErrorCode
 */
bool BtPisces::CreateSyncCodes()
{
   Trace t("BtPisces::CreateSyncCodes()");

   bool bRet = SyncEvenEnd1_.Create( SC_VRE ) == Success &&
          SyncEvenEnd2_.Create( SC_VRE ) == Success &&

          SyncOddEnd1_.Create( SC_VRO )  == Success &&
          SyncOddEnd2_.Create( SC_VRO )  == Success &&

          Starter_.Create( SC_VRO ) == Success;

   DebugOut((1, "*** BtPisces::CreateSyncCodes SyncEvenEnd1_(%x)\n", &SyncEvenEnd1_));
   DebugOut((1, "*** BtPisces::CreateSyncCodes SyncEvenEnd2_(%x)\n", &SyncEvenEnd2_));
   DebugOut((1, "*** BtPisces::CreateSyncCodes SyncOddEnd1_(%x)\n", &SyncOddEnd1_));
   DebugOut((1, "*** BtPisces::CreateSyncCodes SyncOddEnd2_(%x)\n", &SyncOddEnd2_));
   DebugOut((1, "*** BtPisces::CreateSyncCodes Starter_(%x)\n", &Starter_));

   return( bRet );
}

/* Method: BtPisces::Init
 * Purpose: Performs all necessary initialization
 * Input: None
 * Output: None
 */
void BtPisces::Init()
{
   Trace t("BtPisces::Init()");

   InterruptStatus = AllFs;
   InterruptStatus = 0;
   GAMMA = 1;

   // initialize the arrays
   CreatedProgs_.Clear() ;
   ActiveProgs_.Clear()  ;

   // fill in the skippers array and make each program a 'skipper'
   DataBuf buf;

   // [!!!] [TMZ] 
   // Engine_.CreateProgram constants look questionable

   for ( int i = 0; i < sizeof( Skippers_ ) / sizeof( Skippers_ [0] ); i++ ) {
      if ( i & 1 ) {
         MSize s( 10, 10 );
         Skippers_ [i] = Engine_.CreateProgram( s, 10 * 2, CF_VBI, buf, true, 0, false );
         DebugOut((1, "Creating Skipper[%d] == %x\n", i, Skippers_[i]));
         Engine_.Skip( Skippers_ [i] );
      } else {
         MSize s( 768, 12 );
         // now create skippers for the VBI streams
         Skippers_ [i] = Engine_.CreateProgram( s, 768 * 2, CF_VBI, buf, true, 0, false );
         DebugOut((1, "Creating Skipper[%d] == %x\n", i, Skippers_[i]));
      }
      if ( !Skippers_ [i] )
         return;
   }
   // create associations between Created and Skippers
   int link = 0;
   for ( i = 0; i < sizeof( SkipperIdxArr_ ) / sizeof( SkipperIdxArr_ [0] ); i++ ) {
      SkipperIdxArr_ [i] = link;
      i += link & 1; // advance past the sync program entry
      link++;
   }
   // fill in constant elements; see the table in the .h file
   CreatedProgs_ [2] = &SyncOddEnd1_;
   CreatedProgs_ [8] = &SyncOddEnd2_;

   CreatedProgs_ [5]  = &SyncEvenEnd1_;
   CreatedProgs_ [11] = &SyncEvenEnd2_;

   // set corresponding sync bits
   if ( !CreateSyncCodes() )
      return;

   // initialize association array now
   int ArrSize = sizeof( InterruptToIdx_ ) / sizeof( InterruptToIdx_ [0] );
   while ( --ArrSize >= 0 ) {
      if ( ( InterruptToIdx_ [ArrSize] = new IntrIdxAss() ) == 0 )
         return;
   }
   Even_.SetFrameRate(  333667 );
   Odd_. SetFrameRate(  333667 );
   VBIE_.SetFrameRate(  333667 );
   VBIO_.SetFrameRate(  333667 );

   Odd_. SetStreamID( VS_Field1 );
   Even_.SetStreamID( VS_Field2 );
   VBIO_.SetStreamID( VS_VBI1   );
   VBIE_.SetStreamID( VS_VBI2   );

   // finally, can wipe out the prespiration from the forehead
   Inited_ = true;
}

/* Method: BtPisces::AssignIntNumbers
 * Purpose: Assigns numbers to RISC programs that generate interrupt
 * Input: None
 * Output: None
 */
void BtPisces::AssignIntNumbers()
{
   Trace t("BtPisces::AssignIntNumbers()");

   int IntrCnt = 0;
   int limit = ActiveProgs_.NumElements() ;
   int idx;

   // initialize InterruptToIdx_ array
   for ( idx = 0; idx < limit; idx++ ) {
      IntrIdxAss item( idx, -1 );
      *InterruptToIdx_ [idx] = item;
   }

   // assign numbers in front of starting program
   bool first = true;
   for ( idx = 0; idx < (int) ActiveProgs_.NumElements() ; idx++ ) {

      RiscPrgHandle pProg = ActiveProgs_ [idx];

      //if not skipped and generates an interrupt assign number
      if ( pProg && pProg->IsInterrupting() ) {
         if ( first == true ) {
            first = false;
            pProg->ResetStatus();
            Skippers_ [SkipperIdxArr_ [idx] ]->ResetStatus();
         } else {
            pProg->SetToCount();
            Skippers_ [SkipperIdxArr_ [idx] ]->SetToCount();
         }
         IntrIdxAss item( IntrCnt, idx );
         *InterruptToIdx_ [IntrCnt] = item;
         IntrCnt++;
      }
   }
}

/* Method: BtPisces::LinkThePrograms
 * Purpose: Creates links between the created programs
 * Input: None
 * Output: None
 */
void BtPisces::LinkThePrograms()
{
   Trace t("BtPisces::LinkThePrograms()");
   DebugOut((1, "*** Linking Programs\n"));
   RiscPrgHandle hParent    = ActiveProgs_.First(),
                 hChild     = NULL,
                 hVeryFirst = NULL,
                 hLastChild = NULL ;

   if (hParent) {

      if ( hParent->IsSkipped() ) {
         int idx = ActiveProgs_.GetIndex(hParent) ;
         hParent = Skippers_ [SkipperIdxArr_ [idx] ] ;
      }

      while (hParent) {

         if (!hVeryFirst)
            hVeryFirst = hParent ;

         if ( hChild = ActiveProgs_.Next()) {
            if ( hChild->IsSkipped() ) {
               int idx = ActiveProgs_.GetIndex(hChild) ;
               hChild = Skippers_ [SkipperIdxArr_ [idx] ] ;
            }

            hLastChild = hChild;
            Engine_.Chain( hParent, hChild ) ;
         }
         hParent = hChild ;
      }

      // initial jump
      Engine_.Chain( &Starter_, hVeryFirst ) ;

      // now create the loop
      Engine_.Chain( hLastChild ? hLastChild : hVeryFirst, hVeryFirst ) ;
   }
}

/* Method: BtPisces::ProcessSyncPrograms()
 * Purpose: This function unlinks the helper sync programs
 * Input: None
 * Output: None
 */
void BtPisces::ProcessSyncPrograms()
{
   Trace t("BtPisces::ProcessSyncPrograms()");

   for ( int i = 0; i < (int) ActiveProgs_.NumElements(); i += ProgsWithinField ) {
      if ( !ActiveProgs_ [i] && !ActiveProgs_ [i+1] )  {
         ActiveProgs_ [i+2] = NULL;
      } else {
         ActiveProgs_ [i+2] = CreatedProgs_ [i+2];
      }
   }
}

/* Method: BtPisces::ProcessPresentPrograms
 * Purpose:
 * Input: None
 * Output: None
 */
void BtPisces::ProcessPresentPrograms()
{
   Trace t("BtPisces::ProcessPresentPrograms()");

   // link in/out helper sync programs
   ProcessSyncPrograms();
   // and now is time to cross link the programs
   LinkThePrograms();
   // and now figure out the numbers programs use for interrupts
   AssignIntNumbers();
}

/* Method: BtPisces::AddProgram
 * Purpose: Creates new RISC program and inserts it in the chain at a proper place
 * Input: aStream: StreamInfo & - reference to the stream to add a program for
 *   NumberToAdd: int - number of programs to add
 * Output:
 * Note:   Basically this internal function performs a loop 2 times
 *   //4. Tries to get another buffer to establish double buffering
 *   //5. If buffer is available it creates another RISC program with it
 *   //6. Then it has to link the program in...
 */
RiscPrgHandle BtPisces::AddProgram( Field &ToStart, int NumberToAdd )
{
   Trace t("BtPisces::AddProgram()");
   DebugOut((1, "BtPisces::AddProgram()\n"));

   int StartIdx = GetIdxFromStream( ToStart );
   SyncCode Sync;
   int SyncIdx;
   bool rsync;
   if ( StartIdx <= OddStartLocation ) {
      Sync = SC_VRO;
      SyncIdx = OddSyncStartLoc;
      rsync = false;
   } else {
      Sync = SC_VRE;
      SyncIdx = EvenSyncStartLoc;
      rsync = bool( StartIdx == EvenStartLocation );
   }
    // have to know what is the size of the image to produce
   MRect r;
   ToStart.GetDigitalWindow( r );
   // RISC engine operates on absolute sizes, not rectangles
   MSize s = r.Size();

   int BufCnt = 0;

   int Idx = StartIdx;
   for ( ; BufCnt < NumberToAdd; BufCnt++ ) {

      // init sync programs with a premise tha no data program exists
      CreatedProgs_ [SyncIdx]->Create( Sync, true );

      // obtain the next buffer from queue ( entry is removed from container )
      DataBuf buf = ToStart.GetNextBuffer();

      // can create a RISC program now.
      RiscPrgHandle hProgram = Engine_.CreateProgram( s, ToStart.GetBufPitch(),
         ToStart.GetColorFormat(), buf, ToStart.Interrupt_, dwPlanarAdjust_, rsync );

      // store this program
      CreatedProgs_ [Idx] = hProgram;
      DebugOut((1, "Creating RiscProgram[%d] == %x\n", Idx, CreatedProgs_ [Idx]));

      if ( !hProgram ) {
         Idx -= DistBetweenProgs;
         if ( Idx >= 0 ) {
            // clean up previous program
            Engine_.DestroyProgram( CreatedProgs_ [Idx] );
            CreatedProgs_ [Idx] = NULL;
         }
         return NULL;
      }
      // make sure we unskip the program when buffer becomes available
      if ( !buf.pData_ ) {
         hProgram->SetSkipped();  // do not have enough buffers to support double buffering
         nSkipped_++;
      }

      // assign stream to program; makes it easy during interrupt
      hProgram->SetTag( &ToStart );
      SyncIdx += DistBetweenProgs;
      Idx     += DistBetweenProgs; // skip the location intended for the other program

   } /* endfor */
   return CreatedProgs_ [StartIdx];
}

/* Method: BtPisces::Create
 * Purpose: This functions starts the stream.
 * Input: aStream: StreamInfo & - reference to a stream to start
 * Output: Address of the Starter_
 * Note: After the Start 2 entries in the CreatedProgs_ are created. Starting
 *   location is 4 for even and 1 for odd. Increment is 6. So if it is the first
 *   invocation and there is enough ( 2 ) buffers present entries [1] and [7]
 *   or [4] and [10] will be filled with newly created RISC programs. When programs
 *   exist for one field only they are doubly linked. When programs exist for
 *   both fields they alternate, i.e. 0->2->1->3->0... When one of the fields
 *   has 1 program only, programs are linked like this: 0->2->1->0->2...(numbers
 *   are indexes in the CreatedProgs_ array ). Alternating programs makes for
 *   maximum frame rate.
 */
ErrorCode BtPisces::Create( Field &ToCreate )
{
   Trace t("BtPisces::Create()");

   // running full-steam, nothing to create
   if ( ToCreate.IsStarted() == true )
      return Success;

   int StartIdx = GetIdxFromStream( ToCreate );
   if ( CreatedProgs_ [StartIdx] )
      return Success; // not running yet, but exists

   // call into internal function that adds new RISC program
   if ( ! AddProgram( ToCreate, MaxProgsForField ) )
      return Fail;
   return Success;
}

/* Method: BtPisces::Start
 * Purpose: Starts given stream ( by putting in in the Active_ array
 * Input: ToStart: Field &
 */
void BtPisces::Start( Field & ToStart )
{
   Trace t("BtPisces::Start()");
   // DebugOut((1, "BtPisces::Start\n"));

   if ( ToStart.IsStarted() == true )
      return;

   // all we need to do at this point is to create a proper starter
   // and link the programs in.
   int idx = GetIdxFromStream( ToStart );
   // this loop will enable LinkThePrograms to see programs for this stream
   for ( int i = 0; i < MaxProgsForField; i++, idx += DistBetweenProgs ) {
      ActiveProgs_ [idx] = CreatedProgs_ [idx];
   }
   // all I want to do at this point is call Restart.
   // do not signal the buffers
   Update_ = false;

   Restart();

   Update_ = true;
}

/* Method: BtPisces::Stop
 * Purpose: This function stops a stream. Called when PAUSE SRB is received
 * Input: aStream: StreamInfo & - reference to a stream to start
 * Output: None
 */
void BtPisces::Stop( Field &ToStop )
{
   Trace t("BtPisces::Stop()");
   // DebugOut((1, "BtPisces::Stop\n"));

   Engine_.Stop();   // no more interrupts

   int StartIdx = GetIdxFromStream( ToStop );

   // prevent unneeded syncronization interrupts
   IMASK_SCERW = 0;
      
   // it is time to pause the stream now
   ToStop.Stop();
   bool Need2Restart = false;
   // go through the array of programs and killing ones for this field (stream)
   for ( int i = 0; i < MaxProgsForField; i++, StartIdx += DistBetweenProgs ) {

      RiscPrgHandle ToDie = CreatedProgs_ [StartIdx];
      if ( !ToDie ) // this should never happen
         continue;
      if ( ToDie->IsSkipped() )
         nSkipped_--;

      DebugOut((1, "about to destroy idx = %d\n", StartIdx ) );
      Engine_.DestroyProgram( ToDie );
      CreatedProgs_ [StartIdx] = NULL;
      ActiveProgs_  [StartIdx] = NULL; // in case Pause wasn't called

      Need2Restart = true;
   } /* endfor */

   // nobody's around anymore
   if ( !CreatedProgs_.CountDMAProgs() ) {
      Engine_.Stop();
      InterruptMask = 0;
      InterruptStatus = AllFs;
      nSkipped_ = 0;
   } else {
      if ( Need2Restart ) {
         Restart();   // relink the programs and start ones that are alive
         IMASK_SCERW = 1; // re-enable the sync error interrupts
      }
   }
}

/* Method: BtPisces::Pause
 * Purpose: This function stops a stream. Called when PAUSE SRB is received
 * Input: aStream: Field & - reference to a stream to start
 * Output: None
 */
void BtPisces::Pause( Field &ToPause )
{
   Trace t("BtPisces::Pause()");
   // DebugOut((1, "BtPisces::Pause\n"));

   Engine_.Stop();   // no more interrupts

   if ( !ToPause.IsStarted() )
      return;

   int StartIdx = GetIdxFromStream( ToPause );

   // prevent unneeded syncronization interrupts
   IMASK_SCERW = 0;

   // it is time to pause the stream now
//   ToPause.Stop(); - done in Restart

   // go through the array of programs and killing ones for this field (stream)
   for ( int i = 0; i < MaxProgsForField; i++, StartIdx += DistBetweenProgs ) {
      ActiveProgs_ [StartIdx] = NULL;
   } /* endfor */

   Restart();   // relink the programs and start ones that are alive
}

/* Method: BtPisces::PairedPause
 * Purpose: This is a hacky function that pauses 2 streams at once
 * Input: idx: index of the second program in the second field
 * Output: None
 */
void BtPisces::PairedPause( int idx )
{
   Trace t("BtPisces::PairedPause()");
   // DebugOut((1, "BtPisces::PairedPause\n"));

   Engine_.Stop();   // no more interrupts

   // go through the array of programs and killing ones for this field (stream)
   for ( int i = 0; i < MaxProgsForField; i++, idx -= DistBetweenProgs ) {
      ActiveProgs_ [idx] = NULL;
      ActiveProgs_ [idx-ProgsWithinField] = NULL;
   } /* endfor */

   Restart();   // relink the programs and start ones that are alive
}

/* Method: BtPisces::GetStarted
 * Purpose: Figures out the channels that are started
 * Input:
 * Output: None
 */
void BtPisces::GetStarted( bool &EvenWasStarted, bool &OddWasStarted,
   bool &VBIEWasStarted, bool &VBIOWasStarted )
{
   Trace t("BtPisces::GetStarted()");

   VBIEWasStarted = ( ActiveProgs_ [VBIEStartLocation]  ? TRUE : FALSE);
   EvenWasStarted = ( ActiveProgs_ [EvenStartLocation] ? TRUE : FALSE);
   VBIOWasStarted = ( ActiveProgs_ [VBIOStartLocation] ? TRUE : FALSE);
   OddWasStarted  = ( ActiveProgs_ [OddStartLocation] ? TRUE : FALSE);
}

/* Method: BtPisces::RestartStreams
 * Purpose: Restarts streams that were started
 * Input:
 * Output: None
 */
void BtPisces::RestartStreams( bool EvenWasStarted, bool OddWasStarted,
   bool VBIEWasStarted, bool VBIOWasStarted )
{
   Trace t("BtPisces::RestartStream()");

   // vbi programs are first to execute, so enable them first
   if ( VBIOWasStarted )
      VBIO_.Start();
   if ( OddWasStarted )
      Odd_.Start();
   if ( VBIEWasStarted )
      VBIE_.Start();
   if ( EvenWasStarted )
      Even_.Start();
}

/* Method: BtPisces::CreateStarter
 * Purpose: Creates proper sync code for the bootstrap program
 * Input: EvenWasStarted: bool
 * Output: None
 */
void BtPisces::CreateStarter( bool EvenWasStarted )
{
   Trace t("BtPisces::CreateStarter()");
   Starter_.Create( EvenWasStarted ? SC_VRE : SC_VRO, true );
   DebugOut((1, "*** BtPisces::CreateStarter(%x) buf(%x)\n", &Starter_ , Starter_.GetPhysProgAddr( )));
}

/* Method: BtPisces::Restart
 * Purpose: Restarts the capture process. Called by ISR and Stop()
 * Input: None
 * Output: None
 */
void BtPisces::Restart()
{
   Trace t("BtPisces::Restart()");

   bool EvenWasStarted, OddWasStarted, VBIEWasStarted, VBIOWasStarted;
   GetStarted( EvenWasStarted, OddWasStarted, VBIEWasStarted, VBIOWasStarted );

   DebugOut((2, "BtPisces::Restart - Even WasStarted (%d)\n", EvenWasStarted));
   DebugOut((2, "BtPisces::Restart - Odd  WasStarted (%d)\n", OddWasStarted));
   DebugOut((2, "BtPisces::Restart - VBIE WasStarted (%d)\n", VBIEWasStarted));
   DebugOut((2, "BtPisces::Restart - VBIO WasStarted (%d)\n", VBIOWasStarted));

   Engine_.Stop();   // No more interrupts!

   Odd_.Stop();
   Even_.Stop();
   VBIE_.Stop();
   VBIO_.Stop();

   Engine_.Stop();   // No more interrupts!

#if 1
   if ( OddWasStarted )
   {
      Odd_.CancelSrbList();
   }
   if ( EvenWasStarted )
   {
      Even_.CancelSrbList();
   }
   if ( VBIEWasStarted )
   {
      VBIE_.CancelSrbList();
   }
   if ( VBIOWasStarted )
   {
      VBIO_.CancelSrbList();
   }
#endif

   // this will never happen, probably
   if ( !EvenWasStarted && !OddWasStarted && !VBIEWasStarted && !VBIOWasStarted )
      return;

   InterruptStatus = AllFs; // clear all the status bits

   CreateStarter( bool( EvenWasStarted || VBIEWasStarted ) );

   ProcessPresentPrograms();
   
   // DumpRiscPrograms();
   Engine_.Start( Starter_ );

   RestartStreams( EvenWasStarted, OddWasStarted, VBIEWasStarted, VBIOWasStarted );

   OldIdx_ = -1;

   InterruptMask = RISC_I | FBUS_I | OCERR_I | SCERR_I | 
                   RIPERR_I | PABORT_I | EN_TRITON1_BUG_FIX;
}

/* Method: BtPisces::Skip
 * Purpose: Forces a given program to be skipped by the RISC engine
 * Input: ToSkip: RiscPrgHandle - program to be skipped
 * Output: None
 * Note: If the number of skipped programs equals total number of programs, the
 *   RISC engine is stopped
*/
void BtPisces::Skip( int idx )
{
   Trace t("BtPisces::Skip()");

   // get the program and skip it
   RiscPrgHandle ToSkip = ActiveProgs_ [idx];
   if ( ToSkip->IsSkipped() )
      return;

   ToSkip->SetSkipped();
   nSkipped_++;

   //skip by linking the Skipper_ in instead of the skippee
   RiscPrgHandle SkipeeParent = ToSkip->GetParent();
   RiscPrgHandle SkipeeChild = ToSkip->GetChild();
   // get the skipper for this program
   RiscPrgHandle pSkipper = Skippers_ [SkipperIdxArr_ [idx] ];
   Engine_.Chain( pSkipper, SkipeeChild );
   Engine_.Chain( SkipeeParent, pSkipper );

   DebugOut((1, "BtPisces::Skipped %d Skipper %d\n", idx, SkipperIdxArr_ [idx] ) );
}

inline bool IsFirst( int idx )
{
   Trace t("BtPisces::IsFirst()");
   return bool( idx == OddStartLocation || idx == VBIOStartLocation ||
      idx - DistBetweenProgs == OddStartLocation ||
      idx - DistBetweenProgs == VBIOStartLocation  );
}

inline bool IsLast( int idx )
{
   Trace t("BtPisces::IsLast()");
   return bool((idx == (VBIEStartLocation + DistBetweenProgs)) ||
               (idx == (EvenStartLocation + DistBetweenProgs)));
}

/* Method: BtPisces::GetPassed
 * Purpose: Calculates number of programs that have executed since last interrupt
 * Input: None
 * Output: int: number of passed
*/
int BtPisces::GetPassed()
{
   Trace t("BtPisces::GetPassed()");

   // figure out which RISC program caused an interrupt
   int ProgCnt = RISCS;
   int numActive = ActiveProgs_.CountDMAProgs() ;

   if ( ProgCnt >= numActive ) {
      DebugOut((1, "ProgCnt = %d, larger than created\n", ProgCnt ) );
   }

   // now see how many programs have interrupted since last time and process them all
   if ( ProgCnt == OldIdx_ ) {
      DebugOut((1, "ProgCnt is the same = %d\n", ProgCnt ) );
   }
   int passed;

   if ( ProgCnt < OldIdx_ ) {
      passed = numActive - OldIdx_ + ProgCnt; // you spin me like a record, baby - round, round...
   } else
      passed = ProgCnt - OldIdx_;

   // The following line of code was VERY bad !!!
   // This caused crashes when the system got busy and had interrupts backed up.

   // if ( ProgCnt == OldIdx_ )
   //    passed = numActive;

   OldIdx_ = ProgCnt;
   return passed;
}

/* Method: BtPisces::GetProgram
 * Purpose: Finds a RISC program based on its position
 * Input: None
 * Output: None
*/
inline RiscPrgHandle BtPisces::GetProgram( int pos, int &idx )
{
   Trace t("BtPisces::GetProgram()");

   int nActiveProgs = ActiveProgs_.CountDMAProgs( );
   
   if ( nActiveProgs == 0 )
   {
      idx = 0;
      return ( NULL );
   }

   IntrIdxAss *item;
   item = InterruptToIdx_ [ pos % nActiveProgs ];
   idx = item->Idx;

   DEBUG_ASSERT( idx != -1 );

   return (idx == -1) ? NULL : ActiveProgs_ [idx];
}

/* Method: BtPisces::ProcessRISCIntr
 * Purpose: Handles interrupts caused by the RISC programs
 * Input: None
 * Output: None
*/

void  BtPisces::ProcessRISCIntr()
{
   PHW_STREAM_REQUEST_BLOCK gpCurSrb = 0;
   Trace t("BtPisces::ProcessRISCIntr()");

// this line must be before GetPassed(), as OldIdx_ is changed by that function
   int pos = OldIdx_ + 1;

   // measure elapsed time
   int passed = GetPassed();

   DebugOut((1, "  passed = %d\n", passed ) );

   while ( passed-- > 0 ) {

      int idx;
      RiscPrgHandle Rspnsbl = GetProgram( pos, idx );
      pos++;

      // last chance to prevent a disaster...
      if ( !Rspnsbl || !Rspnsbl->IsInterrupting() ) {
         DebugOut((1, "  no resp or not intr\n" ) );
         continue;
      }
      // get conveniently saved stream from the program
      Field &Interrupter = *(Field *)Rspnsbl->GetTag();

   gpCurSrb = Rspnsbl->pSrb_;          // [TMZ] [!!!]
   DebugOut((1, "'idx(%d), pSrb(%x)\n", idx, gpCurSrb));

      bool paired = Interrupter.GetPaired();

      if ( Interrupter.IsStarted() != true ) {
         DebugOut((1, "  not started %d\n", idx ) );
         continue;
      }
      if ( IsFirst( idx ) && paired ) {
         DebugOut((1, "  continue pair %d\n", idx ) );
         continue;
      }

      LONGLONG *pL = (LONGLONG *)Rspnsbl->GetDataBuffer();

      if ( !pL )
      {
            DebugOut((1, "null buffer in interrupt, ignore this interrupt\n"));
            //continue;
      }
      else
      {
            DebugOut((1, "good buffer in interrupt\n"));
      }

      // now make sure all buffers are written to
      if ( !pL || Rspnsbl->IsSkipped() ) {
         // want to call notify, so ProcessBufferAtInterrupt is called
         DebugOut((1, "  skipped %d\n", idx ) );
         Interrupter.Notify( (PVOID)idx, true );
         Interrupter.SetReady( true );
      } else  {
         BOOL test1 = FALSE;
         BOOL test2 = FALSE;
         BOOL test3 = FALSE;

         if ( 1
              //*pL != 0xAAAAAAAA33333333 &&         (test1 = TRUE) &&
              //*(pL + 1) != 0xBBBBBBBB22222222 &&   (test2 = TRUE) &&
              //Interrupter.GetReady() &&            (test3 = TRUE)
            ) {
            // here buffer is available
            DebugOut((1, "  notify %d, addr - %x\n", idx,
               Rspnsbl->GetDataBuffer() ) );

            //#pragma message("*** be very carefull zeroing buffers!!!")
            //Rspnsbl->SetDataBuffer( 0 );  // [TMZ] try to fix buffer re-use bug

            Interrupter.Notify( (PVOID)idx, false );
            Interrupter.SetReady( true );
         } else {
            // add code for the paired streams here
            DebugOut((1, "  not time %d (%d, %d, %d)\n", idx , test1, test2, test3));
            // this if/else takes care of this cases:
            // 1. first buffer for a field is not written to
            // 2. second buffer for a field is written to ( this can happen when
            // both programs were updated at the same time, but the timing was
            // such that first did not start executing, but second was );
            // so this if/else prevents sending buffers back out of order
            if ( Interrupter.GetReady() ) // it is always true before it is ever false
               Interrupter.SetReady( false );
            else
            // make sure that things are correct when the loop is entered later
            // the field must be set to 'ready'
               Interrupter.SetReady( true );
         }
      }
      
   } /* endwhile */
}

/* Method: BtPiscess::ProcessBufferAtInterrupt
 * Purpose: Called by a video channel to perform risc program modifications
 *   if needed
 * Input: pTag: PVOID - pointer to some data ( risc program pointer )
 * Output: None
 */
void BtPisces::ProcessBufferAtInterrupt( PVOID pTag )
{
   Trace t("BtPisces::ProcessBufferAtInterrupt()");

   int idx = (int)pTag;

   RiscPrgHandle Rspnsbl = ActiveProgs_ [idx];
   if ( !Rspnsbl ) {
      DebugOut((1, "PBAI: no responsible\n"));
      return;  // can this really happen ??
   }
   // get conveniently saved field from the program
   Field &Interrupter = *(Field *)Rspnsbl->GetTag();

   // see if there is a buffer in the queue and get it
   DataBuf buf = Interrupter.GetNextBuffer();

   DebugOut((1, "Update %d %x\n", idx, buf.pData_ ) );

   // if buffer is not available skip the program

   if ( !buf.pData_ ) {
      DebugOut((1, "Buffer not available, skipping %d\n", idx ) );
      Skip( idx );
   } else {
      if ( Rspnsbl->IsSkipped() )
         nSkipped_--;
      Engine_.ChangeAddress( Rspnsbl, buf );
      LinkThePrograms();
   }
}

/* Method: BtPisces::Interrupt
 * Purpose: Called by ISR to initiate the processing of an interrupt
 * Input: None
 * Output: None
*/

State BtPisces::Interrupt()
{
   Trace t("BtPisces::Interrupt()");

   DebugOut((2, "BtPisces::Interrupt()\n"));

   extern BYTE *gpjBaseAddr;

   DWORD IntrStatus = *(DWORD*)(gpjBaseAddr+0x100);

   State DidWe = Off;

   if ( IntrStatus & RISC_I ) {
      DebugOut((2, "RISC_I\n"));
      ProcessRISCIntr();
      *(DWORD*)(gpjBaseAddr+0x100) = RISC_I;    // reset the status bit
      DidWe = On;
   }
   if ( IntrStatus & FBUS_I ) {
      DebugOut((2, "FBUS\n"));
      *(DWORD*)(gpjBaseAddr+0x100) = FBUS_I;    // reset the status bit
      DidWe = On;
   }
   if ( IntrStatus & FTRGT_I ) {
      DebugOut((2, "FTRGT\n"));
      *(DWORD*)(gpjBaseAddr+0x100) = FTRGT_I;   // reset the status bit
      DidWe = On; //[TMZ]
   }
   if ( IntrStatus & FDSR_I ) {
      DebugOut((2, "FDSR\n"));
      *(DWORD*)(gpjBaseAddr+0x100) = FDSR_I;    // reset the status bit
      DidWe = On; //[TMZ]
   }
   if ( IntrStatus & PPERR_I ) {
      DebugOut((2, "PPERR\n"));
      *(DWORD*)(gpjBaseAddr+0x100) = PPERR_I;   // reset the status bit
      DidWe = On; //[TMZ]
   }
   if ( IntrStatus & RIPERR_I ) {
      DebugOut((2, "RIPERR\n"));
      *(DWORD*)(gpjBaseAddr+0x100) = RIPERR_I;  // reset the status bit
      Restart();
      DidWe = On;
   }
   if ( IntrStatus & PABORT_I ) {
      DebugOut((2, "PABORT\n"));
      *(DWORD*)(gpjBaseAddr+0x100) = PABORT_I;  // reset the status bit
      DidWe = On;
   }
   if ( IntrStatus & OCERR_I ) {
      DebugOut((2, "OCERR\n"));
      DidWe = On;
      DebugOut((0, "Stopping RiscEngine due to OCERR\n"));  // [!!!] [TMZ] why not restart?
      Engine_.Stop();
      *(DWORD*)(gpjBaseAddr+0x100) = OCERR_I; // reset the status bit
   }
   if ( IntrStatus & SCERR_I ) {
      DebugOut((0, "SCERR\n"));
      DidWe = On;
      *(DWORD*)(gpjBaseAddr+0x100) = SCERR_I; // reset the status bit
      Restart();  // [TMZ] [!!!] this royally screws us over sometimes, figure it out.
      *(DWORD*)(gpjBaseAddr+0x100) = SCERR_I; // reset the status bit
   }
   return DidWe;
}

// resource allocation group 

/* Method: BtPisces::AllocateStream
 * Purpose: This function allocates a stream for use by a video channel
 * Input: StrInf: StreamInfo & - reference to the stream information structure
 * Output:
 */
ErrorCode BtPisces::AllocateStream( Field *&ToAllocate, VideoStream st )
{
   Trace t("BtPisces::AllocateStream()");

   switch ( st ) {
   case VS_Field1:
      ToAllocate = &Odd_;
      break;
   case VS_Field2:
      ToAllocate = &Even_;
      break;
   case VS_VBI1:
      ToAllocate = &VBIO_;
      break;
   case VS_VBI2:
      ToAllocate = &VBIE_;
      break;
   }
   return Success;
}

/* Method: BtPisces::SetBrightness
 * Purpose: Changes brightness of the captured image
 * Input:
 * Output:
 */
void BtPisces::SetBrightness( DWORD value )
{
   Trace t("BtPisces::SetBrightness()");
   PsDecoder_.SetBrightness( value );
}

/* Method: BtPisces::SetSaturation
 * Purpose:
 * Input:
 * Output:
 */
void BtPisces::SetSaturation( DWORD value )
{
   Trace t("BtPisces::SetSaturation()");
   PsDecoder_.SetSaturation( value );
}

/* Method: BtPisces::SetConnector
 * Purpose:
 * Input:
 * Output:
 */
void BtPisces::SetConnector( DWORD value )
{
   Trace t("BtPisces::SetConnector()");
   PsDecoder_.SetVideoInput( Connector( value ) );
}

/* Method: BtPisces::SetContrast
 * Purpose:
 * Input:
 * Output:
 */
void BtPisces::SetContrast( DWORD value )
{
   Trace t("BtPisces::SetContrast()");
   PsDecoder_.SetContrast( value );
}

/* Method: BtPisces::SetHue
 * Purpose:
 * Input:
 * Output:
 */
void BtPisces::SetHue( DWORD value )
{
   Trace t("BtPisces::SetHue()");
   PsDecoder_.SetHue( value );
}

/* Method: BtPisces::SetSVideo
 * Purpose:
 * Input:
 * Output:
 */
void BtPisces::SetSVideo( DWORD )
{
   Trace t("BtPisces::SetSVideo()");
}

/* Method: BtPisces::
 * Purpose:
 * Input:   value: DWORD
 * Output:
 */
void BtPisces::SetFormat( DWORD value )
{
   Trace t("BtPisces::SetFormat()");

   PsDecoder_.SetVideoFormat( VideoFormat( value ) );
   // let the scaler know format has changed
   Even_.VideoFormatChanged( VideoFormat( value ) );
   Odd_.VideoFormatChanged( VideoFormat( value ) );
}

/* Method: BtPisces::GetSaturation
 * Purpose:
 * Input:   pData: PLONG
 * Output:
 */
LONG BtPisces::GetSaturation()
{
   Trace t("BtPisces::GetSaturation()");
   return PsDecoder_.GetSaturation();
}

/* Method: BtPisces::GetHue
 * Purpose:
 * Input:   pData: PLONG
 * Output:
 */
LONG BtPisces::GetHue()
{
   Trace t("BtPisces::GetHue()");
   return PsDecoder_.GetHue();
}

/* Method: BtPisces::GetBrightness
 * Purpose:
 * Input:   pData: PLONG
 * Output:
 */
LONG BtPisces::GetBrightness()
{
   Trace t("BtPisces::GetBrightness()");
   return PsDecoder_.GetBrightness();
}

/* Method: BtPisces::GetSVideo
 * Purpose:
 * Input:   pData: PLONG
 * Output:
 */
LONG BtPisces::GetSVideo()
{
   Trace t("BtPisces::GetSVideo()");
   return 0;
}

/* Method: BtPisces::GetContrast
 * Purpose:
 * Input:   pData: PLONG
 * Output:
 */
LONG BtPisces::GetContrast()
{
   Trace t("BtPisces::GetContrast()");
   return PsDecoder_.GetContrast();
}

/* Method: BtPisces::GetFormat
 * Purpose:
 * Input:   pData: PLONG
 * Output:
 */
LONG BtPisces::GetFormat()
{
   Trace t("BtPisces::GetFormat()");
   return PsDecoder_.GetVideoFormat();
}

/* Method: BtPisces::GetConnector
 * Purpose:
 * Input: pData: PLONG
 * Output:
 */
LONG BtPisces::GetConnector()
{
   Trace t("BtPisces::GetConnector()");
   return PsDecoder_.GetVideoInput();
}

// scaler group
/* Method: BtPisces::SetAnalogWindow
 * Purpose:
 * Input:
 * Output:
 */
ErrorCode BtPisces::SetAnalogWindow( MRect &r, Field &aField )
{
   Trace t("BtPisces::SetAnalogWindow()");
   return aField.SetAnalogWindow( r );
}

/* Method: BtPisces::SetDigitalWindow
 * Purpose:
 * Input:
 * Output:
 */
ErrorCode BtPisces::SetDigitalWindow( MRect &r, Field &aField )
{
   Trace t("BtPisces::SetDigitalWindow()");
   return aField.SetDigitalWindow( r );
}

// color space converter group
/* Method: BtPisces::SetPixelFormat
 * Purpose:
 * Input:
 * Output:
 */
void BtPisces::SetPixelFormat( ColFmt aFormat, Field &aField )
{
   Trace t("BtPisces::SetPixelFormat()");
   aField.SetColorFormat( aFormat );
}

/* Method: BtPisces::GetPixelFormat
 * Purpose:
 * Input:
 * Output:
 */
ColFmt BtPisces::GetPixelFormat( Field &aField )
{
   Trace t("BtPisces::GetPixelFormat()");
   return aField.GetColorFormat();
}


void BtPisces::TurnVFilter( State s )
{
   Trace t("BtPisces::TurnVFilter()");
   Even_.TurnVFilter( s );
   Odd_.TurnVFilter( s );
}

/* Method:
 * Purpose: returns video standards supported by the board
 */
LONG BtPisces::GetSupportedStandards()
{
   Trace t("BtPisces::GetSupportedStandards()");
   return PsDecoder_.GetSupportedStandards();
}
                                                                                                                           
void  BtPisces::DumpRiscPrograms()
{
   LONG x;

   // Dump the links

   DebugOut((0, "------------------------------------------------\n"));
   for( x = 0; x < 12; x++ )
   {
      if ( CreatedProgs_[x] )
      {
         DebugOut((0, "Created #%02d addr(%x) paddr(%x) jaddr(%x)\n", x, CreatedProgs_[x], CreatedProgs_[x]->GetPhysProgAddr( ), *(CreatedProgs_[x]->pChainAddress_ + 1)));
      }
   }
   for( x = 0; x < 8; x++ )
   {
      if ( Skippers_[x] )
      {
         DebugOut((0, "Skipper #%02d addr(%x) paddr(%x) jaddr(%x)\n", x, Skippers_[x], Skippers_[x]->GetPhysProgAddr( ), *(Skippers_[x]->pChainAddress_ + 1)));
      }
   }
   DebugOut((0, "------------------------------------------------\n"));

   return ;

   /////////////////////////////////////////////////

   for( x = 0; x < 12; x++ ) {
      DebugOut((0, "Active Program #  %d(%x) buf(%x)\n", x, ActiveProgs_[x], ActiveProgs_[x]?ActiveProgs_[x]->GetPhysProgAddr( ):-1));
   }
   for( x = 0; x < 12; x++ ) {
      DebugOut((0, "Created Program # %d(%x) buf(%x)\n", x, CreatedProgs_[x], CreatedProgs_[x]?CreatedProgs_[x]->GetPhysProgAddr( ):-1));
   }
   for( x = 0; x < 8; x++ ) {                     
      DebugOut((0, "Skipper Program # %d(%x) buf(%x)\n", x, Skippers_[x], Skippers_[x]?Skippers_[x]->GetPhysProgAddr( ):-1));
   }

   DebugOut((2, "---------------------------------\n"));
   DebugOut((2, "Dumping ActiveProgs_\n"));
   DebugOut((2, "---------------------------------\n"));
   for( x = 0; x < 12; x++ ) {
      DebugOut((1, "Active Program #  %d\n", x));
      ActiveProgs_[x]->Dump();
   }
   DebugOut((2, "---------------------------------\n"));
   DebugOut((2, "Dumping CreatedProgs_\n"));
   DebugOut((2, "---------------------------------\n"));
   for( x = 0; x < 12; x++ ) {
      DebugOut((1, "Created Program # %d\n", x));
      CreatedProgs_[x]->Dump();
   }
   DebugOut((2, "---------------------------------\n"));
   DebugOut((2, "Dumping Skippers_\n"));
   DebugOut((2, "---------------------------------\n"));
   for( x = 0; x < 8; x++ ) {                     
      DebugOut((1, "Skipper Program # %d\n", x));
      Skippers_[x]->Dump();
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\mediums.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

//
// This file defines interconnections between components via Mediums
//

#ifdef DEFINE_MEDIUMS
    #define MEDIUM_DECL static const
#else
    #define MEDIUM_DECL extern
#endif
                               
/*  -----------------------------------------------------------

    Topology of all devices:

                            PinDir  FilterPin#    M_GUID#
    TVTuner                 
        TVTunerVideo        out         0            0
    Crossbar
        TVTunerVideo        in          0            0
        AnalogVideoIn       out         3            1
    Capture
        AnalogVideoIn       in          0            1
        

All other pins are marked as promiscuous connections via GUID_NULL
------------------------------------------------------------------ */        
        
// Define the GUIDs which will be used to create the Mediums
#define M_GUID0 0xa19dc0e0, 0x3b39, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID1 0xa19dc0e1, 0x3b39, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba

// Note: To allow multiple instances of the same piece of hardware,
// set the first ULONG after the GUID in the Medium to a unique value.

// -----------------------------------------------

MEDIUM_DECL KSPIN_MEDIUM TVTunerMediums[] = {
    {M_GUID0,           0, 0},  // Pin 0
    {STATIC_GUID_NULL,  0, 0},  // Pin 1
};

MEDIUM_DECL BOOL TVTunerPinDirection [] = {
    TRUE,                       // Output Pin 0
    TRUE,                       // Output Pin 1
};

// -----------------------------------------------

MEDIUM_DECL KSPIN_MEDIUM CrossbarMediums[] = {
    {STATIC_GUID_NULL,  0, 0},  // Pin 0
    {M_GUID0,           0, 0},  // Pin 1
    {STATIC_GUID_NULL,  0, 0},  // Pin 2
    {M_GUID1,           0, 0},  // Pin 3
};

MEDIUM_DECL BOOL CrossbarPinDirection [] = {
    FALSE,                      // Input  Pin 0
    FALSE,                      // Input  Pin 1
    FALSE,                      // Input  Pin 2
    TRUE,                       // Output Pin 3
};

// -----------------------------------------------

MEDIUM_DECL KSPIN_MEDIUM CaptureMediums[] = {
    {STATIC_KSMEDIUMSETID_Standard,  0, 0},  // Pin 0  Capture
    {STATIC_KSMEDIUMSETID_Standard,  0, 0},  // Pin 1  Preview
    {STATIC_KSMEDIUMSETID_Standard,  0, 0},  // Pin 2  VBI
    {M_GUID1,           0, 0},  // Pin 3  Analog Video In
};

MEDIUM_DECL BOOL CapturePinDirection [] = {
    TRUE,                       // Output Pin 0
    TRUE,                       // Output Pin 1
    TRUE,                       // Output Pin 2
    FALSE,                      // Input  Pin 3
};

MEDIUM_DECL GUID CaptureCategories[] = {
    STATIC_PINNAME_VIDEO_CAPTURE,           // Pin 0
    STATIC_PINNAME_VIDEO_PREVIEW,           // Pin 1
    STATIC_PINNAME_VIDEO_VBI                // Pin 2
    STATIC_PINNAME_VIDEO_ANALOGVIDEOIN,     // Pin 3
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\pisces.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Pisces.h 1.8 1998/05/06 18:25:31 tomz Exp $

#ifndef __PISCES_H
#define __PISCES_H

#include "preg.h"

#ifndef __FIELD_H
#include "field.h"
#endif

#ifndef __DECODER_H
#include "decoder.h"
#endif

#ifndef __RISCENG_H
#include "risceng.h"
#endif

typedef  void  (*EVENTHANDLER)( DWORD dwCB, PVOID pTag );

const PiscesStreams = 4;

#define BIT(x) ((DWORD)1 << (x))

const VSYNC_I     = BIT(1);         // 0x00000001
const I2CDONE_I   = BIT(8);         // 0x00000100
const GPINT_I     = BIT(9);         // 0x00000200
const RISC_I      = BIT(11);        // 0x00000800
const FBUS_I      = BIT(12);        // 0x00001000
const FTRGT_I     = BIT(13);        // 0x00002000
const FDSR_I      = BIT(14);        // 0x00004000
const PPERR_I     = BIT(15);        // 0x00008000
const RIPERR_I    = BIT(16);        // 0x00010000
const PABORT_I    = BIT(17);        // 0x00020000
const OCERR_I     = BIT(18);        // 0x00040000
const SCERR_I     = BIT(19);        // 0x00080000
const DMAERR_I    = BIT(20);        // 0x00100000

const PARITY_I    = (BIT(15)|BIT(16)); // 0x00018000

const EN_TRITON1_BUG_FIX   = BIT(23);  // 0x00800000

/* Class: IntrIdxAss
 * Purpose: Used to assiciate a number program will generate with IRQ and
 *   an index in the array
 */
class IntrIdxAss
{
   public:
      int   IntNo;
      int   Idx;
      IntrIdxAss() : IntNo( 0 ), Idx( 0 ) {}
      IntrIdxAss( int key, int value ) : IntNo( key ), Idx( value ) {}
      int operator ==( const IntrIdxAss &rhs ) { return IntNo == rhs.IntNo; }
};

/* Type: IntrToIdxDict
 * Purpose: Holds values of interrupt number and array index associated
 * Note Use TArrayAsVector instead of TIArrayAsVector ( it contains pointers,
 *   after all ) because compiler insists on calling vector_new which is
 *   non-existent in the VxD libs
 */
typedef IntrIdxAss *IntrToIdxDict [12];

/* Type: ProgramsArray
 * Purpose: Defines an array that holds created programs
 * Note: Elements in the array alternate, i.e. even program, odd, even...
 */
typedef RiscPrgHandle ProgramsArray [12];

// class CProgArray 
//
// assumptions:
//    1. Array size is 12.
//    2. The prog array has fixed locations for specific purposes:
//       0  VBIO
//       1  ODD
//       2  ODD Sync
//       3  VBIE
//       4  EVEN
//       5  EVEN Sync
// --------------------
//       6  VBIO     
//       7  ODD      
//       8  ODD Sync 
//       9  VBIE     
//       10 EVEN     
//       11 EVEN Sync
#define MAX_PROGS 12

class CProgArray {
private:
   DWORD dwCurrNdx_  ;
   RiscPrgHandle rpArray[MAX_PROGS] ;
public:
   CProgArray ()           { Clear() ;}
   virtual ~CProgArray ()  { } 

   // Clear sets all array elements handles to NULL
   void Clear() {
      dwCurrNdx_ = 0 ;
      memset( &rpArray[0], '\0', sizeof( rpArray ) )  ;
   }

   // overload for accessing the array
   inline RiscPrgHandle & operator [] (DWORD n) { 
      n %= MAX_PROGS ; // prevent invalid accesses
      return rpArray[n] ;
   } 

   // Return the index of the given handle. Assumes that the handle
   // was given by this class and is valid and current.
   DWORD GetIndex(RiscPrgHandle hRp)
   {
      for (int i = 0 ; i < MAX_PROGS ; i++)
         if (rpArray[i] == hRp)
            return i ;

      return (DWORD) -1 ;
   }

   //
   // Count Methods
   //

   // Returns the number of elements. Static for now.
   inline DWORD NumElements() { return MAX_PROGS ; }

   // Returns the number of non-null programs
   DWORD Count() {
      DWORD n = 0 ;
      for (int i = 0 ; i < MAX_PROGS ; i++)
         if (rpArray[i])
            n++ ;
      return n ;
   }

   // Returns the number of video programs
   inline DWORD CountVideoProgs() {
      DWORD n = 0 ;
      if (rpArray[1])  n++ ; 
      if (rpArray[4])  n++ ; 
      if (rpArray[7])  n++ ; 
      if (rpArray[10]) n++ ;
      return n ;
   }

   // Returns the number of vbi programs
   inline DWORD CountVbiProgs() {
      DWORD n = 0 ;
      if (rpArray[0]) n++ ;
      if (rpArray[3]) n++ ;
      if (rpArray[6]) n++ ;
      if (rpArray[9]) n++ ;
      return n ;
   }

   // Returns number of programs which actually transfer data
   inline DWORD CountDMAProgs() {
     return CountVideoProgs() + CountVbiProgs() ;
   }

   //
   // Find Methods
   //

   // Returns the first non-null riscprogram. Returns Null if array is empty.
   RiscPrgHandle First() {
      RiscPrgHandle hRp = NULL ;
      for (dwCurrNdx_ = 0 ; dwCurrNdx_ < MAX_PROGS ; dwCurrNdx_++) {
         if (rpArray[dwCurrNdx_]) {
            hRp = rpArray[dwCurrNdx_++] ;
            break ;
         }
      }
      return hRp ;
   }

   // Returns the next non-null riscprogram. Returns null if there are none left.
   RiscPrgHandle Next() {
      RiscPrgHandle hRp = NULL ;
      for ( ; dwCurrNdx_ < MAX_PROGS ; dwCurrNdx_++) {
         if (rpArray[dwCurrNdx_]) {
            hRp = rpArray[dwCurrNdx_++] ;
            break ;
         }
      }
      return hRp ;
   }
} ;

const VBIOStartLocation = 0;
const OddStartLocation  = 1;
const OddSyncStartLoc   = 2;
const VBIEStartLocation = 3;
const EvenStartLocation = 4;
const EvenSyncStartLoc  = 5;

const DistBetweenProgs     = 6;

const ProgsWithinField  = 3;

/* Class: BtPisces
 * Purpose: Controls the BtPisces video capture chip
 * Attributes:
 * Operations:
 * Note: Every time any of the Set functions is called, operation must stop.
 *   After all changes are done execution can resume. This means that all RISC
 *   programs are destroyed ( if they exist ), changes made, new RISC programs
 *   are created ( if needed )
*/
class BtPisces
{
      DECLARE_COLORCONTROL;
      DECLARE_INTERRUPTSTATUS;
      DECLARE_INTERRUPTMASK;
      DECLARE_CONTROL;
      DECLARE_CAPTURECONTROL;
      DECLARE_COLORFORMAT;
      DECLARE_GPIODATAIO;
      DECLARE_GPIOOUTPUTENABLECONTROL;

   public:
         Decoder       PsDecoder_;

   private:

         // all possible data streams
         FieldWithScaler Even_;
         FieldWithScaler Odd_;
         VBIField        VBIE_;
         VBIField        VBIO_;

         RISCEng       Engine_;
         RISCProgram   Starter_;
         RISCProgram   *Skippers_ [PiscesStreams * MaxProgsForField];

         RISCProgram   SyncEvenEnd1_;
         RISCProgram   SyncEvenEnd2_;

         RISCProgram   SyncOddEnd1_;
         RISCProgram   SyncOddEnd2_;

         CProgArray CreatedProgs_;
         CProgArray ActiveProgs_;

         IntrToIdxDict InterruptToIdx_;

         int           nSkipped_;
         int           OldIdx_;

         // this is the indirection array that maps an index from the CreatedProgs_
         // array into the Skippers_ array. It is needed because it is much simpler
         // to assign a strict relationships between a created program and a skipper
         // for it than trying to figure out what skipper program is available
         // when a created program needs to be skipped
         int           SkipperIdxArr_ [ProgsWithinField * 2 * MaxProgsForField];

         bool          Paused_;
         bool          Update_;

         bool          Inited_;
         DWORD         dwPlanarAdjust_;

         void Init();

         bool CreateSyncCodes();
         void ProcessRISCIntr();


   protected:

      // type-unsafe method of getting field associated with a stream
//      Field & GetField( StreamInfo &str ) { return *(Field*)str.tag; }
      int GetIdxFromStream( Field &aField );

      RiscPrgHandle AddProgram( Field &aStream, int NumberToAdd );
      void ProcessPresentPrograms();
      void AssignIntNumbers();
      void ProcessSyncPrograms();
      void LinkThePrograms();
      void Skip( int idx );
      void Restart();
      void GetStarted( bool &EvenWasStarted, bool &OddWasStarted,
         bool &VBIEWasStarted, bool &VBIOWasStarted );
      void RestartStreams( bool EvenWasStarted, bool OddWasStarted,
         bool VBIEWasStarted, bool VBIOWasStarted );
      void CreateStarter( bool EvenWasStarted );

      int  GetPassed();
//      void AdjustTime( LARGE_INTEGER &t, int passed );
      
      RiscPrgHandle GetProgram( int pos, int &idx );


   public:

      void PairedPause( int idx );
      void DumpRiscPrograms();

      // decoder 'set' group
      virtual void SetBrightness( DWORD value );
      virtual void SetSaturation( DWORD value );
      virtual void SetConnector ( DWORD value );
      virtual void SetContrast  ( DWORD value );
      virtual void SetHue       ( DWORD value );
      virtual void SetSVideo    ( DWORD value );
      virtual void SetFormat    ( DWORD value );

      virtual LONG GetSaturation();
      virtual LONG GetHue       ();
      virtual LONG GetBrightness();
      virtual LONG GetSVideo    ();
      virtual LONG GetContrast  ();
      virtual LONG GetFormat    ();
      virtual LONG GetConnector ();
      virtual LONG GetSupportedStandards();

              void SetPlanarAdjust( DWORD val ) { dwPlanarAdjust_ = val; }
              void TurnVFilter( State s );

        // scaler group
      virtual ErrorCode SetAnalogWindow( MRect &r, Field &aField );
      virtual ErrorCode SetDigitalWindow( MRect &r, Field &aField );

      // color space converter group
      virtual void SetPixelFormat( ColFmt, Field &aField );
      ColFmt GetPixelFormat( Field &aField );

      // streaming operation functions
      virtual ErrorCode Create( Field &aField );
      virtual void  Start( Field &aField );
      virtual void  Stop( Field &aField );
              void  Pause( Field &aField );
              void  Continue();
              State Interrupt();
//              void  ProcessAddBuffer( StreamInfo aStream );
              void  ProcessBufferAtInterrupt( PVOID pTag );

              void SetBufPitch( DWORD dwP, Field &aField )
              { aField.SetBufPitch( dwP ); }

       void SetBufQuePtr( Field &aField, VidBufQueue *pQ )
      { aField.SetBufQuePtr( pQ ); }

      VidBufQueue &GetCurrentQue( Field &aField )
      { return aField.GetCurrentQue(); }

      virtual ErrorCode AllocateStream( Field *&Field, VideoStream st );

      DWORD   GetDataBuffer( int idx ) { return CreatedProgs_ [idx]->GetDataBuffer(); }

      bool InitOK();

      BtPisces( DWORD *xtals );
      ~BtPisces();

};

inline bool BtPisces::InitOK()
{
   return Inited_;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\physaddr.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Physaddr.h 1.3 1998/04/29 22:43:34 tomz Exp $

#ifndef __PHYSADDR_H
#define __PHYSADDR_H

inline DWORD GetPhysAddr( DataBuf &buf )
{
   ULONG len = 0;
   return StreamClassGetPhysicalAddress( buf.pSrb_->HwDeviceExtension, buf.pSrb_,
      buf.pData_, SRBDataBuffer, &len ).LowPart;
}

/* Function: IsSumAbovePage
 * Purpose: Sees if sum of 2 numbers is bigger then page
 * Input: first: DWORD
 *   second: DWORD,
 * Output: bool
*/
inline bool IsSumAbovePage( DWORD first, DWORD second )
{
   return bool( BYTE_OFFSET( first ) + BYTE_OFFSET( second ) > ( PAGE_SIZE - 1 ) );
//   return bool( ( first & 0xFFF ) + ( second & 0xFFF ) > 0xFFF );
}


/* Function: Need2Split
 * Purpose: Sees if a scan line needs to be broken into 2 instructions
 * Input: dwAddr: DWORD, address
 *   wCOunt: WORD, byte count
 * Output: bool
*/
inline bool Need2Split( DataBuf &buf, WORD wCount )
{
   DataBuf tmp = buf;
   tmp.pData_ += wCount;
   return bool( IsSumAbovePage( DWORD( buf.pData_ ), wCount ) &&
          ( GetPhysAddr( tmp ) - GetPhysAddr( buf ) != wCount ) );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\pscolspc.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Pscolspc.cpp 1.4 1998/04/29 22:43:35 tomz Exp $

extern "C" {
#ifndef _STREAM_H
#include "strmini.h"
#endif
}

#include "pscolspc.h"

/* Method: PsColorSpace::SetColorFormat
 * Purpose: Sets BtPisces color space converter to the given color
 * Input: eaColor: enum of type ColFmt
 * Output: None
 * Note: No error checking is done ( enum is checked by the compiler during compile
 *   The function writes to the XXXX register
*/

BOOL VerifyColorFormat( ColFmt val )
{
   // [WRK] - use constants here for valid formats
   switch( val ) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 0xe:
         return( TRUE );
      default:
         DebugOut((0, "Caught bad write to ColorFormat (0x%x)\n", val));
         return( FALSE );
   }
}   
void PsColorSpace::SetColorFormat( ColFmt eColor )
{
   // save for later use...
   ColorSpace::SetColorFormat( eColor );
   ByteSwap_ = 0;
 
   switch ( eColor ) {
   case CF_YUV9:
      eColor = CF_PL_411;
      break;
   case CF_YUV12:
   case CF_I420:
      eColor = CF_PL_422;
      break;
   case CF_UYVY:
      eColor = CF_YUY2;
      ByteSwap_ = 1;
      break;
   }

   // set the hardware
   if ( VerifyColorFormat(eColor) ) {
      Format_ = eColor;
   } else {
      Format_ = 7;
      DebugOut((0, "Forcing invalid color format to 0x%x\n", Format_));
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\preg.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Preg.h 1.2 1998/04/29 22:43:35 tomz Exp $

// Header file generated from zzztmp.h 
// use the macro DECLARE_regname to get declarations.
// use the macro CONSTRUCT_regname to get constructor calls.

#define DECLARE_COLORFORMAT RegisterDW ColorFormat; \
	RegField COLOR_EVEN; \
	RegField COLOR_ODD
	
#define CONSTRUCT_COLORFORMAT ColorFormat( 0x00D4, RW), \
	COLOR_EVEN( ColorFormat, 0, 4, RW), \
	COLOR_ODD( ColorFormat, 4, 4, RW)
	
#define DECLARE_COLORCONTROL RegisterDW ColorControl; \
	RegField BSWAP_EVEN; \
	RegField BSWAP_ODD; \
	RegField WSWAP_EVEN; \
	RegField WSWAP_ODD; \
	RegField GAMMA; \
	RegField RGB_DED; \
	RegField COLOR_BARS; \
	RegField EXT_FRMRATE
	
#define CONSTRUCT_COLORCONTROL ColorControl( 0x00D8, RW), \
	BSWAP_EVEN( ColorControl, 0, 1, RW), \
	BSWAP_ODD( ColorControl, 1, 1, RW), \
	WSWAP_EVEN( ColorControl, 2, 1, RW), \
	WSWAP_ODD( ColorControl, 3, 1, RW), \
	GAMMA( ColorControl, 4, 1, RW), \
	RGB_DED( ColorControl, 5, 1, RW), \
	COLOR_BARS( ColorControl, 6, 1, RW), \
	EXT_FRMRATE( ColorControl, 7, 1, RW)
	
#define DECLARE_CAPTURECONTROL RegisterDW CaptureControl; \
	RegField CAPTURE_EVEN; \
	RegField CAPTURE_ODD; \
	RegField CAPTURE_VBI_EVEN; \
	RegField CAPTURE_VBI_ODD; \
	RegField DITH_FRAME; \
	RegField RESERVED0
	
#define CONSTRUCT_CAPTURECONTROL CaptureControl( 0x00DC, RW), \
	CAPTURE_EVEN( CaptureControl, 0, 1, RW), \
	CAPTURE_ODD( CaptureControl, 1, 1, RW), \
	CAPTURE_VBI_EVEN( CaptureControl, 2, 1, RW), \
	CAPTURE_VBI_ODD( CaptureControl, 3, 1, RW), \
	DITH_FRAME( CaptureControl, 4, 1, RW), \
	RESERVED0( CaptureControl, 5, 3, RW)
	
#define DECLARE_VBIPACKETSIZE RegisterDW VBIPacketSize; \
	RegField VBI_PKT_LO
	
#define CONSTRUCT_VBIPACKETSIZE VBIPacketSize( 0x00E0, RW), \
	VBI_PKT_LO( VBIPacketSize, 0, 8, RW)
	
#define DECLARE_VBIDELAY RegisterDW VBIDelay; \
	RegField VBI_PKT_HI; \
	RegField EXT_RAW; \
	RegField VBI_HDELAY
	
#define CONSTRUCT_VBIDELAY VBIDelay( 0x00E4, RW), \
	VBI_PKT_HI( VBIDelay, 0, 1, RW), \
	EXT_RAW( VBIDelay, 1, 1, RW), \
	VBI_HDELAY( VBIDelay, 2, 6, RW)
	
#define DECLARE_INTERRUPTSTATUS RegisterDW InterruptStatus; \
	RegField FMTCHG; \
	RegField VSYNC; \
	RegField HSYNC; \
	RegField OFLOW; \
	RegField HLOCK; \
	RegField VPRES; \
	RegField RESERVED1; \
	RegField RESERVED2; \
	RegField I2CDONE; \
	RegField GPINT; \
	RegField RESERVED3; \
	RegField RISCI; \
	RegField FBUS; \
	RegField FTRGT; \
	RegField FDSR; \
	RegField PPERR; \
	RegField RIPERR; \
	RegField PABORT; \
	RegField OCERR; \
	RegField SCERR; \
	RegField RESERVED4; \
	RegField FIELD; \
	RegField RACK; \
	RegField V5IO; \
	RegField RISC_EN; \
	RegField RISCS
	
#define CONSTRUCT_INTERRUPTSTATUS InterruptStatus( 0x0100, RW), \
	FMTCHG( InterruptStatus, 0, 1, RR), \
	VSYNC( InterruptStatus, 1, 1, RR), \
	HSYNC( InterruptStatus, 2, 1, RR), \
	OFLOW( InterruptStatus, 3, 1, RR), \
	HLOCK( InterruptStatus, 4, 1, RR), \
	VPRES( InterruptStatus, 5, 1, RR), \
	RESERVED1( InterruptStatus, 6, 1, RO), \
	RESERVED2( InterruptStatus, 7, 1, RO), \
	I2CDONE( InterruptStatus, 8, 1, RR), \
	GPINT( InterruptStatus, 9, 1, RR), \
	RESERVED3( InterruptStatus, 10, 1, RO), \
	RISCI( InterruptStatus, 11, 1, RR), \
	FBUS( InterruptStatus, 12, 1, RR), \
	FTRGT( InterruptStatus, 13, 1, RR), \
	FDSR( InterruptStatus, 14, 1, RR), \
	PPERR( InterruptStatus, 15, 1, RR), \
	RIPERR( InterruptStatus, 16, 1, RR), \
	PABORT( InterruptStatus, 17, 1, RR), \
	OCERR( InterruptStatus, 18, 1, RR), \
	SCERR( InterruptStatus, 19, 1, RR), \
	RESERVED4( InterruptStatus, 20, 4, RO), \
	FIELD( InterruptStatus, 24, 1, RO), \
	RACK( InterruptStatus, 25, 1, RO), \
	V5IO( InterruptStatus, 26, 1, RO), \
	RISC_EN( InterruptStatus, 27, 1, RO), \
	RISCS( InterruptStatus, 28, 4, RO)
	
#define DECLARE_INTERRUPTMASK RegisterDW InterruptMask; \
	RegField IMASK_FMTCHG; \
	RegField IMASK_VSYNC; \
	RegField IMASK_HSYNC; \
	RegField IMASK_OFLOW; \
	RegField IMASK_HLOCK; \
	RegField IMASK_VPRES; \
	RegField IMASK_RESERVED6; \
	RegField IMASK_RESERVED7; \
	RegField IMASK_I2CDONE; \
	RegField IMASK_GPINT; \
	RegField IMASK_RESERVED10; \
	RegField IMASK_RISCI; \
	RegField IMASK_FBUS; \
	RegField IMASK_FTRGT; \
	RegField IMASK_FDSR; \
	RegField IMASK_PPERW; \
	RegField IMASK_RIPERW; \
	RegField IMASK_PABORT; \
	RegField IMASK_OCERW; \
	RegField IMASK_SCERW; \
	RegField IMASK_RESERVED23TO20
	
#define CONSTRUCT_INTERRUPTMASK InterruptMask( 0x0104, RW), \
	IMASK_FMTCHG( InterruptMask, 0, 1, RW), \
	IMASK_VSYNC( InterruptMask, 1, 1, RW), \
	IMASK_HSYNC( InterruptMask, 2, 1, RW), \
	IMASK_OFLOW( InterruptMask, 3, 1, RW), \
	IMASK_HLOCK( InterruptMask, 4, 1, RW), \
	IMASK_VPRES( InterruptMask, 5, 1, RW), \
	IMASK_RESERVED6( InterruptMask, 6, 1, RW), \
	IMASK_RESERVED7( InterruptMask, 7, 1, RW), \
	IMASK_I2CDONE( InterruptMask, 8, 1, RW), \
	IMASK_GPINT( InterruptMask, 9, 1, RW), \
	IMASK_RESERVED10( InterruptMask, 10, 1, RW), \
	IMASK_RISCI( InterruptMask, 11, 1, RW), \
	IMASK_FBUS( InterruptMask, 12, 1, RW), \
	IMASK_FTRGT( InterruptMask, 13, 1, RW), \
	IMASK_FDSR( InterruptMask, 14, 1, RW), \
	IMASK_PPERW( InterruptMask, 15, 1, RW), \
	IMASK_RIPERW( InterruptMask, 16, 1, RW), \
	IMASK_PABORT( InterruptMask, 17, 1, RW), \
	IMASK_OCERW( InterruptMask, 18, 1, RW), \
	IMASK_SCERW( InterruptMask, 19, 1, RW), \
	IMASK_RESERVED23TO20( InterruptMask, 20, 4, RW)
	
#define DECLARE_CONTROL RegisterDW Control; \
	RegField FIFO_ENABLE; \
	RegField RISC_ENABLE; \
	RegField PKTP; \
	RegField PLTP1; \
	RegField PLTP23; \
	RegField RESERVED5; \
	RegField GPCLKMODE; \
	RegField GPIOMODE; \
	RegField GPWEC; \
	RegField GPINTI; \
	RegField GPINTC
	
#define CONSTRUCT_CONTROL Control( 0x010C, RW), \
	FIFO_ENABLE( Control, 0, 1, RW), \
	RISC_ENABLE( Control, 1, 1, RW), \
	PKTP( Control, 2, 2, RW), \
	PLTP1( Control, 4, 2, RW), \
	PLTP23( Control, 6, 2, RW), \
	RESERVED5( Control, 8, 2, RW), \
	GPCLKMODE( Control, 10, 1, RW), \
	GPIOMODE( Control, 11, 2, RW), \
	GPWEC( Control, 13, 1, RW), \
	GPINTI( Control, 14, 1, RW), \
	GPINTC( Control, 15, 1, RW)
	
#define DECLARE_RISCPROGRAMSTARTADDRESS RegisterDW RISCProgramStartAddress; \
	RegField RISC_IPC
	
#define CONSTRUCT_RISCPROGRAMSTARTADDRESS RISCProgramStartAddress( 0x0114, RW), \
	RISC_IPC( RISCProgramStartAddress, 0, 32, RW)
	
#define DECLARE_GPIOOUTPUTENABLECONTROL RegisterDW GPIOOutputEnableControl; \
	RegField GPOE
	
#define CONSTRUCT_GPIOOUTPUTENABLECONTROL GPIOOutputEnableControl( 0x0118, RW), \
	GPOE( GPIOOutputEnableControl, 0, 24, RW)
	
#define DECLARE_GPIOREGISTEREDINPUTCONTROL RegisterDW GPIORegisteredInputControl; \
	RegField GPIE
	
#define CONSTRUCT_GPIOREGISTEREDINPUTCONTROL GPIORegisteredInputControl( 0x011C, RW), \
	GPIE( GPIORegisteredInputControl, 0, 24, RW)
	
#define DECLARE_GPIODATAIO RegisterDW GPIODataIO; \
	RegField GPDATA
	
#define CONSTRUCT_GPIODATAIO GPIODataIO( 0x0200, RW), \
	GPDATA( GPIODataIO, 0, 24, RW)
	
#define DECLARE_I2CDATA_CONTROL RegisterDW I2CData_Control; \
	RegField I2CDB0; \
	RegField I2CDB1; \
	RegField I2CDB2; \
	RegField I2CDIV; \
	RegField I2CSYNC; \
	RegField I2CW3B; \
	RegField I2CSCL; \
	RegField I2CSDA
	
#define CONSTRUCT_I2CDATA_CONTROL I2CData_Control( 0x0110, RW), \
	I2CDB0( I2CData_Control, 24, 8, RV), \
	I2CDB1( I2CData_Control, 16, 8, RV), \
	I2CDB2( I2CData_Control, 8, 8, RV), \
	I2CDIV( I2CData_Control, 4, 4, RW), \
	I2CSYNC( I2CData_Control, 3, 1, RW), \
	I2CW3B( I2CData_Control, 2, 1, RW), \
	I2CSCL( I2CData_Control, 1, 1, RV), \
	I2CSDA( I2CData_Control, 0, 1, RV)
	
#define DECLARE_RISCPROGRAMCOUNTER RegisterDW RISCProgramCounter
	
#define CONSTRUCT_RISCPROGRAMCOUNTER RISCProgramCounter( 0x0120, RW)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\mytypes.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Mytypes.h 1.9 1998/04/29 22:43:34 tomz Exp $

#ifndef __MYTYPES_H
#define __MYTYPES_H

#ifdef __cplusplus
extern "C" {

#include "capdebug.h"

#ifndef _STREAM_H
#include "strmini.h"
#endif
#ifndef _KSMEDIA_
#include "ksmedia.h"
#endif
}
#endif


#ifndef __RETCODE_H
#include "retcode.h"
#endif

// Needed for VC4.x compile (_MSC_VER is defined as 1100 for MSVC 5.0) 
#if _MSC_VER < 1100
//  #pragma message  ("***  MSVC 4.x build ***")

  #define bool  BOOL
  #define true  TRUE
  #define false FALSE
  #define VC_4X_BUILD 
#else
//  #pragma message  ("***  MSVC 5.0 or better build ***")
  #undef  VC_4X_BUILD
#endif

inline long abs ( long lval )
{
   return( ( lval < 0 ) ? -lval : lval );
}   

inline void * _cdecl operator new( size_t sz )
{
   PVOID p = ExAllocatePool( NonPagedPool, sz );
   DebugOut((1, "Alloc %x got = %x\n", sz, p ) );
   return p;
}

inline void _cdecl operator delete( void *p )
{
   DebugOut((1, "deleting = %x\n", p ) );
   if ( p ) {
      ExFreePool( p );
   }
}

#ifndef VC_4X_BUILD
// In VC versions below 5.0, the following two cases are covered by the 
// new and delete defined above. The following syntax is invalid in pre-
// 5.0 versions.
inline void * _cdecl operator new[]( size_t sz )  
{
   PVOID p = ExAllocatePool( NonPagedPool, sz );
   DebugOut((1, "Alloc [] %x got = %x\n", sz, p ) );
   return p;
}

inline void _cdecl operator delete []( void *p )
{
   DebugOut((1, "deleting [] = %x\n", p ) );
   if ( p ) {
      ExFreePool( p );
   }
}
#endif

typedef struct tagDataBuf
{
   PHW_STREAM_REQUEST_BLOCK pSrb_;
   PBYTE                    pData_;
   tagDataBuf() : pSrb_( 0 ), pData_( 0 ) {}
   tagDataBuf( PHW_STREAM_REQUEST_BLOCK pSrb, PVOID p )
      : pSrb_( pSrb ), pData_( PBYTE( p ) ) {}
} DataBuf;

class MSize;
class MRect;

class  MPoint : public tagPOINT {
  public:
    // Constructors
};

//
// class MSize
// ----- -----
//
class  MSize : public tagSIZE {
  public:
    // Constructors
    MSize() {}
    MSize(int dx, int dy) {cx = dx; cy = dy;}
    void Set( int dx, int dy ) { cx = dx; cy = dy; }
};


class  MRect : public tagRECT {
  public:
    // Constructors
    MRect() {}
    MRect( int _left, int _top, int _right, int _bottom );
    MRect( const MPoint& origin, const MSize& extent );
    MRect( const struct tagRECT &orgn );

    void Set( int _left, int _top, int _right, int _bottom );

    // Information/access functions(const and non-const)
    const MPoint& TopLeft() const {return *(MPoint*)&left;}
    int          Width() const {return right-left;}
    int          Height() const {return bottom-top;}
    const MSize  Size() const {return MSize(Width(), Height());}
    bool IsEmpty() const;
    bool IsNull() const;

};

//----------------------------------------------------------------------------
// Inlines
//----------------------------------------------------------------------------
inline void MRect::Set(int _left, int _top, int _right, int _bottom) {
  left = _left;
  top = _top;
  right = _right;
  bottom = _bottom;
}

inline MRect::MRect(int _left, int _top, int _right, int _bottom) {
  Set(_left, _top, _right, _bottom);
}
inline MRect::MRect(const MPoint& orgn, const MSize& extent) {
  Set(orgn.x, orgn.y, orgn.x+extent.cx, orgn.y+extent.cy);
}

inline MRect::MRect( const struct tagRECT &orgn )
{
   Set( orgn.left, orgn.top, orgn.right, orgn. bottom );
}

//
// Return true if the rectangle is empty.
//
inline bool MRect::IsEmpty() const
{
  return bool( left >= right || top >= bottom );
}

//
// Return true if all of the points on the rectangle is 0.
//
inline bool MRect::IsNull() const
{
  return bool( !left && !right && !top && !bottom );
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\pscolspc.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Pscolspc.h 1.3 1998/04/29 22:43:36 tomz Exp $

#ifndef __PSCOSPC_H
#define __PSCOLSPC_H

#ifndef __COMPREG_H
#include "compreg.h"
#endif

#ifndef __COLSPACE_H
#include "colspace.h"
#endif


/* Class: PsColorSpace
 * Purpose: This class interfaces to the Pisces HW. That is the only difference
 *    from its base class ColorSpace. Such division was created so ring3 capture
 *    driver can utilize ColorSpace's functionality
 * Attributes: Format_: Register & - reference to the color format register
 * Operations:
 *      void SetColorFormat( ColorFormat aColor );
 */
class PsColorSpace : public ColorSpace
{
   private:
      RegBase &Format_;
      RegBase &WordSwap_;
      RegBase &ByteSwap_;
   public:
      void SetColorFormat( ColFmt aColor );

      PsColorSpace( ColFmt aColForm, RegBase &aFormatReg, RegBase &WS,
         RegBase &BS ) :
         ColorSpace( aColForm ), Format_( aFormatReg ), WordSwap_( WS ),
            ByteSwap_( BS ) {}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\regbase.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Regbase.h 1.5 1998/05/08 00:11:02 tomz Exp $

#ifndef __REGBASE_H
#define __REGBASE_H

#include "mytypes.h"

/* Type: AllFs
 * Purpose: To be used as an error return value from register accessing
 *   functions. All bits are set to 1.
 */
const DWORD AllFs = (DWORD) ~0L;

/* Function: ReturnAllFs
 * Purpose: This function is used in the register access methods to indicate
 *   that some sort of error has occured. Used for easing the debugging, as
 *   it contains a macro to print the error if DEBUG is #defined
 */
inline DWORD ReturnAllFs()
{
//    OUTPUT_MESS( ALLFS );
    return  AllFs;
}

/*
 * Type: RegisterType
 * Purpose: A type to differentiate between diferent kinds of registers.
 *   Depending on the type register may not peforms certain operations
 *   RW - read/write, RO - read-only, WO - write-only
*/
typedef enum { RW, RO, WO, RR } RegisterType;

/* Class: RegBase
 * Purpose:
 *   Defines the interface and encapsulates the register access.
 * Attributes:
 *   pBaseAddress_: DWORD, static. Holds the base address of the registers. On the
 *   PCI bus it is a 32 bit memory address. On the ISA bus it is a 16 bit I/O address.
 *   type_: RegisterType - defines the access permission for the register.
 *   dwShadow_: DWORD - a local copy of the register. Used for returning a value
 *   of write-only registers
 * Operations:
 *   operator DWORD(): data access method. Pure virtual
 *   DWORD operator=( DWORD ): assignment operator. Pure virtual. This assignment
 *      operator does not return a reference to the class because of the performance reasons
 *   void SetBaseAddress( DWORD )
 *   DWORD GetBaseAddress()
 *   RegisterType GetRegisterType()
 *   void SetShadow( DWORD ): assigns a value of a register to a shadow
 *   DWORD GetShadow( void ): retrieves a value from a shadow
 */
class RegBase
{
    private:
         RegisterType type_;
         DWORD        dwShadow_;

         RegBase();

    protected:
         void  SetShadow( DWORD dwValue );
         DWORD GetShadow();
    public:
         RegBase( RegisterType aType ) :
            type_( aType ), dwShadow_( 0 )
         {}

         static LPBYTE GetBaseAddress() {
            extern BYTE *GetBase();
            return GetBase(); 
         }
         RegisterType GetRegisterType() { return type_; }
         virtual operator DWORD() = 0;
         virtual DWORD operator=( DWORD dwValue ) = 0;
         virtual ~RegBase() {}
};

/* Method: RegBase::SetShadow
 * Purpose: Used to store the value of a register in the shadow
 * Input: dwValue: DWORD - new value of a register
 * Output: None
 * Note: inline
 */
inline void  RegBase::SetShadow( DWORD dwValue ) { dwShadow_ = dwValue; }

/* Method: RegBase::GetShadow
 * Purpose: Used to obtain the last value written to a write-only register
 *    from the shadow
 * Input: None
 * Output: DWORD
 * Note: inline
 */
inline DWORD RegBase::GetShadow() { return dwShadow_; }

#endif __REGBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\queue.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Queue.h 1.5 1998/05/08 18:18:52 tomz Exp $

#ifndef __QUEUE_H
#define __QUEUE_h

const QueSize = 200;
/* Class: VidBufQueue
 * Purpose: Queue of buffers to be sent to BtPisces
 */
template <class T> class Queue
{
   private:
      T  Data [QueSize];
      T	 Dummy;
	   unsigned items;
      unsigned left;
      unsigned right;
      unsigned size;
   public:

      bool IsFull();
      bool IsEmpty();

      unsigned Prev( unsigned index ) const;
      unsigned Next( unsigned index ) const;

      T Get();
      T GetRight();

      void Put( const T& t );
      T PeekLeft();
      T PeekRight();

      void Flush();

      int GetNumOfItems();

      Queue();
      ~Queue();
};

template <class T>  bool Queue<T>::IsFull()
{
   return right == Prev( left );
}

template <class T> bool Queue<T>::IsEmpty()
{
   return !items;
}

template <class T> int Queue<T>::GetNumOfItems()
{
   return items;
}

template <class T> unsigned Queue<T>::Prev( unsigned index ) const
{
   if ( index == 0 )
      index = size;
   return --index;
}

template <class T> unsigned Queue<T>::Next( unsigned index ) const
{
   index++;
   if ( index == size )
      index = 0;
   return index;
}

template <class T> T Queue<T>::Get()
{
	if(!items){
		DebugOut((0, "Queue::Get called on empty queue!!!\n"));
//	 	DEBUG_BREAKPOINT();
		return Dummy;
	}
   T t = Data [left];
   Data [left] = T();
   left = Next( left );
   items--;
   return t;
}

/* Method: Queue::GetRight
 * Purpose: Gets the next element
 * Note: Extreme caution must be used when calling this function. The caller must
 *   make sure the queue is not empty before calling it. Otherwise bogus data
 *   will be returned
 */
template <class T> T Queue<T>::GetRight()
{
	if(!items){
		DebugOut((0, "Queue::GetRight called on empty queue!!!\n"));
//		DEBUG_BREAKPOINT();
		return Dummy;
	}
    right = Prev( right );
    T t = Data [right];
    Data[right] = T();
    items--;
    return t;
}

template <class T> void Queue<T>::Flush()
{
	if(items){
		DebugOut((0, "Queue::Flush called on non-empty queue, %d items lost!!!\n", items));
//		DEBUG_BREAKPOINT();
	}
   items = left = right = 0;
}

template <class T> void Queue<T>::Put( const T& t )
{
	if ( items >= size ){
		DebugOut((0, "Queue::Put called on Full queue!!!\n"));
//		DEBUG_BREAKPOINT();
      return;
	}
   Data [right] = t;
   right = Next( right );
   items++;
}

template <class T> Queue<T>::Queue()
   : Data(), Dummy(), items( 0 ), left( 0 ), right( 0 ), size( QueSize )
{
}

template <class T> T Queue<T>::PeekLeft()
{
	if(!items){
		DebugOut((0, "Queue::PeekLeft called on empty queue!!!\n"));
//		DEBUG_BREAKPOINT();
		return Dummy;
	}
   return Data [left];
}

template <class T> T Queue<T>::PeekRight()
{
	if(!items){
		DebugOut((0, "Queue::PeekRight called on empty queue!!!\n"));
//		DEBUG_BREAKPOINT();
		return Dummy;
	}
   return Data [Prev( right )];
}

template <class T> Queue<T>::~Queue()
{
}

typedef Queue<PHW_STREAM_REQUEST_BLOCK> SRBQueue;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\pspagebl.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Pspagebl.h 1.7 1998/04/29 22:43:36 tomz Exp $

#ifndef __PSPAGEBL_H
#define __PSPAGEBL_H

#ifndef __MYTYPES_H
#include "mytypes.h"
#endif

#ifndef __PHYSADDR_H
#include "physaddr.h"
#endif

// unlike things in ks.h, this is a real forward declaration
extern PVOID gpHwDeviceExtension;

/* Class: PsPageBlock
 * Purpose: Encapsulates memory allocations for the data buffers and RISC programs
 */
class PsPageBlock
{
   protected:
      DWORD  PhysAddr_;
      PVOID  LinAddr_;

      void AllocateSpace( DWORD dwSize );
      void FreeSpace();
   public:
      PsPageBlock( DWORD dwSize );
      ~PsPageBlock();

      DWORD GetPhysAddr();
      DWORD getLinearBase();
};

inline PsPageBlock::PsPageBlock( DWORD dwSize )
{
   AllocateSpace( dwSize );
}

inline PsPageBlock::~PsPageBlock()
{
   FreeSpace();
}

inline DWORD PsPageBlock::GetPhysAddr()
{
   return PhysAddr_;
}

inline DWORD PsPageBlock::getLinearBase()
{
   return (DWORD)LinAddr_;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\regfield.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Regfield.h 1.3 1998/04/29 22:43:36 tomz Exp $

#ifndef __REGFIELD_H
#define __REGFIELD_H

#ifndef __REGISTER_H
#include "register.h"
#endif

// maximum size of a register in bits
const BYTE MaxWidth = 32;

/* Class: RegField
 * Purpose: This class encapsulates the behaviour of a register which is a set
 *   of bits withing a larger register
 * Attributes:
 *   Owner_: Register & - reference to the register that contains this field.
 *   It is a reference to Register class because actual register can be either one of
 *   byte, word or dword registers.
 *   StartBit_: BYTE - starting position of this field
 *   FieldWidth_: BYTE - width of this field in bits
 * Operations:
 *   operator DWORD(): data access method. Returns a value of the register
 *   DWORD operator=( DWORD ): assignment operator. Used to set the register
 *   These operations assume that a parent register has RW attribute set, though
 *   not all register fields of it are read-write. If RW is not used for the parent
 *   this class may be in error.
 * Note: the error handling provided by the class is minimal. It is a responibility
 *   of the user to pass correct parameters to the constructor. The class has
 *   no way of knowing if the correct owning registe passed in is correct,
 *   for example. If starting bit or width is beyond the maximum field width
 *   the mask used to isolate the field will be 0xFFFFFFFF
 */
class RegField : public RegBase
{
   private:
      Register &Owner_;
      BYTE      StartBit_;
      BYTE      FieldWidth_;
      DWORD     MakeAMask();
      RegField();
   public:
      virtual operator DWORD();
      virtual DWORD operator=( DWORD dwValue );
      RegField( Register &AnOwner, BYTE nStart, BYTE nWidth, RegisterType aType ) :
         RegBase( aType ), Owner_( AnOwner ), StartBit_( nStart ),
         FieldWidth_( nWidth ) {}
};

/* Function: MakeAMask
 * Purpose: Creates a bit mask to be used in different register classes
 * Input:
 *   bWidth: BYTE - width of a mask in bits
 * Output:
 *   DWORD
 * Note: This function is inline
 */
inline DWORD MakeAMask( BYTE bWidth )
{
   return ( bWidth >= 32 ? 0 : (DWORD)1 << bWidth ) - 1;
}

#endif __REGFIELD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\register.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Register.h 1.3 1998/04/29 22:43:36 tomz Exp $

#ifndef __REGISTER_H
#define __REGISTER_H



#ifndef __REGBASE_H
#include "regbase.h"
#endif

/* Type: Register
 * Purpose: An intermediate class between the RegBase and actual usable classes.
 *   Actual classes are RegisterB, RegisterW, RegisterDW
 * Attributes:
 *   uOffset_: unsigned int - an offset of the register from the base
 * Operations:
 *   GetOffset(): returns the offset value. Protected
 *   operator DWORD(): data access method. Always returns -1
 *   DWORD operator=( DWORD ): assignment operator. Always returns -1
 * Note:
 *   The reason to have operators in this class is for the register field class
 *   to have a member of type 'reference to Register'. Otherwise RegField is not
 *   able to use access methods.
 */
class Register : public RegBase
{
   private:
      unsigned int uOffset_;
      Register();
    protected:

    public:
         unsigned int GetOffset() { return uOffset_; }

         virtual operator DWORD();
      virtual DWORD operator=( DWORD dwValue );

         Register( unsigned int uOff, RegisterType aType ) :
            RegBase( aType ), uOffset_( uOff ) {}
};

/* Type: RegisterB
 * Purpose: A register that performs the BYTE I/O
 * Note:
 *   This class has no additional data members, it just overloads operators
 */
class RegisterB : public Register
{
    private:
         RegisterB();
    public:
         virtual operator DWORD();
         virtual DWORD operator=( DWORD dwValue );
         RegisterB( unsigned int uOff, RegisterType aType ) :
            Register( uOff, aType ) {};
};

/* Type: RegisterW
 * Purpose: A register that performs the WORD I/O
 * Note:
 *   This class has no additional data members, it just overloads operators
 */
class RegisterW : public Register
{
    private:
         RegisterW();
    public:
         virtual operator DWORD();
         virtual DWORD operator=( DWORD dwValue );
         RegisterW( unsigned int uOff, RegisterType aType ) :
            Register( uOff, aType ) {};

};


/* Type: RegisterDW
 * Purpose: A register that performs the DWORD I/O
 * Note:
 *   This class has no additional data members, it just overloads operators
 */
class RegisterDW : public Register
{
    private:
         RegisterDW();
    public:
         virtual operator DWORD();
         virtual DWORD    operator=( DWORD dwValue );

         RegisterDW( unsigned int uOff, RegisterType aType ) :
            Register( uOff, aType ) {};
};

#endif __REGISTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\regfield.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Regfield.cpp 1.3 1998/04/29 22:43:36 tomz Exp $

#include "regfield.h"

/* Method: RegField::MakeAMask
 * Purpose: Computes a mask used to isolate a field withing a register based
 *   on the width of a field
 */
inline DWORD RegField::MakeAMask()
{
//   compute the mask to apply to the owner register to reset
//   all bits that are part of a field. Mask is based on the size of a field
   return ::MakeAMask( FieldWidth_ );
}

/* Method: RegField::operator DWORD()
 * Purpose: Performs the read from a field of register
*/
RegField::operator DWORD()
{
   // if write-only, get the shadow
   if ( GetRegisterType() == WO )
      return GetShadow();

   // for RO and RW do the actual read
   // get the register data and move it to the right position
   DWORD dwValue = ( Owner_ >> StartBit_ );

   DWORD dwMask = MakeAMask();

   return dwValue & dwMask;
}


/* Method: RegField::operator=
 * Purpose: performs the assignment to a field of register
 * Note:
   This function computes the mask to apply to the owner register to reset
   all bits that are part of a field. Mask is based on the start position and size
   Then it calculates the proper value from the passed argument ( moves the size
   number of bits to the starting position ) and ORs these bits in the owner register.
*/
DWORD RegField::operator=( DWORD dwValue )
{
// if a register is read-only nothing is done. This is an error
   if ( GetRegisterType() == RO )
      return ReturnAllFs();

   SetShadow( dwValue );

   // get a mask
   DWORD dwMask = MakeAMask();

   // move mask to a proper position
   dwMask = dwMask << StartBit_;

//   calculate the proper value from the passed argument ( move the size
//   number of bits to the starting position )
   DWORD dwFieldValue = dwValue << StartBit_;
   dwFieldValue &= dwMask;

   // do not perform intermediate steps on the owner; rather use a temp and update
   // the owner at once
   DWORD dwRegContent = Owner_;

   // reset the relevant bits
   if ( GetRegisterType() == RR )
      dwRegContent = 0;
   else
      dwRegContent &= ~dwMask;

   // OR these bits in the owner register.
   dwRegContent |= dwFieldValue;

   Owner_ = dwRegContent;
   return dwValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\register.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Register.cpp 1.3 1998/04/29 22:43:36 tomz Exp $

#include "register.h"

/* Method: Register::operator DWORD()
 * Purpose: a dummy function. Always returns -1
*/
Register::operator DWORD()
{
   return ReturnAllFs();
}


/* Method: Register::operator=
 * Purpose: a dummy function. Does not perform an assignment. Always returns -1
*/
DWORD Register::operator=( DWORD )
{
   return ReturnAllFs();
}

/* Method: RegisterB::operator DWORD()
 * Purpose: Performs the read from a byte register
*/
RegisterB::operator DWORD()
{
   // if write-only return the shadow
   if ( GetRegisterType() == WO )
      return GetShadow();

   // for RO and RW do the actual read
   LPBYTE pRegAddr = GetBaseAddress() + GetOffset();
   return READ_REGISTER_UCHAR( pRegAddr );
}


/* Method: RegisterB::operator=
 * Purpose: performs the assignment to a byte register
*/
DWORD RegisterB::operator=( DWORD dwValue )
{
// if a register is read-only nothing is done. This is an error
   if ( GetRegisterType() == RO )
      return ReturnAllFs();

   // keep a shadow around
   SetShadow( dwValue );

   LPBYTE pRegAddr = GetBaseAddress() + GetOffset();
   WRITE_REGISTER_UCHAR( pRegAddr, (BYTE)dwValue );

   return dwValue;
}

/* Method: RegisterW::operator DWORD()
 * Purpose: Performs the read from a word register
*/
RegisterW::operator DWORD()
{
   // if write-only return the shadow
   if ( GetRegisterType() == WO )
      return GetShadow();

   // for RO and RW do the actual read
   LPWORD pRegAddr = (LPWORD)( GetBaseAddress() + GetOffset() );
   return READ_REGISTER_USHORT( pRegAddr );
}


/* Method: RegisterW::operator=
 * Purpose: performs the assignment to a word register
*/
DWORD RegisterW::operator=( DWORD dwValue )
{
// if a register is read-only nothing is done. This is an error
   if ( GetRegisterType() == RO )
      return ReturnAllFs();

   // keep a shadow around
   SetShadow( dwValue );

   LPWORD pRegAddr = (LPWORD)( GetBaseAddress() + GetOffset() );
   *pRegAddr = (WORD)dwValue;
   WRITE_REGISTER_USHORT( pRegAddr, (WORD)dwValue );

   return dwValue;
}

/* Method: RegisterDW::operator DWORD()
 * Purpose: Performs the read from a dword register
*/
RegisterDW::operator DWORD()
{
   // if write-only return the shadow
   if ( GetRegisterType() == WO )
      return GetShadow();

   // for RO and RW do the actual read
   LPDWORD pRegAddr = (LPDWORD)( GetBaseAddress() + GetOffset() );
   return READ_REGISTER_ULONG( pRegAddr );
}


/* Method: RegisterDW::operator=
 * Purpose: performs the assignment to a dword register
*/
DWORD RegisterDW::operator=( DWORD dwValue )
{
// if a register is read-only nothing is done. This is an error
   if ( GetRegisterType() == RO )
      return ReturnAllFs();

   // keep a shadow around
   SetShadow( dwValue );

   LPDWORD pRegAddr = (LPDWORD)( GetBaseAddress() + GetOffset() );
   WRITE_REGISTER_ULONG( pRegAddr, dwValue );
   return dwValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\retcode.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Retcode.h 1.3 1998/04/29 22:43:37 tomz Exp $

#ifndef __RETCODE_H
#define __RETCODE_H

/* Type: ErrorCode
 * Purpose: Defines the error codes
 */
typedef enum { Success, Fail } ErrorCode;
#define ERROR_CODE_DEFINED



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\rgb16fmt.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Rgb16fmt.h 1.5 1998/04/29 22:43:37 tomz Exp $

#ifndef __RGB16FMT_H
#define __RGB16FMT_H

#ifndef __DEFAULTS_H
#include "defaults.h"
#endif

KS_DATARANGE_VIDEO StreamFormatRGB555 =
{
   // KSDATARANGE
   {
      {
         sizeof( KS_DATARANGE_VIDEO ),
         0,
         DefWidth * DefHeight * 2,               // SampleSize
         0,                                      // Reserved
         { 0x73646976, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } }, //MEDIATYPE_Video
         { 0xe436eb7c, 0x524f, 0x11ce, { 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70 } }, //MEDIASUBTYPE_RGB555,
         { 0x05589f80, 0xc356, 0x11ce, { 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a } }  //FORMAT_VideoInfo
      }
   },
   true,    // BOOL,  bFixedSizeSamples (all samples same size?)
   true,    // BOOL,  bTemporalCompression (all I frames?)
   KS_VIDEOSTREAM_PREVIEW, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
   0,       // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

   // _KS_VIDEO_STREAM_CONFIG_CAPS
   {
      { STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO }, // GUID
      KS_AnalogVideo_NTSC_M,                       // AnalogVideoStandard
      {
         MaxInWidth, MaxInHeight   // SIZE InputSize
      },
      {
         MinInWidth, MinInHeight   // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
      },
      {
         MaxInWidth, MaxInHeight   // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
      },
      2,           // int CropGranularityX;       // granularity of cropping size
      2,           // int CropGranularityY;
      2,           // int CropAlignX;             // alignment of cropping rect
      2,           // int CropAlignY;
      {
         MinOutWidth, MinOutHeight   // SIZE MinOutputSize;         // smallest bitmap stream can produce
      },
      {
         MaxOutWidth, MaxOutHeight   // SIZE MaxOutputSize;         // largest  bitmap stream can produce
      },
      1,          // int OutputGranularityX;     // granularity of output bitmap size
      1,          // int OutputGranularityY;
      0,          // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
      0,          // StretchTapsY
      2,          // ShrinkTapsX
      2,          // ShrinkTapsY
      333667,     // LONGLONG MinFrameInterval;  // 100 nS units
      333667,     // LONGLONG MaxFrameInterval;
      2 * 30 * MinOutWidth * MinOutHeight,  // LONG MinBitsPerSecond;
      2 * 30 * MaxOutWidth * MaxOutHeight   //LONG MaxBitsPerSecond;
   },

   // KS_VIDEOINFOHEADER (default format)
   {
      { 0,0,0,0 },    //    RECT            rcSource;          // The bit we really want to use
      { 0,0,0,0 },    //    RECT            rcTarget;          // Where the video should go
      DefWidth * DefHeight * 2 * 30L,  //    DWORD     dwBitRate;         // Approximate bit data rate
      0L,                        //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
      333667,                    //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

      {
         sizeof( KS_BITMAPINFOHEADER ), //    DWORD      biSize;
         DefWidth,                   //    LONG       biWidth;
         DefHeight,                  //    LONG       biHeight;
         1,                          //    WORD       biPlanes;
         16,                         //    WORD       biBitCount;
         KS_BI_RGB,                  //    DWORD      biCompression;
         DefWidth * DefHeight * 2,   //    DWORD      biSizeImage;
         0,                          //    LONG       biXPelsPerMeter;
         0,                          //    LONG       biYPelsPerMeter;
         0,                          //    DWORD      biClrUsed;
         0                           //    DWORD      biClrImportant;
      }
   }
};

KS_DATARANGE_VIDEO2 StreamFormat2RGB555 =
{
   // KSDATARANGE
   {
      {
         sizeof( KS_DATARANGE_VIDEO2 ),
         0,
         DefWidth * DefHeight * 2,               // SampleSize
         0,                                      // Reserved
         { 0x73646976, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } }, //MEDIATYPE_Video
         { 0xe436eb7c, 0x524f, 0x11ce, { 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70 } }, //MEDIASUBTYPE_RGB555,
         { 0xf72a76A0, 0xeb0a, 0x11d0, { 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba } }  //FORMAT_VideoInfo2
      }
   },
   true,    // BOOL,  bFixedSizeSamples (all samples same size?)
   true,    // BOOL,  bTemporalCompression (all I frames?)
   KS_VIDEOSTREAM_PREVIEW, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
   0,       // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

   // _KS_VIDEO_STREAM_CONFIG_CAPS
   {
      { STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO2 }, // GUID
      KS_AnalogVideo_NTSC_M,                       // AnalogVideoStandard
      {
         MaxInWidth, MaxInHeight   // SIZE InputSize
      },
      {
         MinInWidth, MinInHeight   // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
      },
      {
         MaxInWidth, MaxInHeight   // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
      },
      2,           // int CropGranularityX;       // granularity of cropping size
      2,           // int CropGranularityY;
      2,           // int CropAlignX;             // alignment of cropping rect
      2,           // int CropAlignY;
      {
         MinOutWidth, MinOutHeight   // SIZE MinOutputSize;         // smallest bitmap stream can produce
      },
      {
         MaxOutWidth, MaxOutHeight   // SIZE MaxOutputSize;         // largest  bitmap stream can produce
      },
      1,          // int OutputGranularityX;     // granularity of output bitmap size
      1,          // int OutputGranularityY;
      0,          // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
      0,          // StretchTapsY
      2,          // ShrinkTapsX
      2,          // ShrinkTapsY
      333667,     // LONGLONG MinFrameInterval;  // 100 nS units
      333667,     // LONGLONG MaxFrameInterval;
      2 * 30 * MinOutWidth * MinOutHeight,  // LONG MinBitsPerSecond;
      2 * 30 * MaxOutWidth * MaxOutHeight   //LONG MaxBitsPerSecond;
   },

   // KS_VIDEOINFOHEADER2 (default format)
   {
      { 0,0,0,0 },    //    RECT            rcSource;          // The bit we really want to use
      { 0,0,0,0 },    //    RECT            rcTarget;          // Where the video should go
      DefWidth * DefHeight * 2 * 30L,  //    DWORD     dwBitRate;         // Approximate bit data rate
      0L,                        //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
      333667,                    //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)
#if 0
		//TODO: video memory must be available for interlacing to work
		KS_INTERLACE_IsInterlaced |		//		DWORD		dwInterlaceFlags
#else
			KS_INTERLACE_1FieldPerSample 
			//| KS_INTERLACE_Field1First
			//| KS_INTERLACE_FieldPatField1Only
			| KS_INTERLACE_FieldPatBothRegular
			| KS_INTERLACE_DisplayModeBobOnly,
			//| KS_INTERLACE_DisplayModeBobOrWeave,
#endif
											//		use AMINTERLACE_* defines. Reject connection if undefined bits are not 0   		
											//		AMINTERLACE_IsInterlaced            
											//		AMINTERLACE_1FieldPerSample         
											//		AMINTERLACE_Field1First             
											//		AMINTERLACE_UNUSED                  
											//		AMINTERLACE_FieldPatternMask        
											//		AMINTERLACE_FieldPatField1Only      
											//		AMINTERLACE_FieldPatField2Only      
											//		AMINTERLACE_FieldPatBothRegular     
											//		AMINTERLACE_FieldPatBothIrregular   
											//		AMINTERLACE_DisplayModeMask         
											//		AMINTERLACE_DisplayModeBobOnly      
											//		AMINTERLACE_DisplayModeWeaveOnly    
											//		AMINTERLACE_DisplayModeBobOrWeave 
											//
		0,									//		DWORD		dwCopyProtectFlags
											//		use AMCOPYPROTECT_* defines. Reject connection if undefined bits are not 0 
											//		AMCOPYPROTECT_RestrictDuplication
											//
		4,									//		DWORD		dwPictAspectRatioX
											//		X dimension of picture aspect ratio, e.g. 16 for 16x9 display
											//
		3,									//		DWORD		dwPictAspectRatioY
											//		Y dimension of picture aspect ratio, e.g.  9 for 16x9 display
		0,									//		DWORD		dwReserved1
		0,									//		DWORD		dwReserved2


      {
         sizeof( KS_BITMAPINFOHEADER ), //    DWORD      biSize;
         DefWidth,                   //    LONG       biWidth;
         DefHeight,                  //    LONG       biHeight;
         1,                          //    WORD       biPlanes;
         16,                         //    WORD       biBitCount;
         KS_BI_RGB,                  //    DWORD      biCompression;
         DefWidth * DefHeight * 2,   //    DWORD      biSizeImage;
         0,                          //    LONG       biXPelsPerMeter;
         0,                          //    LONG       biYPelsPerMeter;
         0,                          //    DWORD      biClrUsed;
         0                           //    DWORD      biClrImportant;
      }
   }
};

KS_DATARANGE_VIDEO StreamFormatRGB555Cap =
{
   // KSDATARANGE
   {
      {
         sizeof( KS_DATARANGE_VIDEO ),
         0,
         DefWidth * DefHeight * 2,               // SampleSize
         0,                                      // Reserved
         { 0x73646976, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } }, //MEDIATYPE_Video
         { 0xe436eb7c, 0x524f, 0x11ce, { 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70 } }, //MEDIASUBTYPE_RGB555,
         { 0x05589f80, 0xc356, 0x11ce, { 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a } }  //FORMAT_VideoInfo
      }
   },
   true,    // BOOL,  bFixedSizeSamples (all samples same size?)
   true,    // BOOL,  bTemporalCompression (all I frames?)
   KS_VIDEOSTREAM_CAPTURE, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
   0,       // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

   // _KS_VIDEO_STREAM_CONFIG_CAPS
   {
      { STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO }, // GUID
      KS_AnalogVideo_NTSC_M,                       // AnalogVideoStandard
      {
         MaxInWidth, MaxInHeight   // SIZE InputSize
      },
      {
         MinInWidth, MinInHeight   // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
      },
      {
         MaxInWidth, MaxInHeight   // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
      },
      2,           // int CropGranularityX;       // granularity of cropping size
      2,           // int CropGranularityY;
      2,           // int CropAlignX;             // alignment of cropping rect
      2,           // int CropAlignY;
      {
         MinOutWidth, MinOutHeight   // SIZE MinOutputSize;         // smallest bitmap stream can produce
      },
      {
         MaxOutWidth, MaxOutHeight   // SIZE MaxOutputSize;         // largest  bitmap stream can produce
      },
      1,          // int OutputGranularityX;     // granularity of output bitmap size
      1,          // int OutputGranularityY;
      0,          // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
      0,          // StretchTapsY
      2,          // ShrinkTapsX 
      2,          // ShrinkTapsY
      333667,     // LONGLONG MinFrameInterval;  // 100 nS units
      333667,     // LONGLONG MaxFrameInterval;
      2 * 30 * MinOutWidth * MinOutHeight,  // LONG MinBitsPerSecond;
      2 * 30 * MaxOutWidth * MaxOutHeight   //LONG MaxBitsPerSecond;
   },

   // KS_VIDEOINFOHEADER (default format)
   {
      { 0,0,0,0 },    //    RECT            rcSource;          // The bit we really want to use
      { 0,0,0,0 },    //    RECT            rcTarget;          // Where the video should go
      DefWidth * DefHeight * 2 * 30L,  //    DWORD     dwBitRate;         // Approximate bit data rate
      0L,                        //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
      333667,                    //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

      {
         sizeof( KS_BITMAPINFOHEADER ), //    DWORD      biSize;
         640,//DefWidth,                   //    LONG       biWidth;
         480,//DefHeight,                  //    LONG       biHeight;
         1,                          //    WORD       biPlanes;
         16,                         //    WORD       biBitCount;
         KS_BI_RGB,                  //    DWORD      biCompression;
         640 * 480 * 2,   //    DWORD      biSizeImage;
//         DefWidth * DefHeight * 2,   //    DWORD      biSizeImage;
         0,                          //    LONG       biXPelsPerMeter;
         0,                          //    LONG       biYPelsPerMeter;
         0,                          //    DWORD      biClrUsed;
         0                           //    DWORD      biClrImportant;
      }
   }
};

KS_DATARANGE_VIDEO StreamFormatRGB565 =
{
   // KSDATARANGE
   {
      {
         sizeof( KS_DATARANGE_VIDEO ),
         0,
         DefWidth * DefHeight * 2,               // SampleSize
         0,                                      // Reserved
         { 0x73646976, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } }, //MEDIATYPE_Video
         { 0xe436eb7b, 0x524f, 0x11ce, { 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70 } }, //MEDIASUBTYPE_RGB565,
         { 0x05589f80, 0xc356, 0x11ce, { 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a } }  //FORMAT_VideoInfo
      }
   },
   true,    // BOOL,  bFixedSizeSamples (all samples same size?)
   true,    // BOOL,  bTemporalCompression (all I frames?)
   KS_VIDEOSTREAM_PREVIEW, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
   0,       // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

   // _KS_VIDEO_STREAM_CONFIG_CAPS
   {
      { STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO }, // GUID
      KS_AnalogVideo_NTSC_M,                       // AnalogVideoStandard
      {
         MaxInWidth, MaxInHeight   // SIZE InputSize
      },
      {
         MinInWidth, MinInHeight   // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
      },
      {
         MaxInWidth, MaxInHeight   // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
      },
      2,           // int CropGranularityX;       // granularity of cropping size
      2,           // int CropGranularityY;
      2,           // int CropAlignX;             // alignment of cropping rect
      2,           // int CropAlignY;
      {
         MinOutWidth, MinOutHeight   // SIZE MinOutputSize;         // smallest bitmap stream can produce
      },
      {
         MaxOutWidth, MaxOutHeight   // SIZE MaxOutputSize;         // largest  bitmap stream can produce
      },
      1,          // int OutputGranularityX;     // granularity of output bitmap size
      1,          // int OutputGranularityY;
      0,          // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
      0,          // StretchTapsY
      2,          // ShrinkTapsX
      2,          // ShrinkTapsY
      333667,     // LONGLONG MinFrameInterval;  // 100 nS units
      333667,     // LONGLONG MaxFrameInterval;
      2 * 30 * MinOutWidth * MinOutHeight,  // LONG MinBitsPerSecond;
      2 * 30 * MaxOutWidth * MaxOutHeight   //LONG MaxBitsPerSecond;
   },

   // KS_VIDEOINFOHEADER (default format)
   {
      { 0,0,0,0 },    //    RECT            rcSource;          // The bit we really want to use
      { 0,0,0,0 },    //    RECT            rcTarget;          // Where the video should go
      DefWidth * DefHeight * 2 * 30L,  //    DWORD     dwBitRate;         // Approximate bit data rate
      0L,                        //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
      333667,                    //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

      {
         sizeof( KS_BITMAPINFOHEADER ), //    DWORD      biSize;
         DefWidth,                   //    LONG       biWidth;
         DefHeight,                  //    LONG       biHeight;
         1,                          //    WORD       biPlanes;
         16,                         //    WORD       biBitCount;
         0xe436eb7b,                 //    DWORD      biCompression;
         DefWidth * DefHeight * 2,   //    DWORD      biSizeImage;
         0,                          //    LONG       biXPelsPerMeter;
         0,                          //    LONG       biYPelsPerMeter;
         0,                          //    DWORD      biClrUsed;
         0                           //    DWORD      biClrImportant;
      }
   }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\rgb24fmt.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Rgb24fmt.h 1.5 1998/04/29 22:43:37 tomz Exp $

#ifndef __RGB24FMT_H
#define __RGB24FMT_H

#ifndef __DEFAULTS_H
#include "defaults.h"
#endif


KS_DATARANGE_VIDEO StreamFormatRGB24Bpp =
{
   // KSDATARANGE
   {
      {
         sizeof( KS_DATARANGE_VIDEO ),
         0,
         DefWidth * DefHeight * 3,               // SampleSize
         0,                                      // Reserved
         { STATIC_KSDATAFORMAT_TYPE_VIDEO },
         { 0xe436eb7d, 0x524f, 0x11ce, { 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70 } }, //MEDIASUBTYPE_RGB24,
         { STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO }
      }
   },
   true,
   true,
   KS_VIDEOSTREAM_PREVIEW, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
   0,       // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

   // _KS_VIDEO_STREAM_CONFIG_CAPS
   {
      { STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO }, // GUID
      KS_AnalogVideo_NTSC_M,                       // AnalogVideoStandard
      {
         MaxInWidth, MaxInHeight   // SIZE InputSize
      },
      {
         MinInWidth, MinInHeight   // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
      },
      {
         MaxInWidth, MaxInHeight   // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
      },
      2,           // int CropGranularityX;       // granularity of cropping size
      2,           // int CropGranularityY;
      2,           // int CropAlignX;             // alignment of cropping rect
      2,           // int CropAlignY;
      {
         MinOutWidth, MinOutHeight   // SIZE MinOutputSize;  smallest bitmap stream can produce
      },
      {
         MaxOutWidth, MaxOutHeight   // SIZE MaxOutputSize;  largest  bitmap stream can produce
      },
      2,          // int OutputGranularityX;     // granularity of output bitmap size
      2,          // int OutputGranularityY;
      0,          // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
      0,          // StretchTapsY
      2,          // ShrinkTapsX
      2,          // ShrinkTapsY
      333667,     // LONGLONG MinFrameInterval;  // 100 nS units
      333667,     // LONGLONG MaxFrameInterval;
      3 * 30 * MinOutWidth * MinOutHeight,// LONG MinBitsPerSecond;
      3 * 30 * MaxOutWidth * MaxOutHeight //LONG MaxBitsPerSecond;
   },

   // KS_VIDEOINFOHEADER (default format)
   {
      { 0,0,0,0 },  //    RECT            rcSource;          // The bit we really want to use
      { 0,0,0,0 },  //    RECT            rcTarget;          // Where the video should go
      DefWidth * DefHeight * 3 * 30L,      //    DWORD           dwBitRate;         // Approximate bit data rate
      0L,           //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
      333667,       //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)
      {
         sizeof( KS_BITMAPINFOHEADER ), //    DWORD      biSize;
         DefWidth,                   //    LONG       biWidth;
         DefHeight,                  //    LONG       biHeight;
         1,                          //    WORD       biPlanes;
         24,                         //    WORD       biBitCount;
         KS_BI_RGB,                  //    DWORD      biCompression;
         DefWidth * DefHeight * 3,   //    DWORD      biSizeImage;
         0,                          //    LONG       biXPelsPerMeter;
         0,                          //    LONG       biYPelsPerMeter;
         0,                          //    DWORD      biClrUsed;
         0                           //    DWORD      biClrImportant;
      }
   }
};

KS_DATARANGE_VIDEO2 StreamFormat2RGB24Bpp =
{
   // KSDATARANGE
   {
      {
         sizeof( KS_DATARANGE_VIDEO2 ),
         0,
         DefWidth * DefHeight * 3,               // SampleSize
         0,                                      // Reserved
         { STATIC_KSDATAFORMAT_TYPE_VIDEO },
         { 0xe436eb7d, 0x524f, 0x11ce, { 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70 } }, //MEDIASUBTYPE_RGB24,
         { STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO2 }
      }
   },
   true,
   true,
   KS_VIDEOSTREAM_PREVIEW, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
   0,       // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

   // _KS_VIDEO_STREAM_CONFIG_CAPS
   {
      { STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO2 }, // GUID
      KS_AnalogVideo_NTSC_M,                       // AnalogVideoStandard
      {
         MaxInWidth, MaxInHeight   // SIZE InputSize
      },
      {
         MinInWidth, MinInHeight   // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
      },
      {
         MaxInWidth, MaxInHeight   // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
      },
      2,           // int CropGranularityX;       // granularity of cropping size
      2,           // int CropGranularityY;
      2,           // int CropAlignX;             // alignment of cropping rect
      2,           // int CropAlignY;
      {
         MinOutWidth, MinOutHeight   // SIZE MinOutputSize;  smallest bitmap stream can produce
      },
      {
         MaxOutWidth, MaxOutHeight   // SIZE MaxOutputSize;  largest  bitmap stream can produce
      },
      2,          // int OutputGranularityX;     // granularity of output bitmap size
      2,          // int OutputGranularityY;
      0,          // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
      0,          // StretchTapsY
      2,          // ShrinkTapsX
      2,          // ShrinkTapsY
      333667,     // LONGLONG MinFrameInterval;  // 100 nS units
      333667,     // LONGLONG MaxFrameInterval;
      3 * 30 * MinOutWidth * MinOutHeight,// LONG MinBitsPerSecond;
      3 * 30 * MaxOutWidth * MaxOutHeight //LONG MaxBitsPerSecond;
   },

   // KS_VIDEOINFOHEADER2 (default format)
   {
      { 0,0,0,0 },  //    RECT            rcSource;          // The bit we really want to use
      { 0,0,0,0 },  //    RECT            rcTarget;          // Where the video should go
      DefWidth * DefHeight * 3 * 30L,      //    DWORD           dwBitRate;         // Approximate bit data rate
      0L,           //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
      333667,       //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)
#if 0
		//TODO: video memory must be available for interlacing to work
		KS_INTERLACE_IsInterlaced |		//		DWORD		dwInterlaceFlags
#else
			KS_INTERLACE_1FieldPerSample 
			//| KS_INTERLACE_Field1First
			//| KS_INTERLACE_FieldPatField1Only
			| KS_INTERLACE_FieldPatBothRegular
			| KS_INTERLACE_DisplayModeBobOnly,
			//| KS_INTERLACE_DisplayModeBobOrWeave,
#endif
											//		use AMINTERLACE_* defines. Reject connection if undefined bits are not 0   		
											//		AMINTERLACE_IsInterlaced            
											//		AMINTERLACE_1FieldPerSample         
											//		AMINTERLACE_Field1First             
											//		AMINTERLACE_UNUSED                  
											//		AMINTERLACE_FieldPatternMask        
											//		AMINTERLACE_FieldPatField1Only      
											//		AMINTERLACE_FieldPatField2Only      
											//		AMINTERLACE_FieldPatBothRegular     
											//		AMINTERLACE_FieldPatBothIrregular   
											//		AMINTERLACE_DisplayModeMask         
											//		AMINTERLACE_DisplayModeBobOnly      
											//		AMINTERLACE_DisplayModeWeaveOnly    
											//		AMINTERLACE_DisplayModeBobOrWeave 
											//
		0,									//		DWORD		dwCopyProtectFlags
											//		use AMCOPYPROTECT_* defines. Reject connection if undefined bits are not 0 
											//		AMCOPYPROTECT_RestrictDuplication
											//
		4,									//		DWORD		dwPictAspectRatioX
											//		X dimension of picture aspect ratio, e.g. 16 for 16x9 display
											//
		3,									//		DWORD		dwPictAspectRatioY
											//		Y dimension of picture aspect ratio, e.g.  9 for 16x9 display
		0,									//		DWORD		dwReserved1
		0,									//		DWORD		dwReserved2


      {
         sizeof( KS_BITMAPINFOHEADER ), //    DWORD      biSize;
         DefWidth,                   //    LONG       biWidth;
         DefHeight,                  //    LONG       biHeight;
         1,                          //    WORD       biPlanes;
         24,                         //    WORD       biBitCount;
         KS_BI_RGB,                  //    DWORD      biCompression;
         DefWidth * DefHeight * 3,   //    DWORD      biSizeImage;
         0,                          //    LONG       biXPelsPerMeter;
         0,                          //    LONG       biYPelsPerMeter;
         0,                          //    DWORD      biClrUsed;
         0                           //    DWORD      biClrImportant;
      }
   }
};

KS_DATARANGE_VIDEO StreamFormatRGB24Bpp_Capture =
{
   // KSDATARANGE
   {
      {
         sizeof( KS_DATARANGE_VIDEO ),
         0,
         DefWidth * DefHeight * 3,               // SampleSize
         0,                                      // Reserved
         { STATIC_KSDATAFORMAT_TYPE_VIDEO },
         { 0xe436eb7d, 0x524f, 0x11ce, { 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70 } }, //MEDIASUBTYPE_RGB24,
         { STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO }
      }
   },
   true,
   true,
   KS_VIDEOSTREAM_CAPTURE, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
   0,       // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

   // _KS_VIDEO_STREAM_CONFIG_CAPS
   {
      { STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO }, // GUID
      KS_AnalogVideo_NTSC_M,                       // AnalogVideoStandard
      {
         MaxInWidth, MaxInHeight   // SIZE InputSize
      },
      {
         MinInWidth, MinInHeight   // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
      },
      {
         MaxInWidth, MaxInHeight   // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
      },
      2,           // int CropGranularityX;       // granularity of cropping size
      2,           // int CropGranularityY;
      2,           // int CropAlignX;             // alignment of cropping rect
      2,           // int CropAlignY;
      {
         MinOutWidth, MinOutHeight   // SIZE MinOutputSize;  smallest bitmap stream can produce
      },
      {
         MaxOutWidth, MaxOutHeight   // SIZE MaxOutputSize;  largest  bitmap stream can produce
      },
      2,          // int OutputGranularityX;     // granularity of output bitmap size
      2,          // int OutputGranularityY;
      0,          // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
      0,          // StretchTapsY
      2,          // ShrinkTapsX
      2,          // ShrinkTapsY
      333667,     // LONGLONG MinFrameInterval;  // 100 nS units
      333667,     // LONGLONG MaxFrameInterval;
      3 * 30 * MinOutWidth * MinOutHeight,// LONG MinBitsPerSecond;
      3 * 30 * MaxOutWidth * MaxOutHeight //LONG MaxBitsPerSecond;
   },

   // KS_VIDEOINFOHEADER (default format)
   {
      { 0,0,0,0 },  //    RECT            rcSource;          // The bit we really want to use
      { 0,0,0,0 },  //    RECT            rcTarget;          // Where the video should go
      DefWidth * DefHeight * 3 * 30L,      //    DWORD           dwBitRate;         // Approximate bit data rate
      0L,           //    DWORD           dwBitErrorRate;    // Bit error rate for this stream
      333667,       //    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)
      {
         sizeof( KS_BITMAPINFOHEADER ), //    DWORD      biSize;
         DefWidth,                   //    LONG       biWidth;
         DefHeight,                  //    LONG       biHeight;
         1,                          //    WORD       biPlanes;
         24,                         //    WORD       biBitCount;
         KS_BI_RGB,                  //    DWORD      biCompression;
         DefWidth * DefHeight * 3,   //    DWORD      biSizeImage;
         0,                          //    LONG       biXPelsPerMeter;
         0,                          //    LONG       biYPelsPerMeter;
         0,                          //    DWORD      biClrUsed;
         0                           //    DWORD      biClrImportant;
      }
   }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\registry.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Registry.cpp 1.7 1998/05/07 15:24:55 tomz Exp $

extern "C" {
#include <strmini.h>
}
#include "device.h"

//LONG  PsDevice::PinTypes_ [MaxInpPins]; // just allocate maximum possible
//DWORD PsDevice::xtals_ [2]; // no more than 2 xtals

/*++

Routine Description:

    Reads the specified registry value

Arguments:

    Handle - handle to the registry key
    KeyNameString - value to read
    KeyNameStringLength - length of string
    Data - buffer to read data into
    DataLength - length of data buffer

Return Value:

    NTSTATUS returned as appropriate

--*/
NTSTATUS GetRegistryValue( IN HANDLE Handle, IN const PUNICODE_STRING KeyName,
   IN PCHAR Data, IN ULONG DataLength )
{
   NTSTATUS        Status = STATUS_INSUFFICIENT_RESOURCES;
   ULONG           Length;
   PKEY_VALUE_FULL_INFORMATION FullInfo;

   Length = sizeof( KEY_VALUE_FULL_INFORMATION ) + DataLength + KeyName->MaximumLength;

   FullInfo = (struct _KEY_VALUE_FULL_INFORMATION *)ExAllocatePool(PagedPool, Length);

   if ( FullInfo ) {
      Status = ZwQueryValueKey( Handle, KeyName, KeyValueFullInformation,
         FullInfo, Length, &Length );

      if ( NT_SUCCESS( Status ) ) {

         if ( DataLength >= FullInfo->DataLength ) {
            RtlCopyMemory( Data, ((PUCHAR) FullInfo) + FullInfo->DataOffset,
               FullInfo->DataLength );

         } else {
            Status = STATUS_BUFFER_TOO_SMALL;
         }                   // buffer right length
     }                       // if success
     ExFreePool( FullInfo );
   }                           // if fullinfo
   return Status;
}

/* Function: OpenDriverKey
 * Purpose: Opens the DriverData key off the main driver key
 * Input: PhysicalDeviceObject : DEVICE_OBJECT *
 * Output: Open key handle or NULL
 */
HANDLE OpenDriverKey( IN PDEVICE_OBJECT PhysicalDeviceObject )
{
   NTSTATUS   Status;
   HANDLE     DevHandle;

   Status = IoOpenDeviceRegistryKey( PhysicalDeviceObject, PLUGPLAY_REGKEY_DRIVER,
      STANDARD_RIGHTS_ALL, &DevHandle );

   HANDLE KeyHandle = NULL;
   if ( NT_SUCCESS( Status ) ) {
      OBJECT_ATTRIBUTES attr;
      UNICODE_STRING UDevDataName;
      PWCHAR WDataName = L"DriverData";

      RtlInitUnicodeString( &UDevDataName, WDataName );
      InitializeObjectAttributes( &attr, &UDevDataName, OBJ_INHERIT, DevHandle,
         NULL );

      ZwOpenKey( &KeyHandle, KEY_QUERY_VALUE, &attr );
      ZwClose( DevHandle );
   }
   return KeyHandle;
}
/* Function: PrepareKeyName
 * Purpose: Creates a UNICODE name for a key
 * Parameters: UKeyName: UNICODE_STRING * - key will be created here
 *   name: PCHAR - regular "C" string
 *   idx: int - number to append to the name
 * Note: this function is useful in creating numbered key names
 */
inline void PrepareKeyName( PUNICODE_STRING UKeyName, PCHAR name, int idx )
{
   char buf [80];
   ANSI_STRING  AKeyName;

   if ( idx == -1 )
   {
      RtlInitAnsiString( &AKeyName, name );
   }
   else
   {
      sprintf( buf, "%s%d", name, idx );
      RtlInitAnsiString( &AKeyName, buf );
   }

   RtlAnsiStringToUnicodeString( UKeyName, &AKeyName, TRUE );
}

/*++

Routine Description:

    Reads the XBAR registry values for the device

Arguments:

    PhysicalDeviceObject - pointer to the PDO

Return Value:

     None.

--*/
void ReadXBarRegistryValues( IN PDEVICE_OBJECT PhysicalDeviceObject )
{
   HANDLE KeyHandle = OpenDriverKey( PhysicalDeviceObject );

   if ( KeyHandle ) {

      for ( int i = 0; i < MaxInpPins; i++ ) {

         UNICODE_STRING  UKeyName;

         PrepareKeyName( &UKeyName, "XBarInPin", i );

         CHAR buf [10];

         NTSTATUS   Status;
         Status = GetRegistryValue( KeyHandle, &UKeyName, buf, sizeof( buf ) );

         RtlFreeUnicodeString( &UKeyName );

         if ( NT_SUCCESS(Status ) ) {
            DebugOut((1, "ReadRegistry %d\n", i ) );
            PinTypes_ [i] = *(PDWORD)buf;
         } else
            PinTypes_ [i] = -1;
     }
     ZwClose( KeyHandle );
   } else { // just use some default to make life eaiser for the xbar code
      PinTypes_ [0] = KS_PhysConn_Video_SVideo;
      PinTypes_ [1] = KS_PhysConn_Video_Tuner;
      PinTypes_ [2] = KS_PhysConn_Video_Composite;
      PinTypes_ [3] = KS_PhysConn_Audio_Tuner;
   }
}

/* Method: ReadXTalRegistryValues
 * Purpose: Obtains number and types of the crystals for this device
 * Input: DEVICE_OBJECT *
 * Output: None
 */
void ReadXTalRegistryValues( IN PDEVICE_OBJECT PhysicalDeviceObject )
{
   HANDLE KeyHandle = OpenDriverKey( PhysicalDeviceObject );

   if ( KeyHandle ) {

      for ( int i = 0; i < 2; i++ ) {

         UNICODE_STRING  UKeyName;

         PrepareKeyName( &UKeyName, "XTal", i );

         CHAR buf [10];

         NTSTATUS   Status;
         Status = GetRegistryValue( KeyHandle, &UKeyName, buf, sizeof( buf ) );

         RtlFreeUnicodeString( &UKeyName );

         if ( NT_SUCCESS(Status ) ) {
            DebugOut((1, "Got Xtal %d\n", i ) );
            xtals_ [i] = *(PDWORD)buf;
         } else
            xtals_ [i] = 28; // is this a good default ? :0)
     }
     ZwClose( KeyHandle );
   } else  // just use some default to make life eaiser for the xbar code
      xtals_ [0] = 28; // default to NTSC only
}

TUNER_INFO TunerInfo;

void DumpTunerInfo( TUNER_INFO * pTunerInfo )
{
   DUMPX( pTunerInfo->TunerBrand );
   DUMPX( pTunerInfo->TunerI2CAddress );
   DUMPX( pTunerInfo->TunerBandCtrlLow );
   DUMPX( pTunerInfo->TunerBandCtrlMid );
   DUMPX( pTunerInfo->TunerBandCtrlHigh );
}

void ReadTunerRegistryValues( IN PDEVICE_OBJECT PhysicalDeviceObject )
{
   HANDLE KeyHandle = OpenDriverKey( PhysicalDeviceObject );

   if ( KeyHandle )
   {

      CHAR buf [10];
      NTSTATUS   Status;
      UNICODE_STRING  UKeyName;
      BOOL bSuccess = TRUE;

      PrepareKeyName( &UKeyName, "TunerBrand", -1 );
      Status = GetRegistryValue( KeyHandle, &UKeyName, buf, sizeof( buf ) );
      if ( bSuccess = NT_SUCCESS(Status ) )
      {
         TunerInfo.TunerBrand = *(PDWORD)buf;

         PrepareKeyName( &UKeyName, "TunerI2CAddress", -1 );
         Status = GetRegistryValue( KeyHandle, &UKeyName, buf, sizeof( buf ) );
         if ( bSuccess = NT_SUCCESS(Status ) ) {
            TunerInfo.TunerI2CAddress = *(PBYTE)buf;
         }
         else
         {
            DebugOut((0, "Failed GetRegistryValue(TunerI2CAddress)\n"));
         }
      }
      else
      {
         DebugOut((0, "Failed GetRegistryValue(TunerBrand)\n"));
      }

      if ( !bSuccess )
      {
         TunerInfo.TunerBrand          = TUNER_BRAND_TEMIC;
         TunerInfo.TunerI2CAddress     = 0xC2;
         DebugOut((0, "Defaulting to Temic tuner at I2C address 0xC2\n"));
      }

      RtlFreeUnicodeString( &UKeyName );
      ZwClose( KeyHandle );
   } 
   else
   {
      TunerInfo.TunerBrand          = TUNER_BRAND_TEMIC;
      TunerInfo.TunerI2CAddress     = 0xC2;
      DebugOut((0, "Failed OpenDriverKey()\n"));
      DebugOut((0, "Defaulting to Temic tuner at I2C address 0xC2\n"));
   }

   switch( TunerInfo.TunerBrand )
   {
   case TUNER_BRAND_PHILIPS:
      TunerInfo.TunerBandCtrlLow  = 0xCEA0;  // Ctrl code for VHF low
      TunerInfo.TunerBandCtrlMid  = 0xCE90;  // Ctrl code for VHF high
      TunerInfo.TunerBandCtrlHigh = 0xCE30;  // Ctrl code for UHF
      break;
   case TUNER_BRAND_ALPS:
      TunerInfo.TunerBandCtrlLow  = 0xC214;  // Ctrl code for VHF low
      TunerInfo.TunerBandCtrlMid  = 0xC212;  // Ctrl code for VHF high
      TunerInfo.TunerBandCtrlHigh = 0xC211;  // Ctrl code for UHF
      break;
   case TUNER_BRAND_TEMIC:
   default:
      TunerInfo.TunerBandCtrlLow  = 0x8E02;  // Ctrl code for VHF low
      TunerInfo.TunerBandCtrlMid  = 0x8E04;  // Ctrl code for VHF high
      TunerInfo.TunerBandCtrlHigh = 0x8E01;  // Ctrl code for UHF
      break;
   }

   DumpTunerInfo( &TunerInfo );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\risceng.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Risceng.cpp 1.6 1998/04/29 22:43:37 tomz Exp $

#include "risceng.h"


/* Method: RISCEng::CreateProgram
 * Purpose: Creates a first RISC program for a stream (field)
 * Input: aField: VidField - defines what field the program is for
 *   ImageSize: SIZE & - defines dimentions of the image
 *   dwPitch: DWORD - pitch to be used for data buffer . Useful for producing
 *   interlaced images.
 *   aFormat: ColorFormat - defines type of data
 *   dwBufAddr: DWORD - address of the destination buffer
 * Output: RiscPrgHandle
 */
RiscPrgHandle RISCEng::CreateProgram( MSize &ImageSize, DWORD dwPitch,
   ColFmt aFormat, DataBuf &buf, bool Intr, DWORD dwPlanrAdjust, bool rsync )
{
   // create yet another risc program object
   RISCProgram *YAProgram =
      new RISCProgram( ImageSize, dwPitch, aFormat );

   // and make it create the program itself
   if ( YAProgram->Create( Intr, buf, dwPlanrAdjust, rsync ) != Success ) {
      delete YAProgram;
      YAProgram = NULL;
   }

   return YAProgram;
}

/* Method: RISCEng::DestroyProgram
 * Purpose: Removes a program from a chain and destroy it
 * Input: ToDie: RiscPrgHandle - pointer to a program to destroy
 * Output: None
 */
void RISCEng::DestroyProgram( RiscPrgHandle ToDie )
{
   delete ToDie;
}

/* Method: RISCEng::ChangeAddress
 * Purpose:
 * Input:
 * Output:
 */
void RISCEng::ChangeAddress( RiscPrgHandle prog, DataBuf &buf )
{
   prog->ChangeAddress( buf );
}

/* Method: RISCEng::Chain
 * Purpose: Chains two RISC programs together
 * Input: hParent: RiscPrgHandle - pointer in reality
 *   hChild: RiscPrgHandle - pointer in reality
 * Output: None
 */
void RISCEng::Chain( RiscPrgHandle hParent, RiscPrgHandle hChild , int ndxParent, int ndxChild)
{
   DebugOut((2, "*** Linked hParent(%x)(%d) to hChild(%x)(%d)\n", hParent, ndxParent, hChild, ndxChild));
   hParent->SetChain( hChild );
}

/* Method: RISCEng::Skip
 * Purpose: Sets the given program so it is bypassed by DMA
 * Input: hToSkip: RiscPrgHandle - pointer in reality
 * Output: None
 * Note: The way things are right now a program will always have a child and a
 *   parent, even if it is its own parent and child
 */
void RISCEng::Skip( RiscPrgHandle pToSkip )
{
   pToSkip->Skip();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\risceng.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Risceng.h 1.6 1998/04/29 22:43:38 tomz Exp $

#ifndef __RISCENG_H
#define __RISCENG_H

#ifndef __VIDDEFS_H
#include "viddefs.h"
#endif

#ifndef __RISCPROG_H
#include "riscprog.h"
#endif

#ifndef __COMPREG_H
#include "compreg.h"
#endif

#include "preg.h"

typedef RISCProgram *RiscPrgHandle;

/* Class: RISCEng
 * Purpose: This class provides control over the BtPisces' RISC engine
 * Attributes:
 * Operations:
 */                
class RISCEng
{
   protected:
      DECLARE_RISCPROGRAMSTARTADDRESS;
      DECLARE_CONTROL;
   public:
      virtual RiscPrgHandle CreateProgram( MSize &ImageSize, DWORD dwPitch,
         ColFmt, DataBuf &buf, bool Intr = false, DWORD dwPlanarAdjust = 0, bool rsync = false );

      virtual void DestroyProgram( RiscPrgHandle ToDie );
              void ChangeAddress( RiscPrgHandle prog, DataBuf &buf );
              void Start( RISCProgram &ToStart )
              { 
                  DebugOut((1, "Starting RISC program (%x)\n", &ToStart));
                  //ToStart.Dump();

                  RISC_IPC = ToStart.GetPhysProgAddr() & ~0x3;
                  FIFO_ENABLE = 1; 
                  RISC_ENABLE = 1;  
              }
              void Stop() { RISC_ENABLE = 0; FIFO_ENABLE = 0; };
              void Chain( RiscPrgHandle hParent, RiscPrgHandle hChild , int ndxParent = -1, int ndxChild = -1);
              void Skip( RiscPrgHandle hToSkip );

      RISCEng() : CONSTRUCT_RISCPROGRAMSTARTADDRESS, CONSTRUCT_CONTROL
      { PKTP = 1; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\riscprog.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Riscprog.cpp 1.14 1998/05/04 17:53:37 tomz Exp $

#include "riscprog.h"
#include "physaddr.h"

#define ClearMem( a ) memset( &##a, '\0', sizeof( a ) )


DWORD RISCProgram::GetDataBuffer( )
{
   return dwLinBufAddr_;
}

void RISCProgram::SetDataBuffer( DWORD addr )
{
   dwLinBufAddr_ = addr;
}

void RISCProgram::Dump( )
{
   if( bAlreadyDumped_ ) {
      return;
   }

   DebugOut((0, "; RiscProgram(%x) ProgAddr(%x) PhysProgAddr(%x)\n",
                 this,
                 GetProgAddress( ),
                 GetPhysProgAddr( )));

   DebugOut((0, "  RiscProgram(%x) dwBufAddr_(%x) dwLinBufAddr_(%x)\n",
                 this,
                 dwBufAddr_,
                 dwLinBufAddr_));


   return;



   dwSize_ = 0;
   DWORD* pProgLoc = (DWORD*) GetProgAddress( );
   while( *pProgLoc++ != PROGRAM_TERMINATOR ) {
      dwSize_++;
      if( dwSize_ > 1024 ) {
         dwSize_ = 0;
         break;
      }
   }
   DWORD dwTmpSize_ = dwSize_;
   DebugOut((0, ";  size = %d\n", dwSize_));

   if( dwSize_ ) {
      DebugOut((0, "%x    ", GetPhysProgAddr( )));
   }

   PULONG pulProg = (PULONG) (ProgramSpace_->getLinearBase());
   while( dwTmpSize_ >= 4 ) {
      DebugOut((0, "   %08x %08x %08x %08x\n",
                pulProg[0],
                pulProg[1],
                pulProg[2],
                pulProg[3]));
      pulProg += 4;
      dwTmpSize_ -= 4;
   }
   switch( dwTmpSize_ ) {
      case 3:
         DebugOut((0, "   %08x %08x %08x\n",
                   pulProg[0],
                   pulProg[1],
                   pulProg[2]
                   ));
         break;
      case 2:
         DebugOut((0, "   %08x %08x\n",
                   pulProg[0],
                   pulProg[1]
                   ));
         break;
      case 1:
         DebugOut((0, "   %08x\n",
                   pulProg[0]
                   ));
         break;
   }

   bAlreadyDumped_ = TRUE;

#if 0
   if( pChild_ != NULL ) {
      // *** warning - recursion ***
      pChild_->Dump();
   }
#endif

   bAlreadyDumped_ = FALSE;
}

/*
      {
      // Input
      //    DWORD : RiscProg ndx
      //       CreatedProgs : 12 elements     ndx 0..11
      //       ActiveProgs  : 12 elements     ndx 12..23
      //       Skippers     : 8  elements     ndx 24..31
      // Output
      //    Buffer filled with riscprog
        int i = 0;

        if ( !pDIOCParams->dioc_cbOutBuf || (pDIOCParams->dioc_cbInBuf != 4))
          return -1;          // invalid parameters

        // pause
        // CaptureContrll_->Pause() ;

        // dump a prog
        DWORD WhichProg = *((PDWORD) pDIOCParams->dioc_InBuf);

        RiscPrgHandle hProg ;

        if (WhichProg < 12)            // CreatedProgs
        {
          hProg = CaptureContrll_->CreatedProgs_[WhichProg] ;
        }
        else if (WhichProg < 24)       // Active
        {
          hProg = CaptureContrll_->ActiveProgs_[WhichProg % 12] ;
        }
        else                           // Skippers
        {
          hProg =  CaptureContrll_->Skippers_[WhichProg % 12] ;
        }

        if(hProg)
        {
          char * pRetAddr = (char *)pDIOCParams->dioc_OutBuf;
          DWORD physAddr = hProg->GetPhysProgAddr() ;
          DWORD progSize = hProg->GetProgramSize();
          char * linBuf = (char *) MapPhysToLinear((void *)physAddr, progSize, 0) ;

          *((DWORD *) pRetAddr) = physAddr ;
          pRetAddr+=4 ;
          for (i = 0 ; i < progSize && i < pDIOCParams->dioc_cbOutBuf ; i++)
          {
             *pRetAddr++ = linBuf[i] ;
          }
        }
        if ( pDIOCParams->dioc_bytesret )
          *pDIOCParams->dioc_bytesret = i;

        // and resume
        // CaptureContrll_->Continue() ;
      }
*/



/* Method:  RISCProgram::ChangeAddress
 * Purpose: Modifies existing program to use new destination address
 * Input: dwNewAddr: DWORD - new buffer address
 * Output: None
 */
void  RISCProgram::ChangeAddress( DataBuf &buf )
{
   Trace t("RISCProgram::ChangeAddress()");
   //DebugOut((1, "RISCProgram::ChangeAddress(): this(%x), buf.pData_(%x)\n", this, buf.pData_));
   Create( Interrupting_, buf, dwPlanarAdjust_, GenerateResync_, false );
}

/* Function: CreatePrologEpilog
 * Purpose: Called from Create function to put proper sync codes at the beginning
 *   and at the end of a RISC program
 * Input: pProgLoc: PDWORD - pointer to the instruction memory
 *    SyncBits: SyncCode
 *   CurCommand: Command & - reference to a command object
 * Output: PDWORD - address of the next instruction
 */
inline PDWORD RISCProgram::CreatePrologEpilog( PDWORD pProgLoc, SyncCode SyncBits,
   Command &CurCommand, bool Resync )
{
   Trace t("RISCProgram::CreatePrologEpilog()");

   CurCommand.Create( pProgLoc, SYNC, NULL, NULL, false );//, false, false );
   CurCommand.SetSync( pProgLoc, SyncBits, Resync );
   // advance to the next command's position
   return pProgLoc + CurCommand.GetInstrSize();
}

inline bool IsWithin( int coord, int top, int bot )
{
   Trace t("IsWithin()");
   return bool( coord >= top && coord < bot );
}

inline PDWORD FinishWithSkip( int pixels, int bpp, PDWORD pProgLoc, Command &com )
{
   Trace t("FinishWithSkip()");

   WORD awByteCounts [1];
   awByteCounts [0] = WORD( pixels * bpp );
   return (LPDWORD)com.Create( pProgLoc, SKIP, awByteCounts, NULL,
      true, false, true, false ); // safety, SOL, EOL, Intr
}

ErrorCode RISCProgram::GetDataBufPhys( DataBuf &buf )
{
   Trace t("RISCProgram::GetDataBufPhys()");

   dwBufAddr_ = GetPhysAddr( buf );
   if ( dwBufAddr_ == (DWORD)-1 ) {
      return Fail;
   }
   return Success;
}

/* Method: RISCProgram::AllocateStorage
 * Purpose: Allocates a number of pages ( locked and physically contiguous ) to
 *   hold the new program
 * Input: None
 * Output: ErrorCode
 */
ErrorCode RISCProgram::AllocateStorage( bool extra, int )
{
   Trace t("RISCProgram::AllocateStorage()");

   if ( ProgramSpace_ )
      return Success;

   // figure out size of the memory to hold the program
   // at least as many DWORDs as lines
   DWORD dwProgramSize = ImageSize_.cy * sizeof( DWORD );

   // scale up according to the data format
   switch ( BufFormat_.GetColorFormat() ) {
   case CF_RGB32:
   case CF_RGB24:
   case CF_RGB16:
   case CF_RGB15:
   case CF_Y8:
   case CF_YUY2:
   case CF_UYVY:
   case CF_BTYUV:
   case CF_RGB8:
   case CF_RAW:
   case CF_VBI:
      dwProgramSize *= 2; // size of 'Write' command is 2 DWORDs
      if ( extra == true )  // doing clipping
         dwProgramSize *= 3;
      break;
   case CF_PL_422:
   case CF_PL_411:
   case CF_YUV9:
   case CF_YUV12:
   case CF_I420:
      dwProgramSize *= 5; // Planar WRITE is 5 DWORDs
   }
   // add extra for page crossings
   dwProgramSize += ImageSize_.cx * ImageSize_.cy * BufFormat_.GetBitCount() / 8
      / PAGE_SIZE * sizeof( DWORD ) * 5;

   ProgramSpace_ = new PsPageBlock( dwProgramSize );

   if ( ProgramSpace_ && ProgramSpace_->getLinearBase() != 0 )
      return Success;
   return Fail;
}

/* Function: GetAlternateSwitch
 * Purpose: Chooses alternative instruction frequency
 * Input: AlternateSwitch: int
 *    col: ColFmt, color format
 * Output: None
*/
inline void GetAlternateSwitch( int &AlternateSwitch, ColFmt col )
{
   Trace t("GetAlternateSwitch()");

   AlternateSwitch = col == CF_YUV9  ? 4 :
                     col == CF_YUV12 ? 2 : 1;
}

/* Function: GetSplitAddr
 * Purpose: Calculates page-aligned address
 * Input: dwLinBufAddr: DWORD - linear address
 * Output: DWORD
*/
inline DWORD GetSplitAddr( DWORD dwLinBufAddr )
{
   Trace t("GetSplitAddr()");
   return ( dwLinBufAddr + PAGE_SIZE ) & ~( PAGE_SIZE - 1 );//0xFFFFF000L;
//   return ( dwLinBufAddr + 0x1000 ) & 0xFFFFF000L;
}

/* Function: GetSplitByteCount
 * Purpose: Calculates number of bytes before the page boundary
 * Input: dwLinBufAddr: DWORD, address
 * Output: WORD, byte count
*/
inline WORD GetSplitByteCount( DWORD dwLinBufAddr )
{
   Trace t("GetSplitByteCount()");
   return WORD( PAGE_SIZE - BYTE_OFFSET( dwLinBufAddr ) );
//   return WORD( 0x1000 - ( dwLinBufAddr & 0xFFF ) );
}

/* Function: GetSplitNumbers
 * Purpose: Calculates addresses and byte counts when scan line crosses a page boundary
 * Input: dwLinAddr: DWORD, starting linear address
 *   wByteCount: WORD &, number of bytes to move before page crossing
 *   wByteCSplit: WORD &, number of bytes to move after page crossing
 *   SecondAddr: DWORD &, reference to the DWORD contatining address of the starting
 *   address for the second 'write' instruction
 *   FirstAddr: DWORD &,
 */
void GetSplitNumbers( DataBuf buf, WORD &wFirstByteCount, WORD &wSecondByteCount,
   DWORD &SecondAddr, DWORD &FirstAddr )
{
   Trace t("GetSplitNumbers()");

   // maybe can have some optimization here: if within the same page as previous
   // call ( no split ), don't call out for the physical address - just
   // increment the old physical address by difference in virtual addresses
   FirstAddr = GetPhysAddr( buf );

   if ( Need2Split( buf, wFirstByteCount ) ) {

      wSecondByteCount = wFirstByteCount;

      // lin address of the second write command ( page aligned )
      SecondAddr = GetSplitAddr( DWORD( buf.pData_ ) );

      // byte count of first write command
      wFirstByteCount = GetSplitByteCount( DWORD( buf.pData_ ) );
      wSecondByteCount -= wFirstByteCount;

      // get the physical addresses
      buf.pData_ = PBYTE( SecondAddr );
      SecondAddr = GetPhysAddr( buf );
   } else {
      wSecondByteCount = 0;
      SecondAddr = 0;
   }
}

/* Function: AdjustByteCounts
 * Purpose: This function is used to calculate 2 byte counts based on the given ratio
 * Purpose:
 */
void AdjustByteCounts( WORD &smaller, WORD &larger, WORD total, WORD ratio )
{
   Trace t("AdjustByteCounts()");

   if ( ratio <= 1 ) {
      smaller = WORD( total >> 1 );
   } else
      smaller = WORD( total / ratio );
   smaller += (WORD)3;
   smaller &= ~3;
   larger = WORD( total - smaller );
}

/* Method: RISCProgram::Create
 * Purpose: Creates a RISC program
 * Input: NeedInterrupt: bool - flag
 * Output: None
 * Note: It is likely this function is used to simply change dst addresses of
 *   an already existing program. It does not seem to make much sense to write
 *   basically the same function ( or the one that has to parse existing program)
 *   to change addresses
 */
ErrorCode  RISCProgram::Create( bool NeedInterrupt, DataBuf buf, DWORD dwPlanrAdjust,
   bool rsync, bool LoopOnItself )
{
   Trace t("RISCProgram::Create(2)");

   dwPlanarAdjust_ = dwPlanrAdjust;
   Interrupting_   = NeedInterrupt;
   GenerateResync_ = rsync;

   // allocate memory for the program first
   if ( AllocateStorage() != Success )
      return Fail;

   // store the buffer address in case somebody will want to change clipping
   if ( buf.pData_ && GetDataBufPhys( buf ) != Success )
      return Fail;

   // keep the linear address around
   dwLinBufAddr_ = DWORD( buf.pData_ );
   pSrb_ = buf.pSrb_;
   DebugOut((1, "dwLinBufAddr_ = %x\n", dwLinBufAddr_));

   // bad naming ?
   DWORD dwLinBufAddr = dwLinBufAddr_;

   // probably should create a class to handle these arrays
   WORD  awByteCounts [3];
   DWORD adwAddresses [3];

   Instruction MainInstrToUse, AltInstrToUse;

   int AlternateSwitch = 1;

   // used to increment planes' addresses
   LONG PlanePitch1 = dwBufPitch_, ChromaPitch = dwBufPitch_;

   // get size in bytes
   DWORD dwYPlaneSize = ImageSize_.cy * dwBufPitch_;

//   DebugOut((1, "buf addr = %x\n", dwLinBufAddr ) );

   // this is a physical address
   DWORD Plane1 = dwLinBufAddr_ + dwYPlaneSize, Plane2;

   // initialize byte count for all planar modes
   awByteCounts [0] = (WORD)ImageSize_.cx;

   if ( !dwLinBufAddr_ ) { // hack to handle special case of creating a skipper for VBI streams
      MainInstrToUse = SKIP123;
      AltInstrToUse  = SKIP123;
   } else {
      MainInstrToUse = WRITE1S23;
      AltInstrToUse  = WRITE123;
   }
   // handle all planar modes here
   SyncCode  SyncBits = SC_FM3;

   // these guys used for the calculation of addresses
   // for different planar mode combinations ( pitch > witdh, interleaving )
   DWORD dwEqualPitchDivider = 1;
   DWORD dwByteCountDivider  = 1;

   bool flip = false;

   // prepare all the ugly things
   switch ( BufFormat_.GetColorFormat() ) {
   case CF_RGB32:
   case CF_RGB24:
   case CF_RGB16:
   case CF_RGB15:
   case CF_BTYUV:
   case CF_RGB8:
      flip = Interrupting_;
   case CF_Y8:
   case CF_YUY2:
   case CF_UYVY:
   case CF_RAW:
   case CF_VBI:
      if ( !dwLinBufAddr_ ) { // hack to handle special case of creating a skipper for VBI streams
         MainInstrToUse = SKIP;
         AltInstrToUse  = SKIP;
      } else {
         MainInstrToUse = WRIT;
         AltInstrToUse  = WRIT;
      }
      awByteCounts [0] = (WORD)(ImageSize_.cx * BufFormat_.GetBitCount() / 8 );
      // packed data to follow
      SyncBits = SC_FM1;
      break;
   case CF_PL_422:
      dwEqualPitchDivider = 2;
      dwByteCountDivider  = 2;
      break;
   case CF_PL_411:
      dwEqualPitchDivider = 4;
      dwByteCountDivider  = 4;
      break;
   case CF_YUV9:
      AlternateSwitch = 4;
      dwEqualPitchDivider = 16;
      dwByteCountDivider  = 4;
      break;
   case CF_I420:
   case CF_YUV12:
      AlternateSwitch = 2;
      dwEqualPitchDivider = 4;
      dwByteCountDivider  = 2;
   } /*endswitch*/

   awByteCounts [1] = awByteCounts [2] =
      WORD( awByteCounts [0] / dwByteCountDivider );

   Plane2 = Plane1 + dwYPlaneSize / dwEqualPitchDivider;
   ChromaPitch /= dwByteCountDivider;

   // need to adjust if doing a full-size planar capture.
   Plane2 -= dwPlanarAdjust_;
   Plane1 -= dwPlanarAdjust_;
   Plane2 += dwPlanarAdjust_ / dwByteCountDivider;
   Plane1 += dwPlanarAdjust_ / dwByteCountDivider;

   // U goes first for this color format
   if ( BufFormat_.GetColorFormat() == CF_I420 ) {
      DWORD dwTmp = Plane1;
      Plane1 = Plane2;
      Plane2 = dwTmp;
   }
   // that's were the instructions are going
   LPDWORD pProgLoc = (LPDWORD)(DWORD)ProgramSpace_->getLinearBase();
   LPDWORD pProgStart = pProgLoc;

   Command CurCommand;  // this will create every command we need - yahoo !

   // put one of the FM codes here if this program is for image data only
   pProgLoc = CreatePrologEpilog( pProgLoc, SyncBits, CurCommand );

   // init the destination address
   if ( flip ) {
      dwLinBufAddr += dwYPlaneSize;
      PlanePitch1 = -PlanePitch1;
   } else {
      dwLinBufAddr -= PlanePitch1;
      ;
   }
   // initial adjustment of chroma pointers
   Plane1 -= ChromaPitch;
   Plane2 -= ChromaPitch;

   // now go into a loop (up to the hight of the image) and create
   // a command for every line. Commands depend on the data format
   unsigned int i = 0;
   while ( i < (unsigned)ImageSize_.cy ) {

      Instruction CurInstr;

      // now take care of vertically sub-sampled planar modes
      if ( i % AlternateSwitch != 0 ) {
         CurInstr = AltInstrToUse;
      } else {
         CurInstr = MainInstrToUse;
         Plane2 += ChromaPitch;
         Plane1 += ChromaPitch;
      }
      // advance the linear address to the next scan line
      dwLinBufAddr += PlanePitch1;

      // these arrays contain values for the second instruction
      DWORD adwSecondAddr [3];
      WORD  FirstByteCount [3];
      WORD  SecondByteCount [3];

      adwSecondAddr   [0] = adwSecondAddr   [1] = adwSecondAddr   [2] =
      SecondByteCount [0] = SecondByteCount [1] = SecondByteCount [2] = 0;

      // initialize byte counts
      memmove( FirstByteCount, awByteCounts, sizeof( FirstByteCount ) );

      buf.pData_ = PBYTE( dwLinBufAddr );
      if ( dwLinBufAddr_ ) // don't bother with the addresses, if we are SKIPping them !
         GetSplitNumbers( buf, FirstByteCount [0], SecondByteCount [0],
            adwSecondAddr [0], adwAddresses [0] );

      PVOID pEOLLoc; // this is needed to set EOL bit in split instructions

      if ( AlternateSwitch > 1 && dwLinBufAddr_ ) {

         int split = 1;
         // Y plane is already done
         // now check if we better split instructions
         // just make width half of original and create 2 instructions
         if ( ImageSize_.cx > 320 && SecondByteCount [0 ] )
            split = 2;

         // temps for the loop
         DWORD dwYPlane = dwLinBufAddr;
         DWORD dwVPlane = Plane2;
         DWORD dwUPlane = Plane1;

         for ( int k = 0; k < split; k++ ) {

            // initialize byte counts
            memmove( FirstByteCount, awByteCounts, sizeof( FirstByteCount ) );
            // and split them in half
            for ( int l = 0; l < sizeof FirstByteCount / sizeof FirstByteCount [0]; l++ )
               FirstByteCount [l] = WORD (FirstByteCount [l] / split); //create 2 instructions with half the pixels

            // see if any of the planes crosses a page boundary
            // very ugly... must use the bad structure
            buf.pData_ = PBYTE( dwYPlane );
            GetSplitNumbers( buf, FirstByteCount [0], SecondByteCount [0],
               adwSecondAddr [0], adwAddresses [0] );
            // V plane
            buf.pData_ = PBYTE( dwVPlane );
            GetSplitNumbers( buf, FirstByteCount [1], SecondByteCount [1],
               adwSecondAddr [1], adwAddresses [1] );
            // U plane
            buf.pData_ = PBYTE( dwUPlane );
            GetSplitNumbers( buf, FirstByteCount [2], SecondByteCount [2],
               adwSecondAddr [2], adwAddresses [2] );

            // can not have zero Y byte count
            if ( !SecondByteCount [0] && ( SecondByteCount [1] || SecondByteCount [2] ) ) {
               FirstByteCount  [0] -= max( SecondByteCount [1], SecondByteCount [2] );
               FirstByteCount  [0] &= ~3; // need to align for the second address
               SecondByteCount [0] = WORD( awByteCounts [0] / split - FirstByteCount [0] );
               // second addr starts where first ends; no page crossing
               adwSecondAddr [0] = adwAddresses [0] + FirstByteCount [0];
            }
            // now make sure that there are no zero chroma byte counts
            // adjust chroma byte counts in proportion to luma byte counts split
            if ( SecondByteCount [0] )  {
               if ( !SecondByteCount [1] ) {
                  if ( SecondByteCount [0] > FirstByteCount [0] )
                     AdjustByteCounts( FirstByteCount [1], SecondByteCount [1], FirstByteCount [1],
                        WORD( SecondByteCount [0] / FirstByteCount [0] ) );
                  else
                     AdjustByteCounts( SecondByteCount [1], FirstByteCount [1], FirstByteCount [1],
                        WORD( FirstByteCount [0] / SecondByteCount [0] ) );
                  adwSecondAddr [1] = adwAddresses [1] + FirstByteCount [1];
               }
               if ( !SecondByteCount [2] ) {
                  if ( SecondByteCount [0] > FirstByteCount [0] )
                     AdjustByteCounts( FirstByteCount [2], SecondByteCount [2], FirstByteCount [2],
                        WORD( SecondByteCount [0] / FirstByteCount [0] ) );
                  else
                     AdjustByteCounts( SecondByteCount [2], FirstByteCount [2], FirstByteCount [2],
                        WORD( FirstByteCount [0] / SecondByteCount [0] ) );
                  adwSecondAddr   [2] = adwAddresses [2] + FirstByteCount [2];
               }
            }
            // now write out the instructions
            // first command. SOL==true, EOL==false
            pProgLoc = (LPDWORD)CurCommand.Create( pProgLoc, CurInstr,
               FirstByteCount, adwAddresses, LoopOnItself, k == 0, false );
            pEOLLoc = CurCommand.GetInstrAddr();

            if ( SecondByteCount [0] || SecondByteCount [1] || SecondByteCount [2] ) {
               // second command
               pProgLoc = (LPDWORD)CurCommand.Create( pProgLoc, CurInstr,
                  SecondByteCount, adwSecondAddr, LoopOnItself, false, false );
               pEOLLoc = CurCommand.GetInstrAddr();
            }
            // adjust starting addresses
            dwYPlane += awByteCounts [0] / 2;
            dwVPlane += awByteCounts [1] / 2;
            dwUPlane += awByteCounts [2] / 2;
         } /* endfor */
         // do not forget the EOL bit !
         CurCommand.SetEOL( pEOLLoc );

      } else {
         // first command. SOL==true, EOL==false
         pProgLoc = (LPDWORD)CurCommand.Create( pProgLoc, CurInstr,
            FirstByteCount, adwAddresses, LoopOnItself, true, false );
         pEOLLoc = CurCommand.GetInstrAddr();

         if ( SecondByteCount [0] || SecondByteCount [1] || SecondByteCount [2] ) {
            // second command
            pProgLoc = (LPDWORD)CurCommand.Create( pProgLoc, CurInstr,
               SecondByteCount, adwSecondAddr, LoopOnItself, false );
         } else
            CurCommand.SetEOL( pEOLLoc );
      } /* endif */
      i++;
   } /* endwhile */

   pChainAddress_ = pProgLoc;
   pIRQAddress_ = pProgLoc;

   PutInChain();

   Skipped_ = false;
   dwSize_ = (DWORD)pProgLoc - (DWORD)pProgStart;

   return Success;
}

/* Method: RISCProgram::PutInChain
 * Purpose: Restores the chain of programs this program was in.
 * Input: None
 * Output: None
 * Note: The chain is destroyed when clipping is set or buffer address is changed
 */
void RISCProgram::PutInChain()
{
   Trace t("RISCProgram::PutInChain()");

   if ( pChild_ )
      SetChain( pChild_ );

   if ( pParent_ )
      pParent_->SetChain( this );
}

/* Method: RISCProgram::SetChain
 * Purpose: Chains this program to another one
 * Input: dwProgAddr: DWORD - address of a first instruction in the next program
 * Output: None
 */
void  RISCProgram::SetChain( RISCProgram *ChainTo )
{
   Trace t("RISCProgram::SetChain()");

   if ( !ChainTo )
      return;

   // now we know where we are chaining to
   pChild_ = ChainTo;

   // now child knows who chains to it.Does it really want to know its parent?<g>
   pChild_->SetParent( this );

   SetJump( (PDWORD)pChild_->GetPhysProgAddr() );
}

/* Method: RISCProgram::Skip
 * Purpose: Changes first instruction so program jumps over itself and to the child
 * Input: None
 * Output: None
 * Note: This functionality is useful when there are not enough data buffers
 *   to supply for this program
 */
void RISCProgram::Skip()
{
   Trace t("RISCProgram::Skip()");

// change first SYNC into JUMP
   PDWORD pTmpAddr = pChainAddress_;
   pChainAddress_ = (PDWORD)GetProgAddress();
   ULONG len;
   DWORD  PhysAddr = StreamClassGetPhysicalAddress( gpHwDeviceExtension, NULL,
      pTmpAddr, DmaBuffer, &len ).LowPart;

   SetJump( (PDWORD)PhysAddr );
   pChainAddress_ = pTmpAddr;

   Skipped_ = true;
}

/* Method: RISCProgram::SetJump
 * Purpose: Creates a JUMP instruction to chain some place
 * Input: JumpAddr: PDWORD - target address
 * Output: None
 */
void RISCProgram::SetJump( PDWORD JumpAddr )
{
   Trace t("RISCProgram::SetJump()");

   Command JumpCommand;
   DWORD adwAddresses [1];
   adwAddresses [0] = (DWORD)JumpAddr;
   JumpCommand.Create( pChainAddress_, JUMP, NULL, adwAddresses, false );
   // make the last JUMP interrupt
   if ( Interrupting_ ) {
      JumpCommand.SetIRQ( pIRQAddress_ );
      if ( Counting_ )
         SetToCount();
      else
         ResetStatus();
   }
}

/* Method: RISCProgram::CreateLoop
 * Purpose: Creates a closed loop at the end of a RISC program
 * Input:  resync: bool - value of the resync bit
 * Output: None
 */
void RISCProgram::CreateLoop( bool resync )
{
   Trace t("RISCProgram::CreateLoop()");

   Command SyncCommand( SYNC );
   SyncCommand.SetResync( pChainAddress_, resync );
   if ( resync == true ) {
      DWORD adwAddresses [1];
      ULONG len;
      DWORD  PhysAddr = StreamClassGetPhysicalAddress( gpHwDeviceExtension, NULL,
         pChainAddress_, DmaBuffer, &len ).LowPart;

      adwAddresses [0] = PhysAddr;
      SyncCommand.Create( pChainAddress_, JUMP, NULL, adwAddresses );
   }
}

/* Method: RISCProgram::Create
 * Purpose: Creates a simple SYNC and JUMP program
 * Input: SyncBits: SyncCode - defines what code to do resync with
 * Output: None
 */
ErrorCode RISCProgram::Create( SyncCode SyncBits, bool resync )
{
   Trace t("RISCProgram::Create(3)");

   // allocate memory for the program first
   if ( AllocateStorage() != Success )
      return Fail;

   Command CurCommand;  // this will create every command we need - yahoo !

   // that's were the instructions are going
   LPDWORD pProgLoc = (LPDWORD)ProgramSpace_->getLinearBase();
   LPDWORD pProgStart = pProgLoc;

   // put one of the FM or VRx codes here
   pProgLoc = CreatePrologEpilog( pProgLoc, SyncBits, CurCommand, resync );
   pChainAddress_ = pProgLoc;
   CreateLoop( true );

   dwSize_ = (DWORD)pProgLoc - (DWORD)pProgStart;

   return Success;
}

RISCProgram::~RISCProgram()
{
   Trace t("RISCProgram::~RISCProgram(3)");
   delete ProgramSpace_;
   ProgramSpace_ = NULL;
   if ( pParent_ )
      pParent_->SetChild( NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\riscprog.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Riscprog.h 1.9 1998/04/29 22:43:39 tomz Exp $

#ifndef __RISCPROG_H
#define __RISCPROG_H

#ifndef __MYTYPES_H
#include "mytypes.h"
#endif

#ifndef __VIDDEFS_H
#include "viddefs.h"
#endif

#ifndef __COLSPACE_H
#include "colspace.h"
#endif

#ifndef __PSPAGEBL_H
#include "pspagebl.h"
#endif

#ifndef __COMMAND_H
#include "command.h"
#endif
const Programs = 24;

inline LONGLONG operator-( const LARGE_INTEGER &first, const LARGE_INTEGER &second )
{
   return first.QuadPart - second.QuadPart;
}

inline bool operator>( const LARGE_INTEGER &first, const LARGE_INTEGER &second )
{
   return bool( first.QuadPart > second.QuadPart );
}

inline bool operator>=( const LARGE_INTEGER &first, const LARGE_INTEGER &second )
{
   return bool( first.QuadPart >= second.QuadPart );
}

/* Class: RISCProgram
 * Purpose: Facilitates creation and maintenance of a RISC programs
 * Attributes: ImageSize_: SIZE - structure containing dimentions of the image
 *   dwBufPitch_: DWORD - buffer pitch
 *   Field_: VideoField - which field the program is for
 *   Interrupting_: bool
 *   ProgramSpace_: PsPageBlock * - pointer to the class that manages the memory
 *   occupied by a program ( allocates, deallocates, obtains information )
 *   BufFormat_: ColorSpace - format of the data in the buffer
 * Operations:
 *   void  ChangeAddress( DWORD dwNewAddr )
 *   void  SetClipping( LPRECT pRect )
 *   void  Create( bool NeedInterrupt )
 *   void  SetChain( DWORD dwProgAddr )
 *   DWORD GetProgAddress()
 *   bool  IsInterrupting()
 */
class RISCProgram
{
   public:
      PDWORD       pChainAddress_;

   private:
      MSize        ImageSize_;
      DWORD        dwBufPitch_;

      bool         Interrupting_;
      bool         Counting_;
      
      PsPageBlock *ProgramSpace_;
      ColorSpace   BufFormat_;
      RISCProgram *pChild_;
      RISCProgram *pParent_;
      PDWORD       pIRQAddress_;
      DWORD        dwBufAddr_;
      DWORD        dwLinBufAddr_;
      bool         Skipped_;
      bool         GenerateResync_;

      BOOL          bAlreadyDumped_;
      PVOID         tag_;
      LARGE_INTEGER ExtraTag_;
      LARGE_INTEGER ExpectedExecutionTime_;

      DWORD        dwPlanarAdjust_;
      DWORD        dwSize_;

   protected:
      ErrorCode AllocateStorage( bool extra = false, int cnt = 1 );
      PDWORD CreatePrologEpilog( PDWORD pProgLoc, SyncCode SyncBits,
         Command &CurCommand, bool Resync = false );
      ErrorCode GetDataBufPhys( DataBuf &buf );

      void PutInChain();

   public:

      PHW_STREAM_REQUEST_BLOCK pSrb_;

      DWORD        GetDataBuffer( );
      void         SetDataBuffer( DWORD addr );

      void         ChangeAddress( DataBuf &buf );
      ErrorCode    Create( SyncCode SyncBits, bool resync = false );
      ErrorCode    Create( bool NeedInterrupt, DataBuf buf, DWORD dwPlanAdjust,
         bool resync = false, bool Loop = true );

      void         MakeFault() { *((PDWORD)GetProgAddress()) = (DWORD)-1; }
      DWORD        GetProgAddress();
      void         SetJump( PDWORD JumpAddr );

      // chaining/unchaining group
      RISCProgram *GetParent() { return pParent_; }
      RISCProgram *GetChild() { return pChild_; }
      void         SetParent( RISCProgram *p ) { pParent_ = p; }
      void         SetChild ( RISCProgram *p ) { pChild_  = p; }
      void         CreateLoop( bool );
      void         SetChain( RISCProgram *ChainTo );
      void         Skip();
      void         SetSkipped( bool sk = true );
      void         SetToCount();
      void         ResetStatus();
      void         SetStatus( int val );
      void         SetResync( bool val );

      bool         IsSkipped();
      bool         IsInterrupting();

      void         SetTag( PVOID value );
      PVOID        GetTag();

      void          SetTagEx( LARGE_INTEGER val );
      LARGE_INTEGER GetTagEx();

      LARGE_INTEGER GetExecTime() { return ExpectedExecutionTime_; }

//      static RISCProgram CreateStarter();

      DWORD GetPhysProgAddr();
      void         Dump();

      RISCProgram( MSize &size, DWORD pitch, ColFmt aColor );

      RISCProgram();

      ~RISCProgram();

      friend class RISCEng;
};

/* Method:  RISCProgram::GetProgramAddress
 * Purpose: Obtains address of this program
 * Input: None
 * Output: DWORD: program's address
 */
inline DWORD RISCProgram::GetProgAddress()
{
   return ProgramSpace_->getLinearBase();
}

inline void RISCProgram::SetToCount()
{
   Command IRQCommand;
   IRQCommand.SetToCount( pIRQAddress_ );
   Counting_ = true;
}

inline void RISCProgram::ResetStatus()
{
   Command IRQCommand;
   IRQCommand.ResetStatus( pIRQAddress_, 0xF );
   Counting_ = false;
}

inline void RISCProgram::SetStatus( int val )
{
   Command IRQCommand;
   IRQCommand.SetStatus( pIRQAddress_, val );
}

inline void RISCProgram::SetResync( bool val )
{
   Command SyncCommand;
   SyncCommand.SetResync( (PVOID)GetProgAddress(), val );
}

inline void  RISCProgram::SetSkipped( bool sk )
{
   Skipped_ = sk;
}

inline bool  RISCProgram::IsSkipped()
{
   return Skipped_;
}

inline bool  RISCProgram::IsInterrupting()
{
   return Interrupting_;
}

inline void  RISCProgram::SetTag( PVOID value )
{
   tag_ = value;
}

inline PVOID RISCProgram::GetTag()
{
   return tag_;
}

inline void RISCProgram::SetTagEx( LARGE_INTEGER val )
{
   ExtraTag_ = val;
}

inline LARGE_INTEGER RISCProgram::GetTagEx()
{
   return ExtraTag_;
}

/*
inline RISCProgram RISCProgram::CreateStarter()
{
   return RISCProgram();
}
*/
inline DWORD RISCProgram::GetPhysProgAddr()
{
   return ProgramSpace_->GetPhysAddr();
}

inline RISCProgram::RISCProgram( MSize &size, DWORD pitch, ColFmt aColor ) :
   ImageSize_( size ), dwBufPitch_( pitch ), Interrupting_( false ),
   BufFormat_( aColor ), ProgramSpace_( NULL ), tag_( NULL ), 
   dwPlanarAdjust_( 0 ), pChild_( NULL ), pParent_( NULL ), 
   pChainAddress_( NULL ), GenerateResync_( false ), Skipped_( false ),
   pIRQAddress_( NULL ), dwBufAddr_( 0 ), Counting_( false )
{
   ExtraTag_.QuadPart = 0;
   ExpectedExecutionTime_.QuadPart = 0;
   bAlreadyDumped_ = FALSE;
   dwSize_ = 0xffffffff;
   pSrb_ = 0;
}                                      

inline RISCProgram::RISCProgram() :
   ImageSize_( 10, 10 ), dwBufPitch_( 0 ), Interrupting_( false ),
   Counting_( false ), BufFormat_( CF_RGB32 ), ProgramSpace_( NULL ),
   tag_( NULL ), GenerateResync_( false ), pChild_( NULL ), pParent_( NULL ),
   pChainAddress_( NULL ), Skipped_( false ),
   pIRQAddress_( NULL ), dwBufAddr_( 0 ), dwLinBufAddr_( 0 )
{
   ExtraTag_.QuadPart = 0;
   ExpectedExecutionTime_.QuadPart = 0;
   bAlreadyDumped_ = FALSE;
   dwSize_ = 0xffffffff;
   pSrb_ = 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\riscmem.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Riscmem.cpp 1.5 1998/04/29 22:43:38 tomz Exp $

#include "pspagebl.h"
#include "defaults.h"


typedef struct
{
   DWORD dwSize;
} BT_MEMBLOCK, *PBT_MEMBLOCK;

/* this is a rather simple allocator. It divides entire space into 2 parts:
   1 - for VBI program allocations, 2 - for video program allocations. In addi-
   tion, each VBI program is equal in size ( same goes for video programs ).
   The distinction between video and VBI programs is made based on asked size.
   It is known the VBI programs are always smaller. VBI programs range is from
   zero to MaxVBISize, above memory is for video programs. Total size is big
   enough to hold all risc programs.
*/
void PsPageBlock::AllocateSpace( DWORD dwSize )
{
   PBYTE pBuf = (PBYTE)StreamClassGetDmaBuffer( gpHwDeviceExtension );

   DWORD dwBlockSize = MaxVBISize;
   if ( dwSize > MaxVBISize ) {
      pBuf += VideoOffset;
      dwBlockSize = MaxVidSize;
   }

   // now start searching for the available spot
   while ( 1 ) {

      PBT_MEMBLOCK pMemBlk = PBT_MEMBLOCK( pBuf );
      if ( pMemBlk->dwSize ) // this block is occupied
         pBuf += dwBlockSize;
      else {
         pMemBlk->dwSize = dwBlockSize;
         LinAddr_ = pMemBlk + 1;
         ULONG len;
         PhysAddr_ = StreamClassGetPhysicalAddress( gpHwDeviceExtension, NULL, LinAddr_,
            DmaBuffer, &len ).LowPart;
         break;
      }
   }
}

void PsPageBlock::FreeSpace()
{
   PBT_MEMBLOCK pMemBlk = PBT_MEMBLOCK( (PDWORD)LinAddr_ - 1 );
   pMemBlk->dwSize = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\s_constr.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/S_constr.h 1.3 1998/04/29 22:43:40 tomz Exp $

#ifndef __S_CONSTR_H
#define __S_CONSTR_H


#define CONSTRUCT_SCALER_REGISTERS( offset ) \
regCROP ( (0x03 * 4) + (offset), RW ) ,\
fieldVACTIVE_MSB( regCROP, 4, 2, RW) ,\
fieldHDELAY_MSB( regCROP, 2, 2, RW) ,\
fieldHACTIVE_MSB( regCROP, 0, 2, RW) ,\
regVACTIVE_LO ( (0x05 * 4) + (offset), RW ) ,\
regHDELAY_LO ( (0x06 * 4) + (offset), RW ) ,\
regHACTIVE_LO ( (0x07 * 4) + (offset), RW ) ,\
regHSCALE_HI ( (0x08 * 4) + (offset), RW ) ,\
fieldHSCALE_MSB( regHSCALE_HI, 0, 8, RW) ,\
regHSCALE_LO ( (0x09 * 4) + (offset), RW ) ,\
regSCLOOP ( (0x10 * 4) + (offset), RW ) ,\
fieldHFILT( regSCLOOP, 3, 2, RW) ,\
regVSCALE_HI ( (0x13 * 4) + (offset), RW ) ,\
fieldVSCALE_MSB( regVSCALE_HI, 0, 5, RW) ,\
regVSCALE_LO ( (0x14 * 4) + (offset), RW ) ,\
regVActive( regVACTIVE_LO, 8, fieldVACTIVE_MSB, RW ),\
regVScale( regVSCALE_LO, 8, fieldVSCALE_MSB, RW ),\
regHDelay( regHDELAY_LO, 8, fieldHDELAY_MSB, RW ),\
regHActive( regHACTIVE_LO, 8, fieldHACTIVE_MSB, RW ),\
regHScale( regHSCALE_LO, 8, fieldHSCALE_MSB, RW ),\
regVTC ( (0x1B * 4) + (offset), RW ) ,\
fieldVFILT( regVTC, 0, 2, RW)

#endif   // __S_CONSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\scaler.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Scaler.h 1.2 1998/04/29 22:43:41 tomz Exp $


#ifndef __SCALER_H
#define __SCALER_H

#include "mytypes.h"

#ifndef __COMPREG_H
#include "compreg.h"
#endif

#define HDROP       HANDLE

#include "viddefs.h"


// structure contains video information
struct VideoInfoStruct
{
   WORD Clkx1_HACTIVE;
   WORD Clkx1_HDELAY;
   WORD Min_Pixels;
   WORD Active_lines_per_field;
   WORD Min_UncroppedPixels;
   WORD Max_Pixels;
   WORD Min_Lines;
   WORD Max_Lines;
   WORD Max_VFilter1_Pixels;
   WORD Max_VFilter2_Pixels;
   WORD Max_VFilter3_Pixels;
   WORD Max_VFilter1_Lines;
   WORD Max_VFilter2_Lines;
   WORD Max_VFilter3_Lines;
};


/////////////////////////////////////////////////////////////////
//
// for pisces, instantiate as ...
//
// Scaler evenScaler( VF_Even );
// Scaler oddScaler( VF_Odd );
//
/////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CLASS Scaler
//
// Description:
//    This class encapsulates the register fields in the scaler portion of
//    the Bt848.
//    A complete set of functions are developed to manipulate all the
//    register fields in the scaler registers for the Bt848.
//
// Methods:
//    See below
//
// Note:
//    For Bt848, instantiate as ...
//       Scaler evenScaler( VF_Even );
//       Scaler oddScaler( VF_Odd );
//
/////////////////////////////////////////////////////////////////////////////

class Scaler
{
	public:
		Scaler( VidField );
		~Scaler();

		void VideoFormatChanged( VideoFormat );
      void TurnVFilter( State st ) { VFilterFlag_ = st; }
                             
		void      Scale( MRect & );
      ErrorCode SetAnalogWin( const MRect & );
      void      GetAnalogWin( MRect & ) const;
      ErrorCode SetDigitalWin( const MRect & );
      void      GetDigitalWin( MRect & ) const;

   protected:
      #include "S_declar.h"

		VideoInfoStruct * m_ptrVideoIn;
      MRect AnalogWin_;
      MRect DigitalWin_;

      // member functions to set scaling registers
		virtual void SetHActive( MRect & );
		virtual void SetHDelay( void );
		virtual void SetHScale( void );
      virtual void SetHFilter( void );
		virtual void SetVActive( void );
		virtual void SetVDelay( void );
		virtual void SetVScale( MRect & );
		virtual void SetVFilter( void );

   private:
		VideoFormat  m_videoFormat;   // video format

      // this is to battle junk lines at the top of the video
      State VFilterFlag_;

      WORD  m_HActive;  // calcuated intermediate value
      WORD  m_pixels;   // calcuated intermediate value
      WORD  m_lines;    // calcuated intermediate value
      WORD  m_VFilter;  // calcuated intermediate value

};


#endif __SCALER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\tuner.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Tuner.cpp 1.8 1998/05/07 15:24:56 tomz Exp $

extern "C" {
#include <strmini.h>
#include <wdm.h>
#include <windef.h>
}

#include "device.h"

#define PICTURE_INTERMEDIATE_FREQUENCY 45750000L

const BAND_LOW    =  55250000;    //  55.25 MHz
const BAND_LOWMID = 160000000;    // 160.00 MHz
const BAND_MIDHI  = 454000000;    // 454.00 MHz
const BAND_HI     = 801250000;    // 801.25 MHz

int PsDevice::GetPllOffset( PULONG busy, ULONG &lastFreq )
{
   lastFreq = LastFreq_;
   
   BYTE status = 0;
   I2CHWRead( TunerInfo.TunerI2CAddress, &status );
   DebugOut((1, "Tuner - status(%x)\n", status));
   if ( status & 0x40 ) {
      *busy = false;
      switch ( status & 0x07 ) {
      case 0:     // carrier sensed, need to lower frequency
         DebugOut((1, "Tuner: -2 (carrier sensed, need to lower frequency)\n"));
         return -2;
      case 1:     // carrier sensed, need to lower frequency
         DebugOut((1, "Tuner: -1 (carrier sensed, need to lower frequency)\n"));
         return -1;
      case 2:     // carrier sensed, we are on correct frequency
         DebugOut((1, "Tuner: 0 (carrier sensed, we are on correct frequency)\n"));
         return 0;
      case 3:     // carrier sensed, need to raise frequency
         DebugOut((1, "Tuner: 1 (carrier sensed, need to raise frequency)\n"));
         return 1;
      case 4:     // carrier not sensed
      default:
         DebugOut((1, "Tuner: 2 (carrier not sensed)\n"));
         return 2;
      } // switch
   }
   DebugOut((1, "Tuner: busy - return 0\n"));
   *busy = true;
   return 0;
}

void PsDevice::SetChannel( long lFreq )
{
   // Set the video carrier frequency
   // by controlling the programmable divider
   //
   // N = (16 * (FreqRF + FreqIntermediate)) / 1e6
   //

   LastFreq_ = lFreq;

   LONGLONG lTemp = lFreq;
   WORD wCtrl=0;
   lTemp = (lTemp + PICTURE_INTERMEDIATE_FREQUENCY) * 16;
   lTemp /= 1000000;

   // Set the band register
   if ( lFreq >= BAND_LOW && lFreq <= BAND_LOWMID )
   {
      wCtrl = TunerInfo.TunerBandCtrlLow;
   }
   else if ( lFreq > BAND_LOWMID && lFreq <= BAND_MIDHI )
   {
      wCtrl = TunerInfo.TunerBandCtrlMid;
   }
   else if ( lFreq > BAND_MIDHI && lFreq <= BAND_HI)
   {
      wCtrl = TunerInfo.TunerBandCtrlHigh;
   }

   // write HIWORD to I2C
   I2CHWWrite3( TunerInfo.TunerI2CAddress, HIBYTE( WORD( lTemp ) ), LOBYTE( WORD( lTemp ) ) );

   // write LOWORD to I2C
   I2CHWWrite3( TunerInfo.TunerI2CAddress, HIBYTE( wCtrl ), LOBYTE( wCtrl ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\s_declar.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/S_declar.h 1.3 1998/04/29 22:43:40 tomz Exp $

#ifndef __S_DECLAR_H
#define __S_DECLAR_H

//===========================================================================
// Scaler registers
//===========================================================================
RegisterB regCROP;
RegField  fieldVDELAY_MSB;
RegField  fieldVACTIVE_MSB;
RegField  fieldHDELAY_MSB;
RegField  fieldHACTIVE_MSB;
RegisterB regVDELAY_LO;
RegisterB regVACTIVE_LO;
RegisterB regHDELAY_LO;
RegisterB regHACTIVE_LO;
RegisterB regHSCALE_HI;
RegField  fieldHSCALE_MSB;
RegisterB regHSCALE_LO;
RegisterB regSCLOOP;
RegField  fieldHFILT;
RegisterB regVSCALE_HI;
RegField  fieldVSCALE_MSB;
RegisterB regVSCALE_LO;
RegisterB regVTC;
RegField  fieldVFILT;
CompositeReg regVDelay;
CompositeReg regVActive;
CompositeReg regVScale;
CompositeReg regHDelay;
CompositeReg regHActive;
CompositeReg regHScale;

// Since VDelay register in hardware is reversed;
// i.e. odd reg is really even field and vice versa, need an extra cropping reg
// for the opposite field
RegisterB regReverse_CROP;

#endif   // __S_DECLAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\scaler.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Scaler.cpp 1.3 1998/04/29 22:43:40 tomz Exp $

#include "Scaler.h"
#include "S_constr.h"


// video information for PAL
VideoInfoStruct NTSCVideoInfo =
{
   730,     // Clkx1_HACTIVE          = 746
   148,     // Clkx1_HDELAY           = 140
   44,      // Min_Pixels             =  44
   240,     // Active_lines_per_field = 240
   144,     // Min_UncroppedPixels    = Min_Pixels + 100
   724,     // Max_Pixels             = ((Clkx1_HACTIVE < 774) ? Clkx1_HACTIVE - 6 : 768)
   32,      // Min_Lines              = (Active_lines_per_field / 16 + 1) * 2
   240,     // Max_Lines              = Active_lines_per_field
   352,     // Max_VFilter1_Pixels    = ((Clkx1_HACTIVE > 796) ? 384 : (Clkx1_HACTIVE * 14 / 29))
   176,     // Max_VFilter2_Pixels    = Clkx1_HACTIVE * 8 / 33
   176,     // Max_VFilter3_Pixels    = Clkx1_HACTIVE * 8 / 33
   240,     // Max_VFilter1_Lines     = Active_lines_per_field
   120,     // Max_VFilter2_Lines     = Active_lines_per_field / 2
   96,      // Max_VFilter3_Lines     = Active_lines_per_field * 2 / 5
};

// video information for PAL
VideoInfoStruct PALVideoInfo = 
{
   914,     // Clkx1_HACTIVE          = 914
   190,     // Clkx1_HDELAY           = 190
   48,      // Min_Pixels             =  48
   284,     // Active_lines_per_field = 284
   148,     // Min_UncroppedPixels    = Min_Pixels + 100
   768,     // Max_Pixels             = ((Clkx1_HACTIVE < 774) ? Clkx1_HACTIVE - 6 : 768)
   36,      // Min_Lines              = (Active_lines_per_field / 16 + 1) * 2
   284,     // Max_Lines              = Active_lines_per_field
   384,     // Max_VFilter1_Pixels    = ((Clkx1_HACTIVE > 796) ? 384 : (Clkx1_HACTIVE * 14 / 29))
   221,     // Max_VFilter2_Pixels    = Clkx1_HACTIVE * 8 / 33
   221,     // Max_VFilter3_Pixels    = Clkx1_HACTIVE * 8 / 33
   284,     // Max_VFilter1_Lines     = Active_lines_per_field
   142,     // Max_VFilter2_Lines     = Active_lines_per_field / 2
   113,     // Max_VFilter3_Lines     = Active_lines_per_field * 2 / 5
};

//===========================================================================
// Bt848 Scaler Class Implementation
//===========================================================================



/////////////////////////////////////////////////////////////////////////////
// Constructor
/////////////////////////////////////////////////////////////////////////////

Scaler::Scaler( VidField field ):
   CONSTRUCT_SCALER_REGISTERS( ( ( field == VF_Even ) ? 0 : 0x80 ) ),

   // Since VDelay in hardware is reversed; i.e. odd reg is really even field
   // and vice versa, construct the opposite here
   regReverse_CROP ( (0x03 * 4) + ( ( field == VF_Even ) ? 0x80 : 0 ), RW ),
   fieldVDELAY_MSB( regReverse_CROP, 6, 2, RW),
   regVDELAY_LO ( (0x04 * 4) + ( ( field == VF_Even ) ? 0x80 : 0 ), RW ),
   regVDelay( regVDELAY_LO, 8, fieldVDELAY_MSB, RW ),
   m_videoFormat( VFormat_NTSC ), VFilterFlag_( On ),
   m_ptrVideoIn( &NTSCVideoInfo ) 
{
   m_HActive = 0;
   m_pixels = 0;
   m_lines = 0;
   m_VFilter = 0;
   // this seems to be the minimum needed for reliable CC capture
   regVDelay = 0x1A;
}


/////////////////////////////////////////////////////////////////////////////
// Destructor
/////////////////////////////////////////////////////////////////////////////
Scaler::~Scaler()
{
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::VideoFormatChanged( VideoFormat format )
// Purpose: Set which video format is using
// Input:   Video format -
//            Auto format:          VFormat_AutoDetect
//            NTSC (M):             VFormat_NTSC
//            PAL (B, D, G, H, I):  VFormat_PAL_BDGHI
//            PAL (M):              VFormat_PAL_M
//            PAL(N):               VFormat_PAL_N
//            SECAM:                VFormat_SECAM
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::VideoFormatChanged( VideoFormat format )
{
	m_videoFormat = format;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::Scale( MRect & clientScr )
// Purpose: Perform scaling
// Input:   MRect & clientScr - rectangle to scale to
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::Scale( MRect & clientScr )
{
   if ( m_videoFormat == VFormat_NTSC )
      m_ptrVideoIn = &NTSCVideoInfo;   //  set scaling constants for NTSC
   else
      m_ptrVideoIn = &PALVideoInfo;    // set scaling constants for PAL/SECAM

   // the order of functions calling here is important because some
   // calculations are based on previous results
   SetHActive( clientScr ); 
   SetVActive();
   SetVScale( clientScr );
   SetVFilter();
   SetVDelay();
   SetHDelay();
   SetHScale();
   SetHFilter();

}

/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetHActive( MRect & clientScr )
// Purpose: Set HActive register
// Input:   MRect & clientScr - rectangle to scale to
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetHActive( MRect & clientScr )
{
   m_HActive = min( m_ptrVideoIn->Max_Pixels,
                    max( (WORD)clientScr.Width(), m_ptrVideoIn->Min_Pixels ) );

  regHActive = m_HActive;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetHDelay( void )
// Purpose: Set HDelay register
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetHDelay( void )
{
   // calculations here requires calculation of HActive first!
   m_pixels = m_HActive;
   if ( m_pixels < m_ptrVideoIn->Min_UncroppedPixels )
      m_pixels += (WORD) ( ( m_ptrVideoIn->Min_UncroppedPixels - m_pixels + 9 ) / 10 );

   LONG a = (LONG)m_pixels * (LONG)m_ptrVideoIn->Clkx1_HDELAY;
   LONG b = (LONG)m_ptrVideoIn->Clkx1_HACTIVE * 2L;
   WORD HDelay = (WORD) ( ( a + (LONG)m_ptrVideoIn->Clkx1_HACTIVE * 2 - 1) / b * 2L );

   // now add the cropping region into HDelay register; i.e. skip some pixels
   // before we start taking them as real image
   HDelay += (WORD)AnalogWin_.left;

   // HDelay must be even or else color would be wrong
   HDelay &= ~01;

   regHDelay = HDelay;

   // since we increase HDelay, we should decrease HActive by the same amount
   m_HActive -= (WORD)AnalogWin_.left;
   regHActive = m_HActive;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetHScale( void )
// Purpose: Set HScale register
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetHScale( void )
{
   regHScale = (WORD) ( ( ( (LONG)m_ptrVideoIn->Clkx1_HACTIVE * 4096L ) /
                                            (LONG)m_pixels ) - 4096L );
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetHFilter( void )
// Purpose: Set HFilt register field
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetHFilter( void )
{
   if ( m_videoFormat != VFormat_SECAM )
      fieldHFILT = HFilter_AutoFormat;
   else  // SECAM
      if ( m_pixels < m_ptrVideoIn->Clkx1_HACTIVE / 7 )
         fieldHFILT = HFilter_ICON;
      else
         fieldHFILT = HFilter_QCIF;
}         

/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetVScale( MRect & clientScr )
// Purpose: Set VScale register
// Input:   MRect & clientScr - rectangle to scale to
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetVScale( MRect & clientScr )
{
   m_lines = min( m_ptrVideoIn->Max_Lines,
                  max( (WORD)clientScr.Height(), m_ptrVideoIn->Min_Lines ) );

   WORD LPB_VScale_Factor = (WORD) ( 1 + ( m_lines - 1 ) / m_ptrVideoIn->Active_lines_per_field );

   m_lines = (WORD) ( ( m_lines + LPB_VScale_Factor - 1 ) / LPB_VScale_Factor );

   LONG a = (LONG)m_ptrVideoIn->Active_lines_per_field * 512L / (LONG)m_lines;
   WORD VScale = (WORD) ( ( 0x10000L - a + 512L ) & 0x1FFFL );
   regVScale = VScale;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetVDelay( void )
// Purpose: Set VDelay register
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetVDelay( void )
{
   WORD VDelay, moreDelay;

   // increase VDelay will eliminate garbage lines at top of image
   switch ( m_VFilter )
   {
      case 3:
         moreDelay = 4;
         break;

      case 2:
         moreDelay = 2;
         break;
             
      case 1:
      case 0:
      default:
         moreDelay = 0;
         break;
   }

   if ( m_videoFormat == VFormat_NTSC )
      VDelay = 0x001A + moreDelay;    // NTSC
   else
      VDelay = 0x0026 + moreDelay;    // PAL/SECAM
                            
   // now add the cropping region into VDelay register; i.e. skip some pixels
   // before we start taking them as real image
   VDelay += (WORD)( ( (LONG)m_ptrVideoIn->Max_Lines * (LONG)AnalogWin_.top + m_lines - 1 ) / (LONG)m_lines * 2 );

   regVDelay = VDelay;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetVActive( void )
// Purpose: Set VActive register
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetVActive( void )
{
   // No calculation needed for VActive register since it based on the UNSCALED image
   if ( m_videoFormat == VFormat_NTSC )
      regVActive = 0x1F4;
   else
      regVActive = 0x238;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::SetVFilter( void )
// Purpose: Set VFilt register field
// Input:   None
// Output:  None
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::SetVFilter( void )
{
   // this is to remove junk lines at the top of video. flag set to off
   // when image hight is above CIF
   if ( VFilterFlag_ == Off ) {
      fieldVFILT = 0;
      m_VFilter  = 0;
      return;
   }
   if ( ( m_HActive <= m_ptrVideoIn->Max_VFilter3_Pixels ) &&
        ( m_lines   <= m_ptrVideoIn->Max_VFilter3_Lines ) )
      m_VFilter = 3;
   else if ( ( m_HActive <= m_ptrVideoIn->Max_VFilter2_Pixels ) &&
             ( m_lines   <= m_ptrVideoIn->Max_VFilter2_Lines ) )
      m_VFilter = 2;
   else if ( ( m_HActive <= m_ptrVideoIn->Max_VFilter1_Pixels ) &&
             ( m_lines   <= m_ptrVideoIn->Max_VFilter1_Lines ) )
      m_VFilter = 1;
   else
      m_VFilter = 0;

   fieldVFILT = m_VFilter;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::GetDigitalWin( MRect &DigWin ) const
// Purpose: Retreives the size of digital window
// Input:   None
// Output:  MRect &DigWin - retrieved value
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::GetDigitalWin( MRect &DigWin ) const
{
   DigWin = DigitalWin_;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Scaler::SetDigitalWin( const MRect &DigWin )
// Purpose: Sets the size and location of the digital window
// Input:   const MRect &DigWin - window size to set to
// Output:  None
// Return:  Success or Fail if passed rect is bigger then analog window
// Note:    This function can affect the scaling, so Scale() is called
/////////////////////////////////////////////////////////////////////////////
ErrorCode Scaler::SetDigitalWin( const MRect &DigWin )
{
   // we can not scale up
   if ( ( DigWin.Height() > AnalogWin_.Height() ) ||
        ( DigWin.Width() > AnalogWin_.Width() ) )
      return Fail;

   DigitalWin_ = DigWin;

   // every invocation of SetDigitalWin potentially changes the scaling
   Scale( DigitalWin_ );

   return Success;
}


/////////////////////////////////////////////////////////////////////////////
// Method:  void Scaler::GetAnalogWin( MRect &AWin ) const
// Purpose: Retreives the size of analog window
// Input:   None
// Output:  MRect &DigWin - retrieved value
// Return:  None
/////////////////////////////////////////////////////////////////////////////
void Scaler::GetAnalogWin( MRect &AWin ) const
{
   AWin = AnalogWin_;
}

/////////////////////////////////////////////////////////////////////////////
// Method:  ErrorCode Scaler::SetAnalogWin( const MRect &AWin )
// Purpose: Sets the size and location of the analog window
// Input:   const MRect &AWin - window size to set to
// Output:  None
// Return:  Success or Fail if passed rect is bigger then analog window
/////////////////////////////////////////////////////////////////////////////
ErrorCode Scaler::SetAnalogWin( const MRect &AWin )
{
   AnalogWin_ = AWin;
   return Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\vbifmt.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Vbifmt.h 1.4 1998/04/29 22:43:41 tomz Exp $

#ifndef __VBIFMT_H
#define __VBIFMT_H

#include "defaults.h"

KS_DATARANGE_VIDEO_VBI StreamFormatVBI =
{
   // KSDATARANGE
   {
      {
         sizeof( KS_DATARANGE_VIDEO_VBI ),
         0,
         VBISamples * 12,            // SampleSize
         0,                          // Reserved
         { STATIC_KSDATAFORMAT_TYPE_VBI },
         { STATIC_KSDATAFORMAT_SUBTYPE_RAW8 },
         { STATIC_KSDATAFORMAT_SPECIFIER_VBI }
      }
   },
   true,    // BOOL,  bFixedSizeSamples (all samples same size?)
   true,    // BOOL,  bTemporalCompression (all I frames?)
   KS_VIDEOSTREAM_VBI, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
   0,       // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

   // _KS_VIDEO_STREAM_CONFIG_CAPS
   {
      { STATIC_KSDATAFORMAT_SPECIFIER_VBI },
      KS_AnalogVideo_NTSC_M,                       // AnalogVideoStandard
      {
         VBISamples, VBILines  // SIZE InputSize
      },
      {
         VBISamples, 12   // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
      },
      {
         VBISamples, 12   // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
      },
      1,           // int CropGranularityX;       // granularity of cropping size
      1,           // int CropGranularityY;
      1,           // int CropAlignX;             // alignment of cropping rect
      1,           // int CropAlignY;
      {
         VBISamples, 12   // SIZE MinOutputSize;         // smallest bitmap stream can produce
      },
      {
         VBISamples, 12   // SIZE MaxOutputSize;         // largest  bitmap stream can produce
      },
      1,          // int OutputGranularityX;     // granularity of output bitmap size
      2,          // int OutputGranularityY;
      0,          // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
      0,          // StretchTapsY
      0,          // ShrinkTapsX
      0,          // ShrinkTapsY
      333667,     // LONGLONG MinFrameInterval;  // 100 nS units
      333667,     // LONGLONG MaxFrameInterval;
      VBISamples * 30 * VBILines * 2 * 8, // LONG MinBitsPerSecond;
      VBISamples * 30 * VBILines * 2 * 8  // LONG MaxBitsPerSecond;
   },

   // KS_VBIINFOHEADER (default format)
   {
      VBIStart,      // StartLine  -- inclusive
      VBIEnd,        // EndLine    -- inclusive
      VBISampFreq,   // SamplingFrequency
      454,                    // MinLineStartTime;    // (uS past HR LE) * 100
      900,                    // MaxLineStartTime;    // (uS past HR LE) * 100

      // empirically discovered
      780,                    // ActualLineStartTime  // (uS past HR LE) * 100

      5902,                   // ActualLineEndTime;   // (uS past HR LE) * 100
      KS_AnalogVideo_NTSC_M,      // VideoStandard;
      VBISamples,           // SamplesPerLine;
      VBISamples,       // StrideInBytes;
      VBISamples * 12   // BufferSize;
   }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\tuner.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Tuner.h 1.2.1.2 1998/04/29 22:43:41 tomz Exp ssm $

/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996 Brooktree Corporation
//
//  Module:
//
//    Tuner.h
//
//  Abstract:
//
//    Bt878 Tuner class header file
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __TUNER_H
#define __TUNER_H
/*
#include "retcode.h"

/////////////////////////////////////////////////////////////////////////////
// Constants
/////////////////////////////////////////////////////////////////////////////
// US: 87.5 - 108.0, Japan 76 - 91, Eastern Europe 64 - 72
const int MIN_FREQ = 640;     // no decimal place; i.e. 64.0MHz -> 640
const int MAX_FREQ = 1080;
*/

#define  USE_TEMIC_TUNER
//#define  USE_ALPS_TUNER
//#define  USE_PHILIPS_TUNER

#ifdef USE_TEMIC_TUNER
   const  BYTE  TunerI2CAddress   = 0xC2;    // I2C address for Temic tuner
   const  WORD  TunerBandCtrlLow  = 0x8E02;  // Ctrl code for VHF low
   const  WORD  TunerBandCtrlMid  = 0x8E04;  // Ctrl code for VHF high
   const  WORD  TunerBandCtrlHigh = 0x8E01;  // Ctrl code for UHF
#elif defined(USE_ALPS_TUNER)
   const  BYTE  TunerI2CAddress   = 0xC0;    // I2C address for Alps tuner
   const  WORD  TunerBandCtrlLow  = 0xC214;  // Ctrl code for VHF low
   const  WORD  TunerBandCtrlMid  = 0xC212;  // Ctrl code for VHF high
   const  WORD  TunerBandCtrlHigh = 0xC211;  // Ctrl code for UHF
#elif defined(USE_PHILIPS_TUNER)
   const  BYTE  TunerI2CAddress   = 0xC0;    // I2C address for Philips tuner
   const  WORD  TunerBandCtrlLow  = 0xCEA0;  // Ctrl code for VHF low
   const  WORD  TunerBandCtrlMid  = 0xCE90;  // Ctrl code for VHF high
   const  WORD  TunerBandCtrlHigh = 0xCE30;  // Ctrl code for UHF
#endif

#endif // __TUNER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\vidch.cpp ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Vidch.cpp 1.22 1998/05/12 20:39:19 tomz Exp $

#include "vidch.h"
#include "defaults.h"
#include "fourcc.h"
#include "capmain.h"

#ifdef	HAUPPAUGE
#include "HCWDebug.h"
#endif

void CheckSrbStatus( PHW_STREAM_REQUEST_BLOCK pSrb );

BOOL VideoChannel::bIsVBI()
{
   PSTREAMEX pStrmEx = (PSTREAMEX)GetStrmEx( );
   if ( pStrmEx->StreamNumber == STREAM_IDX_VBI )
   {
      return TRUE;
   }
   else
   {
      return FALSE;
   }
}

BOOL VideoChannel::bIsVideo()
{
   PSTREAMEX pStrmEx = (PSTREAMEX)GetStrmEx( );
   if (( pStrmEx->StreamNumber == STREAM_IDX_PREVIEW ) ||
       ( pStrmEx->StreamNumber == STREAM_IDX_CAPTURE ))
   {
      return TRUE;
   }
   else
   {
      return FALSE;
   }
}


/* Method: VideoChannel::SetDigitalWindow
 * Purpose: Sets the output image size
 * Input: r:   MRect &
 * Output:
 */
ErrorCode VideoChannel::SetDigitalWindow( MRect &r )
{
   Trace t("VideoChannel::SetDigitalWindow()");
   return Digitizer_->SetDigitalWindow( r, *OurField_ );
}

/* Method: VideoChannel::SetAnalogWindow
 * Purpose: Sets the analog dimention for this stream
 * Input: r: MRect &
 * Output:
 */
ErrorCode VideoChannel::SetAnalogWindow( MRect &r )
{
   Trace t("VideoChannel::SetAnalogWindow()");
   return Digitizer_->SetAnalogWindow( r, *OurField_ );
}

/* Method: VideoChannel::OpenChannel
 * Purpose: Allocates a stream from a capture chip
 * Input:
 * Output:
 * Note: It is possible that the current implementation does not require an
 *   elaborate stream allocation scheme. Nonetheless it is used as number of
 *   streams can increase in the future and their dynamics can change
 */
ErrorCode VideoChannel::OpenChannel()
{
   Trace t("VideoChannel::OpenChannel()");

   // can not open twice
   if ( IsOpen() == true )
      return Fail;
   if ( Digitizer_->AllocateStream( OurField_, Stream_ ) == Success ) {
      // store information for all subsequent calls

      SetPaired( false );

      OurField_->SetCallback( &Caller_ );
      SetInterrupt( true );

      // flag the state
      SetOpen();

      SetDefaultQue();
      return Success;
   }
   return Fail;
}

/* Method: VideoChannel::CloseChannel
 * Purpose: Closes the channel. Makes sure everything is freed
 * Input:
 * Output:
 */
ErrorCode VideoChannel::CloseChannel()
{
   Trace t("VideoChannel::CloseChannel()");

   if ( !IsOpen() )
      return Fail;
   
   Stop( );

   while( !BufQue_.IsEmpty( ) )
   {
      DataBuf buf = BufQue_.Get();
   }

   BufQue_.Flush();

   while( !Requests_.IsEmpty( ) )
   {
      PHW_STREAM_REQUEST_BLOCK pSrb = Requests_.Get();
      if ( RemoveSRB( pSrb ))
      {
         DebugOut((0, "   RemoveSRB failed\n"));
         DEBUG_BREAKPOINT();
      }
   }

   Requests_.Flush();

   SetClose();
   return Success;
}

/* Method: VideoChannel::SetFormat
 * Purpose:
 * Input:
 * Output:
 */
ErrorCode VideoChannel::SetFormat( ColFmt aFormat )
{
   Trace t("VideoChannel::SetFormat()");
   Digitizer_->SetPixelFormat( aFormat, *OurField_ );
   return Success;
}

/* Method: VideoChannel::GetFormat
 * Purpose:
 * Input:
 * Output:
 */
ColFmt VideoChannel::GetFormat()
{
   Trace t("VideoChannel::GetFormat()");
   return Digitizer_->GetPixelFormat( *OurField_ );
}

/* Method: VideoChannel::AddBuffer
 * Purpose: This function adds a buffer to a queue
 * Input: pNewBuffer: PVOID - pointer to a buffer to add
 * Output: None
 * Note: This function 'does not know' where the queue is located. It just uses
 *   a pointer to it.
 */
void VideoChannel::AddBuffer( PVOID pPacket )
{
   Trace t("VideoChannel::AddBuffer()");
   DataBuf buf( GetSRB(), pPacket );

   BufQue_.Put( buf );
   DebugOut((1, "AddBuf %x\n", pPacket ) );

   LONGLONG *pB1 = (LONGLONG *)pPacket;
   LONGLONG *pB2 = pB1 + 1;
#ifdef DEBUG
   for ( UINT i = 0; i < 640; i++ ) {
#endif
      *pB1 = 0xAAAAAAAA33333333;
      *pB2 = 0xBBBBBBBB22222222;
#ifdef DEBUG
      pB1 += 2;
      pB2 += 2;
   }
#endif
}

/* Method: VideoChannel::ResetCounters
 * Purpose: Reset the frame info counters
 * Input: None
 * Output: None
 */
VOID VideoChannel::ResetCounters( )
{
   ULONG StreamNumber = Stream_;
   if ( StreamNumber == STREAM_IDX_VBI )
   {
      PKS_VBI_FRAME_INFO pSavedFrameInfo = &((PSTREAMEX)GetStrmEx())->FrameInfo.VbiFrameInfo;
      pSavedFrameInfo->ExtendedHeaderSize = sizeof( KS_VBI_FRAME_INFO );
      pSavedFrameInfo->PictureNumber = 0;
      pSavedFrameInfo->DropCount = 0;
   }
   else
   {
      PKS_FRAME_INFO pSavedFrameInfo = &((PSTREAMEX)GetStrmEx())->FrameInfo.VideoFrameInfo;
      pSavedFrameInfo->ExtendedHeaderSize = sizeof( KS_FRAME_INFO );
      pSavedFrameInfo->PictureNumber = 0;
      pSavedFrameInfo->DropCount = 0;
   }
}

/* Method: VideoChannel::TimeStamp
 * Purpose: Performs the standard buffer massaging when it's done
 * Input: pSrb
 * Output: None
 */
void STREAMAPI VideoChannel::TimeStamp( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("VideoChannel::TimeStamp()");

   PKSSTREAM_HEADER  pDataPacket = pSrb->CommandData.DataBufferArray;
   VideoChannel *chan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;

   pDataPacket->PresentationTime.Numerator = 1;
   pDataPacket->PresentationTime.Denominator = 1;

	if( chan->IsVideoInfo2() )
	{
		pDataPacket->DataUsed = chan->GetVidHdr2()->bmiHeader.biSizeImage;
	}
	else
	{
		pDataPacket->DataUsed = chan->GetVidHdr()->bmiHeader.biSizeImage;
	}

   pDataPacket->Duration = chan->GetTimePerFrame();

   DebugOut((1, "DataUsed = %d\n", pDataPacket->DataUsed));

   // [TMZ] [!!!] - hack, timestamping seems broken
   if( 0 ) {
   //if( hMasterClock ) {
      pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;
      pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_TIMEVALID;
      //pDataPacket->OptionsFlags &= ~KSSTREAM_HEADER_OPTIONSF_TIMEVALID;

      HW_TIME_CONTEXT   TimeContext;

      TimeContext.HwDeviceExtension = (struct _HW_DEVICE_EXTENSION *)pSrb->HwDeviceExtension;
      TimeContext.HwStreamObject    = pSrb->StreamObject;
      TimeContext.Function          = TIME_GET_STREAM_TIME;

      StreamClassQueryMasterClockSync (
         chan->hMasterClock,
         &TimeContext
      );

      /*
      LARGE_INTEGER     Delta;

      Delta.QuadPart = TimeContext.Time;
      
      if( TimeContext.Time > (ULONGLONG) Delta.QuadPart )
      {
         pDataPacket->PresentationTime.Time = TimeContext.Time;
      } else {
         pDataPacket->PresentationTime.Time = 0;
      }
      */
      pDataPacket->PresentationTime.Time = TimeContext.Time;

   } else {
      pDataPacket->OptionsFlags &= ~KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;
      pDataPacket->OptionsFlags &= ~KSSTREAM_HEADER_OPTIONSF_TIMEVALID;
      pDataPacket->PresentationTime.Time = 0;
   }

   // now gather the statistics
   PKS_FRAME_INFO pSavedFrameInfo = &((PSTREAMEX)chan->GetStrmEx())->FrameInfo.VideoFrameInfo;
   pSavedFrameInfo->ExtendedHeaderSize = sizeof( KS_FRAME_INFO );
   pSavedFrameInfo->PictureNumber++;
   pSavedFrameInfo->DropCount = 0;

   PKS_FRAME_INFO pFrameInfo =
   (PKS_FRAME_INFO) ( pSrb->CommandData.DataBufferArray + 1 );

   // copy the information to the outbound buffer
   pFrameInfo->ExtendedHeaderSize = pSavedFrameInfo->ExtendedHeaderSize;
   pFrameInfo->PictureNumber =      pSavedFrameInfo->PictureNumber;
   pFrameInfo->DropCount =          pSavedFrameInfo->DropCount;

   if ( pFrameInfo->DropCount ) {
      pSrb->CommandData.DataBufferArray->OptionsFlags |=
         KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
   }

   // Every frame we generate is a key frame (aka SplicePoint)
   // Delta frames (B or P) should not set this flag

   pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT;

   // make the stream class driver happy
   pSrb->Status = STATUS_SUCCESS;

   DebugOut((1, "*** 2 *** completing SRB %x\n", pSrb));
   CheckSrbStatus( pSrb );
   StreamClassStreamNotification( StreamRequestComplete, pSrb->StreamObject, pSrb );
   
   DebugOut((1, "Signal SRB - %x\n", pSrb->CommandData.DataBufferArray->Data ) );
   DebugOut((1, "********** NeedNotification_ = %d\n", chan->NeedNotification_ ) );

   if ( chan->NeedNotification_ ) {
      // queue was full; now it has at least one entry 
      StreamClassStreamNotification( ReadyForNextStreamDataRequest, pSrb->StreamObject );
   }
}

/* Method: VideoChannel::Interrupt
 * Purpose: Called by the interface class on behalf of capture chip to let know
 *   an interrupt happened.
 * Input: pTag: PVOID, to be passed to the Digitizer_
 * Output: None
 */
void VideoChannel::Interrupt( PVOID pTag, bool skipped )
{
   Trace t("VideoChannel::Interrupt()");

   Digitizer_->ProcessBufferAtInterrupt( pTag );

   if ( skipped ) {
      DebugOut((1, "VidChan::Interrupt skipped\n" ) );
      return;
   }
   // let the class driver know we are done with this buffer
   if ( !Requests_.IsEmpty() ) {
      PHW_STREAM_REQUEST_BLOCK pSrb = Requests_.Get();
      TimeStamp( pSrb ); // [TMZ] [!!!] [HACK]
   }
}

/* Method: VideoChannel::Create
 * Purpose: Creates the stream
 * Input: None
 * Output: None
 */
ErrorCode VideoChannel::Create()
{
   Trace t("VideoChannel::Create()");

	KS_VIDEOINFOHEADER* pVideoInfoHdr = NULL;
	KS_VIDEOINFOHEADER2* pVideoInfoHdr2 = NULL;

	DWORD				biCompression;
	WORD				biBitCount;
	LONG				biWidth;
	LONG				biHeight;
   LONG				biWidthBytes;

	if( IsVideoInfo2() )
	{
		pVideoInfoHdr2 = GetVidHdr2();
		biCompression = pVideoInfoHdr2->bmiHeader.biCompression;
		biBitCount = pVideoInfoHdr2->bmiHeader.biBitCount;   
		biWidth = pVideoInfoHdr2->bmiHeader.biWidth;      
		biHeight = abs(pVideoInfoHdr2->bmiHeader.biHeight);     
	}
	else
	{
		pVideoInfoHdr = GetVidHdr();
		biCompression = pVideoInfoHdr->bmiHeader.biCompression;
		biBitCount = pVideoInfoHdr->bmiHeader.biBitCount;   
		biWidth = pVideoInfoHdr->bmiHeader.biWidth;      
		biHeight = abs(pVideoInfoHdr->bmiHeader.biHeight);     
	}

   MRect analog( 0, 0, biWidth, biHeight );
   MRect ImageRect( 0, 0, biWidth, biHeight );

   DebugOut((1, "**************************************************************************\n"));
   DebugOut((1, "biCompression = %d\n", biCompression));
   DebugOut((1, "biBitCount = %d\n", biBitCount));

   if ( pVideoInfoHdr->bmiHeader.biCompression == 3)
	{
		if( IsVideoInfo2() )
		{
			pVideoInfoHdr2->bmiHeader.biCompression = FCC_YUY2;
			biCompression = FCC_YUY2;
		}
		else
		{
			pVideoInfoHdr->bmiHeader.biCompression = FCC_YUY2;
			biCompression = FCC_YUY2;
		}
	}

   ColorSpace tmp( biCompression, biBitCount );

   DebugOut((1, "ColorFormat = %d\n", tmp.GetColorFormat()));
   DebugOut((1, "**************************************************************************\n"));

   OurField_->ResetCounters();
   ResetCounters();
      
   // verify that we are not asked to produce a smaller image

   #ifdef HACK_FUDGE_RECTANGLES
	if( IsVideoInfo2() )
	{
      if( pVideoInfoHdr2->rcTarget.bottom == 0 ) 
		{
            // [!!!] [TMZ] - hack
            pVideoInfoHdr2->rcTarget.left    = 0;
            pVideoInfoHdr2->rcTarget.top     = 0;
            pVideoInfoHdr2->rcTarget.right   = biWidth;
            pVideoInfoHdr2->rcTarget.bottom  = biHeight;
      }
	}
	else
	{
      if( pVideoInfoHdr->rcTarget.bottom == 0 ) 
		{
            // [!!!] [TMZ] - hack
            pVideoInfoHdr->rcTarget.left    = 0;
            pVideoInfoHdr->rcTarget.top     = 0;
            pVideoInfoHdr->rcTarget.right   = biWidth;
            pVideoInfoHdr->rcTarget.bottom  = biHeight;
      }
	}
   #endif


   MRect		dst;
   MRect		src;
	if( IsVideoInfo2() )
	{
		dst.Set( pVideoInfoHdr2->rcTarget.left, pVideoInfoHdr2->rcTarget.top, pVideoInfoHdr2->rcTarget.right, pVideoInfoHdr2->rcTarget.bottom );
		src.Set( pVideoInfoHdr2->rcSource.left, pVideoInfoHdr2->rcSource.top, pVideoInfoHdr2->rcSource.right, pVideoInfoHdr2->rcSource.bottom );
	}
	else
	{
		dst.Set( pVideoInfoHdr->rcTarget.left, pVideoInfoHdr->rcTarget.top, pVideoInfoHdr->rcTarget.right, pVideoInfoHdr->rcTarget.bottom );
		src.Set( pVideoInfoHdr->rcSource.left, pVideoInfoHdr->rcSource.top, pVideoInfoHdr->rcSource.right, pVideoInfoHdr->rcSource.bottom );
	}
   if ( !dst.IsEmpty() ) 
	{
      // use the new size                                  
      ImageRect = dst;
      if ( !src.IsEmpty() )
		{
         analog = src;
		}
      else
		{
         analog = dst;
		}
      // calculate the offset for the new beginning of the data
      dwBufferOffset_ = dst.top * biWidth + dst.left * tmp.GetPitchBpp();
      // when rcTarget is non-empty, biWidth is stride of the buffer
      biWidthBytes = biWidth;
   } 
	else
	{
      biWidthBytes = biWidth * tmp.GetPitchBpp() / 8;
	}


	if( IsVideoInfo2() )
	{
		DebugOut((1, "pVideoInfoHdr2->rcTarget(%d, %d, %d, %d)\n", 
						  pVideoInfoHdr2->rcTarget.left, 
						  pVideoInfoHdr2->rcTarget.top, 
						  pVideoInfoHdr2->rcTarget.right, 
						  pVideoInfoHdr2->rcTarget.bottom
						  ));
	}
	else
	{
		DebugOut((1, "pVideoInfoHdr->rcTarget(%d, %d, %d, %d)\n", 
						  pVideoInfoHdr->rcTarget.left, 
						  pVideoInfoHdr->rcTarget.top, 
						  pVideoInfoHdr->rcTarget.right, 
						  pVideoInfoHdr->rcTarget.bottom
						  ));
	}
   DebugOut((1, "dst(%d, %d, %d, %d)\n", 
                 dst.left, 
                 dst.top, 
                 dst.right, 
                 dst.bottom
                 ));
   DebugOut((1, "Pitch =%d, width = %d\n", biWidthBytes, dst.Width() ) );

   SetBufPitch( biWidthBytes );

   if ( SetAnalogWindow ( analog  ) == Success && //<-must be set first !
        SetDigitalWindow( ImageRect ) == Success &&
        SetFormat( tmp.GetColorFormat() ) == Success &&
        Digitizer_->Create( *OurField_ ) == Success ) 
	{
      State_ = Created;
      return Success;
   }
   return Fail;
}

/* Method: VideoChannel::Start
 * Purpose: Starts the stream
 * Input: None
 * Output: None
 */
void VideoChannel::Start()
{
   Trace t("VideoChannel::Start()");
   State_ = Started;
   Digitizer_->Start( *OurField_ );
}

/* Method: VideoChannel::Stop
 * Purpose: Stops the stream
 * Input: None
 * Output: None
 */
ErrorCode VideoChannel::Stop()
{
   Trace t("VideoChannel::Stop()");

   if ( !IsOpen() )
      return Fail;

   Digitizer_->Stop( *OurField_ );
   State_ = Open;

   while( !BufQue_.IsEmpty( ) )
   {
      DataBuf buf = BufQue_.Get();
   }

   BufQue_.Flush();
   return Success;
}

/* Method: VideoChannel::Pause
 * Purpose: Stops the stream
 * Input: None
 * Output: None
 */
ErrorCode VideoChannel::Pause()
{
   Trace t("VideoChannel::Pause()");

   Digitizer_->Pause( *OurField_ );
   State_ = Paused;
   OurField_->ResetCounters();  // jaybo
   ResetCounters();
   return Success;
}

/* Method: VideoChanIface::Notify
 * Purpose:  Notifies the VideoChannel that an interrupt happened
 * Input: None
 * Output: None
 */
void VideoChanIface::Notify( PVOID pTag, bool skipped  )
{
   Trace t("VideoChanIface::Notify()");
   ToBeNotified_->Interrupt( pTag, skipped  );
}

/* Method: VideoChannel::AddSRB
 * Purpose: Adds SRB and buffer to the queues
 * Input: pSrb
 * Output: None
 */
void VideoChannel::AddSRB( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("VideoChannel::AddSRB()");

   Requests_.Put( pSrb );
   SetSRB( pSrb );

   PUCHAR pBufAddr = (PUCHAR)pSrb->CommandData.DataBufferArray->Data;
   AddBuffer( pBufAddr + dwBufferOffset_ );

   // don't forget to report our field type !
   // this cast is valid for VBI FRAME as well ( see ksmedia.h )
   PKS_FRAME_INFO pFrameInfo =
   (PKS_FRAME_INFO) ( pSrb->CommandData.DataBufferArray + 1 );
   pFrameInfo->dwFrameFlags = FieldType_;

   // ask for more buffers
   CheckNotificationNeed();
}

/* Method: VideoChannel::RemoveSRB
 * Purpose: Removes SRB from the queue and signals it
 * Input: pSrb
 * Output: None
 */

bool VideoChannel::RemoveSRB( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("VideoChannel::RemoveSRB()");

/*
	//FGR - TODO: i guess we should see if there really is a record of this SRB
   if(Requests_.IsEmpty()){
	   pSrb->Status = STATUS_CANCELLED;

      DebugOut((1, "*** 3 *** completing SRB %x\n", pSrb));
      CheckSrbStatus( pSrb );
      StreamClassStreamNotification( StreamRequestComplete, pSrb->StreamObject, pSrb );
      //StreamClassStreamNotification( ReadyForNextStreamDataRequest, pSrb->StreamObject );

	   return( true );
   }
*/

   int n = 0;
   
   n = Requests_.GetNumOfItems();
   DebugOut((1, "VideoChannel::RemoveSRB - Found %d SRBs in queue\n", n));

   bool bFound = false;

   // cycle through the list
   // pull from the head, put to the tail
   // if we find our pSrb during one cycle, pull it out

   while ( n-- > 0 ) // yes it can go negative
   {
      PHW_STREAM_REQUEST_BLOCK pTempSrb = Requests_.Get();
      if ( pTempSrb == pSrb )
      {
         // Pull him out
         if  ( bFound )
         {
            DebugOut((0, "Found pSrb(%x) in the queue more than once\n", pSrb));
            DEBUG_BREAKPOINT();
         }
         else
         {
            bFound = true;
   	      pSrb->Status = STATUS_CANCELLED;

            DebugOut((1, "*** 4 *** completing SRB %x\n", pSrb));
            CheckSrbStatus( pSrb );
            StreamClassStreamNotification( StreamRequestComplete, pSrb->StreamObject, pSrb );
            //StreamClassStreamNotification( ReadyForNextStreamDataRequest, pSrb->StreamObject );
         }
         n--;  // warning: if this is the last, it will go negative
      }
      else
      {
         Requests_.Put( pTempSrb );
      }
   }

   n = Requests_.GetNumOfItems();
   DebugOut((1, "VideoChannel::RemoveSRB - Left %d SRBs in queue, returning %d\n", n, bFound));

/*   
   PHW_STREAM_REQUEST_BLOCK InQueSRB = Requests_.PeekLeft();
   if ( InQueSRB == pSrb ) {

      InQueSRB = Requests_.Get();
      InQueSRB->Status = STATUS_CANCELLED;

      DebugOut((1, "Cancel SRB -%x\n", pSrb ) );

      CheckSrbStatus( pSrb );
      StreamClassStreamNotification( StreamRequestComplete,
         InQueSRB->StreamObject, InQueSRB );

      if ( Requests_.IsEmpty() )
         DebugOut((1, " queue is empty\n" ) );
      else
         DebugOut((1, "queue is not empty\n" ) );

	   return( true );

   } else {
//      DebugOut((1, "Cancelling wrong SRB ! - %x, %x\n", pSrb, InQueSRB ) );
//#ifdef	HAUPPAUGE
//	  TRAP();
//#endif
//   }
	   InQueSRB = Requests_.PeekRight();
	   if ( InQueSRB == pSrb ) {
		   InQueSRB = Requests_.GetRight();
		   InQueSRB->Status = STATUS_CANCELLED;
		   DebugOut((1, "Cancel SRB from right - %x\n", pSrb ) );
         CheckSrbStatus( pSrb );
		   StreamClassStreamNotification( StreamRequestComplete,
			   pSrb->StreamObject, pSrb );
	      return( true );
	   } else {
         DebugOut((0, "Cancelling wrong SRB from right too! - %x, %x\n", pSrb, InQueSRB ) );
	      return( false );
	   }
   }
*/
   return( bFound );
}

VideoChannel::~VideoChannel()
{
   Trace t("VideoChannel::~VideoChannel()");
   CloseChannel();
}

/* Method: VideoChannel::CheckNotificationNeed
 * Purpose: Sees if there is room for more buffers
 * Input: None
 * Output: None
 */
void VideoChannel::CheckNotificationNeed()
{
   Trace t("VideoChannel::CheckNotificationNeed()");

   if ( !BufQue_.IsFull() ) {
      // always hungry for more
      StreamClassStreamNotification( ReadyForNextStreamDataRequest, pSRB_->StreamObject );
      NeedNotification_ = false;
   } else
      NeedNotification_ = true;
}

/* Method: InterVideoChannel::Interrupt
 * Purpose: Processes the interrupt for the interleaved video streams
 * Input: pTag: PVOID - index in reality
 *   skipped: bool - indicates if buffer was written to
 * Output: None
 */
void InterVideoChannel::Interrupt( PVOID pTag, bool skipped )
{
   Trace t("InterVideoChannel::Interrupt()");

   int idx = (int)pTag;
   slave.IntNotify( PVOID( idx - ProgsWithinField ), skipped );
   Parent::Interrupt( pTag, skipped );
}

/* Method: InterVideoChannel::AddSRB
 * Purpose: Adds SRB to itself and dispatches 2 buffer pointers, one to each
 *   channel
 * Input: pSRB
 * Output: None
 */
void InterVideoChannel::AddSRB( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("InterVideoChannel::AddSRB()");

   PUCHAR pBufAddr = (PUCHAR)pSrb->CommandData.DataBufferArray->Data;
   // biWidth was set in Create()
   UINT biWidthBytes;
	if( IsVideoInfo2() )
	{
		biWidthBytes = VidHeader2_.bmiHeader.biWidth / 2;
	}
	else
	{
		biWidthBytes = VidHeader_.bmiHeader.biWidth / 2;
	}

   // to be used when adding buffer
   SetSRB( pSrb );
   slave.SetSRB( pSrb );

   // need to swap addresses for even/odd fields for RGB formats due to up-side-down bitmaps
   ColorSpace tmp( GetFormat() );
   if ( !( tmp.GetColorFormat() > CF_RGB8 && tmp.GetColorFormat() < CF_VBI ) ) 
	{
      // put buffer in its place
      // and adjusted address into the other channel
      slave.AddBuffer( pBufAddr + biWidthBytes );
      AddBuffer( pBufAddr );
   } 
	else 
	{
      slave.AddBuffer( pBufAddr );
      AddBuffer( pBufAddr + biWidthBytes );
   }

   // don't forget to add the SRB !
   Requests_.Put( pSrb );

   // set field type to full frame.
   PKS_FRAME_INFO pFrameInfo = (PKS_FRAME_INFO)( pSrb->CommandData.DataBufferArray + 1 );
   pFrameInfo->dwFrameFlags = KS_VIDEO_FLAG_FRAME;

   CheckNotificationNeed();
}

/* Function: SplitFrame
 * Purpose: Halfs the size of the video image so 2 fields can be used to create
 *   the original size
 * Input: VidHdr: KS_VIDEOINFOHEADER &
 * Output: None
 */
inline void  SplitFrame( KS_VIDEOINFOHEADER &VidHdr )
{
   Trace t("SplitFrame()");

   VidHdr.bmiHeader.biHeight /= 2;
   VidHdr.rcSource.top /= 2;
   VidHdr.rcTarget.top /= 2;
   VidHdr.rcSource.bottom /= 2;
   VidHdr.rcTarget.bottom /= 2;
}

inline void  SplitFrame2( KS_VIDEOINFOHEADER2 &VidHdr2 )
{
   Trace t("SplitFrame()");

   VidHdr2.bmiHeader.biHeight /= 2;
   VidHdr2.rcSource.top /= 2;
   VidHdr2.rcTarget.top /= 2;
   VidHdr2.rcSource.bottom /= 2;
   VidHdr2.rcTarget.bottom /= 2;
}


/* Method: InterVideoChannel::Create
 * Purpose: Sets the video parameters for the slave channel and
 *   calls into parent to create both
 * Input: None
 * Output: None
 */
ErrorCode InterVideoChannel::Create()
{
   Trace t("InterVideoChannel::Create()");

//   slave.SetInterrupt( false );
   slave.SetCallback( 0 );
   // restore the original as SplitFrame mangles the parameters

	MRect		dst;
	DWORD				biCompression;
	WORD				biBitCount;
   LONG				biWidthBytes;

	if( IsVideoInfo2() )
	{
		VidHeader2_ = OrigVidHeader2_;
		// split a frame into two fields
		SplitFrame2( VidHeader2_ );
		// double up the pitch, so we can interleave the buffers
		dst.Set( VidHeader2_.rcTarget.left, VidHeader2_.rcTarget.top, VidHeader2_.rcTarget.right, VidHeader2_.rcTarget.bottom );
		biCompression = VidHeader2_.bmiHeader.biCompression;
		biBitCount = VidHeader2_.bmiHeader.biBitCount;
	}
	else
	{
		VidHeader_ = OrigVidHeader_;
		// split a frame into two fields
		SplitFrame( VidHeader_ );
		// double up the pitch, so we can interleave the buffers
		dst.Set( VidHeader_.rcTarget.left, VidHeader_.rcTarget.top, VidHeader_.rcTarget.right, VidHeader_.rcTarget.bottom );
		biCompression = VidHeader_.bmiHeader.biCompression;
		biBitCount = VidHeader_.bmiHeader.biBitCount;
	}


   ColorSpace tmp( biCompression, biBitCount );

   if ( !dst.IsEmpty() ) 
	{
      // biWidth is the stride in bytes
		if( IsVideoInfo2() )
		{
			VidHeader2_.bmiHeader.biWidth *= 2 * 2;
			biWidthBytes = VidHeader2_.bmiHeader.biWidth;
		}
		else
		{
			VidHeader_.bmiHeader.biWidth *= 2 * 2;
			biWidthBytes = VidHeader_.bmiHeader.biWidth;
		}
   } 
	else 
	{
		if( IsVideoInfo2() )
		{
			// calculate the number of bytes per scan line
			biWidthBytes = tmp.GetPitchBpp() * VidHeader2_.bmiHeader.biWidth / 8;
			// can it be non-aligned ??
			biWidthBytes += 3;
			biWidthBytes &= ~3;

			// must be increased two times to interleave the fields;
			biWidthBytes *= 2;

			// the rcTarget uses half the original height and full width
			VidHeader2_.rcTarget = MRect(
				0, 
				0, 
				VidHeader2_.bmiHeader.biWidth,
				abs(VidHeader2_.bmiHeader.biHeight) 
			);

			DebugOut((1, "VidHeader2_.rcTarget(%d, %d, %d, %d)\n", 
							  VidHeader2_.rcTarget.left, 
							  VidHeader2_.rcTarget.top, 
							  VidHeader2_.rcTarget.right, 
							  VidHeader2_.rcTarget.bottom
							  ));

			// have to trick the slave into using correct ( doubled ) pitch
			VidHeader2_.bmiHeader.biWidth = biWidthBytes; // this is the pitch slave uses
		}
		else
		{
			// calculate the number of bytes per scan line
			biWidthBytes = tmp.GetPitchBpp() * VidHeader_.bmiHeader.biWidth / 8;
			// can it be non-aligned ??
			biWidthBytes += 3;
			biWidthBytes &= ~3;

			// must be increased two times to interleave the fields;
			biWidthBytes *= 2;

			// the rcTarget uses half the original height and full width
			VidHeader_.rcTarget = MRect(
				0, 
				0, 
				VidHeader_.bmiHeader.biWidth,
				abs(VidHeader_.bmiHeader.biHeight) 
			);

			DebugOut((1, "VidHeader_.rcTarget(%d, %d, %d, %d)\n", 
							  VidHeader_.rcTarget.left, 
							  VidHeader_.rcTarget.top, 
							  VidHeader_.rcTarget.right, 
							  VidHeader_.rcTarget.bottom
							  ));

			// have to trick the slave into using correct ( doubled ) pitch
			VidHeader_.bmiHeader.biWidth = biWidthBytes; // this is the pitch slave uses
		}
   }
   SetBufPitch( biWidthBytes );

	// at this point slave will have all the members set up properly
	if( IsVideoInfo2() )
	{
		slave.SetVidHdr2( VidHeader2_ );
	}
	else
	{
		slave.SetVidHdr( VidHeader_ );
	}
   slave.SetPaired( true );

   // needed for full-size YUV9 and other planar modes
   Digitizer_->SetPlanarAdjust( biWidthBytes / 2 );

   return Parent::Create();
}

/* Method: VideoChannel::GetStreamType
 * Purpose: reports back type of the stream. Used when destroying channels
 */
StreamType VideoChannel::GetStreamType()
{
   Trace t("VideoChannel::GetStreamType()");
   return Single;
}

/* Method: VideoChannel::TimeStampVBI
 * Purpose: Performs the standard buffer massaging when it's done
 * Input: pSrb
 * Output: None
 */
void STREAMAPI VideoChannel::TimeStampVBI( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("VideoChannel::TimeStamp()");

   PKSSTREAM_HEADER  pDataPacket = pSrb->CommandData.DataBufferArray;
   VideoChannel *chan = (VideoChannel *)((PSTREAMEX)pSrb->StreamObject->HwStreamExtension)->videochannel;

   pDataPacket->PresentationTime.Numerator = 1;
   pDataPacket->PresentationTime.Denominator = 1;

	if( chan->IsVideoInfo2() )
	{
		pDataPacket->DataUsed = chan->GetVidHdr2()->bmiHeader.biSizeImage;
	}
	else
	{
		pDataPacket->DataUsed = chan->GetVidHdr()->bmiHeader.biSizeImage;
	}

   pDataPacket->Duration = chan->GetTimePerFrame();

   DebugOut((1, "DataUsed = %d\n", pDataPacket->DataUsed));

   // [TMZ] [!!!] - hack, timestamping seems broken
   if( 0 ) {
   //if( hMasterClock ) {
      pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;
      pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_TIMEVALID;
      //pDataPacket->OptionsFlags &= ~KSSTREAM_HEADER_OPTIONSF_TIMEVALID;

      HW_TIME_CONTEXT   TimeContext;

      TimeContext.HwDeviceExtension = (struct _HW_DEVICE_EXTENSION *)pSrb->HwDeviceExtension;
      TimeContext.HwStreamObject    = pSrb->StreamObject;
      TimeContext.Function          = TIME_GET_STREAM_TIME;

      StreamClassQueryMasterClockSync (
         chan->hMasterClock,
         &TimeContext
      );

      /*
      LARGE_INTEGER     Delta;

      Delta.QuadPart = TimeContext.Time;
      
      if( TimeContext.Time > (ULONGLONG) Delta.QuadPart )
      {
         pDataPacket->PresentationTime.Time = TimeContext.Time;
      } else {
         pDataPacket->PresentationTime.Time = 0;
      }
      */
      pDataPacket->PresentationTime.Time = TimeContext.Time;

   } else {
      pDataPacket->OptionsFlags &= ~KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;
      pDataPacket->OptionsFlags &= ~KSSTREAM_HEADER_OPTIONSF_TIMEVALID;
      pDataPacket->PresentationTime.Time = 0;
   }

   PKS_VBI_FRAME_INFO pSavedFrameInfo = &((PSTREAMEX)chan->GetStrmEx())->FrameInfo.VbiFrameInfo;
   pSavedFrameInfo->ExtendedHeaderSize = sizeof( PKS_VBI_FRAME_INFO );
   pSavedFrameInfo->PictureNumber++;
   pSavedFrameInfo->DropCount = 0;

   // now gather the statistics
   PKS_VBI_FRAME_INFO pFrameInfo =
   (PKS_VBI_FRAME_INFO) ( pSrb->CommandData.DataBufferArray + 1 );

   // copy the information to the outbound buffer
   pFrameInfo->ExtendedHeaderSize = pSavedFrameInfo->ExtendedHeaderSize;
   pFrameInfo->PictureNumber =      pSavedFrameInfo->PictureNumber;
   pFrameInfo->DropCount =          pSavedFrameInfo->DropCount;

   pFrameInfo->dwSamplingFrequency = VBISampFreq; // Bug - changes with video format

   if ( ((VBIChannel*)(chan))->Dirty_ ) { // propagate the tv tuner change notification
      ((VBIChannel*)(chan))->Dirty_ = false;
      pFrameInfo->TvTunerChangeInfo = ((VBIChannel*)(chan))->TVTunerChangeInfo_;
      pFrameInfo->dwFrameFlags      |= KS_VBI_FLAG_TVTUNER_CHANGE;
      pFrameInfo->VBIInfoHeader     = ((VBIChannel*)(chan))->VBIInfoHeader_;
      pFrameInfo->dwFrameFlags      |= KS_VBI_FLAG_VBIINFOHEADER_CHANGE ;
   } else {
      pFrameInfo->dwFrameFlags &= ~KS_VBI_FLAG_TVTUNER_CHANGE;
      pFrameInfo->dwFrameFlags &= ~KS_VBI_FLAG_VBIINFOHEADER_CHANGE;
   }

   if ( pFrameInfo->DropCount ) {
      pSrb->CommandData.DataBufferArray->OptionsFlags |=
         KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
   }

    // Every frame we generate is a key frame (aka SplicePoint)
    // Delta frames (B or P) should not set this flag

    pDataPacket->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT;

   // make the stream class driver happy
   pSrb->Status = STATUS_SUCCESS;

   DebugOut((1, "*** 5 *** completing SRB %x\n", pSrb));
   CheckSrbStatus( pSrb );
   StreamClassStreamNotification( StreamRequestComplete, pSrb->StreamObject, pSrb );

   DebugOut((1, "Signal SRB - %x\n", pSrb->CommandData.DataBufferArray->Data ) );

   DebugOut((1, "********** NeedNotification_ = %d\n", chan->NeedNotification_ ) );

   if ( chan->NeedNotification_ ) {
      // queue was full; now it has at least one entry 
      StreamClassStreamNotification( ReadyForNextStreamDataRequest,
         pSrb->StreamObject );
   }
}

/* Method: VBIAlterChannel::Interrupt
 * Purpose: Processes the interrupt for the VBI channel
 */
void VBIChannel::Interrupt( PVOID pTag, bool skipped )
{
   Trace t("VBIChannel::Interrupt()");

   if ( Requests_.IsEmpty( ) )
   {
      DebugOut((1, "VBI interrupt, but Requests_ is empty\n"));
      return;
   }

   // save the SRB for further processing ( it is gone from the qu in the Parent::Interrupt
   PHW_STREAM_REQUEST_BLOCK pSrb = Requests_.PeekLeft();

   // Parent::Interrupt( pTag, skipped );
   {
      Digitizer_->ProcessBufferAtInterrupt( pTag );

      if ( skipped ) {
         DebugOut((1, "VidChan::Interrupt skipped\n" ) );
         return;
      }
      // let the class driver know we are done with this buffer
      if ( !Requests_.IsEmpty() ) {
         PHW_STREAM_REQUEST_BLOCK pTimeSrb = Requests_.Get();
         TimeStampVBI( pTimeSrb ); // [TMZ] [!!!]
      }
   }
}

/* Method: VBIChannel::ChangeNotification
 * Purpose: Called to save off the tv tuner change notification
 * Input: pSrb
 */
void VBIChannel::ChangeNotification( PHW_STREAM_REQUEST_BLOCK pSrb )
{
   Trace t("VBIChannel::ChangeNotification()");

   const KSSTREAM_HEADER &DataPacket = *pSrb->CommandData.DataBufferArray;
   RtlCopyMemory( &TVTunerChangeInfo_, DataPacket.Data, sizeof( KS_TVTUNER_CHANGE_INFO ) );
   Dirty_ = true;
}

/* Method: VideoChannel::ChangeNotification
 * Purpose: Noop for the base class.
 */
void VideoChannel::ChangeNotification( PHW_STREAM_REQUEST_BLOCK )
{
   Trace t("VideoChannel::ChangeNotification()");
}

/* Method: VBIAlterChannel::SetVidHdr
 * Purpose: Transforms the VBI parameters ( size ) into regular video header
 * Input:
 */
void VBIAlterChannel::SetVidHdr( const KS_DATAFORMAT_VBIINFOHEADER &df )
{
   Trace t("VBIAlterChannel::SetVidHdr()");

   // save for the history ( for the interrupt, actually )
   SetVBIInfHdr( df.VBIInfoHeader );
   (*(VBIChannel*)&slave).SetVBIInfHdr( df.VBIInfoHeader );
   
   KS_VIDEOINFOHEADER VidInfHdr;
   RtlZeroMemory( &VidInfHdr, sizeof( VidInfHdr ) );

   // create a regular video info header
   VidInfHdr.bmiHeader.biWidth = VBISamples;
   VidInfHdr.bmiHeader.biHeight =
      df.VBIInfoHeader.EndLine - df.VBIInfoHeader.StartLine + 1; // inclusive
   // taken from the VBI GUID
   VidInfHdr.bmiHeader.biCompression = FCC_VBI;
   VidInfHdr.bmiHeader.biBitCount = 8;

   // this is very important too
   VidInfHdr.bmiHeader.biSizeImage =
      VidInfHdr.bmiHeader.biWidth * VidInfHdr.bmiHeader.biHeight;

   // now handle the case when stride is larger than width ( have to set the
   // target rectangle )
   if ( df.VBIInfoHeader.StrideInBytes > VBISamples ) {
      VidInfHdr.rcTarget.right  = df.VBIInfoHeader.StrideInBytes;
      VidInfHdr.rcTarget.bottom = VidInfHdr.bmiHeader.biHeight;
   }

   // the Parent::Create will take care of setting vid header for the slave
   Parent::SetVidHdr( VidInfHdr );
}

//??? TODO: -- is this needed?
void VBIAlterChannel::SetVidHdr2( const KS_DATAFORMAT_VBIINFOHEADER &df )
{
   Trace t("VBIAlterChannel::SetVidHdr2()");

   // save for the history ( for the interrupt, actually )
   SetVBIInfHdr( df.VBIInfoHeader );
   
   KS_VIDEOINFOHEADER2 VidInfHdr;
   RtlZeroMemory( &VidInfHdr, sizeof( VidInfHdr ) );

   // create a regular video info header
   VidInfHdr.bmiHeader.biWidth = VBISamples;
   VidInfHdr.bmiHeader.biHeight =
      df.VBIInfoHeader.EndLine - df.VBIInfoHeader.StartLine + 1; // inclusive
   // taken from the VBI GUID
   VidInfHdr.bmiHeader.biCompression = FCC_VBI;
   VidInfHdr.bmiHeader.biBitCount = 8;

   // this is very important too
   VidInfHdr.bmiHeader.biSizeImage =
      VidInfHdr.bmiHeader.biWidth * VidInfHdr.bmiHeader.biHeight;

   // now handle the case when stride is larger than width ( have to set the
   // target rectangle )
   if ( df.VBIInfoHeader.StrideInBytes > VBISamples ) {
      VidInfHdr.rcTarget.right  = df.VBIInfoHeader.StrideInBytes;
      VidInfHdr.rcTarget.bottom = VidInfHdr.bmiHeader.biHeight;
   }

   // the Parent::Create will take care of setting vid header for the slave
   Parent::SetVidHdr2( VidInfHdr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\viddefs.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Viddefs.h 1.3 1998/04/29 22:43:42 tomz Exp $

#ifndef __VIDDEFS_H
#define __VIDDEFS_H


/* Type: Connector
 * Purpose: Defines a video source
 */
typedef enum { ConSVideo = 1, ConTuner, ConComposite } Connector;


/* Type: State
 * Purpose: used to define on-off operations
 */
typedef enum { Off, On } State;

/* Type: Field
 * Purpose: defines fields
 */
typedef enum { VF_Both, VF_Even, VF_Odd } VidField;

/* Type: VideoFormat
 * Purpose: Used to define video format
 */
typedef enum {  VFormat_AutoDetect,
                VFormat_NTSC,
                VFormat_Reserved2,
                VFormat_PAL_BDGHI,
                VFormat_PAL_M,
                VFormat_PAL_N,
                VFormat_SECAM } VideoFormat;

/* Type: LumaRange
 * Purpose: Used to define Luma Output Range
 */
typedef enum { LumaNormal, LumaFull } LumaRange;

/* Type: OutputRounding
 * Purpose: Controls the number of bits output
 */
typedef enum { RND_Normal, RND_6Luma4Chroma, RND_7Luma5Chroma } OutputRounding;

/* Type: ClampLevel
 * Purpose: Defines the clamp levels
 */
typedef enum { ClampLow, ClampMiddle, ClampNormal, ClampHi } ClampLevel;


/*
 * Type: Crystal
 * Purpose: Defines which crystal to use
 */
typedef enum { Crystal_XT0 = 1, Crystal_XT1, Crystal_AutoSelect } Crystal;


/*
 * Type: HoriFilter
 * Purpose: Defines horizontal low-pass filter
 */
typedef enum { HFilter_AutoFormat,
               HFilter_CIF,
               HFilter_QCIF,
               HFilter_ICON } HorizFilter;

/*
 * Type: CoringLevel
 * Purpose: Defines Luma coring level
 */
typedef enum { Coring_None,
               Coring_8,
               Coring_16,
               Coring_32 } CoringLevel;

/*
 * Type: ThreeState
 * Purpose: Defines output three-states for the OE pin
 */
typedef enum { TS_Timing_Data,
               TS_Data,
               TS_Timing_Data_Clock,
               TS_Clock_Data } ThreeState;

/*
 * Type: SCLoopGain
 * Purpose: Defines subcarrier loop gain
 */
typedef enum { SC_Normal, SC_DivBy8, SC_DivBy16, SC_DivBy32 } SCLoopGain;

/*
 * Type: ComparePt
 * Purpose: Defines the majority comparison point for the White Crush Up function
 */
typedef enum { CompPt_3Q, CompPt_2Q, CompPt_1Q, CompPt_Auto } ComparePt;


#endif // __VIDDEFS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\vidchifc.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Vidchifc.h 1.3 1998/04/29 22:43:42 tomz Exp $

#ifndef __VIDCHIFC_H
#define __VIDCHIFC_H


#ifndef __CHANIFACE_H
#include "chanifac.h"
#endif

/* Class: VideoChanIface
 * Purpose: Used to establish a callback mecanism when CaptureChip-derived class
 *   can call VxDVideoChannel class back to notify about an interrupt
 */
class VideoChannel;

class VideoChanIface : public ChanIface
{
   private:
      VideoChannel *ToBeNotified_;
   public:
      virtual void Notify( PVOID pTag, bool skipped );
      VideoChanIface( VideoChannel *aChan ) : ToBeNotified_( aChan ) {}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\xbar.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Xbar.h 1.8 1998/04/29 22:43:42 tomz Exp $

#ifndef __XBAR_H
#define __XBAR_H

//
// This file defines interconnections between components via Mediums
//

#ifdef __cplusplus
extern "C" {
#endif

#ifdef BT848_MEDIUMS
    #define MEDIUM_DECL 
#else
    #define MEDIUM_DECL extern
#endif

/*  -----------------------------------------------------------

    Topology of all devices:

                            PinDir  FilterPin#    M_GUID#
    TVTuner                 
        TVTunerVideo        out         0            0
        TVTunerAudio        out         1            1
    TVAudio
        TVTunerAudio        in          0            1
        TVAudio             out         1            3
    Crossbar
        TVTunerVideo        in          0            0
        TVAudio             in          3            3
        AnalogVideoOut      out         4            4
        AnalogAudioOut      out         5            NULL
    Capture
        AnalogVideoIn       in          0            4
        

All other pins are marked as promiscuous connections via GUID_NULL
------------------------------------------------------------------ */        
        
// Define the GUIDs which will be used to create the Mediums
#define M_GUID0 0xa19dc0e0, 0x3b39, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID1 0xa19dc0e1, 0x3b39, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID2 0xa19dc0e2, 0x3b39, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID3 0xa19dc0e3, 0x3b39, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID4 0xa19dc0e4, 0x3b39, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID5 0xa19dc0e5, 0x3b39, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID6 0xa19dc0e6, 0x3b39, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID7 0xa19dc0e7, 0x3b39, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID8 0xa19dc0e8, 0x3b39, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define M_GUID9 0xa19dc0e9, 0x3b39, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba

// Note: To allow multiple instances of the same piece of hardware,
// set the first ULONG after the GUID in the Medium to a unique value.

// ---------------------------------------------------------------

MEDIUM_DECL KSPIN_MEDIUM TVTunerMediums[2]
#ifdef BT848_MEDIUMS
    = {
        {M_GUID0,           0, 0},  // Pin 0
        {M_GUID1,           0, 0},  // Pin 1
    }
#endif
;

MEDIUM_DECL BOOL TVTunerPinDirection [2]
#ifdef BT848_MEDIUMS
     = {
        TRUE,                       // Output Pin 0
        TRUE,                       // Output Pin 1
    }
#endif
;

// -----------------------------------------------

MEDIUM_DECL KSPIN_MEDIUM TVAudioMediums[2]
#ifdef BT848_MEDIUMS
     = {
         {M_GUID1,           0, 0},  // Pin 0
         {M_GUID3,           0, 0},  // Pin 1
       }
#endif
;

MEDIUM_DECL BOOL TVAudioPinDirection [2]
#ifdef BT848_MEDIUMS
    = {
         FALSE,                      // Input  Pin 0
         TRUE,                       // Output Pin 1
      }
#endif
;

// ---------------------------------------------------------------

MEDIUM_DECL KSPIN_MEDIUM CrossbarMediums[6]
#ifdef BT848_MEDIUMS
     = {
        {STATIC_GUID_NULL,  0, 0},  // Input  Pin 0 - SVideoIn
        {M_GUID0,           0, 0},  // Input  Pin 2, KS_PhysConn_Video_Tuner,        
        {STATIC_GUID_NULL,  0, 0},  // Input  Pin 1 - VideoCompositeIn
        {M_GUID3,           0, 0},  // Input  Pin 3  KS_PhysConn_Audio_Tuner,         
        {M_GUID4,           0, 0},  // Output Pin 4 - VideoDecoderOut
        {STATIC_GUID_NULL,  0, 0},  // Output Pin 5  KS_PhysConn_Audio_AudioDecoder,        
}
#endif
;

MEDIUM_DECL BOOL CrossbarPinDirection [6]
#ifdef BT848_MEDIUMS
     = {
        FALSE,                      // Input  Pin 0
        FALSE,                      // Input  Pin 1
        FALSE,                      // Input  Pin 2
        FALSE,                      // Input  Pin 3
        TRUE,                       // Output Pin 4
        TRUE,                       // Output Pin 5
}
#endif
;

// ---------------------------------------------------------------

MEDIUM_DECL KSPIN_MEDIUM CaptureMediums[4]
#ifdef BT848_MEDIUMS
     = {
        // should change STATIC_KSMEDIUMSETID_Standard to
        // STATIC_GUID_NULL when it works
        {STATIC_KSMEDIUMSETID_Standard,  0, 0},  // Pin 0  Capture
        {STATIC_KSMEDIUMSETID_Standard,  0, 0},  // Pin 1  Preview
        {STATIC_KSMEDIUMSETID_Standard,  0, 0},  // Pin 2  VBI
        {M_GUID4,           0, 0},  // Pin 3  Analog Video In
}
#endif
;

MEDIUM_DECL BOOL CapturePinDirection [4]
#ifdef BT848_MEDIUMS
     = {
        TRUE,                       // Output Pin 0
        TRUE,                       // Output Pin 1
        TRUE,                       // Output Pin 2
        FALSE,                      // Input  Pin 3
}
#endif
;

MEDIUM_DECL GUID CaptureCategories [4]
#ifdef BT848_MEDIUMS
     = {
    STATIC_PINNAME_VIDEO_CAPTURE,           // Pin 0
    STATIC_PINNAME_VIDEO_PREVIEW,           // Pin 1
    STATIC_PINNAME_VIDEO_VBI,               // Pin 2
    STATIC_PINNAME_VIDEO_ANALOGVIDEOIN,     // Pin 3
}
#endif
;

#ifdef __cplusplus
}
#endif


// ---------------------------------------------------------------

struct _XBAR_PIN_DESCRIPTION {
    ULONG PinType;
    ULONG RelatedPinIndex;
    ULONG IsRoutedTo;                 // Index of input pin in use
    ULONG PinNo; // pin number as hard-wired; i.e. mux input 1; to be used in calls
                 // into the decoder to select a mux input

    const KSPIN_MEDIUM *Medium;

    _XBAR_PIN_DESCRIPTION( ULONG type, ULONG no, ULONG rel, const KSPIN_MEDIUM *);
    _XBAR_PIN_DESCRIPTION(){}
};

inline _XBAR_PIN_DESCRIPTION::_XBAR_PIN_DESCRIPTION( ULONG type, ULONG no,
   ULONG rel, const KSPIN_MEDIUM *Medium ) : PinType( type ),
   RelatedPinIndex( rel ), IsRoutedTo( 0 ), PinNo( no ), Medium (Medium)
{
}

const int MaxOutPins = 2;
const int MaxInpPins = 4;

class CrossBar
{
   // it is possible to make these into the pointers and allocate dynamically
   // based on info from registry; but this seems like a lot of work - just allocate
   // the maximum possible number and construct each based on the registry settings
   _XBAR_PIN_DESCRIPTION OutputPins [MaxOutPins];
   _XBAR_PIN_DESCRIPTION InputPins [MaxInpPins];

      int InPinsNo_;
   public:
      int GetNoInputs();
      int GetNoOutputs();
      bool TestRoute( int InPin, int OutPin );
      ULONG  GetPinInfo( int dir, int idx, ULONG &related, 
                KSPIN_MEDIUM * Medium);
      ULONG GetPinNo( int no );

      void Route( int OutPin, int InPin );
      bool GoodPins( int InPin, int OutPin );

      int GetRoute( int OutPin );

      CrossBar() : InPinsNo_( 0 ) {};
      CrossBar( LONG *types );
};

inline CrossBar::CrossBar( LONG *types ) : InPinsNo_( 0 )
{
	OutputPins [0] = _XBAR_PIN_DESCRIPTION( KS_PhysConn_Video_VideoDecoder, 
        0, 1, &CrossbarMediums[4]);
   
   // [!!!] The following should be moved into the _XBAR_PIN_DESCRIPTION 
   //       constructor as another parameter
   Route( 0 /*Video OutPin*/, 1 /*Video InPin*/ );

   OutputPins [1] = _XBAR_PIN_DESCRIPTION( KS_PhysConn_Audio_AudioDecoder, 
        0, 1, &CrossbarMediums[5]);

   // [!!!] The following should be moved into the _XBAR_PIN_DESCRIPTION
   //       constructor as another parameter
   Route( 1 /*Audio OutPin*/, 3 /*Audio InPin*/ );

   for ( int i = 0; i < MaxInpPins; i++ ) {
      if ( types [i] != -1 ) {
         InputPins [InPinsNo_] = _XBAR_PIN_DESCRIPTION( types [i], i, (DWORD) -1, &CrossbarMediums[i] );
         InPinsNo_++;
      }
   }

}

inline int CrossBar::GetNoInputs()
{
   return InPinsNo_;
}

inline int CrossBar::GetNoOutputs()
{
   return MaxOutPins;
}

inline bool CrossBar::GoodPins( int InPin, int OutPin )
{
   return InPinsNo_ &&
      bool( InPin >= -1 && InPin < InPinsNo_ && OutPin >= 0 && OutPin < MaxOutPins );	// JBC 4/1/98 Don't allow negative pin numbers
}

inline void CrossBar::Route( int OutPin, int InPin )
{
   OutputPins [OutPin].IsRoutedTo = InPin;
}

inline int CrossBar::GetRoute( int OutPin )
{
   return OutputPins [OutPin].IsRoutedTo;
}

// should be called for input pins only !
inline ULONG CrossBar::GetPinNo( int no )
{
   return InputPins [no].PinNo;
}

inline ULONG CrossBar::GetPinInfo( int dir, int idx, ULONG &related,
        KSPIN_MEDIUM * Medium )
{
   _XBAR_PIN_DESCRIPTION *pPinDesc;

   if ( dir == KSPIN_DATAFLOW_IN ) {
      pPinDesc = InputPins;
      ASSERT( idx < InPinsNo_ );
   } else {
      pPinDesc = OutputPins;
      ASSERT( idx < MaxOutPins );
   }
   related = pPinDesc [idx].RelatedPinIndex;
   *Medium = *pPinDesc[idx].Medium;
   return pPinDesc [idx].PinType;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\capture\mini\bt848\yuvfmt.h ===
// $Header: G:/SwDev/WDM/Video/bt848/rcs/Yuvfmt.h 1.5 1998/04/29 22:43:43 tomz Exp $

#ifndef __YUVFMT_H
#define __YUVFMT_H

#ifndef __DEFAULTS_H
#include "defaults.h"
#endif

KS_DATARANGE_VIDEO StreamFormatYVU9 =
{
   // KSDATARANGE
   {
      {
         sizeof( KS_DATARANGE_VIDEO ),
         0,
         DefWidth * DefHeight * 2,               // SampleSize
         0,                                      // Reserved
         { 0x73646976, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } }, //MEDIATYPE_Video
         { 0x39555659, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } }, //MEDIASUBTYPE_YVU9
         { 0x05589f80, 0xc356, 0x11ce, { 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a } } //FORMAT_VideoInfo
      } 
   },
   true,
   true,
   KS_VIDEOSTREAM_PREVIEW, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
   0,       // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

   // _KS_VIDEO_STREAM_CONFIG_CAPS
   {
      STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO, // GUID
      KS_AnalogVideo_NTSC_M,                       // AnalogVideoStandard
      {
         MaxInWidth, MaxInHeight   // SIZE InputSize
      },
      {
         MinInWidth, MinInHeight   // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
      },
      {
         MaxInWidth, MaxInHeight   // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
      },
      2,           // int CropGranularityX;       // granularity of cropping size
      2,           // int CropGranularityY;
      2,           // int CropAlignX;             // alignment of cropping rect
      2,           // int CropAlignY;
      {
         MinOutWidth, MinOutHeight   // SIZE MinOutputSize;         // smallest bitmap stream can produce
      },
      {
         MaxOutWidth, MaxOutHeight   // SIZE MaxOutputSize;         // largest  bitmap stream can produce
      },
      16,         // int OutputGranularityX;     // granularity of output bitmap size
      4,          // int OutputGranularityY;
      0,          // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
      0,          // StretchTapsY
      2,          // ShrinkTapsX 
      2,          // ShrinkTapsY 
      333667,     // LONGLO