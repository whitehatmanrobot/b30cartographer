on key that is part of
        every I/O completion packet for this file.

    NumberOfConcurrentThreads - This is the number of threads that are
        alowed to be concurrently active and can be used to avoid
        spurious context switches, e.g., context switches that would
        occur simply because of quantum end.  Up to the number of
        threads specified are allowed to execute concurrently.  If one
        of the threads enters a wait state, then another thread is
        allowed to procede.  There may be times when more then the
        specified number of threads are active, but this will be quickly
        throttled.  A value of 0 tells the system to allow the same
        number of threads as there are processors to run.

Return Value:

    Not NULL - Returns the completion port handle associated with the file.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    HANDLE Port;
    IO_STATUS_BLOCK IoSb;
    FILE_COMPLETION_INFORMATION CompletionInfo;

    Port = ExistingCompletionPort;
    if ( !ARGUMENT_PRESENT(ExistingCompletionPort) ) {
        Status = NtCreateIoCompletion (
                    &Port,
                    IO_COMPLETION_ALL_ACCESS,
                    NULL,
                    NumberOfConcurrentThreads
                    );
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return NULL;
            }
        }

    if ( FileHandle != INVALID_HANDLE_VALUE ) {
        CompletionInfo.Port = Port;
        CompletionInfo.Key = (PVOID)CompletionKey;

        Status = NtSetInformationFile(
                    FileHandle,
                    &IoSb,
                    &CompletionInfo,
                    sizeof(CompletionInfo),
                    FileCompletionInformation
                    );
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            if ( !ARGUMENT_PRESENT(ExistingCompletionPort) ) {
                NtClose(Port);
                }
            return NULL;
            }
        }
    else {

        //
        // file handle is INVALID_HANDLE_VALUE. Usually this is
        // used to create a new unassociated completion port.
        //
        // Special case here to see if existing completion port was
        // specified and fail if it is
        //

        if ( ARGUMENT_PRESENT(ExistingCompletionPort) ) {
            Port = NULL;
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            }
        }

    return Port;
}

BOOL
WINAPI
PostQueuedCompletionStatus(
    HANDLE CompletionPort,
    DWORD dwNumberOfBytesTransferred,
    ULONG_PTR dwCompletionKey,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    This function allows the caller to post an I/O completion packet to
    a completion port. This packet will satisfy an outstanding call to
    GetQueuedCompletionStatus and will provide that caller with the three values
    normally returned from that call.

Arguments:

    CompletionPort - Supplies a handle to a completion port that the caller wants to
        post a completion packet to.

    dwNumberOfBytesTransferred - Supplies the value that is to be
        returned through the lpNumberOfBytesTransfered parameter of the
        GetQueuedCompletionStatus API.

    dwCompletionKey - Supplies the value that is to be returned through
        the lpCompletionKey parameter of the GetQueuedCompletionStatus
        API.

    lpOverlapped - Supplies the value that is to be returned through the
        lpOverlapped parameter of the GetQueuedCompletionStatus API.

Return Value:

    TRUE - The operation was successful

    FALSE - The operation failed, use GetLastError to get detailed error information

--*/

{
    NTSTATUS Status;
    BOOL rv;

    rv = TRUE;
    Status = NtSetIoCompletion(
                CompletionPort,
                (PVOID)dwCompletionKey,
                (PVOID)lpOverlapped,
                STATUS_SUCCESS,
                dwNumberOfBytesTransferred
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        rv = FALSE;
        }
    return rv;
}



BOOL
WINAPI
GetQueuedCompletionStatus(
    HANDLE CompletionPort,
    LPDWORD lpNumberOfBytesTransferred,
    PULONG_PTR lpCompletionKey,
    LPOVERLAPPED *lpOverlapped,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    This function waits for pending I/O operations associated with the
    specified completion port to complete.  Server applications may have
    several threads issuing this call on the same completion port.  As
    I/O operations complete, they are queued to this port.  If threads
    are actively waiting in this call, queued requests complete their
    call.

    This API returns a boolean value.

    A value of TRUE means that a pending I/O completed successfully.
    The the number of bytes transfered during the I/O, the completion
    key that indicates which file the I/O occured on, and the overlapped
    structure address used in the original I/O are all returned.

    A value of FALSE indicates one ow two things:

    If *lpOverlapped is NULL, no I/O operation was dequeued.  This
    typically means that an error occured while processing the
    parameters to this call, or that the CompletionPort handle has been
    closed or is otherwise invalid.  GetLastError() may be used to
    further isolate this.

    If *lpOverlapped is non-NULL, an I/O completion packet was dequeud,
    but the I/O operation resulted in an error.  GetLastError() can be
    used to further isolate the I/O error.  The the number of bytes
    transfered during the I/O, the completion key that indicates which
    file the I/O occured on, and the overlapped structure address used
    in the original I/O are all returned.

Arguments:

    CompletionPort - Supplies a handle to a completion port to wait on.

    lpNumberOfBytesTransferred - Returns the number of bytes transfered during the
        I/O operation whose completion is being reported.

    lpCompletionKey - Returns a completion key value specified during
        CreateIoCompletionPort.  This is a per-file key that can be used
        to tall the caller the file that an I/O operation completed on.

    lpOverlapped - Returns the address of the overlapped structure that
        was specified when the I/O was issued.  The following APIs may
        complete using completion ports.  This ONLY occurs if the file
        handle is associated with with a completion port AND an
        overlapped structure was passed to the API.

        LockFileEx
        WriteFile
        ReadFile
        DeviceIoControl
        WaitCommEvent
        ConnectNamedPipe
        TransactNamedPipe

    dwMilliseconds - Supplies an optional timeout value that specifies
        how long the caller is willing to wait for an I/O completion
        packet.

Return Value:

    TRUE - An I/O operation completed successfully.
        lpNumberOfBytesTransferred, lpCompletionKey, and lpOverlapped
        are all valid.

    FALSE - If lpOverlapped is NULL, the operation failed and no I/O
        completion data is retured.  GetLastError() can be used to
        further isolate the cause of the error (bad parameters, invalid
        completion port handle).  Otherwise, a pending I/O operation
        completed, but it completed with an error.  GetLastError() can
        be used to further isolate the I/O error.
        lpNumberOfBytesTransferred, lpCompletionKey, and lpOverlapped
        are all valid.

--*/

{

    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    IO_STATUS_BLOCK IoSb;
    NTSTATUS Status;
    LPOVERLAPPED LocalOverlapped;
    BOOL rv;


    pTimeOut = BaseFormatTimeOut(&TimeOut,dwMilliseconds);
    Status = NtRemoveIoCompletion(
                CompletionPort,
                (PVOID *)lpCompletionKey,
                (PVOID *)&LocalOverlapped,
                &IoSb,
                pTimeOut
                );

    if ( !NT_SUCCESS(Status) || Status == STATUS_TIMEOUT ) {
        *lpOverlapped = NULL;
        if ( Status == STATUS_TIMEOUT ) {
            SetLastError(WAIT_TIMEOUT);
            }
        else {
            BaseSetLastNTError(Status);
            }
        rv = FALSE;
        }
    else {
        *lpOverlapped = LocalOverlapped;

        *lpNumberOfBytesTransferred = (DWORD)IoSb.Information;

        if ( !NT_SUCCESS(IoSb.Status) ){
            BaseSetLastNTError( IoSb.Status );
            rv = FALSE;
            }
        else {
            rv = TRUE;
            }
        }
    return rv;
}

BOOL
WINAPI
GetOverlappedResult(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait
    )

/*++

Routine Description:

    The GetOverlappedResult function returns the result of the last
    operation that used lpOverlapped and returned ERROR_IO_PENDING.

Arguments:

    hFile - Supplies the open handle to the file that the overlapped
        structure lpOverlapped was supplied to ReadFile, WriteFile,
        ConnectNamedPipe, WaitNamedPipe or TransactNamedPipe.

    lpOverlapped - Points to an OVERLAPPED structure previously supplied to
        ReadFile, WriteFile, ConnectNamedPipe, WaitNamedPipe or
        TransactNamedPipe.

    lpNumberOfBytesTransferred - Returns the number of bytes transferred
        by the operation.

    bWait -  A boolean value that affects the behavior when the operation
        is still in progress. If TRUE and the operation is still in progress,
        GetOverlappedResult will wait for the operation to complete before
        returning. If FALSE and the operation is incomplete,
        GetOverlappedResult will return FALSE. In this case the extended
        error information available from the GetLastError function will be
        set to ERROR_IO_INCOMPLETE.

Return Value:

    TRUE -- The operation was successful, the pipe is in the
        connected state.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{
    DWORD WaitReturn;

    //
    // Did caller specify an event to the original operation or was the
    // default (file handle) used?
    //

    if (lpOverlapped->Internal == (DWORD)STATUS_PENDING ) {
        if ( bWait ) {
            WaitReturn = WaitForSingleObject(
                            ( lpOverlapped->hEvent != NULL ) ?
                                lpOverlapped->hEvent : hFile,
                            INFINITE
                            );
            }
        else {
            WaitReturn = WAIT_TIMEOUT;
            }

        if ( WaitReturn == WAIT_TIMEOUT ) {
            //  !bWait and event in not signalled state
            SetLastError( ERROR_IO_INCOMPLETE );
            return FALSE;
            }

        if ( WaitReturn != 0 ) {
             return FALSE;    // WaitForSingleObject calls BaseSetLastError
             }
        }

    *lpNumberOfBytesTransferred = (DWORD)lpOverlapped->InternalHigh;

    if ( NT_SUCCESS((NTSTATUS)lpOverlapped->Internal) ){
        return TRUE;
        }
    else {
        BaseSetLastNTError( (NTSTATUS)lpOverlapped->Internal );
        return FALSE;
        }
}

#endif // #if NOT_IN_TPOOL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tpool\tpool.h ===
/**
 * tpool.h
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 * Microsoft Windows
 * Copyright (C) Microsoft Corporation, 1992 - 1994.
 * 
 * File:       tpool.h
 * 
 * The list of NT 5 thread pool functions for which we provide
 * our own implementation on NT 4 in tpool.dll.
 * 
 * 
 */

#ifdef __cplusplus
extern "C" {
#endif

#ifndef WT_EXECUTEDEFAULT
#define WT_EXECUTEDEFAULT       0x00000000                           
#define WT_EXECUTEINIOTHREAD    0x00000001                           
#define WT_EXECUTEINUITHREAD    0x00000002                           
#define WT_EXECUTEINWAITTHREAD  0x00000004                           
#define WT_EXECUTEONLYONCE      0x00000008                           
#define WT_EXECUTEINTIMERTHREAD 0x00000020                           
#define WT_EXECUTELONGFUNCTION  0x00000010                           
#define WT_EXECUTEINPERSISTENTIOTHREAD  0x00000040                   
#endif

typedef void (* WAITORTIMERCALLBACKFUNC)(void *, BOOLEAN);
typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK;
 
BOOL
WINAPI
XspRegisterWaitForSingleObject(
    PHANDLE phNewWaitObject,
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    );


HANDLE
WINAPI
XspRegisterWaitForSingleObjectEx(
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    );


BOOL
WINAPI
XspUnregisterWait(
    HANDLE WaitHandle
    );


BOOL
WINAPI
XspUnregisterWaitEx(
    HANDLE WaitHandle,
    HANDLE CompletionEvent
    );


BOOL
WINAPI
XspQueueUserWorkItem(
    LPTHREAD_START_ROUTINE Function,
    PVOID Context,
    ULONG Flags
    );


BOOL
WINAPI
XspBindIoCompletionCallback (
    HANDLE FileHandle,
    LPOVERLAPPED_COMPLETION_ROUTINE Function,
    ULONG Flags
    );


HANDLE
WINAPI
XspCreateTimerQueue(
    VOID
    );


BOOL
WINAPI
XspCreateTimerQueueTimer(
    PHANDLE phNewTimer,
    HANDLE TimerQueue,
    WAITORTIMERCALLBACK Callback,
    PVOID Parameter,
    DWORD DueTime,
    DWORD Period,
    ULONG Flags
    ) ;


BOOL
WINAPI
XspChangeTimerQueueTimer(
    HANDLE TimerQueue,
    HANDLE Timer,
    ULONG DueTime,
    ULONG Period
    );


BOOL
WINAPI
XspDeleteTimerQueueTimer(
    HANDLE TimerQueue,
    HANDLE Timer,
    HANDLE CompletionEvent
    );


BOOL
WINAPI
XspDeleteTimerQueueEx(
    HANDLE TimerQueue,
    HANDLE CompletionEvent
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tpool\tpool.c ===
/**
 * platwrap.cxx
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 * Wrappers for all platform-specific functions used in the XSP project. 
 * 
*/
            
// Standard headers
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <objbase.h>

typedef void (* WAITORTIMERCALLBACKFUNC)(void *, BOOLEAN);
typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK;

NTSTATUS
NTAPI
BaseCreateThreadPoolThread(
    PUSER_THREAD_START_ROUTINE Function,
    HANDLE * ThreadHandle
    );

NTSTATUS
NTAPI
BaseExitThreadPoolThread(
    NTSTATUS Status
    );

DWORD   g_dwPlatformVersion;            // (dwMajorVersion << 16) + (dwMinorVersion)
DWORD   g_dwPlatformID;                 // VER_PLATFORM_WIN32S/WIN32_WINDOWS/WIN32_WINNT
DWORD   g_dwPlatformBuild;              // Build number
DWORD   g_dwPlatformServicePack;        // Service Pack
BOOL    g_fInit;                        // Global flag, set to TRUE after initialization.

BOOL    ProvidingThreadPool;

//+------------------------------------------------------------------------
//
//  Declaration of global function pointers to functions.
//
//-------------------------------------------------------------------------

#define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs) \
        FnType (WINAPI *g_pufn##FnName) FnParamList;

#include "tpoolfnsp.h"

#undef STRUCT_ENTRY

//+------------------------------------------------------------------------
//
//  Define inline functions which call through the global functions. The
//  functions are defined from entries in tpoolfns.h.
//
//-------------------------------------------------------------------------


#define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs)   \
        FnType Xsp##FnName FnParamList                      \
        {                                                   \
            return (*g_pufn##FnName) FnArgs;                \
        }                                                   \

#include "tpoolfnsp.h"

#undef STRUCT_ENTRY

//+---------------------------------------------------------------------------
//
//  Function:   InitPlatformVariables
//
//  Synopsis:   Determines the platform we are running on and
//              initializes pointers to unicode functions.
//
//----------------------------------------------------------------------------

void
InitPlatformVariables()
{
    OSVERSIONINFOA  ovi;
    HINSTANCE       hInst;
    WCHAR           szModuleFileName[_MAX_PATH];
    WCHAR           szDrive[_MAX_PATH];
    WCHAR           szDir[_MAX_PATH];
    WCHAR *         pszModule;

    ovi.dwOSVersionInfoSize = sizeof(ovi);
    GetVersionExA(&ovi);

    g_dwPlatformVersion     = (ovi.dwMajorVersion << 16) + ovi.dwMinorVersion;
    g_dwPlatformID          = ovi.dwPlatformId;
    g_dwPlatformBuild       = ovi.dwBuildNumber;

    if (g_dwPlatformID == VER_PLATFORM_WIN32_NT)
    {
        char * pszBeg = ovi.szCSDVersion;

        if (*pszBeg)
        {
            char * pszEnd = pszBeg + lstrlenA(pszBeg);
            
            while (pszEnd > pszBeg)
            {
                char c = pszEnd[-1];

                if (c < '0' || c > '9')
                    break;

                pszEnd -= 1;
            }

            while (*pszEnd)
            {
                g_dwPlatformServicePack *= 10;
                g_dwPlatformServicePack += *pszEnd - '0';
                pszEnd += 1;
            }
        }
    }

    /*
     * Initialize the global function variables to point to functions in 
     * either kernel32.dll or tpool.dll, depending on the platform.
     */

    ProvidingThreadPool = (g_dwPlatformVersion < 0x00050000);
    if (ProvidingThreadPool)
    {
        #define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs)   \
            FnType WINAPI TPool##FnName FnParamList;
    
        #include "tpoolfnsp.h"
    			    
        #undef STRUCT_ENTRY

        #define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs)   \
                g_pufn##FnName = TPool##FnName;
    
        #include "tpoolfnsp.h"
    			    
        #undef STRUCT_ENTRY
            
        RtlSetThreadPoolStartFunc( BaseCreateThreadPoolThread,
                                   BaseExitThreadPoolThread );
    }
    else
    {
        hInst = LoadLibraryEx(L"kernel32.dll", 0, LOAD_WITH_ALTERED_SEARCH_PATH);

        #define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs)   \
                g_pufn##FnName = (FnType (WINAPI *)FnParamList)GetProcAddress(hInst, #FnName);
    
        #include "tpoolfnsp.h"
    			    
        #undef STRUCT_ENTRY
    }
}


BOOL WINAPI
DllMain(
    HINSTANCE Instance,
    DWORD Reason,
    LPVOID NotUsed)
{
    switch (Reason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(Instance);
        InitPlatformVariables();
        break;

    default:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tpool\tpoolfnsp.h ===
/**
 * tpoolfnsp.h
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 * Private declaration of thread pool library APIs in the XSP project. 
 * 
*/

/**
 *
 *  This file needs to be insync of tpool.h in xsp\inc directory.
 *  Whenever there is a change to the threadpool APIs, both header files need update.
 *
 *
 */
STRUCT_ENTRY(RegisterWaitForSingleObject, BOOL,
            (   PHANDLE phNewWaitObject,
                HANDLE hObject,
                WAITORTIMERCALLBACK Callback,
                PVOID Context,
                ULONG dwMilliseconds,
                ULONG dwFlags ),
            (   phNewWaitObject,
                hObject,
                Callback,
                Context,
                dwMilliseconds,
                dwFlags))

STRUCT_ENTRY(RegisterWaitForSingleObjectEx, HANDLE,
            (   HANDLE hObject,
                WAITORTIMERCALLBACK Callback,
                PVOID Context,
                ULONG dwMilliseconds,
                ULONG dwFlags ),
            (   hObject,
                Callback,
                Context,
                dwMilliseconds,
                dwFlags))

STRUCT_ENTRY(UnregisterWait, BOOL,
            (   HANDLE WaitHandle ),
            (   WaitHandle))

STRUCT_ENTRY(UnregisterWaitEx, BOOL,
            (   HANDLE WaitHandle,
                HANDLE CompletionEvent ),
            (   WaitHandle,
                CompletionEvent))

STRUCT_ENTRY(QueueUserWorkItem, BOOL,
            (   LPTHREAD_START_ROUTINE Function,
                PVOID Context,
                ULONG Flags ),
            (   Function,
                Context,
                Flags))
            

STRUCT_ENTRY(BindIoCompletionCallback, BOOL,
            (   HANDLE FileHandle,
                LPOVERLAPPED_COMPLETION_ROUTINE Function,
                ULONG Flags ),
            (   FileHandle,
                Function,
                Flags))


STRUCT_ENTRY(CreateTimerQueue, HANDLE,
            (   VOID ),
            (   ))

STRUCT_ENTRY(CreateTimerQueueTimer, BOOL,     
            (   PHANDLE phNewTimer,
                HANDLE TimerQueue,
                WAITORTIMERCALLBACK Callback,
                PVOID Parameter,
                DWORD DueTime,
                DWORD Period,
                ULONG Flags),
            (   phNewTimer,
                TimerQueue,
                Callback,
                Parameter,
                DueTime,
                Period,
                Flags))

STRUCT_ENTRY(ChangeTimerQueueTimer, BOOL, 
            (   HANDLE TimerQueue,
                HANDLE Timer,
                ULONG DueTime,
                ULONG Period),
            (   TimerQueue,
                Timer,
                DueTime,
                Period))

STRUCT_ENTRY(DeleteTimerQueueTimer, BOOL, 
            (   HANDLE TimerQueue,
                HANDLE Timer,
                HANDLE CompletionEvent),
            (
                TimerQueue,
                Timer,
                CompletionEvent))

STRUCT_ENTRY(DeleteTimerQueueEx, BOOL, 
            (   HANDLE TimerQueue,
                HANDLE CompletionEvent),
            (   TimerQueue,
                CompletionEvent))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tpool\threads.c ===
/**
 * threads.c
 * 
 * This file is copied from \nt\private\ntos\rtl\threads.c
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */
 
/*++

Copyright (c) 1989-1998 Microsoft Corporation

Module Name:

    threads.c

Abstract:

    This module defines functions for thread pools. Thread pools can be used for
    one time execution of tasks, for waits and for one shot or periodic timers.

Author:

    Gurdeep Singh Pall (gurdeep) Nov 13, 1997

Environment:

    These routines are statically linked in the caller's executable and
    are callable in only from user mode. They make use of Nt system services.


Revision History:

    Aug-19 lokeshs - modifications to thread pool apis.

--*/


// There are 3 types of thread pool functions supported
//
// 1. Wait Thread Pool
// 2. Worker Thread Pool
// 3. Timer Thread Pool
//
// Wait Thread Pool
// ----------------
// Clients can submit a waitable object with an optional timeout to wait on. 
// One thread is created per 63 of such waitable objects. These threads are 
// never killed.
//
// Worker Thread Pool
// ------------------
// Clients can submit functions to be executed by a worker thread. Threads are 
// created if the work queue exceeds a threshold. Clients can request that the 
// function be invoked in the context of a I/O thread. I/O worker threads
// can be used for initiating asynchronous I/O requests. They are not terminated if
// there are pending IO requests. Worker threads terminate if inactivity exceeds a 
// threshold.
// Clients can also associate IO completion requests with the IO completion port
// waited upon by the non I/O worker threads. One should not post overlapped IO requests
// in worker threads.
//
// Timer Thread Pool
// -----------------
// Clients create one or more Timer Queues and insert one shot or periodic 
// timers in them. All timers in a queue are kept in a "Delta List" with each 
// timer's firing time relative to the timer before it. All Queues are also 
// kept in a "Delta List" with each Queue's firing time (set to the firing time 
// of the nearest firing timer) relative to the Queue before it. One NT Timer 
// is used to service all timers in all queues.


//comment out to get rid of dependency check warning
#if 0
//#include <ntos.h>
//#include <ntrtl.h>
//#include <nturtl.h>
//#include "ntrtlp.h"
#endif
#include "threads.h"

ULONG DPRN0 = 0;
ULONG DPRN1 = 0;
ULONG DPRN2 = 0;
ULONG DPRN3 = 0;
ULONG DPRN4 = 0;


NTSTATUS
RtlRegisterWait (
    OUT PHANDLE WaitHandle,
    IN  HANDLE  Handle,
    IN  WAITORTIMERCALLBACKFUNC Function,
    IN  PVOID Context,
    IN  ULONG  Milliseconds,
    IN  ULONG  Flags
    )

/*++

Routine Description:

    This routine adds a new wait request to the pool of objects being waited on.

Arguments:

    WaitHandle - Handle returned on successful completion of this routine.

    Handle - Handle to the object to be waited on

    Function - Routine that is called when the wait completes or a timeout occurs

    Context - Opaque pointer passed in as an argument to Function

    Milliseconds - Timeout for the wait in milliseconds. 0xffffffff means dont 
            timeout.

    Flags - Can be one of:

        WT_EXECUTEINWAITTHREAD - if WorkerProc should be invoked in the wait
                thread itself. This should only be used for small routines.
        WT_EXECUTEINIOTHREAD - use only if the WorkerProc should be invoked in
                an IO Worker thread. Avoid using it.

    If Flags is not WT_EXECUTEINWAITTHREAD, the following flag can also be set:
    
        WT_EXECUTELONGFUNCTION - indicates that the callback might be blocked
                for a long duration. Use only if the callback is being queued to a
                worker thread.
    
Return Value:

    NTSTATUS - Result code from call.  The following are returned

    STATUS_SUCCESS - The registration was successful.

    STATUS_NO_MEMORY - There was not sufficient heap to perform the requested 
                operation.
                
    or other NTSTATUS error code

--*/

{
    PRTLP_WAIT Wait ;
    NTSTATUS Status ;
    PRTLP_EVENT Event ;
    LARGE_INTEGER TimeOut ;
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB ;

    *WaitHandle = NULL ;

    
    // Initialize thread pool if it isnt already done

    if ( CompletedWaitInitialization != 1) {

        Status = RtlpInitializeWaitThreadPool () ;

        if (! NT_SUCCESS( Status ) )
            return Status ;
    }


    // Initialize Wait request

    Wait = (PRTLP_WAIT) RtlpAllocateTPHeap ( sizeof (RTLP_WAIT),
                                            HEAP_ZERO_MEMORY) ;

    if (!Wait) {
        return STATUS_NO_MEMORY ;
    }
    
    Wait->WaitHandle = Handle ;
    Wait->Flags = Flags ;
    Wait->Function = Function ;
    Wait->Context = Context ;
    Wait->Timeout = Milliseconds ;
    SET_SIGNATURE(Wait) ;
        
    
    // timer part of wait is initialized by wait thread in RtlpAddWait

    
    // Get a wait thread that can accomodate another wait request.
    
    Status = RtlpFindWaitThread (&ThreadCB) ;

    if (Status != STATUS_SUCCESS) {
    
        RtlpFreeTPHeap( Wait ) ;
        
        return Status ;
    }

    Wait->ThreadCB = ThreadCB ;

    #if DBG1
    Wait->DbgId = ++NextWaitDbgId ;
    Wait->ThreadId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;
    if (DPRN0)
    DbgPrint("<%d:%d> Wait %x created by thread:<%x:%x>\n\n", 
                Wait->DbgId, 1, (ULONG_PTR)Wait,
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
    #endif

    // Set the wait handle

    *WaitHandle = Wait ;


    // Queue an APC to the Wait Thread

    Status = NtQueueApcThread(
                    ThreadCB->ThreadHandle,
                    (PPS_APC_ROUTINE)RtlpAddWait,
                    (PVOID)Wait,
                    NULL,
                    NULL
                    );


    if ( NT_SUCCESS(Status) ) {

        Status = STATUS_SUCCESS ;

    } else {

        *WaitHandle = NULL ;
        RtlpFreeTPHeap( Wait ) ;
    }

    return Status ;

}



NTSTATUS
RtlDeregisterWait(
    IN HANDLE WaitHandle
    )
/*++

Routine Description:

    This routine removes the specified wait from the pool of objects being
    waited on. This routine is non-blocking. Once this call returns, no new
    Callbacks are invoked. However, Callbacks that might already have been queued
    to worker threads are not cancelled.

Arguments:

    WaitHandle - Handle indentifying the wait.

Return Value:

    STATUS_SUCCESS - The deregistration was successful.
    STATUS_PENDING - Some callbacks associated with this Wait, are still executing.
--*/

{
    return RtlDeregisterWaitEx( WaitHandle, NULL ) ;    
}


NTSTATUS
RtlDeregisterWaitEx(
    IN HANDLE WaitHandle,
    IN HANDLE Event
    )
/*++

Routine Description:

    This routine removes the specified wait from the pool of objects being
    waited on. Once this call returns, no new Callbacks will be invoked.
    Depending on the value of Event, the call can be blocking or non-blocking.
    Blocking calls MUST NOT be invoked inside the callback routines, except
    when a callback being executed in the Wait thread context deregisters
    its associated Wait (in this case there is no reason for making blocking calls),
    or when a callback queued to a worker thread is deregistering some other wait item
    (be careful of deadlocks here).

Arguments:

    WaitHandle - Handle indentifying the wait.

    Event - Event to wait upon.
            (HANDLE)-1: The function creates an event and waits on it.
            Event : The caller passes an Event. The function removes the wait handle,
                    but does not wait for all callbacks to complete. The Event is 
                    released after all callbacks have completed.
            NULL : The function is non-blocking. The function removes the wait handle,
                    but does not wait for all callbacks to complete.
            
Return Value:

    STATUS_SUCCESS - The deregistration was successful.
    STATUS_PENDING - Some callback is still pending.

--*/

{
    NTSTATUS Status, StatusAsync ;
    PRTLP_WAIT Wait = (PRTLP_WAIT) WaitHandle ;
    ULONG CurrentThreadId =  HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;
    PRTLP_EVENT CompletionEvent = NULL ;
    HANDLE ThreadHandle = Wait->ThreadCB->ThreadHandle;
    ULONG NonBlocking = ( Event != (HANDLE) -1 ) ; //The call returns non-blocking

    CHECK_DEL_SIGNATURE( Wait ) ;
    SET_DEL_SIGNATURE( Wait ) ;
    
    #if DBG1
    Wait->ThreadId2 = CurrentThreadId ;
    #endif
    
    if (Event == (HANDLE)-1) {

        // Get an event from the event cache

        CompletionEvent = RtlpGetWaitEvent () ;

        if (!CompletionEvent) {

            return STATUS_NO_MEMORY ;

        }
    }

    
    Wait = (PRTLP_WAIT) WaitHandle ;

    #if DBG1
    if (DPRN0)
    DbgPrint("<%d:%d> Wait %x deregistering by thread:<%x:%x>\n\n", Wait->DbgId, 
                Wait->RefCount, (ULONG_PTR)Wait,
                CurrentThreadId,
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
    #endif


    Wait->CompletionEvent = CompletionEvent
                            ? CompletionEvent->Handle
                            : Event ;

    //
    // RtlDeregisterWaitEx is being called from within the Wait thread callback
    //
    
    if ( CurrentThreadId == Wait->ThreadCB->ThreadId ) {

        Status = RtlpDeregisterWait ( Wait, NULL, NULL ) ;


        // all callback functions run in the wait thread. So cannot return PENDING
        
        ASSERT ( Status != STATUS_PENDING ) ;
          
    
    } else {

        PRTLP_EVENT PartialCompletionEvent = NULL ;

        if (NonBlocking) {
        
            PartialCompletionEvent = RtlpGetWaitEvent () ;

            if (!PartialCompletionEvent) {

                return STATUS_NO_MEMORY ;
            }
        }
        
        // Queue an APC to the Wait Thread
        
        Status = NtQueueApcThread(
                        Wait->ThreadCB->ThreadHandle,
                        (PPS_APC_ROUTINE)RtlpDeregisterWait,
                        (PVOID) Wait,
                        NonBlocking ? PartialCompletionEvent->Handle : NULL ,
                        NonBlocking ? (PVOID)&StatusAsync : NULL
                        );
                        
        if (! NT_SUCCESS(Status)) {

            if (CompletionEvent) RtlpFreeWaitEvent( CompletionEvent ) ;
            if (PartialCompletionEvent) RtlpFreeWaitEvent( PartialCompletionEvent ) ;
    
            return Status ;
        }


        // block till the wait entry has been deactivated
        
        if (NonBlocking) {
        
            Status = RtlpWaitForEvent( PartialCompletionEvent->Handle, ThreadHandle ) ;
        }    


        if (PartialCompletionEvent) RtlpFreeWaitEvent( PartialCompletionEvent ) ;

    }

    if ( CompletionEvent ) {

        // wait for Event to be fired. Return if the thread has been killed.

        #if DBG1
        if (DPRN0)
        DbgPrint("Wait %x deregister waiting ThreadId<%x:%x>\n\n", 
                (ULONG_PTR)Wait,
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
        #endif
        
        Status = RtlpWaitForEvent( CompletionEvent->Handle, ThreadHandle ) ;

        #if DBG1
        if (DPRN0)
        DbgPrint("Wait %x deregister completed\n\n", (ULONG_PTR)Wait) ;
        #endif

        if (CompletionEvent) RtlpFreeWaitEvent( CompletionEvent ) ;

        return NT_SUCCESS( Status ) ? STATUS_SUCCESS : Status ;
        
    } else {

        return StatusAsync ;
    }
}



NTSTATUS
RtlQueueWorkItem(
    IN  WORKERCALLBACKFUNC Function,
    IN  PVOID Context,
    IN  ULONG  Flags
    )

/*++

Routine Description:

    This routine queues up the request to be executed in a worker thread.

Arguments:

    Function - Routine that is called by the worker thread

    Context - Opaque pointer passed in as an argument to WorkerProc

    Flags - Can be:

            WT_EXECUTEINIOTHREAD - Specifies that the WorkerProc should be invoked
            by a thread that is never destroyed when there are pending IO requests.
            This can be used by threads that invoke I/O and/or schedule APCs.

            The below flag can also be set:
            WT_EXECUTELONGFUNCTION - Specifies that the function might block for a
            long duration.

Return Value:

    STATUS_SUCCESS - Queued successfully.

    STATUS_NO_MEMORY - There was not sufficient heap to perform the
        requested operation.

--*/

{
    ULONG Threshold ;
    ULONG CurrentTickCount ;
    NTSTATUS Status = STATUS_SUCCESS ;

    // Make sure the worker thread pool is initialized

    if (CompletedWorkerInitialization != 1) {

        Status = RtlpInitializeWorkerThreadPool () ;
        
        if (! NT_SUCCESS(Status) )
            return Status ;
    }


    // Take lock for the global worker thread pool

    RtlEnterCriticalSection (&WorkerCriticalSection) ;

    
    if (Flags & WT_EXECUTEINIOTHREAD || Flags & WT_EXECUTEINUITHREAD) {

        //
        // execute in IO Worker thread
        //

        ULONG NumEffIOWorkerThreads = NumIOWorkerThreads - NumLongIOWorkRequests ;
        ULONG ThreadCreationDampingTime = NumIOWorkerThreads < NEW_THREAD_THRESHOLD
                                            ? THREAD_CREATION_DAMPING_TIME1
                                            : THREAD_CREATION_DAMPING_TIME2 ;
                                            
        if (PersistentIOTCB && (Flags&WT_EXECUTELONGFUNCTION))
            NumEffIOWorkerThreads -- ;

        
        // Check if we need to grow I/O worker thread pool

        Threshold = (NumEffIOWorkerThreads < MAX_WORKER_THREADS 
                    ? NEW_THREAD_THRESHOLD * NumEffIOWorkerThreads 
                    : 0xffffffff) ;

        if (LastThreadCreationTickCount > NtGetTickCount())
            LastThreadCreationTickCount = NtGetTickCount() ;

        if (NumEffIOWorkerThreads == 0
            || ((NumIOWorkRequests - NumLongIOWorkRequests > Threshold)
                    && (LastThreadCreationTickCount + ThreadCreationDampingTime 
                        < NtGetTickCount()))) {

            // Grow the IO worker thread pool

            Status = RtlpStartIOWorkerThread () ;

        }

        if (Status == STATUS_SUCCESS) {

            // Queue the work request

            Status = RtlpQueueIOWorkerRequest (Function, Context, Flags) ;
        }


    } else {

        //
        // execute in regular worker thread
        //

        ULONG NumEffWorkerThreads = (NumWorkerThreads - NumLongWorkRequests) ;
        ULONG ThreadCreationDampingTime = NumWorkerThreads < NEW_THREAD_THRESHOLD
                                            ? THREAD_CREATION_DAMPING_TIME1
                                            : (NumWorkerThreads < 50
                                                ? THREAD_CREATION_DAMPING_TIME2
                                                : NumWorkerThreads << 7); // *100ms
                                            
        // Check if we need to grow worker thread pool

        Threshold = (NumWorkerThreads < MAX_WORKER_THREADS 
                    ? (NumEffWorkerThreads < 7 
                        ? NumEffWorkerThreads*NumEffWorkerThreads
                        : NEW_THREAD_THRESHOLD * NumEffWorkerThreads )
                    : 0xffffffff) ;

        if (LastThreadCreationTickCount > NtGetTickCount())
            LastThreadCreationTickCount = NtGetTickCount() ;

        if (NumEffWorkerThreads == 0 ||
            ( (NumWorkRequests - NumLongWorkRequests >= Threshold)
                    && (LastThreadCreationTickCount + ThreadCreationDampingTime 
                            < NtGetTickCount()))) 
        {

            // Grow the worker thread pool

            Status = RtlpStartWorkerThread () ;

        } 

        // Queue the work request

        if (Status == STATUS_SUCCESS) {

            Status = RtlpQueueWorkerRequest (Function, Context, Flags) ;
        }

    }

    // Release lock on the worker thread pool

    RtlLeaveCriticalSection (&WorkerCriticalSection) ;

    return Status ;
}



NTSTATUS
RtlSetIoCompletionCallback (
    IN  HANDLE  FileHandle,
    IN  APC_CALLBACK_FUNCTION  CompletionProc,
    IN  ULONG Flags
    )

/*++

Routine Description:

    This routine binds an Handle and an associated callback function to the
    IoCompletionPort which queues work items to worker threads.

Arguments:

    Handle - handle to be bound to the IO completion port
    
    CompletionProc - callback function to be executed when an IO request
        pending on the IO handle completes.

    Flags - Reserved. pass 0.

--*/

{
    IO_STATUS_BLOCK IoSb ;
    FILE_COMPLETION_INFORMATION CompletionInfo ;
    NTSTATUS Status ;
    

    // Make sure that the worker thread pool is initialized as the file handle
    // is bound to IO completion port.

    if (CompletedWorkerInitialization != 1) {

        Status = RtlpInitializeWorkerThreadPool () ;
        
        if (! NT_SUCCESS(Status) )
            return Status ;

    }


    //
    // from now on NumMinWorkerThreads should be 1. If there is only 1 worker thread
    // create a new one.
    //
    
    if ( NumMinWorkerThreads == 0 ) {
    
        // Take lock for the global worker thread pool

        RtlEnterCriticalSection (&WorkerCriticalSection) ;

        if (NumWorkerThreads == 0) {

            Status = RtlpStartWorkerThread () ;

            if ( ! NT_SUCCESS(Status) ) {
            
                RtlLeaveCriticalSection (&WorkerCriticalSection) ;
                return Status ;
            }
        }

        // from now on, there will be at least 1 worker thread
        NumMinWorkerThreads = 1 ;
        
        RtlLeaveCriticalSection (&WorkerCriticalSection) ;

    }


    // bind to IoCompletionPort, which queues work items to worker threads

    CompletionInfo.Port = WorkerCompletionPort ;
    CompletionInfo.Key = (PVOID) CompletionProc ;

    Status = NtSetInformationFile (
                        FileHandle,
                        &IoSb, //not initialized
                        &CompletionInfo,
                        sizeof(CompletionInfo),
                        FileCompletionInformation //enum flag
                        ) ;
    return Status ;
}



NTSTATUS
RtlCreateTimerQueue(
    OUT PHANDLE TimerQueueHandle
    )

/*++

Routine Description:

    This routine creates a queue that can be used to queue time based tasks.

Arguments:

    TimerQueueHandle - Returns back the Handle identifying the timer queue created.

Return Value:

    NTSTATUS - Result code from call.  The following are returned

        STATUS_SUCCESS - Timer Queue created successfully.

        STATUS_NO_MEMORY - There was not sufficient heap to perform the
            requested operation.

--*/

{
    PRTLP_TIMER_QUEUE Queue ;
    NTSTATUS Status ;


    // Initialize the timer component if it hasnt been done already

    if (CompletedTimerInitialization != 1) {

        Status = RtlpInitializeTimerThreadPool () ;

        if ( !NT_SUCCESS(Status) )
            return Status ;

    }


    //
    // even if the timer component is initialized, the timer thread could have
    // been killed
    //
    
    ACQUIRE_GLOBAL_TIMER_LOCK( ) ;
    
    if (TimerThreadHandle == NULL) {

        Status = RtlpStartThreadFunc (RtlpTimerThread, &TimerThreadHandle) ;

        if (!NT_SUCCESS(Status) ) {

            RELEASE_GLOBAL_TIMER_LOCK( ) ;
        
            return Status ;
        }
    }

    InterlockedIncrement( &NumTimerQueues ) ;

    RELEASE_GLOBAL_TIMER_LOCK( ) ;

    
    // Allocate a Queue structure

    Queue = (PRTLP_TIMER_QUEUE) RtlpAllocateTPHeap (
                                      sizeof (RTLP_TIMER_QUEUE),
                                      HEAP_ZERO_MEMORY
                                      ) ;

    if (Queue == NULL) {

        InterlockedDecrement( &NumTimerQueues ) ;
        
        return STATUS_NO_MEMORY ;
    }

    Queue->RefCount = 1 ;

    
    // Initialize the allocated queue

    InitializeListHead (&Queue->List) ;
    InitializeListHead (&Queue->TimerList) ;
    InitializeListHead (&Queue->UncancelledTimerList) ;
    SET_SIGNATURE( Queue ) ;

    Queue->DeltaFiringTime = 0 ;

    #if DBG1
    Queue->DbgId = ++NextTimerDbgId ;
    Queue->ThreadId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;
    if (DPRN0)
    DbgPrint("<%d:%d> TimerQueue %x created by thread:<%x:%x>\n\n", 
                Queue->DbgId, 1, (ULONG_PTR)Queue,
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
    #endif
    
    *TimerQueueHandle = Queue ;
    
    return STATUS_SUCCESS ;
}


NTSTATUS
RtlDeleteTimerQueue(
    IN HANDLE TimerQueueHandle
    )

/*++

Routine Description:

    This routine deletes a previously created queue. This call is non-blocking and 
    can be made from Callbacks. Pending callbacks already queued to worker threads
    are not cancelled.

Arguments:

    TimerQueueHandle - Handle identifying the timer queue created.

Return Value:

    NTSTATUS - Result code from call.

        STATUS_PENDING - Timer Queue created successfully.
        
--*/

{
    return RtlDeleteTimerQueueEx( TimerQueueHandle, NULL ) ;
}


NTSTATUS
RtlDeleteTimerQueueEx (
    HANDLE QueueHandle,
    HANDLE Event
    )
/*++

Routine Description:

    This routine deletes the queue specified in the Request and frees all timers.
    This call is blocking or non-blocking depending on the value passed for Event.
    Blocking calls cannot be made from ANY Timer callbacks. After this call returns,
    no new Callbacks will be fired for any timer associated with the queue.

Arguments:

    QueueHandle - queue to delete

    Event - Event to wait upon.
            (HANDLE)-1: The function creates an event and waits on it.
            Event : The caller passes an event. The function marks the queue for deletion,
                    but does not wait for all callbacks to complete. The event is 
                    signalled after all callbacks have completed.
            NULL : The function is non-blocking. The function marks the queue for deletion,
                    but does not wait for all callbacks to complete.
            
Return Value:

    STATUS_SUCCESS - All timer callbacks have completed.
    STATUS_PENDING - Non-Blocking call. Some timer callbacks associated with timers
                    in this queue may not have completed.
    
--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut ;
    PRTLP_EVENT CompletionEvent = NULL ;
    PRTLP_TIMER_QUEUE Queue = (PRTLP_TIMER_QUEUE)QueueHandle ;

    CHECK_DEL_SIGNATURE( Queue ) ;
    SET_DEL_SIGNATURE( Queue ) ;

    
    #if DBG1
    Queue->ThreadId2 = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;
    if (DPRN0)
    DbgPrint("\n<%d:%d> Queue Delete(Queue:%x Event:%x by Thread:<%x:%x>)\n\n", 
             Queue->DbgId, Queue->RefCount, (ULONG_PTR)Queue, (ULONG_PTR)Event,
             HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
             HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
    #endif


    if (Event == (HANDLE)-1 ) {

        // Get an event from the event cache

        CompletionEvent = RtlpGetWaitEvent () ;

        if (!CompletionEvent) {

            return STATUS_NO_MEMORY ;

        }
    }
    
    Queue->CompletionEvent = CompletionEvent
                             ? CompletionEvent->Handle 
                             : Event ;


    // once this flag is set, no timer will be fired
    
    ACQUIRE_GLOBAL_TIMER_LOCK();
    Queue->State |= STATE_DONTFIRE;
    RELEASE_GLOBAL_TIMER_LOCK();



    // queue an APC
    
    Status = NtQueueApcThread(
                    TimerThreadHandle,
                    (PPS_APC_ROUTINE)RtlpDeleteTimerQueue,
                    (PVOID) QueueHandle,
                    NULL,
                    NULL
                    );

    if (! NT_SUCCESS(Status)) {

        RtlpFreeWaitEvent( CompletionEvent ) ;

        return Status ;
    }
    
    if (CompletionEvent) {

        // wait for Event to be fired. Return if the thread has been killed.


        #if DBG1
        if (DPRN0)
        DbgPrint("<%x> Queue delete waiting Thread<%d:%d>\n\n",
                (ULONG_PTR)Queue,
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
        #endif


        Status = RtlpWaitForEvent( CompletionEvent->Handle, TimerThreadHandle ) ;


        #if DBG1
        if (DPRN0)
        DbgPrint("<%x> Queue delete completed\n\n", (ULONG_PTR) Queue) ;
        #endif

        RtlpFreeWaitEvent( CompletionEvent ) ;

        return NT_SUCCESS( Status ) ? STATUS_SUCCESS : Status ;

    } else {

        return STATUS_PENDING ;
    }
}



NTSTATUS
RtlCreateTimer(
    IN  HANDLE TimerQueueHandle,
    OUT HANDLE *Handle,
    IN  WAITORTIMERCALLBACKFUNC Function,
    IN  PVOID Context,
    IN  ULONG  DueTime,
    IN  ULONG  Period,
    IN  ULONG  Flags
    )
/*++

Routine Description:

    This routine puts a timer request in the queue identified in by TimerQueueHandle.
    The timer request can be one shot or periodic.

Arguments:

    TimerQueueHandle - Handle identifying the timer queue in which to insert the timer
                    request.

    Handle - Specifies a location to return a handle to this timer request

    Function - Routine that is called when the timer fires

    Context - Opaque pointer passed in as an argument to WorkerProc

    DueTime - Specifies the time in milliseconds after which the timer fires.

    Period - Specifies the period of the timer in milliseconds. This should be 0 for
    one shot requests.

    Flags - Can be one of:

            WT_EXECUTEINTIMERTHREAD - if WorkerProc should be invoked in the wait thread
            it this should only be used for small routines.

            WT_EXECUTELONGFUNCTION - if WorkerProc can possibly block for a long time.

            WT_EXECUTEINIOTHREAD - if WorkerProc should be invoked in IO worker thread
            
Return Value:

    NTSTATUS - Result code from call.  The following are returned

        STATUS_SUCCESS - Timer Queue created successfully.

        STATUS_NO_MEMORY - There was not sufficient heap to perform the
            requested operation.

--*/

{
    NTSTATUS Status ;
    PRTLP_TIMER Timer ;

    Timer = (PRTLP_TIMER) RtlpAllocateTPHeap (
                                sizeof (RTLP_TIMER),
                                HEAP_ZERO_MEMORY
                                ) ;

    if (Timer == NULL) {

        return STATUS_NO_MEMORY ;

    }

    // Initialize the allocated timer

    Timer->DeltaFiringTime = DueTime ;
    Timer->Queue = (PRTLP_TIMER_QUEUE) TimerQueueHandle ;
    Timer->RefCount = 1 ;
    Timer->Flags = Flags ;
    Timer->Function = Function ;
    Timer->Context = Context ;
    //todo:remove below
    Timer->Period = (Period == -1) ? 0 : Period;
    InitializeListHead( &Timer->TimersToFireList ) ;
    SET_SIGNATURE( Timer ) ;
    
    
    #if DBG1
    Timer->DbgId = ++ Timer->Queue->NextDbgId ;
    Timer->ThreadId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;
    if (DPRN1)
    DbgPrint("\n<%d:%d:%d> Timer: created by Thread:<%x:%x>\n\n", 
            Timer->Queue->DbgId, Timer->DbgId, 1,
            HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
            HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
    #endif

    *Handle = Timer ;


    // Increment the total number of timers in the queue

    InterlockedIncrement( &((PRTLP_TIMER_QUEUE)TimerQueueHandle)->RefCount ) ;


    // Queue APC to timer thread

    Status = NtQueueApcThread(
                    TimerThreadHandle,
                    (PPS_APC_ROUTINE)RtlpAddTimer,
                    (PVOID)Timer,
                    NULL,
                    NULL
                    ) ;

    return Status ;
}


NTSTATUS
RtlUpdateTimer(
    IN HANDLE TimerQueueHandle,
    IN HANDLE Timer,
    IN ULONG  DueTime,
    IN ULONG  Period
    )
/*++

Routine Description:

    This routine updates the timer

Arguments:

    TimerQueueHandle - Handle identifying the queue in which the timer to be updated exists

    Timer - Specifies a handle to the timer which needs to be updated

    DueTime - Specifies the time in milliseconds after which the timer fires.

    Period - Specifies the period of the timer in milliseconds. This should be 
            0 for one shot requests.

Return Value:

    NTSTATUS - Result code from call.  The following are returned

        STATUS_SUCCESS - Timer updated successfully.

--*/
{
    NTSTATUS Status ;
    PRTLP_TIMER TmpTimer ;

    CHECK_DEL_SIGNATURE( (PRTLP_TIMER)Timer ) ;

    
    TmpTimer = (PRTLP_TIMER) RtlpAllocateTPHeap (
                                        sizeof (RTLP_TIMER),
                                        0
                                        ) ;

    if (TmpTimer == NULL) {

        return STATUS_NO_MEMORY ;
    }

    TmpTimer->DeltaFiringTime = DueTime;
    //todo:remove below
    if (Period==-1) Period = 0;
    TmpTimer->Period = Period ;

    #if DBG1
    ((PRTLP_TIMER)Timer)->ThreadId2 = 
                    HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;
    #endif
    #if DBG1
    if (DPRN1)
    DbgPrint("<%d:%d:%d> Timer: updated by Thread:<%x:%x>\n\n", 
                ((PRTLP_TIMER)Timer)->Queue->DbgId, 
                ((PRTLP_TIMER)Timer)->DbgId, ((PRTLP_TIMER)Timer)->RefCount,
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
    #endif


    // queue APC to update timer
    
    Status = NtQueueApcThread (
                    TimerThreadHandle,
                    (PPS_APC_ROUTINE)RtlpUpdateTimer,
                    (PVOID)Timer, //Actual timer
                    (PVOID)TmpTimer,
                    NULL
                    );


    return Status ;
}


NTSTATUS
RtlDeleteTimer (
    IN HANDLE TimerQueueHandle,
    IN HANDLE TimerToCancel,
    IN HANDLE Event
    )
/*++

Routine Description:

    This routine cancels the timer

Arguments:

    TimerQueueHandle - Handle identifying the queue from which to delete timer

    TimerToCancel - Handle identifying the timer to cancel

    Event - Event to be signalled when the timer is deleted
            (HANDLE)-1: The function creates an event and waits on it.
            Event : The caller passes an event. The function marks the timer for deletion,
                    but does not wait for all callbacks to complete. The event is 
                    signalled after all callbacks have completed.
            NULL : The function is non-blocking. The function marks the timer for deletion,
                    but does not wait for all callbacks to complete.

Return Value:

    NTSTATUS - Result code from call.  The following are returned

        STATUS_SUCCESS - Timer cancelled. No pending callbacks.
        STATUS_PENDING - Timer cancelled. Some callbacks still not completed.

--*/
{
    NTSTATUS Status ;
    PRTLP_EVENT CompletionEvent = NULL ;
    PRTLP_TIMER Timer = (PRTLP_TIMER) TimerToCancel ;
    ULONG TimerRefCount ;
    #if DBG1
    ULONG QueueDbgId = Timer->Queue->DbgId ;
    #endif


    CHECK_DEL_SIGNATURE( Timer ) ;
    SET_DEL_SIGNATURE( Timer ) ;
    CHECK_DEL_SIGNATURE( (PRTLP_TIMER_QUEUE)TimerQueueHandle ) ;

    
    if (Event == (HANDLE)-1 ) {

        // Get an event from the event cache

        CompletionEvent = RtlpGetWaitEvent () ;

        if (!CompletionEvent) {

            return STATUS_NO_MEMORY ;
        }
    }

    #if DBG1
    Timer->ThreadId2 = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;
    #endif
    #if DBG1
    if (DPRN0)
    DbgPrint("\n<%d:%d:%d> Timer: Cancel:(Timer:%x, Event:%x)\n\n", 
                Timer->Queue->DbgId, Timer->DbgId, Timer->RefCount, 
                (ULONG_PTR)Timer, (ULONG_PTR)Event) ;
    #endif

    Timer->CompletionEvent = CompletionEvent
                            ? CompletionEvent->Handle 
                            : Event ;


    ACQUIRE_GLOBAL_TIMER_LOCK();
    Timer->State |= STATE_DONTFIRE ;
    TimerRefCount = Timer->RefCount ;
    RELEASE_GLOBAL_TIMER_LOCK();

    
    Status = NtQueueApcThread(
                TimerThreadHandle,
                (PPS_APC_ROUTINE)RtlpCancelTimer,
                (PVOID)TimerToCancel,
                NULL,
                NULL
                );

    if (! NT_SUCCESS(Status)) {

        RtlpFreeWaitEvent( CompletionEvent ) ;

        return Status ;
    }


    
    if ( CompletionEvent ) {

        // wait for the event to be signalled 

        #if DBG1
        if (DPRN0)
        DbgPrint("<%d> Timer: %x: Cancel waiting Thread<%d:%d>\n\n", 
                QueueDbgId, (ULONG_PTR)Timer,
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;
        #endif

        
        Status = RtlpWaitForEvent( CompletionEvent->Handle,  TimerThreadHandle ) ;

        
        #if DBG1
        if (DPRN0)
        DbgPrint("<%d> Timer: %x: Cancel waiting done\n\n", QueueDbgId, 
                (ULONG_PTR)Timer) ;
        #endif


        RtlpFreeWaitEvent( CompletionEvent ) ;

        return NT_SUCCESS(Status) ? STATUS_SUCCESS : Status ;

    } else {

        return (TimerRefCount > 1) ? STATUS_PENDING : STATUS_SUCCESS;
    }
}




NTSTATUS
NTAPI
RtlSetThreadPoolStartFunc(
    PRTLP_START_THREAD StartFunc,
    PRTLP_EXIT_THREAD ExitFunc
    )
/*++

Routine Description:

    This routine sets the thread pool's thread creation function.  This is not
    thread safe, because it is intended solely for kernel32 to call for processes
    that aren't csrss/smss.

Arguments:

    StartFunc - Function to create a new thread

Return Value:

--*/

{
    RtlpStartThreadFunc = StartFunc ;
    RtlpExitThreadFunc = ExitFunc ;
    return STATUS_SUCCESS ;
}



NTSTATUS
RtlThreadPoolCleanup (
    ULONG Flags
    )
/*++

Routine Description:
    This routine cleans up the thread pool.

Arguments:

    None
    
Return Value:

    STATUS_SUCCESS : if none of the components are in use.
    STATUS_UNSUCCESSFUL : if some components are still in use.

--*/
{
    BOOLEAN Cleanup ;
    PLIST_ENTRY Node ;
    ULONG i ;
    HANDLE TmpHandle ;
    

    // cleanup timer thread
    
    IS_COMPONENT_INITIALIZED(StartedTimerInitialization, 
                            CompletedTimerInitialization,
                            Cleanup ) ;

    if ( Cleanup ) {

        ACQUIRE_GLOBAL_TIMER_LOCK() ;
        
        if (NumTimerQueues != 0 ) {
        
            ASSERTMSG( FALSE,
                "Trying to deinitialize ThreadPool when timers exist\n" ) ;
            RELEASE_GLOBAL_TIMER_LOCK() ;

            return STATUS_UNSUCCESSFUL ;
        }
        
        NtQueueApcThread(
                TimerThreadHandle,
                (PPS_APC_ROUTINE)RtlpThreadCleanup,
                NULL,
                NULL,
                NULL
                );

        NtClose( TimerThreadHandle ) ;
        TimerThreadHandle = NULL ;

        RELEASE_GLOBAL_TIMER_LOCK() ;

    }


    //
    // cleanup wait threads
    //

    IS_COMPONENT_INITIALIZED(StartedWaitInitialization, 
                            CompletedWaitInitialization,
                            Cleanup ) ;

    if ( Cleanup ) {

        PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB ;

        ACQUIRE_GLOBAL_WAIT_LOCK() ;

        // Queue an APC to all Wait Threads
        
        for (Node = WaitThreads.Flink ; Node != &WaitThreads ; 
                Node = Node->Flink) 
        {

            ThreadCB = CONTAINING_RECORD(Node, 
                                RTLP_WAIT_THREAD_CONTROL_BLOCK,
                                WaitThreadsList) ;

            if ( ThreadCB->NumWaits != 0 ) {

                ASSERTMSG( FALSE,
                    "Cannot cleanup ThreadPool. Registered Wait events exist." ) ;
                RELEASE_GLOBAL_WAIT_LOCK( ) ;
                
                return STATUS_UNSUCCESSFUL ;
            }

            RemoveEntryList( &ThreadCB->WaitThreadsList ) ;
            TmpHandle = ThreadCB->ThreadHandle ;
            
            NtQueueApcThread(
                    ThreadCB->ThreadHandle,
                    (PPS_APC_ROUTINE)RtlpThreadCleanup,
                    NULL,
                    NULL,
                    NULL
                    );

            NtClose( TmpHandle ) ;
        }

        RELEASE_GLOBAL_WAIT_LOCK( ) ;

    }


    // cleanup worker threads

    IS_COMPONENT_INITIALIZED( StartedWorkerInitialization, 
                            CompletedWorkerInitialization,
                            Cleanup ) ;
                                
    if ( Cleanup ) {

        RtlEnterCriticalSection (&WorkerCriticalSection) ;

        if ( (NumWorkRequests != 0) || (NumIOWorkRequests != 0) ) {

            ASSERTMSG( FALSE,
                "Cannot cleanup ThreadPool. Work requests pending." ) ;

            RtlLeaveCriticalSection (&WorkerCriticalSection) ;
            
            return STATUS_UNSUCCESSFUL ;
        }
        
        // queue a cleanup for each worker thread
        
        for (i = 0 ;  i < NumWorkerThreads ; i ++ ) {

            NtSetIoCompletion (
                    WorkerCompletionPort,
                    RtlpThreadCleanup,
                    NULL,
                    STATUS_SUCCESS,
                    0
                    );
        }

        // queue an apc to cleanup all IO worker threads

        for (Node = IOWorkerThreads.Flink ; Node != &IOWorkerThreads ;
                Node = Node->Flink )
        {
            PRTLP_IOWORKER_TCB ThreadCB ;
            
            ThreadCB = CONTAINING_RECORD (Node, RTLP_IOWORKER_TCB, List) ;
            RemoveEntryList( &ThreadCB->List) ;
            TmpHandle = ThreadCB->ThreadHandle ;

            NtQueueApcThread(
                   ThreadCB->ThreadHandle,
                   (PPS_APC_ROUTINE)RtlpThreadCleanup,
                   NULL,
                   NULL,
                   NULL
                   );

            NtClose( TmpHandle ) ;
        }

        NumWorkerThreads = NumIOWorkerThreads = 0 ;

        RtlLeaveCriticalSection (&WorkerCriticalSection) ;

    }

    return STATUS_SUCCESS ;

}


// Private Functions


// Worker functions


NTSTATUS
RtlpQueueWorkerRequest (
    WORKERCALLBACKFUNC Function,
    PVOID Context,
    ULONG Flags
    )
/*++

Routine Description:

    This routine queues up the request to be executed in a worker thread.

Arguments:

    Function - Routine that is called by the worker thread

    Context - Opaque pointer passed in as an argument to WorkerProc

    Flags - flags passed to RtlQueueWorkItem
    
Return Value:

--*/

{
    NTSTATUS Status ;
    PRTLP_WORK WorkEntry ;
    
    // Increment the outstanding work request counter

    InterlockedIncrement (&NumWorkRequests) ;
    if (Flags & WT_EXECUTELONGFUNCTION) {
        InterlockedIncrement( & NumLongWorkRequests ) ;
    }

    WorkEntry = (PRTLP_WORK) RtlpForceAllocateTPHeap ( sizeof (RTLP_WORK),
                                                        HEAP_ZERO_MEMORY) ;
    WorkEntry->Function = Function ;
    WorkEntry->Flags = Flags ;

    Status = NtSetIoCompletion (
                WorkerCompletionPort,
                RtlpExecuteWorkerRequest,
                (PVOID) WorkEntry,
                STATUS_SUCCESS,
                (ULONG_PTR)Context
                );

    if ( ! NT_SUCCESS(Status) ) {
    
        InterlockedDecrement (&NumWorkRequests) ;
        if (Flags && WT_EXECUTELONGFUNCTION) {
            InterlockedDecrement( &NumLongWorkRequests ) ;
        }
        
        #if DBG
        DbgPrint("ERROR!! Thread Pool (RtlQeueuWorkItem): could not queue work item\n");
        #endif
    }

    return Status ;
}


VOID
RtlpExecuteWorkerRequest (
    NTSTATUS Status, //not  used
    PVOID Context,
    PVOID WorkContext
    )
/*++

Routine Description:

    This routine executes a work item.
    
Arguments:

    Context - contains context to be passed to the callback function.

    WorkContext - contains callback function ptr and flags
    
Return Value:

--*/

{
    PRTLP_WORK WorkEntry = (PRTLP_WORK) WorkContext;

    #if (DBG1)
    DBG_SET_FUNCTION( WorkEntry->Function, Context ) ;
    #endif
    
    ((WORKERCALLBACKFUNC) WorkEntry->Function) ( Context ) ;

    InterlockedDecrement( &NumWorkRequests ) ;
    if (WorkEntry->Flags & WT_EXECUTELONGFUNCTION) {
        InterlockedDecrement( &NumLongWorkRequests ) ;
    }

    RtlpFreeTPHeap( WorkEntry ) ;
}


NTSTATUS
RtlpQueueIOWorkerRequest (
    WORKERCALLBACKFUNC Function,
    PVOID Context,
    ULONG Flags
    )

/*++

Routine Description:

    This routine queues up the request to be executed in an IO worker thread.

Arguments:

    Function - Routine that is called by the worker thread

    Context - Opaque pointer passed in as an argument to WorkerProc

Return Value:

--*/

{
    NTSTATUS Status ;
    PRTLP_IOWORKER_TCB TCB ;
    PPS_APC_ROUTINE IORoutine ;
    BOOLEAN LongFunction = (Flags & WT_EXECUTELONGFUNCTION) ? TRUE : FALSE ;
    PLIST_ENTRY  ple ;
    
    IORoutine = LongFunction
                ? RtlpExecuteLongIOWorkItem
                : RtlpExecuteIOWorkItem ;


    if (Flags & WT_EXECUTEINPERSISTENTIOTHREAD) {

        if (!PersistentIOTCB) {
            for (ple=IOWorkerThreads.Flink;  ;  ple=ple->Flink) {
                TCB = CONTAINING_RECORD (ple, RTLP_IOWORKER_TCB, List) ;
                if (! TCB->LongFunctionFlag)
                    break;
            }
            
            PersistentIOTCB = TCB ;
            TCB->Flags |= WT_EXECUTEINPERSISTENTIOTHREAD ;
            
        } else {
            TCB = PersistentIOTCB ;
        }

    } else {
        for (ple=IOWorkerThreads.Flink;  ;  ple=ple->Flink) {
        
            TCB = CONTAINING_RECORD (ple, RTLP_IOWORKER_TCB, List) ;

            // do not queue to the thread if it is executing a long function, or
            // if you are queueing a long function and the thread is a persistent thread
            
            if (! TCB->LongFunctionFlag
                && (! ((TCB->Flags&WT_EXECUTEINPERSISTENTIOTHREAD)
                        && (Flags&WT_EXECUTELONGFUNCTION)))) {
                break ;
            }            

        }
        
        // In order to implement "fair" assignment of work items between IO worker threads
        // each time remove the entry and reinsert at back.

        RemoveEntryList (&TCB->List) ;
        InsertTailList (&IOWorkerThreads, &TCB->List) ;
    }

             
    // Increment the outstanding work request counter

    InterlockedIncrement (&NumIOWorkRequests) ;
    if (LongFunction) {
        InterlockedIncrement( &NumLongIOWorkRequests ) ;
        TCB->LongFunctionFlag = TRUE ;
    }

    // Queue an APC to the IoWorker Thread

    Status = NtQueueApcThread(
                    TCB->ThreadHandle,
                    (PPS_APC_ROUTINE)IORoutine,
                    (PVOID)Function,
                    Context,
                    TCB
                    );

    if (! NT_SUCCESS( Status ) ) {
        InterlockedDecrement( &NumIOWorkRequests ) ;
        if (LongFunction)
            InterlockedDecrement( &NumLongIOWorkRequests ) ;
    }
    
    return Status ;

}



NTSTATUS
RtlpStartWorkerThread (
    )
/*++

Routine Description:

    This routine starts a regular worker thread

Arguments:


Return Value:

    NTSTATUS error codes resulting from attempts to create a thread
    STATUS_SUCCESS

--*/
{
    HANDLE ThreadHandle ;
    ULONG CurrentTickCount ;
    NTSTATUS Status ;

    // Create worker thread
    
    Status = RtlpStartThreadFunc (RtlpWorkerThread, &ThreadHandle) ;

    if (Status == STATUS_SUCCESS ) {

        // Update the time at which the current thread was created

        LastThreadCreationTickCount = NtGetTickCount() ;

        // Increment the count of the thread type created

        InterlockedIncrement(&NumWorkerThreads) ;

        // Close Thread handle, we dont need it.

        NtClose (ThreadHandle) ;

    } else {

        // Thread creation failed. If there is even one thread present do not return
        // failure - else queue the request anyway.

        if (NumWorkerThreads == 0) {

            return Status ;
        }

    }

    return STATUS_SUCCESS ;
}


NTSTATUS
RtlpStartIOWorkerThread (
    )
/*++

Routine Description:

    This routine starts an I/O worker thread

Arguments:


Return Value:

    NTSTATUS error codes resulting from attempts to create a thread
    STATUS_SUCCESS

--*/
{
    HANDLE ThreadHandle ;
    ULONG CurrentTickCount ;
    NTSTATUS Status ;


    // Create worker thread

    Status = RtlpStartThreadFunc (RtlpIOWorkerThread, &ThreadHandle) ;

    if (Status == STATUS_SUCCESS ) {

        NtClose( ThreadHandle ) ;

        // Update the time at which the current thread was created

        LastThreadCreationTickCount = NtGetTickCount() ;

    } else {

        // Thread creation failed. If there is even one thread present do not return
        // failure since we can still service the work request.

        if (NumIOWorkerThreads == 0) {

            return Status ;

        }
    }

    return STATUS_SUCCESS ;
}



NTSTATUS
RtlpInitializeWorkerThreadPool (
    )
/*++

Routine Description:

    This routine initializes all aspects of the thread pool.

Arguments:

    None

Return Value:

    None

--*/
{
    NTSTATUS Status = STATUS_SUCCESS ;
    LARGE_INTEGER TimeOut ;

    // In order to avoid an explicit RtlInitialize() function to initialize the thread pool
    // we use StartedInitialization and CompletedInitialization to provide us the necessary
    // synchronization to avoid multiple threads from initializing the thread pool.
    // This scheme does not work if RtlInitializeCriticalSection() fails - but in this case the
    // caller has not choices left.

    if (!InterlockedExchange(&StartedWorkerInitialization, 1L)) {

        if (CompletedWorkerInitialization)
            InterlockedExchange( &CompletedWorkerInitialization, 0 ) ;

            
        do {

            // Initialize Critical Sections

            Status = RtlInitializeCriticalSection( &WorkerCriticalSection );
            if (!NT_SUCCESS(Status))
                break ;


            InitializeListHead (&IOWorkerThreads) ;

            {            
                SYSTEM_BASIC_INFORMATION BasicInfo;

                // get number of processors

                Status = NtQuerySystemInformation (
                                    SystemBasicInformation,
                                    &BasicInfo,
                                    sizeof(BasicInfo),
                                    NULL
                                    ) ;

                if ( !NT_SUCCESS(Status) ) {
                    BasicInfo.NumberOfProcessors = 1 ;
                }

                // Create completion port used by worker threads

                Status = NtCreateIoCompletion (
                                    &WorkerCompletionPort,
                                    IO_COMPLETION_ALL_ACCESS,
                                    NULL,
                                    2 * BasicInfo.NumberOfProcessors
                                    );

                if (!NT_SUCCESS(Status))
                    break ;

            }

        } while ( FALSE ) ;

        if (!NT_SUCCESS(Status) ) {
        
            ASSERT ( Status == STATUS_SUCCESS ) ;
            StartedWorkerInitialization = 0 ;
            InterlockedExchange( &CompletedWorkerInitialization, ~0 ) ;
        }
        
        // Signal that initialization has completed

        InterlockedExchange (&CompletedWorkerInitialization, 1L) ;

    } else {

        LARGE_INTEGER Timeout ;

        // Sleep 1 ms and see if the other thread has completed initialization

        ONE_MILLISECOND_TIMEOUT(TimeOut) ;

        while (!(volatile ULONG) CompletedWorkerInitialization) {

            NtDelayExecution (FALSE, &TimeOut) ;

        }

        if (CompletedWorkerInitialization != 1)
            return STATUS_NO_MEMORY ;
        
    }

    return NT_SUCCESS(Status)  ? STATUS_SUCCESS : Status ;
}




LONG
RtlpWorkerThread (
    PVOID  Initialized
    )
/*++

Routine Description:

    All non I/O worker threads execute in this routine. Worker thread will try to
    terminate when it has not serviced a request for

        STARTING_WORKER_SLEEP_TIME +
        STARTING_WORKER_SLEEP_TIME << 1 +
        ...
        STARTING_WORKER_SLEEP_TIME << MAX_WORKER_SLEEP_TIME_EXPONENT

Arguments:

    Initialized - Set to 1 when we are initialized

Return Value:

--*/
{
    NTSTATUS Status ;
    PVOID WorkerProc ;
    PVOID Context ;
    IO_STATUS_BLOCK IoSb ;
    ULONG SleepTime ;
    LARGE_INTEGER TimeOut ;
    ULONG Terminate ;
    PVOID Overlapped ;


    // We are all initialized now. Notify the starter to queue the task.

    InterlockedExchange ((ULONG *)Initialized, 1L) ;


    // Set default sleep time for 20 seconds. This time is doubled each time a timeout
    // occurs after which the thread terminates

#define WORKER_IDLE_TIMEOUT     40000    // In Milliseconds
#define MAX_WORKER_SLEEP_TIME_EXPONENT 2

    SleepTime = WORKER_IDLE_TIMEOUT ;

    // Loop servicing I/O completion requests

    for ( ; ; ) {

        TimeOut.QuadPart = Int32x32To64( SleepTime, -10000 ) ;

        Status = NtRemoveIoCompletion(
                    WorkerCompletionPort,
                    (PVOID) &WorkerProc,
                    &Overlapped,
                    &IoSb,
                    &TimeOut
                    ) ;

        if (Status == STATUS_SUCCESS) {

            // Call the work item. 
            // If IO APC, context1 contains number of IO bytes transferred, and context2
            // contains the overlapped structure.
            // If (IO)WorkerFunction, context1 contains the actual WorkerFunction to be
            // executed and context2 contains the actual context

            Context = (PVOID) IoSb.Information ;

            ((APC_CALLBACK_FUNCTION)WorkerProc) (
                                        IoSb.Status, 
                                        Context,        // Number of IO bytes transferred
                                        Overlapped      // Overlapped structure
                                        ) ;

            SleepTime = WORKER_IDLE_TIMEOUT ;

        } else if (Status == STATUS_TIMEOUT) {

            // NtRemoveIoCompletion timed out. Check to see if have hit our limit
            // on waiting. If so terminate.

            Terminate = FALSE ;

            RtlEnterCriticalSection (&WorkerCriticalSection) ;

            // The thread terminates if there are > 1 threads and the queue is small
            // OR if there is only 1 thread and there is no request pending

            if (NumWorkerThreads >  1) {

                if (SleepTime >= (WORKER_IDLE_TIMEOUT << MAX_WORKER_SLEEP_TIME_EXPONENT)) {

                    //
                    // have been idle for very long time. terminate irrespective of number of
                    // work items. (This is useful when the set of runnable threads is taking
                    // care of all the work items being queued)
                    //
                    
                    Terminate = TRUE ;

                } else {
                
                    ULONG NumEffWorkerThreads = (NumWorkerThreads - NumLongWorkRequests) ;
                    ULONG Threshold ;
                    
                    // Check if we need to shrink worker thread pool

                    Threshold = NumEffWorkerThreads < 7
                                ? NumEffWorkerThreads*(NumEffWorkerThreads-1)
                                : NEW_THREAD_THRESHOLD * (NumEffWorkerThreads-1);


                    
                    if  (NumWorkRequests-NumLongWorkRequests < Threshold)  {

                        Terminate = TRUE ;

                    } else {

                        Terminate = FALSE ;
                        SleepTime <<= 1 ;
                    }
                }
                
            } else {

                if ( (NumMinWorkerThreads == 0) && (NumWorkRequests == 0) ) {

                    // delay termination of last thread
                    
                    if (SleepTime == WORKER_IDLE_TIMEOUT) {
                        SleepTime <<= 1 ;
                        Terminate = FALSE ;
                    }
                    else {
                        Terminate = TRUE ;
                    }
                    
                } else {

                    Terminate = FALSE ;

                }

            }

            if (Terminate) {

                NTSTATUS Status;
                THREAD_BASIC_INFORMATION ThreadInfo;
                ULONG IsIoPending ;
                HANDLE CurThreadHandle ;

                Status = NtDuplicateObject(
                            NtCurrentProcess(),
                            NtCurrentThread(),
                            NtCurrentProcess(),
                            &CurThreadHandle,
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS
                            ) ;

                ASSERT (Status == STATUS_SUCCESS) ;

                Terminate = FALSE ;

                Status = NtQueryInformationThread( CurThreadHandle,
                                                   ThreadIsIoPending,
                                                   &IsIoPending,
                                                   sizeof( IsIoPending ),
                                                   NULL
                                                 );
                if (NT_SUCCESS( Status )) {

                    if (! IsIoPending )
                        Terminate = TRUE ;
                }

                NtClose( CurThreadHandle ) ;
            }
            
            if (Terminate) {

                InterlockedDecrement (&NumWorkerThreads) ;

                RtlLeaveCriticalSection (&WorkerCriticalSection) ;

                RtlpExitThreadFunc( 0 );

            } else {

                // This is the condition where a request was queued *after* the
                // thread woke up - ready to terminate because of inactivity. In
                // this case dont terminate - service the completion port.

                RtlLeaveCriticalSection (&WorkerCriticalSection) ;

            }

        } else {

            ASSERT (FALSE) ;

        }

    }


    return 1 ;
}



LONG
RtlpIOWorkerThread (
    PVOID  Initialized
    )
/*++

Routine Description:

    All I/O worker threads execute in this routine. All the work requests execute as APCs
    in this thread.

Arguments:

    Initialized - set to 1 when the initialization has completed

Return Value:

--*/
{
    #define IOWORKER_IDLE_TIMEOUT     40000    // In Milliseconds
    
    LARGE_INTEGER TimeOut ;
    ULONG SleepTime = IOWORKER_IDLE_TIMEOUT ;
    RTLP_IOWORKER_TCB ThreadCB ;    // Control Block allocated on the stack
    NTSTATUS Status ;
    BOOLEAN Terminate ;

    
    //
    // Initialize thread control block
    // and insert it into list of IOWorker Threads
    //
    
    Status = NtDuplicateObject(
                NtCurrentProcess(),
                NtCurrentThread(),
                NtCurrentProcess(),
                &ThreadCB.ThreadHandle,
                0,
                FALSE,
                DUPLICATE_SAME_ACCESS
                ) ;

    ASSERT (Status == STATUS_SUCCESS) ;

    InsertHeadList (&IOWorkerThreads, &ThreadCB.List) ;
    ThreadCB.Flags = 0 ;
    ThreadCB.LongFunctionFlag = FALSE ;

    InterlockedIncrement(&NumIOWorkerThreads) ;

    
    // We are all initialized now. Notify the starter to queue the task.

    InterlockedExchange ((ULONG *)Initialized, 1L) ;



    // Sleep alertably so that all the activity can take place
    // in APCs

    for ( ; ; ) {

        // Set timeout for IdleTimeout

        TimeOut.QuadPart = Int32x32To64( SleepTime, -10000 ) ;


        Status = NtDelayExecution (TRUE, &TimeOut) ;


        // Status is STATUS_SUCCESS only when it has timed out
        
        if (Status != STATUS_SUCCESS) {
            continue ;
        } 


        //
        // idle timeout. check if you can terminate the thread
        //
        
        Terminate = FALSE ;

        RtlEnterCriticalSection (&WorkerCriticalSection) ;


        // dont terminate if it is a persistent thread
        
        if (ThreadCB.Flags & WT_EXECUTEINPERSISTENTIOTHREAD) {

            TimeOut.LowPart = 0x0;
            TimeOut.HighPart = 0x80000000;

            RtlLeaveCriticalSection (&WorkerCriticalSection) ;

            continue ;
        }

        
        // The thread terminates if there are > 1 threads and the queue is small
        // OR if there is only 1 thread and there is no request pending

        if (NumIOWorkerThreads >  1) {

            if (SleepTime >= (IOWORKER_IDLE_TIMEOUT << MAX_WORKER_SLEEP_TIME_EXPONENT)) {

                //
                // have been idle for very long time. terminate irrespective of number of
                // work items.
                //

                Terminate = TRUE ;
                
            } else {

                ULONG NumEffIOWorkerThreads = NumIOWorkerThreads - NumLongIOWorkRequests ;
                ULONG Threshold ;

                // Check if we need to shrink worker thread pool

                Threshold = NEW_THREAD_THRESHOLD * (NumEffIOWorkerThreads-1);



                if  (NumIOWorkRequests-NumLongIOWorkRequests < Threshold)  {

                    Terminate = TRUE ;

                } else {

                    Terminate = FALSE ;
                    SleepTime <<= 1 ;
                }
            }

        } else {

            if (NumWorkRequests == 0) {

                // delay termination of last thread

                if (SleepTime == IOWORKER_IDLE_TIMEOUT) {
                
                    SleepTime <<= 1 ;
                    Terminate = FALSE ;

                } else {
                
                    Terminate = TRUE ;
                }

            } else {

                Terminate = FALSE ;

            }

        }

        //
        // terminate only if no io is pending
        //
        
        if (Terminate) {

            NTSTATUS Status;
            THREAD_BASIC_INFORMATION ThreadInfo;
            ULONG IsIoPending ;
            
            Terminate = FALSE ;
            
            Status = NtQueryInformationThread( ThreadCB.ThreadHandle,
                                               ThreadIsIoPending,
                                               &IsIoPending,
                                               sizeof( IsIoPending ),
                                               NULL
                                             );
            if (NT_SUCCESS( Status )) {

                if (! IsIoPending )
                    Terminate = TRUE ;
            }
        }

        if (Terminate) {

            InterlockedDecrement (&NumIOWorkerThreads) ;

            RemoveEntryList (&ThreadCB.List) ;
            NtClose( ThreadCB.ThreadHandle ) ;
            
            RtlLeaveCriticalSection (&WorkerCriticalSection) ;

            RtlpExitThreadFunc( 0 );

        } else {

            // This is the condition where a request was queued *after* the
            // thread woke up - ready to terminate because of inactivity. In
            // this case dont terminate - service the completion port.

            RtlLeaveCriticalSection (&WorkerCriticalSection) ;

        }
    }

    return 0 ;  // Keep compiler happy

}



VOID
RtlpExecuteLongIOWorkItem (
    PVOID Function,
    PVOID Context,
    PVOID ThreadCB
    )
/*++

Routine Description:

    Executes an IO Work function. RUNs in a APC in the IO Worker thread.

Arguments:

    Function - Worker function to call

    Context - Argument for the worker function.

    NotUsed - Argument is not used in this function.

Return Value:

--*/
{
    #if (DBG1)
    DBG_SET_FUNCTION( Function, Context ) ;
    #endif
    
    // Invoke the function

    ((WORKERCALLBACKFUNC) Function)((PVOID)Context) ;


    ((PRTLP_IOWORKER_TCB)ThreadCB)->LongFunctionFlag = FALSE ;
    
    // Decrement pending IO requests count

    InterlockedDecrement (&NumIOWorkRequests) ;

    // decrement pending long funcitons

    InterlockedDecrement (&NumLongIOWorkRequests ) ;
}


VOID
RtlpExecuteIOWorkItem (
    PVOID Function,
    PVOID Context,
    PVOID NotUsed
    )
/*++

Routine Description:

    Executes an IO Work function. RUNs in a APC in the IO Worker thread.

Arguments:

    Function - Worker function to call

    Context - Argument for the worker function.

    NotUsed - Argument is not used in this function.

Return Value:


--*/
{
    #if (DBG1)
    DBG_SET_FUNCTION( Function, Context ) ;
    #endif

    // Invoke the function

    ((WORKERCALLBACKFUNC) Function)((PVOID)Context) ;

    // Decrement pending IO requests count

    InterlockedDecrement (&NumIOWorkRequests) ;

}



NTSTATUS
NTAPI
RtlpStartThread (
    PUSER_THREAD_START_ROUTINE Function,
    HANDLE *ThreadHandle
    )
/*++

Routine Description:

    This routine is used start a new wait thread in the pool.
Arguments:

    None

Return Value:

    STATUS_SUCCESS - Timer Queue created successfully.

    STATUS_NO_MEMORY - There was not sufficient heap to perform the requested operation.

--*/
{
    NTSTATUS Status ;
    ULONG Initialized ;
    LARGE_INTEGER TimeOut ;

    Initialized = FALSE ;

    // Create the first thread. This thread never dies until the process exits

    Status = RtlCreateUserThread(
                   NtCurrentProcess(), // process handle
                   NULL,               // security descriptor
                   FALSE,              // Create suspended?
                   0L,                 // ZeroBits: default
                   0L,                 // Max stack size: default
                   0L,                 // Committed stack size: default
                   Function,           // Function to start in
                   &Initialized,       // Event the thread signals when the thread is ready
                   ThreadHandle,       // Thread handle
                   NULL                // Thread id
                   );

    if ( Status == STATUS_SUCCESS ) {

        // Sleep 1 ms and see if the other thread has completed initialization

        ONE_MILLISECOND_TIMEOUT(TimeOut) ;

        while (!(volatile ULONG) Initialized) {

            NtDelayExecution (FALSE, &TimeOut) ;

        }

    }


    return Status ;
}

NTSTATUS
RtlpExitThread(
    NTSTATUS Status
    )
{
    return NtTerminateThread( NtCurrentThread(), Status );
}



// Wait functions


NTSTATUS
RtlpInitializeWaitThreadPool (
    )
/*++

Routine Description:

    This routine initializes all aspects of the thread pool.

Arguments:

    None

Return Value:

    None

--*/
{
    NTSTATUS Status ;
    LARGE_INTEGER TimeOut ;

    // In order to avoid an explicit RtlInitialize() function to initialize the wait thread pool
    // we use StartedWaitInitialization and CompletedWait Initialization to provide us the
    // necessary synchronization to avoid multiple threads from initializing the thread pool.
    // This scheme does not work if RtlInitializeCriticalSection() or NtCreateEvent fails - but in this case the
    // caller has not choices left.

    if (!InterlockedExchange(&StartedWaitInitialization, 1L)) {

        if (CompletedWaitInitialization)
            InterlockedExchange (&CompletedWaitInitialization, 0L) ;


        do {
            
            // Initialize Critical Sections

            Status = RtlInitializeCriticalSection( &WaitCriticalSection ) ;
            if ( ! NT_SUCCESS( Status ) )
                break;

        } while ( FALSE ) ;


        if (! NT_SUCCESS( Status ) ) {

            ASSERT ( NT_SUCCESS( Status ) ) ;

            StartedWaitInitialization = 0 ;
            InterlockedExchange (&CompletedWaitInitialization, ~0) ;
            
            return Status ;
        }
            
        InitializeListHead (&WaitThreads);  // Initialize global wait threads list

        InterlockedExchange (&CompletedWaitInitialization, 1L) ;

    } else {

        // Sleep 1 ms and see if the other thread has completed initialization

        ONE_MILLISECOND_TIMEOUT(TimeOut) ;

        while (!(volatile ULONG) CompletedWaitInitialization) {

            NtDelayExecution (FALSE, &TimeOut) ;

        }

        if (CompletedWaitInitialization != 1) {
            Status = STATUS_NO_MEMORY ;
        }
    }

    return Status ;
}



LONG
RtlpWaitThread (
    PVOID  Initialized
    )
/*++

Routine Description:

    This routine is used for all waits in the wait thread pool

Arguments:

    Initialized - This is set to 1 when the thread has initialized

Return Value:

    Nothing. The thread never terminates.

--*/
{
    ULONG  i ;                                   // Used as an index
    NTSTATUS Status ;
    LARGE_INTEGER TimeOut;                       // Timeout used for waits
    RTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB ;    // Control Block allocated on the stack


    // Initialize thread control block

    InitializeListHead (&ThreadCB.WaitThreadsList) ;

    Status = NtDuplicateObject(
                NtCurrentProcess(),
                NtCurrentThread(),
                NtCurrentProcess(),
                &ThreadCB.ThreadHandle,
                0,
                FALSE,
                DUPLICATE_SAME_ACCESS
                ) ;

    ASSERT (Status == STATUS_SUCCESS) ;

    ThreadCB.ThreadId =  HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;

    RtlZeroMemory (&ThreadCB.ActiveWaitArray[0], sizeof (HANDLE) * 64) ;

    RtlZeroMemory (&ThreadCB.ActiveWaitPointers[0], sizeof (HANDLE) * 64) ;



    // Initialize the timer related fields.

    Status = NtCreateTimer(
                 &ThreadCB.TimerHandle,
                 TIMER_ALL_ACCESS,
                 NULL,
                 NotificationTimer
                 ) ;

    if (! NT_SUCCESS( Status )) {
        ASSERT (FALSE);
        InterlockedExchange ((ULONG *)Initialized, (ULONG)~0) ;
        return 0;
    }
    

    ThreadCB.Firing64BitTickCount = 0 ;
    ThreadCB.Current64BitTickCount.QuadPart = NtGetTickCount() ;

    // Reset the NT Timer to never fire initially

    RtlpResetTimer (ThreadCB.TimerHandle, -1, &ThreadCB) ;
    
    InitializeListHead (&ThreadCB.TimerQueue.TimerList) ;
    InitializeListHead (&ThreadCB.TimerQueue.UncancelledTimerList) ;

    
    // Initialize the timer blocks

    RtlZeroMemory (&ThreadCB.TimerBlocks[0], sizeof (RTLP_TIMER) * 63) ;

    InitializeListHead (&ThreadCB.FreeTimerBlocks) ;

    for (i = 0 ; i < 63 ; i++) {

        InitializeListHead (&(&ThreadCB.TimerBlocks[i])->List) ;
        InsertHeadList (&ThreadCB.FreeTimerBlocks, &(&ThreadCB.TimerBlocks[i])->List) ;

    }


    // Insert this new wait thread in the WaitThreads list. Insert at the head so that
    // the request that caused this thread to be created can find it right away.

    InsertHeadList (&WaitThreads, &ThreadCB.WaitThreadsList) ;


    // The first wait element is the timer object

    ThreadCB.ActiveWaitArray[0] = ThreadCB.TimerHandle ;

    ThreadCB.NumActiveWaits = ThreadCB.NumWaits = 1 ;


    // till here, the function is running under the global wait lock


    
    // We are all initialized now. Notify the starter to queue the task.

    InterlockedExchange ((ULONG *)Initialized, 1) ;



    // Loop forever - wait threads never, never die.

    for ( ; ; ) {

        Status = NtWaitForMultipleObjects (
                     (CHAR) ThreadCB.NumActiveWaits,
                     ThreadCB.ActiveWaitArray,
                     WaitAny,
                     TRUE,      // Wait Alertably
                     NULL       // Wait forever
                     ) ;

        if (Status == STATUS_ALERTED || Status == STATUS_USER_APC) {

            continue ;

        } else if (Status >= STATUS_WAIT_0 && Status <= STATUS_WAIT_63) {

            if (Status == STATUS_WAIT_0) {

                RtlpProcessTimeouts (&ThreadCB) ;

            } else {

                // Wait completed call Callback function

                RtlpProcessWaitCompletion (
                        ThreadCB.ActiveWaitPointers[Status], Status) ;

            }

        } else if (Status >= STATUS_ABANDONED_WAIT_0 
                    && Status <= STATUS_ABANDONED_WAIT_63) {

            #if DBG
            DbgPrint ("RTL ThreadPool Wait Thread: Abandoned wait: %d\n",
                        Status - STATUS_ABANDONED_WAIT_0 ) ;
            #endif

            
            // Abandoned wait

            ASSERT (FALSE) ;

        } else {

            // Some other error: fatal condition
            LARGE_INTEGER TimeOut ;
            ULONG i ;
            
            ASSERTMSG( "Press 'i', and note the dbgprint\n", FALSE ) ;

            #if DBG
            DbgPrint ("RTL Thread Pool: Application closed an object handle "
                        "that the wait thread was waiting on: Code:%x ThreadId:<%x:%x>\n",
                        Status, HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                        HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)) ;

            TimeOut.QuadPart = 0 ;

            for (i=0;  i<ThreadCB.NumActiveWaits;  i++) {

                Status = NtWaitForMultipleObjects(
                             (CHAR) 1,
                             &ThreadCB.ActiveWaitArray[i],
                             WaitAny,
                             TRUE,      // Wait Alertably
                             &TimeOut   // Dont 0
                             ) ;

                if (Status == STATUS_INVALID_HANDLE) {
                    DbgPrint("Bad Handle index:%d WaitEntry Ptr:%x\n",
                                i, ThreadCB.ActiveWaitPointers[i]) ;
                }
            }
            
            #endif

            ASSERT( FALSE ) ;

            
            // Set timeout for the largest timeout possible

            TimeOut.LowPart = 0 ;
            TimeOut.HighPart = 0x80000000 ;

            NtDelayExecution (TRUE, &TimeOut) ;
            
        }

    } // forever

    return 0 ; // Keep compiler happy

}


VOID
RtlpAsyncCallbackCompletion(
    PVOID Context
    )
/*++

Routine Description:

    This routine is called in a (IO)worker thread and is used to decrement the 
    RefCount at the end and call RtlpDelete(Wait/Timer) if required

Arguments:

    Context - AsyncCallback: containing pointer to Wait/Timer object, 

Return Value:

--*/
{
    PRTLP_ASYNC_CALLBACK AsyncCallback ;
    NTSTATUS Status ;
    
    AsyncCallback = (PRTLP_ASYNC_CALLBACK) Context ;

    // callback queued by WaitThread (event or timer)
    
    if ( AsyncCallback->WaitThreadCallback ) {

        PRTLP_WAIT Wait = AsyncCallback->Wait ;

        //DPRN5
        if (DPRN4)
        DbgPrint("Calling WaitOrTimer: fn:%x  context:%x  bool:%d Thread<%d:%d>\n",
                (ULONG_PTR)Wait->Function, (ULONG_PTR)Wait->Context,
                (ULONG_PTR)AsyncCallback->TimerCondition,
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)
                ) ;

        #if (DBG1)
        DBG_SET_FUNCTION( Wait->Function, Wait->Context ) ;
        #endif
        
        ((WAITORTIMERCALLBACKFUNC) Wait->Function) 
                                ( Wait->Context, AsyncCallback->TimerCondition ) ;

        if ( InterlockedDecrement( &Wait->RefCount ) == 0 ) {

            RtlpDeleteWait( Wait ) ;            
        }

    }

    // callback queued by TimerThread
    
    else {

        PRTLP_TIMER Timer = AsyncCallback->Timer ;

        //DPRN5
        if (DPRN4)
        DbgPrint("Calling WaitOrTimer:Timer: fn:%x  context:%x  bool:%d Thread<%d:%d>\n",
                (ULONG_PTR)Timer->Function, (ULONG_PTR)Timer->Context,
                TRUE,
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)
                ) ;

        #if (DBG1)
        DBG_SET_FUNCTION( Timer->Function, Timer->Context ) ;
        #endif
  

        ((WAITORTIMERCALLBACKFUNC) Timer->Function) ( Timer->Context , TRUE) ;


        // decrement RefCount after function is executed so that the context is not deleted
        
        if ( InterlockedDecrement( &Timer->RefCount ) == 0 ) {
        
            RtlpDeleteTimer( Timer ) ;            
        }
    }

    
    RtlpFreeTPHeap( AsyncCallback );

}


VOID
RtlpProcessWaitCompletion (
    PRTLP_WAIT Wait,
    ULONG ArrayIndex
    )
/*++

Routine Description:

    This routine is used for processing a completed wait

Arguments:

    Wait - Wait that completed

Return Value:

--*/
{
    ULONG TimeRemaining ;
    ULONG NewFiringTime ;
    LARGE_INTEGER DueTime ;
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB ;
    PRTLP_ASYNC_CALLBACK AsyncCallback ;

    ThreadCB = Wait->ThreadCB ;

    // deactivate wait if it is meant for single execution
    
    if ( Wait->Flags & WT_EXECUTEONLYONCE ) {

        RtlpDeactivateWait (Wait) ;
    } 

    else {
        // if wait being reactivated, then reset the timer now itself as
        // it can be deleted in the callback function

        if  ( Wait->Timer ) {

            TimeRemaining = RtlpGetTimeRemaining (ThreadCB->TimerHandle) ;

            if (RtlpReOrderDeltaList (
                        &ThreadCB->TimerQueue.TimerList,
                        Wait->Timer,
                        TimeRemaining,
                        &NewFiringTime,
                        Wait->Timer->Period)) {

                // There is a new element at the head of the queue we need to reset the NT
                // timer to fire later

                RtlpResetTimer (ThreadCB->TimerHandle, NewFiringTime, ThreadCB) ;
            }

        }

        // move the wait entry to the end, and shift elements to its right one pos towards left
        {
            HANDLE HandlePtr = ThreadCB->ActiveWaitArray[ArrayIndex];
            PRTLP_WAIT WaitPtr = ThreadCB->ActiveWaitPointers[ArrayIndex];

            RtlpShiftWaitArray(ThreadCB, ArrayIndex+1, ArrayIndex,
                            ThreadCB->NumActiveWaits -1 - ArrayIndex)
            ThreadCB->ActiveWaitArray[ThreadCB->NumActiveWaits-1] = HandlePtr ;
            ThreadCB->ActiveWaitPointers[ThreadCB->NumActiveWaits-1] = WaitPtr ;
        }
    }
    
    // call callback function (FALSE since this isnt a timeout related callback)

    if ( Wait->Flags & WT_EXECUTEINWAITTHREAD ) {
    
        // executing callback after RtlpDeactivateWait allows the Callback to call
        // RtlDeregisterWait Wait->RefCount is not incremented so that RtlDeregisterWait 
        // will work on this Wait. Though Wait->RefCount is not incremented, others cannot
        // deregister this Wait as it has to be queued as an APC.

        if (DPRN4)
        DbgPrint("Calling WaitOrTimer(wait): fn:%x  context:%x  bool:%d Thread<%d:%d>\n",
                (ULONG_PTR)Wait->Function, (ULONG_PTR)Wait->Context,
                FALSE,
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)
                ) ;
                
        #if (DBG1)
        DBG_SET_FUNCTION( Wait->Function, Wait->Context ) ;
        #endif
        
        
        ((WAITORTIMERCALLBACKFUNC)(Wait->Function))(Wait->Context, FALSE) ;


        // Wait object could have been deleted in the above callback
        
        return ;

        
    } else {

        AsyncCallback = RtlpForceAllocateTPHeap( sizeof( RTLP_ASYNC_CALLBACK ), 0 );
        
        if ( AsyncCallback ) {
        
            AsyncCallback->Wait = Wait ;
            AsyncCallback->WaitThreadCallback = TRUE ;
            AsyncCallback->TimerCondition = FALSE ;

            InterlockedIncrement( &Wait->RefCount ) ;

            RtlQueueWorkItem( RtlpAsyncCallbackCompletion, AsyncCallback,
                                Wait->Flags );

        }
    }
}


VOID
RtlpAddWait (
    PRTLP_WAIT Wait
    )
/*++

Routine Description:

    This routine is used for adding waits to the wait thread. It is executed in
    an APC.

Arguments:

    Wait - The wait to add

Return Value:

--*/
{
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB = Wait->ThreadCB;


    // if the state is deleted, it implies that RtlDeregister was called in a
    // WaitThreadCallback for a Wait other than that which was fired. This is 
    // an application bug. I Assert, but also handle it.
    
    if ( Wait->State & STATE_DELETE ) {

        ASSERT(FALSE) ;

        InterlockedDecrement( &ThreadCB->NumWaits ) ;
        
        RtlpDeleteWait (Wait) ;

        return ;
    }

    
    // activate Wait
        
    ThreadCB->ActiveWaitArray [ThreadCB->NumActiveWaits] = Wait->WaitHandle ;
    ThreadCB->ActiveWaitPointers[ThreadCB->NumActiveWaits] = Wait ;
    ThreadCB->NumActiveWaits ++ ;
    Wait->State |= (STATE_REGISTERED | STATE_ACTIVE) ;
    Wait->RefCount = 1 ;


    // Fill in the wait timer

    if (Wait->Timeout != INFINITE_TIME) {

        ULONG TimeRemaining ;
        ULONG NewFiringTime ;

        // Initialize timer related fields and insert the timer in the timer queue for
        // this wait thread

        Wait->Timer = (PRTLP_TIMER) RemoveHeadList(&ThreadCB->FreeTimerBlocks);
        Wait->Timer->Function = Wait->Function ;
        Wait->Timer->Context = Wait->Context ;
        Wait->Timer->Flags = Wait->Flags ;
        Wait->Timer->DeltaFiringTime = Wait->Timeout ;
        Wait->Timer->Period = ( Wait->Flags & WT_EXECUTEONLYONCE )
                                ? 0 
                                : Wait->Timeout == INFINITE_TIME
                                ? 0 : Wait->Timeout ;

        Wait->Timer->State = ( STATE_REGISTERED | STATE_ACTIVE ) ; ;
        Wait->Timer->Wait = Wait ;
        Wait->Timer->RefCountPtr = &Wait->RefCount ;
        Wait->Timer->Queue = &ThreadCB->TimerQueue ;

        
        TimeRemaining = RtlpGetTimeRemaining (ThreadCB->TimerHandle) ;

        if (RtlpInsertInDeltaList (&ThreadCB->TimerQueue.TimerList, Wait->Timer,
                                    TimeRemaining, &NewFiringTime)) 
        {
            // If the element was inserted at head of list then reset the timers

            RtlpResetTimer (ThreadCB->TimerHandle, NewFiringTime, ThreadCB) ;
        }

    } else {

        // No timer with this wait

        Wait->Timer = NULL ;

    }

    return ;
}


NTSTATUS
RtlpDeregisterWait (
    PRTLP_WAIT Wait,
    HANDLE PartialCompletionEvent,
    PULONG RetStatusPtr
    )
/*++

Routine Description:

    This routine is used for deregistering the specified wait.

Arguments:

    Wait - The wait to deregister

Return Value:

--*/
{
    ULONG Status = STATUS_SUCCESS ;
    ULONG DontUse ;
    PULONG RetStatus = RetStatusPtr ? RetStatusPtr : &DontUse;
    
    CHECK_SIGNATURE(Wait) ;

    
    // RtlpDeregisterWait can be called on a wait that has not yet been
    // registered. This indicates that someone calls a RtlDeregisterWait
    // inside a WaitThreadCallback for a Wait other than that was fired.
    // Application bug!! I assert but handle it
    
    if ( ! (Wait->State & STATE_REGISTERED) ) {

        // set state to deleted, so that it does not get registered
        
        Wait->State |= STATE_DELETE ;
        
        InterlockedDecrement( &Wait->RefCount ) ;

        if ( PartialCompletionEvent ) {
        
            NtSetEvent( PartialCompletionEvent, NULL ) ;
        }

        *RetStatus = STATUS_SUCCESS ;
        return STATUS_SUCCESS ;
    }


    // deactivate wait.
    
    if ( Wait->State & STATE_ACTIVE ) {

        if ( ! NT_SUCCESS( RtlpDeactivateWait ( Wait ) ) ) {

            *RetStatus = STATUS_NOT_FOUND ;
            return STATUS_NOT_FOUND ;
        }
    }

    // delete wait if RefCount == 0

    Wait->State |= STATE_DELETE ;
    
    if ( InterlockedDecrement (&Wait->RefCount) == 0 ) {

        RtlpDeleteWait ( Wait ) ;

        Status = *RetStatus = STATUS_SUCCESS ;

    } else {

        Status = *RetStatus = STATUS_PENDING ;
    }

    if ( PartialCompletionEvent ) {
    
        NtSetEvent( PartialCompletionEvent, NULL ) ;
    }

        
    return Status ;
}


NTSTATUS
RtlpDeactivateWait (
    PRTLP_WAIT Wait
    )
/*++

Routine Description:

    This routine is used for deactivating the specified wait. It is executed in a APC.

Arguments:

    Wait - The wait to deactivate

Return Value:

--*/
{
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB = Wait->ThreadCB ;
    ULONG ArrayIndex ; //Index in ActiveWaitArray where the Wait object is placed
    ULONG EndIndex = ThreadCB->NumActiveWaits -1;

    // get the index in ActiveWaitArray
    
    for (ArrayIndex = 0;  ArrayIndex <= EndIndex; ArrayIndex++) {

        if (ThreadCB->ActiveWaitPointers[ArrayIndex] == Wait)
            break ;
    }

    if ( ArrayIndex > EndIndex ) {
    
        ASSERT (FALSE) ;
        return STATUS_NOT_FOUND;
    }


    // Move the remaining ActiveWaitArray left.

    RtlpShiftWaitArray( ThreadCB, ArrayIndex+1, ArrayIndex,
                    EndIndex - ArrayIndex ) ;


    //
    // delete timer if associated with this wait
    //
    // Though timer is being "freed" here, if it is in the timersToBeFired
    // list, some of its fields will be used later
    //
    
    if ( Wait->Timer ) {
    
        ULONG TimeRemaining ;
        ULONG NewFiringTime ;

        if (! (Wait->Timer->State & STATE_ACTIVE) ) {
        
            RemoveEntryList( &Wait->Timer->List ) ;

        } else {

            TimeRemaining = RtlpGetTimeRemaining (ThreadCB->TimerHandle) ;
            
            
            if (RtlpRemoveFromDeltaList (&ThreadCB->TimerQueue.TimerList, Wait->Timer, 
                                            TimeRemaining, &NewFiringTime)) 
            {

                RtlpResetTimer (ThreadCB->TimerHandle, NewFiringTime, ThreadCB) ;
            }
        }

        
        InsertTailList (&ThreadCB->FreeTimerBlocks, &Wait->Timer->List) ;

        Wait->Timer = NULL ;
    }

    // Decrement the (active) wait count

    ThreadCB->NumActiveWaits-- ;
    InterlockedDecrement( &ThreadCB->NumWaits ) ;
    
    Wait->State &= ~STATE_ACTIVE ;

    return STATUS_SUCCESS;

}


VOID
RtlpDeleteWait (
    PRTLP_WAIT Wait
    )
/*++

Routine Description:

    This routine is used for deleting the specified wait. It can be executed
    outside the context of the wait thread. So structure except the WaitEntry
    can be changed. It also sets the event.

Arguments:

    Wait - The wait to delete

Return Value:

--*/
{
    CHECK_SIGNATURE( Wait ) ;
    CLEAR_SIGNATURE( Wait ) ;

    #if DBG1
    if (DPRN1)
    DbgPrint("<%d> Wait %x deleted in thread:%d\n\n", Wait->DbgId, 
            (ULONG_PTR)Wait,
            HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread)) ;
    #endif

    
    if ( Wait->CompletionEvent ) {

        NtSetEvent( Wait->CompletionEvent, NULL ) ;
    }

    RtlpFreeTPHeap( Wait) ;

    return ;
}




VOID
RtlpDoNothing (
    PVOID NotUsed1,
    PVOID NotUsed2,
    PVOID NotUsed3
    )
/*++

Routine Description:

    This routine is used to see if the thread is alive

Arguments:

    NotUsed1, NotUsed2 and NotUsed 3 - not used

Return Value:

    None

--*/
{

}


__inline
LONGLONG
RtlpGet64BitTickCount(
    LARGE_INTEGER *Last64BitTickCount
    )
/*++

Routine Description:

    This routine is used for getting the latest 64bit tick count.

Arguments:

Return Value: 64bit tick count

Remarks: This call should be made only in the timer thread. if you want to
    call it from other places, you will have to lock it (see impl. in igmpv2.dll)

--*/
{
    LARGE_INTEGER liCurTime ;

    liCurTime.QuadPart = NtGetTickCount() + Last64BitTickCount->HighPart ;

    // see if timer has wrapped.

    if (liCurTime.LowPart < Last64BitTickCount->LowPart) {
        liCurTime.HighPart++ ;
    }

    return (Last64BitTickCount->QuadPart = liCurTime.QuadPart) ;
}

__inline
LONGLONG
RtlpResync64BitTickCount(
    )
/*++

Routine Description:

    This routine is used for getting the latest 64bit tick count.

Arguments:

Return Value: 64bit tick count

Remarks: This call should be made in the first line of any APC queued
    to the timer thread and nowhere else. It is used to reduce the drift

--*/
{
    return Resync64BitTickCount.QuadPart = 
                    RtlpGet64BitTickCount(&Last64BitTickCount);
}


VOID
RtlpProcessTimeouts (
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB
    )
/*++

Routine Description:

    This routine processes timeouts for the wait thread

Arguments:

    ThreadCB - The wait thread to add the wait to

Return Value:

--*/
{
    ULONG NewFiringTime, TimeRemaining ;
    LIST_ENTRY TimersToFireList ;

    //
    // check if incorrect timer fired
    //
    if (ThreadCB->Firing64BitTickCount >
            RtlpGet64BitTickCount(&ThreadCB->Current64BitTickCount) + 200 )
    {
        RtlpResetTimer (ThreadCB->TimerHandle, 
                    RtlpGetTimeRemaining (ThreadCB->TimerHandle),
                    ThreadCB) ;

        return ;
    }
 
    InitializeListHead( &TimersToFireList ) ;

    
    // Walk thru the timer list and fire all waits with DeltaFiringTime == 0

    RtlpFireTimersAndReorder (&ThreadCB->TimerQueue, &NewFiringTime, &TimersToFireList) ;

    // Reset the NT timer

    RtlpResetTimer (ThreadCB->TimerHandle, NewFiringTime, ThreadCB) ;


    RtlpFireTimers( &TimersToFireList ) ;    
}


VOID
RtlpFireTimers (
    PLIST_ENTRY TimersToFireList
    )
/*++

Routine Description:

    Finally all the timers are fired here.

Arguments:

    TimersToFireList: List of timers to fire

--*/

{
    PLIST_ENTRY Node ;
    PRTLP_TIMER Timer ;
    
    for (Node = TimersToFireList->Flink;  Node != TimersToFireList; Node = TimersToFireList->Flink)
    {
        Timer = CONTAINING_RECORD (Node, RTLP_TIMER, TimersToFireList) ;

        RemoveEntryList( Node ) ;
        InitializeListHead( Node ) ;

        
        if ( (Timer->State & STATE_DONTFIRE) 
            || (Timer->Queue->State & STATE_DONTFIRE) )
        {
            ;

        } else if ( Timer->Flags & (WT_EXECUTEINTIMERTHREAD | WT_EXECUTEINWAITTHREAD ) ) {

            //DPRN5
            if (DPRN4)
            DbgPrint("Calling WaitOrTimer(Timer): fn:%x  context:%x  bool:%d Thread<%d:%d>\n",
                (ULONG_PTR)Timer->Function, (ULONG_PTR)Timer->Context,
                TRUE,
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess)
                ) ;

            #if (DBG1)
            DBG_SET_FUNCTION( Timer->Function, Timer->Context ) ;
            #endif
        

            ((WAITORTIMERCALLBACKFUNC) Timer->Function) (Timer->Context, TRUE) ;

            
        } else {

            // create context for Callback and queue it appropriately
            
            PRTLP_ASYNC_CALLBACK  AsyncCallback ;
            
            AsyncCallback = RtlpForceAllocateTPHeap(
                                    sizeof( RTLP_ASYNC_CALLBACK ), 
                                    0 );
            AsyncCallback->TimerCondition = TRUE ;

            // timer associated with WaitEvents should be treated differently
            
            if ( Timer->Wait != NULL ) {

                AsyncCallback->Wait = Timer->Wait ;
                AsyncCallback->WaitThreadCallback = TRUE ;
                
                InterlockedIncrement( Timer->RefCountPtr ) ;

            } else {

                AsyncCallback->Timer = Timer ;
                AsyncCallback->WaitThreadCallback = FALSE ;

                InterlockedIncrement( &Timer->RefCount ) ;
            }

            RtlQueueWorkItem( RtlpAsyncCallbackCompletion, AsyncCallback, 
                                Timer->Flags );

        }

        
    }
}


NTSTATUS
RtlpFindWaitThread (
    PRTLP_WAIT_THREAD_CONTROL_BLOCK *ThreadCB
)
/*++

Routine Description:

    Walks thru the list of wait threads and finds one which can accomodate another wait.
    If one is not found then a new thread is created.

    This routine assumes that the caller has the GlobalWaitLock.

Arguments:

    ThreadCB: returns the ThreadCB of the wait thread that will service the wait request.

Return Value:

    STATUS_SUCCESS if a wait thread was allocated,

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY Node ;
    HANDLE ThreadHandle ;

    ACQUIRE_GLOBAL_WAIT_LOCK() ;

    do {

        // Walk thru the list of Wait Threads and find a Wait thread that can accomodate a
        // new wait request.

        // *Consider* finding a wait thread with least # of waits to facilitate better
        // load balancing of waits.


        for (Node = WaitThreads.Flink ; Node != &WaitThreads ; Node = Node->Flink) {

            *ThreadCB = CONTAINING_RECORD (Node, RTLP_WAIT_THREAD_CONTROL_BLOCK, 
                                            WaitThreadsList) ;


            // Wait Threads can accomodate upto 64 waits (NtWaitForMultipleObject limit)

            if ((*ThreadCB)->NumWaits < 64) {

                // Found a thread with some wait slots available.

                InterlockedIncrement ( &(*ThreadCB)->NumWaits) ;

                RELEASE_GLOBAL_WAIT_LOCK() ;
                
                return STATUS_SUCCESS ;
            }

        }


        // If we reach here, we dont have any more wait threads. so create a new wait thread.

        Status = RtlpStartThreadFunc (RtlpWaitThread, &ThreadHandle) ;


        // If thread creation fails then return the failure to caller

        if (Status != STATUS_SUCCESS ) {

            #if DBG
            DbgPrint("ERROR!! ThreadPool: could not create wait thread\n");
            #endif

            RELEASE_GLOBAL_WAIT_LOCK() ;
            
            return Status ;

        } else {

            // Close Thread handle, we dont need it.

            NtClose (ThreadHandle) ;
        }

        // Loop back now that we have created another thread

    } while (TRUE) ;    // Loop back to top and put new wait request in the newly created thread

    RELEASE_GLOBAL_WAIT_LOCK() ;
    
    return Status ;
}



// Timer Functions



VOID
RtlpAddTimer (
    PRTLP_TIMER Timer
    )
/*++

Routine Description:

    This routine runs as an APC into the Timer thread. It adds a new timer to the
    specified queue.

Arguments:

    Timer - Pointer to the timer to add

Return Value:


--*/
{
    PRTLP_TIMER_QUEUE Queue ;
    ULONG TimeRemaining, QueueRelTimeRemaining ;
    ULONG NewFiringTime ;

    RtlpResync64BitTickCount() ;

    
    // the timer was set to be deleted in a callback function.
    
    if (Timer->State & STATE_DELETE ) {
    
        RtlpDeleteTimer( Timer ) ;
        return ;
    }

    
    Queue = Timer->Queue ;

    
    // TimeRemaining is the time left in the current timer + the relative time of
    // the queue it is being inserted into

    TimeRemaining = RtlpGetTimeRemaining (TimerHandle) ;
    QueueRelTimeRemaining = TimeRemaining + RtlpGetQueueRelativeTime (Queue) ;


    if (RtlpInsertInDeltaList (&Queue->TimerList, Timer, QueueRelTimeRemaining, 
                                &NewFiringTime)) 
    {

        // If the Queue is not attached to TimerQueues since it had no timers 
        // previously then insert the queue into the TimerQueues list, else just 
        // reorder its existing position.

        if (IsListEmpty (&Queue->List)) {

            Queue->DeltaFiringTime = NewFiringTime ;

            if (RtlpInsertInDeltaList (&TimerQueues, Queue, TimeRemaining, 
                                        &NewFiringTime)) 
            {

                // There is a new element at the head of the queue we need to reset the NT
                // timer to fire sooner.

                RtlpResetTimer (TimerHandle, NewFiringTime, NULL) ;
            }

        } else {

            // If we insert at the head of the timer delta list we will need to
            // make sure the queue delta list is readjusted

            if (RtlpReOrderDeltaList(&TimerQueues, Queue, TimeRemaining, &NewFiringTime, NewFiringTime)){

                // There is a new element at the head of the queue we need to reset the NT
                // timer to fire sooner.

                RtlpResetTimer (TimerHandle, NewFiringTime, NULL) ;

            }
        }

    }

    Timer->State |= ( STATE_REGISTERED | STATE_ACTIVE ) ;
}



VOID
RtlpUpdateTimer (
    PRTLP_TIMER Timer,
    PRTLP_TIMER UpdatedTimer
    )
/*++

Routine Description:

    This routine executes in an APC and updates the specified timer if it exists

Arguments:

    Timer - Timer that is actually updated
    UpdatedTimer - Specifies pointer to a timer structure that contains Queue and
                Timer information

Return Value:


--*/
{
    PRTLP_TIMER_QUEUE Queue ;
    ULONG TimeRemaining, QueueRelTimeRemaining ;
    ULONG NewFiringTime ;


    RtlpResync64BitTickCount( ) ;

    CHECK_SIGNATURE(Timer) ;

    Queue = Timer->Queue ;

    // Update the periodic time on the timer

    Timer->Period = UpdatedTimer->Period ;


    // if timer is not in active state, then dont update it
    
    if ( ! ( Timer->State & STATE_ACTIVE ) ) {

        return ;
    }
        
    // Get the time remaining on the NT timer

    TimeRemaining = RtlpGetTimeRemaining (TimerHandle) ;
    QueueRelTimeRemaining = TimeRemaining + RtlpGetQueueRelativeTime (Queue) ;


    // Update the timer based on the due time
    
    if (RtlpReOrderDeltaList (&Queue->TimerList, Timer, QueueRelTimeRemaining, 
                                &NewFiringTime, 
                                UpdatedTimer->DeltaFiringTime)) 
    {

        // If this update caused the timer at the head of the queue to change, then reinsert
        // this queue in the list of queues.

        if (RtlpReOrderDeltaList (&TimerQueues, Queue, TimeRemaining, &NewFiringTime, NewFiringTime)) {

            // NT timer needs to be updated since the change caused the queue at the head of
            // the TimerQueues to change.

            RtlpResetTimer (TimerHandle, NewFiringTime, NULL) ;

        }

    }

    RtlpFreeTPHeap( UpdatedTimer ) ;
}


VOID
RtlpCancelTimer (
    PRTLP_TIMER Timer
    )
/*++

Routine Description:

    This routine executes in an APC and cancels the specified timer if it exists

Arguments:

    Timer - Specifies pointer to a timer structure that contains Queue and Timer information

Return Value:


--*/
{
    RtlpCancelTimerEx( Timer, FALSE ) ; // queue not being deleted
}

VOID
RtlpCancelTimerEx (
    PRTLP_TIMER Timer,
    BOOLEAN DeletingQueue
    )
/*++

Routine Description:

    This routine cancels the specified timer.

Arguments:

    Timer - Specifies pointer to a timer structure that contains Queue and Timer information
    DeletingQueue - FALSE: routine executing in an APC. Delete timer only.
                    TRUE : routine called by timer queue which is being deleted. So dont
                            reset the queue's position
Return Value:


--*/
{
    PRTLP_TIMER_QUEUE Queue ;
    NTSTATUS Status = STATUS_SUCCESS ;

    RtlpResync64BitTickCount() ;
    CHECK_SIGNATURE( Timer ) ;
    
    Queue = Timer->Queue ;


    if ( Timer->State & STATE_ACTIVE ) {

        // if queue is being deleted, then the timer should not be reset
        
        if ( ! DeletingQueue )
            RtlpDeactivateTimer( Queue, Timer ) ;
        
    } else {

        // remove one shot Inactive timer from Queue->UncancelledTimerList
        // called only when the time queue is being deleted
        
        RemoveEntryList( &Timer->List ) ;

    }

    
    // Set the State to deleted
    
    Timer->State |= STATE_DELETE ;


    // delete timer if refcount == 0
    
    if ( InterlockedDecrement( &Timer->RefCount ) == 0 ) {
    
        RtlpDeleteTimer( Timer ) ;
    }
}

VOID
RtlpDeactivateTimer (
    PRTLP_TIMER_QUEUE Queue,
    PRTLP_TIMER Timer
    )
/*++

Routine Description:

    This routine executes in an APC and cancels the specified timer if it exists

Arguments:

    Timer - Specifies pointer to a timer structure that contains Queue and Timer information

Return Value:


--*/
{
    ULONG TimeRemaining, QueueRelTimeRemaining ;
    ULONG NewFiringTime ;

    
    // Remove the timer from the appropriate queue

    TimeRemaining = RtlpGetTimeRemaining (TimerHandle) ;
    QueueRelTimeRemaining = TimeRemaining + RtlpGetQueueRelativeTime (Queue) ;

    if (RtlpRemoveFromDeltaList (&Queue->TimerList, Timer, QueueRelTimeRemaining, &NewFiringTime)) {

        // If we removed the last timer from the queue then we should remove the queue
        // from TimerQueues, else we should readjust its position based on the delta time change

        if (IsListEmpty (&Queue->TimerList)) {

            // Remove the queue from TimerQueues

            if (RtlpRemoveFromDeltaList (&TimerQueues, Queue, TimeRemaining, &NewFiringTime)) {

                // There is a new element at the head of the queue we need to reset the NT
                // timer to fire later

                RtlpResetTimer (TimerHandle, NewFiringTime, NULL) ;

            }

            InitializeListHead (&Queue->List) ;

        } else {

            // If we remove from the head of the timer delta list we will need to
            // make sure the queue delta list is readjusted

            if (RtlpReOrderDeltaList (&TimerQueues, Queue, TimeRemaining, &NewFiringTime, NewFiringTime)) {

                // There is a new element at the head of the queue we need to reset the NT
                // timer to fire later

                RtlpResetTimer (TimerHandle, NewFiringTime, NULL) ;

            }

        }

    }
}


VOID
RtlpDeleteTimer (
    PRTLP_TIMER Timer
    )
/*++

Routine Description:

    This routine executes in worker or timer thread and deletes the timer 
    whose RefCount == 0. The function can be called outside timer thread,
    so no structure outside Timer can be touched (no list etc).

Arguments:

    Timer - Specifies pointer to a timer structure that contains Queue and Timer information

Return Value:


--*/
{
    PRTLP_TIMER_QUEUE Queue = Timer->Queue ;

    CHECK_SIGNATURE( Timer ) ;
    CLEAR_SIGNATURE( Timer ) ;

    #if DBG1
    if (DPRN1)
    DbgPrint("<%d> Timer: %x: deleted\n\n", Timer->Queue->DbgId, 
            (ULONG_PTR)Timer) ;
    #endif

    // safe to call this. Either the timer is in the TimersToFireList and
    // the function is being called in time context or else it is not in the
    // list

    RemoveEntryList( &Timer->TimersToFireList ) ;

    if ( Timer->CompletionEvent )
        NtSetEvent( Timer->CompletionEvent, NULL ) ;


    // decrement the total number of timers in the queue
    
    if ( InterlockedDecrement( &Queue->RefCount ) == 0 )

        RtlpDeleteTimerQueueComplete( Queue ) ;
        

    RtlpFreeTPHeap( Timer ) ;

}



ULONG
RtlpGetQueueRelativeTime (
    PRTLP_TIMER_QUEUE Queue
    )
/*++

Routine Description:

    Walks the list of queues and returns the relative firing time by adding all the
    DeltaFiringTimes for all queues before it.

Arguments:

    Queue - Queue for which to find the relative firing time

Return Value:

    Time in milliseconds

--*/
{
    PLIST_ENTRY Node ;
    ULONG RelativeTime ;
    PRTLP_TIMER_QUEUE CurrentQueue ;

    RelativeTime = 0 ;

    // It the Queue is not attached to TimerQueues List because it has no timer
    // associated with it simply returns 0 as the relative time. Else run thru
    // all queues before it in the list and compute the relative firing time

    if (!IsListEmpty (&Queue->List)) {

        for (Node = TimerQueues.Flink; Node != &Queue->List; Node=Node->Flink) {

            CurrentQueue = CONTAINING_RECORD (Node, RTLP_TIMER_QUEUE, List) ;

            RelativeTime += CurrentQueue->DeltaFiringTime ;

        }

        // Add the queue's delta firing time as well

        RelativeTime += Queue->DeltaFiringTime ;
        
    }

    return RelativeTime ;

}


ULONG
RtlpGetTimeRemaining (
    HANDLE TimerHandle
    )
/*++

Routine Description:

    Gets the time remaining on the specified NT timer

Arguments:

    TimerHandle - Handle to the NT timer

Return Value:

    Time remaining on the timer

--*/
{
    ULONG InfoLen ;
    TIMER_BASIC_INFORMATION Info ;

    NTSTATUS Status ;

    Status = NtQueryTimer (TimerHandle, TimerBasicInformation, &Info, sizeof(Info), &InfoLen) ;

    ASSERT (Status == STATUS_SUCCESS) ;

    // Return 0 if
    //
    // - the timer has already fired then return
    //   OR
    // - the timer is has more than 0x7f0000000 in its high part
    //   (which indicates that the timer was (probably) programmed for -1)

    
    if (Info.TimerState || ((ULONG)Info.RemainingTime.HighPart > 0x7f000000) ) {

        return 0 ;

    } else {

        return (ULONG) (Info.RemainingTime.QuadPart / 10000) ;

    }

}



VOID
RtlpResetTimer (
    HANDLE TimerHandle,
    ULONG DueTime,
    PRTLP_WAIT_THREAD_CONTROL_BLOCK ThreadCB
    )
/*++

Routine Description:

    This routine resets the timer object with the new due time.

Arguments:

    TimerHandle - Handle to the timer object

    DueTime - Relative timer due time in Milliseconds

Return Value:

--*/
{
    LARGE_INTEGER LongDueTime ;

    NtCancelTimer (TimerHandle, NULL) ;

    // If the DueTime is INFINITE_TIME then set the timer to the largest integer possible

    if (DueTime == INFINITE_TIME) {

        LongDueTime.LowPart = 0x0 ;

        LongDueTime.HighPart = 0x80000000 ;

    } else {

        //
        // set the absolute time when timer is to be fired
        //
        
        if (ThreadCB) {
        
            ThreadCB->Firing64BitTickCount = DueTime 
                                + RtlpGet64BitTickCount(&ThreadCB->Current64BitTickCount) ;

        } else {
            //
            // adjust for drift only if it is a global timer
            //
        
            ULONG Drift ;
            LONGLONG llCurrentTick ;
            
            llCurrentTick = RtlpGet64BitTickCount(&Last64BitTickCount) ;
            
            Drift = (ULONG) (llCurrentTick - RtlpGetResync64BitTickCount()) ;
            DueTime = (DueTime > Drift) ? DueTime-Drift : 1 ;
            RtlpSetFiring64BitTickCount(llCurrentTick + DueTime) ;
        }

        
        LongDueTime.QuadPart = Int32x32To64( DueTime, -10000 );

    }
    

    NtSetTimer (
        TimerHandle,
        &LongDueTime,
        ThreadCB ? NULL : RtlpServiceTimer,
        NULL,
        FALSE,
        0,
        NULL
        ) ;
}


BOOLEAN
RtlpInsertInDeltaList (
    PLIST_ENTRY DeltaList,
    PRTLP_GENERIC_TIMER NewTimer,
    ULONG TimeRemaining,
    ULONG *NewFiringTime
    )
/*++

Routine Description:

    Inserts the timer element in the appropriate place in the delta list.

Arguments:

    DeltaList - Delta list to insert into

    NewTimer - Timer element to insert into list

    TimeRemaining - This time must be added to the head of the list to get "real"
                    relative time.

    NewFiringTime - If the new element was inserted at the head of the list - this
                    will contain the new firing time in milliseconds. The caller
                    can use this time to re-program the NT timer. This MUST NOT be
                    changed if the function returns FALSE.

Return Value:

    TRUE - If the timer was inserted at head of delta list

    FALSE - otherwise

--*/
{
    PLIST_ENTRY Node ;
    PRTLP_GENERIC_TIMER Temp ;
    PRTLP_GENERIC_TIMER Head ;

    if (IsListEmpty (DeltaList)) {

        InsertHeadList (DeltaList, &NewTimer->List) ;

        *NewFiringTime = NewTimer->DeltaFiringTime ;
        
        NewTimer->DeltaFiringTime = 0 ;

        return TRUE ;

    }

    // Adjust the head of the list to reflect the time remaining on the NT timer

    Head = CONTAINING_RECORD (DeltaList->Flink, RTLP_GENERIC_TIMER, List) ;

    Head->DeltaFiringTime += TimeRemaining ;


    // Find the appropriate location to insert this element in

    for (Node = DeltaList->Flink ; Node != DeltaList ; Node = Node->Flink) {

        Temp = CONTAINING_RECORD (Node, RTLP_GENERIC_TIMER, List) ;


        if (Temp->DeltaFiringTime <= NewTimer->DeltaFiringTime) {

            NewTimer->DeltaFiringTime -= Temp->DeltaFiringTime ;

        } else {

            // found appropriate place to insert this timer

            break ;

        }

    }

    // Either we have found the appopriate node to insert before in terms of deltas.
    // OR we have come to the end of the list. Insert this timer here.

    InsertHeadList (Node->Blink, &NewTimer->List) ;


    // If this isnt the last element in the list - adjust the delta of the
    // next element

    if (Node != DeltaList) {

        Temp->DeltaFiringTime -= NewTimer->DeltaFiringTime ;

    }


    // Check if element was inserted at head of list

    if (DeltaList->Flink == &NewTimer->List) {

        // Set NewFiringTime to the time in milliseconds when the new head of list
        // should be serviced.

        *NewFiringTime = NewTimer->DeltaFiringTime ;

        // This means the timer must be programmed to service this request

        NewTimer->DeltaFiringTime = 0 ;

        return TRUE ;

    } else {

        // No change to the head of the list, set the delta time back

        Head->DeltaFiringTime -= TimeRemaining ;

        return FALSE ;

    }

}



BOOLEAN
RtlpRemoveFromDeltaList (
    PLIST_ENTRY DeltaList,
    PRTLP_GENERIC_TIMER Timer,
    ULONG TimeRemaining,
    ULONG* NewFiringTime
    )
/*++

Routine Description:

    Removes the specified timer from the delta list

Arguments:

    DeltaList - Delta list to insert into

    Timer - Timer element to insert into list

    TimerHandle - Handle of the NT Timer object

    TimeRemaining - This time must be added to the head of the list to get "real"
                    relative time.

Return Value:

    TRUE if the timer was removed from head of timer list
    FALSE otherwise

--*/
{
    PLIST_ENTRY Next ;
    PRTLP_GENERIC_TIMER Temp ;

    Next = Timer->List.Flink ;

    RemoveEntryList (&Timer->List) ;

    if (IsListEmpty (DeltaList)) {

        *NewFiringTime = INFINITE_TIME ;

        return TRUE ;

    }

    if (Next == DeltaList)  {

        // If we removed the last element in the list nothing to do either

        return FALSE ;

    } else {

        Temp = CONTAINING_RECORD ( Next, RTLP_GENERIC_TIMER, List) ;

        Temp->DeltaFiringTime += Timer->DeltaFiringTime ;
        
        // Check if element was removed from head of list

        if (DeltaList->Flink == Next) {

            *NewFiringTime = Temp->DeltaFiringTime + TimeRemaining ;

            Temp->DeltaFiringTime = 0 ;

            return TRUE ;

        } else {

            return FALSE ;

        }

    }

}



BOOLEAN
RtlpReOrderDeltaList (
    PLIST_ENTRY DeltaList,
    PRTLP_GENERIC_TIMER Timer,
    ULONG TimeRemaining,
    ULONG *NewFiringTime,
    ULONG ChangedFiringTime
    )
/*++

Routine Description:

    Called when a timer in the delta list needs to be re-inserted because the firing time
    has changed.

Arguments:

    DeltaList - List in which to re-insert

    Timer - Timer for which the firing time has changed

    TimeRemaining - Time before the head of the delta list is fired

    NewFiringTime - If the new element was inserted at the head of the list - this
                    will contain the new firing time in milliseconds. The caller
                    can use this time to re-program the NT timer.

    ChangedFiringTime - Changed Time for the specified timer.

Return Value:

    TRUE if the timer was removed from head of timer list
    FALSE otherwise

--*/
{
    ULONG NewTimeRemaining ;
    PRTLP_GENERIC_TIMER Temp ;

    // Remove the timer from the list

    if (RtlpRemoveFromDeltaList (DeltaList, Timer, TimeRemaining, NewFiringTime)) {

        // If element was removed from the head of the list we should record that

        NewTimeRemaining = *NewFiringTime ;


    } else {

        // Element was not removed from head of delta list, the current TimeRemaining is valid

        NewTimeRemaining = TimeRemaining ;

    }

    // Before inserting Timer, set its delta time to the ChangedFiringTime

    Timer->DeltaFiringTime = ChangedFiringTime ;

    // Reinsert this element back in the list

    if (!RtlpInsertInDeltaList (DeltaList, Timer, NewTimeRemaining, NewFiringTime)) {

        // If we did not add at the head of the list, then we should return TRUE if
        // RtlpRemoveFromDeltaList() had returned TRUE. We also update the NewFiringTime to
        // the reflect the new firing time returned by RtlpRemoveFromDeltaList()

        *NewFiringTime = NewTimeRemaining ;

        return (NewTimeRemaining != TimeRemaining) ;

    } else {

        // NewFiringTime contains the time the NT timer must be programmed for

        return TRUE ;

    }

}


VOID
RtlpAddTimerQueue (
    PVOID Queue
    )
/*++

Routine Description:

    This routine runs as an APC into the Timer thread. It does whatever necessary to
    create a new timer queue

Arguments:

    Queue - Pointer to the queue to add

Return Value:


--*/
{

    // We do nothing here. The newly created queue is free floating until a timer is
    // queued onto it.

}


VOID
RtlpServiceTimer (
    PVOID NotUsedArg,
    ULONG NotUsedLowTimer,
    LONG NotUsedHighTimer
    )
/*++

Routine Description:

    Services the timer. Runs in an APC.

Arguments:

    NotUsedArg - Argument is not used in this function.

    NotUsedLowTimer - Argument is not used in this function.

    NotUsedHighTimer - Argument is not used in this function.

Return Value:

Remarks:
    This APC is called only for timeouts of timer threads.
    
--*/
{
    PRTLP_TIMER Timer ;
    PRTLP_TIMER_QUEUE Queue ;
    PLIST_ENTRY TNode ;
    PLIST_ENTRY QNode ;
    PLIST_ENTRY Temp ;
    ULONG NewFiringTime ;
    LIST_ENTRY ReinsertTimerQueueList ;
    LIST_ENTRY TimersToFireList ;

    RtlpResync64BitTickCount() ;
    
if (DPRN2) {
    DbgPrint("Before service timer ThreadId<%x:%x>\n",
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess));
    RtlDebugPrintTimes ();
}

    ACQUIRE_GLOBAL_TIMER_LOCK();

    // fire it if it even 200ms ahead. else reset the timer
    
    if (Firing64BitTickCount.QuadPart > RtlpGet64BitTickCount(&Last64BitTickCount) + 200) {

        RtlpResetTimer (TimerHandle, RtlpGetTimeRemaining (TimerHandle), NULL) ;

        RELEASE_GLOBAL_TIMER_LOCK() ;
        return ;
    }
        
    InitializeListHead (&ReinsertTimerQueueList) ;

    InitializeListHead (&TimersToFireList) ;


    // We run thru all queues with DeltaFiringTime == 0 and fire all timers that
    // have DeltaFiringTime == 0. We remove the fired timers and either free them
    // (for one shot timers) or put them in aside list (for periodic timers).
    // After we have finished firing all timers in a queue we reinsert the timers
    // in the aside list back into the queue based on their new firing times.
    //
    // Similarly, we remove each fired Queue and put it in a aside list. After firing
    // all queues with DeltaFiringTime == 0, we reinsert the Queues in the aside list
    // and reprogram the NT timer to be the firing time of the first queue in the list


    for (QNode = TimerQueues.Flink ; QNode != &TimerQueues ; QNode = QNode->Flink) {

        Queue = CONTAINING_RECORD (QNode, RTLP_TIMER_QUEUE, List) ;

        // If the delta time in the timer queue is 0 - then this queue
        // has timers that are ready to fire. Walk the list and fire all timers with
        // Delta time of 0

        if (Queue->DeltaFiringTime == 0) {

            // Walk all timers with DeltaFiringTime == 0 and fire them. After that
            // reinsert the periodic timers in the appropriate place.

            RtlpFireTimersAndReorder (Queue, &NewFiringTime, &TimersToFireList) ;

            // detach this Queue from the list

            QNode = QNode->Blink ;

            RemoveEntryList (QNode->Flink) ;

            // If there are timers in the queue then prepare to reinsert the queue in
            // TimerQueues.

            if (NewFiringTime != INFINITE_TIME) {

                Queue->DeltaFiringTime = NewFiringTime ;

                // put the timer in list that we will process after we have
                // fired all elements in this queue

                InsertHeadList (&ReinsertTimerQueueList, &Queue->List) ;

            } else {

                // Queue has no more timers in it. Let the Queue float.

                InitializeListHead (&Queue->List) ;

            }


        } else {

            // No more Queues with DeltaFiringTime == 0

            break ;

        }

    }

    // At this point we have fired all the ready timers. We have two lists that need to be
    // merged - TimerQueues and ReinsertTimerQueueList. The following steps do this - at the
    // end of this we will reprogram the NT Timer.

    if (!IsListEmpty(&TimerQueues)) {

        Queue = CONTAINING_RECORD (TimerQueues.Flink, RTLP_TIMER_QUEUE, List) ;

        NewFiringTime = Queue->DeltaFiringTime ;

        Queue->DeltaFiringTime = 0 ;

        if (!IsListEmpty (&ReinsertTimerQueueList)) {

            // TimerQueues and ReinsertTimerQueueList are both non-empty. Merge them.

            RtlpInsertTimersIntoDeltaList (&ReinsertTimerQueueList, &TimerQueues, 
                                            NewFiringTime, &NewFiringTime) ;

        }

        // NewFiringTime contains the time the NT Timer should be programmed to.

    } else {

        if (!IsListEmpty (&ReinsertTimerQueueList)) {

            // TimerQueues is empty. ReinsertTimerQueueList is not.

            RtlpInsertTimersIntoDeltaList (&ReinsertTimerQueueList, &TimerQueues, 0, 
                                            &NewFiringTime) ;

        } else {

            NewFiringTime = INFINITE_TIME ;

        }

        // NewFiringTime contains the time the NT Timer should be programmed to.

    }


    // Reset the timer to reflect the Delta time associated with the first Queue

    RtlpResetTimer (TimerHandle, NewFiringTime, NULL) ;

if (DPRN3) {
    DbgPrint("After service timer:ThreadId<%x:%x>\n",
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess));
    RtlDebugPrintTimes ();
}

    // finally fire all the timers
    
    RtlpFireTimers( &TimersToFireList ) ;

    
    RELEASE_GLOBAL_TIMER_LOCK();

}


VOID
RtlpFireTimersAndReorder (
    PRTLP_TIMER_QUEUE Queue,
    ULONG *NewFiringTime,
    PLIST_ENTRY TimersToFireList
    )
/*++

Routine Description:

    Fires all timers in TimerList that have DeltaFiringTime == 0. After firing the timers
    it reorders the timers based on their periodic times OR frees the fired one shot timers.

Arguments:

    TimerList - Timer list to work thru.

    NewFiringTime - Location where the new firing time for the first timer in the delta list
                    is returned.


Return Value:


--*/
{
    PLIST_ENTRY TNode ;
    PRTLP_TIMER Timer ;
    LIST_ENTRY ReinsertTimerList ;
    PLIST_ENTRY TimerList = &Queue->TimerList ;
    
    InitializeListHead (&ReinsertTimerList) ;
    *NewFiringTime = 0 ;
    

    for (TNode = TimerList->Flink ; (TNode != TimerList) && (*NewFiringTime == 0); 
            TNode = TimerList->Flink) 
    {

        Timer = CONTAINING_RECORD (TNode, RTLP_TIMER, List) ;

        // Fire all timers with delta time of 0

        if (Timer->DeltaFiringTime == 0) {

            // detach this timer from the list

            RemoveEntryList (TNode) ;

            // get next firing time
            
            if (!IsListEmpty(TimerList)) {

                PRTLP_TIMER TmpTimer ;

                TmpTimer = CONTAINING_RECORD (TimerList->Flink, RTLP_TIMER, List) ;

                *NewFiringTime  = TmpTimer->DeltaFiringTime ;

                TmpTimer->DeltaFiringTime = 0 ;

            } else {

                *NewFiringTime = INFINITE_TIME ;
            }


            // if timer is not periodic then remove active state. Timer will be deleted
            // when cancel timer is called.

            if (Timer->Period == 0) {

                InsertHeadList( &Queue->UncancelledTimerList, &Timer->List ) ;

                // if one shot wait was timed out then, deactivate the wait
                
                if ( Timer->Wait ) {

                    //
                    // though timer is being "freed" in this call, it can still be
                    // used after this call
                    //
                    
                    RtlpDeactivateWait( Timer->Wait ) ;
                }

                else {
                    // should be set at the end
                
                    Timer->State &= ~STATE_ACTIVE ;
                }

                Timer->State |= STATE_ONE_SHOT_FIRED ;
                
            } else {

                // Set the DeltaFiringTime to be the next period

                Timer->DeltaFiringTime = Timer->Period ;

                // reinsert the timer in the list.
                
                RtlpInsertInDeltaList (TimerList, Timer, *NewFiringTime, NewFiringTime) ;
            }


            // Call the function associated with this timer. call it in the end
            // so that RtlTimer calls can be made in the timer function

            if ( (Timer->State & STATE_DONTFIRE) 
                || (Timer->Queue->State & STATE_DONTFIRE) )
            {
                ;

            } else {

                InsertTailList( TimersToFireList, &Timer->TimersToFireList ) ;

            }

        } else {

            // No more Timers with DeltaFiringTime == 0

            break ;

        }
    }


    if ( *NewFiringTime == 0 ) {
        *NewFiringTime = INFINITE_TIME ;
    }
}


VOID
RtlpInsertTimersIntoDeltaList (
    IN PLIST_ENTRY NewTimerList,
    IN PLIST_ENTRY DeltaTimerList,
    IN ULONG TimeRemaining,
    OUT ULONG *NewFiringTime
    )
/*++

Routine Description:

    This routine walks thru a list of timers in NewTimerList and inserts them into a delta
    timers list pointed to by DeltaTimerList. The timeout associated with the first element
    in the new list is returned in NewFiringTime.

Arguments:

    NewTimerList - List of timers that need to be inserted into the DeltaTimerList

    DeltaTimerList - Existing delta list of zero or more timers.

    TimeRemaining - Firing time of the first element in the DeltaTimerList

    NewFiringTime - Location where the new firing time will be returned

Return Value:


--*/
{
    PRTLP_GENERIC_TIMER Timer ;
    PLIST_ENTRY TNode ;
    PLIST_ENTRY Temp ;

    for (TNode = NewTimerList->Flink ; TNode != NewTimerList ; TNode = TNode->Flink) {

        Temp = TNode->Blink ;

        RemoveEntryList (Temp->Flink) ;

        Timer = CONTAINING_RECORD (TNode, RTLP_GENERIC_TIMER, List) ;

        if (RtlpInsertInDeltaList (DeltaTimerList, Timer, TimeRemaining, NewFiringTime)) {

            TimeRemaining = *NewFiringTime ;

        }

        TNode = Temp ;

    }

}


LONG
RtlpTimerThread (
    PVOID  Initialized
    )
/*++

Routine Description:

    All the timer activity takes place in APCs.

Arguments:

    Initialized - Used to notify the starter of the thread that thread initialization 
    has completed

Return Value:

--*/
{
    LARGE_INTEGER TimeOut ;
    NTSTATUS Status ;

    // no structure initializations should be done here as new timer thread
    // may be created after threadPoolCleanup
    

    TimerThreadId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;


    // Reset the NT Timer to never fire initially

    RtlpResetTimer (TimerHandle, -1, NULL) ;

    // Notify starter of this thread that it has initialized

    InterlockedExchange ((ULONG *) Initialized, 1) ;

    // Sleep alertably so that all the activity can take place
    // in APCs

    for ( ; ; ) {

        // Set timeout for the largest timeout possible

        TimeOut.LowPart = 0 ;
        TimeOut.HighPart = 0x80000000 ;

        NtDelayExecution (TRUE, &TimeOut) ;

    }

    return 0 ;  // Keep compiler happy

}


NTSTATUS
RtlpInitializeTimerThreadPool (
    )
/*++

Routine Description:

    This routine is used to initialize structures used for Timer Thread

Arguments:


Return Value:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LARGE_INTEGER TimeOut ;

    // In order to avoid an explicit RtlInitialize() function to initialize the wait thread pool
    // we use StartedTimerInitialization and CompletedTimerInitialization to provide us the
    // necessary synchronization to avoid multiple threads from initializing the thread pool.
    // This scheme does not work if RtlInitializeCriticalSection() or NtCreateEvent fails - but in this case the
    // caller has not choices left.

    if (!InterlockedExchange(&StartedTimerInitialization, 1L)) {

        if (CompletedTimerInitialization)
            InterlockedExchange(&CompletedTimerInitialization, 0 ) ;

        do {

            // Initialize global timer lock

            Status = RtlInitializeCriticalSection( &TimerCriticalSection ) ;
            if (! NT_SUCCESS( Status )) {
                break ;
            }

            Status = NtCreateTimer(
                                &TimerHandle,
                                TIMER_ALL_ACCESS,
                                NULL,
                                NotificationTimer
                                ) ;

            if (!NT_SUCCESS(Status) )
                break ;
                
            InitializeListHead (&TimerQueues) ; // Initialize Timer Queue Structures


            // initialize tick count

            Resync64BitTickCount.QuadPart = NtGetTickCount()  ;
            Firing64BitTickCount.QuadPart = 0 ;

            
            Status = RtlpStartThreadFunc (RtlpTimerThread, &TimerThreadHandle) ;

            if (!NT_SUCCESS(Status) )
                break ;


        } while(FALSE ) ;

        if (!NT_SUCCESS(Status) ) {

            ASSERT (Status == STATUS_SUCCESS) ;
            
            StartedTimerInitialization = 0 ;
            InterlockedExchange (&CompletedTimerInitialization, ~0) ;
            
            return Status ;
        }
        
        InterlockedExchange (&CompletedTimerInitialization, 1L) ;

    } else {

        // Sleep 1 ms and see if the other thread has completed initialization

        ONE_MILLISECOND_TIMEOUT(TimeOut) ;

        while (!(volatile ULONG) CompletedTimerInitialization) {

            NtDelayExecution (FALSE, &TimeOut) ;

        }
        
        if (CompletedTimerInitialization != 1)
            Status = STATUS_NO_MEMORY ;
    }

    return NT_SUCCESS(Status) ? STATUS_SUCCESS : Status ;
}


NTSTATUS
RtlpDeleteTimerQueue (
    PRTLP_TIMER_QUEUE Queue
    )
/*++

Routine Description:

    This routine deletes the queue specified in the Request and frees all timers

Arguments:

    Queue - queue to delete

    Event - Event Handle used for signalling completion of request

Return Value:

--*/
{
    NTSTATUS Status;
    ULONG TimeRemaining ;
    ULONG NewFiringTime ;
    PLIST_ENTRY Node ;
    PRTLP_TIMER Timer ;

    RtlpResync64BitTickCount() ;

    
    // If there are no timers in the queue then it is not attached to TimerQueues
    // In this case simply free the memory and return. Otherwise we have to first
    // remove the queue from the TimerQueues List, update the firing time if this
    // was the first queue in the list and then walk all the timers and free them
    // before freeing the Timer Queue.

    if (!IsListEmpty (&Queue->List)) {

        TimeRemaining = RtlpGetTimeRemaining (TimerHandle) 
                        + RtlpGetQueueRelativeTime (Queue) ;

        if (RtlpRemoveFromDeltaList (&TimerQueues, Queue, TimeRemaining, 
                                    &NewFiringTime)) 
        {

            // If removed from head of queue list, reset the timer

            RtlpResetTimer (TimerHandle, NewFiringTime, NULL) ;
        }


        // Free all the timers associated with this queue

        for (Node = Queue->TimerList.Flink ; Node != &Queue->TimerList ; ) {

            Timer =  CONTAINING_RECORD (Node, RTLP_TIMER, List) ;
            
            Node = Node->Flink ;

            RtlpCancelTimerEx( Timer ,TRUE ) ; // Queue being deleted
        }
    }


    // Free all the uncancelled one shot timers in this queue

    for (Node = Queue->UncancelledTimerList.Flink ; Node != &Queue->UncancelledTimerList ; ) {

        Timer =  CONTAINING_RECORD (Node, RTLP_TIMER, List) ;
        
        Node = Node->Flink ;

        RtlpCancelTimerEx( Timer ,TRUE ) ; // Queue being deleted
    }


    // delete the queue completely if the RefCount is 0
    
    if ( InterlockedDecrement( &Queue->RefCount ) == 0 ) {
    
        RtlpDeleteTimerQueueComplete( Queue ) ;

        return STATUS_SUCCESS ;
        
    } else {
    
        return STATUS_PENDING ;
    }

}



/*++

Routine Description:

    This routine frees the queue and sets the event.

Arguments:

    Queue - queue to delete

    Event - Event Handle used for signalling completion of request

Return Value:

--*/
VOID
RtlpDeleteTimerQueueComplete (
    PRTLP_TIMER_QUEUE Queue
    )
{
    #if DBG1
    if (DPRN1)
    DbgPrint("<%d> Queue: %x: deleted\n\n", Queue->DbgId, 
            (ULONG_PTR)Queue) ;
    #endif

    InterlockedDecrement( &NumTimerQueues ) ;    

    // Notify the thread issuing the cancel that the request is completed

    if ( Queue->CompletionEvent )
        NtSetEvent (Queue->CompletionEvent, NULL) ;
    
    RtlpFreeTPHeap( Queue ) ;
}


VOID
RtlpThreadCleanup (
    )
/*++

Routine Description:

    This routine is used for exiting timer, wait and IOworker threads.

Arguments:

Return Value:

--*/
{
    NtTerminateThread( NtCurrentThread(), 0) ;
}


NTSTATUS
RtlpWaitForEvent (
    HANDLE Event,
    HANDLE ThreadHandle
    )
/*++

Routine Description:

    Waits for the event to be signalled. If the event is not signalled within
    one second, then checks to see that the thread is alive

Arguments:

    Event : Event handle used for signalling completion of request

    ThreadHandle: Thread to check whether still alive

Return Value:

    STATUS_SUCCESS if event was signalled
    else return NTSTATUS

--*/
{
    NTSTATUS Status ;
    LARGE_INTEGER TimeOut ;
    
    // Timeout of 1 second for request to complete
    ONE_SECOND_TIMEOUT(TimeOut) ;

Wait:

    Status = NtWaitForSingleObject (Event, FALSE, &TimeOut) ;
    
    if (Status == STATUS_TIMEOUT) {

        // The wait timed out. Check to see if the wait thread is still alive.
        // This is done by trying to queue a dummy APC to it. There is no better
        // way known to determine if the thread has died unexpectedly.
        // If so then go back to waiting.

        Status = NtQueueApcThread(
            ThreadHandle,
            (PPS_APC_ROUTINE)RtlpDoNothing,
            NULL,
            NULL,
            NULL
            );

        if (NT_SUCCESS(Status) ) {

            // Wait thread is still alive. Go back to waiting.

            goto Wait ;

        } else {

            // The wait thread died between the time the APC was queued and the
            // the time we started waiting on NtQueryInformationThread()


            DbgPrint ("Thread died before event could be signalled") ;

        }

    }

    return NT_SUCCESS(Status) ? STATUS_SUCCESS : Status ;
}


PRTLP_EVENT
RtlpGetWaitEvent (
    VOID
    )
/*++

Routine Description:

    Returns an event from the event cache.

Arguments:

    None

Return Value:

    Pointer to event structure

--*/
{
    NTSTATUS Status;
    PRTLP_EVENT Event ;

    if (!CompletedEventCacheInitialization) {

        RtlpInitializeEventCache () ;

    }

    RtlEnterCriticalSection (&EventCacheCriticalSection) ;

    if (!IsListEmpty (&EventCache)) {

        Event = (PRTLP_EVENT) RemoveHeadList (&EventCache) ;

    } else {

        Event = RtlpForceAllocateTPHeap( sizeof( RTLP_EVENT ), 0 );

        if (!Event) {

            RtlLeaveCriticalSection (&EventCacheCriticalSection) ;

            return NULL ;

        }

        Status = NtCreateEvent(
                    &Event->Handle,
                    EVENT_ALL_ACCESS,
                    NULL,
                    SynchronizationEvent,
                    FALSE
                    );

        if (!NT_SUCCESS(Status) ) {

            RtlpFreeTPHeap( Event ) ;

            RtlLeaveCriticalSection (&EventCacheCriticalSection) ;

            return NULL ;

        }

    }

    RtlLeaveCriticalSection (&EventCacheCriticalSection) ;

    return Event ;
}


VOID
RtlpFreeWaitEvent (
    PRTLP_EVENT Event
    )
/*++

Routine Description:

    Frees the event to the event cache

Arguments:

    Event - the event struct to put back into the cache

Return Value:

    Nothing

--*/
{

    if ( Event == NULL )
        return ;
        
    InitializeListHead (&Event->List) ;

    RtlEnterCriticalSection (&EventCacheCriticalSection) ;

    if ( NumUnusedEvents > MAX_UNUSED_EVENTS ) {

        NtClose( Event->Handle ) ;
        
        RtlpFreeTPHeap( Event ) ;

    } else {
    
        InsertHeadList (&EventCache, &Event->List) ;
        NumUnusedEvents++ ;
    }

    
    RtlLeaveCriticalSection (&EventCacheCriticalSection) ;
}



VOID
RtlpInitializeEventCache (
    VOID
    )
/*++

Routine Description:

    Initializes the event cache

Arguments:

    None

Return Value:

    Nothing

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut ;

    if (!InterlockedExchange(&StartedEventCacheInitialization, 1L)) {

        InitializeListHead (&EventCache) ;

        Status = RtlInitializeCriticalSection(&EventCacheCriticalSection) ;

        ASSERT (Status == STATUS_SUCCESS) ;

        NumUnusedEvents = 0 ;
        
        InterlockedExchange (&CompletedEventCacheInitialization, 1L) ;

    } else {

        // sleep for 1 milliseconds and see if the initialization is complete

        ONE_MILLISECOND_TIMEOUT(TimeOut) ;

        while (!(volatile ULONG) CompletedEventCacheInitialization) {

            NtDelayExecution (FALSE, &TimeOut) ;

        }

    }
}


VOID
PrintTimerQueue(PLIST_ENTRY QNode, ULONG Delta, ULONG Count
    )
{
    PLIST_ENTRY Tnode ;
    PRTLP_TIMER Timer ;
    PRTLP_TIMER_QUEUE Queue ;
    
    Queue = CONTAINING_RECORD (QNode, RTLP_TIMER_QUEUE, List) ;
    DbgPrint("<%1d> Queue: %x FiringTime:%d\n", Count, (ULONG_PTR)Queue, 
                Queue->DeltaFiringTime);
    for (Tnode=Queue->TimerList.Flink; Tnode!=&Queue->TimerList; 
            Tnode=Tnode->Flink) 
    {
        Timer = CONTAINING_RECORD (Tnode, RTLP_TIMER, List) ;
        Delta += Timer->DeltaFiringTime ;
        DbgPrint("        Timer: %x Delta:%d Period:%d\n",(ULONG_PTR)Timer,
                    Delta, Timer->Period);
    }

}

VOID
RtlDebugPrintTimes (
    )
{    
    PLIST_ENTRY QNode ;
    ULONG Count = 0 ;
    ULONG Delta = RtlpGetTimeRemaining (TimerHandle) ;
    ULONG CurrentThreadId =  
                        HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) ;

    RtlpResync64BitTickCount();

    if (CompletedTimerInitialization != 1) {

        DbgPrint("===========RtlTimerThread not yet initialized==========\n");
        return ;
    }

    if (CurrentThreadId == TimerThreadId)
    {
        PRTLP_TIMER_QUEUE Queue ;
        
        DbgPrint("================Printing timerqueues====================\n");
        DbgPrint("TimeRemaining: %d\n", Delta);
        for (QNode = TimerQueues.Flink; QNode != &TimerQueues; 
                QNode = QNode->Flink)
        {
            Queue = CONTAINING_RECORD (QNode, RTLP_TIMER_QUEUE, List) ;
            Delta += Queue->DeltaFiringTime ;
            
            PrintTimerQueue(QNode, Delta, ++Count);
            
        }
        DbgPrint("================Printed ================================\n");
    }

    else
    {
        NtQueueApcThread(
                    TimerThreadHandle,
                    (PPS_APC_ROUTINE)RtlDebugPrintTimes,
                    NULL,
                    NULL,
                    NULL
                    );
    }
}


/*DO NOT USE THIS FUNCTION: REPLACED BY RTLCREATETIMER*/

NTSTATUS
RtlSetTimer(
    IN  HANDLE TimerQueueHandle,
    OUT HANDLE *Handle,
    IN  WAITORTIMERCALLBACKFUNC Function,
    IN  PVOID Context,
    IN  ULONG  DueTime,
    IN  ULONG  Period,
    IN  ULONG  Flags
    )
{

    return RtlCreateTimer(TimerQueueHandle,
                            Handle,
                            Function,
                            Context,
                            DueTime,
                            Period,
                            Flags
                            ) ;
}


PVOID
RtlpForceAllocateTPHeap(
    ULONG dwSize,
    ULONG dwFlags
    )
/*++
Routine Description:

    This routine goes into an infinite loop trying to allocate the memory.

Arguments:

    dwSize - size of memory to be allocated

    dwFlags - Flags for memory allocation

Return Value:

    ptr to memory

--*/
{
    PVOID ptr;
    ptr = RtlpAllocateTPHeap(dwSize, dwFlags);
    if (ptr)
        return ptr;

    {
        LARGE_INTEGER TimeOut ;
        do {

            ONE_SECOND_TIMEOUT(TimeOut) ;

            NtDelayExecution (FALSE, &TimeOut) ;

            ptr = RtlpAllocateTPHeap(dwSize, dwFlags);
            if (ptr)
                break;

        } while (TRUE) ;
    }
    return ptr;
}



/*DO NOT USE THIS FUNCTION: REPLACED BY RTLDeleteTimer*/

NTSTATUS
RtlCancelTimer(
    IN HANDLE TimerQueueHandle,
    IN HANDLE TimerToCancel
    )
/*++

Routine Description:

    This routine cancels the timer. This call is non-blocking. The timer Callback
    will not be executed after this call returns.

Arguments:

    TimerQueueHandle - Handle identifying the queue from which to delete timer

    TimerToCancel - Handle identifying the timer to cancel

Return Value:

    NTSTATUS - Result code from call.  The following are returned

        STATUS_SUCCESS - Timer cancelled. All callbacks completed.
        STATUS_PENDING - Timer cancelled. Some callbacks still not completed.

--*/
{
    return RtlDeleteTimer( TimerQueueHandle, TimerToCancel, NULL ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\filter\redist\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\filter\main.cxx ===
/**
 * aspnet_isapi Main module:
 * DllMain, DllGetClassObject, etc.
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

#include "precomp.h"
#include "names.h"

DEFINE_DBG_COMPONENT(FILTER_MODULE_FULL_NAME_L);

//  Private globals
HINSTANCE g_DllInstance;

// exported globals
HANDLE    g_hXSPHeap = NULL;

HRESULT
InitDllLight()
{
    HRESULT hr = S_OK;

    DisableThreadLibraryCalls(g_DllInstance);

    g_hXSPHeap = HeapCreate(0, 0, 0);
    if (g_hXSPHeap == NULL)
        g_hXSPHeap = GetProcessHeap();

    return hr;
}

BOOL WINAPI
DllMain(HINSTANCE Instance, DWORD Reason, LPVOID)
{
    switch (Reason)
    {
    case DLL_PROCESS_ATTACH:
        g_DllInstance = Instance;
        // Don't do full initialization here, every host should call InitializeLibrary
        if (InitDllLight() != S_OK)
        {
            return FALSE;
        }
        break;

    default:
        break;
    }

    return TRUE;
}

HANDLE
GetXSPHeap()
{
    return g_hXSPHeap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\filter\debug.cxx ===
/**
 * Debug functions.
 *
 * Copyright (C) Microsoft Corporation, 1998
 */

#include "precomp.h"
#include "names.h"

//
// private definitions of debug macros so we don't reenter
//

#undef ASSERT 
#undef ASSERTMSG
#undef VERIFY
#undef TRACE
#undef TRACE1
#undef TRACE2
#undef TRACE3
#undef TRACE_ERROR
                                    
#if DBG

extern DWORD    g_dwFALSE; // global variable used to keep compiler from complaining about constant expressions.

#if defined(_M_IX86)
    #define DbgBreak() _asm { int 3 }
#else
    #define DbgBreak() DebugBreak()
#endif

#define TAG_INTERNAL L"Internal"
#define TAG_EXTERNAL L"External"
#define TAG_ALL      L"*"

#define MKSTRING2(x) #x
#define MKSTRING(x) MKSTRING2(x)

#define ASSERT(x)                                                                                                       \
    do                                                                                                                  \
    {                                                                                                                   \
        if (!((DWORD)(x)|g_dwFALSE))                                                                                    \
        {                                                                                                               \
            OutputDebugStringA(FILTER_MODULE_FULL_NAME " Dbg Assertion failure: " #x " " __FILE__ ":" MKSTRING(__LINE__) "\n");         \
            DbgBreak();                                                                                                 \
        }                                                                                                               \
    } while (g_dwFALSE)                                                                                                 \

#define ASSERTMSG(x, msg)                                                                                               \
    do                                                                                                                  \
    {                                                                                                                   \
        if (!((DWORD)(x)|g_dwFALSE))                                                                                    \
        {                                                                                                               \
            OutputDebugStringA(FILTER_MODULE_FULL_NAME " Dbg Assertion failure: " #msg " " __FILE__ ":" MKSTRING(__LINE__) "\n");       \
            DbgBreak();                                                                                                 \
        }                                                                                                               \
    } while (g_dwFALSE)                                                                                                 \

#define VERIFY(x)	ASSERT(x)

#define TRACE(tag, fmt)
#define TRACE1(tag, fmt, a1)
#define TRACE2(tag, fmt, a1, a2)
#define TRACE3(tag, fmt, a1, a2, a3)

void 
DbgPrivTraceError(HRESULT hr, const char * str)
{
    if (hr == S_OK || hr == S_FALSE)
    {
        ASSERTMSG(0, FILTER_MODULE_FULL_NAME " Dbg S_OK or S_FALSE treated as error.\n");
    }
    else if (SUCCEEDED(hr))
    {
        ASSERTMSG(0, FILTER_MODULE_FULL_NAME " Dbg Success code treated as error. Is hr uninitialized?\n");
    }

    OutputDebugStringA(str);
}

#define TRACE_ERROR(hr)                                                                                 \
    do                                                                                                  \
    {                                                                                                   \
        DbgPrivTraceError(hr, FILTER_MODULE_FULL_NAME " Dbg Trace error "  __FILE__ ":" MKSTRING(__LINE__) "\n");   \
    } while (g_dwFALSE)                                                                                 \

#else

#define ASSERT(x)
#define ASSERTMSG(x, sz)

#define VERIFY(x) x

#define TRACE(tag, fmt)
#define TRACE1(tag, fmt, a1)
#define TRACE2(tag, fmt, a1, a2)
#define TRACE3(tag, fmt, a1, a2, a3)

#define TRACE_ERROR(hr)

#endif

/** 
 * Structure for passing data from MessageBoxOnThread to MessageBoxOnThreadFn.
 */
struct MBOT
{
    HWND hwnd;
    int result;
    WCHAR * text;
    WCHAR * caption;
    int type;
};

/**
 * Thread proc for MessageBoxOnThread
 */
DWORD WINAPI
MessageBoxOnThreadFn(
    MBOT *pmbot)
{
    // Flush any messages hanging out in the queue.
    for (int n = 0; n < 100; ++n)
    {
        MSG msg;
        PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);
    }

    pmbot->result = MessageBox(pmbot->hwnd, pmbot->text, pmbot->caption, pmbot->type);

    return 0;
}

/**
 * Display a message box on another thread. This stops
 * the current thread dead in its tracks while the 
 * message pump runs for the message box UI.
 *
 * The arguments for this function are identical to the
 * arguments for the Win32 MessageBox API.
 */

extern "C"
int 
MessageBoxOnThread(
    HWND hwnd,
    WCHAR *text, 
    WCHAR *caption, 
    int type)
{
    MBOT mbot;

    mbot.hwnd = hwnd;
    mbot.text = text;
    mbot.caption = caption;
    mbot.type = type;
    mbot.result = 0;

    MessageBoxOnThreadFn(&mbot);

    return mbot.result;
}

/**
 * Squirt out a debug message using a va_list.
 *
 * @param format Sprintf-style format string with 
 *      optional control codes embedded between a 
 *      pair of \'s at the beginning of the string. 
 *      The control codes are:
 *
 *      n - supress new line
 *      p - supress prefix
 *
 *      Example: "\\p\\Foobar"
 */
BOOL 
TraceV(
        const WCHAR * component,
        WCHAR *tag,
        WCHAR *format, 
        va_list args)
{
    BOOL        newline = TRUE;
    BOOL        prefix = TRUE;
    DWORD       idThread = 0;
    DWORD       idProcess = 0;
    int         iEndOfMsg;
    WCHAR       bufMsg[512];
    int		bufSize = 0;     
    WCHAR	*pbuf, *pbufNew;	
    WCHAR	special;	

    while (format[0] == L'\\')
    {
	special = format[1];
	if (special == L'n')
	{
            newline = FALSE; 
	}
	else if (special == L'p')
	{
            prefix = FALSE;
	}
	else
	{
	    break;
	}

	format += 2;
    }

    if (prefix)
    {
        idThread = GetCurrentThreadId();
        idProcess = GetCurrentProcessId();
    }

    pbufNew = bufMsg;
    bufSize = ARRAY_SIZE(bufMsg);

    do {
	pbuf = pbufNew;
	pbufNew = NULL;

	HRESULT hr = S_OK;

	if (prefix)
	{

	  hr = StringCchPrintfW(pbuf, bufSize, L"[%x.%x %s " PRODUCT_NAME_L L" %s] ", idProcess, idThread, component, tag);
	  if (hr == S_OK)
	  {
	    iEndOfMsg = lstrlenW(pbuf);
	  }
	  else if (hr == STRSAFE_E_INSUFFICIENT_BUFFER)
          {
	    iEndOfMsg = -1;
	  }
	  else 
	  {
	    ASSERT(FALSE);
	    return FALSE;
	  }
	}
	else 
	{
	    iEndOfMsg = 0;
	}

	if (iEndOfMsg >= 0) 
        {
	    if (args != NULL)
	    {
	        hr = StringCchVPrintfW(&pbuf[iEndOfMsg], bufSize - iEndOfMsg, format, args);
		if (hr == S_OK)
		{
		  iEndOfMsg = lstrlenW(pbuf);
		}
		else if (hr == STRSAFE_E_INSUFFICIENT_BUFFER)
		{
		  iEndOfMsg = -1;
		}
		else 
		{
		  ASSERT(FALSE);
		  return FALSE;
		}
	    }
	    else
	    {
	        hr = StringCchPrintf(&pbuf[iEndOfMsg], bufSize - iEndOfMsg, L"%s", format);
		if (hr == S_OK) 
		{
		  iEndOfMsg = lstrlenW(pbuf);
		}
		else if (hr == STRSAFE_E_INSUFFICIENT_BUFFER)
		{
		  iEndOfMsg = -1;
		}
		else 
		{
		  ASSERT(FALSE);
		  return FALSE;
		}
	    }
	}

	if (iEndOfMsg < 0 || (newline && iEndOfMsg+1 >= bufSize)) {
	    bufSize *= 2;
	    pbufNew = new WCHAR[bufSize];
	}
	else {
	    if (newline)
	    {
		pbuf[iEndOfMsg] = L'\n';
		pbuf[iEndOfMsg+1] = L'\0';
	    }
	}

	if (pbufNew == NULL) {
	    OutputDebugString(pbuf);
	}

	if (pbuf != bufMsg) {
	    delete [] pbuf;
	    pbuf = NULL;
	}
    } while (pbufNew != NULL);

    return FALSE;
}


BOOL 
TraceVStatic(
        const WCHAR * component,
        WCHAR *tag,
        WCHAR *format, 
        va_list args)
{
    return TraceV(component, tag, format, args);
}


extern "C"
BOOL
DbgpTraceError(
    HRESULT hr,
    const WCHAR * component,
    char *file,
    int line)
{
#if DBG
    WCHAR buffer[1024];

    if (hr == S_OK || hr == S_FALSE)
    {
        ASSERTMSG(0, "S_OK or S_FALSE treated as error.");
    }
    else if (SUCCEEDED(hr))
    {
        ASSERTMSG(0, "Success code treated as error. Is hr uninitialized?");
    }

    if (!FormatMessage(
            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            hr,
            LANG_SYSTEM_DEFAULT,
            buffer,
            ARRAY_SIZE(buffer),
            NULL))
    {
        buffer[0] = '\n';
        buffer[1] = '\0';
    }

    return DbgpTrace(component, TAG_INTERNAL, L"Trace error %08x %s\t%S(%d)", hr, buffer, file, line);
#else
    UNREFERENCED_PARAMETER(hr);
    UNREFERENCED_PARAMETER(component);
    UNREFERENCED_PARAMETER(file);
    UNREFERENCED_PARAMETER(line);
    return FALSE;
#endif
}

/**
 * Squirt out a debug message.
 *
 */
extern "C"
BOOL __cdecl
DbgpTrace(
    const WCHAR * component,
    WCHAR *tag,
    WCHAR *format, 
    ...)
{
#if DBG
    BOOL fBreak;
    va_list arg;

    va_start(arg, format);
    fBreak = TraceVStatic(component, tag, format, arg);
    va_end(arg);

    return fBreak;
#else
    UNREFERENCED_PARAMETER(component);
    UNREFERENCED_PARAMETER(tag);
    UNREFERENCED_PARAMETER(format);
    return FALSE;
#endif
}

/**
 * Display assert dialog.
 *
 * @return TRUE if caller should break into the debugger.
 */

extern "C"
BOOL
DbgpAssert(const WCHAR * component, char const *message, char const * file, int line, char const * stacktrace)
{
#if DBG
    int     id = IDIGNORE;
    DWORD   idThread, idProcess;
    WCHAR   bufMsg[8192];
    bool    fIncludeFileLine;
    
    fIncludeFileLine = (file != NULL && line > 0);
    if (message == NULL)
    {
        message = "<No Assertion Expression>";
    }

    idThread = GetCurrentThreadId();
    idProcess = GetCurrentProcessId();

    if (fIncludeFileLine)
    {
        StringCchPrintfW(
                bufMsg, 
                ARRAY_SIZE(bufMsg),
                L"Component: %s\n"
                L"PID=%d TID=%d\n"
                L"Failed Expression: %S\n"
                L"File %S:%d\n\n"
                L"A=Exit process R=Debug I=Continue",
                component,
                idProcess, idThread,
                message,
                file, line);
    }
    else if (stacktrace)
    {
        StringCchPrintfW(
                bufMsg, 
                ARRAY_SIZE(bufMsg),
                L"Component: %s\n"
                L"PID=%d TID=%d\n"
                L"Failed Expression: %S\n"
                L"%S\n"
                L"A=Exit process R=Debug I=Continue",
                component,
                idProcess, idThread,
                message,
                stacktrace);
    }
    else
    {
        StringCchPrintfW(
                bufMsg, 
                ARRAY_SIZE(bufMsg),
                L"Component: %s\n"
                L"PID=%d TID=%d\n"
                L"Failed Expression: %S\n"
                L"A=Exit process R=Debug I=Continue",
                component,
                idProcess, idThread,
                message);
    }

    id = MessageBoxOnThread(NULL, bufMsg, PRODUCT_NAME_L L" Assertion", 
            MB_SERVICE_NOTIFICATION | MB_TOPMOST | 
            MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION);

    if (id == IDABORT)
        TerminateProcess(GetCurrentProcess(), 1);
    
    return id == IDRETRY;
#else
    UNREFERENCED_PARAMETER(component);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(file);
    UNREFERENCED_PARAMETER(line);
    UNREFERENCED_PARAMETER(stacktrace);
    return FALSE;
#endif
}

#if 0

#include "util.h"
#include "pm.h"


long    g_DisableAssertThread;

#if DBG

#define TAG_ASSERT L"Assert"

#define TAGVAL_MIN      0
#define TAGVAL_DISABLED 0
#define TAGVAL_ENABLED  1
#define TAGVAL_BREAK    2
#define TAGVAL_MAX      TAGVAL_BREAK

struct BuiltinTag
{
    const WCHAR *   name;
    DWORD           value;
};

class DbgTags
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    static BOOL TraceVStatic(const WCHAR * component, WCHAR *tagname, WCHAR *format, va_list args);
    static BOOL IsTagEnabledStatic(WCHAR * tag);    
    static BOOL IsTagPresentStatic(WCHAR * tag);    
    static void StopNotificationThread();

private:
    enum TagState {TAGS_INIT, TAGS_DEFAULT, TAGS_FROMREGISTRY};

    static void     EnsureInit(void);

    void            Clear();
    void            ReadTagsFromRegistry();
    void            WriteTagsToRegistry();
    void            RevertToDefault();

    DWORD           GetBuiltInLenMaxValueName();

    int             GetCalculatedValue(const WCHAR *);
    const WCHAR *   GetName(int i);

    DWORD               RegNotifyThreadProc();
    static DWORD WINAPI RegNotifyThreadProcStatic(LPVOID);

    BOOL TraceV(const WCHAR * component, WCHAR *tagname, WCHAR *format, va_list args);
    BOOL IsTagEnabled(WCHAR * tag);    
    BOOL IsTagPresent(WCHAR * tag);    

    BOOL                _DebugInitialized; 
    TagState            _tagState;         
    int                 _numTags;          
    int                 _cchName;          
    DWORD               _lenMaxValueName;  
    WCHAR *             _tagNames;         
    int *               _tagValues;        
    int *               _tagPrefixLen;

    static HANDLE             s_hNotificationThread;
    static DbgTags *          s_tags;
    static CReadWriteSpinLock s_lock;
    static const BuiltinTag   s_builtintags[];   
    static const WCHAR        s_KeyName[];
    static const WCHAR        s_KeyListen[];
    static const WCHAR        s_BreakOnAssertName[];
    static const WCHAR        s_EnableAssertMessageName[];
};

HANDLE DbgTags::s_hNotificationThread = NULL;
DbgTags* DbgTags::s_tags = NULL;
CReadWriteSpinLock DbgTags::s_lock("DbgTags::s_lock");

const BuiltinTag  DbgTags::s_builtintags[] = 
{
    TAG_ALL,         TAGVAL_DISABLED,
    TAG_INTERNAL,    TAGVAL_ENABLED,
    TAG_EXTERNAL,    TAGVAL_ENABLED,
    TAG_ASSERT,      TAGVAL_BREAK,
};

const WCHAR      DbgTags::s_KeyName[] = REGPATH_MACHINE_APP_L L"\\Debug";
const WCHAR      DbgTags::s_KeyListen[] = L"Software\\Microsoft";
const WCHAR      DbgTags::s_BreakOnAssertName[] = L"BreakOnAssert";
const WCHAR      DbgTags::s_EnableAssertMessageName[] = L"EnableAssertMessage";

void 
DbgTags::EnsureInit()
{
    DbgTags *   tags;
    DWORD       id;
    BOOL        doinit = FALSE;

    if (s_tags != NULL)
        return;

    s_lock.AcquireWriterLock();
    __try
    {
        if (s_tags == NULL)
        {
            tags = new DbgTags();
            if (tags == NULL)
                return;

            tags->ReadTagsFromRegistry();
            doinit = TRUE;
            s_tags = tags;
        }
    }
    __finally
    {
        s_lock.ReleaseWriterLock();
    }

    if (doinit)
    {
        s_hNotificationThread = CreateThread(NULL, 0, RegNotifyThreadProcStatic, 0, 0, &id);
        if (s_hNotificationThread == NULL)
            return;
    }
}

void
DbgTags::StopNotificationThread()
{
    if (s_hNotificationThread != NULL)
    {
        TerminateThread(s_hNotificationThread, 0);
        CloseHandle(s_hNotificationThread);
        s_hNotificationThread = NULL;
    }
}


void 
DbgTags::Clear()
{
    delete [] _tagNames;
    _tagNames = NULL;
    delete [] _tagValues;
    _tagValues = NULL;
    delete [] _tagPrefixLen;
    _tagPrefixLen = NULL;

    _numTags = 0;
    _cchName = 0;

    _tagState = TAGS_INIT;
}


const WCHAR *   
DbgTags::GetName(int i)
{
    ASSERT(0 <= i && i < _numTags);
    return &_tagNames[_cchName * i];
}


int
DbgTags::GetCalculatedValue(const WCHAR * name)
{
    int i;
    int prefixLen;
    int prefixLenMax;
    int value;

    if (name == NULL)
        return TAGVAL_DISABLED;

    /*
     * Look for an exact match first
     */
    for (i = _numTags; --i >= 0;)
    {
        if (_tagPrefixLen[i] == -1 && _wcsicmp(name, GetName(i)) == 0)
        {
            return _tagValues[i];
        }
    }

    /*
     * Check prefixes. More specific (longer) prefixes override
     * less specific (shorter) ones.
     */
    prefixLenMax = -1;
    value = TAGVAL_DISABLED;
    for (i = _numTags; --i >= 0;)
    {
        prefixLen = _tagPrefixLen[i];
        if (prefixLen > prefixLenMax && _wcsnicmp(name, GetName(i), prefixLen) == 0)
        {
            value = _tagValues[i];
            prefixLenMax = prefixLen;
        }
    }

    return value;
}

DWORD
DbgTags::GetBuiltInLenMaxValueName()
{
    int     k;
    DWORD   len;

    if (_lenMaxValueName == 0)
    {
        for (k = 0; k < ARRAY_SIZE(s_builtintags); k++)
        {
            len = lstrlen(s_builtintags[k].name);
            _lenMaxValueName = max(_lenMaxValueName, len);
        }
    }

    return _lenMaxValueName;
}

void DbgTags::RevertToDefault()
{
    HRESULT hr = 0;
    int     k;
    WCHAR   *pStar;

    if (_tagState == TAGS_DEFAULT)
        return;

    /*
     * Delete old tag information.
     */
    Clear();

    /*
     * Allocate new tag information.
     */
    _numTags = ARRAY_SIZE(s_builtintags);

    _tagState = TAGS_DEFAULT;

    _cchName = (int) GetBuiltInLenMaxValueName() + 1;

    _tagNames = new (NewClear) WCHAR [(ARRAY_SIZE(s_builtintags)) * _cchName];
    ON_OOM_EXIT(_tagNames);

    _tagValues = new (NewClear) int [ARRAY_SIZE(s_builtintags)];
    ON_OOM_EXIT(_tagValues);

    _tagPrefixLen = new (NewClear) int [ARRAY_SIZE(s_builtintags)];
    ON_OOM_EXIT(_tagPrefixLen);

    for (k = 0; k < ARRAY_SIZE(s_builtintags); k++)
    {
        StringCchCopyW((WCHAR *) GetName(k), _cchName, s_builtintags[k].name);
        _tagValues[k] = s_builtintags[k].value;

        pStar = wcschr(GetName(k), L'*');
        if (pStar == NULL)
        {
            _tagPrefixLen[k] = -1;
        }
        else
        {
            _tagPrefixLen[k] = PtrToInt(pStar - GetName(k));
        }
    }

Cleanup:
    if (hr)
    {
        Clear();
    }
}


void
DbgTags::WriteTagsToRegistry()
{
    HRESULT hr = 0;
    long    result = 0;
    HKEY    key = NULL;
    int     i;
    int     value;

    result = RegCreateKeyEx(HKEY_LOCAL_MACHINE, s_KeyName, NULL, NULL,
                   0, KEY_WRITE, NULL, &key, NULL);

    ON_WIN32_ERROR_EXIT(result);

    i = _numTags; 
    while (--i >= 0)
    {
        value = _tagValues[i];
        result = RegSetValueEx(key, GetName(i), NULL, REG_DWORD, (BYTE *)&value, sizeof(value));
        ON_WIN32_ERROR_EXIT(result);
    }

Cleanup:
    if (key != NULL)
    {
        VERIFY(RegCloseKey(key) == ERROR_SUCCESS);
    }
}


void
DbgTags::ReadTagsFromRegistry()
{
    HRESULT hr = 0;
    long    result = 0;
    HKEY    key = NULL;
    DWORD   cValues;
    DWORD   lenMaxValueName;
    DWORD   regType;
    DWORD   value;
    DWORD   cbValue;
    DWORD   cbName;
    DWORD   defValue;
    int     i, j, k;
    BOOL    builtinfound[ARRAY_SIZE(s_builtintags)];
    WCHAR   *pStar;

    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, s_KeyName, 0, KEY_READ, &key);
    if (result != ERROR_SUCCESS)
    {
        RevertToDefault();
        WriteTagsToRegistry();
        return;
    }

    result = RegQueryInfoKey(
            key, NULL, NULL, 0, NULL, NULL, NULL, 
            &cValues, &lenMaxValueName, NULL, NULL, NULL);

    ON_WIN32_ERROR_EXIT(result);

    /*
     * Delete old tag information.
     */
    Clear();

    /*
     * Allocate new tag information.
     */

    /* temporary assignment to get around assertion in GetName */
    _numTags = cValues + ARRAY_SIZE(s_builtintags);

    lenMaxValueName = max(lenMaxValueName, GetBuiltInLenMaxValueName());
    _cchName = lenMaxValueName + 1;    /* add 1 for null terminator */

    _tagNames = new (NewClear) WCHAR [(cValues + ARRAY_SIZE(s_builtintags)) * _cchName];
    ON_OOM_EXIT(_tagNames);

    _tagValues = new (NewClear) int [cValues + ARRAY_SIZE(s_builtintags)];
    ON_OOM_EXIT(_tagValues);

    _tagPrefixLen = new (NewClear) int [cValues + ARRAY_SIZE(s_builtintags)];
    ON_OOM_EXIT(_tagPrefixLen);

    /*
     * Grab tag information from registry.
     */
    ZeroMemory(builtinfound, sizeof(builtinfound));

    j = 0;
    for (i = 0; i < (int) cValues; i++)
    {
        regType = REG_DWORD;
        cbName = _cchName;
        cbValue = sizeof(value);

        result = RegEnumValue(  
                key,
                i,
                (WCHAR *) GetName(j),
                &cbName,
                0,
                &regType,
                (BYTE *) &value,
                &cbValue);

        if (   result != ERROR_SUCCESS 
               || regType != REG_DWORD
               || lstrcmpi(s_BreakOnAssertName, GetName(j)) == 0
               || lstrcmpi(s_EnableAssertMessageName, GetName(j)) == 0)
        {
            continue;
        }

        defValue = TAGVAL_DISABLED;
        for (k = 0; k < ARRAY_SIZE(s_builtintags); k++)
        {
            if (lstrcmpi(s_builtintags[k].name, GetName(j)) == 0)
            {
                builtinfound[k] = TRUE;
                defValue = s_builtintags[k].value;
                break;
            }
        }

        if (value > TAGVAL_MAX)
        {
            value = defValue;
        }

        _tagValues[j] = value;

        j++;
    }

    for (k = 0; k < ARRAY_SIZE(s_builtintags); k++)
    {
        if (!builtinfound[k])
        {
            StringCchCopyW((WCHAR *) GetName(j), _cchName, s_builtintags[k].name);
            _tagValues[j] = s_builtintags[k].value;
            j++;
        }
    }

    for (i = j; --i >= 0;)
    {
        pStar = wcschr(GetName(i), L'*');
        if (pStar == NULL)
        {
            _tagPrefixLen[i] = -1;
        }
        else
        {
            _tagPrefixLen[i] = PtrToInt(pStar - GetName(i));
        }
    }

    _numTags = j;
    _tagState = TAGS_FROMREGISTRY;

Cleanup:
    if (key != NULL)
    {
        RegCloseKey(key);
    }

    if (hr)
    {
        RevertToDefault();
    }
}



DWORD 
DbgTags::RegNotifyThreadProc()
{
    HKEY    key = NULL;
    long    result = ERROR_SUCCESS;
    HRESULT hr = 0;
    HANDLE  event;

    event = CreateEvent(NULL, FALSE, FALSE, FALSE);
    if (event == NULL)
        return GetLastWin32Error();

    for (;;)
    {
        result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, s_KeyListen, 0, KEY_READ, &key);
        ON_WIN32_ERROR_EXIT(result);

        VERIFY(RegNotifyChangeKeyValue(
            key,
            TRUE,
            REG_NOTIFY_CHANGE_NAME       |  
            REG_NOTIFY_CHANGE_LAST_SET,
            event,
            TRUE) == ERROR_SUCCESS);

        VERIFY(WaitForSingleObject(event, INFINITE) != WAIT_FAILED);
        VERIFY(RegCloseKey(key) == ERROR_SUCCESS);

        s_lock.AcquireWriterLock();
        __try
        {
            ReadTagsFromRegistry();
        }
        __finally
        {
            s_lock.ReleaseWriterLock();
        }
    }
    
Cleanup:
    CloseHandle(event);

    return 0;
}



DWORD WINAPI
DbgTags::RegNotifyThreadProcStatic(LPVOID)
{
    return s_tags->RegNotifyThreadProc();
}

/**
 * Squirt out a debug message using a va_list.
 *
 * @param format Sprintf-style format string with 
 *      optional control codes embedded between a 
 *      pair of \'s at the beginning of the string. 
 *      The control codes are:
 *
 *      n - supress new line
 *      p - supress prefix
 *
 *      Example: "\\p\\dir"
 */
BOOL 
DbgTags::TraceV(
        const WCHAR * component,
        WCHAR *tag,
        WCHAR *format, 
        va_list args)
{
    BOOL        newline = TRUE;
    BOOL        prefix = TRUE;
    DWORD       value;
    DWORD       idThread = 0;
    DWORD       idProcess = 0;
    int         iEndOfMsg;
    WCHAR       bufMsg[512];
    int		bufSize = 0;     
    WCHAR	*pbuf, *pbufNew;	
    WCHAR	special;	

    value = TAGVAL_DISABLED;

    s_lock.AcquireWriterLock();
    __try
    {
        value = GetCalculatedValue(tag);
    }
    __finally
    {
        s_lock.ReleaseWriterLock();
    }
    
    if (value == TAGVAL_DISABLED)
        return FALSE;

    while (format[0] == L'\\')
    {
	special = format[1];
	if (special == L'n')
	{
            newline = FALSE; 
	}
	else if (special == L'p')
	{
            prefix = FALSE;
	}
	else
	{
	    break;
	}

	format += 2;
    }

    if (prefix)
    {
        idThread = GetCurrentThreadId();
        idProcess = GetCurrentProcessId();
    }

    pbufNew = bufMsg;
    bufSize = ARRAY_SIZE(bufMsg);

    do {
	pbuf = pbufNew;
	pbufNew = NULL;

	HRESULT hr = S_OK;

	if (prefix)
	{
	  hr = StringCchPrintfW(pbuf, bufSize, L"[%x.%x %s " PRODUCT_NAME_L L" %s] ", idProcess, idThread, component, tag);
	  if (hr == S_OK)
	  {
	    iEndOfMsg = lstrlenW(pbuf);
	  }
	  else if (hr == STRSAFE_E_INSUFFICIENT_BUFFER)
          {
	    iEndOfMsg = -1;
	  }
	  else 
	  {
	    ASSERT(FALSE);
	    return FALSE;
	  }
	}
	else 
	{
	    iEndOfMsg = 0;
	}

	if (iEndOfMsg >= 0) 
        {
	    if (args != NULL)
	    {

	        hr = StringCchVPrintfW(&pbuf[iEndOfMsg], bufSize - iEndOfMsg, format, args);
		if (hr == S_OK)
		{
		  iEndOfMsg = lstrlenW(pbuf);
		}
		else if (hr == STRSAFE_E_INSUFFICIENT_BUFFER)
		{
		  iEndOfMsg = -1;
		}
		else 
		{
		  ASSERT(FALSE);
		  return FALSE;
		}
	    }
	    else
	    {
	        hr = StringCchPrintf(&pbuf[iEndOfMsg], bufSize - iEndOfMsg, L"%s", format);
		if (hr == S_OK) 
		{
		  iEndOfMsg = lstrlenW(pbuf);
		}
		else if (hr == STRSAFE_E_INSUFFICIENT_BUFFER)
		{
		  iEndOfMsg = -1;
		}
		else 
		{
		  ASSERT(FALSE);
		  return FALSE;
		}
	    }
	}


	if (iEndOfMsg < 0 || (newline && iEndOfMsg+1 >= bufSize)) {
	    bufSize *= 2;
	    pbufNew = new WCHAR[bufSize];
	}
	else {
	    if (newline)
	    {
		pbuf[iEndOfMsg] = L'\n';
		pbuf[iEndOfMsg+1] = L'\0';
	    }
	}

	if (pbufNew == NULL) {
	    OutputDebugString(pbuf);
	}

	if (pbuf != bufMsg) {
	    delete [] pbuf;
	    pbuf = NULL;
	}
    } while (pbufNew != NULL);

    return value >= TAGVAL_BREAK;
}


BOOL 
DbgTags::TraceVStatic(
        const WCHAR * component,
        WCHAR *tag,
        WCHAR *format, 
        va_list args)
{
    EnsureInit();

    if (s_tags != NULL)
        return s_tags->TraceV(component, tag, format, args);
    return FALSE;
}

BOOL
DbgTags::IsTagEnabled(WCHAR *tag)
{
    DWORD   value = TAGVAL_DISABLED;

    s_lock.AcquireReaderLock();
    __try
    {
        value = GetCalculatedValue(tag);
    }
    __finally
    {
        s_lock.ReleaseReaderLock();
    }

    return value >= TAGVAL_ENABLED;
}

BOOL
DbgTags::IsTagEnabledStatic(WCHAR *tag)
{
    EnsureInit();
    if (s_tags != NULL)
        return s_tags->IsTagEnabled(tag);
    return FALSE;
}

BOOL
DbgTags::IsTagPresent(WCHAR *tag)
{
    BOOL    result = FALSE;
    int i;

    s_lock.AcquireReaderLock();
    __try
    {
        /*
         * Look for an exact match first
         */
        for (i = _numTags; --i >= 0;)
        {
            if (_tagPrefixLen[i] == -1 && _wcsicmp(tag, GetName(i)) == 0)
            {
                result = TRUE;
                break;
            }
        }
    }
    __finally
    {
        s_lock.ReleaseReaderLock();
    }

    return result;
}

BOOL
DbgTags::IsTagPresentStatic(WCHAR *tag)
{
    EnsureInit();
    if (s_tags != NULL)
        return s_tags->IsTagPresent(tag);
    return FALSE;
}

#endif

/**
 * Squirt out a debug message.
 *
 */
extern "C"
BOOL 
DbgpTraceV(
    const WCHAR * component, 
    WCHAR * tag, 
    WCHAR *format, 
    va_list args)
{
#if DBG
    BOOL fBreak;

    fBreak = DbgTags::TraceVStatic(component, tag, format, args);

    return fBreak;
#else
    UNREFERENCED_PARAMETER(component);
    UNREFERENCED_PARAMETER(tag);
    UNREFERENCED_PARAMETER(format);
    UNREFERENCED_PARAMETER(args);
    return FALSE;
#endif
}


/**
 * Squirt out a debug message.
 *
 */
extern "C"
BOOL __cdecl
DbgpTrace(
    const WCHAR * component,
    WCHAR *tag,
    WCHAR *format, 
    ...)
{
#if DBG
    BOOL fBreak;
    va_list arg;

    va_start(arg, format);
    fBreak = DbgTags::TraceVStatic(component, tag, format, arg);
    va_end(arg);

    return fBreak;
#else
    UNREFERENCED_PARAMETER(component);
    UNREFERENCED_PARAMETER(tag);
    UNREFERENCED_PARAMETER(format);
    return FALSE;
#endif
}

/** 
 * Structure for passing data from MessageBoxOnThread to MessageBoxOnThreadFn.
 */
struct MBOT
{
    HWND hwnd;
    int result;
    WCHAR * text;
    WCHAR * caption;
    int type;
};

/**
 * Thread proc for MessageBoxOnThread
 */
DWORD WINAPI
MessageBoxOnThreadFn(
    MBOT *pmbot)
{
    // Flush any messages hanging out in the queue.
    for (int n = 0; n < 100; ++n)
    {
        MSG msg;
        PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);
    }

    pmbot->result = MessageBox(pmbot->hwnd, pmbot->text, pmbot->caption, pmbot->type);

    return 0;
}

/**
 * Display a message box on another thread. This stops
 * the current thread dead in its tracks while the 
 * message pump runs for the message box UI.
 *
 * The arguments for this function are identical to the
 * arguments for the Win32 MessageBox API.
 */

extern "C"
int 
MessageBoxOnThread(
    HWND hwnd,
    WCHAR *text, 
    WCHAR *caption, 
    int type)
{
    MBOT mbot;
    HANDLE Thread;
    DWORD dwThread;

    mbot.hwnd = hwnd;
    mbot.text = text;
    mbot.caption = caption;
    mbot.type = type;
    mbot.result = 0;

    if (g_DisableAssertThread)
    {
        MessageBoxOnThreadFn(&mbot);
    }
    else
    {
        Thread = CreateThread(
                NULL,
                0,
                (LPTHREAD_START_ROUTINE)MessageBoxOnThreadFn,
                &mbot,
                0,
                &dwThread);
        if (!Thread)
        {
            MessageBoxOnThreadFn(&mbot);
        }
        else
        {
            WaitForSingleObject(Thread, INFINITE);
            CloseHandle(Thread);
        }
    }

    return mbot.result;
}

/**
 * Disable or enable using second thread for assert message box.
 * 
 * Bad things happen if an attempt is made to start a thread during
 * calls to DLLMain(). Use this function to enable or disable 
 * the use of a second thread for the asssert message box.
 */

extern "C"
void
DbgpDisableAssertThread(BOOL disable)
{
    if (disable)
    {
        InterlockedIncrement(&g_DisableAssertThread);
    }
    else
    {
        InterlockedDecrement(&g_DisableAssertThread);
    }
}

/**
 * Display assert dialog.
 *
 * @return TRUE if caller should break into the debugger.
 */

extern "C"
BOOL
DbgpAssert(const WCHAR * component, char const *message, char const * file, int line, char const * stacktrace)
{
#if DBG
    int     id = IDIGNORE;
    BOOL    fBreak;
    DWORD   idThread, idProcess;
    WCHAR   bufMsg[8192];
    bool    fIncludeFileLine;
    
    fIncludeFileLine = (file != NULL && line > 0);
    if (message == NULL)
    {
        message = "<No Assertion Expression>";
    }

    if (fIncludeFileLine)
    {
        fBreak = DbgpTrace(component, TAG_ASSERT, L"%S\n\tFile%S:%d", message, file, line);
    }
    else if (stacktrace != NULL)
    {
        fBreak = DbgpTrace(component, TAG_ASSERT, L"%S\n%S", message, stacktrace);
    }
    else
    {
        fBreak = DbgpTrace(component, TAG_ASSERT, L"%S", message);
    }

    if (fBreak)
    {
        if (DbgTags::IsTagEnabledStatic(L"AssertBreak")) 
        {
            return TRUE;
        }

        idThread = GetCurrentThreadId();
        idProcess = GetCurrentProcessId();

        if (fIncludeFileLine)
        {
            StringCchPrintfW(
                    bufMsg, 
                    ARRAY_SIZE(bufMsg),
                    L"Component: %s\n"
                    L"PID=%d TID=%d\n"
                    L"Failed Expression: %S\n"
                    L"File %S:%d\n\n"
                    L"A=Exit process R=Debug I=Continue",
                    component,
                    idProcess, idThread,
                    message,
                    file, line);
        }
        else if (stacktrace)
        {
            StringCchPrintfW(
                    bufMsg, 
                    ARRAY_SIZE(bufMsg),
                    L"Component: %s\n"
                    L"PID=%d TID=%d\n"
                    L"Failed Expression: %S\n"
                    L"%S\n"
                    L"A=Exit process R=Debug I=Continue",
                    component,
                    idProcess, idThread,
                    message,
                    stacktrace);
        }
        else
        {
            StringCchPrintfW(
                    bufMsg, 
                    ARRAY_SIZE(bufMsg),
                    L"Component: %s\n"
                    L"PID=%d TID=%d\n"
                    L"Failed Expression: %S\n"
                    L"A=Exit process R=Debug I=Continue",
                    component,
                    idProcess, idThread,
                    message);
        }

        id = MessageBoxOnThread(NULL, bufMsg, PRODUCT_NAME_L L" Assertion", 
                MB_SERVICE_NOTIFICATION | MB_TOPMOST | 
                MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION);
    }

    if (id == IDABORT)
        TerminateProcess(GetCurrentProcess(), 1);
    
    return id == IDRETRY;
#else
    UNREFERENCED_PARAMETER(component);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(file);
    UNREFERENCED_PARAMETER(line);
    UNREFERENCED_PARAMETER(stacktrace);
    return FALSE;
#endif
}

extern "C"
BOOL
DbgpTraceError(
    HRESULT hr,
    const WCHAR * component,
    char *file,
    int line)
{
#if DBG
    WCHAR buffer[1024];

    if (hr == S_OK || hr == S_FALSE)
    {
        ASSERTMSG(0, "S_OK or S_FALSE treated as error.");
    }
    else if (SUCCEEDED(hr))
    {
        ASSERTMSG(0, "Success code treated as error. Is hr uninitialized?");
    }

    if (!FormatMessage(
            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            hr,
            LANG_SYSTEM_DEFAULT,
            buffer,
            ARRAY_SIZE(buffer),
            NULL))
    {
        buffer[0] = '\n';
        buffer[1] = '\0';
    }

    return DbgpTrace(component, TAG_INTERNAL, L"Trace error %08x %s\t%S(%d)", hr, buffer, file, line);
#else
    UNREFERENCED_PARAMETER(hr);
    UNREFERENCED_PARAMETER(component);
    UNREFERENCED_PARAMETER(file);
    UNREFERENCED_PARAMETER(line);
    return FALSE;
#endif
}


/*
 * Return whether a tag is enabled.
 */
extern "C"
BOOL 
DbgpIsTagEnabled(WCHAR * tag)
{
#if DBG
    return DbgTags::IsTagEnabledStatic(tag);
#else
    UNREFERENCED_PARAMETER(tag);
    return FALSE;
#endif
}

/*
 * Return whether a tag is present.
 */

extern "C"
BOOL 
DbgpIsTagPresent(WCHAR * tag)
{
#if DBG
    return DbgTags::IsTagPresentStatic(tag);
#else
    UNREFERENCED_PARAMETER(tag);
    return FALSE;
#endif
}


extern "C"
void
DbgpStopNotificationThread()
{
#if DBG
    DbgTags::StopNotificationThread();
#endif
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\filter\makefile.inc ===
$(O)\filter.res : ..\filter.rc

$(O)\filter.def : ..\filter.src ..\..\inc\names.h

$(URTTARGET)\$(ASPNET_PRODUCT)\msvcr70.dll : $(URTTARGET)\$(@F)
    $(ECHO_PROCESSING_CMD) $@
    if not exist $(@D) md $(@D)
    if exist $@.tmp del $@.tmp
    if exist $@ ren $@ $(@F).tmp
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\filter\csfilt.cxx ===
/**
 * csfilt.cxx
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */


#include "precomp.h"
#include "dbg.h"
#include "util.h"
#include "nisapi.h"
#include "iiscnfg.h"

/*
 * These values of these constants come fom System.Web.SessionState.SessionId
 */
#define NUM_CHARS_IN_ENCODING       32
#define SESSIONID_LENGTH_CHARS      24
#define COOKIELESS_SESSION_LENGTH   (SESSIONID_LENGTH_CHARS + 2)
#define COOKIELESS_SESSION_WITH_ESCAPE_LENGTH   (SESSIONID_LENGTH_CHARS + 6)
#define COOKIELESS_SESSION_FILTER_HEADER    "AspFilterSessionId:"

char g_encoding[NUM_CHARS_IN_ENCODING] =
{
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    '0', '1', '2', '3', '4', '5'
};

bool g_legalchars[128];

void 
CookielessSessionFilterInit()
{
    int     i;
    char    ch;

    for (i = NUM_CHARS_IN_ENCODING - 1; i >= 0; i--)
    {
        ch = g_encoding[i];
        ASSERT(0 <= ch && ch < ARRAY_SIZE(g_legalchars));
        g_legalchars[ch] = true;
    }
}

bool 
IsLegit(char *pch)
{
    int     c;
    char    ch;

    for (c = SESSIONID_LENGTH_CHARS; c > 0; pch++, c--)
    {
        ch = *pch;
        if (ch < 0 || ARRAY_SIZE(g_legalchars) <= ch || !g_legalchars[ch])
            return false;
    }

    return true;
}


void AnsiToLower(char *pch) {
    while (*pch) {
        if ('A' <= *pch && *pch <= 'Z') {
            *pch += 'a' - 'A';
            ASSERT('a' <= *pch && *pch <= 'z');
        }

        pch++;
    }
}

DWORD 
CookielessSessionFilterProc(
        HTTP_FILTER_CONTEXT *pfc, 
        HTTP_FILTER_PREPROC_HEADERS *pfph)
{
    HRESULT hr;
    int     ret;
    char    achBuf[1024];
    char    *pchUrl = achBuf;
    int     cbUrl;
    int     cbCopied;
    char    *pch;
    int     lenUrl;
    int     c;
    char    achId[SESSIONID_LENGTH_CHARS + 1];
    char    *pchRestOfUrl;
    int     lenRestOfUrl;
    bool    useEscape = false;

    /*
     * Get the URL.
     */
    cbUrl = sizeof(achBuf);
    for (;;)
    {
        cbCopied = cbUrl;
        ret = pfph->GetHeader(pfc, "url", pchUrl, (DWORD *) &cbCopied);
        if (ret)
            break;

        hr = GetLastWin32Error();
        if (hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
            EXIT();

        hr = S_OK;
        cbUrl += 1024;

        if (pchUrl != achBuf)
        {
            delete [] pchUrl;
        }
        
        pchUrl = new char[cbUrl]; 
        ON_OOM_EXIT(pchUrl);
    }

    /*
     * Look for a cookieless session id.
     */
    lenUrl = cbCopied - 1;

    for (   c = lenUrl - SESSIONID_LENGTH_CHARS - 4, // skip "/(" prefix and ")/" suffix
                pch = pchUrl + 1; 
            c >= 0; 
            c--, pch++)
    {
        bool found = false;

        if (    *pch == '(' &&
                pch[-1] == '/' &&
                pch[SESSIONID_LENGTH_CHARS+1] == ')' &&
                pch[SESSIONID_LENGTH_CHARS+2] == '/')
        {
            CopyMemory(achId, pch+1, SESSIONID_LENGTH_CHARS);
            achId[SESSIONID_LENGTH_CHARS] = '\0';
            found = true;
            useEscape = false;
        }
        else if (   c >= (COOKIELESS_SESSION_WITH_ESCAPE_LENGTH - COOKIELESS_SESSION_LENGTH) &&
                    pch[-1] == '/' &&
                    pch[0] == '%' &&
                    pch[1] == '2' &&
                    pch[2] == '8' &&
                    pch[SESSIONID_LENGTH_CHARS+3] == '%' &&
                    pch[SESSIONID_LENGTH_CHARS+4] == '2' &&
                    pch[SESSIONID_LENGTH_CHARS+5] == '9' &&
                    pch[SESSIONID_LENGTH_CHARS+6] == '/') {
            CopyMemory(achId, pch+3, SESSIONID_LENGTH_CHARS);
            achId[SESSIONID_LENGTH_CHARS] = '\0';
            found = true;
            useEscape = true;
        }

        if (found) {
            AnsiToLower(achId);
            if (IsLegit(achId))
                break;
        }
    }

    /*
     * Stuff the session id in a header and remove the id from the url.
     */
    if (c >= 0)
    {
        if (useEscape) {
            pchRestOfUrl = pch + COOKIELESS_SESSION_WITH_ESCAPE_LENGTH + 1;
        }
        else {
            pchRestOfUrl = pch + COOKIELESS_SESSION_LENGTH + 1;
        }
        lenRestOfUrl = lenUrl - PtrToInt(pchRestOfUrl - pchUrl);
        MoveMemory(pch, pchRestOfUrl, lenRestOfUrl + 1);
        
        ret = pfph->SetHeader(pfc, "url", pchUrl);
        ON_ZERO_EXIT_WITH_LAST_ERROR(ret);

        ret = pfph->AddHeader(pfc, COOKIELESS_SESSION_FILTER_HEADER, achId);
        ON_ZERO_EXIT_WITH_LAST_ERROR(ret);
    }

Cleanup:
    if (pchUrl != achBuf)
    {
        delete [] pchUrl;
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

BOOL
IsBin(const char*szCur) {
    if (!(*szCur == '/'))
        return false;

    szCur++;
    if (!(*szCur == 'b' || *szCur == 'B'))
        return false;

    szCur++;
    if (!(*szCur == 'i' || *szCur == 'I'))
        return false;

    szCur++;
    if (!(*szCur == 'n' || *szCur == 'N'))
        return false;

    szCur++;
    if (!(*szCur == '/' || *szCur == '\0'))
        return false;

    return true;    
}

DWORD 
ForbidBinDir(
        HTTP_FILTER_CONTEXT *pfc, 
        HTTP_FILTER_URL_MAP_EX *pfum)
{
    const char *  szCur = &pfum->pszURL[pfum->cchMatchingURL];

    // If execute flags == true, allow request
    if ((pfum->dwFlags & MD_ACCESS_EXECUTE) != 0) {
        return SF_STATUS_REQ_NEXT_NOTIFICATION;
    }

    if (IsBin(szCur)) {
        SetLastError( ERROR_FILE_NOT_FOUND );
        return SF_STATUS_REQ_ERROR;
    }

    // Not found
    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\filter\sources.inc ===
!include $(DNAROOT)\src\xsp\place.inc

!if "$(ASPNET_PRODUCT)" == "redist"
SYNCHRONIZE_BLOCK=1
SYNCHRONIZE_DRAIN=1
!endif

TARGETNAME=$(ASPNET_NAME_PREFIX)filter
TARGETPATH=$(O)
TARGETTYPE=DYNLINK

DLLDEF=$(O)\filter.def
DLLENTRY=_DllMainCRTStartup

PRECOMPILED_CXX=1
PRECOMPILED_SHARED_INCLUDE=precomp.h
PRECOMPILED_SHARED_PCH=..\..\inc\$(ASPNET_PRODUCT)\$(O)\precomp.pch

!if $(ASPNET_PRODUCT_ID) == $(ASPNET_PRODUCT_REDIST)
HACKSYSTEM32FILES=
!else
HACKSYSTEM32FILES=$(URTTARGET)\$(ASPNET_PRODUCT)\msvcr70.dll

!endif

NTTARGETFILES=$(HACKSYSTEM32FILES)

MISCFILES=                              \
        ..\aspnet_stopbinfilt.reg       \

TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib    \
        $(SDK_LIB_PATH)\user32.lib      \
        $(SDK_LIB_PATH)\uuid.lib        \
        $(SDK_LIB_PATH)\Advapi32.lib    \

LINKLIBS=\
        $(XSPBASEDIR)\inc\$(ASPNET_PRODUCT)\$(O)\precomp.lib          \
        $(XSPBASEDIR)\util\$(ASPNET_PRODUCT)\$(O)\util.lib            \

SOURCES=                                   \
        ..\filter.rc                     \
        ..\csfilt.cxx                      \
        ..\debug.cxx                    \
        ..\filter.cxx                      \
        ..\main.cxx                        \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\filter\filter.cxx ===
/**
 * ASP.NET Filter
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

#include "precomp.h"
#include "names.h"
#include "httpfilt6.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define FILTER_DESCRIPTION_CHAR PRODUCT_NAME    " Cookieless Session Filter"

void CookielessSessionFilterInit();
DWORD CookielessSessionFilterProc(
        HTTP_FILTER_CONTEXT *pfc, 
        HTTP_FILTER_PREPROC_HEADERS *pfph);
DWORD ForbidBinDir(
        HTTP_FILTER_CONTEXT *pfc, 
        HTTP_FILTER_URL_MAP_EX *pfum);

#define VERSION_URL_MAP_EX      6

BOOL
UseFilterBin(PHTTP_FILTER_VERSION   pVer) {
    HRESULT hr;
    int     rc;
    HKEY    key = NULL;
    DWORD   value;
    DWORD   size;

    if ((pVer->dwServerFilterVersion >> 16) < VERSION_URL_MAP_EX) {
        // Check the major version.  If it's lower than 6, don't need to do bin dir filter
        return false;
    }

    // Ready HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ASP.NET\StopBinFiltering
    rc = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        REGPATH_MACHINE_APP_L,
        0,
        KEY_READ,
        &key);

    ON_WIN32_ERROR_EXIT(rc);

    size = sizeof(DWORD);
    rc = RegQueryValueEx(key, REGVAL_STOP_BIN_FILTER, NULL, NULL, (BYTE *)&value, &size);
    ON_WIN32_ERROR_EXIT(rc);

    if (value != 0) {
        // Non-zero value in StopBinFiltering
        return false;
    }

Cleanup:
    // For error case
    return true;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Exported function: GetFilterVersion: Called by IIS to determine what filter
//     events the dll wants to deal with

BOOL
WINAPI
GetFilterVersion(
        PHTTP_FILTER_VERSION   pVer)
{
    if (pVer == NULL)
        return FALSE;

    ////////////////////////////////////////////////////////////
    // Step 1: Initialize pVer
    pVer->dwFilterVersion = HTTP_FILTER_REVISION;
    StringCchCopyA(pVer->lpszFilterDesc, SF_MAX_FILTER_DESC_LEN, FILTER_DESCRIPTION_CHAR);
    pVer->dwFlags = SF_NOTIFY_ORDER_DEFAULT | SF_NOTIFY_PREPROC_HEADERS;

    if (UseFilterBin(pVer)) {
        pVer->dwFlags |= SF_NOTIFY_URL_MAP;
    }

    CookielessSessionFilterInit();

    return TRUE;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL 
WINAPI
TerminateFilter(DWORD)
{
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Exported function: HttpFilterProc: Called by IIS

DWORD 
WINAPI
HttpFilterProc(
        PHTTP_FILTER_CONTEXT   pfc,  
        DWORD                  notificationType,  
        LPVOID                 pvNotification)
{
    switch (notificationType)
    {
    case SF_NOTIFY_PREPROC_HEADERS:
        return CookielessSessionFilterProc(
                    pfc, (HTTP_FILTER_PREPROC_HEADERS *) pvNotification);
        break;
    case SF_NOTIFY_URL_MAP:
        DWORD ret = ForbidBinDir(pfc, (HTTP_FILTER_URL_MAP_EX *) pvNotification);
        // only process the first SF_NOTIFY_URL_MAP for a given request
        pfc->ServerSupportFunction(pfc, SF_REQ_DISABLE_NOTIFICATIONS, NULL, SF_NOTIFY_URL_MAP, 0);
        return ret;
    }

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\appdomains.h ===
/**
 * ASP.NET support for App Domains
 *
 * Copyright (C) Microsoft Corporation, 1999
 */

#pragma once

/**
 * Initialize the app domain factory with the name of the module
 * and the class name for the first class (root object) in app domain
 */
HRESULT
InitAppDomainFactory(
    WCHAR *pModuleName, 
    WCHAR *pTypeName);

HRESULT
InitAppDomainFactory();


/**
 * Lookup (or create a new) app domain (root objects) by application id
 * and the class name for the first class in app domain.
 * If application physical path is missing, it will not create the new
 * app domain (return S_FALSE if app domain is not found)
 * 
 */
HRESULT
GetAppDomain(
    char *pAppId,
    char *pAppPhysPath,
    IUnknown **ppRoot,
    char *szUrlOfAppOrigin,
    int   iZone,
    UINT  codePage = CP_ACP);


/**
 * Enumeration callback
 */
typedef void (__stdcall *PFNAPPDOMAINCALLBACK)(IUnknown *pAppDomainObject);

/**
 * Enumerate all app domains and call callback for each
 */
HRESULT
EnumAppDomains(
    PFNAPPDOMAINCALLBACK callback);

/**
 * Uninitialize the app domain factory.
 */
HRESULT
UninitAppDomainFactory();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\deadcode\tpool\thread.c ===
/**
 * thread.c
 * 
 * This file is copied from \nt\private\windows\base\client\thread.c
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

 
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    thread.c

Abstract:

    This module implements Win32 Thread Object APIs

Author:

    Mark Lucovsky (markl) 21-Sep-1990

Revision History:

--*/

//comment out to get rid of dependency check warning
#if NOT_IN_TPOOL
//#include "basedll.h"
#endif

HANDLE BasepDefaultTimerQueue ;
ULONG BasepTimerQueueInitFlag ;
ULONG BasepTimerQueueDoneFlag ;

#if NOT_IN_TPOOL
HANDLE
APIENTRY
CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    DWORD dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    )

/*++

Routine Description:

    A thread object can be created to execute within the address space of the
    calling process using CreateThread.

    See CreateRemoteThread for a description of the arguments and return value.

--*/
{
    return CreateRemoteThread( NtCurrentProcess(),
                               lpThreadAttributes,
                               dwStackSize,
                               lpStartAddress,
                               lpParameter,
                               dwCreationFlags,
                               lpThreadId
                             );
}

HANDLE
APIENTRY
CreateRemoteThread(
    HANDLE hProcess,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    DWORD dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    )

/*++

Routine Description:

    A thread object can be created to execute within the address space of the
    another process using CreateRemoteThread.

    Creating a thread causes a new thread of execution to begin in the address
    space of the current process. The thread has access to all objects opened
    by the process.

    The thread begins executing at the address specified by the StartAddress
    parameter. If the thread returns from this procedure, the results are
    un-specified.

    The thread remains in the system until it has terminated and
    all handles to the thread
    have been closed through a call to CloseHandle.

    When a thread terminates, it attains a state of signaled satisfying all
    waits on the object.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the following
    object type specific access flags are valid for thread objects:

        - THREAD_QUERY_INFORMATION - This access is required to read
          certain information from the thread object.

        - SYNCHRONIZE - This access is required to wait on a thread
          object.

        - THREAD_GET_CONTEXT - This access is required to read the
          context of a thread using GetThreadContext.

        - THREAD_SET_CONTEXT - This access is required to write the
          context of a thread using SetThreadContext.

        - THREAD_SUSPEND_RESUME - This access is required to suspend or
          resume a thread using SuspendThread or ResumeThread.

        - THREAD_ALL_ACCESS - This set of access flags specifies all of
          the possible access flags for a thread object.

Arguments:

    hProcess - Supplies the handle to the process in which the thread is
        to be create in.

    lpThreadAttributes - An optional parameter that may be used to specify
        the attributes of the new thread.  If the parameter is not
        specified, then the thread is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation.

    dwStackSize - Supplies the size in bytes of the stack for the new thread.
        A value of zero specifies that the thread's stack size should be
        the same size as the stack size of the first thread in the process.
        This size is specified in the application's executable file.

    lpStartAddress - Supplies the starting address of the new thread.  The
        address is logically a procedure that never returns and that
        accepts a single 32-bit pointer argument.

    lpParameter - Supplies a single parameter value passed to the thread.

    dwCreationFlags - Supplies additional flags that control the creation
        of the thread.

        dwCreationFlags Flags:

        CREATE_SUSPENDED - The thread is created in a suspended state.
            The creator can resume this thread using ResumeThread.
            Until this is done, the thread will not begin execution.

    lpThreadId - Returns the thread identifier of the thread.  The
        thread ID is valid until the thread terminates.

Return Value:

    NON-NULL - Returns a handle to the new thread.  The handle has full
        access to the new thread and may be used in any API that
        requires a handle to a thread object.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    CONTEXT ThreadContext;
    INITIAL_TEB InitialTeb;
    CLIENT_ID ClientId;
    ULONG i;

#if !defined(BUILD_WOW6432)
    BASE_API_MSG m;
    PBASE_CREATETHREAD_MSG a = (PBASE_CREATETHREAD_MSG)&m.u.CreateThread;
#endif

#if defined(WX86) || defined(_AXP64_)
    BOOL bWx86 = FALSE;
    HANDLE Wx86Info;
    PWX86TIB Wx86Tib;
#endif



    //
    // Allocate a stack for this thread in the address space of the target
    // process.
    //

    Status = BaseCreateStack(
                hProcess,
                dwStackSize,
                0L,
                &InitialTeb
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
        }

    //
    // Create an initial context for the new thread.
    //

    BaseInitializeContext(
        &ThreadContext,
        lpParameter,
        (PVOID)lpStartAddress,
        InitialTeb.StackBase,
        BaseContextTypeThread
        );

    pObja = BaseFormatObjectAttributes(&Obja,lpThreadAttributes,NULL);


    Status = NtCreateThread(
                &Handle,
                THREAD_ALL_ACCESS,
                pObja,
                hProcess,
                &ClientId,
                &ThreadContext,
                &InitialTeb,
                TRUE
                );
    if (!NT_SUCCESS(Status)) {
        BaseFreeThreadStack(hProcess,NULL, &InitialTeb);
        BaseSetLastNTError(Status);
        return NULL;
        }



    try {


#if defined(WX86) || defined(_AXP64_)

        //
        // Check the Target Processes to see if this is a Wx86 process
        //
        Status = NtQueryInformationProcess(hProcess,
                                           ProcessWx86Information,
                                           &Wx86Info,
                                           sizeof(Wx86Info),
                                           NULL
                                           );
        if (!NT_SUCCESS(Status)) {
            leave;
            }

        Wx86Tib = (PWX86TIB)NtCurrentTeb()->Vdm;

        //
        // if Wx86 process, setup for emulation
        //
        if ((ULONG_PTR)Wx86Info == sizeof(WX86TIB)) {

            //
            // create a WX86Tib and initialize it's Teb->Vdm.
            //
            Status = BaseCreateWx86Tib(hProcess,
                                       Handle,
                                       (ULONG)((ULONG_PTR)lpStartAddress),
                                       dwStackSize,
                                       0L,
                                       (Wx86Tib &&
                                        Wx86Tib->Size == sizeof(WX86TIB) &&
                                        Wx86Tib->EmulateInitialPc)
                                       );
            if (!NT_SUCCESS(Status)) {
                leave;
                }

            bWx86 = TRUE;

            }
        else if (Wx86Tib && Wx86Tib->EmulateInitialPc) {

            //
            // if not Wx86 process, and caller wants to call x86 code in that
            // process, fail the call.
            //
            Status = STATUS_ACCESS_DENIED;
            leave;

            }

#endif  // WX86


        //
        // Call the Windows server to let it know about the
        // process.
        //
        if ( !BaseRunningInServerProcess ) {

#if defined(BUILD_WOW6432)
            Status = CsrBasepCreateThread(Handle,
                                          ClientId
                                          );
#else
            a->ThreadHandle = Handle;
            a->ClientId = ClientId;
            CsrClientCallServer( (PCSR_API_MSG)&m,
                                 NULL,
                                 CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                      BasepCreateThread
                                                    ),
                                 sizeof( *a )
                               );

            Status = m.ReturnValue;
#endif
        }

        else {
            if (hProcess != NtCurrentProcess()) {
                CSRREMOTEPROCPROC ProcAddress;
                ProcAddress = (CSRREMOTEPROCPROC)GetProcAddress(
                                                    GetModuleHandleA("csrsrv"),
                                                    "CsrCreateRemoteThread"
                                                    );
                if (ProcAddress) {
                    Status = (ProcAddress)(Handle, &ClientId);
                    }
                }
            }


        if (!NT_SUCCESS(Status)) {
            Status = (NTSTATUS)STATUS_NO_MEMORY;
            }
        else {

            if ( ARGUMENT_PRESENT(lpThreadId) ) {
                *lpThreadId = HandleToUlong(ClientId.UniqueThread);
                }

            if (!( dwCreationFlags & CREATE_SUSPENDED) ) {
                NtResumeThread(Handle,&i);
                }
            }

        }
    finally {
        if (!NT_SUCCESS(Status)) {
            BaseFreeThreadStack(hProcess,
                                Handle,
                                &InitialTeb
                                );

            NtTerminateThread(Handle, Status);
            NtClose(Handle);
            BaseSetLastNTError(Status);
            Handle = NULL;
            }
        }


    return Handle;

}

#endif // NOT_IN_TPOOL

NTSTATUS
NTAPI
BaseCreateThreadPoolThread(
    PUSER_THREAD_START_ROUTINE Function,
    HANDLE * ThreadHandle
    )
{
    ULONG Initialized ;
    LARGE_INTEGER TimeOut ;
    DWORD tid ;

    Initialized = FALSE ;

    *ThreadHandle = CreateRemoteThread(
                        NtCurrentProcess(),
                        NULL,
                        0,
                        (LPTHREAD_START_ROUTINE) Function,
                        &Initialized,
                        0,
                        &tid );

    //
    // The thread will set the Initialized flag to 1 when it is initialized.  We
    // cycle here, yielding our quantum until

    if ( *ThreadHandle ) {

        TimeOut.QuadPart = -1 * ( 10 * 10000 ) ;

        while (! (volatile ULONG) Initialized) {

            NtDelayExecution (FALSE, &TimeOut) ;

        }

        if (Initialized == 1)
            return STATUS_SUCCESS ;

    }

    return NtCurrentTeb()->LastStatusValue ;
}

NTSTATUS
NTAPI
BaseExitThreadPoolThread(
    NTSTATUS Status
    )
{
    ExitThread( (DWORD) Status );
    return STATUS_SUCCESS ;
}

#if NOT_IN_TPOOL

HANDLE
WINAPI
OpenThread(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwThreadId
    )

/*++

Routine Description:

    A handle to a thread object may be created using OpenThread.

    Opening a thread creates a handle to the specified thread.
    Associated with the thread handle is a set of access rights that
    may be performed using the thread handle.  The caller specifies the
    desired access to the thread using the DesiredAccess parameter.

Arguments:

    mDesiredAccess - Supplies the desired access to the thread object.
        For NT/Win32, this access is checked against any security
        descriptor on the target thread.  The following object type
        specific access flags can be specified in addition to the
        STANDARD_RIGHTS_REQUIRED access flags.

        DesiredAccess Flags:

        THREAD_TERMINATE - This access is required to terminate the
            thread using TerminateThread.

        THREAD_SUSPEND_RESUME - This access is required to suspend and
            resume the thread using SuspendThread and ResumeThread.

        THREAD_GET_CONTEXT - This access is required to use the
            GetThreadContext API on a thread object.

        THREAD_SET_CONTEXT - This access is required to use the
            SetThreadContext API on a thread object.

        THREAD_SET_INFORMATION - This access is required to set certain
            information in the thread object.

        THREAD_SET_THREAD_TOKEN - This access is required to set the
            thread token using SetTokenInformation.

        THREAD_QUERY_INFORMATION - This access is required to read
            certain information from the thread object.

        SYNCHRONIZE - This access is required to wait on a thread object.

        THREAD_ALL_ACCESS - This set of access flags specifies all of the
            possible access flags for a thread object.

    bInheritHandle - Supplies a flag that indicates whether or not the
        returned handle is to be inherited by a new process during
        process creation.  A value of TRUE indicates that the new
        process will inherit the handle.

    dwThreadId - Supplies the thread id of the thread to open.

Return Value:

    NON-NULL - Returns an open handle to the specified thread.  The
        handle may be used by the calling process in any API that
        requires a handle to a thread.  If the open is successful, the
        handle is granted access to the thread object only to the
        extent that it requested access through the DesiredAccess
        parameter.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    CLIENT_ID ClientId;

    ClientId.UniqueThread = (HANDLE)dwThreadId;
    ClientId.UniqueProcess = (HANDLE)NULL;

    InitializeObjectAttributes(
        &Obja,
        NULL,
        (bInheritHandle ? OBJ_INHERIT : 0),
        NULL,
        NULL
        );
    Status = NtOpenThread(
                &Handle,
                (ACCESS_MASK)dwDesiredAccess,
                &Obja,
                &ClientId
                );
    if ( NT_SUCCESS(Status) ) {
        return Handle;
        }
    else {
        BaseSetLastNTError(Status);
        return NULL;
        }
}


BOOL
APIENTRY
SetThreadPriority(
    HANDLE hThread,
    int nPriority
    )

/*++

Routine Description:

    The specified thread's priority can be set using SetThreadPriority.

    A thread's priority may be set using SetThreadPriority.  This call
    allows the thread's relative execution importance to be communicated
    to the system.  The system normally schedules threads according to
    their priority.  The system is free to temporarily boost the
    priority of a thread when signifigant events occur (e.g.  keyboard
    or mouse input...).  Similarly, as a thread runs without blocking,
    the system will decay its priority.  The system will never decay the
    priority below the value set by this call.

    In the absence of system originated priority boosts, threads will be
    scheduled in a round-robin fashion at each priority level from
    THREAD_PRIORITY_TIME_CRITICAL to THREAD_PRIORITY_IDLE.  Only when there
    are no runnable threads at a higher level, will scheduling of
    threads at a lower level take place.

    All threads initially start at THREAD_PRIORITY_NORMAL.

    If for some reason the thread needs more priority, it can be
    switched to THREAD_PRIORITY_ABOVE_NORMAL or THREAD_PRIORITY_HIGHEST.
    Switching to THREAD_PRIORITY_TIME_CRITICAL should only be done in extreme
    situations.  Since these threads are given the highes priority, they
    should only run in short bursts.  Running for long durations will
    soak up the systems processing bandwidth starving threads at lower
    levels.

    If a thread needs to do low priority work, or should only run there
    is nothing else to do, its priority should be set to
    THREAD_PRIORITY_BELOW_NORMAL or THREAD_PRIORITY_LOWEST.  For extreme
    cases, THREAD_PRIORITY_IDLE can be used.

    Care must be taken when manipulating priorites.  If priorities are
    used carelessly (every thread is set to THREAD_PRIORITY_TIME_CRITICAL),
    the effects of priority modifications can produce undesireable
    effects (e.g.  starvation, no effect...).

Arguments:

    hThread - Supplies a handle to the thread whose priority is to be
        set.  The handle must have been created with
        THREAD_SET_INFORMATION access.

    nPriority - Supplies the priority value for the thread.  The
        following five priority values (ordered from lowest priority to
        highest priority) are allowed.

        nPriority Values:

        THREAD_PRIORITY_IDLE - The thread's priority should be set to
            the lowest possible settable priority.

        THREAD_PRIORITY_LOWEST - The thread's priority should be set to
            the next lowest possible settable priority.

        THREAD_PRIORITY_BELOW_NORMAL - The thread's priority should be
            set to just below normal.

        THREAD_PRIORITY_NORMAL - The thread's priority should be set to
            the normal priority value.  This is the value that all
            threads begin execution at.

        THREAD_PRIORITY_ABOVE_NORMAL - The thread's priority should be
            set to just above normal priority.

        THREAD_PRIORITY_HIGHEST - The thread's priority should be set to
            the next highest possible settable priority.

        THREAD_PRIORITY_TIME_CRITICAL - The thread's priority should be set
            to the highest possible settable priority.  This priority is
            very likely to interfere with normal operation of the
            system.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.
--*/

{
    NTSTATUS Status;
    LONG BasePriority;

    BasePriority = (LONG)nPriority;


    //
    // saturation is indicated by calling with a value of 16 or -16
    //

    if ( BasePriority == THREAD_PRIORITY_TIME_CRITICAL ) {
        BasePriority = ((HIGH_PRIORITY + 1) / 2);
        }
    else if ( BasePriority == THREAD_PRIORITY_IDLE ) {
        BasePriority = -((HIGH_PRIORITY + 1) / 2);
        }
    Status = NtSetInformationThread(
                hThread,
                ThreadBasePriority,
                &BasePriority,
                sizeof(BasePriority)
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return TRUE;
}

int
APIENTRY
GetThreadPriority(
    HANDLE hThread
    )

/*++

Routine Description:

    The specified thread's priority can be read using GetThreadPriority.

Arguments:

    hThread - Supplies a handle to the thread whose priority is to be
        set.  The handle must have been created with
        THREAD_QUERY_INFORMATION access.

Return Value:

    The value of the thread's current priority is returned.  If an error
    occured, the value THREAD_PRIORITY_ERROR_RETURN is returned.
    Extended error status is available using GetLastError.

--*/

{
    NTSTATUS Status;
    THREAD_BASIC_INFORMATION BasicInfo;
    int returnvalue;

    Status = NtQueryInformationThread(
                hThread,
                ThreadBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return (int)THREAD_PRIORITY_ERROR_RETURN;
        }

    returnvalue = (int)BasicInfo.BasePriority;
    if ( returnvalue > THREAD_BASE_PRIORITY_MAX ) {
        returnvalue = THREAD_PRIORITY_TIME_CRITICAL;
        }
    else if ( returnvalue < THREAD_BASE_PRIORITY_MIN ) {
        returnvalue = THREAD_PRIORITY_IDLE;
        }
    return returnvalue;
}

BOOL
WINAPI
SetThreadPriorityBoost(
    HANDLE hThread,
    BOOL bDisablePriorityBoost
    )
{
    NTSTATUS Status;
    ULONG DisableBoost;

    DisableBoost = bDisablePriorityBoost ? 1 : 0;

    Status = NtSetInformationThread(
                hThread,
                ThreadPriorityBoost,
                &DisableBoost,
                sizeof(DisableBoost)
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return TRUE;

}

BOOL
WINAPI
GetThreadPriorityBoost(
    HANDLE hThread,
    PBOOL pDisablePriorityBoost
    )
{
    NTSTATUS Status;
    DWORD DisableBoost;

    Status = NtQueryInformationThread(
                hThread,
                ThreadPriorityBoost,
                &DisableBoost,
                sizeof(DisableBoost),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }


    *pDisablePriorityBoost = DisableBoost;

    return TRUE;
}

VOID
APIENTRY
ExitThread(
    DWORD dwExitCode
    )

/*++

Routine Description:

    The current thread can exit using ExitThread.

    ExitThread is the prefered method of exiting a thread.  When this
    API is called (either explicitly or by returning from a thread
    procedure), The current thread's stack is deallocated and the thread
    terminates.  If the thread is the last thread in the process when
    this API is called, the behavior of this API does not change.  DLLs
    are not notified as a result of a call to ExitThread.

Arguments:

    dwExitCode - Supplies the termination status for the thread.

Return Value:

    None.

--*/

{
    MEMORY_BASIC_INFORMATION MemInfo;
    NTSTATUS st;
    ULONG LastThread;

#if DBG
    PRTL_CRITICAL_SECTION LoaderLock;

    //
    // Assert on exiting while holding loader lock
    //
    LoaderLock = NtCurrentPeb()->LoaderLock;
    if (LoaderLock) {
        ASSERT(NtCurrentTeb()->ClientId.UniqueThread != LoaderLock->OwningThread);
        }
#endif
    st = NtQueryInformationThread(
            NtCurrentThread(),
            ThreadAmILastThread,
            &LastThread,
            sizeof(LastThread),
            NULL
            );
    if ( st == STATUS_SUCCESS && LastThread ) {
        ExitProcess(dwExitCode);
        }
    else {
#if DBG
        RtlCheckForOrphanedCriticalSections(NtCurrentThread());
#endif
        LdrShutdownThread();
        if ( NtCurrentTeb()->TlsExpansionSlots ) {
            //
            // Serialize with TlsXXX functions so the kernel code that zero's tls slots
            // wont' trash heap
            //
            RtlAcquirePebLock();
            try {
                RtlFreeHeap(RtlProcessHeap(),0,NtCurrentTeb()->TlsExpansionSlots);
                NtCurrentTeb()->TlsExpansionSlots = NULL;
                }
            finally {
                RtlReleasePebLock();
                }
            }
        st = NtQueryVirtualMemory(
                NtCurrentProcess(),
                NtCurrentTeb()->NtTib.StackLimit,
                MemoryBasicInformation,
                (PVOID)&MemInfo,
                sizeof(MemInfo),
                NULL
                );
        if ( !NT_SUCCESS(st) ) {
            RtlRaiseStatus(st);
            }

#ifdef _ALPHA_
        //
        // Note stacks on Alpha must be octaword aligned. Probably
        // a good idea on other platforms as well.
        //
        BaseSwitchStackThenTerminate(
            MemInfo.AllocationBase,
            (PVOID)(((ULONG_PTR)&NtCurrentTeb()->User32Reserved[0] - 0x10) & ~0xf),
            dwExitCode
            );
#else // _ALPHA
        //
        // Note stacks on i386 need not be octaword aligned.
        //
        BaseSwitchStackThenTerminate(
            MemInfo.AllocationBase,
            &NtCurrentTeb()->UserReserved[0],
            dwExitCode
            );
#endif // _ALPHA_
        }
}



BOOL
APIENTRY
TerminateThread(
    HANDLE hThread,
    DWORD dwExitCode
    )

/*++

Routine Description:

    A thread may be terminated using TerminateThread.

    TerminateThread is used to cause a thread to terminate user-mode
    execution.  There is nothing a thread can to to predict or prevent
    when this occurs.  If a process has a handle with appropriate
    termination access to the thread or to the threads process, then the
    thread can be unconditionally terminated without notice.  When this
    occurs, the target thread has no chance to execute any user-mode
    code and its initial stack is not deallocated.  The thread attains a
    state of signaled satisfying any waits on the thread.  The thread's
    termination status is updated from its initial value of
    STATUS_PENDING to the value of the TerminationStatus parameter.
    Terminating a thread does not remove a thread from the system.  The
    thread is not removed from the system until the last handle to the
    thread is closed.

Arguments:

    hThread - Supplies a handle to the thread to terminate.  The handle
        must have been created with THREAD_TERMINATE access.

    dwExitCode - Supplies the termination status for the thread.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    NTSTATUS Status;
#if DBG
    PRTL_CRITICAL_SECTION LoaderLock;
    HANDLE ThreadId;
    THREAD_BASIC_INFORMATION ThreadInfo;
#endif

    if ( hThread == NULL ) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
        }
#if DBG
    //
    // Assert on suicide while holding loader lock
    //
    LoaderLock = NtCurrentPeb()->LoaderLock;
    if (LoaderLock) {
        Status = NtQueryInformationThread(
                                hThread,
                                ThreadBasicInformation,
                                &ThreadInfo,
                                sizeof(ThreadInfo),
                                NULL
                                );

        if (NT_SUCCESS(Status)) {
            ASSERT( NtCurrentTeb()->ClientId.UniqueThread != ThreadInfo.ClientId.UniqueThread ||
                    NtCurrentTeb()->ClientId.UniqueThread != LoaderLock->OwningThread);
            }
        }
    RtlCheckForOrphanedCriticalSections(hThread);
#endif

    Status = NtTerminateThread(hThread,(NTSTATUS)dwExitCode);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}


BOOL
APIENTRY
GetExitCodeThread(
    HANDLE hThread,
    LPDWORD lpExitCode
    )

/*++

Routine Description:

    The termination status of a thread can be read using
    GetExitCodeThread.

    If a Thread is in the signaled state, calling this function returns
    the termination status of the thread.  If the thread is not yet
    signaled, the termination status returned is STILL_ACTIVE.

Arguments:

    hThread - Supplies a handle to the thread whose termination status is
        to be read.  The handle must have been created with
        THREAD_QUERY_INFORMATION access.

    lpExitCode - Returns the current termination status of the
        thread.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    THREAD_BASIC_INFORMATION BasicInformation;

    Status = NtQueryInformationThread(
                hThread,
                ThreadBasicInformation,
                &BasicInformation,
                sizeof(BasicInformation),
                NULL
                );

    if ( NT_SUCCESS(Status) ) {
        *lpExitCode = BasicInformation.ExitStatus;
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

HANDLE
APIENTRY
GetCurrentThread(
    VOID
    )

/*++

Routine Description:

    A pseudo handle to the current thread may be retrieved using
    GetCurrentThread.

    A special constant is exported by Win32 that is interpreted as a
    handle to the current thread.  This handle may be used to specify
    the current thread whenever a thread handle is required.  On Win32,
    this handle has THREAD_ALL_ACCESS to the current thread.  On
    NT/Win32, this handle has the maximum access allowed by any security
    descriptor placed on the current thread.

Arguments:

    None.

Return Value:

    Returns the pseudo handle of the current thread.

--*/

{
    return NtCurrentThread();
}

DWORD
APIENTRY
GetCurrentThreadId(
    VOID
    )

/*++

Routine Description:

The thread ID of the current thread may be retrieved using
GetCurrentThreadId.

Arguments:

    None.

Return Value:

    Returns a unique value representing the thread ID of the currently
    executing thread.  The return value may be used to identify a thread
    in the system.

--*/

{
    return HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread);
}

BOOL
APIENTRY
GetThreadContext(
    HANDLE hThread,
    LPCONTEXT lpContext
    )

/*++

Routine Description:

    The context of a specified thread can be retreived using
    GetThreadContext.

    This function is used to retreive the context of the specified
    thread.  The API allows selective context to be retrieved based on
    the value of the ContextFlags field of the context structure.  The
    specified thread does not have to be being debugged in order for
    this API to operate.  The caller must simply have a handle to the
    thread that was created with THREAD_GET_CONTEXT access.

Arguments:

    hThread - Supplies an open handle to a thread whose context is to be
        retreived.  The handle must have been created with
        THREAD_GET_CONTEXT access to the thread.

    lpContext - Supplies the address of a context structure that
        receives the appropriate context of the specified thread.  The
        value of the ContextFlags field of this structure specifies
        which portions of a threads context are to be retreived.  The
        context structure is highly machine specific.  There are
        currently two versions of the context structure.  One version
        exists for x86 processors, and another exists for MIPS
        processors.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;

    Status = NtGetContextThread(hThread,lpContext);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    else {
        return TRUE;
        }
}

BOOL
APIENTRY
SetThreadContext(
    HANDLE hThread,
    CONST CONTEXT *lpContext
    )

/*++

Routine Description:

    This function is used to set the context in the specified thread.
    The API allows selective context to be set based on the value of the
    ContextFlags field of the context structure.  The specified thread
    does not have to be being debugged in order for this API to operate.
    The caller must simply have a handle to the thread that was created
    with THREAD_SET_CONTEXT access.

Arguments:

    hThread - Supplies an open handle to a thread whose context is to be
        written.  The handle must have been created with
        THREAD_SET_CONTEXT access to the thread.

    lpContext - Supplies the address of a context structure that
        contains the context that is to be set in the specified thread.
        The value of the ContextFlags field of this structure specifies
        which portions of a threads context are to be set.  Some values
        in the context structure are not settable and are silently set
        to the correct value.  This includes cpu status register bits
        that specify the priviledged processor mode, debug register
        global enabling bits, and other state that must be completely
        controlled by the operating system.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtSetContextThread(hThread,(PCONTEXT)lpContext);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    else {
        return TRUE;
        }
}

DWORD
APIENTRY
SuspendThread(
    HANDLE hThread
    )

/*++

Routine Description:

    A thread can be suspended using SuspendThread.

    Suspending a thread causes the thread to stop executing user-mode
    (or application) code.  Each thread has a suspend count (with a
    maximum value of MAXIMUM_SUSPEND_COUNT).  If the suspend count is
    greater than zero, the thread is suspended; otherwise, the thread is
    not suspended and is eligible for execution.

    Calling SuspendThread causes the target thread's suspend count to
    increment.  Attempting to increment past the maximum suspend count
    causes an error without incrementing the count.

Arguments:

    hThread - Supplies a handle to the thread that is to be suspended.
        The handle must have been created with THREAD_SUSPEND_RESUME
        access to the thread.

Return Value:

    -1 - The operation failed.  Extended error status is available using
         GetLastError.

    Other - The target thread was suspended. The return value is the thread's
        previous suspend count.

--*/

{
    NTSTATUS Status;
    DWORD PreviousSuspendCount;

    Status = NtSuspendThread(hThread,&PreviousSuspendCount);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return (DWORD)-1;
        }
    else {
        return PreviousSuspendCount;
        }
}

DWORD
APIENTRY
ResumeThread(
    IN HANDLE hThread
    )

/*++

Routine Description:

    A thread can be resumed using ResumeThread.

    Resuming a thread object checks the suspend count of the subject
    thread.  If the suspend count is zero, then the thread is not
    currently suspended and no operation is performed.  Otherwise, the
    subject thread's suspend count is decremented.  If the resultant
    value is zero , then the execution of the subject thread is resumed.

    The previous suspend count is returned as the function value.  If
    the return value is zero, then the subject thread was not previously
    suspended.  If the return value is one, then the subject thread's
    the subject thread is still suspended and must be resumed the number
    of times specified by the return value minus one before it will
    actually resume execution.

    Note that while reporting debug events, all threads withing the
    reporting process are frozen.  This has nothing to do with
    SuspendThread or ResumeThread.  Debuggers are expected to use
    SuspendThread and ResumeThread to limit the set of threads that can
    execute within a process.  By suspending all threads in a process
    except for the one reporting a debug event, it is possible to
    "single step" a single thread.  The other threads will not be
    released by a continue if they are suspended.

Arguments:

    hThread - Supplies a handle to the thread that is to be resumed.
        The handle must have been created with THREAD_SUSPEND_RESUME
        access to the thread.

Return Value:

    -1 - The operation failed.  Extended error status is available using
        GetLastError.

    Other - The target thread was resumed (or was not previously
        suspended).  The return value is the thread's previous suspend
        count.

--*/

{
    NTSTATUS Status;
    DWORD PreviousSuspendCount;

    Status = NtResumeThread(hThread,&PreviousSuspendCount);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return (DWORD)-1;
        }
    else {
        return PreviousSuspendCount;
        }
}

VOID
APIENTRY
RaiseException(
    DWORD dwExceptionCode,
    DWORD dwExceptionFlags,
    DWORD nNumberOfArguments,
    CONST ULONG_PTR *lpArguments
    )

/*++

Routine Description:

    Raising an exception causes the exception dispatcher to go through
    its search for an exception handler.  This includes debugger
    notification, frame based handler searching, and system default
    actions.

Arguments:

    dwExceptionCode - Supplies the exception code of the exception being
        raised.  This value may be obtained in exception filters and in
        exception handlers by calling GetExceptionCode.

    dwExceptionFlags - Supplies a set of flags associated with the exception.

    dwExceptionFlags Flags:

        EXCEPTION_NONCONTINUABLE - The exception is non-continuable.
            Returning EXCEPTION_CONTINUE_EXECUTION from an exception
            marked in this way causes the
            STATUS_NONCONTINUABLE_EXCEPTION exception.

    nNumberOfArguments - Supplies the number of arguments associated
        with the exception.  This value may not exceed
        EXCEPTION_MAXIMUM_PARAMETERS.  This parameter is ignored if
        lpArguments is NULL.

    lpArguments - An optional parameter, that if present supplies the
        arguments for the exception.

Return Value:

    None.

--*/

{
    EXCEPTION_RECORD ExceptionRecord;
    ULONG n;
    PULONG_PTR s,d;
    ExceptionRecord.ExceptionCode = (DWORD)dwExceptionCode;
    ExceptionRecord.ExceptionFlags = dwExceptionFlags & EXCEPTION_NONCONTINUABLE;
    ExceptionRecord.ExceptionRecord = NULL;
    ExceptionRecord.ExceptionAddress = (PVOID)RaiseException;
    if ( ARGUMENT_PRESENT(lpArguments) ) {
        n =  nNumberOfArguments;
        if ( n > EXCEPTION_MAXIMUM_PARAMETERS ) {
            n = EXCEPTION_MAXIMUM_PARAMETERS;
            }
        ExceptionRecord.NumberParameters = n;
        s = (PULONG_PTR)lpArguments;
        d = ExceptionRecord.ExceptionInformation;
        while(n--){
            *d++ = *s++;
            }
        }
    else {
        ExceptionRecord.NumberParameters = 0;
        }
    RtlRaiseException(&ExceptionRecord);
}


UINT
GetErrorMode();

BOOLEAN BasepAlreadyHadHardError = FALSE;

LPTOP_LEVEL_EXCEPTION_FILTER BasepCurrentTopLevelFilter;

LPTOP_LEVEL_EXCEPTION_FILTER
WINAPI
SetUnhandledExceptionFilter(
    LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    )

/*++

Routine Description:

    This function allows an application to supersede the top level
    exception handler that Win32 places at the top of each thread and
    process.

    If an exception occurs, and it makes it to the Win32 unhandled
    exception filter, and the process is not being debugged, the Win32
    filter will call the unhandled exception filter specified by
    lpTopLevelExceptionFilter.

    This filter may return:

        EXCEPTION_EXECUTE_HANDLER - Return from the Win32
            UnhandledExceptionFilter and execute the associated
            exception handler.  This will usually result in process
            termination

        EXCEPTION_CONTINUE_EXECUTION - Return from the Win32
            UnhandledExceptionFilter and continue execution from the
            point of the exception.  The filter is of course free to
            modify the continuation state my modifying the passed
            exception information.

        EXCEPTION_CONTINUE_SEARCH - Proceed with normal execution of the
            Win32 UnhandledExceptionFilter.  e.g.  obey the SetErrorMode
            flags, or invoke the Application Error popup.

    This function is not a general vectored exception handling
    mechanism.  It is intended to be used to establish a per-process
    exception filter that can monitor unhandled exceptions at the
    process level and respond to these exceptions appropriately.

Arguments:

    lpTopLevelExceptionFilter - Supplies the address of a top level
        filter function that will be called whenever the Win32
        UnhandledExceptionFilter gets control, and the process is NOT
        being debugged.  A value of NULL specifies default handling
        within the Win32 UnhandledExceptionFilter.


Return Value:

    This function returns the address of the previous exception filter
    established with this API.  A value of NULL means that there is no
    current top level handler.

--*/

{
    LPTOP_LEVEL_EXCEPTION_FILTER PreviousTopLevelFilter;

    PreviousTopLevelFilter = BasepCurrentTopLevelFilter;
    BasepCurrentTopLevelFilter = lpTopLevelExceptionFilter;

    return PreviousTopLevelFilter;
}

LONG
BasepCheckForReadOnlyResource(
    PVOID Va
    )
{
    SIZE_T RegionSize;
    ULONG OldProtect;
    NTSTATUS Status;
    MEMORY_BASIC_INFORMATION MemInfo;
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory;
    ULONG ResourceSize;
    char *rbase, *va;
    LONG ReturnValue;

    //
    // Locate the base address that continas this va
    //

    Status = NtQueryVirtualMemory(
                NtCurrentProcess(),
                Va,
                MemoryBasicInformation,
                (PVOID)&MemInfo,
                sizeof(MemInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return EXCEPTION_CONTINUE_SEARCH;
        }

    //
    // if the va is readonly and in an image then continue
    //

    if ( !((MemInfo.Protect == PAGE_READONLY) && (MemInfo.Type == MEM_IMAGE)) ){
        return EXCEPTION_CONTINUE_SEARCH;
        }

    ReturnValue = EXCEPTION_CONTINUE_SEARCH;

    try {
        ResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
            RtlImageDirectoryEntryToData(MemInfo.AllocationBase,
                                         TRUE,
                                         IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                         &ResourceSize
                                         );

        rbase = (char *)ResourceDirectory;
        va = (char *)Va;

        if ( rbase && va >= rbase && va < rbase+ResourceSize ) {
            RegionSize = 1;
            Status = NtProtectVirtualMemory(
                        NtCurrentProcess(),
                        &va,
                        &RegionSize,
                        PAGE_READWRITE,
                        &OldProtect
                        );
            if ( NT_SUCCESS(Status) ) {
                ReturnValue = EXCEPTION_CONTINUE_EXECUTION;
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ;
        }

    return ReturnValue;
}

LONG
UnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    NTSTATUS Status;
    ULONG_PTR Parameters[ 4 ];
    ULONG Response;
    HANDLE DebugPort;
    CHAR AeDebuggerCmdLine[256];
    CHAR AeAutoDebugString[8];
    BOOLEAN AeAutoDebug;
    ULONG ResponseFlag;
    LONG FilterReturn;
    PRTL_CRITICAL_SECTION PebLockPointer;
    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimit;

    //
    // If we take a write fault, then attampt to make the memory writable. If this
    // succeeds, then silently proceed
    //

    if ( ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_ACCESS_VIOLATION
        && ExceptionInfo->ExceptionRecord->ExceptionInformation[0] ) {

        FilterReturn = BasepCheckForReadOnlyResource((PVOID)ExceptionInfo->ExceptionRecord->ExceptionInformation[1]);

        if ( FilterReturn == EXCEPTION_CONTINUE_EXECUTION ) {
            return FilterReturn;
            }
        }

    //
    // If the process is being debugged, just let the exception happen
    // so that the debugger can see it. This way the debugger can ignore
    // all first chance exceptions.
    //

    DebugPort = (HANDLE)NULL;
    Status = NtQueryInformationProcess(
                GetCurrentProcess(),
                ProcessDebugPort,
                (PVOID)&DebugPort,
                sizeof(DebugPort),
                NULL
                );

    if ( BasepCurrentTopLevelFilter ) {
        FilterReturn = (BasepCurrentTopLevelFilter)(ExceptionInfo);
        if ( FilterReturn == EXCEPTION_EXECUTE_HANDLER ||
             FilterReturn == EXCEPTION_CONTINUE_EXECUTION ) {
            return FilterReturn;
            }
        }

    if ( NT_SUCCESS(Status) && DebugPort ) {

        //
        // Process is being debugged.
        // Return a code that specifies that the exception
        // processing is to continue
        //
        return EXCEPTION_CONTINUE_SEARCH;
        }

    if ( GetErrorMode() & SEM_NOGPFAULTERRORBOX ) {
        return EXCEPTION_EXECUTE_HANDLER;
        }

    //
    // See if the process's job has been programmed to NOGPFAULTERRORBOX
    //
    Status = NtQueryInformationJobObject(
                NULL,
                JobObjectBasicLimitInformation,
                &BasicLimit,
                sizeof(BasicLimit),
                NULL
                );
    if ( NT_SUCCESS(Status) && (BasicLimit.LimitFlags & JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION) ) {
        return EXCEPTION_EXECUTE_HANDLER;
        }

    //
    // The process is not being debugged, so do the hard error
    // popup.
    //

    Parameters[ 0 ] = (ULONG_PTR)ExceptionInfo->ExceptionRecord->ExceptionCode;
    Parameters[ 1 ] = (ULONG_PTR)ExceptionInfo->ExceptionRecord->ExceptionAddress;

    //
    // For inpage i/o errors, juggle the real status code to overwrite the
    // read/write field
    //

    if ( ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_IN_PAGE_ERROR ) {
        Parameters[ 2 ] = ExceptionInfo->ExceptionRecord->ExceptionInformation[ 2 ];
        }
    else {
        Parameters[ 2 ] = ExceptionInfo->ExceptionRecord->ExceptionInformation[ 0 ];
        }

    Parameters[ 3 ] = ExceptionInfo->ExceptionRecord->ExceptionInformation[ 1 ];

    //
    // See if a debugger has been programmed in. If so, use the
    // debugger specified. If not then there is no AE Cancel support
    // DEVL systems will default the debugger command line. Retail
    // systems will not.
    //

    ResponseFlag = OptionOk;
    AeAutoDebug = FALSE;

    //
    // If we are holding the PebLock, then the createprocess will fail
    // because a new thread will also need this lock. Avoid this by peeking
    // inside the PebLock and looking to see if we own it. If we do, then just allow
    // a regular popup.
    //

    PebLockPointer = NtCurrentPeb()->FastPebLock;

    if ( PebLockPointer->OwningThread != NtCurrentTeb()->ClientId.UniqueThread ) {

        try {
            if ( GetProfileString(
                    "AeDebug",
                    "Debugger",
                    NULL,
                    AeDebuggerCmdLine,
                    sizeof(AeDebuggerCmdLine)-1
                    ) ) {
                ResponseFlag = OptionOkCancel;
                }

            if ( GetProfileString(
                    "AeDebug",
                    "Auto",
                    "0",
                    AeAutoDebugString,
                    sizeof(AeAutoDebugString)-1
                    ) ) {

                if ( !strcmp(AeAutoDebugString,"1") ) {
                    if ( ResponseFlag == OptionOkCancel ) {
                        AeAutoDebug = TRUE;
                        }
                    }
                }
            }
        except (EXCEPTION_EXECUTE_HANDLER) {
            ResponseFlag = OptionOk;
            AeAutoDebug = FALSE;
            }
        }
    if ( !AeAutoDebug ) {
        Status =NtRaiseHardError( STATUS_UNHANDLED_EXCEPTION | HARDERROR_OVERRIDE_ERRORMODE,
                                  4,
                                  0,
                                  Parameters,
                                  BasepAlreadyHadHardError ? OptionOk : ResponseFlag,
                                  &Response
                                );

        }
    else {
        Status = STATUS_SUCCESS;
        Response = ResponseCancel;
        }

    //
    // Internally, send OkCancel. If we get back Ok then die.
    // If we get back Cancel, then enter the debugger
    //

    if ( NT_SUCCESS(Status) && Response == ResponseCancel && BasepAlreadyHadHardError == FALSE) {
        if ( !BaseRunningInServerProcess ) {
            BOOL b;
            STARTUPINFO StartupInfo;
            PROCESS_INFORMATION ProcessInformation;
            CHAR CmdLine[256];
            NTSTATUS Status;
            HANDLE EventHandle;
            SECURITY_ATTRIBUTES sa;

            BasepAlreadyHadHardError = TRUE;
            sa.nLength = sizeof(sa);
            sa.lpSecurityDescriptor = NULL;
            sa.bInheritHandle = TRUE;
            EventHandle = CreateEvent(&sa,TRUE,FALSE,NULL);
            RtlZeroMemory(&StartupInfo,sizeof(StartupInfo));
            sprintf(CmdLine,AeDebuggerCmdLine,GetCurrentProcessId(),EventHandle);
            StartupInfo.cb = sizeof(StartupInfo);
            StartupInfo.lpDesktop = "Winsta0\\Default";
            CsrIdentifyAlertableThread();
            b =  CreateProcess(
                    NULL,
                    CmdLine,
                    NULL,
                    NULL,
                    TRUE,
                    0,
                    NULL,
                    NULL,
                    &StartupInfo,
                    &ProcessInformation
                    );

            if ( b && EventHandle) {

                //
                // Do an alertable wait on the event
                //

                do {
                    Status = NtWaitForSingleObject(
                                EventHandle,
                                TRUE,
                                NULL
                                );
                    } while (Status == STATUS_USER_APC || Status == STATUS_ALERTED);
                return EXCEPTION_CONTINUE_SEARCH;
                }

            }
        }

#if DBG
    if (!NT_SUCCESS( Status )) {
        DbgPrint( "BASEDLL: Unhandled exception: %lx  IP: %x\n",
                  ExceptionInfo->ExceptionRecord->ExceptionCode,
                  ExceptionInfo->ExceptionRecord->ExceptionAddress
                );
        }
#endif
    if ( BasepAlreadyHadHardError ) {
        NtTerminateProcess(NtCurrentProcess(),ExceptionInfo->ExceptionRecord->ExceptionCode);
        }
    return EXCEPTION_EXECUTE_HANDLER;
}


#define TLS_MASK 0x80000000


DWORD
APIENTRY
TlsAlloc(
    VOID
    )

/*++

Routine Description:

    A TLS index may be allocated using TlsAlloc.  Win32 garuntees a
    minimum number of TLS indexes are available in each process.  The
    constant TLS_MINIMUM_AVAILABLE defines the minimum number of
    available indexes.  This minimum is at least 64 for all Win32
    systems.

Arguments:

    None.

Return Value:

    Not-0xffffffff - Returns a TLS index that may be used in a
        subsequent call to TlsFree, TlsSetValue, or TlsGetValue.  The
        storage associated with the index is initialized to NULL.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    PPEB Peb;
    PTEB Teb;
    DWORD Index;

    Peb = NtCurrentPeb();
    Teb = NtCurrentTeb();

    RtlAcquirePebLock();
    try {

        Index = RtlFindClearBitsAndSet((PRTL_BITMAP)Peb->TlsBitmap,1,0);
        if ( Index == 0xffffffff ) {
            Index = RtlFindClearBitsAndSet((PRTL_BITMAP)Peb->TlsExpansionBitmap,1,0);
            if ( Index == 0xffffffff ) {
                BaseSetLastNTError(STATUS_NO_MEMORY);
                }
            else {
                if ( !Teb->TlsExpansionSlots ) {
                    Teb->TlsExpansionSlots = RtlAllocateHeap(
                                                RtlProcessHeap(),
                                                MAKE_TAG( TMP_TAG ) | HEAP_ZERO_MEMORY,
                                                TLS_EXPANSION_SLOTS * sizeof(PVOID)
                                                );
                    if ( !Teb->TlsExpansionSlots ) {
                        RtlClearBits((PRTL_BITMAP)Peb->TlsExpansionBitmap,Index,1);
                        Index = 0xffffffff;
                        BaseSetLastNTError(STATUS_NO_MEMORY);
                        return Index;
                        }
                    }
                Teb->TlsExpansionSlots[Index] = NULL;
                Index += TLS_MINIMUM_AVAILABLE;
                }
            }
        else {
            Teb->TlsSlots[Index] = NULL;
            }
        }
    finally {
        RtlReleasePebLock();
        }
#if DBG
    Index |= TLS_MASK;
#endif
    return Index;
}

LPVOID
APIENTRY
TlsGetValue(
    DWORD dwTlsIndex
    )

/*++

Routine Description:

    This function is used to retrive the value in the TLS storage
    associated with the specified index.

    If the index is valid this function clears the value returned by
    GetLastError(), and returns the value stored in the TLS slot
    associated with the specified index.  Otherwise a value of NULL is
    returned with GetLastError updated appropriately.

    It is expected, that DLLs will use TlsAlloc and TlsGetValue as
    follows:

      - Upon DLL initialization, a TLS index will be allocated using
        TlsAlloc.  The DLL will then allocate some dynamic storage and
        store its address in the TLS slot using TlsSetValue.  This
        completes the per thread initialization for the initial thread
        of the process.  The TLS index is stored in instance data for
        the DLL.

      - Each time a new thread attaches to the DLL, the DLL will
        allocate some dynamic storage and store its address in the TLS
        slot using TlsSetValue.  This completes the per thread
        initialization for the new thread.

      - Each time an initialized thread makes a DLL call requiring the
        TLS, the DLL will call TlsGetValue to get the TLS data for the
        thread.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAlloc.  The
        index specifies which TLS slot is to be located.  Translating a
        TlsIndex does not prevent a TlsFree call from proceding.

Return Value:

    NON-NULL - The function was successful. The value is the data stored
        in the TLS slot associated with the specified index.

    NULL - The operation failed, or the value associated with the
        specified index was NULL.  Extended error status is available
        using GetLastError.  If this returns non-zero, the index was
        invalid.

--*/
{
    PTEB Teb;
    LPVOID *Slot;

#if DBG
    // See if the Index passed in is from TlsAlloc or random goo...
    ASSERTMSG( "BASEDLL: Invalid TlsIndex passed to TlsGetValue\n", (dwTlsIndex & TLS_MASK));
    dwTlsIndex &= ~TLS_MASK;
#endif

    Teb = NtCurrentTeb();

    if ( dwTlsIndex < TLS_MINIMUM_AVAILABLE ) {
        Slot = &Teb->TlsSlots[dwTlsIndex];
        Teb->LastErrorValue = 0;
        return *Slot;
        }
    else {
        if ( dwTlsIndex >= TLS_MINIMUM_AVAILABLE+TLS_EXPANSION_SLOTS ) {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return NULL;
            }
        else {
            Teb->LastErrorValue = 0;
            if ( Teb->TlsExpansionSlots ) {
                return  Teb->TlsExpansionSlots[dwTlsIndex-TLS_MINIMUM_AVAILABLE];
                }
            else {
                return NULL;
                }
            }
        }
}

BOOL
APIENTRY
TlsSetValue(
    DWORD dwTlsIndex,
    LPVOID lpTlsValue
    )

/*++

Routine Description:

    This function is used to store a value in the TLS storage associated
    with the specified index.

    If the index is valid this function stores the value and returns
    TRUE. Otherwise a value of FALSE is returned.

    It is expected, that DLLs will use TlsAlloc and TlsSetValue as
    follows:

      - Upon DLL initialization, a TLS index will be allocated using
        TlsAlloc.  The DLL will then allocate some dynamic storage and
        store its address in the TLS slot using TlsSetValue.  This
        completes the per thread initialization for the initial thread
        of the process.  The TLS index is stored in instance data for
        the DLL.

      - Each time a new thread attaches to the DLL, the DLL will
        allocate some dynamic storage and store its address in the TLS
        slot using TlsSetValue.  This completes the per thread
        initialization for the new thread.

      - Each time an initialized thread makes a DLL call requiring the
        TLS, the DLL will call TlsGetValue to get the TLS data for the
        thread.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAlloc.  The
        index specifies which TLS slot is to be located.  Translating a
        TlsIndex does not prevent a TlsFree call from proceding.

    lpTlsValue - Supplies the value to be stored in the TLS Slot.

Return Value:

    TRUE - The function was successful. The value lpTlsValue was
        stored.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PTEB Teb;

#if DBG
    // See if the Index passed in is from TlsAlloc or random goo...
    ASSERTMSG( "BASEDLL: Invalid TlsIndex passed to TlsSetValue\n", (dwTlsIndex & TLS_MASK));
    dwTlsIndex &= ~TLS_MASK;
#endif

    Teb = NtCurrentTeb();

    if ( dwTlsIndex >= TLS_MINIMUM_AVAILABLE ) {
        dwTlsIndex -= TLS_MINIMUM_AVAILABLE;
        if ( dwTlsIndex < TLS_EXPANSION_SLOTS ) {
            if ( !Teb->TlsExpansionSlots ) {
                RtlAcquirePebLock();
                if ( !Teb->TlsExpansionSlots ) {
                    Teb->TlsExpansionSlots = RtlAllocateHeap(
                                                RtlProcessHeap(),
                                                MAKE_TAG( TMP_TAG ) | HEAP_ZERO_MEMORY,
                                                TLS_EXPANSION_SLOTS * sizeof(PVOID)
                                                );
                    if ( !Teb->TlsExpansionSlots ) {
                        RtlReleasePebLock();
                        BaseSetLastNTError(STATUS_NO_MEMORY);
                        return FALSE;
                        }
                    }
                RtlReleasePebLock();
                }
            Teb->TlsExpansionSlots[dwTlsIndex] = lpTlsValue;
            }
        else {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;
            }
        }
    else {
        Teb->TlsSlots[dwTlsIndex] = lpTlsValue;
        }
    return TRUE;
}

BOOL
APIENTRY
TlsFree(
    DWORD dwTlsIndex
    )

/*++

Routine Description:

    A valid TLS index may be free'd using TlsFree.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAlloc.  If the
        index is a valid index, it is released by this call and is made
        available for reuse.  DLLs should be carefull to release any
        per-thread data pointed to by all of their threads TLS slots
        before calling this function.  It is expected that DLLs will
        only call this function (if at ALL) during their process detach
        routine.

Return Value:

    TRUE - The operation was successful.  Calling TlsTranslateIndex with
        this index will fail.  TlsAlloc is free to reallocate this
        index.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PPEB Peb;
    BOOLEAN ValidIndex;
    PRTL_BITMAP TlsBitmap;
    NTSTATUS Status;
    DWORD Index2;

#if DBG
    // See if the Index passed in is from TlsAlloc or random goo...
    ASSERTMSG( "BASEDLL: Invalid TlsIndex passed to TlsFree\n", (dwTlsIndex & TLS_MASK));
    dwTlsIndex &= ~TLS_MASK;
#endif

    Peb = NtCurrentPeb();

    RtlAcquirePebLock();
    try {

        if ( dwTlsIndex >= TLS_MINIMUM_AVAILABLE ) {
            Index2 = dwTlsIndex - TLS_MINIMUM_AVAILABLE;
            if ( Index2 >= TLS_EXPANSION_SLOTS ) {
                ValidIndex = FALSE;
                }
            else {
                TlsBitmap = (PRTL_BITMAP)Peb->TlsExpansionBitmap;
                ValidIndex = RtlAreBitsSet(TlsBitmap,Index2,1);
                }
            }
        else {
            TlsBitmap = (PRTL_BITMAP)Peb->TlsBitmap;
            Index2 = dwTlsIndex;
            ValidIndex = RtlAreBitsSet(TlsBitmap,Index2,1);
            }
        if ( ValidIndex ) {

            Status = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadZeroTlsCell,
                        &dwTlsIndex,
                        sizeof(dwTlsIndex)
                        );
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(STATUS_INVALID_PARAMETER);
                return FALSE;
                }

            RtlClearBits(TlsBitmap,Index2,1);
            }
        else {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            }
        }
    finally {
        RtlReleasePebLock();
        }
    return ValidIndex;
}



BOOL
WINAPI
GetThreadTimes(
    HANDLE hThread,
    LPFILETIME lpCreationTime,
    LPFILETIME lpExitTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    )

/*++

Routine Description:

    This function is used to return various timing information about the
    thread specified by hThread.

    All times are in units of 100ns increments. For lpCreationTime and lpExitTime,
    the times are in terms of the SYSTEM time or GMT time.

Arguments:

    hThread - Supplies an open handle to the specified thread.  The
        handle must have been created with THREAD_QUERY_INFORMATION
        access.

    lpCreationTime - Returns a creation time of the thread.

    lpExitTime - Returns the exit time of a thread.  If the thread has
        not exited, this value is not defined.

    lpKernelTime - Returns the amount of time that this thread has
        executed in kernel-mode.

    lpUserTime - Returns the amount of time that this thread has
        executed in user-mode.


Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/


{
    NTSTATUS Status;
    KERNEL_USER_TIMES TimeInfo;

    Status = NtQueryInformationThread(
                hThread,
                ThreadTimes,
                (PVOID)&TimeInfo,
                sizeof(TimeInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    *lpCreationTime = *(LPFILETIME)&TimeInfo.CreateTime;
    *lpExitTime = *(LPFILETIME)&TimeInfo.ExitTime;
    *lpKernelTime = *(LPFILETIME)&TimeInfo.KernelTime;
    *lpUserTime = *(LPFILETIME)&TimeInfo.UserTime;

    return TRUE;
}

DWORD_PTR
WINAPI
SetThreadAffinityMask(
    HANDLE hThread,
    DWORD_PTR dwThreadAffinityMask
    )

/*++

Routine Description:

    This function is used to set the specified thread's processor
    affinity mask.  The thread affinity mask is a bit vector where each
    bit represents the processors that the thread is allowed to run on.
    The affinity mask MUST be a proper subset of the containing process'
    process level affinity mask.

Arguments:

    hThread - Supplies a handle to the thread whose priority is to be
        set.  The handle must have been created with
        THREAD_SET_INFORMATION access.

    dwThreadAffinityMask - Supplies the affinity mask to be used for the
        specified thread.

Return Value:

    non-0 - The API was successful.  The return value is the previous
        affinity mask for the thread.

    0 - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    THREAD_BASIC_INFORMATION BasicInformation;
    NTSTATUS Status;
    DWORD_PTR rv;
    DWORD_PTR LocalThreadAffinityMask;


    Status = NtQueryInformationThread(
                hThread,
                ThreadBasicInformation,
                &BasicInformation,
                sizeof(BasicInformation),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        rv = 0;
        }
    else {
        LocalThreadAffinityMask = dwThreadAffinityMask;

        Status = NtSetInformationThread(
                    hThread,
                    ThreadAffinityMask,
                    &LocalThreadAffinityMask,
                    sizeof(LocalThreadAffinityMask)
                    );
        if ( !NT_SUCCESS(Status) ) {
            rv = 0;
            }
        else {
            rv = BasicInformation.AffinityMask;
            }
        }


    if ( !rv ) {
        BaseSetLastNTError(Status);
        }

    return rv;
}

VOID
BaseDispatchAPC(
    LPVOID lpApcArgument1,
    LPVOID lpApcArgument2,
    LPVOID lpApcArgument3
    )
{
    PAPCFUNC pfnAPC;
    ULONG_PTR dwData;

    pfnAPC = (PAPCFUNC)lpApcArgument1;
    dwData = (ULONG_PTR)lpApcArgument2;
    (pfnAPC)(dwData);
}


WINBASEAPI
DWORD
WINAPI
QueueUserAPC(
    PAPCFUNC pfnAPC,
    HANDLE hThread,
    ULONG_PTR dwData
    )
/*++

Routine Description:

    This function is used to queue a user-mode APC to the specified thread. The APC
    will fire when the specified thread does an alertable wait.

Arguments:

    pfnAPC - Supplies the address of the APC routine to execute when the
        APC fires.

    hHandle - Supplies a handle to a thread object.  The caller
        must have THREAD_SET_CONTEXT access to the thread.

    dwData - Supplies a DWORD passed to the APC

Return Value:

    TRUE - The operations was successful

    FALSE - The operation failed. GetLastError() is not defined.

--*/

{
    NTSTATUS Status;

    Status = NtQueueApcThread(
                hThread,
                (PPS_APC_ROUTINE)BaseDispatchAPC,
                (PVOID)pfnAPC,
                (PVOID)dwData,
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        return 0;
        }
    return 1;
}


DWORD
WINAPI
SetThreadIdealProcessor(
    HANDLE hThread,
    DWORD dwIdealProcessor
    )
{
    NTSTATUS Status;
    ULONG rv;

    Status = NtSetInformationThread(
                hThread,
                ThreadIdealProcessor,
                &dwIdealProcessor,
                sizeof(dwIdealProcessor)
                );
    if ( !NT_SUCCESS(Status) ) {
        rv = (DWORD)0xFFFFFFFF;
        BaseSetLastNTError(Status);
        }
    else {
        rv = (ULONG)Status;
        }

    return rv;
}

WINBASEAPI
LPVOID
WINAPI
CreateFiber(
    DWORD dwStackSize,
    LPFIBER_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    )
{

    NTSTATUS Status;
    PFIBER Fiber;
    INITIAL_TEB InitialTeb;

    Fiber = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), sizeof(*Fiber) );
    if ( !Fiber ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return Fiber;
        }

    Status = BaseCreateStack(
                NtCurrentProcess(),
                dwStackSize,
                0L,
                &InitialTeb
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        RtlFreeHeap(RtlProcessHeap(), 0, Fiber);
        return NULL;
        }

    Fiber->FiberData = lpParameter;
    Fiber->StackBase = InitialTeb.StackBase;
    Fiber->StackLimit = InitialTeb.StackLimit;
    Fiber->DeallocationStack = InitialTeb.StackAllocationBase;
    Fiber->ExceptionList = (struct _EXCEPTION_REGISTRATION_RECORD *)-1;
    Fiber->Wx86Tib = NULL;

#ifdef _IA64_

    Fiber->BStoreLimit = InitialTeb.BStoreLimit;
    Fiber->DeallocationBStore = InitialTeb.StackAllocationBase;

#endif // _IA64_

    //
    // Create an initial context for the new fiber.
    //

    BaseInitializeContext(
        &Fiber->FiberContext,
        lpParameter,
        (PVOID)lpStartAddress,
        InitialTeb.StackBase,
        BaseContextTypeFiber
        );

    return Fiber;
}

WINBASEAPI
VOID
WINAPI
DeleteFiber(
    LPVOID lpFiber
    )
{
    SIZE_T dwStackSize;
    PFIBER Fiber = lpFiber;



    //
    // If the current fiber makes this call, then it's just a thread exit
    //

    if ( NtCurrentTeb()->NtTib.FiberData == Fiber ) {
        ExitThread(1);
        }

    dwStackSize = 0;

    NtFreeVirtualMemory( NtCurrentProcess(),
                        &Fiber->DeallocationStack,
                        &dwStackSize,
                        MEM_RELEASE
                        );

#if defined (WX86)

    if (Fiber->Wx86Tib && Fiber->Wx86Tib->Size == sizeof(WX86TIB)) {
        PVOID BaseAddress = Fiber->Wx86Tib->DeallocationStack;

        dwStackSize = 0;

        NtFreeVirtualMemory( NtCurrentProcess(),
                            &BaseAddress,
                            &dwStackSize,
                            MEM_RELEASE
                            );
        }
#endif

    RtlFreeHeap(RtlProcessHeap(),0,Fiber);
}


WINBASEAPI
LPVOID
WINAPI
ConvertThreadToFiber(
    LPVOID lpParameter
    )
{

    PFIBER Fiber;
    PTEB Teb;

    Fiber = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), sizeof(*Fiber) );
    if ( !Fiber ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return Fiber;
        }
    Teb = NtCurrentTeb();
    Fiber->FiberData = lpParameter;
    Fiber->StackBase = Teb->NtTib.StackBase;
    Fiber->StackLimit = Teb->NtTib.StackLimit;
    Fiber->DeallocationStack = Teb->DeallocationStack;
    Fiber->ExceptionList = Teb->NtTib.ExceptionList;
    Fiber->Wx86Tib = NULL;
    Teb->NtTib.FiberData = Fiber;


    return Fiber;
}

BOOL
WINAPI
SwitchToThread(
    VOID
    )
/*++

Routine Description:

    This function causes a yield from the running thread to any other
    thread that is ready and can run on the current processor.  The
    yield will be effective for up to one quantum and then the yielding
    thread will be scheduled again according to its priority and
    whatever other threads may also be avaliable to run.  The thread
    that yields will not bounce to another processor even it another
    processor is idle or running a lower priority thread.

Arguments:

    None

Return Value:

    TRUE - Calling this function caused a switch to another thread to occur
    FALSE - There were no other ready threads, so no context switch occured

--*/

{

    if ( NtYieldExecution() == STATUS_NO_YIELD_PERFORMED ) {
        return FALSE;
        }
    else {
        return TRUE;
        }
}

#endif // #if NOT_IN_TPOOL

BOOL
WINAPI
RegisterWaitForSingleObject(
    PHANDLE phNewWaitObject,
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    )
/*++

Routine Description:

    This function registers a wait for a particular object, with an optional
    timeout.  This differs from WaitForSingleObject because the wait is performed
    by a different thread that combines several such calls for efficiency.  The
    function supplied in Callback is called when the object is signalled, or the
    timeout expires.

Arguments:

    phNewWaitObject - pointer to new WaitObject returned by this function.

    hObject -   HANDLE to a Win32 kernel object (Event, Mutex, File, Process,
                Thread, etc.) that will be waited on.  Note:  if the object
                handle does not immediately return to the not-signalled state,
                e.g. an auto-reset event, then either WT_EXECUTEINWAITTHREAD or
                WT_EXECUTEONLYONCE should be specified.  Otherwise, the thread
                pool will continue to fire the callbacks. If WT_EXECUTEINWAITTHREAD
                is specified, the the object should be deregistered or reset in the
                callback.

    Callback -  Function that will be called when the object is signalled or the
                timer expires.

    Context -   Context that will be passed to the callback function.

    dwMilliseconds - timeout for the wait. Each time the timer is fired or the event
                is fired, the timer is reset (except if WT_EXECUTEONLYONCE is set).

    dwFlags -   Flags indicating options for this wait:
                WT_EXECUTEDEFAULT       - Default (0)
                WT_EXECUTEINIOTHREAD    - Select an I/O thread for execution
                WT_EXECUTEINUITHREAD    - Select a UI thread for execution
                WT_EXECUTEINWAITTHREAD  - Execute in the thread that handles waits
                WT_EXECUTEONLYONCE      - The callback function will be called only once
                WT_EXECUTELONGFUNCTION  - The Callback function can potentially block
                                          for a long time. Is valid only if
                                          WT_EXECUTEINWAITTHREAD flag is not set.
Return Value:

    FALSE - an error occurred, use GetLastError() for more information.

    TRUE - success.

--*/
{
    NTSTATUS Status ;
    PPEB Peb;

    *phNewWaitObject = NULL;
    Peb = NtCurrentPeb();
    switch( HandleToUlong(hObject) )
    {
        case STD_INPUT_HANDLE:  hObject = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hObject = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hObject = Peb->ProcessParameters->StandardError;
                                break;
    }

    if (CONSOLE_HANDLE(hObject) && VerifyConsoleIoHandle(hObject))
    {
        hObject = GetConsoleInputWaitHandle();
    }

    Status = RtlRegisterWait(
                phNewWaitObject,
                hObject,
                Callback,
                Context,
                dwMilliseconds,
                dwFlags );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;

}


HANDLE
WINAPI
RegisterWaitForSingleObjectEx(
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    )
/*++

Routine Description:

    This function registers a wait for a particular object, with an optional
    timeout.  This differs from WaitForSingleObject because the wait is performed
    by a different thread that combines several such calls for efficiency.  The
    function supplied in Callback is called when the object is signalled, or the
    timeout expires.

Arguments:

    hObject -   HANDLE to a Win32 kernel object (Event, Mutex, File, Process,
                Thread, etc.) that will be waited on.  Note:  if the object
                handle does not immediately return to the not-signalled state,
                e.g. an auto-reset event, then either WT_EXECUTEINWAITTHREAD or
                WT_EXECUTEONLYONCE should be specified.  Otherwise, the thread
                pool will continue to fire the callbacks. If WT_EXECUTEINWAITTHREAD
                is specified, the the object should be deregistered or reset in the
                callback.

    Callback -  Function that will be called when the object is signalled or the
                timer expires.

    Context -   Context that will be passed to the callback function.

    dwMilliseconds - timeout for the wait. Each time the timer is fired or the event
                is fired, the timer is reset (except if WT_EXECUTEONLYONCE is set).

    dwFlags -   Flags indicating options for this wait:
                WT_EXECUTEDEFAULT       - Default (0)
                WT_EXECUTEINIOTHREAD    - Select an I/O thread for execution
                WT_EXECUTEINUITHREAD    - Select a UI thread for execution
                WT_EXECUTEINWAITTHREAD  - Execute in the thread that handles waits
                WT_EXECUTEONLYONCE      - The callback function will be called only once
                WT_EXECUTELONGFUNCTION  - The Callback function can potentially block
                                          for a long time. Is valid only if
                                          WT_EXECUTEINWAITTHREAD flag is not set.
Return Value:

    NULL - an error occurred, use GetLastError() for more information.

    non-NULL - a virtual handle that can be passed later to
               UnregisterWait

--*/
{
    HANDLE WaitHandle ;
    NTSTATUS Status ;
    PPEB Peb;

    Peb = NtCurrentPeb();
    switch( HandleToUlong(hObject) )
    {
        case STD_INPUT_HANDLE:  hObject = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hObject = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hObject = Peb->ProcessParameters->StandardError;
                                break;
    }

    if (CONSOLE_HANDLE(hObject) && VerifyConsoleIoHandle(hObject))
    {
        hObject = GetConsoleInputWaitHandle();
    }

    Status = RtlRegisterWait(
                &WaitHandle,
                hObject,
                Callback,
                Context,
                dwMilliseconds,
                dwFlags );

    if ( NT_SUCCESS( Status ) )
    {
        return WaitHandle ;
    }

    BaseSetLastNTError( Status );

    return NULL ;

}

BOOL
WINAPI
UnregisterWait(
    HANDLE WaitHandle
    )
/*++

Routine Description:

    This function cancels a wait for a particular object.
    All objects that were registered by the RtlWaitForSingleObject(Ex) call
    should be deregistered. This is a non-blocking call, and the associated
    callback function can still be executing after the return of this function.

Arguments:

    WaitHandle - Handle returned from RegisterWaitForSingleObject(Ex)

Return Value:

    TRUE - The wait was cancelled
    FALSE - an error occurred or a callback function was still executing,
            use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;

    if ( WaitHandle )
    {
        Status = RtlDeregisterWait( WaitHandle );

        // set error if it is a non-blocking call and STATUS_PENDING was returned
        /*ksl1
        if ( Status == STATUS_PENDING  || !NT_SUCCESS( Status ) )
        {

            BaseSetLastNTError( Status );
            return FALSE;
        }
        */
        return TRUE ;

    }

    SetLastError( ERROR_INVALID_HANDLE );

    return FALSE ;
}


BOOL
WINAPI
UnregisterWaitEx(
    HANDLE WaitHandle,
    HANDLE CompletionEvent
    )
/*++

Routine Description:

    This function cancels a wait for a particular object.
    All objects that were registered by the RtlWaitForSingleObject(Ex) call
    should be deregistered.

Arguments:

    WaitHandle - Handle returned from RegisterWaitForSingleObject

    CompletionEvent - Handle to wait on for completion.
        NULL - NonBlocking call.
        INVALID_HANDLE_VALUE - Blocking call. Block till all Callback functions
                    associated with the WaitHandle have completed
        Event - NonBlocking call. The Object is deregistered. The Event is signalled
                    when the last callback function has completed execution.
Return Value:

    TRUE - The wait was cancelled
    FALSE - an error occurred or a callback was still executing,
            use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;

    if ( WaitHandle )
    {
        Status = RtlDeregisterWaitEx( WaitHandle, CompletionEvent );

        // set error if it is a non-blocking call and STATUS_PENDING was returned
        /*ksl1
        if ( (CompletionEvent != INVALID_HANDLE_VALUE && Status == STATUS_PENDING)
            || ( ! NT_SUCCESS( Status ) ) )
        {

            BaseSetLastNTError( Status );
            return FALSE;
        }
        */
        return TRUE ;

    }

    SetLastError( ERROR_INVALID_HANDLE );

    return FALSE ;
}

BOOL
WINAPI
QueueUserWorkItem(
    LPTHREAD_START_ROUTINE Function,
    PVOID Context,
    ULONG Flags
    )
/*++

Routine Description:

    This function queues a work item to a thread out of the thread pool.  The
    function passed is invoked in a different thread, and passed the Context
    pointer.  The caller can specify whether the thread pool should select
    a thread that can have I/O pending, or any thread.

Arguments:

    Function -  Function to call

    Context -   Pointer passed to the function when it is invoked.

    Flags   -
        - WT_EXECUTEINIOTHREAD
                Indictes to the thread pool that this thread will perform
                I/O.  A thread that starts an asynchronous I/O operation
                must wait for it to complete.  If a thread exits with
                outstanding I/O requests, those requests will be cancelled.
                This flag is a hint to the thread pool that this function
                will start I/O, so that a thread which can have pending I/O
                will be used.

        - WT_EXECUTELONGFUNCTION
                Indicates to the thread pool that the function might block
                for a long time.

Return Value:

    TRUE - The work item was queued to another thread.
    FALSE - an error occurred, use GetLastError() for more information.

--*/

{
    NTSTATUS Status ;

    Status = RtlQueueWorkItem(
                (WORKERCALLBACKFUNC) Function,
                Context,
                Flags );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;
}

BOOL
WINAPI
BindIoCompletionCallback (
    HANDLE FileHandle,
    LPOVERLAPPED_COMPLETION_ROUTINE Function,
    ULONG Flags
    )
/*++

Routine Description:

    This function binds the FileHandle opened for overlapped operations
    to the IO completion port associated with worker threads.

Arguments:

    FileHandle -  File Handle on which IO operations will be initiated.

    Function -    Function executed in a non-IO worker thread when the
                  IO operation completes.

    Flags   -     Currently set to 0. Not used.

Return Value:

    TRUE - The file handle was associated with the IO completion port.
    FALSE - an error occurred, use GetLastError() for more information.

--*/

{
    NTSTATUS Status ;

    Status = RtlSetIoCompletionCallback(
                FileHandle,
                (APC_CALLBACK_FUNCTION) Function,
                Flags );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;
}


//+---------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   BasepCreateDefaultTimerQueue
//
//  Synopsis:   Creates the default timer queue for the process
//
//  Arguments:  (none)
//
//  History:    5-26-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
BasepCreateDefaultTimerQueue(
    VOID
    )
{
    NTSTATUS Status ;

    while ( 1 )
    {
        if ( !InterlockedExchange( &BasepTimerQueueInitFlag, 1 ) )
        {
            //
            // Force the done flag to 0.  If it was 1, so one already tried to
            // init and failed.
            //

            InterlockedExchange( &BasepTimerQueueDoneFlag, 0 );

            Status = RtlCreateTimerQueue( &BasepDefaultTimerQueue );

            if ( NT_SUCCESS( Status ) )
            {
                InterlockedIncrement( &BasepTimerQueueDoneFlag );

                return TRUE ;
            }

            //
            // This is awkward.  We aren't able to create a timer queue,
            // probably because of low memory.  We will fail this call, but decrement
            // the init flag, so that others can try again later.  Need to increment
            // the done flag, or any other threads would be stuck.
            //

            BaseSetLastNTError( Status );

            InterlockedIncrement( &BasepTimerQueueDoneFlag );

            InterlockedDecrement( &BasepTimerQueueInitFlag );

            return FALSE ;
        }
        else
        {
            LARGE_INTEGER TimeOut ;

            TimeOut.QuadPart = -1 * 10 * 10000 ;

            //
            // yield the quantum so that the other thread can
            // try to create the timer queue.
            //

            while ( !BasepTimerQueueDoneFlag )
            {
                NtDelayExecution( FALSE, &TimeOut );
            }

            //
            // Make sure it was created.  Otherwise, try it again (memory might have
            // freed up).  This way, every thread gets an individual chance to create
            // the queue if another thread failed.
            //

            if ( BasepDefaultTimerQueue )
            {
                return TRUE ;
            }

        }
    }
}

HANDLE
WINAPI
CreateTimerQueue(
    VOID
    )
/*++

Routine Description:

    This function creates a queue for timers.  Timers on a timer queue are
    lightweight objects that allow the caller to specify a function to
    be called at some point in the future.  Any number of timers can be
    created in a particular timer queue.

Arguments:

    None.

Return Value:

    non-NULL  - a timer queue handle that can be passed to SetTimerQueueTimer,
                ChangeTimerQueueTimer, CancelTimerQueueTimer, and
                DeleteTimerQueue.

    NULL - an error occurred, use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;
    HANDLE Handle ;

    Status = RtlCreateTimerQueue( &Handle );

    if ( NT_SUCCESS( Status ) )
    {
        return Handle ;
    }

    BaseSetLastNTError( Status );

    return NULL ;

}


BOOL
WINAPI
CreateTimerQueueTimer(
    PHANDLE phNewTimer,
    HANDLE TimerQueue,
    WAITORTIMERCALLBACK Callback,
    PVOID Parameter,
    DWORD DueTime,
    DWORD Period,
    ULONG Flags
    )
/*++

Routine Description:

    This function creates a timer queue timer, a lightweight timer that
    will fire at the DueTime, and then every Period milliseconds afterwards.
    When the timer fires, the function passed in Callback will be invoked,
    and passed the Parameter pointer.

Arguments:

    phNewTimer - pointer to new timer handle

    TimerQueue - Timer Queue to attach this timer to.  NULL indicates that the
                 default process timer queue be used.

    Function -  Function to call

    Context -   Pointer passed to the function when it is invoked.

    DueTime -   Time from now that the timer should fire, expressed in
                milliseconds. If set to INFINITE, then it will never fire.
                If set to 0, then it will fire immediately.

    Period -    Time in between firings of this timer.
                If 0, then it is a one shot timer.

    Flags  -  by default the Callback function is queued to a non-IO worker thread.

            - WT_EXECUTEINIOTHREAD
                Indictes to the thread pool that this thread will perform
                I/O.  A thread that starts an asynchronous I/O operation
                must wait for it to complete.  If a thread exits with
                outstanding I/O requests, those requests will be cancelled.
                This flag is a hint to the thread pool that this function
                will start I/O, so that a thread with I/O already pending
                will be used.

            - WT_EXECUTEINTIMERTHREAD
                The callback function will be executed in the timer thread.

            - WT_EXECUTELONGFUNCTION
                Indicates that the function might block for a long time. Useful
                only if it is queued to a worker thread.

Return Value:

    TRUE -  no error

    FALSE - an error occurred, use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;

    *phNewTimer = NULL ;

    //
    // if the passed timer queue is NULL, use the default one.  If it is null,
    // call the initializer that will do it in a nice thread safe fashion.
    //

    if ( !TimerQueue )
    {
        if ( !BasepDefaultTimerQueue )
        {
            if ( !BasepCreateDefaultTimerQueue( ) )
            {
                return FALSE ;
            }
        }

        TimerQueue = BasepDefaultTimerQueue ;
    }

    Status = RtlCreateTimer(
                TimerQueue,
                phNewTimer,
                Callback,
                Parameter,
                DueTime,
                Period,
                Flags );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;

}



BOOL
WINAPI
ChangeTimerQueueTimer(
    HANDLE TimerQueue,
    HANDLE Timer,
    ULONG DueTime,
    ULONG Period
    )
/*++

Routine Description:

    This function updates a timer queue timer created with SetTimerQueueTimer.

Arguments:

    TimerQueue - Timer Queue to attach this timer to.  NULL indicates the default
                 process timer queue.

    Timer -     Handle returned from SetTimerQueueTimer.

    DueTime -   Time from now that the timer should fire, expressed in
                milliseconds.

    Period -    Time in between firings of this timer. If set to 0, then it becomes
                a one shot timer.


Return Value:

    TRUE - the timer was changed

    FALSE - an error occurred, use GetLastError() for more information.

--*/

{
    NTSTATUS Status ;

    //
    // Use the default timer queue if none was passed in.  If there isn't one, then
    // the process hasn't created one with SetTimerQueueTimer, and that's an error.
    //

    if ( !TimerQueue )
    {
        TimerQueue = BasepDefaultTimerQueue ;

        if ( !TimerQueue )
        {
            SetLastError( ERROR_INVALID_PARAMETER );

            return FALSE ;
        }
    }

    Status = RtlUpdateTimer( TimerQueue,
                             Timer,
                             DueTime,
                             Period );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;
}


BOOL
WINAPI
DeleteTimerQueueTimer(
    HANDLE TimerQueue,
    HANDLE Timer,
    HANDLE CompletionEvent
    )
/*++

Routine Description:

    This function cancels a timer queue timer created with SetTimerQueueTimer.

Arguments:

    TimerQueue - Timer Queue that this timer was created on.

    Timer -     Handle returned from SetTimerQueueTimer.

    CompletionEvent -
            - NULL : NonBlocking call. returns immediately.
            - INVALID_HANDLE_VALUE : Blocking call. Returns after all callbacks have executed
            - Event (handle to an event) : NonBlocking call. Returns immediately.
                    Event signalled after all callbacks have executed.

Return Value:

    TRUE - the timer was cancelled.

    FALSE - an error occurred or the call is pending, use GetLastError()
            for more information.

--*/
{
    NTSTATUS Status ;

    //
    // Use the default timer queue if none was passed in.  If there isn't one, then
    // the process hasn't created one with SetTimerQueueTimer, and that's an error.
    //

    if ( !TimerQueue )
    {
        TimerQueue = BasepDefaultTimerQueue ;

        if ( !TimerQueue )
        {
            SetLastError( ERROR_INVALID_PARAMETER );

            return FALSE ;
        }
    }

    Status = RtlDeleteTimer( TimerQueue, Timer, CompletionEvent );

    // set error if it is a non-blocking call and STATUS_PENDING was returned
    /*ksl1
    if ( (CompletionEvent != INVALID_HANDLE_VALUE && Status == STATUS_PENDING)
        || ( ! NT_SUCCESS( Status ) ) )
    {

        BaseSetLastNTError( Status );
        return FALSE;
    }
    */
    return TRUE ;

}


BOOL
WINAPI
DeleteTimerQueueEx(
    HANDLE TimerQueue,
    HANDLE CompletionEvent
    )
/*++

Routine Description:

    This function deletes a timer queue created with CreateTimerQueue.
    Any pending timers on the timer queue are cancelled and deleted.

Arguments:

    TimerQueue - Timer Queue to delete.

    CompletionEvent -
            - NULL : NonBlocking call. returns immediately.
            - INVALID_HANDLE_VALUE : Blocking call. Returns after all callbacks
                    have executed
            - Event (handle to an event) : NonBlocking call. Returns immediately.
                    Event signalled after all callbacks have executed.

Return Value:

    TRUE - the timer queue was deleted.

    FALSE - an error occurred, use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;

    if ( TimerQueue )
    {
        Status = RtlDeleteTimerQueueEx( TimerQueue, CompletionEvent );

        // set error if it is a non-blocking call and STATUS_PENDING was returned
        /*ksl1
        if ( (CompletionEvent != INVALID_HANDLE_VALUE && Status == STATUS_PENDING)
            || ( ! NT_SUCCESS( Status ) ) )
        {

            BaseSetLastNTError( Status );
            return FALSE;
        }
        */
        return TRUE ;

    }


    SetLastError( ERROR_INVALID_HANDLE );
    return FALSE ;
}

BOOL
WINAPI
ThreadPoolCleanup (
    ULONG Flags
    )
/*++

Routine Description:

    Called by terminating process for thread pool to cleanup and
    delete all its threads.

Arguments:

    Flags - currently not used

Return Value:

    NO_ERROR

--*/
{

    // RtlThreadPoolCleanup( Flags ) ;

    return TRUE ;
}


/*OBSOLETE FUNCTION - REPLACED BY CreateTimerQueueTimer */
HANDLE
WINAPI
SetTimerQueueTimer(
    HANDLE TimerQueue,
    WAITORTIMERCALLBACK Callback,
    PVOID Parameter,
    DWORD DueTime,
    DWORD Period,
    BOOL PreferIo
    )
/*OBSOLETE FUNCTION - REPLACED BY CreateTimerQueueTimer */
{
    NTSTATUS Status ;
    HANDLE Handle ;

    //
    // if the passed timer queue is NULL, use the default one.  If it is null,
    // call the initializer that will do it in a nice thread safe fashion.
    //

    if ( !TimerQueue )
    {
        if ( !BasepDefaultTimerQueue )
        {
            if ( !BasepCreateDefaultTimerQueue( ) )
            {
                return NULL ;
            }
        }

        TimerQueue = BasepDefaultTimerQueue ;
    }

    Status = RtlCreateTimer(
                TimerQueue,
                &Handle,
                Callback,
                Parameter,
                DueTime,
                Period,
                (PreferIo ? WT_EXECUTEINIOTHREAD : 0 ) );

    if ( NT_SUCCESS( Status ) )
    {
        return Handle ;
    }

    BaseSetLastNTError( Status );

    return NULL ;
}


/*OBSOLETE: Replaced by DeleteTimerQueueEx */
BOOL
WINAPI
DeleteTimerQueue(
    HANDLE TimerQueue
    )
/*++

  OBSOLETE: Replaced by DeleteTimerQueueEx

Routine Description:

    This function deletes a timer queue created with CreateTimerQueue.
    Any pending timers on the timer queue are cancelled and deleted.
    This is a non-blocking call. Callbacks might still be running after
    this call returns.

Arguments:

    TimerQueue - Timer Queue to delete.

Return Value:

    TRUE - the timer queue was deleted.

    FALSE - an error occurred, use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;

    if (TimerQueue)
    {
        Status = RtlDeleteTimerQueueEx( TimerQueue, NULL );

        // set error if it is a non-blocking call and STATUS_PENDING was returned
        /*
        if ( Status == STATUS_PENDING || ! NT_SUCCESS( Status ) )
        {

            BaseSetLastNTError( Status );
            return FALSE;
        }
        */
        return TRUE ;

    }

    SetLastError( ERROR_INVALID_HANDLE );

    return FALSE ;
}


/*OBSOLETE: USE DeleteTimerQueueTimer*/
BOOL
WINAPI
CancelTimerQueueTimer(
    HANDLE TimerQueue,
    HANDLE Timer
    )
/*OBSOLETE: USE DeleteTimerQueueTimer*/
{
    NTSTATUS Status ;

    //
    // Use the default timer queue if none was passed in.  If there isn't one, then
    // the process hasn't created one with SetTimerQueueTimer, and that's an error.
    //

    if ( !TimerQueue )
    {
        TimerQueue = BasepDefaultTimerQueue ;

        if ( !TimerQueue )
        {
            SetLastError( ERROR_INVALID_PARAMETER );

            return FALSE ;
        }
    }

    Status = RtlDeleteTimer( TimerQueue, Timer, NULL );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\ary.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       ary.h
//
//  Contents:   CImplAry* classes
//
//----------------------------------------------------------------------------

#pragma once

//+------------------------------------------------------------------------
//
// This is the implementation of the generic resizeable array classes. There
// are four array classes:
//
// CPtrAry<ELEM> --
//
//       Dynamic array class which is optimized for sizeof(ELEM) equal
//       to 4. The array is initially empty with no space or memory allocated
//       for data.
//
// CDataAry<ELEM> --
//
//       Same as CPtrAry but where sizeof(ELEM) is != 4 and less than 128.
//
// CStackPtrAry<ELEM, N> --
//
//       Dynamic array class optimized for sizeof(ELEM) equal to 4.
//       Space for N elements is allocated as member data of the class. If
//       this class is created on the stack, then space for N elements will
//       be created on the stack. The class can grow beyond N elements, at
//       which point memory will be allocated for the array data.
//
// CStackDataAry<ELEM, N> --
//
//       Same as CStackPtrAry, but where sizeof(ELEM) is != 4 and less than 128.
//
//
// All four classes have virtually the same methods, and are used the same.
// The only difference is that the DataAry classes have AppendIndirect and
// InsertIndirect, while the PtrAry classes use Append and Insert. The reason
// for the difference is that the Indirect methods take a pointer to the data,
// while the non-indirect methods take the actual data as an argument.
//
// The Stack arrays (CStackPtrAry and CStackDataAry) are used to pre-allocate
// space for elements in the array. This is useful if you create the array on
// the stack and you know that most of the time the array will be less than
// a certain number of elements. Creating one of these arrays on the stack
// allocates the array on the stack as well, preventing a separate memory
// allocation. Only if the array grows beyond the initial size will any
// additional memory be allocated.
//
// The fastest and most efficient way of looping through all elements in
// the array is as follows:
//
//            ELEM * pElem;
//            int    i;
//
//            for (i = aryElems.Size(), pElem = aryElems;
//                 i > 0;
//                 i--, pElem++)
//            {
//                (*pElem)->DoSomething();
//            }
//
// This loop syntax has been shown to be the fastest and produce the smallest
// code. Here's an example using a real data type:
//
//            CStackPtrAry<CSite*, 16> arySites;
//            CSite **ppSite;
//            int     i;
//
//            // Populate the array.
//            ...
//
//            // Now loop through every element in the array.
//            for (i = arySites.Size(), ppSite = arySites;
//                 i > 0;
//                 i--, ppSite++)
//            {
//                (*ppSite)->DoSomething();
//            }
//
// METHOD DESCRIPTIONS:
//
// Commonly used methods:
//
//        Size()             Returns the number of elements currently stored
//                           in the array.
//
//        operator []        Returns the given element in the array.
//
//        Item(int i)        Returns the given element in the array.
//
//        operator ELEM*     Allows the array class to be cast to a pointer
//                           to ELEM. Returns a pointer to the first element
//                           in the array. (Same as a Base() method).
//
//        Append(ELEM e)     Adds a new pointer to the end of the array,
//                           growing the array if necessary.  Only valid
//                           for arrays of pointers (CPtrAry, CStackPtrAry).
//
//        AppendIndirect(ELEM *pe, ELEM** ppePlaced)
//                           As Append, for non-pointer arrays
//                           (CDataAry, CStackDataAry).
//                           pe [in] - Pointer to element to add to array. The
//                                     data is copied into the array. Can be
//                                     NULL, in which case the new element is
//                                     initialized to all zeroes.
//                           ppePlaced [out] - Returns pointer to the new
//                                     element. Can be NULL.
//
//        Insert(int i, ELEM e)
//                           Inserts a new element (e) at the given index (i)
//                           in the array, growing the array if necessary. Any
//                           elements at or following the index are moved
//                           out of the way.
//
//        InsertIndirect(int i, ELEM *pe)
//                           As Insert, for non-pointer arrays
//                                 (CDataAry, CStackDataAry).
//
//        Find(ELEM e)       Returns the index at which a given element (e)
//                           is found (CPtrAry, CStackPtrAry).
//
//        FindIndirect(ELEM *pe)
//                           As Find, for non-pointer arrays
//                                 (CDataAry, CStackDataAry).
//
//        DeleteAll()        Empties the array and de-allocates associated
//                           memory.
//
//        Delete(int i)      Deletes an element of the array, moving any
//                           elements that follow it to fill
//
//        DeleteMultiple(int start, int end)
//                           Deletes a range of elements from the array,
//                           moving to fill. [start] and [end] are the indices
//                           of the start and end elements (inclusive).
//
//        DeleteByValue(ELEM e)
//                           Delete the element matching the given value.
//
//        DeleteByValueIndirect(ELEM *pe)
//                           As DeleteByValue, for non-pointer arrays.
//                                    (CDataAry, CStackDataAry).
//
//
// Less commonly used methods:
//
//        EnsureSize(long c) If you know how many elements you are going to put
//                          in the array before you actually do it, you can use
//                          EnsureSize to allocate the memory all at once instead
//                          of relying on Append(Indirect) to grow the array. This
//                          can be much more efficient (by causing only a single
//                          memory allocation instead of many) than just using
//                          Append(Indirect). You pass in the number of elements
//                          that memory should be allocated for. Note that this
//                          does not affect the "Size" of the array, which is
//                          the number of elements currently stored in it.
//
//        SetSize(int c)    Sets the "Size" of the array, which is the number
//                          of elements currently stored in it. SetSize will not
//                          allocate memory if you're growing the array.
//                          EnsureSize must be called first to reserve space if
//                          the array is growing. Setting the size smaller does
//                          not de-allocate memory, it just chops off the
//                          elements at the end of the array.
//
//        Grow(int c)       Equivalent to calling EnsureSize(c) followed by
//                          SetSize(c).
//
//        BringToFront(int i) Moves the given element of the array to index 0,
//                          shuffling elements to make room.
//
//        SendToBack(int i) Moves the given element to the end of the array,
//                          shuffling elements to make room.
//
//        Swap(int i, int j) Swaps the given two elements.
//
//        ReleaseAll()      (CPtrAry and CStackPtrAry only) Calls Release()
//                          on each element in the array and empties the array.
//
//        ReleaseAndDelete(int idx)
//                          (CPtrAry and CStackPtrAry only) Calls Release() on
//                          the given element and removes it from the array.
//
//           (See the class definitions below for signatures of the following
//            methods and src\core\cdutil\formsary.cxx for argument
//            descriptions)
//
//        CopyAppend        Appends data from another array (of the same type)
//                          to the end.
//
//        Copy              Copies data from another array (of the same type)
//                          into this array, replacing any existing data.
//
//        CopyAppendIndirect  Appends data from a C-style array of element data
//                          to the end of this array.
//
//        CopyIndirect      Copies elements from a C-style array into this array
//                          replacing any existing data.
//
//        operator void *   Allow the CImplAry class to be cast
//                          to a (void *). Avoid using if possible - use
//                          the type-safe operator ELEM * instead.
//
//        ClearAndReset     Obsolete. Do not use.
//
//
//----------------------------------------------------------------------------





//----------------------------------------------------------------------------
//
// Class:     CImplAry
//
// Purpose:   Base implementation of all the dynamic array classes.
//
// Interface:
//
//        Deref       Returns a pointer to an element of the array;
//                    should only be used by derived classes. Use the
//                    type-safe methods operator[] or Item() instead.
//
//        GetAlloced  Get number of elements allocated
//
//  Members:    _c          Current size of the array
//              _pv         Buffer storing the elements
//
//  Note:       The CImplAry class only supports arrays of elements
//              whose size is less than 128.
//
//-------------------------------------------------------------------------


class CImplAry
{
    friend class CImplPtrAry;

private:
                DECLARE_MEMALLOC_NEW_DELETE();
public:

                        ~CImplAry();
    inline int          Size() const    { return _c; } // UNIX: long->int for min() macro
    inline void         SetSize(int c)  { _c = c; }
    inline operator void *()            { return PData(); }
    void                DeleteAll();

    // CONSIDER -- This method should be protected, but I don't want to convert
    // existing code that uses it. (lylec)
    void *      Deref(size_t cb, int i);

#if DBG == 1
    BOOL _fCheckLock ; // If set with TraceTag CImplAryLock then any change
                       // (addition or deletion to the DataAry will generate an assert.

    void        LockCheck(BOOL fState)
      { _fCheckLock = fState; }
#else
    void        LockCheck(BOOL)
      {  }
#endif

protected:

    //  Methods which are wrapped by inline subclass methods

                CImplAry();

    HRESULT     EnsureSize(size_t cb, long c);
    HRESULT     Grow(size_t cb, int c);
    HRESULT     AppendIndirect(size_t cb, void * pv, void ** ppvPlaced=NULL);
    HRESULT     InsertIndirect(size_t cb, int i, void * pv);
    int         FindIndirect(size_t cb, void *);

    void        Delete(size_t cb, int i);
    BOOL        DeleteByValueIndirect(size_t cb, void *pv);
    void        DeleteMultiple(size_t cb, int start, int end);

    HRESULT     CopyAppend(size_t cb, const CImplAry& ary, BOOL fAddRef);
    HRESULT     Copy(size_t cb, const CImplAry& ary, BOOL fAddRef);
    HRESULT     CopyIndirect(size_t cb, int c, void * pv, BOOL fAddRef);

    size_t      GetAlloced(size_t cb);

    inline BOOL UsingStackArray()
                    { return _fDontFree; }

    UINT        GetStackSize()
                    { ASSERT(_fStack);
                      return *(UINT*)((BYTE*)this + sizeof(CImplAry)); }
    void *      GetStackPtr()
                    { ASSERT(_fStack);
                      return (void*)((BYTE*)this + sizeof(CImplAry) + sizeof(int)); }

    unsigned long   _fStack     :1  ;  // Set if we're a stack-based array.
    unsigned long   _fDontFree  :1  ;  // Cleared if _pv points to alloced memory.
    unsigned long   _c          :30 ; // Count of elements
    void *          _pv;

    inline void * & PData()    { return _pv; }
};

//+------------------------------------------------------------------------
//
//  Member:     CImplAry::CImplAry
//
//+------------------------------------------------------------------------
inline
CImplAry::CImplAry()
{
    memset(this, 0, sizeof(CImplAry));
}


//+------------------------------------------------------------------------
//
//  Member:     CImplAry::Deref
//
//  Synopsis:   Returns a pointer to the i'th element of the array. This
//              method is normally called by type-safe methods in derived
//              classes.
//
//  Arguments:  i
//
//  Returns:    void *
//
//-------------------------------------------------------------------------

inline void *
CImplAry::Deref(size_t cb, int i)
{
    ASSERT(i >= 0);
    ASSERT(ULONG( i ) < GetAlloced(cb));
    return ((BYTE *) PData()) + i * cb;
}

//+------------------------------------------------------------------------
//
//  Class:      CImplPtrAry (ary)
//
//  Purpose:    Subclass used for arrays of pointers.  In this case, the
//              element size is known to be sizeof(void *).  Normally, the
//              CPtrAry template is used to define a specific concrete
//              implementation of this class, to hold a specific type of
//              pointer.
//
//              See documentation above for use.
//
//-------------------------------------------------------------------------

class CImplPtrAry : public CImplAry
{
private:
    DECLARE_MEMALLOC_NEW_DELETE();

protected:

    CImplPtrAry() : CImplAry() {};

    HRESULT     Append(void * pv);
    HRESULT     Insert(int i, void * pv);
    int         Find(void * pv);
    BOOL        DeleteByValue(void *pv);

    HRESULT     CopyAppend(const CImplAry& ary, BOOL fAddRef);
    HRESULT     Copy(const CImplAry& ary, BOOL fAddRef);
    HRESULT     CopyIndirect(int c, void * pv, BOOL fAddRef);


public:

    HRESULT     EnsureSize(long c);

    HRESULT     Grow(int c);

    void        Delete(int i);
    void        DeleteMultiple(int start, int end);

    void        ReleaseAll();
    void        ReleaseAndDelete(int idx);
};


//+---------------------------------------------------------------------------
//
//  Class:      CDataAry
//
//  Purpose:    This template class declares a concrete derived class
//              of CImplAry.
//
//              See documentation above for use.
//
//----------------------------------------------------------------------------

template <class ELEM>
class CDataAry : public CImplAry
{
private:
    DECLARE_MEMALLOC_NEW_DELETE();

public:

    CDataAry() : CImplAry() { }
    operator ELEM *() { return (ELEM *)PData(); }
    CDataAry(const CDataAry &);

    ELEM & Item(int i) { return *(ELEM*)Deref(sizeof(ELEM), i); }

    HRESULT     EnsureSize(long c)
                    { return CImplAry::EnsureSize(sizeof(ELEM), c); }
    HRESULT     Grow(int c)
                    { return CImplAry::Grow(sizeof(ELEM), c); }
    HRESULT     AppendIndirect(ELEM * pe, ELEM ** ppePlaced=NULL)
                    { return CImplAry::AppendIndirect(sizeof(ELEM), (void*)pe, (void**)ppePlaced); }
    ELEM *      Append()
                    { ELEM * pElem; return AppendIndirect( NULL, & pElem ) ? NULL : pElem; }
    HRESULT     InsertIndirect(int i, ELEM * pe)
                    { return CImplAry::InsertIndirect(sizeof(ELEM), i, (void*)pe); }
    int         FindIndirect(ELEM * pe)
                    { return CImplAry::FindIndirect(sizeof(ELEM), (void*)pe); }

    void        Delete(int i)
                    { CImplAry::Delete(sizeof(ELEM), i); }
    BOOL        DeleteByValueIndirect(ELEM *pe)
                    { return CImplAry::DeleteByValueIndirect(sizeof(ELEM), (void*)pe); }
    void        DeleteMultiple(int start, int end)
                    { CImplAry::DeleteMultiple(sizeof(ELEM), start, end); }

    HRESULT     CopyAppend(const CDataAry<ELEM>& ary, BOOL fAddRef)
                    { return CImplAry::Copy(sizeof(ELEM), ary, fAddRef); }
    HRESULT     Copy(const CDataAry<ELEM>& ary, BOOL fAddRef)
                    { return CImplAry::Copy(sizeof(ELEM), ary, fAddRef); }
    HRESULT     CopyIndirect(int c, ELEM * pv, BOOL fAddRef)
                    { return CImplAry::CopyIndirect(sizeof(ELEM), c, (void*)pv, fAddRef); }
};

#define DECLARE_CDataAry(tAry, tElem) \
    class tAry : public CDataAry<tElem> \
        { public: DECLARE_MEMALLOC_NEW_DELETE(); tAry() : CDataAry<tElem>() {} };

//+---------------------------------------------------------------------------
//
//  Class:      CPtrAry
//
//  Purpose:    This template class declares a concrete derived class
//              of CImplPtrAry.
//
//              See documentation above for use.
//
//----------------------------------------------------------------------------

template <class ELEM>
class CPtrAry : public CImplPtrAry
{
private:
    DECLARE_MEMALLOC_NEW_DELETE();

public:

    CPtrAry() : CImplPtrAry() { ASSERT(sizeof(ELEM) == sizeof(void*)); }
    operator ELEM *() { return (ELEM *)PData(); }
    CPtrAry(const CPtrAry &);

    ELEM & Item(int i) { return *(ELEM*)Deref(sizeof(ELEM), i); }

    HRESULT     Append(ELEM e)
                    { return CImplPtrAry::Append((void*)(DWORD_PTR)e); }
    HRESULT     Insert(int i, ELEM e)
                    { return CImplPtrAry::Insert(i, (void*)(DWORD_PTR)e); }
    BOOL        DeleteByValue(ELEM e)
                    { return CImplPtrAry::DeleteByValue((void*)(DWORD_PTR)e); }
    int         Find(ELEM e)
                    { return CImplPtrAry::Find((void*)(DWORD_PTR)e); }

    HRESULT     CopyAppend(const CPtrAry<ELEM>& ary, BOOL fAddRef)
                    { return CImplPtrAry::Copy(ary, fAddRef); }
    HRESULT     Copy(const CPtrAry<ELEM>& ary, BOOL fAddRef)
                    { return CImplPtrAry::Copy(ary, fAddRef); }
    HRESULT     CopyIndirect(int c, ELEM *pe, BOOL fAddRef)
                    { return CImplPtrAry::CopyIndirect(c, (void*)pe, fAddRef); }

};

#define DECLARE_CPtrAry(tAry, tElem) \
    class tAry : public CPtrAry<tElem> \
        { public: DECLARE_MEMALLOC_NEW_DELETE(); tAry() : CPtrAry<tElem>() {} };

//+---------------------------------------------------------------------------
//
//  Class:      CStackDataAry
//
//  Purpose:    Declares a CDataAry that has initial storage on the stack.
//              N elements are declared on the stack, and the array will
//              grow dynamically beyond that if necessary.
//
//              See documentation above for use.
//
//----------------------------------------------------------------------------

template <class ELEM, int N>
class CStackDataAry : public CDataAry<ELEM>
{
private:
    DECLARE_MEMALLOC_NEW_DELETE();

public:
    CStackDataAry() : CDataAry<ELEM>()
    {
        _cStack     = N;
        _fStack     = TRUE;
        _fDontFree  = TRUE;
        PData()     = (void *) & _achTInit;
#if DBG
        _pElemsInit = (ELEM * ) _achTInit;
#endif
    }

protected:
    int   _cStack;                     // Must be first data member.
    char  _achTInit[N*sizeof(ELEM)];
#if DBG
    ELEM * _pElemsInit;
#endif
};

#define DECLARE_CStackDataAry(tAry, tElem, cElem) \
    class tAry : public CStackDataAry<tElem, cElem> \
        { public: DECLARE_MEMALLOC_NEW_DELETE(); tAry() : CStackDataAry<tElem, cElem>() {} };

//+---------------------------------------------------------------------------
//
//  Class:      CStackPtrAry
//
//  Purpose:    Same as CStackDataAry except for pointer types.
//
//              See documentation above for use.
//
//----------------------------------------------------------------------------

template <class ELEM, int N>
class CStackPtrAry : public CPtrAry<ELEM>
{
private:
    DECLARE_MEMALLOC_NEW_DELETE();

public:
    CStackPtrAry() : CPtrAry<ELEM>()
    {
        _cStack     = N;
        _fStack     = TRUE;
        _fDontFree  = TRUE;
        PData()     = (void *) & _achTInit;
#if DBG
        _pElemsInit = (ELEM *) _achTInit;
#endif
    }

protected:
    int   _cStack;                     // Must be first data member.
    char  _achTInit[N*sizeof(ELEM)];
#if DBG
    ELEM * _pElemsInit;
#endif
};

#define DECLARE_CStackPtrAry(tAry, tElem, cElem) \
    class tAry : public CStackPtrAry<tElem, cElem> \
        { public: DECLARE_MEMALLOC_NEW_DELETE(); tAry() : CStackPtrAry<tElem, cElem>() {} };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\asptlb.h ===
//------------------------------------------------------------------------------
// <copyright file="asptlb.h" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   asptlb.h
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0268 */
/* at Wed Jul 07 15:54:33 1999
 */
/* Compiler settings for asp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef ___asptlb_h__
#define ___asptlb_h__

/* Forward Declarations */ 

#ifndef __IStringList_FWD_DEFINED__
#define __IStringList_FWD_DEFINED__
typedef interface IStringList IStringList;
#endif 	/* __IStringList_FWD_DEFINED__ */


#ifndef __IRequestDictionary_FWD_DEFINED__
#define __IRequestDictionary_FWD_DEFINED__
typedef interface IRequestDictionary IRequestDictionary;
#endif 	/* __IRequestDictionary_FWD_DEFINED__ */


#ifndef __IRequest_FWD_DEFINED__
#define __IRequest_FWD_DEFINED__
typedef interface IRequest IRequest;
#endif 	/* __IRequest_FWD_DEFINED__ */


#ifndef __Request_FWD_DEFINED__
#define __Request_FWD_DEFINED__

#ifdef __cplusplus
typedef class Request Request;
#else
typedef struct Request Request;
#endif /* __cplusplus */

#endif 	/* __Request_FWD_DEFINED__ */


#ifndef __IReadCookie_FWD_DEFINED__
#define __IReadCookie_FWD_DEFINED__
typedef interface IReadCookie IReadCookie;
#endif 	/* __IReadCookie_FWD_DEFINED__ */


#ifndef __IWriteCookie_FWD_DEFINED__
#define __IWriteCookie_FWD_DEFINED__
typedef interface IWriteCookie IWriteCookie;
#endif 	/* __IWriteCookie_FWD_DEFINED__ */


#ifndef __IResponse_FWD_DEFINED__
#define __IResponse_FWD_DEFINED__
typedef interface IResponse IResponse;
#endif 	/* __IResponse_FWD_DEFINED__ */


#ifndef __Response_FWD_DEFINED__
#define __Response_FWD_DEFINED__

#ifdef __cplusplus
typedef class Response Response;
#else
typedef struct Response Response;
#endif /* __cplusplus */

#endif 	/* __Response_FWD_DEFINED__ */


#ifndef __IVariantDictionary_FWD_DEFINED__
#define __IVariantDictionary_FWD_DEFINED__
typedef interface IVariantDictionary IVariantDictionary;
#endif 	/* __IVariantDictionary_FWD_DEFINED__ */


#ifndef __ISessionObject_FWD_DEFINED__
#define __ISessionObject_FWD_DEFINED__
typedef interface ISessionObject ISessionObject;
#endif 	/* __ISessionObject_FWD_DEFINED__ */


#ifndef __Session_FWD_DEFINED__
#define __Session_FWD_DEFINED__

#ifdef __cplusplus
typedef class Session Session;
#else
typedef struct Session Session;
#endif /* __cplusplus */

#endif 	/* __Session_FWD_DEFINED__ */


#ifndef __IApplicationObject_FWD_DEFINED__
#define __IApplicationObject_FWD_DEFINED__
typedef interface IApplicationObject IApplicationObject;
#endif 	/* __IApplicationObject_FWD_DEFINED__ */


#ifndef __Application_FWD_DEFINED__
#define __Application_FWD_DEFINED__

#ifdef __cplusplus
typedef class Application Application;
#else
typedef struct Application Application;
#endif /* __cplusplus */

#endif 	/* __Application_FWD_DEFINED__ */


#ifndef __IASPError_FWD_DEFINED__
#define __IASPError_FWD_DEFINED__
typedef interface IASPError IASPError;
#endif 	/* __IASPError_FWD_DEFINED__ */


#ifndef __IServer_FWD_DEFINED__
#define __IServer_FWD_DEFINED__
typedef interface IServer IServer;
#endif 	/* __IServer_FWD_DEFINED__ */


#ifndef __Server_FWD_DEFINED__
#define __Server_FWD_DEFINED__

#ifdef __cplusplus
typedef class Server Server;
#else
typedef struct Server Server;
#endif /* __cplusplus */

#endif 	/* __Server_FWD_DEFINED__ */


#ifndef __IScriptingContext_FWD_DEFINED__
#define __IScriptingContext_FWD_DEFINED__
typedef interface IScriptingContext IScriptingContext;
#endif 	/* __IScriptingContext_FWD_DEFINED__ */


#ifndef __ScriptingContext_FWD_DEFINED__
#define __ScriptingContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class ScriptingContext ScriptingContext;
#else
typedef struct ScriptingContext ScriptingContext;
#endif /* __cplusplus */

#endif 	/* __ScriptingContext_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __ASPTypeLibrary_LIBRARY_DEFINED__
#define __ASPTypeLibrary_LIBRARY_DEFINED__

/* library ASPTypeLibrary */
/* [version][lcid][helpstring][uuid] */ 


DEFINE_GUID(LIBID_ASPTypeLibrary,0xD97A6DA0,0xA85C,0x11cf,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#ifndef __IStringList_INTERFACE_DEFINED__
#define __IStringList_INTERFACE_DEFINED__

/* interface IStringList */
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IStringList,0xD97A6DA0,0xA85D,0x11cf,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A85D-11cf-83AE-00A0C90C2BD8")
    IStringList : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT i,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStringListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStringList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStringList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IStringList __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IStringList __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IStringList __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IStringList __RPC_FAR * This,
            /* [in][optional] */ VARIANT i,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IStringListVtbl;

    interface IStringList
    {
        CONST_VTBL struct IStringListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStringList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStringList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStringList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStringList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStringList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IStringList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IStringList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IStringList_get_Item(This,i,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,i,pVariantReturn)

#define IStringList_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IStringList_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get_Item_Proxy( 
    IStringList __RPC_FAR * This,
    /* [in][optional] */ VARIANT i,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IStringList_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get_Count_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IStringList_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get__NewEnum_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IStringList_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStringList_INTERFACE_DEFINED__ */


#ifndef __IRequestDictionary_INTERFACE_DEFINED__
#define __IRequestDictionary_INTERFACE_DEFINED__

/* interface IRequestDictionary */
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IRequestDictionary,0xD97A6DA0,0xA85F,0x11df,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A85F-11df-83AE-00A0C90C2BD8")
    IRequestDictionary : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequestDictionary __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequestDictionary __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequestDictionary __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IRequestDictionary __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IRequestDictionary __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        END_INTERFACE
    } IRequestDictionaryVtbl;

    interface IRequestDictionary
    {
        CONST_VTBL struct IRequestDictionaryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequestDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequestDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequestDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequestDictionary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequestDictionary_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRequestDictionary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRequestDictionary_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRequestDictionary_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IRequestDictionary_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#define IRequestDictionary_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IRequestDictionary_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Item_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [in][optional] */ VARIANT Var,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IRequestDictionary_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get__NewEnum_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IRequestDictionary_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Count_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IRequestDictionary_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Key_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IRequestDictionary_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequestDictionary_INTERFACE_DEFINED__ */


#ifndef __IRequest_INTERFACE_DEFINED__
#define __IRequest_INTERFACE_DEFINED__

/* interface IRequest */
/* [object][hidden][dual][oleautomation][uuid] */ 


DEFINE_GUID(IID_IRequest,0xD97A6DA0,0xA861,0x11cf,0x93,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A861-11cf-93AE-00A0C90C2BD8")
    IRequest : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_QueryString( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Form( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [hidden][propget] */ HRESULT STDMETHODCALLTYPE get_Body( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ServerVariables( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ClientCertificate( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_TotalBytes( 
            /* [retval][out] */ long __RPC_FAR *pcbTotal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BinaryRead( 
            /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequest __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequest __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequest __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QueryString )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Form )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [hidden][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Body )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServerVariables )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClientCertificate )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cookies )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TotalBytes )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcbTotal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BinaryRead )( 
            IRequest __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn);
        
        END_INTERFACE
    } IRequestVtbl;

    interface IRequest
    {
        CONST_VTBL struct IRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRequest_get_Item(This,bstrVar,ppObjReturn)	\
    (This)->lpVtbl -> get_Item(This,bstrVar,ppObjReturn)

#define IRequest_get_QueryString(This,ppDictReturn)	\
    (This)->lpVtbl -> get_QueryString(This,ppDictReturn)

#define IRequest_get_Form(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Form(This,ppDictReturn)

#define IRequest_get_Body(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Body(This,ppDictReturn)

#define IRequest_get_ServerVariables(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ServerVariables(This,ppDictReturn)

#define IRequest_get_ClientCertificate(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ClientCertificate(This,ppDictReturn)

#define IRequest_get_Cookies(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Cookies(This,ppDictReturn)

#define IRequest_get_TotalBytes(This,pcbTotal)	\
    (This)->lpVtbl -> get_TotalBytes(This,pcbTotal)

#define IRequest_BinaryRead(This,pvarCountToRead,pvarReturn)	\
    (This)->lpVtbl -> BinaryRead(This,pvarCountToRead,pvarReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Item_Proxy( 
    IRequest __RPC_FAR * This,
    /* [in] */ BSTR bstrVar,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);


void __RPC_STUB IRequest_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_QueryString_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_QueryString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Form_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Form_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Body_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Body_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_ServerVariables_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ServerVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_ClientCertificate_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ClientCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Cookies_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_TotalBytes_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcbTotal);


void __RPC_STUB IRequest_get_TotalBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRequest_BinaryRead_Proxy( 
    IRequest __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn);


void __RPC_STUB IRequest_BinaryRead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequest_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Request,0x920c25d0,0x25d9,0x11d0,0xa5,0x5f,0x00,0xa0,0xc9,0x0c,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("920c25d0-25d9-11d0-a55f-00a0c90c2091")
Request;
#endif

#ifndef __IReadCookie_INTERFACE_DEFINED__
#define __IReadCookie_INTERFACE_DEFINED__

/* interface IReadCookie */
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IReadCookie,0x71EAF260,0x0CE0,0x11D0,0xA5,0x3E,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71EAF260-0CE0-11D0-A53E-00A0C90C2091")
    IReadCookie : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasKeys( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReadCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReadCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReadCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReadCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IReadCookie __RPC_FAR * This,
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasKeys )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        END_INTERFACE
    } IReadCookieVtbl;

    interface IReadCookie
    {
        CONST_VTBL struct IReadCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReadCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReadCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReadCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReadCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReadCookie_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReadCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReadCookie_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReadCookie_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IReadCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IReadCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#define IReadCookie_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IReadCookie_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Item_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [in][optional] */ VARIANT Var,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IReadCookie_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_HasKeys_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);


void __RPC_STUB IReadCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get__NewEnum_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IReadCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Count_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IReadCookie_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Key_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IReadCookie_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReadCookie_INTERFACE_DEFINED__ */


#ifndef __IWriteCookie_INTERFACE_DEFINED__
#define __IWriteCookie_INTERFACE_DEFINED__

/* interface IWriteCookie */
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IWriteCookie,0xD97A6DA0,0xA862,0x11cf,0x84,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A862-11cf-84AE-00A0C90C2BD8")
    IWriteCookie : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in][optional] */ VARIANT key,
            /* [in] */ BSTR bstrValue) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Expires( 
            /* [in] */ DATE dtExpires) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Domain( 
            /* [in] */ BSTR bstrDomain) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR bstrPath) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Secure( 
            /* [in] */ VARIANT_BOOL fSecure) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasKeys( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWriteCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWriteCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWriteCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWriteCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Item )( 
            IWriteCookie __RPC_FAR * This,
            /* [in][optional] */ VARIANT key,
            /* [in] */ BSTR bstrValue);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Expires )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DATE dtExpires);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Domain )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR bstrDomain);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Path )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR bstrPath);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Secure )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fSecure);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasKeys )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IWriteCookieVtbl;

    interface IWriteCookie
    {
        CONST_VTBL struct IWriteCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWriteCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWriteCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWriteCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWriteCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWriteCookie_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWriteCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWriteCookie_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWriteCookie_put_Item(This,key,bstrValue)	\
    (This)->lpVtbl -> put_Item(This,key,bstrValue)

#define IWriteCookie_put_Expires(This,dtExpires)	\
    (This)->lpVtbl -> put_Expires(This,dtExpires)

#define IWriteCookie_put_Domain(This,bstrDomain)	\
    (This)->lpVtbl -> put_Domain(This,bstrDomain)

#define IWriteCookie_put_Path(This,bstrPath)	\
    (This)->lpVtbl -> put_Path(This,bstrPath)

#define IWriteCookie_put_Secure(This,fSecure)	\
    (This)->lpVtbl -> put_Secure(This,fSecure)

#define IWriteCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IWriteCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Item_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in][optional] */ VARIANT key,
    /* [in] */ BSTR bstrValue);


void __RPC_STUB IWriteCookie_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Expires_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ DATE dtExpires);


void __RPC_STUB IWriteCookie_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Domain_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR bstrDomain);


void __RPC_STUB IWriteCookie_put_Domain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Path_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR bstrPath);


void __RPC_STUB IWriteCookie_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Secure_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fSecure);


void __RPC_STUB IWriteCookie_put_Secure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IWriteCookie_get_HasKeys_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);


void __RPC_STUB IWriteCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWriteCookie_get__NewEnum_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IWriteCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWriteCookie_INTERFACE_DEFINED__ */


#ifndef __IResponse_INTERFACE_DEFINED__
#define __IResponse_INTERFACE_DEFINED__

/* interface IResponse */
/* [object][hidden][dual][oleautomation][uuid] */ 


DEFINE_GUID(IID_IResponse,0xD97A6DA0,0xA864,0x11cf,0x83,0xBE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A864-11cf-83BE-00A0C90C2BD8")
    IResponse : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Buffer( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Buffer( 
            /* [in] */ VARIANT_BOOL fIsBuffering) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ContentType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ContentType( 
            /* [in] */ BSTR bstrContentType) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Expires( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Expires( 
            /* [in] */ long lExpiresMinutes) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ExpiresAbsolute( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ExpiresAbsolute( 
            /* [in] */ DATE dtExpires) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Status( 
            /* [in] */ BSTR bstrStatus) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddHeader( 
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppendToLog( 
            /* [in] */ BSTR bstrLogEntry) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BinaryWrite( 
            /* [in] */ VARIANT varInput) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Redirect( 
            /* [in] */ BSTR bstrURL) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ VARIANT varText) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE WriteBlock( 
            /* [in] */ short iBlockNumber) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsClientConnected( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CharSet( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CharSet( 
            /* [in] */ BSTR bstrCharSet) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Pics( 
            /* [in] */ BSTR bstrHeaderValue) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CacheControl( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CacheControl( 
            /* [in] */ BSTR bstrCacheControl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResponseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResponse __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResponse __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IResponse __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IResponse __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IResponse __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fIsBuffering);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrContentType);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Expires )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Expires )( 
            IResponse __RPC_FAR * This,
            /* [in] */ long lExpiresMinutes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [in] */ DATE dtExpires);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cookies )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Status )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrStatus);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddHeader )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendToLog )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrLogEntry);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BinaryWrite )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varInput);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Flush )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redirect )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrURL);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varText);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteBlock )( 
            IResponse __RPC_FAR * This,
            /* [in] */ short iBlockNumber);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsClientConnected )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CharSet )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CharSet )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrCharSet);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pics )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CacheControl )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CacheControl )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrCacheControl);
        
        END_INTERFACE
    } IResponseVtbl;

    interface IResponse
    {
        CONST_VTBL struct IResponseVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResponse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResponse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResponse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResponse_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IResponse_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IResponse_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IResponse_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IResponse_get_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> get_Buffer(This,fIsBuffering)

#define IResponse_put_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> put_Buffer(This,fIsBuffering)

#define IResponse_get_ContentType(This,pbstrContentTypeRet)	\
    (This)->lpVtbl -> get_ContentType(This,pbstrContentTypeRet)

#define IResponse_put_ContentType(This,bstrContentType)	\
    (This)->lpVtbl -> put_ContentType(This,bstrContentType)

#define IResponse_get_Expires(This,pvarExpiresMinutesRet)	\
    (This)->lpVtbl -> get_Expires(This,pvarExpiresMinutesRet)

#define IResponse_put_Expires(This,lExpiresMinutes)	\
    (This)->lpVtbl -> put_Expires(This,lExpiresMinutes)

#define IResponse_get_ExpiresAbsolute(This,pvarExpiresRet)	\
    (This)->lpVtbl -> get_ExpiresAbsolute(This,pvarExpiresRet)

#define IResponse_put_ExpiresAbsolute(This,dtExpires)	\
    (This)->lpVtbl -> put_ExpiresAbsolute(This,dtExpires)

#define IResponse_get_Cookies(This,ppCookies)	\
    (This)->lpVtbl -> get_Cookies(This,ppCookies)

#define IResponse_get_Status(This,pbstrStatusRet)	\
    (This)->lpVtbl -> get_Status(This,pbstrStatusRet)

#define IResponse_put_Status(This,bstrStatus)	\
    (This)->lpVtbl -> put_Status(This,bstrStatus)

#define IResponse_Add(This,bstrHeaderValue,bstrHeaderName)	\
    (This)->lpVtbl -> Add(This,bstrHeaderValue,bstrHeaderName)

#define IResponse_AddHeader(This,bstrHeaderName,bstrHeaderValue)	\
    (This)->lpVtbl -> AddHeader(This,bstrHeaderName,bstrHeaderValue)

#define IResponse_AppendToLog(This,bstrLogEntry)	\
    (This)->lpVtbl -> AppendToLog(This,bstrLogEntry)

#define IResponse_BinaryWrite(This,varInput)	\
    (This)->lpVtbl -> BinaryWrite(This,varInput)

#define IResponse_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IResponse_End(This)	\
    (This)->lpVtbl -> End(This)

#define IResponse_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#define IResponse_Redirect(This,bstrURL)	\
    (This)->lpVtbl -> Redirect(This,bstrURL)

#define IResponse_Write(This,varText)	\
    (This)->lpVtbl -> Write(This,varText)

#define IResponse_WriteBlock(This,iBlockNumber)	\
    (This)->lpVtbl -> WriteBlock(This,iBlockNumber)

#define IResponse_IsClientConnected(This,pfIsClientConnected)	\
    (This)->lpVtbl -> IsClientConnected(This,pfIsClientConnected)

#define IResponse_get_CharSet(This,pbstrCharSetRet)	\
    (This)->lpVtbl -> get_CharSet(This,pbstrCharSetRet)

#define IResponse_put_CharSet(This,bstrCharSet)	\
    (This)->lpVtbl -> put_CharSet(This,bstrCharSet)

#define IResponse_Pics(This,bstrHeaderValue)	\
    (This)->lpVtbl -> Pics(This,bstrHeaderValue)

#define IResponse_get_CacheControl(This,pbstrCacheControl)	\
    (This)->lpVtbl -> get_CacheControl(This,pbstrCacheControl)

#define IResponse_put_CacheControl(This,bstrCacheControl)	\
    (This)->lpVtbl -> put_CacheControl(This,bstrCacheControl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering);


void __RPC_STUB IResponse_get_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fIsBuffering);


void __RPC_STUB IResponse_put_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);


void __RPC_STUB IResponse_get_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrContentType);


void __RPC_STUB IResponse_put_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);


void __RPC_STUB IResponse_get_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ long lExpiresMinutes);


void __RPC_STUB IResponse_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);


void __RPC_STUB IResponse_get_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ DATE dtExpires);


void __RPC_STUB IResponse_put_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_get_Cookies_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);


void __RPC_STUB IResponse_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);


void __RPC_STUB IResponse_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrStatus);


void __RPC_STUB IResponse_put_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IResponse_Add_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderValue,
    /* [in] */ BSTR bstrHeaderName);


void __RPC_STUB IResponse_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_AddHeader_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderName,
    /* [in] */ BSTR bstrHeaderValue);


void __RPC_STUB IResponse_AddHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_AppendToLog_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrLogEntry);


void __RPC_STUB IResponse_AppendToLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_BinaryWrite_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varInput);


void __RPC_STUB IResponse_BinaryWrite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Clear_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_End_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Flush_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Redirect_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrURL);


void __RPC_STUB IResponse_Redirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Write_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varText);


void __RPC_STUB IResponse_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IResponse_WriteBlock_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ short iBlockNumber);


void __RPC_STUB IResponse_WriteBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_IsClientConnected_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected);


void __RPC_STUB IResponse_IsClientConnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_CharSet_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet);


void __RPC_STUB IResponse_get_CharSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_CharSet_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrCharSet);


void __RPC_STUB IResponse_put_CharSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Pics_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderValue);


void __RPC_STUB IResponse_Pics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_CacheControl_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl);


void __RPC_STUB IResponse_get_CacheControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_CacheControl_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrCacheControl);


void __RPC_STUB IResponse_put_CacheControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResponse_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Response,0x46E19BA0,0x25DD,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("46E19BA0-25DD-11D0-A55F-00A0C90C2091")
Response;
#endif

#ifndef __IVariantDictionary_INTERFACE_DEFINED__
#define __IVariantDictionary_INTERFACE_DEFINED__

/* interface IVariantDictionary */
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IVariantDictionary,0x4a7deb90,0xb069,0x11d0,0xb3,0x73,0x00,0xa0,0xc9,0x0c,0x2b,0xd8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a7deb90-b069-11d0-b373-00a0c90c2bd8")
    IVariantDictionary : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Item( 
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT VarKey) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVariantDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVariantDictionary __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVariantDictionary __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVariantDictionary __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IVariantDictionary __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IVariantDictionary __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAll )( 
            IVariantDictionary __RPC_FAR * This);
        
        END_INTERFACE
    } IVariantDictionaryVtbl;

    interface IVariantDictionary
    {
        CONST_VTBL struct IVariantDictionaryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVariantDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVariantDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVariantDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVariantDictionary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVariantDictionary_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVariantDictionary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVariantDictionary_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVariantDictionary_get_Item(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Item(This,VarKey,pvar)

#define IVariantDictionary_put_Item(This,VarKey,var)	\
    (This)->lpVtbl -> put_Item(This,VarKey,var)

#define IVariantDictionary_putref_Item(This,VarKey,var)	\
    (This)->lpVtbl -> putref_Item(This,VarKey,var)

#define IVariantDictionary_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#define IVariantDictionary_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IVariantDictionary_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#define IVariantDictionary_Remove(This,VarKey)	\
    (This)->lpVtbl -> Remove(This,VarKey)

#define IVariantDictionary_RemoveAll(This)	\
    (This)->lpVtbl -> RemoveAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IVariantDictionary_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_put_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [in] */ VARIANT var);


void __RPC_STUB IVariantDictionary_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_putref_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [in] */ VARIANT var);


void __RPC_STUB IVariantDictionary_putref_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Key_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IVariantDictionary_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Count_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IVariantDictionary_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get__NewEnum_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IVariantDictionary_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_Remove_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey);


void __RPC_STUB IVariantDictionary_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_RemoveAll_Proxy( 
    IVariantDictionary __RPC_FAR * This);


void __RPC_STUB IVariantDictionary_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVariantDictionary_INTERFACE_DEFINED__ */


#ifndef __ISessionObject_INTERFACE_DEFINED__
#define __ISessionObject_INTERFACE_DEFINED__

/* interface ISessionObject */
/* [object][hidden][oleautomation][dual][uuid] */ 


DEFINE_GUID(IID_ISessionObject,0xD97A6DA0,0xA865,0x11cf,0x83,0xAF,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A865-11cf-83AF-00A0C90C2BD8")
    ISessionObject : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SessionID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Timeout( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Timeout( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Abandon( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CodePage( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CodePage( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LCID( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LCID( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StaticObjects( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Contents( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISessionObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISessionObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISessionObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISessionObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SessionID )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abandon )( 
            ISessionObject __RPC_FAR * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CodePage )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CodePage )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LCID )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LCID )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StaticObjects )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contents )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } ISessionObjectVtbl;

    interface ISessionObject
    {
        CONST_VTBL struct ISessionObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISessionObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISessionObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISessionObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISessionObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISessionObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISessionObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISessionObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISessionObject_get_SessionID(This,pbstrRet)	\
    (This)->lpVtbl -> get_SessionID(This,pbstrRet)

#define ISessionObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define ISessionObject_put_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,var)

#define ISessionObject_putref_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,var)

#define ISessionObject_get_Timeout(This,plvar)	\
    (This)->lpVtbl -> get_Timeout(This,plvar)

#define ISessionObject_put_Timeout(This,lvar)	\
    (This)->lpVtbl -> put_Timeout(This,lvar)

#define ISessionObject_Abandon(This)	\
    (This)->lpVtbl -> Abandon(This)

#define ISessionObject_get_CodePage(This,plvar)	\
    (This)->lpVtbl -> get_CodePage(This,plvar)

#define ISessionObject_put_CodePage(This,lvar)	\
    (This)->lpVtbl -> put_CodePage(This,lvar)

#define ISessionObject_get_LCID(This,plvar)	\
    (This)->lpVtbl -> get_LCID(This,plvar)

#define ISessionObject_put_LCID(This,lvar)	\
    (This)->lpVtbl -> put_LCID(This,lvar)

#define ISessionObject_get_StaticObjects(This,ppTaggedObjects)	\
    (This)->lpVtbl -> get_StaticObjects(This,ppTaggedObjects)

#define ISessionObject_get_Contents(This,ppProperties)	\
    (This)->lpVtbl -> get_Contents(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_SessionID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);


void __RPC_STUB ISessionObject_get_SessionID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB ISessionObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB ISessionObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_putref_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB ISessionObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISessionObject_Abandon_Proxy( 
    ISessionObject __RPC_FAR * This);


void __RPC_STUB ISessionObject_Abandon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_CodePage_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_CodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_CodePage_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_CodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_LCID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_LCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_LCID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_LCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_StaticObjects_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects);


void __RPC_STUB ISessionObject_get_StaticObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Contents_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ISessionObject_get_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISessionObject_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Session,0x509F8F20,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("509F8F20-25DE-11D0-A55F-00A0C90C2091")
Session;
#endif

#ifndef __IApplicationObject_INTERFACE_DEFINED__
#define __IApplicationObject_INTERFACE_DEFINED__

/* interface IApplicationObject */
/* [object][hidden][dual][oleautomation][uuid] */ 


DEFINE_GUID(IID_IApplicationObject,0xD97A6DA0,0xA866,0x11cf,0x83,0xAE,0x10,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A866-11cf-83AE-10A0C90C2BD8")
    IApplicationObject : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Lock( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnLock( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StaticObjects( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Contents( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IApplicationObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IApplicationObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IApplicationObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Lock )( 
            IApplicationObject __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnLock )( 
            IApplicationObject __RPC_FAR * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StaticObjects )( 
            IApplicationObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contents )( 
            IApplicationObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } IApplicationObjectVtbl;

    interface IApplicationObject
    {
        CONST_VTBL struct IApplicationObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IApplicationObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IApplicationObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IApplicationObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IApplicationObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IApplicationObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IApplicationObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IApplicationObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define IApplicationObject_put_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,var)

#define IApplicationObject_putref_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,var)

#define IApplicationObject_Lock(This)	\
    (This)->lpVtbl -> Lock(This)

#define IApplicationObject_UnLock(This)	\
    (This)->lpVtbl -> UnLock(This)

#define IApplicationObject_get_StaticObjects(This,ppProperties)	\
    (This)->lpVtbl -> get_StaticObjects(This,ppProperties)

#define IApplicationObject_get_Contents(This,ppProperties)	\
    (This)->lpVtbl -> get_Contents(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IApplicationObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_put_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB IApplicationObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_putref_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB IApplicationObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IApplicationObject_Lock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IApplicationObject_UnLock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_UnLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_StaticObjects_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB IApplicationObject_get_StaticObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_Contents_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB IApplicationObject_get_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IApplicationObject_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Application,0x7C3BAF00,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("7C3BAF00-25DE-11D0-A55F-00A0C90C2091")
Application;
#endif

#ifndef __IASPError_INTERFACE_DEFINED__
#define __IASPError_INTERFACE_DEFINED__

/* interface IASPError */
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IASPError,0xF5A6893E,0xA0F5,0x11d1,0x8C,0x4B,0x00,0xC0,0x4F,0xC3,0x24,0xA4);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F5A6893E-A0F5-11d1-8C4B-00C04FC324A4")
    IASPError : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ASPCode( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrASPCode) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Number( 
            /* [retval][out] */ long __RPC_FAR *plNumber) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Category( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSource) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_File( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFileName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Line( 
            /* [retval][out] */ long __RPC_FAR *plLineNumber) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ASPDescription( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Column( 
            /* [retval][out] */ long __RPC_FAR *plColumn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Source( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrLineText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IASPErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IASPError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IASPError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IASPError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IASPError __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IASPError __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IASPError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IASPError __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ASPCode )( 
            IASPError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrASPCode);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Number )( 
            IASPError __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plNumber);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Category )( 
            IASPError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSource);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_File )( 
            IASPError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFileName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Line )( 
            IASPError __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plLineNumber);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IASPError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ASPDescription )( 
            IASPError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Column )( 
            IASPError __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plColumn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Source )( 
            IASPError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrLineText);
        
        END_INTERFACE
    } IASPErrorVtbl;

    interface IASPError
    {
        CONST_VTBL struct IASPErrorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IASPError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IASPError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IASPError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IASPError_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IASPError_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IASPError_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IASPError_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IASPError_get_ASPCode(This,pbstrASPCode)	\
    (This)->lpVtbl -> get_ASPCode(This,pbstrASPCode)

#define IASPError_get_Number(This,plNumber)	\
    (This)->lpVtbl -> get_Number(This,plNumber)

#define IASPError_get_Category(This,pbstrSource)	\
    (This)->lpVtbl -> get_Category(This,pbstrSource)

#define IASPError_get_File(This,pbstrFileName)	\
    (This)->lpVtbl -> get_File(This,pbstrFileName)

#define IASPError_get_Line(This,plLineNumber)	\
    (This)->lpVtbl -> get_Line(This,plLineNumber)

#define IASPError_get_Description(This,pbstrDescription)	\
    (This)->lpVtbl -> get_Description(This,pbstrDescription)

#define IASPError_get_ASPDescription(This,pbstrDescription)	\
    (This)->lpVtbl -> get_ASPDescription(This,pbstrDescription)

#define IASPError_get_Column(This,plColumn)	\
    (This)->lpVtbl -> get_Column(This,plColumn)

#define IASPError_get_Source(This,pbstrLineText)	\
    (This)->lpVtbl -> get_Source(This,pbstrLineText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IASPError_get_ASPCode_Proxy( 
    IASPError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrASPCode);


void __RPC_STUB IASPError_get_ASPCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IASPError_get_Number_Proxy( 
    IASPError __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plNumber);


void __RPC_STUB IASPError_get_Number_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IASPError_get_Category_Proxy( 
    IASPError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrSource);


void __RPC_STUB IASPError_get_Category_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IASPError_get_File_Proxy( 
    IASPError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFileName);


void __RPC_STUB IASPError_get_File_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IASPError_get_Line_Proxy( 
    IASPError __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plLineNumber);


void __RPC_STUB IASPError_get_Line_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IASPError_get_Description_Proxy( 
    IASPError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription);


void __RPC_STUB IASPError_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IASPError_get_ASPDescription_Proxy( 
    IASPError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDescription);


void __RPC_STUB IASPError_get_ASPDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IASPError_get_Column_Proxy( 
    IASPError __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plColumn);


void __RPC_STUB IASPError_get_Column_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IASPError_get_Source_Proxy( 
    IASPError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrLineText);


void __RPC_STUB IASPError_get_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IASPError_INTERFACE_DEFINED__ */


#ifndef __IServer_INTERFACE_DEFINED__
#define __IServer_INTERFACE_DEFINED__

/* interface IServer */
/* [object][hidden][dual][oleautomation][uuid] */ 


DEFINE_GUID(IID_IServer,0xD97A6DA0,0xA867,0x11cf,0x83,0xAE,0x01,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A867-11cf-83AE-01A0C90C2BD8")
    IServer : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ScriptTimeout( 
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ScriptTimeout( 
            /* [in] */ long lTimeoutSeconds) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateObject( 
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE HTMLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapPath( 
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE URLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE URLPathEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ BSTR bstrLogicalPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Transfer( 
            /* [in] */ BSTR bstrLogicalPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLastError( 
            /* [retval][out] */ IASPError __RPC_FAR *__RPC_FAR *ppASPErrorObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IServer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IServer __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IServer __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [in] */ long lTimeoutSeconds);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateObject )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HTMLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapPath )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *URLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *URLPathEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Execute )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrLogicalPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Transfer )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrLogicalPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastError )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ IASPError __RPC_FAR *__RPC_FAR *ppASPErrorObject);
        
        END_INTERFACE
    } IServerVtbl;

    interface IServer
    {
        CONST_VTBL struct IServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IServer_get_ScriptTimeout(This,plTimeoutSeconds)	\
    (This)->lpVtbl -> get_ScriptTimeout(This,plTimeoutSeconds)

#define IServer_put_ScriptTimeout(This,lTimeoutSeconds)	\
    (This)->lpVtbl -> put_ScriptTimeout(This,lTimeoutSeconds)

#define IServer_CreateObject(This,bstrProgID,ppDispObject)	\
    (This)->lpVtbl -> CreateObject(This,bstrProgID,ppDispObject)

#define IServer_HTMLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> HTMLEncode(This,bstrIn,pbstrEncoded)

#define IServer_MapPath(This,bstrLogicalPath,pbstrPhysicalPath)	\
    (This)->lpVtbl -> MapPath(This,bstrLogicalPath,pbstrPhysicalPath)

#define IServer_URLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> URLEncode(This,bstrIn,pbstrEncoded)

#define IServer_URLPathEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> URLPathEncode(This,bstrIn,pbstrEncoded)

#define IServer_Execute(This,bstrLogicalPath)	\
    (This)->lpVtbl -> Execute(This,bstrLogicalPath)

#define IServer_Transfer(This,bstrLogicalPath)	\
    (This)->lpVtbl -> Transfer(This,bstrLogicalPath)

#define IServer_GetLastError(This,ppASPErrorObject)	\
    (This)->lpVtbl -> GetLastError(This,ppASPErrorObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IServer_get_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);


void __RPC_STUB IServer_get_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IServer_put_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ long lTimeoutSeconds);


void __RPC_STUB IServer_put_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_CreateObject_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrProgID,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);


void __RPC_STUB IServer_CreateObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_HTMLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_HTMLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_MapPath_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrLogicalPath,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);


void __RPC_STUB IServer_MapPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_URLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_URLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IServer_URLPathEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_URLPathEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_Execute_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrLogicalPath);


void __RPC_STUB IServer_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_Transfer_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrLogicalPath);


void __RPC_STUB IServer_Transfer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_GetLastError_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ IASPError __RPC_FAR *__RPC_FAR *ppASPErrorObject);


void __RPC_STUB IServer_GetLastError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServer_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Server,0xA506D160,0x25E0,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("A506D160-25E0-11D0-A55F-00A0C90C2091")
Server;
#endif

#ifndef __IScriptingContext_INTERFACE_DEFINED__
#define __IScriptingContext_INTERFACE_DEFINED__

/* interface IScriptingContext */
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 


DEFINE_GUID(IID_IScriptingContext,0xD97A6DA0,0xA868,0x11cf,0x83,0xAE,0x00,0xB0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A868-11cf-83AE-00B0C90C2BD8")
    IScriptingContext : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Request( 
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Response( 
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Server( 
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScriptingContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScriptingContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScriptingContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IScriptingContext __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Request )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Response )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Server )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);
        
        END_INTERFACE
    } IScriptingContextVtbl;

    interface IScriptingContext
    {
        CONST_VTBL struct IScriptingContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptingContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptingContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScriptingContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScriptingContext_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IScriptingContext_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IScriptingContext_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IScriptingContext_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IScriptingContext_get_Request(This,ppRequest)	\
    (This)->lpVtbl -> get_Request(This,ppRequest)

#define IScriptingContext_get_Response(This,ppResponse)	\
    (This)->lpVtbl -> get_Response(This,ppResponse)

#define IScriptingContext_get_Server(This,ppServer)	\
    (This)->lpVtbl -> get_Server(This,ppServer)

#define IScriptingContext_get_Session(This,ppSession)	\
    (This)->lpVtbl -> get_Session(This,ppSession)

#define IScriptingContext_get_Application(This,ppApplication)	\
    (This)->lpVtbl -> get_Application(This,ppApplication)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Request_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);


void __RPC_STUB IScriptingContext_get_Request_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Response_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);


void __RPC_STUB IScriptingContext_get_Response_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Server_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);


void __RPC_STUB IScriptingContext_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Session_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);


void __RPC_STUB IScriptingContext_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Application_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);


void __RPC_STUB IScriptingContext_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScriptingContext_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_ScriptingContext,0xD97A6DA0,0xA868,0x11cf,0x83,0xAE,0x11,0xB0,0xC9,0x0C,0x2B,0xD8);

#ifdef __cplusplus

class DECLSPEC_UUID("D97A6DA0-A868-11cf-83AE-11B0C90C2BD8")
ScriptingContext;
#endif
#endif /* __ASPTypeLibrary_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\aspnetetw.h ===
/**
 * AspNetEtw.h
 *
 * Copyright (c) 2001 Microsoft Corporation
 */

HRESULT EtwTraceAspNetRegister();
HRESULT EtwTraceAspNetUnregister();
HRESULT EtwTraceAspNetPageStart( HCONN ConnId );
HRESULT EtwTraceAspNetPageEnd( HCONN ConnId );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\aspnetverlist.h ===
/**
 * aspnetverlist.h
 *
 * Header file for CASPNET_VER_LIST
 * 
 * Copyright (c) 1998-2001, Microsoft Corporation
 * 
 */
#pragma once

#include <ary.h>
#include <ndll.h>

class CASPNET_VER_LIST {
public:
    CASPNET_VER_LIST();
    ~CASPNET_VER_LIST();

    HRESULT     Add(WCHAR *pchVersion, DWORD dwStatus, WCHAR *pchDllPath, WCHAR *pchInstallPath);

    WCHAR       *GetVersion(int i);
    DWORD       GetStatus(int i);
    WCHAR       *GetPath(int i);
    WCHAR       *GetInstallPath(int i);
    int         Size() { return m_VerInfoAry.Size(); }

private:

    typedef CDataAry<ASPNET_VERSION_INFO *> CAspnetVerInfoAry;

    CAspnetVerInfoAry   m_VerInfoAry;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\dirmoncompletion.h ===
/**
 * DirMonCompletion definition.
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _DIRMONCOMPLETION_H
#define _DIRMONCOMPLETION_H

#include "util.h"

/**
 * Callback for file change notifications.
 * managed delegates are marshaled as this callback.
 */
typedef void (__stdcall *PFNDIRMONCALLBACK)(int action, WCHAR *pFilename);


#define RDCW_FILTER_FILE_AND_DIR_CHANGES        \
	(FILE_NOTIFY_CHANGE_FILE_NAME | 	\
         FILE_NOTIFY_CHANGE_DIR_NAME |		\
         FILE_NOTIFY_CHANGE_CREATION |		\
         FILE_NOTIFY_CHANGE_SIZE |		\
         FILE_NOTIFY_CHANGE_LAST_WRITE |        \
         FILE_NOTIFY_CHANGE_ATTRIBUTES |        \
         FILE_NOTIFY_CHANGE_SECURITY)

#define RDCW_FILTER_FILE_CHANGES                \
	(FILE_NOTIFY_CHANGE_FILE_NAME | 	\
         FILE_NOTIFY_CHANGE_CREATION |		\
         FILE_NOTIFY_CHANGE_SIZE |		\
         FILE_NOTIFY_CHANGE_LAST_WRITE |        \
         FILE_NOTIFY_CHANGE_ATTRIBUTES |        \
         FILE_NOTIFY_CHANGE_SECURITY)

#define RDCW_FILTER_DIR_RENAMES             FILE_NOTIFY_CHANGE_DIR_NAME


/**
 * Directory monitor that implements ICompletion. Watches changes file
 * changes for a single driectory.
 */
class DirMonCompletion : public Completion
{
public:
    DirMonCompletion();
    ~DirMonCompletion();

    DECLARE_MEMCLEAR_NEW_DELETE();

    HRESULT Init(WCHAR *pDir, BOOL watchSubtrees, DWORD notifyFilter, PFNDIRMONCALLBACK callback);
    HRESULT Close();

    // ICompletion interface

    STDMETHOD(ProcessCompletion)(HRESULT, int, LPOVERLAPPED);

private:
    HRESULT Monitor();
    HRESULT GrowNotificationBuffer();
    HRESULT ProcessOneFileNotification(FILE_NOTIFY_INFORMATION *pInfo);
    void CallCallback(int action, WCHAR *pFilename);

private:
    long    _numCalls;              // number of active callbacks
    HANDLE  _dirHandle;             // open directory handle
    WCHAR*  _dirName;		    // for diagnostics 

    PFNDIRMONCALLBACK _callback;    // the delegate marshaled as callback

    BYTE *  _pBuffer;               // buffer for the changes
    int     _bufferSize;            // current buffer size

    DWORD   _notifyFilter;          // notify filter
    BOOL    _watchSubdirs; 	    // watch subdirs? 
};


HRESULT
__stdcall
DirMonOpen(
    LPCWSTR pDir,
    BOOL watchSubtree,
    DWORD notifyFilter,
    PFNDIRMONCALLBACK pCallbackDelegate,
    DirMonCompletion ** ppCompletion);

void
__stdcall
DirMonClose(DirMonCompletion *pDirMon);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\dbg.h ===
/**
 * dbg.h
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

#pragma once

/*
 * ASP.NET debugging functionality includes the following:
 * 
 * C++: ASSERT(assertion), ASSERTMSG(assertion, msg), and VERIFY(statement)
 * C#:  Debug.Assert(assertion), Debug.Assert(assertion, message)
 * 
 *     These are self-explanatory. Note that C# does not have Verify
 *     because there is no way to remove a call to the function while
 *     still evaluating its arguments.
 * 
 * C++: TRACE(tag, msg), TRACE1(tag, msg, a1), ...
 * C#:  Debug.Trace(tag, message)
 * 
 *     These print a message to the debugger.
 * 
 * C++: DbgIsTagEnabled(tag)
 * C#:  Debug.IsTagEnabled(tag)
 * 
 *     These determine whether a tag is enabled (non-zero).
 * 
 * All of the above are controlled by "tags". Tags are strings that
 * have one of the following values:
 * 
 *     0 - does not print or break
 *     1 - prints, but does not break
 *     2 - prints and breaks
 * 
 * Tags are intended to allow developers to add trace code specific to
 * a module that can be turned on and off. For example, the following
 * C# code prints a message specific to caching:
 *     
 *     Debug.Trace("Cache", "Cache hit: " + key);
 * 
 * And the following executes code when a tag is enabled:
 * 
 *     #if DBG
 *     if (Debug.IsTagEnabled("Cache"))
 *     {
 *         Cache.UpdateStats();
 *         Cache.PrintStats();
 *     }
 *     #endif
 * 
 * There are three tags that are always defined:
 * 
 *     TAG_INTERNAL = "Internal"
 *         This tag is for notifying ourselves of serious problems.
 * 
 *         TAG_INTERNAL defaults to 1.
 * 
 *     TAG_EXTERNAL = "External"
 *         This tag is for notifying users of our APIs that they have
 *         used them erroneously.
 * 
 *         TAG_EXTERNAL defaults to 1.
 *          
 *     "Assert"
 *         This tag is for controlling asserts. It should not be used directly.
 *         
 *         "Assert" defaults to 2.
 * 
 * All other tags default to a value of 0.
 * 
 * Tag values can be specified as DWORD values in the registry at the following key:
 * 
 *         "HKEY_LOCAL_MACHINE\Software\Microsoft\ASP.NET\Debug"
 * 
 * They can be altered during a session - the debug code is notified when the 
 * values of this key are added/deleted/modified and refreshes its values. 
 * Note, however, that the key itself cannot be added or deleted while the
 * debugging library is in use.
 * 
 * Xsptool can also be used to retrieve and set these values with the
 * functions Util.ListDebug, Util.SetDebug, and Util.GetDebug
 */


extern "C"
{
int
MessageBoxOnThread(HWND hwnd, WCHAR *text,  WCHAR *caption, int type);

/*
 * These functions should only be accessed through macros.
 */
BOOL    
DbgpIsTagEnabled(WCHAR * tag);

BOOL    
DbgpIsTagPresent(WCHAR * tag);

void
DbgpDisableAssertThread(BOOL Disable);

BOOL 
DbgpAssert(const WCHAR * component, char const * message, char const * file, int line, char const * stacktrace);

BOOL __cdecl
DbgpTrace(const WCHAR * component, WCHAR * tag, WCHAR *format, ...);

BOOL 
DbgpTraceV(const WCHAR * component, WCHAR * tag, WCHAR *format, va_list args);

BOOL 
DbgpTraceError(HRESULT hr, const WCHAR * component, char *file, int line);

void
DbgpStopNotificationThread();
}


//
// undef things we redefine below
//

#ifdef ASSERT
#undef ASSERT
#endif

#ifdef ASSERTMSG
#undef ASSERTMSG
#endif

#if DBG

extern const WCHAR *    DbgComponent;
extern DWORD            g_dwFALSE; // global variable used to keep compiler from complaining about constant expressions.

#define DEFINE_DBG_COMPONENT(x)         \
    const WCHAR * DbgComponent = x;     \
    DWORD           g_dwFALSE

#if defined(_M_IX86)
    #define DbgBreak() _asm { int 3 }
#else
    #define DbgBreak() DebugBreak()
#endif

#define DbgIsTagEnabled(x)          DbgpIsTagEnabled(x)
#define DbgIsTagPresent(x)          DbgpIsTagPresent(x)
#define DbgDisableAssertThread(x)   DbgpDisableAssertThread(x)
#define DbgStopNotificationThread() DbgpStopNotificationThread()

#define ASSERT(x) 	  do { if (!((DWORD)(x)|g_dwFALSE) && DbgpAssert(DbgComponent, #x, __FILE__, __LINE__, NULL)) DbgBreak(); } while (g_dwFALSE)
#define ASSERTMSG(x, msg) do { if (!((DWORD)(x)|g_dwFALSE) && DbgpAssert(DbgComponent, msg, __FILE__, __LINE__, NULL)) DbgBreak(); } while (g_dwFALSE)

#define VERIFY(x)	ASSERT(x)

#define TRACE(tag, fmt)                                 do { if (DbgpTrace(DbgComponent, tag, fmt)) DbgBreak(); } while (g_dwFALSE)                     
#define TRACE1(tag, fmt, a1)                            do { if (DbgpTrace(DbgComponent, tag, fmt, a1)) DbgBreak(); } while (g_dwFALSE)                 
#define TRACE2(tag, fmt, a1, a2)                        do { if (DbgpTrace(DbgComponent, tag, fmt, a1, a2)) DbgBreak(); } while (g_dwFALSE)             
#define TRACE3(tag, fmt, a1, a2, a3)                    do { if (DbgpTrace(DbgComponent, tag, fmt, a1, a2, a3)) DbgBreak(); } while (g_dwFALSE)         
#define TRACE4(tag, fmt, a1, a2, a3, a4)                do { if (DbgpTrace(DbgComponent, tag, fmt, a1, a2, a3, a4)) DbgBreak(); } while (g_dwFALSE)     
#define TRACE5(tag, fmt, a1, a2, a3, a4, a5)            do { if (DbgpTrace(DbgComponent, tag, fmt, a1, a2, a3, a4, a5)) DbgBreak(); } while (g_dwFALSE) 
#define TRACE6(tag, fmt, a1, a2, a3, a4, a5, a6)        do { if (DbgpTrace(DbgComponent, tag, fmt, a1, a2, a3, a4, a5, a6)) DbgBreak(); } while (g_dwFALSE)
#define TRACE7(tag, fmt, a1, a2, a3, a4, a5, a6, a7)    do { if (DbgpTrace(DbgComponent, tag, fmt, a1, a2, a3, a4, a5, a6, a7)) DbgBreak(); } while (g_dwFALSE)

#define TRACE_ERROR(hr)                     do { if (DbgpTraceError(hr, DbgComponent, __FILE__, __LINE__)) DbgBreak(); } while (g_dwFALSE)

#define TAG_INTERNAL L"Internal"
#define TAG_EXTERNAL L"External"
#define TAG_ALL      L"*"


#else

#define DEFINE_DBG_COMPONENT(x)

#define DbgBreak()
#define DbgIsTagEnabled(x)          
#define DbgIsTagPresent(x)          
#define DbgDisableAssertThread(x)
#define DbgStopNotificationThread()

#define ASSERT(x)
#define ASSERTMSG(x, sz)

#define VERIFY(x) x

#define ASSERT(x)
#define TRACE(tag, fmt)
#define TRACE1(tag, fmt, a1)
#define TRACE2(tag, fmt, a1, a2)
#define TRACE3(tag, fmt, a1, a2, a3)
#define TRACE4(tag, fmt, a1, a2, a3, a4)
#define TRACE5(tag, fmt, a1, a2, a3, a4, a5)
#define TRACE6(tag, fmt, a1, a2, a3, a4, a5, a6)
#define TRACE7(tag, fmt, a1, a2, a3, a4, a5, a6, a7)

#define TRACE_ERROR(hr)

#define TAG_INTERNAL
#define TAG_EXTERNAL
#define TAG_ALL

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\dummy.cxx ===
//------------------------------------------------------------------------------
// <copyright file="dummy.cxx" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   dummy.cxx
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\hashtable.h ===
/**
 * Simple hashtable
 * 
 * Copyright (c) 1999, Microsoft Corporation
 * 
 */

#pragma once

/**
 * One link in a chain (remembers [copy of] the key)
 */
class HashtableLink
{
private:
	long      _keyHash;         // hash code
	int       _keyLength;       // key length in bytes
    BYTE     *_pKey;            // key
public:
    void     *_pValue;          // value
    HashtableLink *_pNext;      // next link in chain
    

    inline HashtableLink::HashtableLink()
    {
        _pKey = NULL;
    }

    inline HashtableLink::~HashtableLink()
    {
        delete [] _pKey;
    }

    inline HRESULT Init(BYTE *pKey, int keyLength, long keyHash, void *pValue)
    {
        HRESULT hr = S_OK;

        _pKey = (BYTE*)MemDup(pKey, keyLength);
        ON_OOM_EXIT(_pKey);

        _keyLength = keyLength;
        _keyHash = keyHash;

        _pValue = pValue;

        _pNext = NULL;

    Cleanup:
        return hr;
    }

    /**
     * inline method to do the key comparison
     */
    inline BOOL Equals(BYTE *pKey, int keyLength, long keyHash)
    {
        return (keyHash == _keyHash && keyLength == _keyLength &&
                memcmp(pKey, _pKey, keyLength) == 0);
    }
};


/**
 * One link chain in the hashtable
 */
struct HashtableChain
{
    HashtableChain() : _spinLock("HashtableChain") {}
    NO_COPY(HashtableChain);

    CReadWriteSpinLock _spinLock;          // chain's spin lock
    HashtableLink     *_pFirstLink;        // pointer to first link
};

/**
 * Enumeration callback
 */
typedef void (__stdcall *PFNHASHTABLEIUNKCALLBACK)(IUnknown *pValue);
typedef void (__stdcall *PFNHASHTABLECALLBACK)(void *pValue, void *pState);

/**
 * The hashtable of IUnknown* objects
 */
class Hashtable
{

private:

    int             _numChains;     // number of bucket chains
    HashtableChain *_pChains;       // array of bucket chains

    long _numEntries;               // current number of entries

protected:
    
    HRESULT
    DoAction(
        BYTE      *pKey,            // key to find
        int        keyLength,       // key's length 
        long       keyHash,         // key's hash code
        void      *pInValue,        // value to insert (could be NULL)
        BOOL       removeExisting,  // flag: remove existing entry (if found)
        void     **ppOutValue);     // receives (if not NULL) existing value

    void Enumerate(void * callback, void * pState);
    void Release();

    virtual void EnumerateCallback(void *callback, void *pValue, void *pState) = 0;
    virtual void AddCallback(void *pValue) = 0;
    virtual void ReleaseCallback(void *pValue) = 0;
    
public:

    Hashtable();

    virtual ~Hashtable() {
        Release();
    }

    HRESULT Init(int numChains);
    
    void RemoveAll();
    
    //
    //  Inlines for various actions (call DoAction)
    //

    inline HRESULT Find(
        BYTE *pKey,                     // key
        int   keyLength,                // key's length
        long  keyHash)                  // key's hash code
    {
        return DoAction(pKey, keyLength, keyHash, NULL, FALSE, NULL);
    }

    inline HRESULT Remove(
        BYTE *pKey,                     // key
        int   keyLength,                // key's length
        long  keyHash)                  // key's hash code
    {
        return DoAction(pKey, keyLength, keyHash, NULL, TRUE, NULL);
    }

    /**
     * Get current [volatile] number of entries
     */
    inline long GetSize()
    {
        return _numEntries;
    }
};

class HashtableIUnknown : public Hashtable {
public:    
    using Hashtable::Find;
    using Hashtable::Remove;

    virtual ~HashtableIUnknown() {
        Release();
    }
    
    inline HRESULT Find(
        BYTE *pKey,                     // key
        int   keyLength,                // key's length
        long  keyHash,                  // key's hash code
        IUnknown**ppValue)              // value found
    {
        return DoAction(pKey, keyLength, keyHash, NULL, FALSE, (void**)ppValue);
    }

    void Enumerate(PFNHASHTABLEIUNKCALLBACK callback)
    {
        Hashtable::Enumerate((void*)callback, NULL);
    }

    inline HRESULT Insert(
        BYTE *pKey,                     // key
        int   keyLength,                // key's length
        long  keyHash,                  // key's hash code
        IUnknown *pValue,                   // value to insert
        IUnknown **ppDupValue = NULL)       // receives dup value (if found)
    {
        return DoAction(pKey, keyLength, keyHash, (void*)pValue, FALSE, (void**)ppDupValue);
    }

    inline HRESULT Remove(
        BYTE *pKey,                     // key
        int   keyLength,                // key's length
        long  keyHash,                  // key's hash code
        IUnknown **ppValue)                 // value removed
    {
        return DoAction(pKey, keyLength, keyHash, NULL, TRUE, (void**)ppValue);
    }

protected:
    virtual void EnumerateCallback(void *callback, void *pValue, void *pState) {
        PFNHASHTABLEIUNKCALLBACK    iunkCallback;

        iunkCallback = (PFNHASHTABLEIUNKCALLBACK)callback;
        (*iunkCallback)((IUnknown*)(pValue));
    }

    virtual void ReleaseCallback(void *pValue) {
        IUnknown *  pIUnk = (IUnknown *)pValue;
        pIUnk->Release();
    }        
    
    virtual void AddCallback(void *pValue) {
        IUnknown *  pIUnk = (IUnknown *)pValue;
        pIUnk->AddRef();
    }        
};


class HashtableGeneric : public Hashtable {
public:    
    using Hashtable::Find;
    using Hashtable::Remove;
    
    virtual ~HashtableGeneric() {
        Release();
    }
    
    void Enumerate(PFNHASHTABLECALLBACK callback, void *pState)
    {
        Hashtable::Enumerate((void*)callback, pState);
    }

    inline HRESULT Find(
        BYTE *pKey,                     // key
        int   keyLength,                // key's length
        long  keyHash,                  // key's hash code
        void**ppValue)                  // value found
    {
        return DoAction(pKey, keyLength, keyHash, NULL, FALSE, ppValue);
    }

    inline HRESULT Remove(
        BYTE *pKey,                     // key
        int   keyLength,                // key's length
        long  keyHash,                  // key's hash code
        void **ppValue)                 // value removed
    {
        return DoAction(pKey, keyLength, keyHash, NULL, TRUE, ppValue);
    }

    inline HRESULT Insert(
        BYTE *pKey,                     // key
        int   keyLength,                // key's length
        long  keyHash,                  // key's hash code
        void *pValue,                   // value to insert
        void **ppDupValue = NULL)       // receives dup value (if found)
    {
        return DoAction(pKey, keyLength, keyHash, pValue, FALSE, ppDupValue);
    }

protected:
    virtual void EnumerateCallback(void *callback, void *pValue, void *pState) {
        PFNHASHTABLECALLBACK    voidCallback;

        voidCallback = (PFNHASHTABLECALLBACK)callback;
        (*voidCallback)(pValue, pState);
    }
    
    virtual void ReleaseCallback(void *pValue) {
    }        
    
    virtual void AddCallback(void *pValue) {
    }        
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\httpext6.h ===
/********
*
*  Copyright (c) 1995  Process Software Corporation
*
*  Copyright (c) 1995-1999  Microsoft Corporation
*
*
*  Module Name  : HttpExt.h
*
*  Abstract :
*
*     This module contains  the structure definitions and prototypes for the
*      HTTP Server Extension interface used to build ISAPI Applications
*
******************/

#ifndef _HTTPEXT_H_
#define _HTTPEXT_H_

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif


/************************************************************
 *   Manifest Constants
 ************************************************************/

#define   HSE_VERSION_MAJOR           6      // major version of this spec
#define   HSE_VERSION_MINOR           0      // minor version of this spec
#define   HSE_LOG_BUFFER_LEN         80
#define   HSE_MAX_EXT_DLL_NAME_LEN  256

#define   HSE_VERSION     MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR )

//
// the following are the status codes returned by the Extension DLL
//

#define   HSE_STATUS_SUCCESS                       1
#define   HSE_STATUS_SUCCESS_AND_KEEP_CONN         2
#define   HSE_STATUS_PENDING                       3
#define   HSE_STATUS_ERROR                         4

//
// The following are the values to request services with the
//   ServerSupportFunction().
//  Values from 0 to 1000 are reserved for future versions of the interface

#define   HSE_REQ_BASE                             0
#define   HSE_REQ_SEND_URL_REDIRECT_RESP           ( HSE_REQ_BASE + 1 )
#define   HSE_REQ_SEND_URL                         ( HSE_REQ_BASE + 2 )
#define   HSE_REQ_SEND_RESPONSE_HEADER             ( HSE_REQ_BASE + 3 )
#define   HSE_REQ_DONE_WITH_SESSION                ( HSE_REQ_BASE + 4 )
#define   HSE_REQ_END_RESERVED                     1000

//
//  These are Microsoft specific extensions
//

#define   HSE_REQ_MAP_URL_TO_PATH                  (HSE_REQ_END_RESERVED+1)
#define   HSE_REQ_GET_SSPI_INFO                    (HSE_REQ_END_RESERVED+2)
#define   HSE_APPEND_LOG_PARAMETER                 (HSE_REQ_END_RESERVED+3)
#define   HSE_REQ_IO_COMPLETION                    (HSE_REQ_END_RESERVED+5)
#define   HSE_REQ_TRANSMIT_FILE                    (HSE_REQ_END_RESERVED+6)
#define   HSE_REQ_REFRESH_ISAPI_ACL                (HSE_REQ_END_RESERVED+7)
#define   HSE_REQ_IS_KEEP_CONN                     (HSE_REQ_END_RESERVED+8)
#define   HSE_REQ_ASYNC_READ_CLIENT                (HSE_REQ_END_RESERVED+10)
#define   HSE_REQ_GET_IMPERSONATION_TOKEN          (HSE_REQ_END_RESERVED+11)
#define   HSE_REQ_MAP_URL_TO_PATH_EX               (HSE_REQ_END_RESERVED+12)
#define   HSE_REQ_ABORTIVE_CLOSE                   (HSE_REQ_END_RESERVED+14)
#define   HSE_REQ_GET_CERT_INFO_EX                 (HSE_REQ_END_RESERVED+15)
#define   HSE_REQ_SEND_RESPONSE_HEADER_EX          (HSE_REQ_END_RESERVED+16)
#define   HSE_REQ_CLOSE_CONNECTION                 (HSE_REQ_END_RESERVED+17)
#define   HSE_REQ_IS_CONNECTED                     (HSE_REQ_END_RESERVED+18)
#define   HSE_REQ_EXTENSION_TRIGGER                (HSE_REQ_END_RESERVED+20)
#define   HSE_REQ_MAP_UNICODE_URL_TO_PATH          (HSE_REQ_END_RESERVED+23)
#define   HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX       (HSE_REQ_END_RESERVED+24)
#define   HSE_REQ_EXEC_UNICODE_URL                 (HSE_REQ_END_RESERVED+25)
#define   HSE_REQ_EXEC_URL                         (HSE_REQ_END_RESERVED+26)
#define   HSE_REQ_GET_EXEC_URL_STATUS              (HSE_REQ_END_RESERVED+27)
#define   HSE_REQ_SEND_CUSTOM_ERROR                (HSE_REQ_END_RESERVED+28)
#define   HSE_REQ_IS_IN_PROCESS                    (HSE_REQ_END_RESERVED+30)
#define   HSE_REQ_REPORT_UNHEALTHY                 (HSE_REQ_END_RESERVED+32)
#define   HSE_REQ_VECTOR_SEND                      (HSE_REQ_END_RESERVED+37)
#define   HSE_REQ_GET_ANONYMOUS_TOKEN              (HSE_REQ_END_RESERVED+38)
#define   HSE_REQ_GET_CACHE_INVALIDATION_CALLBACK  (HSE_REQ_END_RESERVED+40)

//
//  Bit Flags for TerminateExtension
//
//    HSE_TERM_ADVISORY_UNLOAD - Server wants to unload the extension,
//          extension can return TRUE if OK, FALSE if the server should not
//          unload the extension
//
//    HSE_TERM_MUST_UNLOAD - Server indicating the extension is about to be
//          unloaded, the extension cannot refuse.
//

#define HSE_TERM_ADVISORY_UNLOAD                   0x00000001
#define HSE_TERM_MUST_UNLOAD                       0x00000002

//
// Flags for IO Functions, supported for IO Funcs.
//  TF means ServerSupportFunction( HSE_REQ_TRANSMIT_FILE)
//

# define HSE_IO_SYNC                      0x00000001   // for WriteClient
# define HSE_IO_ASYNC                     0x00000002   // for WriteClient/TF/EU
# define HSE_IO_DISCONNECT_AFTER_SEND     0x00000004   // for TF
# define HSE_IO_SEND_HEADERS              0x00000008   // for TF
# define HSE_IO_NODELAY                   0x00001000   // turn off nagling 

//
// These two are only used by VectorSend
//

# define HSE_IO_FINAL_SEND                0x00000010
# define HSE_IO_CACHE_RESPONSE            0x00000020


/************************************************************
 *   Type Definitions
 ************************************************************/

typedef   LPVOID          HCONN;

//
// structure passed to GetExtensionVersion()
//

typedef struct   _HSE_VERSION_INFO {

    DWORD  dwExtensionVersion;
    CHAR   lpszExtensionDesc[HSE_MAX_EXT_DLL_NAME_LEN];

} HSE_VERSION_INFO, *LPHSE_VERSION_INFO;


//
// structure passed to extension procedure on a new request
//
typedef struct _EXTENSION_CONTROL_BLOCK {

    DWORD     cbSize;                 // size of this struct.
    DWORD     dwVersion;              // version info of this spec
    HCONN     ConnID;                 // Context number not to be modified!
    DWORD     dwHTTPStatusCode;       // HTTP Status code
    CHAR      lpszLogData[HSE_LOG_BUFFER_LEN];// null terminated log info specific to this Extension DLL

    LPSTR     lpszMethod;             // REQUEST_METHOD
    LPSTR     lpszQueryString;        // QUERY_STRING
    LPSTR     lpszPathInfo;           // PATH_INFO
    LPSTR     lpszPathTranslated;     // PATH_TRANSLATED

    DWORD     cbTotalBytes;           // Total bytes indicated from client
    DWORD     cbAvailable;            // Available number of bytes
    LPBYTE    lpbData;                // pointer to cbAvailable bytes

    LPSTR     lpszContentType;        // Content type of client data

    BOOL (WINAPI * GetServerVariable) ( HCONN       hConn,
                                        LPSTR       lpszVariableName,
                                        LPVOID      lpvBuffer,
                                        LPDWORD     lpdwSize );

    BOOL (WINAPI * WriteClient)  ( HCONN      ConnID,
                                   LPVOID     Buffer,
                                   LPDWORD    lpdwBytes,
                                   DWORD      dwReserved );

    BOOL (WINAPI * ReadClient)  ( HCONN      ConnID,
                                  LPVOID     lpvBuffer,
                                  LPDWORD    lpdwSize );

    BOOL (WINAPI * ServerSupportFunction)( HCONN      hConn,
                                           DWORD      dwHSERequest,
                                           LPVOID     lpvBuffer,
                                           LPDWORD    lpdwSize,
                                           LPDWORD    lpdwDataType );

} EXTENSION_CONTROL_BLOCK, *LPEXTENSION_CONTROL_BLOCK;




//
//  Bit field of flags that can be on a virtual directory
//

#define HSE_URL_FLAGS_READ          0x00000001    // Allow for Read
#define HSE_URL_FLAGS_WRITE         0x00000002    // Allow for Write
#define HSE_URL_FLAGS_EXECUTE       0x00000004    // Allow for Execute
#define HSE_URL_FLAGS_SSL           0x00000008    // Require SSL
#define HSE_URL_FLAGS_DONT_CACHE    0x00000010    // Don't cache (vroot only)
#define HSE_URL_FLAGS_NEGO_CERT     0x00000020    // Allow client SSL certs
#define HSE_URL_FLAGS_REQUIRE_CERT  0x00000040    // Require client SSL certs
#define HSE_URL_FLAGS_MAP_CERT      0x00000080    // Map SSL cert to NT account
#define HSE_URL_FLAGS_SSL128        0x00000100    // Require 128 bit SSL
#define HSE_URL_FLAGS_SCRIPT        0x00000200    // Allow for Script execution

#define HSE_URL_FLAGS_MASK          0x000003ff

//
//  Structure for extended information on a URL mapping
//

typedef struct _HSE_URL_MAPEX_INFO {

    CHAR   lpszPath[MAX_PATH]; // Physical path root mapped to
    DWORD  dwFlags;            // Flags associated with this URL path
    DWORD  cchMatchingPath;    // Number of matching characters in physical path
    DWORD  cchMatchingURL;     // Number of matching characters in URL

    DWORD  dwReserved1;
    DWORD  dwReserved2;

} HSE_URL_MAPEX_INFO, * LPHSE_URL_MAPEX_INFO;


typedef struct _HSE_UNICODE_URL_MAPEX_INFO {

    WCHAR  lpszPath[MAX_PATH]; // Physical path root mapped to
    DWORD  dwFlags;            // Flags associated with this URL path
    DWORD  cchMatchingPath;    // Number of matching characters in physical path
    DWORD  cchMatchingURL;     // Number of matching characters in URL

} HSE_UNICODE_URL_MAPEX_INFO, * LPHSE_UNICODE_URL_MAPEX_INFO;


//
// PFN_HSE_IO_COMPLETION - callback function for the Async I/O Completion.
//

typedef VOID
  (WINAPI * PFN_HSE_IO_COMPLETION)(
                                   IN EXTENSION_CONTROL_BLOCK * pECB,
                                   IN PVOID    pContext,
                                   IN DWORD    cbIO,
                                   IN DWORD    dwError
                                   );



//
// HSE_TF_INFO defines the type for HTTP SERVER EXTENSION support for
//  ISAPI applications to send files using TransmitFile.
// A pointer to this object should be used with ServerSupportFunction()
//  for HSE_REQ_TRANSMIT_FILE.
//

typedef struct _HSE_TF_INFO  {

    //
    // callback and context information
    // the callback function will be called when IO is completed.
    // the context specified will be used during such callback.
    //
    // These values (if non-NULL) will override the one set by calling
    //  ServerSupportFunction() with HSE_REQ_IO_COMPLETION
    //
    PFN_HSE_IO_COMPLETION   pfnHseIO;
    PVOID  pContext;

    // file should have been opened with FILE_FLAG_SEQUENTIAL_SCAN
    HANDLE hFile;

    //
    // HTTP header and status code
    // These fields are used only if HSE_IO_SEND_HEADERS is present in dwFlags
    //

    LPCSTR pszStatusCode; // HTTP Status Code  eg: "200 OK"

    DWORD  BytesToWrite;  // special value of "0" means write entire file.
    DWORD  Offset;        // offset value within the file to start from

    PVOID  pHead;         // Head buffer to be sent before file data
    DWORD  HeadLength;    // header length
    PVOID  pTail;         // Tail buffer to be sent after file data
    DWORD  TailLength;    // tail length

    DWORD  dwFlags;       // includes HSE_IO_DISCONNECT_AFTER_SEND, ...

} HSE_TF_INFO, * LPHSE_TF_INFO;


//
// HSE_SEND_HEADER_EX_INFO allows an ISAPI application to send headers
// and specify keep-alive behavior in the same call.
//

typedef struct _HSE_SEND_HEADER_EX_INFO  {

    //
    // HTTP status code and header
    //

    LPCSTR  pszStatus;  // HTTP status code  eg: "200 OK"
    LPCSTR  pszHeader;  // HTTP header

    DWORD   cchStatus;  // number of characters in status code
    DWORD   cchHeader;  // number of characters in header

    BOOL    fKeepConn;  // keep client connection alive?

} HSE_SEND_HEADER_EX_INFO, * LPHSE_SEND_HEADER_EX_INFO;

//
// Flags for use with HSE_REQ_EXEC_URL
//

#define HSE_EXEC_URL_NO_HEADERS                     0x02
#define HSE_EXEC_URL_IGNORE_CURRENT_INTERCEPTOR     0x04
#define HSE_EXEC_URL_IGNORE_APPPOOL                 0x08
#define HSE_EXEC_URL_IGNORE_VALIDATION_AND_RANGE    0x10
#define HSE_EXEC_URL_DISABLE_CUSTOM_ERROR           0x20
#define HSE_EXEC_URL_SSI_CMD                        0x40
          
//
// HSE_EXEC_URL_USER_INFO provides a new user content for use with
// HSE_REQ_EXEC_URL
//

typedef struct _HSE_EXEC_URL_USER_INFO  {

    HANDLE hImpersonationToken;
    LPSTR pszCustomUserName;
    LPSTR pszCustomAuthType;

} HSE_EXEC_URL_USER_INFO, * LPHSE_EXEC_URL_USER_INFO;

//
// HSE_EXEC_URL_ENTITY_INFO describes the entity body to be provided
// to the executed request using HSE_REQ_EXEC_URL
//

typedef struct _HSE_EXEC_URL_ENTITY_INFO  {
    
    DWORD cbAvailable;
    LPVOID lpbData;
    
} HSE_EXEC_URL_ENTITY_INFO, * LPHSE_EXEC_URL_ENTITY_INFO;

//
// HSE_EXEC_URL_STATUS provides the status of the last HSE_REQ_EXEC_URL 
// call
//

typedef struct _HSE_EXEC_URL_STATUS  {

    USHORT uHttpStatusCode;
    USHORT uHttpSubStatus;
    DWORD dwWin32Error;

} HSE_EXEC_URL_STATUS, * LPHSE_EXEC_URL_STATUS;

//
// HSE_EXEC_URL_INFO provides a description of the request to execute
// on behalf of the ISAPI.  
//

typedef struct _HSE_EXEC_URL_INFO  {

    LPSTR pszUrl;                       // URL to execute
    LPSTR pszMethod;                    // Method
    LPSTR pszChildHeaders;              // Request headers for child
    LPHSE_EXEC_URL_USER_INFO pUserInfo; // User for new request
    LPHSE_EXEC_URL_ENTITY_INFO pEntity; // Entity body for new request
    DWORD dwExecUrlFlags;               // Flags

} HSE_EXEC_URL_INFO, * LPHSE_EXEC_URL_INFO;

//
// HSE_EXEC_UNICODE_URL_USER_INFO provides a new user content for use with
// HSE_REQ_UNICODE_EXEC_URL
//

typedef struct _HSE_EXEC_UNICODE_URL_USER_INFO  {

    HANDLE hImpersonationToken;
    LPWSTR pszCustomUserName;
    LPSTR  pszCustomAuthType;

} HSE_EXEC_UNICODE_URL_USER_INFO, * LPHSE_EXEC_UNICODE_URL_USER_INFO;

//
// HSE_EXEC_UNICODE_URL_INFO provides a description of the request to execute
// on behalf of the ISAPI.  
//

typedef struct _HSE_EXEC_UNICODE_URL_INFO  {

    LPWSTR pszUrl;                              // URL to execute
    LPSTR  pszMethod;                           // Method
    LPSTR  pszChildHeaders;                     // Request headers for child
    LPHSE_EXEC_UNICODE_URL_USER_INFO pUserInfo; // User for new request
    LPHSE_EXEC_URL_ENTITY_INFO pEntity;         // Entity body for new request
    DWORD  dwExecUrlFlags;                      // Flags

} HSE_EXEC_UNICODE_URL_INFO, * LPHSE_EXEC_UNICODE_URL_INFO;

//
// HSE_CUSTOM_ERROR_INFO structured used in HSE_REQ_SEND_CUSTOM_ERROR
// 

typedef struct _HSE_CUSTOM_ERROR_INFO  {

    CHAR * pszStatus;
    USHORT uHttpSubError;
    BOOL fAsync;

} HSE_CUSTOM_ERROR_INFO, * LPHSE_CUSTOM_ERROR_INFO;


//
// structures for the HSE_REQ_VECTOR_SEND ServerSupportFunction
//


//
// Types of vector-elements currently supported
//
#define HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER       0
#define HSE_VECTOR_ELEMENT_TYPE_FILE_HANDLE         1

//
// element of the vector
//

typedef struct _HSE_VECTOR_ELEMENT
{
    DWORD ElementType;  // Type of element (buffer/file/fragment etc)

    PVOID pvContext;    // The context representing the element to be sent

    ULONGLONG cbOffset; // Offset from the start of hFile

    ULONGLONG cbSize;   // Number of bytes to send
} HSE_VECTOR_ELEMENT, *LPHSE_VECTOR_ELEMENT;

//
// The whole vector to be passed to the ServerSupportFunction
//

typedef struct _HSE_RESPONSE_VECTOR
{
    DWORD dwFlags;                          // combination of HSE_IO_* flags

    LPSTR pszStatus;                        // Status line to send like "200 OK"
    LPSTR pszHeaders;                       // Headers to send

    DWORD nElementCount;                    // Number of HSE_VECTOR_ELEMENT's
    LPHSE_VECTOR_ELEMENT lpElementArray;    // Pointer to those elements
} HSE_RESPONSE_VECTOR, *LPHSE_RESPONSE_VECTOR;


typedef HRESULT
  (WINAPI * PFN_HSE_CACHE_INVALIDATION_CALLBACK)(
        WCHAR *pszUrl);


#if(_WIN32_WINNT >= 0x400)
#include <wincrypt.h>
//
//      CERT_CONTEXT_EX is passed as an an argument to 
//  ServerSupportFunction( HSE_REQ_GET_CERT_INFO_EX )
//

typedef struct _CERT_CONTEXT_EX {
    CERT_CONTEXT    CertContext;
    DWORD           cbAllocated;
    DWORD           dwCertificateFlags;
} CERT_CONTEXT_EX;
#endif



//
// Flags for determining application type
//

#define HSE_APP_FLAG_IN_PROCESS   0
#define HSE_APP_FLAG_ISOLATED_OOP 1
#define HSE_APP_FLAG_POOLED_OOP   2


/************************************************************
 *   Function Prototypes 
 *   o  for functions exported from the ISAPI Application DLL
 ************************************************************/

BOOL  WINAPI   GetExtensionVersion( HSE_VERSION_INFO  *pVer );
DWORD WINAPI   HttpExtensionProc(  EXTENSION_CONTROL_BLOCK *pECB );
BOOL  WINAPI   TerminateExtension( DWORD dwFlags );

// the following type declarations is for use in the server side

typedef BOOL
    (WINAPI * PFN_GETEXTENSIONVERSION)( HSE_VERSION_INFO  *pVer );

typedef DWORD 
    (WINAPI * PFN_HTTPEXTENSIONPROC )( EXTENSION_CONTROL_BLOCK * pECB );

typedef BOOL  (WINAPI * PFN_TERMINATEEXTENSION )( DWORD dwFlags );


#ifdef __cplusplus
}
#endif


#endif  // end definition _HTTPEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\event.h ===
/**
 * Header file for Eventlog helper functions
 * 
 * Copyright (c) 2001 Microsoft Corporation
 */


#pragma once

#include "msg.h"

void
SetEventCateg(WORD wCateg);

HRESULT
XspLogEvent(DWORD dwEventId, WCHAR *sFormat, ...);

HRESULT
XspLogEvent(DWORD dwEventId, WORD wCategory, WCHAR *sFormat, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\iiis.h ===
//------------------------------------------------------------------------------
// <copyright file="iiis.h" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   iiis.h
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Mon Nov 03 15:43:07 1997
 */
/* Compiler settings for iis.odl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __iiis_h__
#define __iiis_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IISMimeType_FWD_DEFINED__
#define __IISMimeType_FWD_DEFINED__
typedef interface IISMimeType IISMimeType;
#endif 	/* __IISMimeType_FWD_DEFINED__ */


#ifndef __MimeMap_FWD_DEFINED__
#define __MimeMap_FWD_DEFINED__

#ifdef __cplusplus
typedef class MimeMap MimeMap;
#else
typedef struct MimeMap MimeMap;
#endif /* __cplusplus */

#endif 	/* __MimeMap_FWD_DEFINED__ */


#ifndef __IISIPSecurity_FWD_DEFINED__
#define __IISIPSecurity_FWD_DEFINED__
typedef interface IISIPSecurity IISIPSecurity;
#endif 	/* __IISIPSecurity_FWD_DEFINED__ */


#ifndef __IPSecurity_FWD_DEFINED__
#define __IPSecurity_FWD_DEFINED__

#ifdef __cplusplus
typedef class IPSecurity IPSecurity;
#else
typedef struct IPSecurity IPSecurity;
#endif /* __cplusplus */

#endif 	/* __IPSecurity_FWD_DEFINED__ */


#ifndef __IISNamespace_FWD_DEFINED__
#define __IISNamespace_FWD_DEFINED__

#ifdef __cplusplus
typedef class IISNamespace IISNamespace;
#else
typedef struct IISNamespace IISNamespace;
#endif /* __cplusplus */

#endif 	/* __IISNamespace_FWD_DEFINED__ */


#ifndef __IISProvider_FWD_DEFINED__
#define __IISProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class IISProvider IISProvider;
#else
typedef struct IISProvider IISProvider;
#endif /* __cplusplus */

#endif 	/* __IISProvider_FWD_DEFINED__ */


#ifndef __IISDsCrMap_FWD_DEFINED__
#define __IISDsCrMap_FWD_DEFINED__
typedef interface IISDsCrMap IISDsCrMap;
#endif 	/* __IISDsCrMap_FWD_DEFINED__ */


#ifndef __IISApp_FWD_DEFINED__
#define __IISApp_FWD_DEFINED__
typedef interface IISApp IISApp;
#endif 	/* __IISApp_FWD_DEFINED__ */


#ifndef __IISComputer_FWD_DEFINED__
#define __IISComputer_FWD_DEFINED__
typedef interface IISComputer IISComputer;
#endif 	/* __IISComputer_FWD_DEFINED__ */


#ifndef __IISBaseObject_FWD_DEFINED__
#define __IISBaseObject_FWD_DEFINED__
typedef interface IISBaseObject IISBaseObject;
#endif 	/* __IISBaseObject_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __IISOle_LIBRARY_DEFINED__
#define __IISOle_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: IISOle
 * at Mon Nov 03 15:43:07 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_IISOle;

#ifndef __IISMimeType_INTERFACE_DEFINED__
#define __IISMimeType_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IISMimeType
 * at Mon Nov 03 15:43:07 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IISMimeType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9036B027-A780-11d0-9B3D-0080C710EF95")
    IISMimeType : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MimeType( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MimeType( 
            /* [in] */ BSTR bstrMimeType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Extension( 
            /* [retval][out] */ BSTR __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Extension( 
            /* [in] */ BSTR bstrExtension) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISMimeTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IISMimeType __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IISMimeType __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IISMimeType __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IISMimeType __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IISMimeType __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IISMimeType __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IISMimeType __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MimeType )( 
            IISMimeType __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MimeType )( 
            IISMimeType __RPC_FAR * This,
            /* [in] */ BSTR bstrMimeType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Extension )( 
            IISMimeType __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Extension )( 
            IISMimeType __RPC_FAR * This,
            /* [in] */ BSTR bstrExtension);
        
        END_INTERFACE
    } IISMimeTypeVtbl;

    interface IISMimeType
    {
        CONST_VTBL struct IISMimeTypeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISMimeType_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IISMimeType_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IISMimeType_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IISMimeType_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IISMimeType_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IISMimeType_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IISMimeType_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IISMimeType_get_MimeType(This,retval)	\
    (This)->lpVtbl -> get_MimeType(This,retval)

#define IISMimeType_put_MimeType(This,bstrMimeType)	\
    (This)->lpVtbl -> put_MimeType(This,bstrMimeType)

#define IISMimeType_get_Extension(This,retval)	\
    (This)->lpVtbl -> get_Extension(This,retval)

#define IISMimeType_put_Extension(This,bstrExtension)	\
    (This)->lpVtbl -> put_Extension(This,bstrExtension)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISMimeType_get_MimeType_Proxy( 
    IISMimeType __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IISMimeType_get_MimeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISMimeType_put_MimeType_Proxy( 
    IISMimeType __RPC_FAR * This,
    /* [in] */ BSTR bstrMimeType);


void __RPC_STUB IISMimeType_put_MimeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISMimeType_get_Extension_Proxy( 
    IISMimeType __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *retval);


void __RPC_STUB IISMimeType_get_Extension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISMimeType_put_Extension_Proxy( 
    IISMimeType __RPC_FAR * This,
    /* [in] */ BSTR bstrExtension);


void __RPC_STUB IISMimeType_put_Extension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IISMimeType_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MimeMap;

#ifdef __cplusplus

class DECLSPEC_UUID("9036B028-A780-11d0-9B3D-0080C710EF95")
MimeMap;
#endif

#ifndef __IISIPSecurity_INTERFACE_DEFINED__
#define __IISIPSecurity_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IISIPSecurity
 * at Mon Nov 03 15:43:07 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IISIPSecurity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F3287521-BBA3-11d0-9BDC-00A0C922E703")
    IISIPSecurity : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_IPDeny( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_IPDeny( 
            /* [in] */ VARIANT vIPDeny) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_IPGrant( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_IPGrant( 
            /* [in] */ VARIANT vIPGrant) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DomainDeny( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DomainDeny( 
            /* [in] */ VARIANT vDomainDeny) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DomainGrant( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DomainGrant( 
            /* [in] */ VARIANT vDomainGrant) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GrantByDefault( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GrantByDefault( 
            /* [in] */ VARIANT_BOOL fGrantByDefault) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISIPSecurityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IISIPSecurity __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IISIPSecurity __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IISIPSecurity __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IPDeny )( 
            IISIPSecurity __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IPDeny )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ VARIANT vIPDeny);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IPGrant )( 
            IISIPSecurity __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IPGrant )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ VARIANT vIPGrant);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DomainDeny )( 
            IISIPSecurity __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DomainDeny )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ VARIANT vDomainDeny);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DomainGrant )( 
            IISIPSecurity __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DomainGrant )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ VARIANT vDomainGrant);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GrantByDefault )( 
            IISIPSecurity __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GrantByDefault )( 
            IISIPSecurity __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fGrantByDefault);
        
        END_INTERFACE
    } IISIPSecurityVtbl;

    interface IISIPSecurity
    {
        CONST_VTBL struct IISIPSecurityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISIPSecurity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IISIPSecurity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IISIPSecurity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IISIPSecurity_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IISIPSecurity_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IISIPSecurity_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IISIPSecurity_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IISIPSecurity_get_IPDeny(This,retval)	\
    (This)->lpVtbl -> get_IPDeny(This,retval)

#define IISIPSecurity_put_IPDeny(This,vIPDeny)	\
    (This)->lpVtbl -> put_IPDeny(This,vIPDeny)

#define IISIPSecurity_get_IPGrant(This,retval)	\
    (This)->lpVtbl -> get_IPGrant(This,retval)

#define IISIPSecurity_put_IPGrant(This,vIPGrant)	\
    (This)->lpVtbl -> put_IPGrant(This,vIPGrant)

#define IISIPSecurity_get_DomainDeny(This,retval)	\
    (This)->lpVtbl -> get_DomainDeny(This,retval)

#define IISIPSecurity_put_DomainDeny(This,vDomainDeny)	\
    (This)->lpVtbl -> put_DomainDeny(This,vDomainDeny)

#define IISIPSecurity_get_DomainGrant(This,retval)	\
    (This)->lpVtbl -> get_DomainGrant(This,retval)

#define IISIPSecurity_put_DomainGrant(This,vDomainGrant)	\
    (This)->lpVtbl -> put_DomainGrant(This,vDomainGrant)

#define IISIPSecurity_get_GrantByDefault(This,retval)	\
    (This)->lpVtbl -> get_GrantByDefault(This,retval)

#define IISIPSecurity_put_GrantByDefault(This,fGrantByDefault)	\
    (This)->lpVtbl -> put_GrantByDefault(This,fGrantByDefault)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_get_IPDeny_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IISIPSecurity_get_IPDeny_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_put_IPDeny_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [in] */ VARIANT vIPDeny);


void __RPC_STUB IISIPSecurity_put_IPDeny_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_get_IPGrant_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IISIPSecurity_get_IPGrant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_put_IPGrant_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [in] */ VARIANT vIPGrant);


void __RPC_STUB IISIPSecurity_put_IPGrant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_get_DomainDeny_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IISIPSecurity_get_DomainDeny_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_put_DomainDeny_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [in] */ VARIANT vDomainDeny);


void __RPC_STUB IISIPSecurity_put_DomainDeny_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_get_DomainGrant_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB IISIPSecurity_get_DomainGrant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_put_DomainGrant_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [in] */ VARIANT vDomainGrant);


void __RPC_STUB IISIPSecurity_put_DomainGrant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_get_GrantByDefault_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB IISIPSecurity_get_GrantByDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IISIPSecurity_put_GrantByDefault_Proxy( 
    IISIPSecurity __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fGrantByDefault);


void __RPC_STUB IISIPSecurity_put_GrantByDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IISIPSecurity_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_IPSecurity;

#ifdef __cplusplus

class DECLSPEC_UUID("F3287520-BBA3-11d0-9BDC-00A0C922E703")
IPSecurity;
#endif

EXTERN_C const CLSID CLSID_IISNamespace;

#ifdef __cplusplus

class DECLSPEC_UUID("d6bfa35e-89f2-11d0-8527-00c04fd8d503")
IISNamespace;
#endif

EXTERN_C const CLSID CLSID_IISProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("d88966de-89f2-11d0-8527-00c04fd8d503")
IISProvider;
#endif

#ifndef __IISDsCrMap_INTERFACE_DEFINED__
#define __IISDsCrMap_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IISDsCrMap
 * at Mon Nov 03 15:43:07 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IISDsCrMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("edcd6a60-b053-11d0-a62f-00a0c922e752")
    IISDsCrMap : public IADs
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreateMapping( 
            /* [in] */ VARIANT vCert,
            /* [in] */ BSTR bstrNtAcct,
            /* [in] */ BSTR bstrNtPwd,
            /* [in] */ BSTR bstrName,
            /* [in] */ LONG lEnabled) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetMapping( 
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [out] */ VARIANT __RPC_FAR *pvCert,
            /* [out] */ VARIANT __RPC_FAR *pbstrNtAcct,
            /* [out] */ VARIANT __RPC_FAR *pbstrNtPwd,
            /* [out] */ VARIANT __RPC_FAR *pbstrName,
            /* [out] */ VARIANT __RPC_FAR *plEnabled) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteMapping( 
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetEnabled( 
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [in] */ LONG lEnabled) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetPwd( 
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [in] */ BSTR bstrPwd) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetAcct( 
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [in] */ BSTR bstrAcct) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISDsCrMapVtbl
    {
        BEGIN_INTERFACE
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in][idldescattr] */ GUID __RPC_FAR *riid,
            /* [out][idldescattr] */ void __RPC_FAR *__RPC_FAR *ppvObj,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ unsigned long __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ unsigned long __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IISDsCrMap __RPC_FAR * This,
            /* [out][idldescattr] */ unsigned UINT __RPC_FAR *pctinfo,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in][idldescattr] */ unsigned UINT itinfo,
            /* [in][idldescattr] */ unsigned long lcid,
            /* [out][idldescattr] */ void __RPC_FAR *__RPC_FAR *pptinfo,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in][idldescattr] */ GUID __RPC_FAR *riid,
            /* [in][idldescattr] */ signed char __RPC_FAR *__RPC_FAR *rgszNames,
            /* [in][idldescattr] */ unsigned UINT cNames,
            /* [in][idldescattr] */ unsigned long lcid,
            /* [out][idldescattr] */ signed long __RPC_FAR *rgdispid,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in][idldescattr] */ signed long dispidMember,
            /* [in][idldescattr] */ GUID __RPC_FAR *riid,
            /* [in][idldescattr] */ unsigned long lcid,
            /* [in][idldescattr] */ unsigned short wFlags,
            /* [in][idldescattr] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [out][idldescattr] */ VARIANT __RPC_FAR *pvarResult,
            /* [out][idldescattr] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out][idldescattr] */ unsigned UINT __RPC_FAR *puArgErr,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GUID )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ADsPath )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Schema )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfo )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInfo )( 
            IISDsCrMap __RPC_FAR * This,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [retval][out] */ typedef /* [wire_marshal] */ struct tagVARIANT VARIANT;
            );
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [in][idldescattr] */ VARIANT vProp,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEx )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [retval][out] */ typedef /* [wire_marshal] */ struct tagVARIANT VARIANT;
            );
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutEx )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in][idldescattr] */ signed long lnControlCode,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [in][idldescattr] */ VARIANT vProp,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfoEx )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in][idldescattr] */ VARIANT vProperties,
            /* [in][idldescattr] */ signed long lnReserved,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateMapping )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in] */ VARIANT vCert,
            /* [in] */ BSTR bstrNtAcct,
            /* [in] */ BSTR bstrNtPwd,
            /* [in] */ BSTR bstrName,
            /* [in] */ LONG lEnabled);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMapping )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [out] */ VARIANT __RPC_FAR *pvCert,
            /* [out] */ VARIANT __RPC_FAR *pbstrNtAcct,
            /* [out] */ VARIANT __RPC_FAR *pbstrNtPwd,
            /* [out] */ VARIANT __RPC_FAR *pbstrName,
            /* [out] */ VARIANT __RPC_FAR *plEnabled);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteMapping )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnabled )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [in] */ LONG lEnabled);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [in] */ BSTR bstrName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPwd )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [in] */ BSTR bstrPwd);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAcct )( 
            IISDsCrMap __RPC_FAR * This,
            /* [in] */ LONG lMethod,
            /* [in] */ VARIANT vKey,
            /* [in] */ BSTR bstrAcct);
        
        END_INTERFACE
    } IISDsCrMapVtbl;

    interface IISDsCrMap
    {
        CONST_VTBL struct IISDsCrMapVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISDsCrMap_QueryInterface(This,riid,ppvObj,retval)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObj,retval)

#define IISDsCrMap_AddRef(This,retval)	\
    (This)->lpVtbl -> AddRef(This,retval)

#define IISDsCrMap_Release(This,retval)	\
    (This)->lpVtbl -> Release(This,retval)

#define IISDsCrMap_GetTypeInfoCount(This,pctinfo,retval)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo,retval)

#define IISDsCrMap_GetTypeInfo(This,itinfo,lcid,pptinfo,retval)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo,retval)

#define IISDsCrMap_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid,retval)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid,retval)

#define IISDsCrMap_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr,retval)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr,retval)

#define IISDsCrMap_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IISDsCrMap_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IISDsCrMap_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IISDsCrMap_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IISDsCrMap_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IISDsCrMap_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IISDsCrMap_GetInfo(This,retval)	\
    (This)->lpVtbl -> GetInfo(This,retval)

#define IISDsCrMap_SetInfo(This,retval)	\
    (This)->lpVtbl -> SetInfo(This,retval)

#define IISDsCrMap_Get(This,bstrName,retval)	\
    (This)->lpVtbl -> Get(This,bstrName,retval)

#define IISDsCrMap_Put(This,bstrName,vProp,retval)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp,retval)

#define IISDsCrMap_GetEx(This,bstrName,retval)	\
    (This)->lpVtbl -> GetEx(This,bstrName,retval)

#define IISDsCrMap_PutEx(This,lnControlCode,bstrName,vProp,retval)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp,retval)

#define IISDsCrMap_GetInfoEx(This,vProperties,lnReserved,retval)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved,retval)


#define IISDsCrMap_CreateMapping(This,vCert,bstrNtAcct,bstrNtPwd,bstrName,lEnabled)	\
    (This)->lpVtbl -> CreateMapping(This,vCert,bstrNtAcct,bstrNtPwd,bstrName,lEnabled)

#define IISDsCrMap_GetMapping(This,lMethod,vKey,pvCert,pbstrNtAcct,pbstrNtPwd,pbstrName,plEnabled)	\
    (This)->lpVtbl -> GetMapping(This,lMethod,vKey,pvCert,pbstrNtAcct,pbstrNtPwd,pbstrName,plEnabled)

#define IISDsCrMap_DeleteMapping(This,lMethod,vKey)	\
    (This)->lpVtbl -> DeleteMapping(This,lMethod,vKey)

#define IISDsCrMap_SetEnabled(This,lMethod,vKey,lEnabled)	\
    (This)->lpVtbl -> SetEnabled(This,lMethod,vKey,lEnabled)

#define IISDsCrMap_SetName(This,lMethod,vKey,bstrName)	\
    (This)->lpVtbl -> SetName(This,lMethod,vKey,bstrName)

#define IISDsCrMap_SetPwd(This,lMethod,vKey,bstrPwd)	\
    (This)->lpVtbl -> SetPwd(This,lMethod,vKey,bstrPwd)

#define IISDsCrMap_SetAcct(This,lMethod,vKey,bstrAcct)	\
    (This)->lpVtbl -> SetAcct(This,lMethod,vKey,bstrAcct)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IISDsCrMap_CreateMapping_Proxy( 
    IISDsCrMap __RPC_FAR * This,
    /* [in] */ VARIANT vCert,
    /* [in] */ BSTR bstrNtAcct,
    /* [in] */ BSTR bstrNtPwd,
    /* [in] */ BSTR bstrName,
    /* [in] */ LONG lEnabled);


void __RPC_STUB IISDsCrMap_CreateMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISDsCrMap_GetMapping_Proxy( 
    IISDsCrMap __RPC_FAR * This,
    /* [in] */ LONG lMethod,
    /* [in] */ VARIANT vKey,
    /* [out] */ VARIANT __RPC_FAR *pvCert,
    /* [out] */ VARIANT __RPC_FAR *pbstrNtAcct,
    /* [out] */ VARIANT __RPC_FAR *pbstrNtPwd,
    /* [out] */ VARIANT __RPC_FAR *pbstrName,
    /* [out] */ VARIANT __RPC_FAR *plEnabled);


void __RPC_STUB IISDsCrMap_GetMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISDsCrMap_DeleteMapping_Proxy( 
    IISDsCrMap __RPC_FAR * This,
    /* [in] */ LONG lMethod,
    /* [in] */ VARIANT vKey);


void __RPC_STUB IISDsCrMap_DeleteMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISDsCrMap_SetEnabled_Proxy( 
    IISDsCrMap __RPC_FAR * This,
    /* [in] */ LONG lMethod,
    /* [in] */ VARIANT vKey,
    /* [in] */ LONG lEnabled);


void __RPC_STUB IISDsCrMap_SetEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISDsCrMap_SetName_Proxy( 
    IISDsCrMap __RPC_FAR * This,
    /* [in] */ LONG lMethod,
    /* [in] */ VARIANT vKey,
    /* [in] */ BSTR bstrName);


void __RPC_STUB IISDsCrMap_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISDsCrMap_SetPwd_Proxy( 
    IISDsCrMap __RPC_FAR * This,
    /* [in] */ LONG lMethod,
    /* [in] */ VARIANT vKey,
    /* [in] */ BSTR bstrPwd);


void __RPC_STUB IISDsCrMap_SetPwd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISDsCrMap_SetAcct_Proxy( 
    IISDsCrMap __RPC_FAR * This,
    /* [in] */ LONG lMethod,
    /* [in] */ VARIANT vKey,
    /* [in] */ BSTR bstrAcct);


void __RPC_STUB IISDsCrMap_SetAcct_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IISDsCrMap_INTERFACE_DEFINED__ */


#ifndef __IISApp_INTERFACE_DEFINED__
#define __IISApp_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IISApp
 * at Mon Nov 03 15:43:07 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IISApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("46FBBB80-0192-11d1-9C39-00A0C922E703")
    IISApp : public IADs
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppCreate( 
            /* [in] */ VARIANT_BOOL bSetInProcFlag) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppDelete( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppDeleteRecursive( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppUnLoad( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppUnLoadRecursive( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppDisable( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppDisableRecursive( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppEnable( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppEnableRecursive( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AppGetStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISAppVtbl
    {
        BEGIN_INTERFACE
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IISApp __RPC_FAR * This,
            /* [in][idldescattr] */ GUID __RPC_FAR *riid,
            /* [out][idldescattr] */ void __RPC_FAR *__RPC_FAR *ppvObj,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ unsigned long __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ unsigned long __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IISApp __RPC_FAR * This,
            /* [out][idldescattr] */ unsigned UINT __RPC_FAR *pctinfo,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IISApp __RPC_FAR * This,
            /* [in][idldescattr] */ unsigned UINT itinfo,
            /* [in][idldescattr] */ unsigned long lcid,
            /* [out][idldescattr] */ void __RPC_FAR *__RPC_FAR *pptinfo,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IISApp __RPC_FAR * This,
            /* [in][idldescattr] */ GUID __RPC_FAR *riid,
            /* [in][idldescattr] */ signed char __RPC_FAR *__RPC_FAR *rgszNames,
            /* [in][idldescattr] */ unsigned UINT cNames,
            /* [in][idldescattr] */ unsigned long lcid,
            /* [out][idldescattr] */ signed long __RPC_FAR *rgdispid,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IISApp __RPC_FAR * This,
            /* [in][idldescattr] */ signed long dispidMember,
            /* [in][idldescattr] */ GUID __RPC_FAR *riid,
            /* [in][idldescattr] */ unsigned long lcid,
            /* [in][idldescattr] */ unsigned short wFlags,
            /* [in][idldescattr] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [out][idldescattr] */ VARIANT __RPC_FAR *pvarResult,
            /* [out][idldescattr] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out][idldescattr] */ unsigned UINT __RPC_FAR *puArgErr,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GUID )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ADsPath )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Schema )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfo )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInfo )( 
            IISApp __RPC_FAR * This,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IISApp __RPC_FAR * This,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [retval][out] */ typedef /* [wire_marshal] */ struct tagVARIANT VARIANT;
            );
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IISApp __RPC_FAR * This,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [in][idldescattr] */ VARIANT vProp,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEx )( 
            IISApp __RPC_FAR * This,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [retval][out] */ typedef /* [wire_marshal] */ struct tagVARIANT VARIANT;
            );
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutEx )( 
            IISApp __RPC_FAR * This,
            /* [in][idldescattr] */ signed long lnControlCode,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [in][idldescattr] */ VARIANT vProp,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfoEx )( 
            IISApp __RPC_FAR * This,
            /* [in][idldescattr] */ VARIANT vProperties,
            /* [in][idldescattr] */ signed long lnReserved,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppCreate )( 
            IISApp __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bSetInProcFlag);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppDelete )( 
            IISApp __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppDeleteRecursive )( 
            IISApp __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppUnLoad )( 
            IISApp __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppUnLoadRecursive )( 
            IISApp __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppDisable )( 
            IISApp __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppDisableRecursive )( 
            IISApp __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppEnable )( 
            IISApp __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppEnableRecursive )( 
            IISApp __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppGetStatus )( 
            IISApp __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        END_INTERFACE
    } IISAppVtbl;

    interface IISApp
    {
        CONST_VTBL struct IISAppVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISApp_QueryInterface(This,riid,ppvObj,retval)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObj,retval)

#define IISApp_AddRef(This,retval)	\
    (This)->lpVtbl -> AddRef(This,retval)

#define IISApp_Release(This,retval)	\
    (This)->lpVtbl -> Release(This,retval)

#define IISApp_GetTypeInfoCount(This,pctinfo,retval)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo,retval)

#define IISApp_GetTypeInfo(This,itinfo,lcid,pptinfo,retval)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo,retval)

#define IISApp_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid,retval)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid,retval)

#define IISApp_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr,retval)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr,retval)

#define IISApp_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IISApp_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IISApp_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IISApp_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IISApp_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IISApp_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IISApp_GetInfo(This,retval)	\
    (This)->lpVtbl -> GetInfo(This,retval)

#define IISApp_SetInfo(This,retval)	\
    (This)->lpVtbl -> SetInfo(This,retval)

#define IISApp_Get(This,bstrName,retval)	\
    (This)->lpVtbl -> Get(This,bstrName,retval)

#define IISApp_Put(This,bstrName,vProp,retval)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp,retval)

#define IISApp_GetEx(This,bstrName,retval)	\
    (This)->lpVtbl -> GetEx(This,bstrName,retval)

#define IISApp_PutEx(This,lnControlCode,bstrName,vProp,retval)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp,retval)

#define IISApp_GetInfoEx(This,vProperties,lnReserved,retval)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved,retval)


#define IISApp_AppCreate(This,bSetInProcFlag)	\
    (This)->lpVtbl -> AppCreate(This,bSetInProcFlag)

#define IISApp_AppDelete(This)	\
    (This)->lpVtbl -> AppDelete(This)

#define IISApp_AppDeleteRecursive(This)	\
    (This)->lpVtbl -> AppDeleteRecursive(This)

#define IISApp_AppUnLoad(This)	\
    (This)->lpVtbl -> AppUnLoad(This)

#define IISApp_AppUnLoadRecursive(This)	\
    (This)->lpVtbl -> AppUnLoadRecursive(This)

#define IISApp_AppDisable(This)	\
    (This)->lpVtbl -> AppDisable(This)

#define IISApp_AppDisableRecursive(This)	\
    (This)->lpVtbl -> AppDisableRecursive(This)

#define IISApp_AppEnable(This)	\
    (This)->lpVtbl -> AppEnable(This)

#define IISApp_AppEnableRecursive(This)	\
    (This)->lpVtbl -> AppEnableRecursive(This)

#define IISApp_AppGetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> AppGetStatus(This,pdwStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppCreate_Proxy( 
    IISApp __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bSetInProcFlag);


void __RPC_STUB IISApp_AppCreate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppDelete_Proxy( 
    IISApp __RPC_FAR * This);


void __RPC_STUB IISApp_AppDelete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppDeleteRecursive_Proxy( 
    IISApp __RPC_FAR * This);


void __RPC_STUB IISApp_AppDeleteRecursive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppUnLoad_Proxy( 
    IISApp __RPC_FAR * This);


void __RPC_STUB IISApp_AppUnLoad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppUnLoadRecursive_Proxy( 
    IISApp __RPC_FAR * This);


void __RPC_STUB IISApp_AppUnLoadRecursive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppDisable_Proxy( 
    IISApp __RPC_FAR * This);


void __RPC_STUB IISApp_AppDisable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppDisableRecursive_Proxy( 
    IISApp __RPC_FAR * This);


void __RPC_STUB IISApp_AppDisableRecursive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppEnable_Proxy( 
    IISApp __RPC_FAR * This);


void __RPC_STUB IISApp_AppEnable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppEnableRecursive_Proxy( 
    IISApp __RPC_FAR * This);


void __RPC_STUB IISApp_AppEnableRecursive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISApp_AppGetStatus_Proxy( 
    IISApp __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB IISApp_AppGetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IISApp_INTERFACE_DEFINED__ */


#ifndef __IISComputer_INTERFACE_DEFINED__
#define __IISComputer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IISComputer
 * at Mon Nov 03 15:43:07 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IISComputer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CF87A2E0-078B-11d1-9C3D-00A0C922E703")
    IISComputer : public IADs
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Backup( 
            /* [in] */ BSTR bstrLocation,
            /* [in] */ LONG lVersion,
            /* [in] */ LONG lFlags) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Restore( 
            /* [in] */ BSTR bstrLocation,
            /* [in] */ LONG lVersion,
            /* [in] */ LONG lFlags) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EnumBackups( 
            /* [in] */ BSTR bstrLocation,
            /* [in] */ LONG lIndex,
            /* [out] */ VARIANT __RPC_FAR *pvVersion,
            /* [out] */ VARIANT __RPC_FAR *pvLocations,
            /* [out] */ VARIANT __RPC_FAR *pvDate) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteBackup( 
            /* [in] */ BSTR bstrLocation,
            /* [in] */ LONG lVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISComputerVtbl
    {
        BEGIN_INTERFACE
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IISComputer __RPC_FAR * This,
            /* [in][idldescattr] */ GUID __RPC_FAR *riid,
            /* [out][idldescattr] */ void __RPC_FAR *__RPC_FAR *ppvObj,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ unsigned long __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ unsigned long __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IISComputer __RPC_FAR * This,
            /* [out][idldescattr] */ unsigned UINT __RPC_FAR *pctinfo,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IISComputer __RPC_FAR * This,
            /* [in][idldescattr] */ unsigned UINT itinfo,
            /* [in][idldescattr] */ unsigned long lcid,
            /* [out][idldescattr] */ void __RPC_FAR *__RPC_FAR *pptinfo,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IISComputer __RPC_FAR * This,
            /* [in][idldescattr] */ GUID __RPC_FAR *riid,
            /* [in][idldescattr] */ signed char __RPC_FAR *__RPC_FAR *rgszNames,
            /* [in][idldescattr] */ unsigned UINT cNames,
            /* [in][idldescattr] */ unsigned long lcid,
            /* [out][idldescattr] */ signed long __RPC_FAR *rgdispid,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][restricted][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IISComputer __RPC_FAR * This,
            /* [in][idldescattr] */ signed long dispidMember,
            /* [in][idldescattr] */ GUID __RPC_FAR *riid,
            /* [in][idldescattr] */ unsigned long lcid,
            /* [in][idldescattr] */ unsigned short wFlags,
            /* [in][idldescattr] */ DISPPARAMS __RPC_FAR *pdispparams,
            /* [out][idldescattr] */ VARIANT __RPC_FAR *pvarResult,
            /* [out][idldescattr] */ EXCEPINFO __RPC_FAR *pexcepinfo,
            /* [out][idldescattr] */ unsigned UINT __RPC_FAR *puArgErr,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Class )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GUID )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ADsPath )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][propget][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Schema )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;
            );
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfo )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInfo )( 
            IISComputer __RPC_FAR * This,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IISComputer __RPC_FAR * This,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [retval][out] */ typedef /* [wire_marshal] */ struct tagVARIANT VARIANT;
            );
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IISComputer __RPC_FAR * This,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [in][idldescattr] */ VARIANT vProp,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEx )( 
            IISComputer __RPC_FAR * This,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [retval][out] */ typedef /* [wire_marshal] */ struct tagVARIANT VARIANT;
            );
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutEx )( 
            IISComputer __RPC_FAR * This,
            /* [in][idldescattr] */ signed long lnControlCode,
            /* [in][idldescattr] */ BSTR bstrName,
            /* [in][idldescattr] */ VARIANT vProp,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id][funcdescattr] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfoEx )( 
            IISComputer __RPC_FAR * This,
            /* [in][idldescattr] */ VARIANT vProperties,
            /* [in][idldescattr] */ signed long lnReserved,
            /* [retval][out] */ void __RPC_FAR *retval);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Backup )( 
            IISComputer __RPC_FAR * This,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ LONG lVersion,
            /* [in] */ LONG lFlags);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Restore )( 
            IISComputer __RPC_FAR * This,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ LONG lVersion,
            /* [in] */ LONG lFlags);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumBackups )( 
            IISComputer __RPC_FAR * This,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ LONG lIndex,
            /* [out] */ VARIANT __RPC_FAR *pvVersion,
            /* [out] */ VARIANT __RPC_FAR *pvLocations,
            /* [out] */ VARIANT __RPC_FAR *pvDate);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteBackup )( 
            IISComputer __RPC_FAR * This,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ LONG lVersion);
        
        END_INTERFACE
    } IISComputerVtbl;

    interface IISComputer
    {
        CONST_VTBL struct IISComputerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISComputer_QueryInterface(This,riid,ppvObj,retval)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObj,retval)

#define IISComputer_AddRef(This,retval)	\
    (This)->lpVtbl -> AddRef(This,retval)

#define IISComputer_Release(This,retval)	\
    (This)->lpVtbl -> Release(This,retval)

#define IISComputer_GetTypeInfoCount(This,pctinfo,retval)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo,retval)

#define IISComputer_GetTypeInfo(This,itinfo,lcid,pptinfo,retval)	\
    (This)->lpVtbl -> GetTypeInfo(This,itinfo,lcid,pptinfo,retval)

#define IISComputer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid,retval)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgdispid,retval)

#define IISComputer_Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr,retval)	\
    (This)->lpVtbl -> Invoke(This,dispidMember,riid,lcid,wFlags,pdispparams,pvarResult,pexcepinfo,puArgErr,retval)

#define IISComputer_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define IISComputer_get_Class(This,retval)	\
    (This)->lpVtbl -> get_Class(This,retval)

#define IISComputer_get_GUID(This,retval)	\
    (This)->lpVtbl -> get_GUID(This,retval)

#define IISComputer_get_ADsPath(This,retval)	\
    (This)->lpVtbl -> get_ADsPath(This,retval)

#define IISComputer_get_Parent(This,retval)	\
    (This)->lpVtbl -> get_Parent(This,retval)

#define IISComputer_get_Schema(This,retval)	\
    (This)->lpVtbl -> get_Schema(This,retval)

#define IISComputer_GetInfo(This,retval)	\
    (This)->lpVtbl -> GetInfo(This,retval)

#define IISComputer_SetInfo(This,retval)	\
    (This)->lpVtbl -> SetInfo(This,retval)

#define IISComputer_Get(This,bstrName,retval)	\
    (This)->lpVtbl -> Get(This,bstrName,retval)

#define IISComputer_Put(This,bstrName,vProp,retval)	\
    (This)->lpVtbl -> Put(This,bstrName,vProp,retval)

#define IISComputer_GetEx(This,bstrName,retval)	\
    (This)->lpVtbl -> GetEx(This,bstrName,retval)

#define IISComputer_PutEx(This,lnControlCode,bstrName,vProp,retval)	\
    (This)->lpVtbl -> PutEx(This,lnControlCode,bstrName,vProp,retval)

#define IISComputer_GetInfoEx(This,vProperties,lnReserved,retval)	\
    (This)->lpVtbl -> GetInfoEx(This,vProperties,lnReserved,retval)


#define IISComputer_Backup(This,bstrLocation,lVersion,lFlags)	\
    (This)->lpVtbl -> Backup(This,bstrLocation,lVersion,lFlags)

#define IISComputer_Restore(This,bstrLocation,lVersion,lFlags)	\
    (This)->lpVtbl -> Restore(This,bstrLocation,lVersion,lFlags)

#define IISComputer_EnumBackups(This,bstrLocation,lIndex,pvVersion,pvLocations,pvDate)	\
    (This)->lpVtbl -> EnumBackups(This,bstrLocation,lIndex,pvVersion,pvLocations,pvDate)

#define IISComputer_DeleteBackup(This,bstrLocation,lVersion)	\
    (This)->lpVtbl -> DeleteBackup(This,bstrLocation,lVersion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IISComputer_Backup_Proxy( 
    IISComputer __RPC_FAR * This,
    /* [in] */ BSTR bstrLocation,
    /* [in] */ LONG lVersion,
    /* [in] */ LONG lFlags);


void __RPC_STUB IISComputer_Backup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISComputer_Restore_Proxy( 
    IISComputer __RPC_FAR * This,
    /* [in] */ BSTR bstrLocation,
    /* [in] */ LONG lVersion,
    /* [in] */ LONG lFlags);


void __RPC_STUB IISComputer_Restore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISComputer_EnumBackups_Proxy( 
    IISComputer __RPC_FAR * This,
    /* [in] */ BSTR bstrLocation,
    /* [in] */ LONG lIndex,
    /* [out] */ VARIANT __RPC_FAR *pvVersion,
    /* [out] */ VARIANT __RPC_FAR *pvLocations,
    /* [out] */ VARIANT __RPC_FAR *pvDate);


void __RPC_STUB IISComputer_EnumBackups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IISComputer_DeleteBackup_Proxy( 
    IISComputer __RPC_FAR * This,
    /* [in] */ BSTR bstrLocation,
    /* [in] */ LONG lVersion);


void __RPC_STUB IISComputer_DeleteBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IISComputer_INTERFACE_DEFINED__ */


#ifndef __IISBaseObject_INTERFACE_DEFINED__
#define __IISBaseObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IISBaseObject
 * at Mon Nov 03 15:43:07 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IISBaseObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4B42E390-0E96-11d1-9C3F-00A0C922E703")
    IISBaseObject : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetDataPaths( 
            /* [in] */ BSTR bstrName,
            /* [in] */ LONG lnAttribute,
            /* [retval][out] */ VARIANT __RPC_FAR *pvPaths) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISBaseObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IISBaseObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IISBaseObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IISBaseObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IISBaseObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IISBaseObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IISBaseObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IISBaseObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataPaths )( 
            IISBaseObject __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ LONG lnAttribute,
            /* [retval][out] */ VARIANT __RPC_FAR *pvPaths);
        
        END_INTERFACE
    } IISBaseObjectVtbl;

    interface IISBaseObject
    {
        CONST_VTBL struct IISBaseObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISBaseObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IISBaseObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IISBaseObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IISBaseObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IISBaseObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IISBaseObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IISBaseObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IISBaseObject_GetDataPaths(This,bstrName,lnAttribute,pvPaths)	\
    (This)->lpVtbl -> GetDataPaths(This,bstrName,lnAttribute,pvPaths)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IISBaseObject_GetDataPaths_Proxy( 
    IISBaseObject __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ LONG lnAttribute,
    /* [retval][out] */ VARIANT __RPC_FAR *pvPaths);


void __RPC_STUB IISBaseObject_GetDataPaths_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IISBaseObject_INTERFACE_DEFINED__ */

#endif /* __IISOle_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\ecbimports.h ===
/**
 * EcbImports.h
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _EcbImports_H
#define _EcbImports_H

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Request packaging functions
int
__stdcall 
EcbGetBasics(EXTENSION_CONTROL_BLOCK *pECB, LPSTR buffer, int size, int contentInfo [] );

/////////////////////////////////////////////////////////////////////////////

int
__stdcall
EcbGetServerVariable(EXTENSION_CONTROL_BLOCK *pECB, LPCSTR name, LPSTR buffer, int size);

/////////////////////////////////////////////////////////////////////////////

int
__stdcall
EcbGetQueryString(EXTENSION_CONTROL_BLOCK *pECB, int encode, LPSTR buffer, int size);

/////////////////////////////////////////////////////////////////////////////

int
__stdcall
EcbGetPreloadedPostedContent(EXTENSION_CONTROL_BLOCK *pECB, BYTE *bytes, int size);

/////////////////////////////////////////////////////////////////////////////

int
__stdcall
EcbGetAdditionalPostedContent(EXTENSION_CONTROL_BLOCK *pECB, BYTE *bytes, int size);

/////////////////////////////////////////////////////////////////////////////

int
__stdcall
EcbIsClientConnected(EXTENSION_CONTROL_BLOCK *pECB);

/////////////////////////////////////////////////////////////////////////////

int
__stdcall
EcbMapUrlToPath(EXTENSION_CONTROL_BLOCK *pECB, LPCSTR url, LPSTR buffer, int size);

/////////////////////////////////////////////////////////////////////////////
// Response functions

int
__stdcall
EcbWriteHeaders(EXTENSION_CONTROL_BLOCK *pECB, LPCSTR status, LPCSTR header, int keepConnected);

/////////////////////////////////////////////////////////////////////////////

int
__stdcall
EcbWriteBytes(EXTENSION_CONTROL_BLOCK *pECB, void * bytes, int size);

/////////////////////////////////////////////////////////////////////////////

int
__stdcall
EcbDoneWithSession(EXTENSION_CONTROL_BLOCK *pECB, int status, int iCallerID);

/////////////////////////////////////////////////////////////////////////////

int
__stdcall
EcbFlushCore(
        EXTENSION_CONTROL_BLOCK *pECB,
        LPCSTR  status, 
        LPCSTR  header, 
        BOOL    keepConnected,
        int     totalBodySize,
        int     numBodyFragments,
        BYTE*   bodyFragments[],
        int     bodyFragmentLengths[],
        BOOL    doneWithSession,
        int     finalStatus);

/////////////////////////////////////////////////////////////////////////////

int
__stdcall
EcbCloseConnection(EXTENSION_CONTROL_BLOCK *pECB);

/////////////////////////////////////////////////////////////////////////////
// Response functions

int
__stdcall
EcbWriteHeaders(EXTENSION_CONTROL_BLOCK *pECB, LPCSTR status, LPCSTR header, int keepConnected);

/////////////////////////////////////////////////////////////////////////////

HANDLE
__stdcall
EcbGetImpersonationToken(EXTENSION_CONTROL_BLOCK *pECB, HANDLE iProcessHandle);

/////////////////////////////////////////////////////////////////////////////

HANDLE
__stdcall
EcbGetVirtualPathToken(EXTENSION_CONTROL_BLOCK *pECB, HANDLE iProcessHandle);

/////////////////////////////////////////////////////////////////////////////

int
__stdcall
EcbGetClientCertificate(EXTENSION_CONTROL_BLOCK *pECB, LPSTR szBuf, int iBufSize, int * pInts, __int64 * pDates);

/////////////////////////////////////////////////////////////////////////////


typedef
void
(__stdcall *PFNTIMERCALLBACK)    (void);

/////////////////////////////////////////////////////////////////////////////


int
__stdcall
EcbAppendLogParameter            (EXTENSION_CONTROL_BLOCK *pECB, LPCSTR pLogParam);

/////////////////////////////////////////////////////////////////////////////

HANDLE
__stdcall
TimerNDCreateTimerQueue          ();

/////////////////////////////////////////////////////////////////////////////

HANDLE
__stdcall
TimerNDCreateTimerQueueTimer     (HANDLE                hTimerQueue, 
                                  PFNTIMERCALLBACK      callback, 
                                  int                   dueTime, 
                                  int                   period);

/////////////////////////////////////////////////////////////////////////////

void
__stdcall
TimerNDDeleteTimerQueueEx        (HANDLE hTimerQueue);


/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
GetAppDomainIndirect(char * appId, char *appPath, IUnknown ** ppRuntime);

/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
DisposeAppDomainsIndirect();

/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
InitializeManagedCode();

/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
UnInitializeManagedCode();

/////////////////////////////////////////////////////////////////////////////

void
ReportHttpErrorIndirect(EXTENSION_CONTROL_BLOCK * iECB, UINT errorResCode);

/////////////////////////////////////////////////////////////////////////////

int
__stdcall
EcbWriteBytesAsync(
    EXTENSION_CONTROL_BLOCK *pECB,
    void *pBytes,
    int size,
    PFN_HSE_IO_COMPLETION callback,
    void *pContext);

/////////////////////////////////////////////////////////////////////////////

int
__stdcall
EcbWriteBytesUsingTransmitFile(
    EXTENSION_CONTROL_BLOCK *pECB,
    LPCSTR pStatus,
    LPCSTR pHeaders,
    int keepConnected,    
    void *pBytes,
    int size,
    PFN_HSE_IO_COMPLETION callback,
    void *pContext);

/////////////////////////////////////////////////////////////////////////////
int
__stdcall
EcbCallISAPI(
    EXTENSION_CONTROL_BLOCK *pECB,
    int       iFunction,
    LPBYTE    bufferIn,
    int       iBufSizeIn,
    LPBYTE    bufferOut,
    int       iBufSizeOut);


/////////////////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\etw.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    etwtrace.hxx (ETW tracelogging)

Abstract:

    This file contrains the Event Tracer for Windows (ETW)
    tracing class. 

Author:

    Melur Raghuraman (mraghu)       08-May-2001

Revision History:

    Revision to incorporate into ASP.NET tree - Fabio Yeon (fabioy)  2-5-2001

--*/
#ifndef _ETWTRACER_HXX_
#define _ETWTRACER_HXX_

#define ETW_TRACER_BUILD 2195           // Earliest Build ETW Tracing works on

#define ETWMAX_TRACE_LEVEL  4           // Maximum Number of Trace Levels supported

#define ETW_LEVEL_MIN       0           // Basic Logging of inbound/outbound traffic
#define ETW_LEVEL_CP        1           // Capacity Planning Tracing 
#define ETW_LEVEL_DBG       2           // Performance Analysis or Debug Tracing
#define ETW_LEVEL_MAX       3           // Very Detailed Debugging trace

class CEtwTracer {
private:
    BOOL        m_fTraceEnabled;        // Set by the control Callback function
    BOOL        m_fTraceSupported;      // True if tracing is supported 
                                        // (currently only W2K or above)
    BOOL        m_fTraceInitialized;    // True if we have initialized 
    TRACEHANDLE m_hProviderReg;         // Registration Handle to unregister
    TRACEHANDLE m_hTraceLogger;         // Handle to Event Trace Logger
    ULONG       m_ulEnableFlags;        // Used to set various options
    ULONG       m_ulEnableLevel;        // used to control the level
    GUID        m_guidProvider;         // Control Guid for the Provider

public:
    /* Register Function
     * Desc:    Registers provider guid with the event
     *          tracer.  
     * Ret:     Returns ERROR_SUCCESS on success
     ***********************************************/
    HRESULT Register(
        const GUID *    ControlGuid,
        const GUID *    EventGuid,
        LPWSTR          ImagePath,
        LPWSTR          MofResourceName );


    /* Unregister Function
     * Desc:    Unregisters the provider GUID with the
     *          event tracer.
     * Ret:     Returns ERROR_SUCCESS on success
     ***********************************************/
    HRESULT Unregister();

    HRESULT CEtwTracer::WriteEvent( PEVENT_TRACE_HEADER event );

    /* Class Constructor
     ***********************************************/
    CEtwTracer();


    /* ETW control callback
     * Desc:    This function handles the ETW control
     *          callback.  It enables or disables tracing.
     *          On enable, it also reads the flag and level
     *          passed in by ETW, and does some error checking
     *          to ensure that the parameters can be fulfilled.
     * Ret:     ERROR_SUCCESS on success
     *          ERROR_INVALID_HANDLE if a bad handle is passed from ETW
     *          ERROR_INVALID_PARAMETER if an invalid parameter is sent by ETW
     * Warning: The only caller of this function should be ETW, you should
     *          never call this function explicitely.
     ***********************************************/
    ULONG CtrlCallback(
        WMIDPREQUESTCODE RequestCode,
        PVOID Context,
        ULONG *InOutBufferSize, 
        PVOID Buffer);

    /* Desc:    Check if tracing is enabled
     ***********************************************/
    inline BOOL TraceEnabled()
    { 
        return m_ulEnableLevel;
    };

    /* Desc:    Check if tracing is enabled for a particular
     *          level or less.
     ***********************************************/
    inline BOOL TraceEnabled(ULONG Level) 
    { 
        ULONG IsEnabled =  ((Level < ETWMAX_TRACE_LEVEL) ? 
               (m_ulEnableLevel >> Level) : 
               (m_ulEnableLevel >> ETWMAX_TRACE_LEVEL) );  
        return (IsEnabled != 0);
    };

    inline ULONG GetEtwFlags()
    { 
        return m_ulEnableFlags;
    };

    inline BOOL Initialized() {
        return m_fTraceInitialized;
    }
    
};


//
// Map CEtwTracer's CtrlCallback function into C callable function
//

extern "C" {

ULONG WINAPI ControlCallback(
    WMIDPREQUESTCODE RequestCode,
    PVOID Context,
    ULONG *InOutBufferSize, 
    PVOID Buffer);
}

//
// The ONE and only ONE global instantiation of this class
//
extern CEtwTracer * g_pEtwTracer;

#endif //_ETWTRACER_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\iiscnfg.h ===
/*++



   Copyright (c) 1997-1999 Microsoft Corporation

   Module  Name :

       iiscnfg.h

   Abstract:

        Contains public Metadata IDs used by IIS.

   Environment:

      Win32 User Mode

--*/

#ifndef _IISCNFG_H_
#define _IISCNFG_H_


//
// Paths
//

#define IIS_MD_LOCAL_MACHINE_PATH       "LM"

//
// Name of the default publishing root under an instance
//

#define IIS_MD_INSTANCE_ROOT            "Root"

//
//  ISAPI Filters are kept in a list under the instances and the service (for
//  global filters) in the following format:
//
//  LM/W3Svc/<Instance>/Filters
//      MD_FILTER_LOAD_ORDER  "Filter1, Filter2, Filter3"
//
//  LM/W3Svc/<Instance>/Filters/Filter1
//      MD_FILTER_IMAGE_PATH  "d:\inetsrv\myfilter.dll"
//
//  LM/W3Svc/<Instance>/Filters/Filter2
//      MD_FILTER_IMAGE_PATH  "d:\inetsrv\otherfilter.dll"
//

#define IIS_MD_ISAPI_FILTERS            "/Filters"

//
// Path below each service to the key that publishes service information
//

#define IIS_MD_SVC_INFO_PATH            "Info"

//
// ADSI schema properties path
//

#define IIS_MD_ADSI_SCHEMA_PATH_A       "/Schema"
#define IIS_MD_ADSI_SCHEMA_PATH_W       L"/Schema"
#define IIS_MD_ADSI_METAID_BEGIN        130000

//
// user types
//
// There are two user types:
//
//   Server configuration - All the properties for configuring the server that
//      are not applicable to files and directories - such as Port, Host name,
//      Server comment, Connection timeout etc.
//
//  File/Dir configuration - All the properties that can be configured down to
//      the files and directories - such as Access permissions (Read, Write etc),
//      Extension mapping, IP Security etc.
//

#define IIS_MD_UT_SERVER                1   // Server configuration parameters
#define IIS_MD_UT_FILE                  2   // File/Dir inheritable properties
#define IIS_MD_UT_WAM                 100   // Web Application configuration parameters
#define ASP_MD_UT_APP                 101   // ASP application configuration parameters
#define IIS_MD_UT_END_RESERVED       2000   // All user types below this are
                                            // reserved for IIS services


//
//  Metabase property IDs must be unique.  This table defines reserved ranges
//

#define IIS_MD_ID_BEGIN_RESERVED    0x00000001      // IIS reserved range
#define IIS_MD_ID_END_RESERVED      0x00007fff
#define ASP_MD_ID_BEGIN_RESERVED    0x00007000      // ASP reserved range, subrange of IIS.
#define ASP_MD_ID_END_RESERVED      0x000074ff
#define WAM_MD_ID_BEGIN_RESERVED    0x00007500      // ASP reserved range, subrange of IIS.
#define WAM_MD_ID_END_RESERVED      0x00007fff
#define FP_MD_ID_BEGIN_RESERVED     0x00008000      // Front page reserved range
#define FP_MD_ID_END_RESERVED       0x00008fff
#define SMTP_MD_ID_BEGIN_RESERVED   0x00009000
#define SMTP_MD_ID_END_RESERVED     0x00009fff
#define POP3_MD_ID_BEGIN_RESERVED   0x0000a000
#define POP3_MD_ID_END_RESERVED     0x0000afff
#define NNTP_MD_ID_BEGIN_RESERVED   0x0000b000
#define NNTP_MD_ID_END_RESERVED     0x0000bfff
#define IMAP_MD_ID_BEGIN_RESERVED   0x0000c000
#define IMAP_MD_ID_END_RESERVED     0x0000cfff
#define MSCS_MD_ID_BEGIN_RESERVED   0x0000d000
#define MSCS_MD_ID_END_RESERVED     0x0000dfff
#define APPCTR_MD_ID_BEGIN_RESERVED 0x0000e000
#define APPCTR_MD_ID_END_RESERVED   0x0000efff

#define USER_MD_ID_BASE_RESERVED    0x0000ffff

//
//  General server related attributes - these should be added in the metabase
//  with a user type of IIS_MD_UT_SERVER
//

#define IIS_MD_SERVER_BASE              1000

//
//  These are global to all services and should only be set at
//  the IIS root
//

#define MD_MAX_BANDWIDTH                (IIS_MD_SERVER_BASE+0  )
#define MD_KEY_TYPE                     (IIS_MD_SERVER_BASE+2  )
#define MD_MAX_BANDWIDTH_BLOCKED        (IIS_MD_SERVER_BASE+3  )
#define MD_SCHEMA_METAID                (IIS_MD_SERVER_BASE+4  )

//
//  These properties are applicable to both HTTP and FTP virtual
//  servers
//

#define MD_SERVER_COMMAND               (IIS_MD_SERVER_BASE+12 )
#define MD_CONNECTION_TIMEOUT           (IIS_MD_SERVER_BASE+13 )
#define MD_MAX_CONNECTIONS              (IIS_MD_SERVER_BASE+14 )
#define MD_SERVER_COMMENT               (IIS_MD_SERVER_BASE+15 )
#define MD_SERVER_STATE                 (IIS_MD_SERVER_BASE+16 )
#define MD_SERVER_AUTOSTART             (IIS_MD_SERVER_BASE+17 )
#define MD_SERVER_SIZE                  (IIS_MD_SERVER_BASE+18 )
#define MD_SERVER_LISTEN_BACKLOG        (IIS_MD_SERVER_BASE+19 )
#define MD_SERVER_LISTEN_TIMEOUT        (IIS_MD_SERVER_BASE+20 )
#define MD_DOWNLEVEL_ADMIN_INSTANCE     (IIS_MD_SERVER_BASE+21 )
#define MD_LEVELS_TO_SCAN               (IIS_MD_SERVER_BASE+22 )
#define MD_SERVER_BINDINGS              (IIS_MD_SERVER_BASE+23 )
#define MD_MAX_ENDPOINT_CONNECTIONS     (IIS_MD_SERVER_BASE+24 )
#define MD_SERVER_CONFIGURATION_INFO    (IIS_MD_SERVER_BASE+27 )
#define MD_IISADMIN_EXTENSIONS          (IIS_MD_SERVER_BASE+28 )
#define MD_DISABLE_SOCKET_POOLING       (IIS_MD_SERVER_BASE+29 )
#define MD_METADATA_ID_REGISTRATION     (IIS_MD_SERVER_BASE+30 )


//
//  These properties are specific to HTTP and belong to the website
//

#define IIS_MD_HTTP_BASE                2000

#define MD_SECURE_BINDINGS              (IIS_MD_HTTP_BASE+21 )

#define MD_FILTER_LOAD_ORDER            (IIS_MD_HTTP_BASE+40 )
#define MD_FILTER_IMAGE_PATH            (IIS_MD_HTTP_BASE+41 )
#define MD_FILTER_STATE                 (IIS_MD_HTTP_BASE+42 )
#define MD_FILTER_ENABLED               (IIS_MD_HTTP_BASE+43 )
#define MD_FILTER_FLAGS                 (IIS_MD_HTTP_BASE+44 )
#define MD_FILTER_DESCRIPTION           (IIS_MD_HTTP_BASE+45 )
#define MD_FILTER_ENABLE_CACHE          (IIS_MD_HTTP_BASE+46 )

#define MD_ADV_NOTIFY_PWD_EXP_IN_DAYS   (IIS_MD_HTTP_BASE+63 )
#define MD_ADV_CACHE_TTL                (IIS_MD_HTTP_BASE+64 )
#define MD_NET_LOGON_WKS                (IIS_MD_HTTP_BASE+65 )
#define MD_USE_HOST_NAME                (IIS_MD_HTTP_BASE+66 )
#define MD_AUTH_CHANGE_FLAGS            (IIS_MD_HTTP_BASE+68 )

#define MD_PROCESS_NTCR_IF_LOGGED_ON    (IIS_MD_HTTP_BASE+70 )

#define MD_FRONTPAGE_WEB                (IIS_MD_HTTP_BASE+72 )
#define MD_IN_PROCESS_ISAPI_APPS        (IIS_MD_HTTP_BASE+73 )

#define MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS  ( IIS_MD_HTTP_BASE+95)

#define MD_APP_FRIENDLY_NAME            (IIS_MD_HTTP_BASE+102)
#define MD_APP_ROOT                     (IIS_MD_HTTP_BASE+103)
#define MD_APP_ISOLATED                 (IIS_MD_HTTP_BASE+104)
#define MD_APP_WAM_CLSID                (IIS_MD_HTTP_BASE+105)
#define MD_APP_PACKAGE_ID               (IIS_MD_HTTP_BASE+106)
#define MD_APP_PACKAGE_NAME             (IIS_MD_HTTP_BASE+107)
#define MD_APP_OOP_RECOVER_LIMIT        (IIS_MD_HTTP_BASE+110)
#define MD_APP_PERIODIC_RESTART_TIME    (IIS_MD_HTTP_BASE+111)
#define MD_APP_PERIODIC_RESTART_REQUESTS  (IIS_MD_HTTP_BASE+112)
#define MD_APP_PERIODIC_RESTART_SCHEDULE  (IIS_MD_HTTP_BASE+113)
#define MD_APP_SHUTDOWN_TIME_LIMIT      (IIS_MD_HTTP_BASE+114)


#define MD_ADMIN_INSTANCE               (IIS_MD_HTTP_BASE+115)
// This is only used by setup & UI
#define MD_NOT_DELETABLE                (IIS_MD_HTTP_BASE+116)

#define MD_CUSTOM_ERROR_DESC            (IIS_MD_HTTP_BASE+120)

//
//  Client Access License parameters
//

#define MD_CAL_VC_PER_CONNECT           (IIS_MD_HTTP_BASE+130)
#define MD_CAL_AUTH_RESERVE_TIMEOUT     (IIS_MD_HTTP_BASE+131)
#define MD_CAL_SSL_RESERVE_TIMEOUT      (IIS_MD_HTTP_BASE+132)
#define MD_CAL_W3_ERROR                 (IIS_MD_HTTP_BASE+133)

//
// CPU Accounting and Throttling Properties
//

//
// The enabled flags are per Application or CGI
//

#define MD_CPU_CGI_ENABLED              (IIS_MD_HTTP_BASE+140)
#define MD_CPU_APP_ENABLED              (IIS_MD_HTTP_BASE+141)

//
// These values are per site
//

#define MD_CPU_LIMITS_ENABLED           (IIS_MD_HTTP_BASE+143)
#define MD_CPU_RESET_INTERVAL           (IIS_MD_HTTP_BASE+144)
#define MD_CPU_LOGGING_INTERVAL         (IIS_MD_HTTP_BASE+145)
#define MD_CPU_LOGGING_OPTIONS          (IIS_MD_HTTP_BASE+146)
#define MD_CPU_CGI_LIMIT                (IIS_MD_HTTP_BASE+148)
#define MD_CPU_LIMIT_LOGEVENT           (IIS_MD_HTTP_BASE+149)
#define MD_CPU_LIMIT_PRIORITY           (IIS_MD_HTTP_BASE+150)
#define MD_CPU_LIMIT_PROCSTOP           (IIS_MD_HTTP_BASE+151)
#define MD_CPU_LIMIT_PAUSE              (IIS_MD_HTTP_BASE+152)

//
// DAV Enabled - Can be set on a per-URL level
//
#define MD_DAV_ENABLED                  (IIS_MD_HTTP_BASE+153)

//
// Valid values for CPU Accounting's MD_CPU_LOGGING_OPTIONS field
//

#define MD_CPU_DISABLE_ALL_LOGGING      0x0
#define MD_CPU_ENABLE_ALL_PROC_LOGGING  0x1
#define MD_CPU_ENABLE_CGI_LOGGING       0x2
#define MD_CPU_ENABLE_APP_LOGGING       0x4

//
// Valid values for CPU Accounting's MD_CPU_LOGGING_MASK field
// This defines which fields will be logged
//

#define MD_CPU_ENABLE_EVENT             0x01
#define MD_CPU_ENABLE_PROC_TYPE         0x02
#define MD_CPU_ENABLE_USER_TIME         0x04
#define MD_CPU_ENABLE_KERNEL_TIME       0x08
#define MD_CPU_ENABLE_PAGE_FAULTS       0x10
#define MD_CPU_ENABLE_TOTAL_PROCS       0x20
#define MD_CPU_ENABLE_ACTIVE_PROCS      0x40
#define MD_CPU_ENABLE_TERMINATED_PROCS  0x80

#define MD_CPU_ENABLE_LOGGING           0x80000000

//
//  Site Server properties
//


//
// Properties to disable/restrict request handlers.
//

#define MD_ISAPI_RESTRICTION_LIST           (IIS_MD_HTTP_BASE+163)
#define MD_CGI_RESTRICTION_LIST             (IIS_MD_HTTP_BASE+164)
#define MD_RESTRICTION_LIST_CUSTOM_DESC     (IIS_MD_HTTP_BASE+165)
#define MD_SECURITY_SETUP_REQUIRED          (IIS_MD_HTTP_BASE+166)
#define MD_APP_DEPENDENCIES                 (IIS_MD_HTTP_BASE+167)
#define MD_WEB_SVC_EXT_RESTRICTION_LIST     (IIS_MD_HTTP_BASE+168)

#define MD_MD_SERVER_SS_AUTH_MAPPING        (IIS_MD_HTTP_BASE+200)

//
// valid values for MD_CERT_CHECK_MODE
//

#define MD_CERT_NO_REVOC_CHECK                   0x00000001
#define MD_CERT_CACHE_RETRIEVAL_ONLY             0x00000002
#define MD_CERT_CHECK_REVOCATION_FRESHNESS_TIME  0x00000004
#define MD_CERT_NO_USAGE_CHECK                   0x00010000

//
// HTTP Compression properties.  All are global and unheritable.
//

#define MD_HC_COMPRESSION_DIRECTORY             (IIS_MD_HTTP_BASE+210)
#define MD_HC_CACHE_CONTROL_HEADER              (IIS_MD_HTTP_BASE+211)
#define MD_HC_EXPIRES_HEADER                    (IIS_MD_HTTP_BASE+212)
#define MD_HC_DO_DYNAMIC_COMPRESSION            (IIS_MD_HTTP_BASE+213)
#define MD_HC_DO_STATIC_COMPRESSION             (IIS_MD_HTTP_BASE+214)
#define MD_HC_DO_ON_DEMAND_COMPRESSION          (IIS_MD_HTTP_BASE+215)
#define MD_HC_DO_DISK_SPACE_LIMITING            (IIS_MD_HTTP_BASE+216)
#define MD_HC_NO_COMPRESSION_FOR_HTTP_10        (IIS_MD_HTTP_BASE+217)
#define MD_HC_NO_COMPRESSION_FOR_PROXIES        (IIS_MD_HTTP_BASE+218)
#define MD_HC_NO_COMPRESSION_FOR_RANGE          (IIS_MD_HTTP_BASE+219)
#define MD_HC_SEND_CACHE_HEADERS                (IIS_MD_HTTP_BASE+220)
#define MD_HC_MAX_DISK_SPACE_USAGE              (IIS_MD_HTTP_BASE+221)
#define MD_HC_IO_BUFFER_SIZE                    (IIS_MD_HTTP_BASE+222)
#define MD_HC_COMPRESSION_BUFFER_SIZE           (IIS_MD_HTTP_BASE+223)
#define MD_HC_MAX_QUEUE_LENGTH                  (IIS_MD_HTTP_BASE+224)
#define MD_HC_FILES_DELETED_PER_DISK_FREE       (IIS_MD_HTTP_BASE+225)
#define MD_HC_MIN_FILE_SIZE_FOR_COMP            (IIS_MD_HTTP_BASE+226)

#define MD_HC_COMPRESSION_DLL                   (IIS_MD_HTTP_BASE+237)
#define MD_HC_FILE_EXTENSIONS                   (IIS_MD_HTTP_BASE+238)
#define MD_HC_PRIORITY                          (IIS_MD_HTTP_BASE+240)
#define MD_HC_DYNAMIC_COMPRESSION_LEVEL         (IIS_MD_HTTP_BASE+241)
#define MD_HC_ON_DEMAND_COMP_LEVEL              (IIS_MD_HTTP_BASE+242)
#define MD_HC_CREATE_FLAGS                      (IIS_MD_HTTP_BASE+243)
#define MD_HC_SCRIPT_FILE_EXTENSIONS            (IIS_MD_HTTP_BASE+244)

#define MD_HC_DO_NAMESPACE_DYNAMIC_COMPRESSION  (IIS_MD_HTTP_BASE+255)
#define MD_HC_DO_NAMESPACE_STATIC_COMPRESSION   (IIS_MD_HTTP_BASE+256)

//
// Generic property indicating a failure status code - Can be used under
// any component that can fail (virtual directory, filters, applications etc)
//

#define MD_WIN32_ERROR                          (IIS_MD_SERVER_BASE+99 )

//
// Virtual root properties - note MD_ACCESS_PERM is also generally set at
// the virtual directory.  These are used for both HTTP and FTP
//

#define IIS_MD_VR_BASE                  3000

#define MD_VR_PATH                      (IIS_MD_VR_BASE+1 )
#define MD_VR_USERNAME                  (IIS_MD_VR_BASE+2 )
#define MD_VR_PASSWORD                  (IIS_MD_VR_BASE+3 )
#define MD_VR_PASSTHROUGH               (IIS_MD_VR_BASE+6 )
#define MD_VR_NO_CACHE                  (IIS_MD_VR_BASE+7 )

//
//  Logging related attributes
//

#define IIS_MD_LOG_BASE                     4000

#define MD_LOG_TYPE                         (IIS_MD_LOG_BASE+0  )
#define MD_LOGFILE_DIRECTORY                (IIS_MD_LOG_BASE+1  )
#define MD_LOG_UNUSED1                      (IIS_MD_LOG_BASE+2  )
#define MD_LOGFILE_PERIOD                   (IIS_MD_LOG_BASE+3  )
#define MD_LOGFILE_TRUNCATE_SIZE            (IIS_MD_LOG_BASE+4  )
#define MD_LOG_PLUGIN_MOD_ID                (IIS_MD_LOG_BASE+5  )
#define MD_LOG_PLUGIN_UI_ID                 (IIS_MD_LOG_BASE+6  )
#define MD_LOGSQL_DATA_SOURCES              (IIS_MD_LOG_BASE+7  )
#define MD_LOGSQL_TABLE_NAME                (IIS_MD_LOG_BASE+8  )
#define MD_LOGSQL_USER_NAME                 (IIS_MD_LOG_BASE+9  )
#define MD_LOGSQL_PASSWORD                  (IIS_MD_LOG_BASE+10 )
#define MD_LOG_PLUGIN_ORDER                 (IIS_MD_LOG_BASE+11 )
#define MD_LOG_PLUGINS_AVAILABLE            (IIS_MD_LOG_BASE+12 )
#define MD_LOGEXT_FIELD_MASK                (IIS_MD_LOG_BASE+13 )
#define MD_LOGEXT_FIELD_MASK2               (IIS_MD_LOG_BASE+14 )

//
// Allow W3C logging file naming and rollover based on Local Time
//

#define MD_LOGFILE_LOCALTIME_ROLLOVER       (IIS_MD_LOG_BASE+15 )

#define IIS_MD_LOG_LAST                     MD_LOGFILE_LOCALTIME_ROLLOVER

//
// Global Flag to denote that IIS will generate one centralized
// binary log file rather than a separate file per web site
//
#define MD_GLOBAL_BINARY_LOGGING_ENABLED    (IIS_MD_LOG_BASE+16 )

//
// Log type
//

#define MD_LOG_TYPE_DISABLED            0
#define MD_LOG_TYPE_ENABLED             1

//
// LOGGING values
//

#define MD_LOGFILE_PERIOD_NONE          0
#define MD_LOGFILE_PERIOD_MAXSIZE       0
#define MD_LOGFILE_PERIOD_DAILY         1
#define MD_LOGFILE_PERIOD_WEEKLY        2
#define MD_LOGFILE_PERIOD_MONTHLY       3
#define MD_LOGFILE_PERIOD_HOURLY        4

//
// Field masks for extended logging
// Fields are logged in order of increasing mask value
//

#define MD_EXTLOG_DATE                  0x00000001
#define MD_EXTLOG_TIME                  0x00000002
#define MD_EXTLOG_CLIENT_IP             0x00000004
#define MD_EXTLOG_USERNAME              0x00000008
#define MD_EXTLOG_SITE_NAME             0x00000010
#define MD_EXTLOG_COMPUTER_NAME         0x00000020
#define MD_EXTLOG_SERVER_IP             0x00000040
#define MD_EXTLOG_METHOD                0x00000080
#define MD_EXTLOG_URI_STEM              0x00000100
#define MD_EXTLOG_URI_QUERY             0x00000200
#define MD_EXTLOG_HTTP_STATUS           0x00000400
#define MD_EXTLOG_WIN32_STATUS          0x00000800
#define MD_EXTLOG_BYTES_SENT            0x00001000
#define MD_EXTLOG_BYTES_RECV            0x00002000
#define MD_EXTLOG_TIME_TAKEN            0x00004000
#define MD_EXTLOG_SERVER_PORT           0x00008000
#define MD_EXTLOG_USER_AGENT            0x00010000
#define MD_EXTLOG_COOKIE                0x00020000
#define MD_EXTLOG_REFERER               0x00040000
#define MD_EXTLOG_PROTOCOL_VERSION      0x00080000
#define MD_EXTLOG_HOST                  0x00100000


#define MD_DEFAULT_EXTLOG_FIELDS        (MD_EXTLOG_CLIENT_IP | \
                                         MD_EXTLOG_TIME      | \
                                         MD_EXTLOG_METHOD    | \
                                         MD_EXTLOG_URI_STEM  | \
                                         MD_EXTLOG_HTTP_STATUS)

//
// Custom Logging related attributes
//

#define IIS_MD_LOGCUSTOM_BASE           4500

//
// Custom Logging configuration attributes
//

#define MD_LOGCUSTOM_PROPERTY_NAME      (IIS_MD_LOGCUSTOM_BASE+1 )
#define MD_LOGCUSTOM_PROPERTY_HEADER    (IIS_MD_LOGCUSTOM_BASE+2 )
#define MD_LOGCUSTOM_PROPERTY_ID        (IIS_MD_LOGCUSTOM_BASE+3 )
#define MD_LOGCUSTOM_PROPERTY_MASK      (IIS_MD_LOGCUSTOM_BASE+4 )
#define MD_LOGCUSTOM_PROPERTY_DATATYPE  (IIS_MD_LOGCUSTOM_BASE+5 )
#define MD_LOGCUSTOM_SERVICES_STRING    (IIS_MD_LOGCUSTOM_BASE+6 )      // MultiSZ List of services that the property is applicable to.

#define MD_CPU_LOGGING_MASK             (IIS_MD_LOGCUSTOM_BASE+7 )
#define MD_LOGCUSTOM_PROPERTY_NODE_ID   (IIS_MD_LOGCUSTOM_BASE+8 )

//
// The values for MD_CPU_LOGGING_MASK are defined above.
// See MD_CPU_ENABLE_EVENT, etc.
//


#define IIS_MD_LOGCUSTOM_LAST           MD_CPU_LOGGING_MASK

//
// Valid values for Custom Logging's MD_LOGCUSTOM_PROPERTY_DATATYPE field
//

#define MD_LOGCUSTOM_DATATYPE_INT       0
#define MD_LOGCUSTOM_DATATYPE_UINT      1
#define MD_LOGCUSTOM_DATATYPE_LONG      2
#define MD_LOGCUSTOM_DATATYPE_ULONG     3
#define MD_LOGCUSTOM_DATATYPE_FLOAT     4
#define MD_LOGCUSTOM_DATATYPE_DOUBLE    5
#define MD_LOGCUSTOM_DATATYPE_LPSTR     6
#define MD_LOGCUSTOM_DATATYPE_LPWSTR    7


//
//  ISAPI Filter Notification Flags
//

#define MD_NOTIFY_SECURE_PORT           0x00000001
#define MD_NOTIFY_NONSECURE_PORT        0x00000002

#define MD_NOTIFY_READ_RAW_DATA         0x00008000
#define MD_NOTIFY_PREPROC_HEADERS       0x00004000
#define MD_NOTIFY_AUTHENTICATION        0x00002000
#define MD_NOTIFY_URL_MAP               0x00001000
#define MD_NOTIFY_ACCESS_DENIED         0x00000800
#define MD_NOTIFY_SEND_RESPONSE         0x00000040
#define MD_NOTIFY_SEND_RAW_DATA         0x00000400
#define MD_NOTIFY_LOG                   0x00000200
#define MD_NOTIFY_END_OF_REQUEST        0x00000080
#define MD_NOTIFY_END_OF_NET_SESSION    0x00000100
#define MD_NOTIFY_AUTH_COMPLETE         0x04000000
//
//  ISAPI Filter ordering flags
//

#define MD_NOTIFY_ORDER_HIGH            0x00080000
#define MD_NOTIFY_ORDER_MEDIUM          0x00040000
#define MD_NOTIFY_ORDER_LOW             0x00020000
#define MD_NOTIFY_ORDER_DEFAULT         MD_NOTIFY_ORDER_LOW

#define MD_NOTIFY_ORDER_MASK            (MD_NOTIFY_ORDER_HIGH   |    \
                                         MD_NOTIFY_ORDER_MEDIUM |    \
                                         MD_NOTIFY_ORDER_LOW)


//
//  These are FTP specific properties
//

#define IIS_MD_FTP_BASE                 5000

#define MD_EXIT_MESSAGE                 (IIS_MD_FTP_BASE+1  )
#define MD_GREETING_MESSAGE             (IIS_MD_FTP_BASE+2  )
#define MD_MAX_CLIENTS_MESSAGE          (IIS_MD_FTP_BASE+3  )
#define MD_MSDOS_DIR_OUTPUT             (IIS_MD_FTP_BASE+4  )
#define MD_ALLOW_ANONYMOUS              (IIS_MD_FTP_BASE+5  )
#define MD_ANONYMOUS_ONLY               (IIS_MD_FTP_BASE+6  )
#define MD_LOG_ANONYMOUS                (IIS_MD_FTP_BASE+7  )
#define MD_LOG_NONANONYMOUS             (IIS_MD_FTP_BASE+8  )
#define MD_ALLOW_REPLACE_ON_RENAME      (IIS_MD_FTP_BASE+9  )
#define MD_SHOW_4_DIGIT_YEAR            (IIS_MD_FTP_BASE+10 )
#define MD_BANNER_MESSAGE               (IIS_MD_FTP_BASE+11 )
#define MD_USER_ISOLATION               (IIS_MD_FTP_BASE+12 )
#define MD_FTP_LOG_IN_UTF_8             (IIS_MD_FTP_BASE+13 )
#define MD_AD_CONNECTIONS_USERNAME      (IIS_MD_FTP_BASE+14 )
#define MD_AD_CONNECTIONS_PASSWORD      (IIS_MD_FTP_BASE+15 )
#define MD_PASSIVE_PORT_RANGE           (IIS_MD_FTP_BASE+16 )

//
//  These are SSL specific properties
//

#define IIS_MD_SSL_BASE                 5500

#define MD_SSL_PUBLIC_KEY               ( IIS_MD_SSL_BASE+0 )
#define MD_SSL_PRIVATE_KEY              ( IIS_MD_SSL_BASE+1 )
#define MD_SSL_KEY_PASSWORD             ( IIS_MD_SSL_BASE+2 )
#define MD_SSL_KEY_REQUEST              ( IIS_MD_SSL_BASE+3 )

//
// These are server certificate properties
//
//
// These are Certificate Trust List properties
//

//
// Metabase property that defines whether to use DS mapper or not
//
#define MD_SSL_USE_DS_MAPPER            ( IIS_MD_SSL_BASE+19 )


//
// Metabase properties that are used by the CertWiz ActiveX control, that
// is used for the Certificate/CTL UI management tool
//

//
// Metabase properties used for Fortezza certificates
//

//
// Metabase properties that are used by the CertWiz ActiveX control to keep
// track of the user's entry history, and whether DEBUG is enabled.  We keep
// these private properties on a per VS basis.
//

//  File and Directory related properties - these should be added in the
//  metabase with a user type of IIS_MD_UT_FILE
//

#define IIS_MD_FILE_PROP_BASE           6000

#define MD_AUTHORIZATION                (IIS_MD_FILE_PROP_BASE )
#define MD_REALM                        (IIS_MD_FILE_PROP_BASE+1 )
#define MD_HTTP_EXPIRES                 (IIS_MD_FILE_PROP_BASE+2 )
#define MD_HTTP_PICS                    (IIS_MD_FILE_PROP_BASE+3 )
#define MD_HTTP_CUSTOM                  (IIS_MD_FILE_PROP_BASE+4 )
#define MD_DIRECTORY_BROWSING           (IIS_MD_FILE_PROP_BASE+5 )
#define MD_DEFAULT_LOAD_FILE            (IIS_MD_FILE_PROP_BASE+6 )
#define MD_CUSTOM_ERROR                 (IIS_MD_FILE_PROP_BASE+8 )
#define MD_FOOTER_DOCUMENT              (IIS_MD_FILE_PROP_BASE+9 )
#define MD_FOOTER_ENABLED               (IIS_MD_FILE_PROP_BASE+10 )
#define MD_HTTP_REDIRECT                (IIS_MD_FILE_PROP_BASE+11 )
#define MD_DEFAULT_LOGON_DOMAIN         (IIS_MD_FILE_PROP_BASE+12 )
#define MD_LOGON_METHOD                 (IIS_MD_FILE_PROP_BASE+13 )
#define MD_SCRIPT_MAPS                  (IIS_MD_FILE_PROP_BASE+14 )
#define MD_MIME_MAP                     (IIS_MD_FILE_PROP_BASE+15 )
#define MD_ACCESS_PERM                  (IIS_MD_FILE_PROP_BASE+16 )
#define MD_IP_SEC                       (IIS_MD_FILE_PROP_BASE+19 )
#define MD_ANONYMOUS_USER_NAME          (IIS_MD_FILE_PROP_BASE+20 )
#define MD_ANONYMOUS_PWD                (IIS_MD_FILE_PROP_BASE+21 )
#define MD_ANONYMOUS_USE_SUBAUTH        (IIS_MD_FILE_PROP_BASE+22 )
#define MD_DONT_LOG                     (IIS_MD_FILE_PROP_BASE+23 )
#define MD_ADMIN_ACL                    (IIS_MD_FILE_PROP_BASE+27 )
#define MD_SSI_EXEC_DISABLED            (IIS_MD_FILE_PROP_BASE+28 )
#define MD_DO_REVERSE_DNS               (IIS_MD_FILE_PROP_BASE+29 )
#define MD_SSL_ACCESS_PERM              (IIS_MD_FILE_PROP_BASE+30 )
#define MD_AUTHORIZATION_PERSISTENCE    (IIS_MD_FILE_PROP_BASE+31 )
#define MD_NTAUTHENTICATION_PROVIDERS   (IIS_MD_FILE_PROP_BASE+32 )
#define MD_SCRIPT_TIMEOUT               (IIS_MD_FILE_PROP_BASE+33 )
#define MD_CACHE_EXTENSIONS             (IIS_MD_FILE_PROP_BASE+34 )
#define MD_CREATE_PROCESS_AS_USER       (IIS_MD_FILE_PROP_BASE+35 )
#define MD_CREATE_PROC_NEW_CONSOLE      (IIS_MD_FILE_PROP_BASE+36 )
#define MD_POOL_IDC_TIMEOUT             (IIS_MD_FILE_PROP_BASE+37 )
#define MD_ALLOW_KEEPALIVES             (IIS_MD_FILE_PROP_BASE+38 )
#define MD_IS_CONTENT_INDEXED           (IIS_MD_FILE_PROP_BASE+39 )
#define MD_CC_NO_CACHE                  (IIS_MD_FILE_PROP_BASE+41 )
#define MD_CC_MAX_AGE                   (IIS_MD_FILE_PROP_BASE+42 )
#define MD_CC_OTHER                     (IIS_MD_FILE_PROP_BASE+43 )
#define MD_REDIRECT_HEADERS             (IIS_MD_FILE_PROP_BASE+44 )
#define MD_UPLOAD_READAHEAD_SIZE        (IIS_MD_FILE_PROP_BASE+45 )
#define MD_PUT_READ_SIZE                (IIS_MD_FILE_PROP_BASE+46 )
#define MD_USE_DIGEST_SSP               (IIS_MD_FILE_PROP_BASE+47 )

#define MD_ENABLE_URL_AUTHORIZATION     (IIS_MD_FILE_PROP_BASE+48 )
#define MD_URL_AUTHORIZATION_STORE_NAME (IIS_MD_FILE_PROP_BASE+49 )
#define MD_URL_AUTHORIZATION_SCOPE_NAME (IIS_MD_FILE_PROP_BASE+50 )

#define MD_MAX_REQUEST_ENTITY_ALLOWED   (IIS_MD_FILE_PROP_BASE+51 )


#define ASP_MD_SERVER_BASE                  7000

#define MD_ASP_BUFFERINGON                  (ASP_MD_SERVER_BASE + 0)
#define MD_ASP_LOGERRORREQUESTS             (ASP_MD_SERVER_BASE + 1)
#define MD_ASP_SCRIPTERRORSSENTTOBROWSER    (ASP_MD_SERVER_BASE + 2)
#define MD_ASP_SCRIPTERRORMESSAGE           (ASP_MD_SERVER_BASE + 3)
#define MD_ASP_SCRIPTFILECACHESIZE          (ASP_MD_SERVER_BASE + 4)
#define MD_ASP_SCRIPTENGINECACHEMAX         (ASP_MD_SERVER_BASE + 5)
#define MD_ASP_SCRIPTTIMEOUT                (ASP_MD_SERVER_BASE + 6)
#define MD_ASP_SESSIONTIMEOUT               (ASP_MD_SERVER_BASE + 7)
#define MD_ASP_ENABLEPARENTPATHS            (ASP_MD_SERVER_BASE + 8)
#define MD_ASP_MEMFREEFACTOR                (ASP_MD_SERVER_BASE + 9)    // OBSOLETE
#define MD_ASP_MINUSEDBLOCKS                (ASP_MD_SERVER_BASE + 10)   // OBSOLETE
#define MD_ASP_ALLOWSESSIONSTATE            (ASP_MD_SERVER_BASE + 11)
#define MD_ASP_SCRIPTLANGUAGE               (ASP_MD_SERVER_BASE + 12)
#define MD_ASP_QUEUETIMEOUT                 (ASP_MD_SERVER_BASE + 13)
#define MD_ASP_ALLOWOUTOFPROCCOMPONENTS     (ASP_MD_SERVER_BASE + 14)
#define MD_ASP_ALLOWOUTOFPROCCMPNTS         (MD_ASP_ALLOWOUTOFPROCCOMPONENTS)   // Deprecated.  Use MD_ASP_ALLOWOUTOFPROCCMPNTS
#define MD_ASP_EXCEPTIONCATCHENABLE         (ASP_MD_SERVER_BASE + 15)
#define MD_ASP_CODEPAGE                     (ASP_MD_SERVER_BASE + 16)
#define MD_ASP_SCRIPTLANGUAGELIST           (ASP_MD_SERVER_BASE + 17)
#define MD_ASP_ENABLESERVERDEBUG            (ASP_MD_SERVER_BASE + 18)
#define MD_ASP_ENABLECLIENTDEBUG            (ASP_MD_SERVER_BASE + 19)
#define MD_ASP_TRACKTHREADINGMODEL          (ASP_MD_SERVER_BASE + 20)
// added for IIS 5.0
#define MD_ASP_ENABLEASPHTMLFALLBACK        (ASP_MD_SERVER_BASE + 21)
#define MD_ASP_ENABLECHUNKEDENCODING        (ASP_MD_SERVER_BASE + 22)
#define MD_ASP_ENABLETYPELIBCACHE           (ASP_MD_SERVER_BASE + 23)
#define MD_ASP_ERRORSTONTLOG                (ASP_MD_SERVER_BASE + 24)
#define MD_ASP_PROCESSORTHREADMAX           (ASP_MD_SERVER_BASE + 25)
#define MD_ASP_REQEUSTQUEUEMAX              (ASP_MD_SERVER_BASE + 26)
#define MD_ASP_ENABLEAPPLICATIONRESTART     (ASP_MD_SERVER_BASE + 27)
#define MD_ASP_QUEUECONNECTIONTESTTIME      (ASP_MD_SERVER_BASE + 28)
#define MD_ASP_SESSIONMAX                   (ASP_MD_SERVER_BASE + 29)
// thread gate
#define MD_ASP_THREADGATEENABLED            (ASP_MD_SERVER_BASE + 30)
#define MD_ASP_THREADGATETIMESLICE          (ASP_MD_SERVER_BASE + 31)
#define MD_ASP_THREADGATESLEEPDELAY         (ASP_MD_SERVER_BASE + 32)
#define MD_ASP_THREADGATESLEEPMAX           (ASP_MD_SERVER_BASE + 33)
#define MD_ASP_THREADGATELOADLOW            (ASP_MD_SERVER_BASE + 34)
#define MD_ASP_THREADGATELOADHIGH           (ASP_MD_SERVER_BASE + 35)

// added IIS5.1

// persist template cache
#define MD_ASP_DISKTEMPLATECACHEDIRECTORY   (ASP_MD_SERVER_BASE + 36)
#define MD_ASP_MAXDISKTEMPLATECACHEFILES    (ASP_MD_SERVER_BASE + 40)
#define MD_ASP_EXECUTEINMTA                 (ASP_MD_SERVER_BASE + 41)
#define MD_ASP_LCID                         (ASP_MD_SERVER_BASE + 42)
#define MD_ASP_KEEPSESSIONIDSECURE          (ASP_MD_SERVER_BASE + 43)

// added IIS6.0

// Services without components integration
#define MD_ASP_SERVICE_FLAGS                (ASP_MD_SERVER_BASE + 44)
#define MD_ASP_SERVICE_FLAG_TRACKER         (ASP_MD_SERVER_BASE + 45)
#define MD_ASP_SERVICE_FLAG_FUSION          (ASP_MD_SERVER_BASE + 46)
#define MD_ASP_SERVICE_FLAG_PARTITIONS      (ASP_MD_SERVER_BASE + 47)
#define MD_ASP_SERVICE_PARTITION_ID         (ASP_MD_SERVER_BASE + 48)
#define MD_ASP_SERVICE_SXS_NAME             (ASP_MD_SERVER_BASE + 49)

// Line number calculation flag.
#define MD_ASP_CALCLINENUMBER               (ASP_MD_SERVER_BASE + 50)

#define MD_ASP_RUN_ONEND_ANON               (ASP_MD_SERVER_BASE + 51)

#define MD_ASP_BUFFER_LIMIT                 (ASP_MD_SERVER_BASE + 52)

#define MD_ASP_MAX_REQUEST_ENTITY_ALLOWED   (ASP_MD_SERVER_BASE + 53)

#define MD_ASP_ID_LAST                      (ASP_MD_SERVER_BASE + 53)

//
//  Valid values for WAM
//
#define WAM_MD_SERVER_BASE                  7500

#define MD_WAM_USER_NAME                    (WAM_MD_SERVER_BASE+1)
#define MD_WAM_PWD                          (WAM_MD_SERVER_BASE+2)


// added IIS6

//
//  Valid values for APP POOL
//

#define IIS_MD_APPPOOL_BASE 9000

#define MD_APPPOOL_PERIODIC_RESTART_TIME              (IIS_MD_APPPOOL_BASE + 1)
#define MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT     (IIS_MD_APPPOOL_BASE + 2)
#define MD_APPPOOL_MAX_PROCESS_COUNT                  (IIS_MD_APPPOOL_BASE + 3)
#define MD_APPPOOL_PINGING_ENABLED                    (IIS_MD_APPPOOL_BASE + 4)
#define MD_APPPOOL_IDLE_TIMEOUT                       (IIS_MD_APPPOOL_BASE + 5)
#define MD_APPPOOL_RAPID_FAIL_PROTECTION_ENABLED      (IIS_MD_APPPOOL_BASE + 6)
#define MD_APPPOOL_SMP_AFFINITIZED                    (IIS_MD_APPPOOL_BASE + 7)
#define MD_APPPOOL_SMP_AFFINITIZED_PROCESSOR_MASK     (IIS_MD_APPPOOL_BASE + 8)
#define MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING     (IIS_MD_APPPOOL_BASE + 9)

#define MD_APPPOOL_STARTUP_TIMELIMIT                  (IIS_MD_APPPOOL_BASE + 11)
#define MD_APPPOOL_SHUTDOWN_TIMELIMIT                 (IIS_MD_APPPOOL_BASE + 12)
#define MD_APPPOOL_PING_INTERVAL                      (IIS_MD_APPPOOL_BASE + 13)
#define MD_APPPOOL_PING_RESPONSE_TIMELIMIT            (IIS_MD_APPPOOL_BASE + 14)
#define MD_APPPOOL_DISALLOW_OVERLAPPING_ROTATION      (IIS_MD_APPPOOL_BASE + 15)
#define MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH            (IIS_MD_APPPOOL_BASE + 17)
#define MD_APPPOOL_DISALLOW_ROTATION_ON_CONFIG_CHANGE (IIS_MD_APPPOOL_BASE + 18)
#define MD_APPPOOL_PERIODIC_RESTART_SCHEDULE          (IIS_MD_APPPOOL_BASE + 20)
#define MD_APPPOOL_IDENTITY_TYPE                      (IIS_MD_APPPOOL_BASE + 21)
#define MD_CPU_ACTION                                 (IIS_MD_APPPOOL_BASE + 22)
#define MD_CPU_LIMIT                                  (IIS_MD_APPPOOL_BASE + 23)
#define MD_APPPOOL_PERIODIC_RESTART_MEMORY            (IIS_MD_APPPOOL_BASE + 24)
#define MD_APPPOOL_COMMAND                            (IIS_MD_APPPOOL_BASE + 26)
#define MD_APPPOOL_STATE                              (IIS_MD_APPPOOL_BASE + 27)
#define MD_APPPOOL_AUTO_START                         (IIS_MD_APPPOOL_BASE + 28)
#define MD_RAPID_FAIL_PROTECTION_INTERVAL             (IIS_MD_APPPOOL_BASE + 29)
#define MD_RAPID_FAIL_PROTECTION_MAX_CRASHES          (IIS_MD_APPPOOL_BASE + 30)
#define MD_APPPOOL_ORPHAN_ACTION_EXE                  (IIS_MD_APPPOOL_BASE + 31)
#define MD_APPPOOL_ORPHAN_ACTION_PARAMS               (IIS_MD_APPPOOL_BASE + 32)
#define MB_DONT_IMPERSONATE                           (IIS_MD_APPPOOL_BASE + 33)

//
// Load balancer properties
//
#define MD_LOAD_BALANCER_CAPABILITIES                 (IIS_MD_APPPOOL_BASE + 34)

//
//  Valid values for APP POOL
//
#define MD_APPPOOL_AUTO_SHUTDOWN_EXE                  (IIS_MD_APPPOOL_BASE + 35)
#define MD_APPPOOL_AUTO_SHUTDOWN_PARAMS               (IIS_MD_APPPOOL_BASE + 36)
#define MD_APP_POOL_LOG_EVENT_ON_RECYCLE              (IIS_MD_APPPOOL_BASE + 37)
#define MD_APPPOOL_PERIODIC_RESTART_PRIVATE_MEMORY    (IIS_MD_APPPOOL_BASE + 38)

//
// Valid values for MD_APP_POOL_LOG_EVENT_ON_RECYCLE
//
#define MD_APP_POOL_RECYCLE_TIME                      1
#define MD_APP_POOL_RECYCLE_REQUESTS                  2
#define MD_APP_POOL_RECYCLE_SCHEDULE                  4
#define MD_APP_POOL_RECYCLE_MEMORY                    8
#define MD_APP_POOL_RECYCLE_ISAPI_UNHEALTHY           16
#define MD_APP_POOL_RECYCLE_ON_DEMAND                 32
#define MD_APP_POOL_RECYCLE_CONFIG_CHANGE             64
#define MD_APP_POOL_RECYCLE_PRIVATE_MEMORY            128


//
// Valid values for MD_CPU_ACTION
//

#define MD_CPU_NO_ACTION                              0
#define MD_CPU_KILL_W3WP                              1
#define MD_CPU_TRACE                                  2
#define MD_CPU_THROTTLE                               3

//
// Valid values for MD_APPPOOL_COMMAND
//

#define MD_APPPOOL_COMMAND_START                      1
#define MD_APPPOOL_COMMAND_STOP                       2

//
// Valid values for MD_APPPOOL_STATE
//

#define MD_APPPOOL_STATE_STARTING                     1
#define MD_APPPOOL_STATE_STARTED                      2
#define MD_APPPOOL_STATE_STOPPING                     3
#define MD_APPPOOL_STATE_STOPPED                      4

//
// Valid values for MD_APPPOOL_IDENTITY_TYPE
//
#define MD_APPPOOL_IDENTITY_TYPE_LOCALSYSTEM          0
#define MD_APPPOOL_IDENTITY_TYPE_LOCALSERVICE         1
#define MD_APPPOOL_IDENTITY_TYPE_NETWORKSERVICE       2
#define MD_APPPOOL_IDENTITY_TYPE_SPECIFICUSER         3

//
// Valid values for MD_LOAD_BALANCER_CAPABILITIES
//
#define MD_LOAD_BALANCER_CAPABILITIES_BASIC           1
#define MD_LOAD_BALANCER_CAPABILITIES_SOPHISTICATED   2

#define IIS_MD_APP_BASE                               9100
#define MD_APP_APPPOOL_ID                             (IIS_MD_APP_BASE+1)
#define MD_APP_ALLOW_TRANSIENT_REGISTRATION           (IIS_MD_APP_BASE+2)
#define MD_APP_AUTO_START                             (IIS_MD_APP_BASE+3)
#define MD_APPPOOL_PERIODIC_RESTART_CONNECTIONS       (IIS_MD_APP_BASE+4)

//
// TODO: These are duplicate definitions. Remove them if no one is using it.
//

#define MD_APPPOOL_APPPOOL_ID                         (IIS_MD_APP_BASE + 101)
#define MD_APPPOOL_ALLOW_TRANSIENT_REGISTRATION       (IIS_MD_APP_BASE + 102)
// commented out so we can build
//#define MD_APPPOOL_AUTO_START                         (IIS_MD_APP_BASE + 103)


#define IIS_MD_GLOBAL_BASE                              9200
#define MD_MAX_GLOBAL_BANDWIDTH                         (IIS_MD_GLOBAL_BASE+1)
#define MD_GLOBAL_STANDARD_APP_MODE_ENABLED             (IIS_MD_GLOBAL_BASE+3)
#define MD_HEADER_WAIT_TIMEOUT                          (IIS_MD_GLOBAL_BASE+4)
#define MD_MIN_FILE_BYTES_PER_SEC                       (IIS_MD_GLOBAL_BASE+5)
#define MD_GLOBAL_LOG_IN_UTF_8                          (IIS_MD_GLOBAL_BASE+6)
#define MD_DEMAND_START_THRESHOLD                       (IIS_MD_GLOBAL_BASE+7)

#define MD_GLOBAL_SESSIONKEY                                 9999
#define MD_ROOT_ENABLE_EDIT_WHILE_RUNNING                    9998
#define MD_GLOBAL_CHANGE_NUMBER                              9997
#define MD_ROOT_ENABLE_HISTORY                               9996
#define MD_ROOT_MAX_HISTORY_FILES                            9995
#define MD_GLOBAL_EDIT_WHILE_RUNNING_MAJOR_VERSION_NUMBER    9994
#define MD_GLOBAL_EDIT_WHILE_RUNNING_MINOR_VERSION_NUMBER    9993
#define MD_GLOBAL_XMLSCHEMATIMESTAMP                         9992
#define MD_GLOBAL_BINSCHEMATIMESTAMP                         9991
#define MD_COMMENTS                                          9990
#define MD_LOCATION                                          9989
#define MD_MAX_ERROR_FILES                                   9988
#define MD_STOP_LISTENING                                    9987

//
//  Valid values for MD_AUTHORIZATION
//

#define MD_AUTH_ANONYMOUS               0x00000001
#define MD_AUTH_BASIC                   0x00000002
#define MD_AUTH_NT                      0x00000004    // Use NT auth provider (like NTLM)
#define MD_AUTH_PASSPORT                0x00000040

//
//  Valid values for MD_AUTHORIZATION_PERSISTENCE
//


#define MD_AUTH_SINGLEREQUEST                   0x00000040
#define MD_AUTH_SINGLEREQUESTIFPROXY            0x00000080
#define MD_AUTH_SINGLEREQUESTALWAYSIFPROXY      0x00000100

//
//  Valid values for MD_ACCESS_PERM
//

#define MD_ACCESS_READ                  0x00000001    // Allow for Read
#define MD_ACCESS_WRITE                 0x00000002    // Allow for Write
#define MD_ACCESS_EXECUTE               0x00000004    // Allow for Execute
#define MD_ACCESS_SOURCE                0x00000010    // Apply access mask to source
#define MD_ACCESS_SCRIPT                0x00000200    // Allow for Script execution
#define MD_ACCESS_NO_REMOTE_WRITE       0x00000400    // Local host access only
#define MD_ACCESS_NO_REMOTE_READ        0x00001000    // Local host access only
#define MD_ACCESS_NO_REMOTE_EXECUTE     0x00002000    // Local host access only
#define MD_ACCESS_NO_REMOTE_SCRIPT      0x00004000    // Local host access only

#define MD_NONSLL_ACCESS_MASK           (MD_ACCESS_READ|                \
                                         MD_ACCESS_WRITE|               \
                                         MD_ACCESS_EXECUTE|             \
                                         MD_ACCESS_SOURCE|              \
                                         MD_ACCESS_SCRIPT|              \
                                         MD_ACCESS_NO_REMOTE_READ|      \
                                         MD_ACCESS_NO_REMOTE_WRITE|     \
                                         MD_ACCESS_NO_REMOTE_EXECUTE|   \
                                         MD_ACCESS_NO_REMOTE_SCRIPT     \
                                         )
//
//  Valid values for MD_SSL_ACCESS_PERM
//

#define MD_ACCESS_SSL                   0x00000008    // Require SSL
#define MD_ACCESS_NEGO_CERT             0x00000020    // Allow client SSL certs
#define MD_ACCESS_REQUIRE_CERT          0x00000040    // Require client SSL certs
#define MD_ACCESS_MAP_CERT              0x00000080    // Map SSL cert to NT account
#define MD_ACCESS_SSL128                0x00000100    // Require 128 bit SSL

#define MD_SSL_ACCESS_MASK              (MD_ACCESS_SSL|\
                                         MD_ACCESS_NEGO_CERT|\
                                         MD_ACCESS_REQUIRE_CERT|\
                                         MD_ACCESS_MAP_CERT|\
                                         MD_ACCESS_SSL128)

#define MD_ACCESS_MASK                  0x00007fff

//
//  Valid values for MD_DIRECTORY_BROWSING
//

#define MD_DIRBROW_SHOW_DATE            0x00000002
#define MD_DIRBROW_SHOW_TIME            0x00000004
#define MD_DIRBROW_SHOW_SIZE            0x00000008
#define MD_DIRBROW_SHOW_EXTENSION       0x00000010
#define MD_DIRBROW_LONG_DATE            0x00000020

#define MD_DIRBROW_ENABLED              0x80000000  // Allow directory browsing
#define MD_DIRBROW_LOADDEFAULT          0x40000000  // Load default doc if exists

#define MD_DIRBROW_MASK                 (MD_DIRBROW_SHOW_DATE      |    \
                                         MD_DIRBROW_SHOW_TIME      |    \
                                         MD_DIRBROW_SHOW_SIZE      |    \
                                         MD_DIRBROW_SHOW_EXTENSION |    \
                                         MD_DIRBROW_LONG_DATE      |    \
                                         MD_DIRBROW_LOADDEFAULT    |    \
                                         MD_DIRBROW_ENABLED)



//
//  Valid values for MD_LOGON_METHOD
//

#define MD_LOGON_INTERACTIVE        0
#define MD_LOGON_BATCH              1
#define MD_LOGON_NETWORK            2
#define MD_LOGON_NETWORK_CLEARTEXT  3

//
// Valid values for MD_NOTIFY_EXAUTH
//

#define MD_NOTIFEXAUTH_NTLMSSL  1

//
//  Valid values for MD_FILTER_STATE
//

#define MD_FILTER_STATE_LOADED          1
#define MD_FILTER_STATE_UNLOADED        4

//
//  Valid values for MD_SERVER_STATE
//

#define MD_SERVER_STATE_STARTING        1
#define MD_SERVER_STATE_STARTED         2
#define MD_SERVER_STATE_STOPPING        3
#define MD_SERVER_STATE_STOPPED         4
#define MD_SERVER_STATE_PAUSING         5
#define MD_SERVER_STATE_PAUSED          6
#define MD_SERVER_STATE_CONTINUING      7

//
//  Valid values for MD_SERVER_COMMAND
//

#define MD_SERVER_COMMAND_START         1
#define MD_SERVER_COMMAND_STOP          2
#define MD_SERVER_COMMAND_PAUSE         3
#define MD_SERVER_COMMAND_CONTINUE      4

//
//  Valid values for MD_SERVER_SIZE
//

#define MD_SERVER_SIZE_SMALL            0
#define MD_SERVER_SIZE_MEDIUM           1
#define MD_SERVER_SIZE_LARGE            2

//
// Valid values for MD_SERVER_CONFIG_INFO
//

#define MD_SERVER_CONFIG_SSL_40         0x00000001
#define MD_SERVER_CONFIG_SSL_128        0x00000002
#define MD_SERVER_CONFIG_ALLOW_ENCRYPT  0x00000004
#define MD_SERVER_CONFIG_AUTO_PW_SYNC   0x00000008

#define MD_SERVER_CONFIGURATION_MASK   (MD_SERVER_CONFIG_SSL_40       | \
                                        MD_SERVER_CONFIG_SSL_128      | \
                                        MD_SERVER_CONFIG_ENCRYPT      | \
                                        MD_SERVER_CONFIG_AUTO_PW_SYNC)

//
// Valid values for MD_SCRIPT_MAPS flag field
//

#define MD_SCRIPTMAPFLAG_SCRIPT                     0x00000001
#define MD_SCRIPTMAPFLAG_CHECK_PATH_INFO            0x00000004

#ifdef REMOVE   // SteveBr
//
//  Bogus value - do not use
//
#define MD_SCRIPTMAPFLAG_ALLOWED_ON_READ_DIR        0x00000001
#endif // REMOVE


//
// Valid values for MD_AUTH_CHANGE_ENABLE
//

#define MD_AUTH_CHANGE_UNSECURE     0x00000001
#define MD_AUTH_CHANGE_DISABLE      0x00000002
#define MD_AUTH_ADVNOTIFY_DISABLE   0x00000004

//
// Valid values for MD_NET_LOGON_WKS
//

#define MD_NETLOGON_WKS_NONE        0
#define MD_NETLOGON_WKS_IP          1
#define MD_NETLOGON_WKS_DNS         2

//
//  Valide substatus errors for MD_CUSTOM_ERROR
//

#define MD_ERROR_SUB401_LOGON                   1
#define MD_ERROR_SUB401_LOGON_CONFIG            2
#define MD_ERROR_SUB401_LOGON_ACL               3
#define MD_ERROR_SUB401_FILTER                  4
#define MD_ERROR_SUB401_APPLICATION             5

#define MD_ERROR_SUB403_EXECUTE_ACCESS_DENIED   1
#define MD_ERROR_SUB403_READ_ACCESS_DENIED      2
#define MD_ERROR_SUB403_WRITE_ACCESS_DENIED     3
#define MD_ERROR_SUB403_SSL_REQUIRED            4
#define MD_ERROR_SUB403_SSL128_REQUIRED         5
#define MD_ERROR_SUB403_ADDR_REJECT             6
#define MD_ERROR_SUB403_CERT_REQUIRED           7
#define MD_ERROR_SUB403_SITE_ACCESS_DENIED      8
#define MD_ERROR_SUB403_TOO_MANY_USERS          9
#define MD_ERROR_SUB403_INVALID_CNFG           10
#define MD_ERROR_SUB403_PWD_CHANGE             11
#define MD_ERROR_SUB403_MAPPER_DENY_ACCESS     12
#define MD_ERROR_SUB403_CERT_REVOKED           13
#define MD_ERROR_SUB403_DIR_LIST_DENIED        14
#define MD_ERROR_SUB403_CAL_EXCEEDED           15
#define MD_ERROR_SUB403_CERT_BAD               16
#define MD_ERROR_SUB403_CERT_TIME_INVALID      17
#define MD_ERROR_SUB403_APPPOOL_DENIED         18
#define MD_ERROR_SUB403_INSUFFICIENT_PRIVILEGE_FOR_CGI  19

#define MD_ERROR_SUB404_SITE_NOT_FOUND          1
#define MD_ERROR_SUB404_DENIED_BY_POLICY        2

#define MD_ERROR_SUB502_TIMEOUT                 1
#define MD_ERROR_SUB502_PREMATURE_EXIT          2

#define MD_ERROR_SUB503_CPU_LIMIT               1

//
// Valid access rights for ACE entries in MD_ADMIN_ACL
//

#define MD_ACR_READ                 0x00000001
#define MD_ACR_WRITE                0x00000002
#define MD_ACR_RESTRICTED_WRITE     0x00000020
#define MD_ACR_UNSECURE_PROPS_READ  0x00000080
#define MD_ACR_ENUM_KEYS            0x00000008
#define MD_ACR_WRITE_DAC            0x00040000

//
// Valid modes for MD_USER_ISOLATION
//

#define MD_USER_ISOLATION_NONE      0
#define MD_USER_ISOLATION_BASIC     1
#define MD_USER_ISOLATION_AD        2
#define MD_USER_ISOLATION_LAST      2

//
// MD_IP_SEC binary format description
//

/*

  This object is composed of 4 lists : 2 lists ( deny & grant ) of network addresses,
  the only allowed family is AF_INET.
  Each of this list is composed of sublists, one for each ( network address family,
  significant subnet mask ) combination. The significant subnet mask is stored as
  ( number of bytes all 1 ( 0xff ), bitmask in last byte ).
  This is followed by 2 lists ( deny & grant ) of DNS names. Each of these lists is
  composed of sublists, based on then number of components in the DNS name
  e.g. "microsoft.com" has 2 components, "www.msft.com" has 3.

Header:
    SELFREFINDEX    iDenyAddr;      // address deny list
                                    // points to ADDRESS_HEADER
    SELFREFINDEX    iGrantAddr;     // address grant list
                                    // points to ADDRESS_HEADER
    SELFREFINDEX    iDenyName;      // DNS name deny list
                                    // points to NAME_HEADER
    SELFREFINDEX    iGrantName;     // DNS name grant list
                                    // points to NAME_HEADER
    DWORD           dwFlags;
    DWORD           cRefSize;       // size of reference area ( in bytes )

ADDRESS_HEADER :
    DWORD               cEntries;   // # of Entries[]
    DWORD               cAddresses; // total # of addresses in all
                                    // ADDRESS_LIST_ENTRY
    ADDRESS_LIST_ENTRY  Entries[];

ADDRESS_LIST_ENTRY :
    DWORD           iFamily;
    DWORD           cAddresses;
    DWORD           cFullBytes;
    DWORD           LastByte;
    SELFREFINDEX    iFirstAddress;  // points to array of addresses

NAME_HEADER :
    DWORD           cEntries;
    DWORD           cNames;         // total # of names for all Entries[]
    NAME_LIST_ENTRY Entries[];

Name list entry :
    DWORD           cComponents;    // # of DNS components
    DWORD           cNames;
    SELFREFINDEX    iName[];        // array of references to DNS names

This is followed by address arrays & names pointed to by iFirstAddress & iName
Names are '\0' delimited

SELFREFINDEX is a DWORD offset from start of structure with high bit set to 1

*/

//
// Macros
//

#define MD_SET_DATA_RECORD(_pMDR, _id, _attr, _utype, _dtype, _dlen, _pData) \
            { \
            (_pMDR)->dwMDIdentifier=(_id);      \
            (_pMDR)->dwMDAttributes=(_attr);    \
            (_pMDR)->dwMDUserType=(_utype);     \
            (_pMDR)->dwMDDataType=(_dtype);     \
            (_pMDR)->dwMDDataLen=(_dlen);       \
            (_pMDR)->pbMDData=(LPBYTE)(_pData); \
            }

//
// IIS ADSI Admin Object class names
//

#define IIS_CLASS_COMPUTER             "IIsComputer"
#define IIS_CLASS_WEB_SERVICE          "IIsWebService"
#define IIS_CLASS_WEB_SERVER           "IIsWebServer"
#define IIS_CLASS_WEB_INFO             "IIsWebInfo"
#define IIS_CLASS_WEB_DIR              "IIsWebDirectory"
#define IIS_CLASS_WEB_VDIR             "IIsWebVirtualDir"
#define IIS_CLASS_WEB_FILE             "IIsWebFile"
#define IIS_CLASS_FTP_SERVICE          "IIsFtpService"
#define IIS_CLASS_FTP_SERVER           "IIsFtpServer"
#define IIS_CLASS_FTP_INFO             "IIsFtpInfo"
#define IIS_CLASS_FTP_VDIR             "IIsFtpVirtualDir"
#define IIS_CLASS_FILTERS              "IIsFilters"
#define IIS_CLASS_FILTER               "IIsFilter"
#define IIS_CLASS_LOG_MODULES          "IIsLogModules"
#define IIS_CLASS_LOG_MODULE           "IIsLogModule"
#define IIS_CLASS_MIMEMAP              "IIsMimeMap"
#define IIS_CLASS_CERTMAPPER           "IIsCertMapper"
#define IIS_CLASS_COMPRESS_SCHEMES     "IIsCompressionSchemes"
#define IIS_CLASS_COMPRESS_SCHEME      "IIsCompressionScheme"

#define IIS_CLASS_COMPUTER_W           L"IIsComputer"
#define IIS_CLASS_WEB_SERVICE_W        L"IIsWebService"
#define IIS_CLASS_WEB_SERVER_W         L"IIsWebServer"
#define IIS_CLASS_WEB_INFO_W           L"IIsWebInfo"
#define IIS_CLASS_WEB_DIR_W            L"IIsWebDirectory"
#define IIS_CLASS_WEB_VDIR_W           L"IIsWebVirtualDir"
#define IIS_CLASS_WEB_FILE_W           L"IIsWebFile"
#define IIS_CLASS_FTP_SERVICE_W        L"IIsFtpService"
#define IIS_CLASS_FTP_SERVER_W         L"IIsFtpServer"
#define IIS_CLASS_FTP_INFO_W           L"IIsFtpInfo"
#define IIS_CLASS_FTP_VDIR_W           L"IIsFtpVirtualDir"
#define IIS_CLASS_FILTERS_W            L"IIsFilters"
#define IIS_CLASS_FILTER_W             L"IIsFilter"
#define IIS_CLASS_LOG_MODULES_W        L"IIsLogModules"
#define IIS_CLASS_LOG_MODULE_W         L"IIsLogModule"
#define IIS_CLASS_MIMEMAP_W            L"IIsMimeMap"
#define IIS_CLASS_CERTMAPPER_W         L"IIsCertMapper"
#define IIS_CLASS_COMPRESS_SCHEMES_W   L"IIsCompressionSchemes"
#define IIS_CLASS_COMPRESS_SCHEME_W    L"IIsCompressionScheme"

#endif // _IISCNFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\npt.h ===
/**
 * npt.h
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

#pragma once

extern CLSID CLSID_PTProtocol;
HRESULT GetPTProtocolClassObject(REFIID, void **);
void    TerminatePTProtocol();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\makefile.inc ===
COUNTERVERDATASRC=$(XSPBASEDIR)\inc\CounterVersion.src

!if $(PASS0)
USER_C_DEFINES="/DFX_VER_INTERNALNAME_STR=precomp" "/DFX_VFT=VFT_UNKNOWN"

$(O)\CounterVer.txt : $(COUNTERVERDATASRC) ..\names.h 
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $(COUNTERVERDATASRC)
<<$(KEEPFILES)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$(COUNTERVERDATASRC) > $@
$(CPPXX: =
)
<<$(KEEPFILES)

$(PERFFILES): ..\CounterData.perf ..\CounterGenerator.bat $(O)\CounterVer.txt
	..\CounterGenerator.bat ..\CounterData.perf $(PERF_H) $(O)\CounterVer.txt $(PERF_INI) $(O)\perfstruct.h $(O)\perfconsts.h $(O)\PerfCounterEnum.cs
        
        
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\mtxpriv.h ===
//------------------------------------------------------------------------------
// <copyright file="mtxpriv.h" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   mtxpriv.h
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Sep 11 16:03:09 1997
 */
/* Compiler settings for mtxpriv.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mtxpriv_h__
#define __mtxpriv_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IContextProperties_FWD_DEFINED__
#define __IContextProperties_FWD_DEFINED__
typedef interface IContextProperties IContextProperties;
#endif 	/* __IContextProperties_FWD_DEFINED__ */


#ifndef __IMTSCall_FWD_DEFINED__
#define __IMTSCall_FWD_DEFINED__
typedef interface IMTSCall IMTSCall;
#endif 	/* __IMTSCall_FWD_DEFINED__ */


#ifndef __IMTSActivity_FWD_DEFINED__
#define __IMTSActivity_FWD_DEFINED__
typedef interface IMTSActivity IMTSActivity;
#endif 	/* __IMTSActivity_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "mtx.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_mtxpriv_0000
 * at Thu Sep 11 16:03:09 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


// -----------------------------------------------------------------------
// mtxpriv.h  -- Microsoft Transaction Server Undisclosed APIs
//
// This file provides the prototypes for those APIs and COM interfaces
// used by Microsoft Transaction Server applications which have NOT been
// disclosed or documented.
//
// Microsoft Transaction Server 2.0
// Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------------
#include <mtx.h>

#define CONTEXT_E_EXCEPTION				0x8004E010
#define CONTEXT_E_QUEUEFULL				0x8004E011


extern RPC_IF_HANDLE __MIDL_itf_mtxpriv_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtxpriv_0000_v0_0_s_ifspec;

#ifndef __IContextProperties_INTERFACE_DEFINED__
#define __IContextProperties_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IContextProperties
 * at Thu Sep 11 16:03:09 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IContextProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372af1-cae7-11cf-be81-00aa00a2fa25")
    IContextProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [retval][out] */ long __RPC_FAR *plCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *pProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumNames( 
            /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT property) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProperty( 
            /* [in] */ BSTR name) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContextProperties __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContextProperties __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContextProperties __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Count )( 
            IContextProperties __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IContextProperties __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *pProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumNames )( 
            IContextProperties __RPC_FAR * This,
            /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProperty )( 
            IContextProperties __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT property);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveProperty )( 
            IContextProperties __RPC_FAR * This,
            /* [in] */ BSTR name);
        
        END_INTERFACE
    } IContextPropertiesVtbl;

    interface IContextProperties
    {
        CONST_VTBL struct IContextPropertiesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextProperties_Count(This,plCount)	\
    (This)->lpVtbl -> Count(This,plCount)

#define IContextProperties_GetProperty(This,name,pProperty)	\
    (This)->lpVtbl -> GetProperty(This,name,pProperty)

#define IContextProperties_EnumNames(This,ppenum)	\
    (This)->lpVtbl -> EnumNames(This,ppenum)

#define IContextProperties_SetProperty(This,name,property)	\
    (This)->lpVtbl -> SetProperty(This,name,property)

#define IContextProperties_RemoveProperty(This,name)	\
    (This)->lpVtbl -> RemoveProperty(This,name)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IContextProperties_Count_Proxy( 
    IContextProperties __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCount);


void __RPC_STUB IContextProperties_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContextProperties_GetProperty_Proxy( 
    IContextProperties __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT __RPC_FAR *pProperty);


void __RPC_STUB IContextProperties_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContextProperties_EnumNames_Proxy( 
    IContextProperties __RPC_FAR * This,
    /* [retval][out] */ IEnumNames __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IContextProperties_EnumNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContextProperties_SetProperty_Proxy( 
    IContextProperties __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [in] */ VARIANT property);


void __RPC_STUB IContextProperties_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContextProperties_RemoveProperty_Proxy( 
    IContextProperties __RPC_FAR * This,
    /* [in] */ BSTR name);


void __RPC_STUB IContextProperties_RemoveProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextProperties_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_mtxpriv_0104
 * at Thu Sep 11 16:03:09 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


#ifdef __cplusplus
extern "C"
#endif __cplusplus
EXTERN_C HRESULT __stdcall MTSCreateActivity ( REFIID riid, void** ppobj );
EXTERN_C HRESULT __stdcall CreateActivityInMTA ( REFIID riid, void** ppobj );


extern RPC_IF_HANDLE __MIDL_itf_mtxpriv_0104_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtxpriv_0104_v0_0_s_ifspec;

#ifndef __IMTSCall_INTERFACE_DEFINED__
#define __IMTSCall_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMTSCall
 * at Thu Sep 11 16:03:09 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IMTSCall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372AEF-CAE7-11CF-BE81-00AA00A2FA25")
    IMTSCall : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCall( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMTSCallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMTSCall __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMTSCall __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMTSCall __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnCall )( 
            IMTSCall __RPC_FAR * This);
        
        END_INTERFACE
    } IMTSCallVtbl;

    interface IMTSCall
    {
        CONST_VTBL struct IMTSCallVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMTSCall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMTSCall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMTSCall_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMTSCall_OnCall(This)	\
    (This)->lpVtbl -> OnCall(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMTSCall_OnCall_Proxy( 
    IMTSCall __RPC_FAR * This);


void __RPC_STUB IMTSCall_OnCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMTSCall_INTERFACE_DEFINED__ */


#ifndef __IMTSActivity_INTERFACE_DEFINED__
#define __IMTSActivity_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMTSActivity
 * at Thu Sep 11 16:03:09 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][unique][uuid][local] */ 



EXTERN_C const IID IID_IMTSActivity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51372AF0-CAE7-11CF-BE81-00AA00A2FA25")
    IMTSActivity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SynchronousCall( 
            /* [in] */ IMTSCall __RPC_FAR *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AsyncCall( 
            /* [in] */ IMTSCall __RPC_FAR *pCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AsyncCallWithAdvice( 
            /* [in] */ IMTSCall __RPC_FAR *pCall,
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual void STDMETHODCALLTYPE BindToCurrentThread( void) = 0;
        
        virtual void STDMETHODCALLTYPE UnbindFromThread( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMTSActivityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMTSActivity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMTSActivity __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMTSActivity __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SynchronousCall )( 
            IMTSActivity __RPC_FAR * This,
            /* [in] */ IMTSCall __RPC_FAR *pCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AsyncCall )( 
            IMTSActivity __RPC_FAR * This,
            /* [in] */ IMTSCall __RPC_FAR *pCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AsyncCallWithAdvice )( 
            IMTSActivity __RPC_FAR * This,
            /* [in] */ IMTSCall __RPC_FAR *pCall,
            /* [in] */ REFCLSID rclsid);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *BindToCurrentThread )( 
            IMTSActivity __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *UnbindFromThread )( 
            IMTSActivity __RPC_FAR * This);
        
        END_INTERFACE
    } IMTSActivityVtbl;

    interface IMTSActivity
    {
        CONST_VTBL struct IMTSActivityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMTSActivity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMTSActivity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMTSActivity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMTSActivity_SynchronousCall(This,pCall)	\
    (This)->lpVtbl -> SynchronousCall(This,pCall)

#define IMTSActivity_AsyncCall(This,pCall)	\
    (This)->lpVtbl -> AsyncCall(This,pCall)

#define IMTSActivity_AsyncCallWithAdvice(This,pCall,rclsid)	\
    (This)->lpVtbl -> AsyncCallWithAdvice(This,pCall,rclsid)

#define IMTSActivity_BindToCurrentThread(This)	\
    (This)->lpVtbl -> BindToCurrentThread(This)

#define IMTSActivity_UnbindFromThread(This)	\
    (This)->lpVtbl -> UnbindFromThread(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMTSActivity_SynchronousCall_Proxy( 
    IMTSActivity __RPC_FAR * This,
    /* [in] */ IMTSCall __RPC_FAR *pCall);


void __RPC_STUB IMTSActivity_SynchronousCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMTSActivity_AsyncCall_Proxy( 
    IMTSActivity __RPC_FAR * This,
    /* [in] */ IMTSCall __RPC_FAR *pCall);


void __RPC_STUB IMTSActivity_AsyncCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMTSActivity_AsyncCallWithAdvice_Proxy( 
    IMTSActivity __RPC_FAR * This,
    /* [in] */ IMTSCall __RPC_FAR *pCall,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB IMTSActivity_AsyncCallWithAdvice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IMTSActivity_BindToCurrentThread_Proxy( 
    IMTSActivity __RPC_FAR * This);


void __RPC_STUB IMTSActivity_BindToCurrentThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IMTSActivity_UnbindFromThread_Proxy( 
    IMTSActivity __RPC_FAR * This);


void __RPC_STUB IMTSActivity_UnbindFromThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMTSActivity_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\perfcounters.h ===
/**
 * PerfCounters.h
 *
 * The minimum necessary header to instrument code with perf counters in ASP.NET
 *
 * Copyright (c) 1998-2002 Microsoft Corporation
 */

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _PerfCounter_H
#define _PerfCounter_H

#include "perfconsts.h"  // This is the build-generated perf constants file

#define PERF_PIPE_NAME_MAX_BUFFER 128      // Max buffer size for pipe name comes

class CPerfDataHeader
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    const static int MaxTransmitSize = 32768;

    int transmitDataSize;
};

class CPerfData
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    const static int MaxNameLength = 256;

    int nameLength;               // This is the length of field "name" in units of WCHAR, not including the NULL termination
    int data[PERF_NUM_DWORDS];
    WCHAR name[1];
};

class CPerfVersion
{
public:
    LONG majorVersion;
    LONG minorVersion;
    LONG buildVersion;

    static CPerfVersion * GetCurrentVersion();
};

// Methods to initialize and to set counter values.
// These same methods are also entry points from managed code.

HRESULT __stdcall PerfCounterInitialize();

CPerfData * __stdcall PerfOpenGlobalCounters();
CPerfData * __stdcall PerfOpenAppCounters(WCHAR * szAppName);
void __stdcall PerfCloseAppCounters(CPerfData * perfData);

void __stdcall PerfIncrementCounter(CPerfData *base, DWORD number);
void __stdcall PerfDecrementCounter(CPerfData *base, DWORD number);
void __stdcall PerfIncrementCounterEx(CPerfData *base, DWORD number, int dwDelta);
void __stdcall PerfSetCounter(CPerfData *base, DWORD number, DWORD dwValue);

void __stdcall PerfIncrementGlobalCounter(DWORD number);
void __stdcall PerfDecrementGlobalCounter(DWORD number);
void __stdcall PerfIncrementGlobalCounterEx(DWORD number, int dwDelta);
void __stdcall PerfSetGlobalCounter(DWORD number, DWORD dwValue);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\names.h ===
/**
 * names.h
 * 
 * Names of files, registry keys, etc.
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

#ifdef __cplusplus
#pragma once
#endif

#include "fxver.h"

#define PRODUCT_TOKEN_3(x, y)         x ## y
#define PRODUCT_TOKEN_2(x, y)         PRODUCT_TOKEN_3(x, y)
#define PRODUCT_TOKEN(y)              PRODUCT_TOKEN_2(ASPNET_NAME_PREFIX, y)
#define PRODUCT_TOKEN_NO_SUFFIX(y)    PRODUCT_TOKEN_2(ASPNET_NAME_PREFIX_NO_SUFFIX, y)

#define PRODUCT_STRING(z)             QUOTE_MACRO(PRODUCT_TOKEN(z))
#define PRODUCT_STRING_L(z)           QUOTE_MACRO_L(PRODUCT_TOKEN(z))

#define PRODUCT_STRING_NO_SUFFIX(z)   QUOTE_MACRO(PRODUCT_TOKEN_NO_SUFFIX(z))
#define PRODUCT_STRING_NO_SUFFIX_L(z) QUOTE_MACRO_L(PRODUCT_TOKEN_NO_SUFFIX(z))

/*
 * Product name
 */

#define PRODUCT_NAME                "ASP.NET"
#define PRODUCT_NAME_L              L"ASP.NET"

#if ASPNET_PRODUCT_IS_REDIST == 1
#define ASPNET_FLAVOR_STRING          ""
#define ASPNET_FLAVOR_STRING_L        L""
#else
#define ASPNET_FLAVOR_STRING          QUOTE_MACRO(ASPNET_FLAVOR)
#define ASPNET_FLAVOR_STRING_L        QUOTE_MACRO_L(ASPNET_FLAVOR)
#endif

/*
 * Module names.
 */

#define ISAPI_MODULE_LIBRARY_NAME       PRODUCT_TOKEN(isapi)

#define ISAPI_MODULE_FULL_NAME          PRODUCT_STRING(isapi.dll)
#define ISAPI_MODULE_FULL_NAME_L        PRODUCT_STRING_L(isapi.dll)
#define ISAPI_MODULE_FULL_NAME_TOKEN    PRODUCT_TOKEN(isapi.dll)

#define ISAPI_MODULE_BASE_NAME          PRODUCT_STRING(isapi)      
#define ISAPI_MODULE_BASE_NAME_L        PRODUCT_STRING_L(isapi)    
                                                                   
#define PERF_MODULE_FULL_NAME           PRODUCT_STRING(perf.dll)   
#define PERF_MODULE_FULL_NAME_L         PRODUCT_STRING_L(perf.dll) 
#define PERF_MODULE_FULL_NAME_TOKEN     PRODUCT_TOKEN(perf.dll)    
                                                                   
#define PERF_MODULE_BASE_NAME           PRODUCT_STRING(perf)       
#define PERF_MODULE_BASE_NAME_L         PRODUCT_STRING_L(perf)     
                                                                   
#define PERF_INI_FULL_NAME              PRODUCT_STRING(perf.ini)   
#define PERF_INI_FULL_NAME_L            PRODUCT_STRING_L(perf.ini) 

#define PERF_INI_COMMON_FULL_NAME       PRODUCT_STRING(perf2.ini)   
#define PERF_INI_COMMON_FULL_NAME_L     PRODUCT_STRING_L(perf2.ini) 

#define RC_MODULE_FULL_NAME             PRODUCT_STRING(rc.dll)     
#define RC_MODULE_FULL_NAME_L           PRODUCT_STRING_L(rc.dll)   
                                                                   
#define RC_MODULE_BASE_NAME             PRODUCT_STRING(rc)         
#define RC_MODULE_BASE_NAME_L           PRODUCT_STRING_L(rc)       

#define STATE_MODULE_FULL_NAME          PRODUCT_STRING(state.exe)
#define STATE_MODULE_FULL_NAME_L        PRODUCT_STRING_L(state.exe)
#define STATE_MODULE_FULL_NAME_TOKEN    PRODUCT_TOKEN(state.exe)

#define STATE_MODULE_BASE_NAME          PRODUCT_STRING(state)
#define STATE_MODULE_BASE_NAME_L        PRODUCT_STRING_L(state)

#define WEB_MODULE_FULL_NAME            "System.Web.dll"         
#define WEB_MODULE_FULL_NAME_L          L"System.Web.dll"        
                                                                 
#define WEB_MODULE_BASE_NAME            "System.Web"             
#define WEB_MODULE_BASE_NAME_L          L"System.Web"            
                                                                 
#define WP_MODULE_FULL_NAME             PRODUCT_STRING(wp.exe)   
#define WP_MODULE_FULL_NAME_L           PRODUCT_STRING_L(wp.exe) 
                                                                 
#define WP_MODULE_BASE_NAME             PRODUCT_STRING(wp)       
#define WP_MODULE_BASE_NAME_L           PRODUCT_STRING_L(wp)     
                                                                 
#define WININET_MODULE_FULL_NAME        "wininet.dll"            
#define WININET_MODULE_FULL_NAME_L      L"wininet.dll"           

#define PERF_H_FULL_NAME                < PRODUCT_TOKEN(perf.h) >

#define ASPNET_CONFIG_FILE              PRODUCT_STRING_NO_SUFFIX(.config)
#define ASPNET_CONFIG_FILE_L            PRODUCT_STRING_NO_SUFFIX_L(.config)

#define FILTER_NAME                     QUOTE_MACRO(CONCAT_MACRO(ASP.NET_, VER_DOTPRODUCTVERSION))
#define FILTER_NAME_L                   QUOTE_MACRO_L(CONCAT_MACRO(ASP.NET_, VER_DOTPRODUCTVERSION))

#define FILTER_MODULE_LIBRARY_NAME      PRODUCT_TOKEN(filter)

#define FILTER_MODULE_FULL_NAME         PRODUCT_STRING(filter.dll)
#define FILTER_MODULE_FULL_NAME_L       PRODUCT_STRING_L(filter.dll)
#define FILTER_MODULE_FULL_NAME_TOKEN   PRODUCT_TOKEN(filter.dll)

#define FILTER_MODULE_BASE_NAME         PRODUCT_STRING(filter)      
#define FILTER_MODULE_BASE_NAME_L       PRODUCT_STRING_L(filter)    

#define PRODUCT_DESCRIPTION             QUOTE_MACRO(CONCAT_MACRO(ASP.NET_, VER_DOTPRODUCTVERSION))
#define PRODUCT_DESCRIPTION_L           QUOTE_MACRO_L(CONCAT_MACRO(ASP.NET_, VER_DOTPRODUCTVERSION))

#define IIS_GROUP_ID_L                  QUOTE_MACRO_L(CONCAT_MACRO(ASP.NET v, VER_DOTPRODUCTVERSIONNOQFE))

#define IIS_APP_NAME_L                  IIS_GROUP_ID_L

#define IIS_APP_DESCRIPTION_L           IIS_GROUP_ID_L

#define IIS_GROUP_ID_PREFIX_L           L"ASP.NET v"
                                                                   

/*
 * Service names.
 */

#define STATE_SERVICE_NAME              "aspnet_state"
#define STATE_SERVICE_NAME_L            L"aspnet_state"

#define W3SVC_SERVICE_NAME              "w3svc"
#define W3SVC_SERVICE_NAME_L            L"w3svc"

#define IISADMIN_SERVICE_NAME           "iisadmin"
#define IISADMIN_SERVICE_NAME_L         L"iisadmin"

#define PERF_SERVICE_PREFIX_L           L"ASP.NET"
#define PERF_SERVICE_PREFIX_LENGTH      7
#define PERF_SERVICE_VERSION_NAME       QUOTE_MACRO(CONCAT_MACRO(ASP.NET_, VER_DOTPRODUCTVERSIONNOQFE))
#define PERF_SERVICE_VERSION_NAME_L     QUOTE_MACRO_L(CONCAT_MACRO(ASP.NET_, VER_DOTPRODUCTVERSIONNOQFE))

/*
 * Registry keys
 */

#define REGPATH_MACHINE_APP             "Software\\Microsoft\\ASP.NET"
#define REGPATH_MACHINE_APP_L           L"Software\\Microsoft\\ASP.NET"

#define REGPATH_SERVICES_KEY_L          L"SYSTEM\\CurrentControlSet\\Services\\"

#define REGPATH_PERF_VERSIONED_ROOT_KEY   "SYSTEM\\CurrentControlSet\\Services\\" PERF_SERVICE_VERSION_NAME 
#define REGPATH_PERF_VERSIONED_ROOT_KEY_L L"SYSTEM\\CurrentControlSet\\Services\\" PERF_SERVICE_VERSION_NAME_L 

#define REGPATH_PERF_VERSIONED_PERFORMANCE_KEY   "SYSTEM\\CurrentControlSet\\Services\\" PERF_SERVICE_VERSION_NAME "\\Performance"
#define REGPATH_PERF_VERSIONED_PERFORMANCE_KEY_L L"SYSTEM\\CurrentControlSet\\Services\\" PERF_SERVICE_VERSION_NAME_L L"\\Performance"

#define REGPATH_PERF_VERSIONED_NAMES_KEY   "SYSTEM\\CurrentControlSet\\Services\\" PERF_SERVICE_VERSION_NAME "\\Names"
#define REGPATH_PERF_VERSIONED_NAMES_KEY_L L"SYSTEM\\CurrentControlSet\\Services\\" PERF_SERVICE_VERSION_NAME_L L"\\Names"

#define REGPATH_PERF_GENERIC_PERFORMANCE_KEY   "SYSTEM\\CurrentControlSet\\Services\\" PRODUCT_NAME "\\Performance"
#define REGPATH_PERF_GENERIC_PERFORMANCE_KEY_L L"SYSTEM\\CurrentControlSet\\Services\\" PRODUCT_NAME_L L"\\Performance"

#define REGPATH_PERF_GENERIC_ROOT_KEY_L  L"SYSTEM\\CurrentControlSet\\Services\\" PRODUCT_NAME_L

#define REGPATH_EVENTLOG_APP_L          L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\"

#define IIS_KEY_L                       L"Software\\Microsoft\\InetStp\\"

#define REGPATH_STATE_SERVER_PARAMETERS_KEY_L L"SYSTEM\\CurrentControlSet\\Services\\"  STATE_SERVICE_NAME_L  L"\\Parameters"

#if ASPNET_PRODUCT_IS_REDIST
#define EVENTLOG_PRODUCT                ASP.NET
#elif ASPNET_PRODUCT_IS_EXPRESS
#define EVENTLOG_PRODUCT                ASP.NET Express
#elif ASPNET_PRODUCT_IS_STANDARD
#define EVENTLOG_PRODUCT                ASP.NET Standard
#elif ASPNET_PRODUCT_IS_ENTERPRISE
#define EVENTLOG_PRODUCT                ASP.NET Enterprise
#endif

#define EVENTLOG_KEY_INF                CONCAT_MACRO(System\CurrentControlSet\Services\EventLog\Application\, EVENTLOG_PRODUCT)
#define EVENTLOG_NAME_L                 QUOTE_MACRO_L(EVENTLOG_PRODUCT VER_DOTPRODUCTVERSIONZEROQFE)

/*
 * Registry values
 */
 
#define REGVAL_DEFDOC               L"DefaultDoc"
#define REGVAL_MIMEMAP              L"Mimemap"
#define REGVAL_PATH                 L"Path"
#define REGVAL_DLLFULLPATH          L"DllFullPath"
#define REGVAL_ROOTVER              L"RootVer"
#define REGVAL_STATESOCKETTIMEOUT   L"SocketTimeout"
#define REGVAL_STATEALLOWREMOTE     L"AllowRemoteConnection"
#define REGVAL_STATEPORT            L"Port"
#define REGVAL_IIS_MAJORVER         L"MajorVersion"
#define REGVAL_IIS_MINORVER         L"Minorversion"
#define REGVAL_SUPPORTED_EXTS       L"SupportedExts"
#define REGVAL_STOP_BIN_FILTER      L"StopBinFiltering"

/*
 * Directory names
 */

#define ASPNET_CLIENT_SCRIPT_SRC_DIR    "asp.netclientfiles"
#define ASPNET_CLIENT_SCRIPT_SRC_DIR_L  L"asp.netclientfiles"

#define ASPNET_CLIENT_DIR               "aspnet_client" 
#define ASPNET_CLIENT_DIR_L             L"aspnet_client" 

#define ASPNET_CLIENT_SYS_WEB_DIR       "system_web"
#define ASPNET_CLIENT_SYS_WEB_DIR_L     L"system_web"

#define ASPNET_TEMP_DIR_L               L"Temporary ASP.NET Files"

#define ASPNET_CUSTOM_HEADER_L          L"X-Powered-By: ASP.NET"

/*
 * Metabase values
 */

//
// !!! Important note:
// New versions of DFEAULT_DOC and MIMEMAP must be backward compatible, i.e. a new version
// must include all the content from an older version.
//

// DEFAULT_DOC is comma delimited.
#define DEFAULT_DOC         L"Default.aspx"
                                                        
#define MIMEMAP             L".wsdl,text/xml,"  \
                            L".disco,text/xml," \
                            L".xsd,text/xml,"   \
                            L".wbmp,image/vnd.wap.wbmp," \
                            L".png,image/png," \
                            L".pnz,image/png," \
                            L".smd,audio/x-smd," \
                            L".smz,audio/x-smd," \
                            L".smx,audio/x-smd," \
                            L".mmf,application/x-smaf"
                            

// All the extensions supported by this version
// After each extension, 1 = mapped to forbidden handler; 0 = not
// The comma at the end of the last extension is required
#define SUPPORTED_EXTS          L".asax,1," \
                                L".ascx,1," \
                                L".ashx,0," \
                                L".asmx,0," \
                                L".aspx,0," \
                                L".axd,0," \
                                L".vsdisco,0," \
                                L".rem,0," \
                                L".soap,0," \
                                L".config,1," \
                                L".cs,1," \
                                L".csproj,1," \
                                L".vb,1," \
                                L".vbproj,1," \
                                L".webinfo,1," \
                                L".licx,1," \
                                L".resx,1," \
                                L".resources,1,"
 
// All the extensions supported by version 1.0 and its SP1
#define SUPPORTED_EXTS_v1       L".asax,1," \
                                L".ascx,1," \
                                L".ashx,0," \
                                L".asmx,0," \
                                L".aspx,0," \
                                L".axd,0," \
                                L".vsdisco,0," \
                                L".rem,0," \
                                L".soap,0," \
                                L".config,1," \
                                L".cs,1," \
                                L".csproj,1," \
                                L".vb,1," \
                                L".vbproj,1," \
                                L".webinfo,1," \
                                L".licx,1," \
                                L".resx,1," \
                                L".resources,1,"
 

//
//  Config file name
//

// the filename at the machine level
#define SZ_WEB_CONFIG_FILE       "machine.config"
#define WSZ_WEB_CONFIG_FILE     L"machine.config"

// the filename at the machine level
#define SZ_WEB_CONFIG_SUBDIR   "Config"
#define WSZ_WEB_CONFIG_SUBDIR L"Config"

// the filename at the machine level
#define SZ_WEB_CONFIG_FILE_AND_SUBDIR   "Config\\machine.config"
#define WSZ_WEB_CONFIG_FILE_AND_SUBDIR  L"Config\\machine.config"

// the filename for asp.net below the machine level
#define SZ_WEB_CONFIG_FILE2       "web.config"
#define WSZ_WEB_CONFIG_FILE2     L"web.config"

#define SHORT_FILENAME_SIZE 14  // matches WIN32_FIND_DATA.cAltFileName

#define PATH_SEPARATOR_CHAR    '\\'
#define PATH_SEPARATOR_CHAR_L L'\\'

#define PATH_SEPARATOR_STR     "\\"
#define PATH_SEPARATOR_STR_L  L"\\"

#ifdef __cplusplus

class Names {
public:
    static HRESULT  GetInterestingFileNames();

    static LPCWSTR  InstallDirectory()              {return s_wszInstallDirectory;}
    static LPCWSTR  ClrInstallDirectory()           {return s_wszClrInstallDirectory;}
    static LPCWSTR  GlobalConfigDirectory()         {return s_wszGlobalConfigDirectory;}
    static LPCSTR   GlobalConfigFullPath()          {return s_szGlobalConfigFullPath;}
    static LPCWSTR  GlobalConfigFullPathW()         {return s_wszGlobalConfigFullPath;}
    static LPCWSTR  GlobalConfigShortFileName()     {return s_wszGlobalConfigShortFileName;}
    static LPCWSTR  ExeFullPath()                   {return s_wszExeFullPath;}
    static LPCWSTR  ExeFileName()                   {return s_wszExeFileName;}
    static LPCWSTR  IsapiFullPath()                 {return s_wszIsapiFullPath;}
    static LPCWSTR  FilterFullPath()                {return s_wszFilterFullPath;}
    static LPCWSTR  RcFullPath()                    {return s_wszRcFullPath;}
    static LPCWSTR  WebFullPath()                   {return s_wszWebFullPath;}
    static LPCWSTR  ClientScriptSrcDir()            {return s_wszClientScriptSrcDir;}
    static LANGID   SysLangId()                     {return s_langid;}

private:
    static HRESULT ConvertLangIdToLanguageName(LANGID id, WCHAR** wcsCultureName, WCHAR** wcsCultureNeutralName);

    static WCHAR s_wszInstallDirectory[MAX_PATH];
    static WCHAR s_wszClrInstallDirectory[MAX_PATH];
    static WCHAR s_wszGlobalConfigDirectory[MAX_PATH];
    static char  s_szGlobalConfigFullPath[MAX_PATH];
    static WCHAR s_wszGlobalConfigFullPath[MAX_PATH];
    static WCHAR s_wszGlobalConfigShortFileName[SHORT_FILENAME_SIZE];
    static WCHAR s_wszExeFileName[MAX_PATH];
    static WCHAR s_wszExeFullPath[MAX_PATH];
    static WCHAR s_wszIsapiFullPath[MAX_PATH];
    static WCHAR s_wszFilterFullPath[MAX_PATH];
    static WCHAR s_wszRcFullPath[MAX_PATH];
    static WCHAR s_wszWebFullPath[MAX_PATH];
    static WCHAR s_wszClientScriptSrcDir[MAX_PATH];

    static LANGID s_langid;
};

#endif //  __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\ndll.h ===
/**
 * ndll.h
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

#ifndef _NDLL_H_
#define _NDLL_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define ASPNET_VERSION_STATUS_ROOT      0x00000001
#define ASPNET_VERSION_STATUS_VALID     0x00000002
#define ASPNET_VERSION_STATUS_INVALID   0x00000004

// Flags passed to RegisterISAPIEx
#define ASPNET_REG_NO_VER_COMPARISON        0x00000001
#define ASPNET_REG_RECURSIVE                0x00000002
#define ASPNET_REG_RESTART_W3SVC            0x00000004
#define ASPNET_REG_SKIP_SCRIPTMAP           0x00000008
#define ASPNET_REG_SCRIPTMAP_ONLY           0x00000010
#define ASPNET_REG_ENABLE                   0x00000020


typedef enum {
    SUPPORT_SECURITY_LOCKDOWN,
} IIS_SUPPORT_FEATURE;

struct ASPNET_VERSION_INFO {
    WCHAR   Version[MAX_PATH+1];
    WCHAR   Path[MAX_PATH+1];
    WCHAR   InstallPath[MAX_PATH+1];
    DWORD   Status;
};
    
struct ASPNET_IIS_KEY_INFO {
    WCHAR   KeyPath[MAX_PATH+1];
    WCHAR   Version[MAX_PATH+1];
};

STDAPI RegisterISAPI();
    
STDAPI RegisterISAPIEx(WCHAR *pchBase, DWORD dwFlags);

STDAPI UnregisterISAPI(BOOL fAll, BOOL fRestartIIS);

STDAPI RemoveAspnetFromIISKey(WCHAR *pchBase, BOOL fRecursive);

STDAPI ValidateIISPath(WCHAR *pchPath, BOOL *pfValid);

STDAPI ListAspnetInstalledVersions(ASPNET_VERSION_INFO **ppVerInfo, DWORD *pCount);

STDAPI ListAspnetInstalledIISKeys(ASPNET_IIS_KEY_INFO **ppKeyInfo, DWORD *pCount);

STDAPI CopyClientScriptFiles();

STDAPI RemoveClientScriptFiles(BOOL fAllVersion);

STDAPI InstallInfSections(HMODULE hmod, bool installServices, const WCHAR * action);

void   GetExistingVersion(CHAR *pchVersion, DWORD dwCount);

ULONG IncrementDllObjectCount();

ULONG DecrementDllObjectCount();

STDAPI GetProcessMemoryInformation(ULONG pid, DWORD * pPrivatePageCount, DWORD * pPeakPagefileUsage, BOOL fNonBlocking);

STDAPI CheckIISFeature(IIS_SUPPORT_FEATURE support, BOOL *pbResult);

#ifdef __cplusplus
}
#endif

#endif  // _NDLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\messagedefs.h ===
/**
 * Message Definitions header file
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 */

////////////////////////////////////////////////////////////////////////////
// This file defines the structs sent on the named pipes. 
////////////////////////////////////////////////////////////////////////////

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _MessageDefs_H
#define _MessageDefs_H

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Messages on the async pipe

/////////////////////////////////////////////////////////////////////////////
// Types of async messages
enum EAsyncMessageType
{
    EMessageType_Unknown,
    EMessageType_Request,
    EMessageType_Response,
    EMessageType_Response_And_DoneWithRequest,
    EMessageType_Shutdown,
    EMessageType_ShutdownImmediate,
    EMessageType_GetDataFromIIS,
    EMessageType_Response_ManagedCodeFailure,
    EMessageType_CloseConnection,
    EMessageType_Debug,
    EMessageType_Response_Empty
};

/////////////////////////////////////////////////////////////////////////////
// Header sent with each async message
struct CAsyncMessageHeader
{
    EAsyncMessageType   eType;       // Type of message
    LONG                lRequestID;  // Request ID
    LONG                lDataLength; // Length of data in pData
};

/////////////////////////////////////////////////////////////////////////////
// Async message: NOTE: Actual async message can be smaller/larger that this.
//                      Depends on oHeader.lDataLength
struct CAsyncMessage
{
    CAsyncMessageHeader  oHeader;
    BYTE                 pData[4]; // Dummy variable: This is actually BYTE pData[oHeader.lDataLength]    
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Messages on the sync pipe

/////////////////////////////////////////////////////////////////////////////
// Sync message Types 
enum ESyncMessageType
{
    ESyncMessageType_Unknown,
    ESyncMessageType_Ack,
    ESyncMessageType_GetServerVariable,
    //    ESyncMessageType_GetQueryString,
    ESyncMessageType_GetAdditionalPostedContent,
    ESyncMessageType_IsClientConnected,
    ESyncMessageType_CloseConnection,
    ESyncMessageType_MapUrlToPath,
    ESyncMessageType_GetImpersonationToken,
    ESyncMessageType_GetAllServerVariables,
    ESyncMessageType_GetHistory,
    ESyncMessageType_GetClientCert,
    ESyncMessageType_CallISAPI,
    ESyncMessageType_ChangeDebugStatus,
    ESyncMessageType_GetMemoryLimit
};

/////////////////////////////////////////////////////////////////////////////
// Message on the sync pipe
struct CSyncMessage
{
    ESyncMessageType    eType;
    LONG                lRequestID;// Req ID of the message being acked
    INT_PTR             iMiscInfo;
    int                 iOutputSize;
    int                 iSize;
    BYTE                buf[4];
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Structs used to package a request

/////////////////////////////////////////////////////////////////////////////
// Request struct
struct CRequestStruct
{
    __int64     qwRequestStartTime; 
    HANDLE      iUserToken;
    HANDLE      iUNCToken;
    DWORD       dwWPPid;
    int         iContentInfo [4]; // Content info generated by EcbGetBasics
    int         iQueryStringOffset; // Start point of query str in bufStrings
    int         iPostedDataOffset; // Start point of posted data
    int         iPostedDataLen;    // Length of posted data
    int         iServerVariablesOffset; // Start point of ServerVariables
    BYTE        bufStrings   [4]; // Variable length Buffer
};

#define NUM_SERVER_VARS                       32
#define DEFINE_SERVER_VARIABLES_ORDER          \
   LPCSTR g_szServerVars[NUM_SERVER_VARS] = {  \
             "APPL_MD_PATH", /*always first*/ \
             "ALL_RAW",\
             "AUTH_PASSWORD",\
             "AUTH_TYPE",\
             "CERT_COOKIE",\
             "CERT_FLAGS",\
             "CERT_ISSUER",\
             "CERT_KEYSIZE",\
             "CERT_SECRETKEYSIZE",\
             "CERT_SERIALNUMBER",\
             "CERT_SERVER_ISSUER",\
             "CERT_SERVER_SUBJECT",\
             "CERT_SUBJECT",\
             "GATEWAY_INTERFACE",\
             "HTTP_COOKIE",\
             "HTTP_USER_AGENT",\
             "HTTPS",\
             "HTTPS_KEYSIZE",\
             "HTTPS_SECRETKEYSIZE",\
             "HTTPS_SERVER_ISSUER",\
             "HTTPS_SERVER_SUBJECT",\
             "INSTANCE_ID",\
             "INSTANCE_META_PATH",\
             "LOCAL_ADDR",\
             "LOGON_USER",\
             "REMOTE_ADDR",\
             "REMOTE_HOST",\
             "SERVER_NAME",\
             "SERVER_PORT",\
             "SERVER_PROTOCOL",\
             "SERVER_SOFTWARE",\
             "REMOTE_PORT"};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Response Structs

/////////////////////////////////////////////////////////////////////////////
// Type of Write: Calls EcbWriteXXX function
enum EWriteType
{
    EWriteType_Unknown,
    EWriteType_None,
    EWriteType_WriteHeaders,
    EWriteType_WriteBytes,
    EWriteType_AppendToLog,
    EWriteType_FlushCore
};

/////////////////////////////////////////////////////////////////////////////
// Response struct
struct CResponseStruct
{
    EWriteType  eWriteType;
    int         iMiscInfo; // iKeepConnected for EWriteType_WriteHeaders, Buf size for EWriteType_WriteBytes
    BYTE        bufStrings   [4];
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// History table entry structs

/////////////////////////////////////////////////////////////////////////////
// Enum describing the reason of death
enum EReasonForDeath
{
    EReasonForDeath_Active                      = 0x0000,
    EReasonForDeath_ShuttingDown                = 0x0001,
    EReasonForDeath_ShutDown                    = 0x0002,
    EReasonForDeath_Terminated                  = 0x0004,
    EReasonForDeath_RemovedFromList             = 0x0008,
    EReasonForDeath_ProcessCrash                = 0x0010,
    EReasonForDeath_TimeoutExpired              = 0x0020,
    EReasonForDeath_IdleTimeoutExpired          = 0x0040,
    EReasonForDeath_MaxRequestsServedExceeded   = 0x0080,
    EReasonForDeath_MaxRequestQLengthExceeded   = 0x0100,
    EReasonForDeath_MemoryLimitExeceeded        = 0x0200,
    EReasonForDeath_PingFailed                  = 0x0400,
    EReasonForDeath_DeadlockSuspected           = 0x0800
};

/////////////////////////////////////////////////////////////////////////////
// CHistoryEntry: History info for each process
//   NOTE: All fields must be of size sizeof(DWORD)
struct CHistoryEntry
{
    // Process identity
    DWORD            dwPID;
    DWORD            dwInternalProcessNumber;

    // Requests stats
    DWORD            dwRequestsExecuted;
    DWORD            dwRequestsPending;
    DWORD            dwRequestsExecuting;

    DWORD            dwPeakMemoryUsed;

    // Times
    __int64          tmCreateTime;
    __int64          tmDeathTime;
    
    // Reason for death
    EReasonForDeath  eReason;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\nisapi.h ===
/**
 * nisapi.h
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

#pragma once

#include "httpext6.h"
#include "httpfilt6.h"
#include "util.h"
#include "dirmoncompletion.h"

extern HRESULT  g_InitHR;
extern char *   g_pInitErrorMessage;
extern BOOL     g_fUseXSPProcessModel;

typedef NTSTATUS (NTAPI *PFN_NtQuerySystemInformation) (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

typedef NTSTATUS (NTAPI *PFN_NtQueryInformationThread) (
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

typedef NTSTATUS (WINAPI * PFN_NtQueryInformationProcess) (
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

extern PFN_NtQuerySystemInformation g_pfnNtQuerySystemInformation;
extern PFN_NtQueryInformationThread g_pfnNtQueryInformationThread;
extern PFN_NtQueryInformationProcess g_pfnNtQueryInformationProcess;

/**                                                     
 * Thread pool APIs					
 *                                                      
 */                                                     
                                                        
#define RECOMMENDED_DRAIN_THREAD_POOL_TIMEOUT 2000

HRESULT
InitThreadPool();

extern "C"
{
HRESULT  __stdcall
DrainThreadPool(                                        
    int timeout                                         
    );                                                  
                                                        
HRESULT   __stdcall
AttachHandleToThreadPool(                               
    HANDLE handle                                       
    );                                                  
                                                        
HRESULT   __stdcall
PostThreadPoolCompletion(                               
    ICompletion *pCompletion                            
    );

DWORD GetClrThreadPoolLimit();

HRESULT   __stdcall
SetClrThreadPoolLimits(
    DWORD maxWorkerThreads,
    DWORD maxIoThreads,
    BOOL  setNowAndDontAdjustForCpuCount
    );

}
                                                        

/**
 * ECB wrapper implementing ICompletion.
 */
class HttpCompletion : public Completion
{
public:

    DECLARE_MEMALLOC_NEW_DELETE()

    inline HttpCompletion(EXTENSION_CONTROL_BLOCK *pEcb)
    {
        _pEcb = pEcb;
    }

    static HRESULT InitManagedCode();
    static HRESULT UninitManagedCode();
    static HRESULT DisposeAppDomains();

    // ICompletion interface

    STDMETHOD(ProcessCompletion)(HRESULT, int, LPOVERLAPPED);

    // Report error using ECB (didn' make it over to managed code)

    static void ReportHttpError(
                    EXTENSION_CONTROL_BLOCK *pEcb,
                    UINT errorResCode,
                    BOOL badRequest,
                    BOOL callDoneWithSession,
                    int  iCallerID);

    // Stores the request start time
    __int64 qwRequestStartTime;

    static LONG s_ActiveManagedRequestCount;

    static void IncrementActiveManagedRequestCount() {
        InterlockedIncrement(&s_ActiveManagedRequestCount);
    }

    static void DecrementActiveManagedRequestCount() {
        InterlockedDecrement(&s_ActiveManagedRequestCount);
    }

private:

    EXTENSION_CONTROL_BLOCK *_pEcb;

    HRESULT ProcessRequestInManagedCode();
    HRESULT ProcessRequestViaProcessModel();
};

/*
 * Cookieless session filter.
 */

DWORD CookielessSessionFilterProc(HTTP_FILTER_CONTEXT *, HTTP_FILTER_PREPROC_HEADERS *);
void CookielessSessionFilterInit();

/*
 * Shared configuration decls
 */
class DirMonCompletion;

bool                __stdcall IsConfigFileName(WCHAR * pFileName);
DirMonCompletion *  __stdcall MonitorGlobalConfigFile(PFNDIRMONCALLBACK pCallbackDelegate);
BOOL                __stdcall GetConfigurationFromNativeCode(
        LPCWSTR   szFileName,
        LPCWSTR   szConfigTag,
        LPCWSTR * szProperties,
        DWORD   * dwValues,
        DWORD     dwNumProperties,
        LPCWSTR * szPropertiesStrings,
        LPWSTR  * szValues,
        DWORD     dwNumPropertiesStrings,
        LPWSTR    szUnrecognizedAttrib,
        DWORD     dwUnrecognizedAttribSize);

/*
 * Custom error
 */

BOOL WriteCustomHttpError(EXTENSION_CONTROL_BLOCK *pEcb);
extern WCHAR g_szCustomErrorFile[MAX_PATH];
extern BOOL g_fCustomErrorFileChanged;


//
//  Health monitoring
//

void UpdateLastActivityTimeForHealthMonitor();
void UpdateLastRequestStartTimeForHealthMonitor();
void CheckAndReportHealthProblems(EXTENSION_CONTROL_BLOCK *pECB);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\platform_apis.h ===
/**
 * Support for platform-dependent APIs
 * 
 * Copyright (c) 2000, Microsoft Corporation
 * 
 */

#pragma once

enum ASPX_PLATFORM
{
    APSX_PLATFORM_UNKNOWN   = 0,
    APSX_PLATFORM_NT4       = 4,
    APSX_PLATFORM_W2K       = 5,
    APSX_PLATFORM_WIN9X     = 90
};

ASPX_PLATFORM GetCurrentPlatform();

BOOL PlatformGlobalMemoryStatusEx(MEMORYSTATUSEX *pMemStatEx);

HRESULT PlatformGetObjectContext(void **ppContext);
HRESULT PlatformCreateActivity(void **ppActivity);

BOOL    PlatformHasServiceDomainAPIs();
HRESULT PlatformEnterServiceDomain(IUnknown *pConfigObject);
HRESULT PlatformLeaveServiceDomain(IUnknown *pStatus);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\pm.h ===
/**
 * pm.h
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

#pragma once

HRESULT
DllInitProcessModel();

HRESULT
DllUninitProcessModel();

HRESULT
ISAPIInitProcessModel();

HRESULT
ISAPIUninitProcessModel();


void
LogDoneWithSession(
        PVOID  pECB,
        int    iCallerID);
void
LogNewRequest(
        PVOID  pECB);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\precomp.h ===
/**
 * Precompiled header for ASP.NET utility library.
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

// Standard headers

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <winsock2.h>
#include <mswsock.h>
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <io.h>
#include <limits.h>
#include <float.h>
#include <fcntl.h>
#include <iads.h>
#include <adshlp.h>
#include <commdlg.h>
#include <ocidl.h>
#include <activscp.h>
#include <activdbg.h>
#include <activscp.h>
#include <activdbg.h>
#include <math.h>
#include <shlwapi.h>
#include <iiis.h>
#include <setupapi.h>
#include <initguid.h>
#include <winver.h>
#include <icecap.h>

#pragma warning( disable : 4201 )

#include <wmistr.h>
#include <guiddef.h>
#include <evntrace.h>

#pragma warning( default : 4201 )

#include "httpext6.h"
#include "dbg.h"
#include "util.h"
#include "strsafe.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\sources.inc ===
!include $(DNAROOT)\src\xsp\place.inc

!if "$(ASPNET_PRODUCT)" == "redist"
SYNCHRONIZE_BLOCK=1	
!endif

TARGETNAME=precomp
TARGETPATH=$(O)
TARGETTYPE=LIBRARY

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h

PERF_H=$(O)\$(ASPNET_NAME_PREFIX)perf.h
PERF_INI=$(O)\$(ASPNET_NAME_PREFIX)perf_enu.ini
PERF_COMMON_INI=$(O)\$(ASPNET_NAME_PREFIX)perf2_enu.ini

PERFFILES=$(PERF_H) $(PERF_INI) $(PERF_COMMON_INI) $(O)\perfstruct.h $(O)\perfconsts.h $(O)\PerfCounterEnum.cs

MISCFILES=$(PERF_H) $(PERF_INI) $(PERF_COMMON_INI)

NTTARGETFILE0=$(PERFFILES) 

SOURCES=..\completion.idl \
        ..\dummy.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\smartfilehandle.h ===
/**
 * CSmartFileHandle header file
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 */

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _SmartFileHandle_H
#define _SmartFileHandle_H


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CSmartFileHandle
{
public:
    CSmartFileHandle(BOOL fBlocking = TRUE)
        : m_hHandle          (INVALID_HANDLE_VALUE),
          m_fBlocking        (fBlocking)
    {
        if (m_fBlocking)
            InitializeCriticalSection(&m_oCritSection);
    }

    ~CSmartFileHandle()
    {
        if (m_hHandle != INVALID_HANDLE_VALUE)
            CloseHandle(m_hHandle);
        if (m_fBlocking)
            DeleteCriticalSection(&m_oCritSection);
    }

    HANDLE GetHandle(BOOL fWait=TRUE)
    {
        if (!m_fBlocking)
            return m_hHandle;

        if (fWait)
        {
            EnterCriticalSection(&m_oCritSection);
            return m_hHandle;
        }

        if (TryEnterCriticalSection(&m_oCritSection))            
            return m_hHandle;
        return NULL;
    }

    void SetHandle(HANDLE hHandle)
    {
        m_hHandle = hHandle;
    }
    
    void ReleaseHandle()
    {
        if (m_fBlocking)
            LeaveCriticalSection(&m_oCritSection);
    }

    BOOL IsAlive()
    {
        return (m_hHandle != INVALID_HANDLE_VALUE);
    }

    void Close()
    {
        HANDLE hPipe = m_hHandle;

        if (hPipe != INVALID_HANDLE_VALUE)
        {
            HANDLE hOld = (HANDLE) InterlockedCompareExchangePointer(
                                       &m_hHandle, 
                                       INVALID_HANDLE_VALUE, 
                                       hPipe);
            if (hOld == hPipe)
                CloseHandle(hPipe);
        }
        
        m_hHandle = INVALID_HANDLE_VALUE;
    }


private:
    HANDLE              m_hHandle;
    CRITICAL_SECTION    m_oCritSection;
    BOOL                m_fBlocking;
};

/////////////////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\timeclass.h ===
/**
 * TimeClass header file
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _TimeClass_H
#define _TimeClass_H

#include "winbase.h"

class TimeClass
{
public:
    TimeClass                 ();

    void    SnapCurrentTime   ();

    DWORD   AgeInSeconds      ();

    void    Reset             () { m_fSet = FALSE; }

    BOOL    IsSet             () { return m_fSet; }
    
    static DWORD  DiffInSeconds (const TimeClass & t1, const TimeClass & t2);

private:

    __int64                   m_ulTime;
    BOOL                      m_fSet;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\xspstate.h ===
/**
 * xspstate.h
 * 
 * Shared definitions for the xspstate server protocol.
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

#define STATE_EXCLUSIVE_NONE      0
#define STATE_EXCLUSIVE_ACQUIRE   1
#define STATE_EXCLUSIVE_RELEASE   2

#define STATE_VERB_GET            1
#define STATE_VERB_PUT            2            
#define STATE_VERB_DELETE         3         
#define STATE_VERB_HEAD           4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\_appdomainfactory.h ===
/**
 * Contains IID and interface definition for ISAPIRuntime managed class.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

#pragma once
#pragma pack(push, 8)

#include <comdef.h>

namespace xspmrt
{

struct __declspec(uuid("e6e21054-a7dc-4378-877d-b7f4a2d7e8ba")) _AppDomainFactory;

struct _AppDomainFactory : IUnknown
{
    virtual HRESULT __stdcall Create ( BSTR module, 
                                       BSTR type, 
                                       BSTR appId,
                                       BSTR appPath,
                                       BSTR urlOfAppOrigin,
                                       int  iZone,
                                       IUnknown **ppObject ) = 0;
};

} // namespace xspmrt

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\ent\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\exp\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\std\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\_isapiruntime.h ===
/**
 * Contains IID and interface definition for ISAPIRuntime managed class.
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

#pragma once
#pragma pack(push, 8)

#include <comdef.h>

namespace xspmrt 
{

struct __declspec(uuid("08a2c56f-7c16-41c1-a8be-432917a1a2d1")) _ISAPIRuntime;

struct _ISAPIRuntime : IUnknown
{
    virtual HRESULT __stdcall StartProcessing ( ) = 0;
    virtual HRESULT __stdcall StopProcessing ( ) = 0;
    virtual HRESULT __stdcall ProcessRequest ( PVOID ecb, int iUseProcessModel, int *pfRestartRequired ) = 0;
    virtual HRESULT __stdcall DoGCCollect ( ) = 0;
};


} // namespace xspmrt

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\util.h ===
/**
 * ASP.NET utilties.
 *
 * Copyright (C) Microsoft Corporation, 1998
 */

#pragma once

#include "completion.h"

//
// goto MACROS
//

#pragma warning(disable:4127) // conditional expression is constant

#define ON_ERROR_EXIT() \
        do { if (hr) { TRACE_ERROR(hr); if (1) goto Cleanup; } } while (0)

#define ON_ERROR_CONTINUE() \
        do { if (hr) { TRACE_ERROR(hr); } } while (0)

#define ON_WIN32_ERROR_EXIT(x) \
        do { if ((x) != ERROR_SUCCESS) { hr = HRESULT_FROM_WIN32(x); TRACE_ERROR(hr); if (1) goto Cleanup; } } while (0)

#define ON_WIN32_ERROR_CONTINUE(x) \
        do { if ((x) != ERROR_SUCCESS) { hr = HRESULT_FROM_WIN32(x); TRACE_ERROR(hr); } } while (0)

#define ON_ZERO_EXIT_WITH_LAST_ERROR(x) \
        do { if ((x) == 0) { hr = GetLastWin32Error(); TRACE_ERROR(hr); if (1) goto Cleanup; } } while (0)

#define ON_ZERO_EXIT_WITH_HRESULT(x, y) \
        do { if ((x) == 0) { hr = y; TRACE_ERROR(hr); if (1) goto Cleanup; } } while (0)

#define ON_ZERO_EXIT_WITH_LAST_SOCKET_ERROR(x) \
        do { if ((x) == 0) { hr = HRESULT_FROM_WIN32(WSAGetLastError()); TRACE_ERROR(hr); if (1) goto Cleanup; } } while (0)

#define ON_ZERO_CONTINUE_WITH_LAST_ERROR(x) \
        do { if ((x) == 0) { hr = GetLastWin32Error(); TRACE_ERROR(hr); } } while (0)

#define ON_SOCKET_ERROR_EXIT(x) \
        do { if ((x) == SOCKET_ERROR) { hr = HRESULT_FROM_WIN32(WSAGetLastError()); TRACE_ERROR(hr); if (1) goto Cleanup; } } while (0)

#define ON_SOCKET_ERROR_CONTINUE(x) \
        do { if ((x) == SOCKET_ERROR) { hr = HRESULT_FROM_WIN32(WSAGetLastError()); TRACE_ERROR(hr); } } while (0)

#define ON_OOM_EXIT(p) \
        do { if ((p) == NULL) { hr = E_OUTOFMEMORY; TRACE_ERROR(hr); if (1) goto Cleanup; } } while (0)

#define ON_OOM_CONTINUE(p) \
        do { if ((p) == NULL) { hr = E_OUTOFMEMORY; TRACE_ERROR(hr); } } while (0)

#define EXIT() \
        do { if (hr) { TRACE_ERROR(hr); } if (1) goto Cleanup; } while (0)

#define EXIT_WITH_HRESULT(x) \
        do { hr = (x); TRACE_ERROR(hr); if (1) goto Cleanup; } while (0)

#define EXIT_WITH_SUCCESSFUL_HRESULT(x) \
        do { hr = (x); if (1) goto Cleanup; } while (0)

#define EXIT_WITH_OOM() \
        do { hr = E_OUTOFMEMORY; TRACE_ERROR(hr); if (1) goto Cleanup; } while (0)

#define EXIT_WITH_WIN32_ERROR(x) \
        do { hr = HRESULT_FROM_WIN32(x); TRACE_ERROR(hr); if (1) goto Cleanup; } while (0)

#define EXIT_WITH_LAST_ERROR() \
        do { hr = GetLastWin32Error(); TRACE_ERROR(hr); if (1) goto Cleanup; } while (0)

#define EXIT_WITH_LAST_SOCKET_ERROR() \
        do { hr = HRESULT_FROM_WIN32(WSAGetLastError()); TRACE_ERROR(hr); if (1) goto Cleanup; } while (0)

#define CONTINUE_WITH_LAST_ERROR() \
        do { hr = GetLastWin32Error(); TRACE_ERROR(hr); } while (0)

#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))

HRESULT GetLastWin32Error();


/*
 *  Macro to obtain array length
 */

#define ARRAY_LENGTH(_array) (sizeof(_array)/sizeof((_array)[0]))

/*
 * Min/Max
 */

#ifdef min
#undef min
#endif

template <class T> 
T min( T a, T b )
{
    return ( a <= b ) ? a : b;
}

#ifdef max
#undef max
#endif

template <class T> 
T max( T a, T b )
{
    return ( a >= b ) ? a : b;
}

/* comutil.cxx */
void ClearInterfaceFn(IUnknown ** ppUnk);
void ClearClassFn(void ** ppv, IUnknown * pUnk);
void ReplaceInterfaceFn(IUnknown ** ppUnk, IUnknown * pUnk);
void ReleaseInterface(IUnknown * pUnk);
BOOL IsSameObject(IUnknown *pUnkLeft, IUnknown *pUnkRight);
void ExcepInfoClear(EXCEPINFO *pExcepInfo);
void ExcepInfoInit(EXCEPINFO *pExcepInfo);

/**
 * Sets an interface pointer to NULL, after first calling
 * Release if the pointer was not NULL initially.
 */
template <class PI>
inline void
ClearInterface(PI * ppI)
{
#if DBG
    IUnknown * pUnk = *ppI;
    ASSERT((void *) pUnk == (void *) *ppI);
#endif
    ClearInterfaceFn((IUnknown **) ppI);
}

/**
 * Replaces an interface pointer with a new interface,
 * following proper ref counting rules:
 *
 *  *ppI is set to pI
 *  if pI is not NULL, it is AddRef'd
 *  if *ppI is not NULL initially, it is Release'd
 *
 * Effectively, this allows pointer assignment for ref-counted pointers.
 */
template <class PI>
inline void
ReplaceInterface(PI * ppI, PI pI)
{
#if DBG
    IUnknown * pUnk = *ppI;
    ASSERT((void *) pUnk == (void *) *ppI);
#endif
    ReplaceInterfaceFn((IUnknown **) ppI, pI);
}

//
// Runtime integration
//

DWORD GetMachineCpuCount();
DWORD GetCurrentProcessCpuCount();

HRESULT SelectRuntimeFlavor(IUnknown** ppHost = NULL);
HRESULT GetRuntimeDirectory(WCHAR *pBuffer, DWORD bufferSize);
HRESULT MarkThreadForRuntime();

//
// ISAPI Initialization
//

HRESULT __stdcall InitializeLibrary();

//
//  Spin locks
//

//+------------------------------------------------------------------------
//
//  NO_COPY *declares* the constructors and assignment operator for copying.
//  By not *defining* these functions, you can prevent your class from
//  accidentally being copied or assigned -- you will be notified by
//  a linkage error.
//
//-------------------------------------------------------------------------

#define NO_COPY(cls)    \
    cls(const cls&);    \
    cls& operator=(const cls&)


//
// Spin Lock Class
//

class CReadWriteSpinLock
{
private:
    long            _bits;
    DWORD           _id;

    static BOOL     s_disableBusyWaiting;
    static DWORD    s_spinTimeoutInSeconds;
    static int      s_init;

    enum {
        SIGN_BIT_MASK           = 0x80000000,   // 1 bit
        WRITER_WAITING_MASK     = 0x40000000,   // 1 bit
        WRITE_COUNT_MASK        = 0x3FFF0000,   // 14 bits
        READ_COUNT_MASK         = 0x0000FFFF,   // 16 bits
        WRITER_WAITING_SHIFT    = 30,           
        WRITE_COUNT_SHIFT       = 16,           
    };

    static BOOL WriterWaiting(int bits)             {return ((bits & WRITER_WAITING_MASK) != 0);}
    static int  WriteLockCount(int bits)            {return ((bits & WRITE_COUNT_MASK) >> WRITE_COUNT_SHIFT);}
    static int  ReadLockCount(int bits)             {return (bits & READ_COUNT_MASK);}
    static BOOL NoWriters(int bits)                 {return ((bits & WRITE_COUNT_MASK) == 0);}
    static BOOL NoWritersOrWaitingWriters(int bits) {return ((bits & (WRITE_COUNT_MASK | WRITER_WAITING_MASK)) == 0);}
    static BOOL NoLocks(int bits)                   {return ((bits & ~WRITER_WAITING_MASK) == 0);}

    BOOL    WriterWaiting()             {return WriterWaiting(_bits);}
    int     WriteLockCount()            {return WriteLockCount(_bits);}
    int     ReadLockCount()             {return ReadLockCount(_bits);}
    BOOL    NoWriters()                 {return NoWriters(_bits);}
    BOOL    NoWritersOrWaitingWriters() {return NoWritersOrWaitingWriters(_bits);}
    BOOL    NoLocks()                   {return NoLocks(_bits);}

    int CreateNewBits(BOOL writerWaiting, int writeCount, int readCount) {
        return ( ((int)writerWaiting << WRITER_WAITING_SHIFT)   |
                 (writeCount << WRITE_COUNT_SHIFT)              |
                 (readCount));
    }

    void AlterWriteCountHoldingWriterLock(int oldBits, int delta);

    BOOL _TryAcquireWriterLock(int threadId);
    BOOL _TryAcquireReaderLock(int threadId);
    void _Spin(BOOL isReaderAcquisition, int threadId);

public:
    CReadWriteSpinLock(char * pszName);
    NO_COPY(CReadWriteSpinLock);
    ~CReadWriteSpinLock();
    static int StaticInit();


    inline void AssertInWriteLock() {
#if DBG
        long bits = _bits;
        ASSERT(WriteLockCount(bits) > 0);
#endif
    }

    inline void AssertInReadLock() {
#if DBG
        long bits = _bits;
        ASSERT(ReadLockCount(bits) > 0);
#endif
    }

    inline void AssertNotInLock() {
#if DBG
        long bits = _bits;
        ASSERT(NoLocks(bits));
#endif
    }

    void AcquireReaderLock();
    void ReleaseReaderLock();
    void AcquireWriterLock();
    void ReleaseWriterLock();

    BOOL TryAcquireWriterLock();
    BOOL TryAcquireReaderLock();
    
};

//
//  Simple hash function
//
inline long
SimpleHash(
    BYTE *buf,
    int len)
{
    long hash = 0;
    for (int i = 0;  i < len;  i++) {
        hash = 37 * hash + (buf[i] & 0xDF);  // strip off lowercase bit
    }

    return hash;
}






//
//  Allocations
//


void *MemAlloc(size_t size);
void *MemAllocClear(size_t size);
void  MemFree(void *pMem);
void *MemReAlloc(void *pMem, size_t NewSize);
size_t  MemGetSize(void *pv);
void *MemDup(void *pMem, int cb);

enum NewClearEnum { NewClear};
enum NewReAllocEnum { NewReAlloc};

inline void * __cdecl operator new(size_t cb)                               { return MemAlloc(cb); }
inline void * __cdecl operator new(size_t cb, NewClearEnum)                 { return MemAllocClear(cb); }
inline void * __cdecl operator new(size_t cb, void *pv, NewReAllocEnum)     { return MemReAlloc(pv, cb); }
inline void * __cdecl operator new[](size_t cb)                             { return MemAlloc(cb); }
inline void * __cdecl operator new[](size_t cb, NewClearEnum)               { return MemAllocClear(cb); }
inline void * __cdecl operator new[](size_t cb, void *pv, NewReAllocEnum)   { return MemReAlloc(pv, cb); }
inline void   __cdecl operator delete(void *pv)                             { MemFree(pv); }
inline void   __cdecl operator delete[](void *pv)                           { MemFree(pv); }

#define NEW_BYTES(numBytes)  (new BYTE[numBytes])
#define NEW_CLEAR_BYTES(numBytes)  (new (NewClear) BYTE[numBytes])
#define DELETE_BYTES(pMem) (delete [] ((BYTE *)pMem))

#define DECLARE_MEMALLOC_NEW_DELETE() \
    inline void * __cdecl operator new(size_t cb)               { return MemAlloc(cb); } \
    inline void * __cdecl operator new[](size_t cb)             { return MemAlloc(cb); } \
    inline void   __cdecl operator delete(void * pv)            { MemFree(pv); }

#define DECLARE_MEMCLEAR_NEW_DELETE() \
    inline void * __cdecl operator new(size_t cb)               { return MemAllocClear(cb); } \
    inline void * __cdecl operator new[](size_t cb)             { return MemAllocClear(cb); } \
    inline void   __cdecl operator delete(void * pv)            { MemFree(pv); }



#define EqualMemory(Source1, Source2, Length) RtlEqualMemory((Source1), (Source2), (Length))

/*
 * Strings - strutil.cxx
 */

WCHAR * DupStr(const WCHAR *str);
WCHAR * DupStrN(const WCHAR *str, int n);
char *  DupStr(const char *str);
char *  DupStrA(const WCHAR *input, UINT cp = CP_ACP);
WCHAR * DupStrW(const char *input, UINT cp = CP_ACP);
BSTR    DupStrBSTR(const char *input, UINT cp = CP_ACP);

char *  stristr(char* pszString, char* pszSubString);
char *  strnstr(const char * str1, const char * str2, int cstr1);
WCHAR * wcsistr(const WCHAR *pszMain, const WCHAR *pszSub);

bool    StrEquals(char ** ppch, char * str, int len);
#define STREQUALS(ppch, str) StrEquals(ppch, str, ARRAY_SIZE(str) - 1)

HRESULT WideStrToMultiByteStr(WCHAR *wszIn, CHAR **pszOut, UINT codepage);


/*
 * Socket helpers.
 */

#ifndef _WINSOCKAPI_

/*
 * The new type to be used in all
 * instances which refer to sockets.
 */

typedef UINT_PTR        SOCKET;

#endif

BOOL IsSocketConnected(SOCKET s);

/*
 * OLE helpers.
 */

HRESULT EnsureCoInitialized(BOOL *pNeedCoUninit);

/*
 * Completion helper.
 */
class Completion : public ICompletion
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    Completion();
    virtual ~Completion();

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID, void **);

    OVERLAPPED_COMPLETION * Overlapped() {return &_overlappedCompletion;}
    HRESULT Post();

protected:
    int     Refs() {return _refs;}

private:
    OVERLAPPED_COMPLETION   _overlappedCompletion;
    long                    _refs;
};


/*
 * Time constants
 */

/* 
 * TICKS are 100 nanoseconds, the units of a FILETIME and a managed DateTime 
 */

#define TICKS_PER_MSEC               10000
#define TICKS_PER_SEC             10000000            
#define TICKS_PER_MIN            600000000
#define TICKS_PER_HOUR         36000000000
#define TICKS_PER_DAY         864000000000

#define MSEC_PER_SEC                  1000
#define MSEC_PER_MIN                 60000
#define MSEC_PER_HOUR              3600000
#define MSEC_PER_DAY              86400000

#define SEC_PER_MIN                     60 
#define SEC_PER_HOUR                  3600 
#define SEC_PER_DAY                  86400 

#define DAYS_PER_YEAR                  365
#define DAYS_PER_LEAP_YEAR             366
#define DAYS_PER_4YEARS               1461  /* one leap year */
#define DAYS_PER_100YEARS            36524  /* no leap year every 100 years ... */
#define DAYS_PER_400YEARS           146097  /* ... except every 400 years */

/*
 * 1/1/1601 is the start of a FILETIME.
 * Note that this isn't really accurate, since the modern calendar
 * was not adopted until 1601.
 */

#define DAYS_TO_1601                584388
#define TICKS_TO_1601   504911232000000000


//
//  Get ASP.NET Version
//

char *GetStaticVersionString();
WCHAR *GetStaticVersionStringW();
HRESULT GetFileVersion( const WCHAR *pFilename, VS_FIXEDFILEINFO *pInfo);

// Generate random strings of (iStringSize - 1) length
// Don't forget to NULL terminate the string!
HRESULT GenerateRandomString(LPWSTR szRandom, int iStringSize);


//
// strsafe.h macros
//

#if DBG
#define ASSERT_ON_BAD_HRESULT_IN_STRSAFE         1
#endif

#define StringCchCopyUnsafeW(dest, src)          StringCchCopyW(dest, STRSAFE_MAX_CCH, src)
#define StringCchCopyUnsafeA(dest, src)          StringCchCopyA(dest, STRSAFE_MAX_CCH, src)

#define StringCchCopyNUnsafeW(dest, src, len)    StringCchCopyNW(dest, STRSAFE_MAX_CCH, src, len)
#define StringCchCopyNUnsafeA(dest, src, len)    StringCchCopyNA(dest, STRSAFE_MAX_CCH, src, len)

#define StringCchCopyToArrayW(dest, src)         StringCchCopyW(dest, ARRAY_SIZE(dest), src)
#define StringCchCopyToArrayA(dest, src)         StringCchCopyA(dest, ARRAY_SIZE(dest), src)

#define StringCchCatToArrayW(dest, src)          StringCchCatW(dest, ARRAY_SIZE(dest), src)
#define StringCchCatToArrayA(dest, src)          StringCchCatA(dest, ARRAY_SIZE(dest), src)

#define StringCchCopyNToArrayW(dest, src, len)   StringCchCopyNW(dest, ARRAY_SIZE(dest), src, len)
#define StringCchCopyNToArrayA(dest, src, len)   StringCchCopyNA(dest, ARRAY_SIZE(dest), src, len)

#define StringCchCatUnsafeW(dest, src)           StringCchCatW(dest, STRSAFE_MAX_CCH, src)
#define StringCchCatUnsafeA(dest, src)           StringCchCatA(dest, STRSAFE_MAX_CCH, src)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\inc\redist\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\ackreceiver.h ===
/**
 * AckReceiver header file
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

#if _MSC_VER > 1000
#pragma once
#endif

/////////////////////////////////////////////////////////////////////////////
// This file defines the class CAckReceiver. This class controls access of
// ASPNET_ISAPI with the sync pipe. Primary purpose of the sync pipe is to handle
// acks of requests. Secondary purpose is to allow calling EcbXXX functions
// remotely by the worker process.
/////////////////////////////////////////////////////////////////////////////

#ifndef _AckReceiver_H
#define _AckReceiver_H

#include "SmartFileHandle.h"
#include "MessageDefs.h"
#include "completion.h"

/////////////////////////////////////////////////////////////////////////////
// Forward decl.
class CProcessEntry;
class CAckReceiver;
/////////////////////////////////////////////////////////////////////////////

struct CAckReceiverOverlapped : public OVERLAPPED_COMPLETION
{
    BOOL           fWriteOperation;
    DWORD          dwBytes;
    int            iPipeIndex;
};

/////////////////////////////////////////////////////////////////////////////
class CAckReceiver : public ICompletion
{
public:
    CAckReceiver                     ();
    ~CAckReceiver                    ();

    HRESULT   Init                   (CProcessEntry * pProcess, 
                                      LPCWSTR         szPipeName,
                                      LPSECURITY_ATTRIBUTES pSA,
                                      int iNumPipes);

    void      Close                  ();
    BOOL      IsAlive                ();
    HRESULT   StartRead              (DWORD dwOffset, int iPipe);
    BOOL      AnyPendingReadOrWrite  ()  {return m_lPendingReadWriteCount>0;}

    HRESULT   ProcessSyncMessage     (CSyncMessage * pMsg, BOOL fError);

    // ICompletion interface
    STDMETHOD    (QueryInterface   ) (REFIID    , void **       );
    STDMETHOD    (ProcessCompletion) (HRESULT   , int, LPOVERLAPPED  );

    STDMETHOD_   (ULONG, AddRef    ) ();
    STDMETHOD_   (ULONG, Release   ) ();


private:
    LONG                             m_lPendingReadWriteCount;
    CSmartFileHandle *               m_oPipes;
    CAckReceiverOverlapped *         m_oOverlappeds;
    CProcessEntry *                  m_pProcess;
    DWORD *                          m_dwMsgSizes;
    CSyncMessage **                  m_pMsgs;
    int                              m_iNumPipes;
};

/////////////////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\aspcompat.cxx ===
/**
 * Support for ASP Compat Request execution -- infrastructure
 * 
 * Copyright (c) 2000, Microsoft Corporation
 * 
 */

#include "precomp.h"

#include "platform_apis.h"
#include "aspcompat.h"

//
// Counters for debugging
//

LONG g_NumActiveAspCompatCalls = 0;
LONG g_NumLiveAspCompatCalls = 0;

//////////////////////////////////////////////////////////////////////////////
//
// Entrypoints from managed code called via PInvoke
//

int __stdcall
AspCompatProcessRequest(PFN_ASPCOMPAT_CB callback, IUnknown *pContext) {

    HRESULT hr = S_OK;
    AspCompatAsyncCall *pAsyncCall = NULL;
    IManagedContext *pManagedContext = NULL;

    hr = pContext->QueryInterface(__uuidof(IManagedContext), (void **)&pManagedContext);
    ON_ERROR_EXIT();

    pAsyncCall = new AspCompatAsyncCall(callback, pManagedContext);
    ON_OOM_EXIT(pAsyncCall);

    hr = pAsyncCall->Post();
    ON_ERROR_EXIT();

Cleanup:
    ReleaseInterface(pManagedContext);
    ReleaseInterface(pAsyncCall);
    return (hr == S_OK) ? 1 : 0;
}

int __stdcall 
AspCompatOnPageStart(IUnknown *pComponent) {
    HRESULT hr = S_OK;
    AspCompatAsyncCall *pCall = NULL;
    IDispatch *pDisp = NULL;

    // get current AspCompatAsyncCall
    hr = AspCompatAsyncCall::GetCurrent(&pCall);
    ON_ERROR_EXIT();

    // get IDispatch from component
   	hr = pComponent->QueryInterface(IID_IDispatch, (void **)&pDisp);
    ON_ERROR_EXIT();

    // call to do the work
    hr = pCall->OnPageStart(pDisp);
    ON_ERROR_EXIT();

Cleanup:
    ReleaseInterface(pCall);
    ReleaseInterface(pDisp);
    return (hr == S_OK) ? 1 : 0;
}

int __stdcall 
AspCompatIsApartmentComponent(IUnknown *pComponent) {
    HRESULT hr = S_OK;
	IMarshal *pMarshal = NULL;
	GUID guidClsid;
    int rc = 1;  // Assume it is apartment

    // check if aggregates FTM

	hr = pComponent->QueryInterface(IID_IMarshal, (void**)&pMarshal);
    if (hr != S_OK)
        EXIT_WITH_SUCCESSFUL_HRESULT(S_OK);

	hr = pMarshal->GetUnmarshalClass(IID_IUnknown, pComponent, MSHCTX_INPROC, NULL, MSHLFLAGS_NORMAL, &guidClsid);
    if (hr != S_OK)
        EXIT_WITH_SUCCESSFUL_HRESULT(S_OK);

	if (guidClsid == CLSID_InProcFreeMarshaler)  // aggregates FTM?
        rc = 0;

Cleanup:
    ReleaseInterface(pMarshal);
    return rc;
}

//////////////////////////////////////////////////////////////////////////////
//
// Get IContextProperties from IObjectContext
//

HRESULT GetContextProperties(IObjectContext *pObjectContext, IContextProperties **ppContextProperties) {
    HRESULT hr = S_OK;

    if (GetCurrentPlatform() == APSX_PLATFORM_W2K) {
        hr = pObjectContext->QueryInterface(IID_IContextProperties, (void **)ppContextProperties);
        ON_ERROR_EXIT();
    }
    else {
        EXIT_WITH_HRESULT(E_NOINTERFACE);
    }

Cleanup:
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// FtmHelper implementation
//

HRESULT
FtmHelper::QueryInterface(IUnknown *pObject, REFIID iid, void **ppvObj) {

    HRESULT hr = S_OK;

    if (_pFtm == NULL) {
        // create FTM on demand
        _lock.AcquireWriterLock();

        if (_pFtm == NULL)
            hr = CoCreateFreeThreadedMarshaler(pObject, &_pFtm);

        _lock.ReleaseWriterLock();
        ON_ERROR_EXIT();
    }

    hr = _pFtm->QueryInterface(iid, ppvObj);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// Access to ASP type library
//

struct __declspec(uuid("D97A6DA0-A85C-11CF-83AE-00A0C90C2BD8")) ASPTLB;
ITypeLib           *g_pAspTypelib = NULL;
HRESULT             g_AspTypelibHR = S_OK;
CReadWriteSpinLock  g_AspTypelibLock("g_AspTypelibLock");

HRESULT GetAspTypeLibrary(ITypeLib **ppTypeLib) {
    HRESULT hr = S_OK;

    if (g_pAspTypelib == NULL) {

        if (g_AspTypelibHR != S_OK)
            EXIT_WITH_HRESULT(g_AspTypelibHR);

        g_AspTypelibLock.AcquireWriterLock();

        if (g_pAspTypelib == NULL && g_AspTypelibHR == S_OK) {

            // different version on different platforms
            WORD version = 3;
            if (GetCurrentPlatform() != APSX_PLATFORM_W2K) {
                EXIT_WITH_HRESULT(TYPE_E_LIBNOTREGISTERED);
            }

            hr = LoadRegTypeLib(__uuidof(ASPTLB), version, 0, 0, &g_pAspTypelib);

            if (hr != S_OK)
                g_AspTypelibHR = hr;
        }

        g_AspTypelibLock.ReleaseWriterLock();

        if (g_AspTypelibHR != NULL)
            EXIT_WITH_HRESULT(g_AspTypelibHR);
    }

Cleanup:

    *ppTypeLib = g_pAspTypelib;
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// AspDispatchHelper implementation
//

HRESULT AspDispatchHelper::GetTypeInfoInternal() {
    HRESULT hr = S_OK;

    _lock.AcquireWriterLock();

    if (_pAspTypeInfo == NULL) {

        ITypeLib *pAspTlb;
        hr = GetAspTypeLibrary(&pAspTlb);
        ON_ERROR_EXIT();

        hr = pAspTlb->GetTypeInfoOfGuid(_aspIID, &_pAspTypeInfo);
        ON_ERROR_EXIT();
    }

Cleanup:
    _lock.ReleaseWriterLock();
    return hr;
}

HRESULT AspDispatchHelper::GetTypeInfoCount(UINT *pctinfo) {
    *pctinfo = 1;
    return S_OK;
}

HRESULT AspDispatchHelper::GetTypeInfo(UINT, ULONG, ITypeInfo **ppTypeInfo) {
    HRESULT hr = S_OK;

    if (_pAspTypeInfo == NULL) {
        hr = GetTypeInfoInternal();
        ON_ERROR_EXIT();
    }

    *ppTypeInfo = _pAspTypeInfo;
    (*ppTypeInfo)->AddRef();

Cleanup:
    return hr;
}

HRESULT AspDispatchHelper::GetIDsOfNames(REFIID, LPOLESTR *pNames, UINT cNames, LCID, DISPID *pDispid) {
    HRESULT hr = S_OK;

    if (_pAspTypeInfo == NULL) {
        hr = GetTypeInfoInternal();
        ON_ERROR_EXIT();
    }

    hr = _pAspTypeInfo->GetIDsOfNames(pNames, cNames, pDispid);

Cleanup:
    return hr;
}

HRESULT AspDispatchHelper::Invoke(IDispatch *pObject, DISPID dispidMember, REFIID, LCID, WORD wFlags, DISPPARAMS *pParams, VARIANT *pResult, EXCEPINFO *pExcepInfo, UINT *puArgErr) {
    HRESULT hr = S_OK;

    if (_pAspTypeInfo == NULL) {
        hr = GetTypeInfoInternal();
        ON_ERROR_EXIT();
    }

    // Add DISPATCH_PROPERTYGET for the default property (CS components don't include it)
    if (dispidMember == 0 && wFlags == DISPATCH_METHOD)
        wFlags |= DISPATCH_PROPERTYGET;

    hr = _pAspTypeInfo->Invoke(pObject, dispidMember, wFlags, pParams, pResult, pExcepInfo, puArgErr);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// AspCompatAsyncCall implementation
//

AspCompatAsyncCall::AspCompatAsyncCall(PFN_ASPCOMPAT_CB callback, IManagedContext *pManagedContext) {
    InitializeListHead(&_objectWrappersList);

    _refs     = 1;
    _callback = callback;

    _pManagedContext = pManagedContext;
    _pManagedContext->AddRef();

    InterlockedIncrement(&g_NumLiveAspCompatCalls);
}

AspCompatAsyncCall::~AspCompatAsyncCall() {
    // free all object wrappers for OnPageStart/OnPageEnd
    while (!IsListEmpty(&_objectWrappersList)) {
        AspCompatObjectWrapper *pWrap = CONTAINING_RECORD(_objectWrappersList.Flink, AspCompatObjectWrapper, _listEntry);
        RemoveEntryList(&pWrap->_listEntry);
        delete pWrap;
    }

    // release interfaces
    ReleaseInterface(_pManagedContext);
    ReleaseInterface(_pActivity);
    ReleaseInterface(_pScriptingContext);

    InterlockedDecrement(&g_NumLiveAspCompatCalls);
}

HRESULT AspCompatAsyncCall::QueryInterface(REFIID iid, void **ppvObj) {
    HRESULT hr = S_OK;

    if (iid == IID_IUnknown || iid == __uuidof(IMTSCall)) {
        AddRef();
        *ppvObj = this;
    }
    else if (iid == IID_IMarshal) {
        hr = _ftmHelper.QueryInterface(this, iid, ppvObj);
        ON_ERROR_EXIT();
    }
    else {
        EXIT_WITH_HRESULT(E_NOINTERFACE);
    }

Cleanup:
    return hr;
}

ULONG AspCompatAsyncCall::AddRef() {
    return InterlockedIncrement(&_refs);
}

ULONG AspCompatAsyncCall::Release() {
    long r = InterlockedDecrement(&_refs);
    if (r == 0) {
        delete this;
        return 0;
    }
    return r;
}

HRESULT AspCompatAsyncCall::Post() {
    HRESULT hr = S_OK;

    AddRef();           // for the duration of async call

    hr = PlatformCreateActivity((void **)&_pActivity);
    ON_ERROR_EXIT();

    hr = _pActivity->AsyncCall(this);
    ON_ERROR_EXIT();

Cleanup:
    if (hr != S_OK)
        Release();      // if async call wasn't posted
    return hr;
}

HRESULT AspCompatAsyncCall::OnCall() {
    HRESULT hr = S_OK;
    int sessionPresent = 1;
    IObjectContext *pObjectContext = NULL;
    IContextProperties *pContextProperties = NULL;

    InterlockedIncrement(&g_NumActiveAspCompatCalls);

    // Create the ASP compat intrinsics

    _pScriptingContext = new AspCompatScriptingContext();
    ON_OOM_EXIT(_pScriptingContext);

    hr = _pManagedContext->Session_IsPresent(&sessionPresent);
    ON_ERROR_EXIT();

    hr = _pScriptingContext->CreateIntrinsics(this, (sessionPresent != 0));
    ON_ERROR_EXIT();

    // Attach the intrinsics to the object context

    hr = PlatformGetObjectContext((void **)&pObjectContext);
    ON_ERROR_EXIT();

    hr = GetContextProperties(pObjectContext, &pContextProperties);
    ON_ERROR_EXIT();

    hr = AddContextProperty(pContextProperties, L"Application", _pScriptingContext->_pApplication);
    ON_ERROR_EXIT();

    hr = AddContextProperty(pContextProperties, L"Session", _pScriptingContext->_pSession);
    ON_ERROR_EXIT();

    hr = AddContextProperty(pContextProperties, L"Request", _pScriptingContext->_pRequest);
    ON_ERROR_EXIT();

    hr = AddContextProperty(pContextProperties, L"Response", _pScriptingContext->_pResponse);
    ON_ERROR_EXIT();

    hr = AddContextProperty(pContextProperties, L"Server", _pScriptingContext->_pServer);
    ON_ERROR_EXIT();

    __try {
        // Call into managed code to process the request catching all exceptions
        (*_callback)();

        // OnPageEnd for all components
        OnPageEnd();
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        hr = GetExceptionCode();
        ON_ERROR_CONTINUE();
        hr = S_OK;
    }

Cleanup:

    ReleaseInterface(pContextProperties);
    ReleaseInterface(pObjectContext);

    // let intrinsics go
    ClearInterface(&_pScriptingContext);

    // remove the connection to managed code
    ClearInterface(&_pManagedContext);

    // remove the activity and the intrinsics in the associated object context
    ClearInterface(&_pActivity);

    // undo the addref before posting the call
    Release();

    InterlockedDecrement(&g_NumActiveAspCompatCalls);

    return S_OK; // nobody to complain to (COM gets this HRESULT)
}

HRESULT AspCompatAsyncCall::AddContextProperty(IContextProperties *pCP, LPWSTR pName, IDispatch *pIntrinsic) {
    HRESULT hr = S_OK;
    BSTR bstrName = NULL;
    VARIANT v;
    VariantInit(&v);

    if (pIntrinsic == NULL) // no intrinsic - no problem (session isn't always available)
        EXIT();

    bstrName = SysAllocString(pName);
    ON_OOM_EXIT(bstrName);

    pIntrinsic->AddRef();
    V_VT(&v) = VT_DISPATCH;
    V_DISPATCH(&v) = pIntrinsic;
    
    hr = pCP->SetProperty(bstrName, v);
    ON_ERROR_EXIT();

Cleanup:
     SysFreeString(bstrName);
    VariantClear(&v);
    return hr;
}

HRESULT AspCompatAsyncCall::GetContextProperty(LPWSTR pName, IDispatch **ppIntrinsic) {
    HRESULT hr = S_OK;
    IObjectContext *pObjectContext = NULL;
    IContextProperties *pContextProperties = NULL;
    IDispatch *pIntrinsic = NULL;
    VARIANT v;
    BSTR bstrName = NULL;

    VariantInit(&v);

    // Get to IContextProperies

    hr = PlatformGetObjectContext((void **)&pObjectContext);
    ON_ERROR_EXIT();

    hr = GetContextProperties(pObjectContext, &pContextProperties);
    ON_ERROR_EXIT();

    // Ask for property

    bstrName = SysAllocString(pName);
    ON_OOM_EXIT(bstrName);

    hr = pContextProperties->GetProperty(bstrName, &v);
    ON_ERROR_EXIT();

    // Convert Variant to IDispatch*

    if (V_VT(&v) == VT_DISPATCH) {
        pIntrinsic = V_DISPATCH(&v);
        if (pIntrinsic == NULL)
            EXIT_WITH_HRESULT(E_POINTER);
        pIntrinsic->AddRef();
    }
    
Cleanup:
    ReleaseInterface(pContextProperties);
    ReleaseInterface(pObjectContext);

    if (bstrName != NULL)
        SysFreeString(bstrName);
    VariantClear(&v);

    *ppIntrinsic = pIntrinsic;
    return hr;
}

// Get current AspCompatAsyncCall from the context (static method)
HRESULT AspCompatAsyncCall::GetCurrent(AspCompatAsyncCall **ppCurrent) {
    HRESULT hr = S_OK;
    AspCompatAsyncCall *pCurrent = NULL;
    AspCompatRequest *pRequest = NULL;

    // Get it from Request

    hr = GetContextProperty(L"Request", (IDispatch **)&pRequest);
    ON_ERROR_EXIT();

    pCurrent = pRequest->_pCall;
    pCurrent->AddRef();

Cleanup:
    ReleaseInterface(pRequest);
    *ppCurrent = pCurrent;
    return hr;
}

// Response logic requires reset of request cookies
HRESULT AspCompatAsyncCall::ResetRequestCoookies() {
    HRESULT hr = S_OK;

    ON_ZERO_EXIT_WITH_HRESULT(_pScriptingContext, E_UNEXPECTED);
    hr = _pScriptingContext->_pRequest->ResetCookies();
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

// Call OnPageStart and remember the component to call OnPageEnd later
HRESULT AspCompatAsyncCall::OnPageStart(IDispatch *pComponent) {
    HRESULT hr = S_OK;
    static LPOLESTR pOnStartPageName = L"OnStartPage";
    static LPOLESTR pOnEndPageName =   L"OnEndPage";
    DISPID startId, endId;
    AspCompatObjectWrapper *pWrap = NULL;

    // get IDs for OnPageStart / OnPageEnd
    hr = pComponent->GetIDsOfNames(IID_NULL, &pOnStartPageName, 1, LOCALE_SYSTEM_DEFAULT, &startId);
    if (hr != S_OK) { hr = S_OK; EXIT(); }  // no method = no problem
    hr = pComponent->GetIDsOfNames(IID_NULL, &pOnEndPageName,   1, LOCALE_SYSTEM_DEFAULT, &endId);
    if (hr != S_OK) { hr = S_OK; EXIT(); }  // no method = no problem

    // create new AspCompatObjectWrapper and call OnPageStart
    pWrap = new AspCompatObjectWrapper(pComponent, startId, endId);
    ON_OOM_EXIT(pWrap);

    // call on start page
    hr = pWrap->CallOnPageStart(_pScriptingContext);
    ON_ERROR_EXIT();

    // only if everything the above succeeded remember the object to call OnPageEnd
    InsertTailList(&_objectWrappersList, &pWrap->_listEntry);

Cleanup:
    if (hr != S_OK && pWrap != NULL)
        delete pWrap;
    return hr;
}

// Call OnPageEnd for all remembered components
HRESULT AspCompatAsyncCall::OnPageEnd() {
    HRESULT hr = S_OK;
    AspCompatObjectWrapper *pWrap = NULL;

    while (!IsListEmpty(&_objectWrappersList)) {
        pWrap = CONTAINING_RECORD(_objectWrappersList.Flink, AspCompatObjectWrapper, _listEntry);
        RemoveEntryList(&pWrap->_listEntry);

        hr = pWrap->CallOnPageEnd();
        ON_ERROR_CONTINUE();            // call another component if one failes
        hr = S_OK;

        delete pWrap;
    }

    return hr;
}

//
// Helpers to call OnPageStart / OnPageEnd
//

HRESULT AspCompatObjectWrapper::CallOnPageStart(IDispatch *pContext) {
    HRESULT hr = S_OK;
    EXCEPINFO   excepInfo;
    DISPPARAMS  dispParams;
    VARIANT     varResult;
    VARIANT     varParam;
    UINT        nArgErr;

    memset(&dispParams, 0, sizeof(DISPPARAMS));
    memset(&excepInfo, 0, sizeof(EXCEPINFO));

    VariantInit(&varParam);
    V_VT(&varParam) = VT_DISPATCH;
    V_DISPATCH(&varParam) = pContext;

    dispParams.rgvarg = &varParam;
    dispParams.cArgs = 1;

    VariantInit(&varResult);

    hr = _pObject->Invoke(_startId, IID_NULL, NULL, DISPATCH_METHOD, &dispParams, &varResult, &excepInfo, &nArgErr);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatObjectWrapper::CallOnPageEnd() {
    HRESULT hr = S_OK;
    EXCEPINFO   excepInfo;
    DISPPARAMS  dispParams;
    VARIANT     varResult;
    UINT        nArgErr;

    memset(&dispParams, 0, sizeof(DISPPARAMS));
    memset(&excepInfo, 0, sizeof(EXCEPINFO));

    VariantInit(&varResult);

    hr = _pObject->Invoke(_endId, IID_NULL, NULL, DISPATCH_METHOD, &dispParams, &varResult, &excepInfo, &nArgErr);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\aspnetetw.cxx ===
/**
 * AspNet Event Trace 
 *
 * Copyright (c) 2001 Microsoft Corporation
 */

#include "precomp.h"
#include "names.h"
#include "etw.h"
#include "aspnetetw.h"
#include "util.h"


//
// The global aspnet tracer instance
//
CEtwTracer g_EtwTracer;

//
// Resource constants
//

#define ASPNET_RESOURCE_NAME L"AspNetMofResource"

//
// Control Guid.
//

DEFINE_GUID( /* AFF081FE-0247-4275-9C4E-021F3DC1DA35 */
    AspNetControlGuid, 
    0xaff081fe,
    0x247,
    0x4275,
    0x9c, 0x4e, 0x2, 0x1f, 0x3d, 0xc1, 0xda, 0x35
);

//
// Event guid.
//
DEFINE_GUID( /* 06A01367-79D3-4594-8EB3-C721603C4679} */
    AspNetEventGuid, 
    0x6a01367,
    0x79d3,
    0x4594,
    0x8e, 0xb3, 0xc7, 0x21, 0x60, 0x3c, 0x46, 0x79
);

//
// Event data structures
//
typedef struct _ASPNET_START_EVENT {
    EVENT_TRACE_HEADER  Header;
    HCONN               ConnId;
} ASPNET_START_EVENT, *PASPNET_START_EVENT;

typedef struct _ASPNET_STOP_EVENT {
    EVENT_TRACE_HEADER  Header;
    HCONN               ConnId;
} ASPNET_STOP_EVENT, *PASPNET_STOP_EVENT;

//
// Define this Provider's Event Types. 
//
#define ETW_TYPE_START                  0x01
#define ETW_TYPE_END                    0x02

//
// Initializes and registers our CEtwTracer object
// to be the tracer for aspnet.
//
HRESULT EtwTraceAspNetRegister() 
{
    HRESULT hr = S_OK;

    TRACE(L"ETW", L"Registering AspNetEtwTrace!");
    
    if (g_EtwTracer.Initialized()) {
        EXIT();
    }
    else {
        hr = g_EtwTracer.Register( 
            &AspNetControlGuid,
            &AspNetEventGuid,
            ISAPI_MODULE_FULL_NAME_L,
            ASPNET_RESOURCE_NAME );
    }

Cleanup:
    return hr;
}

//
// Unregisters for ETW
//
HRESULT EtwTraceAspNetUnregister() 
{
    HRESULT hr = S_OK;

    TRACE(L"ETW", L"Unregistering AspNetEtwTrace!");

    if (g_EtwTracer.Initialized()) {
        hr = g_EtwTracer.Unregister();
    }

    return hr;
}

//
// Call this to fire a ASP.NET start page event
//
HRESULT EtwTraceAspNetPageStart(HCONN ConnId)  
{
    HRESULT hr = S_OK;
    ASPNET_START_EVENT event;

    if (!g_EtwTracer.TraceEnabled())
        EXIT();
    
    RtlZeroMemory(&event, sizeof(event));
    
    event.Header.Flags      = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_GUID_PTR;
    event.Header.Size       = (USHORT)(sizeof(ASPNET_START_EVENT));
    event.Header.Class.Type = (UCHAR)ETW_TYPE_START;
    event.Header.GuidPtr    = (ULONGLONG)&AspNetEventGuid;
    event.ConnId            = ConnId;

    hr = g_EtwTracer.WriteEvent((PEVENT_TRACE_HEADER)&event);

Cleanup:
    return hr;
}

//
// Call this to fire a ASP.NET end page event
//
HRESULT EtwTraceAspNetPageEnd(HCONN ConnId) 
{
    HRESULT hr = S_OK;
    ASPNET_STOP_EVENT event;

    if (!g_EtwTracer.TraceEnabled())
        EXIT();
    
    RtlZeroMemory(&event, sizeof(event));
    
    event.Header.Flags      = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_GUID_PTR;
    event.Header.Size       = (USHORT)(sizeof(ASPNET_STOP_EVENT));
    event.Header.Class.Type = (UCHAR)ETW_TYPE_END;
    event.Header.GuidPtr    = (ULONGLONG)&AspNetEventGuid;
    event.ConnId            = ConnId;

    hr = g_EtwTracer.WriteEvent((PEVENT_TRACE_HEADER)&event);

Cleanup:
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\aspnetver.h ===
/**
 * aspnetver.h
 *
 * Header file for ASPNETVER
 * 
 * Copyright (c) 1998-2001, Microsoft Corporation
 * 
 */
#pragma once

class ASPNETVER {
public:
    ASPNETVER();
    ASPNETVER(VS_FIXEDFILEINFO *pinfo); 
    ASPNETVER(WCHAR *pchVerStr);

    static ASPNETVER& ThisVer() { return m_gThisVer; }

    BOOL    Init(WCHAR *pchVerStr);
    BOOL    Init(VS_FIXEDFILEINFO *pinfo);
    BOOL    Init(ASPNETVER *pver);
    BOOL    Init(DWORD dwMajor, DWORD dwMinor, DWORD dwBuild);
    void    Reset();

    BOOL    IsValid() { return m_fValid; }
    
    void    operator=(ASPNETVER &ver);
    BOOL    operator==(ASPNETVER &ver);
    BOOL    operator!=(ASPNETVER &ver);
    BOOL    operator>(ASPNETVER &ver);
    BOOL    operator>=(ASPNETVER &ver);
    BOOL    operator<(ASPNETVER &ver);

    BOOL    Equal(WCHAR * pchVer);
    int     ToString(WCHAR buffer[], int count);

    DWORD   Major() { return m_dwMajor; }
    DWORD   Minor() { return m_dwMinor; }
    DWORD   Build() { return m_dwBuild; }
    DWORD   QFE() { return m_dwQFE; }

private:
    DWORD   m_dwMajor;
    DWORD   m_dwMinor;
    DWORD   m_dwBuild;
    DWORD   m_dwQFE;
    
    BOOL    m_fValid;

    static  ASPNETVER   m_gThisVer;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\ackreceiver.cxx ===
/**
 * Process Model: AckReceiver defn file 
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

/////////////////////////////////////////////////////////////////////////////
// This file defines the class CAckReceiver. This class controls access of
// ASPNET_ISAPI with the sync pipe. Primary purpose of the sync pipe is to handle
// acks of requests. Secondary purpose is to allow calling EcbXXX functions
// remotely by the worker process.
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "util.h"
#include "nisapi.h"
#include "AckReceiver.h"
#include "RequestTableManager.h"
#include "ProcessEntry.h"
#include "EcbImports.h"
#include "MessageDefs.h"
#include "ProcessTableManager.h"
#include "HistoryTable.h"
#include "ecbdirect.h"

LONG g_lSecurityIssueBug129921_f = 0;
LONG g_lSecurityIssueBug129921_h = 0;
HANDLE
__stdcall
CreateUserToken (
       LPCWSTR   name, 
       LPCWSTR   password,
       BOOL      fImpersonationToken,
       LPWSTR    szError,
       int       iErrorSize);

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CTor
CAckReceiver::CAckReceiver()
    : m_lPendingReadWriteCount       (0),
      m_pProcess                     (NULL),
      m_iNumPipes                    (0),
      m_oOverlappeds                 (NULL),
      m_dwMsgSizes                   (NULL),
      m_pMsgs                        (NULL),
      m_oPipes                       (NULL)
{
}

/////////////////////////////////////////////////////////////////////////////
// Init
HRESULT
CAckReceiver::Init(
        CProcessEntry *          pProcess, 
        LPCWSTR                  szPipeName,
        LPSECURITY_ATTRIBUTES    pSA,
        int                      iNumPipes)
{    
    HRESULT  hr   = S_OK;
    WCHAR    szPipeNameAll[_MAX_PATH];   
    HANDLE   hPipe;
    int      iter;

    if (pProcess == NULL || szPipeName == NULL || iNumPipes < 1 || lstrlenW(szPipeName) > _MAX_PATH - 12)
    {
        EXIT_WITH_HRESULT(E_INVALIDARG);
    }

    m_pProcess = pProcess;

    m_oPipes = new CSmartFileHandle[iNumPipes];
    ON_OOM_EXIT(m_oPipes);

    m_oOverlappeds = new (NewClear) CAckReceiverOverlapped[iNumPipes];
    ON_OOM_EXIT(m_oOverlappeds);

    m_dwMsgSizes = new (NewClear) DWORD[iNumPipes];
    ON_OOM_EXIT(m_dwMsgSizes);

    m_pMsgs = new (NewClear) CSyncMessage * [iNumPipes];
    ON_OOM_EXIT(m_pMsgs);

    for(iter=0; iter<iNumPipes; iter++)
    {    
        m_oOverlappeds[iter].iPipeIndex = iter;
        m_oOverlappeds[iter].pCompletion = this;

        m_dwMsgSizes[iter]   = 1024;
        m_pMsgs[iter]        = (CSyncMessage *) NEW_CLEAR_BYTES(m_dwMsgSizes[iter]);
        ON_OOM_EXIT(m_pMsgs[iter]);
        
        // Construct pipe name
	StringCchCopyToArrayW(szPipeNameAll, szPipeName); // strlen of szPipeName is already checked: guarranteed to be < _MAX_PATH - 10
        int iLen = lstrlenW(szPipeNameAll);
        szPipeNameAll[iLen++] = L'_';
        _itow(iter, &szPipeNameAll[iLen], 10);

        // Create pipe
        hPipe = CreateNamedPipe(szPipeNameAll, 
                                FILE_FLAG_OVERLAPPED | PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,
                                PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, 
                                1, 1024, 1024, 1000, pSA);

        if (hPipe == INVALID_HANDLE_VALUE)
        {
            EXIT_WITH_LAST_ERROR();
        }

        // Set pipe
        m_oPipes[iter].SetHandle(hPipe);
    
        hr = AttachHandleToThreadPool (hPipe);
        ON_ERROR_EXIT();

        m_iNumPipes++;
    }

 Cleanup:
    return hr;
}   

/////////////////////////////////////////////////////////////////////////////
// DTor
CAckReceiver::~CAckReceiver()
{
    for(int iter=0; iter<m_iNumPipes; iter++)
    {    
      if (m_pMsgs[iter] != NULL)
	  DELETE_BYTES(m_pMsgs[iter]);
    }

    delete [] m_oPipes;

    delete [] m_oOverlappeds;
    delete [] m_dwMsgSizes;
    delete [] m_pMsgs;
}

/////////////////////////////////////////////////////////////////////////////
// Start reading from the pipe
HRESULT 
CAckReceiver::StartRead(DWORD dwOffset, int iPipe)
{
    HRESULT   hr                   = S_OK;
    HANDLE    hPipe                = m_oPipes[iPipe].GetHandle();
    BYTE *    pBuf                 = (BYTE *) m_pMsgs[iPipe];

    if (hPipe == INVALID_HANDLE_VALUE)
    {
        EXIT_WITH_HRESULT(E_FAIL);
    }

    m_oOverlappeds[iPipe].fWriteOperation  = FALSE;

    AddRef(); // Add Ref because we are calling ReadFile
    if (!ReadFile ( hPipe, 
                    &pBuf[dwOffset], 
                    m_dwMsgSizes[iPipe] - dwOffset, 
                    &m_oOverlappeds[iPipe].dwBytes, 
                    &m_oOverlappeds[iPipe]))
    {
        DWORD dwE = GetLastError();
        if (dwE != ERROR_IO_PENDING && dwE != ERROR_MORE_DATA)
        {
            Release(); // Release for the AddRef above
            Close();
            m_pProcess->OnProcessDied();
            EXIT_WITH_LAST_ERROR();
        }
    }


 Cleanup:
    m_oPipes[iPipe].ReleaseHandle();    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Close
void
CAckReceiver::Close()
{
    for(int iter=0; iter<m_iNumPipes; iter++)
    {    
        m_oPipes[iter].Close();
    }
}

/////////////////////////////////////////////////////////////////////////////
// IsAlive 
BOOL
CAckReceiver::IsAlive()
{
    for(int iter=0; iter<m_iNumPipes; iter++)
    {    
        if (!m_oPipes[iter].IsAlive())
            return FALSE;
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CAckReceiver::QueryInterface(REFIID iid, void **ppvObj)
{
    if (iid == IID_IUnknown || iid == __uuidof(ICompletion))
    {
        *ppvObj = this;
        AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////

ULONG
CAckReceiver::AddRef()
{
    return InterlockedIncrement(&m_lPendingReadWriteCount);
}

/////////////////////////////////////////////////////////////////////////////

ULONG
CAckReceiver::Release()
{
    return InterlockedDecrement(&m_lPendingReadWriteCount);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CAckReceiver::ProcessCompletion(HRESULT hr, int numBytes, LPOVERLAPPED pOver)
{
    CAckReceiverOverlapped * pAckOverlapped;
    int                      iPipe = -1;
    HANDLE                   hPipe;

    if (pOver == NULL)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    pAckOverlapped = reinterpret_cast<CAckReceiverOverlapped *> (pOver);
    iPipe = pAckOverlapped->iPipeIndex;
    
    if (iPipe < 0 || iPipe >= m_iNumPipes)
        EXIT_WITH_HRESULT(E_INVALIDARG);
        
    hPipe = m_oPipes[iPipe].GetHandle();

    ////////////////////////////////////////////////////////////
    // Step 0: Make sure the pipe is working
    if (hPipe == INVALID_HANDLE_VALUE) // It's closed!
    {
        if (FAILED(hr) == FALSE)
            hr = E_FAIL; // Make sure hr indicates failed
        EXIT();
    }
   
    ////////////////////////////////////////////////////////////
    // Step 1: Did the oprn succeed?
    if (hr != S_OK) // It failed: maybe the file handle was closed...
    {
        //////////////////////////////////////////////////
        // Step 1a: Get the correct error number
        DWORD dwBytes =  0;

#if DBG
        BOOL result = 
#endif

        GetOverlappedResult( hPipe, 
                             &m_oOverlappeds[iPipe], 
                             &dwBytes, 
                             FALSE);

        ASSERT(result == FALSE);


        // Special case: If it failed due to insufficient buffer,
        //    then realloc and try again
        if (GetLastError() == ERROR_MORE_DATA)
        {
            LPVOID pOld      = NULL;
            DWORD  dwReqSize = sizeof(CSyncMessage) + m_pMsgs[iPipe]->iSize;
            if (dwReqSize < m_dwMsgSizes[iPipe]) // Must not happen: indicates that the current allocated size was large enough for the message
            {
                EXIT_WITH_HRESULT(E_FAIL);
            }

            // Allocate new buffer
            CSyncMessage * pNew = (CSyncMessage *) NEW_CLEAR_BYTES(dwReqSize + 100);
            ON_OOM_EXIT(pNew);

            // Copy the old stuff
            memcpy(pNew, m_pMsgs[iPipe], m_dwMsgSizes[iPipe]);

            // Free the old
            pOld = m_pMsgs[iPipe];
            m_pMsgs[iPipe] = pNew; // Make the new buffer, the real buffer

            m_dwMsgSizes[iPipe] = dwReqSize + 100;

            // Read the rest of the message
            hr = StartRead(dwBytes, iPipe); // Retry at offset==dwBytes
            
            DELETE_BYTES(pOld);
        }

        EXIT(); // Exit on all errors
    }
 
    ////////////////////////////////////////////////////////////
    // Step 2: If it's a write completion or a ping (zero bytes), start another read
    if (pAckOverlapped->fWriteOperation == TRUE || numBytes == 0) 
    {
        // Start another read
        hr = StartRead(0, iPipe);
    }
    else
    {
        ////////////////////////////////////////////////////////
        // Step 3: Read a sync message: deal with it
        m_pProcess->NotifyHeardFromWP();
        switch(m_pMsgs[iPipe]->eType)
        {
        case ESyncMessageType_Unknown:
            ASSERT(0);
            EXIT_WITH_HRESULT(E_FAIL);
            break;

            // It's an ack for a request: Update the request table, etc
        case ESyncMessageType_Ack:
        case ESyncMessageType_GetHistory:
        case ESyncMessageType_ChangeDebugStatus:
        case ESyncMessageType_GetImpersonationToken:    
        case ESyncMessageType_GetMemoryLimit:
            hr = ProcessSyncMessage(m_pMsgs[iPipe], FALSE);
            break;

            // It's a remote call to a EcbXXX function
            //case ESyncMessageType_GetAllServerVariables:
            //case ESyncMessageType_GetServerVariable:
        case ESyncMessageType_GetAdditionalPostedContent:
        case ESyncMessageType_IsClientConnected:
        case ESyncMessageType_CloseConnection:
        case ESyncMessageType_MapUrlToPath:    
        case ESyncMessageType_GetClientCert:
        case ESyncMessageType_CallISAPI:            
            // Add it to the to-do list for this request
            hr = CRequestTableManager::AddWorkItem(m_pMsgs[iPipe]->lRequestID, EWorkItemType_SyncMessage, (BYTE *) m_pMsgs[iPipe]);
            if (hr == S_OK)
            {
                // Step 5: Tell the parent to execute the to-do list
                //         Note: Parent will free the buffer
                m_pProcess->ExecuteWorkItemsForRequest(m_pMsgs[iPipe]->lRequestID);
            }
            else
            {
                ProcessSyncMessage(m_pMsgs[iPipe], TRUE);
                hr = S_OK;
            }
        }
    }

 Cleanup:
    if (hr != S_OK)
    {
        Close(); // Close the pipe on all errors
        m_pProcess->OnProcessDied();
    }
    
    if (iPipe >= 0 && iPipe < m_iNumPipes)
        m_oPipes[iPipe].ReleaseHandle();
    Release(); // Release, because this completion impies completion of an oprn
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Deal with a message on the sync pipe
HRESULT
CAckReceiver::ProcessSyncMessage(
        CSyncMessage * pMsg,
        BOOL           fError)
{
    int            iPipe;
    HANDLE         hPipe       = INVALID_HANDLE_VALUE;
    INT_PTR        iRet        = 0;
    char *         szBuf       = NULL;
    int            iOutputSize = 0;
    HRESULT        hr          = S_OK;
    CRequestEntry  oEntry;


    for(iPipe=0; iPipe<m_iNumPipes; iPipe++)
        if (pMsg == m_pMsgs[iPipe])
        {
            hPipe = m_oPipes[iPipe].GetHandle();
            break;
        }

    if (hPipe == INVALID_HANDLE_VALUE)
        EXIT_WITH_HRESULT(E_INVALIDARG);
    
    if (fError == FALSE)  {
        ////////////////////////////////////////////////////////////
        // Step 1: See what type of message it is
        switch(m_pMsgs[iPipe]->eType)
        {
        case ESyncMessageType_Unknown:
            ASSERT(0);
            EXIT_WITH_HRESULT(E_FAIL);
            break;

        case ESyncMessageType_GetHistory:
            iOutputSize = m_pMsgs[iPipe]->iOutputSize;
            if (iOutputSize > 1000000) // Make sure output buf size is resonable
            {
                InterlockedIncrement(&g_lSecurityIssueBug129921_f);                
                EXIT_WITH_HRESULT(E_UNEXPECTED);
            }
            szBuf = new (NewClear) char [m_pMsgs[iPipe]->iOutputSize];
            ON_OOM_EXIT(szBuf);
            iRet = CHistoryTable::GetHistory((BYTE *) szBuf, m_pMsgs[iPipe]->iOutputSize);
            break;


            ////////////////////////////////////////////////////////////
            // Step 2: Deal with ack for a request: Tell the parent the good news
        case ESyncMessageType_Ack:
            if (m_pProcess->OnAckReceived((EAsyncMessageType) m_pMsgs[iPipe]->iMiscInfo, m_pMsgs[iPipe]->lRequestID) == S_OK)
            {
                iRet = m_pMsgs[iPipe]->lRequestID; // Indicates successful ack for the request
            }
            else
            {
                iRet = 0; // Indicates un-successful ack for the request
            }
            break;

        case ESyncMessageType_ChangeDebugStatus:
            m_pProcess->SetDebugStatus(PtrToInt(m_pMsgs[iPipe]->iMiscInfo));
            iRet = 1;
            break;

        case ESyncMessageType_GetMemoryLimit:            
            iRet = CProcessTableManager::GetWPMemoryLimitInMB();
            break;

            ////////////////////////////////////////////////////////////
            // Step 3: It's a remote call to a EcbXXX function
            //case ESyncMessageType_GetAllServerVariables:
            //case ESyncMessageType_GetServerVariable:
        case ESyncMessageType_GetAdditionalPostedContent:
        case ESyncMessageType_IsClientConnected:
        case ESyncMessageType_CloseConnection:
        case ESyncMessageType_MapUrlToPath:    
        case ESyncMessageType_GetClientCert:
        case ESyncMessageType_CallISAPI:
        case ESyncMessageType_GetImpersonationToken:

            ////////////////////////////////////////////////////////////
            // Step 3.1: Get the ECB pointer for this request from the request table
            iRet = 0; // iRet == 0 indicates failure
            if (CRequestTableManager::GetRequest(m_pMsgs[iPipe]->lRequestID, oEntry) != S_OK || oEntry.iECB == 0)
                break; // Can't get the request!

            ////////////////////////////////////////////////////////////
            // Step 3.2: Allocate the output string buffer from the EcbXXX function
            iOutputSize = m_pMsgs[iPipe]->iOutputSize;
            if (m_pMsgs[iPipe]->iOutputSize > 0)
            {
                if (iOutputSize > 1000000) // Make sure output buf size is resonable
                {
                    InterlockedIncrement(&g_lSecurityIssueBug129921_f);                
                    EXIT_WITH_HRESULT(E_UNEXPECTED);
                }
                szBuf = new (NewClear) char[m_pMsgs[iPipe]->iOutputSize];
                ON_OOM_EXIT(szBuf);
            }

            ////////////////////////////////////////////////////////////
            // Step 3.3: Call the appropiate EcbXXX function
            switch(m_pMsgs[iPipe]->eType)
            {
                /*
                  case ESyncMessageType_GetServerVariable:
                  iRet = EcbGetServerVariable(oEntry.iECB, 
                  (LPCSTR) m_pMsgs[iPipe]->buf, 
                  szBuf, 
                  m_pMsgs[iPipe]->iOutputSize);
                  break;
                  case ESyncMessageType_GetQueryString:
                  iRet = EcbGetQueryString(oEntry.iECB, 
                  PtrToInt(m_pMsgs[iPipe]->iMiscInfo), 
                  szBuf, 
                  m_pMsgs[iPipe]->iOutputSize);
                  break;
                */

            case ESyncMessageType_GetAdditionalPostedContent:
                iRet = EcbGetAdditionalPostedContent(oEntry.iECB, 
                                           (BYTE *) szBuf, 
                                           m_pMsgs[iPipe]->iOutputSize);
                break;

            case ESyncMessageType_IsClientConnected:
                iRet = EcbIsClientConnected(oEntry.iECB);
                break;

            case ESyncMessageType_CloseConnection:
                iRet = EcbCloseConnection(oEntry.iECB);
                break;

            case ESyncMessageType_MapUrlToPath:    
                // Make sure m_pMsgs[iPipe]->buf is valid
                if (SafeStringLenghtA((LPCSTR) m_pMsgs[iPipe]->buf, m_dwMsgSizes[iPipe] - sizeof(CSyncMessage)) < 0)
                {
                    ASSERT(FALSE);
                    InterlockedIncrement(&g_lSecurityIssueBug129921_h);
                    EXIT_WITH_HRESULT(E_UNEXPECTED);
                }
                iRet = EcbMapUrlToPath(oEntry.iECB, 
                                       (LPCSTR) m_pMsgs[iPipe]->buf, 
                                       szBuf, 
                                       m_pMsgs[iPipe]->iOutputSize);
                break;

            case ESyncMessageType_GetImpersonationToken:    
                iRet = (INT_PTR) m_pProcess->OnGetImpersonationToken((DWORD) m_pMsgs[iPipe]->iMiscInfo, oEntry.iECB);
                break;

                /*
                  case ESyncMessageType_GetAllServerVariables:    
                  iRet = GetAllServerVariables(oEntry.iECB, szBuf, m_pMsgs[iPipe]->iOutputSize);
                  break;
                */

            case ESyncMessageType_GetClientCert:
                if (m_pMsgs[iPipe]->iOutputSize >= 32)
                {
                    iRet = EcbGetClientCertificate(
                            oEntry.iECB, 
                            &szBuf[32], 
                            m_pMsgs[iPipe]->iOutputSize-32,
                            (int *)     (&szBuf[0]),
                            (__int64 *) (&szBuf[16]));
                }
                else
                {
                    iRet = 0;
                }
                break;

            case ESyncMessageType_CallISAPI:
                if (PtrToInt(m_pMsgs[iPipe]->iMiscInfo) == CallISAPIFunc_GenerateToken)
                {
                    LPWSTR  szName   = NULL;
                    LPWSTR  szPass   = NULL;
                    HANDLE  hTok     = NULL;
                    HANDLE  hToken   = NULL;

                    iRet = 0;
                    if (m_pMsgs[iPipe]->iOutputSize < sizeof(HANDLE))
                        break;
                    szName   = (LPWSTR) m_pMsgs[iPipe]->buf;
                    szName[m_pMsgs[iPipe]->iSize/sizeof(WCHAR)-1] = NULL;                    
                    szPass   = wcschr(szName, L'\t');
                    if (szPass == NULL)
                        break;

                    szPass[0] = NULL;
                    szPass++;
                    hTok = CreateUserToken(szName, szPass, TRUE, NULL, 0);
                    if (hTok == NULL || hTok == INVALID_HANDLE_VALUE)
                        break;
                    hToken = m_pProcess->ConvertToken(hTok);
                    if (hToken == NULL || hToken == INVALID_HANDLE_VALUE)
                        break;
                    iRet = 1;
                    for(int iByte=sizeof(HANDLE)-1; iByte>=0; iByte--)
                    {
                        szBuf[iByte] = (BYTE) (__int64(hToken) & 0xFF);
                        hToken = (HANDLE) (__int64(hToken) >> 8);
                    }
                }
                else
                {
                    iRet = EcbCallISAPI(oEntry.iECB, 
                                        PtrToInt(m_pMsgs[iPipe]->iMiscInfo),
                                        m_pMsgs[iPipe]->buf,
                                        m_pMsgs[iPipe]->iSize,
                                        (LPBYTE) szBuf,
                                        m_pMsgs[iPipe]->iOutputSize);
                }
                break;

            case ESyncMessageType_GetHistory:
            case ESyncMessageType_Ack:
            case ESyncMessageType_Unknown:
            case ESyncMessageType_GetAllServerVariables:
            case ESyncMessageType_GetServerVariable:
            case ESyncMessageType_ChangeDebugStatus:
            case ESyncMessageType_GetMemoryLimit:            
            default:
                ASSERT(0);
                break;
            } // end of inner switch
        } // end of outer switch
    }
    else { // if fError == TRUE
        iOutputSize = m_pMsgs[iPipe]->iOutputSize;        
        iRet = 0;
    }

    ////////////////////////////////////////////////////////////
    // Step 4: Create the output message
    if (int(iOutputSize) > int(m_dwMsgSizes[iPipe]) - int(sizeof(CSyncMessage)))
    {   // If the buffer size for output is larger than the size of
        // the current sync message, alloc a new sync message buffer
        DWORD dwReqSize = sizeof(CSyncMessage) + iOutputSize;
        DELETE_BYTES(m_pMsgs[iPipe]);

        m_dwMsgSizes[iPipe] = dwReqSize + 100;
        m_pMsgs[iPipe]      = (CSyncMessage *) NEW_CLEAR_BYTES(m_dwMsgSizes[iPipe]);

        ON_OOM_EXIT(m_pMsgs[iPipe]);
    }
    else
    {   // If the output message will fit the current sync message,
        //  then just zero it
        ZeroMemory(m_pMsgs[iPipe], m_dwMsgSizes[iPipe]);
    }


    ////////////////////////////////////////////////////////////
    // Step 5: Fill the output message
    m_pMsgs[iPipe]->iMiscInfo = iRet; // the function return code

    if (szBuf != NULL && iOutputSize > 0)
    { // the output buffer
        memcpy(m_pMsgs[iPipe]->buf, szBuf, iOutputSize);                
        m_pMsgs[iPipe]->iSize = iOutputSize;
    }

    if (szBuf != NULL)
    {
        delete [] szBuf;
        szBuf = NULL;
    }


    ////////////////////////////////////////////////////////////
    // Step 6: Write the message to the pipe
    m_oOverlappeds[iPipe].fWriteOperation = TRUE;
    
    AddRef(); // AddRef for this WriteFile call
    if (! WriteFile ( hPipe, 
                      m_pMsgs[iPipe], 
                      sizeof(CSyncMessage)+iOutputSize, 
                      &m_oOverlappeds[iPipe].dwBytes, 
                      &m_oOverlappeds[iPipe]))
    {
        if (GetLastError() != ERROR_IO_PENDING)
        {   // Failed to call WriteFile
            Release(); // Release for this write file            
            EXIT_WITH_LAST_ERROR();
        }
    }

    ////////////////////////////////////////////////////////////
    // Done
 Cleanup:
    if (hr != S_OK)
    {
        Close(); // Close the pipe on all errors
        m_pProcess->OnProcessDied();
    }

    if (iPipe < m_iNumPipes && iPipe >= 0)
        m_oPipes[iPipe].ReleaseHandle();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\aspcompat.h ===
/**
 * Support for ASP Compat Request execution
 * 
 * Copyright (c) 2000, Microsoft Corporation
 * 
 */

#pragma once

#include "util.h"
#include "nisapi.h"

#include <asptlb.h>
#include <mtxpriv.h>

//////////////////////////////////////////////////////////////////////////////
//
// Typedef for delegates to call back to managed code
//

typedef void (__stdcall *PFN_ASPCOMPAT_CB)();

//
// Entrypoints from managed code called via PInvoke
//

int __stdcall AspCompatProcessRequest(PFN_ASPCOMPAT_CB callback, IUnknown *pAspCompatContext);
int __stdcall AspCompatFinishRequest(PFN_ASPCOMPAT_CB callback);
int __stdcall AspCompatOnPageStart(IUnknown *pComponent);

//////////////////////////////////////////////////////////////////////////////
//
// Interface used for interop to talk to managed intrinsics.
// Implemented by the mananged context
//

struct __declspec(uuid("a1cca730-0e36-4870-aa7d-ca39c211f99d")) IManagedContext;

#define REQUESTSTRING_QUERYSTRING   1
#define REQUESTSTRING_FORM          2
#define REQUESTSTRING_COOKIES       3
#define REQUESTSTRING_SERVERVARS    4

// interface for interop calls back into managed code
struct IManagedContext : IUnknown {

    virtual HRESULT __stdcall Application_Lock() = 0;
    virtual HRESULT __stdcall Application_UnLock() = 0;
    virtual HRESULT __stdcall Application_GetContentsNames(BSTR *result) = 0;
    virtual HRESULT __stdcall Application_GetStaticNames(BSTR *result) = 0;
    virtual HRESULT __stdcall Application_GetContentsObject(BSTR name, VARIANT *pVar) = 0;
    virtual HRESULT __stdcall Application_SetContentsObject(BSTR name, VARIANT var) = 0;
    virtual HRESULT __stdcall Application_RemoveContentsObject(BSTR name) = 0;
    virtual HRESULT __stdcall Application_RemoveAllContentsObjects() = 0;
    virtual HRESULT __stdcall Application_GetStaticObject(BSTR name, VARIANT *pVar) = 0;

    virtual HRESULT __stdcall Request_GetAsString(int what, BSTR *result) = 0;
    virtual HRESULT __stdcall Request_GetCookiesAsString(BSTR *result) = 0;
    virtual HRESULT __stdcall Request_GetTotalBytes(int *pResult) = 0;
    virtual HRESULT __stdcall Request_BinaryRead(void *pData, int size, int *pCount) = 0;

    virtual HRESULT __stdcall Response_GetCookiesAsString(BSTR *result) = 0;
    virtual HRESULT __stdcall Response_AddCookie(BSTR name) = 0;
    virtual HRESULT __stdcall Response_SetCookieText(BSTR name, BSTR text) = 0;
    virtual HRESULT __stdcall Response_SetCookieSubValue(BSTR name, BSTR key, BSTR value) = 0;
    virtual HRESULT __stdcall Response_SetCookieExpires(BSTR name, double dtExpires) = 0;
    virtual HRESULT __stdcall Response_SetCookieDomain(BSTR name, BSTR domain) = 0;
    virtual HRESULT __stdcall Response_SetCookiePath(BSTR name, BSTR path) = 0;
    virtual HRESULT __stdcall Response_SetCookieSecure(BSTR name, int secure) = 0;
    virtual HRESULT __stdcall Response_Write(BSTR text) = 0;
    virtual HRESULT __stdcall Response_BinaryWrite(void *pData, int size) = 0;
    virtual HRESULT __stdcall Response_Redirect(BSTR bstrURL) = 0;
    virtual HRESULT __stdcall Response_AddHeader(BSTR bstrHeaderName, BSTR bstrHeaderValue) = 0;
    virtual HRESULT __stdcall Response_Pics(BSTR bstrHeaderValue) = 0;
    virtual HRESULT __stdcall Response_Clear() = 0;
    virtual HRESULT __stdcall Response_Flush() = 0;
    virtual HRESULT __stdcall Response_End() = 0;
    virtual HRESULT __stdcall Response_AppendToLog(BSTR bstrLogEntry) = 0;
    virtual HRESULT __stdcall Response_GetContentType(BSTR *pbstrContentTypeRet) = 0;
    virtual HRESULT __stdcall Response_SetContentType(BSTR bstrContentType) = 0;
    virtual HRESULT __stdcall Response_GetCharSet(BSTR *pbstrContentTypeRet) = 0;
    virtual HRESULT __stdcall Response_SetCharSet(BSTR bstrContentType) = 0;
    virtual HRESULT __stdcall Response_GetCacheControl(BSTR *pbstrCacheControl) = 0;
    virtual HRESULT __stdcall Response_SetCacheControl(BSTR bstrCacheControl) = 0;	
    virtual HRESULT __stdcall Response_GetStatus(BSTR *pbstrStatusRet) = 0;	
    virtual HRESULT __stdcall Response_SetStatus(BSTR bstrStatus) = 0;
    virtual HRESULT __stdcall Response_GetExpiresMinutes(int *pExpiresMinutesRet) = 0;
    virtual HRESULT __stdcall Response_SetExpiresMinutes(int expiresMinutes) = 0;
    virtual HRESULT __stdcall Response_GetExpiresAbsolute(double *pdtExpires) = 0;
    virtual HRESULT __stdcall Response_SetExpiresAbsolute(double dtExpires) = 0;
    virtual HRESULT __stdcall Response_GetIsBuffering(int *pfIsBuffering) = 0;
    virtual HRESULT __stdcall Response_SetIsBuffering(int fIsBuffering) = 0;
    virtual HRESULT __stdcall Response_IsClientConnected(int *fIsConnected) = 0;

    virtual HRESULT __stdcall Server_CreateObject(BSTR bstr, IUnknown **ppObject) = 0;
    virtual HRESULT __stdcall Server_MapPath(BSTR bstrLogicalPath, BSTR *pbstrPhysicalPath) = 0;
    virtual HRESULT __stdcall Server_HTMLEncode(BSTR bstrIn, BSTR *pbstrEncoded) = 0;
    virtual HRESULT __stdcall Server_URLEncode(BSTR bstrIn, BSTR *pbstrEncoded) = 0;
    virtual HRESULT __stdcall Server_URLPathEncode(BSTR bstrIn, BSTR *pbstrEncoded) = 0;
    virtual HRESULT __stdcall Server_GetScriptTimeout(int *pTimeoutSeconds) = 0;
    virtual HRESULT __stdcall Server_SetScriptTimeout(int timeoutSeconds) = 0;
    virtual HRESULT __stdcall Server_Execute(BSTR bstrURL) = 0;
    virtual HRESULT __stdcall Server_Transfer(BSTR bstrURL) = 0;

    virtual HRESULT __stdcall Session_IsPresent(int *pValue) = 0;
    virtual HRESULT __stdcall Session_GetID(BSTR *pID) = 0;
    virtual HRESULT __stdcall Session_GetTimeout(int *pValue) = 0;
    virtual HRESULT __stdcall Session_SetTimeout(int value) = 0;
    virtual HRESULT __stdcall Session_GetCodePage(int *pValue) = 0;
    virtual HRESULT __stdcall Session_SetCodePage(int value) = 0;
    virtual HRESULT __stdcall Session_GetLCID(int *pValue) = 0;
    virtual HRESULT __stdcall Session_SetLCID(int value) = 0;
    virtual HRESULT __stdcall Session_Abandon() = 0;
    virtual HRESULT __stdcall Session_GetContentsNames(BSTR *result) = 0;
    virtual HRESULT __stdcall Session_GetStaticNames(BSTR *result) = 0;
    virtual HRESULT __stdcall Session_GetContentsObject(BSTR name, VARIANT *pVar) = 0;
    virtual HRESULT __stdcall Session_SetContentsObject(BSTR name, VARIANT var) = 0;
    virtual HRESULT __stdcall Session_RemoveContentsObject(BSTR name) = 0;
    virtual HRESULT __stdcall Session_RemoveAllContentsObjects() = 0;
    virtual HRESULT __stdcall Session_GetStaticObject(BSTR name, VARIANT *pVar) = 0;
};

//////////////////////////////////////////////////////////////////////////////
//
// Helper class to aggregate FTM
//

class FtmHelper {

private:
    long                _refs;
    CReadWriteSpinLock  _lock;
    IUnknown           *_pFtm;

public:
    FtmHelper() : _lock("FtmHelper") {}
    ~FtmHelper() { ReleaseInterface(_pFtm); }

    HRESULT QueryInterface(IUnknown *pObject, REFIID iid, void **ppvObj);
};

//////////////////////////////////////////////////////////////////////////////
//
// Forward declarations
//

class AspCompatApplication;
class AspCompatApplicationDictionary;
class AspCompatApplicationSessionDictionaryBase;
class AspCompatReadCookie;
class AspCompatRequest;
class AspCompatRequestDictionary;
class AspCompatResponse;
class AspCompatResponseCookies;
class AspCompatScriptingContext;
class AspCompatServer;
class AspCompatSession;
class AspCompatSessionDictionary;
class AspCompatStringList;
class AspCompatStringListEnum;
class AspCompatVariantDictionary;
class AspCompatVariantDictionaryEnum;
class AspCompatWriteCookie;

//////////////////////////////////////////////////////////////////////////////
//
// Access to ASP type library
//

HRESULT GetAspTypeLibrary(ITypeLib **ppTypeLib);

//
// Helper class to provide IDispatch implementation for ASP intrinsics
//

class AspDispatchHelper {

private:
    CReadWriteSpinLock  _lock;
    ITypeInfo          *_pAspTypeInfo;
public:
    IID                 _aspIID;

private:
    HRESULT GetTypeInfoInternal();

public:
    AspDispatchHelper() : _lock("AspDispatchHelper") {}
    ~AspDispatchHelper() { ReleaseInterface(_pAspTypeInfo); }

    HRESULT GetTypeInfoCount(UINT FAR* pctinfo);
    HRESULT GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    HRESULT GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid);
    HRESULT Invoke(IDispatch *pObject, DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);
};

//////////////////////////////////////////////////////////////////////////////
//
// AspCompatAsyncCall -- encapsulated single request execution via ASP Compat mode
//

class AspCompatObjectWrapper { // to call OnStartPage / OnEndPage

    friend class AspCompatAsyncCall;

private:
    LIST_ENTRY _listEntry;
    IDispatch *_pObject;
    DISPID _startId;
    DISPID _endId;

public:
    AspCompatObjectWrapper(IDispatch *pObject, DISPID startId, DISPID endId) {
        _pObject = pObject;
        _pObject->AddRef();
        _startId = startId;
        _endId = endId;
    }

    ~AspCompatObjectWrapper() {
        ReleaseInterface(_pObject);
    }

    HRESULT CallOnPageStart(IDispatch *pContext);
    HRESULT CallOnPageEnd();
};

class AspCompatAsyncCall : public IMTSCall {

private:
    long                        _refs;
    FtmHelper                   _ftmHelper;
    PFN_ASPCOMPAT_CB            _callback;
    IManagedContext            *_pManagedContext;
    IMTSActivity               *_pActivity;
    AspCompatScriptingContext  *_pScriptingContext;
    LIST_ENTRY                  _objectWrappersList;

    static HRESULT AddContextProperty(IContextProperties *pCP, LPWSTR pName, IDispatch *pIntrinsic);
    static HRESULT GetContextProperty(LPWSTR pName, IDispatch **pIntrinsic);

public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    AspCompatAsyncCall(PFN_ASPCOMPAT_CB callback, IManagedContext *pManagedContext);
    ~AspCompatAsyncCall();

    STDMETHOD(QueryInterface)(REFIID, void **);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

	STDMETHOD(OnCall)();

    HRESULT Post();

    HRESULT OnPageStart(IDispatch *pComponent);
    HRESULT OnPageEnd();

    IManagedContext *ManagedContext() { return _pManagedContext; }

    static HRESULT GetCurrent(AspCompatAsyncCall **ppCurrent);

    HRESULT ResetRequestCoookies();
};

//////////////////////////////////////////////////////////////////////////////
//
// Template for classes representing ASP Intrinsics
//

template <class IAspIntrinsic>
class AspCompatIntrinsic : public IAspIntrinsic {

private:
    long                        _refs;
    FtmHelper                   _ftmHelper;
    AspDispatchHelper           _dispatchHelper;

public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    // ctor

    AspCompatIntrinsic() {
        _refs = 1;
        _dispatchHelper._aspIID = __uuidof(IAspIntrinsic);
    }

    virtual ~AspCompatIntrinsic() {
    }

    // IUnknown implementation

    STDMETHOD(QueryInterface)(REFIID iid, void **ppvObj) {
        if (iid == IID_IUnknown || iid == IID_IDispatch || iid == _dispatchHelper._aspIID) {
            AddRef();
            *ppvObj = this;
            return S_OK;
        }
        else if (iid == IID_IMarshal) {
            return _ftmHelper.QueryInterface(this, iid, ppvObj);
        }
        else {
            return E_NOINTERFACE;
        }
    }

    STDMETHOD_(ULONG, AddRef)() {
        return InterlockedIncrement(&_refs);
    }

    STDMETHOD_(ULONG, Release)() {
        long r = InterlockedDecrement(&_refs);
        if (r == 0) {
            delete this;
            return 0;
        }
        return r;
    }

    // IDispatch implementation

	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo) {
        return _dispatchHelper.GetTypeInfoCount(pctinfo);
	}

	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo) {
		return _dispatchHelper.GetTypeInfo(itinfo, lcid, pptinfo);
	}

    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid) {
		return _dispatchHelper.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
	}

    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr) {
        return _dispatchHelper.Invoke(this, dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
	}
};

typedef AspCompatIntrinsic<IApplicationObject>   AspCompatApplicationBase;
typedef AspCompatIntrinsic<IReadCookie>          AspCompatReadCookieBase;
typedef AspCompatIntrinsic<IRequest>             AspCompatRequestBase;
typedef AspCompatIntrinsic<IRequestDictionary>   AspCompatRequestDictionaryBase;
typedef AspCompatIntrinsic<IResponse>            AspCompatResponseBase;
typedef AspCompatIntrinsic<IScriptingContext>    AspCompatScriptingContextBase;
typedef AspCompatIntrinsic<IServer>              AspCompatServerBase;
typedef AspCompatIntrinsic<ISessionObject>       AspCompatSessionBase;
typedef AspCompatIntrinsic<IStringList>          AspCompatStringListBase;
typedef AspCompatIntrinsic<IVariantDictionary>   AspCompatVariantDictionaryBase;
typedef AspCompatIntrinsic<IWriteCookie>         AspCompatWriteCookieBase;

//////////////////////////////////////////////////////////////////////////////
//
// AspCompatScriptingContext -- IScriptingContext holding on to intrinsics
//

class AspCompatScriptingContext : public AspCompatScriptingContextBase {

    friend class AspCompatAsyncCall;

private:
    AspCompatApplication *_pApplication;
    AspCompatSession     *_pSession;
    AspCompatRequest     *_pRequest;
    AspCompatResponse    *_pResponse;
    AspCompatServer      *_pServer;

public:
    AspCompatScriptingContext();
    virtual ~AspCompatScriptingContext();

    HRESULT CreateIntrinsics(AspCompatAsyncCall *pAsyncCallContext, BOOL sessionNeeded);

    STDMETHOD(QueryInterface)(REFIID, void **);

	STDMETHODIMP get_Request(IRequest **ppRequest);
	STDMETHODIMP get_Response(IResponse **ppResponse);
	STDMETHODIMP get_Server(IServer **ppServer);
	STDMETHODIMP get_Session(ISessionObject **ppSession);
	STDMETHODIMP get_Application(IApplicationObject **ppApplication);
};

//////////////////////////////////////////////////////////////////////////////
//
// Other ASP compat intrinsics classes
//

class AspCompatApplication : public AspCompatApplicationBase {

    friend class AspCompatAsyncCall;

private:
    AspCompatAsyncCall *_pCall;
    AspCompatApplicationDictionary *_pContents;
    AspCompatApplicationDictionary *_pStaticObjects;

public:
    AspCompatApplication(AspCompatAsyncCall *pCall);
    virtual ~AspCompatApplication();

    STDMETHODIMP Lock();
    STDMETHODIMP UnLock();
    STDMETHODIMP get_Value(BSTR bstr, VARIANT *pvar);
    STDMETHODIMP put_Value(BSTR bstr, VARIANT var);
    STDMETHODIMP putref_Value(BSTR bstr, VARIANT var);
    STDMETHODIMP get_Contents(IVariantDictionary **ppDictReturn);
    STDMETHODIMP get_StaticObjects(IVariantDictionary **ppDictReturn);
};

class AspCompatReadCookie : public AspCompatReadCookieBase {

    friend class AspCompatRequest;

private:
    BOOL _hasKeys;
    BSTR _bstrTextValue;
    AspCompatVariantDictionary *_pDict; // for many values

    HRESULT Init(BOOL hasKeys, LPWSTR pTextValue);
    HRESULT AddKeyValuePair(LPWSTR pKey, LPWSTR pValue);

public:
    AspCompatReadCookie();
    virtual ~AspCompatReadCookie();

 	STDMETHODIMP get_Item(VARIANT i, VARIANT *pVariantReturn);
	STDMETHODIMP get_HasKeys(VARIANT_BOOL *pfHasKeys);
	STDMETHODIMP get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP get_Count(int *pcValues);
	STDMETHODIMP get_Key(VARIANT VarKey, VARIANT *pvar);
};

class AspCompatRequest : public AspCompatRequestBase {

    friend class AspCompatAsyncCall;

private:
    AspCompatAsyncCall *_pCall;
    AspCompatRequestDictionary *_pQueryString;
    AspCompatRequestDictionary *_pForm;
    AspCompatRequestDictionary *_pCookies;
    AspCompatRequestDictionary *_pServerVars;
    BOOL _cookiesReset;

    HRESULT CreateRequestDictionary(int what, AspCompatRequestDictionary **ppDict);
    HRESULT FillInCookiesDictionary();
    HRESULT ResetCookies();

public:
    AspCompatRequest(AspCompatAsyncCall *pCall);
    virtual ~AspCompatRequest();

	STDMETHODIMP get_Item(BSTR bstrVar, IDispatch **ppDispReturn);
	STDMETHODIMP get_QueryString(IRequestDictionary **ppDictReturn);
	STDMETHODIMP get_Form(IRequestDictionary **ppDictReturn);
	STDMETHODIMP get_Body(IRequestDictionary **ppDictReturn);
	STDMETHODIMP get_ServerVariables(IRequestDictionary **ppDictReturn);
	STDMETHODIMP get_ClientCertificate(IRequestDictionary **ppDictReturn);
	STDMETHODIMP get_Cookies(IRequestDictionary **ppDictReturn);
	STDMETHODIMP get_TotalBytes(long *pcbTotal);
	STDMETHODIMP BinaryRead(VARIANT *pvarCount, VARIANT *pvarReturn);
};

class AspCompatRequestDictionary : public AspCompatRequestDictionaryBase {

    friend class AspCompatRequest;
    friend class AspCompatResponse;

private:
    AspCompatVariantDictionary *_pDict;
    IDispatch *_pEmptyValue; // instead of empty variant when returning not found value
    BSTR       _bstrDefault; // default property when get_Item invoked with VT_ERROR

protected:
    HRESULT Add(LPWSTR pKey, IDispatch *pValue);
	HRESULT Get(VARIANT Var, IDispatch **ppDisp);

public:
    AspCompatRequestDictionary();
    virtual ~AspCompatRequestDictionary();

    HRESULT Init(IDispatch *pEmptyValue, BSTR bstrDefault);
    HRESULT Clear();

	STDMETHODIMP get_Item(VARIANT Var, VARIANT *pVariantReturn);
	STDMETHODIMP get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP get_Count(int *pcValues);
	STDMETHODIMP get_Key(VARIANT VarKey, VARIANT *pvar);
};

class AspCompatResponse : public AspCompatResponseBase {

    friend class AspCompatAsyncCall;

private:
    AspCompatAsyncCall *_pCall;
    AspCompatResponseCookies *_pCookies;

    HRESULT FillInCookiesDictionary();

public:
    AspCompatResponse(AspCompatAsyncCall *pCall);
    virtual ~AspCompatResponse();

	STDMETHODIMP Write(VARIANT varInput);
	STDMETHODIMP BinaryWrite(VARIANT varInput);
	STDMETHODIMP WriteBlock(short iBlockNumber);
	STDMETHODIMP Redirect(BSTR bstrURL);
	STDMETHODIMP AddHeader(BSTR bstrHeaderName, BSTR bstrHeaderValue);
	STDMETHODIMP Pics(BSTR bstrHeaderValue);	
	STDMETHODIMP Add(BSTR bstrHeaderValue, BSTR bstrHeaderName);
	STDMETHODIMP Clear();
	STDMETHODIMP Flush();
	STDMETHODIMP End();
	STDMETHODIMP AppendToLog(BSTR bstrLogEntry);
	STDMETHODIMP get_ContentType(BSTR *pbstrContentTypeRet);
	STDMETHODIMP put_ContentType(BSTR bstrContentType);
	STDMETHODIMP get_CharSet(BSTR *pbstrContentTypeRet);
	STDMETHODIMP put_CharSet(BSTR bstrContentType);
	STDMETHODIMP get_CacheControl(BSTR *pbstrCacheControl);
	STDMETHODIMP put_CacheControl(BSTR bstrCacheControl);	
	STDMETHODIMP get_Status(BSTR *pbstrStatusRet);	
	STDMETHODIMP put_Status(BSTR bstrStatus);
	STDMETHODIMP get_Expires(VARIANT *pvarExpiresMinutesRet);
	STDMETHODIMP put_Expires(long lExpiresMinutes);
	STDMETHODIMP get_ExpiresAbsolute(VARIANT *pvarTimeRet);
	STDMETHODIMP put_ExpiresAbsolute(DATE dtExpires);
	STDMETHODIMP get_Buffer(VARIANT_BOOL* fIsBuffering);
	STDMETHODIMP put_Buffer(VARIANT_BOOL fIsBuffering);
	STDMETHODIMP get_Cookies(IRequestDictionary **ppDictReturn);
	STDMETHODIMP IsClientConnected(VARIANT_BOOL* fIsBuffering);
};

class AspCompatResponseCookies : public AspCompatRequestDictionary {

    friend class AspCompatResponse;

private:
    AspCompatAsyncCall *_pCall;

    HRESULT ResetRequestCookies();
    
public:
    AspCompatResponseCookies(AspCompatAsyncCall *pCall);
    virtual ~AspCompatResponseCookies();

    // get creates response cookie on demand when not found
	STDMETHODIMP get_Item(VARIANT var, VARIANT *pVarReturn);
};

class AspCompatServer : public AspCompatServerBase {

    friend class AspCompatAsyncCall;

private:
    AspCompatAsyncCall *_pCall;

public:
    AspCompatServer(AspCompatAsyncCall *pCall);
    virtual ~AspCompatServer();

	STDMETHODIMP CreateObject(BSTR bstr, IDispatch **ppdispObject);
	STDMETHODIMP MapPath(BSTR bstrLogicalPath, BSTR *pbstrPhysicalPath);
	STDMETHODIMP HTMLEncode(BSTR bstrIn, BSTR *pbstrEncoded);
	STDMETHODIMP URLEncode(BSTR bstrIn, BSTR *pbstrEncoded);
	STDMETHODIMP URLPathEncode(BSTR bstrIn, BSTR *pbstrEncoded);
	STDMETHODIMP get_ScriptTimeout(long * plTimeoutSeconds);
	STDMETHODIMP put_ScriptTimeout(long lTimeoutSeconds);		
	STDMETHODIMP Execute(BSTR bstrURL);
	STDMETHODIMP Transfer(BSTR bstrURL);
	STDMETHODIMP GetLastError(IASPError **ppASPErrorObject);
};

class AspCompatSession : public AspCompatSessionBase {

    friend class AspCompatAsyncCall;

private:
    AspCompatAsyncCall *_pCall;
    AspCompatSessionDictionary *_pContents;
    AspCompatSessionDictionary *_pStaticObjects;

public:
    AspCompatSession(AspCompatAsyncCall *pCall);
    virtual ~AspCompatSession();

	STDMETHODIMP get_SessionID(BSTR *pbstrRet);
	STDMETHODIMP get_Timeout(long *plVar);
	STDMETHODIMP put_Timeout(long lVar);
	STDMETHODIMP get_CodePage(long *plVar);
	STDMETHODIMP put_CodePage(long lVar);
	STDMETHODIMP get_Value(BSTR bstr, VARIANT FAR * pvar);
	STDMETHODIMP put_Value(BSTR bstr, VARIANT var);
	STDMETHODIMP putref_Value(BSTR bstr, VARIANT var);
	STDMETHODIMP Abandon();
	STDMETHODIMP get_LCID(long *plVar);
	STDMETHODIMP put_LCID(long lVar);
	STDMETHODIMP get_StaticObjects(IVariantDictionary **ppDictReturn);
	STDMETHODIMP get_Contents(IVariantDictionary **ppDictReturn);
};

class AspCompatStringList : public AspCompatStringListBase {

    friend class AspCompatStringListEnum;
    friend class AspCompatRequest;

private:
    int      _count;
    int      _size;
    BSTR    *_pStrings;

    HRESULT SizeTo(int newSize);
    HRESULT Add(LPWSTR pStr);
    HRESULT GetDefaultProperty(VARIANT *pvarOut);

public:
    AspCompatStringList();
    virtual ~AspCompatStringList();

	STDMETHODIMP get_Item(VARIANT varIndex, VARIANT *pvarOut);
	STDMETHODIMP get_Count(int *pcValues);
	STDMETHODIMP get__NewEnum(IUnknown **ppEnum);
};

class AspCompatStringListEnum : public IEnumVARIANT {

private:
    int _refs;
    int _index;
    AspCompatStringList *_pList;

public:
    AspCompatStringListEnum(AspCompatStringList *pList);
    ~AspCompatStringListEnum();

	STDMETHODIMP         QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	STDMETHODIMP Clone(IEnumVARIANT **ppEnumReturn);
	STDMETHODIMP Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched);
	STDMETHODIMP Skip(unsigned long cElements);
	STDMETHODIMP Reset();
};

class AspCompatVariantDictionary : public AspCompatVariantDictionaryBase {

    friend class AspCompatVariantDictionaryEnum;

private:
    int      _count;
    int      _size;
    VARIANT *_pVars;
    BSTR    *_pKeys;

protected:
    void    Clear();
    int     Find(BSTR bstrKey);
    HRESULT SizeTo(int newSize);
    HRESULT Get(BSTR bstrKey, VARIANT *pValue);
    HRESULT Get(int index, VARIANT *pValue);
    HRESULT GetKey(BSTR bstrKey, VARIANT *pValue);
    HRESULT GetKey(int index, VARIANT *pValue);
    HRESULT GetKey(int index, BSTR *pbstrKey);
    HRESULT Set(BSTR bstrKey, VARIANT value, BOOL deref, int *pIndex);
    HRESULT Set(int index, VARIANT value, BOOL deref);
    HRESULT Put(VARIANT varKey, VARIANT varValue, BOOL deref, int *pIndex);
    HRESULT Remove(BSTR bstrKey);
    HRESULT Remove(int index);
	HRESULT Remove(VARIANT varKey, BSTR *pbstrName);

public:
    AspCompatVariantDictionary();
    virtual ~AspCompatVariantDictionary();

    STDMETHODIMP get_Item(VARIANT Var, VARIANT *pvar);
    STDMETHODIMP put_Item(VARIANT varKey, VARIANT var);
    STDMETHODIMP putref_Item(VARIANT varKey, VARIANT var);
    STDMETHODIMP get_Key(VARIANT Var, VARIANT *pvar);
    STDMETHODIMP get__NewEnum(IUnknown **ppEnumReturn);
    STDMETHODIMP get_Count(int *pcValues);
	STDMETHODIMP Remove(VARIANT VarKey);
	STDMETHODIMP RemoveAll();
};

class AspCompatVariantDictionaryEnum : public IEnumVARIANT {

private:
    int _refs;
    int _index;
    AspCompatVariantDictionary *_pDict;

public:
    AspCompatVariantDictionaryEnum(AspCompatVariantDictionary *pDict);
    ~AspCompatVariantDictionaryEnum();

	STDMETHODIMP         QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	STDMETHODIMP Clone(IEnumVARIANT **ppEnumReturn);
	STDMETHODIMP Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched);
	STDMETHODIMP Skip(unsigned long cElements);
	STDMETHODIMP Reset();
};

// base class for app and session dictionaries defers managed updates to derived classes
class AspCompatApplicationSessionDictionaryBase : public AspCompatVariantDictionary {
    
    friend class AspCompatApplication;
    friend class AspCompatSession;

private:
    AspCompatAsyncCall *_pCall;
    BOOL _readonly;

    HRESULT PutItem(VARIANT varKey, VARIANT var, BOOL deref);

    HRESULT FillIn(BSTR names);

public:
    AspCompatApplicationSessionDictionaryBase(AspCompatAsyncCall *pCall, BOOL readonly);
    virtual ~AspCompatApplicationSessionDictionaryBase();

    // overrides for dictionary methods that require synchronization with managed code
    STDMETHODIMP put_Item(VARIANT varKey, VARIANT var);
    STDMETHODIMP putref_Item(VARIANT varKey, VARIANT var);
	STDMETHODIMP Remove(VARIANT VarKey);
	STDMETHODIMP RemoveAll();

    // implemented by derived class
    virtual HRESULT GetContentsObject(IManagedContext *pContext, BSTR name, VARIANT *pVariant) = 0;
    virtual HRESULT GetStaticObject(IManagedContext *pContext, BSTR name, VARIANT *pVariant) = 0;
    virtual HRESULT OnAdd(IManagedContext *pContext, BSTR name, VARIANT value) = 0;
    virtual HRESULT OnRemove(IManagedContext *pContext, BSTR name) = 0;
    virtual HRESULT OnRemoveAll(IManagedContext *pContext) = 0;
};

class AspCompatApplicationDictionary : public AspCompatApplicationSessionDictionaryBase {
    
    friend class AspCompatApplication;

public:
    AspCompatApplicationDictionary(AspCompatAsyncCall *pCall, BOOL readonly) 
        : AspCompatApplicationSessionDictionaryBase(pCall, readonly) {
    }

    virtual HRESULT GetContentsObject(IManagedContext *pContext, BSTR name, VARIANT *pVariant) {
        return pContext->Application_GetContentsObject(name, pVariant);
    }

    virtual HRESULT GetStaticObject(IManagedContext *pContext, BSTR name, VARIANT *pVariant) {
        return pContext->Application_GetStaticObject(name, pVariant);
    }

    virtual HRESULT OnAdd(IManagedContext *pContext, BSTR name, VARIANT value) {
        return pContext->Application_SetContentsObject(name, value);
    }

    virtual HRESULT OnRemove(IManagedContext *pContext, BSTR name) {
        return pContext->Application_RemoveContentsObject(name);
    }

    virtual HRESULT OnRemoveAll(IManagedContext *pContext) {
        return pContext->Application_RemoveAllContentsObjects();
    }
};

class AspCompatSessionDictionary : public AspCompatApplicationSessionDictionaryBase {
    
    friend class AspCompatSession;

public:
    AspCompatSessionDictionary(AspCompatAsyncCall *pCall, BOOL readonly) 
        : AspCompatApplicationSessionDictionaryBase(pCall, readonly) {
    }

    virtual HRESULT GetContentsObject(IManagedContext *pContext, BSTR name, VARIANT *pVariant) {
        return pContext->Session_GetContentsObject(name, pVariant);
    }

    virtual HRESULT GetStaticObject(IManagedContext *pContext, BSTR name, VARIANT *pVariant) {
        return pContext->Session_GetStaticObject(name, pVariant);
    }

    virtual HRESULT OnAdd(IManagedContext *pContext, BSTR name, VARIANT value) {
        return pContext->Session_SetContentsObject(name, value);
    }

    virtual HRESULT OnRemove(IManagedContext *pContext, BSTR name) {
        return pContext->Session_RemoveContentsObject(name);
    }

    virtual HRESULT OnRemoveAll(IManagedContext *pContext) {
        return pContext->Session_RemoveAllContentsObjects();
    }
};

class AspCompatWriteCookie : public AspCompatWriteCookieBase {

    friend class AspCompatResponse;
    friend class AspCompatResponseCookies;

private:
    AspCompatAsyncCall *_pCall;
    BSTR _bstrName;
    BSTR _bstrTextValue;
    BOOL _hasKeys;
    AspCompatVariantDictionary *_pDict; // for many values

    HRESULT SetName(LPWSTR pName);
    HRESULT SetTextValue(LPWSTR pTextValue);
    HRESULT AddKeyValuePair(LPWSTR pKey, LPWSTR pValue);
    HRESULT ResetRequestCookies();

public:
    AspCompatWriteCookie(AspCompatAsyncCall *pCall);
    virtual ~AspCompatWriteCookie();

	STDMETHODIMP put_Item(VARIANT varKey, BSTR bstrValue);
	STDMETHODIMP put_Expires(DATE dtExpires);
	STDMETHODIMP put_Domain(BSTR bstrDomain);
	STDMETHODIMP put_Path(BSTR bstrPath);
	STDMETHODIMP put_Secure(VARIANT_BOOL fSecure);
	STDMETHODIMP get_HasKeys(VARIANT_BOOL *pfHasKeys);
	STDMETHODIMP get__NewEnum(IUnknown **ppEnum);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\aspcompat_intrinsics.cxx ===
/**
 * Support for ASP Compat Request execution -- intrinsics implementation
 * 
 * Copyright (c) 2000, Microsoft Corporation
 * 
 */

#include "precomp.h"

#include "aspcompat.h"

/*****************************************************************************

Known limitations of this implementation of OLEAUT ASP intrinsics'

Request.ClientCertificate
Server.GetLastError

*****************************************************************************/


//////////////////////////////////////////////////////////////////////////////
//
// Utilities to deal with variants
//

HRESULT VariantDereferenceDefaultDispatchProperty(VARIANT *pVarDest, VARIANT *pVarSrc) {
    HRESULT     hr = S_OK;
    VARIANT     varResolved;
    DISPPARAMS  dispParamsNoArgs = {NULL, NULL, 0, 0};
    EXCEPINFO   excepInfo;

    VariantInit(pVarDest);

    if (V_VT(pVarSrc) & VT_BYREF) {
        hr = VariantCopyInd(pVarDest, pVarSrc);
        ON_ERROR_EXIT();
    }
    else {
        hr = VariantCopy(pVarDest, pVarSrc);
        ON_ERROR_EXIT();
    }

    while (V_VT(pVarDest) == VT_DISPATCH) {
        if (V_DISPATCH(pVarDest) == NULL) {
            EXIT_WITH_HRESULT(DISP_E_MEMBERNOTFOUND);
        }
        else {
            VariantInit(&varResolved);
            hr = V_DISPATCH(pVarDest)->Invoke(DISPID_VALUE, 
                                              IID_NULL, 
                                              LOCALE_SYSTEM_DEFAULT,
                                              DISPATCH_PROPERTYGET | DISPATCH_METHOD, 
                                              &dispParamsNoArgs, 
                                              &varResolved, 
                                              &excepInfo,
                                              NULL);

            ON_ERROR_EXIT();
        }

        VariantClear(pVarDest);
        *pVarDest = varResolved;
    }

Cleanup:
    return S_OK;
}

BSTR VariantGetInnerBstr(VARIANT *pVar) {
    if (V_VT(pVar) == VT_BSTR)
        return V_BSTR(pVar);

    if (V_VT(pVar) == (VT_BYREF|VT_VARIANT))
        {
        VARIANT *pVarRef = V_VARIANTREF(pVar);
        if (pVarRef && V_VT(pVarRef) == VT_BSTR)
            return V_BSTR(pVarRef);
        }
    return NULL;
}

HRESULT VariantCopyBstrOrInt(VARIANT *pVarDest, VARIANT *pVarSrc, BOOL allowInt) {
    HRESULT hr = S_OK;

    VariantClear(pVarDest);
    VariantDereferenceDefaultDispatchProperty(pVarDest, pVarSrc);

    switch (V_VT(pVarDest)) {
        case VT_BSTR:
            // good as is
            break;

        // numbers
        case VT_I4:
            if (allowInt)
                break;
            // fall through

        case VT_I1:  case VT_I2:               case VT_I8:
        case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
        case VT_R4:  case VT_R8:
            if (allowInt) {
                // coerce to I4
                hr = VariantChangeType(pVarDest, pVarDest, 0, VT_I4);
                ON_ERROR_EXIT();
                break;
            }
            // fall through

        default:
            // coerce to BSTR
            hr = VariantChangeType(pVarDest, pVarDest, 0, VT_BSTR);
            ON_ERROR_EXIT();
            break;
        }

Cleanup:
    if (hr != S_OK)
        VariantClear(pVarDest);
    return hr;
}

HRESULT VariantCopyBstrOrInt(VARIANT *pVarDest, VARIANT *pVarSrc) {
    return VariantCopyBstrOrInt(pVarDest, pVarSrc, TRUE);
}

HRESULT VariantCopyBstr(VARIANT *pVarDest, VARIANT *pVarSrc) {
    return VariantCopyBstrOrInt(pVarDest, pVarSrc, FALSE);
}

HRESULT VariantCopyFromStr(VARIANT *pVarDest, LPWSTR pStr) {
    HRESULT hr = S_OK;
    BSTR bstr = NULL;

    VariantClear(pVarDest);

    bstr = SysAllocString(pStr);
    ON_OOM_EXIT(pStr);

    V_VT(pVarDest) = VT_BSTR;
    V_BSTR(pVarDest) = bstr;

Cleanup:
    return hr;
}

HRESULT VariantCopyFromIDispatch(VARIANT *pVarDest, IDispatch *pDisp) {
    VariantClear(pVarDest);

    pDisp->AddRef();
    V_VT(pVarDest) = VT_DISPATCH;
    V_DISPATCH(pVarDest) = pDisp;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// Utilities for tokenization of marshalled '\t' separated strings
//

WCHAR *GetFirstToken(WCHAR *pStart, WCHAR **pMarker) {
    *pMarker = wcschr(pStart, L'\t');
    if (*pMarker != NULL)
        **pMarker = L'\0';
    return pStart;
}

WCHAR *GetNextToken(WCHAR **pMarker) {
    WCHAR *pStart = *pMarker;
    if (pStart == NULL)
        return NULL;
    *pMarker = wcschr(++pStart, L'\t');
    if (*pMarker != NULL)
        **pMarker = L'\0';
    return pStart;
}

//////////////////////////////////////////////////////////////////////////////
//
// AspCompatScriptingContext implementation
//

AspCompatScriptingContext::AspCompatScriptingContext() {
}

AspCompatScriptingContext::~AspCompatScriptingContext() {
    ReleaseInterface(_pApplication);
    ReleaseInterface(_pSession);
    ReleaseInterface(_pRequest);
    ReleaseInterface(_pResponse);
    ReleaseInterface(_pServer);
}

HRESULT AspCompatScriptingContext::CreateIntrinsics(AspCompatAsyncCall *pAsyncCall, BOOL sessionNeeded) {
    HRESULT hr = S_OK;

    _pApplication = new AspCompatApplication(pAsyncCall);
    ON_OOM_EXIT(_pApplication);

    if (sessionNeeded) {
        _pSession = new AspCompatSession(pAsyncCall);
        ON_OOM_EXIT(_pSession);
    }

    _pRequest = new AspCompatRequest(pAsyncCall);
    ON_OOM_EXIT(_pRequest);

    _pResponse = new AspCompatResponse(pAsyncCall);
    ON_OOM_EXIT(_pResponse);

    _pServer = new AspCompatServer(pAsyncCall);
    ON_OOM_EXIT(_pServer);

Cleanup:
    return hr;
}

HRESULT AspCompatScriptingContext::QueryInterface(REFIID iid, void **ppvObj) {
    HRESULT hr = S_OK;

    // base class first
    hr = AspCompatIntrinsic<IScriptingContext>::QueryInterface(iid, ppvObj);

    if (hr == E_NOINTERFACE) {
        if (iid == __uuidof(IApplicationObject)) {
            hr = get_Application((IApplicationObject **)ppvObj);
            ON_ERROR_EXIT();
        }
        else if (iid == __uuidof(ISessionObject)) {
            hr = get_Session((ISessionObject **)ppvObj);
            ON_ERROR_EXIT();
        }
        else if (iid == __uuidof(IRequest)) {
            hr = get_Request((IRequest **)ppvObj);
            ON_ERROR_EXIT();
        }
        else if (iid == __uuidof(IResponse)) {
            hr = get_Response((IResponse **)ppvObj);
            ON_ERROR_EXIT();
        }
        else if (iid == __uuidof(IServer)) {
            hr = get_Server((IServer **)ppvObj);
            ON_ERROR_EXIT();
        }
    }

    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatScriptingContext::get_Application(IApplicationObject **ppObject) {
    if (_pApplication != NULL) {
        _pApplication->AddRef();
        *ppObject = _pApplication;
        return S_OK;
    }
    else {
        *ppObject = NULL;
        return TYPE_E_ELEMENTNOTFOUND;
    }
}

HRESULT AspCompatScriptingContext::get_Session(ISessionObject **ppObject) {
    if (_pSession != NULL) {
        _pSession->AddRef();
        *ppObject = _pSession;
        return S_OK;
    }
    else {
        *ppObject = NULL;
        return TYPE_E_ELEMENTNOTFOUND;
    }
}

HRESULT AspCompatScriptingContext::get_Request(IRequest **ppObject) {
    if (_pRequest != NULL) {
        _pRequest->AddRef();
        *ppObject = _pRequest;
        return S_OK;
    }
    else {
        *ppObject = NULL;
        return TYPE_E_ELEMENTNOTFOUND;
    }
}

HRESULT AspCompatScriptingContext::get_Response(IResponse **ppObject) {
    if (_pResponse != NULL) {
        _pResponse->AddRef();
        *ppObject = _pResponse;
        return S_OK;
    }
    else {
        *ppObject = NULL;
        return TYPE_E_ELEMENTNOTFOUND;
    }
}

HRESULT AspCompatScriptingContext::get_Server(IServer **ppObject) {
    if (_pServer != NULL) {
        _pServer->AddRef();
        *ppObject = _pServer;
        return S_OK;
    }
    else {
        *ppObject = NULL;
        return TYPE_E_ELEMENTNOTFOUND;
    }
}

//////////////////////////////////////////////////////////////////////////////

#pragma warning(disable:4100) // unreferenced formal parameter

//////////////////////////////////////////////////////////////////////////////
//
// AspCompatApplication implementation
//

AspCompatApplication::AspCompatApplication(AspCompatAsyncCall *pCall) {
    _pCall = pCall;
    _pCall->AddRef();
}

AspCompatApplication::~AspCompatApplication() {
    ReleaseInterface(_pContents);
    ReleaseInterface(_pStaticObjects);
    ReleaseInterface(_pCall);
}

HRESULT AspCompatApplication::Lock() {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Application_Lock();
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatApplication::UnLock() {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Application_UnLock();
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatApplication::get_Value(BSTR bstr, VARIANT *pvar) {
    HRESULT hr = S_OK;
    IVariantDictionary *pDict = NULL;
    VARIANT varKey;

    hr = get_Contents(&pDict);
    ON_ERROR_EXIT();
    
    V_VT(&varKey) = VT_BSTR;
    V_BSTR(&varKey) = bstr;
    hr = pDict->get_Item(varKey, pvar);
    ON_ERROR_EXIT();

Cleanup:
    ReleaseInterface(pDict);
    return hr;
}

HRESULT AspCompatApplication::put_Value(BSTR bstr, VARIANT var) {
    HRESULT hr = S_OK;
    IVariantDictionary *pDict = NULL;
    VARIANT varKey;

    hr = get_Contents(&pDict);
    ON_ERROR_EXIT();
    
    V_VT(&varKey) = VT_BSTR;
    V_BSTR(&varKey) = bstr;
    hr = pDict->put_Item(varKey, var);
    ON_ERROR_EXIT();

Cleanup:
    ReleaseInterface(pDict);
    return hr;
}

HRESULT AspCompatApplication::putref_Value(BSTR bstr, VARIANT var) {
    HRESULT hr = S_OK;
    IVariantDictionary *pDict = NULL;
    VARIANT varKey;

    hr = get_Contents(&pDict);
    ON_ERROR_EXIT();
    
    V_VT(&varKey) = VT_BSTR;
    V_BSTR(&varKey) = bstr;
    hr = pDict->putref_Item(varKey, var);
    ON_ERROR_EXIT();

Cleanup:
    ReleaseInterface(pDict);
    return hr;
}

HRESULT AspCompatApplication::get_Contents(IVariantDictionary **ppDictReturn) {
    if (_pContents != NULL) {
        // fast return if already threre
        _pContents->AddRef();
        *ppDictReturn = _pContents;
        return S_OK;
    }

    HRESULT hr = S_OK;
    BSTR bstr = NULL;
    AspCompatApplicationDictionary *pDict = NULL;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Application_GetContentsNames(&bstr);
    ON_ERROR_EXIT();

    pDict = new AspCompatApplicationDictionary(_pCall, FALSE);
    ON_OOM_EXIT(pDict);

    hr = pDict->FillIn(bstr);
    ON_ERROR_EXIT();

Cleanup:
    if (hr == S_OK) {
        _pContents = pDict;
        _pContents->AddRef();
        *ppDictReturn = _pContents;
    }
    else {
        ReleaseInterface(pDict);
        *ppDictReturn = NULL;
    }

    SysFreeString(bstr);
    return hr;
}

HRESULT AspCompatApplication::get_StaticObjects(IVariantDictionary **ppDictReturn) {
    if (_pStaticObjects != NULL) {
        // fast return if already threre
        _pStaticObjects->AddRef();
        *ppDictReturn = _pStaticObjects;
        return S_OK;
    }

    HRESULT hr = S_OK;
    BSTR bstr = NULL;
    AspCompatApplicationDictionary *pDict = NULL;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Application_GetStaticNames(&bstr);
    ON_ERROR_EXIT();

    pDict = new AspCompatApplicationDictionary(_pCall, TRUE);
    ON_OOM_EXIT(pDict);

    hr = pDict->FillIn(bstr);
    ON_ERROR_EXIT();

Cleanup:
    if (hr == S_OK) {
        _pStaticObjects = pDict;
        _pStaticObjects->AddRef();
        *ppDictReturn = _pStaticObjects;
    }
    else {
        ReleaseInterface(pDict);
        *ppDictReturn = NULL;
    }

    SysFreeString(bstr);
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// AspCompatApplicationSessionDictionaryBase implementation
//

AspCompatApplicationSessionDictionaryBase::AspCompatApplicationSessionDictionaryBase(AspCompatAsyncCall *pCall, BOOL readonly) {
    _pCall = pCall;
    _pCall->AddRef();
    _readonly = readonly;
}

AspCompatApplicationSessionDictionaryBase::~AspCompatApplicationSessionDictionaryBase() {
    ReleaseInterface(_pCall);
}

HRESULT AspCompatApplicationSessionDictionaryBase::FillIn(BSTR names) {
    HRESULT hr = S_OK;
    BSTR bstr = NULL;
    WCHAR *pBuf = NULL, *pMarker, *pName;
    VARIANT var, varKey;
    VariantInit(&var);

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    pBuf = DupStr(names);  // use for [destructive] parsing
    ON_OOM_EXIT(pBuf);

    pName = GetFirstToken(pBuf, &pMarker);

    while (pName != NULL) {
        bstr = SysAllocString(pName);
        ON_OOM_EXIT(bstr);
        
        if (_readonly) {
            hr = GetStaticObject(pContext, bstr, &var);
            ON_ERROR_EXIT();
        }
        else {
            hr = GetContentsObject(pContext, bstr, &var);
            ON_ERROR_EXIT();
        }

        V_VT(&varKey) = VT_BSTR;
        V_BSTR(&varKey) = bstr;     // the variant isn't freed, BSTR is

        // insert into dictionary
        hr = AspCompatVariantDictionary::put_Item(varKey, var);
        ON_ERROR_EXIT();

        SysFreeString(bstr);
        bstr = NULL;
        VariantClear(&var);

        pName = GetNextToken(&pMarker);
    }

Cleanup:
    SysFreeString(bstr);
    VariantClear(&var);
    delete [] pBuf;
    return hr;
}

HRESULT AspCompatApplicationSessionDictionaryBase::PutItem(VARIANT varKey, VARIANT varValue, BOOL deref) {
    HRESULT hr = S_OK;
    int index = 0;
    BSTR key = NULL;
    VARIANT var;
    VariantInit(&var);

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    if (_readonly)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    // update this dictionary

    hr = AspCompatVariantDictionary::Put(varKey, varValue, deref, &index);
    ON_ERROR_EXIT();

    // update managed state

    hr = AspCompatVariantDictionary::GetKey(index, &key);
    ON_ERROR_EXIT();

    hr = AspCompatVariantDictionary::Get(index, &var);
    ON_ERROR_EXIT();

    hr = OnAdd(pContext, key, var);
    ON_ERROR_EXIT();

Cleanup:
    SysFreeString(key);
    VariantClear(&var);
    return hr;
}

HRESULT AspCompatApplicationSessionDictionaryBase::put_Item(VARIANT varKey, VARIANT varValue) {
    return PutItem(varKey, varValue, FALSE);
}

HRESULT AspCompatApplicationSessionDictionaryBase::putref_Item(VARIANT varKey, VARIANT varValue) {
    return PutItem(varKey, varValue, TRUE);
}

HRESULT AspCompatApplicationSessionDictionaryBase::Remove(VARIANT varKey) {
    HRESULT hr = S_OK;
    BSTR key = NULL;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    if (_readonly)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    // update this dictionary
    hr = AspCompatVariantDictionary::Remove(varKey, &key);
    ON_ERROR_EXIT();

    // update managed state
    hr = OnRemove(pContext, key);
    ON_ERROR_EXIT();

Cleanup:
    SysFreeString(key);
    return hr;
}

HRESULT AspCompatApplicationSessionDictionaryBase::RemoveAll() {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    if (_readonly)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    // update this dictionary
    hr = AspCompatVariantDictionary::RemoveAll();
    ON_ERROR_EXIT();

    // update managed state
    hr = OnRemoveAll(pContext);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// AspCompatReadCookie implementation
//

AspCompatReadCookie::AspCompatReadCookie() {
}

AspCompatReadCookie::~AspCompatReadCookie() {
    ReleaseInterface(_pDict);
    SysFreeString(_bstrTextValue);
}

HRESULT AspCompatReadCookie::Init(BOOL hasKeys, LPWSTR pTextValue) {
    HRESULT hr = S_OK;

    _hasKeys = hasKeys;

    _bstrTextValue = SysAllocString(pTextValue);
    ON_OOM_EXIT(_bstrTextValue);

    _pDict = new AspCompatVariantDictionary();
    ON_OOM_EXIT(_pDict);

Cleanup:
    return hr;
}

HRESULT AspCompatReadCookie::AddKeyValuePair(LPWSTR pKey, LPWSTR pValue) {
    HRESULT hr = S_OK;
    VARIANT varKey, varValue;
    VariantInit(&varKey);
    VariantInit(&varValue);

    ON_ZERO_EXIT_WITH_HRESULT(_pDict, E_UNEXPECTED);

    hr = VariantCopyFromStr(&varKey, pKey);
    ON_ERROR_EXIT();

    hr = VariantCopyFromStr(&varValue, pValue);
    ON_ERROR_EXIT();

    hr = _pDict->put_Item(varKey, varValue);
    ON_ERROR_EXIT();

Cleanup:
    VariantClear(&varKey);
    VariantClear(&varValue);
    return hr;
}

HRESULT AspCompatReadCookie::get_Item(VARIANT var, VARIANT *pVarReturn) {
    HRESULT hr = S_OK;

    VariantInit(pVarReturn);

    if (V_VT(&var) == VT_ERROR) {
        // default property (text value) when no index given
        hr = VariantCopyFromStr(pVarReturn, _bstrTextValue);
        ON_ERROR_EXIT();
        EXIT();
    }

    ON_ZERO_EXIT_WITH_HRESULT(_pDict, E_UNEXPECTED);
    hr = _pDict->get_Item(var, pVarReturn);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatReadCookie::get_HasKeys(VARIANT_BOOL *pfHasKeys) {
    *pfHasKeys = (VARIANT_BOOL)(_hasKeys ? -1 : 0);
    return S_OK;
}

HRESULT AspCompatReadCookie::get__NewEnum(IUnknown **ppEnumReturn) {
    HRESULT hr = S_OK;

    *ppEnumReturn = NULL;

    ON_ZERO_EXIT_WITH_HRESULT(_pDict, E_UNEXPECTED);
    hr = _pDict->get__NewEnum(ppEnumReturn);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatReadCookie::get_Count(int *pcValues) {
    HRESULT hr = S_OK;

    *pcValues = 0;

    if (_hasKeys) {
        ON_ZERO_EXIT_WITH_HRESULT(_pDict, E_UNEXPECTED);
        hr = _pDict->get_Count(pcValues);
        ON_ERROR_EXIT();
    }

Cleanup:
    return hr;
}

HRESULT AspCompatReadCookie::get_Key(VARIANT varKey, VARIANT *pVarReturn) {
    HRESULT hr = S_OK;

    VariantInit(pVarReturn);

    ON_ZERO_EXIT_WITH_HRESULT(_pDict, E_UNEXPECTED);
    hr = _pDict->get_Key(varKey, pVarReturn);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// AspCompatRequest implementation
//

AspCompatRequest::AspCompatRequest(AspCompatAsyncCall *pCall) {
    _pCall = pCall;
    _pCall->AddRef();
}

AspCompatRequest::~AspCompatRequest() {
    ReleaseInterface(_pCall);

    ReleaseInterface(_pQueryString);
    ReleaseInterface(_pForm);
    ReleaseInterface(_pCookies);
    ReleaseInterface(_pServerVars);
}

HRESULT AspCompatRequest::CreateRequestDictionary(int what, AspCompatRequestDictionary **ppDict) {
    HRESULT hr = S_OK;
    AspCompatRequestDictionary *pDict = NULL;
    BSTR bstr = NULL;
    WCHAR *pBuf = NULL, *pMarker, *pKey, *pNumValues, *pValue;
    int i, numValues;
    AspCompatStringList *pList = NULL;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Request_GetAsString(what, &bstr);
    ON_ERROR_EXIT();

    pDict = new AspCompatRequestDictionary();
    ON_OOM_EXIT(pDict);

    pList = new AspCompatStringList();  // empty string list as not-found-value
    ON_OOM_EXIT(pList);

    hr = pDict->Init(pList, NULL);
    ON_ERROR_EXIT();

    ClearInterface(&pList);

    if (bstr == NULL || *bstr == L'\0')
        EXIT();

    pBuf = DupStr(bstr);  // use for [destructive] parsing
    ON_OOM_EXIT(pBuf);

    pKey = GetFirstToken(pBuf, &pMarker);

    while (pKey != NULL) {
        pNumValues = GetNextToken(&pMarker);
        ON_ZERO_EXIT_WITH_HRESULT(pNumValues, E_UNEXPECTED);
        numValues = _wtoi(pNumValues);

        // contruct string list
        pList = new AspCompatStringList();
        ON_OOM_EXIT(pList);

        for (i = 0; i < numValues; i++) {
            pValue = GetNextToken(&pMarker);
            ON_ZERO_EXIT_WITH_HRESULT(pValue, E_UNEXPECTED);

            hr = pList->Add(pValue);
            ON_ERROR_EXIT();
        }

        // add string list to the requests dictionary
        hr = pDict->Add(pKey, pList);
        ON_ERROR_EXIT();
        ClearInterface(&pList);

        // next key
        pKey = GetNextToken(&pMarker);
    }

Cleanup:
    if (hr != S_OK && pDict != NULL)
        ClearInterface(&pDict);
    *ppDict = pDict;
    SysFreeString(bstr);
    delete [] pBuf;
    ReleaseInterface(pList);
    return hr;
}

HRESULT AspCompatRequest::FillInCookiesDictionary() {
    HRESULT hr = S_OK;
    AspCompatReadCookie *pCookie = NULL;
    BSTR bstr = NULL;
    WCHAR *pBuf = NULL, *pMarker, *pValue, *pNum, *pName, *pKey;
    int i, j, numCookies, numKeys;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Request_GetCookiesAsString(&bstr);
    ON_ERROR_EXIT();

    pBuf = DupStr(bstr);  // use for [destructive] parsing
    ON_OOM_EXIT(pBuf);

    SysFreeString(bstr);
    bstr = NULL;

    // default value (all cookies as text)
    pValue = GetFirstToken(pBuf, &pMarker);
    ON_ZERO_EXIT_WITH_HRESULT(pValue, E_UNEXPECTED);

    bstr = SysAllocString(pValue);
    ON_OOM_EXIT(bstr);

    // create empty cookie
    pCookie = new AspCompatReadCookie();
    ON_OOM_EXIT(pCookie);
    hr = pCookie->Init(FALSE, L"");
    ON_OOM_EXIT(bstr);

    // initialize the request dictionary
    hr = _pCookies->Init(pCookie, bstr);
    ON_ERROR_EXIT();

    SysFreeString(bstr);
    bstr = NULL;

    ClearInterface(&pCookie);

    // number of cookies
    pNum = GetNextToken(&pMarker);
    ON_ZERO_EXIT_WITH_HRESULT(pNum, E_UNEXPECTED);
    numCookies = _wtoi(pNum);

    for (i = 0; i < numCookies; i++) {
        // name
        pName = GetNextToken(&pMarker);
        ON_ZERO_EXIT_WITH_HRESULT(pName, E_UNEXPECTED);
        // text
        pValue = GetNextToken(&pMarker);
        ON_ZERO_EXIT_WITH_HRESULT(pValue, E_UNEXPECTED);
        // num keys
        pNum = GetNextToken(&pMarker);
        ON_ZERO_EXIT_WITH_HRESULT(pNum, E_UNEXPECTED);
        numKeys = _wtoi(pNum);

        // create new cookie
        pCookie = new AspCompatReadCookie();
        ON_OOM_EXIT(pCookie);
        hr = pCookie->Init(numKeys > 0, pValue);
        ON_ERROR_EXIT();

        for (j = 0; j < numKeys; j++) {
            pKey = GetNextToken(&pMarker);
            ON_ZERO_EXIT_WITH_HRESULT(pKey, E_UNEXPECTED);
            pValue = GetNextToken(&pMarker);
            ON_ZERO_EXIT_WITH_HRESULT(pValue, E_UNEXPECTED);
            hr = pCookie->AddKeyValuePair(pKey, pValue);
            ON_ERROR_EXIT();
        }

        // add cookie to the dictionary
        hr = _pCookies->Add(pName, pCookie);
        ON_ERROR_EXIT();

        ClearInterface(&pCookie);
    }

Cleanup:
    ReleaseInterface(pCookie);
    SysFreeString(bstr);
    delete [] pBuf;
    _cookiesReset = FALSE;
    return hr;
}

HRESULT AspCompatRequest::ResetCookies() {
    if (_pCookies != NULL) {
        _pCookies->Clear();
        _cookiesReset = TRUE;
    }
    return S_OK;
}

HRESULT AspCompatRequest::get_Item(BSTR bstrKey, IDispatch **ppDispReturn) {
    HRESULT hr = S_OK;
    IRequestDictionary *pDict = NULL;
    IDispatch *pDisp = NULL;
    VARIANT varKey;
    VariantInit(&varKey);

    hr = VariantCopyFromStr(&varKey, bstrKey);
    ON_ERROR_EXIT();

    // Query string
    hr = get_QueryString(&pDict);
    if (hr == S_OK) {
        ClearInterface(&pDict);
        hr = _pQueryString->Get(varKey, &pDisp);
        if (pDisp != NULL)
            EXIT();
    }

    // Form
    hr = get_Form(&pDict);
    if (hr == S_OK) {
        ClearInterface(&pDict);
        hr = _pForm->Get(varKey, &pDisp);
        if (pDisp != NULL)
            EXIT();
    }

    // Cookies
    hr = get_Cookies(&pDict);
    if (hr == S_OK) {
        ClearInterface(&pDict);
        hr = _pCookies->Get(varKey, &pDisp);
        if (pDisp != NULL)
            EXIT();
    }

    // Server vars
    hr = get_ServerVariables(&pDict);
    if (hr == S_OK) {
        ClearInterface(&pDict);
        hr = _pServerVars->Get(varKey, &pDisp);
        if (pDisp != NULL)
            EXIT();
    }

    // Default to Empty string list
    hr = S_OK;
    pDisp = new AspCompatStringList();
    ON_OOM_EXIT(pDisp);

Cleanup:
    *ppDispReturn = pDisp;
    VariantClear(&varKey);
    return hr;
}

HRESULT AspCompatRequest::get_QueryString(IRequestDictionary **ppDictReturn) {
    HRESULT hr = S_OK;
    
    if (_pQueryString == NULL) {
        hr = CreateRequestDictionary(REQUESTSTRING_QUERYSTRING, &_pQueryString);
        ON_ERROR_EXIT();
    }

Cleanup:
    if (hr == S_OK) {
        _pQueryString->AddRef();
        *ppDictReturn = _pQueryString;
    }
    else {
        *ppDictReturn = NULL;
    }
    return hr;
}

HRESULT AspCompatRequest::get_Form(IRequestDictionary **ppDictReturn) {
    HRESULT hr = S_OK;
    
    if (_pForm == NULL) {
        hr = CreateRequestDictionary(REQUESTSTRING_FORM, &_pForm);
        ON_ERROR_EXIT();
    }

Cleanup:
    if (hr == S_OK) {
        _pForm->AddRef();
        *ppDictReturn = _pForm;
    }
    else {
        *ppDictReturn = NULL;
    }
    return hr;
}

HRESULT AspCompatRequest::get_Body(IRequestDictionary **ppDictReturn) {
    return get_Form(ppDictReturn);
}

HRESULT AspCompatRequest::get_ServerVariables(IRequestDictionary **ppDictReturn) {
    HRESULT hr = S_OK;
    
    if (_pServerVars == NULL) {
        hr = CreateRequestDictionary(REQUESTSTRING_SERVERVARS, &_pServerVars);
        ON_ERROR_EXIT();
    }

Cleanup:
    if (hr == S_OK) {
        _pServerVars->AddRef();
        *ppDictReturn = _pServerVars;
    }
    else {
        *ppDictReturn = NULL;
    }
    return hr;
}

HRESULT AspCompatRequest::get_ClientCertificate(IRequestDictionary **ppDictReturn) {
    return E_NOTIMPL;
}

HRESULT AspCompatRequest::get_Cookies(IRequestDictionary **ppDictReturn) {
    HRESULT hr = S_OK;

    if (_pCookies == NULL) {
        _pCookies = new AspCompatRequestDictionary();
        ON_OOM_EXIT(_pCookies);

        hr = FillInCookiesDictionary();
        ON_ERROR_EXIT();
    }
    else if (_cookiesReset) {
        hr = FillInCookiesDictionary();
        ON_ERROR_EXIT();
    }

Cleanup:
    if (hr == S_OK) {
        _pCookies->AddRef();
        *ppDictReturn = _pCookies;
    }
    else {
        *ppDictReturn = NULL;
    }
    return hr;
}

HRESULT AspCompatRequest::get_TotalBytes(long *pcbTotal) {
    HRESULT hr = S_OK;
    int numBytes = 0;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);
    
    hr = pContext->Request_GetTotalBytes(&numBytes);
    ON_ERROR_EXIT();

Cleanup:
    *pcbTotal = numBytes;
    return hr;
}

HRESULT AspCompatRequest::BinaryRead(VARIANT *pvarCount, VARIANT *pvarReturn) {
    HRESULT hr = S_OK;
    SAFEARRAY *pArray = NULL;
    SAFEARRAYBOUND bound[1];
    int size, bytesRead = 0;
    void *pData = 0;
    VARIANT varData;
    VariantInit(&varData);

    VariantInit(pvarReturn);

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    // figure out the size

    if (V_VT(pvarCount) != VT_I4) {
        hr = VariantChangeType(pvarCount, pvarCount, 0, VT_I4);
        ON_ERROR_EXIT();
    }

    size = V_I4(pvarCount);

    // create safe array

    bound[0].lLbound = 0;
    bound[0].cElements = size;

    pArray = SafeArrayCreate(VT_UI1, 1, bound);
    ON_OOM_EXIT(pArray);

    V_VT(&varData) = VT_ARRAY|VT_UI1;
    V_ARRAY(&varData) = pArray;

    hr = SafeArrayAccessData(pArray, &pData);
    ON_ERROR_EXIT();

    // read the data

    hr = pContext->Request_BinaryRead(pData, size, &bytesRead);
    ON_ERROR_EXIT();

Cleanup:
    if (pData != NULL)
        SafeArrayUnaccessData(pArray);

    VariantClear(pvarCount);
    V_VT(pvarCount) = VT_I4;

    if (hr == S_OK) {
        *pvarReturn = varData;
        V_I4(pvarCount) = bytesRead;
    }
    else {
        VariantClear(&varData);
        V_I4(pvarCount) = 0;
    }

	return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// AspCompatRequestDictionary implementation
//

AspCompatRequestDictionary::AspCompatRequestDictionary() {
}

AspCompatRequestDictionary::~AspCompatRequestDictionary() {
    Clear();
}

HRESULT AspCompatRequestDictionary::Init(IDispatch *pEmptyValue, BSTR bstrDefault) {
    HRESULT hr = S_OK;

    hr = Clear();
    ON_ERROR_EXIT();

    _pDict = new AspCompatVariantDictionary();
    ON_OOM_EXIT(_pDict);

    if (pEmptyValue != NULL) {
        _pEmptyValue = pEmptyValue;
        _pEmptyValue->AddRef();
    }

    if (bstrDefault != NULL) {
        _bstrDefault = SysAllocString(bstrDefault);
        ON_OOM_EXIT(_bstrDefault);
    }

Cleanup:
    return hr;
}

HRESULT AspCompatRequestDictionary::Clear() {
    ClearInterface(&_pDict);
    ClearInterface(&_pEmptyValue);
    SysFreeString(_bstrDefault);
    _bstrDefault = NULL;
    return S_OK;
}

HRESULT AspCompatRequestDictionary::Add(LPWSTR pKey, IDispatch *pValue) {
    HRESULT hr = S_OK;
    VARIANT varKey, varValue;
    VariantInit(&varKey);
    VariantInit(&varValue);

    ON_ZERO_EXIT_WITH_HRESULT(_pDict, E_UNEXPECTED);

    hr = VariantCopyFromStr(&varKey, pKey);
    ON_ERROR_EXIT();

    hr = VariantCopyFromIDispatch(&varValue, pValue);
    ON_ERROR_EXIT();

    hr = _pDict->put_Item(varKey, varValue);
    ON_ERROR_EXIT();

Cleanup:
    VariantClear(&varKey);
    VariantClear(&varValue);
    return hr;
}

HRESULT AspCompatRequestDictionary::Get(VARIANT varKey, IDispatch **ppDisp) {
    HRESULT hr = S_OK;
    IDispatch *pDisp = NULL;
    VARIANT var;
    VariantInit(&var);

    ON_ZERO_EXIT_WITH_HRESULT(_pDict, E_UNEXPECTED);
    hr = _pDict->get_Item(varKey, &var);
    ON_ERROR_EXIT();

    if (V_VT(&var) == VT_DISPATCH && V_DISPATCH(&var) != NULL) {
        pDisp = V_DISPATCH(&var);
        pDisp->AddRef();
    }

Cleanup:
    VariantClear(&var);
    *ppDisp = pDisp;
    return hr;
}

HRESULT AspCompatRequestDictionary::get_Item(VARIANT var, VARIANT *pVarReturn) {
    HRESULT hr = S_OK;
    IDispatch *pDisp = NULL;

    VariantInit(pVarReturn);

    if (V_VT(&var) == VT_ERROR && _bstrDefault != NULL) {
        // default property when no index given
        hr = VariantCopyFromStr(pVarReturn, _bstrDefault);
        ON_ERROR_EXIT();
        EXIT();
    }

    hr = Get(var, &pDisp);
    ON_ERROR_EXIT();

    if (pDisp == NULL && _pEmptyValue != NULL) {
        pDisp = _pEmptyValue;
        pDisp->AddRef();
    }

    if (pDisp != NULL) {
        hr = VariantCopyFromIDispatch(pVarReturn, pDisp);
        ON_ERROR_EXIT();
    }

Cleanup:
    ReleaseInterface(pDisp);
    return hr;
}

HRESULT AspCompatRequestDictionary::get__NewEnum(IUnknown **ppEnumReturn) {
    HRESULT hr = S_OK;

    *ppEnumReturn = NULL;

    ON_ZERO_EXIT_WITH_HRESULT(_pDict, E_UNEXPECTED);
    hr = _pDict->get__NewEnum(ppEnumReturn);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatRequestDictionary::get_Count(int *pcValues) {
    HRESULT hr = S_OK;

    *pcValues = 0;

    ON_ZERO_EXIT_WITH_HRESULT(_pDict, E_UNEXPECTED);
    hr = _pDict->get_Count(pcValues);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatRequestDictionary::get_Key(VARIANT varKey, VARIANT *pVarReturn) {
    HRESULT hr = S_OK;

    VariantInit(pVarReturn);

    ON_ZERO_EXIT_WITH_HRESULT(_pDict, E_UNEXPECTED);
    hr = _pDict->get_Key(varKey, pVarReturn);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// AspCompatResponse implementation
//

AspCompatResponse::AspCompatResponse(AspCompatAsyncCall *pCall) {
    _pCall = pCall;
    _pCall->AddRef();
}

AspCompatResponse::~AspCompatResponse() {
    ReleaseInterface(_pCookies);
    ReleaseInterface(_pCall);
}

HRESULT AspCompatResponse::FillInCookiesDictionary() {
    HRESULT hr = S_OK;
    AspCompatWriteCookie *pCookie = NULL;
    BSTR bstr = NULL;
    WCHAR *pBuf = NULL, *pMarker, *pValue, *pNum, *pName, *pKey;
    int i, j, numCookies, numKeys;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_GetCookiesAsString(&bstr);
    ON_ERROR_EXIT();

    pBuf = DupStr(bstr);  // use for [destructive] parsing
    ON_OOM_EXIT(pBuf);
    SysFreeString(bstr);
    bstr = NULL;

    // initialize the request dictionary
    hr = _pCookies->Init(NULL, NULL);
    ON_ERROR_EXIT();

    // skip the entire value (all cookies as text - not needed for write cookies)
    pValue = GetFirstToken(pBuf, &pMarker);
    ON_ZERO_EXIT_WITH_HRESULT(pValue, E_UNEXPECTED);

    // number of cookies
    pNum = GetNextToken(&pMarker);
    ON_ZERO_EXIT_WITH_HRESULT(pNum, E_UNEXPECTED);
    numCookies = _wtoi(pNum);

    for (i = 0; i < numCookies; i++) {
        // name
        pName = GetNextToken(&pMarker);
        ON_ZERO_EXIT_WITH_HRESULT(pName, E_UNEXPECTED);
        // text
        pValue = GetNextToken(&pMarker);
        ON_ZERO_EXIT_WITH_HRESULT(pValue, E_UNEXPECTED);
        // num keys
        pNum = GetNextToken(&pMarker);
        ON_ZERO_EXIT_WITH_HRESULT(pNum, E_UNEXPECTED);
        numKeys = _wtoi(pNum);

        // create new cookie
        pCookie = new AspCompatWriteCookie(_pCall);
        ON_OOM_EXIT(pCookie);

        hr = pCookie->SetName(pName);
        ON_ERROR_EXIT();

        if (numKeys == 0) {
            hr = pCookie->SetTextValue(pValue);
            ON_ERROR_EXIT();
        }

        for (j = 0; j < numKeys; j++) {
            pKey = GetNextToken(&pMarker);
            ON_ZERO_EXIT_WITH_HRESULT(pKey, E_UNEXPECTED);
            pValue = GetNextToken(&pMarker);
            ON_ZERO_EXIT_WITH_HRESULT(pValue, E_UNEXPECTED);
            hr = pCookie->AddKeyValuePair(pKey, pValue);
            ON_ERROR_EXIT();
        }

        // add cookie to the dictionary
        hr = _pCookies->Add(pName, pCookie);
        ON_ERROR_EXIT();

        ClearInterface(&pCookie);
    }

Cleanup:
    ReleaseInterface(pCookie);
    SysFreeString(bstr);
    delete [] pBuf;
    return hr;
}

HRESULT AspCompatResponse::Write(VARIANT var) {
    HRESULT hr = S_OK;
    BSTR bstrText;
    VARIANT v;
    VariantInit(&v);
    
    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    bstrText = VariantGetInnerBstr(&var);

    if (bstrText == NULL) {
        hr = VariantCopyBstr(&v, &var);
        ON_ERROR_EXIT();

        bstrText = VariantGetInnerBstr(&v);
    }

    if (bstrText != NULL) {
        hr = pContext->Response_Write(bstrText);
        ON_ERROR_EXIT();
    }

Cleanup:
    VariantClear(&v);
    return hr;
}

HRESULT AspCompatResponse::BinaryWrite(VARIANT varInput) {
    HRESULT hr = S_OK;
    DWORD numDim;
    long lBound, uBound;
    void *pData = NULL;
    DWORD numBytes;
    SAFEARRAY *pArray = NULL;
    VARIANT var;
    VariantInit(&var);

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    // convert to (VT_ARRAY|VT_UI1)

    hr = VariantDereferenceDefaultDispatchProperty(&var, &varInput);
    ON_ERROR_EXIT();

    if (V_VT(&var) != (VT_ARRAY|VT_UI1)) {
        hr = VariantChangeType(&var, &var, 0, VT_ARRAY|VT_UI1);
        ON_ERROR_EXIT();
    }

    // get pointer to data

    pArray = V_ARRAY(&var);

    numDim = SafeArrayGetDim(pArray);
    if (numDim != 1)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    hr = SafeArrayGetLBound(pArray, 1, &lBound);
    ON_ERROR_EXIT();

    hr = SafeArrayGetUBound(pArray, 1, &uBound);
    ON_ERROR_EXIT();

    numBytes = uBound - lBound + 1;
    if (numBytes <= 0)
        EXIT();

    hr = SafeArrayAccessData(pArray, &pData);
    ON_ERROR_EXIT();

    // send the data to managed code

    pContext->Response_BinaryWrite(pData, numBytes);

Cleanup:
    if (pData != NULL)
        SafeArrayUnaccessData(pArray);
    VariantClear(&var);
    return hr;
}

HRESULT AspCompatResponse::WriteBlock(short iBlockNumber) {
    return E_UNEXPECTED;
}

HRESULT AspCompatResponse::Redirect(BSTR bstrURL) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_Redirect(bstrURL);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatResponse::AddHeader(BSTR bstrHeaderName, BSTR bstrHeaderValue) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_AddHeader(bstrHeaderName, bstrHeaderValue);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatResponse::Pics(BSTR bstrHeaderValue) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_Pics(bstrHeaderValue);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatResponse::Add(BSTR bstrHeaderValue, BSTR bstrHeaderName) {
    return AddHeader(bstrHeaderName, bstrHeaderValue);
}

HRESULT AspCompatResponse::Clear() {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_Clear();
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatResponse::Flush() {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_Flush();
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatResponse::End() {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_End();
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatResponse::AppendToLog(BSTR bstr) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_AppendToLog(bstr);
    ON_ERROR_EXIT();


Cleanup:
    return hr;
}

HRESULT AspCompatResponse::get_ContentType(BSTR *pbstrRet) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_GetContentType(pbstrRet);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatResponse::put_ContentType(BSTR bstr) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_SetContentType(bstr);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatResponse::get_CharSet(BSTR *pbstrRet) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_GetCharSet(pbstrRet);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatResponse::put_CharSet(BSTR bstr) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_SetCharSet(bstr);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatResponse::get_CacheControl(BSTR *pbstrRet) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_GetCacheControl(pbstrRet);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatResponse::put_CacheControl(BSTR bstr) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_SetCacheControl(bstr);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatResponse::get_Status(BSTR *pbstrRet) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_GetStatus(pbstrRet);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatResponse::put_Status(BSTR bstr) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_SetStatus(bstr);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatResponse::get_Expires(VARIANT *pvarExpiresMinutesRet) {
    HRESULT hr = S_OK;
    int m = 0;

    VariantInit(pvarExpiresMinutesRet);

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_GetExpiresMinutes(&m);
    ON_ERROR_EXIT();

Cleanup:
    V_VT(pvarExpiresMinutesRet) = VT_I4;
    V_I4(pvarExpiresMinutesRet) = m;
    return hr;
}

HRESULT AspCompatResponse::put_Expires(long lExpiresMinutes) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_SetExpiresMinutes(lExpiresMinutes);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatResponse::get_ExpiresAbsolute(VARIANT *pvarTimeRet) {
    HRESULT hr = S_OK;
    double d = 0;

    VariantInit(pvarTimeRet);

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_GetExpiresAbsolute(&d);
    ON_ERROR_EXIT();

Cleanup:
    V_VT(pvarTimeRet) = VT_DATE;
    V_DATE(pvarTimeRet) = d;
    return hr;
}

HRESULT AspCompatResponse::put_ExpiresAbsolute(DATE dtExpires) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_SetExpiresAbsolute(dtExpires);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatResponse::get_Buffer(VARIANT_BOOL* fIsBuffering) {
    HRESULT hr = S_OK;
    int isBuffering = 1;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_GetIsBuffering(&isBuffering);
    ON_ERROR_EXIT();

Cleanup:
    *fIsBuffering = (VARIANT_BOOL)(isBuffering ? -1 : 0);
    return hr;
}

HRESULT AspCompatResponse::put_Buffer(VARIANT_BOOL fIsBuffering) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_SetIsBuffering((fIsBuffering == 0) ? 0 : 1);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatResponse::get_Cookies(IRequestDictionary **ppDictReturn) {
    HRESULT hr = S_OK;

    if (_pCookies == NULL) {
        _pCookies = new AspCompatResponseCookies(_pCall);
        ON_OOM_EXIT(_pCookies);

        hr = FillInCookiesDictionary();
        ON_ERROR_EXIT();
    }

Cleanup:
    if (hr == S_OK) {
        _pCookies->AddRef();
        *ppDictReturn = _pCookies;
    }
    else {
        *ppDictReturn = NULL;
    }
    return hr;
}

HRESULT AspCompatResponse::IsClientConnected(VARIANT_BOOL *fIsConnected) {
    HRESULT hr = S_OK;
    int isConnected = 1;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_IsClientConnected(&isConnected);
    ON_ERROR_EXIT();

Cleanup:
    *fIsConnected = (VARIANT_BOOL)(isConnected ? -1 : 0);
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// AspCompatResponseCookies implementation
//

AspCompatResponseCookies::AspCompatResponseCookies(AspCompatAsyncCall *pCall) {
    _pCall = pCall;
    _pCall->AddRef();
}

AspCompatResponseCookies::~AspCompatResponseCookies() {
    ReleaseInterface(_pCall);
}

HRESULT AspCompatResponseCookies::ResetRequestCookies() {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = _pCall->ResetRequestCoookies();
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatResponseCookies::get_Item(VARIANT var, VARIANT *pVarReturn) {
    HRESULT hr = S_OK;
    AspCompatWriteCookie *pCookie = NULL;
    VARIANT varName;
    VariantInit(&varName);

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = AspCompatRequestDictionary::get_Item(var, pVarReturn);
    ON_ERROR_EXIT();

    if (V_VT(pVarReturn) == VT_EMPTY) {
        // create cookie on demand (if requested by name)
        hr = VariantCopyBstrOrInt(&varName, &var);
        ON_ERROR_EXIT();

        if (V_VT(&varName) == VT_BSTR) {
            pCookie = new AspCompatWriteCookie(_pCall);
            ON_OOM_EXIT(pCookie);

            hr = pCookie->SetName(V_BSTR(&varName));
            ON_ERROR_EXIT();

            hr = Add(V_BSTR(&varName), pCookie);
            ON_ERROR_EXIT();

            hr = pContext->Response_AddCookie(V_BSTR(&varName));
            ON_ERROR_EXIT();

            hr = VariantCopyFromIDispatch(pVarReturn, pCookie);
            ON_ERROR_EXIT();

            // invalidate request cookies
            hr = ResetRequestCookies();
            ON_ERROR_EXIT();
        }
    }

Cleanup:
    VariantClear(&varName);
    ReleaseInterface(pCookie);
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// AspCompatServer implementation
//

AspCompatServer::AspCompatServer(AspCompatAsyncCall *pCall) {
    _pCall = pCall;
    _pCall->AddRef();
}

AspCompatServer::~AspCompatServer() {
    ReleaseInterface(_pCall);
}

HRESULT AspCompatServer::CreateObject(BSTR bstr, IDispatch **ppdispObject) {
    HRESULT hr = S_OK;
    IUnknown *pUnknown = NULL;

    *ppdispObject = NULL;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Server_CreateObject(bstr, &pUnknown);
    ON_ERROR_EXIT();

    hr = pUnknown->QueryInterface(IID_IDispatch, (void **)ppdispObject);
    ON_ERROR_EXIT();

Cleanup:
    ReleaseInterface(pUnknown);
    return hr;
}

HRESULT AspCompatServer::MapPath(BSTR bstrLogicalPath, BSTR *pbstrPhysicalPath) {
    HRESULT hr = S_OK;

    *pbstrPhysicalPath = NULL;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    // ASP classic fails on passed physical path
    if (bstrLogicalPath != NULL && wcschr(bstrLogicalPath, L':') != NULL)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    hr = pContext->Server_MapPath(bstrLogicalPath, pbstrPhysicalPath);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatServer::HTMLEncode(BSTR bstrIn, BSTR *pbstrEncoded) {
    HRESULT hr = S_OK;

    *pbstrEncoded = NULL;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Server_HTMLEncode(bstrIn, pbstrEncoded);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatServer::URLEncode(BSTR bstrIn, BSTR *pbstrEncoded) {
    HRESULT hr = S_OK;

    *pbstrEncoded = NULL;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Server_URLEncode(bstrIn, pbstrEncoded);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatServer::URLPathEncode(BSTR bstrIn, BSTR *pbstrEncoded) {
    HRESULT hr = S_OK;

    *pbstrEncoded = NULL;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Server_URLPathEncode(bstrIn, pbstrEncoded);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatServer::get_ScriptTimeout(long *plTimeoutSeconds) {
    HRESULT hr = S_OK;
    int t = 0;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Server_GetScriptTimeout(&t);
    ON_ERROR_EXIT();

Cleanup:
    *plTimeoutSeconds = t;
    return hr;
}

HRESULT AspCompatServer::put_ScriptTimeout(long lTimeoutSeconds) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Server_SetScriptTimeout(lTimeoutSeconds);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatServer::Execute(BSTR bstrURL) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Server_Execute(bstrURL);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatServer::Transfer(BSTR bstrURL) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Server_Transfer(bstrURL);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatServer::GetLastError(IASPError **ppASPErrorObject) {
    return E_NOTIMPL;
}


//////////////////////////////////////////////////////////////////////////////
//
// AspCompatSession implementation
//

AspCompatSession::AspCompatSession(AspCompatAsyncCall *pCall) {
    _pCall = pCall;
    _pCall->AddRef();
}

AspCompatSession::~AspCompatSession() {
    ReleaseInterface(_pContents);
    ReleaseInterface(_pStaticObjects);
    ReleaseInterface(_pCall);
}

HRESULT AspCompatSession::get_SessionID(BSTR *pbstrRet) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Session_GetID(pbstrRet);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatSession::get_Timeout(long *plVar) {
    HRESULT hr = S_OK;
    int t;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Session_GetTimeout(&t);
    ON_ERROR_EXIT();

    *plVar = t;

Cleanup:
    return hr;
}

HRESULT AspCompatSession::put_Timeout(long lVar) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Session_SetTimeout(lVar);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatSession::get_CodePage(long *plVar) {
    HRESULT hr = S_OK;
    int t;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Session_GetCodePage(&t);
    ON_ERROR_EXIT();

    *plVar = t;

Cleanup:
    return hr;
}

HRESULT AspCompatSession::put_CodePage(long lVar) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Session_SetCodePage(lVar);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatSession::get_LCID(long *plVar) {
    HRESULT hr = S_OK;
    int t;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Session_GetLCID(&t);
    ON_ERROR_EXIT();

    *plVar = t;

Cleanup:
    return hr;
}

HRESULT AspCompatSession::put_LCID(long lVar) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Session_SetLCID(lVar);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatSession::Abandon() {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Session_Abandon();
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatSession::get_Value(BSTR bstr, VARIANT FAR * pvar) {
    HRESULT hr = S_OK;
    IVariantDictionary *pDict = NULL;
    VARIANT varKey;

    hr = get_Contents(&pDict);
    ON_ERROR_EXIT();
    
    V_VT(&varKey) = VT_BSTR;
    V_BSTR(&varKey) = bstr;
    hr = pDict->get_Item(varKey, pvar);
    ON_ERROR_EXIT();

Cleanup:
    ReleaseInterface(pDict);
    return hr;
}

HRESULT AspCompatSession::put_Value(BSTR bstr, VARIANT var) {
    HRESULT hr = S_OK;
    IVariantDictionary *pDict = NULL;
    VARIANT varKey;

    hr = get_Contents(&pDict);
    ON_ERROR_EXIT();
    
    V_VT(&varKey) = VT_BSTR;
    V_BSTR(&varKey) = bstr;
    hr = pDict->put_Item(varKey, var);
    ON_ERROR_EXIT();

Cleanup:
    ReleaseInterface(pDict);
    return hr;
}

HRESULT AspCompatSession::putref_Value(BSTR bstr, VARIANT var) {
    HRESULT hr = S_OK;
    IVariantDictionary *pDict = NULL;
    VARIANT varKey;

    hr = get_Contents(&pDict);
    ON_ERROR_EXIT();
    
    V_VT(&varKey) = VT_BSTR;
    V_BSTR(&varKey) = bstr;
    hr = pDict->putref_Item(varKey, var);
    ON_ERROR_EXIT();

Cleanup:
    ReleaseInterface(pDict);
    return hr;
}

HRESULT AspCompatSession::get_Contents(IVariantDictionary **ppDictReturn) {
    if (_pContents != NULL) {
        // fast return if already threre
        _pContents->AddRef();
        *ppDictReturn = _pContents;
        return S_OK;
    }

    HRESULT hr = S_OK;
    BSTR bstr = NULL;
    AspCompatSessionDictionary *pDict = NULL;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Session_GetContentsNames(&bstr);
    ON_ERROR_EXIT();

    pDict = new AspCompatSessionDictionary(_pCall, FALSE);
    ON_OOM_EXIT(pDict);

    hr = pDict->FillIn(bstr);
    ON_ERROR_EXIT();

Cleanup:
    if (hr == S_OK) {
        _pContents = pDict;
        _pContents->AddRef();
        *ppDictReturn = _pContents;
    }
    else {
        ReleaseInterface(pDict);
        *ppDictReturn = NULL;
    }

    SysFreeString(bstr);
    return hr;
}

HRESULT AspCompatSession::get_StaticObjects(IVariantDictionary **ppDictReturn) {
    if (_pStaticObjects != NULL) {
        // fast return if already threre
        _pStaticObjects->AddRef();
        *ppDictReturn = _pStaticObjects;
        return S_OK;
    }

    HRESULT hr = S_OK;
    BSTR bstr = NULL;
    AspCompatSessionDictionary *pDict = NULL;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Session_GetStaticNames(&bstr);
    ON_ERROR_EXIT();

    pDict = new AspCompatSessionDictionary(_pCall, TRUE);
    ON_OOM_EXIT(pDict);

    hr = pDict->FillIn(bstr);
    ON_ERROR_EXIT();

Cleanup:
    if (hr == S_OK) {
        _pStaticObjects = pDict;
        _pStaticObjects->AddRef();
        *ppDictReturn = _pStaticObjects;
    }
    else {
        ReleaseInterface(pDict);
        *ppDictReturn = NULL;
    }

    SysFreeString(bstr);
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// AspCompatStringList implementation
//

AspCompatStringList::AspCompatStringList() {
    _count = 0;
    _size = 0;
    _pStrings = NULL;
}

AspCompatStringList::~AspCompatStringList() {
    for (int i = 0; i < _count; i++)
      SysFreeString(_pStrings[i]);
    delete [] _pStrings;
}

HRESULT AspCompatStringList::SizeTo(int suggestedNewSize) {
    HRESULT hr = S_OK;
    int newSize;
    BSTR *pNewStrings = NULL;

    if (suggestedNewSize <= _size)
        EXIT();

    newSize = (_size == 0) ? 16 : max(suggestedNewSize, _size*2);

    pNewStrings = new (NewClear) BSTR[newSize];
    ON_OOM_EXIT(pNewStrings);

    if (_size > 0) {
        memcpy(pNewStrings, _pStrings, _size * sizeof(BSTR));
        delete [] _pStrings;
    }

    _pStrings = pNewStrings;
    _size  = newSize;

Cleanup:
    if (hr != S_OK)
        delete [] pNewStrings;
    return hr;
}

HRESULT AspCompatStringList::Add(LPWSTR pStr) {
    HRESULT hr = S_OK;
    BSTR bstr = NULL;

    bstr = SysAllocString(pStr);
    ON_OOM_EXIT(bstr);

    hr = SizeTo(_count+1);
    ON_ERROR_EXIT();

    _pStrings[_count++] = bstr;

Cleanup:
    if (hr != S_OK)
        SysFreeString(bstr);
    return hr;
}

HRESULT AspCompatStringList::GetDefaultProperty(VARIANT *pvarOut) {
    HRESULT hr = S_OK;
    WCHAR *pStr = NULL;
    int i, j;

    VariantInit(pvarOut);

    if (_count == 0)
        EXIT();

    j = 0;
    for (i = 0; i < _count; i++)
        j += SysStringLen(_pStrings[i]);
    j += (_count - 1) * 2 + 1;      // separators + \0 terminator

    pStr = new WCHAR[j];
    ON_OOM_EXIT(pStr);

    StringCchCopy(pStr, j, _pStrings[0]);
    for (i = 1; i < _count; i++) {
      StringCchCat(pStr, j, L", ");
      StringCchCat(pStr, j, _pStrings[i]);
    }

    hr = VariantCopyFromStr(pvarOut, pStr);
    ON_ERROR_EXIT();

Cleanup:
    delete [] pStr;
    return hr;
}

HRESULT AspCompatStringList::get_Item(VARIANT varIndex, VARIANT *pvarOut) {
    HRESULT hr = S_OK;
	VARIANT v;		
	VariantInit(&v);
    int index;
	
    if (V_VT(&varIndex) == VT_ERROR) {
		hr = GetDefaultProperty(pvarOut);
        EXIT();
    }

    VariantInit(pvarOut);

	hr = VariantChangeType(&v, &varIndex, 0, VT_I4);
    ON_ERROR_EXIT();

    index = V_I4(&v)-1;

    if (index < 0 || index >= _count)
        EXIT_WITH_HRESULT(DISP_E_BADINDEX);

    hr = VariantCopyFromStr(pvarOut, _pStrings[index]);
    ON_ERROR_EXIT();

Cleanup:
    VariantClear(&v);
    return hr;
}

HRESULT AspCompatStringList::get_Count(int *pcValues) {
    *pcValues = _count;
    return S_OK;
}

HRESULT AspCompatStringList::get__NewEnum(IUnknown **ppEnumReturn) {
    HRESULT hr = S_OK;
    AspCompatStringListEnum *pEnum = NULL;

    pEnum = new AspCompatStringListEnum(this);
    ON_OOM_EXIT(pEnum);

Cleanup:
    *ppEnumReturn = pEnum;
    return hr;
}

// Enumerator class implementation

AspCompatStringListEnum::AspCompatStringListEnum(AspCompatStringList *pList) {
    _refs  = 1;
    _pList = pList;
    _pList->AddRef();
    _index = 0;
}

AspCompatStringListEnum::~AspCompatStringListEnum() {
    ReleaseInterface(_pList);
}

HRESULT AspCompatStringListEnum::QueryInterface(REFIID iid, void **ppvObj) {
    HRESULT hr = S_OK;

    if (iid == IID_IUnknown || iid == __uuidof(IEnumVARIANT)) {
        AddRef();
        *ppvObj = this;
    }
    else {
        EXIT_WITH_HRESULT(E_NOINTERFACE);
    }

Cleanup:
    return hr;
}

ULONG AspCompatStringListEnum::AddRef() {
    return ++_refs;
}

ULONG AspCompatStringListEnum::Release() {
    if (--_refs == 0) {
        delete this;
        return 0;
    }
    return _refs;
}

HRESULT AspCompatStringListEnum::Clone(IEnumVARIANT **ppEnumReturn) {
    HRESULT hr = S_OK;
    AspCompatStringListEnum *pClone = NULL;

    pClone = new AspCompatStringListEnum(_pList);
    ON_OOM_EXIT(pClone);

    pClone->_index = _index;

Cleanup:
    *ppEnumReturn = pClone;
    return hr;
}

HRESULT AspCompatStringListEnum::Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched) {
    HRESULT hr = S_OK;
    int numFetched = 0;
    int maxFetched = cElements;

    for (int i = 0; i < maxFetched; i++) {
        if (_index >= _pList->_count) {
            hr = S_FALSE;
            break;
        }

        VariantInit(&rgVariant[i]);
        hr = VariantCopyFromStr(&rgVariant[i], _pList->_pStrings[_index]);
        ON_ERROR_EXIT();

        numFetched++;
        _index++;
    }

Cleanup:
    if (pcElementsFetched != NULL)
        *pcElementsFetched = numFetched;
    return hr;
}

HRESULT AspCompatStringListEnum::Skip(unsigned long cElements) {
    HRESULT hr = S_OK;

    _index += cElements;

    if (_index >= _pList->_count) {
        _index = _pList->_count-1;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT AspCompatStringListEnum::Reset() {
    _index = 0;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// AspCompatVariantDictionary implementation
//

AspCompatVariantDictionary::AspCompatVariantDictionary() {
    _count = 0;
    _size  = 0;
    _pVars = NULL;
    _pKeys = NULL;
}

AspCompatVariantDictionary::~AspCompatVariantDictionary() {
    Clear();
}

// helper methods for interface implementation

void AspCompatVariantDictionary::Clear() {
    for (int i = 0; i < _count; i++) {
        VariantClear(&_pVars[i]);
        SysFreeString(_pKeys[i]);
    }

    delete [] _pVars;
    delete [] _pKeys;

    _count = 0;
    _size  = 0;
    _pVars = NULL;
    _pKeys = NULL;
}

int AspCompatVariantDictionary::Find(BSTR bstrKey) {
    for (int i = 0; i < _count; i++) {
        if (_wcsicmp(_pKeys[i], bstrKey) == 0)
            return i;
    }
    return -1;
}

HRESULT AspCompatVariantDictionary::SizeTo(int suggestedNewSize) {
    HRESULT hr = S_OK;
    int newSize;
    VARIANT *pNewVars = NULL;
    BSTR    *pNewKeys = NULL;

    if (suggestedNewSize <= _size)
        EXIT();

    newSize = (_size == 0) ? 16 : max(suggestedNewSize, _size*2);

    pNewVars = new (NewClear) VARIANT[newSize];
    ON_OOM_EXIT(pNewVars);

    pNewKeys = new (NewClear) BSTR[newSize];
    ON_OOM_EXIT(pNewKeys);

    if (_size > 0) {
        memcpy(pNewVars, _pVars, _size * sizeof(VARIANT));
        memcpy(pNewKeys, _pKeys, _size * sizeof(BSTR));
        delete [] _pVars;
        delete [] _pKeys;
    }

    _pVars = pNewVars;
    _pKeys = pNewKeys;
    _size  = newSize;

Cleanup:
    if (hr != S_OK) {
        delete [] pNewVars;
        delete [] pNewKeys;
    }

    return hr;
}

HRESULT AspCompatVariantDictionary::Get(BSTR bstrKey, VARIANT *pValue) {
    HRESULT hr = S_OK;

    VariantInit(pValue);

    int i = Find(bstrKey);
    if (i >= 0) {
        hr = VariantCopyInd(pValue, &_pVars[i]);
        ON_ERROR_EXIT();
    }

Cleanup:
    return hr;
}

HRESULT AspCompatVariantDictionary::Get(int index, VARIANT *pValue) {
    HRESULT hr = S_OK;

    VariantInit(pValue);

    if (index < 0 || index >= _count)
        EXIT_WITH_HRESULT(DISP_E_BADINDEX);

    hr = VariantCopyInd(pValue, &_pVars[index]);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatVariantDictionary::GetKey(BSTR bstrKey, VARIANT *pVarKey) {
    HRESULT hr = S_OK;

    VariantInit(pVarKey);

    int i = Find(bstrKey);
    if (i >= 0) {
        hr = VariantCopyFromStr(pVarKey, _pKeys[i]);
        ON_ERROR_EXIT();
    }
    else {
        hr = VariantCopyFromStr(pVarKey, L"");
        ON_ERROR_EXIT();
    }

Cleanup:
    return hr;
}

HRESULT AspCompatVariantDictionary::GetKey(int index, VARIANT *pVarKey) {
    HRESULT hr = S_OK;

    VariantInit(pVarKey);

    if (index < 0 || index >= _count)
        EXIT_WITH_HRESULT(DISP_E_BADINDEX);

    hr = VariantCopyFromStr(pVarKey, _pKeys[index]);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatVariantDictionary::GetKey(int index, BSTR *pbstrKey) {
    HRESULT hr = S_OK;

    *pbstrKey = NULL;

    if (index < 0 || index >= _count)
        EXIT_WITH_HRESULT(DISP_E_BADINDEX);

    *pbstrKey = SysAllocString(_pKeys[index]);
    ON_OOM_EXIT(*pbstrKey);

Cleanup:
    return hr;
}

HRESULT AspCompatVariantDictionary::Set(BSTR bstrKey, VARIANT value, BOOL derefValue, int *pIndex) {
    HRESULT hr = S_OK;
    BSTR bstrName = NULL;
    int  index;
    VARIANT v;
    VariantInit(&v);

    *pIndex = -1;

    index = Find(bstrKey);
    if (index >= 0) {
        hr = Set(index, value, derefValue);
        *pIndex = index;
        EXIT();
    }

    if (derefValue) {
        hr = VariantDereferenceDefaultDispatchProperty(&v, &value);
        ON_ERROR_EXIT();
    }
    else {
        hr = VariantCopyInd(&v, &value);
        ON_ERROR_EXIT();
    }

    bstrName = SysAllocString(bstrKey);
    ON_OOM_EXIT(bstrName);

    hr = SizeTo(_count+1);
    ON_ERROR_EXIT();

    index = _count++;
    _pVars[index] = v;
    _pKeys[index] = bstrName;
    *pIndex = index;

Cleanup:
    if (hr != S_OK) {
        SysFreeString(bstrName);
        VariantClear(&v);
    }

    return hr;
}

HRESULT AspCompatVariantDictionary::Set(int index, VARIANT value, BOOL derefValue) {
    HRESULT hr = S_OK;

    if (index < 0 || index >= _count)
        EXIT_WITH_HRESULT(DISP_E_BADINDEX);

    if (derefValue) {
        hr = VariantDereferenceDefaultDispatchProperty(&_pVars[index], &value);
        ON_ERROR_EXIT();
    }
    else {
        hr = VariantCopyInd(&_pVars[index], &value);
        ON_ERROR_EXIT();
    }

Cleanup:
    return hr;
}

HRESULT AspCompatVariantDictionary::Put(VARIANT varKey, VARIANT varValue, BOOL deref, int *pIndex) {
    HRESULT hr = S_OK;
    BSTR bstrKey;
    VARIANT v;
    VariantInit(&v);

    *pIndex = -1;

    bstrKey = VariantGetInnerBstr(&varKey);

    if (bstrKey != NULL) {
        hr = Set(bstrKey, varValue, deref, pIndex);
        EXIT();
    }
    
    hr = VariantCopyBstrOrInt(&v, &varKey);
    ON_ERROR_EXIT();

    switch (V_VT(&v)) {
        case VT_BSTR:
            bstrKey = VariantGetInnerBstr(&v);
            ON_ZERO_EXIT_WITH_HRESULT(bstrKey, E_UNEXPECTED);
            hr = Set(bstrKey, varValue, deref, pIndex);
            ON_ERROR_EXIT();
            EXIT();
        case VT_I4:
            hr = Set(V_I4(&v)-1, varValue, deref);      // argument is 1-based
            ON_ERROR_EXIT();
            *pIndex = V_I4(&v)-1;
            EXIT();
        default:
            EXIT_WITH_HRESULT(E_UNEXPECTED);
    }

Cleanup:
    VariantClear(&v);
    return hr;
}

HRESULT AspCompatVariantDictionary::Remove(BSTR bstrKey) {
    int i = Find(bstrKey);
    if (i >= 0)
        return Remove(i);
    else
        return S_OK;
}

HRESULT AspCompatVariantDictionary::Remove(int index) {
    HRESULT hr = S_OK;
    int i;

    if (index < 0 || index >= _count)
        EXIT_WITH_HRESULT(DISP_E_BADINDEX);

    VariantClear(&_pVars[index]);
    SysFreeString(_pKeys[index]);

    for (i = index; i < _count-1; i++) {
        _pVars[i] = _pVars[i+1];
        _pKeys[i] = _pKeys[i+1];
    }

    _count--;

Cleanup:
    return hr;
}

HRESULT AspCompatVariantDictionary::Remove(VARIANT varKey, BSTR *pbstrName) {
    HRESULT hr = S_OK;
    BSTR bstrKey;
    BSTR bstrName = NULL;
    VARIANT v, varName;
    VariantInit(&v);
    VariantInit(&varName);

    bstrKey = VariantGetInnerBstr(&varKey);

    if (bstrKey != NULL) {
        hr = Remove(bstrKey);
        ON_ERROR_EXIT();

        bstrName = SysAllocString(bstrKey);
        ON_OOM_EXIT(bstrName);

        EXIT();
    }
    
    hr = VariantCopyBstrOrInt(&v, &varKey);
    ON_ERROR_EXIT();

    switch (V_VT(&v)) {
        case VT_BSTR:
            bstrKey = VariantGetInnerBstr(&v);
            ON_ZERO_EXIT_WITH_HRESULT(bstrKey, E_UNEXPECTED);

            hr = Remove(bstrKey);
            ON_ERROR_EXIT();

            bstrName = SysAllocString(bstrKey);
            ON_OOM_EXIT(bstrName);

            EXIT();

        case VT_I4:
            if (pbstrName != NULL) {
                // need to return name being removed
                hr = GetKey(V_I4(&v)-1, &bstrName);
                ON_ERROR_EXIT();
            }

            hr = Remove(V_I4(&v)-1);        // argument is 1-based
            EXIT();

        default:
            EXIT_WITH_HRESULT(E_UNEXPECTED);
    }

Cleanup:
    VariantClear(&v);

    if (hr != S_OK || pbstrName == NULL) {
        SysFreeString(bstrName);
        bstrName = NULL;
    }

    if (pbstrName != NULL)
        *pbstrName = bstrName;

    return hr;
}

// IVariantDictionary implementation

HRESULT AspCompatVariantDictionary::get_Item(VARIANT varKey, VARIANT *pVarValue) {
    HRESULT hr = S_OK;
    BSTR bstrKey;
    VARIANT v;
    VariantInit(&v);

    bstrKey = VariantGetInnerBstr(&varKey);

    if (bstrKey != NULL) {
        hr = Get(bstrKey, pVarValue);
        EXIT();
    }
    
    hr = VariantCopyBstrOrInt(&v, &varKey);
    ON_ERROR_EXIT();

    switch (V_VT(&v)) {
        case VT_BSTR:
            bstrKey = VariantGetInnerBstr(&v);
            ON_ZERO_EXIT_WITH_HRESULT(bstrKey, E_UNEXPECTED);
            hr = Get(bstrKey, pVarValue);
            EXIT();
        case VT_I4:
            hr = Get(V_I4(&v)-1, pVarValue);        // argument is 1-based
            EXIT();
        default:
            EXIT_WITH_HRESULT(E_UNEXPECTED);
    }

Cleanup:
    VariantClear(&v);
    return hr;
}

HRESULT AspCompatVariantDictionary::put_Item(VARIANT varKey, VARIANT varValue) {
    int index = 0;
    return Put(varKey, varValue, FALSE, &index);
}

HRESULT AspCompatVariantDictionary::putref_Item(VARIANT varKey, VARIANT varValue) {
    int index = 0;
    return Put(varKey, varValue, TRUE, &index);
}

HRESULT AspCompatVariantDictionary::get_Key(VARIANT varKey, VARIANT *pVar) {
    HRESULT hr = S_OK;
    BSTR bstrKey;
    VARIANT v;
    VariantInit(&v);

    bstrKey = VariantGetInnerBstr(&varKey);

    if (bstrKey != NULL) {
        hr = GetKey(bstrKey, pVar);
        EXIT();
    }
    
    hr = VariantCopyBstrOrInt(&v, &varKey);
    ON_ERROR_EXIT();

    switch (V_VT(&v)) {
        case VT_BSTR:
            bstrKey = VariantGetInnerBstr(&v);
            ON_ZERO_EXIT_WITH_HRESULT(bstrKey, E_UNEXPECTED);
            hr = GetKey(bstrKey, pVar);
            EXIT();
        case VT_I4:
            hr = GetKey(V_I4(&v)-1, pVar);      // argument is 1-based
            EXIT();
        default:
            EXIT_WITH_HRESULT(E_UNEXPECTED);
    }

Cleanup:
    VariantClear(&v);
    return hr;
}

HRESULT AspCompatVariantDictionary::get__NewEnum(IUnknown **ppEnumReturn) {
    HRESULT hr = S_OK;
    AspCompatVariantDictionaryEnum *pEnum = NULL;

    pEnum = new AspCompatVariantDictionaryEnum(this);
    ON_OOM_EXIT(pEnum);

Cleanup:
    *ppEnumReturn = pEnum;
    return hr;
}

HRESULT AspCompatVariantDictionary::get_Count(int *pcValues) {
    *pcValues = _count;
    return S_OK;
}

HRESULT AspCompatVariantDictionary::Remove(VARIANT varKey) {
    return Remove(varKey, NULL);
}

HRESULT AspCompatVariantDictionary::RemoveAll() {
    Clear();
    return S_OK;
}

// Enumerator class implementation

AspCompatVariantDictionaryEnum::AspCompatVariantDictionaryEnum(AspCompatVariantDictionary *pDict) {
    _refs  = 1;
    _pDict = pDict;
    _pDict->AddRef();
    _index = 0;
}

AspCompatVariantDictionaryEnum::~AspCompatVariantDictionaryEnum() {
    ReleaseInterface(_pDict);
}

HRESULT AspCompatVariantDictionaryEnum::QueryInterface(REFIID iid, void **ppvObj) {
    HRESULT hr = S_OK;

    if (iid == IID_IUnknown || iid == __uuidof(IEnumVARIANT)) {
        AddRef();
        *ppvObj = this;
    }
    else {
        EXIT_WITH_HRESULT(E_NOINTERFACE);
    }

Cleanup:
    return hr;
}

ULONG AspCompatVariantDictionaryEnum::AddRef() {
    return ++_refs;
}

ULONG AspCompatVariantDictionaryEnum::Release() {
    if (--_refs == 0) {
        delete this;
        return 0;
    }
    return _refs;
}

HRESULT AspCompatVariantDictionaryEnum::Clone(IEnumVARIANT **ppEnumReturn) {
    HRESULT hr = S_OK;
    AspCompatVariantDictionaryEnum *pClone = NULL;

    pClone = new AspCompatVariantDictionaryEnum(_pDict);
    ON_OOM_EXIT(pClone);

    pClone->_index = _index;

Cleanup:
    *ppEnumReturn = pClone;
    return hr;
}

HRESULT AspCompatVariantDictionaryEnum::Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched) {
    HRESULT hr = S_OK;
    int numFetched = 0;
    int maxFetched = cElements;

    for (int i = 0; i < maxFetched; i++) {
        if (_index >= _pDict->_count) {
            hr = S_FALSE;
            break;
        }

        VariantInit(&rgVariant[i]);
        hr = VariantCopyFromStr(&rgVariant[i], _pDict->_pKeys[_index]);
        ON_ERROR_EXIT();

        numFetched++;
        _index++;
    }

Cleanup:
    if (pcElementsFetched != NULL)
        *pcElementsFetched = numFetched;
    return hr;
}

HRESULT AspCompatVariantDictionaryEnum::Skip(unsigned long cElements) {
    HRESULT hr = S_OK;

    _index += cElements;

    if (_index >= _pDict->_count) {
        _index = _pDict->_count-1;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT AspCompatVariantDictionaryEnum::Reset() {
    _index = 0;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// AspCompatWriteCookie implementation
//

AspCompatWriteCookie::AspCompatWriteCookie(AspCompatAsyncCall *pCall) {
    _pCall = pCall;
    _pCall->AddRef();
}

AspCompatWriteCookie::~AspCompatWriteCookie() {
    ReleaseInterface(_pCall);
    SysFreeString(_bstrName);
    SysFreeString(_bstrTextValue);
    ReleaseInterface(_pDict);
}

HRESULT AspCompatWriteCookie::SetName(LPWSTR pName) {
    HRESULT hr = S_OK;

    _bstrName = SysAllocString(pName);
    ON_OOM_EXIT(_bstrName);

Cleanup:
    return hr;
}

HRESULT AspCompatWriteCookie::SetTextValue(LPWSTR pTextValue) {
    HRESULT hr = S_OK;

    _bstrTextValue = SysAllocString(pTextValue);
    ON_OOM_EXIT(_bstrTextValue);

Cleanup:
    return hr;
}

HRESULT AspCompatWriteCookie::AddKeyValuePair(LPWSTR pKey, LPWSTR pValue) {
    HRESULT hr = S_OK;
    VARIANT varKey, varValue;
    VariantInit(&varKey);
    VariantInit(&varValue);

    if (_pDict == NULL) {
        _pDict = new AspCompatVariantDictionary();
        ON_OOM_EXIT(_pDict);
    }

    _hasKeys = TRUE;

    hr = VariantCopyFromStr(&varKey, pKey);
    ON_ERROR_EXIT();

    hr = VariantCopyFromStr(&varValue, pValue);
    ON_ERROR_EXIT();

    hr = _pDict->put_Item(varKey, varValue);
    ON_ERROR_EXIT();

Cleanup:
    VariantClear(&varKey);
    VariantClear(&varValue);
    return hr;
}

HRESULT AspCompatWriteCookie::ResetRequestCookies() {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = _pCall->ResetRequestCoookies();
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatWriteCookie::put_Item(VARIANT varKey, BSTR bstrValue) {
    HRESULT hr = S_OK;
    VARIANT varValue, varNameOrIndex;
    VariantInit(&varValue);
    VariantInit(&varNameOrIndex);

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    if (V_VT(&varKey) == VT_ERROR) {
        // set entire cookie text
        hr = SetTextValue(bstrValue);
        ON_ERROR_EXIT();

        hr = pContext->Response_SetCookieText(_bstrName, bstrValue);
        ON_ERROR_EXIT();
    }
    else {
        hr = VariantCopyFromStr(&varValue, bstrValue);
        ON_ERROR_EXIT();

        if (_pDict == NULL) {
            _pDict = new AspCompatVariantDictionary();
            ON_OOM_EXIT(_pDict);
        }

        hr = _pDict->put_Item(varKey, varValue);
        ON_ERROR_EXIT();

        _hasKeys = TRUE;

        hr = VariantCopyBstrOrInt(&varNameOrIndex, &varKey);
        ON_ERROR_EXIT();

        if (V_VT(&varNameOrIndex) == VT_BSTR) {
            hr = pContext->Response_SetCookieSubValue(_bstrName, V_BSTR(&varNameOrIndex), bstrValue);
            ON_ERROR_EXIT();
        }
    }

Cleanup:
    VariantClear(&varValue);
    VariantClear(&varNameOrIndex);
    return hr;
}

HRESULT AspCompatWriteCookie::put_Expires(DATE dtExpires) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_SetCookieExpires(_bstrName, dtExpires);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatWriteCookie::put_Domain(BSTR bstrDomain) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_SetCookieDomain(_bstrName, bstrDomain);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatWriteCookie::put_Path(BSTR bstrPath) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_SetCookiePath(_bstrName, bstrPath);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatWriteCookie::put_Secure(VARIANT_BOOL fSecure) {
    HRESULT hr = S_OK;

    IManagedContext *pContext = _pCall->ManagedContext();
    ON_ZERO_EXIT_WITH_HRESULT(pContext, E_UNEXPECTED);

    hr = pContext->Response_SetCookieSecure(_bstrName, fSecure ? 1 : 0);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT AspCompatWriteCookie::get_HasKeys(VARIANT_BOOL *pfHasKeys) {
    *pfHasKeys = (VARIANT_BOOL)(_hasKeys ? -1 : 0);
    return S_OK;
}

HRESULT AspCompatWriteCookie::get__NewEnum(IUnknown **ppEnumReturn) {
    HRESULT hr = S_OK;

    *ppEnumReturn = NULL;

    if (_pDict == NULL) {
        _pDict = new AspCompatVariantDictionary();
        ON_OOM_EXIT(_pDict);
    }

    hr = _pDict->get__NewEnum(ppEnumReturn);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\aspnetver.cxx ===
/**
 * Aspnetver.cxx
 * 
 * Helper class for regiis.cxx
 * 
 * Copyright (c) 2001, Microsoft Corporation
 * 
 */

#include "precomp.h"
#include "_ndll.h"
#include "aspnetver.h"

ASPNETVER   ASPNETVER::m_gThisVer(PRODUCT_VERSION_L);

ASPNETVER::ASPNETVER() {
    m_dwMajor = 0;
    m_dwMinor = 0;
    m_dwBuild = 0;
    m_dwQFE = 0;
    m_fValid = FALSE;
}

ASPNETVER::ASPNETVER(WCHAR *pchVerStr) {
    Init(pchVerStr);
}

ASPNETVER::ASPNETVER(VS_FIXEDFILEINFO *pinfo) {
    Init(pinfo);
}

void
ASPNETVER::Reset() {
    m_dwMajor = 0;
    m_dwMinor = 0;
    m_dwBuild = 0;
    m_dwQFE = 0;
    m_fValid = FALSE;
}

BOOL
ASPNETVER::Init(WCHAR *pchVerStr) {
    m_fValid = (swscanf(pchVerStr, L"%d.%d.%d.%d",
                        &m_dwMajor, &m_dwMinor, 
                        &m_dwBuild, &m_dwQFE) == 4);
    return m_fValid;
}


BOOL
ASPNETVER::Init(VS_FIXEDFILEINFO *pinfo) {
    m_dwMajor = pinfo->dwFileVersionMS >> 16;
    m_dwMinor = pinfo->dwFileVersionMS & 0xFFFF;
    m_dwBuild = pinfo->dwFileVersionLS >> 16;
    m_dwQFE = pinfo->dwFileVersionLS & 0xFFFF;

    m_fValid = TRUE;
    return m_fValid;
}


BOOL
ASPNETVER::Init(ASPNETVER *pver) {
    (*this) = *pver;
    return m_fValid;
}

BOOL
ASPNETVER::Init(DWORD dwMajor, DWORD dwMinor, DWORD dwBuild) {
    m_fValid = TRUE;
    
    m_dwMajor = dwMajor;
    m_dwMinor = dwMinor;
    m_dwBuild = dwBuild;
    m_dwQFE = 0;
    
    return m_fValid;
}

void
ASPNETVER::operator=(ASPNETVER &ver) {
    m_dwMajor = ver.m_dwMajor;
    m_dwMinor = ver.m_dwMinor;
    m_dwBuild = ver.m_dwBuild;
    m_dwQFE = ver.m_dwQFE;
    m_fValid = ver.m_fValid;
}

BOOL
ASPNETVER::operator==(ASPNETVER &ver) {
    return (m_dwMajor == ver.Major()) && (m_dwMinor == ver.Minor()) &&
           (m_dwBuild == ver.Build());
}

BOOL
ASPNETVER::operator!=(ASPNETVER &ver) {
    return !(*this == ver);
}

BOOL
ASPNETVER::operator>(ASPNETVER &ver) {
    if (m_dwMajor > ver.Major()) {
        return TRUE;
    }
    else if (m_dwMajor < ver.Major()) {
        return FALSE;
    }
    else if (m_dwMinor > ver.Minor()) {
        return TRUE;
    }
    else if (m_dwMinor < ver.Minor()) {
        return FALSE;
    }
    else if (m_dwBuild > ver.Build()) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


BOOL
ASPNETVER::operator>=(ASPNETVER &ver) {
    return (*this > ver) || (*this == ver);
}

BOOL
ASPNETVER::operator<(ASPNETVER &ver) {
    return !(*this >= ver);
}

BOOL
ASPNETVER::Equal(WCHAR *pchVer) {
    ASPNETVER   ver;

    if (!ver.Init(pchVer)) {
        return FALSE;
    }

    return *this == ver;
}
    
/**
 *  Parameters:
 *  buffer      Output buffer
 *  count       Max number of characters to store in buffer, not including the terminating zero
 */
int
ASPNETVER::ToString(WCHAR buffer[], int count) {
  ASSERT(buffer != NULL && count > (4 * 4) + 3 + 1 ); // count > 4 * 4_digit_number + 3 dots + 1 null_terminator
  StringCchPrintf(buffer, count, L"%d.%d.%d.%d", 
      m_dwMajor, m_dwMinor, m_dwBuild, m_dwQFE);
  return lstrlenW(buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\aspnetverlist.cxx ===
/**
 * Aspnetverlist.cxx
 * 
 * 
 * Copyright (c) 2001, Microsoft Corporation
 * 
 */

#include "precomp.h"
#include "_ndll.h"
#include "aspnetverlist.h"

CASPNET_VER_LIST::CASPNET_VER_LIST() {
}

CASPNET_VER_LIST::~CASPNET_VER_LIST() {
    int     i;

    for (i = 0; i < m_VerInfoAry.Size(); i++) {
        ASPNET_VERSION_INFO *pInfo;

        pInfo = (ASPNET_VERSION_INFO*)m_VerInfoAry[i];
        ASSERT(pInfo != NULL);

        if (!pInfo)
            continue;

        delete pInfo;
    }
}

HRESULT
CASPNET_VER_LIST::Add(WCHAR *pchVersion, DWORD dwStatus, WCHAR *pchDllPath, WCHAR *pchInstallPath) {
    HRESULT             hr = S_OK;
    ASPNET_VERSION_INFO *pVerInfo = NULL;

    pVerInfo = new ASPNET_VERSION_INFO;
    ON_OOM_EXIT(pVerInfo);

    wcsncpy(pVerInfo->Version, pchVersion, MAX_PATH);
    wcsncpy(pVerInfo->Path, pchDllPath, MAX_PATH);
    wcsncpy(pVerInfo->InstallPath, pchInstallPath, MAX_PATH);
    pVerInfo->Status = dwStatus;

    hr = m_VerInfoAry.AppendIndirect(&pVerInfo);
    ON_ERROR_EXIT();

    pVerInfo = NULL;

Cleanup:
    delete [] pVerInfo;
    
    return hr;
}

WCHAR *
CASPNET_VER_LIST::GetVersion(int i) {
    if (i >= m_VerInfoAry.Size()) {
        return NULL;
    }
    else {
        return ((ASPNET_VERSION_INFO*)m_VerInfoAry[i])->Version;
    }
}

DWORD
CASPNET_VER_LIST::GetStatus(int i) {
    if (i >= m_VerInfoAry.Size()) {
        return 0;
    }
    else {
        return ((ASPNET_VERSION_INFO*)m_VerInfoAry[i])->Status;
    }
}

WCHAR *
CASPNET_VER_LIST::GetPath(int i) {
    if (i >= m_VerInfoAry.Size()) {
        return NULL;
    }
    else {
        return ((ASPNET_VERSION_INFO*)m_VerInfoAry[i])->Path;
    }
}


WCHAR *
CASPNET_VER_LIST::GetInstallPath(int i) {
    if (i >= m_VerInfoAry.Size()) {
        return NULL;
    }
    else {
        return ((ASPNET_VERSION_INFO*)m_VerInfoAry[i])->InstallPath;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\asyncpipe.h ===
/**
 * ProcessTableManager header file
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

/////////////////////////////////////////////////////////////////////////////
// This file defines the class CAsyncPipe. This class controls access of
// ASPNET_ISAPI with the async pipe. Primary purpose of the async pipe is to
// send out requests and get back responses
/////////////////////////////////////////////////////////////////////////////

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _AsyncPipe_H
#define _AsyncPipe_H

#include "SmartFileHandle.h"
#include "AckReceiver.h"
#include "MessageDefs.h"

/////////////////////////////////////////////////////////////////////////////
class CAsyncPipe;

struct CAsyncPipeOverlapped : public OVERLAPPED_COMPLETION
{

    BOOL            fWriteOprn;   // Set by CAsyncPipeManager: 
                                  //    Are we calling ReadFile or WriteFile

    long            dwRefCount;

    DWORD           dwNumBytes;   // Pointer to this variable is passed
                                  //   to ReadFile/WriteFile

    DWORD           dwBufferSize; // Indicates the current size of
                                  //   oMsg in BYTES

    DWORD           dwOffset;     // Byte offset into oMsg where the
                                  //   read should start

    CAsyncPipeOverlapped *pNext;

    CAsyncMessage   oMsg;         // The actual async message
};

#define CASYNPIPEOVERLAPPED_HEADER_SIZE                         \
        ( sizeof(OVERLAPPED_COMPLETION) +                       \
          sizeof(BOOL) /*CAsyncPipeOverlapped::fWriteOprn*/ +   \
          3 * sizeof(DWORD) /*CAsyncOverlapped::DWORDs*/ +      \
          sizeof(CAsyncPipeOverlapped *) +                      \
          sizeof(long) )



/////////////////////////////////////////////////////////////////////////////

class CFreeBufferList
{
public:
    static void                      ReturnBuffer  (CAsyncPipeOverlapped * pBuffer);
    static CAsyncPipeOverlapped *    GetBuffer     ();

private:
    static CAsyncPipeOverlapped *    g_pHead;
    static CReadWriteSpinLock        g_lLock;
    static LONG                      g_lNumBufs;
};

///////////////////////////////////////////////////////////////////////////
// Forward decl.
class CProcessEntry;

///////////////////////////////////////////////////////////////////////////
// Async pipe
class CAsyncPipe : public ICompletion
{
public:
    CAsyncPipe                       ();
    ~CAsyncPipe                      ();

    HRESULT   Init                   (CProcessEntry * pProcess, 
                                      LPCWSTR         szPipeName,
                                      LPSECURITY_ATTRIBUTES pSA);
    void      Close                  ();
    BOOL      IsAlive                ();
    HRESULT   StartRead              (CAsyncPipeOverlapped * pOver = NULL);
    HRESULT   WriteToProcess         (CAsyncPipeOverlapped * pOver);
    BOOL      AnyPendingReadOrWrite  () { return m_lPendingReadWriteCount>0;}


    HRESULT   AllocNewMessage        (DWORD dwSize, CAsyncPipeOverlapped ** ppOut);
    void      ReturnResponseBuffer   (CAsyncPipeOverlapped * pOver);

    
    // ICompletion interface
    STDMETHOD    (QueryInterface   ) (REFIID    , void **       );
    STDMETHOD    (ProcessCompletion) (HRESULT   , int       , LPOVERLAPPED  );

    STDMETHOD_   (ULONG, AddRef    ) ();
    STDMETHOD_   (ULONG, Release   ) ();

private:
    // Ref count
    LONG                             m_lPendingReadWriteCount;
    
    // Handle to pipe
    CSmartFileHandle                 m_oPipe;

    // Pointer to owning process struct
    CProcessEntry *                  m_pProcess;
};

/////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\attachdebugger.cxx ===
/**
 * Attach debugger call though PInvoke
 * 
 * Copyright (c) 2000 Microsoft Corporation
 */

#include "precomp.h"
#include "dbg.h"
#include "util.h"
#include "nisapi.h"
#include "platform_apis.h"

//
// AutoAttach interface definition
//

enum
{
    AUTOATTACH_PROGRAM_WIN32          = 0x00000001,
    AUTOATTACH_PROGRAM_COMPLUS        = 0x00000002,
};
typedef DWORD AUTOATTACH_PROGRAM_TYPE;

struct __declspec(uuid("E9958F1F-0A56-424a-A300-530EBB2E9865")) _DebugAutoAttach;

struct _DebugAutoAttach : IUnknown
{
    virtual HRESULT __stdcall AutoAttach(
        REFGUID guidPort,
        DWORD dwPid,
        AUTOATTACH_PROGRAM_TYPE dwProgramType,
        DWORD dwProgramId,
        LPCWSTR pszSessionId);
};

/////////////////////////////////////////////////////////////////////////////

HRESULT
GetSidFromToken(
        HANDLE  hToken, 
        PSID *  ppSidToken)
{
    if (hToken == NULL || ppSidToken == NULL)
        return E_INVALIDARG;

    HRESULT   hr        = S_OK;    
    DWORD     dwRequire = 0;
    LPVOID    pBuffer   = NULL;

    if (GetTokenInformation(hToken, TokenUser, NULL, 0, &dwRequire) || dwRequire == 0 || dwRequire > 1000000)
        EXIT_WITH_LAST_ERROR();

    pBuffer = new (NewClear) BYTE[dwRequire + 10];
    ON_OOM_EXIT(pBuffer);

    if (!GetTokenInformation(hToken, TokenUser, pBuffer, dwRequire + 10, &dwRequire))
        EXIT_WITH_LAST_ERROR();

    dwRequire = GetLengthSid(((TOKEN_USER *)pBuffer)->User.Sid);
    ON_ZERO_EXIT_WITH_LAST_ERROR(dwRequire);

    (*ppSidToken) = (PSID) NEW_CLEAR_BYTES(dwRequire + 20);
    ON_OOM_EXIT(*ppSidToken);
    
    if (!CopySid(dwRequire + 20, *ppSidToken, ((TOKEN_USER *)pBuffer)->User.Sid))
        EXIT_WITH_LAST_ERROR();
    
 Cleanup:
    delete [] pBuffer;

    if (hr != S_OK && (*ppSidToken) != NULL)
    {
        DELETE_BYTES(*ppSidToken);
        (*ppSidToken) = NULL;
    }
    return hr;
}
/////////////////////////////////////////////////////////////////////////////

HRESULT
IsTokenAdmin(
        HANDLE    hToken,
        LPBOOL    pfIsAdmin)
{
    if (hToken == NULL || pfIsAdmin == NULL)
        return E_INVALIDARG;

    HRESULT                  hr            = S_OK;
    PSID                     pSidAdmin     = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuthNT     = SECURITY_NT_AUTHORITY;

    (*pfIsAdmin) = FALSE;
    
    if (!AllocateAndInitializeSid(
                &SIDAuthNT, 2,
                SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &pSidAdmin))
    {
        EXIT_WITH_LAST_ERROR();
    }
    if (!CheckTokenMembership(hToken, pSidAdmin, pfIsAdmin))
    {
        EXIT_WITH_LAST_ERROR();
    }
 Cleanup:
    if (pSidAdmin != NULL)
        FreeSid(pSidAdmin);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT
IsTokenSameAsProcessToken(
        HANDLE    hToken,
        LPBOOL    pfIsSameAsProcessToken)
{
    if (hToken == NULL || pfIsSameAsProcessToken == NULL)
        return E_INVALIDARG;

    HRESULT   hr            = S_OK;
    PSID      pSidToken     = NULL;
    PSID      pSidProcess   = NULL;
    HANDLE    hProcessToken = NULL;

    (*pfIsSameAsProcessToken) = FALSE;

    hr = GetSidFromToken(hToken, &pSidToken);
    ON_ERROR_EXIT();

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hProcessToken))
    {    
        EXIT_WITH_LAST_ERROR();
    }

    hr = GetSidFromToken(hProcessToken, &pSidProcess);
    ON_ERROR_EXIT();
    
    (*pfIsSameAsProcessToken) = EqualSid(pSidProcess, pSidToken);

 Cleanup:
    DELETE_BYTES(pSidToken);
    DELETE_BYTES(pSidProcess);
    if (hProcessToken != NULL)
        CloseHandle(hProcessToken);
    return hr;
}

#if DBG
void DumpThreadToken(void)
{
    HANDLE hThreadToken = NULL;
    HANDLE hProcessToken = NULL;
    TOKEN_USER* pUserToken = NULL;
    BOOL isOk;
    HRESULT hr = S_OK;

    isOk = OpenThreadToken(GetCurrentThread(), TOKEN_READ | TOKEN_IMPERSONATE, TRUE, &hThreadToken);
    ON_ZERO_EXIT_WITH_LAST_ERROR(isOk);

    isOk = OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hProcessToken);
    ON_ZERO_EXIT_WITH_LAST_ERROR(isOk);

    __try {

        if (hThreadToken) {
            isOk = RevertToSelf();
            ON_ZERO_EXIT_WITH_LAST_ERROR(isOk);
        }
        __try {
            HANDLE hToken = hThreadToken ? hThreadToken : hProcessToken;

            // Call with null buffer to get needed buffer size back
            DWORD dwSize = 0;
            isOk = GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
            if (isOk) {
                EXIT_WITH_HRESULT(E_UNEXPECTED);
            } else if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
                EXIT_WITH_LAST_ERROR();
            }
                            
            // We're here because GetTokenInformation returned FALSE and last error was INSUFFICIENT_BUFFER
            pUserToken = (TOKEN_USER*)(new BYTE[dwSize]);
            ON_OOM_EXIT(pUserToken);

            isOk = GetTokenInformation(hToken, TokenUser, pUserToken, dwSize, &dwSize);
            ON_ZERO_EXIT_WITH_LAST_ERROR(isOk);

            {
                DWORD dwSessionId;
                isOk = GetTokenInformation(hToken, TokenSessionId, &dwSessionId, sizeof(dwSessionId), &dwSize);
                ON_ZERO_EXIT_WITH_LAST_ERROR(isOk);

                WCHAR wcsName[512];
                DWORD dwNameLen = ARRAY_LENGTH(wcsName);
                WCHAR wcsDomainName[512];
                DWORD dwDomainNameLen = ARRAY_LENGTH(wcsDomainName);
                SID_NAME_USE SidUse;

                isOk = LookupAccountSid(NULL, pUserToken->User.Sid, wcsName, &dwNameLen, wcsDomainName, &dwDomainNameLen, &SidUse);
                ON_ZERO_EXIT_WITH_LAST_ERROR(isOk);

                TRACE4(L"AutoAttach", L"Thread %x is running as %s\\%s on session %d\n", GetCurrentThreadId(), wcsDomainName, wcsName, dwSessionId);
            }

        }
        __finally {
            if (hThreadToken)
            {
                isOk = SetThreadToken(NULL, hThreadToken);
                if (! isOk) {
                    TRACE1(L"AutoAttach", L"Failure setting original thread token back! GetLastError=%x\n", GetLastError());
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
    }

Cleanup:
    if (hThreadToken)
    {
        CloseHandle(hThreadToken);
    }
    if (hProcessToken)
    {
        CloseHandle(hProcessToken);
    }
    if (pUserToken) 
    {
        delete [] pUserToken;
    }
}
#endif

//
// Exported function
//

HRESULT
__stdcall
AttachDebugger(LPWSTR pClsId, LPCWSTR pSessionId, HANDLE hUserToken)
{
    HRESULT hr = S_OK;
    BOOL needCoUninit = FALSE;
    _DebugAutoAttach *pAutoAttach = NULL;
    IID debugClsid;
    BOOL bTokenSet = FALSE;
    BOOL ret = 0;

    // Impersonation vars
    HANDLE hCurrentThread = GetCurrentThread();
    HANDLE hFormerToken = NULL;
    DWORD authnSvc;
    DWORD authzSvc;
    OLECHAR * pServerPrincName = NULL;
    DWORD authnLevel;
    DWORD impLevel;
    RPC_AUTH_IDENTITY_HANDLE pAuthInfo;
    DWORD capabilities;
    BOOL isOk;
    BOOL isUserAdmin;
    BOOL isUserOwner;
    
    // CoInit
    hr = EnsureCoInitialized(&needCoUninit);
    ON_ERROR_EXIT();

    hr = IIDFromString(pClsId, &debugClsid);
    ON_ERROR_EXIT();
    
    // Impersonate the authenticated user
    // It's ok for this method to return FALSE, since it just means that the thread
    // wasn't impersonating anyone.  
    ret = OpenThreadToken(hCurrentThread, TOKEN_IMPERSONATE, TRUE, &hFormerToken);
    if (ret == 0) 
        hFormerToken = NULL;

    // Check to see if the token passed in belongs to the Admin group
    // or is the same as the process owner.  
    // If so, continue, else abort with E_ACCESSDENIED
    isOk = RevertToSelf();
    ON_ZERO_EXIT_WITH_LAST_ERROR(isOk);

    hr = IsTokenAdmin(hUserToken, &isUserAdmin);
    ON_ERROR_EXIT();

    if (! isUserAdmin) {
        hr = IsTokenSameAsProcessToken(hUserToken, &isUserOwner);
        ON_ERROR_EXIT();
        
        if (! isUserOwner) {
            TRACE(L"AutoAttach", L"Debug attach not attempted because user is not admin or process owner.");
            EXIT_WITH_HRESULT(E_ACCESSDENIED);
        }
    }

    // Ok, if we got here, the user token is ok.  Set the thread token and continue
    // with the auto-attach.
    ret = SetThreadToken(NULL, hUserToken);
    ON_ZERO_EXIT_WITH_LAST_ERROR(ret);
    bTokenSet = TRUE;

#if DBG
    DumpThreadToken();
#endif

    TRACE(L"AutoAttach", L"Debug attach calling CoCreateInstance.");

    // Create the debugger
    hr = CoCreateInstance(
            debugClsid,
            NULL,
            CLSCTX_LOCAL_SERVER,
            __uuidof(_DebugAutoAttach),
            (LPVOID*)&pAutoAttach);
    ON_ERROR_EXIT();

    // Impersonate in the interface call
    hr = CoQueryProxyBlanket(pAutoAttach, &authnSvc, &authzSvc, &pServerPrincName, &authnLevel, &impLevel, &pAuthInfo, &capabilities);
    ON_ERROR_EXIT();

    // Set impersonation level and capabilities
    // If it's Win2k or higher, we need to set the static cloaking flag so that impersonation can occur for
    // remote debugging.
    if (GetCurrentPlatform() == APSX_PLATFORM_W2K) 
    {
        capabilities = EOAC_STATIC_CLOAKING;
    }
    
    impLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
    hr = CoSetProxyBlanket(pAutoAttach, authnSvc, authzSvc, pServerPrincName, authnLevel, impLevel, pAuthInfo, capabilities);
    ON_ERROR_EXIT();

    TRACE(L"AutoAttach", L"Debug attach calling AutoAttach.");

    // Attach
    hr = pAutoAttach->AutoAttach(
            GUID_NULL, 
            GetCurrentProcessId(), 
            AUTOATTACH_PROGRAM_COMPLUS,
            0,
            pSessionId);
    ON_ERROR_EXIT();

Cleanup:

    if (pAutoAttach != NULL)
        pAutoAttach->Release();

    // Remove impersonation
    if (bTokenSet) {
        isOk = RevertToSelf();
        ON_ZERO_CONTINUE_WITH_LAST_ERROR(isOk);

        if (isOk && (hFormerToken != NULL)) {
            isOk = SetThreadToken(NULL, hFormerToken);
            ON_ZERO_CONTINUE_WITH_LAST_ERROR(isOk);
        }
    }
 
    if (hFormerToken != NULL)
        CloseHandle(hFormerToken);

    if (pServerPrincName != NULL)
        CoTaskMemFree(pServerPrincName);

    if (needCoUninit)
        CoUninitialize();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\asyncpipe.cxx ===
/**
 * Process Model: Async pipe's defn file 
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

#include "precomp.h"
#include "AsyncPipe.h"
#include "util.h"
#include "nisapi.h"
#include "ProcessEntry.h"
#include "RequestTableManager.h"

/////////////////////////////////////////////////////////////////////////////
// This file defines the class CAsyncPipe. This class controls access of
// ASPNET_ISAPI with the async pipe. Primary purpose of the async pipe is to
// send out requests and get back responses
/////////////////////////////////////////////////////////////////////////////

#define DEFAULT_RESPONSE_BUF_SIZE  1024 * 32

CAsyncPipeOverlapped *    CFreeBufferList::g_pHead    = 0;
CReadWriteSpinLock        CFreeBufferList::g_lLock("CFreeBufferList::g_lLock");
LONG                      CFreeBufferList::g_lNumBufs = 0;
LONG                      g_lSecurityIssueBug129921_a = 0;
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CTor
CAsyncPipe::CAsyncPipe()
    : m_oPipe                  (FALSE), // non-blocking handle
    m_lPendingReadWriteCount   (0),
    m_pProcess                 (NULL)
{
}

/////////////////////////////////////////////////////////////////////////////
// DTor
CAsyncPipe::~CAsyncPipe()
{
}

/////////////////////////////////////////////////////////////////////////////
// Create the pipe
HRESULT 
CAsyncPipe::Init(
        CProcessEntry * pProcess, 
        LPCWSTR  szPipeName,
        LPSECURITY_ATTRIBUTES pSA)
{
    HRESULT hr    = S_OK;
    HANDLE  hPipe;

    if(pProcess==NULL || szPipeName==NULL)
    {
        EXIT_WITH_HRESULT(E_INVALIDARG);
    }

    m_pProcess    = pProcess;

    hPipe = CreateNamedPipe (
                szPipeName, 
                FILE_FLAG_OVERLAPPED | PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE, 
                PIPE_TYPE_MESSAGE    | PIPE_READMODE_MESSAGE | PIPE_WAIT, 
                1, 
                1024, 
                1024, 
                1000, 
                pSA);


    if (hPipe == INVALID_HANDLE_VALUE)
    {
        EXIT_WITH_LAST_ERROR();
    }

    m_oPipe.SetHandle(hPipe);

    hr = AttachHandleToThreadPool(hPipe);
    ON_ERROR_EXIT();

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Close the pipe
void
CAsyncPipe::Close()
{
    m_oPipe.Close();
}

/////////////////////////////////////////////////////////////////////////////

BOOL 
CAsyncPipe::IsAlive()
{
    return m_oPipe.IsAlive();
}

/////////////////////////////////////////////////////////////////////////////
// Start a read
HRESULT
CAsyncPipe::StartRead(CAsyncPipeOverlapped * pOver)
{
    HRESULT    hr      = S_OK;
    HANDLE     hPipe   = m_oPipe.GetHandle();
    BYTE *     pBuf    = NULL;

    if (hPipe == INVALID_HANDLE_VALUE)
    {
        EXIT_WITH_HRESULT(E_FAIL);
    }

    if (pOver == NULL)
    {
        pOver = CFreeBufferList::GetBuffer();
        ON_OOM_EXIT(pOver);
        pOver->pCompletion = this;
    }

    pOver->dwRefCount  = 1;
    pOver->fWriteOprn  = FALSE;
    pOver->dwNumBytes  = 0;

    pBuf    = (BYTE *) &pOver->oMsg;
    AddRef(); // AddRef for this readfile call
    if (!ReadFile ( hPipe, 
                    &pBuf[pOver->dwOffset], 
                    pOver->dwBufferSize - pOver->dwOffset, 
                    &pOver->dwNumBytes, 
                    pOver))
    {
        DWORD dwE = GetLastError();
        if (dwE != ERROR_IO_PENDING && dwE != ERROR_MORE_DATA)
        {
            pOver->dwRefCount = 0;
            DELETE_BYTES(pOver);
            Release();
            EXIT_WITH_LAST_ERROR();
        }
    }

    pOver->dwRefCount = 0;

 Cleanup:
    if (hr != S_OK)
    {
        m_oPipe.Close();
        m_pProcess->OnProcessDied();
    }
    m_oPipe.ReleaseHandle();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Send a message to the worker process
HRESULT
CAsyncPipe::WriteToProcess (CAsyncPipeOverlapped * pOver)
{
    HRESULT    hr      = S_OK;
    HANDLE     hPipe   = m_oPipe.GetHandle();

    // Check params
    if (pOver == NULL)
    {
        EXIT_WITH_HRESULT(E_INVALIDARG);
    }

    // Check the pipe
    if (hPipe == INVALID_HANDLE_VALUE)
    {
        DELETE_BYTES(pOver);
        pOver = NULL;
        EXIT_WITH_HRESULT(E_FAIL);
    }

    // Do the (w)rite thing
    pOver->fWriteOprn  = TRUE;

    AddRef(); // AddRef for this WriteFile
    pOver->dwRefCount = 2;
    if (!WriteFile ( hPipe, 
                     &pOver->oMsg, 
                     pOver->dwBufferSize, 
                     &pOver->dwNumBytes, 
                     pOver ))
    {
        if (GetLastError() != ERROR_IO_PENDING)
        {
            pOver->dwRefCount = 0;
            DELETE_BYTES(pOver);
            pOver = NULL;
            Release(); // For the AddRef
            EXIT_WITH_LAST_ERROR();
        }
    }

    if (InterlockedDecrement(&pOver->dwRefCount) == 0)
        DELETE_BYTES(pOver);

 Cleanup:
    if (hr != S_OK)
    {
        m_oPipe.Close();
        m_pProcess->OnProcessDied();
    }
    m_oPipe.ReleaseHandle();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Allocate a message buffer to hold dwSize bytes in it's content
HRESULT 
CAsyncPipe::AllocNewMessage(DWORD dwSize, CAsyncPipeOverlapped ** ppOut)
{
    HRESULT    hr      = S_OK;

    // Size of message overhead
    DWORD   dwOverheadSize  = CASYNPIPEOVERLAPPED_HEADER_SIZE;

    // Size of message header
    DWORD   dwMsgHeaderSize = sizeof(CAsyncMessageHeader);

    // Total size
    DWORD   dwActualSize    = 0;

    // Calculate the total size
    if (dwSize > 0)
        dwActualSize = dwSize + dwOverheadSize + dwMsgHeaderSize;
    else
        dwActualSize = 1024; // default message for reading

    if (ppOut == NULL)
    {
        EXIT_WITH_HRESULT(E_INVALIDARG);        
    }
    
    // Alloc mem for the total size
    (*ppOut) = (CAsyncPipeOverlapped*) NEW_CLEAR_BYTES(dwActualSize);

    ON_OOM_EXIT((*ppOut));

    (*ppOut)->pCompletion  = this;
    (*ppOut)->dwBufferSize = dwActualSize - dwOverheadSize;


 Cleanup:
    if (hr != S_OK)
    {
        m_oPipe.Close();
        m_pProcess->OnProcessDied();
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
HRESULT
CAsyncPipe::QueryInterface(REFIID iid, void **ppvObj)
{
    if (iid == IID_IUnknown || iid == __uuidof(ICompletion))
    {
        *ppvObj = this;
        AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////
//
ULONG
CAsyncPipe::AddRef()
{
    return InterlockedIncrement(&m_lPendingReadWriteCount);
}

/////////////////////////////////////////////////////////////////////////////
//
ULONG
CAsyncPipe::Release()
{
    return InterlockedDecrement(&m_lPendingReadWriteCount);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CAsyncPipe::ProcessCompletion(
        HRESULT      hr2, 
        int          numBytes, 
        LPOVERLAPPED pOver)
{
	HRESULT                hr          = hr2;
    HANDLE                 hPipe       = m_oPipe.GetHandle();
    CAsyncPipeOverlapped * pOverlapped = reinterpret_cast<CAsyncPipeOverlapped *> (pOver);

    ////////////////////////////////////////////////////////////
    // Step 0: Make sure the pipe is working and params are correct
    if (hPipe == INVALID_HANDLE_VALUE || pOverlapped == NULL)
    {
        if (FAILED(hr) == FALSE) // make sure hr indicates failed
            hr = E_FAIL;
        if (pOverlapped != NULL)
        {
            if (!pOverlapped->fWriteOprn)
            {
                ReturnResponseBuffer(pOverlapped);
            }
            else
            {
                if (InterlockedDecrement(&pOverlapped->dwRefCount) == 0)                
                    DELETE_BYTES(pOverlapped);
            }
            pOverlapped = NULL;
        }
        EXIT();
    }

    ////////////////////////////////////////////////////////////
    // Step 1: Check is the oprn failed
    if (hr != S_OK)
    {
        DWORD dwBytes =  0;

#if DBG
        BOOL result =
#endif

        GetOverlappedResult(hPipe, pOverlapped, &dwBytes, FALSE);
        
        ASSERT(result == FALSE);

        ////////////////////////////////////////////////////////////
        // Step 2: Handle buffer-too-small case

        // Special case: If it failed due to insufficient buffer, 
        //  then realloc and try again
        if (GetLastError() == ERROR_MORE_DATA)
        {
            // Allocate a new one to hold enough data
            CAsyncPipeOverlapped * pNew = NULL;
            hr = AllocNewMessage(pOverlapped->oMsg.oHeader.lDataLength, &pNew);
            ON_ERROR_EXIT();
        
            // Copy the old contents
            memcpy(&pNew->oMsg, &pOverlapped->oMsg, dwBytes);

            // Set the offset so that the new data is appended
            pNew->dwOffset = dwBytes;

                
            // Start another read with new struct
            hr = StartRead(pNew); // Retry

            while(pOverlapped->dwRefCount)
                Sleep(0);
            DELETE_BYTES(pOverlapped);
        }
        EXIT();
    }


    ////////////////////////////////////////////////////////////
    // Step 3: If a write oprn succeeded, then tell the parent,
    //         so that it can free buffers, etc...
    if (pOverlapped->fWriteOprn)
    {
        m_pProcess->OnWriteComplete(pOverlapped);
    }
    else
    {
        // Make sure we read at least the size of a valid response struct
        DWORD    dwTotalSize = numBytes + pOverlapped->dwOffset;
        DWORD    dwHeader1   = sizeof(CAsyncMessage) - 4;
        DWORD    dwHeader2   = sizeof(CResponseStruct) - 4;            
      
        if (dwTotalSize < dwHeader1 + dwHeader2 || dwTotalSize - dwHeader1 <  (DWORD) pOverlapped->oMsg.oHeader.lDataLength)
        {
            ASSERT(FALSE);
            InterlockedIncrement(&g_lSecurityIssueBug129921_a);
            EXIT_WITH_HRESULT(E_UNEXPECTED);
        }

        ////////////////////////////////////////////////////////////
        // Step 4: If a read oprn succeeded, then first, copy the
        //         message, and start a fresh read

        m_pProcess->NotifyHeardFromWP();

        if ( pOverlapped->oMsg.oHeader.eType == EMessageType_Response || 
             pOverlapped->oMsg.oHeader.eType == EMessageType_Response_And_DoneWithRequest ||
             pOverlapped->oMsg.oHeader.eType == EMessageType_Response_ManagedCodeFailure  )
        {
            CResponseStruct * pResponseStruct = reinterpret_cast<CResponseStruct *> (pOverlapped->oMsg.pData);
            BOOL              fServerTooBusy  = FALSE;

            if ( dwTotalSize - (dwHeader1 + dwHeader2) >  4 * sizeof(DWORD) + 3 && 
                 pResponseStruct->eWriteType == EWriteType_FlushCore)
            {
                LPDWORD pInts  = (LPDWORD) pResponseStruct->bufStrings;
                LPSTR   szStr  = (LPSTR) &pResponseStruct->bufStrings[4 * sizeof(DWORD)];
                if (pInts[0] > 2 && szStr[0] == '5' && szStr[1] == '0' && szStr[2] == '3')
                    fServerTooBusy = TRUE;
            }

            if (!fServerTooBusy)
                m_pProcess->NotifyResponseFromWP();
        }

        while(pOverlapped->dwRefCount)
            Sleep(0);

        if (pOverlapped->oMsg.oHeader.eType == EMessageType_Response_Empty)
        {
            m_pProcess->NotifyResponseFromWP();

            // Start another read on buffer pOverlapped
            pOverlapped->fWriteOprn  = FALSE;
            pOverlapped->dwNumBytes  = 0;
            pOverlapped->dwOffset    = 0;

            hr = StartRead(pOverlapped); 
            ON_ERROR_EXIT();
            EXIT();
        }




        LONG   lReqID     = pOverlapped->oMsg.oHeader.lRequestID;

        // Add it to the Queue of work items for this request
        hr = CRequestTableManager::AddWorkItem(lReqID, EWorkItemType_ASyncMessage, (BYTE *) pOverlapped);
        if (hr != S_OK)
        {   // This implies that the request is probably dead 
            ReturnResponseBuffer(pOverlapped);
            hr = S_OK;
        }

        pOverlapped = CFreeBufferList::GetBuffer();
        ON_OOM_EXIT(pOverlapped);
        pOverlapped->pCompletion = this;

        // Start another read on buffer pOverlapped
        pOverlapped->fWriteOprn  = FALSE;
        pOverlapped->dwNumBytes  = 0;
        pOverlapped->dwOffset    = 0;

        hr = StartRead(pOverlapped); 
        ON_ERROR_EXIT();
        
        ////////////////////////////////////////////////////////////
        // Step 5: Inform the parent. Note: Parent will free the buffer
        m_pProcess->ExecuteWorkItemsForRequest(lReqID);
    }


    ////////////////////////////////////////////////////////////
    // Done!
    hr = S_OK;

 Cleanup:
    if (hr != S_OK)
    {
        Close();
        m_pProcess->OnProcessDied();
    }

    Release(); // Release for this completion
    return hr;
}

/////////////////////////////////////////////////////////////////////////////

void
CAsyncPipe::ReturnResponseBuffer(CAsyncPipeOverlapped * pOver)
{
    DWORD  dwMsgSize  = sizeof(CAsyncPipeOverlapped) + pOver->dwBufferSize - sizeof(CAsyncMessage);
    if (dwMsgSize == DEFAULT_RESPONSE_BUF_SIZE)
        CFreeBufferList::ReturnBuffer(pOver);
    else
        DELETE_BYTES(pOver);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void
CFreeBufferList::ReturnBuffer(CAsyncPipeOverlapped * pBuffer)
{
    if (g_lNumBufs > 1000) // Make sure free list does not exceed 1000
    {
        DELETE_BYTES(pBuffer);
        return;
    }

    g_lLock.AcquireWriterLock();
    pBuffer->pNext = g_pHead;
    g_pHead = pBuffer;
    InterlockedIncrement(&g_lNumBufs);
    g_lLock.ReleaseWriterLock();
}

/////////////////////////////////////////////////////////////////////////////

CAsyncPipeOverlapped * 
CFreeBufferList::GetBuffer()
{
    CAsyncPipeOverlapped * pNew = NULL;
    BOOL                   fNew = TRUE;

    if (g_pHead == NULL)
    {
        pNew = (CAsyncPipeOverlapped *) NEW_CLEAR_BYTES(DEFAULT_RESPONSE_BUF_SIZE);        
    }
    else
    {
        g_lLock.AcquireWriterLock();
        if (g_pHead == NULL)
        {
            g_lLock.ReleaseWriterLock();
            pNew = (CAsyncPipeOverlapped *) NEW_CLEAR_BYTES(DEFAULT_RESPONSE_BUF_SIZE);
        }
        else
        {
            pNew = g_pHead;
            g_pHead = (CAsyncPipeOverlapped *) pNew->pNext;
            InterlockedDecrement(&g_lNumBufs);
            g_lLock.ReleaseWriterLock();
            fNew = FALSE;
        }
    }

    if (pNew == NULL)
        return NULL;
    
    pNew->dwOffset = 0;
    pNew->pNext = NULL;

    if (fNew)
    {
        pNew->dwBufferSize = DEFAULT_RESPONSE_BUF_SIZE - CASYNPIPEOVERLAPPED_HEADER_SIZE;
    }

    return pNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\curproc.cxx ===
/**
 * Functionality to find the current processor
 * 
 * Copyright (c) 2002 Microsoft Corporation
 */

// class implementing the processor finder

#include "precomp.h"

class CCurrentProcessor {

private:
    DWORD_PTR	*m_pGDTTable;
    DWORD_PTR	*m_pProcTable;
    UINT_PTR	m_uNumProcs;
    DWORD		m_rdwTemp[2];

public:
    int Init() {
        DWORD_PTR	dwProcessMask;
        DWORD_PTR	dwSystemMask;
        DWORD_PTR	dwThreadMask;
        DWORD_PTR	dwOldThreadMask;
        UCHAR		rb[6];
        DWORD_PTR	pGDT; 
        UINT_PTR	uProc;
        SYSTEM_INFO	si;

        m_uNumProcs = 0;
        GetSystemInfo (&si);
        m_pGDTTable = new DWORD_PTR[si.dwNumberOfProcessors];
        m_pProcTable = new DWORD_PTR[si.dwNumberOfProcessors];

        GetProcessAffinityMask(GetCurrentProcess(), &dwProcessMask, &dwSystemMask);
        dwThreadMask = 1;
        uProc = 0;

        while (dwProcessMask) {
            dwOldThreadMask = SetThreadAffinityMask(GetCurrentThread(), dwThreadMask);

            if (dwOldThreadMask != 0) {
                _asm sgdt rb;
                SetThreadAffinityMask(GetCurrentThread(), dwOldThreadMask);

                pGDT = *(DWORD_PTR *)&rb[2];

                m_pGDTTable[m_uNumProcs] = pGDT;
                m_pProcTable[m_uNumProcs] = uProc;

                m_uNumProcs++;
            }

            dwProcessMask = dwProcessMask & ~dwThreadMask;
            dwThreadMask <<= 1;
            uProc++;
        }

        return ((int)m_uNumProcs);
    }

    inline int GetCurrentProcessor() {
        int iResult;

        _asm {
            mov	    ebx, this
            sgdt    [ebx].m_rdwTemp+2
            mov	    eax, [ebx].m_rdwTemp+4
            mov	    edx, [ebx].m_uNumProcs
            mov	    ecx, [ebx].m_pGDTTable
        SearchLoop:
            cmp	    eax, [edx*4+ecx - 4]
            je	    Done
            sub	    edx,1
            jnc	    SearchLoop
            sub	    edx, edx
        Done:
            mov	    ecx, [ebx].m_pProcTable
            mov	    eax, [edx*4+ecx - 4]
            mov	    iResult, eax
        }

        return iResult;    
    }
};

// APIs callable from managed code

CCurrentProcessor g_CurProc;
int  g_CurProcInitResult = 0;
BOOL g_fCurProcInited = FALSE;
LONG g_CurProcInitLock = 0;
		
int __stdcall CurProcInitialize() {
    if (!g_fCurProcInited) {

        while (InterlockedCompareExchange(&g_CurProcInitLock, 1, 0) != 0)
            SwitchToThread();

        if (!g_fCurProcInited) {
            g_CurProcInitResult = g_CurProc.Init();
            g_fCurProcInited = TRUE;
        }

        InterlockedExchange(&g_CurProcInitLock, 0);
    }

    return g_CurProcInitResult;
}

int __stdcall CurProcGetReading() {
    return g_CurProc.GetCurrentProcessor();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\ciisinfo.h ===
/**
 * ciisinfo.h
 *
 * Header file for CRegInfo
 * 
 * Copyright (c) 1998-2001, Microsoft Corporation
 * 
 */
#pragma once

#include "_ndll.h"
#include "regiis.h"
#include "ary.h"
#include "aspnetverlist.h"

#define REG_CLEANUP_SAME_PATH   0x00000001

class CRegInfo {
public:
    DECLARE_MEMCLEAR_NEW_DELETE();
    
    CRegInfo();
    ~CRegInfo();
    
    static  HRESULT RegCleanup(DWORD dwFlags);
    static  HRESULT RemoveRelatedKeys(WCHAR *pchVer);
    static  HRESULT RemoveKeyFromRegistry(WCHAR *pchParent, WCHAR *pchKey);
    static  HRESULT IsAllVerDeleted(BOOL *pfResult);
    static  HRESULT EnumKeyWithVer( WCHAR *pchParent, WCHAR *pchVer, CStrAry *pcsKeys );
    static  HRESULT GetIISVersion( DWORD *pdwMajor, DWORD *pdwMinor );
    static  HRESULT GetHighestVersion(ASPNETVER *pVer);
    static  HRESULT ReadRegValue(HKEY hKey, WCHAR *pchKey, WCHAR *pchValue, WCHAR **ppchResult);
    static  HRESULT IsVerInstalled(ASPNETVER *pVer, BOOL *pfInstalled);
    
    HRESULT     GetVerInfoList(ASPNETVER *pVerRoot, CASPNET_VER_LIST *pList);
    
    HRESULT     InitHighestInfo(ASPNETVER *pVerExclude);
    WCHAR       *GetHighestVersionDefaultDoc() 
                    { ASSERT(m_fInitHighest); return m_pchHighestVersionDD; }
    WCHAR       *GetHighestVersionMimemap() 
                    { ASSERT(m_fInitHighest); return m_pchHighestVersionMM; }
    
    WCHAR       *GetHighestVersionDllPath() 
                    { ASSERT(m_fInitHighest); return m_pchHighestVersionDll; }
                    
    WCHAR       *GetHighestVersionFilterPath() 
                    { ASSERT(m_fInitHighest); return m_pchHighestVersionFilter; }


    WCHAR       *GetHighestVersionInstallPath() 
                    { ASSERT(m_fInitHighest); return m_pchHighestVersionInstallPath; }
    
    CStrAry     *GetActiveDlls() { ASSERT(m_fInitHighest); return &m_ActiveDlls; }
    
    ASPNETVER   *GetMaxVersion() 
                    { ASSERT(m_fInitHighest); 
                      return m_verMaxVersion.IsValid() ? &m_verMaxVersion : NULL; }

    static
    HRESULT     OpenVersionKey(ASPNETVER *pVer, WCHAR sSubkey[], size_t cchSubkey, HKEY *pKey);

private:
    BOOL        m_fInitHighest;

    WCHAR       *m_pchHighestVersionDD; // Default Document property from highest version
    WCHAR       *m_pchHighestVersionMM; // Mimemap settings from highest version
    
    WCHAR       *m_pchHighestVersionDll; // Full Dll path of highest version
    WCHAR       *m_pchHighestVersionFilter; // Full isapi filter path of highest version

    WCHAR       *m_pchHighestVersionInstallPath; // Install path of the highest version
    
    WCHAR       *m_pchDDAlloc;
    WCHAR       *m_pchMMAlloc;
    WCHAR       *m_pchDllAlloc;
    WCHAR       *m_pchFilterAlloc;
    WCHAR       *m_pchInstallAlloc;


    CStrAry     m_ActiveDlls;

    ASPNETVER   m_verMaxVersion;

    static  
    HRESULT     DetectMissingDll(ASPNETVER *pVer, BOOL *pfMissing);
    
    static
    HRESULT     IsSamePathKey(ASPNETVER *pVer, BOOL *pfResult);

    static
    HRESULT     RemoveKeyWithVer( WCHAR *pchParent, WCHAR *pchVer );
    
    void        CleanupHighestVersionInfo();

    HRESULT     EnumRegistry(DWORD dwActions, ASPNETVER *pVerExclude,                             
                            CASPNET_VER_LIST *pVerInfo, ASPNETVER *pRootVer);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\cpuentry.cxx ===
/**
 * Process Model: CPU Entry defn file
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

/////////////////////////////////////////////////////////////////////////////
// This file defines the class: CCPUEntry. For each CPU on which ASP.NET Process
// model works, we create an instance of this class. It has a pointer to the
// active CProcessEntry object and a linked list of CProcessEntry objects 
// that are shutting down.
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "util.h"
#include "AckReceiver.h"
#include "RequestTableManager.h"
#include "httpext6.h"
#include "CPUEntry.h"
#include "ProcessTableManager.h"
#include "HistoryTable.h"
#include "PerfCounters.h"
#include "EcbImports.h"
#include "msg.h"
#include "_ndll.h"

extern BOOL       g_fShuttingDown;

#define  MIN_PROC_REPLACE_WAIT_TIME        5

long g_lWaitingRequests = 0;
char * g_szTooBusy = NULL;
int    g_iSZTooBusyLen = 0;
long g_lPopulateTooBusy = 0;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CTor
CCPUEntry::CCPUEntry() : m_oLock("CCPUEntry")
{
    InitializeCriticalSection(&m_oCSDyingList);
    InitializeCriticalSection(&m_oCSReplaceProcess);
}

/////////////////////////////////////////////////////////////////////////////
// DTor
CCPUEntry::~CCPUEntry()
{
    if (m_pActiveProcess != NULL)
        delete m_pActiveProcess;

    if (m_pDyingProcessListHead)
    {
        for(CProcessEntry * pTemp = m_pDyingProcessListHead; pTemp != NULL; pTemp = m_pDyingProcessListHead)
        {
            m_pDyingProcessListHead = m_pDyingProcessListHead->GetNext();
            delete pTemp;
        }
    }

    DeleteCriticalSection(&m_oCSDyingList);
    DeleteCriticalSection(&m_oCSReplaceProcess);
}

/////////////////////////////////////////////////////////////////////////////
// Create it: Give the CPU number on which it acts
void
CCPUEntry::Init(DWORD dwCPUNumber)
{
    m_dwCPUNumber = dwCPUNumber;
    m_dwCPUMask = (1 << dwCPUNumber);
    m_dwNumProcs = 0;
}

/////////////////////////////////////////////////////////////////////////////
// Create a new process: Make the new one the active one.
HRESULT
CCPUEntry::ReplaceActiveProcess(BOOL fSendDebugMsg)
{
    if (g_fShuttingDown == TRUE)
        return E_FAIL;

    EnterCriticalSection(&m_oCSReplaceProcess);

    if ( m_tmProcessReplaced.IsSet() && 
         m_tmProcessReplaced.AgeInSeconds() < MIN_PROC_REPLACE_WAIT_TIME)
    {
        LeaveCriticalSection(&m_oCSReplaceProcess);
        return ( (m_pActiveProcess != NULL) ? S_OK : E_FAIL);
    } 


    HRESULT         hr             = S_OK;
    CProcessEntry * pOld           = NULL;
    CProcessEntry * pNew           = NULL;

    ////////////////////////////////////////////////////////////
    // Step 1: Get the process number
    DWORD dwNum = InterlockedIncrement((LONG *) &m_dwNumProcs);
    dwNum = dwNum << 8;
    dwNum += m_dwCPUNumber;

    ////////////////////////////////////////////////////////////
    // Step 2: Create the proccess
    pNew = new CProcessEntry(this, m_dwCPUMask, dwNum);
    ON_OOM_EXIT(pNew);

    hr = pNew->Init();
    if (hr != S_OK) 
    {  // Add pNew to the dying list
        EnterCriticalSection(&m_oCSDyingList); // Lock for the Dying list
        pNew->SetNext(m_pDyingProcessListHead);
        m_pDyingProcessListHead = pNew;
        LeaveCriticalSection(&m_oCSDyingList);
    }
    ON_ERROR_EXIT();

    ////////////////////////////////////////////////////////////
    // Step 3: Make the new process the active process: Need to lock
    m_oLock.AcquireWriterLock(); // Get a write lock for changing m_pActiveProcess
    pOld = m_pActiveProcess;
    m_pActiveProcess = pNew;
    m_oLock.ReleaseWriterLock();

    ////////////////////////////////////////////////////////////
    // Step 4: Add the old process to the dying list and send kill message 
    if (pOld != NULL)
    {        
        pOld->AddRef();

        // Increment the worker restart counter
        PerfIncrementGlobalCounter(ASPNET_WPS_RESTARTS_NUMBER);

        // Add to dying list
        EnterCriticalSection(&m_oCSDyingList); // Lock for the Dying list
        pOld->SetNext(m_pDyingProcessListHead);
        m_pDyingProcessListHead = pOld;
        LeaveCriticalSection(&m_oCSDyingList);

        // Send the kill message
        SwitchToThread(); // Make sure the thread gets swapped out: Just an optimization
        if (pOld->GetProcessStatus() == EProcessState_Running)
            Sleep(1000);
        pOld->SendKillMessage(fSendDebugMsg ? 2 : 0);

        pOld->Release();
    }

 Cleanup:
    m_tmProcessReplaced.SnapCurrentTime();
    LeaveCriticalSection(&m_oCSReplaceProcess);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Delete CProcessEntry structs for dead processes
void
CCPUEntry::CleanUpOldProcesses()
{
    if (g_fShuttingDown == TRUE)
        return;

    if (m_pDyingProcessListHead == NULL) // Nothing to do
        return;

    CProcessEntry *       pDelHead  = NULL;
    CProcessEntry *       pNext     = NULL;
    CProcessEntry *       pBefore   = NULL;

    ////////////////////////////////////////////////////////////
    // Step 1: Lock the Dying list
    EnterCriticalSection(&m_oCSDyingList);
    pBefore = m_pDyingProcessListHead;    

    ////////////////////////////////////////////////////////////
    // Step 2: Iterate through all dying processes and see which ones we can nuke
    for (CProcessEntry * pProcess = m_pDyingProcessListHead; pProcess != NULL; pProcess = pNext)
    {
        pNext = pProcess->GetNext();

        ////////////////////////////////////////////////////////////
        // Step 3: Ask the process: Is your Ref-Count zero and is the worker process dead? 
        if ( pProcess->CanBeDestructed() && 
             CRequestTableManager::GetNumRequestsForProcess(pProcess, ERequestStatus_DontCare) == 0)
        {
            if (m_pDyingProcessListHead == pProcess)
                pBefore = m_pDyingProcessListHead = pNext;
            else
                pBefore->SetNext(pNext);

            ////////////////////////////////////////////////////////////
            // Step 4: Insert this  into the delete list
            pProcess->SetNext(pDelHead);
            pDelHead = pProcess;
        }
        else
        {
            pBefore = pProcess;

            if (pProcess->IsKillImmediateSent() == FALSE)
            {
                if ((pProcess->GetLastKillTime()).AgeInSeconds() > (DWORD) ((50 * CProcessTableManager::GetTerminateTimeout()) / 60))
                    pProcess->SendKillMessage(TRUE);
            }
            else
            {
                if ((pProcess->GetLastKillTime()).AgeInSeconds() > (DWORD) ((10 * CProcessTableManager::GetTerminateTimeout()) / 60) )
                {
                    pProcess->Terminate();
                }
            }
        }
    }
    LeaveCriticalSection(&m_oCSDyingList);

    ////////////////////////////////////////////////////////////
    // Step 5: Free the delete list
    for (pProcess = pDelHead; pProcess != NULL; pProcess = pNext)
    {
        pProcess->UpdateStatusInHistoryTable(EReasonForDeath_RemovedFromList);
        pNext = pProcess->GetNext();
        CRequestTableManager::DeleteRequestsForProcess(pProcess); // Cleanup the request table

        pProcess->Terminate(); // Make sure pipes are closed
        if (pProcess->CanBeDestructed())
            delete pProcess;
    }
}

/////////////////////////////////////////////////////////////////////////////
// Close all pipes
void
CCPUEntry::CloseAll()
{
    if (m_pActiveProcess != NULL)
        m_pActiveProcess->Close(FALSE);

    EnterCriticalSection(&m_oCSDyingList);
    for(CProcessEntry * pTemp = m_pDyingProcessListHead; pTemp != NULL; pTemp = pTemp->GetNext())
        pTemp->Close(FALSE);
    LeaveCriticalSection(&m_oCSDyingList);
}

/////////////////////////////////////////////////////////////////////////////
// Write the "too busy" message

void
CCPUEntry::WriteBusyMsg(
        EXTENSION_CONTROL_BLOCK * pEcb)
{
    if (g_szTooBusy == NULL)
        PopulateServerTooBusy();

    DWORD bytes = g_iSZTooBusyLen;
    pEcb->dwHTTPStatusCode = 500;

    (*pEcb->ServerSupportFunction)(
            pEcb->ConnID,
            HSE_REQ_SEND_RESPONSE_HEADER,
            "503 Service Unavailable",
            NULL,
            (LPDWORD)"Content-Type: text/html\r\n\r\n");

    (*pEcb->WriteClient)(
            pEcb->ConnID,
            g_szTooBusy,
            &bytes,
            0);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
void
CCPUEntry::PopulateServerTooBusy()
{
    if (g_szTooBusy != NULL)
        return;

    HRESULT  hr      = S_OK;
    WCHAR *  szTemp  = NULL;
    char  *  szTempA = NULL;
    DWORD    dwTemp   = 0;
    int      iLen, iter;

    if (InterlockedIncrement(&g_lPopulateTooBusy) == 1)
    {
        szTemp = new (NewClear) WCHAR[2048];
        ON_OOM_EXIT(szTemp);

        dwTemp = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, 
                              g_rcDllInstance, IDS_SERVER_TOO_BUSY, 0, 
                              szTemp, 2048, NULL);
        ON_ZERO_EXIT_WITH_LAST_ERROR(dwTemp);

        iLen = lstrlen(szTemp);

        if (iLen < 1)
            EXIT_WITH_HRESULT(E_UNEXPECTED);

        szTempA = new (NewClear) char[2 * iLen + 100]; // Never freed by design: ManuVa
        ON_OOM_EXIT(szTempA);

        WideCharToMultiByte(CP_ACP, 0, szTemp, iLen, szTempA, 2 * iLen + 98,  NULL, NULL);

        if (szTempA[0] == NULL)
        {
            delete [] szTempA;
            szTempA = NULL;
            EXIT_WITH_HRESULT(E_UNEXPECTED);
        }
        g_iSZTooBusyLen = lstrlenA(szTempA);
        g_szTooBusy = szTempA;
    }
    else
    {
        for(iter=0; iter<6000 && g_szTooBusy == NULL; iter++) // Sleep at most 10 minutes
            Sleep(100);
        if (g_szTooBusy == NULL)
            EXIT_WITH_WIN32_ERROR(ERROR_TIMEOUT);
    }
    
 Cleanup:
    if (g_szTooBusy == NULL)
    {
        szTempA = "<html><body><h1>Server is too busy</h1></body></html>";
        g_iSZTooBusyLen = lstrlenA(szTempA);
        g_szTooBusy = szTempA;
    }         
    delete [] szTemp;

    if (g_iSZTooBusyLen > lstrlenA(g_szTooBusy))
        g_iSZTooBusyLen = lstrlenA(g_szTooBusy);
}

/////////////////////////////////////////////////////////////////////////////
// Assign a request to the active process
HRESULT
CCPUEntry::AssignRequest(EXTENSION_CONTROL_BLOCK * iECB, BOOL fFirstAttempt)
{
    HRESULT            hr            = S_OK;
    CProcessEntry *    pProcToAssign = GetActiveProcess();
    CRequestEntry      oEntry;
    DWORD              dwReqsWaiting = 0;

    InterlockedIncrement(&m_dwTotalRequests);

    /////////////////////////////////////////////////////////////
    // Step 1: Make sure we have an active process
    if (pProcToAssign == NULL)
    {
        // Create a new process
        hr = ReplaceActiveProcess();
        ON_ERROR_EXIT();

        pProcToAssign = GetActiveProcess();
    }


    // If the active process is starting up, then wait for it
    if (pProcToAssign != NULL && pProcToAssign->GetProcessStatus() == EProcessState_Starting)
    {
        pProcToAssign->WaitForProcessToStart();
    }

    if (pProcToAssign != NULL)
	{
        int iNumExecuting = pProcToAssign->GetNumRequestStat(1);
        if (iNumExecuting  > 0 && (DWORD) iNumExecuting > CProcessTableManager::GetRequestQLimit())
        {
            WriteBusyMsg(iECB);
            EcbDoneWithSession(iECB, 1, 4);

            // Increment the requests rejected counter
            PerfIncrementGlobalCounter(ASPNET_REQUESTS_REJECTED_NUMBER);

            hr  = S_OK;
            EXIT();
        }
    }

    ////////////////////////////////////////////////////////////
    // Step 2: If Active process is not running, then create a new one
    if (pProcToAssign != NULL && pProcToAssign->GetProcessStatus() != EProcessState_Running)
    {
        (pProcToAssign->GetHistoryEntry()).eReason = EReasonForDeath((pProcToAssign->GetHistoryEntry()).eReason | EReasonForDeath_ProcessCrash);
        pProcToAssign->Release();
        pProcToAssign = NULL;
        
        // See how many requests are waiting for this wp:
        dwReqsWaiting = (DWORD) InterlockedIncrement(&g_lWaitingRequests);

        // If restart-Q is more than configured value, then exit immediately
        if (dwReqsWaiting > 1 && dwReqsWaiting > CProcessTableManager::GetRestartQLimit())
        {
            InterlockedDecrement(&g_lWaitingRequests);
            EXIT_WITH_HRESULT(E_FAIL);
        }

        // Create a new process
        hr = ReplaceActiveProcess();
        InterlockedDecrement(&g_lWaitingRequests);
        ON_ERROR_EXIT();
        
        pProcToAssign = GetActiveProcess();
    }
   
    ON_ZERO_EXIT_WITH_LAST_ERROR(pProcToAssign);

    ////////////////////////////////////////////////////////////
    // Step 3: Add the request to the request table
    ZeroMemory(&oEntry, sizeof(oEntry));
    
    if (CProcessTableManager::GetWillRequestsBeAcknowledged())
        oEntry.eStatus = ERequestStatus_Pending;
    else
        oEntry.eStatus = ERequestStatus_Executing;
    oEntry.pProcess   = pProcToAssign;
    oEntry.iECB       = iECB;
    
    hr = CRequestTableManager::AddRequestToTable(oEntry);
    ON_ERROR_EXIT();

    ////////////////////////////////////////////////////////////
    // Step 4: Send the request to the worker process
    hr = pProcToAssign->SendRequest(iECB, oEntry.lRequestID);
    ON_ERROR_CONTINUE();
        
    if (hr != S_OK) // If it failed
    {
        if (CRequestTableManager::RemoveRequestFromTable(oEntry.lRequestID) != S_OK)
        {
            // Unable to remove request from table: The only valid scenaio in which this
            // can happen is that a thread has removed it and called DoneWSession.
            //   In this scenario, we want to make sure that DoneWSession is not called
            //   twice. So, pretend that everything worked, and return as if the request
            //   was assigned properly.
            hr = S_OK;
        }
    }


//////////////////////////////////////////////////////////////////////
// Old code for trying again to assign a request, if the first try failed
//      if (hr != S_OK) // If it failed
//      {
//          ////////////////////////////////////////////////////////////
//          // Step 5: It may fail because the health monitoring thread 
//          //          swapped out the active process: Check for this condition
//          BOOL fTryAgain = (m_pActiveProcess != pProcToAssign);
//          // Another condition: Worker process died before we could write to it.
//          //    For this, if this is the first attemp at sending the request, try
//          //      it again.
//          if (fTryAgain == FALSE && fFirstAttempt == TRUE)
//              fTryAgain = (pProcToAssign->GetUpdatedStatus() != EProcessState_Running);            
//
//          if (fTryAgain == TRUE)
//          {
//              // First, cleanup, and then try again
//              CRequestTableManager::RemoveRequestFromTable(oEntry.lRequestID);
//              hr = AssignRequest(iECB, FALSE); // Try it again
//          }
//      }
//////////////////////////////////////////////////////////////////////

 Cleanup:    
    if (pProcToAssign != NULL)
        pProcToAssign->Release();    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Get an add-refed pointer to the active process
CProcessEntry * 
CCPUEntry::GetActiveProcess()
{
    CProcessEntry * pProc = NULL;

    m_oLock.AcquireReaderLock();

    pProc = m_pActiveProcess;
    if (pProc != NULL)
        pProc->AddRef();

    m_oLock.ReleaseReaderLock();

    return pProc;
}

/////////////////////////////////////////////////////////////////////////////
// Handle process death notification from the pipes
void
CCPUEntry::OnProcessDeath(CProcessEntry * pProcess)
{
    if (g_fShuttingDown == TRUE)
        return;

    HRESULT       hr            = S_OK;
    BOOL          fEnterCalled  = FALSE;
    LONG *        pReqIDArray   = NULL;
    int           iter          = 0;

    if (pProcess == m_pActiveProcess) // If the active process died, 
    {   //                               then create a new active process
        (pProcess->GetHistoryEntry()).eReason = EReasonForDeath((pProcess->GetHistoryEntry()).eReason | EReasonForDeath_ProcessCrash);
        hr = ReplaceActiveProcess();
        ON_ERROR_CONTINUE();
        hr = S_OK;
    }

    ////////////////////////////////////////////////////////////
    // Step 1: Lock everything: This function is rare and we don't want
    //         the any other thread's interference
    EnterCriticalSection(&m_oCSDyingList);
    fEnterCalled  = TRUE;

    // Reassign all requests (same as when shutdown is acked)
    OnShutdownAcknowledged(pProcess);

    ////////////////////////////////////////////////////////////
    // Step 2: Get the number of executing requests for this process
    int iNumExecuting = CRequestTableManager::GetNumRequestsForProcess(pProcess, ERequestStatus_Executing);
    if (iNumExecuting < 1)
    {
        EXIT();
    }

    ////////////////////////////////////////////////////////////
    // Step 3: Alloc memory to get the list of IDs of executing requets 
    pReqIDArray = new (NewClear) LONG[iNumExecuting];
    ON_OOM_EXIT(pReqIDArray);

    hr = CRequestTableManager::GetRequestsIDsForProcess(pProcess, ERequestStatus_Executing, pReqIDArray, iNumExecuting);
    ON_ERROR_EXIT();

    for(iter=0; iter<iNumExecuting; iter++)
    {
        if (S_OK == CRequestTableManager::AddWorkItem(pReqIDArray[iter], EWorkItemType_CloseWithError, (BYTE *) 1))
            pProcess->ExecuteWorkItemsForRequest(pReqIDArray[iter]);
    }

 Cleanup:
    
    if (fEnterCalled == TRUE)
        LeaveCriticalSection(&m_oCSDyingList);
    // CRequestTableManager::DeleteRequestsForProcess(pProcess); // Cleanup the request table
    if (pReqIDArray != NULL)
        delete [] pReqIDArray;
}

/////////////////////////////////////////////////////////////////////////////
// Shutdown was sent to a process and it has acknowledged it
void 
CCPUEntry::OnShutdownAcknowledged(CProcessEntry * pOld)
{
    if (g_fShuttingDown == TRUE)
        return;

    HRESULT             hr            = S_OK;
    LONG *              pReqIDArray   = NULL;
    int                 iter          = 0;
    CProcessEntry *     pActiveProc   = NULL;

    // Shutdown message was acknowledged for this process.
    //   This implies that no more requests will be executed by this process

    ////////////////////////////////////////////////////////////
    // Step 1: Lock everything: This function is rare and we don't want
    //         the health monitoring thread or re-entrance
    EnterCriticalSection(&m_oCSDyingList);
    ////////////////////////////////////////////////////////////
    // Step 2: Get the number of pending requests for this process
    int iNumPending = CRequestTableManager::GetNumRequestsForProcess(pOld, ERequestStatus_Pending);
    if (iNumPending < 1)
    {
        EXIT(); // Normal case
    }

    ////////////////////////////////////////////////////////////
    // Step 3: Get the active process: We'll re-assign to this
    //         process
    pActiveProc = GetActiveProcess();

    if (pActiveProc == NULL)
    {
        hr = ReplaceActiveProcess();
        ON_ERROR_EXIT();

        pActiveProc = GetActiveProcess();
    }

    if (pActiveProc == NULL)
    {
        EXIT(); 
    }

    
    ////////////////////////////////////////////////////////////
    // Step 4: Alloc memory to get the list of IDs of pending requests
    pReqIDArray = new (NewClear) LONG[iNumPending];
    ON_OOM_EXIT(pReqIDArray);

    hr = CRequestTableManager::GetRequestsIDsForProcess(pOld, ERequestStatus_Pending, pReqIDArray, iNumPending);
    ON_ERROR_EXIT();

    CRequestTableManager::ReassignRequestsForProcess(pOld, pActiveProc, ERequestStatus_Pending);

    for(iter=0; iter<iNumPending; iter++)
    {
        CRequestEntry oEntry;
        if (CRequestTableManager::GetRequest(pReqIDArray[iter], oEntry) == S_OK)
        {
            pActiveProc->SendRequest(oEntry.iECB, pReqIDArray[iter]);
        }
    }

 Cleanup:
    if (pActiveProc != NULL)
        pActiveProc->Release();
    if (pReqIDArray != NULL)
        delete [] pReqIDArray;
    LeaveCriticalSection(&m_oCSDyingList);
}

/////////////////////////////////////////////////////////////////////////////
// Called by Processes to increment / decrement active request count
void
CCPUEntry::IncrementActiveRequestCount(LONG lValue)
{

    if (lValue == 1) // normal case
        InterlockedIncrement(&m_lActiveRequestCount);

    if (lValue == -1) // normal case
        InterlockedDecrement(&m_lActiveRequestCount);

    if (lValue > 1 || lValue < -1) // unlikely -- happens when a process crashes
    {
        LONG   lOld   = m_lActiveRequestCount;
        LONG   lNew   = lValue + lOld;

        if (InterlockedCompareExchange(&m_lActiveRequestCount, lNew, lOld) != lOld)
        {
            if (lValue < 0)
            {
                lValue = -lValue;
                for(LONG iter=0; iter<lValue; iter++)
                    InterlockedDecrement(&m_lActiveRequestCount);
            }
            else
            {
                for(LONG iter=0; iter<lValue; iter++)
                    InterlockedIncrement(&m_lActiveRequestCount);
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// 
CProcessEntry *
CCPUEntry::FindProcess(DWORD dwProcNum)
{
    CProcessEntry * pProc = GetActiveProcess();
    if (pProc != NULL && pProc->GetProcessNumber() == dwProcNum)
        return pProc;

    if (pProc != NULL)
        pProc->Release();

    EnterCriticalSection(&m_oCSDyingList);
    for (pProc = m_pDyingProcessListHead; pProc != NULL; pProc = pProc->GetNext())
    {
        if (pProc->GetProcessNumber() == dwProcNum)
        {
            pProc->AddRef();
            break;
        }
    }
    LeaveCriticalSection(&m_oCSDyingList);

    return pProc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\ciisinfo.cxx ===
/**
 * CRegInfo.cxx
 * 
 * Helper class for regiis.cxx
 * 
 * Copyright (c) 2001, Microsoft Corporation
 * 
 */

#include "precomp.h"
#include "_ndll.h"
#include "ciisinfo.h"
#include "regiis.h"
#include "register.h"
#include "ary.h"
#include "event.h"
#include "aspnetverlist.h"

#define ACTION_GET_HIGHEST_INFO         0x00000001
#define ACTION_SKIP_MISSING_DLL         0x00000002
#define ACTION_GET_VER_INFO             0x00000004
#define ACTION_FIND_HIGHEST_VERSION 0x00000008


CRegInfo::CRegInfo() {
    m_pchHighestVersionDD = NULL;
    m_pchHighestVersionMM = NULL;
    m_pchHighestVersionDll = NULL;
    m_pchHighestVersionFilter = NULL;
    m_pchHighestVersionInstallPath = NULL;
    
    m_pchDDAlloc = NULL;
    m_pchMMAlloc = NULL;
    m_pchDllAlloc = NULL;
    m_pchFilterAlloc = NULL;
    m_pchInstallAlloc = NULL;

    m_fInitHighest = FALSE;
}

CRegInfo::~CRegInfo() {
    CleanupHighestVersionInfo();
    CleanupCStrAry(&m_ActiveDlls);
}

void
CRegInfo::CleanupHighestVersionInfo() {
    delete [] m_pchDDAlloc;
    delete [] m_pchMMAlloc;
    delete [] m_pchDllAlloc;
    delete [] m_pchFilterAlloc;
    delete [] m_pchInstallAlloc;
}
    

HRESULT
CRegInfo::ReadRegValue(HKEY hKey, WCHAR *pchKey, WCHAR *pchValue, WCHAR **ppchResult) {
    HRESULT     hr = S_OK;
    LONG        sc = ERROR_SUCCESS;
    DWORD       iSize;
    WCHAR *     pchBuf = NULL;

    *ppchResult = NULL;

    sc = RegQueryValueEx( hKey, pchValue, NULL, NULL, NULL, &iSize);
    ON_WIN32_ERROR_EXIT(sc);

    pchBuf = new WCHAR[iSize/sizeof(WCHAR)+1];
    ON_OOM_EXIT(pchBuf);

    sc = RegQueryValueEx(hKey, pchValue, NULL, NULL, (LPBYTE)pchBuf, &iSize);
    ON_WIN32_ERROR_EXIT(sc);

    *ppchResult = pchBuf;
    pchBuf = NULL;

Cleanup:
    if (hr) {
        CHAR *  szLogAlloc = NULL;
        CHAR *  szLog;
        WCHAR * wszKeyValue = NULL;
        int     len;

        len = lstrlenW(pchKey) + 1 + lstrlenW(pchValue) + 1;
        wszKeyValue = new WCHAR[len];
        if (wszKeyValue == NULL) {
            szLog = "Reading the registry";
        }
        else {
            StringCchCopyW(wszKeyValue, len, pchKey);
            StringCchCatW(wszKeyValue, len, L"/");
            StringCchCatW(wszKeyValue, len, pchValue);
            
            szLog = SpecialStrConcatForLogging(wszKeyValue, "Reading the registry: ", &szLogAlloc);
        }
        
        CSetupLogging::Log(1, "CRegInfo::ReadRegValue", 0, szLog);        
        CSetupLogging::Log(hr, "CRegInfo::ReadRegValue", 0, szLog);        

        delete [] szLogAlloc;
        delete [] wszKeyValue;
    }

    delete [] pchBuf;
    return hr;
}


/**
 * This function will read the DllFullPath value from the registry, and
 * detect if the Dll is missing or not.
 *
 * Params:
 *  pVer        Version of the Dll from which we want to read the value
 *  pfMissing   Returned result.
 */
HRESULT
CRegInfo::DetectMissingDll(ASPNETVER *pVer, BOOL *pfMissing) {
    HRESULT     hr = S_OK;
    WCHAR       sKey[MAX_PATH];
    HKEY        hSubkey = NULL;
    WCHAR       *pchPath = NULL;
    BOOL        fRet;

    *pfMissing = TRUE;
    
    hr = OpenVersionKey(pVer, sKey, ARRAY_SIZE(sKey), &hSubkey);
    ON_ERROR_EXIT();
   
    hr = ReadRegValue(hSubkey, sKey, REGVAL_DLLFULLPATH, &pchPath);
    ON_ERROR_EXIT();

    fRet = PathFileExists(pchPath);
    if (!fRet) {
        if (SCODE_CODE(GetLastError()) != ERROR_FILE_NOT_FOUND) {
            EXIT_WITH_LAST_ERROR();
        }
        else {
            EXIT();
        }
    }

    *pfMissing = FALSE;
    
Cleanup:
    if (hr == S_OK && *pfMissing) {
        WCHAR   pchVer[MAX_PATH];
        
        pVer->ToString(pchVer, MAX_PATH);
        XspLogEvent(IDS_EVENTLOG_DETECT_DLL_MISSING, 
                        L"%s^%s", pchPath, pchVer);    
    }
    
    delete [] pchPath;

    if (hSubkey)
        RegCloseKey(hSubkey);
    
    return hr;
}


/**
 * This function will remove the specified key under the specified parent
 * from the registry.
 */
HRESULT
CRegInfo::RemoveKeyFromRegistry(WCHAR *pchParent, WCHAR *pchKey)
{
    HRESULT     hr = S_OK;
    LONG        sc;
    HKEY        hKey = NULL;

    sc = RegOpenKeyEx( HKEY_LOCAL_MACHINE, pchParent, 0, KEY_READ|KEY_WRITE|DELETE, &hKey);
    if (sc == ERROR_PATH_NOT_FOUND) {
        EXIT();
    }
    ON_WIN32_ERROR_EXIT(sc);

    sc = SHDeleteKey(hKey, pchKey);
    if (sc == ERROR_FILE_NOT_FOUND || sc == ERROR_PATH_NOT_FOUND) {
        sc = S_OK;
    }
    ON_WIN32_ERROR_EXIT(sc);

Cleanup:
    if (hKey)
        RegCloseKey(hKey);
    
    return hr;
}

/**
 * This function enumerate all the subkeys of pchParent and delete those that
 * match ASP.NET*[ver] wher [ver] is provided by caller, and * means wildchar
 *
 * Params:
 *  pchParent       Parent key
 *  pchVer          Version String.  If NULL, then it'll machine any version.
 */
HRESULT
CRegInfo::RemoveKeyWithVer( WCHAR *pchParent, WCHAR *pchVer) {
    HRESULT     hr = S_OK;
    int         iKey;
    CStrAry     csKeys;

    hr = EnumKeyWithVer( pchParent, pchVer, &csKeys );
    ON_ERROR_EXIT();
    
    // Go through the list of entries and delete each key
    for( iKey = 0; iKey < csKeys.Size(); iKey++ ) {
        hr = RemoveKeyFromRegistry(pchParent, csKeys[iKey]);
        ON_ERROR_CONTINUE();
    }

Cleanup:
    CleanupCStrAry(&csKeys);
    
    return hr;
}

/**
 * This function enumerate all the subkeys of pchParent that
 * matches ASP.NET*[ver] wher [ver] is provided by caller, and * means wildchar
 *
 * Params:
 *  pchParent       Parent key
 *  pchVer          Version String.  If NULL, then it'll machine any version.
 */
HRESULT
CRegInfo::EnumKeyWithVer( WCHAR *pchParent, WCHAR *pchVer, CStrAry *pcsKeys ) {
    HRESULT     hr = S_OK;
    HKEY        hKey = NULL;
    LONG        sc = ERROR_SUCCESS;
    WCHAR       pchKey[MAX_PATH];
    DWORD       iKeyLength;
    WCHAR       *pchT;
    int         iKey;

    memset(pchKey, 0, sizeof(pchKey));

    // Open the system's "Services" key and start enumerating them
    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pchParent, 0, KEY_READ|DELETE, &hKey);
    ON_WIN32_ERROR_EXIT(hr);

    for(iKey = 0;; iKey++) {
        iKeyLength = MAX_PATH - 1;    // Will fail if string longer than 255.  But that shouldn't happen
        sc = RegEnumKeyEx( hKey, iKey, pchKey, &iKeyLength, 
                                NULL, NULL, NULL, NULL );
        if (sc == ERROR_NO_MORE_ITEMS) {
            break;
        }
        
        ON_WIN32_ERROR_EXIT(sc);

        // First make sure it starts with "ASP.NET"
        if (wcsncmp(PERF_SERVICE_PREFIX_L, pchKey, PERF_SERVICE_PREFIX_LENGTH) != 0) {
            continue; // Skip it
        }

        if (pchVer) {
            // Next, see if it contains the version
            if ((pchT = wcsstr(pchKey, pchVer)) == NULL) {
                continue; // Skip it
            }

            // Last, see if the contained version string is the last part
            if (wcscmp(pchT, pchVer) != 0) {
                continue; // Skip it
            }
        }

        // Save it
        hr = AppendCStrAry(pcsKeys, pchKey);
        ON_ERROR_EXIT();
    }
    
Cleanup:
    if (hKey)
        RegCloseKey(hKey);

    return hr;
}



/**
 * This function will remove all keys that match the specified version from:
 * - /HKLM/System/CurrentControlSet/Services/
 * - /HKLM/System/CurrentControlSet/Services/Eventlog/Application/
 */
HRESULT
CRegInfo::RemoveRelatedKeys(WCHAR *pchVer)
{
    HRESULT     hr = S_OK;
    
    CSetupLogging::Log(1, "CRegInfo::RemoveRelatedKeys", 0, "Removing ASP.NET registry keys");

    // Remove from /HKLM/System/CurrentControlSet/Services/
    hr = RemoveKeyWithVer(REGPATH_SERVICES_KEY_L, pchVer);
    ON_ERROR_EXIT();

    // Remove from /HKLM/System/CurrentControlSet/Services/Eventlog/Application/
    hr = RemoveKeyWithVer(REGPATH_EVENTLOG_APP_L, pchVer);
    ON_ERROR_EXIT();
    
Cleanup:
    CSetupLogging::Log(hr, "CRegInfo::RemoveRelatedKeys", 0, "Removing ASP.NET registry keys");
    return hr;
}


HRESULT
CRegInfo::IsSamePathKey(ASPNETVER *pVer, BOOL *pfResult) {    
    HRESULT     hr = S_OK;
    HKEY        hSubkey = NULL;
    WCHAR       *pchPath = NULL;
    WCHAR       sKey[MAX_PATH];

    *pfResult = FALSE;
    
    // Skip current one
    if ((*pVer) == ASPNETVER::ThisVer()) {
        EXIT();
    }
    
    hr = OpenVersionKey(pVer, sKey, ARRAY_SIZE(sKey), &hSubkey);
    ON_ERROR_EXIT();
   
    hr = ReadRegValue(hSubkey, sKey, REGVAL_DLLFULLPATH, &pchPath);
    ON_ERROR_EXIT();

    // Delete the key if the contained fullpath matches that of the current one
    if (_wcsicmp(pchPath, Names::IsapiFullPath()) == 0) {
        *pfResult = TRUE;
    }

Cleanup:
    delete [] pchPath;

    if (hSubkey)
        RegCloseKey(hSubkey);
    
    return hr;
}


/*
 * This function will go through all version keys in the registry, pick the
 * one with the highest version #, and read its 'Default Document', 'Mimemap'
 * and 'Aspnet Dll fullpath' values.  The function will skip any Dlls that
 * are missing.  For all non-missing Dlls, it will record a list of them in
 * m_ActiveDlls.
 *
 * If an error occured during the search, it uses the values from the current 
 * installing Dll.
 *
 * Parameters:
 *  pVerExclude - If it's non-Null, then the function will skip all entries
 *                with that same version while it's doing highest version
 *                comparison.
 */
HRESULT
CRegInfo::InitHighestInfo(ASPNETVER *pVerExclude) {
    HRESULT hr;
    m_fInitHighest = TRUE;
    
    CSetupLogging::Log(1, "InitHighestInfo", 0, "Getting highest version information from registry");        
    hr = EnumRegistry(ACTION_GET_HIGHEST_INFO|ACTION_SKIP_MISSING_DLL, 
                            pVerExclude, NULL, NULL);
    ON_ERROR_EXIT();
Cleanup:
    CSetupLogging::Log(hr, "InitHighestInfo", 0, "Getting highest version information from registry");        
    return hr;
}


/*
 * This function will go through all version keys in the registry, and for each
 * version, read its Dll Path, Version, and Status (i.e. Root? Valid? Dll Missing?)
 *
 * Parameters:
 *  pVerRoot    An ASPNETVER class object that specify the version installed at the
 *              IIS root.  It has to be provided by the caller in order to do
 *              root version comparison.  If NULL, then no version comparison is done.
 *  pList       Returned result.
 */
HRESULT
CRegInfo::GetVerInfoList(ASPNETVER *pVerRoot, CASPNET_VER_LIST *pList) {
    return EnumRegistry(ACTION_GET_VER_INFO, NULL, pList, pVerRoot);
}


/*
 * This function will go through all version keys in the registry, and carry
 * out the actions as specified in dwActions.
 *
 * Parameters:
 *  dwActions:
 *  ACTION_GET_HIGHEST_INFO     Read info from the "highest" version.  Info include
 *                              'Default Document', 'Mimemap' and 'Aspnet Dll fullpath'.
 *                              A caller can specify pVerExclude to exclude a specific
 *                              version.
 *  ACTION_SKIP_MISSING_DLL     It will skip all Dlls that are missing from the file system
 *                              when enumerating the registry.
 *  ACTION_GET_VER_INFO         For each version as specified in the registry, it records its
 *                              Dll Path, Version, and Status (i.e. Root? Valid? Dll Missing?)
 *                              using a CASPNET_VER_LIST class object.
 *  ACTION_FIND_HIGHEST_VERSION Just detect the highest version
 *
 *  pVerExclude                 If it's non-Null, then the function will skip all entries
 *                              with that same version when enumerating the registry
 *  pVerInfo                    The returned result when ACTION_GET_VER_INFO is specified
 *  pRootVer                    The root version used for comparison.  Supplied by caller
 *                              when ACTION_GET_VER_INFO is used.  If NULL, then no
 *                              version comparison is done.
 */
HRESULT
CRegInfo::EnumRegistry(DWORD dwActions, ASPNETVER *pVerExclude,  
                        CASPNET_VER_LIST *pVerInfo, ASPNETVER *pRootVer) {
    HRESULT     hr = S_OK;
    LONG        sc = ERROR_SUCCESS;
    DWORD       iKey = 0, iKeyLength/*, iCurLength = 0*/;
    WCHAR       pchKey[MAX_PATH], sSubkey[MAX_PATH];
    ASPNETVER   verMaxVersion, verCur;
    HKEY        hKey = NULL, hSubkey = NULL;
    WCHAR       *pchDllPath = NULL, *pchDupDllPath = NULL, *pchInstallPath = NULL;
    BOOL        fGetHighestInfo;
    BOOL        fSkipMissingDll;
    BOOL        fGetVerInfo;
    BOOL        fFindHighest;       // If TRUE, we will look for the highest version

    fGetHighestInfo = !!(dwActions & ACTION_GET_HIGHEST_INFO);
    fSkipMissingDll = !!(dwActions & ACTION_SKIP_MISSING_DLL);
    fGetVerInfo = !!(dwActions & ACTION_GET_VER_INFO);
    
    fFindHighest = !!(dwActions & ACTION_FIND_HIGHEST_VERSION) || fGetHighestInfo;

    // First, key all the keys underneath HKLM\SOFTWARE\Microsoft\ASP.NET
    sc = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGPATH_MACHINE_APP_L, 0, KEY_READ, &hKey);
    ON_WIN32_ERROR_EXIT(sc);

    for(iKey = 0;; iKey++) {
        iKeyLength = MAX_PATH - 1;    // Will fail if string longer than 255.  But that shouldn't happen
        sc = RegEnumKeyEx( hKey, iKey, pchKey, &iKeyLength, 
                                NULL, NULL, NULL, NULL );
        if (sc == ERROR_NO_MORE_ITEMS) {
            break;
        }
        
        ON_WIN32_ERROR_EXIT(sc);

        // Create the version string.  Version has this form: Major.Minor.Build.QFE
        if (verCur.Init(pchKey)) {
            BOOL    fMissing;

            hr = DetectMissingDll(&verCur, &fMissing);
            if (hr) {
                // An error happened.  Just skip this DLL.
                hr = S_OK;
                continue;
            }

            if (fSkipMissingDll && fMissing) {
                continue;
            }

            // Caller can exclude a specific version
            if (pVerExclude && verCur == *pVerExclude) {
                continue;
            }

            // Find highest version if asked for it.
            if (fFindHighest && verCur > verMaxVersion) {
                verMaxVersion = verCur;
            }

            // Read additional information if asked for it
            if (fGetHighestInfo || fGetVerInfo) {
                WCHAR   sKey[MAX_PATH];
                
                hr = OpenVersionKey(&verCur, sKey, ARRAY_SIZE(sKey), &hSubkey);
                ON_ERROR_EXIT();
   
                hr = ReadRegValue(hSubkey, sKey, REGVAL_DLLFULLPATH, &pchDllPath);
                if (hr == S_OK) {
                    if (fGetHighestInfo) {
                        // Add to Active DLLs except current.  This list is used for registering
                        // Dlls to ISAPI-Inproc.  RegisterIIS in regiis.cxx will always add the 
                        // current Dll to ISAPI-Inproc (just to make sure that get added even though
                        // this function fails)
                        if (_wcsicmp(pchDllPath, Names::IsapiFullPath()) != 0) {
                            pchDupDllPath = DupStr(pchDllPath);
                            ON_OOM_EXIT(pchDupDllPath);
                            
                            hr = m_ActiveDlls.Append(pchDupDllPath);
                            ON_ERROR_EXIT();
                            
                            pchDupDllPath = NULL;
                        }
                    }

                    if (fGetVerInfo) {
                        do {
                            DWORD   dwStatus = 0;
                            
                            if (fMissing) {
                                dwStatus |= ASPNET_VERSION_STATUS_INVALID;
                            }
                            else {
                                dwStatus |= ASPNET_VERSION_STATUS_VALID;
                            }

                            if (pRootVer && pRootVer->Equal(pchKey)) {
                                dwStatus |= ASPNET_VERSION_STATUS_ROOT;
                            }

                            // We want to read the installation path as well.                        
                            hr = ReadRegValue(hSubkey, pchKey, REGVAL_PATH, &pchInstallPath);
                            if (hr != S_OK) {
                                break;
                            }
                            
                            hr = pVerInfo->Add(pchKey, dwStatus, pchDllPath, pchInstallPath);
                            ON_ERROR_CONTINUE();
                        } while(0);
                    }
                    
                }
            }

            // Cleanup

            delete [] pchDllPath;
            pchDllPath = NULL;
            
            delete [] pchInstallPath;
            pchInstallPath = NULL;
            
            // Close the opened key
            RegCloseKey(hSubkey);
            hSubkey = NULL;
        }
    }

    if (fFindHighest) {
        m_verMaxVersion = verMaxVersion;
        
        if (!m_verMaxVersion.IsValid()) {
            EXIT_WITH_WIN32_ERROR(ERROR_NOT_FOUND);
        }
    }
    
    if (fGetHighestInfo) {

        // Now read the values for:
        // - Max Version Default Document
        // - Max Version Mimemap
        // - Max Version Dll Path

        // For Default Document and Mimemap, we take the ones from the highest version #
        hr = OpenVersionKey(&verMaxVersion, sSubkey, ARRAY_SIZE(sSubkey), &hSubkey);
        ON_ERROR_EXIT();

        // Default Doc
        hr = ReadRegValue(hSubkey, sSubkey, REGVAL_DEFDOC, &m_pchDDAlloc);
        ON_ERROR_EXIT();

        // Mimemap
        hr = ReadRegValue(hSubkey, sSubkey, REGVAL_MIMEMAP, &m_pchMMAlloc);
        ON_ERROR_EXIT();

        m_pchHighestVersionDD = m_pchDDAlloc;
        m_pchHighestVersionMM = m_pchMMAlloc;

        // For Dll Path (which is used for Filter and "be the next highest one" during 
        // uninstallation, we take the ones from the highest version
        hr = ReadRegValue(hSubkey, sSubkey, REGVAL_DLLFULLPATH, &m_pchDllAlloc);
        ON_ERROR_EXIT();

        m_pchHighestVersionDll = m_pchDllAlloc;

        // Install Directory
        hr = ReadRegValue(hSubkey, sSubkey, REGVAL_PATH, &m_pchInstallAlloc);
        ON_ERROR_EXIT();
        m_pchHighestVersionInstallPath = m_pchInstallAlloc;

        // Filter
    
        size_t size = lstrlenW(m_pchHighestVersionInstallPath) + 1 + lstrlenW(FILTER_MODULE_FULL_NAME_L) + 1;
        m_pchFilterAlloc = new WCHAR[size];
        ON_OOM_EXIT(m_pchFilterAlloc);

        StringCchCopyW(m_pchFilterAlloc, size, m_pchHighestVersionInstallPath);
        StringCchCatW(m_pchFilterAlloc, size, PATH_SEPARATOR_STR_L);
        StringCchCatW(m_pchFilterAlloc, size, FILTER_MODULE_FULL_NAME_L);
        
        m_pchHighestVersionFilter = m_pchFilterAlloc;

    }

Cleanup:
    if (hKey)
        RegCloseKey(hKey);

    if (hSubkey)
        RegCloseKey(hSubkey);

    delete [] pchDllPath;

    delete [] pchDupDllPath;

    delete [] pchInstallPath;
    
    if (hr) {
        if (fGetHighestInfo) {
            CleanupHighestVersionInfo();
            
            m_pchHighestVersionDD = DEFAULT_DOC;
            m_pchHighestVersionMM = MIMEMAP;
            m_pchHighestVersionDll = (WCHAR*)Names::IsapiFullPath();
            m_pchHighestVersionFilter = (WCHAR*)Names::FilterFullPath();
            m_pchHighestVersionInstallPath = (WCHAR*)Names::InstallDirectory();
        }
    }

    return hr;
}



/*
 * This function will go through all version keys in the registry, and perform
 * the requested cleanup action.
 *
 * Parameters:
 *  dwFlags:
 *  REG_CLEANUP_SAME_PATH   Remove from the registry the keys of all versions that has 
 *                          the same aspnet DLL fullpath as the current one.
 */
HRESULT
CRegInfo::RegCleanup(DWORD dwFlags) {
    HRESULT     hr = S_OK;
    LONG        sc = ERROR_SUCCESS;
    int         iKey;
    DWORD       iKeyLength;
    WCHAR       pchKey[MAX_PATH];
    ASPNETVER   verCur;
    HKEY        hKey = NULL;
    WCHAR       *pchDup = NULL;
    CStrAry     csToBeDeleted;
    BOOL        fRemoveSamePath = !!(dwFlags & REG_CLEANUP_SAME_PATH);
    
    CSetupLogging::Log(1, "CleanupRegistry", 0, "Cleaning up registry");

    // First, key all the keys underneath HKLM\SOFTWARE\Microsoft\ASP.NET
    sc = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGPATH_MACHINE_APP_L, 0, KEY_READ, &hKey);
    ON_WIN32_ERROR_EXIT(sc);

    for(iKey = 0;; iKey++) {
        iKeyLength = MAX_PATH - 1;    // Will fail if string longer than 255.  But that shouldn't happen
        sc = RegEnumKeyEx( hKey, iKey, pchKey, &iKeyLength, 
                                NULL, NULL, NULL, NULL );
        if (sc == ERROR_NO_MORE_ITEMS) {
            break;
        }
        
        ON_WIN32_ERROR_EXIT(sc);

        // Create the version string.  Version has this form: Major.Minor.Build.QFE
        if (verCur.Init(pchKey)) {
            BOOL    fSamePath;

            if (fRemoveSamePath) {
                hr = IsSamePathKey(&verCur, &fSamePath);
                if (hr == S_OK && fSamePath) {
                    hr = AppendCStrAry(&csToBeDeleted, pchKey);
                    ON_ERROR_EXIT();
                    continue;
                }
                
                ON_ERROR_EXIT();
            }
        }
    }

    // Delete the version key and all related keys
    for (iKey = 0; iKey < csToBeDeleted.Size(); iKey++) {
        hr = RemoveKeyFromRegistry(REGPATH_MACHINE_APP_L, csToBeDeleted[iKey]);
        ON_ERROR_EXIT();

        hr = RemoveRelatedKeys(csToBeDeleted[iKey]);
        ON_ERROR_EXIT();
    }

Cleanup:
    CSetupLogging::Log(hr, "CleanupRegistry", 0, "Cleaning up registry");
    
    if (hKey)
        RegCloseKey(hKey);

    delete [] pchDup;

    CleanupCStrAry(&csToBeDeleted);

    return hr;
}


/*
 * Check HKLM/Software/Microsoft/ASP.NET to see if all versions have been deleted
 *
 * Params:
 *  pfResult     - Returned flag stating if all version keys are removed
 */
HRESULT
CRegInfo::IsAllVerDeleted(BOOL *pfResult)
{
    HRESULT     hr = S_OK;
    LONG        sc;
    HKEY        hKey = NULL;
    DWORD       iKeyLength, iKey;
    WCHAR       pchKey[MAX_PATH];
    BOOL        fHasVerSubkey = FALSE;

    CSetupLogging::Log(1, "CRegInfo::IsAllVerDeleted", 0, "Checking if there are any versions of ASP.NET installed");
    
    *pfResult = FALSE;

    sc = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGPATH_MACHINE_APP_L, 0, KEY_READ|KEY_WRITE, &hKey);
    if (sc == ERROR_PATH_NOT_FOUND) {
        EXIT();
    }
    ON_WIN32_ERROR_EXIT(sc);

    // Find if we still have any version subkey.
    for(iKey = 0;; iKey++) {
        DWORD   temp[4];
        
        iKeyLength = MAX_PATH - 1;    // Will fail if string longer than 255.  But that shouldn't happen
        sc = RegEnumKeyEx( hKey, iKey, pchKey, &iKeyLength, 
                                NULL, NULL, NULL, NULL );
        if (sc == ERROR_NO_MORE_ITEMS) {
            break;
        }
        
        ON_WIN32_ERROR_EXIT(sc);

        // Check for a valid version string.  Version has this form: Major.Minor.Build.QFE
        if (swscanf(pchKey, L"%d.%d.%d.%d", &temp[0], &temp[1], &temp[2], &temp[3]) == 4)
        {
            fHasVerSubkey = TRUE;
            break;
        }
    }

    if (!fHasVerSubkey) {
        *pfResult = TRUE;
    }

Cleanup:
    CSetupLogging::Log(hr, "CRegInfo::IsAllVerDeleted", 0, "Checking if there are any versions of ASP.NET installed");
    
    if (hKey)
        RegCloseKey(hKey);
    
    return hr;
}


HRESULT
CRegInfo::GetIISVersion( DWORD *pdwMajor, DWORD *pdwMinor )
{
    HRESULT     hr = S_OK;
    LONG        sc = ERROR_SUCCESS;
    HKEY        hKey = NULL;
    DWORD       size = sizeof(DWORD);

    sc = RegOpenKeyEx( HKEY_LOCAL_MACHINE, IIS_KEY_L, 0, KEY_READ, &hKey);
    ON_WIN32_ERROR_EXIT(sc);

    sc = RegQueryValueEx(hKey, REGVAL_IIS_MAJORVER, NULL, NULL, (BYTE *)pdwMajor, &size);
    ON_WIN32_ERROR_EXIT(sc);

    sc = RegQueryValueEx(hKey, REGVAL_IIS_MINORVER, NULL, NULL, (BYTE *)pdwMinor, &size);
    ON_WIN32_ERROR_EXIT(sc);

Cleanup:
    if (hKey)
        RegCloseKey(hKey);
    
    return hr;
}


HRESULT
CRegInfo::GetHighestVersion(ASPNETVER *pVer)
{
    CRegInfo    reginfo;
    HRESULT     hr = S_OK;

    reginfo.m_fInitHighest = TRUE;

    hr = reginfo.EnumRegistry(ACTION_FIND_HIGHEST_VERSION, NULL, NULL, NULL);
    ON_ERROR_EXIT();

    if (reginfo.GetMaxVersion()) {
        pVer->Init(reginfo.GetMaxVersion());
    }
    else {
        pVer->Reset();
    }

Cleanup:
    return hr;

}

HRESULT
CRegInfo::IsVerInstalled(ASPNETVER *pVer, BOOL *pfInstalled)
{
    HRESULT hr = S_OK;
    BOOL    bMissing;

    *pfInstalled   = FALSE;

    hr = DetectMissingDll(pVer, &bMissing);
    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) {
        hr = S_OK;
        EXIT();
    }
    ON_ERROR_EXIT();

    if (!bMissing) {
        *pfInstalled = TRUE;
    }

Cleanup:
    return hr;
}


/*
 * Everyone should use this function to open an ASP.NET version registry key.
 *
 * Parameters:
 *  pver            The version to open
 *  sSubkey         A buffer to return the actual full path of the key we open
 *  cchSubkey       Size of sSubkey
 *  pKey            The returned HKEY
 */
HRESULT
CRegInfo::OpenVersionKey(ASPNETVER *pVer, WCHAR sSubkey[], size_t cchSubkey, HKEY *pKey) {
    HRESULT     hr = S_OK;
    LONG        sc = ERROR_SUCCESS;

    *pKey = NULL;

    if (S_OK != StringCchPrintf( 
                sSubkey, cchSubkey, 
                L"%s\\%d.%d.%d.%d", REGPATH_MACHINE_APP_L, 
                pVer->Major(), pVer->Minor(), 
                pVer->Build(), pVer->QFE()
                )
    ) {
        EXIT_WITH_WIN32_ERROR(ERROR_BUFFER_OVERFLOW);
    }
    
    sc = RegOpenKeyEx( HKEY_LOCAL_MACHINE, sSubkey, 0, KEY_READ, pKey);
    ON_WIN32_ERROR_EXIT(sc);

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\cpuentry.h ===
/**
 * CPU Entry header file
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

/////////////////////////////////////////////////////////////////////////////
// This file defines the class: CCPUEntry. For each CPU on which ASP.NET Process
// model works, we create an instance of this class. It has a pointer to the
// active CProcessEntry object and a linked list of CProcessEntry objects 
// that are shutting down.
/////////////////////////////////////////////////////////////////////////////

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _CPUEntry_H
#define _CPUEntry_H

#include "ProcessEntry.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Data structure for each CPU used by the process model
class CCPUEntry
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    // CTor and DTors
    CCPUEntry                                    ();
    ~CCPUEntry                                   ();

    // Init method: NOT Thread safe
    void                Init                     (DWORD dwCPUNumber); // CPU number, not mask

    // Recycle the process
    HRESULT             ReplaceActiveProcess     (BOOL fSendDebugMsg = FALSE);

    // Cleanup all dead processes
    void                CleanUpOldProcesses      ();

    // Execute request
    HRESULT             AssignRequest            (EXTENSION_CONTROL_BLOCK *  iECB, 
                                                  BOOL fFirstAttempt = TRUE);

    // A shutdown request has been acknoledged: sent by any old CProcessEntry
    void                OnShutdownAcknowledged   (CProcessEntry * pOld);

    // Get a safe (add-refed) handle to the active process
    CProcessEntry *     GetActiveProcess         ();

    // Called by Processes to increment / decrement active request count
    void                IncrementActiveRequestCount   (LONG lValue );

    // Get the count of active requests
    LONG                GetActiveRequestCount    () { return m_lActiveRequestCount; }

    DWORD               GetTotalRequestsAssigned () { return m_dwTotalRequests; }

    // A process died
    void                OnProcessDeath           (CProcessEntry * pProcess);

    // Close all pipes
    void                CloseAll                 ();

    DWORD               GetCPUNumber             () { return m_dwCPUNumber; }

    CProcessEntry *     FindProcess              (DWORD dwProcNum);

private:
	// Write the "too busy" message
	static void         WriteBusyMsg             (EXTENSION_CONTROL_BLOCK * pECB);
    static void         PopulateServerTooBusy    ();
	
    DWORD                        m_dwCPUMask, m_dwNumProcs, m_dwCPUNumber;

    // Active process and Read-Write Lock to guard it's usage 
    CReadWriteSpinLock           m_oLock;
    CProcessEntry *              m_pActiveProcess;

    // Dying list and the critical section to control access to it
    CRITICAL_SECTION             m_oCSDyingList;
    CRITICAL_SECTION             m_oCSReplaceProcess;
    CProcessEntry *              m_pDyingProcessListHead;


    // Number of active requests
    LONG                         m_lActiveRequestCount;

    // Number of active requests
    LONG                         m_dwTotalRequests;

    
    TimeClass                    m_tmProcessReplaced;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\dbgdirect.cxx ===
/**
 * Debug callback functions though N/Direct.
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

#include "precomp.h"
#include "dbg.h"
#include "util.h"
#include "nisapi.h"
#include "names.h"

#if DBG
const WCHAR * DBGNDComponent = L"System.Web.dll";
#endif

/**
 * Output debug message.
 */
extern "C"
BOOL __stdcall
DBGNDTrace(
#if DBG       // no argument name in release mode
    LPWSTR ptag,
    LPWSTR pMessage
#else
    LPWSTR,
    LPWSTR
#endif
    )
{
#if DBG
    return DbgpTraceV(DBGNDComponent, ptag, pMessage, NULL);
#else
    return FALSE;
#endif
}



extern "C"
BOOL __stdcall
DBGNDAssert(
#if DBG
    LPSTR   message,
    LPSTR   stacktrace
#else
    LPSTR, 
    LPSTR
#endif
    )
{
#if DBG
    return DbgpAssert(DBGNDComponent, message, NULL, 0, stacktrace);
#else
    return FALSE;
#endif
}
     
extern "C"
BOOL __stdcall
DBGNDIsTagEnabled(
#if DBG
    WCHAR * tag
#else
    WCHAR * 
#endif
    )
{
#if DBG
    return DbgIsTagEnabled(tag);
#else
    return FALSE;
#endif
}

extern "C"
BOOL __stdcall
DBGNDIsTagPresent(
#if DBG
    WCHAR * tag
#else
    WCHAR * 
#endif
    )
{
#if DBG
    return DbgIsTagPresent(tag);
#else
    return FALSE;
#endif
}

extern "C"
int __stdcall
DBGNDMessageBoxOnThread(
#if DBG
    HWND hwnd,
    WCHAR *text, 
    WCHAR *caption, 
    int type
#else
    HWND,
    WCHAR *, 
    WCHAR *, 
    int
#endif
    )
{
#if DBG
    return MessageBoxOnThread(hwnd, text, caption, type);
#else
    return 0;
#endif
}


extern "C"
void __stdcall
DBGNDLaunchCordbg(
    void
    )
{
#if DBG
    DWORD   pid;
    char    buf[1024];

    pid = GetCurrentProcessId();
    StringCchPrintfA(buf, ARRAY_SIZE(buf), "cordbg.exe !a %d !g", pid);
    WinExec(buf, SW_SHOWNORMAL);
    Sleep(5000);
#endif
}


void 
PrintHardBreakMessage(LPWSTR pMessage)
{
    WCHAR       buf[4092];
    DWORD       idThread;
    DWORD       idProcess;

    idThread = GetCurrentThreadId();
    idProcess = GetCurrentProcessId();
    StringCchPrintf(buf, ARRAY_SIZE(buf), PRODUCT_NAME_L L" hard break [0x%x.%x] %s", idProcess, idThread, pMessage);
    OutputDebugString(buf);
}

/*
 * Hard break to catch stress problems in all build types.
 */
extern "C"
void __stdcall
HardBreak(LPWSTR pMessage)
{
    /*
     * We put PrintHardBreakMessage in a separate function so the stack
     * looks cleaner at the call to DebugBreak - we don't have a local buffer
     * above the stack pointer.
     */
    if (pMessage != NULL)
    {
        PrintHardBreakMessage(pMessage);
    }

    DbgBreak();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\customerror.cxx ===
/**
 * HttpCompletion implementation.
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

#include "precomp.h"
#include "dbg.h"
#include "util.h"
#include "nisapi.h"
#include "names.h"

WCHAR g_szCustomErrorFile[MAX_PATH] = L"";
BOOL g_fCustomErrorFileChanged = TRUE;

CReadWriteSpinLock g_CustomErrorLock("CustomErrorFile");

WCHAR  g_szCustomErrorRealFilename[MAX_PATH];
char *g_pCachedCustomErrorText = NULL;
DWORD g_CachedCustomErrorTextLength = 0;

DWORD g_LastCustomErrorUpdateCheck = 0;
DWORD g_LastCustomErrorFileSize = 0;
FILETIME g_LastCustomErrorFileTime = { 0, 0 };
const DWORD UpdateFrequencyTicks = 2000;

HRESULT GetCustomErrorFileInfo(WCHAR *pFileName, DWORD *pSize, FILETIME *pWriteTime) {
    HRESULT hr = S_OK;
    WIN32_FILE_ATTRIBUTE_DATA fileData;

    if (GetFileAttributesEx(pFileName, GetFileExInfoStandard, &fileData) == 0)
        EXIT_WITH_LAST_ERROR();

    if (fileData.nFileSizeHigh != 0)
        EXIT_WITH_OOM();

Cleanup:
    if (hr == S_OK) {
        *pSize = fileData.nFileSizeLow;
        *pWriteTime = fileData.ftLastWriteTime;
    }

    return hr;
}

HRESULT UpdateCachedCustomErrorText() {
    HRESULT hr = S_OK;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    DWORD bytesRead = 0;

    // clear out the old message

    delete [] g_pCachedCustomErrorText;
    g_pCachedCustomErrorText = NULL;
    g_CachedCustomErrorTextLength = 0;

    // get the real filename

    if (g_szCustomErrorFile[0] == L'\0') {
        EXIT();
    }
    else if (g_szCustomErrorFile[0] == L'\\' || g_szCustomErrorFile[1] == L':') {
        // absolute
        StringCchCopyToArrayW(g_szCustomErrorRealFilename, g_szCustomErrorFile);
    }
    else {
        // relative to config directory
        StringCchCopyToArrayW(g_szCustomErrorRealFilename, Names::GlobalConfigDirectory());
        StringCchCatToArrayW(g_szCustomErrorRealFilename, L"\\");
        if (lstrlenW(g_szCustomErrorRealFilename) + lstrlenW(g_szCustomErrorFile) > MAX_PATH-2)
            EXIT_WITH_OOM();
        StringCchCatToArrayW(g_szCustomErrorRealFilename, g_szCustomErrorFile);
    }

    // make the new message out of the file contents

    // open the file
    fileHandle = CreateFile(g_szCustomErrorRealFilename,
                             GENERIC_READ,
                             FILE_SHARE_READ, 
                             NULL, 
                             OPEN_EXISTING, 
                             FILE_ATTRIBUTE_NORMAL, 
                             NULL);

    if (fileHandle == INVALID_HANDLE_VALUE)
        EXIT_WITH_LAST_ERROR();

    // get the length
    hr = GetCustomErrorFileInfo(g_szCustomErrorRealFilename, &g_LastCustomErrorFileSize, &g_LastCustomErrorFileTime);
    g_LastCustomErrorUpdateCheck = GetTickCount();
    ON_ERROR_EXIT();

    // alloc memory for message
    g_CachedCustomErrorTextLength = g_LastCustomErrorFileSize;
    g_pCachedCustomErrorText = new (NewClear) char[g_CachedCustomErrorTextLength];
    ON_OOM_EXIT(g_pCachedCustomErrorText);

    // read it
    if (ReadFile(fileHandle, g_pCachedCustomErrorText, g_CachedCustomErrorTextLength, &bytesRead, NULL) == 0 ||
        bytesRead != g_CachedCustomErrorTextLength) {
        EXIT_WITH_LAST_ERROR();
    }

Cleanup:
    // close the file
    if (fileHandle != INVALID_HANDLE_VALUE)
        CloseHandle(fileHandle);

    if (hr != S_OK) {
        delete [] g_pCachedCustomErrorText;
        g_pCachedCustomErrorText = NULL;
        g_CachedCustomErrorTextLength = 0;
    }

    return hr;
}

BOOL WriteCustomHttpError(EXTENSION_CONTROL_BLOCK *pEcb) {
    HRESULT hr = S_OK;
    BOOL fErrorWritten = FALSE;
    DWORD numBytes = 0;

    if (g_szCustomErrorFile[0] == L'\0') {
        // no config file
        EXIT();
    }

    // check periodically if changed
    if (!g_fCustomErrorFileChanged && (GetTickCount()-g_LastCustomErrorUpdateCheck) >= UpdateFrequencyTicks) {
        g_CustomErrorLock.AcquireReaderLock();

        if (!g_fCustomErrorFileChanged) {
            DWORD fileSize;
            FILETIME fileTime;

            if (GetCustomErrorFileInfo(g_szCustomErrorRealFilename, &fileSize, &fileTime) != S_OK ||
                g_LastCustomErrorFileSize != fileSize ||
                g_LastCustomErrorFileTime.dwLowDateTime != fileTime.dwLowDateTime ||
                g_LastCustomErrorFileTime.dwHighDateTime != fileTime.dwHighDateTime) {
                // something changed or can't open the file
                g_fCustomErrorFileChanged = TRUE;
            }

            g_LastCustomErrorUpdateCheck = GetTickCount();
        }

        g_CustomErrorLock.ReleaseReaderLock();
    }

    if (g_fCustomErrorFileChanged) {

        g_CustomErrorLock.AcquireWriterLock();

        if (g_fCustomErrorFileChanged) {
            hr = UpdateCachedCustomErrorText();
            g_fCustomErrorFileChanged = FALSE;
        }

        g_CustomErrorLock.ReleaseWriterLock();

        ON_ERROR_EXIT();
    }

    g_CustomErrorLock.AcquireReaderLock();

    if (g_pCachedCustomErrorText != NULL && g_CachedCustomErrorTextLength > 0) {
        numBytes = g_CachedCustomErrorTextLength;
        (*pEcb->WriteClient)(pEcb->ConnID, g_pCachedCustomErrorText, &numBytes, 0);
        fErrorWritten = TRUE;
    }

    g_CustomErrorLock.ReleaseReaderLock();

Cleanup:
    return fErrorWritten;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\debug.cxx ===
/**
 * Debug functions.
 *
 * Copyright (C) Microsoft Corporation, 1998
 */

#include "precomp.h"
#include "names.h"

//
// private definitions of debug macros so we don't reenter
//

#undef ASSERT 
#undef ASSERTMSG
#undef VERIFY
#undef TRACE
#undef TRACE1
#undef TRACE2
#undef TRACE3
#undef TRACE_ERROR
                                    
#if DBG

extern DWORD    g_dwFALSE; // global variable used to keep compiler from complaining about constant expressions.

#if defined(_M_IX86)
    #define DbgBreak() _asm { int 3 }
#else
    #define DbgBreak() DebugBreak()
#endif

#define TAG_INTERNAL L"Internal"
#define TAG_EXTERNAL L"External"
#define TAG_ALL      L"*"

#define MKSTRING2(x) #x
#define MKSTRING(x) MKSTRING2(x)

#define ASSERT(x)                                                                                                       \
    do                                                                                                                  \
    {                                                                                                                   \
        if (!((DWORD)(x)|g_dwFALSE))                                                                                    \
        {                                                                                                               \
            OutputDebugStringA(ISAPI_MODULE_FULL_NAME " Dbg Assertion failure: " #x " " __FILE__ ":" MKSTRING(__LINE__) "\n");         \
            DbgBreak();                                                                                                 \
        }                                                                                                               \
    } while (g_dwFALSE)                                                                                                 \

#define ASSERTMSG(x, msg)                                                                                               \
    do                                                                                                                  \
    {                                                                                                                   \
        if (!((DWORD)(x)|g_dwFALSE))                                                                                    \
        {                                                                                                               \
            OutputDebugStringA(ISAPI_MODULE_FULL_NAME " Dbg Assertion failure: " #msg " " __FILE__ ":" MKSTRING(__LINE__) "\n");       \
            DbgBreak();                                                                                                 \
        }                                                                                                               \
    } while (g_dwFALSE)                                                                                                 \

#define VERIFY(x)	ASSERT(x)

#define TRACE(tag, fmt)
#define TRACE1(tag, fmt, a1)
#define TRACE2(tag, fmt, a1, a2)
#define TRACE3(tag, fmt, a1, a2, a3)

void 
DbgPrivTraceError(HRESULT hr, const char * str)
{
    if (hr == S_OK || hr == S_FALSE)
    {
        ASSERTMSG(0, ISAPI_MODULE_FULL_NAME " Dbg S_OK or S_FALSE treated as error.\n");
    }
    else if (SUCCEEDED(hr))
    {
        ASSERTMSG(0, ISAPI_MODULE_FULL_NAME " Dbg Success code treated as error. Is hr uninitialized?\n");
    }

    OutputDebugStringA(str);
}

#define TRACE_ERROR(hr)                                                                                 \
    do                                                                                                  \
    {                                                                                                   \
        DbgPrivTraceError(hr, ISAPI_MODULE_FULL_NAME " Dbg Trace error "  __FILE__ ":" MKSTRING(__LINE__) "\n");   \
    } while (g_dwFALSE)                                                                                 \

#else

#define ASSERT(x)
#define ASSERTMSG(x, sz)

#define VERIFY(x) x

#define TRACE(tag, fmt)
#define TRACE1(tag, fmt, a1)
#define TRACE2(tag, fmt, a1, a2)
#define TRACE3(tag, fmt, a1, a2, a3)

#define TRACE_ERROR(hr)

#endif

#include "util.h"
#include "pm.h"


long    g_DisableAssertThread;

#if DBG

#define TAG_ASSERT L"Assert"

#define TAGVAL_MIN      0
#define TAGVAL_DISABLED 0
#define TAGVAL_ENABLED  1
#define TAGVAL_BREAK    2
#define TAGVAL_MAX      TAGVAL_BREAK

struct BuiltinTag
{
    const WCHAR *   name;
    DWORD           value;
};

class DbgTags
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    static BOOL TraceVStatic(const WCHAR * component, WCHAR *tagname, WCHAR *format, va_list args);
    static BOOL IsTagEnabledStatic(WCHAR * tag);    
    static BOOL IsTagPresentStatic(WCHAR * tag);    
    static void StopNotificationThread();

private:
    enum TagState {TAGS_INIT, TAGS_DEFAULT, TAGS_FROMREGISTRY};

    static void     EnsureInit(void);

    void            Clear();
    void            ReadTagsFromRegistry();
    void            WriteTagsToRegistry();
    void            RevertToDefault();

    DWORD           GetBuiltInLenMaxValueName();

    int             GetCalculatedValue(const WCHAR *);
    const WCHAR *   GetName(int i);

    DWORD               RegNotifyThreadProc();
    static DWORD WINAPI RegNotifyThreadProcStatic(LPVOID);

    BOOL TraceV(const WCHAR * component, WCHAR *tagname, WCHAR *format, va_list args);
    BOOL IsTagEnabled(WCHAR * tag);    
    BOOL IsTagPresent(WCHAR * tag);    

    BOOL                _DebugInitialized; 
    TagState            _tagState;         
    int                 _numTags;          
    int                 _cchName;          
    DWORD               _lenMaxValueName;  
    WCHAR *             _tagNames;         
    int *               _tagValues;        
    int *               _tagPrefixLen;

    static HANDLE             s_hNotificationThread;
    static DbgTags *          s_tags;
    static CReadWriteSpinLock s_lock;
    static const BuiltinTag   s_builtintags[];   
    static const WCHAR        s_KeyName[];
    static const WCHAR        s_KeyListen[];
    static const WCHAR        s_BreakOnAssertName[];
    static const WCHAR        s_EnableAssertMessageName[];
};

HANDLE DbgTags::s_hNotificationThread = NULL;
DbgTags* DbgTags::s_tags = NULL;
CReadWriteSpinLock DbgTags::s_lock("DbgTags::s_lock");

const BuiltinTag  DbgTags::s_builtintags[] = 
{
    TAG_ALL,         TAGVAL_DISABLED,
    TAG_INTERNAL,    TAGVAL_ENABLED,
    TAG_EXTERNAL,    TAGVAL_ENABLED,
    TAG_ASSERT,      TAGVAL_BREAK,
};

const WCHAR      DbgTags::s_KeyName[] = REGPATH_MACHINE_APP_L L"\\Debug";
const WCHAR      DbgTags::s_KeyListen[] = L"Software\\Microsoft";
const WCHAR      DbgTags::s_BreakOnAssertName[] = L"BreakOnAssert";
const WCHAR      DbgTags::s_EnableAssertMessageName[] = L"EnableAssertMessage";

void 
DbgTags::EnsureInit()
{
    DbgTags *   tags;
    DWORD       id;
    BOOL        doinit = FALSE;

    if (s_tags != NULL)
        return;

    s_lock.AcquireWriterLock();
    __try
    {
        if (s_tags == NULL)
        {
            tags = new DbgTags();
            if (tags == NULL)
                return;

            tags->ReadTagsFromRegistry();
            doinit = TRUE;
            s_tags = tags;
        }
    }
    __finally
    {
        s_lock.ReleaseWriterLock();
    }

    if (doinit)
    {
        s_hNotificationThread = CreateThread(NULL, 0, RegNotifyThreadProcStatic, 0, 0, &id);
        if (s_hNotificationThread == NULL)
            return;
    }
}

void
DbgTags::StopNotificationThread()
{
    if (s_hNotificationThread != NULL)
    {
        TerminateThread(s_hNotificationThread, 0);
        CloseHandle(s_hNotificationThread);
        s_hNotificationThread = NULL;
    }
}


void 
DbgTags::Clear()
{
    delete [] _tagNames;
    _tagNames = NULL;
    delete [] _tagValues;
    _tagValues = NULL;
    delete [] _tagPrefixLen;
    _tagPrefixLen = NULL;

    _numTags = 0;
    _cchName = 0;

    _tagState = TAGS_INIT;
}


const WCHAR *   
DbgTags::GetName(int i)
{
    ASSERT(0 <= i && i < _numTags);
    return &_tagNames[_cchName * i];
}


int
DbgTags::GetCalculatedValue(const WCHAR * name)
{
    int i;
    int prefixLen;
    int prefixLenMax;
    int value;

    if (name == NULL)
        return TAGVAL_DISABLED;

    /*
     * Look for an exact match first
     */
    for (i = _numTags; --i >= 0;)
    {
        if (_tagPrefixLen[i] == -1 && _wcsicmp(name, GetName(i)) == 0)
        {
            return _tagValues[i];
        }
    }

    /*
     * Check prefixes. More specific (longer) prefixes override
     * less specific (shorter) ones.
     */
    prefixLenMax = -1;
    value = TAGVAL_DISABLED;
    for (i = _numTags; --i >= 0;)
    {
        prefixLen = _tagPrefixLen[i];
        if (prefixLen > prefixLenMax && _wcsnicmp(name, GetName(i), prefixLen) == 0)
        {
            value = _tagValues[i];
            prefixLenMax = prefixLen;
        }
    }

    return value;
}

DWORD
DbgTags::GetBuiltInLenMaxValueName()
{
    int     k;
    DWORD   len;

    if (_lenMaxValueName == 0)
    {
        for (k = 0; k < ARRAY_SIZE(s_builtintags); k++)
        {
            len = lstrlen(s_builtintags[k].name);
            _lenMaxValueName = max(_lenMaxValueName, len);
        }
    }

    return _lenMaxValueName;
}

void DbgTags::RevertToDefault()
{
    HRESULT hr = 0;
    int     k;
    WCHAR   *pStar;

    if (_tagState == TAGS_DEFAULT)
        return;

    /*
     * Delete old tag information.
     */
    Clear();

    /*
     * Allocate new tag information.
     */
    _numTags = ARRAY_SIZE(s_builtintags);

    _tagState = TAGS_DEFAULT;

    _cchName = (int) GetBuiltInLenMaxValueName() + 1;

    _tagNames = new (NewClear) WCHAR [(ARRAY_SIZE(s_builtintags)) * _cchName];
    ON_OOM_EXIT(_tagNames);

    _tagValues = new (NewClear) int [ARRAY_SIZE(s_builtintags)];
    ON_OOM_EXIT(_tagValues);

    _tagPrefixLen = new (NewClear) int [ARRAY_SIZE(s_builtintags)];
    ON_OOM_EXIT(_tagPrefixLen);

    for (k = 0; k < ARRAY_SIZE(s_builtintags); k++)
    {
      StringCchCopyW((WCHAR*) GetName(k), _cchName, s_builtintags[k].name);
      _tagValues[k] = s_builtintags[k].value;

        pStar = wcschr(GetName(k), L'*');
        if (pStar == NULL)
        {
            _tagPrefixLen[k] = -1;
        }
        else
        {
            _tagPrefixLen[k] = PtrToInt(pStar - GetName(k));
        }
    }

Cleanup:
    if (hr)
    {
        Clear();
    }
}


void
DbgTags::WriteTagsToRegistry()
{
    HRESULT hr = 0;
    long    result = 0;
    HKEY    key = NULL;
    int     i;
    int     value;

    result = RegCreateKeyEx(HKEY_LOCAL_MACHINE, s_KeyName, NULL, NULL,
                   0, KEY_WRITE, NULL, &key, NULL);

    ON_WIN32_ERROR_EXIT(result);

    i = _numTags; 
    while (--i >= 0)
    {
        value = _tagValues[i];
        result = RegSetValueEx(key, GetName(i), NULL, REG_DWORD, (BYTE *)&value, sizeof(value));
        ON_WIN32_ERROR_EXIT(result);
    }

Cleanup:
    if (key != NULL)
    {
        VERIFY(RegCloseKey(key) == ERROR_SUCCESS);
    }
}


void
DbgTags::ReadTagsFromRegistry()
{
    HRESULT hr = 0;
    long    result = 0;
    HKEY    key = NULL;
    DWORD   cValues;
    DWORD   lenMaxValueName;
    DWORD   regType;
    DWORD   value;
    DWORD   cbValue;
    DWORD   cbName;
    DWORD   defValue;
    int     i, j, k;
    BOOL    builtinfound[ARRAY_SIZE(s_builtintags)];
    WCHAR   *pStar;

    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, s_KeyName, 0, KEY_READ, &key);
    if (result != ERROR_SUCCESS)
    {
        RevertToDefault();
        WriteTagsToRegistry();
        return;
    }

    result = RegQueryInfoKey(
            key, NULL, NULL, 0, NULL, NULL, NULL, 
            &cValues, &lenMaxValueName, NULL, NULL, NULL);

    ON_WIN32_ERROR_EXIT(result);

    /*
     * Delete old tag information.
     */
    Clear();

    /*
     * Allocate new tag information.
     */

    /* temporary assignment to get around assertion in GetName */
    _numTags = cValues + ARRAY_SIZE(s_builtintags);

    lenMaxValueName = max(lenMaxValueName, GetBuiltInLenMaxValueName());
    _cchName = lenMaxValueName + 1;    /* add 1 for null terminator */

    _tagNames = new (NewClear) WCHAR [(cValues + ARRAY_SIZE(s_builtintags)) * _cchName];
    ON_OOM_EXIT(_tagNames);

    _tagValues = new (NewClear) int [cValues + ARRAY_SIZE(s_builtintags)];
    ON_OOM_EXIT(_tagValues);

    _tagPrefixLen = new (NewClear) int [cValues + ARRAY_SIZE(s_builtintags)];
    ON_OOM_EXIT(_tagPrefixLen);

    /*
     * Grab tag information from registry.
     */
    ZeroMemory(builtinfound, sizeof(builtinfound));

    j = 0;
    for (i = 0; i < (int) cValues; i++)
    {
        regType = REG_DWORD;
        cbName = _cchName;
        cbValue = sizeof(value);

        result = RegEnumValue(  
                key,
                i,
                (WCHAR *) GetName(j),
                &cbName,
                0,
                &regType,
                (BYTE *) &value,
                &cbValue);

        if (   result != ERROR_SUCCESS 
               || regType != REG_DWORD
               || lstrcmpi(s_BreakOnAssertName, GetName(j)) == 0
               || lstrcmpi(s_EnableAssertMessageName, GetName(j)) == 0)
        {
            continue;
        }

        defValue = TAGVAL_DISABLED;
        for (k = 0; k < ARRAY_SIZE(s_builtintags); k++)
        {
            if (lstrcmpi(s_builtintags[k].name, GetName(j)) == 0)
            {
                builtinfound[k] = TRUE;
                defValue = s_builtintags[k].value;
                break;
            }
        }

        if (value > TAGVAL_MAX)
        {
            value = defValue;
        }

        _tagValues[j] = value;

        j++;
    }

    for (k = 0; k < ARRAY_SIZE(s_builtintags); k++)
    {
        if (!builtinfound[k])
        {
	  StringCchCopyW((WCHAR*) GetName(j), _cchName, s_builtintags[k].name);
	  _tagValues[j] = s_builtintags[k].value;
	  j++;
        }
    }

    for (i = j; --i >= 0;)
    {
        pStar = wcschr(GetName(i), L'*');
        if (pStar == NULL)
        {
            _tagPrefixLen[i] = -1;
        }
        else
        {
            _tagPrefixLen[i] = PtrToInt(pStar - GetName(i));
        }
    }

    _numTags = j;
    _tagState = TAGS_FROMREGISTRY;

Cleanup:
    if (key != NULL)
    {
        RegCloseKey(key);
    }

    if (hr)
    {
        RevertToDefault();
    }
}



DWORD 
DbgTags::RegNotifyThreadProc()
{
    HKEY    key = NULL;
    long    result = ERROR_SUCCESS;
    HRESULT hr = 0;
    HANDLE  event;

    event = CreateEvent(NULL, FALSE, FALSE, FALSE);
    if (event == NULL)
        return GetLastWin32Error();

    for (;;)
    {
        result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, s_KeyListen, 0, KEY_READ, &key);
        ON_WIN32_ERROR_EXIT(result);

        VERIFY(RegNotifyChangeKeyValue(
            key,
            TRUE,
            REG_NOTIFY_CHANGE_NAME       |  
            REG_NOTIFY_CHANGE_LAST_SET,
            event,
            TRUE) == ERROR_SUCCESS);

        VERIFY(WaitForSingleObject(event, INFINITE) != WAIT_FAILED);
        VERIFY(RegCloseKey(key) == ERROR_SUCCESS);

        s_lock.AcquireWriterLock();
        __try
        {
            ReadTagsFromRegistry();
        }
        __finally
        {
            s_lock.ReleaseWriterLock();
        }
    }
    
Cleanup:
    CloseHandle(event);

    return 0;
}



DWORD WINAPI
DbgTags::RegNotifyThreadProcStatic(LPVOID)
{
    return s_tags->RegNotifyThreadProc();
}

/**
 * Squirt out a debug message using a va_list.
 *
 * @param format Sprintf-style format string with 
 *      optional control codes embedded between a 
 *      pair of \'s at the beginning of the string. 
 *      The control codes are:
 *
 *      n - supress new line
 *      p - supress prefix
 *
 *      Example: "\\p\\dir"
 */
BOOL 
DbgTags::TraceV(
        const WCHAR * component,
        WCHAR *tag,
        WCHAR *format, 
        va_list args)
{
    BOOL        newline = TRUE;
    BOOL        prefix = TRUE;
    DWORD       value;
    DWORD       idThread = 0;
    DWORD       idProcess = 0;
    int         iEndOfMsg;
    WCHAR       bufMsg[512];
    int		bufSize = 0;     
    WCHAR	*pbuf, *pbufNew;	
    WCHAR	special;	

    value = TAGVAL_DISABLED;

    s_lock.AcquireWriterLock();
    __try
    {
        value = GetCalculatedValue(tag);
    }
    __finally
    {
        s_lock.ReleaseWriterLock();
    }
    
    if (value == TAGVAL_DISABLED)
        return FALSE;

    while (format[0] == L'\\')
    {
	special = format[1];
	if (special == L'n')
	{
            newline = FALSE; 
	}
	else if (special == L'p')
	{
            prefix = FALSE;
	}
	else
	{
	    break;
	}

	format += 2;
    }

    if (prefix)
    {
        idThread = GetCurrentThreadId();
        idProcess = GetCurrentProcessId();
    }

    pbufNew = bufMsg;
    bufSize = ARRAY_SIZE(bufMsg);

    do {
	pbuf = pbufNew;
	pbufNew = NULL;

	HRESULT hr = S_OK;

	if (prefix)
	{

	  hr = StringCchPrintfW(pbuf, bufSize, L"[%x.%x %s " PRODUCT_NAME_L L" %s] ", idProcess, idThread, component, tag);
	  if (hr == S_OK)
	  {
	    iEndOfMsg = lstrlenW(pbuf);
	  }
	  else if (hr == STRSAFE_E_INSUFFICIENT_BUFFER)
          {
	    iEndOfMsg = -1;
	  }
	  else 
	  {
	    ASSERT(FALSE);
	    return FALSE;
	  }
	}
	else 
	{
	    iEndOfMsg = 0;
	}

	if (iEndOfMsg >= 0) 
        {
	    if (args != NULL)
	    {
	        hr = StringCchVPrintfW(&pbuf[iEndOfMsg], bufSize - iEndOfMsg, format, args);
		if (hr == S_OK)
		{
		  iEndOfMsg = lstrlenW(pbuf);
		}
		else if (hr == STRSAFE_E_INSUFFICIENT_BUFFER)
		{
		  iEndOfMsg = -1;
		}
		else 
		{
		  ASSERT(FALSE);
		  return FALSE;
		}
	    }
	    else
	    {
	        hr = StringCchPrintf(&pbuf[iEndOfMsg], bufSize - iEndOfMsg, L"%s", format);
		if (hr == S_OK) 
		{
		  iEndOfMsg = lstrlenW(pbuf);
		}
		else if (hr == STRSAFE_E_INSUFFICIENT_BUFFER)
		{
		  iEndOfMsg = -1;
		}
		else 
		{
		  ASSERT(FALSE);
		  return FALSE;
		}
	    }
	}

	if (iEndOfMsg < 0 || (newline && iEndOfMsg+1 >= bufSize)) {
	    bufSize *= 2;
	    pbufNew = new WCHAR[bufSize];
	}
	else {
	    if (newline)
	    {
		pbuf[iEndOfMsg] = L'\n';
		pbuf[iEndOfMsg+1] = L'\0';
	    }
	}

	if (pbufNew == NULL) {
	    OutputDebugString(pbuf);
	}

	if (pbuf != bufMsg) {
	    delete [] pbuf;
	    pbuf = NULL;
	}
    } while (pbufNew != NULL);

    return value >= TAGVAL_BREAK;
}


BOOL 
DbgTags::TraceVStatic(
        const WCHAR * component,
        WCHAR *tag,
        WCHAR *format, 
        va_list args)
{
    EnsureInit();

    if (s_tags != NULL)
        return s_tags->TraceV(component, tag, format, args);
    return FALSE;
}

BOOL
DbgTags::IsTagEnabled(WCHAR *tag)
{
    DWORD   value = TAGVAL_DISABLED;

    s_lock.AcquireReaderLock();
    __try
    {
        value = GetCalculatedValue(tag);
    }
    __finally
    {
        s_lock.ReleaseReaderLock();
    }

    return value >= TAGVAL_ENABLED;
}

BOOL
DbgTags::IsTagEnabledStatic(WCHAR *tag)
{
    EnsureInit();
    if (s_tags != NULL)
        return s_tags->IsTagEnabled(tag);
    return FALSE;
}

BOOL
DbgTags::IsTagPresent(WCHAR *tag)
{
    BOOL    result = FALSE;
    int i;

    s_lock.AcquireReaderLock();
    __try
    {
        /*
         * Look for an exact match first
         */
        for (i = _numTags; --i >= 0;)
        {
            if (_tagPrefixLen[i] == -1 && _wcsicmp(tag, GetName(i)) == 0)
            {
                result = TRUE;
                break;
            }
        }
    }
    __finally
    {
        s_lock.ReleaseReaderLock();
    }

    return result;
}

BOOL
DbgTags::IsTagPresentStatic(WCHAR *tag)
{
    EnsureInit();
    if (s_tags != NULL)
        return s_tags->IsTagPresent(tag);
    return FALSE;
}

#endif

/**
 * Squirt out a debug message.
 *
 */
extern "C"
BOOL 
DbgpTraceV(
    const WCHAR * component, 
    WCHAR * tag, 
    WCHAR *format, 
    va_list args)
{
#if DBG
    BOOL fBreak;

    fBreak = DbgTags::TraceVStatic(component, tag, format, args);

    return fBreak;
#else
    UNREFERENCED_PARAMETER(component);
    UNREFERENCED_PARAMETER(tag);
    UNREFERENCED_PARAMETER(format);
    UNREFERENCED_PARAMETER(args);
    return FALSE;
#endif
}


/**
 * Squirt out a debug message.
 *
 */
extern "C"
BOOL __cdecl
DbgpTrace(
    const WCHAR * component,
    WCHAR *tag,
    WCHAR *format, 
    ...)
{
#if DBG
    BOOL fBreak;
    va_list arg;

    va_start(arg, format);
    fBreak = DbgTags::TraceVStatic(component, tag, format, arg);
    va_end(arg);

    return fBreak;
#else
    UNREFERENCED_PARAMETER(component);
    UNREFERENCED_PARAMETER(tag);
    UNREFERENCED_PARAMETER(format);
    return FALSE;
#endif
}

/** 
 * Structure for passing data from MessageBoxOnThread to MessageBoxOnThreadFn.
 */
struct MBOT
{
    HWND hwnd;
    int result;
    WCHAR * text;
    WCHAR * caption;
    int type;
};

/**
 * Thread proc for MessageBoxOnThread
 */
DWORD WINAPI
MessageBoxOnThreadFn(
    MBOT *pmbot)
{
    // Flush any messages hanging out in the queue.
    for (int n = 0; n < 100; ++n)
    {
        MSG msg;
        PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);
    }

    pmbot->result = MessageBox(pmbot->hwnd, pmbot->text, pmbot->caption, pmbot->type);

    return 0;
}

/**
 * Display a message box on another thread. This stops
 * the current thread dead in its tracks while the 
 * message pump runs for the message box UI.
 *
 * The arguments for this function are identical to the
 * arguments for the Win32 MessageBox API.
 */

extern "C"
int 
MessageBoxOnThread(
    HWND hwnd,
    WCHAR *text, 
    WCHAR *caption, 
    int type)
{
    MBOT mbot;
    HANDLE Thread;
    DWORD dwThread;

    mbot.hwnd = hwnd;
    mbot.text = text;
    mbot.caption = caption;
    mbot.type = type;
    mbot.result = 0;

    if (g_DisableAssertThread)
    {
        MessageBoxOnThreadFn(&mbot);
    }
    else
    {
        Thread = CreateThread(
                NULL,
                0,
                (LPTHREAD_START_ROUTINE)MessageBoxOnThreadFn,
                &mbot,
                0,
                &dwThread);
        if (!Thread)
        {
            MessageBoxOnThreadFn(&mbot);
        }
        else
        {
            WaitForSingleObject(Thread, INFINITE);
            CloseHandle(Thread);
        }
    }

    return mbot.result;
}

/**
 * Disable or enable using second thread for assert message box.
 * 
 * Bad things happen if an attempt is made to start a thread during
 * calls to DLLMain(). Use this function to enable or disable 
 * the use of a second thread for the asssert message box.
 */

extern "C"
void
DbgpDisableAssertThread(BOOL disable)
{
    if (disable)
    {
        InterlockedIncrement(&g_DisableAssertThread);
    }
    else
    {
        InterlockedDecrement(&g_DisableAssertThread);
    }
}

/**
 * Display assert dialog.
 *
 * @return TRUE if caller should break into the debugger.
 */

extern "C"
BOOL
DbgpAssert(const WCHAR * component, char const *message, char const * file, int line, char const * stacktrace)
{
#if DBG
    int     id = IDIGNORE;
    BOOL    fBreak;
    DWORD   idThread, idProcess;
    WCHAR   bufMsg[8192];
    bool    fIncludeFileLine;
    
    fIncludeFileLine = (file != NULL && line > 0);
    if (message == NULL)
    {
        message = "<No Assertion Expression>";
    }

    if (fIncludeFileLine)
    {
        fBreak = DbgpTrace(component, TAG_ASSERT, L"%S\n\tFile%S:%d", message, file, line);
    }
    else if (stacktrace != NULL)
    {
        fBreak = DbgpTrace(component, TAG_ASSERT, L"%S\n%S", message, stacktrace);
    }
    else
    {
        fBreak = DbgpTrace(component, TAG_ASSERT, L"%S", message);
    }

    if (fBreak)
    {
        if (DbgTags::IsTagEnabledStatic(L"AssertBreak")) 
        {
            return TRUE;
        }

        idThread = GetCurrentThreadId();
        idProcess = GetCurrentProcessId();

        if (fIncludeFileLine)
        {
            StringCchPrintfW(
                    bufMsg, 
                    ARRAY_SIZE(bufMsg),
                    L"Component: %s\n"
                    L"PID=%d TID=%d\n"
                    L"Failed Expression: %S\n"
                    L"File %S:%d\n\n"
                    L"A=Exit process R=Debug I=Continue",
                    component,
                    idProcess, idThread,
                    message,
                    file, line);
        }
        else if (stacktrace)
        {
            StringCchPrintfW(
                    bufMsg, 
                    ARRAY_SIZE(bufMsg),
                    L"Component: %s\n"
                    L"PID=%d TID=%d\n"
                    L"Failed Expression: %S\n"
                    L"%S\n"
                    L"A=Exit process R=Debug I=Continue",
                    component,
                    idProcess, idThread,
                    message,
                    stacktrace);
        }
        else
        {
            StringCchPrintfW(
                    bufMsg, 
                    ARRAY_SIZE(bufMsg),
                    L"Component: %s\n"
                    L"PID=%d TID=%d\n"
                    L"Failed Expression: %S\n"
                    L"A=Exit process R=Debug I=Continue",
                    component,
                    idProcess, idThread,
                    message);
        }

        id = MessageBoxOnThread(NULL, bufMsg, PRODUCT_NAME_L L" Assertion", 
                MB_SERVICE_NOTIFICATION | MB_TOPMOST | 
                MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION);
    }

    if (id == IDABORT)
        TerminateProcess(GetCurrentProcess(), 1);
    
    return id == IDRETRY;
#else
    UNREFERENCED_PARAMETER(component);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(file);
    UNREFERENCED_PARAMETER(line);
    UNREFERENCED_PARAMETER(stacktrace);
    return FALSE;
#endif
}

extern "C"
BOOL
DbgpTraceError(
    HRESULT hr,
    const WCHAR * component,
    char *file,
    int line)
{
#if DBG
    WCHAR buffer[1024];

    if (hr == S_OK || hr == S_FALSE)
    {
        ASSERTMSG(0, "S_OK or S_FALSE treated as error.");
    }
    else if (SUCCEEDED(hr))
    {
        ASSERTMSG(0, "Success code treated as error. Is hr uninitialized?");
    }

    if (!FormatMessage(
            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            hr,
            LANG_SYSTEM_DEFAULT,
            buffer,
            ARRAY_SIZE(buffer),
            NULL))
    {
        buffer[0] = '\n';
        buffer[1] = '\0';
    }

    return DbgpTrace(component, TAG_INTERNAL, L"Trace error %08x %s\t%S(%d)", hr, buffer, file, line);
#else
    UNREFERENCED_PARAMETER(hr);
    UNREFERENCED_PARAMETER(component);
    UNREFERENCED_PARAMETER(file);
    UNREFERENCED_PARAMETER(line);
    return FALSE;
#endif
}


/*
 * Return whether a tag is enabled.
 */
extern "C"
BOOL 
DbgpIsTagEnabled(WCHAR * tag)
{
#if DBG
    return DbgTags::IsTagEnabledStatic(tag);
#else
    UNREFERENCED_PARAMETER(tag);
    return FALSE;
#endif
}

/*
 * Return whether a tag is present.
 */

extern "C"
BOOL 
DbgpIsTagPresent(WCHAR * tag)
{
#if DBG
    return DbgTags::IsTagPresentStatic(tag);
#else
    UNREFERENCED_PARAMETER(tag);
    return FALSE;
#endif
}


extern "C"
void
DbgpStopNotificationThread()
{
#if DBG
    DbgTags::StopNotificationThread();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\ecbdirect.h ===
/**
 * Ecbdirect.h
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _Ecbdirect_H
#define _Ecbdirect_H

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

int
EcbGetServerVariable(
    EXTENSION_CONTROL_BLOCK *pECB,
    LPCSTR pVarName, 
    LPSTR pBuffer,
    int bufferSizeInChars);

int
EcbGetUtf8ServerVariable(
    EXTENSION_CONTROL_BLOCK *pECB,
    LPCSTR pVarName, 
    LPSTR pBuffer,
    int bufferSizeInChars);


/////////////////////////////////////////////////////////////////////////////
// List of functions supported by EcbCallISAPI
//
// ATTENTION!!
// If you change this list, make sure it is in sync with the
// CallISAPIFunc enum in the UnsafeNativeMethods class
//
enum CallISAPIFunc {
	CallISAPIFunc_GetSiteServerComment = 1,
	CallISAPIFunc_SetBinAccess = 2,
    CallISAPIFunc_CreateTempDir = 3,
    CallISAPIFunc_GetAutogenKeys = 4,
    CallISAPIFunc_GenerateToken = 5
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\dirmoncompletion.cxx ===
/**
 * DirMonCompletion implementation.
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

#include "precomp.h"
#include "dbg.h"
#include "util.h"
#include "nisapi.h"
#include "dirmoncompletion.h"

//
// Global constants
//

const int g_InitialNotificationBufferSize = (4 * (sizeof(FILE_NOTIFY_INFORMATION) + (sizeof(WCHAR) * FILENAME_MAX)));
const int g_MaxNotificationBufferSize = 8 * g_InitialNotificationBufferSize;

const int g_SubdirInitialNotificationBufferSize = (8 * (sizeof(FILE_NOTIFY_INFORMATION) + (sizeof(WCHAR) * FILENAME_MAX)));
const int g_SubdirMaxNotificationBufferSize = 8 * g_SubdirInitialNotificationBufferSize;

#define ACTION_ERROR -1
#define ACTION_DISPOSE -2

//
// DirMonCompletion implementation
//

DirMonCompletion::DirMonCompletion()
{
    _dirHandle = INVALID_HANDLE_VALUE;

    TRACE3(L"FileChangesMonitorNativeConstructor", 
	   L"DirMonCompletion this=%p _dirHandle=%x _refs=%d", 
	   (void *) this, _dirHandle, Refs());

}

DirMonCompletion::~DirMonCompletion()
{
    TRACE5(L"FileChangesMonitorNativeDestructor", 
	   L"~DirMonCompletion this=%p _dirHandle=%x _dirName=%s _callback=%p _refs=%d", 
	   (void *) this, _dirHandle, _dirName, _callback, Refs());

    if (_dirHandle != INVALID_HANDLE_VALUE) {
        // We should only get here if ::Init fails
        CloseHandle(_dirHandle);
    }

    delete [] _dirName;
    delete [] _pBuffer;
}

/**
 * Open the directory and attach the handle to the completion port
 */
HRESULT
DirMonCompletion::Init(
    WCHAR *pDir,
    BOOL watchSubdirs,
    DWORD notifyFilter,
    PFNDIRMONCALLBACK callback)
{
    HRESULT hr = S_OK;
    int bufferSize;

    _watchSubdirs = watchSubdirs;
    _notifyFilter = notifyFilter;

    _dirName = DupStr(pDir);
    ON_OOM_EXIT(_dirName);

    // Allocate initial notifications buffer (large buffer for directory renames only)
    if (watchSubdirs) 
    {
        bufferSize = g_SubdirInitialNotificationBufferSize;
    }
    else 
    {
        bufferSize = g_InitialNotificationBufferSize;
    }

    _pBuffer = new BYTE[bufferSize];
    ON_OOM_EXIT(_pBuffer);

    _bufferSize = bufferSize;

    // Open the directory handle
    _dirHandle = CreateFile(
            pDir,
            FILE_LIST_DIRECTORY,
            FILE_SHARE_READ|FILE_SHARE_DELETE|FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_OVERLAPPED,
            NULL);

    if (_dirHandle == INVALID_HANDLE_VALUE)
        EXIT_WITH_LAST_ERROR();

    // Attach handle to the completion port
    hr = AttachHandleToThreadPool(_dirHandle);
    ON_ERROR_EXIT();

    // Remember the callback
    _callback = callback;

    // Start monitoring
    hr = Monitor();
    ON_ERROR_EXIT();

Cleanup:
    TRACE7(L"FileChangesMonitorNativeInit", 
	   L"Init hr=%x this=%p subdirs=%d _dirHandle=%x _dirName=%s _callback=%p _refs=%d", 
	   hr, (void *) this, _watchSubdirs, _dirHandle, _dirName, _callback, Refs());

    return hr;
}

/**
 * Stop notifications by closing the directory handle
 */
HRESULT
DirMonCompletion::Close()
{
    TRACE5(L"FileChangesMonitorNative", 
	   L"Close this=%p _dirHandle=%x _dirName=%s _callback=%p _refs=%d", 
	   (void *) this, _dirHandle, _dirName, _callback, Refs());


    HANDLE dirHandle = _dirHandle;
    if (    dirHandle != INVALID_HANDLE_VALUE &&
            InterlockedCompareExchangePointer(&_dirHandle, INVALID_HANDLE_VALUE, dirHandle) == dirHandle) {

        // This call to CloseHandle will cause the outstanding completion
        // for ReadDirectoryChangesW to complete, which will in turn decrement 
        // the ref count to 0.
        CloseHandle(dirHandle);

        // signal that we're closed by decrementing _numCalls, and
        // dispose if there are no outstanding calls
        if (InterlockedDecrement(&_numCalls) < 0) {
            __try {
                (*_callback)(ACTION_DISPOSE, NULL);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
            }
        }

        Release();  // Self-destruct
    }

    return S_OK;
}


/**
 * ICompletion callback method implementation. Call the managed runtime.
 */
HRESULT
DirMonCompletion::ProcessCompletion(
    HRESULT hr,
    int numBytes, 
    LPOVERLAPPED)
{
    TRACE7(L"FileChangesMonitorNative", 
	   L"ProcessCompletion hr=%x numBytes=%d this=%p _dirHandle=%x _dirName=%s _callback=%p _refs=%d", 
	   hr, numBytes, (void *) this, _dirHandle, _dirName, _callback, Refs());


    if (_dirHandle == INVALID_HANDLE_VALUE) {
	// I/O aborted completion due to handle closure - no need
        // to callback to client because the client caused the closure
        // and does not want to receive further notifications.
        //
        // By exiting without continuing to monitor, the last reference
        // will be dropped and this DirMonCompletion destroyed.

        // hr can be zero or non-zero
        hr = S_OK;
        EXIT();
    }

    // If an error occurred, exit and call client to cleanup.
    ON_ERROR_EXIT();

    if (numBytes == 0)
    {
        // Overwhelming changes - call callback with NULL
        CallCallback(0, NULL);

        // Try to increase the buffer size
        (void) GrowNotificationBuffer();
    }
    else 
    {
        // Process changes to files one by one
        FILE_NOTIFY_INFORMATION *pInfo;
        UINT byteIndex = 0;

        while (TRUE)
        {
            pInfo = (FILE_NOTIFY_INFORMATION *)(&_pBuffer[byteIndex]);

            ProcessOneFileNotification(pInfo);

            if (pInfo->NextEntryOffset == 0) 
                break;

            byteIndex += pInfo->NextEntryOffset;
        }
    }

    //
    // Continue monitoring
    //
    hr = Monitor();
    ON_ERROR_EXIT();

Cleanup:
    if (hr) {
	//
	// We can't continue monitoring, so we need the client to 
        // cleanup by calling DirMonClose if they haven't done so.
	//
	CallCallback(ACTION_ERROR, NULL);
    }

    Release();  // pending I/O did AddRef() - completion does Release()

    return hr;
}

/**
 * Request another change notification completion.
 */
HRESULT
DirMonCompletion::Monitor()
{
    HRESULT hr = S_OK;
    BOOL rc;
    DWORD bytes = 0;
    HANDLE dirHandle;

    dirHandle = _dirHandle;
    if (dirHandle == INVALID_HANDLE_VALUE) {
        // client closed, don't continue
        return S_OK;
    }

    ZeroMemory(_pBuffer, _bufferSize);

    AddRef();       // extra reference for every pending I/O

    rc = ReadDirectoryChangesW(
            dirHandle,
            _pBuffer,
            _bufferSize,
            _watchSubdirs,
            _notifyFilter,
            &bytes,
            Overlapped(),
            NULL);

    if (!rc)
    {
        Release();              // undo AddRef() above
        EXIT_WITH_LAST_ERROR();
    }

Cleanup:
    return hr;
}

/**
 * Call the notification callback passing the action and the file name.
 */
void
DirMonCompletion::CallCallback(
    int action,
    WCHAR *pFilename)
{
    long n;

    // check for unsuccessful initialization or closure
    if (_callback == NULL || _dirHandle == INVALID_HANDLE_VALUE)
        return;

    for (;;) 
    {
        // don't make the call if we've already disposed the delegate
        // this check will always leave _numCalls at -1 once it has reached it
        n = _numCalls;
        if (n < 0)
            return;

        // increment the number of outstanding calls
        if (InterlockedCompareExchange(&_numCalls, n + 1, n) == n)
            break;
    }

    // call the callback
    __try {
        (*_callback)(action, pFilename);

        // decrement count, and dispose if there are no more callers and
        // its been closed
        if (InterlockedDecrement(&_numCalls) < 0) {
            (*_callback)(ACTION_DISPOSE, NULL);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
    }
}

/**
 * When an overwhelming change notification comes, grow the buffer
 * to catch the next one.
 */
HRESULT
DirMonCompletion::GrowNotificationBuffer()
{
    HRESULT hr = S_OK;
    int bufferSizeMax;

    if (_watchSubdirs)
    {
        bufferSizeMax = g_SubdirMaxNotificationBufferSize;
    }
    else
    {
        bufferSizeMax = g_MaxNotificationBufferSize;
    }

    if (_bufferSize < bufferSizeMax)
    {
        int newBufferSize = 2 * _bufferSize;
        BYTE *pNewBuffer = new BYTE[newBufferSize];
        ON_OOM_EXIT(pNewBuffer);

        delete [] _pBuffer;
        _pBuffer = pNewBuffer;
        _bufferSize = newBufferSize;
    }

Cleanup:
    return hr;
}

/**
 * When walking the notifications buffer, process one file.
 */
HRESULT
DirMonCompletion::ProcessOneFileNotification(
    FILE_NOTIFY_INFORMATION *pInfo)
{
    HRESULT hr = S_OK;
    WCHAR *pFilename;
    int len;

    // Allocate and fill in the file name
    len = pInfo->FileNameLength / sizeof(WCHAR);  // len in wchars
    pFilename = new WCHAR[len+1];
    ON_OOM_EXIT(pFilename);
    CopyMemory(pFilename, pInfo->FileName,  len*sizeof(WCHAR));
    pFilename[len] = L'\0';

    // Call the callback
    CallCallback(pInfo->Action, pFilename);

Cleanup:
    delete [] pFilename;
    return hr;
}

//
// N/Direct accessible APIs 
//

/**
 * Create DirMonCompletion and returns it as int.
 */

HRESULT __stdcall
DirMonOpen(
    LPCWSTR pDir,
    BOOL watchSubdirs,
    DWORD notifyFilter,
    PFNDIRMONCALLBACK pCallbackDelegate,
    DirMonCompletion ** ppCompletion)
{
    HRESULT hr = S_OK;
    DirMonCompletion *pDirMon = NULL;

    *ppCompletion = NULL;

    pDirMon = new DirMonCompletion();
    ON_OOM_EXIT(pDirMon);

    hr = pDirMon->Init((WCHAR *)pDir, watchSubdirs, notifyFilter, pCallbackDelegate);
    ON_ERROR_EXIT();

    *ppCompletion = pDirMon;

Cleanup:
    if (hr) {
        ReleaseInterface(pDirMon);
    }

    return hr;
}

/**
 * Closes DirMonCompletion passed as int.
 */
void
__stdcall
DirMonClose(DirMonCompletion *pDirMon)
{
    ASSERT(pDirMon != NULL);

    if (pDirMon != NULL) {
        pDirMon->Close();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\event.cxx ===
/**
 * Eventlog helper functions 
 * 
 * Copyright (c) 2001 Microsoft Corporation
 */

#include "precomp.h"
#include "names.h"
#include "event.h"
#include "_ndll.h"

void
SetEventCateg(WORD wCateg) {
    ASSERT(g_tlsiEventCateg != TLS_OUT_OF_INDEXES);

    TlsSetValue(g_tlsiEventCateg, UIntToPtr((UINT)wCateg));
}

/**
 * This function write an event in eventlog.  If parameters are needed, please supply
 * a format string, followed by the parameters.  Each parameter inside the format
 * string should be delimited by an '^'.  If no parameter is needed, you still need
 * to supply a NULL.
 *
 * For example:
 *  XspLogEvent( IDS_FOOBAR, L"%s^%s", string1, string2 );
 *  XspLogEvent( IDS_FOOBAR, L"%s^0x%08x", string1, hresult );
 *  XspLogEvent( IDS_FOOBAR, NULL ); // no parameter at all
 */
HRESULT
DoLogEvent(DWORD dwEventId, WORD wCategory, WCHAR *sFormat, va_list marker) {
    HRESULT     hr = S_OK;
    HANDLE      hEventLog = NULL;
    WORD        wType = EVENTLOG_SUCCESS;
    int         i = 0, iRet;
    WORD        cParams = 0;
    WCHAR       buf[512];
    WCHAR       *pbufNew = NULL, *pbuf = NULL, *pFmtBuf = NULL;
    int         bufsize = 0;
    LPCWSTR     rgParams[128];
    WCHAR       delim = '^';

    // First generate a string that contains all the params using this format:
    // "<param1>^<param2>^<param3>" where <param1> is the string representation
    // of the parameter 1.

    if (sFormat) {
        memset(buf, 0, sizeof(buf));
        pbuf = buf;
        bufsize = ARRAY_SIZE(buf);

        do {
      hr = StringCchVPrintf(pbuf, bufsize-1, sFormat, marker);

      if (hr == STRSAFE_E_INVALID_PARAMETER) {
        ASSERT(FALSE);
        ON_ERROR_EXIT();
      }

      if (hr == STRSAFE_E_INSUFFICIENT_BUFFER) {
        bufsize *= 2;
        delete [] pbufNew;
        pbufNew = new  (NewClear) WCHAR[bufsize];
        ON_OOM_EXIT(pbufNew);
        pbuf = pbufNew;
      }

        } while (hr == STRSAFE_E_INSUFFICIENT_BUFFER);

        
        // Then replace all occurences of the delimiter character with \0,
        // and remember the pointers to each string
        while (pbuf[i] != '\0') {
            if (cParams >= ARRAY_SIZE(rgParams)) {
                ASSERT(cParams < ARRAY_SIZE(rgParams));
                EXIT_WITH_WIN32_ERROR(ERROR_INTERNAL_ERROR);
            }
            rgParams[cParams] = (LPCWSTR)&pbuf[i];
            cParams++;
            
            do {
                if (pbuf[i] == delim) {
                    pbuf[i] = '\0';
                    i++;
                    break;
                }
                
                i++;
            } while (pbuf[i] != '\0');
        }
    }

    
    hEventLog = RegisterEventSource(NULL, EVENTLOG_NAME_L);
    ON_ZERO_EXIT_WITH_LAST_ERROR(hEventLog);

    // Find out wType
    switch(dwEventId >> 30) {
        case 0:
            wType = EVENTLOG_SUCCESS;
            break;

        case 1:
            wType = EVENTLOG_INFORMATION_TYPE;
            break;

        case 2:
            wType = EVENTLOG_WARNING_TYPE;
            break;

        case 3:
            wType = EVENTLOG_ERROR_TYPE;
    }

    if (wCategory == IDS_CATEGORY_UNINSTALL) {
        // After a successful uninstallation, reference to the correct eventlog
        // resource file will be removed from the registry.  In order for admin
        // to see the content of our eventlogging, we are here formatting the
        // string from the original event id, and log the whole string using
        // a generic event string whose whole body is a single input string.
        iRet = FormatMessage(
                FORMAT_MESSAGE_FROM_HMODULE|
                FORMAT_MESSAGE_ARGUMENT_ARRAY|
                FORMAT_MESSAGE_ALLOCATE_BUFFER,
                g_rcDllInstance,
                dwEventId,
                Names::SysLangId(),
                (LPWSTR)&pFmtBuf,
                0,
                (va_list*)rgParams);
        ON_ZERO_EXIT_WITH_LAST_ERROR(iRet);

        // Reuse rgParams to point to the formatted buffer
        rgParams[0] = pFmtBuf;
        cParams = 1;
        dwEventId = IDS_EVENTLOG_GENERIC;
    }

    ReportEvent(hEventLog, wType, wCategory, dwEventId, NULL, cParams, 0, rgParams, NULL);

Cleanup:
    if (hEventLog)
        DeregisterEventSource(hEventLog);

    if (pFmtBuf)
        LocalFree(pFmtBuf);

    delete [] pbufNew;

    return hr;
}


HRESULT
XspLogEvent(DWORD dwEventId, WORD wCategory, WCHAR *sFormat, ...) {
    va_list marker;
    
    va_start(marker, sFormat);
    return DoLogEvent(dwEventId, wCategory, sFormat, marker);
}


HRESULT
XspLogEvent(DWORD dwEventId, WCHAR *sFormat, ...) {
    va_list marker;

    ASSERT(g_tlsiEventCateg != TLS_OUT_OF_INDEXES);
    
    va_start(marker, sFormat);
    return DoLogEvent(dwEventId, (WORD)TlsGetValue(g_tlsiEventCateg), sFormat, marker);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\getconfig.cxx ===
/**
 * AuthFilter Main module:
 * DllMain, 
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

#include "precomp.h"
#include "dbg.h"
#include "util.h"
#include "nisapi.h"
#include "names.h"

/////////////////////////////////////////////////////////////////////////////

#define SZ_END_COMMENT             L"-->"
#define SZ_START_COMMENT           L"<!--"
#define SZ_START_TAG               L"<"
#define SZ_END_TAG                 L"/>"
#define SZ_END_TAG_2               L"</"
#define SZ_REG_CONFIG_DIR_VALUE    L"ConfigDir"

/////////////////////////////////////////////////////////////////////////////
// Forward
DWORD
GetNextWord(WCHAR * strWord, WCHAR * buf, DWORD dwBufSize);

void
GetQuotedString(WCHAR * strOut, WCHAR * buf, DWORD dwBufSize);

DWORD
GetColonSeparatedTimeInSeconds(WCHAR * strWord);


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CReadWriteSpinLock g_GetConfigurationFromNativeCodeLock("GetConfigurationFromNativeCode");

BOOL __stdcall
GetConfigurationFromNativeCode(
        LPCWSTR   szFileName,
        LPCWSTR   szConfigTag,
        LPCWSTR * szProperties,
        DWORD   * dwValues,
        DWORD     dwNumProperties,
        LPCWSTR * szPropertiesStrings,
        LPWSTR  * szValues,
        DWORD     dwNumPropertiesStrings,
        LPWSTR    szUnrecognizedAttrib,
        DWORD     dwUnrecognizedAttribSize)
{
    if (szFileName == NULL || dwValues == NULL || szProperties == NULL || szConfigTag == NULL || dwNumProperties == 0)
    {
        return FALSE;
    }

    HRESULT      hr          = S_OK;
    BOOL         fRet        = FALSE;
    HANDLE       hFile       = INVALID_HANDLE_VALUE;
    LPBYTE       buf         = NULL;
    DWORD        dwBufSize   = 0;
    DWORD        dwRead      = 0;
    BOOL         fTagStart   = FALSE;
    BOOL         fInMyTag    = FALSE;
    DWORD        dwPos       = 0;
    WCHAR        strWord[104];
    BOOL         fLastWordWasEqualTo     = FALSE;
    int          iIndexDW    = -1;
    int          iIndexS     = -1;
    WCHAR  *     pBuffer     = NULL;

    g_GetConfigurationFromNativeCodeLock.AcquireWriterLock();

    hFile = CreateFile(szFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ|FILE_SHARE_WRITE, 
                        NULL, 
                        OPEN_EXISTING, 
                        FILE_ATTRIBUTE_NORMAL, 
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        EXIT_WITH_LAST_ERROR();

    dwBufSize = GetFileSize(hFile, NULL);
    if (dwBufSize == 0 || dwBufSize == INVALID_FILE_SIZE)
        EXIT_WITH_LAST_ERROR();

    buf = new (NewClear) BYTE[dwBufSize + 2];
    ON_OOM_EXIT(buf);
    
    if ( ! ReadFile(hFile, buf, dwBufSize, &dwRead, NULL) )
        EXIT_WITH_LAST_ERROR();

    if (dwRead < 3)
        EXIT_WITH_HRESULT(E_FAIL);
    

    if ((buf[0] == 0xff && buf[1] == 0xfe) || (buf[0] == 0xfe && buf[1] == 0xff)) // Unicode Format: Nothing to do
    { 
        if (buf[0] == 0xfe && buf[1] == 0xff) // Unicode big endian format: swap bytes 
        {
            for(DWORD iter=2; iter < dwBufSize-1;)
            {                
                BYTE cTemp = buf[iter];
                buf[iter] = buf[iter+1];
                buf[iter+1] = cTemp;                
                iter += 2;
            }
        }
        pBuffer = (WCHAR *) (&buf[2]);
    } 
    else // Multi-byte format
    {
        UINT  iCodePage = ((buf[0] == 0xef && buf[1] == 0xbb && buf[2] == 0xbf) ? CP_UTF8 : CP_ACP);
        int   iStartPos = ((iCodePage == CP_UTF8) ? 3 : 0);
        int   iLen      = MultiByteToWideChar(iCodePage, 0, (LPCSTR) &buf[iStartPos], dwRead-iStartPos, NULL, 0);

        if (iLen <= 0)
            EXIT_WITH_LAST_ERROR();
        
        iLen++;
        pBuffer = new (NewClear) WCHAR[iLen + 1];
        ON_OOM_EXIT(pBuffer);

        if (!MultiByteToWideChar(iCodePage, 0, (LPCSTR) &buf[iStartPos], dwRead-iStartPos, pBuffer, iLen))
        {
            delete [] pBuffer;
            pBuffer = NULL;
            EXIT_WITH_LAST_ERROR();
        }
        delete [] buf;
        buf = (LPBYTE) pBuffer;
        dwRead = (DWORD) iLen;
    }

    while(dwPos < dwRead)
    {
        DWORD dwAdvance = GetNextWord(strWord, &pBuffer[dwPos], dwRead - dwPos); 
        int iLen = lstrlenW(strWord);
        if (iLen < 1)
            break;

        if (wcsstr(strWord, SZ_START_COMMENT) == strWord)
        { // comment section
            WCHAR * szEndComment = wcsstr(&pBuffer[dwPos], SZ_END_COMMENT);
            if (szEndComment == NULL)
                break;
            dwAdvance = (DWORD) (LPBYTE(szEndComment) - LPBYTE(&pBuffer[dwPos])) / sizeof(WCHAR) + 3;
            ASSERT(&pBuffer[dwPos+dwAdvance] == &szEndComment[3]);
            dwPos += dwAdvance;
            continue;
        }

        if (fInMyTag)
        {
            if (fLastWordWasEqualTo)
            {
                fLastWordWasEqualTo = FALSE;
                if (iIndexDW >= 0)
                {
                    DWORD   dwVal   = 0;
                    BOOL    fSet    = TRUE;

                    if (_wcsicmp(strWord, L"\"true\"") == 0)
                        dwVal = 1;
                    else if (_wcsicmp(strWord, L"\"false\"") == 0) 
                        dwVal = 0;
                    else if (_wcsicmp(strWord, L"\"infinite\"") == 0)
                        dwVal = 0xffffffff;
                    else if (wcschr(strWord, L':') != NULL)
                        dwVal = GetColonSeparatedTimeInSeconds(strWord);
                    else if (iLen > 2 && iLen < 15)
                    {
                        strWord[iLen - 1] = NULL;
                        dwVal = wcstoul(&strWord[1], NULL, 0);
                    }
                    else
                    {
                        fSet = FALSE;
                    }
                
                    if (fSet == TRUE)
                    {
                        fRet = TRUE;
                        dwValues[iIndexDW] = dwVal;
                    }

                    iIndexS = iIndexDW = -1;
                }

                if (iIndexS >= 0)
                {
                    GetQuotedString(szValues[iIndexS], &pBuffer[dwPos], dwRead - dwPos);
                    iIndexS = iIndexDW = -1;
                }
            }
            else
            {
                if (wcscmp(strWord, L"=") == 0)
                {
                    fLastWordWasEqualTo = TRUE;
                }
                else
                {
                    fLastWordWasEqualTo = FALSE;
                    for(DWORD iter=0; iter<dwNumProperties; iter++)
                    {
                        if (wcscmp(szProperties[iter], strWord) == 0)
                        {
                            iIndexDW = iter;
                            break;
                        }
                    }


                    for(iter=0; iter<dwNumPropertiesStrings; iter++)
                    {
                        if (_wcsicmp(szPropertiesStrings[iter], strWord) == 0)
                        {
                            iIndexS = iter;
                            break;
                        }
                    }


                    if ( iIndexDW < 0                     && 
                         iIndexS  < 0                     && 
                         szUnrecognizedAttrib     != NULL && 
                         szUnrecognizedAttrib[0]  == NULL && 
                         dwUnrecognizedAttribSize >  1    && 
                         wcscmp(L"/>", strWord)  !=  0      )
                    {
                        wcsncpy(szUnrecognizedAttrib, strWord, dwUnrecognizedAttribSize-1);
                        szUnrecognizedAttrib[dwUnrecognizedAttribSize-1]=NULL;
                    }
                }
            }
            
            if (_wcsicmp(strWord, SZ_END_TAG) == 0 || _wcsicmp(strWord, SZ_END_TAG_2) == 0)
            {
                fInMyTag = fLastWordWasEqualTo = FALSE;
                iIndexS = iIndexDW = -1;
            }
        }

        if (fTagStart && _wcsicmp(strWord, szConfigTag) == 0)
        {
            dwPos += dwAdvance;
            fInMyTag = TRUE;
            continue;
        }

        fTagStart = (wcscmp(strWord, SZ_START_TAG) == 0);
        dwPos += dwAdvance;        
    }

 Cleanup:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    g_GetConfigurationFromNativeCodeLock.ReleaseWriterLock();
    if (buf != NULL)
        delete [] buf;

    return fRet;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

DWORD
GetNextWord(WCHAR * strWord, WCHAR * buf, DWORD dwBufSize)
{
    if (dwBufSize < 1)
        return 0;
    
    DWORD dwStart = 0;
    DWORD dwEnd   = 0;

    // remove white spaces
    while(dwStart < dwBufSize && iswspace(buf[dwStart]))
        dwStart ++;
    
    if (dwStart == dwBufSize)
    {
        strWord[0] = NULL;
        return dwStart;
    }

    dwEnd = dwStart+1;

    if (iswalnum(buf[dwStart])) // AlphaNum word
    {
        while(dwEnd < dwBufSize && iswalnum(buf[dwEnd]))
            dwEnd ++;
    } 
    else if (buf[dwStart] == L'\"') // Quoted string
    {
        while(dwEnd < dwBufSize && buf[dwEnd] != L'\"') // read to ending quote
            dwEnd ++;
        if (dwEnd < dwBufSize)
            dwEnd++;
    }
    else
    {
        // Non-AphaNum string -- read till space, AlphaNum or special char (", < and > )
        while(dwEnd < dwBufSize && !iswalnum(buf[dwEnd]) && !iswspace(buf[dwEnd]) && 
              buf[dwEnd] != L'\"' && buf[dwEnd] != L'>' && buf[dwEnd] != L'<')
        {
            dwEnd ++;
        }

        if (dwEnd < dwBufSize && buf[dwEnd] == L'>') // if it is an XML end-tag, then include it in the word
        {
            dwEnd++; 
        }
    }
    
    // Make sure we don't exceed bounds
    if (dwEnd > dwBufSize)
        dwEnd = dwBufSize;
    if (dwStart >= dwBufSize)
        dwStart = dwBufSize-1;

    // Number of bytes to copy
    DWORD dwRet = ((dwEnd - dwStart) > 99) ?  99 : (dwEnd - dwStart);

    // copy string
    wcsncpy(strWord, &buf[dwStart], dwRet);
    strWord[dwRet] = NULL;
    return dwEnd;
}
 
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void
GetQuotedString(
        WCHAR * strWord, 
        WCHAR * buf, 
        DWORD  dwBufSize)
{
    strWord[0] = NULL;

    if (dwBufSize < 1)
        return;
    
    DWORD dwStart = 0;
    DWORD dwEnd   = 0;

    while(dwStart < dwBufSize && iswspace(buf[dwStart]))
        dwStart ++;
    
    dwEnd = dwStart;
    if (buf[dwStart] == L'\"')
    {
        dwStart++;
        dwEnd++;
        while(dwEnd < dwBufSize && buf[dwEnd] != L'\"')
            dwEnd ++;
    }
    else
    {
        if (iswalnum(buf[dwStart]))
        {
            while(dwEnd < dwBufSize && (iswalnum(buf[dwEnd]) || buf[dwEnd] == L'\"' || buf[dwEnd] == L':'))
                dwEnd ++;
        }
        else
        {
            while(dwEnd < dwBufSize && !iswalnum(buf[dwEnd]) && !iswspace(buf[dwEnd]) && buf[dwEnd] != L'\"' && buf[dwEnd] != L':')
                dwEnd ++;
        }
    }

    DWORD dwRet = dwEnd - dwStart;
    if (dwRet > 99)
    {
        wcsncpy(strWord, &buf[dwStart], 99);
        strWord[99] = NULL;
    }
    else
    {
        wcsncpy(strWord, &buf[dwStart], dwRet);
        strWord[dwRet] = NULL;
    }
}
 
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

bool
__stdcall
IsConfigFileName(WCHAR * pFileName) {
    return pFileName == NULL ||
        _wcsicmp(pFileName, WSZ_WEB_CONFIG_FILE) == 0 ||
        _wcsicmp(pFileName, Names::GlobalConfigShortFileName()) == 0;

}

DirMonCompletion *
__stdcall
MonitorGlobalConfigFile(PFNDIRMONCALLBACK pCallbackDelegate)
{
    HRESULT hr;
    DirMonCompletion * pCompletion = NULL;

    hr = DirMonOpen(Names::GlobalConfigDirectory(), FALSE, RDCW_FILTER_FILE_AND_DIR_CHANGES, pCallbackDelegate, &pCompletion);
    ON_ERROR_CONTINUE();

    return pCompletion;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

DWORD
GetColonSeparatedTimeInSeconds(WCHAR * strWord)
{
    if (strWord == NULL)
        return 0xffffffff;

    WCHAR * pStart       = NULL;
    DWORD  dwRet        = 0;
    int    iMultiplier  = 1;
    
    for(pStart = wcschr(strWord, L':'); pStart != NULL; pStart = wcschr(&pStart[1], L':'))
        iMultiplier *= 60;
    
    if (iMultiplier > 3600)
        return 0xffffffff;


    pStart = strWord;
    if (pStart[0] == L'"')
        pStart++;

    while(pStart != NULL && pStart[0] != NULL)
    {
        WCHAR * pEnd = wcschr(pStart, L':');

        if (pEnd == NULL)
        {
            // Check if the last WCHAR is L"
            int iLen = lstrlenW(pStart);
            if (iLen > 0 && pStart[iLen-1] == L'"')
                pStart[iLen-1] = NULL;
        }
        else
        {
            // NULL the :
            pEnd[0] = NULL;
            pEnd++;
        }

        while(pStart[0] == L'0')
            pStart++;
        dwRet += wcstoul(pStart, NULL, 0) * iMultiplier;
        iMultiplier /= 60;
        pStart = pEnd;
    }

    
    return ((dwRet==0) ? 0xffffffff : dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\ecbdirect.cxx ===
/**
 * ECB callback functions though N/Direct.
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

#include "precomp.h"
#include "dbg.h"
#include "util.h"
#include "nisapi.h"
#include "Wincrypt.h"
#include "_ndll.h"
#include "PerfCounters.h"
#include "ecbdirect.h"
#include "pm.h"
#include "RegAccount.h"
#include "etw.h"
#include "aspnetetw.h"

// Defined in securityapi.cxx
BOOL
GetAutogenKeys(
        LPBYTE    pDefaultKey,
        int       iBufSizeIn, 
        LPBYTE    pBuf, 
        int       iBufSizeOut);


HANDLE
__stdcall
CreateUserToken (
       LPCWSTR   name, 
       LPCWSTR   password,
       BOOL      fImpersonationToken,
       LPWSTR    szError,
       int       iErrorSize);

#define HSE_REQ_GET_VIRTUAL_PATH_TOKEN      (HSE_REQ_END_RESERVED+21)
#define NUM_SERVER_VARIABLES                31
LPCSTR g_szServerVariables[NUM_SERVER_VARIABLES] = {  
    "APPL_MD_PATH",  /* always first */
    "ALL_RAW",
    "AUTH_PASSWORD",
    "AUTH_TYPE",
    "CERT_COOKIE",
    "CERT_FLAGS",
    "CERT_ISSUER",
    "CERT_KEYSIZE",
    "CERT_SECRETKEYSIZE",
    "CERT_SERIALNUMBER",
    "CERT_SERVER_ISSUER",
    "CERT_SERVER_SUBJECT",
    "CERT_SUBJECT",
    "GATEWAY_INTERFACE",
    "HTTP_COOKIE",
    "HTTP_USER_AGENT",
    "HTTPS",
    "HTTPS_KEYSIZE",
    "HTTPS_SECRETKEYSIZE",
    "HTTPS_SERVER_ISSUER",
    "HTTPS_SERVER_SUBJECT",
    "INSTANCE_ID",
    "INSTANCE_META_PATH",
    "LOCAL_ADDR",
    "LOGON_USER",
    "REMOTE_ADDR",
    "REMOTE_HOST",
    "SERVER_NAME",
    "SERVER_PORT",
    "SERVER_PROTOCOL",
    "SERVER_SOFTWARE"};

void
EcbSetStatus(
    EXTENSION_CONTROL_BLOCK *pECB,
    LPCSTR pStatus)
{
    int code;

    if (pStatus[0] == '2' && pStatus[1] == '0' && pStatus[2] == '0' && pStatus[3] == ' ')
        code = 200; // shortcut
    else
        code = atoi(pStatus);

    if (code != 0)
        pECB->dwHTTPStatusCode = code;
}

/**
 * HSE_REQ_SEND_RESPONSE_HEADER_EX wrapper.
 */
int
__stdcall
EcbWriteHeaders(
    EXTENSION_CONTROL_BLOCK *pECB,
    LPCSTR pStatus,
    LPCSTR pHeaders,
    int keepConnected)
{
    HSE_SEND_HEADER_EX_INFO headerExInfo;

    headerExInfo.pszStatus = pStatus;
    headerExInfo.pszHeader = pHeaders;
    headerExInfo.cchStatus = 0;
    headerExInfo.cchHeader = 0;
    headerExInfo.fKeepConn = keepConnected;

    EcbSetStatus(pECB, pStatus);

    BOOL fRet = (*pECB->ServerSupportFunction)(
                            pECB->ConnID,
                            HSE_REQ_SEND_RESPONSE_HEADER_EX,
                            &headerExInfo,
                            NULL,
                            NULL
                            );

    return fRet ? 1 : 0;
}

/**
 * WriteClient binary.
 */
int
__stdcall
EcbWriteBytes(
    EXTENSION_CONTROL_BLOCK *pECB,
    void *pBytes,
    int size)
{
    BOOL fRet = (*pECB->WriteClient)(
                            pECB->ConnID,
                            (LPVOID)pBytes,
                            (LPDWORD)&size,
                            HSE_IO_SYNC
                            );

    PerfIncrementGlobalCounterEx(
        ASPNET_REQUEST_BYTES_OUT_NUMBER, size);

    return fRet ? 1 : 0;
}

/**
 * WriteClient binary, async.
 */
int
__stdcall
EcbWriteBytesAsync(
    EXTENSION_CONTROL_BLOCK *pECB,
    void *pBytes,
    int size,
    PFN_HSE_IO_COMPLETION callback,
    void *pContext)
{
    HRESULT hr;

    // setup the callback

    BOOL fRet;

    fRet = (*pECB->ServerSupportFunction)(
                        pECB->ConnID,
                        HSE_REQ_IO_COMPLETION,
                        callback,
                        NULL,
                        (DWORD*)pContext);
    if (!fRet)
        EXIT_WITH_LAST_ERROR();

    // launch IO

    fRet = (*pECB->WriteClient)(
                        pECB->ConnID,
                        (LPVOID)pBytes,
                        (LPDWORD)&size,
                        HSE_IO_ASYNC);

    PerfIncrementGlobalCounterEx(
        ASPNET_REQUEST_BYTES_OUT_NUMBER, size);

Cleanup:

    return fRet ? 1 : 0;
}

/**
 * HSE_REQ_DONE_WITH_SESSION wrapper.
 */
int
__stdcall
EcbDoneWithSession(
    EXTENSION_CONTROL_BLOCK *pECB,
    int status,
    int iCallerID)
{
    DWORD stat = status;

    // Don't care about return value here
    EtwTraceAspNetPageEnd(pECB->ConnID);

    BOOL fRet = (*pECB->ServerSupportFunction)(
                            pECB->ConnID,
                            HSE_REQ_DONE_WITH_SESSION,
                            &stat,
                            NULL,
                            NULL
                            );

#if ICECAP
    {
        char buf[4028];

        NameProfile(PRODUCT_NAME, PROFILE_THREADLEVEL,  PROFILE_CURRENTID);

        if (pECB->lpszQueryString != NULL && pECB->lpszQueryString[0] != '\0')
        {
	  StringCchPrintfA(buf, ARRAY_SIZE(buf), "EcbDoneWithSession 0x%p %s %s?%s", 
                      pECB, pECB->lpszMethod, pECB->lpszPathInfo, pECB->lpszQueryString);
        }
        else
        {
            StringCchPrintfA(buf, ARRAY_SIZE(buf), "EcbDoneWithSession 0x%p %s %s", 
                      pECB, pECB->lpszMethod, pECB->lpszPathInfo);
        }

        CommentMarkProfile(3, buf);
    }
#endif

    return fRet ? 1 : 0;
}

//
// FlushCore -- the catch-all function to write output
// 

HRESULT FlushUsingWriteClient(
    EXTENSION_CONTROL_BLOCK *pECB,
    int     totalBodySize,
    int     numBodyFragments,
    BYTE*   bodyFragments[],
    int     bodyFragmentLengths[])
{
    HRESULT hr = S_OK;

    if (totalBodySize > 0) 
    {
        for (int i = 0; i < numBodyFragments; i++) 
        {
            if (EcbWriteBytes(pECB, bodyFragments[i], bodyFragmentLengths[i]) != 1)
                EXIT_WITH_LAST_ERROR();
        }
    }

Cleanup:
    return hr;
}

typedef void (__stdcall *PFN_MANAGED_IO_COMPLETION_CALLBACK)(
                                   EXTENSION_CONTROL_BLOCK * pECB,
                                   DWORD    cbIO,
                                   DWORD    dwError);

VOID WINAPI
FlushCompletionCallback(
    EXTENSION_CONTROL_BLOCK *pECB,
    PVOID    pContext,
    DWORD    cbIO,
    DWORD    dwError)
{
    PFN_MANAGED_IO_COMPLETION_CALLBACK pfnManagedCallBack = (PFN_MANAGED_IO_COMPLETION_CALLBACK)pContext;

    if (pfnManagedCallBack != NULL)
    {
        (*pfnManagedCallBack)(pECB, cbIO, dwError);
    }
}

PFN_HSE_CACHE_INVALIDATION_CALLBACK g_KernalCacheInvalidatationCallback = NULL;

void __stdcall InvalidateKernelCache(WCHAR *key)
{
    if (g_KernalCacheInvalidatationCallback != NULL)
        g_KernalCacheInvalidatationCallback(key);
}

HRESULT FlushUsingVectorSend(
    EXTENSION_CONTROL_BLOCK *pECB,
    LPCSTR  status, 
    LPCSTR  header, 
    BOOL    finalSend,
    BOOL    useKernelCache,
    int     totalBodySize,
    int     numBodyFragments,
    BYTE*   bodyFragments[],
    int     bodyFragmentLengths[],
    BOOL    useAsync,
    PFN_HSE_IO_COMPLETION callback)
{
    HRESULT hr = S_OK;
    HSE_RESPONSE_VECTOR vector;
    const int numPreAllocatedElements = 10;
    HSE_VECTOR_ELEMENT elements[numPreAllocatedElements];
    HSE_VECTOR_ELEMENT *pElements = NULL;
    BOOL needToFreeElements = FALSE;

    // allocate array of elements if needed

    if (numBodyFragments > numPreAllocatedElements) 
    {
        pElements = new (NewClear) HSE_VECTOR_ELEMENT[numBodyFragments];
        ON_OOM_EXIT(pElements);
        needToFreeElements = TRUE;
    }
    else
    {
        pElements = elements;
        memset(pElements, 0, sizeof(HSE_VECTOR_ELEMENT) * numBodyFragments);
    }

    // fill up the vector

    memset(&vector, 0, sizeof(HSE_RESPONSE_VECTOR));
    vector.dwFlags = HSE_IO_NODELAY;
    vector.nElementCount = numBodyFragments;
    vector.lpElementArray = pElements;

    if (status != NULL)
    {
        vector.dwFlags |= HSE_IO_SEND_HEADERS;
        vector.pszStatus = (LPSTR)status;
        vector.pszHeaders = (LPSTR)header;

        EcbSetStatus(pECB, status);
    }

    if (finalSend)
    {
        vector.dwFlags |= HSE_IO_FINAL_SEND;
    }

    if (useKernelCache)
    {
        vector.dwFlags |= HSE_IO_CACHE_RESPONSE;

        if (g_KernalCacheInvalidatationCallback == NULL)
        {
            // remember the invalidation callback once

            PFN_HSE_CACHE_INVALIDATION_CALLBACK callback = NULL;

            if (!(*pECB->ServerSupportFunction)(
                            pECB->ConnID,
                            HSE_REQ_GET_CACHE_INVALIDATION_CALLBACK,
                            &callback,
                            NULL,
                            NULL))
            {
                EXIT_WITH_LAST_ERROR();
            }

            g_KernalCacheInvalidatationCallback = callback;
        }
    }

    if (useAsync)
    {
        vector.dwFlags |= HSE_IO_ASYNC;

        if (!(*pECB->ServerSupportFunction)(
                        pECB->ConnID,
                        HSE_REQ_IO_COMPLETION,
                        FlushCompletionCallback,
                        NULL,
                        (DWORD*)callback))
        {
            EXIT_WITH_LAST_ERROR();
        }
    }
    else
    {
        vector.dwFlags |= HSE_IO_SYNC;
    }

    // fill up the elements

    for (int i = 0; i < numBodyFragments; i++)
    {
        pElements[i].ElementType    = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;
        pElements[i].pvContext      = bodyFragments[i];
        pElements[i].cbOffset       = 0;
        pElements[i].cbSize         = bodyFragmentLengths[i];
    }

    // call IIS

    if (!(*pECB->ServerSupportFunction)(
                            pECB->ConnID,
                            HSE_REQ_VECTOR_SEND,
                            &vector,
                            NULL,
                            NULL)) 
    {
        EXIT_WITH_LAST_ERROR();
    }

    PerfIncrementGlobalCounterEx(ASPNET_REQUEST_BYTES_OUT_NUMBER, totalBodySize);

Cleanup:
    if (needToFreeElements)
        delete [] pElements;

    return hr;
}

int
__stdcall
EcbFlushCore(
    EXTENSION_CONTROL_BLOCK *pECB,
    LPCSTR  status, 
    LPCSTR  header, 
    BOOL    keepConnected,
    int     totalBodySize,
    int     numBodyFragments,
    BYTE*   bodyFragments[],
    int     bodyFragmentLengths[],
    BOOL    doneWithSession,
    int     finalStatus,
    BOOL    useKernelCache,
    BOOL    useAsync,
    PFN_HSE_IO_COMPLETION callback)
{
    HRESULT hr = S_OK;

    if (totalBodySize == 0 && status == NULL)
    {
        // optimization when only DoneWithSession is required
        EXIT();
    }

    if ((pECB->dwVersion >> 16) >= 6)
    {
        BOOL isFinalSend = doneWithSession || useAsync; // async is only used at the last write

        // IIS6
        if (status != NULL && keepConnected && totalBodySize > 0)
        {
            // send headers with vector send
            hr = FlushUsingVectorSend(pECB, status, header, isFinalSend, useKernelCache, totalBodySize, numBodyFragments, bodyFragments, bodyFragmentLengths, useAsync, callback);
            ON_ERROR_EXIT();
        }
        else
        {
            // send headers separately
            if (status != NULL)
            {
                if (EcbWriteHeaders(pECB, status, header, keepConnected) != 1)
                    EXIT_WITH_LAST_ERROR();
            }

            if (totalBodySize > 0)
            {
                hr = FlushUsingVectorSend(pECB, NULL, NULL, isFinalSend, useKernelCache, totalBodySize, numBodyFragments, bodyFragments, bodyFragmentLengths, useAsync, callback);
                ON_ERROR_EXIT();
            }
        }
    }
    else 
    {
        ASSERT(!useAsync);

        if (status != NULL)
        {
            // Try to send the body along with header to prevent nagling on small responses
            int headerLen = (int) strlen(header);
            int totalLen = headerLen + totalBodySize;
            if (totalBodySize > 0 && totalLen < 527) // Reserve one byte for the null character
            {  
                // Total request can fit within a packet, so try sending everything at once
                BYTE newHeader[528];
                BYTE *bytePtr = newHeader;
                BOOL useOpt = TRUE;
                memcpy(bytePtr, header, headerLen);
                bytePtr += headerLen;
                for (int i = 0; i < numBodyFragments; i++) 
                {
                    // Check to see if body has a '\0'.  If so, abort the joint send and do it the
                    // other way.
                    if (memchr(bodyFragments[i], '\0', bodyFragmentLengths[i]) != NULL) 
                    {
                        useOpt = FALSE;
                        break;
                    }
                    memcpy(bytePtr, bodyFragments[i], bodyFragmentLengths[i]);
                    bytePtr += bodyFragmentLengths[i];
                }
                if (useOpt)
                {
                    // If we got here, everything checks out ok and we're ready to send the header+body out.
                    (*bytePtr) = '\0';

                    if (EcbWriteHeaders(pECB, status, (LPCSTR) newHeader, keepConnected) != 1)
                        EXIT_WITH_LAST_ERROR();

                    // Get out of here!
                    EXIT();
                }
            }

            // If we got here, the "new header" couldn't be used, so do the original header write
            if (EcbWriteHeaders(pECB, status, header, keepConnected) != 1)
                EXIT_WITH_LAST_ERROR();
        }

        if (totalBodySize > 0)
        {
            // We got here because either there was no status or the request didn't fit with the header
            hr = FlushUsingWriteClient(pECB, totalBodySize, numBodyFragments, bodyFragments, bodyFragmentLengths);
            ON_ERROR_EXIT();
        }
    }

Cleanup:
    if (doneWithSession != 0) 
    {
        ASSERT(!useAsync);

        if (EcbDoneWithSession(pECB, finalStatus, 5) != 1)
            hr = E_FAIL;

        // Decrement the managed request count after 'done with session' call
        //      this is the only place where it happens in the 'in-process' case
        //      when requests make it to managed code
        HttpCompletion::DecrementActiveManagedRequestCount();

        PerfDecrementGlobalCounter(ASPNET_REQUESTS_CURRENT_NUMBER);
    }

    UpdateLastActivityTimeForHealthMonitor();

    return (hr == S_OK) ? 1 : 0;
}

/**
 * Wrapper for ECB->lpszQueryString.
 */
int
__stdcall
EcbGetQueryString(
    EXTENSION_CONTROL_BLOCK *pECB,
    int needDecoding, 
    LPSTR pBuffer,
    int bufferSize)
{
    int size = lstrlenA(pECB->lpszQueryString);
    if (pBuffer == NULL || bufferSize <= size)
        return -(size+1);

    StringCchCopyA(pBuffer, bufferSize, pECB->lpszQueryString);
    return 1;
}

/**
 * Wrapper for ECB->lpszQueryString.
 */
int
__stdcall
EcbGetQueryStringRawBytes(
    EXTENSION_CONTROL_BLOCK *pECB, 
    BYTE *pBuffer,
    int bufferSize)
{
    int l = lstrlenA(pECB->lpszQueryString);

    if (bufferSize < l)
        return -l;

    memcpy(pBuffer, pECB->lpszQueryString, l);
    return 1;
}

/**
 * Gets preloaded posted data
 */
int
__stdcall
EcbGetPreloadedPostedContent(
    EXTENSION_CONTROL_BLOCK *pECB, 
    BYTE *pBytesBuffer,
    int bufferSize)
{
    int len = pECB->cbAvailable;

    if (bufferSize < len)
        return -len;      // return negative required size

    if (len > 0)
        CopyMemory(pBytesBuffer, pECB->lpbData, len);

    PerfIncrementGlobalCounterEx(ASPNET_REQUEST_BYTES_IN_NUMBER, len);
    return len;
}

/**
 * Wrapper for ReadClient
 */
int
__stdcall
EcbGetAdditionalPostedContent(
    EXTENSION_CONTROL_BLOCK *pECB, 
    BYTE *pBytesBuffer,
    int bufferSize)
{
    int len = 0;
    DWORD bytesToRead = bufferSize;
    BYTE *pDest = pBytesBuffer;

    while (bytesToRead > 0)
    {
        DWORD bytesRead = bytesToRead;

        if (!(*pECB->ReadClient)(pECB->ConnID, pDest, &bytesRead) || bytesRead == 0) 
            break;

        bytesToRead -= bytesRead;
        pDest += bytesRead;
        len += bytesRead;
    }

    PerfIncrementGlobalCounterEx(ASPNET_REQUEST_BYTES_IN_NUMBER, len);
    return len;
}

/**
 * Wrapper for GetServerVariable.
 */
int
__stdcall
EcbGetServerVariable(
    EXTENSION_CONTROL_BLOCK *pECB,
    LPCSTR pVarName, 
    LPSTR pBuffer,
    int bufferSize)
{
    DWORD size = bufferSize;

    BOOL fRet = (*pECB->GetServerVariable)(
                            pECB->ConnID,
                            (LPSTR)pVarName,
                            pBuffer,
                            &size
                            );

    if (fRet)
    {
        // change all tabs to spaces (ASURT 111082)
        CHAR *pTab = strchr(pBuffer, '\t');
        while (pTab != NULL)
        {
            *pTab = ' ';
            pTab = strchr(pTab+1, '\t');
        }

        return size-1; // ok
    }
    else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) 
    {
        int reqSize = size+1;
        return -reqSize;   // return negative required size
    }
    else if (GetLastError() == ERROR_INVALID_INDEX) 
    {
        pBuffer[0] = '\0';
        return 0;           // non-existent server variable
    }
    else 
    {
        // error
        return 0;
    }
}


int
__stdcall
EcbGetUnicodeServerVariable(
    EXTENSION_CONTROL_BLOCK *pECB,
    LPCSTR pVarName, 
    LPWSTR pBuffer,
    int bufferSizeInChars)
{
    DWORD size = bufferSizeInChars * sizeof(WCHAR);

    BOOL fRet = (*pECB->GetServerVariable)(
                            pECB->ConnID,
                            (LPSTR)pVarName,
                            pBuffer,
                            &size
                            );

    if (fRet)
    {
        return size/sizeof(WCHAR)-1; // ok -> return length
    }
    else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) 
    {
        int reqSize = size/sizeof(WCHAR)+1;
        return -reqSize;   // return negative required size
    }
    else if (GetLastError() == ERROR_INVALID_INDEX) 
    {
        pBuffer[0] = L'\0';
        return 0;           // non-existent server variable
    }
    else 
    {
        // error
        return 0;
    }
}

int
EcbGetUtf8ServerVariable(
    EXTENSION_CONTROL_BLOCK *pECB,
    LPCSTR pVarName, 
    LPSTR pBuffer,
    int bufferSizeInChars)
{
    // only works on IIS6
    if ((pECB->dwVersion >> 16) < 6)
        return 0;

    HRESULT hr = S_OK;
    int     ret = 0;

    WCHAR *pUnicodeBuffer = new WCHAR[bufferSizeInChars];
    ON_OOM_EXIT(pUnicodeBuffer);

    ret = EcbGetUnicodeServerVariable(pECB, pVarName, pUnicodeBuffer, bufferSizeInChars);
    if (ret <= 0)
    {
        EXIT();
    }

    // convert to UTF8
    if (WideCharToMultiByte(CP_UTF8, 0, pUnicodeBuffer, -1, pBuffer, bufferSizeInChars, NULL, NULL) == 0)
        EXIT_WITH_LAST_ERROR();

    ret = 1;

Cleanup:
    if (pUnicodeBuffer != NULL)
        delete [] pUnicodeBuffer;
    return ret;
}

int
__stdcall
EcbGetVersion(
    EXTENSION_CONTROL_BLOCK *pECB)
{
    return (int)pECB->dwVersion;
}

/**
 * Wrapper for HSE_REQ_MAP_Url_TO_PATH.
 */
int
__stdcall
EcbMapUrlToPath(
    EXTENSION_CONTROL_BLOCK *pECB, 
    LPCSTR pUrl,
    LPSTR pBuffer,
    int bufferSize)
{
    int l = lstrlenA(pUrl);

    if (pBuffer == NULL || bufferSize <= l)
        return -(l+1);  // // not enough space to copy the buffer


    StringCchCopyA(pBuffer, bufferSize, pUrl);

    DWORD size = bufferSize;

    BOOL fRet = (*pECB->ServerSupportFunction)(
                            pECB->ConnID,
                            HSE_REQ_MAP_URL_TO_PATH,
                            pBuffer,
                            &size,
                            NULL
                            );

    if (fRet)
    {
        return 1; // ok
    }
    else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) 
    {
        int reqSize = size+1;
        return -reqSize;   // return negative required size
    }
    else 
    {
        // error
        return 0;
    }
}

int
__stdcall
EcbMapUrlToPathUnicode(
    EXTENSION_CONTROL_BLOCK *pECB, 
    LPWSTR pUrl,
    LPWSTR pBuffer,
    int bufferSizeInChars)
{
    int l = lstrlenW(pUrl);

    if (pBuffer == NULL || bufferSizeInChars <= l)
        return -(l+1);  // // not enough space to copy the buffer


    StringCchCopyW(pBuffer, bufferSizeInChars, pUrl);

    DWORD size = bufferSizeInChars * sizeof(WCHAR);

    BOOL fRet = (*pECB->ServerSupportFunction)(
                            pECB->ConnID,
                            HSE_REQ_MAP_UNICODE_URL_TO_PATH,
                            pBuffer,
                            &size,
                            NULL
                            );

    if (fRet)
    {
        return 1; // ok
    }
    else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) 
    {
        int reqSize = size/sizeof(WCHAR)+1;
        return -reqSize;   // return negative required size
    }
    else 
    {
        // error
        return 0;
    }
}



//
//  Called directly for IIS6 case (strings are obtained as Unicode individually)
//
int
__stdcall
EcbGetBasicsContentInfo(
    EXTENSION_CONTROL_BLOCK *pECB,
    int contentInfo[])
{
    if (pECB->cbTotalBytes > 0)
    {
        static char s_FormContentType[] = "application/x-www-form-urlencoded";
        static char s_MultipartContentTypePrefix[] = "multipart/form-data";

        // check the content type

        if (_stricmp(pECB->lpszContentType, s_FormContentType) == 0)
        {
            contentInfo[0] = 1;     // form content-type
        }
        else if (_strnicmp(
                    pECB->lpszContentType, 
                    s_MultipartContentTypePrefix,
                    sizeof(s_MultipartContentTypePrefix)-1) == 0)
        {
            contentInfo[0] = 2;     // [likely] multipart content-type
        }
        else
        {
            contentInfo[0] = 3;     // unknown content-type
        }

        // remember sizes
        contentInfo[1] = pECB->cbTotalBytes;
        contentInfo[2] = pECB->cbAvailable;
    }
    else
    {
        // no posted content
        contentInfo[0] = 0;
        contentInfo[1] = 0;
        contentInfo[2] = 0;
    }

    // query string length
    contentInfo[3] = lstrlenA(pECB->lpszQueryString);

    return 1;
}

/**
 * Get basic request info:
 *     Strings - 
 *          Method
 *          FilePath
 *          PathInfo 
 *          PhysicalPath
 *          AppPath
 *          AppPhysicalPath
 *
 *     Content info - type, total len, avail len, qs len
 *
 * For the purpose of this function url is considered to like this
 *     /vdir/page.aspx/pathinfo
 *
 * The strings are put into single buffer separated with tabs.
 */
int
__stdcall
EcbGetBasics(
    EXTENSION_CONTROL_BLOCK *pECB,
    LPSTR pBuffer,
    int bufferSize,
    int contentInfo[])
{
    HRESULT hr;
    DWORD size;
    BOOL  fRet;
    int   ret = 1;
    char  appPath[MAX_PATH], appMDPath[MAX_PATH], *pAppVirtPath;

    int methodLength, pathInfoLength, pathTranslatedLength;
    int appPathLength, appVPathLength, urlLength, suffixLength;
    int i, l;

    if (pBuffer != NULL)
        *pBuffer = '\0';   // in case of error

    //
    // get application physical path
    //

    size = MAX_PATH;
    fRet = (*pECB->GetServerVariable)(
                            pECB->ConnID,
                            "APPL_PHYSICAL_PATH",
                            appPath,
                            &size);
    if (fRet == FALSE)
    {
        ret = 0;
        EXIT_WITH_LAST_ERROR();
    }

    //
    // get application metabase path and application virtual path from it
    //

    size = MAX_PATH;
    fRet = (*pECB->GetServerVariable)(
                            pECB->ConnID,
                            "APPL_MD_PATH",
                            appMDPath,
                            &size);
    if (fRet == FALSE)
    {
        ret = 0;
        EXIT_WITH_LAST_ERROR();
    }

    // virtual path starts on fifth '/' as in "/LM/W3SVC/1/Root/foo"
    pAppVirtPath = appMDPath;   // starts with '/'
    for (i = 0; i < 4 && pAppVirtPath != NULL; i++)
        pAppVirtPath = strchr(pAppVirtPath+1, '/');
    if (pAppVirtPath == NULL)
        pAppVirtPath = "/";

    //
    // get the length of the required strings
    //

    methodLength = lstrlenA(pECB->lpszMethod);
    pathInfoLength = lstrlenA(pECB->lpszPathInfo);
    pathTranslatedLength = lstrlenA(pECB->lpszPathTranslated);
    appPathLength = lstrlenA(appPath);
    appVPathLength = lstrlenA(pAppVirtPath);

    //
    // calculate suffix length
    //   Algorithm: in case when length of URL server var is greater then 
    //      the length of path info from ECB, then the length of the suffix
    //      is the difference between the length of the URL and the length
    //      of path info.  This only applies when it is not a child request
    //      (path info in ECB must be identical to PATH_INFO server var)
    //

    suffixLength = 0;  // default assumption

    size = 0;
    fRet = (*pECB->GetServerVariable)(
                            pECB->ConnID,
                            "URL",
                            NULL,
                            &size);
    if (fRet != FALSE || GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        ret = 0;
        EXIT_WITH_LAST_ERROR();
    }

    urlLength = size-1;

    if (urlLength < pathInfoLength)
    {
        // make sure it is not a child request

        char pathInfoBuf[MAX_PATH];

        size = MAX_PATH;
        fRet = (*pECB->GetServerVariable)(
                                pECB->ConnID,
                                "PATH_INFO",
                                pathInfoBuf,
                                &size);
        if (fRet == FALSE || strcmp(pathInfoBuf, pECB->lpszPathInfo) == 0)
            suffixLength = pathInfoLength - urlLength;  // not a child request

        if (suffixLength >= pathTranslatedLength)  // iis sometimes truncates pathtranslated
            suffixLength = 0;
    }

    //
    // adjust path length to exclude suffix
    //

    pathTranslatedLength -= suffixLength;
    pathInfoLength -= suffixLength;

    //
    // calculate total length required -- return on insufficient buffer
    //

    l = methodLength + pathInfoLength + suffixLength +
        pathTranslatedLength + appPathLength + appVPathLength + 8;

    if (bufferSize <= l)
        return -(l+1);

    //
    // copy the strings into the buffer
    //

    // method
    CopyMemory(pBuffer, pECB->lpszMethod, methodLength);
    pBuffer[methodLength] = '\t';
    pBuffer += methodLength+1;

    // file path
    CopyMemory(pBuffer, pECB->lpszPathInfo, pathInfoLength);
    pBuffer[pathInfoLength] = '\t';
    pBuffer += pathInfoLength+1;

    // path info (suffix)
    if (suffixLength > 0)
    {
        CopyMemory(pBuffer, pECB->lpszPathInfo + pathInfoLength, suffixLength);
        pBuffer[suffixLength] = '\t';
        pBuffer += suffixLength+1;
    }
    else
    {
        pBuffer[0] = '\t';
        pBuffer++;
    }

    // path translated
    CopyMemory(pBuffer, pECB->lpszPathTranslated, pathTranslatedLength);
    pBuffer[pathTranslatedLength] = '\t';
    pBuffer += pathTranslatedLength+1;

    // app virtual path
    CopyMemory(pBuffer, pAppVirtPath, appVPathLength);
    pBuffer[appVPathLength] = '\t';
    pBuffer += appVPathLength+1;

    // app physical path
    CopyMemory(pBuffer, appPath, appPathLength);
    pBuffer[appPathLength] = '\0';

    //
    // fill in the content info
    //

    EcbGetBasicsContentInfo(pECB, contentInfo);

Cleanup:
    return ret;
}


/**
 * HSE_APPEND_LOG_PARAMETER wrapper.
 */
int
__stdcall
EcbAppendLogParameter(
    EXTENSION_CONTROL_BLOCK *pECB,
    LPCSTR pLogParam)
{
    BOOL fRet = (*pECB->ServerSupportFunction)(
                            pECB->ConnID,
                            HSE_APPEND_LOG_PARAMETER,
                            (LPVOID)pLogParam,
                            NULL,
                            NULL
                            );

    return fRet ? 1 : 0;
}

/**
 * HSE_REQ_IS_CONNECTED wrapper.
 */
int
__stdcall
EcbIsClientConnected(
    EXTENSION_CONTROL_BLOCK *pECB)
{
    HRESULT hr = S_OK;
    BOOL fConnected = TRUE;

    BOOL fRet = (*pECB->ServerSupportFunction)(
                            pECB->ConnID,
                            HSE_REQ_IS_CONNECTED,
                            (LPVOID)&fConnected,
                            NULL,
                            NULL
                            );

    if (!fRet && GetLastError() == WSAECONNRESET) 
    {
        // Patch up the special case of reset connection
        fConnected = FALSE; 
        fRet = TRUE;
    }

    if (!fRet)
    {
        fConnected = TRUE;
        EXIT_WITH_LAST_ERROR(); // unexpected error
    }

Cleanup:
    return fConnected;
}

/**
 * HSE_REQ_CLOSE_CONNECTION wrapper.
 */
int
__stdcall
EcbCloseConnection(
    EXTENSION_CONTROL_BLOCK *pECB)
{
    BOOL fRet = (*pECB->ServerSupportFunction)(
                            pECB->ConnID,
                            HSE_REQ_CLOSE_CONNECTION,
                            NULL,
                            NULL,
                            NULL
                            );

    return fRet ? 1 : 0;
}

/**
 * HSE_REQ_GET_IMPERSONATION_TOKEN wrapper
 */
HANDLE
__stdcall
EcbGetImpersonationToken(
    EXTENSION_CONTROL_BLOCK *pECB,
    HANDLE iProcessHandle)
{
    HANDLE                     hHandle = NULL;
    HANDLE                     hReturn = NULL;

    BOOL fRet = (*pECB->ServerSupportFunction)(
                            pECB->ConnID,
                            HSE_REQ_GET_IMPERSONATION_TOKEN,
                            &hHandle,
                            NULL,
                            NULL
                            );

    if (fRet == FALSE || hHandle == NULL)
        return 0;

    if (iProcessHandle == NULL)
        return hHandle;

    fRet = DuplicateHandle( 
                  GetCurrentProcess(),
                  hHandle,
                  iProcessHandle,
                  &hReturn,
                  0,
                  TRUE,
                  DUPLICATE_SAME_ACCESS);
    
    
    return fRet ?  hReturn : 0;
}

/**
 * HSE_REQ_GET_IMPERSONATION_TOKEN wrapper
 */
HANDLE
__stdcall
EcbGetVirtualPathToken(
    EXTENSION_CONTROL_BLOCK *pECB,
    HANDLE iProcessHandle)
{
#ifdef GET_VIRTUAL_PATH_TOKEN_WORKS
    HANDLE                     hHandle = NULL;
    HANDLE                     hReturn = NULL;

    BOOL fRet = (*pECB->ServerSupportFunction)(
                            pECB->ConnID,
                            HSE_REQ_GET_VIRTUAL_PATH_TOKEN,
                            &hHandle,
                            NULL,
                            NULL
                            );

    if (fRet == FALSE || hHandle == NULL)
        return 0;

    if (iProcessHandle == NULL)
        return hHandle;

    fRet = DuplicateHandle( 
                  GetCurrentProcess(),
                  hHandle,
                  iProcessHandle,
                  &hReturn,
                  0,
                  TRUE,
                  DUPLICATE_SAME_ACCESS);
    
    
    return fRet ?  hReturn : 0;
#else
    return EcbGetImpersonationToken(pECB, iProcessHandle);
#endif
}

/**
 * HSE_REQ_GET_CERT_INFO_EX
 */
int
__stdcall
EcbGetClientCertificate(
    EXTENSION_CONTROL_BLOCK *  pECB,
    LPSTR      buf,
    int        iBufSize,
    int *      pInts,
    __int64 *  pDates)
{
    HRESULT                    hr            = S_OK;
    BOOL                       fRet          = FALSE;
    CERT_CONTEXT_EX            oCertContextEx;
    PCCERT_CONTEXT             pCertContext  = NULL;
    int                        iReturnValue  = 1;

    ZeroMemory(&oCertContextEx, sizeof(oCertContextEx));

    ////////////////////////////////////////////////////////////
    // Step 1: Check args
    if (pECB == NULL || buf == NULL || pDates == NULL || pInts == NULL)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    ////////////////////////////////////////////////////////////
    // Step 2: Prepare the Cert Context struct
    oCertContextEx.cbAllocated = 8192;
    oCertContextEx.CertContext.pbCertEncoded = new (NewClear) BYTE[oCertContextEx.cbAllocated];
    ON_OOM_EXIT(oCertContextEx.CertContext.pbCertEncoded);

    ////////////////////////////////////////////////////////////
    // Step 3: Make the actual call to IIS
    fRet = (*pECB->ServerSupportFunction)(
            pECB->ConnID,
            HSE_REQ_GET_CERT_INFO_EX,
            &oCertContextEx,
            NULL,
            NULL);

    ////////////////////////////////////////////////////////////
    // Step 4: Check for errors
    if (!fRet && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        EXIT_WITH_LAST_ERROR();

    ////////////////////////////////////////////////////////////
    // Step 4: Deal with buffer too small
    if (!fRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        ////////////////////////////////////////////////////////////
        // Grow the buffer
        delete [] oCertContextEx.CertContext.pbCertEncoded;
        oCertContextEx.CertContext.pbCertEncoded = new (NewClear) BYTE[oCertContextEx.cbAllocated];
        ON_OOM_EXIT(oCertContextEx.CertContext.pbCertEncoded);

        ////////////////////////////////////////////////////////////
        // Let's try it again
        fRet = (*pECB->ServerSupportFunction)(
                pECB->ConnID,
                HSE_REQ_GET_CERT_INFO_EX,
                &oCertContextEx,
                NULL,
                NULL);
        ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);
    }

    ////////////////////////////////////////////////////////////
    // Step 5: Get the cert info
    pCertContext = CertCreateCertificateContext(oCertContextEx.CertContext.dwCertEncodingType,
                                                oCertContextEx.CertContext.pbCertEncoded,
                                                oCertContextEx.CertContext.cbCertEncoded);
    ////////////////////////////////////////////////////////////
    // Step 6: Check for errors
    ON_ZERO_EXIT_WITH_LAST_ERROR(pCertContext);
    ON_ZERO_EXIT_WITH_LAST_ERROR(pCertContext->pCertInfo);

    // Deal with output buffer too small
    if (iBufSize <   (int) oCertContextEx.CertContext.cbCertEncoded  + 
                     (int)pCertContext->pCertInfo->Issuer.cbData +
                     (int)pCertContext->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData)
    {
        iReturnValue = -((int)oCertContextEx.CertContext.cbCertEncoded + 
                         (int)pCertContext->pCertInfo->Issuer.cbData +
                         (int)pCertContext->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData);
        goto Cleanup;
    }

    ////////////////////////////////////////////////////////////
    // Step 7: Extract the info
    
    // Extract the dates
    memcpy(& (pDates[0]), &pCertContext->pCertInfo->NotBefore, 8);
    memcpy(& (pDates[1]), &pCertContext->pCertInfo->NotAfter,  8);


    ////////////////////////////////////////////////////////////
    // Extract the encoding info
    pInts[0] = (int) oCertContextEx.CertContext.dwCertEncodingType;

    ////////////////////////////////////////////////////////////
    // Extract the Actual certificate
    pInts[1] = oCertContextEx.CertContext.cbCertEncoded;
    memcpy(buf, oCertContextEx.CertContext.pbCertEncoded, pInts[1]);


    ////////////////////////////////////////////////////////////
    // Extract the BinaryIssuer
    pInts[2] = (int)pCertContext->pCertInfo->Issuer.cbData;
    if (pInts[2] > 0)
        memcpy( &buf[pInts[1]], 
                pCertContext->pCertInfo->Issuer.pbData, 
                pInts[2]);
    
    
    ////////////////////////////////////////////////////////////
    // Extract the Public Key
    pInts[3] = (int)pCertContext->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData;
    if (pInts[3] > 0)
        memcpy( &buf[pInts[1] + pInts[2]], 
                pCertContext->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData, 
                pInts[3]);
    
    
 Cleanup:
    if (pCertContext != NULL)
        CertFreeCertificateContext(pCertContext);

    delete [] oCertContextEx.CertContext.pbCertEncoded;
    if (hr != S_OK)
        return 0;
    else
        return iReturnValue;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/**
 * WriteClient binary, async using TransmitFile.
 */
int
__stdcall
EcbWriteBytesUsingTransmitFile(
    EXTENSION_CONTROL_BLOCK *pECB,
    LPCSTR pStatus,
    LPCSTR pHeaders,
    int /*keepConnected*/,    
    void *pBytes,
    int size,
    PFN_HSE_IO_COMPLETION callback,
    void *pContext)
{
    HRESULT hr;

    // setup the callback

    BOOL          fRet;
    HSE_TF_INFO   oTFInfo;

    ZeroMemory(&oTFInfo, sizeof(oTFInfo));

    oTFInfo.pfnHseIO     = callback;
    oTFInfo.pContext     = pContext;
    oTFInfo.pTail        = pBytes;
    oTFInfo.TailLength   = size;
    oTFInfo.dwFlags      = HSE_IO_ASYNC;

    if (pStatus != NULL && pStatus[0] != NULL) // Need to send headers?
    {
        oTFInfo.pszStatusCode = pStatus;
        oTFInfo.dwFlags |= HSE_IO_SEND_HEADERS;

        EcbSetStatus(pECB, pStatus);

        ASSERT(pHeaders != NULL);
        oTFInfo.pHead = (void *) pHeaders;
        oTFInfo.HeadLength = (pHeaders ? lstrlenA(pHeaders) : 0);
    }
    

    fRet = (*pECB->ServerSupportFunction)(
                        pECB->ConnID,
                        HSE_REQ_TRANSMIT_FILE,
                        &oTFInfo,
                        NULL,
                        NULL);

    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

    PerfIncrementGlobalCounterEx(
        ASPNET_REQUEST_BYTES_OUT_NUMBER, size);

Cleanup:
    return (fRet ? 1 : 0);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/**
 * EcbGetAllServerVarsCore: Get the list of all server variables
 */
int
__stdcall
EcbGetAllServerVarsCore(
    EXTENSION_CONTROL_BLOCK *pECB,
    LPSTR     buffer,
    int       iBufSize)
{
    BOOL       fOverflow       = FALSE;
    int        iPos            = 0;
    char       szDummy[2];
    int        iRet;

    for(int iter=0; iter<NUM_SERVER_VARIABLES; iter++)
    {
        if (fOverflow)
        {
            iRet = EcbGetServerVariable(pECB, 
                                        g_szServerVariables[iter], 
                                        szDummy,
                                        2);
            if (iRet < 0)
                iPos += -iRet;
            else
                iPos += 2;
        }
        else
        {
            if (iter > 0 && iBufSize > 1) 
                buffer[iPos++] = '\t'; 

            iRet = EcbGetServerVariable(pECB, 
                                        g_szServerVariables[iter], 
                                        &buffer[iPos],
                                        iBufSize - iPos);
            if (iRet < 0)
            {
                iPos += -iRet;
                fOverflow = TRUE;
            }
            else
            {
                if (iRet == 0)
                    iPos += 1;
                else
                    iPos += lstrlenA(&buffer[iPos]);
                
                if (iPos > iBufSize - 2)
                    fOverflow = TRUE;                
            }
        }
    } 
    
    return (fOverflow ? -(iPos+5) : 1);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/**
 * EcbCallISAPI
 */
int
__stdcall
EcbCallISAPI(
    EXTENSION_CONTROL_BLOCK *,
    int       iFunction,
    LPBYTE    bufferIn,
    int       iBufSizeIn,
    LPBYTE    bufferOut,
    int       iBufSizeOut)
{
    // Note: Reserve 0 for errors
    // Note: Reserve 1 for success
    // Note: Reserve 2 for overflow (call back with larger bufferOut)

    if (iFunction < 0 || bufferIn == NULL || bufferOut == NULL || iBufSizeIn < 0 || iBufSizeOut < 0)
        return 0;
    WCHAR * szStr = NULL;
    switch (iFunction) {
    case CallISAPIFunc_GetSiteServerComment:
        {
            WCHAR * serverComment = NULL;

            if (bufferIn == NULL || iBufSizeIn < 1)
                return 0;

            szStr = (WCHAR *)bufferIn;
            szStr[iBufSizeIn/sizeof(WCHAR)-1] = NULL; // Make sure it is NULL terminated string
            HRESULT hr = GetSiteServerComment(szStr, &serverComment);

            
            if (hr == S_OK) {
                if (serverComment == NULL)
                    return 0;

                int serverCommentLen = 1 + lstrlenW(serverComment);
                int serverCommentBufLen = serverCommentLen * sizeof(WCHAR);
                if (serverCommentBufLen > iBufSizeOut) {
                    delete [] serverComment;
                    return 2;
                }

                memcpy(bufferOut, serverComment, serverCommentBufLen);
            }
            
            delete [] serverComment;
        }
        break;

    case CallISAPIFunc_SetBinAccess:
        {
            szStr = (WCHAR *)bufferIn;
            szStr[iBufSizeIn/sizeof(WCHAR)-1] = NULL; // Make sure it is NULL terminated string
            HRESULT hr = SetBinAccessIIS(szStr);

            if (hr != S_OK)
                return 0;
            
            break;
        }
    case CallISAPIFunc_CreateTempDir:
        return (CRegAccount::CreateTempDir() == S_OK) ? 1 : 0;

    case CallISAPIFunc_GetAutogenKeys:
        return GetAutogenKeys(bufferIn, iBufSizeIn, bufferOut, iBufSizeOut);

    case CallISAPIFunc_GenerateToken:
        if (iBufSizeOut >= sizeof(HANDLE))
        {            
            HANDLE    hToken = NULL;
            LPWSTR    szName = NULL;
            LPWSTR    szPass = NULL;
            int       iByte  = 0;

            szName = (LPWSTR) bufferIn;
            szName[iBufSizeIn/sizeof(WCHAR)-1] = NULL; // Make sure it is NULL terminated string

            szPass   = wcschr(szName, L'\t');
            if (szPass == NULL)
                return 0;

            szPass[0] = NULL;
            szPass++;
            hToken = CreateUserToken(szName, szPass, TRUE, NULL, 0);
            if (hToken == NULL || hToken == INVALID_HANDLE_VALUE)
                return 0;
            for(iByte=sizeof(HANDLE)-1; iByte>=0; iByte--)
            {
                bufferOut[iByte] = (BYTE) (__int64(hToken) & 0xFF);
                hToken = (HANDLE) (__int64(hToken) >> 8);
            }
            return 1;
        }
        return 0;
        
    default:
        // ctracy: unrecognized function, return error
        return 0;
    }
    
    return 1;
}


//======================================================================
// This function returns true if it can determine that the instruction pointer
// refers to a code address that belongs in the range of the given image.
// This is used to protect against the attack described in ASURT 145040.
BOOL
IsIPInModule(HINSTANCE hModule, BYTE *ip)
{
    __try {
        
        BYTE *pBase = (BYTE *)hModule;
        
        IMAGE_DOS_HEADER *pDOS = (IMAGE_DOS_HEADER *)pBase;
        if (pDOS->e_magic != IMAGE_DOS_SIGNATURE ||
            pDOS->e_lfanew == 0) {
            __leave;
        }
        IMAGE_NT_HEADERS *pNT = (IMAGE_NT_HEADERS*)(pBase + pDOS->e_lfanew);
        if (pNT->Signature != IMAGE_NT_SIGNATURE ||
            pNT->FileHeader.SizeOfOptionalHeader != IMAGE_SIZEOF_NT_OPTIONAL_HEADER ||
            pNT->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC
            ) 
        {
            __leave;
        }

        if (ip >= pBase && ip < pBase + pNT->OptionalHeader.SizeOfImage) 
        {
            return true;
        }
    
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    return false;
}

BOOL
__stdcall
IsValidResource(HINSTANCE hModule, BYTE *pStart, DWORD dwSize) {

    if (pStart + dwSize < pStart)
        return FALSE;

    if (!IsIPInModule(hModule, pStart))
        return FALSE;
        
    if (!IsIPInModule(hModule, pStart+dwSize))
        return FALSE;
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\healthmonitor.cxx ===
/**
 * Health monitoring for IIS6 in ASP.NET
 * 
 * Copyright (c) 2002 Microsoft Corporation
 */

#include "precomp.h"
#include "dbg.h"
#include "util.h"
#include "nisapi.h"
#include "Wincrypt.h"
#include "_ndll.h"
#include "event.h"

/////////////////////////////////////////////////////////////////////////////

BOOL    g_HealthMonitoringEnabled = FALSE;
DWORD   g_DeadlockIntervalSeconds = 0;
DWORD   g_LastActivityTime = 0;     // last time a response was written
DWORD   g_LastRequestStartTime = 0; // last time request was sent to managed code
LONG    g_ProblemReportedFlag = 0;  // flag set in an interlocked way to report problem only once

// 
//  Local helpers
//

inline DWORD GetCurrentHealthMonitoringTime() {
    return (GetTickCount() / 1000);
}

void ReportHealthProblem(EXTENSION_CONTROL_BLOCK *pECB, int messageId, LPSTR fallbackMessageText) {
    // report only once
    if (InterlockedExchange(&g_ProblemReportedFlag, 1) == 1)
        return;

    // format the message
    char bufMessage[256];
    char *pMessage;

    if (FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE,
                       g_rcDllInstance, 
                       messageId, 
                       0,
                       bufMessage, 
                       ARRAY_SIZE(bufMessage)-1,
                       NULL)) {
        pMessage = bufMessage;

        // strip trailing \r\n
        DWORD l = lstrlenA(bufMessage);
        while (l > 0 && (bufMessage[l-1] == '\r') || (bufMessage[l-1] == '\n'))
            bufMessage[--l] = '\0';
    }
    else {
        pMessage = fallbackMessageText;
    }

    // report to IIS6
    pECB->ServerSupportFunction(pECB->ConnID, HSE_REQ_REPORT_UNHEALTHY, pMessage, NULL, NULL);
}

void CheckForDeadlocks(EXTENSION_CONTROL_BLOCK *pECB, DWORD timeStamp) {
    // only if interval set
    if (g_DeadlockIntervalSeconds == 0)
        return;

    // no requests in the system -- no problem
    if (HttpCompletion::s_ActiveManagedRequestCount == 0) {
        // First request after idle is considered 'activity' for health monitoring
        // (otherwise there's a race if 2 requests come after a period of idle and
        // the second of them would report a health problem if the first didn't write
        // anything yet by the time the second checks for deadlock)
        UpdateLastActivityTimeForHealthMonitor();
        return;
    }

    // not enough time passed since the last activity
    DWORD lastActivityTime = g_LastActivityTime;

    if (timeStamp <= lastActivityTime) // could not be the case if g_LastActivityTime just updated
        return;

    if ((timeStamp - lastActivityTime) < g_DeadlockIntervalSeconds)
        return;

    // 144967 & 145323: if fewer requests than threads, it's not a deadlock
    if (HttpCompletion::s_ActiveManagedRequestCount <= (LONG) GetClrThreadPoolLimit())
        return;

    TRACE2(L"HealthMonitor", L"Deadlock detected, RequestCount %d, TimeSinceLastActivity %d sec.", 
        HttpCompletion::s_ActiveManagedRequestCount, (timeStamp - g_LastActivityTime));

    ReportHealthProblem(pECB, IDS_HEALTH_MONITOR_DEADLOCK_MESSAGE, "deadlock");
}

//
//  Functions called from outside
//

void
__stdcall
InitializeHealthMonitor( // called from managed code which reads config
    int deadlockIntervalSeconds) {

    // this functions could be called from multiple app domain
    // thus and has to be thread safe
    
    // deadlock detection
    if (deadlockIntervalSeconds > 0) {
        g_DeadlockIntervalSeconds = deadlockIntervalSeconds;
        g_HealthMonitoringEnabled = TRUE;
    }
    else {
        // need to disable in case of change in machine.config to "Infinite"
        g_HealthMonitoringEnabled = FALSE;
    }

    // CONSIDER: other health monitoring ...

    if (g_HealthMonitoringEnabled) 
        g_LastActivityTime = GetCurrentHealthMonitoringTime();
}

void
__stdcall
UpdateLastActivityTimeForHealthMonitor() {
    if (!g_HealthMonitoringEnabled)
        return;

    g_LastActivityTime = GetCurrentHealthMonitoringTime();
}

void UpdateLastRequestStartTimeForHealthMonitor() {
    if (!g_HealthMonitoringEnabled)
        return;

    g_LastRequestStartTime = GetCurrentHealthMonitoringTime();
}

void CheckAndReportHealthProblems(EXTENSION_CONTROL_BLOCK *pECB) {

    // only for IIS and only if enabled
    if (!g_HealthMonitoringEnabled || ((pECB->dwVersion >> 16) < 6))
        return;

    DWORD timeStamp = GetCurrentHealthMonitoringTime();

    CheckForDeadlocks(pECB, timeStamp);

    // CONSIDER: other health monitoring ...
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\historytable.cxx ===
/**
 * Process Model: HistoryTable defn file
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "util.h"
#include "HistoryTable.h"
#include "ProcessTableManager.h"
#include "ProcessEntry.h"

#define  SZ_REG_XSP_PROCESS_MODEL_HISTORY_TABLE_SIZE  L"MaxProcessHistoryTableRows"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Globals
CHistoryTable * CHistoryTable::g_pHistoryTable = NULL;
LONG            g_lCreatingHistoryTable        = 0;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Static functions

/////////////////////////////////////////////////////////////////////////////
// Create the table in a thread safe way
void
CHistoryTable::Init()
{
    if (g_pHistoryTable != NULL)
        return;

    if (g_lCreatingHistoryTable != 0 || InterlockedIncrement(&g_lCreatingHistoryTable) != 1)
    {
        for(int iter=0; g_pHistoryTable == NULL && iter<3000; iter++)
            Sleep(100);
    }
    else
    {
        g_pHistoryTable = new CHistoryTable();
    }
}

/////////////////////////////////////////////////////////////////////////////
// Add an entry for a process
void   
CHistoryTable::AddEntry(const CHistoryEntry & oEntry)
{
    if (g_pHistoryTable == NULL)
        Init();

    if (g_pHistoryTable == NULL || g_pHistoryTable->m_pTable == NULL)
        return;

    g_pHistoryTable->m_oLock.AcquireWriterLock();

    LONG lPos = g_pHistoryTable->m_lFillPos;
    g_pHistoryTable->m_lFillPos = (g_pHistoryTable->m_lFillPos + 1) % g_pHistoryTable->m_lMaxRows;

    g_pHistoryTable->m_oLock.ReleaseWriterLock();

    memcpy(&g_pHistoryTable->m_pTable[lPos], &oEntry, sizeof(oEntry));
    if (g_pHistoryTable->m_lRowsAdded < g_pHistoryTable->m_lMaxRows)
        InterlockedIncrement(&g_pHistoryTable->m_lRowsAdded);
}

/////////////////////////////////////////////////////////////////////////////
// Update the entry for process "dwInternalProcessNumber". The field to be updated is 
//   specified by dwOffset
void   
CHistoryTable::UpdateEntry(const CHistoryEntry & oEntry)
{
    if (g_pHistoryTable == NULL || g_pHistoryTable->m_pTable == NULL)
        return;

    for(int iter=0; iter<g_pHistoryTable->m_lMaxRows; iter++)
        if (g_pHistoryTable->m_pTable[iter].dwInternalProcessNumber == oEntry.dwInternalProcessNumber)
        {
            memcpy(&g_pHistoryTable->m_pTable[iter], &oEntry, sizeof(oEntry));
            return;
        }
}

/////////////////////////////////////////////////////////////////////////////
// Dump the table into this buffer: must be of size from GetDumpSize
int
CHistoryTable::GetHistory(BYTE * pBuf, int iBufSize)
{
    int iRows = iBufSize / sizeof(CHistoryEntry);

    if (iRows <= 0 || pBuf == NULL || g_pHistoryTable == NULL || 
        g_pHistoryTable->m_pTable == NULL || g_pHistoryTable->m_lRowsAdded == 0)
    {
        return 0;
    }

    if (iRows > g_pHistoryTable->m_lMaxRows)
        iRows = g_pHistoryTable->m_lMaxRows;

    if (iRows > g_pHistoryTable->m_lRowsAdded)
        iRows = g_pHistoryTable->m_lRowsAdded;

    int iEnd = g_pHistoryTable->m_lFillPos - 1;
    if (iEnd < 0)
        iEnd += g_pHistoryTable->m_lMaxRows;

    int iStart = iEnd - (iRows - 1);

    if (iStart < 0)
        iStart += g_pHistoryTable->m_lMaxRows;
    
    CHistoryEntry * pDest = (CHistoryEntry *) pBuf;
    for(int iDestPos = 0; iDestPos < iRows; iDestPos++)
    {
        memcpy(&pDest[iDestPos], &g_pHistoryTable->m_pTable[iStart], sizeof(CHistoryEntry));

        if ((pDest[iDestPos].eReason & EReasonForDeath_RemovedFromList) == 0)
        {
            CProcessEntry * pProc = CProcessTableManager::GetProcess(pDest[iDestPos].dwInternalProcessNumber);
            if (pProc != NULL)
            {
                pDest[iDestPos].dwRequestsExecuted   = pProc->GetNumRequestStat(2);
                pDest[iDestPos].dwRequestsPending    = 0; //pProc->GetNumRequestStat(0);
                pDest[iDestPos].dwRequestsExecuting  = pProc->GetNumRequestStat(1);
                pDest[iDestPos].dwPeakMemoryUsed     = pProc->GetPeakMemoryUsed();
                pProc->Release();
            }
        }


        iStart++;
        if (iStart >= g_pHistoryTable->m_lMaxRows)
            iStart = 0;
    }

    return iRows;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Non Static functions
// CTor
CHistoryTable::CHistoryTable() : m_oLock("CHistoryTable")
{
    m_lMaxRows = 100;
    m_pTable = new (NewClear) CHistoryEntry[m_lMaxRows];
    m_lFillPos = 0;
}

/////////////////////////////////////////////////////////////////////////////
// DTor
CHistoryTable::~CHistoryTable()
{ 
    delete [] m_pTable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\etw.cxx ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    etwtrace.cpp (ETW tracelogging)

Abstract:

    This module implements the Event Tracer for Windows (ETW)
    tracing capability.

Author:

    Melur Raghuraman (mraghu)       08-May-2001

Revision History:

    Revision to incorporate into ASP.NET tree - Fabio Yeon (fabioy)  2-5-2001

--*/

//
//--> Include other headers from the project
//
#include "precomp.h"
#include "platform_apis.h"
#include "etw.h"

#define ETW_MAX_PATH 256

/*++

Routine Description:
    Class Constructor.
    Initializes the private members.

Arguments:
    none

Return Value:

--*/
CEtwTracer::CEtwTracer()
{
    m_fTraceEnabled     = FALSE;
    m_fTraceSupported   = TRUE;
    m_fTraceInitialized = FALSE;
    m_hTraceLogger      = ((TRACEHANDLE)INVALID_HANDLE_VALUE);
    m_hProviderReg      = ((TRACEHANDLE)INVALID_HANDLE_VALUE);
    m_ulEnableFlags     = 0;
    m_ulEnableLevel     = 0;

}

/*++

Routine Description:

    Registers with ETW tracing framework. 
    This function should not be called more than once.

Arguments:
    ControlGuid     This is the provider's identifying GUID
    EventGuid       This guid is used for all events associated
                    with this provider.
    ImagePath       A wide-string containing the name of the image
                    that contains the MOF resource that describes events
                    associated with this provider
    MofResourceName Name of the MOF resource

Return Value:
    Returns the status from RegisterTraceGuids. 

--*/
HRESULT CEtwTracer::Register(const GUID * ControlGuid, const GUID * EventGuid, LPWSTR ImagePath, LPWSTR MofResourceName)
{
    HRESULT hr = S_OK;

    //
    // If we are already initialized, return success
    //
    if(m_fTraceInitialized == TRUE) {
        EXIT();
    }

    //
    // ETW tracing only exists on W2k and greater OS's
    //
    if (GetCurrentPlatform() != APSX_PLATFORM_W2K) {
        m_fTraceSupported = FALSE;
        EXIT_WITH_WIN32_ERROR(ERROR_NOT_SUPPORTED);
    }
    else {
        m_fTraceSupported = TRUE;
    }

    //
    // Create the guid registration array
    //
    TRACE_GUID_REGISTRATION TraceGuidReg[] =
    {
      { 
        EventGuid, 
        NULL 
      }
    };

    //
    // Get the full path for this image file
    //
    HMODULE     hModule;
    WCHAR       FileName[ETW_MAX_PATH+1];
    DWORD       nLen = 0;

    hModule = GetModuleHandle(ImagePath);
    ON_ZERO_EXIT_WITH_LAST_ERROR(hModule);

    nLen = GetModuleFileName(hModule, FileName, ETW_MAX_PATH);
    ON_ZERO_EXIT_WITH_LAST_ERROR(nLen);

    //
    // Now register this process as a WMI trace provider.
    //
    ULONG status = RegisterTraceGuids(
        (WMIDPREQUEST)ControlCallback,  // Enable/disable function.
        this,                           // RequestContext parameter
        ControlGuid,                    // Provider GUID
        1,                              // TraceGuidReg array size
        TraceGuidReg,                   // Array of TraceGuidReg structures
        FileName,                       // Optional WMI - MOFImagePath
        MofResourceName,                // Optional WMI - MOFResourceName
        &m_hProviderReg);               // Handle required to unregister.

    if( status == ERROR_SUCCESS ) {
        m_fTraceInitialized = TRUE;
    }
    else {
        EXIT_WITH_WIN32_ERROR(status);
    }

Cleanup:
    return hr;
}

/*++

Routine Description:
        Unregisters the provider from ETW. This function
        should only be called once.

Arguments:
    none

Return Value:
    Return value from UnregisterTraceGuids. 

--*/
HRESULT CEtwTracer::Unregister() 
{
    HRESULT hr = S_OK;

    if (m_fTraceSupported == FALSE) {
        EXIT_WITH_WIN32_ERROR(ERROR_NOT_SUPPORTED);
    }

    if (m_fTraceInitialized == FALSE) {
        EXIT();
    }

    ULONG status = UnregisterTraceGuids( m_hProviderReg );
    m_hProviderReg = (TRACEHANDLE)INVALID_HANDLE_VALUE;
    m_fTraceInitialized = FALSE;

    if (status != ERROR_SUCCESS) {
        EXIT_WITH_WIN32_ERROR(status);
    }

Cleanup:
    return hr;
}

#pragma warning ( disable : 4061 )

/*++

Routine Description:

    This function handles the ETW control callback. 
    It enables or disables tracing. On enable, it also
    reads the flag and level that was passed in by the
    trace console / trace controller.

Arguments:
    none

Return Value:
    ERROR_SUCCESS on success.
    ERROR_INVALID_HANDLE if a bad handle is passed from ETW.
    ERROR_INVALID_PARAMETER if an invalid parameter is sent by ETW. 

--*/
ULONG CEtwTracer::CtrlCallback(WMIDPREQUESTCODE RequestCode, PVOID Context, ULONG *InOutBufferSize, PVOID Buffer)
{
    ULONG ret = ERROR_SUCCESS;
    LONG Level=0;

    switch(RequestCode) {
        case WMI_ENABLE_EVENTS:                  //Enable tracing!

            m_hTraceLogger = (TRACEHANDLE) GetTraceLoggerHandle(Buffer);
            
            //This should never happen...
            if (m_hTraceLogger == (TRACEHANDLE)INVALID_HANDLE_VALUE) {
                m_fTraceEnabled = FALSE;
                ret = ERROR_INVALID_HANDLE;
                break;
            }

            //Get other trace related info
            Level = GetTraceEnableLevel(m_hTraceLogger);
            m_ulEnableFlags = GetTraceEnableFlags(m_hTraceLogger);

            if (Level > ETWMAX_TRACE_LEVEL) {
                Level = ETWMAX_TRACE_LEVEL;
            }

            m_ulEnableLevel = 1 << Level;
            m_fTraceEnabled = TRUE;         //Enable the trace events
            break;
        
        case WMI_DISABLE_EVENTS:            //Disable tracing
            m_fTraceEnabled = FALSE;
            m_ulEnableFlags = 0;
            m_ulEnableLevel = 0;
            m_hTraceLogger = (TRACEHANDLE)INVALID_HANDLE_VALUE;
            break;
        
        default:                            //This also should never happen
            ret = ERROR_INVALID_PARAMETER;
    }

    return ret;
}

#pragma warning ( default : 4061 )

/*++

Routine Description:

    Wrapper function for firing a trace event

Arguments:

    buffer containing the event to be traced.
    This buffer must start with an EVENT_TRACE_HEADER
    object.

Return:

    Returns status from TraceEvent call

--*/
HRESULT CEtwTracer::WriteEvent(PEVENT_TRACE_HEADER event)
{
    HRESULT hr = S_OK;
    
    if (!m_fTraceEnabled) 
        EXIT_WITH_WIN32_ERROR(ERROR_NOT_SUPPORTED);

    ULONG status = TraceEvent(m_hTraceLogger, event);
    if (status != ERROR_SUCCESS)
        EXIT_WITH_WIN32_ERROR(status);

Cleanup:
    return hr;
}

extern "C" {

/*++

Routine Description:

    ETW likes to have a standard C function for a control callback,
    so simply wrap a call to the global instance's CtrlCallback function. 

Arguments:
    none

Return Value:
    Return value from the CtrlCallback function. 

--*/
ULONG WINAPI ControlCallback(WMIDPREQUESTCODE RequestCode, PVOID Context, ULONG *InOutBufferSize, PVOID Buffer) 
{

    CEtwTracer * Tracer = (CEtwTracer*) Context;

    if (Context == NULL) return ERROR_INVALID_PARAMETER;

    return Tracer->CtrlCallback(RequestCode, Context, InOutBufferSize, Buffer);
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\historytable.h ===
/**
 * HistoryTable header file
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _HistoryTable_H
#define _HistoryTable_H

#include "MessageDefs.h"

/////////////////////////////////////////////////////////////////////////////

class CHistoryTable
{
public:
    // Create the history table
    static   void   Init          ();

    // Add an entry for a process
    static   void   AddEntry      (const CHistoryEntry & oEntry);

    // Update a process's entry (if present)
    static   void   UpdateEntry   (const CHistoryEntry & oEntry);

    // Dump the history to a buffer: Returns: number of rows dumped
    static   int    GetHistory    (BYTE * pBuf, int iBufSize);

private:
    // CTor and DTor
    DECLARE_MEMCLEAR_NEW_DELETE();
    CHistoryTable                 ();
    ~CHistoryTable                ();


    ////////////////////////////////////////////////////////////
    // Singleton instance
    static CHistoryTable *        g_pHistoryTable;

    ////////////////////////////////////////////////////////////
    // Private data

    // Current fill position
    LONG                          m_lFillPos, m_lMaxRows, m_lRowsAdded;
    CReadWriteSpinLock            m_oLock;

    // The actual table
    CHistoryEntry *               m_pTable;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\instrumentedmutex.cxx ===
/**
 * Intrumented Mutex Code
 * 
 * Copyright (c) 1998-2001, Microsoft Corporation
 * 
 */

#include "precomp.h"
#include "_ndll.h"
#include "util.h"
#include "hashtable.h"

// global instrumented mutex table
CReadWriteSpinLock g_InstrumentedMutexTableLock("InstrumentedMutexTableLock");
HashtableIUnknown *g_pInstrumentedMutexTable = NULL;

HRESULT CreateInstrumentedMutexTable() {
    HRESULT hr = S_OK;
    HashtableIUnknown *pTempTable = NULL;

    pTempTable = new HashtableIUnknown();
    ON_OOM_EXIT(pTempTable);

    hr = pTempTable->Init(177);
    ON_ERROR_EXIT();

    g_pInstrumentedMutexTable = pTempTable;
    pTempTable = NULL;

Cleanup:
    if (pTempTable != NULL)
        delete pTempTable;

    return hr;
}

// ref counted class to represent one named mutex
class InstrumentedMutex : public IUnknown {

private:
    long   _refs;
    WCHAR *_pName;
    HANDLE _handle;
    DWORD  _threadId;
    int    _state;

public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    InstrumentedMutex() {
        _refs = 1;
        _pName = NULL;
        _handle = NULL;
        _threadId = 0;
        _state = 0;
    }

    ~InstrumentedMutex() {
        if (_handle != NULL)
            CloseHandle(_handle);
        delete [] _pName;
    }

    HRESULT Create(WCHAR *pName) {
        HRESULT hr = S_OK;

        if (pName != NULL) {
            _pName = DupStr(pName);
            ON_OOM_EXIT(_pName);
        }

        _handle = CreateMutex(NULL, FALSE, _pName);
        ON_ZERO_EXIT_WITH_LAST_ERROR(_handle);

    Cleanup:
        return hr;
    }

    DWORD GetLock(DWORD timeout) {
        HRESULT hr = S_OK;

        DWORD rc = WaitForSingleObjectEx(_handle, timeout, FALSE);

        if (rc == WAIT_FAILED)
            EXIT_WITH_LAST_ERROR();

        if (rc == WAIT_OBJECT_0 || rc == WAIT_ABANDONED) {
            _threadId = GetCurrentThreadId();
            _state = 0;
        }

    Cleanup:
        return rc;
    }

    BOOL ReleaseLock() {
        HRESULT hr = S_OK;

        DWORD oldThreadId = _threadId;

        if (_threadId == GetCurrentThreadId()) {
            _threadId = 0;
            _state = 0;
        }

        BOOL rc = ReleaseMutex(_handle);
        ON_ZERO_EXIT_WITH_LAST_ERROR(rc);

    Cleanup:
        if (!rc && _threadId == 0)
            _threadId = oldThreadId;    // failed to release - restore thread id

        return rc;
    }

    void SetState(int state) {
        _state = state;
    }


    // IUnknown implementation
    STDMETHOD(QueryInterface)(REFIID iid, void **ppvObj) {
        if (iid == IID_IUnknown) {
            AddRef();
            *ppvObj = this;
            return S_OK;
        }
        else {
            return E_NOINTERFACE;
        }
    }

    STDMETHOD_(ULONG, AddRef)() {
        return InterlockedIncrement(&_refs);
    }

    STDMETHOD_(ULONG, Release)() {
        long r = InterlockedDecrement(&_refs);
        if (r == 0) {
            delete this;
            return 0;
        }
        return r;
    }
};

// exported functions

ULONG_PTR __stdcall InstrumentedMutexCreate(WCHAR *pName) {
    HRESULT hr = S_OK;
    ULONG_PTR rc = 0;
    BYTE *pKey;
    int keyLen;
    long keyHash;
    InstrumentedMutex *pMutex = NULL;

    g_InstrumentedMutexTableLock.AcquireWriterLock();

    if (g_pInstrumentedMutexTable == NULL) {
        hr = CreateInstrumentedMutexTable();
        ON_ERROR_EXIT();
    }

    pKey = (BYTE *)pName;
    keyLen = (int)wcslen(pName)*sizeof(WCHAR);
    keyHash = SimpleHash(pKey, keyLen);

    hr = g_pInstrumentedMutexTable->Find(pKey, keyLen, keyHash, (IUnknown **)&pMutex);

    if (hr != S_OK) {
        // not found -- need to create and insert
        pMutex = new InstrumentedMutex();
        ON_OOM_EXIT(pMutex);

        hr = pMutex->Create(pName);
        ON_ERROR_EXIT();

        pMutex->AddRef();
        hr = g_pInstrumentedMutexTable->Insert(pKey, keyLen, keyHash, pMutex);
        ON_ERROR_EXIT();
    }

    // return the value
    pMutex->AddRef();
    rc = (ULONG_PTR)pMutex;

Cleanup:
    g_InstrumentedMutexTableLock.ReleaseWriterLock();

    ReleaseInterface(pMutex);
    return rc;
}

void __stdcall InstrumentedMutexDelete(ULONG_PTR mutex) {
    if (mutex != 0)
        ((InstrumentedMutex *)mutex)->Release();

    // keep it in the global table, so we can find its state later
}

DWORD __stdcall InstrumentedMutexGetLock(ULONG_PTR mutex, DWORD timeout) {
    if (mutex != 0)
        return ((InstrumentedMutex *)mutex)->GetLock(timeout);
    else
        return WAIT_FAILED;
}

BOOL __stdcall InstrumentedMutexReleaseLock(ULONG_PTR mutex) {
    if (mutex != 0)
        return ((InstrumentedMutex *)mutex)->ReleaseLock();
    else
        return FALSE;
}

void __stdcall InstrumentedMutexSetState(ULONG_PTR mutex, int state) {
    if (mutex != 0)
        ((InstrumentedMutex *)mutex)->SetState(state);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\main.cxx ===
/**
 * aspnet_isapi Main module:
 * DllMain, DllGetClassObject, etc.
 *
 * Copyright (c) 1998 Microsoft Corporation
 */

#include "precomp.h"
#include "pm.h"
#include "nisapi.h"
#include "npt.h"
#include "names.h"
#include "event.h"


DEFINE_DBG_COMPONENT(ISAPI_MODULE_FULL_NAME_L);

//  Private globals
HINSTANCE g_DllInstance;
HINSTANCE g_rcDllInstance;

// exported globals
HANDLE    g_hXSPHeap = NULL;
DWORD     g_tlsiEventCateg = TLS_OUT_OF_INDEXES;

//
// One time explicit library initialization
//

BOOL g_fLibraryInited = FALSE;
LONG g_LibraryInitLock = 0;

PFN_NtQuerySystemInformation g_pfnNtQuerySystemInformation;
PFN_NtQueryInformationThread g_pfnNtQueryInformationThread;
PFN_NtQueryInformationProcess g_pfnNtQueryInformationProcess;

void LinkToNtdll() {
    HMODULE hmod;

    hmod = LoadLibrary(L"ntdll.dll");
    if (hmod != NULL) {
        g_pfnNtQuerySystemInformation = (PFN_NtQuerySystemInformation) GetProcAddress(hmod, "NtQuerySystemInformation");
        g_pfnNtQueryInformationThread = (PFN_NtQueryInformationThread) GetProcAddress(hmod, "NtQueryInformationThread");
        g_pfnNtQueryInformationProcess = (PFN_NtQueryInformationProcess) GetProcAddress(hmod, "NtQueryInformationProcess");
    }
}

HRESULT
InitDllLight()
{
    HRESULT hr = S_OK;

    LinkToNtdll();

    DisableThreadLibraryCalls(g_DllInstance);

    g_hXSPHeap = HeapCreate(0, 0, 0);
    if (g_hXSPHeap == NULL)
        g_hXSPHeap = GetProcessHeap();

    hr = Names::GetInterestingFileNames();
    ON_ERROR_EXIT();

    g_tlsiEventCateg = TlsAlloc();
    if (g_tlsiEventCateg == TLS_OUT_OF_INDEXES)
        EXIT_WITH_LAST_ERROR();

    LoadLibrary(Names::IsapiFullPath());   // to disable unloading

Cleanup:
    return hr;
}

HRESULT
InitDllReal()
{
    HRESULT hr = S_OK;

    hr = InitThreadPool();
    ON_ERROR_EXIT();

    hr = DllInitProcessModel();
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}


// Exported API

HRESULT
__stdcall
InitializeLibrary()
{
    HRESULT hr = S_OK;

    if (!g_fLibraryInited) 
    {
        // use simple lock that doesn't rely on any initialization taken place
        while (InterlockedCompareExchange(&g_LibraryInitLock, 1, 0) != 0)
            Sleep(0);

        if (!g_fLibraryInited) 
        {
            hr = InitDllReal();
            g_fLibraryInited = TRUE;
        }

        InterlockedExchange(&g_LibraryInitLock, 0);
    }

    return hr;
}


BOOL WINAPI
DllMain(HINSTANCE Instance, DWORD Reason, LPVOID)
{
    switch (Reason)
    {
    case DLL_PROCESS_ATTACH:
        g_DllInstance = Instance;
        // Don't do full initialization here, every host should call InitializeLibrary
        if (InitDllLight() != S_OK)
        {
            DbgpStopNotificationThread();
            return FALSE;
        }
        break;

    default:
        break;
    }

    return TRUE;
}

HINSTANCE
GetXSPInstance()
{
    return g_DllInstance;
}

HANDLE
GetXSPHeap()
{
    return g_hXSPHeap;
}

HINSTANCE
GetRCInstance()
{
    return g_rcDllInstance;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\httpextproc.cxx ===
/**
 * ASP.NET ISAPI HttpExtensionProc implementation.
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

#include "precomp.h"
#include "dbg.h"
#include "util.h"
#include "nisapi.h"
#include "pm.h"
#include "msg.h"
#include "processtablemanager.h"
#include "PerfCounters.h"
#include "etw.h"
#include "aspnetetw.h"

/**
 * Initialization error
 */
HRESULT g_InitHR;
char *  g_pInitErrorMessage;

// Prototypes for functions defined here
extern "C"
{
BOOL  __stdcall GetExtensionVersion(HSE_VERSION_INFO *);
BOOL  __stdcall TerminateExtension(DWORD);
DWORD __stdcall HttpExtensionProc(EXTENSION_CONTROL_BLOCK *);
}

HRESULT EcbWrite(EXTENSION_CONTROL_BLOCK *pEcb, LPCSTR text)
{
    HRESULT hr = S_OK;
    DWORD cbWrite;

    cbWrite = lstrlenA(text);

    pEcb->WriteClient(pEcb->ConnID, (void *)text, &cbWrite, HSE_IO_SYNC);

    return hr;
}

static BOOL IsGoodPath(char *pPath)
{
    int lastChar = 0;
    int iChar = 0;
    int ch = 0;

    do {
        ch = pPath[iChar++];

        switch (ch) {
            case '<':
            case '>':
            case '*':
// DBCS chars could produce it: case '?':
            case '%':
            case '&':
            case ':':
                return FALSE;

            case '.':
                if (lastChar == '.')
                    return FALSE;
                break;

            default:
                if (ch > 0 && ch < 32)
                    return FALSE;
                break;
        }

        if (iChar > MAX_PATH)
            return FALSE;

        lastChar = ch;
    }
    while (ch != 0);

    return TRUE;
}

HRESULT VerifyRequest(EXTENSION_CONTROL_BLOCK *pEcb) 
{
    HRESULT hr = S_OK;

    if (!IsGoodPath(pEcb->lpszPathInfo))
        EXIT_WITH_HRESULT(E_UNEXPECTED);

Cleanup:
    return hr;
}


/**
 * ISAPI initialization function
 */
BOOL __stdcall
GetExtensionVersion(
    HSE_VERSION_INFO *pVersionInfo)
{
    HRESULT hr;

    hr = InitializeLibrary();
    ON_ERROR_EXIT();

    // Init perf counters
    hr = PerfCounterInitialize();
    ON_ERROR_CONTINUE(); hr = S_OK;

    hr = ISAPIInitProcessModel();
    ON_ERROR_EXIT();

    // Init the WMI Event Trace
    hr = EtwTraceAspNetRegister();
    ON_ERROR_CONTINUE(); hr = S_OK;

    if (_wcsicmp(Names::ExeFileName(), L"DLLHOST.EXE") == 0) {
        hr = E_FAIL;
        g_InitHR = hr;
    }

    pVersionInfo->dwExtensionVersion = MAKELONG(HSE_VERSION_MAJOR, HSE_VERSION_MINOR);
    StringCchCopyA(pVersionInfo->lpszExtensionDesc, HSE_MAX_EXT_DLL_NAME_LEN, ISAPI_MODULE_FULL_NAME);

Cleanup:
    if (hr) 
    {
        SetLastError(hr);
    }

    return (hr == S_OK);
}


/**
 * ISAPI uninitialization function
 */
BOOL __stdcall
TerminateExtension(
    DWORD
    )
{
    HRESULT hr = S_OK;

    if (!g_fUseXSPProcessModel)
    {
        hr = HttpCompletion::DisposeAppDomains();
        ON_ERROR_CONTINUE();
    }

    hr = ISAPIUninitProcessModel();
    ON_ERROR_CONTINUE();

    // Unregister the WMI Event Trace
    hr = EtwTraceAspNetUnregister();
    ON_ERROR_CONTINUE();

    // To disable unloading.  We already call this in InitDllLight, but on
    // Windows.NET, it doesn't seem to work, probably because it's during
    // DLL_PROCESS_ATTACH time (ASURT 74004)
    LoadLibrary(Names::IsapiFullPath());

    return (hr == S_OK);
}


/**
 * ISAPI 'process request' function
 */
DWORD __stdcall
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK *pEcb)
{
    HRESULT hr = S_OK;
    BOOL verified = FALSE;
    BOOL errorReported = FALSE;
    HttpCompletion *pCompletion = NULL;

    PerfIncrementGlobalCounter(ASPNET_REQUESTS_TOTAL_NUMBER);

    // Check if initialization failed
    if (g_InitHR)
        EXIT_WITH_HRESULT(g_InitHR);

    // Verify for bad requests (attack?)
    hr = VerifyRequest(pEcb);
    ON_ERROR_EXIT();
    verified = TRUE;

    hr = EtwTraceAspNetPageStart(pEcb->ConnID );
    ON_ERROR_CONTINUE();

    if (g_fUseXSPProcessModel)
    {
        SetThreadToken(NULL, NULL); // Make sure thread is clean w.r.t. impersonation
        hr = AssignRequestUsingXSPProcessModel(pEcb);
    }
    else
    {
        // Check health on IIS6
        if ((pEcb->dwVersion >> 16) >= 6)
            CheckAndReportHealthProblems(pEcb);

        // Create HttpCompletion object
        pCompletion = new HttpCompletion(pEcb);
        ON_OOM_EXIT(pCompletion);
        // Set the request start time
        GetSystemTimeAsFileTime((FILETIME *) &(pCompletion->qwRequestStartTime));

        PerfIncrementGlobalCounter(ASPNET_REQUESTS_QUEUED_NUMBER);
        PerfIncrementGlobalCounter(ASPNET_REQUESTS_CURRENT_NUMBER);

        //  Post the request to ASP.NET runtime
        hr = PostThreadPoolCompletion(pCompletion);

        if (hr)
        {
            delete pCompletion;
            
            PerfDecrementGlobalCounter(ASPNET_REQUESTS_QUEUED_NUMBER);
            
            HttpCompletion::ReportHttpError(
                pEcb, 
                g_InitHR ? IDS_INIT_ERROR : IDS_CANNOT_QUEUE,
                !verified,
                FALSE,
                0);

            PerfDecrementGlobalCounter(ASPNET_REQUESTS_CURRENT_NUMBER);

            errorReported = TRUE;
        }
    }

Cleanup:
    if (hr)
    {
        if (!errorReported) 
        {
            HttpCompletion::ReportHttpError(
                pEcb, 
                g_InitHR ? IDS_INIT_ERROR : IDS_CANNOT_QUEUE,
                !verified,
                FALSE,
                0);
        }
        return HSE_STATUS_ERROR;
    }

    return HSE_STATUS_PENDING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\httpcompletion.cxx ===
/**
 * HttpCompletion implementation.
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

#include "precomp.h"
#include "dbg.h"
#include "util.h"
#include "nisapi.h"
#include "appdomains.h"
#include "_isapiruntime.h"
#include "msg.h"
#include "processtablemanager.h"
#include "PerfCounters.h"
#include "pm.h"
#include "_ndll.h"
#include "event.h"
#include "etw.h"
#include "aspnetetw.h"
#include "ecbdirect.h"

//
//  Check for potential SBS problems
//  only one version ASP.NET ISAPI is allowed to go into managed code in a process
//

BOOL g_SameProcessSideBySideOk = FALSE;
CReadWriteSpinLock g_CheckSideBySideLock("SBSVerificationLock");

HRESULT CheckSideBySide()
{
    static BOOL s_checked = FALSE;
    static BOOL s_failed = FALSE;
    static WCHAR s_atom[] = L"ASP.NET";

    HRESULT hr = S_OK;
    BOOL locked = FALSE;

    // already checked?
    if (s_checked)
        EXIT();

    g_CheckSideBySideLock.AcquireWriterLock();
    locked = TRUE;

    if (s_checked)
        EXIT();

    // make sure no other DLL has the Atom
    if (FindAtom(s_atom) != 0) 
    {
        s_failed = TRUE;
        XspLogEvent(IDS_SAME_PROCESS_SBS_NOT_SUPPORTED, NULL);
    }
    AddAtom(s_atom);

    g_SameProcessSideBySideOk = !s_failed;
    s_checked = TRUE;

Cleanup:
    if (locked)
        g_CheckSideBySideLock.ReleaseWriterLock();

    return s_failed ? E_FAIL : S_OK;
}

//
//  Request count in managed code (used for deadlock detection in IIS6)
//

LONG HttpCompletion::s_ActiveManagedRequestCount = 0;

/**
 * Static method to connect to the managed runtime code
 */
HRESULT
HttpCompletion::InitManagedCode()
{
    HRESULT hr;

    hr = InitAppDomainFactory();
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

/**
 * Static method to disconnect from the managed runtime code
 */
HRESULT
HttpCompletion::UninitManagedCode()
{
    HRESULT hr;

    // appdomain factory
    hr = UninitAppDomainFactory();
    ON_ERROR_CONTINUE();

    return hr;
}

/**
 * Callback to dispose individual app domain
 */
void __stdcall AppDomainDisposeCallback(IUnknown *pAppDomainObject)
{
    if (pAppDomainObject != NULL)
    {
        xspmrt::_ISAPIRuntime *pRuntime = NULL;

        if (pAppDomainObject->QueryInterface(__uuidof(xspmrt::_ISAPIRuntime), (LPVOID*)&pRuntime) == S_OK)
        {
            pRuntime->StopProcessing();
            pRuntime->Release();
        }
    }
}

/**
 * Static method to close all app domains created with ISAPIRuntime
 */
HRESULT
HttpCompletion::DisposeAppDomains()
{
    return EnumAppDomains(AppDomainDisposeCallback);
}

HRESULT
FormatResourceMessage(
        UINT     messageId, 
        LPWSTR * buffer) 
{
    DWORD    dwRet   = 0;
    HRESULT  hr      = S_OK;
    
    for(int iSize = 512; iSize < 1024 * 1024 - 1; iSize *= 2)
    {
        (*buffer) = new (NewClear) WCHAR[iSize+1];
        ON_OOM_EXIT(*buffer);

        dwRet = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, 
                               g_rcDllInstance, messageId, 0, *buffer, iSize, NULL);

        if (dwRet != 0)
            EXIT(); // succeeded!
        
        // Free buffer
        delete [] (*buffer);
        (*buffer) = NULL;

        dwRet = GetLastError();
        if (dwRet != ERROR_INSUFFICIENT_BUFFER && dwRet != ERROR_MORE_DATA)
            EXIT_WITH_LAST_ERROR(); // Failed due to error
    }

 Cleanup:
    return hr;
}


HRESULT
FormatResourceMessageWithStrings(
        LPCWSTR    szTemplate, 
        LPWSTR *   buffer,
        LPWSTR *   args) 
{
    DWORD    dwRet   = 0;
    HRESULT  hr      = S_OK;
    
    for(int iSize = 1024; iSize < 1024 * 1024 - 1; iSize *= 2)
    {
        (*buffer) = new (NewClear) WCHAR[iSize+1];
        ON_OOM_EXIT(*buffer);

        dwRet = FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                               szTemplate, 0, 0, *buffer, iSize, (va_list *) args);

        if (dwRet != 0)
            EXIT(); // Done
        
        // Free Buffer
        delete [] (*buffer);
        (*buffer) = NULL;

        dwRet = GetLastError();
        if (dwRet != ERROR_INSUFFICIENT_BUFFER && dwRet != ERROR_MORE_DATA)
            EXIT_WITH_LAST_ERROR(); // Failed due to error
    }

 Cleanup:
    return hr;
}


//
// Error reportting from unmanaged code
//

CReadWriteSpinLock g_AllocAndFormatHtmlErrorLock("AllocAndFormatHtmlErrorLock");

char *
AllocAndFormatHtmlError(UINT errorResCode)
{
    static char *s_errorPage = NULL;
    static WCHAR s_template[] = 
        L"<html>\r\n"
        L"   <head>\r\n"
        L"      <title>%1</title>\r\n"
        L"   </head>\r\n"
        L"   <body>\r\n"
        L"      <h1><font face=Verdana color=#ff3300>%2</font></h1>\r\n"
        L"      <p>\r\n"
        L"      <font face=Verdana>\r\n"
        L"        %3</p>\r\n"
        L"   <p>\r\n"
        L"   <b>%4</b> %5 </p>\r\n"
        L"   </body>\r\n"
        L"</html>\r\n";

    
    //static char *s_VersionError;

    LPWSTR   pServerUnvailable  = NULL;
    LPWSTR   pServerApp         = NULL;
    LPWSTR   pRetry             = NULL;
    LPWSTR   pAdminNote         = NULL;
    LPWSTR   pReviewLog         = NULL;
    BOOL     fFreeLock          = FALSE;
    LPWSTR   pLast              = NULL;
    HRESULT  hr                 = S_OK;
    LPWSTR   argArray[5];
    int      iLen;
    LPSTR    szUtf8Error        = NULL;

    //char *pVersion = NULL;


    if (s_errorPage != NULL)
        EXIT();  // Already loaded

    // load resource strings once in a thread safe way
    g_AllocAndFormatHtmlErrorLock.AcquireWriterLock();
    fFreeLock = TRUE;

    if (s_errorPage != NULL)
        EXIT();

    // load version info
    //pVersion = GetStaticVersionString();
    // load "Version Information: ASP.NET Build: " 
    //char* versionArray[] = {pVersion};
    //ON_ZERO_EXIT_WITH_LAST_ERROR(FormatResourceMessage(IDS_VERSION, (LPSTR) &s_VersionError, versionArray));

    hr = FormatResourceMessage(IDS_SERVER_UNAVAILABLE, &pServerUnvailable);
    ON_ERROR_EXIT();
            
    hr = FormatResourceMessage(IDS_SERVER_APP_UNAVAILABLE, &pServerApp);
    ON_ERROR_EXIT();

    hr = FormatResourceMessage(IDS_RETRY, &pRetry);
    ON_ERROR_EXIT();
        
    hr = FormatResourceMessage(IDS_ADMIN_NOTE, &pAdminNote);
    ON_ERROR_EXIT();

    hr = FormatResourceMessage(IDS_REVIEW_LOG, &pReviewLog);
    ON_ERROR_EXIT();

    argArray[0] = pServerUnvailable; 
    argArray[1] = pServerApp; 
    argArray[2] = pRetry;
    argArray[3] = pAdminNote;
    argArray[4] = pReviewLog ;
            
    hr = FormatResourceMessageWithStrings(s_template, &pLast, argArray);
    ON_ERROR_EXIT();

    iLen = WideCharToMultiByte(CP_UTF8, 0, pLast, -1, NULL, 0, NULL, NULL);
    if (iLen <= 0 || iLen > 1000000)
        EXIT_WITH_LAST_ERROR();
    szUtf8Error = new (NewClear) char[iLen+1];
    ON_OOM_EXIT(szUtf8Error);
    iLen = WideCharToMultiByte(CP_UTF8, 0, pLast, -1, szUtf8Error, iLen+1, NULL, NULL);
    if (iLen <= 0 || iLen > 1000001)
        EXIT_WITH_LAST_ERROR();
    s_errorPage = szUtf8Error;

Cleanup:
    if (fFreeLock)
        g_AllocAndFormatHtmlErrorLock.ReleaseWriterLock();
    delete [] pServerUnvailable;
    delete [] pServerApp;
    delete [] pRetry;
    delete [] pAdminNote;
    delete [] pReviewLog;
    delete [] pLast;

    if (s_errorPage != szUtf8Error)
        delete [] szUtf8Error;

    return (hr==S_OK) ? s_errorPage : NULL;
}

/**
 * Fallback error if formatting fails
 */
static char s_FallbackHtmlError[] = "<html><body>Fatal Error: There was a fatal error and the error description could not be loaded from aspnet_rc.dll.</body></html>";

static char s_BadRequestHtmlError[] = "<html><body>Bad Request</body></html>";

/**
 * Static method to report error in case the code never made it to
 * the managed runtime. Optionally closes the http session.
 */
void
HttpCompletion::ReportHttpError(
    EXTENSION_CONTROL_BLOCK *pEcb,
    UINT errorResCode,
    BOOL badRequest,
    BOOL callDoneWithSession,
    int  iCallerID)
{
    char *pErrorText = NULL;
    DWORD bytes;

    // write out header

    pEcb->dwHTTPStatusCode = badRequest ? 400 : 500;
    (*pEcb->ServerSupportFunction)(
            pEcb->ConnID,
            HSE_REQ_SEND_RESPONSE_HEADER,
            badRequest ? "400 Bad Request" : "500 Internal Server Error",
            NULL,
            (LPDWORD)"Content-Type: text/html\r\n\r\n"
            );

    if (badRequest)
    {
        // use static error to respond to an attack using malformed requests

       bytes = sizeof(s_BadRequestHtmlError) - 1;

        (*pEcb->WriteClient)(
                pEcb->ConnID,
                s_BadRequestHtmlError,
                &bytes,
                0
                );
    }
    else
    {
        // use custom error if specified

        if (WriteCustomHttpError(pEcb))
        {
            // Successfully sent custom error
        }
        else
        {
            // use error from resource

            pErrorText = AllocAndFormatHtmlError(errorResCode);

            if (pErrorText != NULL)
            {
                bytes = lstrlenA(pErrorText);

                (*pEcb->WriteClient)(
                        pEcb->ConnID,
                        pErrorText,
                        &bytes,
                        0
                        );
            }
            else
            {
                // use static error

                bytes = sizeof(s_FallbackHtmlError) - 1;

                (*pEcb->WriteClient)(
                        pEcb->ConnID,
                        s_FallbackHtmlError,
                        &bytes,
                        0
                        );
            }
        }
    }

    if (callDoneWithSession)
    {
        DWORD status = HSE_STATUS_SUCCESS;

        // Don't care about return value here
        EtwTraceAspNetPageEnd(pEcb->ConnID);

        (*pEcb->ServerSupportFunction)(
                pEcb->ConnID,
                HSE_REQ_DONE_WITH_SESSION,
                &status,
                NULL,
                NULL
                );
    }
}

//
// Request processing in unmanaged code
//

/**
 * ICompletion callback method implemantation
 */
HRESULT
HttpCompletion::ProcessCompletion(HRESULT, int, LPOVERLAPPED)
{
#if ICECAP
    char buf[4028];
    {
        NameProfile(PRODUCT_NAME, PROFILE_THREADLEVEL,  PROFILE_CURRENTID);

        if (_pEcb->lpszQueryString != NULL && _pEcb->lpszQueryString[0] != '\0')
        {
            StringCchPrintfA(buf, ARRAY_SIZE(buf), "Start HttpComplection::ProcessCompletion 0x%p %s %s?%s", 
                      _pEcb, _pEcb->lpszMethod, _pEcb->lpszPathInfo, _pEcb->lpszQueryString);
        }
        else
        {
            StringCchPrintfA(buf, ARRAY_SIZE(buf), "Start HttpComplection::ProcessCompletion 0x%p %s %s", 
                      _pEcb, _pEcb->lpszMethod, _pEcb->lpszPathInfo);
        }

        CommentMarkProfile(1, buf);
    }
#endif

    HRESULT hr;

    PerfDecrementGlobalCounter(ASPNET_REQUESTS_QUEUED_NUMBER);

    if (g_fUseXSPProcessModel)
        hr = ProcessRequestViaProcessModel();
    else
        hr = ProcessRequestInManagedCode();

    ON_ERROR_EXIT();

Cleanup:

#if ICECAP
    {
        if (_pEcb->lpszQueryString != NULL && _pEcb->lpszQueryString[0] != '\0')
        {
            StringCchPrintfA(buf, ARRAY_SIZE(buf), "End HttpComplection::ProcessCompletion 0x%p %s %s?%s", 
                      _pEcb, _pEcb->lpszMethod, _pEcb->lpszPathInfo, _pEcb->lpszQueryString);
        }
        else
        {
            StringCchPrintfA(buf, ARRAY_SIZE(buf), "End HttpComplection::ProcessCompletion 0x%p %s %s", 
                      _pEcb, _pEcb->lpszMethod, _pEcb->lpszPathInfo);
        }
    
        CommentMarkProfile(2, buf);
    }
#endif

    Release();      // self-destruct
    return hr;
}


/**
 * In process request processing - go into managed code
 */
HRESULT
HttpCompletion::ProcessRequestInManagedCode()
{
    HRESULT hr = S_OK;
    IUnknown *pAppDomainObject = NULL;
    xspmrt::_ISAPIRuntime *pRuntime = NULL;
    char appIdBuffer[MAX_PATH];
    int  iRet;
    int  restartAppDomain = 0;
    int  maxRestarts = 10;
    int  numRestarts = 0;


    BOOL fUseUtf8 = ((_pEcb->dwVersion >> 16) >= 6);

    // Only one ASPNET_ISAPI per process is allowed to dispatch to managed code

    if (!g_SameProcessSideBySideOk) // not checked or failed?
    {
        if (CheckSideBySide() != S_OK)
        {
            ReportHttpError(_pEcb, IDS_COULDNT_CREATE_APP_DOMAIN, FALSE, FALSE, 0);
            EXIT_WITH_HRESULT(E_FAIL);
        }
    }

    // Get application ID to dispatch to the correct app domain

    if (fUseUtf8)
        iRet = EcbGetUtf8ServerVariable(_pEcb, "UNICODE_APPL_MD_PATH", appIdBuffer, MAX_PATH);
    else
        iRet = EcbGetServerVariable(_pEcb, "APPL_MD_PATH", appIdBuffer, MAX_PATH);

    if (iRet <= 0)
        EXIT_WITH_LAST_ERROR();


    do // Multiple times if app domain needs restart
    {
        // Find runtime  object in the correct app domain

        hr = GetAppDomain(appIdBuffer, NULL, &pAppDomainObject, NULL, 0, fUseUtf8 ? CP_UTF8 : CP_ACP);

        if (hr)
        {
            if (hr == S_FALSE && (numRestarts < maxRestarts))
            {
                // app domain not found -- need to create a new one

                char appPathBuffer[MAX_PATH];

                if (fUseUtf8)
                    iRet = EcbGetUtf8ServerVariable(_pEcb, "UNICODE_APPL_PHYSICAL_PATH", appPathBuffer, MAX_PATH);
                else
                    iRet = EcbGetServerVariable(_pEcb, "APPL_PHYSICAL_PATH", appPathBuffer, MAX_PATH);

                if (iRet <= 0)
                    EXIT_WITH_LAST_ERROR();

                hr = GetAppDomain(appIdBuffer, appPathBuffer, &pAppDomainObject, NULL, 0, fUseUtf8 ? CP_UTF8 : CP_ACP);
                numRestarts++;
            }

            if (hr)
            {
                ReportHttpError(_pEcb, IDS_COULDNT_CREATE_APP_DOMAIN, FALSE, FALSE, 0);
                EXIT();
            }
        }

        // Get ISAPI Runtime interface off app domain object

        hr = pAppDomainObject->QueryInterface(__uuidof(xspmrt::_ISAPIRuntime), (LPVOID*)&pRuntime);
        if (hr)
        {
            ReportHttpError(_pEcb, IDS_UNHANDLED_EXCEPTION, FALSE, FALSE, 0);
            EXIT();
        }

        // Count the requests in managed code
        IncrementActiveManagedRequestCount();

        // Remember the timestamp for stress investigations
        UpdateLastRequestStartTimeForHealthMonitor();

        // Call the managed code to process request
        hr = pRuntime->ProcessRequest(_pEcb, FALSE, &restartAppDomain);

        // App domain unloaded (error means that ThreadAbort happens while sending the respoinse)
        // in this case the error is sent from unmananged code so we can't call DONE_WITH_SESSION
        //      (real app domain unloaded errors before managed code would show up as failures
        //      in QI for ISAPIRuntime above
        if (hr == 0x80131014)
            hr = S_OK;

        // Count only errors (the request count is decremented from EcbFlushCore which could happen on another thread)
        if (hr != S_OK || restartAppDomain)
            DecrementActiveManagedRequestCount();

        // Make sure this thread is clean with respect to impersonation

        SetThreadToken(NULL, NULL);

        if (hr)
        {
            ReportHttpError(_pEcb, IDS_UNHANDLED_EXCEPTION, FALSE, FALSE, 0);
            EXIT();
        }
    }
    while (restartAppDomain);


Cleanup:

    if (pRuntime)
        pRuntime->Release();

    if (pAppDomainObject)
        pAppDomainObject->Release();

    if (hr)
    {
        // need 'done with session' in case of error before managed code
        DWORD status = HSE_STATUS_SUCCESS;

        // Don't care about return value here
        EtwTraceAspNetPageEnd(_pEcb->ConnID);

        (*_pEcb->ServerSupportFunction)(
                _pEcb->ConnID,
                HSE_REQ_DONE_WITH_SESSION,
                &status,
                NULL,
                NULL);
    }

    return hr;
}

/**
 * Out-of-process request processing - use process model
 */
HRESULT
HttpCompletion::ProcessRequestViaProcessModel()
{
    HRESULT hr;
    
    hr = AssignRequestUsingXSPProcessModel(_pEcb);

    if (hr)
    {
        ON_ERROR_CONTINUE();
        ReportHttpError(_pEcb, IDS_FAILED_PROC_MODEL, FALSE, TRUE, 10);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
InitializeManagedCode()
{
    return HttpCompletion::InitManagedCode();
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
UnInitializeManagedCode()
{
    return HttpCompletion::UninitManagedCode();
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
GetAppDomainIndirect(char * appId, char *appPath, IUnknown ** ppRuntime)
{
    return GetAppDomain(appId, appPath, ppRuntime, NULL, 0);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
DisposeAppDomainsIndirect()
{
    return HttpCompletion::DisposeAppDomains();
}

/////////////////////////////////////////////////////////////////////////////

void
ReportHttpErrorIndirect(
    EXTENSION_CONTROL_BLOCK * iECB,
    UINT    errorResCode)
{
    HttpCompletion::ReportHttpError(iECB, errorResCode, FALSE, FALSE, 0);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT // From CorUtil
IsManagedDebuggerConnected();

HRESULT
IsManagedDebuggerConnectedIndirect()
{
	return IsManagedDebuggerConnected();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\names.cxx ===
/**
 * names
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */


#include "precomp.h"
#include "_ndll.h"
#include "windows.h"
#include "cultures.h"
#include "search.h"

WCHAR Names::s_wszInstallDirectory[MAX_PATH];
WCHAR Names::s_wszClrInstallDirectory[MAX_PATH];
WCHAR Names::s_wszGlobalConfigDirectory[MAX_PATH];
char  Names::s_szGlobalConfigFullPath[MAX_PATH];
WCHAR Names::s_wszGlobalConfigFullPath[MAX_PATH];
WCHAR Names::s_wszGlobalConfigShortFileName[SHORT_FILENAME_SIZE];
WCHAR Names::s_wszExeFileName[MAX_PATH];
WCHAR Names::s_wszExeFullPath[MAX_PATH];
WCHAR Names::s_wszIsapiFullPath[MAX_PATH];
WCHAR Names::s_wszFilterFullPath[MAX_PATH];
WCHAR Names::s_wszRcFullPath[MAX_PATH];
WCHAR Names::s_wszWebFullPath[MAX_PATH];
WCHAR Names::s_wszClientScriptSrcDir[MAX_PATH];
LANGID Names::s_langid;
    
HRESULT Names::GetInterestingFileNames() {
    HRESULT hr = S_OK;
    int     rc;
    WCHAR * pwsz;
    WCHAR * cultureName = NULL;
    WCHAR * cultureNeutralName = NULL;

    rc = GetModuleFileName(NULL, s_wszExeFullPath, ARRAY_SIZE(s_wszExeFullPath));
    ON_ZERO_EXIT_WITH_LAST_ERROR(rc);

    pwsz = wcsrchr(s_wszExeFullPath, PATH_SEPARATOR_CHAR_L);
    if (pwsz == NULL) {
        EXIT_WITH_HRESULT(E_UNEXPECTED);
    }

    StringCchCopyToArrayW(s_wszExeFileName, pwsz + 1);

    rc = GetModuleFileName(g_DllInstance, s_wszIsapiFullPath, ARRAY_SIZE(s_wszIsapiFullPath));
    ON_ZERO_EXIT_WITH_LAST_ERROR(rc);

    StringCchCopyToArrayW(s_wszInstallDirectory, s_wszIsapiFullPath);
    pwsz = wcsrchr(s_wszInstallDirectory, PATH_SEPARATOR_CHAR_L);
    if (pwsz == NULL) {
        EXIT_WITH_HRESULT(E_UNEXPECTED);
    }

    *pwsz = L'\0';

    StringCchCopyToArrayW(s_wszWebFullPath, s_wszInstallDirectory);
    StringCchCatToArrayW(s_wszWebFullPath, PATH_SEPARATOR_STR_L);
    StringCchCatToArrayW(s_wszWebFullPath, WEB_MODULE_FULL_NAME_L);

    if (GetRuntimeDirectory(s_wszClrInstallDirectory, MAX_PATH) == S_OK) {
        StringCchCopyToArrayW(s_wszGlobalConfigDirectory, s_wszClrInstallDirectory);
        StringCchCatToArrayW(s_wszGlobalConfigDirectory, PATH_SEPARATOR_STR_L);
        StringCchCatToArrayW(s_wszGlobalConfigDirectory, WSZ_WEB_CONFIG_SUBDIR);
        TRACE1(L"NAMES", L"Config directory (under CLR) is %s", s_wszGlobalConfigDirectory);
    }
    else {
        StringCchCopyToArrayW(s_wszGlobalConfigDirectory, s_wszInstallDirectory);
        StringCchCatToArrayW(s_wszGlobalConfigDirectory, PATH_SEPARATOR_STR_L);
        StringCchCatToArrayW(s_wszGlobalConfigDirectory, WSZ_WEB_CONFIG_SUBDIR);
        TRACE1(L"NAMES", L"Config directory (under ASP.NET) is %s", s_wszGlobalConfigDirectory);
    }

    rc = WideCharToMultiByte(CP_ACP, 0, s_wszGlobalConfigDirectory, -1, 
        s_szGlobalConfigFullPath, ARRAY_SIZE(s_szGlobalConfigFullPath), NULL, NULL);

    ON_ZERO_EXIT_WITH_LAST_ERROR(rc);
    StringCchCatToArrayA(s_szGlobalConfigFullPath, PATH_SEPARATOR_STR);
    StringCchCatToArrayA(s_szGlobalConfigFullPath, SZ_WEB_CONFIG_FILE);

    WIN32_FIND_DATA wfd;
    HANDLE          hFindFile;
    WCHAR           globalConfigFullPath[MAX_PATH];

    StringCchCopyToArrayW(globalConfigFullPath, s_wszGlobalConfigDirectory);
    StringCchCatToArrayW(globalConfigFullPath, PATH_SEPARATOR_STR_L);
    StringCchCatToArrayW(globalConfigFullPath, WSZ_WEB_CONFIG_FILE);
    StringCchCopyToArrayW(s_wszGlobalConfigFullPath, globalConfigFullPath);

    hFindFile = FindFirstFile(globalConfigFullPath, &wfd);
    if (hFindFile != INVALID_HANDLE_VALUE) {
        FindClose(hFindFile);
        StringCchCopyToArrayW(s_wszGlobalConfigShortFileName, wfd.cAlternateFileName);
    }

    TRACE1(L"NAMES", L"GlobalConfigDirectory=%s", s_wszGlobalConfigDirectory);
    TRACE1(L"NAMES", L"GlobalConfigFullPath=%s", DupStrW(s_szGlobalConfigFullPath));
    TRACE1(L"NAMES", L"GlobalConfigShortFileName=%s", s_wszGlobalConfigShortFileName);

    // get the system language and load the resource dll. 
    // Note: No need to free the cultureName and cultureNeutralName strings, 
    //       since they're only pointers into a static string table
    s_langid = GetSystemDefaultUILanguage();
    hr = ConvertLangIdToLanguageName(s_langid, &cultureName, &cultureNeutralName);
    ON_ERROR_CONTINUE(); hr = S_OK;

    ASSERT(cultureName != NULL);
    ASSERT(cultureNeutralName != NULL);

    // Try the culture specific name       
    StringCchCopyToArrayW(s_wszRcFullPath, s_wszInstallDirectory);
    StringCchCatToArrayW(s_wszRcFullPath, PATH_SEPARATOR_STR_L);
    StringCchCatToArrayW(s_wszRcFullPath, cultureName);
    StringCchCatToArrayW(s_wszRcFullPath, PATH_SEPARATOR_STR_L);
    StringCchCatToArrayW(s_wszRcFullPath, RC_MODULE_FULL_NAME_L);

    g_rcDllInstance= LoadLibraryExW(s_wszRcFullPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (g_rcDllInstance == NULL) {
        // Couldn't get the culture specific name, try with culture neutral name
        StringCchCopyToArrayW(s_wszRcFullPath, s_wszInstallDirectory);
        StringCchCatToArrayW(s_wszRcFullPath, PATH_SEPARATOR_STR_L);
        StringCchCatToArrayW(s_wszRcFullPath, cultureNeutralName);
        StringCchCatToArrayW(s_wszRcFullPath, PATH_SEPARATOR_STR_L);
        StringCchCatToArrayW(s_wszRcFullPath, RC_MODULE_FULL_NAME_L);

        g_rcDllInstance= LoadLibraryExW(s_wszRcFullPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (g_rcDllInstance == NULL) {
            // Couldn't get the localized version at all, so try again with the default
            StringCchCopyToArrayW(s_wszRcFullPath, s_wszInstallDirectory);
            StringCchCatToArrayW(s_wszRcFullPath, PATH_SEPARATOR_STR_L);
            StringCchCatToArrayW(s_wszRcFullPath, RC_MODULE_FULL_NAME_L);
            g_rcDllInstance = LoadLibraryExW(s_wszRcFullPath, NULL, LOAD_LIBRARY_AS_DATAFILE);

            ON_ZERO_EXIT_WITH_LAST_ERROR(g_rcDllInstance);
        }
    }

    StringCchCopyToArrayW(s_wszClientScriptSrcDir, s_wszInstallDirectory);
    StringCchCatToArrayW(s_wszClientScriptSrcDir, PATH_SEPARATOR_STR_L);
    StringCchCatToArrayW(s_wszClientScriptSrcDir, ASPNET_CLIENT_SCRIPT_SRC_DIR_L);

    StringCchCopyToArrayW(s_wszFilterFullPath, s_wszInstallDirectory);
    StringCchCatToArrayW(s_wszFilterFullPath, PATH_SEPARATOR_STR_L);
    StringCchCatToArrayW(s_wszFilterFullPath, FILTER_MODULE_FULL_NAME_L);

    TRACE1(L"TESTING", L"%s", ASPNET_CONFIG_FILE_L);

Cleanup:
    return hr;
}

int __cdecl compare(int *arg1, int *arg2)
{
    if (*arg1 == *arg2)
        return 0;
    if (*arg1 >  *arg2)
        return 1;
    return -1;
}

//
// Note: Do NOT free the wcsCultureName and wcsCultureNeutralName strings returned from this
//       method, since it only returns string pointers from a static table.
//
HRESULT Names::ConvertLangIdToLanguageName(LANGID id, WCHAR** wcsCultureName, WCHAR** wcsCultureNeutralName) 
{
    HRESULT hr = S_OK;
    int intid = (int) id;
    
    int *index = (int*) bsearch(&intid, knownLangIds, sizeof(knownLangIds) / sizeof(knownLangIds[0]), 
                                sizeof(int), (int (__cdecl *)(const void*, const void*))compare);
    ON_ZERO_EXIT_WITH_HRESULT(index, E_INVALIDARG);

    *wcsCultureName = cultureNames[(int) (index-knownLangIds)];
    *wcsCultureNeutralName = cultureNeutralNames[(int) (index-knownLangIds)];

Cleanup:
    if (hr != S_OK) {
        *wcsCultureName = L"en-US";
        *wcsCultureNeutralName = L"en";
    }
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
LPCWSTR
GetGlobalConfigFullPathW()
{
    return Names::GlobalConfigFullPathW();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\makefile.inc ===
SELFREGSRC=$(XSPBASEDIR)\isapi\selfreg.src

$(O)\selfreg.inf : $(SELFREGSRC) ..\..\inc\names.h
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $(SELFREGSRC)
<<$(KEEPFILES)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$(SELFREGSRC) > $@
$(CPPXX: =
)
<<$(KEEPFILES)

$(O)\xspisapi.res : ..\xspisapi.rc $(O)\selfreg.inf ..\xsp.ico

$(O)\isapi.def : ..\isapi.src ..\..\inc\names.h

$(URTTARGET)\$(ASPNET_PRODUCT)\mscoree.dll $(URTTARGET)\$(ASPNET_PRODUCT)\msvcr70.dll : $(URTTARGET)\$(@F)
    $(ECHO_PROCESSING_CMD) $@
    if not exist $(@D) md $(@D)
    if exist $@.tmp del $@.tmp
    if exist $@ ren $@ $(@F).tmp
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\passport.cxx ===
/**
 * Passport Auth Native code
 * 
 * Copyright (c) 2000 Microsoft Corporation
 */

#include "precomp.h"
#include "util.H"
#include "dbg.h"

#import "bin\\x86\\msppmgr.dll" named_guids raw_interfaces_only no_namespace

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// Prototypes for functions defined here
extern "C"
{
    HRESULT            __stdcall   PassportVersion();

    HRESULT __stdcall  PassportCreate(
            LPCWSTR      szQueryStrT, 
            LPCWSTR      szQueryStrP,
            LPCWSTR      szAuthCookie,
            LPCWSTR      szProfCookie,
            LPCWSTR      szProfCCookie,
            LPWSTR       szAuthCookieRet,
            LPWSTR       szProfCookieRet,
            int          iRetBufSize,
            IPassportManager ** pManager);

    HRESULT __stdcall   PassportCreateHttpRaw(
            LPCWSTR      szRequestLine, 
            LPCWSTR      szHeaders,
            BOOL         fSecure,
            LPWSTR       szBufOut,
            DWORD        dwRetBufSize,
            IPassportManager ** pManager);

    HRESULT __stdcall   PassportAuthURL(
            IPassportManager * pManager,
            LPCWSTR     szReturnURL,
            int         iTimeWindow,
            BOOL        fForceLogin,
            LPCWSTR     szCOBrandArgs,
            int         iLangID,
            LPCWSTR     strNameSpace,
            int         iKPP,
            int         iUseSecureAuth,
            LPWSTR      szAuthVal,
            int         iAuthValSize);

    HRESULT __stdcall   PassportAuthURL2(
            IPassportManager * pManager,
            LPCWSTR     szReturnURL,
            int         iTimeWindow,
            BOOL        fForceLogin,
            LPCWSTR     szCOBrandArgs,
            int         iLangID,
            LPCWSTR     strNameSpace,
            int         iKPP,
            int         iUseSecureAuth,
            LPWSTR      szAuthVal,
            int         iAuthValSize);

    HRESULT __stdcall   PassportCommit(
            IPassportManager * pManager,
            LPWSTR      szAuthVal,
            int         iAuthValSize);

    
    HRESULT __stdcall   PassportGetError(
            IPassportManager * pManager);
    
    HRESULT __stdcall   PassportDomainFromMemberName (
            IPassportManager * pManager,
            LPCWSTR     szDomain, 
            LPWSTR      szMember,
            int         iMemberSize);

    HRESULT __stdcall   PassportGetFromNetworkServer(
            IPassportManager * pManager);

    
    HRESULT __stdcall   PassportGetDomainAttribute(
            IPassportManager * pManager,
            LPCWSTR     szAttributeName,
            int         iLCID,	
            LPCWSTR     szDomain,
            LPWSTR      szValue,
            int         iValueSize);

    HRESULT __stdcall   PassportHasProfile(
            IPassportManager * pManager,
            LPCWSTR     szProfile);

    HRESULT __stdcall   PassportGetHasSavedPassword(
            IPassportManager * pManager);

    
    HRESULT __stdcall   PassportHasTicket(
            IPassportManager * pManager);

    HRESULT __stdcall   PassportHasConsent(
            IPassportManager * pManager, 
            int                iFullConsent,
            int                iNeedBirthdate);

    HRESULT __stdcall   PassportIsAuthenticated(
            IPassportManager * pManager,
            int         iTimeWindow,
            BOOL        fForceLogin,
            BOOL        fUseSecureAuth);
    

    HRESULT __stdcall   PassportLogoTag(
            IPassportManager * pManager,
            LPCWSTR     szRetURL,
            int         iTimeWindow,
            BOOL        fForceLogin,
            LPCWSTR     szCOBrandArgs,
            int         iLangID,
            BOOL        fSecure,
            LPCWSTR     strNameSpace,
            int         iKPP,
            int         iUseSecureAuth,
            LPWSTR      szValue,
            int         iValueSize);


    HRESULT __stdcall   PassportLogoTag2(
            IPassportManager * pManager,
            LPCWSTR     szRetURL,
            int         iTimeWindow,
            BOOL        fForceLogin,
            LPCWSTR     szCOBrandArgs,
            int         iLangID,
            BOOL        fSecure,
            LPCWSTR     strNameSpace,
            int         iKPP,
            int         iUseSecureAuth,
            LPWSTR      szValue,
            int         iValueSize);


    HRESULT __stdcall   PassportGetProfile(
            IPassportManager * pManager,
            LPCWSTR     szProfile,
            VARIANT *   pReturn);

    HRESULT __stdcall   PassportHasFlag(
            IPassportManager * pManager,
            int                iFlagMask);


    HRESULT __stdcall   PassportPutProfile(
            IPassportManager * pManager,
            LPCWSTR     szProfile,
            VARIANT     vPut);


    HRESULT __stdcall   PassportGetProfileString(
            IPassportManager * pManager,
            LPCWSTR     szProfile,
            LPWSTR      szValue,
            int         iSize);

    HRESULT __stdcall   PassportPutProfileString(
            IPassportManager * pManager,
            LPCWSTR     szProfile,
            LPCWSTR     szValue);

    int     __stdcall   PassportGetTicketAge(
            IPassportManager * pManager);

    int     __stdcall   PassportGetTimeSinceSignIn(
            IPassportManager * pManager);
    
    void    __stdcall   PassportDestroy(
            IPassportManager * pManager);    

    HRESULT __stdcall   PassportTicket(
            IPassportManager * pManager,
            LPCWSTR     szAttr,
            VARIANT *   pReturn);
    
    HRESULT __stdcall   PassportGetCurrentConfig(
            IPassportManager * pManager,
            LPCWSTR     szAttr,
            VARIANT *   pReturn);
    

    HRESULT __stdcall   PassportGetLoginChallenge(
            IPassportManager * pManager,
            LPCWSTR     szRetURL,
            int         iTimeWindow,
            BOOL        fForceLogin,
            LPCWSTR     szCOBrandArgs,
            int         iLangID,
            LPCWSTR     strNameSpace,
            int         iKPP,
            int         iUseSecureAuth,
            VARIANT     vExtraParams,
            LPWSTR      szOut,
            int         iOutSize);
    
    HRESULT __stdcall   PassportHexPUID(
            IPassportManager * pManager,
            LPWSTR      szOut,
            int         iOutSize);
                                                      
    HRESULT  __stdcall   PassportContinueStartPageHTTPRaw(
            IPassportManager * pManager,
            LPBYTE             bufBody,
            int                iBodyLen,
            LPWSTR             szHeaders,
            int                iHeadersLen,
            LPBYTE             bufContent,
            LPDWORD            pdwContentLen);

    HRESULT __stdcall   PassportLogoutURL(
            IPassportManager * pManager,
            LPCWSTR     szReturnURL,
            LPCWSTR     szCOBrandArgs,
            int         iLangID,
            LPCWSTR     strDomain,
            int         iUseSecureAuth,
            LPWSTR      szAuthVal,
            int         iAuthValSize);
    
    HRESULT __stdcall   PassportGetOption(
            IPassportManager * pManager,
            LPCWSTR     szOption,
            VARIANT *   vOut);

    HRESULT __stdcall   PassportSetOption(
            IPassportManager * pManager,
            LPCWSTR     szOption,
            VARIANT     vOut);

    HRESULT __stdcall   PassportEncrypt(
            LPCWSTR     szSrc,
            LPWSTR      szDest,
            int         iDestLength);

    HRESULT __stdcall   PassportDecrypt(
            LPCWSTR     szSrc,
            LPWSTR      szDest,
            int         iDestLength);

}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
void
SetVariantString(
        VARIANT & vOut,
        LPCWSTR   szStr)
{
    VariantInit(&vOut);
    if (szStr != NULL)
    {
        V_BSTR(&vOut)  = SysAllocString(szStr);
        V_VT(&vOut)    = VT_BSTR;    
    }
    else
    {
        V_VT(&vOut)    = VT_ERROR;
        vOut.scode     = DISP_E_PARAMNOTFOUND;
    }
}

void
SetVariantInt(
        VARIANT & vOut,
        int       iVal)
{
    VariantInit(&vOut);
    if (iVal >= 0)
    {
        V_I4(&vOut) = iVal;
        V_VT(&vOut) = VT_I4;
    }
    else
    {
        V_VT(&vOut)    = VT_ERROR;
        vOut.scode     = DISP_E_PARAMNOTFOUND;
    }
}

void
SetVariantBool(
        VARIANT & vOut,
        BOOL      fVal)
{
    VariantInit(&vOut);
    if (fVal >= 0)
    {
        V_BOOL(&vOut)= (fVal ? VARIANT_TRUE : VARIANT_FALSE);
        V_VT(&vOut)  = VT_BOOL;
    }
    else
    {
        V_VT(&vOut)    = VT_ERROR;
        vOut.scode     = DISP_E_PARAMNOTFOUND;
    }
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

char *
DupeInAnsi(LPCWSTR szStr)
{
    char *   szRet  = NULL;
    HRESULT  hr     = S_OK;

    DWORD dwLen = WideCharToMultiByte(CP_ACP, 0, szStr, -1, NULL, 0, NULL, NULL);
    ON_ZERO_EXIT_WITH_LAST_ERROR(dwLen);

    szRet = new (NewClear) char[dwLen + 1];
    ON_OOM_EXIT(szRet);

    dwLen = WideCharToMultiByte(CP_ACP, 0, szStr, -1, szRet, dwLen, NULL, NULL);        
    ON_ZERO_EXIT_WITH_LAST_ERROR(dwLen);

 Cleanup:
    if (hr != S_OK)
    {
        delete [] szRet;
        return NULL;
    }

    return szRet;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Globals
IPassportFactory * g_pPassportFactory  = NULL;  
LONG               g_lCreatingFactory  = 0;
IPassportCrypt   * g_pPassportCrypt    = NULL;  
LONG               g_lCreatingCrypt    = 0;
CRITICAL_SECTION   g_oCryptCritSec;
HRESULT            g_hrPassportVersion  = S_OK;

/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

IPassportFactory * 
GetPassportFactory()
{
    if (g_pPassportFactory != NULL)
        return g_pPassportFactory;

    HRESULT  hr = S_OK;

    if (g_lCreatingFactory == 0 && InterlockedIncrement(&g_lCreatingFactory) == 1 && g_pPassportFactory == NULL)
    {
        hr = CoCreateInstance(CLSID_PassportFactory, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_IPassportFactory, 
                              (void**) &g_pPassportFactory);
        
        g_lCreatingFactory = 10000;
        ON_ERROR_EXIT();
    }
    else
    {
        for(int iter=0; iter<600 && g_lCreatingFactory != 10000 && g_pPassportFactory == NULL; iter++) // Wait 1 minute at most
            Sleep(100);

        if (iter==600)
        {
            EXIT_WITH_WIN32_ERROR(ERROR_TIMEOUT);
        }
    }

 Cleanup:
    return g_pPassportFactory;
}

/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportVersion ()
{
    if (g_hrPassportVersion != S_OK)
        return g_hrPassportVersion;

    IPassportFactory *   pFactory = NULL;
    IPassportManager *   pManager = NULL;
    IDispatch        *   pDisp    = NULL;
    HRESULT              hr       = S_OK;
    BOOL                 fCoUnint = FALSE;
    
    EnsureCoInitialized(&fCoUnint);
    pFactory = GetPassportFactory();
    if (pFactory == NULL)
        EXIT_WITH_HRESULT(E_FAIL);

    hr = pFactory->CreatePassportManager(&pDisp);
    ON_ERROR_EXIT();
    if (pDisp == NULL)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    hr = pDisp->QueryInterface(IID_IPassportManager3, (void **) &pManager);
    if (hr == S_OK)
    {
        g_hrPassportVersion = 3;
        EXIT();
    }
    hr = pDisp->QueryInterface(IID_IPassportManager2, (void **) &pManager);
    if (hr == S_OK)
    {
        g_hrPassportVersion = 2;
        EXIT();
    }
    hr = pDisp->QueryInterface(IID_IPassportManager, (void **) &pManager);
    if (hr == S_OK)
    {
        g_hrPassportVersion = 1;
        EXIT();
    }

 Cleanup:
    ReleaseInterface(pManager);
    ReleaseInterface(pDisp);

    if (hr != S_OK)
        g_hrPassportVersion = hr;
    return g_hrPassportVersion;
}

/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

IPassportCrypt * 
GetPassportCryptInterface()
{
    if (g_pPassportCrypt != NULL)
        return g_pPassportCrypt;

    HRESULT  hr = S_OK;

    if (g_lCreatingCrypt == 0 && InterlockedIncrement(&g_lCreatingCrypt) == 1 && g_pPassportCrypt == NULL)
    {
        hr = CoCreateInstance(CLSID_Crypt, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_IPassportCrypt, 
                              (void**) &g_pPassportCrypt);
        
        InitializeCriticalSection(&g_oCryptCritSec);
        g_lCreatingCrypt = 10000;
        ON_ERROR_EXIT();
    }
    else
    {
        for(int iter=0; iter<600 && g_lCreatingCrypt != 10000 && g_pPassportCrypt == NULL; iter++) // Wait 1 minute at most
            Sleep(100);

        if (iter==600)
        {
            EXIT_WITH_WIN32_ERROR(ERROR_TIMEOUT);
        }
    }

 Cleanup:
    return g_pPassportCrypt;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportCreate (
        LPCWSTR     szQueryStrT, 
        LPCWSTR     szQueryStrP,
        LPCWSTR     szAuthCookie,
        LPCWSTR     szProfCookie,
        LPCWSTR     szProfCCookie,
        LPWSTR      szAuthCookieRet,
        LPWSTR      szProfCookieRet,
        int         iRetBufSize,
        IPassportManager ** ppManager)
{
    IPassportFactory * pFactory = NULL;
    IDispatch        * pDisp    = NULL;
    HRESULT            hr       = S_OK;
    BOOL               fCoUnint = FALSE;
    BSTR               szBstrQT = NULL;
    BSTR               szBstrQP = NULL;
    BSTR               szBstrAC = NULL;
    BSTR               szBstrPC = NULL;
    BSTR               szBstrPCC= NULL;
    VARIANT            vReturn;
    VARIANT            vSec;

    VariantInit(&vReturn);
    VariantInit(&vSec);

    vSec.vt     = VT_ERROR;
    vSec.scode  = DISP_E_PARAMNOTFOUND;

    EnsureCoInitialized(&fCoUnint);

    pFactory = GetPassportFactory();
    if (pFactory == NULL)
    {
        EXIT_WITH_HRESULT(E_FAIL);
    }

    hr = pFactory->CreatePassportManager(&pDisp);
    ON_ERROR_EXIT();

    hr = (pDisp ? pDisp->QueryInterface(IID_IPassportManager, (void **) ppManager) : E_FAIL);
    ON_ERROR_EXIT();
    
    if ((*ppManager) == NULL)
    {
        EXIT_WITH_HRESULT(E_FAIL);
    }

    if (szProfCCookie == NULL)
        szProfCCookie = L"";

    szBstrQT = SysAllocString(szQueryStrT);
    szBstrQP = SysAllocString(szQueryStrP);
    szBstrAC = SysAllocString(szAuthCookie);
    szBstrPC = SysAllocString(szProfCookie);
    szBstrPCC= SysAllocString(szProfCCookie);
    if ((szBstrQT == NULL && szQueryStrT  != NULL && szQueryStrT [0] != NULL) ||
        (szBstrQP == NULL && szQueryStrP  != NULL && szQueryStrP [0] != NULL) ||
        (szBstrAC == NULL && szAuthCookie != NULL && szAuthCookie[0] != NULL) ||
        (szBstrPC == NULL && szProfCookie != NULL && szProfCookie[0] != NULL) ||
        (szBstrPCC== NULL && szProfCCookie!= NULL && szProfCCookie[0]!= NULL)  )        
    {
        EXIT_WITH_HRESULT(E_OUTOFMEMORY);
    }
    
    
    hr = (*ppManager)->OnStartPageManual(szBstrQT, szBstrQP, szBstrAC, szBstrPC, szBstrPCC, vSec, &vReturn);
    ON_ERROR_EXIT();
    
    if (szAuthCookieRet != NULL && iRetBufSize > 0)
        szAuthCookieRet[0] = NULL;

    if (szProfCookieRet != NULL && iRetBufSize > 0)
        szProfCookieRet[0] = NULL;

    if (vReturn.vt == (VT_ARRAY | VT_VARIANT))
    {
        VARIANT  vtValue;
        LONG     lBound = 0;

        VariantInit(&vtValue);

        if (szAuthCookieRet != NULL && iRetBufSize > 0)
        {
            hr = SafeArrayGetElement(V_ARRAY(&vReturn), &lBound, &vtValue);
            if (hr == S_OK && vtValue.vt == VT_BSTR && vtValue.bstrVal != NULL)
            {
                WCHAR * szCopy = wcsstr(vtValue.bstrVal, L"MSPAuth");
                if (szCopy == NULL)
                {
                    szCopy = vtValue.bstrVal;
                }

                int iLen = lstrlenW(szCopy);
                
                if (iLen < iRetBufSize)
                {
		  StringCchCopyW(szAuthCookieRet, iRetBufSize, szCopy);
		  if (szAuthCookieRet[iLen-2] == L'\r' && szAuthCookieRet[iLen-1] == L'\n')
		    szAuthCookieRet[iLen-2] = NULL;

                }
            }
              
            VariantClear(&vtValue);
        }

        if (szProfCookieRet != NULL && iRetBufSize > 0)
        {
            lBound = 1;

            VariantInit(&vtValue);
            hr = SafeArrayGetElement(V_ARRAY(&vReturn), &lBound, &vtValue);
            if (hr == S_OK && vtValue.vt == VT_BSTR && vtValue.bstrVal != NULL)
            {
                WCHAR * szCopy = wcsstr(vtValue.bstrVal, L"MSPProf");
                if (szCopy == NULL)
                {
                    szCopy = vtValue.bstrVal;
                }

                int iLen = lstrlenW(szCopy);
                
                if (iLen < iRetBufSize)
                {
		  StringCchCopyW(szProfCookieRet, iRetBufSize, szCopy);
		  if (szProfCookieRet[iLen-2] == '\r' && szProfCookieRet[iLen-1] == '\n')
		    szProfCookieRet[iLen-2] = NULL;
                }
            }
            VariantClear(&vtValue);
        }
    }

    hr = S_OK;

 Cleanup:
    if (hr != S_OK && (*ppManager) != NULL)
    {
        (*ppManager)->Release();
        (*ppManager) = NULL;
    }

    if (pDisp != NULL)
        pDisp->Release();

    VariantClear(&vReturn);
    SysFreeString(szBstrQT);
    SysFreeString(szBstrQP);
    SysFreeString(szBstrAC);
    SysFreeString(szBstrPC);
    SysFreeString(szBstrPCC);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportCreateHttpRaw(
        LPCWSTR      szRequestLine, 
        LPCWSTR      szHeaders,
        BOOL         fSecure,
        LPWSTR       szBufOut,
        DWORD        dwRetBufSize,
        IPassportManager ** ppManager)
{
    IPassportFactory  * pFactory = NULL;
    IDispatch         * pDisp    = NULL;
    HRESULT             hr       = S_OK;
    BOOL                fCoUnint = FALSE;
    char *              szR      = DupeInAnsi(szRequestLine);
    char *              szH      = DupeInAnsi(szHeaders);
    DWORD               dwSize   = 4000;
    char                szOut[4000] = "";
    IPassportManager3 * pManager3 = NULL;
    BOOL                fCallContinue = FALSE;

    EnsureCoInitialized(&fCoUnint);

    ON_OOM_EXIT(szR);
    ON_OOM_EXIT(szH);

    pFactory = GetPassportFactory();
    if (pFactory == NULL)
    {
        EXIT_WITH_HRESULT(E_FAIL);
    }

    hr = pFactory->CreatePassportManager(&pDisp);
    ON_ERROR_EXIT();
    if (pDisp == NULL)
        EXIT_WITH_HRESULT(E_UNEXPECTED);
      

    hr = pDisp->QueryInterface(IID_IPassportManager3, (void **) &pManager3);
    ON_ERROR_EXIT();
    
    if (pManager3 == NULL)
        EXIT_WITH_HRESULT(E_FAIL);

    hr = pManager3->OnStartPageHTTPRaw(szR, szH, fSecure, &dwSize, szOut);
    if (hr == 0x80040207) // Continue needs to be called
    {
        fCallContinue = TRUE;
        hr = S_OK;
    }
    ON_ERROR_EXIT();

    hr = pManager3->QueryInterface(IID_IPassportManager, (void **) ppManager);
    ON_ERROR_EXIT();

    if (szOut[0] != NULL)
    {
        DWORD dwLen = MultiByteToWideChar(CP_ACP, 0, szOut, -1, NULL, 0);
        ON_ZERO_EXIT_WITH_LAST_ERROR(dwLen);
        if (dwLen > dwRetBufSize)
        {
            EXIT_WITH_HRESULT(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
        }
        dwLen = MultiByteToWideChar(CP_ACP, 0, szOut, -1, szBufOut, dwRetBufSize);
        ON_ZERO_EXIT_WITH_LAST_ERROR(dwLen);
    }

 Cleanup:
    if (hr != S_OK && (*ppManager) != NULL)
    {
        (*ppManager)->Release();
        (*ppManager) = NULL;
    }

    ReleaseInterface(pManager3);
    if (pDisp != NULL)
        pDisp->Release();

    delete [] szR;
    delete [] szH;

    return ((fCallContinue && hr == S_OK) ? 0x80040207 : hr);
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


HRESULT 
__stdcall
PassportFunction(
        int         iFunctionID,
        IPassportManager * pManager,
        LPCWSTR     szRetURL,
        int         iTimeWindow,
        BOOL        fForceLogin,
        LPCWSTR     szCOBrandArgs,
        int         iLangID,
        BOOL        fSecure,
        LPCWSTR     strNameSpace,
        int         iKPP,
        int         iUseSecureAuth,
        LPWSTR      szValue,
        int         iValueSize)
{
    if (pManager == NULL)
        return E_FAIL;
    
    HRESULT            hr       = S_OK;
    BSTR               bstrRet  = NULL;
    VARIANT            vUrl;
    VARIANT            vTime;
    VARIANT            vLogin;
    VARIANT            vCoArgs;
    VARIANT            vLangID;
    VARIANT            vNamespace;
    VARIANT            vKPP;
    VARIANT            vUseSecure;
    VARIANT            vSecure;
    IPassportManager2 * pManager2 = NULL;

    SetVariantString  (vUrl, szRetURL);
    SetVariantInt     (vTime, iTimeWindow);
    SetVariantBool    (vLogin, fForceLogin);
    SetVariantString  (vCoArgs, szCOBrandArgs);
    SetVariantInt     (vLangID, iLangID);
    SetVariantString  (vNamespace, strNameSpace);
    SetVariantInt     (vKPP, iKPP);
    SetVariantBool    (vUseSecure, iUseSecureAuth);
    SetVariantBool    (vSecure, fSecure);

    if (iFunctionID == 2 || iFunctionID == 4)
    {
        hr = pManager->QueryInterface(IID_IPassportManager2, (void **) &pManager2);
        ON_ERROR_EXIT();
    }
                
    if (g_hrPassportVersion >= 3)
        SetVariantInt(vUseSecure, iUseSecureAuth);        


    switch(iFunctionID)
    {
    case 1:
        hr = pManager->LogoTag(vUrl, vTime, vLogin, vCoArgs, vLangID, vSecure, vNamespace, vKPP, vUseSecure, &bstrRet);
        break;
    case 2:
        hr = pManager2->LogoTag2(vUrl, vTime, vLogin, vCoArgs, vLangID, vSecure, vNamespace, vKPP, vUseSecure, &bstrRet);
        break;
    case 3:
        hr = pManager->AuthURL(vUrl, vTime, vLogin, vCoArgs, vLangID, vNamespace, vKPP, vUseSecure, &bstrRet);
        break;
    case 4:
        hr = pManager2->AuthURL2(vUrl, vTime, vLogin, vCoArgs, vLangID, vNamespace, vKPP, vUseSecure, &bstrRet);
        break;
    default:
        hr = E_UNEXPECTED;
    }

    ON_ERROR_EXIT();

    if (bstrRet != NULL)
    {
        if (szValue == NULL || iValueSize <= lstrlenW(bstrRet))
        {            
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            if (szValue != NULL && iValueSize > 10)
            {
                _itow(lstrlenW(bstrRet) + 1, szValue, 10);                
            }
        }
        else
        {
            StringCchCopy(szValue, iValueSize, bstrRet);
        }
    }

 Cleanup:
    ReleaseInterface(pManager2);
    SysFreeString(bstrRet);
    VariantClear(&vUrl);
    VariantClear(&vTime);
    VariantClear(&vLogin);
    VariantClear(&vCoArgs);
    VariantClear(&vLangID);
    VariantClear(&vSecure);
    VariantClear(&vUseSecure);
    VariantClear(&vKPP);
    VariantClear(&vNamespace);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT 
__stdcall
PassportLogoTag(
        IPassportManager * pManager,
        LPCWSTR     szRetURL,
        int         iTimeWindow,
        BOOL        fForceLogin,
        LPCWSTR     szCOBrandArgs,
        int         iLangID,
        BOOL        fSecure,
        LPCWSTR     strNameSpace,
        int         iKPP,
        int         iUseSecureAuth,
        LPWSTR      szValue,
        int         iValueSize)
{
    return PassportFunction(1,
                            pManager,
                            szRetURL,
                            iTimeWindow,
                            fForceLogin,
                            szCOBrandArgs,
                            iLangID,
                            fSecure,
                            strNameSpace,
                            iKPP,
                            iUseSecureAuth,
                            szValue,
                            iValueSize);
                           
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT 
__stdcall
PassportLogoTag2(
        IPassportManager * pManager,
        LPCWSTR     szRetURL,
        int         iTimeWindow,
        BOOL        fForceLogin,
        LPCWSTR     szCOBrandArgs,
        int         iLangID,
        BOOL        fSecure,
        LPCWSTR     strNameSpace,
        int         iKPP,
        int         iUseSecureAuth,
        LPWSTR      szValue,
        int         iValueSize)
{
    return PassportFunction(2,
                            pManager,
                            szRetURL,
                            iTimeWindow,
                            fForceLogin,
                            szCOBrandArgs,
                            iLangID,
                            fSecure,
                            strNameSpace,
                            iKPP,
                            iUseSecureAuth,
                            szValue,
                            iValueSize);
                           
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportAuthURL  (
        IPassportManager * pManager,
        LPCWSTR     szRetURL,
        int         iTimeWindow,
        BOOL        fForceLogin,
        LPCWSTR     szCOBrandArgs,
        int         iLangID,
        LPCWSTR     strNameSpace,
        int         iKPP,
        int         iUseSecureAuth,
        LPWSTR      szValue,
        int         iValueSize)
{
    return PassportFunction(3,
                            pManager,
                            szRetURL,
                            iTimeWindow,
                            fForceLogin,
                            szCOBrandArgs,
                            iLangID,
                            TRUE,
                            strNameSpace,
                            iKPP,
                            iUseSecureAuth,
                            szValue,
                            iValueSize);
                           
    
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportAuthURL2  (
        IPassportManager * pManager,
        LPCWSTR     szRetURL,
        int         iTimeWindow,
        BOOL        fForceLogin,
        LPCWSTR     szCOBrandArgs,
        int         iLangID,
        LPCWSTR     strNameSpace,
        int         iKPP,
        int         iUseSecureAuth,
        LPWSTR      szValue,
        int         iValueSize)
{
    return PassportFunction(4,
                            pManager,
                            szRetURL,
                            iTimeWindow,
                            fForceLogin,
                            szCOBrandArgs,
                            iLangID,
                            TRUE,
                            strNameSpace,
                            iKPP,
                            iUseSecureAuth,
                            szValue,
                            iValueSize);
                           
    
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportCommit  (
        IPassportManager * pManager,
        LPWSTR      szAuthVal,
        int         iAuthValSize)
{
    if (pManager == NULL)
        return E_FAIL;

    HRESULT            hr       = S_OK;
    BSTR               bstrRet  = NULL;

    hr = pManager->Commit(&bstrRet);
    ON_ERROR_EXIT();

    if (bstrRet != NULL)
    {
        if (szAuthVal == NULL || iAuthValSize <= lstrlenW(bstrRet))
        {            
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            if (szAuthVal != NULL && iAuthValSize > 10)
            {
                _itow(lstrlenW(bstrRet) + 1, szAuthVal, 10);                
            }
        }
        else
        {
            StringCchCopy(szAuthVal, iAuthValSize, bstrRet);
        }
    }

 Cleanup:
    SysFreeString(bstrRet);
    return hr;    
}
 
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportGetError (IPassportManager * pManager)
{
    if (pManager == NULL)
        return E_FAIL;

    HRESULT            hr       = S_OK;
    LONG               lError   = 0;

    hr = pManager->get_Error (&lError);
    if (SUCCEEDED(hr))
        return lError;

    return hr;
}
    
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportDomainFromMemberName (
        IPassportManager * pManager,
        LPCWSTR     szMember, 
        LPWSTR      szDomain,
        int         iDomainSize)
{
    if (pManager == NULL)
        return E_FAIL;

    HRESULT            hr       = S_OK;
    VARIANT            vMember;
    BSTR               bstrRet  = NULL;

    SetVariantString(vMember, szMember);

    hr = pManager->DomainFromMemberName(vMember, &bstrRet);
    ON_ERROR_EXIT();

    if (bstrRet != NULL)
    {
        if (szDomain == NULL || iDomainSize <= lstrlenW(bstrRet))
        {            
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            if (szDomain != NULL && iDomainSize > 10)
            {
                _itow(lstrlenW(bstrRet) + 1, szDomain, 10);                
            }
        }
        else
        {
            StringCchCopy(szDomain, iDomainSize, bstrRet);
        }
    }

 Cleanup:
    SysFreeString(bstrRet);
    VariantClear(&vMember);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportGetFromNetworkServer (
        IPassportManager * pManager)
{
    if (pManager == NULL)
        return E_FAIL;

    HRESULT            hr       = S_OK;
    VARIANT_BOOL       vtBool   = VARIANT_FALSE;

    hr = pManager->get_FromNetworkServer(&vtBool);
    ON_ERROR_EXIT();

 Cleanup:
    if (SUCCEEDED(hr))
        hr = ((vtBool == VARIANT_FALSE) ? S_FALSE : S_OK);
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT 
__stdcall
PassportGetDomainAttribute   (
        IPassportManager * pManager,
        LPCWSTR     szAttributeName,
        int         iLCID,	
        LPCWSTR     szDomain,
        LPWSTR      szValue,
        int         iValueSize)
{
    if (pManager == NULL)
        return E_FAIL;

    HRESULT            hr       = S_OK;
    BSTR               bstrAtt  = SysAllocString(szAttributeName);
    VARIANT            vLCID;
    VARIANT            vDomain;
    BSTR               bstrRet  = NULL;

    SetVariantString(vDomain, szDomain);
    SetVariantInt(vLCID, iLCID);

    hr = pManager->GetDomainAttribute(bstrAtt, vLCID, vDomain, &bstrRet);
    ON_ERROR_EXIT();

    if (bstrRet != NULL)
    {
        if (szValue == NULL || iValueSize <= lstrlenW(bstrRet))
        {            
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            if (szValue != NULL && iValueSize > 10)
            {
                _itow(lstrlenW(bstrRet) + 1, szValue, 10);                
            }
        }
        else
        {
            StringCchCopy(szValue, iValueSize, bstrRet);
        }
    }

 Cleanup:
    SysFreeString(bstrAtt);
    SysFreeString(bstrRet);
    VariantClear(&vLCID);
    VariantClear(&vDomain);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportHasProfile(
        IPassportManager * pManager,
        LPCWSTR     szProfile)
{
    if (pManager == NULL)
        return E_FAIL;

    HRESULT            hr       = S_OK;
    VARIANT_BOOL       vtBool   = VARIANT_FALSE;
    VARIANT            vProfile;

    SetVariantString(vProfile, szProfile);

    hr = pManager->HasProfile(vProfile, &vtBool);
    ON_ERROR_EXIT();

 Cleanup:
    if (SUCCEEDED(hr))
        hr = ((vtBool == VARIANT_FALSE) ? S_FALSE : S_OK);
    VariantClear(&vProfile);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportHasFlag(
        IPassportManager * pManager,
        int iFlag)
{
    if (pManager == NULL)
        return E_FAIL;

    HRESULT            hr       = S_OK;
    VARIANT            vFlag;
    VARIANT_BOOL       vtBool   = VARIANT_FALSE;
    
    SetVariantInt(vFlag, iFlag);
    hr = pManager->HasFlag(vFlag, &vtBool);
    ON_ERROR_EXIT();

 Cleanup:
    if (hr == S_OK && vtBool == VARIANT_FALSE)
        hr = S_FALSE;
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT 
__stdcall
PassportGetHasSavedPassword      (
    IPassportManager * pManager)
{
    if (pManager == NULL)
        return E_FAIL;

    HRESULT            hr       = S_OK;
    VARIANT_BOOL       vtBool   = VARIANT_FALSE;

    hr = pManager->get_HasSavedPassword(&vtBool);
    ON_ERROR_EXIT();

 Cleanup:
    if (hr == S_OK && vtBool == VARIANT_FALSE)
        hr = S_FALSE;
    return hr;
}
    
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
HRESULT
__stdcall
PassportHasTicket (
    IPassportManager * pManager)
{
    if (pManager == NULL)
        return E_FAIL;

    HRESULT            hr       = S_OK;
    VARIANT_BOOL       vtBool   = VARIANT_FALSE;

    hr = pManager->get_HasTicket(&vtBool);
    ON_ERROR_EXIT();

 Cleanup:
    if (hr == S_OK && vtBool == VARIANT_FALSE)
        hr = S_FALSE;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
HRESULT
__stdcall
PassportHasConsent (
    IPassportManager * pManager,
    int                iFullConsent,
    int                iNeedBirthdate)
{
    if (pManager == NULL)
        return E_FAIL;

    HRESULT            hr       = S_OK;
    VARIANT_BOOL       vtBool1  = (iFullConsent ? VARIANT_TRUE : VARIANT_FALSE);
    VARIANT_BOOL       vtBool2  = (iNeedBirthdate ? VARIANT_TRUE : VARIANT_FALSE);
    VARIANT_BOOL       vtBool   = VARIANT_FALSE;

    hr = pManager->HaveConsent(vtBool1, vtBool2, &vtBool);
    ON_ERROR_EXIT();

 Cleanup:
    if (hr == S_OK && vtBool == VARIANT_FALSE)
        hr = S_FALSE;

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT 
__stdcall
PassportIsAuthenticated(
        IPassportManager * pManager,
        int         iTimeWindow,
        BOOL        fForceLogin,
        int         iUseSecureAuth)
{
    if (pManager == NULL)
        return E_FAIL;

    HRESULT            hr       = S_OK;
    VARIANT_BOOL       vtBool   = VARIANT_FALSE;
    VARIANT            vTime;
    VARIANT            vLogin;
    VARIANT            vUseSecure;

    SetVariantBool(vUseSecure, iUseSecureAuth);
    SetVariantInt(vTime, iTimeWindow);
    SetVariantBool(vLogin, fForceLogin);

    if (g_hrPassportVersion >= 3)
        SetVariantInt(vUseSecure, iUseSecureAuth);        

    hr = pManager->IsAuthenticated(vTime, vLogin, vUseSecure, &vtBool);
    ON_ERROR_EXIT();

 Cleanup:
    if (hr == S_OK && vtBool == VARIANT_FALSE)
        hr = S_FALSE;
    VariantClear(&vUseSecure);
    return hr;
}
    
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT 
__stdcall
PassportGetProfile(
        IPassportManager * pManager,
        LPCWSTR   szProfile,
        VARIANT * pReturn)
{
    if (pManager == NULL)
        return E_FAIL;
    
    HRESULT            hr       = S_OK;
    BSTR               bstrP    = SysAllocString(szProfile);

    hr = pManager->get_Profile(bstrP, pReturn);
    ON_ERROR_EXIT();

 Cleanup:
    SysFreeString(bstrP);    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportPutProfile(
        IPassportManager * pManager,
        LPCWSTR   szProfile,
        VARIANT   vPut)
{
    if (pManager == NULL)
        return E_FAIL;

    HRESULT            hr       = S_OK;
    BSTR               bstrP    = SysAllocString(szProfile);

    hr = pManager->put_Profile(bstrP, vPut);
    ON_ERROR_EXIT();

 Cleanup:
    SysFreeString(bstrP);    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

int
__stdcall
PassportGetTicketAge(
    IPassportManager * pManager)

{
    if (pManager == NULL)
        return E_FAIL;

    HRESULT            hr       = S_OK;
    int                iAge     = 0;
    
    hr = pManager->get_TicketAge(&iAge);
    ON_ERROR_EXIT();

 Cleanup:
    if (hr == S_OK)
        hr = iAge;
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

int     
__stdcall
PassportGetTimeSinceSignIn(
    IPassportManager * pManager)

{
    if (pManager == NULL)
        return E_FAIL;

    HRESULT            hr       = S_OK;
    int                iAge     = 0;
    
    hr = pManager->get_TimeSinceSignIn(&iAge);
    ON_ERROR_EXIT();

 Cleanup:
    if (hr == S_OK)
        hr = iAge;
    return hr;
}
    
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void    
__stdcall
PassportDestroy(
    IPassportManager * pManager)
{
    ReleaseInterface(pManager);
}
    
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT 
__stdcall
PassportGetProfileString(
        IPassportManager * pManager,
        LPCWSTR   szProfile,
        LPWSTR    szValue,
        int       iValueSize)
{
    VARIANT   vTemp, vRet;
    HRESULT   hr;

    VariantInit(&vRet);
    VariantInit(&vTemp);

    hr = PassportGetProfile(pManager, szProfile, &vTemp);
    ON_ERROR_EXIT();

    if (vTemp.vt != VT_DATE)
    {
        hr = VariantChangeType(&vRet, &vTemp, 0, VT_BSTR);
        ON_ERROR_EXIT();        
    }
    else
    {
        vRet.vt = VT_BSTR;
        VarBstrFromDate(vTemp.date, 0, LOCALE_NOUSEROVERRIDE, &vRet.bstrVal);
    }

    if (vRet.vt != VT_BSTR)
        EXIT_WITH_HRESULT(hr);

    if (vRet.bstrVal != NULL)
    {
        if (szValue == NULL || iValueSize <= lstrlenW(vRet.bstrVal))
        {            
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            if (szValue != NULL && iValueSize > 10)
            {
                _itow(lstrlenW(vRet.bstrVal) + 1, szValue, 10);                
            }
        }
        else
        {
            StringCchCopy(szValue, iValueSize, vRet.bstrVal);
        }
    }

 Cleanup:
    VariantClear(&vRet);    
    VariantClear(&vTemp);    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportPutProfileString(
        IPassportManager * pManager,
        LPCWSTR   szProfile,
        LPCWSTR   szValue)

{
    VARIANT   vRet;
    HRESULT   hr;

    SetVariantString(vRet, szValue);

    hr = PassportPutProfile(pManager, szProfile, vRet);
    VariantClear(&vRet);    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT __stdcall   PassportTicket(
        IPassportManager * pManager,
        LPCWSTR     szAttr,
        VARIANT *   pReturn)
{
    if (pManager == NULL)
        return E_INVALIDARG;
    if (g_hrPassportVersion < 3)
        return E_NOTIMPL;

    IPassportManager3 * pManager3 = NULL;    
    HRESULT            hr        = S_OK;
    BSTR               bstrP     = SysAllocString(szAttr);

    if (szAttr != NULL && szAttr[0] != NULL)
        ON_OOM_EXIT(bstrP);

    hr = pManager->QueryInterface(IID_IPassportManager3, (void **) &pManager3);
    ON_ERROR_EXIT();
    
    hr = pManager3->get_Ticket(bstrP, pReturn);
    ON_ERROR_EXIT();

 Cleanup:
    ReleaseInterface(pManager3);
    SysFreeString(bstrP);    
    return hr;
}
    
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
HRESULT __stdcall   PassportGetCurrentConfig(
        IPassportManager * pManager,
        LPCWSTR     szAttr,
        VARIANT *   pReturn)
{
    if (pManager == NULL)
        return E_INVALIDARG;
    if (g_hrPassportVersion < 3)
        return E_NOTIMPL;

    IPassportManager3 * pManager3 = NULL;    
    HRESULT            hr        = S_OK;
    BSTR               bstrP     = SysAllocString(szAttr);

    if (szAttr != NULL && szAttr[0] != NULL)
        ON_OOM_EXIT(bstrP);

    hr = pManager->QueryInterface(IID_IPassportManager3, (void **) &pManager3);
    ON_ERROR_EXIT();
    
    hr = pManager3->GetCurrentConfig(bstrP, pReturn);
    ON_ERROR_EXIT();

 Cleanup:
    ReleaseInterface(pManager3);
    SysFreeString(bstrP);    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
HRESULT __stdcall   PassportGetLoginChallenge(
        IPassportManager * pManager,
        LPCWSTR     szRetURL,
        int         iTimeWindow,
        BOOL        fForceLogin,
        LPCWSTR     szCOBrandArgs,
        int         iLangID,
        LPCWSTR     strNameSpace,
        int         iKPP,
        int         iUseSecureAuth,
        VARIANT     vExtraParams,
        LPWSTR      szOut,
        int         iOutSize)
{
    if (pManager == NULL)
        return E_INVALIDARG;
    if (g_hrPassportVersion < 3)
        return E_NOTIMPL;

    IPassportManager3 * pManager3 = NULL;    
    HRESULT            hr        = S_OK;
    VARIANT            vUrl;
    VARIANT            vTime;
    VARIANT            vLogin;
    VARIANT            vCoArgs;
    VARIANT            vLangID;
    VARIANT            vNamespace;
    VARIANT            vKPP;
    VARIANT            vUseSecure;
    BSTR               bOut = NULL;
    VARIANT            vNone;
    VARIANT *          pExtraParams = &vExtraParams;
    
    SetVariantInt     (vNone, -1);
    
    if (V_VT(pExtraParams) == VT_EMPTY)
        pExtraParams = &vNone;

    SetVariantString  (vUrl, szRetURL);
    SetVariantInt     (vTime, iTimeWindow);
    SetVariantBool    (vLogin, fForceLogin);
    SetVariantString  (vCoArgs, szCOBrandArgs);
    SetVariantInt     (vLangID, iLangID);
    SetVariantString  (vNamespace, strNameSpace);
    SetVariantInt     (vKPP, iKPP);
    SetVariantInt     (vUseSecure, iUseSecureAuth);

    hr = pManager->QueryInterface(IID_IPassportManager3, (void **) &pManager3);
    ON_ERROR_EXIT();
    
    hr = pManager3->GetLoginChallenge(vUrl, vTime, vLogin, vCoArgs, vLangID, vNamespace, vKPP, vUseSecure, *pExtraParams, &bOut);
    ON_ERROR_EXIT();

    if (bOut != NULL)
    {
        if (lstrlenW(bOut) < iOutSize)
        {
            StringCchCopy(szOut, iOutSize, bOut);
        }
        else
        {
            EXIT_WITH_WIN32_ERROR(ERROR_INSUFFICIENT_BUFFER);
        }
    }
    else
    {
        if (iOutSize > 0)
            szOut[0] = NULL;
    }
 Cleanup:
    ReleaseInterface(pManager3);
    VariantClear(&vUrl);
    VariantClear(&vTime);
    VariantClear(&vLogin);
    VariantClear(&vCoArgs);
    VariantClear(&vLangID);
    VariantClear(&vUseSecure);
    VariantClear(&vKPP);
    VariantClear(&vNamespace);
    if (bOut != NULL)
        SysFreeString(bOut);
    return hr;    
}
    
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT __stdcall   PassportHexPUID(
        IPassportManager * pManager,
        LPWSTR      szOut,
        int         iOutSize)
{
    if (pManager == NULL)
        return E_INVALIDARG;
    if (g_hrPassportVersion < 3)
        return E_NOTIMPL;

    IPassportManager3 * pManager3 = NULL;    
    HRESULT            hr        = S_OK;
    BSTR               bOut      = NULL;

    hr = pManager->QueryInterface(IID_IPassportManager3, (void **) &pManager3);
    ON_ERROR_EXIT();

    hr = pManager3->get_HexPUID(&bOut);
    ON_ERROR_EXIT();

    if (bOut != NULL)
    {
        if (lstrlenW(bOut) < iOutSize)
        {
            StringCchCopy(szOut, iOutSize, bOut);
        }
        else
        {
            EXIT_WITH_WIN32_ERROR(ERROR_INSUFFICIENT_BUFFER);
        }
    }
    else
    {
        if (iOutSize > 0)
            szOut[0] = NULL;
    }
 Cleanup:
    ReleaseInterface(pManager3);
    if (bOut != NULL)
        SysFreeString(bOut);
    return hr;    
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportLogoutURL(
        IPassportManager * pManager,
        LPCWSTR     szRetURL,
        LPCWSTR     szCOBrandArgs,
        int         iLangID,
        LPCWSTR     strDomain,
        int         iUseSecureAuth,
        LPWSTR      szOut,
        int         iOutSize)
{
    if (pManager == NULL)
        return E_INVALIDARG;
    if (g_hrPassportVersion < 3)
        return E_NOTIMPL;

    IPassportManager3 * pManager3 = NULL;    
    HRESULT            hr        = S_OK;
    VARIANT            vUrl;
    VARIANT            vCoArgs;
    VARIANT            vLangID;
    VARIANT            vNamespace;
    VARIANT            vUseSecure;
    BSTR               bOut = NULL;

    SetVariantString  (vUrl, szRetURL);
    SetVariantString  (vCoArgs, szCOBrandArgs);
    SetVariantInt     (vLangID, iLangID);
    SetVariantString  (vNamespace, strDomain);
    SetVariantInt     (vUseSecure, iUseSecureAuth);

    hr = pManager->QueryInterface(IID_IPassportManager3, (void **) &pManager3);
    ON_ERROR_EXIT();
    
    hr = pManager3->LogoutURL(vUrl, vCoArgs, vLangID, vNamespace, vUseSecure, &bOut);
    ON_ERROR_EXIT();

    if (bOut != NULL)
    {
        if (lstrlenW(bOut) < iOutSize)
        {
            StringCchCopy(szOut, iOutSize, bOut);
        }
        else
        {
            EXIT_WITH_WIN32_ERROR(ERROR_INSUFFICIENT_BUFFER);
        }
    }
    else
    {
        if (iOutSize > 0)
            szOut[0] = NULL;
    }
 Cleanup:
    ReleaseInterface(pManager3);
    VariantClear(&vUrl);
    VariantClear(&vCoArgs);
    VariantClear(&vLangID);
    VariantClear(&vUseSecure);
    VariantClear(&vNamespace);
    if (bOut != NULL)
        SysFreeString(bOut);
    return hr;    
}
    
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportGetOption(
        IPassportManager * pManager,
        LPCWSTR     szOption,
        VARIANT *   vOut)
{
    if (pManager == NULL)
        return E_INVALIDARG;
    if (g_hrPassportVersion < 3)
        return E_NOTIMPL;

    IPassportManager3 * pManager3 = NULL;    
    HRESULT            hr         = S_OK;
    BSTR               bstrP      = SysAllocString(szOption);

    hr = pManager->QueryInterface(IID_IPassportManager3, (void **) &pManager3);
    ON_ERROR_EXIT();
    
    hr = pManager3->get_Option(bstrP, vOut);
    ON_ERROR_EXIT();

 Cleanup:
    ReleaseInterface(pManager3);
    if (bstrP != NULL)
        SysFreeString(bstrP);
    return hr;   
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportSetOption(
        IPassportManager * pManager,
        LPCWSTR     szOption,
        VARIANT     vOut)
{
    if (pManager == NULL)
        return E_INVALIDARG;
    if (g_hrPassportVersion < 3)
        return E_NOTIMPL;

    IPassportManager3 * pManager3 = NULL;    
    HRESULT            hr         = S_OK;
    BSTR               bstrP      = SysAllocString(szOption);

    hr = pManager->QueryInterface(IID_IPassportManager3, (void **) &pManager3);
    ON_ERROR_EXIT();
    
    hr = pManager3->put_Option(bstrP, vOut);
    ON_ERROR_EXIT();

 Cleanup:
    ReleaseInterface(pManager3);
    if (bstrP != NULL)
        SysFreeString(bstrP);
    return hr;   
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT  __stdcall
PassportContinueStartPageHTTPRaw(
        IPassportManager * pManager,
        LPBYTE             bufBody,
        int                iBodyLen,
        LPWSTR             szHeaders,
        int                iHeadersLen,
        LPBYTE             bufContent,
        LPDWORD            pdwContentLen)
{
    HRESULT              hr                  = S_OK;
    LPSTR                szAHeaders          = NULL;
    DWORD                dwAHeadersLen       = iHeadersLen;
    IPassportManager3 *  pManager3           = NULL;    
    
    if (pManager == NULL || bufBody == NULL || iBodyLen < 1 || szHeaders == NULL || iHeadersLen < 1)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    if (g_hrPassportVersion < 3)
        return E_NOTIMPL;

    hr = pManager->QueryInterface(IID_IPassportManager3, (void **) &pManager3);
    ON_ERROR_EXIT();

    szAHeaders = new (NewClear) char[dwAHeadersLen + 1];
    ON_OOM_EXIT(szAHeaders);

    hr = pManager3->ContinueStartPageHTTPRaw(iBodyLen, bufBody, &dwAHeadersLen, szAHeaders, pdwContentLen, bufContent);
    ON_ERROR_EXIT();
    
    if (dwAHeadersLen > 0 && szAHeaders[0] != NULL)
    {
        if (!MultiByteToWideChar(CP_ACP, 0, szAHeaders, -1, szHeaders, iHeadersLen-1))
            EXIT_WITH_LAST_ERROR();
        szHeaders[iHeadersLen-1] = NULL;
    }

 Cleanup:
    delete [] szAHeaders;
    ReleaseInterface(pManager3);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportCrypt   (
        int         iFunctionID,
        LPCWSTR     szSrc,
        LPWSTR      szDest,
        int         iDestLength)
{
    if (iFunctionID < 0 || iFunctionID > 3)
        return E_INVALIDARG;

    IPassportCrypt   * pCrypt = GetPassportCryptInterface();
    if (pCrypt == NULL)
        return E_FAIL;

    BSTR      bSrc   = SysAllocString(szSrc);
    BSTR      bDest  = NULL;
    HRESULT   hr     = S_OK;

    if (bSrc == NULL && szSrc != NULL && szSrc[0] != NULL)
        ON_OOM_EXIT(bSrc);

    EnterCriticalSection(&g_oCryptCritSec);
    switch(iFunctionID)
    {
    case 0:
        hr = pCrypt->Encrypt(bSrc, &bDest);
        break;
    case 1:
        hr = pCrypt->Decrypt(bSrc, &bDest);
        break;
    case 2:
        hr = pCrypt->Compress(bSrc, &bDest);
        break;
    case 3:
        hr = pCrypt->Decompress(bSrc, &bDest);
        break;
    default:
        ASSERT(FALSE);
        EXIT_WITH_HRESULT(E_INVALIDARG);
    }

    LeaveCriticalSection(&g_oCryptCritSec);    
    ON_ERROR_EXIT();

    if (bDest != NULL)
    {
        if (szDest == NULL || iDestLength <= lstrlenW(bDest))
        {            
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            if (szDest != NULL && iDestLength > 10)
            {
                _itow(lstrlenW(bDest) + 1, szDest, 10);                
            }
        }
        else
        {
            StringCchCopy(szDest, iDestLength, bDest);
        }
    }

 Cleanup:
    SysFreeString(bSrc);
    SysFreeString(bDest);
    return hr;    
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportCryptPut   (
        int         iFunctionID,        
        LPCWSTR     szSrc)
{
    if (iFunctionID < 0 || iFunctionID > 1)
        return E_INVALIDARG;

    IPassportCrypt   * pCrypt = GetPassportCryptInterface();
    if (pCrypt == NULL)
        return E_FAIL;

    BSTR      bSrc   = SysAllocString(szSrc);
    HRESULT   hr     = S_OK;

    if (bSrc == NULL && szSrc != NULL && szSrc[0] != NULL)
        ON_OOM_EXIT(bSrc);

    EnterCriticalSection(&g_oCryptCritSec);
    if (iFunctionID == 0)
        hr = pCrypt->put_host(bSrc);
    else
        hr = pCrypt->put_site(bSrc);
    LeaveCriticalSection(&g_oCryptCritSec);    

 Cleanup:
    SysFreeString(bSrc);
    return hr;    
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
__stdcall
PassportCryptIsValid   ()
{
    IPassportCrypt   * pCrypt = GetPassportCryptInterface();
    if (pCrypt == NULL)
        return E_FAIL;

    VARIANT_BOOL  vRet;
    HRESULT hr = pCrypt->get_IsValid(&vRet);
    
    if (SUCCEEDED(hr))
        hr = ((vRet == VARIANT_FALSE) ? S_FALSE : S_OK);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\perfcounterserver.cxx ===
/**
 * PerfCounterServer.cxx
 * 
 * Copyright (c) 1998-2002, Microsoft Corporation
 * 
 */


#include "precomp.h"
#include "ProcessTableManager.h"
#include "dbg.h"
#include "util.h"
#include "platform_apis.h"
#include "nisapi.h"
#include "aspnetver.h"
#include "hashtable.h"
#include "SmartFileHandle.h"
#include "completion.h"
#include "names.h"
#include "ary.h"
#include "PerfCounters.h"


/*  Performance counters in ASP.NET

    Here's a short description on the implementation details of performance counters for ASP.NET.

    The main class for dealing with performance counters is the CPerfCounterServer class.  This class was
    designed to be a singleton per process and does all the management of counter data for different
    app domains, as well as the communication layer with the perf counter dll.  Communication with
    the perf dll is done via named pipes, with their names randomly generated and stored in a key
    in the registry ACL'd so that worker processes can R/W from it, but everyone else can only Read.
    Named pipes are also connected with static security of Anonymous, to prevent any malicious users
    from impersonating the process.
    
    ASP.NET contains 2 sets of performance counters:  global and app.  Internally they are stored
    in a CPerfData structure, which contains a DWORD array of values and the name of the application.
    A NULL application name signifies it contains the global data.  An array of CPerfData is
    used to hold on to the data for all app domains.

    There is also a set of methods exposed that are basically entry points for managed code to open, close
    and set the various perf counters. 
*/

/////////////////////////////////////////////////////////////////////////////
// Class definitions

#define PIPE_PREFIX_L L"\\\\.\\pipe\\"
#define PIPE_PREFIX_LENGTH 9

// Declare the array of CPerfData* 
DECLARE_CPtrAry(CPerfDataAry, CPerfData*);

// Declare the array of WCHAR*
DECLARE_CPtrAry(CWCHARAry, WCHAR*);

class CPerfPipeOverlapped : public OVERLAPPED_COMPLETION
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    CPerfPipeOverlapped();
    ~CPerfPipeOverlapped();

    BOOL  fWriteOprn;   // WriteFile or ReadFile?
    DWORD dwPipeNum;
    DWORD dwBytes;
    DWORD dwBufferSize;
    BYTE* lpNextData;
    BYTE* lpBuffer;
    CSmartFileHandle pipeHandle;
    CPerfVersion versionBuffer;
    BOOL fClientConnected;

private:
    NO_COPY(CPerfPipeOverlapped);
};

class CPerfCounterServer : public ICompletion
{
public:
    static CPerfCounterServer* GetSingleton();
    static CPerfData * g_GlobalCounterData;
    static HRESULT StaticInitialize();

    HRESULT OpenInstanceCounter(CPerfData ** hInstanceData, WCHAR * szAppName);
    HRESULT CloseInstanceCounter(CPerfData * pInstanceData);
    
    // ICompletion interface
    STDMETHOD    (QueryInterface   ) (REFIID    , void **       );
    STDMETHOD    (ProcessCompletion) (HRESULT   , int, LPOVERLAPPED  );

    STDMETHOD_   (ULONG, AddRef    ) ();
    STDMETHOD_   (ULONG, Release   ) ();

private:
    DECLARE_MEMCLEAR_NEW_DELETE();

    // Private constructor and destructor -- there can only be a singleton of this class
    CPerfCounterServer();
    ~CPerfCounterServer();
    NO_COPY(CPerfCounterServer);

    // Private methods
    HRESULT Initialize();
    HRESULT StartRead(HANDLE hPipe, CPerfPipeOverlapped * pOverlapped);
    HRESULT StartOverlapped(HANDLE hPipe, CPerfPipeOverlapped * pOverlapped);
    HRESULT InitPerfPipe();
    HRESULT StartNewPipeInstance(BOOL firstOne);
    void ClosePipe(CPerfPipeOverlapped * pOverlapped);
    HRESULT CleanupNames();
    HRESULT CreateSids(PSID *BuiltInAdministrators, PSID *ServiceUsers, PSID *AuthenticatedUsers);
    HRESULT CreateSd(PSECURITY_DESCRIPTOR * descriptor);
    HRESULT SendPerfData(HANDLE hPipe, CPerfPipeOverlapped * lpOverlapped);

    // Static        
    static CPerfCounterServer * s_Singleton;

    const static int MaxPipeInstances = 32;             
    const static int MaxPipeNameLength = PERF_PIPE_NAME_MAX_BUFFER;
    const static int MaxDirInfoBufferSize = 4000;

    // Instance vars
    CReadWriteSpinLock _perfLock;
    CPerfDataAry _perfDataAry;

    CPerfVersion * _currentVersion;

    // Pipe maintenance vars
    BOOL _inited;
    LONG _lPendingReadWriteCount;
    CPerfPipeOverlapped * _pipeServerData[MaxPipeInstances];
    LONG _pipesConnected;
    LONG  _pipeIndex;                     // This is the highest pipe INDEX created (add 1 for count!)
    WCHAR * _pipeName;
};

/////////////////////////////////////////////////////////////////////////////
// Static
// 
CPerfCounterServer * CPerfCounterServer::s_Singleton;
CPerfData * CPerfCounterServer::g_GlobalCounterData;

/////////////////////////////////////////////////////////////////////////////
// Singleton retriever for CPerfCounterServer class
// 
inline CPerfCounterServer* CPerfCounterServer::GetSingleton()
{
    return s_Singleton;
}

/////////////////////////////////////////////////////////////////////////////
// CTor
// 
CPerfCounterServer::CPerfCounterServer():_perfLock("CPerfCounterServer")
{
    _pipeIndex = -1;
}


/////////////////////////////////////////////////////////////////////////////
// DTor
// 
CPerfCounterServer::~CPerfCounterServer()
{
}
/////////////////////////////////////////////////////////////////////////////
// CTor
// 
CPerfPipeOverlapped::CPerfPipeOverlapped()
{
}

/////////////////////////////////////////////////////////////////////////////
// DTor
// 
CPerfPipeOverlapped::~CPerfPipeOverlapped()
{
    DELETE_BYTES(lpBuffer);
}

/////////////////////////////////////////////////////////////////////////////
// Inits the CPerfCounterServer class
// 
HRESULT CPerfCounterServer::StaticInitialize()
{
    HRESULT hr = S_OK;
    CPerfCounterServer * counterServer = NULL;

    if (CPerfCounterServer::s_Singleton == NULL) {
        counterServer = new CPerfCounterServer;
        ON_OOM_EXIT(counterServer);

        hr = counterServer->Initialize();
        ON_ERROR_EXIT();

        CPerfCounterServer::s_Singleton = counterServer;
        counterServer = NULL;
    }
Cleanup:
    delete counterServer;

    return hr;
}

HRESULT CPerfCounterServer::Initialize()
{
    HRESULT hr = S_OK;
    
    _currentVersion = CPerfVersion::GetCurrentVersion();
    ON_OOM_EXIT(_currentVersion);

    g_GlobalCounterData = new CPerfData;
    ON_OOM_EXIT(g_GlobalCounterData);

    _perfDataAry.Append(g_GlobalCounterData);

    hr = InitPerfPipe();
    ON_ERROR_EXIT();
    
    _inited = TRUE;

Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Given an app name, returns the CPerfData struct for it.
// It'll retrieve an existing one if there, else will return a new one
// 
HRESULT CPerfCounterServer::OpenInstanceCounter(CPerfData ** hInstanceData, WCHAR * wcsAppName)
{
    HRESULT hr = S_OK;
    size_t length;
    CPerfData * data;
    
    if (!_inited)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    hr = StringCchLengthW(wcsAppName, CPerfData::MaxNameLength, &length);
    ON_ERROR_EXIT();

    _perfLock.AcquireWriterLock();
    __try {
        data = (CPerfData *) NEW_CLEAR_BYTES(sizeof(CPerfData) + (length * sizeof(WCHAR)));
        ON_OOM_EXIT(data);

        hr = StringCchCopyW(data->name, length + 1, wcsAppName);
        ON_ERROR_EXIT();
        data->nameLength = (int) length;

        _perfDataAry.Append(data);

        *hInstanceData = data;
    }
    __finally {
        _perfLock.ReleaseWriterLock();
    }

Cleanup:
   
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Removes the given CPerfData from the list and deletes it
// 
HRESULT CPerfCounterServer::CloseInstanceCounter(CPerfData * pInstanceData)
{
    HRESULT hr = S_OK;

    _perfLock.AcquireWriterLock();
    __try {

        int index = _perfDataAry.Find(pInstanceData);
        if (index == -1)
            EXIT();
        
        CPerfData * perfData = _perfDataAry[index];

        _perfDataAry.Delete(index);
        delete perfData;
    }
    __finally {
        _perfLock.ReleaseWriterLock();
    }
    
Cleanup:

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Queries the system for all named pipes and sees if the perf counter
// named pipes in the registry still exist.  If not, they are deleted
// 
HRESULT CPerfCounterServer::CleanupNames()
{
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    LONG retCode = 0;
    DWORD index;
    WCHAR keyName[MAX_PATH];
    DWORD keyLength;
    HashtableGeneric * nameTable = NULL;
    HANDLE hPipe = NULL;
    void * obj;
    WCHAR name[MAX_PATH];
    int cbLength;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA findFileData;
    CWCHARAry delKeysAry;
    
    nameTable = new HashtableGeneric;
    ON_OOM_EXIT(nameTable);

    nameTable->Init(13);

    hFind = FindFirstFileEx(L"\\\\.\\pipe\\*", FindExInfoStandard, &findFileData, (FINDEX_SEARCH_OPS ) 0, NULL, 0 );
    if (hFind == INVALID_HANDLE_VALUE)
        EXIT_WITH_LAST_ERROR();

    do {
        size_t iRemaining;
        // Copy the pipe name into a new wchar buffer
        hr = StringCchCopyNExW(name, MAX_PATH, findFileData.cFileName, MAX_PATH - 1, NULL, &iRemaining, NULL);
        ON_ERROR_EXIT();

        // Insert the name into the hashtable
        cbLength = (MAX_PATH + 1 - ((int) iRemaining)) * sizeof(WCHAR);
        hr = nameTable->Insert((BYTE *) name, cbLength, SimpleHash((BYTE*) name, cbLength), nameTable, NULL);
        ON_ERROR_EXIT();
    } while(FindNextFile(hFind, &findFileData));

    // Now open registry key of previously stored name pipes
    retCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_PERF_VERSIONED_NAMES_KEY_L, 0, KEY_READ | KEY_WRITE, &hKey);
    ON_WIN32_ERROR_EXIT(retCode);

    // On each name, see if it's in the hashtable -- if so, skip
    for (index = 0;;index++) {
        keyLength = ARRAY_SIZE(keyName) - 1;
        retCode = RegEnumValue(hKey, index, (LPWSTR) &keyName, &keyLength, 0, 0, 0, NULL);
        keyName[ARRAY_SIZE(keyName) - 1] = L'\0';
        if (retCode == ERROR_SUCCESS) {
            obj = NULL;
            cbLength = (keyLength + 1) * sizeof(WCHAR);
            nameTable->Find((BYTE*)keyName, cbLength, SimpleHash((BYTE*) keyName, cbLength), &obj);

            // If name is not on the hashtable, keep its name around to delete later
            if (obj == NULL) {
                WCHAR * toDelName = new WCHAR[keyLength + 1];
                hr = StringCchCopyNW(toDelName, keyLength + 1, keyName, keyLength);
                delKeysAry.Append(toDelName);
            }
        }
        else if (retCode == ERROR_NO_MORE_ITEMS) {
            break;
        }
        else if (retCode != ERROR_MORE_DATA) {
            EXIT_WITH_WIN32_ERROR(retCode);
        }
    }

    for (int i = 0; i < delKeysAry.Size(); i++) {
        retCode = RegDeleteValue(hKey, delKeysAry[i]);
        ON_WIN32_ERROR_CONTINUE(retCode);
    }

Cleanup:
    if (hKey != NULL)
        RegCloseKey(hKey);

    if (hPipe != NULL)
        CloseHandle(hPipe);

    if (hFind != INVALID_HANDLE_VALUE)
        FindClose(hFind);

    for (int i = 0; i < delKeysAry.Size(); i++) {
        WCHAR * toDelName = delKeysAry[i];
        delete [] toDelName;
    }

    delete nameTable;

    return hr;
}
            
/////////////////////////////////////////////////////////////////////////////
// Initializes the perf dll communication name pipe servers.
// 
HRESULT CPerfCounterServer::InitPerfPipe()
{    
    HRESULT  hr   = S_OK;

    // Cleanup the old names off the registry
    CleanupNames();

    hr = StartNewPipeInstance(TRUE);
    ON_ERROR_EXIT();

 Cleanup:

    return hr;
}   

HRESULT CPerfCounterServer::StartNewPipeInstance(BOOL firstOne)
{
    HRESULT  hr   = S_OK;
    HANDLE   hPipe = NULL;
    WCHAR *  szName;
    HKEY     hKey = NULL;
    PSECURITY_DESCRIPTOR pSd = NULL;
    SECURITY_ATTRIBUTES sa;
    DWORD maxRetry = 5;
    DWORD pipeNum = InterlockedIncrement(&_pipeIndex);
    CPerfPipeOverlapped * pipeData;

    if (pipeNum >= MaxPipeInstances) 
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    ASSERT(_pipeServerData[pipeNum] == NULL);
    _pipeServerData[pipeNum] = new CPerfPipeOverlapped;
    ON_OOM_EXIT(_pipeServerData[pipeNum]);

    pipeData = _pipeServerData[pipeNum];
        
    // Don't forget to free the pSd!
    hr = CreateSd(&pSd);
    ON_ERROR_EXIT();

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = pSd;
    sa.bInheritHandle = FALSE;

    pipeData->dwPipeNum = pipeNum;
    pipeData->pCompletion = this;

    // Create pipe
    // Only on first create do we specify the first pipe flag
    if (firstOne) {
        // Copy the pipe prefix to the name buffer
        _pipeName = new WCHAR[CPerfCounterServer::MaxPipeNameLength];
        ON_OOM_EXIT(_pipeName);
        
        hr = StringCchCopy(_pipeName, PIPE_PREFIX_LENGTH + 1, PIPE_PREFIX_L);
        ON_ERROR_EXIT();
        szName = _pipeName + PIPE_PREFIX_LENGTH;

        while (maxRetry > 0) {
            // Obtain the random pipe name
            // GenerateRandomString will return only fill up the string to (size - 1) entries
            hr = GenerateRandomString(szName, CPerfCounterServer::MaxPipeNameLength - PIPE_PREFIX_LENGTH);
            ON_ERROR_EXIT();
            szName[CPerfCounterServer::MaxPipeNameLength - PIPE_PREFIX_LENGTH - 1] = L'\0';
            
            hPipe = CreateNamedPipe(_pipeName, 
                                    FILE_FLAG_OVERLAPPED | PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE,
                                    PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
                                    MaxPipeInstances, 1024, 1024, 1000, &sa);

            // Because we specify first pipe instance, creation will fail unless we're the creator
            if (hPipe != INVALID_HANDLE_VALUE) {
                // Put the pipe name into the registry
                hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_PERF_VERSIONED_NAMES_KEY_L, 0, KEY_READ | KEY_WRITE, &hKey);
                ON_WIN32_ERROR_EXIT(hr);

                int val = GetCurrentProcessId();
                hr = RegSetValueEx(hKey, szName, 0, REG_DWORD, (BYTE*) &val, sizeof(DWORD));
                ON_WIN32_ERROR_EXIT(hr);

                RegCloseKey(hKey);
                hKey = NULL;

                // Get out of the while loop
                break;
            }
                
            maxRetry--;
        }
    }
    else {
        ASSERT(_pipeName != NULL);
        
        hPipe = CreateNamedPipe(_pipeName, 
                                FILE_FLAG_OVERLAPPED | PIPE_ACCESS_DUPLEX,
                                PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
                                MaxPipeInstances, 1024, 1024, 1000, &sa);
    }

    if (hPipe == INVALID_HANDLE_VALUE)
        EXIT_WITH_LAST_ERROR();

    // Set pipe
    pipeData->pipeHandle.SetHandle(hPipe);

    hr = AttachHandleToThreadPool(hPipe);
    ON_ERROR_EXIT();

    hr = StartOverlapped(hPipe, pipeData);
    ON_ERROR_EXIT();

 Cleanup:
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    DELETE_BYTES(pSd);

    if (hr != S_OK) {
        if (hPipe != INVALID_HANDLE_VALUE)
            CloseHandle(hPipe);
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Starts the overlapped operation on the named pipe
// 
HRESULT CPerfCounterServer::StartOverlapped(HANDLE hPipe, CPerfPipeOverlapped * pOverlapped)
{
    HRESULT hr = S_OK;

    pOverlapped->fWriteOprn = FALSE;
    if (!ConnectNamedPipe(hPipe, pOverlapped)) {
        DWORD lastError = GetLastError();
        if (lastError != ERROR_PIPE_CONNECTED && lastError != ERROR_IO_PENDING) {
            EXIT_WITH_LAST_ERROR();
        }
    }

Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Start reading from the pipe
// 
HRESULT CPerfCounterServer::StartRead(HANDLE hPipe, CPerfPipeOverlapped * pOverlapped)
{
    HRESULT hr    = S_OK;

    pOverlapped->fWriteOprn = FALSE;
    if (!ReadFile(hPipe, &(pOverlapped->versionBuffer), sizeof(CPerfVersion), NULL, pOverlapped))
    {
        DWORD dwE = GetLastError();
        if (dwE != ERROR_IO_PENDING && dwE != ERROR_MORE_DATA)
        {
            EXIT_WITH_LAST_ERROR();
        }
    }

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Close
void CPerfCounterServer::ClosePipe(CPerfPipeOverlapped * pOverlapped)
{
    pOverlapped->pipeHandle.Close();
}

/////////////////////////////////////////////////////////////////////////////
//
// CreateSids
//
// Create 3 Security IDs
//
// Caller must free memory allocated to SIDs on success.
//
// Returns: TRUE if successfull, FALSE if not.
//
HRESULT CPerfCounterServer::CreateSids(PSID *BuiltInAdministrators, PSID *ServiceUsers, PSID *AuthenticatedUsers)
{
    HRESULT hr = S_OK;
    PSID tmpAdmin = NULL;
    PSID tmpService = NULL;
    PSID tmpUser = NULL;
    
    //
    // An SID is built from an Identifier Authority and a set of Relative IDs
    // (RIDs).  The Authority of interest to us SECURITY_NT_AUTHORITY.
    //
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    //
    // Each RID represents a sub-unit of the authority.  Two of the SIDs we
    // want to build, Local Administrators, and Power Users, are in the "built
    // in" domain.  The other SID, for Authenticated users, is based directly
    // off of the authority.
    //     
    // For examples of other useful SIDs consult the list in
    // \nt\public\sdk\inc\ntseapi.h.
    //
    if (!AllocateAndInitializeSid(&NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0,0,0,0,0,0, &tmpAdmin)) 
        EXIT_WITH_LAST_ERROR();
    
    if (!AllocateAndInitializeSid(&NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_POWER_USERS, 0,0,0,0,0,0, &tmpService))
        EXIT_WITH_LAST_ERROR();

    if (!AllocateAndInitializeSid(&NtAuthority, 1, SECURITY_AUTHENTICATED_USER_RID, 0,0,0,0,0,0,0, &tmpUser))
        EXIT_WITH_LAST_ERROR();

    *BuiltInAdministrators = tmpAdmin;
    tmpAdmin = NULL;

    *ServiceUsers = tmpService;
    tmpService = NULL;

    *AuthenticatedUsers = tmpUser;
    tmpUser = NULL;

Cleanup:
    FreeSid(tmpAdmin);
    FreeSid(tmpService);
    FreeSid(tmpUser);

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// CreateSd
//
// Creates a SECURITY_DESCRIPTOR with specific DACLs.  Modify the code to
// change. 
//
// Caller must free the returned buffer if not NULL.
//
HRESULT CPerfCounterServer::CreateSd(PSECURITY_DESCRIPTOR * descriptor)
{
    HRESULT hr = S_OK;
    PSID AuthenticatedUsers;
    PSID BuiltInAdministrators;
    PSID ServiceUsers;
    PSECURITY_DESCRIPTOR Sd = NULL;
    LONG AclSize;

    BuiltInAdministrators = NULL;
    ServiceUsers = NULL;
    AuthenticatedUsers = NULL;

    hr = CreateSids(&BuiltInAdministrators, &ServiceUsers, &AuthenticatedUsers);
    ON_ERROR_EXIT();

    // Calculate the size of and allocate a buffer for the DACL, we need
    // this value independently of the total alloc size for ACL init.

    // "- sizeof (LONG)" represents the SidStart field of the
    // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
    // SID, this field is counted twice.

    AclSize = sizeof (ACL) +
        (3 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (LONG))) +
        GetLengthSid(AuthenticatedUsers) +
        GetLengthSid(BuiltInAdministrators) +
        GetLengthSid(ServiceUsers);

    Sd = (PSECURITY_DESCRIPTOR) NEW_BYTES(SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);
    ON_OOM_EXIT(Sd);

    ACL *Acl;
    Acl = (ACL *)((BYTE *)Sd + SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (!InitializeAcl(Acl, AclSize, ACL_REVISION)) 
        EXIT_WITH_LAST_ERROR();

    if (!AddAccessAllowedAce(Acl, ACL_REVISION, GENERIC_READ | GENERIC_WRITE, AuthenticatedUsers)) 
        EXIT_WITH_LAST_ERROR();

    if (!AddAccessAllowedAce(Acl, ACL_REVISION, GENERIC_READ | GENERIC_WRITE, ServiceUsers)) 
        EXIT_WITH_LAST_ERROR();

    if (!AddAccessAllowedAce(Acl, ACL_REVISION, GENERIC_ALL, BuiltInAdministrators)) 
        EXIT_WITH_LAST_ERROR();

    if (!InitializeSecurityDescriptor(Sd, SECURITY_DESCRIPTOR_REVISION)) 
        EXIT_WITH_LAST_ERROR();

    if (!SetSecurityDescriptorDacl(Sd, TRUE, Acl, FALSE)) 
        EXIT_WITH_LAST_ERROR();

    *descriptor = Sd;
    Sd = NULL;

Cleanup:
    FreeSid(AuthenticatedUsers);
    FreeSid(BuiltInAdministrators);
    FreeSid(ServiceUsers);

    DELETE_BYTES(Sd);
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CPerfCounterServer::QueryInterface(REFIID iid, void **ppvObj)
{
    if (iid == IID_IUnknown || iid == __uuidof(ICompletion))
    {
        *ppvObj = (ICompletion *) this;
        AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////

ULONG CPerfCounterServer::AddRef()
{
    return InterlockedIncrement(&_lPendingReadWriteCount);
}

/////////////////////////////////////////////////////////////////////////////

ULONG CPerfCounterServer::Release()
{
    return InterlockedDecrement(&_lPendingReadWriteCount);
}

/////////////////////////////////////////////////////////////////////////////
// The call back once data arrives for a named pipe
// 
HRESULT CPerfCounterServer::ProcessCompletion(HRESULT hr, int numBytes, LPOVERLAPPED pOver)
{
    CPerfPipeOverlapped * pPipeOverlapped = NULL;
    HANDLE hPipe = INVALID_HANDLE_VALUE;
    int sendBufSize;
    int dataSize;
    CPerfData * message;
    int startIndex;

    if (pOver == NULL)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    pPipeOverlapped = (CPerfPipeOverlapped *) pOver;
    hPipe = pPipeOverlapped->pipeHandle.GetHandle();

    ////////////////////////////////////////////////////////////
    // Step 1: Make sure the pipe is working
    if (hPipe == INVALID_HANDLE_VALUE) // It's closed!
    {
        if (FAILED(hr) == FALSE)
            hr = E_FAIL; // Make sure hr indicates failed
        EXIT();
    }
   
    ////////////////////////////////////////////////////////////
    // Step 2: Did the operation succeed?
    if (hr != S_OK) // It failed: maybe the file handle was closed...
    {
        // Do a call for debugging purposes
#if DBG
        DWORD dwBytes =  0;

        BOOL result = GetOverlappedResult(hPipe, pPipeOverlapped, &dwBytes, FALSE);

        ASSERT(result == FALSE);
#endif

        EXIT(); // Exit on all errors
    }

    ////////////////////////////////////////////////////////////
    // Step 3: In in write mode, check and see if there's any more
    //         data to send.
    //
    if (pPipeOverlapped->fWriteOprn == TRUE) {
        // Check and see if we have more data to send
        CPerfDataHeader * dataHeader = (CPerfDataHeader*) pPipeOverlapped->lpNextData;

        // If the transmitDataSize is positive, then there's another packet of data to be sent
        if (dataHeader->transmitDataSize > 0) {
            pPipeOverlapped->lpNextData += dataHeader->transmitDataSize;
            hr = SendPerfData(hPipe, pPipeOverlapped);
            ON_ERROR_EXIT();
        }
        else { // Nope, last bit of data has been sent, so start a read
            hr = StartRead(hPipe, pPipeOverlapped);
            ON_ERROR_EXIT();
        }
    }
    else {
        ////////////////////////////////////////////////////////////
        // Responding to an async read

        ////////////////////////////////////////////////////////////
        // Step 4: If the number of active pipes is the same
        //         as the number of instances, but we haven't
        //         hit the limit, then start a new instance
        if (pPipeOverlapped->fClientConnected == FALSE) {
            pPipeOverlapped->fClientConnected = TRUE;
            InterlockedIncrement(&_pipesConnected);

            if ((_pipesConnected == (_pipeIndex + 1)) && (_pipesConnected < MaxPipeInstances)) {
                StartNewPipeInstance(FALSE);
            }
        }
     
        ////////////////////////////////////////////////////////////
        // Step 5: If it's a ping (zero bytes), start another read
        if (numBytes == 0) 
        {
            // Start another read
            hr = StartRead(hPipe, pPipeOverlapped);
            ON_ERROR_EXIT();
        }
        else
        {
            ////////////////////////////////////////////////////////
            // Step 6: Received a message: deal with it

            // Check and see if the received version buffer matches our version
            if (pPipeOverlapped->versionBuffer.majorVersion == _currentVersion->majorVersion &&
                pPipeOverlapped->versionBuffer.minorVersion == _currentVersion->minorVersion &&
                pPipeOverlapped->versionBuffer.buildVersion == _currentVersion->buildVersion)
            {

                _perfLock.AcquireReaderLock();
                __try {
                    DWORD totalDataSize = sizeof(CPerfDataHeader);

                    sendBufSize = 0;
                    startIndex = 0;

                    // Get total size needed for data buffer
                    for (int i = 0; i < _perfDataAry.Size(); i++) {
                        message = _perfDataAry[i];

                        dataSize = sizeof(CPerfData) + (message->nameLength * sizeof(message->name[0]));

                        // If the next data packet exceeds the max buffer send size, then it needs to be
                        // chunked into the next transmit.  
                        if (sendBufSize + dataSize > CPerfDataHeader::MaxTransmitSize) {
                            totalDataSize += sizeof(CPerfDataHeader);
                            sendBufSize = 0;
                        }
                        sendBufSize += dataSize;
                        totalDataSize += dataSize;
                    }

                    // If buffer is too small, release and allocate a new one
                    if (totalDataSize > pPipeOverlapped->dwBufferSize) {
                        DELETE_BYTES(pPipeOverlapped->lpBuffer);
                        pPipeOverlapped->dwBufferSize = 0;

                        pPipeOverlapped->lpBuffer = (BYTE *) NEW_BYTES(totalDataSize);
                        ON_OOM_EXIT(pPipeOverlapped->lpBuffer);
                        pPipeOverlapped->dwBufferSize = totalDataSize;
                    }

                    BYTE * lpDataPtr = pPipeOverlapped->lpBuffer;
                    CPerfDataHeader * curHeader = (CPerfDataHeader *) lpDataPtr;
            
                    pPipeOverlapped->lpNextData = pPipeOverlapped->lpBuffer;

                    // Offset for the data header
                    lpDataPtr += sizeof(CPerfDataHeader);

                    sendBufSize = 0;

                    for (int i = 0; i < _perfDataAry.Size(); i++) {
                        message = _perfDataAry[i];

                        dataSize = sizeof(CPerfData) + (message->nameLength * sizeof(message->name[0]));

                        // If the next data packet exceeds the max buffer send size, then
                        // chunk the send and send the data to the client
                        if (sendBufSize + dataSize > CPerfDataHeader::MaxTransmitSize) {
                            curHeader->transmitDataSize = sendBufSize;
                            curHeader = (CPerfDataHeader *) lpDataPtr;
                            lpDataPtr += sizeof(CPerfDataHeader);
                            sendBufSize = 0;
                        }
                        CopyMemory(lpDataPtr, message, dataSize);
                        lpDataPtr += dataSize;
                        sendBufSize += dataSize;
                    }

                    // Set the transmitDataSize to be the negative of the buffer size
                    // to indicate that it's the last packet of data
                    curHeader->transmitDataSize = -sendBufSize;

                }
                __finally {
                    _perfLock.ReleaseReaderLock();
                }

                hr = SendPerfData(hPipe, pPipeOverlapped);
                ON_ERROR_EXIT();
            }
            else {
                // Nope, not the same version as ours
                hr = E_INVALIDARG;
            }
        }
    }

 Cleanup:
    if (hr != S_OK)
    {
        // On all errors, restart the read on the pipe
        if (pPipeOverlapped != NULL && hPipe != INVALID_HANDLE_VALUE) {
            DisconnectNamedPipe(hPipe);
            pPipeOverlapped->fClientConnected = FALSE;  
            InterlockedDecrement(&_pipesConnected);
            DELETE_BYTES(pPipeOverlapped->lpBuffer);
            pPipeOverlapped->lpBuffer = NULL;
            pPipeOverlapped->lpNextData = NULL;
            pPipeOverlapped->dwBufferSize = 0;
            StartOverlapped(hPipe, pPipeOverlapped);
        }
    }
    
    if (pPipeOverlapped != NULL)
        pPipeOverlapped->pipeHandle.ReleaseHandle();

    return hr;
}

HRESULT CPerfCounterServer::SendPerfData(HANDLE hPipe, CPerfPipeOverlapped * lpOverlapped)
{
    HRESULT hr = S_OK;
    CPerfDataHeader *dataHeader;

    dataHeader = (CPerfDataHeader*) lpOverlapped->lpNextData;

    if (dataHeader->transmitDataSize < 0) {
        lpOverlapped->dwBytes = -(dataHeader->transmitDataSize);
    }
    else {
        lpOverlapped->dwBytes = dataHeader->transmitDataSize;
    }

    ASSERT(lpOverlapped->dwBytes <= CPerfDataHeader::MaxTransmitSize);

    lpOverlapped->fWriteOprn = TRUE;

    if (!WriteFile(hPipe, lpOverlapped->lpNextData, lpOverlapped->dwBytes + sizeof(CPerfDataHeader), NULL, lpOverlapped)) {
        DWORD dwE = GetLastError();
        if (dwE != ERROR_IO_PENDING) {
            EXIT_WITH_LAST_ERROR();
        }
    }

Cleanup:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// A static method that returns the current product version
// Note: it'll return NULL if it couldn't allocate a CPerfVersion object
// 
CPerfVersion * CPerfVersion::GetCurrentVersion()
{
    CPerfVersion * version = new CPerfVersion;
    if (version == NULL)
        return NULL;
    
    ASPNETVER curVersion(VER_PRODUCTVERSION_STR_L);

    version->majorVersion = curVersion.Major();
    version->minorVersion = curVersion.Minor();
    version->buildVersion = curVersion.Build();

    return version;
}

///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
// Init entry point for unmanaged code
//
HRESULT __stdcall PerfCounterInitialize()
{
    return CPerfCounterServer::StaticInitialize();
}

///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
// Entry points from managed code
//

CPerfData * __stdcall PerfOpenGlobalCounters()
{
    return CPerfCounterServer::g_GlobalCounterData;
}

CPerfData * __stdcall PerfOpenAppCounters(WCHAR * szAppName)
{
    CPerfData * data = NULL;
    CPerfCounterServer * perfServer = CPerfCounterServer::GetSingleton();

    if (perfServer != NULL) {
        perfServer->OpenInstanceCounter(&data, szAppName);
    }

    return data;
}

void __stdcall PerfCloseAppCounters(CPerfData * perfData) 
{
    CPerfCounterServer * perfServer = CPerfCounterServer::GetSingleton();

    if (perfServer != NULL) {
        perfServer->CloseInstanceCounter(perfData);
    }
}

//
// Increment the specified global counter by 1
// 
void __stdcall PerfIncrementGlobalCounter(DWORD number)
{
    PerfIncrementCounter(CPerfCounterServer::g_GlobalCounterData, number);
}

//
// Decrement the specified global counter by 1
// 
void __stdcall PerfDecrementGlobalCounter(DWORD number)
{
    PerfDecrementCounter(CPerfCounterServer::g_GlobalCounterData, number);
}

//
// Increment the specified global counter by specified number
// 
void __stdcall PerfIncrementGlobalCounterEx(DWORD number, int dwDelta)
{
    PerfIncrementCounterEx(CPerfCounterServer::g_GlobalCounterData, number, dwDelta);
}

//
// Set the specified global counter to the specified value
//
void __stdcall PerfSetGlobalCounter(DWORD number, DWORD dwValue)
{
    PerfSetCounter(CPerfCounterServer::g_GlobalCounterData, number, dwValue);
}

//
// Increment the specified (by number) counter by 1
// 
void __stdcall PerfIncrementCounter(CPerfData *base, DWORD number)
{
    if ((base != NULL) && (0 <= number) && (number < PERF_NUM_DWORDS))
    {
        InterlockedIncrement((LPLONG)&(base->data[number]));
    }
}

//
// Decrement the specified (by number) counter by 1
// 
void __stdcall PerfDecrementCounter(CPerfData *base, DWORD number)
{
    if ((base != NULL) && (0 <= number) && (number < PERF_NUM_DWORDS))
    {
        InterlockedDecrement((LPLONG)&(base->data[number]));
    }
}


//
// Get the specified counter value
//
DWORD __stdcall PerfGetCounter(CPerfData *base, DWORD number)
{
#if DBG 
    if ((base != NULL) && (0 <= number) && (number < PERF_NUM_DWORDS))
    {
        return base->data[number];
    }
    else
    {
        return (DWORD) -1;
    }
#else
    return (DWORD) -1;
#endif
}


//
// Increment the specified (by number) counter by specified number
// 
void 
__stdcall
PerfIncrementCounterEx(CPerfData *base, DWORD number, int dwDelta)
{
    if ((base != NULL) && (0 <= number) && (number < PERF_NUM_DWORDS))
    {
        InterlockedExchangeAdd((LPLONG)&(base->data[number]), dwDelta);
    }
}

//
// Set the specified counter to the specified value
//
void 
__stdcall
PerfSetCounter(CPerfData *base, DWORD number, DWORD dwValue)
{
    if ((base != NULL) && (0 <= number) && (number < PERF_NUM_DWORDS))
    {
        InterlockedExchange((LPLONG)&(base->data[number]), dwValue);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\processentry.cxx ===
/**
 * Process Model: ProcessEntry defn file 
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

/////////////////////////////////////////////////////////////////////////////
// This file decl the class CProcessEntry. This class creates and controls
// all interaction with a worker process.
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <iadmw.h>
#include <iiscnfg.h>
#include "ProcessTableManager.h"
#include "ProcessEntry.h"
#include "util.h"
#include "platform_apis.h"
#include "AckReceiver.h"
#include "RequestTableManager.h"
#include "httpext6.h"
#include "CPUEntry.h"
#include "EcbImports.h"
#include "HistoryTable.h"
#include "ResponseContext.h"
#include "msg.h"
#include "PerfCounters.h"
#include "regaccount.h"
#include "event.h"
#include "product_version.h"
#include "ndll.h"
#include "nisapi.h"
#include "Userenv.h"
#include "regiis.h"
#include "_ndll.h"

#define  MAX_WAIT_TIME_FOR_PROCESS_START     300 // 5 minutes
#define  ROUND_TO_4_BYTES(X)                 {X += ((X & 3) ? 4 - (X & 3) : 0); }
#define  ZERO_ARRAY(X)                      ZeroMemory(X, sizeof(X)) 

extern BOOL    g_fShuttingDown;
extern BOOL    g_fLogWorkerProcs;
extern int     g_iAsyncOption;
extern DWORD   g_dwRPCAuthLevel;
extern DWORD   g_dwRPCImperLevel;
extern DWORD   g_dwMaxWorkerThreads;
extern DWORD   g_dwMaxIoThreads;
DWORD g_dwResetPingEventError = 0;
extern int     g_iLogLevel;
LONG g_lNumAsyncPending = 0;
LONG g_lSecurityIssueBug129921_b = 0;
LONG g_lSecurityIssueBug129921_c = 0;
LONG g_lSecurityIssueBug129921_d = 0;
LONG g_lSecurityIssueBug129921_e = 0;

VOID
WINAPI
OnWriteBytesComplete (
        LPEXTENSION_CONTROL_BLOCK /*lpECB*/,        
        PVOID pContext,
        DWORD /*cbIO*/,
        DWORD /*dwError*/);


int 
__stdcall
GetUserNameFromToken (
        HANDLE        token, 
        LPWSTR        buffer,
        int           size);


BOOL
HackGetDebugReg(BOOL & fUnderDebugger);


BOOL    g_fUseTransmitFileChecked       = FALSE;
BOOL    g_fUseTransmitFile              = FALSE;
LONG    g_lBug38658Count                = 0;
DEFINE_SERVER_VARIABLES_ORDER

void
GetStringForHresult(
        LPWSTR  szError,
        int     iErrSize,
        HRESULT hrErr)
{
    if (szError == NULL || iErrSize < 1)
        return;

    ZeroMemory(szError, iErrSize * sizeof(WCHAR));
    if (iErrSize < 14)
        return;

    StringCchPrintf(szError, iErrSize, L"0x%08x ", hrErr);
    int ilen = lstrlenW(szError);

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                   NULL, hrErr, LANG_SYSTEM_DEFAULT, &szError[ilen], iErrSize - ilen - 1, NULL);        

    for(int iter=0; szError[iter] != NULL && iter < iErrSize; iter++)
        if (szError[iter] == '\r' || szError[iter] == '\n')
            szError[iter] = ' ';
}

int
SafeStringLenghtA(
        LPCSTR szStr,
        int    iMaxSize)
{
    if (szStr == NULL)
        return -1;

    int iter=0;
    while(iter<iMaxSize && szStr[iter] != NULL)
        iter++;

    if (szStr[iter] != NULL)
        return -1;
    else
        return iter;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL
CheckFlushCoreBufferForSecurity(
        CAsyncPipeOverlapped *   pOver)
{    
    if (pOver == NULL)
        return FALSE;
    CAsyncMessage *    pMsg            = &pOver->oMsg;
    CResponseStruct *  pResponseStruct = (CResponseStruct *) (pMsg->pData);    
    LPDWORD            pInts           = (LPDWORD) pResponseStruct->bufStrings;
    LPSTR              szStr           = (LPSTR) &pResponseStruct->bufStrings[4 * sizeof(DWORD)];

    if (pMsg->oHeader.lDataLength < sizeof(CResponseStruct)-4)
        return FALSE;

    DWORD dwDataSize = pMsg->oHeader.lDataLength - sizeof(CResponseStruct) + 4;
    if (dwDataSize < sizeof(DWORD) * 4)
        return FALSE;

    
    // pInts format: 
    //   pInts[0] = iStatusLen;
    //   pInts[1] = iHeadLen;
    //   pInts[2] = iTotalBodySize;
    //   pInts[3] = iStatus;
    if (dwDataSize < pInts[0] + pInts[1] + pInts[2] + sizeof(DWORD) * 4)
        return FALSE;
    
    // Make sure that the status and Header strings are trunscated properly
    if (pInts[0] != 0 && SafeStringLenghtA(szStr, pInts[0]) < 0)
        return FALSE;
    if (pInts[1] != 0 && SafeStringLenghtA(&szStr[pInts[0]], pInts[1]) < 0)
        return FALSE;

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CTor
CProcessEntry::CProcessEntry (CCPUEntry * pParent,
                              DWORD       dwCPUMask, 
                              DWORD       dwProcessNum)
    : 
    m_hProcess               (INVALID_HANDLE_VALUE),
    m_lRefCount              (0),
    m_pParent                (pParent),
    m_fShuttingDown          (FALSE),
    m_fKillImmSent           (FALSE),
    m_lRequestsExecuted      (0), 
    m_lRequestsExecuting     (0),
    m_eProcessStatus         (EProcessState_Starting), 
    m_dwCPUMask              (dwCPUMask),
    m_dwProcessNumber        (dwProcessNum), 
    m_pNext                  (NULL),
    m_lCloseCalled           (0),
    m_fUpdatePerfCounter     (FALSE),
    m_hPingSendEvent         (NULL),
    m_hPingRespondEvent      (NULL),
    m_hStartupEvent          (NULL),
    m_fAnyReqsSinceLastPing  (FALSE),
    m_fDebugStatus           (FALSE),
    m_dwResetPingEventError  (0)
{
    m_tTimeCreated.SnapCurrentTime();
    m_hStartupEvent  = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (m_hStartupEvent == NULL)
        m_eProcessStatus = EProcessState_Dead;

    ZeroMemory(&m_oHistoryEntry, sizeof(m_oHistoryEntry));
    InitializeCriticalSection(&m_oCSPing);
    InitializeCriticalSection(&m_oCSPIDAdujustment);
}

/////////////////////////////////////////////////////////////////////////////
// Init
HRESULT
CProcessEntry::Init()
{
    if (g_fShuttingDown == TRUE || m_pParent == NULL)
        return E_FAIL;

    HRESULT                 hr          = S_OK;
    DWORD                   dwPID       = GetCurrentProcessId();
    WCHAR                   szAPipeName [_MAX_PATH + 1];
    WCHAR                   szSPipeName [_MAX_PATH + 1];
    WCHAR                   szArgs      [1024];
    WCHAR                   szLog       [_MAX_PATH + 1];
    WCHAR                   szEvent     [_MAX_PATH + 1];
    WCHAR                   szEvent2    [_MAX_PATH + 1];
    WCHAR                   szProgram   [_MAX_PATH + 1];
    STARTUPINFO             si;
    SECURITY_ATTRIBUTES     sa;
    LPSECURITY_ATTRIBUTES   pSA = NULL;
    PACL                    pACL = NULL;
    SECURITY_DESCRIPTOR     sd;
    int                     iter;
    int                     iNumSyncPipes = ReadRegForNumSyncPipes();
    DWORD                   dwMask = 0;
    BOOL                    fRet = FALSE;
    WCHAR                   szRandom[32];
    int                     iSize;
    LPVOID                  pEnvironment = NULL;
    HANDLE                  hWPToken = NULL;

    ZERO_ARRAY(szAPipeName);
    ZERO_ARRAY(szSPipeName);
    ZERO_ARRAY(szArgs);
    ZERO_ARRAY(szLog);
    ZERO_ARRAY(szEvent);
    ZERO_ARRAY(szEvent2);
    ZERO_ARRAY(szProgram);
    ZERO_ARRAY(szRandom);
    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&sd, sizeof(sd));

    hr = GenerateRandomString(szRandom, 31);
    ON_ERROR_EXIT();


    if (m_eProcessStatus == EProcessState_Running) // Already running
        EXIT();

    // Set the processor affinity mask
    if (CProcessTableManager::GetUseCPUAffinity())
        dwMask = m_dwCPUMask;

    if (dwMask != 0)
    {
        SYSTEM_INFO      si;
        GetSystemInfo(&si);
        dwMask &= si.dwActiveProcessorMask;       
    }

    hWPToken = CProcessTableManager::GetWorkerProcessToken();
    if (hWPToken == INVALID_HANDLE_VALUE)
    {
        XspLogEvent(IDS_EVENTLOG_BAD_CREDENTIALS, NULL);        
        EXIT_WITH_LAST_ERROR();
    }

    if (hWPToken != NULL)
    {        
        hr = CreateDACL(&pACL, hWPToken);
        ON_ERROR_EXIT();

        if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION) || 
            !SetSecurityDescriptorDacl(&sd, TRUE, pACL, FALSE) )
        {
            EXIT_WITH_LAST_ERROR();            
        }
        
        ZeroMemory(&sa, sizeof(sa));
        sa.nLength = sizeof(sa);
        sa.lpSecurityDescriptor = &sd;
        sa.bInheritHandle = FALSE;
        pSA = &sa;
        
        if (!CreateEnvironmentBlock(&pEnvironment, hWPToken, FALSE))
            pEnvironment = NULL;

        ON_ZERO_CONTINUE_WITH_LAST_ERROR(pEnvironment);
        hr = S_OK;
    }

    ////////////////////////////////////////////////////////////
    // Step 1: Make sure the startup event is created, and we have
    //         a valid parent (CPU)
    if (m_hStartupEvent == NULL)
    {
        EXIT_WITH_LAST_ERROR();
    }

    ////////////////////////////////////////////////////////////
    // Step 3: Create the Sync Pipe
    StringCchPrintf(szSPipeName, ARRAY_SIZE(szSPipeName)-1, 
               L"\\\\.\\pipe\\" PRODUCT_NAME_L L"PMSyncPipe_%s_%s_%u_%u", 
               szRandom, VER_PRODUCTVERSION_STR_L, dwPID, m_dwProcessNumber);

    hr = m_oAckReciever.Init(this, szSPipeName, pSA, iNumSyncPipes);
    ON_ERROR_EXIT();

    ////////////////////////////////////////////////////////////
    // Step 4: Create the Async Pipe
    StringCchPrintf(szAPipeName, ARRAY_SIZE(szAPipeName)-1,
               L"\\\\.\\pipe\\" PRODUCT_NAME_L L"PMAsyncPipe_%s_%s_%u_%u", 
               szRandom, VER_PRODUCTVERSION_STR_L, dwPID, m_dwProcessNumber);

    hr = m_oAsyncPipe.Init(this, szAPipeName, pSA);
    ON_ERROR_EXIT();

    ////////////////////////////////////////////////////////////
    // Step 6: Create the event used by the worker process to signal
    //         that it started up okay
    StringCchPrintf(szEvent, ARRAY_SIZE(szEvent)-1, PRODUCT_NAME_L L"PMEvent_%s_%s_%u_%u", szRandom, VER_PRODUCTVERSION_STR_L, dwPID, m_dwProcessNumber);
    StringCchPrintf(szEvent2, ARRAY_SIZE(szEvent2)-1, PRODUCT_NAME_L L"PMEvent_%s_%s_%u_%u_Ping", szRandom, VER_PRODUCTVERSION_STR_L, dwPID, m_dwProcessNumber);

    SetLastError(0);
    m_hPingRespondEvent = CreateEvent(pSA, TRUE, FALSE, szEvent);    
    ON_ZERO_EXIT_WITH_LAST_ERROR(m_hPingRespondEvent);
    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        EXIT_WITH_LAST_ERROR();        
    }

    SetLastError(0);
    m_hPingSendEvent = CreateEvent(pSA, TRUE, FALSE, szEvent2);    
    ON_ZERO_EXIT_WITH_LAST_ERROR(m_hPingSendEvent);
    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        EXIT_WITH_LAST_ERROR();        
    }

    ////////////////////////////////////////////////////////////
    // Step 7: Create the args list for passing to CreateProcess

    iSize = lstrlenW(Names::InstallDirectory()) + lstrlenW(PATH_SEPARATOR_STR_L) + lstrlenW(WP_MODULE_FULL_NAME_L) + 1;
    if (iSize >= ARRAY_SIZE(szProgram))
        EXIT_WITH_HRESULT(E_FAIL);
    StringCchCopyToArrayW(szProgram, Names::InstallDirectory()); // Size checked
    StringCchCatToArrayW(szProgram, PATH_SEPARATOR_STR_L); // Size checked
    StringCchCatToArrayW(szProgram, WP_MODULE_FULL_NAME_L); // Size checked
    StringCchPrintf(szArgs, ARRAY_SIZE(szArgs)-1,
              L"%s %u %u %d %u %u %u %u %u %s", 
              WP_MODULE_FULL_NAME_L,
              dwPID, m_dwProcessNumber, iNumSyncPipes, 
              g_dwRPCAuthLevel, g_dwRPCImperLevel, dwMask,
              g_dwMaxWorkerThreads, g_dwMaxIoThreads,
              szRandom);

    ////////////////////////////////////////////////////////////
    // Step 8: Create the process    
    si.cb = sizeof(si);    

    hr = LaunchWP(szProgram, szArgs, hWPToken, &si, pSA, pEnvironment);
    if (hr != S_OK)
    {
        // Try launching with empty desktop
        ZeroMemory(&si, sizeof(si));
        si.cb = sizeof(si);
        si.lpDesktop = L"";

        // Recreate the args string
        StringCchPrintf(szArgs, ARRAY_SIZE(szArgs)-1,
                   L"%s %u %u %d %u %u %u %u %u %s", 
                   WP_MODULE_FULL_NAME_L,
                   dwPID, m_dwProcessNumber, iNumSyncPipes, 
                   g_dwRPCAuthLevel, g_dwRPCImperLevel, dwMask,
                   g_dwMaxWorkerThreads, g_dwMaxIoThreads,
                   szRandom);

        // Try again
        hr = LaunchWP(szProgram, szArgs, hWPToken, &si, pSA, pEnvironment);
    }
    ON_ERROR_EXIT();

    // Add this process to the history table
    m_tLastHeardFromWP.SnapCurrentTime();
    m_tLastResponse.SnapCurrentTime();
    m_oHistoryEntry.dwInternalProcessNumber = m_dwProcessNumber;
    GetSystemTimeAsFileTime((FILETIME *) &m_oHistoryEntry.tmCreateTime);
    CHistoryTable::AddEntry(m_oHistoryEntry);


    ////////////////////////////////////////////////////////////
    // Step 10: Start reading on the two pipes
    hr = m_oAsyncPipe.StartRead();
    ON_ERROR_EXIT();

    for(iter=0; iter<iNumSyncPipes; iter++)
    {
        hr = m_oAckReciever.StartRead(0, iter);
        ON_ERROR_EXIT();
    }

    if (WaitForSingleObject(m_hProcess, 0) != WAIT_TIMEOUT)
        EXIT_WITH_HRESULT(E_FAIL);

    //////////////////////////////////////////////////////////////////////
    // Step 11: Successfully started the process
    m_eProcessStatus = EProcessState_Running;

    // Increment the worker process counters
    m_fUpdatePerfCounter = TRUE;
    PerfIncrementGlobalCounter(ASPNET_WPS_RUNNING_NUMBER);


    if (hWPToken != NULL)
    {
        HANDLE  hProcessToken = NULL;
        fRet = OpenProcessToken(m_hProcess, TOKEN_ALL_ACCESS, &hProcessToken);
        ON_ZERO_CONTINUE_WITH_LAST_ERROR(fRet);

        if (hProcessToken != NULL && fRet)
        {
            fRet = SetKernelObjectSecurity(hProcessToken, DACL_SECURITY_INFORMATION, &sd);
            ON_ZERO_CONTINUE_WITH_LAST_ERROR(fRet);
            CloseHandle(hProcessToken);
        }

        hr = S_OK;
    }

 Cleanup:
    if (hr != S_OK)
    {
        if (g_iLogLevel != 0)
            XspLogEvent(IDS_EVENTLOG_WP_LAUNCH_FAILED, L"%X", hr);
        Close(TRUE);
    }

    if (m_hStartupEvent != NULL)
        SetEvent(m_hStartupEvent);
    if (pEnvironment != NULL)
        DestroyEnvironmentBlock(pEnvironment);


    DELETE_BYTES(pACL);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
HRESULT
CProcessEntry::LaunchWP(
        LPWSTR                   szProgram, 
        LPWSTR                   szArgs, 
        HANDLE                   hToken, 
        LPSTARTUPINFO            pSI,
        LPSECURITY_ATTRIBUTES    pSA,
        LPVOID                   pEnvironment)
{
    HANDLE                  hArray[2];
    PROCESS_INFORMATION     pi;
    HRESULT                 hr = S_OK;    
    DWORD                   dwRet;
    DWORD                   dwFlags = CREATE_NO_WINDOW;

    if (pEnvironment != NULL)
        dwFlags |= CREATE_UNICODE_ENVIRONMENT;

    ZeroMemory(&pi, sizeof(pi));
    if (hToken == NULL)
    {
        if ( CreateProcess(szProgram, szArgs, NULL, NULL, FALSE, 
                           dwFlags, pEnvironment, NULL, pSI, &pi)
             == FALSE)
        {
            EXIT_WITH_LAST_ERROR();        
        }
    }
    else
    {
        if ( CreateProcessAsUser(hToken, szProgram, szArgs, pSA, pSA, FALSE, 
                                 dwFlags, pEnvironment, NULL, pSI, &pi)
             == FALSE)
        {
            EXIT_WITH_LAST_ERROR();        
        }
    }

    CloseHandle(pi.hThread);
    m_hProcess = pi.hProcess;
    
    ////////////////////////////////////////////////////////////
    // Wait at most MAX_WAIT_TIME_FOR_PROCESS_START seconds
    //         for the process to startup
    hArray[0] = m_hPingRespondEvent;
    hArray[1] = m_hProcess;
    dwRet = WaitForMultipleObjects(2, hArray, FALSE, MAX_WAIT_TIME_FOR_PROCESS_START * 1000);
    switch(dwRet)
    {
    case WAIT_OBJECT_0: // Normal case
        break;

    case WAIT_TIMEOUT: // Timed out
        EXIT_WITH_WIN32_ERROR(ERROR_TIMEOUT);
        
    default: // Process died during startup
        //DWORD dwErr;
        //GetExitCodeProcess(m_hProcess, &dwErr);
        
        EXIT_WITH_HRESULT(E_FAIL);
    }
    
    if (WaitForSingleObject(m_hProcess, 0) != WAIT_TIMEOUT)
        EXIT_WITH_HRESULT(E_FAIL);
    m_oHistoryEntry.dwPID = pi.dwProcessId; 

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DTor
CProcessEntry::~CProcessEntry()
{
    Close(TRUE);

    DeleteCriticalSection(&m_oCSPing);
    DeleteCriticalSection(&m_oCSPIDAdujustment);
}

/////////////////////////////////////////////////////////////////////////////
// Wait For the Process To Start: i.e. wait for the Init function to return
void
CProcessEntry::WaitForProcessToStart()
{
    if (g_fShuttingDown == TRUE)
        return;

    if (m_eProcessStatus == EProcessState_Starting)
        WaitForSingleObject(m_hStartupEvent, INFINITE);
}

/////////////////////////////////////////////////////////////////////////////
//
BOOL 
CProcessEntry::BreakIntoProcess() 
{
    // use global ::IsUnderDebugger which ignores UnderDebugger regkey
    if (::IsUnderDebugger(m_hProcess))
    {
        return RemoteBreakIntoProcess(m_hProcess);
    }
    else
    {
        return FALSE;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
void
CProcessEntry::UpdateStatusInHistoryTable (EReasonForDeath eReason)
{
    m_oHistoryEntry.eReason =  EReasonForDeath(int(m_oHistoryEntry.eReason) | int(eReason));
    m_oHistoryEntry.dwRequestsPending = 0; //(DWORD) m_lRequestsPending;
    m_oHistoryEntry.dwRequestsExecuted = (DWORD) m_lRequestsExecuted;
    m_oHistoryEntry.dwRequestsExecuting = (DWORD) m_lRequestsExecuting;
    CHistoryTable::UpdateEntry(m_oHistoryEntry);
}

/////////////////////////////////////////////////////////////////////////////
//
DWORD
CProcessEntry::GetSecondsSinceLastResponse()
{
    return m_tLastResponse.AgeInSeconds();
}

/////////////////////////////////////////////////////////////////////////////
// Get the current status of the process
EProcessState
CProcessEntry::GetUpdatedStatus()
{
    if (m_eProcessStatus != EProcessState_Dead)
    { // If not dead, check the pipes
        if ( m_hProcess                ==  INVALID_HANDLE_VALUE || 
             m_oAsyncPipe.IsAlive()    ==  FALSE                ||
             m_oAckReciever.IsAlive()  ==  FALSE                ||
             ( m_lRequestsExecuting == 0 && m_fShuttingDown == TRUE ) ||
             WaitForSingleObject(m_hProcess, 0) != WAIT_TIMEOUT  )            
        { // It's dead!
            Close(FALSE);
        }
        else
        { // Pulse the sync event
            if (m_fAnyReqsSinceLastPing && m_fDebugStatus == FALSE)
            {
                DWORD dwFreq, dwTimeout;
                CProcessTableManager::GetPingConfig(dwFreq, dwTimeout);
                if (m_tLastHeardFromWP.AgeInSeconds() > dwFreq) 
                {
                    m_fAnyReqsSinceLastPing = FALSE;
                    EnterCriticalSection(&m_oCSPing);
                    if (!ResetEvent(m_hPingRespondEvent))
                    {
                        m_dwResetPingEventError = g_dwResetPingEventError = GetLastError();
                    }
                    else
                    {
                        m_dwResetPingEventError = 0;
                    }

                    SetEvent(m_hPingSendEvent);
                    if (m_dwResetPingEventError != 0 || WaitForSingleObject(m_hPingRespondEvent, dwTimeout * 1000) != WAIT_OBJECT_0) 
                    { // Ping Failed
                        if (!IsProcessUnderDebugger())
                        { 
                            UpdateStatusInHistoryTable(EReasonForDeath_PingFailed);
                            Close(FALSE);
                        }
                        else
                        {
                            m_dwResetPingEventError = 0;
                        }
                    }
                    m_tLastHeardFromWP.SnapCurrentTime();
                    LeaveCriticalSection(&m_oCSPing);
                }
            }
        }        
    }
    return m_eProcessStatus;
}

/////////////////////////////////////////////////////////////////////////////
// Is the wp under a debugger

BOOL
CProcessEntry::IsProcessUnderDebugger()
{
    BOOL fUnderDebugger = FALSE;
    if (HackGetDebugReg(fUnderDebugger))
        return fUnderDebugger;
    
    if (m_fDebugStatus)
        return TRUE;

    return ::IsUnderDebugger(m_hProcess);
}

/////////////////////////////////////////////////////////////////////////////
// Execute work items for a request
void
CProcessEntry::ExecuteWorkItemsForRequest(
        LONG  lReqID, 
        CAsyncPipeOverlapped *  pOver)
{
    BOOL fComingBackFromAsyncWork = (pOver != NULL);

    if (pOver != NULL)
        m_oAsyncPipe.ReturnResponseBuffer(pOver);
        

    do { // Do till there are no work items remaining
        
        BYTE *          pMsg   = NULL;
        EWorkItemType   eType;
        BOOL            fAsyncCompletion = FALSE;

        if (g_fShuttingDown == TRUE)
        {
            if (fComingBackFromAsyncWork)
                CRequestTableManager::BlockWorkItemsQueue(lReqID, FALSE);
            return;
        }

        if (fComingBackFromAsyncWork == FALSE)
        {
            ////////////////////////////////////////////////////////////
            // Step 1: Try to get exclusive access to the work items Q for this request
            if (CRequestTableManager::BlockWorkItemsQueue(lReqID, TRUE) != S_OK)
                return; // If didn't get => some other thread is executing the work items
        }

        fComingBackFromAsyncWork = FALSE;

        ////////////////////////////////////////////////////////////
        // Step 2: While we can successfully extract a work item from the Q
        while(CRequestTableManager::RemoveWorkItem(lReqID, eType, &pMsg) == S_OK)
        {
            if (g_fShuttingDown == TRUE)
            {
                CRequestTableManager::BlockWorkItemsQueue(lReqID, FALSE);
                break;
            }

            switch(eType)
            {
            case EWorkItemType_SyncMessage:
                m_oAckReciever.ProcessSyncMessage((CSyncMessage *) pMsg, FALSE);
                break;
            case EWorkItemType_ASyncMessage:
                fAsyncCompletion = ProcessResponse((CAsyncPipeOverlapped *) pMsg);
                if (fAsyncCompletion == TRUE)
                    return;
                else
                    break;
            case EWorkItemType_CloseWithError:
                CleanupRequest(lReqID);
                return;
            }
        }

        ////////////////////////////////////////////////////////////
        // Step 3: Free the blockade
        CRequestTableManager::BlockWorkItemsQueue(lReqID, FALSE);

        if (g_fShuttingDown == TRUE)
            break;

        // There is a small chance that a thread may slip in and add a 
        //    a work item between the time we call the last RemoveWorkItem 
        //    and BlockWorkItemsQueue. Calling an un-protected AnyWorkItemsInQueue
        //    deals with this scenario

    }
    while(CRequestTableManager::AnyWorkItemsInQueue(lReqID));
}

/////////////////////////////////////////////////////////////////////////////
// Got a response, deal with it: Return value: Async completion
BOOL
CProcessEntry::ProcessResponse(
        CAsyncPipeOverlapped * pOver)
{
    // If shutting down, do nothing
    if (g_fShuttingDown == TRUE)
        return FALSE;

    HRESULT          hr        = S_OK;
    int              iMiscInfo = 0;
    CRequestEntry    oEntry;
    BOOL             fAsyncCompletion = FALSE;
    CAsyncMessage *  pMsg      = (pOver ? &(pOver->oMsg) : NULL);

    ////////////////////////////////////////////////////////////
    // Step 0: Check args
    if (pMsg == NULL)
    {
        ASSERT(0);
        EXIT_WITH_HRESULT(E_INVALIDARG);                
    }

    ////////////////////////////////////////////////////////////
    // Step 1: Get the request from the table
    hr = CRequestTableManager::GetRequest(pMsg->oHeader.lRequestID, oEntry);
    ON_ERROR_EXIT();
    if (oEntry.iECB == 0)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    ////////////////////////////////////////////////////////////
    // Step 1b: Deal with close connection
    if ( pMsg->oHeader.eType == EMessageType_CloseConnection)
    {
        EcbCloseConnection(oEntry.iECB);
    }

    ////////////////////////////////////////////////////////////
    // Step 2: If it's a response, deal with it
    if ( pMsg->oHeader.eType == EMessageType_Response || 
         pMsg->oHeader.eType == EMessageType_Response_And_DoneWithRequest ||
         pMsg->oHeader.eType == EMessageType_Response_ManagedCodeFailure  )
    {
        CResponseStruct * pResponseStruct = reinterpret_cast<CResponseStruct *> (pMsg->pData);

        iMiscInfo = pResponseStruct->iMiscInfo;

        DWORD dwStrSize = pMsg->oHeader.lDataLength - sizeof(CResponseStruct) + 4;
        ////////////////////////////////////////////////////////////
        // Step 3: Call the appropiate EcbXXX function
        switch(pResponseStruct->eWriteType)
        {
        case EWriteType_WriteHeaders:       {
            int     iLen1     = SafeStringLenghtA((LPCSTR) pResponseStruct->bufStrings, dwStrSize);
            if (iLen1 < 0)
            {
                ASSERT(FALSE);
                InterlockedIncrement(&g_lSecurityIssueBug129921_b);
                EXIT_WITH_HRESULT(E_UNEXPECTED);
            }
            LPCSTR  szStatus  = (LPCSTR) pResponseStruct->bufStrings;
            int     iLen2     = SafeStringLenghtA((LPCSTR) &pResponseStruct->bufStrings[iLen1+1], dwStrSize-iLen1-1);
            if (iLen2 < 0)
            {
                ASSERT(FALSE);
                InterlockedIncrement(&g_lSecurityIssueBug129921_b);
                EXIT_WITH_HRESULT(E_UNEXPECTED);
            }
            LPCSTR  szHead    = (LPCSTR) &szStatus[iLen1+1];
            
            EcbWriteHeaders(oEntry.iECB, 
                            szStatus, 
                            szHead, 
                            pResponseStruct->iMiscInfo);
        }
        break;

        case EWriteType_WriteBytes:
            if (pResponseStruct->iMiscInfo > (int) dwStrSize)
            {
                ASSERT(FALSE);
                InterlockedIncrement(&g_lSecurityIssueBug129921_c);
                EXIT_WITH_HRESULT(E_UNEXPECTED);
            }
            EcbWriteBytes(oEntry.iECB,
                          (void *) pResponseStruct->bufStrings,
                          pResponseStruct->iMiscInfo);            
            break;

        case EWriteType_AppendToLog:
            {
                int iLen1 = SafeStringLenghtA((LPCSTR) pResponseStruct->bufStrings, dwStrSize);
                if (iLen1 < 0)
                {
                    ASSERT(FALSE);
                    InterlockedIncrement(&g_lSecurityIssueBug129921_d);
                    EXIT_WITH_HRESULT(E_UNEXPECTED);
                }            
                EcbAppendLogParameter(oEntry.iECB, 
                                      (LPCSTR) pResponseStruct->bufStrings);
            }
            break;

        case EWriteType_None:
            break;

        case EWriteType_FlushCore:
            fAsyncCompletion = FlushCore(oEntry.iECB, pOver);
            if (!fAsyncCompletion)
                iMiscInfo = pResponseStruct->iMiscInfo;            
            break;

        case EWriteType_Unknown:
        default:
            ASSERT(0);
            break;
        }
    }

    
    ////////////////////////////////////////////////////////////
    // Step 4: Deal with Done-With-Session
    if (!fAsyncCompletion && (pMsg->oHeader.eType == EMessageType_Response_And_DoneWithRequest ||
                              pMsg->oHeader.eType == EMessageType_Response_ManagedCodeFailure   ))
    {
        if (pMsg->oHeader.eType == EMessageType_Response_ManagedCodeFailure)
        {
            CResponseStruct * pResponseStruct = reinterpret_cast<CResponseStruct *> (pMsg->pData);
            LPDWORD  pdwErrorPoint = (LPDWORD) & (pResponseStruct->bufStrings);
            UINT     iStringID     = 0;
            WCHAR    szError[256];

            switch(*pdwErrorPoint)
            {
            case 1:
                iStringID = IDS_EVENTLOG_UNABLE_TO_EXEC_REQ_INTERNAL;
                break;
            case 2:
                iStringID = IDS_EVENTLOG_UNABLE_TO_EXEC_REQ_GET_APP_DOMAIN;
                break;
            case 3:
                iStringID = IDS_EVENTLOG_UNABLE_TO_EXEC_REQ_QI_ASPNET;
                break;
            case 4:
                iStringID = IDS_EVENTLOG_UNABLE_TO_EXEC_REQ_GAC_INACCESSIBLE;
                break;
            case 5:
                break;
            default:
                iStringID = IDS_EVENTLOG_UNABLE_TO_EXEC_REQ_UNKNOWN;
                break;
            }
            
            if (iStringID)
            {
                GetStringForHresult(szError, ARRAY_SIZE(szError), (HRESULT) iMiscInfo);
                XspLogEvent(iStringID, szError);
            }
            ReportHttpErrorIndirect(oEntry.iECB, IDS_MANAGED_CODE_FAILURE);
            iMiscInfo = 0;
        }

        OnRequestComplete(pMsg->oHeader.lRequestID, oEntry.iECB, iMiscInfo);
    }

 Cleanup:
    ZeroMemory(&oEntry, sizeof(oEntry));
    if (!fAsyncCompletion && pMsg != NULL)
    {
        m_oAsyncPipe.ReturnResponseBuffer(pOver);
    }

    return fAsyncCompletion;
}

/////////////////////////////////////////////////////////////////////////////
// Send a Kill message to the process
void
CProcessEntry::SendKillMessage(int iImmediate)
{
    if (iImmediate == 1)
        m_fKillImmSent = TRUE;

    if (g_fShuttingDown == TRUE || m_eProcessStatus != EProcessState_Running)
        return;

    HRESULT                 hr    = S_OK;
    CAsyncPipeOverlapped *  pOver = NULL;

    m_fShuttingDown = TRUE;

    ////////////////////////////////////////////////////////////
    // Step 1: Alloc the message buffer
    hr = m_oAsyncPipe.AllocNewMessage(4, &pOver);
    ON_ERROR_EXIT();
    ON_OOM_EXIT(pOver);

    ////////////////////////////////////////////////////////////
    // Step 2: Set the message header
    switch(iImmediate)
    {
    case 1:        
        pOver->oMsg.oHeader.eType = EMessageType_ShutdownImmediate;
        break;
    case 2:
        pOver->oMsg.oHeader.eType = EMessageType_Debug;
        break;
    default:
        pOver->oMsg.oHeader.eType = EMessageType_Shutdown;
    }

    pOver->dwBufferSize = pOver->dwNumBytes = sizeof(CAsyncMessageHeader);

    ////////////////////////////////////////////////////////////
    // Step 3: Write to the worker process
    hr = m_oAsyncPipe.WriteToProcess(pOver);
    pOver = NULL;
    ON_ERROR_EXIT();

    ////////////////////////////////////////////////////////////
    // Step 4: The kodak moment
    m_tLastKillTime.SnapCurrentTime();
    if (m_tFirstKillTime.IsSet() == FALSE)
        m_tFirstKillTime.SnapCurrentTime();

 Cleanup:
    if (hr != S_OK && pOver != NULL)
        DELETE_BYTES(pOver);
    return;
}

/////////////////////////////////////////////////////////////////////////////
// Terminate the worker process
void
CProcessEntry::Terminate()
{
    if (g_fShuttingDown == TRUE)
        return;

    ////////////////////////////////////////////////////////////
    // Step 1: Close the pipes: This *should* work
    m_oAsyncPipe.Close();
    m_oAckReciever.Close();        

    ////////////////////////////////////////////////////////////
    // Step 2: Check if the process is running
    DWORD dwExitCode = 0;
    if ( m_hProcess != INVALID_HANDLE_VALUE          && 
         GetExitCodeProcess(m_hProcess, &dwExitCode) && 
         dwExitCode == STILL_ACTIVE                   )
    {
        Sleep(100); // Give the process one last chance
    }

    Close(TRUE);
    UpdateStatusInHistoryTable(EReasonForDeath_Terminated);

    m_tTerminateTime.SnapCurrentTime();
}

/////////////////////////////////////////////////////////////////////////////
// Send a request to the worker process
HRESULT
CProcessEntry::SendRequest(EXTENSION_CONTROL_BLOCK * iECB, LONG lReqID)
{
    if (g_fShuttingDown == TRUE)
        return E_FAIL;

    m_fAnyReqsSinceLastPing = TRUE;
    // Idicate that we are not idle
    m_tTimeIdle.Reset();

    CAsyncPipeOverlapped *   pOver = NULL;
    HRESULT                  hr    = S_OK;

    ////////////////////////////////////////////////////////////
    // Step 0: Don't send a request if we've already sent a 
    //          shutdown message or the process is not running
    if (m_eProcessStatus ==  EProcessState_Starting)
        WaitForProcessToStart();

    if ( m_fShuttingDown ==  TRUE                  || 
         m_eProcessStatus   !=  EProcessState_Running  )
    {
        EXIT_WITH_HRESULT(E_FAIL);
    }


    ////////////////////////////////////////////////////////////
    // Step 1: Package the request
    hr = PackageRequest(iECB, lReqID, &pOver);
    ON_ERROR_EXIT();

    // Again, don't send a request if we've already sent a shutdown message
    if ( m_eProcessStatus   != EProcessState_Running || 
         m_fShuttingDown == TRUE                   )
    {
        EXIT_WITH_HRESULT(E_FAIL);
    }

    // Update requests executing count for cpu
    m_pParent->IncrementActiveRequestCount(1);

    // if there are no requests executing, we need to update the last response time
    // because of our deadlock detection mechanism 
    if (m_lRequestsExecuting == 0)
        m_tLastResponse.SnapCurrentTime(); 

    // Update requests executing count for process
    InterlockedIncrement(&m_lRequestsExecuting);
    PerfIncrementGlobalCounter(ASPNET_REQUESTS_CURRENT_NUMBER);
    PerfIncrementGlobalCounter(ASPNET_REQUESTS_QUEUED_NUMBER);

    ////////////////////////////////////////////////////////////
    // Step 2: Write to the worker process
    hr = m_oAsyncPipe.WriteToProcess(pOver);
    pOver = NULL;
 
    if (hr != S_OK) 
    {
      // Update requests executing count for cpu and process
      m_pParent->IncrementActiveRequestCount(-1);
      InterlockedDecrement(&m_lRequestsExecuting);
      PerfDecrementGlobalCounter(ASPNET_REQUESTS_CURRENT_NUMBER);
      PerfDecrementGlobalCounter(ASPNET_REQUESTS_QUEUED_NUMBER);
      EXIT();
    }

 Cleanup:
    if (hr != S_OK && pOver != NULL)
        DELETE_BYTES(pOver);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Package a request
HRESULT
CProcessEntry::PackageRequest(EXTENSION_CONTROL_BLOCK * pECB, LONG lReqID, CAsyncPipeOverlapped ** ppOut)
{
    HRESULT      hr          = S_OK;

    // Temp buffers to hold the ecb-basics, query strings, posted data
    //   and server variables
    int   iContentInfo       [4] = {0, 0, 0, 0};
    BYTE  bTempBuf           [1000];

    // Are the strings from ecb-baisics stored in bTempBuf?
    BOOL  fBasicInBuffer     = FALSE;

    // Length of the query string
    int   iQueryStrSize      = 0;

    // Size of the posted data
    int   iPostedDataSize    = 0;

    // Get the Ecb basics
    int   iBasicSize         = 0;

    // Current filled position whithin bTempBuf
    int   iTempPos           = 0;

    // Total length, in bytes
    int   iTotalLen          = 0;

    // Total size (in bytes) of pre-packaged server variables
    int   iServerVariablesSize = 0;

    // Position of each server-var in bTempBuf
    int   iLenArray     [NUM_SERVER_VARS];

    // Return value for an EcbXXX function
    int   iRet               = 0;

    // The message data is a request struct 
    CRequestStruct * pReqStruct = NULL;

    // Pos whithin pReqStruct->bufStrings for the current server variable
    int   iPos               = 0;

    // Size of header of each server variable
    int   iter          = 0;  

    char  bOne[2];

    ////////////////////////////////////////////////////////////
    // Step 0: Check args
    if ( ppOut == NULL || lReqID == 0 || pECB == NULL)
    {
        EXIT_WITH_HRESULT(E_INVALIDARG);
    }

    (*ppOut) = NULL;

    //////////////////////////////////////////////////////////////////////
    // Step 1: Calculate the buffer size required to store the ecb-baiscs,
    //         query-string, posted data and (some) server variables for this
    //         request

    ////////////////////////////////////////////////////////////
    // Step 1a: Length of the query string
    iQueryStrSize      = 1 + ((pECB->lpszQueryString != NULL) ? 
                              lstrlenA(pECB->lpszQueryString) : 0);
    ROUND_TO_4_BYTES(iQueryStrSize);

    ////////////////////////////////////////////////////////////
    // Step 1b: Size of the posted data
    iPostedDataSize    = pECB->cbAvailable;
    ROUND_TO_4_BYTES(iPostedDataSize);

    ////////////////////////////////////////////////////////////
    // Step 1c: Get the Ecb basics
    iBasicSize  = EcbGetBasics(pECB, 
                               (LPSTR) bTempBuf, 
                               sizeof(bTempBuf), 
                               iContentInfo);
    if (iBasicSize == 0)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    // Examine return value of ecb-basics
    if (iBasicSize < 0) // -ve implies that the return value is the -ve
                        // of the size required
    {
        iBasicSize        = -iBasicSize; 
        fBasicInBuffer    = FALSE;
        iTempPos          = 0;
    }
    else
    {
        // Correct size of ecb-basic strings
        iBasicSize        = lstrlenA((LPSTR) bTempBuf) + 1; 

        // Yes, ecb-basic strings are in bTempBuf
        fBasicInBuffer    = TRUE;      

        // Current filled position whithin bTempBuf
        iTempPos          = iBasicSize;
    }

    ROUND_TO_4_BYTES(iBasicSize);


    // For each server variable
    for (iter=0; iter<NUM_SERVER_VARS; iter++)
    { 
        iLenArray[iter] = CProcessTableManager::GetServerVariable(pECB, g_szServerVars[iter], bOne, 0);

        if (iLenArray[iter] > 0)
            EXIT_WITH_HRESULT(E_FAIL);

        // Actual len of the server variable
        iLenArray[iter] = -iLenArray[iter];   

        // Calculate the space required to store this server variable
        iServerVariablesSize += iLenArray[iter] + 1;
    }

    //////////////////////////////////////////////////////////////////////
    // Step 2: Calcuate the total length of buffer required for this request
    iTotalLen = 
        sizeof(CRequestStruct) - 4 +  // Size of CRequestStruct - sizeof CRequestStruct::buf
        iBasicSize +                  // Size of EcbBasic strings
        iQueryStrSize +               // Size of the Query string
        iPostedDataSize +             // Size of the posted data
        iServerVariablesSize;         // Size of the server variables

    //////////////////////////////////////////////////////////////////////
    // Step 3: Alloc a message of this length
    hr = m_oAsyncPipe.AllocNewMessage(iTotalLen, ppOut);
    ON_ERROR_EXIT();
    ASSERT((*ppOut) != NULL);

    //////////////////////////////////////////////////////////////////////
    // Step 4: Set this messaages header correctly
    (*ppOut)->oMsg.oHeader.eType          = EMessageType_Request;
    (*ppOut)->oMsg.oHeader.lRequestID     = lReqID;
    (*ppOut)->oMsg.oHeader.lDataLength    = iTotalLen;
    (*ppOut)->dwNumBytes                  = sizeof(CAsyncMessageHeader) + iTotalLen;
    (*ppOut)->dwBufferSize                = (*ppOut)->dwNumBytes;

    //////////////////////////////////////////////////////////////////////
    // Step 5: Set the message contents

    // The message data is a request struct 
    pReqStruct = reinterpret_cast<CRequestStruct *> ((*ppOut)->oMsg.pData); 

    GetSystemTimeAsFileTime((FILETIME *) &(pReqStruct->qwRequestStartTime));

    ////////////////////////////////////////////////////////////
    // Step 5a: Copy the info for EcbGetBasics
    
    if (fBasicInBuffer == TRUE)
    {        
        memcpy(pReqStruct->bufStrings, bTempBuf, iBasicSize);
    }
    else
    {
        iRet = EcbGetBasics(pECB, 
                            (LPSTR) pReqStruct->bufStrings, 
                            iBasicSize, 
                            iContentInfo);
        if (iRet <= 0)
            EXIT_WITH_HRESULT(E_UNEXPECTED);        
    }
    memcpy(pReqStruct->iContentInfo, iContentInfo, sizeof(iContentInfo));


    ////////////////////////////////////////////////////////////
    // Step 5b: Copy the Query string
    pReqStruct->iQueryStringOffset = iBasicSize;
    if (iQueryStrSize > 0 && pECB->lpszQueryString != NULL)
    {
      StringCchCopyA((LPSTR) &pReqStruct->bufStrings[iBasicSize], iQueryStrSize,
		     pECB->lpszQueryString);
    }
    else
    {
        pReqStruct->bufStrings[iBasicSize] = NULL;
    }

    ////////////////////////////////////////////////////////////
    // Step 5c: Copy the posted content
    pReqStruct->iPostedDataOffset = pReqStruct->iQueryStringOffset + 
                                    iQueryStrSize;

    pReqStruct->iPostedDataLen = pECB->cbAvailable;
    if (iPostedDataSize > 0)
    {
        iRet = EcbGetPreloadedPostedContent(
                pECB, 
                &pReqStruct->bufStrings[pReqStruct->iPostedDataOffset],
                iPostedDataSize);
    }

    ////////////////////////////////////////////////////////////
    // Step 5d: Copy the server variables
  

    // Staring point of all server variable in pReqStruct->bufStrings
    pReqStruct->iServerVariablesOffset = pReqStruct->iPostedDataOffset + iPostedDataSize;

    // Pos whithin pReqStruct->bufStrings for the current server variable
    iPos = pReqStruct->iServerVariablesOffset;

    // For each server variable
    for(iter=0; iter<NUM_SERVER_VARS; iter++)
    {
        if (iLenArray[iter] > 0)
        {
            // Get it from Ecb
            iRet = CProcessTableManager::GetServerVariable(
                    pECB, 
                    g_szServerVars[iter], 
                    (LPSTR) &pReqStruct->bufStrings[iPos],
                    iLenArray[iter] + 1);
        }                    

        iPos += iLenArray[iter]+1; // Increment the iPos postion

        // Put a Tab at the end
        pReqStruct->bufStrings[iPos-1] = '\t';
    }


    // Null Terminate the server vars collection
    pReqStruct->bufStrings[iPos-1] = NULL;
    ASSERT (iPos + int(sizeof(CRequestStruct)) - 4 == iTotalLen);

    pReqStruct->iUserToken = GetImpersonationToken(pECB); 
    pReqStruct->iUNCToken  = pReqStruct->iUserToken;
    pReqStruct->dwWPPid    = m_oHistoryEntry.dwPID;

    //////////////////////////////////////////////////////////////////////
    // Done packaging the request
    hr = S_OK;

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// 
HANDLE
CProcessEntry::GetImpersonationToken(
        EXTENSION_CONTROL_BLOCK *   pECB)
{
    HANDLE     hHandle = NULL;
    HANDLE     hReturn = NULL;
    BOOL       fSidPresent=FALSE;
    
    BOOL fRet = (*pECB->ServerSupportFunction)(
                            pECB->ConnID,
                            HSE_REQ_GET_IMPERSONATION_TOKEN,
                            &hHandle,
                            NULL,
                            NULL
                            );

    if (fRet == FALSE || hHandle == NULL)
        return 0;

    if (CProcessTableManager::GetWorkerProcessSid() != NULL)  
        CRegAccount::AddSidToToken(hHandle, CProcessTableManager::GetWorkerProcessSid(), &fSidPresent);
    
    fRet = DuplicateHandle( 
                  GetCurrentProcess(),
                  hHandle,
                  m_hProcess,
                  &hReturn,
                  0,
                  TRUE,
                  DUPLICATE_SAME_ACCESS);
    return fRet ?  hReturn : 0;
}

/////////////////////////////////////////////////////////////////////////////
// 
HANDLE
CProcessEntry::ConvertToken(
        HANDLE hHandle)
{
    HANDLE     hReturn    = NULL;
    BOOL       fSidPresent=FALSE;
    HRESULT    hr         = S_OK;

    if (CProcessTableManager::GetWorkerProcessSid() != NULL)  
        CRegAccount::AddSidToToken(hHandle, CProcessTableManager::GetWorkerProcessSid(), &fSidPresent);
    
    BOOL fRet = DuplicateHandle( 
            GetCurrentProcess(),
            hHandle,
            m_hProcess,
            &hReturn,
            0,
            TRUE,
            DUPLICATE_SAME_ACCESS);    
    ON_ZERO_CONTINUE_WITH_LAST_ERROR(fRet);
    CloseHandle(hHandle);
    return fRet ?  hReturn : 0;
}

/////////////////////////////////////////////////////////////////////////////
// 

HANDLE
CProcessEntry::OnGetImpersonationToken(
        DWORD                       dwPID,
        EXTENSION_CONTROL_BLOCK *   iECB)        
{
    if (dwPID != m_oHistoryEntry.dwPID)
    {        
        EnterCriticalSection(&m_oCSPIDAdujustment);
        if (dwPID != m_oHistoryEntry.dwPID)
        {
            m_hProcess = OpenProcess(
                    PROCESS_ALL_ACCESS,
                    FALSE,
                    dwPID);
            m_oHistoryEntry.dwPID = dwPID;
        }
        LeaveCriticalSection(&m_oCSPIDAdujustment);
    }

    return GetImpersonationToken(iECB); 
}
/////////////////////////////////////////////////////////////////////////////
// A write to worker process completed: free buffers etc...
void
CProcessEntry::OnWriteComplete (CAsyncPipeOverlapped * pMsg)
{
    if (pMsg == NULL || pMsg->dwRefCount == 0)
        return;

    if (InterlockedDecrement(&pMsg->dwRefCount) == 0)
        DELETE_BYTES(pMsg);
}

/////////////////////////////////////////////////////////////////////////////
// The process died: Inform my parent (the CPUEntry)
void 
CProcessEntry::OnProcessDied()
{
    // Tell the CPU: "I died"
    Close(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// An ack for a request is recved
HRESULT
CProcessEntry::OnAckReceived(EAsyncMessageType eAckForType, LONG lRequestID)
{
    HRESULT  hr = S_OK;

    switch(eAckForType)
    {
    case EMessageType_Request:
        hr = CRequestTableManager::UpdateRequestStatus(
                                      lRequestID,
                                      ERequestStatus_Executing);
        break;

    case EMessageType_Shutdown:
    case EMessageType_ShutdownImmediate:
        // Tell the parent
        m_pParent->OnShutdownAcknowledged(this);

        // Set state appropiately
        m_eProcessStatus = EProcessState_Stopping;
        hr = S_OK;
        break;

    case EMessageType_CloseConnection:
    case EMessageType_Response_ManagedCodeFailure:
    case EMessageType_GetDataFromIIS:
    case EMessageType_Response_And_DoneWithRequest:
    case EMessageType_Response:
    case EMessageType_Response_Empty:
    case EMessageType_Unknown:
    case EMessageType_Debug:
    default:
        hr = E_FAIL;
        ASSERT(0);
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Close all pipes
void
CProcessEntry::Close(BOOL fCallTerminateProcess)
{
    if (InterlockedIncrement(&m_lCloseCalled) == 1)
    {
        m_oAckReciever.Close();
        m_oAsyncPipe.Close();
        m_eProcessStatus = EProcessState_Dead;

        if (m_hProcess != INVALID_HANDLE_VALUE)
        {
            Sleep(1);
            if (fCallTerminateProcess && !g_fShuttingDown)
                TerminateProcess(m_hProcess, 1);        
            CloseHandle(m_hProcess);
            m_hProcess = INVALID_HANDLE_VALUE;
        }
        if (m_hStartupEvent != NULL)
        {
            CloseHandle(m_hStartupEvent);
            m_hStartupEvent = NULL;
        }
        if (m_hPingSendEvent != NULL)
        {
            CloseHandle(m_hPingSendEvent);
            m_hPingSendEvent = NULL;
        }
        if (m_hPingRespondEvent != NULL)
        {
            CloseHandle(m_hPingRespondEvent);
            m_hPingRespondEvent = NULL;
        }
        
        m_eProcessStatus = EProcessState_Dead;

        GetSystemTimeAsFileTime((FILETIME *) &m_oHistoryEntry.tmDeathTime);
        if (!g_fShuttingDown)
        {
            UpdateStatusInHistoryTable(EReasonForDeath_ShutDown);
            if (m_pParent != NULL)
                m_pParent->OnProcessDeath(this);
            if (m_fUpdatePerfCounter == TRUE)
                PerfDecrementGlobalCounter(ASPNET_WPS_RUNNING_NUMBER); 
            if (m_lRequestsExecuting > 0 && m_pParent != NULL) 
                m_pParent->IncrementActiveRequestCount(-m_lRequestsExecuting);
            m_lRequestsExecuting = 0;
            
            CProcessTableManager::LogWorkerProcessDeath(
                    m_oHistoryEntry.eReason, 
                    m_oHistoryEntry.dwPID);       

            // Reset the requests queued number
            CProcessTableManager::ResetRequestQueuedCounter(0);
        }
    }
}

/////////////////////////////////////////////////////////////////////////////

void
CProcessEntry::AddRef()
{
    InterlockedIncrement(&m_lRefCount);
}
/////////////////////////////////////////////////////////////////////////////

void
CProcessEntry::Release()
{
    InterlockedDecrement(&m_lRefCount);
}

/////////////////////////////////////////////////////////////////////////////
// Can this class be deleted?
BOOL
CProcessEntry::CanBeDestructed()
{
    // Not if the process is not dead
    if (GetUpdatedStatus() != EProcessState_Dead)
        return FALSE;

    if (m_lRefCount > 0) // not if ref count > 0
        return FALSE;

    // Not if the pipes have pending file oprns
    if ( m_oAckReciever.AnyPendingReadOrWrite()  || 
         m_oAsyncPipe.AnyPendingReadOrWrite()    )
    {
        return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Get the age of the process in seconds
DWORD
CProcessEntry::GetAge()
{ 
    return m_tTimeCreated.IsSet() ? m_tTimeCreated.AgeInSeconds() : 0;
}

/////////////////////////////////////////////////////////////////////////////
// Get time for which it's been idle in seconds
DWORD
CProcessEntry::GetIdleTime()
{
    return m_tTimeIdle.IsSet() ? m_tTimeIdle.AgeInSeconds() : 0;
}

/////////////////////////////////////////////////////////////////////////////
//
DWORD
CProcessEntry::GetMemoryUsed()
{
    HRESULT hr = S_OK;
    DWORD   dwRet = 0;
    DWORD   dwPeak = 0;

    hr = GetProcessMemoryInformation(m_oHistoryEntry.dwPID, &dwRet, &dwPeak, FALSE);
    ON_ERROR_EXIT();

    if (dwPeak > m_oHistoryEntry.dwPeakMemoryUsed)
    {
        m_oHistoryEntry.dwPeakMemoryUsed = dwPeak;
    }

 Cleanup:
    return dwRet;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void
CProcessEntry::OnRequestComplete(
        LONG lReqID,
        EXTENSION_CONTROL_BLOCK * iECB,
        int  iDoneWSession)
{
    if (CRequestTableManager::RemoveRequestFromTable(lReqID) == S_OK)
    {
        EcbDoneWithSession(iECB, iDoneWSession, 1);
        // Decrement the active request count
        m_pParent->IncrementActiveRequestCount(-1);  
        InterlockedDecrement(&m_lRequestsExecuting);
        InterlockedIncrement(&m_lRequestsExecuted);
        PerfDecrementGlobalCounter(ASPNET_REQUESTS_CURRENT_NUMBER);
    }

    // Check idle condition
    if (m_lRequestsExecuting == 0) 
    {
        m_tTimeIdle.SnapCurrentTime();
        if (m_fShuttingDown == TRUE)
        {
            Close(FALSE);
        }
    }
}

void
CProcessEntry::ProcessSyncMessage(
        CSyncMessage * pMsg,
        BOOL           fError)
{
    m_oAckReciever.ProcessSyncMessage(pMsg, fError);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL
CProcessEntry::FlushCore(
        EXTENSION_CONTROL_BLOCK * iECB,
        CAsyncPipeOverlapped *   pOver)
{    
    CAsyncMessage *    pMsg            = &pOver->oMsg;
    CResponseStruct *  pResponseStruct = reinterpret_cast<CResponseStruct *> (pMsg->pData);
    LPDWORD            pInts           = (LPDWORD) pResponseStruct->bufStrings;
    LPSTR              szStr           = (LPSTR) &pResponseStruct->bufStrings[4 * sizeof(DWORD)];
    BOOL               fAsync          = FALSE;
    HRESULT            hr              = S_OK;
    int                iMiscInfo       = pResponseStruct->iMiscInfo;
    CResponseContext   oContext;
    CResponseContext   * pContext      = NULL;
    LONG               lContextID      = 0;
    LONG               lReqID          = pOver->oMsg.oHeader.lRequestID;
    int                iDoneWSession   = pInts[3];


    if (!CheckFlushCoreBufferForSecurity(pOver))
    {
        ASSERT(FALSE);
        InterlockedIncrement(&g_lSecurityIssueBug129921_e);
        EXIT_WITH_HRESULT(E_UNEXPECTED);
    }

    pResponseStruct->iMiscInfo = pInts[3];

    ////////////////////////////////////////////////////////////
    // Step 1: If we are not on IIS (or if there is nothing to write),
    //         call the sync version and exit
    if (!UseTransmitFile() || (pInts[0]<=1 && pInts[2]==0))
    {
        if (pInts[0] > 1) // any headers to write?
        {
            EcbWriteHeaders(iECB, 
                            szStr, 
                            &szStr[pInts[0]], 
                            iMiscInfo);                    
        }
        if (pInts[2] > 0) // body to write
        {
            EcbWriteBytes(iECB,
                          (void *) &szStr[pInts[0] + pInts[1]],
                          pInts[2]);            
        }

        return FALSE; // FALSE => not async
    }

    ////////////////////////////////////////////////////////////
    // Step 2: Alloc memory for the context object passed to the 
    //         async function. The callback function (OnWriteBytesComplete)
    //         gets this pointer.
    ////////////////////////////////////////////////////////////
    // Step 3: Set values in the context object 
    ZeroMemory(&oContext, sizeof(oContext));    

    oContext.pProcessEntry                  = this;
    oContext.pOver                          = pOver; 
    oContext.fInAsyncWriteFunction          = TRUE; // Indicates that this thread has NOT returned from EcbWriteBytesAsync call
    oContext.dwThreadIdOfAsyncWriteFunction = GetCurrentThreadId();
    oContext.iECB                           = iECB;

    ////////////////////////////////////////////////////////////
    // Check that the status string is of valid length
    if (strlen(szStr) >= pInts[0])
    {
        ASSERT(FALSE);
        szStr[0] = NULL;
    }

    ////////////////////////////////////////////////////////////
    // Check that the header string is of valid length
    if (strlen(&szStr[pInts[0]]) >= pInts[1])
    {
        ASSERT(FALSE);
        szStr[pInts[0]] = NULL;
    }

    ////////////////////////////////////////////////////////////
    // Check that the body bytes is of valid length
    if (/*#of bytes in body*/ (SIZE_T)pInts[2]  + /*starting address*/(ULONG_PTR)(&szStr[pInts[0] + pInts[1]]) > 
        /*staring address of buffer*/(ULONG_PTR)pOver + /*total sizeof buffer*/ pOver->dwBufferSize + sizeof(CAsyncPipeOverlapped) - sizeof(CAsyncMessage))
    {
        ASSERT(FALSE);
        pInts[2] = 0;
    }

    pContext = CResponseContextHolder::Add(oContext);
    ON_OOM_EXIT(pContext);

    lContextID = pContext->lID;
    AddRef();

    if (g_iAsyncOption == 2)
    {
        if (pInts[0] > 1) // Write headers
        {
            EcbWriteHeaders(iECB, 
                            szStr, 
                            &szStr[pInts[0]], 
                            iMiscInfo);                    
        }

        fAsync = EcbWriteBytesAsync(
                iECB, 
                (void *) &szStr[pInts[0] + pInts[1]], 
                pInts[2],
                OnWriteBytesComplete,
                LongToPtr(lContextID));        
    }
    else
    {
        fAsync = EcbWriteBytesUsingTransmitFile(
                iECB, 
                szStr, 
                &szStr[pInts[0]], 
                iMiscInfo,            
                (void *) &szStr[pInts[0] + pInts[1]], 
                pInts[2],
                OnWriteBytesComplete,
                LongToPtr(lContextID));
    }

    if (fAsync && !pContext->fSyncCallback)
        InterlockedIncrement(&g_lNumAsyncPending);

    ////////////////////////////////////////////////////////////
    // Step 4: If pContext->fSyncCallback is true, that means that the 
    //  async write's callback was on the same thread -- i.e. synchronous!
    if (pContext->fSyncCallback)
    {
        CResponseContextHolder::Remove(lContextID);
        if (pContext->fSyncCallback==2)
        {
            ReturnResponseBuffer(pOver);
            DELETE_BYTES(pContext);
            Release();
            return TRUE;
        }
        DELETE_BYTES(pContext);
        Release();
        return FALSE;
    }

    ////////////////////////////////////////////////////////////
    // Step 5: Indicate that this thread has returned from the call
    //         to EcbWriteBytesAsync. This is important: the callback
    //         function can now execute more items for this request after 
    //         seeing this variable set to 0.
    pContext->fInAsyncWriteFunction = FALSE; 

    ////////////////////////////////////////////////////////////
    // Step 6: If async failed, then free the context object 
    if (!fAsync)
    {
        pContext = CResponseContextHolder::Remove(lContextID);
        if (pContext != NULL)
        {
            Release();
            ReturnResponseBuffer(pOver);
            DELETE_BYTES(pContext);
            Release();

            // Kill the request on all errors
            OnRequestComplete(lReqID, iECB, iDoneWSession);       
            fAsync = TRUE;
            hr = S_OK;
        }
    }

 Cleanup:
    if (hr != S_OK)
        fAsync = FALSE;

    return fAsync;
}

/////////////////////////////////////////////////////////////////////////////
BOOL
CProcessEntry::UseTransmitFile()
{
    if (g_iAsyncOption == 1)
        return FALSE;

    if (!g_fUseTransmitFileChecked)
    {
        g_fUseTransmitFile = 
            (GetCurrentPlatform() == APSX_PLATFORM_W2K) && 
            !_wcsicmp(Names::ExeFileName(), L"inetinfo.exe");

        g_fUseTransmitFileChecked = TRUE;
    }

    return g_fUseTransmitFile;
}

/////////////////////////////////////////////////////////////////////////////
void
CProcessEntry::ReturnResponseBuffer (CAsyncPipeOverlapped * pOver)
{
    if (pOver)
        m_oAsyncPipe.ReturnResponseBuffer(pOver);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Copied from nisapi
void
CProcessEntry::CleanupRequest(LONG lReqID)
{
    CRequestEntry  oEntry;
    if (CRequestTableManager::GetRequest(lReqID, oEntry) == S_OK && oEntry.iECB != 0)
    {
        UINT iStringID   = IDS_WORKER_PROC_STOPPED;

        if (!(m_oHistoryEntry.eReason & EReasonForDeath_ProcessCrash))
        {
            if (m_oHistoryEntry.eReason & EReasonForDeath_TimeoutExpired)
                iStringID = IDS_WORKER_PROC_RECYCLED_TIMEOUT;
            else if (m_oHistoryEntry.eReason & EReasonForDeath_IdleTimeoutExpired)
                iStringID = IDS_WORKER_PROC_RECYCLED_IDLETIMEOUT;
            else if (m_oHistoryEntry.eReason & EReasonForDeath_MaxRequestsServedExceeded)
                iStringID = IDS_WORKER_PROC_RECYCLED_REQLIMIT;
            else if (m_oHistoryEntry.eReason & EReasonForDeath_MaxRequestQLengthExceeded)
                iStringID = IDS_WORKER_PROC_RECYCLED_REQQLENGTHLIMIT;
            else if (m_oHistoryEntry.eReason & EReasonForDeath_MemoryLimitExeceeded)
                iStringID = IDS_WORKER_PROC_RECYCLED_MEMLIMIT;
            else if (m_oHistoryEntry.eReason & EReasonForDeath_PingFailed)
                iStringID = IDS_WORKER_PROC_PING_FAILED;
            else
                iStringID = IDS_WORKER_PROC_STOPPED_EXPECTEDLY;
        }

        ReportHttpErrorIndirect(
                oEntry.iECB,
                iStringID);
        OnRequestComplete(lReqID, oEntry.iECB, 1);
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
int
CProcessEntry::ReadRegForNumSyncPipes()
{
    int             iRet = 4;
    SYSTEM_INFO     si;
    int             iNumCPUs = 0;

    GetSystemInfo(&si);
    for(int iter=0; iter<32; iter++)
    {
        if (si.dwActiveProcessorMask & 0x1)
            iNumCPUs ++;
        si.dwActiveProcessorMask = (si.dwActiveProcessorMask >> 1);
    }
    

    return (iRet * iNumCPUs) / CProcessTableManager::NumActiveCPUs();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CProcessEntry::CreateDACL(
        PACL *    ppACL,        
        HANDLE    hToken)
{
    HRESULT     hr            = S_OK;
    PSID        pSids[3]      = {NULL, NULL, NULL};
    HANDLE      hTokenMe      = NULL;
    BOOL        fFreeSid[3]   = {FALSE, FALSE, FALSE};
    BOOL        fDoNothing    = FALSE;
    BOOL        fRet          = FALSE;
    int         iter          = 0;
    PACL        pACL          = NULL;
    ACL_SIZE_INFORMATION      aclSizeInfo;

    if (hToken == NULL || ppACL == NULL)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    fRet = OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hTokenMe);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

    hr = GetSidFromToken(hTokenMe, &pSids[0], &fFreeSid[0]);
    ON_ERROR_EXIT();

    hr = GetSidFromToken(hToken, &pSids[1], &fFreeSid[1]);
    ON_ERROR_EXIT();

    hr = CRegAccount::GetPrincipalSID(L"administrators", &pSids[2], &fFreeSid[2]);
    ON_ERROR_EXIT();

    pACL = (PACL) NEW_CLEAR_BYTES(4096);
    ON_OOM_EXIT(pACL);
    
    fRet = InitializeAcl(pACL, 4096, ACL_REVISION);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

    for(iter=0; iter<3; iter++)
    {
        hr = CRegAccount::AddAccess(pACL, pSids[iter], GENERIC_ALL, &fDoNothing);
        ON_ERROR_EXIT();
    }

    ZeroMemory(&aclSizeInfo, sizeof(aclSizeInfo));
    if (!GetAclInformation(pACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
        EXIT_WITH_LAST_ERROR();
    
    (*ppACL) = (PACL) NEW_CLEAR_BYTES(aclSizeInfo.AclBytesInUse + 30);
    ON_OOM_EXIT(*ppACL);
    
    fRet = InitializeAcl(*ppACL, aclSizeInfo.AclBytesInUse + 30, ACL_REVISION);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

    hr = CRegAccount::CopyACL(*ppACL, pACL);
    ON_ERROR_EXIT();
    
 Cleanup:
    if (hTokenMe != NULL)
        CloseHandle(hTokenMe);
    if (hr != S_OK && ppACL != NULL)
    {
        DELETE_BYTES(*ppACL);
        (*ppACL) = NULL;
    }

    for(iter=0; iter<3; iter++)
    {
        if (fFreeSid[iter] && pSids[iter] != NULL)
            FreeSid(pSids[iter]);
        else
            DELETE_BYTES(pSids[iter]);
    }
    DELETE_BYTES(pACL);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CProcessEntry::GetSidFromToken (
        HANDLE   hToken,
        PSID *   ppSid,
        LPBOOL   pfWellKnown)
{
    HRESULT         hr = S_OK;
    WCHAR           szName[256];
	int             iRet;

    if (hToken == NULL || ppSid == NULL)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    iRet = GetUserNameFromToken(hToken, szName, (sizeof(szName) / sizeof(WCHAR)) - 1);
	if (iRet <= 0)
		EXIT_WITH_HRESULT(E_FAIL);

    hr = CRegAccount::GetPrincipalSID(szName, ppSid, pfWellKnown);
    ON_ERROR_EXIT();

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

LONG
CProcessEntry::GetNumRequestStat    (
        int iStat)
{
    switch(iStat)
    {
    case 1:
        return m_lRequestsExecuting;
    case 2:
        return m_lRequestsExecuted;
    }
    ASSERT(FALSE);
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Callback, from IIS, when an Async write completes
VOID
WINAPI
OnWriteBytesComplete (
        LPEXTENSION_CONTROL_BLOCK  /*lpECB*/,        
        PVOID                      lContextID,
        DWORD                      /*cbIO*/,
        DWORD                      dwError)
{
    InterlockedDecrement(&g_lNumAsyncPending);

    ////////////////////////////////////////////////////////////
    // Step 1: Get the context
    CResponseContext * pMyContext = CResponseContextHolder::Remove(PtrToLong(lContextID));
    if (pMyContext == NULL)
    { // Not found!
        InterlockedIncrement(&g_lBug38658Count);
        return;
    }
 
    if (pMyContext == NULL || pMyContext->pProcessEntry == NULL || pMyContext->pOver == NULL)
    {
        ASSERT(FALSE);
        return;
    }
    
    // if client disconnected, cleanup request, call "done with session"
    if (dwError == WSAECONNRESET || dwError == WSAECONNABORTED)
    {
        LONG                      lReqID   = pMyContext->pOver->oMsg.oHeader.lRequestID;
        CProcessEntry *           pProcess = pMyContext->pProcessEntry;
        CAsyncPipeOverlapped *    pOver    = pMyContext->pOver;
        EXTENSION_CONTROL_BLOCK * iECB     = pMyContext->iECB;

        pProcess->OnRequestComplete(lReqID, iECB, 0);

        if (pMyContext->fInAsyncWriteFunction == TRUE && GetCurrentThreadId() == pMyContext->dwThreadIdOfAsyncWriteFunction)
        {
            pMyContext->fSyncCallback = 2;
        }
        else
        {
            while(pMyContext->fInAsyncWriteFunction) 
                SwitchToThread();
            pProcess->ReturnResponseBuffer(pOver);
            DELETE_BYTES(pMyContext);
            pProcess->Release();
        }
        
        return;
    }

    ////////////////////////////////////////////////////////////
    // Step 2: If the async function caller hasn't returned as
    //         yet, then we have to do something special
    if (pMyContext->fInAsyncWriteFunction == TRUE) 
    {
        ////////////////////////////////////////////////////////////
        // Step 2a: If the current thread is the AsyncWrite caller,
        //         indicate it in the fInAsyncWriteFunction and return
        if (GetCurrentThreadId() == pMyContext->dwThreadIdOfAsyncWriteFunction)
        {
            pMyContext->fSyncCallback = 1;
            return;
        }
        else
        { 
            // Wait for the caller to return 
            while(pMyContext->fInAsyncWriteFunction) 
                SwitchToThread();
        }
    }

    LONG                    lReqID   = pMyContext->pOver->oMsg.oHeader.lRequestID;
    CProcessEntry *         pProcess = pMyContext->pProcessEntry;
    CAsyncPipeOverlapped *  pOver    = pMyContext->pOver;
    EXTENSION_CONTROL_BLOCK * iECB     = pMyContext->iECB;

    ASSERT(pOver != NULL);

    ////////////////////////////////////////////////////////////
    // Step 4: Free allocated memory
    DELETE_BYTES(pMyContext);

    if (pOver->oMsg.oHeader.eType == EMessageType_Response_And_DoneWithRequest)
    {
        
        CResponseStruct *  pRes = (CResponseStruct *) pOver->oMsg.pData;
        int iDoneWSession = pRes->iMiscInfo;
        pProcess->ReturnResponseBuffer(pOver);
        pProcess->OnRequestComplete(lReqID, iECB, iDoneWSession);
    }
    else
    {
        ////////////////////////////////////////////////////////////
        // Step 5: Continue executuing more items for this request
        pProcess->ExecuteWorkItemsForRequest(lReqID, pOver);
    }

    pProcess->Release();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL
HackGetDebugReg(
        BOOL & fUnderDebugger)
{
    HKEY  hKeyXSP;    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_MACHINE_APP_L, 
                     0, KEY_READ, &hKeyXSP) != ERROR_SUCCESS)
        return FALSE;

    DWORD dwVal = 0, dwSize = 4;
    if (RegQueryValueEx(hKeyXSP, L"UnderDebugger", 0, NULL, 
                        (BYTE *) &dwVal, &dwSize) != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyXSP);
        return FALSE;
    }
    fUnderDebugger = (dwVal == 1);
    RegCloseKey(hKeyXSP);
    return (dwVal == 1 || dwVal == 0);
}


CReadWriteSpinLock g_lockSPI("spi");
DWORD   g_cbBufSPI = 0;
BYTE*   g_bufSPI = NULL;


DWORD   g_PrivatePageCount = 0;
DWORD   g_PeakPagefileUsage = 0;
__int64 g_LastRead = 0;

#define FT_SECOND ((__int64) 10000000)


STDAPI
GetProcessMemoryInformation(ULONG pid, DWORD * pPrivatePageCount, DWORD * pPeakPagefileUsage, 
                                BOOL fNonBlocking) 
{
    HRESULT                     hr = E_UNEXPECTED;
    NTSTATUS                    status;
    ULONG                       iTotalOffset = 0;
    PSYSTEM_PROCESS_INFORMATION pCur = NULL;
    DWORD                       dummy;
    __int64                     now;
    BOOL                        NeedUnlock = FALSE;

    if (pPrivatePageCount == NULL) {
        pPrivatePageCount = &dummy;
    }

    if (pPeakPagefileUsage == NULL) {
        pPeakPagefileUsage = &dummy;
    }

    *pPrivatePageCount = 0;
    *pPeakPagefileUsage = 0;

    if (fNonBlocking) {
        BOOL    fUseCachedValues = FALSE;
        GetSystemTimeAsFileTime((FILETIME *) &now);
        
        if (now - g_LastRead < FT_SECOND) {
            // The cached values were read less than 1 second ago.
            // Just use the cached value.
            fUseCachedValues = TRUE;
        }
        else {
            // Try to acquire the writer lock.  If failed, we'll use cached
            // values instead.
            if (!g_lockSPI.TryAcquireWriterLock()) {
                fUseCachedValues = TRUE;
            }
        }

        if (fUseCachedValues) {
            if (g_LastRead == 0) {
                // We still haven't got the value initialized yet.
                // Since we won't block, just return with an error.
                EXIT_WITH_WIN32_ERROR(ERROR_BUSY);
            }
            
            ASSERT(g_PrivatePageCount != 0);
            ASSERT(g_PeakPagefileUsage != 0);

            // N.B. !!
            // g_PrivatePageCount and g_PeakPagefileUsage may
            // get out of sync.  Beware of this limitation.
            *pPrivatePageCount = g_PrivatePageCount;
            *pPeakPagefileUsage = g_PeakPagefileUsage;
            hr = S_OK;
            EXIT();        
        }
    }
    else
    {
        g_lockSPI.AcquireWriterLock();
    }
    
    NeedUnlock = TRUE;

    if (g_bufSPI == NULL) 
    {
        g_cbBufSPI = 60 * 1024;
        g_bufSPI = new BYTE[g_cbBufSPI];
        ON_OOM_EXIT(g_bufSPI);
    }

    do {
        status = g_pfnNtQuerySystemInformation(SystemProcessInformation, g_bufSPI, g_cbBufSPI, NULL);

        // try again if buffer is too small
        if (status == STATUS_INFO_LENGTH_MISMATCH) 
        {
            DWORD cbNewBuf = g_cbBufSPI * 2;
            BYTE* pNewBuf = new BYTE[cbNewBuf];
            ON_OOM_EXIT(pNewBuf);
            
            delete [] g_bufSPI;
            g_cbBufSPI = cbNewBuf;
            g_bufSPI = pNewBuf;
        }
    }
    while (status == STATUS_INFO_LENGTH_MISMATCH && g_cbBufSPI < (1024*1024));

    if (!NT_SUCCESS(status))
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    for (iTotalOffset=0; iTotalOffset < g_cbBufSPI; iTotalOffset += pCur->NextEntryOffset)
    {
        pCur = (PSYSTEM_PROCESS_INFORMATION) &g_bufSPI[iTotalOffset];         

        if (HandleToULong(pCur->UniqueProcessId) == pid)
        {
            g_PrivatePageCount = *pPrivatePageCount = (DWORD) (pCur->PrivatePageCount >> 20);
            g_PeakPagefileUsage = *pPeakPagefileUsage = (DWORD) (pCur->PeakPagefileUsage >> 10);
            GetSystemTimeAsFileTime((FILETIME *) &g_LastRead);
            hr = S_OK;
            break;
        }

        if (pCur->NextEntryOffset == 0)
            break;
    }                        

Cleanup:
    if (NeedUnlock) {
        g_lockSPI.ReleaseWriterLock();
    }
    return hr;
}


__int64     g_lastGcCallTime = 0;
LONG        g_GcCollectToken = 1;

#define GC_COLLECT_INTERVAL     (10 * FT_SECOND)

STDAPI
SetGCLastCalledTime(BOOL *pfCall) 
{
    HRESULT     hr = S_OK;
    __int64     now;
    BOOL        fReleaseToken = FALSE;

    *pfCall = FALSE;

    GetSystemTimeAsFileTime((FILETIME *) &now);
    if (now - g_lastGcCallTime < GC_COLLECT_INTERVAL) {
        EXIT();
    }

    // First grab the token
    if (InterlockedCompareExchange(&g_GcCollectToken, 0, 1) != 1) {
        EXIT();
    }

    fReleaseToken = TRUE;

    if (now - g_lastGcCallTime < GC_COLLECT_INTERVAL) {
        EXIT();
    }

    *pfCall = TRUE;
    g_lastGcCallTime = now;
    
Cleanup:
    if (fReleaseToken) {
        InterlockedExchange(&g_GcCollectToken, 1);
    }
    
    return hr;
}

#define ENVVAR_APP_POOL_ID L"APP_POOL_ID"

// Returns the private bytes memory limit of a w3wp process in KB (1024).
// If there is no limit, or an error occurs, returns 0.
STDAPI_(int)
GetW3WPMemoryLimitInKB() {
    HRESULT         hr = S_OK;
    int             limit = 0;
    DWORD           rc, rc2;
    METADATA_RECORD md;
    DWORD           size;
    DWORD           dwData = 0;
    IMSAdminBase    *pAdmin = NULL;
    WCHAR           achAppPoolId[MAX_PATH];
    WCHAR           *pchAppPoolId = achAppPoolId;
    WCHAR           *pchPath = NULL;
    int             cchPath;

    // Get the app pool id
    rc = GetEnvironmentVariable(ENVVAR_APP_POOL_ID, achAppPoolId, ARRAY_SIZE(achAppPoolId));
    if (rc == 0) {
        // the app pool always defines APP_POOL_ID, so this is unexpected
        EXIT_WITH_HRESULT(E_UNEXPECTED);
    }
    else if (rc >= ARRAY_SIZE(achAppPoolId)) {
        pchAppPoolId = new WCHAR[rc];
        ON_OOM_EXIT(pchAppPoolId);

        rc2 = GetEnvironmentVariable(ENVVAR_APP_POOL_ID, pchAppPoolId, rc);
        if (rc2 >= rc) {
            // should never happen, but handle it gracefully
            EXIT_WITH_HRESULT(E_UNEXPECTED);
        }

        rc = rc2;
    }

    // Create the metadata key path to the app pool
    cchPath = rc + KEY_APP_POOL_LEN + 1;
    pchPath = new WCHAR[cchPath];
    hr = StringCchCopy(pchPath, cchPath, KEY_APP_POOL);
    ON_ERROR_EXIT();
    hr = StringCchCat(pchPath, cchPath, pchAppPoolId);
    ON_ERROR_EXIT();

    // Setup the metadata record
    ZeroMemory(&md, sizeof(md));
    md.dwMDIdentifier = MD_APPPOOL_PERIODIC_RESTART_PRIVATE_MEMORY;
    md.dwMDAttributes = METADATA_INHERIT;
    md.dwMDDataType = DWORD_METADATA;
    md.pbMDData = (unsigned char *) &dwData;
    md.dwMDDataLen = sizeof(limit);

    // Get the metabase object
    hr = CoCreateInstance(
            CLSID_MSAdminBase,
            NULL,
            CLSCTX_ALL,
            IID_IMSAdminBase,
            (VOID **) &pAdmin);

    ON_ERROR_EXIT();

    // Get the data we want
    hr = pAdmin->GetData(METADATA_MASTER_ROOT_HANDLE, pchPath, &md, &size);
    ON_ERROR_EXIT();

    // Assign the value
    limit = (int) dwData;

Cleanup:
    ReleaseInterface(pAdmin);

    delete [] pchPath;
    if (pchAppPoolId != achAppPoolId) {
        delete [] pchAppPoolId;
    }

    if (hr != S_OK) {
        XspLogEvent(IDS_CANT_GET_W3WP_PRIVATE_BYTES_LIMIT, L"0x%08x", hr);
    }

    return limit;
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
HRESULT
GenerateRandomString(
        LPWSTR  szRandom, 
        int     iStringSize)
{
    if (iStringSize < 1 || szRandom == NULL)
        return E_INVALIDARG;

    HRESULT     hr      = S_OK;
    int         iter    = 0;
    BOOL        fRet    = FALSE;
    LPBYTE      bArray  = NULL;
    HCRYPTPROV  hProv   = NULL;

    for(iter=0; iter<iStringSize-1; iter++)
        szRandom[iter] = L'A';
    szRandom[iStringSize-1] = NULL;

    bArray = new (NewClear) BYTE[iStringSize-1];
    ON_OOM_EXIT(bArray);

    fRet = CryptAcquireContext(&hProv, NULL, NULL, 1, CRYPT_VERIFYCONTEXT);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

    fRet = CryptGenRandom(hProv, iStringSize-1, bArray);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);
    
    for(iter=0; iter<iStringSize-1; iter++)
    {
        int iRandom = (bArray[iter] % 62);
        if (iRandom < 26)            
            szRandom[iter] = (WCHAR) (L'A' + iRandom);
        else if (iRandom < 52)            
            szRandom[iter] = (WCHAR) (L'a' + iRandom - 26);
        else 
            szRandom[iter] = (WCHAR) (L'0' + iRandom - 52);
    }

 Cleanup:
    delete [] bArray;
    if (hProv != NULL)
        CryptReleaseContext(hProv, 0);
    return hr; 
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\platform_apis.cxx ===
/**
 * Support for platform-dependent APIs
 * 
 * Copyright (c) 2000, Microsoft Corporation
 * 
 */

#include "precomp.h"

#include <comsvcs.h>
#include <mtxpriv.h>
#include "httpext6.h"
#include "platform_apis.h"

////////////////////////////////////////////////////////////////////////////////////////////
//
// Generic platform support
//

BOOL                g_fPlatformSupportInited = FALSE;
ASPX_PLATFORM       g_PlatformType = APSX_PLATFORM_UNKNOWN;
CReadWriteSpinLock  g_PlatformSupportLock("g_PlatformSupportLock");

HRESULT InitPlatformSupport() {
    HRESULT hr = S_OK;
    BOOL rc;
    OSVERSIONINFO vi;

    g_PlatformSupportLock.AcquireWriterLock();

    if (g_fPlatformSupportInited)
        EXIT();

    vi.dwOSVersionInfoSize = sizeof(vi);
    rc = GetVersionEx(&vi);
    ON_ZERO_EXIT_WITH_LAST_ERROR(rc);

    if (vi.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        if (vi.dwMajorVersion >= 5)
            g_PlatformType = APSX_PLATFORM_W2K;
        else if (vi.dwMajorVersion == 4)
            g_PlatformType = APSX_PLATFORM_NT4;
    }
    else if (vi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
        g_PlatformType = APSX_PLATFORM_WIN9X;
    }
    
Cleanup:
    g_fPlatformSupportInited = TRUE;
    g_PlatformSupportLock.ReleaseWriterLock();
    return hr;
}

ASPX_PLATFORM GetCurrentPlatform() {
    if (!g_fPlatformSupportInited)
        InitPlatformSupport();

    return g_PlatformType;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
// Support for Win2k only API GlobalMemoryStatusEx.
// On all other platforms it is ok to return FALSE
//

typedef BOOL (__stdcall *PFN_GlobalMemoryStatusEx)(MEMORYSTATUSEX *pMemStatEx);
PFN_GlobalMemoryStatusEx g_pfnGlobalMemoryStatusEx = NULL;


BOOL PlatformGlobalMemoryStatusEx(MEMORYSTATUSEX *pMemStatEx) {
    ASPX_PLATFORM platform = GetCurrentPlatform();

    if (platform != APSX_PLATFORM_W2K)
        return FALSE;

    if (g_pfnGlobalMemoryStatusEx == NULL) {
        g_PlatformSupportLock.AcquireWriterLock();

        HMODULE lib = LoadLibrary(L"KERNEL32.DLL");
        if (lib != NULL)
            g_pfnGlobalMemoryStatusEx = (PFN_GlobalMemoryStatusEx)GetProcAddress(lib, "GlobalMemoryStatusEx");

        g_PlatformSupportLock.ReleaseWriterLock();
    }

    if (g_pfnGlobalMemoryStatusEx == NULL)
        return FALSE;


    return (*g_pfnGlobalMemoryStatusEx)(pMemStatEx);
}

////////////////////////////////////////////////////////////////////////////////////////////
//
// Support for MTS APIs:
// On Win2k and Whistler they are in COMSVCS.DLL, CoEnter/Exit are Whistler only
//

BOOL g_fMTSPlatformSupportInited = FALSE;

typedef HRESULT (__cdecl   *PFN_GetObjectContext)(void **ppObj);
typedef HRESULT (__stdcall *PFN_MTSCreateActivity)(REFIID riid, void **ppObj);
typedef HRESULT (__stdcall *PFN_CoEnterServiceDomain)(IUnknown *pConfigObject);
typedef void    (__stdcall *PFN_CoLeaveServiceDomain)(IUnknown *pStatus);

PFN_GetObjectContext        pfnGetObjectContext = NULL;
PFN_MTSCreateActivity       pfnMTSCreateActivity = NULL;
PFN_CoEnterServiceDomain    pfnEnterServiceDomain = NULL;
PFN_CoLeaveServiceDomain    pfnLeaveServiceDomain = NULL;


HRESULT InitMTSPlatformSupport() {
    HRESULT hr = S_OK;
    HMODULE lib = NULL;
    ASPX_PLATFORM platform = GetCurrentPlatform();

    g_PlatformSupportLock.AcquireWriterLock();

    if (g_fMTSPlatformSupportInited)
        EXIT();

    if (platform == APSX_PLATFORM_W2K) {
        lib = LoadLibrary(L"COMSVCS.DLL");
        ON_ZERO_EXIT_WITH_LAST_ERROR(lib);
    }
    else {
        EXIT_WITH_HRESULT(E_NOTIMPL);
    }

    pfnGetObjectContext     = (PFN_GetObjectContext) GetProcAddress(lib, "GetObjectContext");
    pfnMTSCreateActivity    = (PFN_MTSCreateActivity)GetProcAddress(lib, "MTSCreateActivity");
    pfnEnterServiceDomain   = (PFN_CoEnterServiceDomain)GetProcAddress(lib, "CoEnterServiceDomain");
    pfnLeaveServiceDomain   = (PFN_CoLeaveServiceDomain)GetProcAddress(lib, "CoLeaveServiceDomain");

Cleanup:
    g_fMTSPlatformSupportInited = TRUE;
    g_PlatformSupportLock.ReleaseWriterLock();
    return hr;
}

HRESULT PlatformGetObjectContext(void **ppContext) {
    HRESULT hr = S_OK;

    if (!g_fMTSPlatformSupportInited) {
        hr = InitMTSPlatformSupport();
        ON_ERROR_EXIT();
    }

    if (pfnGetObjectContext == NULL)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    hr = (*pfnGetObjectContext)(ppContext);

Cleanup:
    return hr;
}

HRESULT PlatformCreateActivity(void **ppActivity) {
    HRESULT hr = S_OK;

    if (!g_fMTSPlatformSupportInited) {
        hr = InitMTSPlatformSupport();
        ON_ERROR_EXIT();
    }

    if (pfnMTSCreateActivity == NULL)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    hr = (*pfnMTSCreateActivity)(__uuidof(IMTSActivity), ppActivity);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

BOOL PlatformHasServiceDomainAPIs() {
    HRESULT hr = S_OK;
    BOOL result = FALSE;

    if (!g_fMTSPlatformSupportInited) {
        hr = InitMTSPlatformSupport();
        ON_ERROR_EXIT();
    }

    result = (pfnEnterServiceDomain != NULL && pfnEnterServiceDomain != NULL);

Cleanup:
    return result;
}

HRESULT PlatformEnterServiceDomain(IUnknown *pConfigObject) {
    HRESULT hr = S_OK;

    if (!g_fMTSPlatformSupportInited) {
        hr = InitMTSPlatformSupport();
        ON_ERROR_EXIT();
    }

    if (pfnEnterServiceDomain == NULL)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    hr = (*pfnEnterServiceDomain)(pConfigObject);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}

HRESULT PlatformLeaveServiceDomain(IUnknown *pStatus) {
    HRESULT hr = S_OK;

    if (!g_fMTSPlatformSupportInited) {
        hr = InitMTSPlatformSupport();
        ON_ERROR_EXIT();
    }

    if (pfnLeaveServiceDomain == NULL)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    (*pfnLeaveServiceDomain)(pStatus);

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\processentry.h ===
/**
 * ProcessEntry header file
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

/////////////////////////////////////////////////////////////////////////////
// This file decl the class CProcessEntry. This class creates and controls
// all interaction with a worker process.
/////////////////////////////////////////////////////////////////////////////

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _ProcessEntry_H
#define _ProcessEntry_H

class  CProcessEntry;

#include "AckReceiver.h"
#include "AsyncPipe.h"
#include "TimeClass.h"

/////////////////////////////////////////////////////////////////////////////
// Forward decl.
class CCPUEntry;

/////////////////////////////////////////////////////////////////////////////
// State of the Process
enum   EProcessState
{
    EProcessState_Starting, // Initial state
    EProcessState_Running,  // Healthy
    EProcessState_Stopping, // Kill Message has been sent to the worker process and has been acknowledged
    EProcessState_Dead      // The process is dead
};

/////////////////////////////////////////////////////////////////////////////
// Data struct associated with a process

class  CProcessEntry
{
public:
    // CTor
    CProcessEntry                           (CCPUEntry * pParent   = NULL, // My CPU data struct
                                             DWORD       dwCPUMask = 0x1,  // CPU Affinity Mask to use  
                                             DWORD       dwProcessNum = 0);// Unique number for this proc

    // Dtor
    ~CProcessEntry                          (); 

    HRESULT            Init                 ();

    // Close the pipes
    void               Close                (BOOL fCallTerminateProcess);

    // Update your status
    EProcessState      GetUpdatedStatus     ();

    // Send a request to the worker process 
    HRESULT            SendRequest          (EXTENSION_CONTROL_BLOCK * iECB, LONG lReqID);

    // Process a response from the worker process: sent on async pipe
    BOOL               ProcessResponse      (CAsyncPipeOverlapped * pOver);

    // Wait for the process to startup 
    void               WaitForProcessToStart();

    // Send a Kill message to the worker process
    void               SendKillMessage      (int iImmediate = 0);

    // Kill worker process
    void               Terminate            ();

    // Refernce counting
    void               AddRef               ();
    void               Release              ();

    // Can this Data struct be freed?
    BOOL               CanBeDestructed      ();

    // A write completed on the async pipe: Free the buffer(s) 
    void               OnWriteComplete      (CAsyncPipeOverlapped * pMsg);

    // Got an ack for a request sent
    HRESULT            OnAckReceived        (EAsyncMessageType eAckForType,
                                             LONG              lRequestID);

    // 
    void              ExecuteWorkItemsForRequest 
                                            (LONG  lReqID, 
                                             CAsyncPipeOverlapped * pOver = NULL);


    // Called by the pipes
    void               OnProcessDied        ();

    // Get age in minutes
    DWORD              GetAge               ();

    // Get time the proc's been idle in minutes
    DWORD              GetIdleTime          ();

    BOOL               IsKillImmediateSent  () { return m_fKillImmSent; }

    HANDLE             GetProcessHandle     () { return m_hProcess; }

    void               UpdateStatusInHistoryTable (EReasonForDeath eReason);

    DWORD              GetMemoryUsed        ();

    DWORD              GetPeakMemoryUsed    () { return m_oHistoryEntry.dwPeakMemoryUsed; }

    void               ReturnResponseBuffer (CAsyncPipeOverlapped * pMsg);

    void               OnRequestComplete    (LONG    lReqID, EXTENSION_CONTROL_BLOCK * iECB, int iDoneWSession);

    void               ProcessSyncMessage   (CSyncMessage * pMsg, BOOL fError);
    
    CProcessEntry *    GetNext              () { return m_pNext; }

    void               SetNext              (CProcessEntry * pNext) { m_pNext = pNext; }

    EProcessState      GetProcessStatus     () { return m_eProcessStatus; }
    void               SetProcessStatus     (EProcessState eStatus) { eStatus = m_eProcessStatus; }
    
    TimeClass &        GetLastKillTime      () { return m_tLastKillTime; } 
    
    LONG               GetNumRequestStat    (int iStat);

    CHistoryEntry &    GetHistoryEntry      () { return m_oHistoryEntry; }

    DWORD              GetProcessNumber     () { return m_dwProcessNumber; }

    void               NotifyHeardFromWP    () { m_tLastHeardFromWP.SnapCurrentTime(); }

    void               NotifyResponseFromWP    () { m_tLastResponse.SnapCurrentTime(); }

    void               SetDebugStatus        (BOOL fDebugActive) { m_fDebugStatus = fDebugActive; }

    HANDLE             OnGetImpersonationToken(DWORD dwPID, EXTENSION_CONTROL_BLOCK * pECB);        

    DWORD              GetSecondsSinceLastResponse();

    BOOL               IsProcessUnderDebugger  ();   

    HANDLE             ConvertToken            (HANDLE hHandle);

    BOOL               BreakIntoProcess        ();


private:
    HRESULT            PackageRequest     (EXTENSION_CONTROL_BLOCK * iECB,
                                           LONG    lReqID, 
                                           CAsyncPipeOverlapped ** ppOut);

    HANDLE             GetImpersonationToken(EXTENSION_CONTROL_BLOCK * iECB);

    void               CleanupRequest     (LONG    lReqID);

    BOOL               FlushCore          (EXTENSION_CONTROL_BLOCK * iECB,
                                           CAsyncPipeOverlapped *   pOver);
    static BOOL        UseTransmitFile    ();

    static int         ReadRegForNumSyncPipes();
    static HRESULT     CreateDACL         (PACL * ppACL, HANDLE hToken);
    static HRESULT     GetSidFromToken    (HANDLE hToken, PSID * ppSID, LPBOOL   pfWellKnown);
    HRESULT            LaunchWP           (LPWSTR szProgram, LPWSTR szArgs, HANDLE hToken, 
                                           LPSTARTUPINFO pSI, LPSECURITY_ATTRIBUTES pSA, LPVOID pEnvironment);

    // Private data

    // Handle to worker process
    HANDLE             m_hProcess;

    // Ack receiving pipe  
    CAckReceiver       m_oAckReciever;

    // Async pipe  
    CAsyncPipe         m_oAsyncPipe;

    // Ref counting
    LONG               m_lRefCount;

    // My Parent
    CCPUEntry *        m_pParent;

    // Are we in shutdown mode?
    BOOL               m_fShuttingDown;

    BOOL               m_fKillImmSent;

    // Event signalling that we are starting
    HANDLE             m_hStartupEvent;
    HANDLE             m_hPingRespondEvent, m_hPingSendEvent;

    // Number of Requests executed
    LONG               m_lRequestsExecuted;

    // Number of Requests Pending
    LONG               m_lRequestsExecuting;

    // Create Time
    TimeClass          m_tTimeCreated;

    // Tick at which it became idle
    TimeClass          m_tTimeIdle;

    // First Kill Message, Last Kill Message and Terminate Times 
    TimeClass          m_tFirstKillTime, m_tLastKillTime, m_tTerminateTime;
    
    TimeClass          m_tLastHeardFromWP;

    TimeClass          m_tLastResponse;

    // Current process status
    EProcessState      m_eProcessStatus;

    // CPU Affinity Mask
    DWORD              m_dwCPUMask;

    // Process Number
    DWORD              m_dwProcessNumber;


    // Pointers in case it's in a linked list
    CProcessEntry *    m_pNext;

    CHistoryEntry      m_oHistoryEntry;

    LONG               m_lCloseCalled;

    BOOL               m_fUpdatePerfCounter;
    CRITICAL_SECTION   m_oCSPing;
    CRITICAL_SECTION   m_oCSPIDAdujustment;
    BOOL               m_fAnyReqsSinceLastPing;
    BOOL               m_fDebugStatus;
    DWORD              m_dwResetPingEventError;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

struct CWriteByteCompletionContext
{
    CProcessEntry *          pProcessEntry;
    CAsyncPipeOverlapped *   pOver;
    BOOL                     fInAsyncWriteFunction;
    DWORD                    dwThreadIdOfAsyncWriteFunction;
    EXTENSION_CONTROL_BLOCK * iECB;
};

int
SafeStringLenghtA(
        LPCSTR szStr,
        int    iMaxSize);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\perfcounterclient.cxx ===
/**
 * PerfCounterClient.cxx
 * 
 * Copyright (c) 1998-2002, Microsoft Corporation
 * 
 */

#include "precomp.h"
#include "util.h"
#include "fxver.h"
#include "names.h"
#include "hashtable.h"
#include "ary.h"
#include "PerfCounters.h"
#include PERF_H_FULL_NAME

#ifndef ALIGN8
#define ALIGN8(x) ((x + 7L) & ~7L)
#endif

#define PERF_TOTAL_NAME_L L"__Total__"
#define PERF_TOTAL_NAME_L_LENGTH 9

#define PIPE_PREFIX_L L"\\\\.\\pipe\\"
#define PIPE_PREFIX_LENGTH 9

#define PERF_COUNTERS_SIZE (PERF_NUM_DWORDS * sizeof(DWORD))
#define PERF_INSTANCE_SIZE (sizeof(PERF_INSTANCE_DEFINITION) + MAX_PATH * sizeof(WCHAR))

#define PERFCTR(base, defaultscale, type) \
{\
    sizeof(PERF_COUNTER_DEFINITION),\
    base,0,base,0,defaultscale,\
    PERF_DETAIL_NOVICE, type, \
    sizeof(DWORD), base##_OFFSET \
}

#define PERF_POLL_SLEEP_TIME_MS 400  // This is the pool sleep time in MilliSeconds
#define PERF_STALE_DATA_TIME_100NS (100 * 10000)  // This is the stale data time in 100 nanosecond units 
                                                  // (i.e. 100E-9 * 200E+6 = 2E-1 = 0.2 sec = 200ms)



//
// Include generated perf counter data struct header
//
#include "perfstruct.h"

struct PerfPipeInfo {
    HANDLE hPipe;
    WCHAR wcsPipeName[PERF_PIPE_NAME_MAX_BUFFER];   
};

DECLARE_CPtrAry(CPerfPipeAry, PerfPipeInfo *);

DWORD WINAPI PerfDataGatherThreadStart(LPVOID param);
DWORD WINAPI RegistryMonitorThreadStart(LPVOID param);

void PerfDataHashtableCallback(void * pValue, void * pArgument);
void DeleteDataCallback(void * pValue, void * pArgument);

struct PerfEnumStateData {
    BYTE *  pData;
    DWORD * pcbApp;
    DWORD * pTotalData;
};

class CPerfCounterClient
{
public:
    static CPerfCounterClient* GetSingleton();

    HRESULT OpenPerf(BOOL generic);
    HRESULT ClosePerf();
    HRESULT CollectPerf(BOOL generic, LPWSTR Values, LPVOID *lppData, LPDWORD lpcbTotalBytes, LPDWORD lpNumObjectTypes);

    HRESULT InitCounterData(BOOL generic);
    HRESULT MonitorPerfPipeNames();
    HRESULT GatherPerfData();

private:
    DECLARE_MEMCLEAR_NEW_DELETE();

    CPerfCounterClient();
    ~CPerfCounterClient();
    NO_COPY(CPerfCounterClient);

    // Methods
    void CommonDataInit();
    BOOL IsNumberInUnicodeList(DWORD number, WCHAR *list);
    void SetCounterValue(DWORD * buf, DWORD counterNumber, DWORD value);
    HRESULT GetDataFromWP(CPerfPipeAry * handleList, CPerfData * globalData, HashtableGeneric * dataTable);
    HRESULT ReadPipeData(HANDLE hPipe, HashtableGeneric * dataTable, CPerfData * globalData);
    HRESULT UpdateHandleList(CPerfPipeAry * handleList);
    void SumGlobalData(CPerfData * globalData, CPerfData * message);
    HRESULT WaitForAsync(HANDLE hPipe, DWORD lastError);

#if DBG
    void DumpPerfData(void *pData, int numObjects);
#endif

    // Static        
    static CPerfCounterClient s_Singleton;

    // Instance variables
    PERF_GLOBAL_DATA * _versionedGlobalPerfData;
    PERF_APPS_DATA * _versionedAppsPerfData;

    PERF_GLOBAL_DATA * _genericGlobalPerfData;
    PERF_APPS_DATA * _genericAppsPerfData;
        
    BOOL _initedGeneric;
    BOOL _initedVersioned;
    long _openCount;
    CReadWriteSpinLock _perfLock;
    LONG _needUpdateList;

    HashtableGeneric * _appDataTable;
    CPerfData * _globalData;

    CPerfVersion * _versionMessage;
    LPOVERLAPPED _lpOverlapped;

    BYTE * _receiveBuffer;
    int _receiveBufferSize;

    HANDLE _hRegistryMonitorThread;
    HANDLE _hDataCollectorThread;
    
    HANDLE _hGoGatherEvent;
    HANDLE _hGatherWaitEvent;

    __int64 _lastGatherTime;
};

 
#pragma pack()

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// External entry points
/////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// These are the entry points for the generic "ASP.NET" perf counters
//
DWORD WINAPI OpenGenericPerfData(LPWSTR counterVersion) 
{
    return CPerfCounterClient::GetSingleton()->OpenPerf(TRUE);
}

DWORD WINAPI CollectGenericPerfData(
    LPWSTR Values,
    LPVOID *lppData,
    LPDWORD lpcbTotalBytes,
    LPDWORD lpNumObjectTypes)
{
    return CPerfCounterClient::GetSingleton()->CollectPerf(TRUE, Values, lppData, lpcbTotalBytes, lpNumObjectTypes);
}

DWORD WINAPI CloseGenericPerfData()
{
    return CPerfCounterClient::GetSingleton()->ClosePerf();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// These are the entry points for the versioned "ASP.NET vX.X.XXXX.X" perf counters
//
DWORD WINAPI OpenVersionedPerfData(LPWSTR counterVersion)
{
    return CPerfCounterClient::GetSingleton()->OpenPerf(FALSE);
}

DWORD WINAPI CollectVersionedPerfData(
    LPWSTR Values,
    LPVOID *lppData,
    LPDWORD lpcbTotalBytes,
    LPDWORD lpNumObjectTypes)
{
    return CPerfCounterClient::GetSingleton()->CollectPerf(FALSE, Values, lppData, lpcbTotalBytes, lpNumObjectTypes);
}

DWORD WINAPI CloseVersionedPerfData()
{
    return CPerfCounterClient::GetSingleton()->ClosePerf();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// These are thread start method definitions
//
DWORD WINAPI RegistryMonitorThreadStart(LPVOID param)
{
    CPerfCounterClient::GetSingleton()->MonitorPerfPipeNames();

    ExitThread(0);

    return 0;
}

DWORD WINAPI PerfDataGatherThreadStart(LPVOID param)
{
    CPerfCounterClient::GetSingleton()->GatherPerfData();

    ExitThread(0);

    return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Internal implementation 
/////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Singleton retriever for CPerfCounterClient class
// 
CPerfCounterClient CPerfCounterClient::s_Singleton;

CPerfCounterClient* CPerfCounterClient::GetSingleton()
{
    return &s_Singleton;
}

/////////////////////////////////////////////////////////////////////////////
// CTor
// 
CPerfCounterClient::CPerfCounterClient():_perfLock("CPerfCounterClient")
{
}

CPerfCounterClient::~CPerfCounterClient()
{
    DELETE_BYTES(_receiveBuffer);
    delete _genericGlobalPerfData;
    delete _genericAppsPerfData;
    delete _appDataTable;
    delete _globalData;
    delete _versionMessage;
}

/////////////////////////////////////////////////////////////////////////////
// OpenPerf
// 
HRESULT CPerfCounterClient::OpenPerf(BOOL generic) 
{
    HRESULT hr = S_OK;
    DWORD count;
    HANDLE hTemp;
    HANDLE hPrevious;

    // Increment the open perf count
    count = InterlockedIncrement(&_openCount);

    // If we're asking for generic perf data and we haven't initialized the generic data stuff
    // or if we're asking for versioned perf data and we haven't initalized the versioned data stuff,
    // then call InitCounterData
    if ((generic && (!_initedGeneric)) || ((!generic) && (!_initedVersioned))) {
        hr = InitCounterData(generic);
        ON_ERROR_EXIT();
    }

    // Create events and threads if not previously created
    if (_hGoGatherEvent == NULL) {
        hTemp = CreateEvent(NULL, FALSE, FALSE, NULL);
        ON_ZERO_EXIT_WITH_LAST_ERROR(hTemp);

        hPrevious = InterlockedCompareExchangePointer(&_hGoGatherEvent, hTemp, NULL);
        if (hPrevious != NULL) {
            CloseHandle(hTemp);
        }
    }

    if (_hGatherWaitEvent == NULL) {
        hTemp = CreateEvent(NULL, TRUE, FALSE, NULL);
        ON_ZERO_EXIT_WITH_LAST_ERROR(hTemp);

        hPrevious = InterlockedCompareExchangePointer(&_hGatherWaitEvent, hTemp, NULL);
        if (hPrevious != NULL) {
            CloseHandle(hTemp);
        }
    }

    if (_hRegistryMonitorThread == NULL) {
        hTemp = CreateThread(NULL, 0, &RegistryMonitorThreadStart, NULL, CREATE_SUSPENDED , NULL);
        ON_ZERO_EXIT_WITH_LAST_ERROR(hTemp);

        hPrevious = InterlockedCompareExchangePointer(&_hRegistryMonitorThread, hTemp, NULL);
        if (hPrevious != NULL) {
            CloseHandle(hTemp);
        }
        else {
            ResumeThread(_hRegistryMonitorThread);
        }
    }

    if (_hDataCollectorThread == NULL) {
        hTemp = CreateThread(NULL, 0, &PerfDataGatherThreadStart, NULL, CREATE_SUSPENDED , NULL);
        ON_ZERO_EXIT_WITH_LAST_ERROR(hTemp);

        hPrevious = InterlockedCompareExchangePointer(&_hDataCollectorThread, hTemp, NULL);
        if (hPrevious != NULL) {
            CloseHandle(hTemp);
        }
        else {
            ResumeThread(_hDataCollectorThread);
        }
    }

Cleanup:

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Sets the new data for the perf collector
// 
HRESULT CPerfCounterClient::ClosePerf()
{
    InterlockedDecrement(&_openCount);

    return S_OK;
}

HRESULT CPerfCounterClient::InitCounterData(BOOL generic)
{
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType, dwFirstCounter, dwFirstHelp;
    PERF_COUNTER_DEFINITION *pCounterDef;
    LPWSTR perfRegPath;
    PERF_GLOBAL_DATA * globalData; 
    PERF_APPS_DATA * appsData;

    if ((generic && _initedGeneric) || ((!generic) && _initedVersioned))
        EXIT();

    _perfLock.AcquireWriterLock();

    __try {
        // If we have already initialized the generic or versioned one (depending on the "generic" BOOL), then bail
        if ((generic && _initedGeneric) || ((!generic) && _initedVersioned))
            EXIT();

        if (_versionMessage == NULL) {
            _versionMessage = CPerfVersion::GetCurrentVersion();
            ON_OOM_EXIT(_versionMessage);
        }

        if (generic) {
            perfRegPath = REGPATH_PERF_GENERIC_PERFORMANCE_KEY_L;

            // Allocate the generic data structures
            _genericGlobalPerfData = new PERF_GLOBAL_DATA;
            ON_OOM_EXIT(_genericGlobalPerfData);
            _genericAppsPerfData = new PERF_APPS_DATA;
            ON_OOM_EXIT(_genericAppsPerfData);

            // The default initializer for the g_GlobalPerfData and g_AppsPerfData fill in info on counter types and what not.
            // Copy that info into the generic perf data structures as well, since they're the static data is the same
            // (dynamic data, like text indexes, are filled in below)
            CopyMemory(_genericGlobalPerfData, &g_GlobalPerfData, sizeof(PERF_GLOBAL_DATA));
            CopyMemory(_genericAppsPerfData, &g_AppsPerfData, sizeof(PERF_APPS_DATA));
         
            globalData = _genericGlobalPerfData;
            appsData = _genericAppsPerfData;
        }
        else {
            perfRegPath = REGPATH_PERF_VERSIONED_PERFORMANCE_KEY_L;

            // These are defined in the "perfstruct.h" file, so we just assign them here.
            _versionedGlobalPerfData = &g_GlobalPerfData;
            _versionedAppsPerfData = &g_AppsPerfData;

            globalData = _versionedGlobalPerfData;
            appsData = _versionedAppsPerfData;
        }

        // 
        // Retrieve offsets for string indexes
        // 
        
        hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, perfRegPath, 0, KEY_READ, &hKey);
        ON_WIN32_ERROR_EXIT(hr);

        hr = RegQueryValueEx(hKey, TEXT("First Counter"), 0, &dwType, (LPBYTE) &dwFirstCounter, &dwSize);
        if(hr != ERROR_SUCCESS || dwType != REG_DWORD || dwSize != sizeof(DWORD))
            EXIT_WITH_LAST_ERROR();

        hr = RegQueryValueEx(hKey, TEXT("First Help"), 0, &dwType, (LPBYTE) &dwFirstHelp, &dwSize);
        if(hr != ERROR_SUCCESS || dwType != REG_DWORD || dwSize != sizeof(DWORD))
            EXIT_WITH_LAST_ERROR();

        // Adjust indexes for global object
        globalData->obj.ObjectNameTitleIndex += dwFirstCounter;
        globalData->obj.ObjectHelpTitleIndex += dwFirstHelp;

        pCounterDef = (PERF_COUNTER_DEFINITION *)&(globalData->counterDefs[0]);

        for (int i = 0; i < PERF_NUM_GLOBAL_PERFCOUNTERS; i++) {
            pCounterDef[i].CounterNameTitleIndex += dwFirstCounter;
            pCounterDef[i].CounterHelpTitleIndex += dwFirstHelp;
        }

        // Adjust indexes for applications object
        appsData->obj.ObjectNameTitleIndex += dwFirstCounter;
        appsData->obj.ObjectHelpTitleIndex += dwFirstHelp;

        pCounterDef = (PERF_COUNTER_DEFINITION *)&(appsData->counterDefs[0]);

        for (i = 0; i < PERF_NUM_PERAPP_PERFCOUNTERS; i++) {
            pCounterDef[i].CounterNameTitleIndex += dwFirstCounter;
            pCounterDef[i].CounterHelpTitleIndex += dwFirstHelp;
        }

        if (generic)
            _initedGeneric = TRUE;
        else
            _initedVersioned = TRUE;

    }
    __finally {
        _perfLock.ReleaseWriterLock();
    }


Cleanup:
    if(hKey != NULL)
        RegCloseKey(hKey);

    return hr;
}

HRESULT CPerfCounterClient::CollectPerf(BOOL generic, LPWSTR Values, LPVOID *lppData, LPDWORD lpcbTotalBytes, LPDWORD lpNumObjectTypes)
{
    HRESULT hr = S_OK;
    DWORD dwResult = ERROR_SUCCESS;
    DWORD cbTotal, cbApp = 0;
    DWORD numApps;
    BYTE *pData = (BYTE *)*lppData;
    CPerfData * perfData;
    PERF_GLOBAL_DATA * globalData;
    PERF_APPS_DATA * appsData;
    __int64 curTime;
    BOOL doWait = FALSE;

    if(lppData == NULL || lpcbTotalBytes == NULL || lpNumObjectTypes == NULL)
        EXIT_WITH_WIN32_ERROR(ERROR_INVALID_PARAMETER);

    if (generic) {
        globalData = _genericGlobalPerfData;
        appsData = _genericAppsPerfData;
    }
    else {
        globalData = _versionedGlobalPerfData;
        appsData = _versionedAppsPerfData;
    }

    _perfLock.AcquireReaderLock();
    __try {
        GetSystemTimeAsFileTime((FILETIME *) &curTime);
        if ((curTime - _lastGatherTime) > PERF_STALE_DATA_TIME_100NS) {
            // If so, go and signal a gather
            if (!SetEvent(_hGoGatherEvent)) {
                CONTINUE_WITH_LAST_ERROR(); hr = S_OK;
            }
            // Reset the gather wait event
            if (!ResetEvent(_hGatherWaitEvent)) {
                CONTINUE_WITH_LAST_ERROR(); hr = S_OK;
            }
            doWait = TRUE;
        }
    }
    __finally {
        _perfLock.ReleaseReaderLock();
    }

    if (doWait) {
        if (WaitForSingleObject(_hGatherWaitEvent, 100) == WAIT_FAILED) {
            CONTINUE_WITH_LAST_ERROR(); hr = S_OK;
        }
    }

    _perfLock.AcquireReaderLock();
    __try {
        // Compute our space requirements: Step 1 - global counters
        cbTotal = sizeof(PERF_GLOBAL_DATA) + sizeof(PERF_COUNTER_BLOCK) + PERF_COUNTERS_SIZE + 16;

        // Step 2 - per-app counters
        if (_appDataTable == NULL)
            numApps = 0;
        else
            numApps = _appDataTable->GetSize();
        
        cbApp = sizeof(PERF_APPS_DATA) + 
                (numApps + 1) * 
                (16 /* padding */ + PERF_INSTANCE_SIZE + 
                sizeof(PERF_COUNTER_BLOCK) + PERF_COUNTERS_SIZE);
        
        cbTotal += cbApp;

        // Tell perfmon we need more space
        if(cbTotal > *lpcbTotalBytes)
        {
            dwResult = ERROR_MORE_DATA;
            EXIT();
        }
        *lpNumObjectTypes = 0;

        if(wcscmp(Values, L"Global") == 0 ||
            IsNumberInUnicodeList(globalData->obj.ObjectNameTitleIndex, Values))
        {
            // Pack global data definition
            CopyMemory(pData, globalData, sizeof(PERF_GLOBAL_DATA));
            pData += sizeof(PERF_GLOBAL_DATA);

            // Pack COUNTER_BLOCK
            ((PERF_COUNTER_BLOCK *)pData)->ByteLength = ALIGN8(PERF_COUNTERS_SIZE + sizeof(PERF_COUNTER_BLOCK));
            pData += sizeof(PERF_COUNTER_BLOCK);

            // Pack counters
            perfData = _globalData;
            if (perfData == NULL)
                ZeroMemory(pData, PERF_COUNTERS_SIZE);
            else {
                CopyMemory(pData, perfData->data, PERF_COUNTERS_SIZE);
                // Set the number of apps in the global counter
                SetCounterValue((DWORD *) pData, ASPNET_APPLICATIONS_RUNNING_NUMBER, numApps);
            }
            pData += PERF_COUNTERS_SIZE;

            (*lpNumObjectTypes)++;

            pData = (BYTE *)*lppData + ALIGN8(pData - (BYTE *)*lppData);
        }

        if( (wcscmp(Values, L"Global") == 0 ||
            IsNumberInUnicodeList(appsData->obj.ObjectNameTitleIndex, Values)))
        {

            PERF_INSTANCE_DEFINITION *pInstance;
            DWORD *total_data;
            DWORD *pcbApp = &((PERF_OBJECT_TYPE *)pData)->TotalByteLength;

            // Pack per-app counters
            (*lpNumObjectTypes)++;

            // Pack per-app data definition
            appsData->obj.NumInstances = numApps + 1;
            CopyMemory(pData, appsData, sizeof(PERF_APPS_DATA));
            pData += sizeof(PERF_APPS_DATA);

            // Fill in __Total__ instance counter
            //
            pInstance = (PERF_INSTANCE_DEFINITION *)pData;
            ZeroMemory(pInstance, PERF_INSTANCE_SIZE);

            // fill in the instance definition
            pInstance->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
            pData = (BYTE *)pInstance + pInstance->NameOffset;
            hr = StringCchCopyW((WCHAR *) pData, PERF_TOTAL_NAME_L_LENGTH + 1, PERF_TOTAL_NAME_L);
            ON_ERROR_EXIT();

            pInstance->NameLength = (PERF_TOTAL_NAME_L_LENGTH + 1) * sizeof(WCHAR);

            pInstance->UniqueID = PERF_NO_UNIQUE_ID;
            pInstance->ByteLength = ALIGN8(sizeof(PERF_INSTANCE_DEFINITION) + pInstance->NameLength);

            *pcbApp += pInstance->ByteLength;

            pData = (BYTE *)pInstance + pInstance->ByteLength;

            // Pack PERF_COUNTER_BLOCK
            // Fill in PERF_COUNTER_BLOCK's ByteLength field
            *((DWORD *)pData) = ALIGN8(PERF_COUNTERS_SIZE + sizeof(PERF_COUNTER_BLOCK));

            // Pack counters themselves (copy data after perf counter block definition)
            ZeroMemory(pData + sizeof(PERF_COUNTER_BLOCK), PERF_COUNTERS_SIZE);
            total_data = (DWORD*) (pData + sizeof(PERF_COUNTER_BLOCK));

            pData += ALIGN8(PERF_COUNTERS_SIZE + sizeof(PERF_COUNTER_BLOCK));
            *pcbApp += ALIGN8(sizeof(PERF_COUNTER_BLOCK) + PERF_COUNTERS_SIZE);

            // Fill in the rest of the instance info
            //
            if (_appDataTable != NULL) {
                PerfEnumStateData stateData;

                stateData.pData = pData;
                stateData.pcbApp = pcbApp;
                stateData.pTotalData = total_data;
                
                _appDataTable->Enumerate(&PerfDataHashtableCallback, (void*) &stateData);

                pData = stateData.pData;
                pcbApp = stateData.pcbApp;
            }
        }
    }
    __finally {
        _perfLock.ReleaseReaderLock();
    }
    
    #if DBG
//        DumpPerfData(*lppData, 2);
    #endif

    *lpcbTotalBytes = ALIGN8(PtrToUint(pData - (BYTE *)*lppData));
    pData = (BYTE *)*lppData + *lpcbTotalBytes;
    *lppData = (void *)pData;
        
Cleanup:
   
    return dwResult;
}

void PerfDataHashtableCallback(void * pValue, void * pArgument) 
{
    HRESULT hr = S_OK;
    
    PerfEnumStateData * stateData = (PerfEnumStateData *) pArgument;
    BYTE *pData = stateData->pData;
    DWORD * pTotalData = stateData->pTotalData;
    CPerfData * perfData = (CPerfData *) pValue;
    
    PERF_INSTANCE_DEFINITION *pInstance = (PERF_INSTANCE_DEFINITION *)pData;
    ZeroMemory(pInstance, PERF_INSTANCE_SIZE);

    // fill in the instance definition
    pInstance->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pData = (BYTE *)pInstance + pInstance->NameOffset;
    if (perfData->nameLength < 0) {
        pInstance->NameLength = 1 * sizeof(WCHAR);
        *((WCHAR *) pData) = L'\0';
    }
    else {
        // Set the NameLength size in WCHAR for copying
        pInstance->NameLength = (perfData->nameLength < CPerfData::MaxNameLength) ? perfData->nameLength : CPerfData::MaxNameLength;
        hr = StringCchCopyW((WCHAR *) pData, pInstance->NameLength + 1, perfData->name);
        ON_ERROR_EXIT();
        // Now set it in BYTEs, since struct expects it that way
        pInstance->NameLength = (pInstance->NameLength + 1) * sizeof(WCHAR);
    }

    //
    // PerfMon UI gets confused when sees slashes. 
    // Replace them with underbars
    //
    {
        WCHAR *p = (WCHAR *) pData;

        while(*p)
        {
            if(*p == L'/') *p = L'_';
            p++;
        }
    }

    pInstance->UniqueID = PERF_NO_UNIQUE_ID;
    pInstance->ByteLength = ALIGN8(sizeof(PERF_INSTANCE_DEFINITION) + pInstance->NameLength);

    pData = (BYTE *)pInstance + pInstance->ByteLength;

    // Pack PERF_COUNTER_BLOCK
    *((DWORD *)pData) = ALIGN8(PERF_COUNTERS_SIZE + sizeof(PERF_COUNTER_BLOCK));

    // Pack counters themselves
    pData += sizeof(PERF_COUNTER_BLOCK);
    CopyMemory(pData, perfData->data, PERF_COUNTERS_SIZE);

    // Add the new instance and counter data sizes
    *(stateData->pcbApp) += pInstance->ByteLength;
    *(stateData->pcbApp) += ALIGN8(sizeof(PERF_COUNTER_BLOCK) + PERF_COUNTERS_SIZE);

    // Sum the pTotalData area with this counter instance's data
    DWORD *pOneData = pTotalData;
    DWORD *pWalk = (DWORD*) pData;
    for (int k = 0; k < PERF_NUM_DWORDS; k++) {
        *pOneData += *pWalk;
        pOneData++;
        pWalk++;
    }

    // Move the stateData->pData pointer forward to the next instance definition
    stateData->pData += pInstance->ByteLength + ALIGN8(PERF_COUNTERS_SIZE + sizeof(PERF_COUNTER_BLOCK));

Cleanup:
    return;
}


BOOL CPerfCounterClient::IsNumberInUnicodeList(DWORD number, WCHAR *list)
{
    WCHAR c;
    BOOL found = FALSE;
    DWORD seenNumber = 0;
    BOOL sawSomeDigits = FALSE;

    if(list != NULL) 
    {
        for(;;)
        {
            // get the character
            c = *(list++);

            if(c == L' ' || c == 0) 
            {
                // delimiter - see if we've got our number
                if(sawSomeDigits && number == seenNumber)
                {
                    found = TRUE;
                    break;
                }

                // not our number. Quit if end of the list
                if(c == 0)
                    break;

                // note the fact that we don't have any digits
                sawSomeDigits = FALSE;
            } else if(c >= L'0' && c <= L'9')
            {
                // digit
                if(sawSomeDigits)
                {
                    // not the first digit
                    seenNumber = seenNumber * 10 + (c - L'0');
                }
                else
                {
                    // first digit -- reset the number
                    sawSomeDigits = TRUE;
                    seenNumber = (c - L'0');
                }
            } 
            else // something other than digit, zero or space
            {
                break;
            }
        }
    }

    return found;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
// This method is used to fixup a specific counter value with a known 
// value at collect time.  An example is the number of applications
// running -- a number that is only truly known at collect time
//
void CPerfCounterClient::SetCounterValue(DWORD * buf, DWORD counterNumber, DWORD value)
{
    buf[counterNumber] = value;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Sum the global data.
// Note that "message" may be from the stack, so be careful when changing this method!
//
void CPerfCounterClient::SumGlobalData(CPerfData * globalData, CPerfData * message)
{
    for (int i = 0; i < PERF_NUM_GLOBAL_PERFCOUNTERS; i++) {
        if (i == ASPNET_REQUEST_EXECUTION_TIME_NUMBER ||
            i == ASPNET_REQUEST_WAIT_TIME_NUMBER) {
            // Some of these we want the max time, not sum
            globalData->data[i] = globalData->data[i] > message->data[i] ? globalData->data[i] : message->data[i];
        }
        else {
            // Every other counter should just add
            globalData->data[i] += message->data[i];
        }
    }
    
}

HRESULT CPerfCounterClient::MonitorPerfPipeNames()
{
    HRESULT hr = S_OK;
    LONG retCode;
    HANDLE hEvent = NULL;
    HKEY hKey = NULL;

    // Create an event
    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    ON_ZERO_EXIT_WITH_LAST_ERROR(hEvent);

    while (TRUE) {
        // Open the perf name reg key
        retCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_PERF_VERSIONED_NAMES_KEY_L, 0, KEY_NOTIFY, &hKey);
        ON_WIN32_ERROR_EXIT(retCode);

        // Watch the registry for changes in name or values and make it async
        retCode = RegNotifyChangeKeyValue(hKey, TRUE, REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET, hEvent, TRUE);
        ON_WIN32_ERROR_EXIT(retCode);

        if (WaitForSingleObject(hEvent, INFINITE) == WAIT_FAILED) 
            CONTINUE_WITH_LAST_ERROR(); hr = S_OK;
            
        if (RegCloseKey(hKey) != ERROR_SUCCESS)
            CONTINUE_WITH_LAST_ERROR(); hr = S_OK;

        // Raise the flag that the pipe list needs to be updated
        InterlockedExchange(&_needUpdateList, 1);
    }
    
Cleanup:
    if (hEvent != NULL)
        CloseHandle(hEvent);

    HANDLE hTemp = _hRegistryMonitorThread;
    _hRegistryMonitorThread = NULL;
    CloseHandle(hTemp);

    return hr;
}

HRESULT CPerfCounterClient::GetDataFromWP(CPerfPipeAry * handleList, CPerfData * globalData, HashtableGeneric * dataTable)
{
    HRESULT hr = S_OK;
    HANDLE hPipe;
    PerfPipeInfo * pipeInfo;
    
    for (int i = 0; i < handleList->Size(); i++) {
        pipeInfo = (*handleList)[i];
        hPipe = pipeInfo->hPipe;

        // If handle is invalid, try opening the pipe
        if (hPipe == INVALID_HANDLE_VALUE) {
            // Note that we create the pipe with anonymous security only, to prevent
            // the server from impersonating us
            hPipe = CreateFile(pipeInfo->wcsPipeName, 
                   GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL,
                   OPEN_EXISTING,
                   FILE_FLAG_OVERLAPPED | SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS,
                   NULL);

            if (hPipe == INVALID_HANDLE_VALUE) {
#if DBG
                DWORD dwErrorCode = GetLastError();
                if (dwErrorCode) TRACE_ERROR(E_FAIL);
#endif
            }
            else {
                pipeInfo->hPipe = hPipe;
            }
        }

        // If we now have a valid pipe handle, read from it
        if (hPipe != INVALID_HANDLE_VALUE) {
            hr = ReadPipeData(hPipe, dataTable, globalData);
            if (hr != S_OK) {
                // On any error, close the handle and invalidate it from the list
                CancelIo(hPipe);
                CloseHandle(hPipe);
                pipeInfo->hPipe = INVALID_HANDLE_VALUE;
                continue;
            }
        }
    }

    return hr;
}

HRESULT CPerfCounterClient::UpdateHandleList(CPerfPipeAry * handleList)
{
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    WCHAR pipeName[MAX_PATH] = PIPE_PREFIX_L;
    DWORD keyNameLength;
    DWORD index;
    LONG retCode = 0;
    HANDLE hPipe;
    PerfPipeInfo * pipeInfo;

    // Close all old handles
    for(int i = 0; i < handleList->Size(); i++) {
        pipeInfo = (*handleList)[i];
        hPipe = pipeInfo->hPipe;
        if (hPipe != INVALID_HANDLE_VALUE) {
            CancelIo(hPipe);
            CloseHandle(hPipe);
        }

        delete pipeInfo;
    }

    // Empties the array
    handleList->DeleteAll();

    // Opens the perf names key
    retCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_PERF_VERSIONED_NAMES_KEY_L, 0, KEY_READ, &hKey);
    ON_WIN32_ERROR_EXIT(retCode);

    // Shift and copy the pipe prefix into the buffer
    WCHAR * keyName = pipeName + PIPE_PREFIX_LENGTH;

    for (index = 0; ;index++) {
        keyNameLength = ARRAY_SIZE(pipeName) - PIPE_PREFIX_LENGTH;
        retCode = RegEnumValue(hKey, index, keyName, &keyNameLength, 0, 0, 0, NULL);
        // null terminate pipeName
        pipeName[ARRAY_LENGTH(pipeName) - 1] = L'\0';
        if (retCode == ERROR_SUCCESS) {
            pipeInfo = new PerfPipeInfo;
            pipeInfo->hPipe = INVALID_HANDLE_VALUE;
            hr = StringCchCopyW(pipeInfo->wcsPipeName, PERF_PIPE_NAME_MAX_BUFFER, pipeName);
            ON_ERROR_EXIT();

            handleList->Append(pipeInfo);   
        }
        else if (retCode == ERROR_NO_MORE_ITEMS) {
            break;
        }
        else if (retCode != ERROR_MORE_DATA)  // If data was longer than MAX_PATH, ignore it and go on -- anything else raise an error
            EXIT_WITH_WIN32_ERROR(retCode);
    }

Cleanup:
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return hr;
}

HRESULT CPerfCounterClient::GatherPerfData()
{
    HRESULT hr = S_OK;
    CPerfData * globalData = NULL;
    HashtableGeneric * instanceData = NULL;
    CPerfPipeAry * handleList = NULL;
    int tableSize = 431;
    int listSize;
    bool sleepAgain;

    handleList = new CPerfPipeAry;
    ON_OOM_EXIT(handleList);

    // Get the list of handles when we begin
    hr = UpdateHandleList(handleList);
    ON_ERROR_CONTINUE(); hr = S_OK;

    _lpOverlapped = (LPOVERLAPPED) NEW_CLEAR_BYTES(sizeof(OVERLAPPED));
    ON_OOM_EXIT(_lpOverlapped);

    _lpOverlapped->hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    while (TRUE) {
        // See if there's a new set of pipes we need to monitor
        if (InterlockedExchange(&_needUpdateList, 0) == 1) {
            hr = UpdateHandleList(handleList);
            ON_ERROR_CONTINUE(); hr = S_OK;
        }
        
        // Only do work if there are pipes to conenct
        listSize = handleList->Size();
        if (listSize != 0) {
            globalData = new CPerfData;
            ON_OOM_EXIT(globalData);
        
            instanceData = new HashtableGeneric;
            ON_OOM_EXIT(instanceData);

            if (listSize < 20) {
                tableSize = 11;
            }
            else if (listSize < 100) {
                tableSize = 59;
            }
            else if (listSize < 250) {
                tableSize = 131;
            }
            else {
                tableSize = 431;
            }
                
            instanceData->Init(tableSize);

            hr = GetDataFromWP(handleList, globalData, instanceData);
            ON_ERROR_CONTINUE(); hr = S_OK;
            
            if (globalData != NULL && instanceData != NULL) {
                _perfLock.AcquireWriterLock();
                __try {
                    if (_appDataTable != NULL) {
                        _appDataTable->Enumerate(&DeleteDataCallback, NULL);
                        delete _appDataTable;
                    }

                    delete _globalData;

                    _appDataTable = instanceData;
                    _globalData = globalData;

                    GetSystemTimeAsFileTime((FILETIME *) &_lastGatherTime);
                    if (!SetEvent(_hGatherWaitEvent)) {
                        CONTINUE_WITH_LAST_ERROR(); hr = S_OK;
                    }
                }
                __finally {
                    _perfLock.ReleaseWriterLock();
                }

                globalData = NULL;
                instanceData = NULL;
            }
        }


        // Sleep loop
        // If there are no pending opens and the timer expires, we will just sleep again
        do {
            sleepAgain = FALSE;
            switch (WaitForSingleObject(_hGoGatherEvent, PERF_POLL_SLEEP_TIME_MS)) {
                case WAIT_ABANDONED:
                    TRACE(L"CounterServerMore", L"Event abandoned");
                    break;
                case WAIT_OBJECT_0:
                    TRACE(L"CounterServerMore", L"Gather event signalled");
                    break;
                case WAIT_TIMEOUT:
                    TRACE(L"CounterServerMore", L"Gather event timed out");
                    if (_openCount == 0) {
                        sleepAgain = TRUE;
                    }
                    break;
                default:
                    CONTINUE_WITH_LAST_ERROR();
            }
        } while (sleepAgain);
    }

Cleanup:
    for(int i = 0; i < handleList->Size(); i++) {
        PerfPipeInfo * pipeInfo = (*handleList)[i];
        if (pipeInfo->hPipe != INVALID_HANDLE_VALUE) {
            CancelIo(pipeInfo->hPipe);
            CloseHandle(pipeInfo->hPipe);
        }
        delete pipeInfo;
    }

    delete handleList;

    if (_lpOverlapped != NULL && _lpOverlapped->hEvent != NULL)
        CloseHandle(_lpOverlapped->hEvent);
    
    DELETE_BYTES(_lpOverlapped);
    _lpOverlapped = NULL;

    HANDLE hTemp = _hDataCollectorThread;
    _hDataCollectorThread = NULL;
    CloseHandle(hTemp);
        
    return hr;
}

void DeleteDataCallback(void * pValue, void * pArgument) 
{
    CPerfData * perfData = (CPerfData*) pValue;
    DELETE_BYTES(perfData);
}

HRESULT CPerfCounterClient::WaitForAsync(HANDLE hPipe, DWORD lastError)
{
    HRESULT hr = S_OK;
    
    if (lastError == ERROR_IO_PENDING) {
        switch (WaitForSingleObject(_lpOverlapped->hEvent, 10000)) {
            case WAIT_ABANDONED:
                EXIT_WITH_HRESULT(E_UNEXPECTED);
                break;
            case WAIT_OBJECT_0:
                // Ok, async write completed, just go on
                break;
            case WAIT_TIMEOUT:
                // If timed out, server may be bad.  Cancel Io and exit with error.
                TRACE(L"CounterServer", L"Timed out waiting for named pipe");
                if (!CancelIo(hPipe)) {
                    EXIT_WITH_LAST_ERROR();
                }
                EXIT_WITH_HRESULT(E_UNEXPECTED);
                break;
            default:
                EXIT_WITH_LAST_ERROR();
        }
    }
    else {
        TRACE1(L"CounterServer", L"Error reading/writing: %d", GetLastError());

        EXIT_WITH_WIN32_ERROR(lastError);
    }

Cleanup:
    return hr;
}

HRESULT CPerfCounterClient::ReadPipeData(HANDLE hPipe, HashtableGeneric * dataTable, CPerfData * globalData)
{
    HRESULT hr = S_OK;
    CPerfData * savedData;
    CPerfDataHeader dataHeader;
    DWORD bytesNum = 0;
    int bytesRead;
    void * obj;
    int keyLength;
    long hashVal;
    BOOL isLastPacket = FALSE;
    CPerfData * perfData;
    BYTE * nextData;
    int dataSize;

    // Write version info to the pipe
    // If the server expects a different version message, it'll close the pipe, with an
    // error returned here.  Just exit in that case
    if (!WriteFile(hPipe, _versionMessage, sizeof(CPerfVersion), NULL, _lpOverlapped)) {
        hr = WaitForAsync(hPipe, GetLastError());
        ON_ERROR_EXIT();
    }   

    while (! isLastPacket) {
        // Wait and read the header -- it should be the size of the data to be received    
        dataHeader.transmitDataSize = 0;
        bytesRead = 0;
        while (bytesRead < sizeof(CPerfDataHeader)) {
            if (!ReadFile(hPipe, (((BYTE*) &dataHeader) + bytesRead), sizeof(CPerfDataHeader) - bytesRead, NULL, _lpOverlapped)) {
                hr = WaitForAsync(hPipe, GetLastError());
                ON_ERROR_EXIT();
            }

            if (!GetOverlappedResult(hPipe, _lpOverlapped, &bytesNum, FALSE))
                EXIT_WITH_LAST_ERROR();

            TRACE1(L"CounterServer", L"Header bytes read from pipe: %d", bytesNum);
            bytesRead += bytesNum;
        }

        if (bytesNum != sizeof(CPerfDataHeader))
            EXIT_WITH_HRESULT(E_UNEXPECTED);

        isLastPacket = dataHeader.transmitDataSize < 0 ? TRUE : FALSE;
        dataHeader.transmitDataSize = dataHeader.transmitDataSize < 0 ? -dataHeader.transmitDataSize : dataHeader.transmitDataSize;

        if (dataHeader.transmitDataSize > CPerfDataHeader::MaxTransmitSize) {
            EXIT_WITH_HRESULT(E_UNEXPECTED);
        }

        if (dataHeader.transmitDataSize > _receiveBufferSize) {
            DELETE_BYTES(_receiveBuffer);
            _receiveBufferSize = 0;

            _receiveBuffer = NEW_BYTES(dataHeader.transmitDataSize);
            ON_OOM_EXIT(_receiveBuffer);
            _receiveBufferSize = dataHeader.transmitDataSize;
        }

        // Read data packet
        bytesRead = 0;
        while (bytesRead < dataHeader.transmitDataSize) {
            if (!ReadFile(hPipe, _receiveBuffer + bytesRead, dataHeader.transmitDataSize - bytesRead, NULL, _lpOverlapped)) {
                hr = WaitForAsync(hPipe, GetLastError());
                ON_ERROR_EXIT();
            }

            if (!GetOverlappedResult(hPipe, _lpOverlapped, &bytesNum, FALSE))
                EXIT_WITH_LAST_ERROR();

            TRACE1(L"CounterServer", L"Data bytes read from pipe: %d", bytesNum);
            bytesRead += bytesNum;
        }

        // If packet size doesn't match expected size, exit
        if (bytesRead != dataHeader.transmitDataSize) {
            EXIT_WITH_WIN32_ERROR(E_UNEXPECTED);
        }

        nextData = _receiveBuffer;
      
        while (nextData < (_receiveBuffer + dataHeader.transmitDataSize)) {
            perfData = (CPerfData *) nextData;

            // Do parameter check on the nameLength and name fields
            if (perfData->nameLength < 0 || perfData->nameLength >= CPerfData::MaxNameLength)
                EXIT_WITH_WIN32_ERROR(E_UNEXPECTED);

            // Calculate this data packet size
            dataSize = sizeof(CPerfData) + (perfData->nameLength * sizeof(perfData->name[0]));

            // Is the data claimed to end be beyond the end of the buffer?
            if ((nextData + dataSize) > (_receiveBuffer + dataHeader.transmitDataSize)) {
                EXIT_WITH_WIN32_ERROR(E_UNEXPECTED);
            }

            if (perfData->nameLength == 0 && perfData->name[0] == L'\0') {
                SumGlobalData(globalData, perfData);
            }
            else {
                // Check and ensure that the string is properly sized and null terminated
                for (int i = 0; i < perfData->nameLength; i++) {
                    if (perfData->name[i] == L'\0') {
                        EXIT_WITH_WIN32_ERROR(E_UNEXPECTED);
                    }
                }
                if (perfData->name[perfData->nameLength] != L'\0') {
                    EXIT_WITH_WIN32_ERROR(E_UNEXPECTED);
                }

                // String is ok, look it up in the hashtable
                obj = NULL;
                keyLength = (perfData->nameLength + 1) * sizeof(perfData->name[0]);
                hashVal = SimpleHash((BYTE*) perfData->name, keyLength);
                dataTable->Find((BYTE *)perfData->name, keyLength, hashVal, &obj);

                // If we have a previous instance of it, merge the data
                if (obj != NULL) {
                    // Merge instance perf counter data
                    savedData = (CPerfData *) obj;
                    for (int i = 0; i < PERF_NUM_DWORDS; i++) {
                        savedData->data[i] += perfData->data[i];
                    }
                }
                else {
                    // Store new object into hashtable
                    CPerfData * tmpData = (CPerfData *) NEW_BYTES(sizeof(CPerfData) + (perfData->nameLength * sizeof(perfData->name[0])));
                    ON_OOM_EXIT(tmpData);
                    
                    CopyMemory(tmpData, perfData, sizeof(CPerfData) + (perfData->nameLength * sizeof(perfData->name[0])));
                    hr = dataTable->Insert((BYTE*) tmpData->name, keyLength, hashVal, tmpData, NULL);
                    ON_ERROR_EXIT();
                }
            }
            nextData += dataSize;
        }
    }

Cleanup:

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if DBG

#define WriteDebugString1(buf, szFormat, arg1) StringCbPrintfW(buf, sizeof(buf), szFormat, arg1); OutputDebugString(buf);
#define WriteDebugString2(buf, szFormat, arg2) StringCbPrintfW(buf, sizeof(buf), szFormat, arg1, arg2); OutputDebugString(buf);

void CPerfCounterClient::DumpPerfData(void *pData, int numObjects)
{
    WCHAR buf[256];

    for (int objNum = 0; objNum < numObjects; objNum++) {
        _PERF_OBJECT_TYPE * objType = (_PERF_OBJECT_TYPE *) pData;

        WriteDebugString1(buf, L"Object start address: 0x%X\n", objType);
        WriteDebugString1(buf, L"    TotalByteLength: %d\n", objType->TotalByteLength);
        WriteDebugString1(buf, L"    DefinitionLength: %d\n", objType->DefinitionLength);
        WriteDebugString1(buf, L"    HeaderLength: %d\n", objType->HeaderLength);
        WriteDebugString1(buf, L"    NumCounters: %d\n", objType->NumCounters);
        WriteDebugString1(buf, L"    NumInstances: %d\n", objType->NumInstances);

        pData = (((BYTE*) pData) + objType->HeaderLength);

        for (DWORD i = 0; i < objType->NumCounters; i++) {
            _PERF_COUNTER_DEFINITION * counterDef = (_PERF_COUNTER_DEFINITION *) pData;
            WriteDebugString1(buf, L"Definition start address: 0x%X\n", counterDef);
            WriteDebugString1(buf, L"    ByteLength: %d\n", counterDef->ByteLength);
            WriteDebugString1(buf, L"    CounterSize: %d\n", counterDef->CounterSize);
            WriteDebugString1(buf, L"    CounterOffset: %d\n", counterDef->CounterOffset);
            pData = (((BYTE *) pData) + counterDef->ByteLength);
        }

        if (objType->NumInstances == -1) {
            WriteDebugString1(buf, L"Data start address: 0x%X\n", pData);
            WriteDebugString1(buf, L"    Data length: %d\n", *((DWORD *) pData));

            DWORD alignedPtrValue = ALIGN8(PtrToUint((((BYTE*) pData) + *((DWORD *) pData))));
            pData = LongToPtr(alignedPtrValue);
        }
        else {        
            for (LONG i = 0; i < objType->NumInstances; i++) {
                _PERF_INSTANCE_DEFINITION * instanceDef = (_PERF_INSTANCE_DEFINITION *) pData;
            
                WriteDebugString1(buf, L"Instance start address: 0x%X\n", instanceDef);
                WriteDebugString1(buf, L"    ByteLength: %d\n", instanceDef->ByteLength);
                WriteDebugString1(buf, L"    NameOffset: %d\n", instanceDef->NameOffset);
                WriteDebugString1(buf, L"    NameLength: %d\n", instanceDef->NameLength);
                WriteDebugString1(buf, L"    Name: %s\n", (WCHAR *) (((BYTE *) instanceDef) + instanceDef->NameOffset));
                pData = (((BYTE*) pData) + instanceDef->ByteLength);

                WriteDebugString1(buf, L"Data start address: 0x%X\n", pData);
                WriteDebugString1(buf, L"    Data length: %d\n", *((DWORD *) pData));

                DWORD alignedPtrValue = ALIGN8(PtrToUint((((BYTE*) pData) + *((DWORD *) pData))));
                pData = LongToPtr(alignedPtrValue);
            }
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\processtablemanager.h ===
/**
 * ProcessTableManager header file
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

/////////////////////////////////////////////////////////////////////////////
// This file defines the class CProcessTableManager. This class creates and
// holds on to an array of CPUEntry classes. When a request comes in, the
// least busy CPU is picked and assigned the request.
/////////////////////////////////////////////////////////////////////////////

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _ProcessTableManager_H
#define _ProcessTableManager_H

#include "ProcessEntry.h"
#include "names.h"
#include "MessageDefs.h"

enum EPMConfig
{
    EPMConfig_enable,
    EPMConfig_timeout,
    EPMConfig_idletimeout,
    EPMConfig_shutdowntimeout,
    EPMConfig_requestlimit,
    EPMConfig_requestqueuelimit,
    EPMConfig_memorylimit,
    EPMConfig_cpumask,
    EPMConfig_webgarden,
    EPMConfig_requestacks,
    EPMConfig_asyncoption,
    EPMConfig_restartQLimit,
    EPMConfig_pingFrequency,
    EPMConfig_pingTimeout,
    EPMConfig_responseRestartDeadlockInterval,
    EPMConfig_responseDeadlockInterval,
    EPMConfig_maxWorkerThreads,
    EPMConfig_maxIoThreads
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Function called from IIS
HRESULT __stdcall AssignRequestUsingXSPProcessModel (EXTENSION_CONTROL_BLOCK * iECB);
void    __stdcall ProcessModelStopHealthMonitor     ();
HRESULT __stdcall ProcessModelInit                  ();
void    __cdecl   MonitorHealth                     (void *);

/////////////////////////////////////////////////////////////////////////////
// 
class CProcessTableManager
{
public:
    // Init method: Need not be called directly: First call to
    //              AssignRequest will call it
    static HRESULT  Init                   ();

    // Commit suicide...
    static void     Destroy                ();

    // Get Number of pending requests
    static LONG     NumPendingRequests     ();
    
    static DWORD    GetTerminateTimeout    ();

    static int      GetServerVariable      (EXTENSION_CONTROL_BLOCK * ecb, LPCSTR  name, LPSTR buffer, int bufferSize);

    static BOOL     GetUseCPUAffinity      ();

    static CProcessEntry * GetProcess      (DWORD dwProcNum);
    
    static BOOL     GetWillRequestsBeAcknowledged ();

    static void     LogWorkerProcessDeath  (EReasonForDeath eReason, DWORD dwPID);


    static int      NumActiveCPUs          ();

    static DWORD   GetRestartQLimit        ();
    static DWORD   GetRequestQLimit        ();

    static void    GetPingConfig           (DWORD & dwFreq, DWORD & dwTimeout);

    static DWORD   GetWPMemoryLimitInMB    ();
    
    static HANDLE  GetWorkerProcessToken   ();
    static HANDLE  GetWorkerProcessProfile ();
    static HANDLE  GetWorkerProcessSid     ();

    static void    ResetRequestQueuedCounter(int requestsDied);
    

private:

    ////////////////////////////////////////////////////////////
    // Private functions
    CProcessTableManager                   ();
    ~CProcessTableManager                  ();
    
    BOOL     IsAlive                       () { return(m_pCPUArray!=NULL);}
    static void              CreateWPToken ();

    LONG     PrivateNumPendingRequests     ();
    HRESULT  PrivateAssignRequest          (EXTENSION_CONTROL_BLOCK * iECB);
    void     PrivateMonitorHealth          ();
    void     ReadConfiguration             (DWORD & dwCPUMask);

    CCPUEntry *                            m_pCPUArray;
    int                                    m_iCPUArraySize;    
    int                                    m_iRequestsLimit;
    TimeClass                              m_tmLastCreateProcessFailure;
    CRITICAL_SECTION                       m_csMonitorHealth;
    DWORD                                  m_dwHealthMonitorPeriod;

    // this pointer: Single instance class
    static CProcessTableManager *          g_pProcessTableManager;


    // friends: So that they can access g_pProcessTableManager
    friend HRESULT __stdcall AssignRequestUsingXSPProcessModel (EXTENSION_CONTROL_BLOCK * iECB);
    friend void    __stdcall ProcessModelStopHealthMonitor     ();
    friend void    __cdecl   MonitorHealth                     (void *);
    friend HRESULT __stdcall ProcessModelInit                  ();
};

/////////////////////////////////////////////////////////////////////////////

#define  SZ_REG_XSP_PROCESS_MODEL_KEY                       REGPATH_MACHINE_APP_L L"\\ProcessModel"
#define  SZ_XSP_REGISTRY_PROCESS_MODEL_HOSTS_KEY            REGPATH_MACHINE_APP_L L"\\ProcessModel\\Hosts"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\processtablemanager.cxx ===
/**
 * Process Model: CProcessTableManager defn file 
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

/////////////////////////////////////////////////////////////////////////////
// This file defines the class CProcessTableManager. This class creates and
// holds on to an array of CPUEntry classes. When a request comes in, the
// least busy CPU is picked and assigned the request.
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "ProcessTableManager.h"
#include "nisapi.h"
#include "util.h"
#include "platform_apis.h"
#include "AckReceiver.h"
#include "RequestTableManager.h"
#include "httpext6.h"
#include "CPUEntry.h"
#include "EcbImports.h"
#include "process.h"
#include "TimeClass.h"
#include "HistoryTable.h"
#include "_ndll.h"
#include "event.h"
#include "regaccount.h"
#include "Userenv.h"
#include "perfcounters.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define  MIN_PROC_START_WAIT_TIME               30
#define  HEALTH_MONITORING_DEFAULT_PERIOD       20
#define  DEFAULT_WP_TERMINATE_TIMEOUT           5 
#define  ROUND_TO_4_BYTES(X)                    {X += ((X & 3) ? 4 - (X & 3) : 0); }
#define  MIN_MEMORY_LIMIT                       10
#define  NUM_PM_PROPERTIES                      18
#define  SZ_PM_CONFIG_TAG                       L"processModel"
#define  DEFAULT_MEMORY_LIMIT_IN_PERCENT        80

#define  NUM_PM_PROPERTIES_STRINGS              6
LPWSTR   g_szPropValues                         [NUM_PM_PROPERTIES_STRINGS];
LPCWSTR  g_szPMPropertiesStrings               [NUM_PM_PROPERTIES_STRINGS] = { 
    L"userName", 
    L"password", 
    L"logLevel",  
    L"comAuthenticationLevel",
    L"comImpersonationLevel",
    L"serverErrorMessageFile"};

WCHAR    g_szUserName[104]                      = L"";
WCHAR    g_szPassword[104]                      = L"";
WCHAR    g_szLogLevel[104]                      = L"errors";
int      g_iLogLevel                            = 1;
BOOL     g_fInvalidCredentials                  = FALSE;

int 
__stdcall
GetUserNameFromToken (
        HANDLE        token, 
        LPWSTR        buffer,
        int           size);

void
XspSecureZeroMemory(
        PVOID  pPtr,
        SIZE_T  len);

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Config enum

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Global data
CProcessTableManager * CProcessTableManager::g_pProcessTableManager = NULL;
LONG                   g_lCreatingProcessTable                      = 0;
LONG                   g_lDestroyingProcessTable                    = 0;
WCHAR                  g_szLogDir[256]                              = L"";
BOOL                   g_fShuttingDown                              = FALSE;
BOOL                   g_fHealthMonitorStopped                      = TRUE;
BOOL                   g_fStopHealthMonitor                         = FALSE;
BOOL                   g_fLogWorkerProcs                            = FALSE;
BOOL                   g_fUseXSPProcessModel                        = FALSE;
LPCWSTR                g_szPMProperties[NUM_PM_PROPERTIES]          = {  L"enable", 
                                                                         L"timeout",
                                                                         L"idleTimeout", 
                                                                         L"shutdownTimeout", 
                                                                         L"requestLimit", 
                                                                         L"requestQueueLimit", 
                                                                         L"memoryLimit", 
                                                                         L"cpuMask", 
                                                                         L"webGarden",
                                                                         L"requestAcks",
                                                                         L"asyncOption",
                                                                         L"restartQueueLimit",
                                                                         L"pingFrequency",
                                                                         L"pingTimeout",
                                                                         L"responseRestartDeadlockInterval",
                                                                         L"responseDeadlockInterval",
                                                                         L"maxWorkerThreads",
                                                                         L"maxIoThreads"
};

DWORD                  g_dwPropValues[NUM_PM_PROPERTIES];

DWORD                  g_dwDefaultPropValues[NUM_PM_PROPERTIES] =      { 1, 
                                                                        0x7fffffff, 
                                                                        0x7fffffff, 
                                                                        5, 
                                                                        0x7fffffff, 
                                                                        5000, 
                                                                        60, 
                                                                        0xffff, 
                                                                        0,
                                                                        0,
                                                                        0,
                                                                        10,
                                                                        30,
                                                                        5,
                                                                        540,
                                                                        180,
                                                                        20,
                                                                        20
};

DWORD g_dwMaxPhyMemory           =  0;
DWORD g_dwProcessMemoryLimitInMB =  10;
BOOL  g_fWebGarden               = FALSE;
int   g_iAsyncOption             = 0;
DWORD g_dwRPCAuthLevel           = RPC_C_AUTHN_LEVEL_CONNECT;
DWORD g_dwRPCImperLevel          = RPC_C_IMP_LEVEL_IMPERSONATE;
DWORD g_dwMaxWorkerThreads       = 25;
DWORD g_dwMaxIoThreads           = 25;
HANDLE g_hToken                  = INVALID_HANDLE_VALUE;
HANDLE g_hProfile                = NULL;
LONG   g_lTokenCreated           = 0;
BOOL   g_fPasswordIsEncrypted    = FALSE;
DWORD  g_dwPassLength            = NULL;
LPBYTE g_pEncPassword            = NULL;
PSID   g_pSid                    = NULL;

#define SZ_PASSWORD_ENTROPY L"ASP.NET Password from Machine.config file entropy" 
#define SZ_PASSWORD_PASS L"ASP.NET Password from Machine.config file"

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
// Functions

DWORD
GetDebugOnDeadlock()
{
    HKEY      hKeyXSP;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_MACHINE_APP_L,
                     0, KEY_READ, &hKeyXSP) != ERROR_SUCCESS)
        return FALSE; // registry key doesn't exists
    
    DWORD dwVal = 0, dwSize = sizeof(DWORD);
    RegQueryValueEx(hKeyXSP, L"DebugOnDeadlock", 0, NULL, (BYTE *) &dwVal, &dwSize);
    RegCloseKey(hKeyXSP);
    
    if (dwVal == 2 || dwVal == 1) return dwVal;
    else return 0;

}

BOOL
DebugOnHighMemoryConsumption()
{
    HKEY      hKeyXSP;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_MACHINE_APP_L, 
                     0, KEY_READ, &hKeyXSP) != ERROR_SUCCESS)
        return FALSE; // registry key doesn't exists

    DWORD dwVal = 0, dwSize = sizeof(DWORD);
    RegQueryValueEx(hKeyXSP, L"DebugOnHighMem", 0, NULL, (BYTE *) &dwVal, &dwSize);
    RegCloseKey(hKeyXSP);
    return (dwVal != 0);
}

HRESULT
GetCredentialFromRegistry(
        LPCWSTR   szReg,
        LPWSTR    szStr,
        DWORD    dwSize);

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void
EncryptPassword(
        LPWSTR szSrc)
{
    HRESULT     hr = S_OK;
    DATA_BLOB   dataIn, dataOut, dataEnt;

    dataOut.cbData = 0;
    dataOut.pbData = NULL;

    g_fPasswordIsEncrypted = FALSE;
    delete [] g_pEncPassword;
    g_pEncPassword = NULL;
    g_dwPassLength = 0;

    if (szSrc == NULL || szSrc[0] == NULL)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    if (lstrcmpiW(szSrc, L"autogenerate") == 0) // No point encrypting autogenerate
        EXIT();

    if (lstrlen(szSrc) > 8 && szSrc[8] == L':') // 8 == lstrlen(L"registry"))
    {
        WCHAR c = szSrc[8];
        szSrc[8] = NULL;
        if (_wcsicmp(szSrc, L"registry") == 0)
        {
            szSrc[8] = c;
            EXIT(); // No point encrypting registry key name
        }

        szSrc[8] = c;
    }


    dataIn.cbData = (lstrlen(szSrc) + 1) * sizeof(WCHAR);
    dataIn.pbData = (LPBYTE) szSrc;
    dataOut.cbData = 0;
    dataOut.pbData = NULL;
    dataEnt.cbData = (lstrlenW(SZ_PASSWORD_ENTROPY) + 1) * sizeof(WCHAR);
    dataEnt.pbData = (LPBYTE) SZ_PASSWORD_ENTROPY;
    
    if (CryptProtectData(&dataIn, SZ_PASSWORD_PASS, &dataEnt, NULL, NULL, CRYPTPROTECT_UI_FORBIDDEN, &dataOut))
    {
        g_pEncPassword = new BYTE[dataOut.cbData];
        ON_OOM_EXIT(g_pEncPassword);
        memcpy(g_pEncPassword, dataOut.pbData, dataOut.cbData);
        g_dwPassLength = dataOut.cbData;
        g_fPasswordIsEncrypted = TRUE;
    }
    else
    {
        EXIT_WITH_LAST_ERROR();
    }

 Cleanup:
    // Check if there is something to encrypt and we have not encrypted anything
    if (szSrc != NULL && szSrc[0] != NULL && !g_fPasswordIsEncrypted)
    {
        wcsncpy(g_szPassword, szSrc, ARRAY_SIZE(g_szPassword)-1);
        g_szPassword[ARRAY_SIZE(g_szPassword)-1] = NULL;
    }
    // Destroy the source string
    if (szSrc != NULL)
    {
        XspSecureZeroMemory(szSrc, lstrlen(szSrc) * sizeof(WCHAR));
    }
    if (dataOut.pbData != NULL)
        LocalFree(dataOut.pbData);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void
UnEncryptPassword(
        LPWSTR szDest,
        DWORD  dwSize)
{
    HRESULT     hr = S_OK;
    DATA_BLOB   dataIn, dataOut, dataEnt;

    dataOut.cbData = 0;
    dataOut.pbData = NULL;

    if (szDest == NULL || dwSize < 1)
        EXIT_WITH_HRESULT(E_INVALIDARG);
        
    ZeroMemory(szDest, dwSize * sizeof(WCHAR));
    if (g_fPasswordIsEncrypted == FALSE)
    {
        if (wcsstr(g_szPassword, L"registry:") == g_szPassword || wcsstr(g_szPassword, L"Registry:") == g_szPassword) // starts with "registry:"
        {
            GetCredentialFromRegistry(g_szPassword, szDest, dwSize);
        }
        else
        {
            wcsncpy(szDest, g_szPassword, dwSize-1);            
        }
    }
    else
    {
        if (g_pEncPassword == NULL)
            EXIT_WITH_HRESULT(E_UNEXPECTED);

        dataIn.cbData = g_dwPassLength;
        dataIn.pbData = g_pEncPassword;
        dataEnt.cbData = (lstrlenW(SZ_PASSWORD_ENTROPY) + 1) * sizeof(WCHAR);
        dataEnt.pbData = (LPBYTE) SZ_PASSWORD_ENTROPY;

        if (!CryptUnprotectData(&dataIn, NULL, &dataEnt, NULL, NULL, CRYPTPROTECT_UI_FORBIDDEN, &dataOut))
        {
            dataOut.pbData = NULL;
            EXIT_WITH_LAST_ERROR();
        }

        memcpy(szDest, dataOut.pbData, (dataOut.cbData < dwSize * sizeof(WCHAR)) ? dataOut.cbData : dwSize * sizeof(WCHAR));
    }

    szDest[dwSize-1] = NULL;

 Cleanup:
    if (dataOut.pbData != NULL)
        LocalFree(dataOut.pbData);
}

////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// 

/**
 * Function to decide whether we should use the ASP.NET Process Model
 */

BOOL 
UseXSPProcessModel()
{
    WCHAR szRPCAuth  [104] = L"";
    WCHAR szRPCImper [104] = L"";
    WCHAR szUserName [104] = L"";
    WCHAR szPassword [104] = L"";

    //////////////////////////////////////////////////////////////////
    // Step 1: Initialize globals
    g_lCreatingProcessTable    = 0;
    g_lDestroyingProcessTable  = 0;
    g_fShuttingDown            = FALSE;
    g_fHealthMonitorStopped    = TRUE;
    g_fStopHealthMonitor       = FALSE;
    g_fLogWorkerProcs          = FALSE;
    memcpy(g_dwPropValues, g_dwDefaultPropValues, sizeof(g_dwPropValues));

    ////////////////////////////////////////////////////////////
    // Step 3: Parse the config file
    g_szPropValues[0] = szUserName;
    g_szPropValues[1] = szPassword;
    g_szPropValues[2] = g_szLogLevel;
    g_szPropValues[3] = szRPCAuth;
    g_szPropValues[4] = szRPCImper;
    g_szPropValues[5] = g_szCustomErrorFile;

    g_szCustomErrorFile[0] = NULL;
    g_fCustomErrorFileChanged = TRUE;
    
    BOOL fRet = GetConfigurationFromNativeCode(
            Names::GlobalConfigFullPathW(), 
            SZ_PM_CONFIG_TAG, 
            g_szPMProperties, 
            g_dwPropValues, 
            NUM_PM_PROPERTIES,
            g_szPMPropertiesStrings, 
            g_szPropValues, 
            NUM_PM_PROPERTIES_STRINGS,
            NULL, 
            0);
    ASSERT(fRet);    
    g_iAsyncOption = g_dwPropValues[EPMConfig_asyncoption];
    if (!fRet)
        g_dwPropValues[EPMConfig_enable] = 1;
    if (g_dwMaxPhyMemory == 0)
    {
        MEMORYSTATUSEX memStatEx;
        ZeroMemory(&memStatEx, sizeof(memStatEx));
        memStatEx.dwLength = sizeof(memStatEx);
        
        if (PlatformGlobalMemoryStatusEx(&memStatEx))
        {
            g_dwMaxPhyMemory = (DWORD) (memStatEx.ullTotalPhys / (1024 * 1024));         
        }
        else
        {
            // This following code fragment should never run on Win64
#ifdef _WIN64
            ASSERTMSG(FALSE, L"GlobalMemoryStatus shouldn't be call on Win64");
#else
            MEMORYSTATUS memStat;
            ZeroMemory(&memStat, sizeof(memStat));
            GlobalMemoryStatus(&memStat);
            g_dwMaxPhyMemory = ((DWORD)memStat.dwTotalPhys / (1024 * 1024));         
#endif            
        }
    }

    g_dwProcessMemoryLimitInMB = (g_dwPropValues[EPMConfig_memorylimit] * g_dwMaxPhyMemory) / 100;
    if (g_dwProcessMemoryLimitInMB < MIN_MEMORY_LIMIT)
        g_dwProcessMemoryLimitInMB = MIN_MEMORY_LIMIT;

    if (_wcsicmp(g_szLogLevel, L"errors") == 0)
        g_iLogLevel = 1;
    else if (_wcsicmp(g_szLogLevel, L"none") == 0)
        g_iLogLevel = 0;
    else if (_wcsicmp(g_szLogLevel, L"warnings") == 0)
        g_iLogLevel = 2;
    else            
        g_iLogLevel = 3;


    if (_wcsicmp(L"None", szRPCAuth) == 0)
        g_dwRPCAuthLevel = RPC_C_AUTHN_LEVEL_NONE;
    else if (_wcsicmp(L"Connect", szRPCAuth) == 0)
        g_dwRPCAuthLevel = RPC_C_AUTHN_LEVEL_CONNECT;
    else if (_wcsicmp(L"Call", szRPCAuth) == 0)
        g_dwRPCAuthLevel = RPC_C_AUTHN_LEVEL_CALL;
    else if (_wcsicmp(L"Pkt", szRPCAuth) == 0)
        g_dwRPCAuthLevel = RPC_C_AUTHN_LEVEL_PKT;
    else if (_wcsicmp(L"PktIntegrity", szRPCAuth) == 0)
        g_dwRPCAuthLevel = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
    else if (_wcsicmp(L"PktPrivacy", szRPCAuth) == 0)
        g_dwRPCAuthLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
    else if (_wcsicmp(L"Default", szRPCAuth) == 0)
        g_dwRPCAuthLevel = RPC_C_AUTHN_LEVEL_DEFAULT;
    else
        g_dwRPCAuthLevel = RPC_C_AUTHN_LEVEL_CONNECT;

    if (_wcsicmp(L"Anonymous", szRPCImper) == 0)
        g_dwRPCImperLevel = RPC_C_IMP_LEVEL_ANONYMOUS;
    else if (_wcsicmp(L"Identify", szRPCImper) == 0)
        g_dwRPCImperLevel = RPC_C_IMP_LEVEL_IDENTIFY;
    else if (_wcsicmp(L"Impersonate", szRPCImper) == 0)
        g_dwRPCImperLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
    else if (_wcsicmp(L"Delegate", szRPCImper) == 0)
        g_dwRPCImperLevel = RPC_C_IMP_LEVEL_DELEGATE;
    else if (_wcsicmp(L"Default", szRPCImper) == 0)
        g_dwRPCImperLevel = RPC_C_IMP_LEVEL_DEFAULT;
    else
        g_dwRPCImperLevel = RPC_C_IMP_LEVEL_IMPERSONATE;

    g_dwMaxWorkerThreads = g_dwPropValues[EPMConfig_maxWorkerThreads];
    g_dwMaxIoThreads     = g_dwPropValues[EPMConfig_maxIoThreads];

    if (szUserName[0] != NULL)
    {
        wcsncpy(g_szUserName, szUserName, ARRAY_SIZE(g_szUserName)-1);
        g_szUserName[ARRAY_SIZE(g_szUserName)-1] = NULL;
    }

    EncryptPassword(szPassword);

    return (g_dwPropValues[EPMConfig_enable] != 0);
}
/////////////////////////////////////////////////////////////////////////////

BOOL
ProcessModelIsEnabled()
{
    g_fUseXSPProcessModel = UseXSPProcessModel();
    return g_fUseXSPProcessModel;
}
/////////////////////////////////////////////////////////////////////////////

HRESULT
DllInitProcessModel()
{
    HRESULT hr = S_OK;
    CRegAccount::CreateTempDir();

    if (!g_fUseXSPProcessModel)
    {
        hr = HttpCompletion::InitManagedCode();
        ON_ERROR_EXIT();
    }

Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
DllUninitProcessModel()
{
    HRESULT hr = S_OK;

    if (!g_fUseXSPProcessModel)
    {
        hr = HttpCompletion::UninitManagedCode();
        ON_ERROR_CONTINUE();
    }

    g_fShuttingDown = FALSE;
    g_lCreatingProcessTable = 0;
    g_lDestroyingProcessTable = 0;
    g_fHealthMonitorStopped = TRUE;
    g_fUseXSPProcessModel = FALSE;

    return hr;
}


/////////////////////////////////////////////////////////////////////////////

HRESULT
ISAPIInitProcessModel()
{
    HRESULT hr;
    CRegAccount::CreateTempDir();

    if (g_fUseXSPProcessModel)
    {
        UseXSPProcessModel(); // Read the config.cfg
        hr = ProcessModelInit();
        if (hr)
        {
            g_InitHR = hr;
            g_pInitErrorMessage = "Couldn't create managed " PRODUCT_NAME " runtime component";
            EXIT();
        }
    }

Cleanup:
    // always return S_OK to enable descriptive error messages
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
ISAPIUninitProcessModel()
{
    HRESULT hr = S_OK;

    if (g_fUseXSPProcessModel)
    {
        ProcessModelStopHealthMonitor();
    }

    hr = DrainThreadPool(RECOMMENDED_DRAIN_THREAD_POOL_TIMEOUT);
    ON_ERROR_CONTINUE();

    return hr;
}

////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Function called by ASPNET_ISAPI to assign a request

HRESULT 
__stdcall
AssignRequestUsingXSPProcessModel (EXTENSION_CONTROL_BLOCK * iEcb)
{
    if (g_fShuttingDown == TRUE)
        return E_FAIL;

    HRESULT  hr = S_OK;

    if ( CProcessTableManager::g_pProcessTableManager == NULL)
    {
        hr = CProcessTableManager::Init();
        ON_ERROR_EXIT();
    }

    if ( CProcessTableManager::g_pProcessTableManager == NULL)
    {
        EXIT_WITH_HRESULT(E_FAIL);
    }

    hr = CProcessTableManager::g_pProcessTableManager->PrivateAssignRequest(iEcb);
    ON_ERROR_CONTINUE();

    if (hr != S_OK && g_fInvalidCredentials)
    {
        ReportHttpErrorIndirect(iEcb, IDS_BAD_CREDENTIALS);
        EcbDoneWithSession(iEcb, 1, 2);
        hr = S_OK;
    }

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Stop the health mon
void
__stdcall
ProcessModelStopHealthMonitor ()
{
    g_fStopHealthMonitor = TRUE;
    g_fShuttingDown = TRUE;

    if ( CProcessTableManager::g_pProcessTableManager == NULL)
        return;

    // Close all pipes
    for (int iter=0; iter<CProcessTableManager::g_pProcessTableManager->m_iCPUArraySize; iter++)
    {
        CProcessTableManager::g_pProcessTableManager->m_pCPUArray[iter].CloseAll();
        SwitchToThread();
    }

    CRequestTableManager::DisposeAllRequests();

    for(iter=0; g_fHealthMonitorStopped == FALSE && iter<600; iter++) // sleep at most 1 minute
        Sleep(100);        

    SwitchToThread();
    CProcessTableManager::g_pProcessTableManager = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// Stop the health mon
HRESULT
__stdcall
ProcessModelInit ()
{
    HRESULT  hr = S_OK;
    int      iter;

    g_fShuttingDown = FALSE;

    hr = CProcessTableManager::Init();
    ON_ERROR_EXIT();

    for (iter=0; iter<CProcessTableManager::g_pProcessTableManager->m_iCPUArraySize; iter++)
        CProcessTableManager::g_pProcessTableManager->m_pCPUArray[iter].ReplaceActiveProcess();

    g_fStopHealthMonitor = FALSE;
    _beginthread(MonitorHealth, 0, NULL);

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Static functions

// Create the process table
HRESULT
CProcessTableManager::Init()
{
    HRESULT hr = S_OK;

    if (g_pProcessTableManager == NULL)
    {
        // Create it in a thread safe way
        LONG lVal = InterlockedIncrement(&g_lCreatingProcessTable);
        if (lVal == 1 && !g_pProcessTableManager)
        {            
            g_pProcessTableManager = new CProcessTableManager();
            ON_OOM_EXIT(g_pProcessTableManager);

            if (g_pProcessTableManager->IsAlive() == FALSE)
            {
                EXIT_WITH_HRESULT(E_OUTOFMEMORY);
            }
        }
        else
        {
            for(int iter=0; iter<600 && !g_pProcessTableManager; iter++) // Sleep at most a minute
                Sleep(100);

            if (g_pProcessTableManager == NULL)
            {
                EXIT_WITH_WIN32_ERROR(ERROR_TIMEOUT);
            }
        }
        InterlockedDecrement(&g_lCreatingProcessTable);
    }

    g_lDestroyingProcessTable = 0;
    g_fShuttingDown = FALSE;

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Destroy the table
void
CProcessTableManager::Destroy()
{
    if (g_pProcessTableManager == NULL)
        return;

    LONG lVal = InterlockedIncrement(&g_lDestroyingProcessTable);
    if (lVal == 1 && g_pProcessTableManager)
    {
        delete g_pProcessTableManager;
        g_pProcessTableManager = NULL;
        g_lCreatingProcessTable = g_lDestroyingProcessTable = 0;
    }
}

/////////////////////////////////////////////////////////////////////////////
// Get the number of pending/executing requests
LONG
CProcessTableManager::NumPendingRequests()
{
    if (g_pProcessTableManager != NULL)
        return g_pProcessTableManager->PrivateNumPendingRequests();
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// Get a server variable: also return the space required in bytes: rounded up to the
// nearest 4 bytes
int 
CProcessTableManager::GetServerVariable(
        EXTENSION_CONTROL_BLOCK * pECB, 
        LPCSTR   pVarName, 
        LPSTR    pBuffer, 
        int      bufferSize)
{
    BYTE     b[4];
    DWORD    size = bufferSize;

    if (bufferSize < 0)
    {
        ZeroMemory(&b, sizeof(b));
        pBuffer = (LPSTR) &b;
        size    = 0;        
    }

    BOOL fRet = (*pECB->GetServerVariable)(
                            pECB->ConnID,
                            (LPSTR)pVarName,
                            pBuffer,
                            &size
                            );

    if (fRet != 0)
    {
        // change all tabs to spaces (ASURT 111082)
        CHAR *pTab = strchr(pBuffer, '\t');
        while (pTab != NULL)
        {
            *pTab = ' ';
            pTab = strchr(pTab+1, '\t');
        }

        return (size - 1);
    }

    if (GetLastError() == ERROR_INSUFFICIENT_BUFFER && size > 0) 
    {
        return -int(size-1);
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
CProcessEntry * 
CProcessTableManager::GetProcess(DWORD dwProcNum)
{
    if ( g_pProcessTableManager == NULL)
        return NULL;

    for(int iter=0; iter<g_pProcessTableManager->m_iCPUArraySize; iter++)
        if (g_pProcessTableManager->m_pCPUArray[iter].GetCPUNumber() == (dwProcNum & 0xff))
            return g_pProcessTableManager->m_pCPUArray[iter].FindProcess(dwProcNum);

    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
BOOL
CProcessTableManager::GetUseCPUAffinity()
{
    return g_fWebGarden;
}

/////////////////////////////////////////////////////////////////////////////
DWORD
CProcessTableManager::GetTerminateTimeout()
{
    return g_dwPropValues[EPMConfig_shutdowntimeout];
}

/////////////////////////////////////////////////////////////////////////////
BOOL
CProcessTableManager::GetWillRequestsBeAcknowledged()
{
    return g_dwPropValues[EPMConfig_requestacks];
}

/////////////////////////////////////////////////////////////////////////////

int
CProcessTableManager::NumActiveCPUs()
{    
    return (g_pProcessTableManager ? g_pProcessTableManager->m_iCPUArraySize : 1);

}

/////////////////////////////////////////////////////////////////////////////

DWORD
CProcessTableManager::GetRestartQLimit()
{
    return g_dwPropValues[EPMConfig_restartQLimit];
}
/////////////////////////////////////////////////////////////////////////////

DWORD
CProcessTableManager::GetRequestQLimit()
{
    return g_dwPropValues[EPMConfig_requestqueuelimit];
}

/////////////////////////////////////////////////////////////////////////////

void
CProcessTableManager::GetPingConfig(
        DWORD & dwFreq, 
        DWORD & dwTimeout)
{
    dwFreq    = g_dwPropValues[EPMConfig_pingFrequency];
    dwTimeout = g_dwPropValues[EPMConfig_pingTimeout];
}

/////////////////////////////////////////////////////////////////////////////

DWORD
CProcessTableManager::GetWPMemoryLimitInMB()
{
    DWORD dwLimit = g_dwProcessMemoryLimitInMB;
    if (g_pProcessTableManager->m_iCPUArraySize > 1)
        dwLimit = (dwLimit / g_pProcessTableManager->m_iCPUArraySize);

    if (dwLimit < MIN_MEMORY_LIMIT)
        dwLimit = MIN_MEMORY_LIMIT;
    return dwLimit;
}

/////////////////////////////////////////////////////////////////////////////

void
CProcessTableManager::LogWorkerProcessDeath  (
        EReasonForDeath   eReason, 
        DWORD             dwPID)
{
    if (g_iLogLevel == 0 || g_fShuttingDown)
        return;

    ASSERT(g_iLogLevel < 4);

    WORD      wType;
    DWORD     dwParam     = 0;
    HRESULT   hr          = S_OK;
    DWORD     dwEventID;

    if (eReason & EReasonForDeath_MemoryLimitExeceeded) {
        wType = EVENTLOG_ERROR_TYPE;
        dwEventID = IDS_EVENTLOG_RECYCLE_MEM;
        dwParam = g_dwProcessMemoryLimitInMB / CProcessTableManager::NumActiveCPUs();
    } else if (eReason & EReasonForDeath_MaxRequestQLengthExceeded) {
        wType = EVENTLOG_ERROR_TYPE;
        dwEventID = IDS_EVENTLOG_RECYCLE_Q_REQ;
        dwParam = g_dwPropValues[EPMConfig_requestqueuelimit];
    } else if (eReason & EReasonForDeath_DeadlockSuspected) {
        wType = EVENTLOG_ERROR_TYPE;
        dwEventID = IDS_EVENTLOG_RECYCLE_DEADLOCK;
        dwParam = g_dwPropValues[EPMConfig_responseDeadlockInterval];
    } else if (eReason & EReasonForDeath_TimeoutExpired) {
        wType = EVENTLOG_INFORMATION_TYPE;
        dwEventID = IDS_EVENTLOG_RECYCLE_TIME;
        dwParam = g_dwPropValues[EPMConfig_timeout];

    } else if (eReason & EReasonForDeath_IdleTimeoutExpired) {
        wType = EVENTLOG_INFORMATION_TYPE;
        dwEventID = IDS_EVENTLOG_RECYCLE_IDLE;
        dwParam = g_dwPropValues[EPMConfig_idletimeout];

    } else if (eReason & EReasonForDeath_MaxRequestsServedExceeded) {
        wType = EVENTLOG_INFORMATION_TYPE;
        dwEventID = IDS_EVENTLOG_RECYCLE_REQ;
        dwParam = g_dwPropValues[EPMConfig_requestlimit];
    } else if (eReason & EReasonForDeath_PingFailed) {
        wType = EVENTLOG_ERROR_TYPE;
        dwEventID = IDS_EVENTLOG_PING_FAILED;
    } else if (eReason & EReasonForDeath_ProcessCrash) {
        wType = EVENTLOG_ERROR_TYPE;
        dwEventID = IDS_EVENTLOG_PROCESS_CRASH;
    } else {
        EXIT();
    }

    if ((g_iLogLevel < 3 && wType == EVENTLOG_INFORMATION_TYPE) ||
        (g_iLogLevel < 2 && wType == EVENTLOG_WARNING_TYPE)      )
    {
        EXIT();
    }

    if ((eReason & EReasonForDeath_ProcessCrash) || (eReason & EReasonForDeath_PingFailed)) {
        hr = XspLogEvent(dwEventID, L"%d", dwPID);
        ON_ERROR_EXIT();
    }
    else {
        if (dwEventID == IDS_EVENTLOG_RECYCLE_MEM)
            hr = XspLogEvent(dwEventID, L"%d^%d^%d", dwPID, dwParam, g_dwPropValues[EPMConfig_memorylimit]);
        else
            hr = XspLogEvent(dwEventID, L"%d^%d", dwPID, dwParam);
        ON_ERROR_EXIT();
    }
    
 Cleanup:    
    return;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HANDLE
CProcessTableManager::GetWorkerProcessToken()
{
    CreateWPToken();
    return g_hToken;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HANDLE
CProcessTableManager::GetWorkerProcessProfile()
{
    CreateWPToken();
    return g_hProfile;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HANDLE
CProcessTableManager::GetWorkerProcessSid()
{
    CreateWPToken();
    return g_pSid;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void
CProcessTableManager::CreateWPToken()
{
    if (g_lTokenCreated >= 1000)
        return;

    if (InterlockedIncrement(&g_lTokenCreated) == 1)
    {
        WCHAR   szPass[104];
        WCHAR   szUser[104];

        ZeroMemory(szUser, sizeof(szUser));
        if (wcsstr(g_szUserName, L"registry:") == g_szUserName || wcsstr(g_szUserName, L"Registry:") == g_szUserName) // starts with "registry:"
        {
            GetCredentialFromRegistry(g_szUserName, szUser, ARRAY_SIZE(szUser));
        }
        else
        {
            wcsncpy(szUser, g_szUserName, ARRAY_SIZE(szUser)-1);
        }

        UnEncryptPassword(szPass, ARRAY_SIZE(szPass));
        g_hToken = CRegAccount::CreateWorkerProcessToken(szUser, szPass, &g_pSid);
        XspSecureZeroMemory(szPass, sizeof(szPass));

        if (g_hToken != NULL && g_hToken != INVALID_HANDLE_VALUE) 
        {
            PROFILEINFO    oProfileInfo;
            WCHAR          buf[100];

            ZeroMemory(&oProfileInfo, sizeof(oProfileInfo));
            ZeroMemory(buf, sizeof(buf));

            GetUserNameFromToken(g_hToken, buf, ARRAY_SIZE(buf));
            oProfileInfo.dwSize       = sizeof(oProfileInfo);
            oProfileInfo.dwFlags      = PI_NOUI;
            oProfileInfo.lpUserName   = buf;
            
            if (LoadUserProfile(g_hToken, &oProfileInfo))            
                g_hProfile = oProfileInfo.hProfile;
        }

        SwitchToThread();
        g_lTokenCreated = 1000;
    }
    else
    {
        for(int iter=0; iter<300 && g_lTokenCreated<1000; iter++)
            Sleep(100);
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CTor
CProcessTableManager::CProcessTableManager()
    :  m_pCPUArray             (NULL),
       m_iCPUArraySize         (0),
       m_dwHealthMonitorPeriod (HEALTH_MONITORING_DEFAULT_PERIOD)
{
    InitializeCriticalSection(&m_csMonitorHealth);

    g_fWebGarden = (g_dwPropValues[EPMConfig_webgarden] != 0);

    if (!g_fWebGarden)
    {
        g_dwPropValues[EPMConfig_cpumask] = 1;
    }
    else
    {    
        ////////////////////////////////////////////////////////////
        // Step 2: Make sure the CPU mask is valid
        SYSTEM_INFO      si;
        GetSystemInfo(&si);

        g_dwPropValues[EPMConfig_cpumask] &= si.dwActiveProcessorMask;

        if (g_dwPropValues[EPMConfig_cpumask] == 0)
            g_dwPropValues[EPMConfig_cpumask] = 0x1;    
    }

    ////////////////////////////////////////////////////////////
    // Step 3: Create the CPUEntry array based on the CPU Mask
    DWORD dwMask  = g_dwPropValues[EPMConfig_cpumask];
    
    for(int iter=0; iter<32; iter++)
    {
        if (dwMask & 0x1)
            m_iCPUArraySize ++;
        dwMask = dwMask >> 1;
    }

    if (m_iCPUArraySize == 0)
        m_iCPUArraySize = 1;

    int iNum = 0;
    m_pCPUArray = new CCPUEntry[m_iCPUArraySize];
    if (m_pCPUArray == NULL)
        return;

    dwMask = g_dwPropValues[EPMConfig_cpumask];
    for(iter=0; iter<32; iter++)
    {
        if (dwMask & 0x1)
        {
            m_pCPUArray[iNum++].Init(iter);
        }
        dwMask = dwMask >> 1;
    }
}

/////////////////////////////////////////////////////////////////////////////
// DTor
CProcessTableManager::~CProcessTableManager()
{
    delete [] m_pCPUArray;
    m_pCPUArray = NULL;
    DeleteCriticalSection(&m_csMonitorHealth);    
}

/////////////////////////////////////////////////////////////////////////////
// Assign a request to a CPU
HRESULT
CProcessTableManager::PrivateAssignRequest(EXTENSION_CONTROL_BLOCK * iECB)
{
    int   iCPUNum         = 0;

    if (m_iCPUArraySize > 1) // If there are more than CPU, find the least
                             // busy one
    {
        LONG      lMinReqExcuting   = 0x7fffffff;
        DWORD     dwMinReqAssigned  = 0x7fffffff;

        for (int iter=0; iter<m_iCPUArraySize; iter++)
        {
            LONG    dwExec = m_pCPUArray[iter].GetActiveRequestCount();
            DWORD   dwAss  = m_pCPUArray[iter].GetTotalRequestsAssigned();

            if (dwExec < lMinReqExcuting || (dwExec == lMinReqExcuting && dwAss < dwMinReqAssigned))
            { 
                iCPUNum = iter;
                lMinReqExcuting = dwExec;
                dwMinReqAssigned = dwAss;
            }
        }
    }
    
    // Assign it
    return m_pCPUArray[iCPUNum].AssignRequest(iECB);
}

/////////////////////////////////////////////////////////////////////////////
// Periodically monitor health
void
CProcessTableManager::PrivateMonitorHealth()
{
    // If there's another thread executing this function, then do nothing
    BOOL fLock = TryEnterCriticalSection(&m_csMonitorHealth);
    if (fLock == FALSE)
    {
        return; // Some other thread is in here
    }

    ////////////////////////////////////////////////////////////
    // Step 1: For each CPU, evaluate if we want to re-cycle the
    //         active process
    for (int iter=0; iter<m_iCPUArraySize && g_fStopHealthMonitor == FALSE; iter++)
    {
        ////////////////////////////////////////////////////////////
        // Step 1a: Did we recently try to (unsuccessfully) create a
        //          process?
        // NOTE: We don't want to get into a loop creating processes.
        //       So, we wait at atleast MIN_PROC_START_WAIT_TIME seconds
        //       before trying again
        if ( m_tmLastCreateProcessFailure.IsSet() && 
             m_tmLastCreateProcessFailure.AgeInSeconds() < MIN_PROC_START_WAIT_TIME )
        {
            break;
        }
        
        ////////////////////////////////////////////////////////////
        // Step 1b: Evaluate if we can re-cycle the process
        CProcessEntry * pProc    = m_pCPUArray[iter].GetActiveProcess();
        BOOL            fRecycle = FALSE;
        EReasonForDeath eReason  = EReasonForDeath_Active;

        // Conditions under which to recycle:
        // 1. If the active process is NULL
        fRecycle = (pProc == NULL);

        // 2. If the active process is dead
        if (!fRecycle &&  pProc->GetUpdatedStatus() == EProcessState_Dead)
        {
            fRecycle = TRUE;
            eReason = EReasonForDeath_ProcessCrash;
        }
            
        // 3. If it's too old
        if (!fRecycle && pProc->GetAge() >= g_dwPropValues[EPMConfig_timeout])
        {
            fRecycle = TRUE;
            eReason = EReasonForDeath_TimeoutExpired;
        }

        // 4. If it has executed too many requests
        if (!fRecycle && (DWORD) pProc->GetNumRequestStat(2) >= g_dwPropValues[EPMConfig_requestlimit])
        {
            fRecycle = TRUE;
            eReason = EReasonForDeath_MaxRequestsServedExceeded;
        }


        // 5. If it's been idle too long
        if (!fRecycle && pProc->GetIdleTime() >= g_dwPropValues[EPMConfig_idletimeout])
        {
            fRecycle = TRUE;
            eReason = EReasonForDeath_IdleTimeoutExpired;
        }

        // 6. If it's request Q is too long -- Functionality removed

//          if (!fRecycle && DWORD(pProc->GetNumRequestStat(0) + pProc->GetNumRequestStat(1)) > g_dwPropValues[EPMConfig_requestqueuelimit])
//          {
//              fRecycle = TRUE;
//              eReason = EReasonForDeath_MaxRequestQLengthExceeded;
//          }

        // 7. If it's consumed too much memory
        if (!fRecycle && g_dwPropValues[EPMConfig_memorylimit] < 1000)
        {
            if (CProcessTableManager::GetWPMemoryLimitInMB() < pProc->GetMemoryUsed())
            {
                fRecycle = TRUE;
                eReason = EReasonForDeath_MemoryLimitExeceeded;
            }
        }


        if ( !fRecycle && 
             g_dwPropValues[EPMConfig_responseDeadlockInterval] != 0 &&
             /*pProc->GetNumRequestStat(0) + */ pProc->GetNumRequestStat(1) > (LONG)(g_dwMaxWorkerThreads + g_dwMaxIoThreads) && 
             pProc->GetSecondsSinceLastResponse() > g_dwPropValues[EPMConfig_responseDeadlockInterval] &&
             !pProc->IsProcessUnderDebugger())
        {
            fRecycle = TRUE;
            eReason = EReasonForDeath_DeadlockSuspected;
        }
 
        //////////////////////////////
        // 7. Counter check: If the process is just starting up, don't restart...
        if (fRecycle && pProc != NULL && pProc->GetUpdatedStatus() == EProcessState_Starting)
            fRecycle = FALSE;

        ////////////////////////////////////////////////////////////
        // Step 2: Recycle the process
        if (fRecycle == TRUE && g_fStopHealthMonitor == FALSE)
        {
            if (pProc != NULL)
                pProc->UpdateStatusInHistoryTable(EReasonForDeath(eReason | EReasonForDeath_ShuttingDown));
            BOOL fDebug = FALSE;
            if (eReason == EReasonForDeath_MemoryLimitExeceeded)
            {
                fDebug = DebugOnHighMemoryConsumption();
            }
            else if (eReason == EReasonForDeath_DeadlockSuspected) 
            {
                DWORD breakValue = GetDebugOnDeadlock();
                fDebug = (breakValue == 1);
                if (breakValue == 2)
                {
                    pProc->BreakIntoProcess();
                    if (IsUnderDebugger()) 
                    {
                        DebugBreak();
                    }
                }
            }

            if (m_pCPUArray[iter].ReplaceActiveProcess(fDebug) == S_OK)
                m_tmLastCreateProcessFailure.Reset();
            else // Record the time of as the last attempted failure
                m_tmLastCreateProcessFailure.SnapCurrentTime();
        }

        if (pProc != NULL)
            pProc->Release();

    } // End of for-each-cpu-recycle-processs

    if (g_fStopHealthMonitor != FALSE)
        return;

    Sleep(100); // Make sure the thread gets swapped out
    SwitchToThread();

    // Cleanup old processes
    for (iter=0; iter<m_iCPUArraySize && g_fStopHealthMonitor == FALSE; iter++)
        m_pCPUArray[iter].CleanUpOldProcesses();

    LeaveCriticalSection(&m_csMonitorHealth);
}

/////////////////////////////////////////////////////////////////////////////
// Get the number of active requests
LONG
CProcessTableManager::PrivateNumPendingRequests()
{
    LONG lRet = 0;

    for (int iter=0; iter<m_iCPUArraySize; iter++)
    {
        lRet += m_pCPUArray[iter].GetActiveRequestCount();
    }

    return lRet;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CReadWriteSpinLock g_OnISAPIMachineConfigChangeLock("OnISAPIMachineConfigChange");

void 
__stdcall
OnISAPIMachineConfigChange(int, WCHAR *)
{
    if (!g_fUseXSPProcessModel)
        return;
    if (!g_OnISAPIMachineConfigChangeLock.TryAcquireWriterLock())
        return;

    WCHAR szRPCAuth    [104] = L"";
    WCHAR szRPCImper   [104] = L"";
    WCHAR szPassword   [104] = L"";
    WCHAR szUserName   [104] = L"";
    
    DWORD dwPropValues [NUM_PM_PROPERTIES];
    memcpy(dwPropValues, g_dwPropValues, sizeof(g_dwPropValues));

    g_szPropValues[0] = szUserName;
    g_szPropValues[1] = szPassword;
    g_szPropValues[2] = g_szLogLevel;
    g_szPropValues[3] = szRPCAuth;
    g_szPropValues[4] = szRPCImper;
    g_szPropValues[5] = g_szCustomErrorFile;

    g_szCustomErrorFile[0] = NULL;
    g_fCustomErrorFileChanged = TRUE;

    if (GetConfigurationFromNativeCode(Names::GlobalConfigFullPathW(), 
                                       SZ_PM_CONFIG_TAG, 
                                       g_szPMProperties, 
                                       dwPropValues, 
                                       NUM_PM_PROPERTIES,
                                       g_szPMPropertiesStrings, 
                                       g_szPropValues, 
                                       NUM_PM_PROPERTIES_STRINGS,
                                       NULL,
                                       0) == FALSE)
    {
        g_OnISAPIMachineConfigChangeLock.ReleaseWriterLock();
        return;
    }

    memcpy(g_dwPropValues, dwPropValues, sizeof(dwPropValues));

    g_dwProcessMemoryLimitInMB = (g_dwPropValues[EPMConfig_memorylimit] * g_dwMaxPhyMemory) / 100;
    if (g_dwProcessMemoryLimitInMB < MIN_MEMORY_LIMIT)
        g_dwProcessMemoryLimitInMB = MIN_MEMORY_LIMIT;

    if (_wcsicmp(g_szLogLevel, L"errors") == 0)
        g_iLogLevel = 1;
    else if (_wcsicmp(g_szLogLevel, L"none") == 0)
        g_iLogLevel = 0;
    else if (_wcsicmp(g_szLogLevel, L"warnings") == 0)
        g_iLogLevel = 2;
    else            
        g_iLogLevel = 3;


    if (_wcsicmp(L"None", szRPCAuth) == 0)
        g_dwRPCAuthLevel = RPC_C_AUTHN_LEVEL_NONE;
    else if (_wcsicmp(L"Connect", szRPCAuth) == 0)
        g_dwRPCAuthLevel = RPC_C_AUTHN_LEVEL_CONNECT;
    else if (_wcsicmp(L"Call", szRPCAuth) == 0)
        g_dwRPCAuthLevel = RPC_C_AUTHN_LEVEL_CALL;
    else if (_wcsicmp(L"Pkt", szRPCAuth) == 0)
        g_dwRPCAuthLevel = RPC_C_AUTHN_LEVEL_PKT;
    else if (_wcsicmp(L"PktIntegrity", szRPCAuth) == 0)
        g_dwRPCAuthLevel = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
    else if (_wcsicmp(L"PktPrivacy", szRPCAuth) == 0)
        g_dwRPCAuthLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
    else
        g_dwRPCAuthLevel = RPC_C_AUTHN_LEVEL_DEFAULT;

    if (_wcsicmp(L"Anonymous", szRPCImper) == 0)
        g_dwRPCImperLevel = RPC_C_IMP_LEVEL_ANONYMOUS;
    else if (_wcsicmp(L"Identify", szRPCImper) == 0)
        g_dwRPCImperLevel = RPC_C_IMP_LEVEL_IDENTIFY;
    else if (_wcsicmp(L"Impersonate", szRPCImper) == 0)
        g_dwRPCImperLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
    else if (_wcsicmp(L"Delegate", szRPCImper) == 0)
        g_dwRPCImperLevel = RPC_C_IMP_LEVEL_DELEGATE;
    else 
        g_dwRPCImperLevel = RPC_C_IMP_LEVEL_DEFAULT;

    g_dwMaxWorkerThreads = g_dwPropValues[EPMConfig_maxWorkerThreads];
    g_dwMaxIoThreads     = g_dwPropValues[EPMConfig_maxIoThreads];

    if (szUserName[0] != NULL)
    {
        wcsncpy(g_szUserName, szUserName, ARRAY_SIZE(g_szUserName)-1);
        g_szUserName[ARRAY_SIZE(g_szUserName)-1] = NULL;
    }

    EncryptPassword(szPassword);
    g_OnISAPIMachineConfigChangeLock.ReleaseWriterLock();
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void __cdecl
MonitorHealth(void *)
{
    g_fHealthMonitorStopped = FALSE;
    
    int iter;
    DirMonCompletion * pDirMon = MonitorGlobalConfigFile(OnISAPIMachineConfigChange);
    while(g_fStopHealthMonitor == FALSE && CProcessTableManager::g_pProcessTableManager != NULL)
    {
        CProcessTableManager::g_pProcessTableManager->PrivateMonitorHealth();

        // Sleep 2 seconds
        for(iter=0; iter<20; iter++)
        {
            if (g_fStopHealthMonitor)
                goto Cleanup;
            Sleep(100);
        }

        if (g_fStopHealthMonitor)
            goto Cleanup;
    }

 Cleanup:
    if (pDirMon != NULL)
        pDirMon->Close();
    g_fHealthMonitorStopped = TRUE;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

// This method resets the Requests Queued number to the number of active
// requests accross all worker processes, minus the number of requests from
// the worker process that died (the "requestsDied" parameter)
void CProcessTableManager::ResetRequestQueuedCounter(int requestsDied)
{
    DWORD activeRequests = -requestsDied;
    CProcessTableManager * tableManager;

    tableManager = CProcessTableManager::g_pProcessTableManager;

    // If there is not global instance of table manager, return
    if (tableManager == NULL)
        return;
    
    for (int iter=0; iter < tableManager->m_iCPUArraySize; iter++)
    {
        activeRequests += tableManager->m_pCPUArray[iter].GetActiveRequestCount();
    }

    PerfSetGlobalCounter(ASPNET_REQUESTS_QUEUED_NUMBER, activeRequests);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\regiis.h ===
/**
 * regiis.h
 *
 * Some helper functions and types from regiis.cxx
 * 
 * Copyright (c) 2001, Microsoft Corporation
 * 
 */

#pragma once


#define SCRIPT_MAP_SUFFIX_W2K L",1,GET,HEAD,POST,DEBUG"
#define SCRIPT_MAP_SUFFIX_NT4 L",1,PUT,DELETE"

#define SCRIPT_MAP_SUFFIX_W2K_FORBIDDEN L",5,GET,HEAD,POST,DEBUG"
#define SCRIPT_MAP_SUFFIX_NT4_FORBIDDEN L",5,PUT,DELETE"

#define KEY_LMW3SVC         L"/LM/w3svc"
#define KEY_LMW3SVC_SLASH   L"/LM/w3svc/"
#define KEY_LMW3SVC_SLASH_LEN   10
#define KEY_LM              L"/LM"
#define KEY_LM_SLASH        L"/LM/"
#define KEY_W3SVC           L"w3svc"
#define KEY_ASPX_FILTER     L"/Filters/" FILTER_NAME_L
#define KEY_ASPX_FILTER_PREFIX L"/Filters/ASP.NET_"
#define KEY_ASPX_FILTER_PREFIX_LEN 17
#define PATH_FILTERS        L"Filters"
#define KEY_FILTER_KEYTYPE  L"IIsFilter"
#define KEY_MIMEMAP         L"/LM/MimeMap"
#define KEY_SEPARATOR_STR_L L"/"
#define ASPNET_CLIENT_KEY   L"/aspnet_client"
#define FILTER_ASPNET_PREFIX L"ASP.NET_"
#define FILTER_ASPNET_PREFIX_LEN 8

#define KEY_APP_POOL        L"/LM/W3SVC/AppPools/"
#define KEY_APP_POOL_LEN    19

#define ASPNET_ALL_VERS     ((WCHAR*)0 - 1)

#define IIS_GROUP_ID_PREFIX          L"ASP.NET v"
#define IIS_GROUP_ID_PREFIX_LEN      9                                                                 

#define ASPNET_V1           L"1.0.3705.0"

#define METABASE_REQUEST_TIMEOUT 1000

#define COMPARE_UNDEF                   0x00000000      // Undefined value
#define COMPARE_SM_NOT_FOUND            0x00000001      // No Scriptmap is found at root.
#define COMPARE_ASPNET_NOT_FOUND        0x00000002      // No ASP.net DLL is found at root.
#define COMPARE_SAME_PATH               0x00000004      // The two DLLs have the same path
#define COMPARE_FIRST_FILE_MISSING      0x00000008      // The 1st DLL is missing from file system
#define COMPARE_SECOND_FILE_MISSING 0x00000010          // The 2nd DLL is missing from file system
#define COMPARE_DIFFERENT               0x00000020      // The two versions are different
#define COMPARE_SAME                    0x00000040      // The two versions are exactly the same


#define REGIIS_INSTALL_SM               0x00000001      // We want to install scriptmap
#define REGIIS_INSTALL_OTHERS           0x00000002      // We want to install all things (except the scriptmap)
#define REGIIS_SM_RECURSIVE             0x00000010      // SM installation is recursively
#define REGIIS_SM_IGNORE_VER            0x00000020      // When installing SM, ignore version comparison 
                                                        // (Default is upgrade compatible version only)
#define REGIIS_FRESH_INSTALL            0x00000040      // This is a fresh install
#define REGIIS_ENABLE                   0x00000080      // ASP.Net is enabled during installation (IIS 6 only)

struct SCRIPTMAP_PREFIX {
    WCHAR * wszExt;         // Name of the extension
    BOOL    bForbidden;     // TRUE if it is mapped to the forbidden handler
};

extern WCHAR *  g_AspnetDllNames[];
extern int      g_AspnetDllNamesSize;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\regiis.cxx ===
/**
 * regiis.cxx
 * 
 * Handles registration with IIS.
 * 
 * Copyright (c) 1998-2000, Microsoft Corporation
 * 
 */

#include "precomp.h"
#include <iadmw.h>
#include <iiscnfg.h>
#include "_ndll.h"
#include "ndll.h"
#include "regiis.h"
#include "register.h"
#include "ciisinfo.h"
#include "platform_apis.h"
#include <ary.h>
#include "event.h"
#include "aspnetver.h"
#include "regiisutil.h"


WCHAR *g_AspnetDllNames[] = {
    L"aspnet_isapi.dll",
    L"aspnet_express_isapi.dll",
    L"aspnet_standard_isapi.dll",
    L"aspnet_enterprise_isapi.dll",
    L"aspnet_sisapi.dll",
    L"aspnet_pisapi.dll",
    L"aspnet_eisapi.dll",
    L"aspnet_filter.dll"
};

int g_AspnetDllNamesSize = ARRAY_SIZE(g_AspnetDllNames);

#define SUBKEY_ROOT     L"/Root"

CStrAry csMissingDlls;

SCRIPTMAP_REGISTER_MANAGER  g_smrm;

BOOL
HasAspnetDll(WCHAR *pchSrc) {
    int     i;

    for (i = 0; i < ARRAY_SIZE(g_AspnetDllNames); i++) {
        if (wcsistr(pchSrc, g_AspnetDllNames[i]) != NULL) {
            return TRUE;
        }
    }

    return FALSE;
}

/**
 * Check for the existence of a property in the metabase.
 * 
 * @param pAdmin           Administration object.
 * @param keyHandle        Metabase key.
 * @param pchPath          Path of property relative to key.
 * @param dwMDIdentifier   Id of the property.
 * @param pfFound          Results.
 */
HRESULT
CheckMDProperty(
        IMSAdminBase    *pAdmin,
        METADATA_HANDLE keyHandle,
        WCHAR           *pchPath,
        METADATA_RECORD *pmd,
        BOOL            *pfFound) {

    HRESULT         hr;
    WCHAR           chDummy;
    DWORD           size;
    METADATA_RECORD md;

    // Init return values
    *pfFound = FALSE;

    // First get with zero-size buffer
    chDummy = L'\0';
    md.dwMDIdentifier = pmd->dwMDIdentifier;
    md.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    md.dwMDUserType = pmd->dwMDUserType;
    md.dwMDDataType = pmd->dwMDDataType;
    md.pbMDData = (unsigned char *) &chDummy;
    md.dwMDDataLen = 0;
    md.dwMDDataTag = 0;

    hr = pAdmin->GetData(keyHandle, pchPath, &md, &size);
    ASSERT(hr != S_OK);
    
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        *pfFound = TRUE;
    } else if (hr == HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND)) {
        *pfFound = FALSE;
    } else {
        EXIT();
    }

    hr = S_OK;

Cleanup:
    return hr;
}


/**
 * Get the data paths for a property, and return allocated memory for them.
 * 
 * @param pAdmin           Administration object.
 * @param keyHandle        Metabase key.
 * @param pchPath          Path of property relative to key.
 * @param dwMDIdentifier   Id of the property.
 * @param type             Type of data.
 * @param ppchPaths        Pointer to the memory alloced for the paths.
 */
HRESULT
GetDataPaths(
        IMSAdminBase    *pAdmin,
        METADATA_HANDLE keyHandle,
        WCHAR           *pchPath,
        DWORD           dwMDIdentifier,
        METADATATYPES   type,
        WCHAR           **ppchPaths) {

    HRESULT hr;
    WCHAR   chDummy;
    DWORD   len;
    WCHAR * pchPaths = NULL;

    *ppchPaths = NULL;

    // Get path with zero length buffer to get buffer size
    chDummy = L'\0';
    hr = pAdmin->GetDataPaths(keyHandle, pchPath, dwMDIdentifier, type, 0, &chDummy, &len);
    ASSERT(hr != S_OK);
    if (hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        EXIT();

    // Create buffer of proper size and get again
    pchPaths = new WCHAR[len];
    ON_OOM_EXIT(pchPaths);

    hr = pAdmin->GetDataPaths(keyHandle, pchPath, dwMDIdentifier, type, len, pchPaths, &len);
    if (hr) {
        delete [] pchPaths;
        EXIT();
    }

    *ppchPaths = pchPaths;

Cleanup:
    return hr;
}

/**
 * Add a string to a property list.
 * 
 * @param pAdmin           Administration object.
 * @param keyHandle        Metabase key.
 * @param pchPath          Path of property relative to key.
 * @param dwMDIdentifier   Id of the property.
 * @param pchAppend        String to append.
 */
HRESULT 
AppendListProperty(
        IMSAdminBase    *pAdmin,
        METADATA_HANDLE keyHandle,
        WCHAR           *pchPath,
        DWORD           dwMDIdentifier,
        WCHAR           *pchAppend) {
    HRESULT         hr;
    WCHAR           *pchCurrent = NULL;
    WCHAR           *pchNew = NULL;
    METADATA_RECORD md;

    // get the property
    hr = GetStringProperty(pAdmin, keyHandle, pchPath, dwMDIdentifier, &md);
    pchCurrent = (WCHAR*) md.pbMDData;
    if (hr == S_OK) {
        if (pchCurrent[0] != L'\0')  {
            // append to existing property
        size_t size = lstrlenW(pchCurrent) + lstrlenW(pchAppend) + 2;
            pchNew = new WCHAR[size];
            ON_OOM_EXIT(pchNew);
            StringCchCopyW(pchNew, size, pchCurrent);
            StringCchCatW(pchNew, size, L",");
            StringCchCatW(pchNew, size, pchAppend);
        }
    }
    else {
        // new properties are inheritable
        md.dwMDAttributes = METADATA_INHERIT;
    }

    if (pchNew == NULL) {
        pchNew = pchAppend;
    }

    // set the data
    md.pbMDData = (unsigned char*) pchNew;
    md.dwMDDataLen = (lstrlenW(pchNew) + 1) * sizeof(pchNew[0]);
    hr = pAdmin->SetData(keyHandle, pchPath, &md);
    ON_ERROR_EXIT();

Cleanup:
    delete [] pchCurrent;
    if (pchNew != pchAppend) {
        delete [] pchNew;
    }

    return hr;
}

/**
 * Remove the first occurance of len characters of a 
 * string from another string.
 * 
 * @param String       String to remove chars from
 * @param SubString    String to search for
 * @param len          Number of characters to remove
 * @fPrefix            SubString is just a prefix.  len is not used, and
 *                     each item in String should end with a ','
 */
BOOL
RemoveStringFromString(
        WCHAR *String,
        WCHAR *SubString, 
        int   len,
        BOOL  fPrefix) {
    WCHAR *Temp;
    WCHAR *End;

    Temp = wcsistr(String, SubString);
    if (Temp) {
        if (fPrefix) {
            End = Temp + 1;
            while(*End != L',' && *End != L'\0') {
                End++;
            }

            // This is unexpected.  See description for the fPrefix param.
            ASSERT(*End != L'\0');
        }
        else {
            End = Temp + len;
        }
        StringCchCopyUnsafeW(Temp, End);
        return TRUE;
    }
    else {
        return FALSE;
    }
}

/**
 * Remove a string from a property list.
 * 
 * @param pAdmin           Administration object.
 * @param keyHandle        Metabase key.
 * @param pchPath          Path of property relative to key.
 * @param dwMDIdentifier   Id of the property.
 * @param pchRemove        String to remove.
 * @param fPrefix          if true, use prefix comparison
 * @param fRemoveEmpty     if true, will remove the property if it's empty
 */
HRESULT 
RemoveListProperty(
        IMSAdminBase    *pAdmin,
        METADATA_HANDLE keyHandle,
        WCHAR           *pchPath,
        DWORD           dwMDIdentifier,
        WCHAR           *pchRemove,
        BOOL            fPrefix,
        BOOL            fRemoveEmpty) {
    HRESULT         hr;
    METADATA_RECORD md;
    WCHAR*          pchCurrent = NULL;
    WCHAR*          pchCurrentWithComma = NULL;
    WCHAR*          pchRemoveWithComma = NULL;
    int             len;
    bool            altered;

    // get the current value
    hr = GetStringProperty(pAdmin, keyHandle, pchPath, dwMDIdentifier, &md);
    ON_ERROR_EXIT();

    // delimit both current value and remove string with commas 
    // to get an exact case-insensitive match
    pchCurrent = (WCHAR*) md.pbMDData;
    
    {
    size_t size = lstrlenW(pchCurrent) + 3;
    pchCurrentWithComma = new WCHAR[size];
    ON_OOM_EXIT(pchCurrentWithComma);
    pchCurrentWithComma[0] = L',';
    pchCurrentWithComma[1] = L'\0';
    StringCchCatW(pchCurrentWithComma, size, pchCurrent);
    StringCchCatW(pchCurrentWithComma, size, L",");
    };

    {
      size_t size = lstrlenW(pchRemove) + 3;
      pchRemoveWithComma = new WCHAR[size];
      ON_OOM_EXIT(pchRemoveWithComma);
      pchRemoveWithComma[0] = L',';
      pchRemoveWithComma[1] = L'\0';
      StringCchCatW(pchRemoveWithComma, size, pchRemove);
      if (!fPrefix) {
        StringCchCatW(pchRemoveWithComma, size, L",");
      }
    };

    // remove all instances
    len = lstrlenW(pchRemoveWithComma) - 1;
    altered = false;
    while (RemoveStringFromString(pchCurrentWithComma, pchRemoveWithComma, len, fPrefix)) {
        altered = true;
    }

    if (altered) {
        // replace with the altered string
        len = lstrlenW(pchCurrentWithComma);
        if (pchCurrentWithComma[len-1] == L',') {
            pchCurrentWithComma[len-1] = L'\0';
        }

        if (pchCurrentWithComma[1] == L'\0' && fRemoveEmpty) {
            hr = pAdmin->DeleteData(keyHandle, pchPath, dwMDIdentifier, STRING_METADATA);
            ON_ERROR_EXIT();
        }
        else {
            md.pbMDData = (unsigned char*) &pchCurrentWithComma[1];
            md.dwMDDataLen = (lstrlenW(&pchCurrentWithComma[1]) + 1) * sizeof(pchCurrentWithComma[0]);
            hr = pAdmin->SetData(keyHandle, pchPath, &md);
            ON_ERROR_EXIT();
        }
    }

Cleanup:
    delete [] pchCurrent;
    delete [] pchCurrentWithComma;
    delete [] pchRemoveWithComma;

    return hr;
}



HRESULT
CreateMDProperty(IMSAdminBase *pAdmin, METADATA_HANDLE hBase, WCHAR *pchKey, 
                            METADATA_RECORD *pmd, BOOL fReplace) {
    HRESULT         hr;
    METADATA_HANDLE hKey = NULL;
    BOOL            fFound = FALSE;
    
    hr = pAdmin->OpenKey(
            hBase,
            pchKey,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &hKey);

    ON_ERROR_EXIT();

    if (!fReplace) {
        // First check if the property exists.
        hr = CheckMDProperty(pAdmin, hBase, pchKey, pmd, &fFound);
        ON_ERROR_EXIT();
    }

    if (fReplace || (!fReplace && !fFound)) {
        hr = pAdmin->SetData(hKey, L"/", pmd);
        ON_ERROR_EXIT();
    }

Cleanup:
    if (hKey != NULL) {
        pAdmin->CloseKey(hKey);
    }

    return hr;
}



HRESULT
CheckObjectClass(IMSAdminBase* pAdmin, METADATA_HANDLE hBase, WCHAR *pchKey,
                    WCHAR *rgpchClass[], int rgsize, BOOL *pfRet) {
    HRESULT         hr;
    METADATA_RECORD md;
    DWORD           size;
    WCHAR           rgchT[128];
    int             i;

    // Init return values
    *pfRet = FALSE;

    // First get with zero-size buffer
    md.dwMDIdentifier = MD_KEY_TYPE;
    md.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    md.dwMDUserType = IIS_MD_UT_SERVER;
    md.dwMDDataType = STRING_METADATA;
    md.pbMDData = (unsigned char*) rgchT;
    md.dwMDDataLen = sizeof(rgchT);
    md.dwMDDataTag = 0;

    hr = pAdmin->GetData(hBase, pchKey, &md, &size);
    if (hr == HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND)) {
        *pfRet = FALSE;
        hr = S_OK;
    } 
    else {
        ON_ERROR_EXIT();

        for ( i = 0; i < rgsize; i++ ) {
            if (wcscmp(rgpchClass[i], (WCHAR*)rgchT) == 0) {
                *pfRet = TRUE;
                break;
            }
        }
    }

Cleanup:
    return hr;
}


HRESULT
RegisterInProc(IMSAdminBase* pAdmin, const WCHAR *pchPath) {
    HRESULT         hr;
    METADATA_HANDLE w3svcHandle = NULL;

    CSetupLogging::Log(1, "RegisterInProc", 0, "Registering InProcessIsapiApps property in IIS metabase");        
    
    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            KEY_LMW3SVC,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &w3svcHandle);

    ON_ERROR_EXIT();

    hr = AppendStringToMultiStringProp(pAdmin, w3svcHandle, L"/", MD_IN_PROCESS_ISAPI_APPS, pchPath, TRUE);
    ON_ERROR_EXIT();

Cleanup:
    CSetupLogging::Log(hr, "RegisterInProc", 0, "Registering InProcessIsapiApps property in IIS metabase");        
    
    if (w3svcHandle != NULL) {
        pAdmin->CloseKey(w3svcHandle);
    }

    return hr;
}

/*
 * Params:
 * pchInProcPath    - Path of In-Proc module to uninstall.  If NULL, then all
 *                    versions of aspnet DLL will be uninstalled.
 */
HRESULT
UnregisterInProc(IMSAdminBase* pAdmin, const WCHAR *pchInProcPath) {
    HRESULT         hr;
    METADATA_HANDLE w3svcHandle = NULL;
    WCHAR           *pchPaths = NULL;
    WCHAR           *path;

    CSetupLogging::Log(1, "UnregisterInProc", 0, "Unregistering InProcessIsapiApps property in IIS metabase");        
    
    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            KEY_LMW3SVC,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &w3svcHandle);

    ON_ERROR_EXIT();

    hr = GetDataPaths(pAdmin, w3svcHandle, L"/", MD_IN_PROCESS_ISAPI_APPS, MULTISZ_METADATA, &pchPaths);
    ON_ERROR_EXIT();

    for (path = pchPaths; *path != L'\0'; path += lstrlenW(path) + 1) {
        if (pchInProcPath == ASPNET_ALL_VERS) {
            hr = RemoveAspnetDllFromMulti(pAdmin, w3svcHandle, MD_IN_PROCESS_ISAPI_APPS, path);
        }
        else {
            hr = RemoveStringFromMultiStringProp(pAdmin, w3svcHandle, path, MD_IN_PROCESS_ISAPI_APPS, 
                            (WCHAR*)pchInProcPath, MULTISZ_MATCHING_PREFIX, TRUE);
        }
            
        ON_ERROR_EXIT();
    }

Cleanup:
    CSetupLogging::Log(hr, "UnregisterInProc", 0, "Unregistering InProcessIsapiApps property in IIS metabase");        
    
    if (w3svcHandle != NULL) {
        pAdmin->CloseKey(w3svcHandle);
    }

    delete [] pchPaths;

    return hr;
}


/**
 *  A helper function to report missing Dlls when we're trying to
 *  read the version of an asp.net dll from a scriptmap.  This
 *  function will avoid repeatedly reporting the missing of the
 *  same DLL.
 */
HRESULT
ReportMissingDll(WCHAR *pchDll, HRESULT hrReport)
{
    int             i;
    WCHAR *         pchDup;
    HRESULT         hr = S_OK;

    for (i=0; i < csMissingDlls.Size(); i++) {
        if (_wcsicmp(csMissingDlls[i], pchDll) == 0)
            break;
    }

    if (i == csMissingDlls.Size()) {
        XspLogEvent(IDS_EVENTLOG_GET_DLL_VER_FAILED, 
            L"%s^0x%08x", pchDll, hrReport);

        pchDup = DupStr(pchDll);
        ON_OOM_EXIT(pchDup);

        hr = csMissingDlls.Append(pchDup);
        ON_ERROR_EXIT();
    }
    
Cleanup:
    return hr;
}


/**
 *  Because csMissingDlls is just global variable, so RegisterIIS
 *  and UnregisterIIS should call this when exiting to free up
 *  the memory allocated to hold the strings added to it.
 */
VOID
CleanupMissingDllMem()
{
    CleanupCStrAry(&csMissingDlls);
}


/**
 *  The function compares the version of two aspnet DLL's.
 *
 *  Version numbers have this format: Major.Minor.Build.QFE.
 *
 *  Parameters:
 *  pchDLL1     - Full path of DLL 1
 *  pchDLL2     - Full path of DLL 2
 *  pdwRes      - Major result of comparison.
 *  pfIsLower   - TRUE if DLL1 version < DLL2 version
 */
HRESULT
CompareDllsVersion(WCHAR* pchDLL1, WCHAR *pchDLL2, DWORD *pdwRes, BOOL *pfIsLower) {
    HRESULT             hr = S_OK;
    int                 i;

    // Init
    *pdwRes = 0;
    *pfIsLower = FALSE;
    
    // Step 1: Check full path
    if (_wcsicmp(pchDLL1, pchDLL2) == 0) {
        *pdwRes |= COMPARE_SAME_PATH;
    }
    else {
        // Step 2: Compare file version stamps
        
        WCHAR *     rgpchDLL[] = { pchDLL1, pchDLL2 };
        ASPNETVER   rgver[2];

        for (i = 0; i < 2; i++) {
            hr = g_smrm.FindDllVer(rgpchDLL[i], &(rgver[i]));
            if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) {
                // Report if the aspnet DLL that's contained in SM is missing
                ReportMissingDll(rgpchDLL[i], hr);

                if (i==0)
                    *pdwRes |= COMPARE_FIRST_FILE_MISSING;
                else
                    *pdwRes |= COMPARE_SECOND_FILE_MISSING;

                hr = S_OK;
                EXIT();
            }
            ON_ERROR_EXIT();
    
            ASSERT(rgver[i].IsValid());
        }

        // Compare DLL 1 with DLL 2
        if (rgver[0] == rgver[1]) {
            *pdwRes |= COMPARE_SAME;
        }
        else {
            *pdwRes |= COMPARE_DIFFERENT;
            *pfIsLower = (rgver[0] < rgver[1]);
        }
    }

Cleanup:
    return hr;
}



/**
 * The function will return the aspnet dll from the script maps
 * property in the provided key.  If more than one version is found,
 * the latest version is returned.
 *
 * Parameters:
 *  pAdmin
 *  hBase       - Handle to the opened key which is the base key of pchKey.
 *  pchKey      - The IIS metabase key we are looking at.
 *  ppchDllPath - Returned DLL path.
 *
 * Return:
 *  HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND) - Scriptmap property isn't found at the key
 *  HRESULT_FROM_WIN32(ERROR_NOT_FOUND)         - ASP.NET Dll isn't found at the scriptmap
 */
HRESULT
GetDllPathFromScriptMaps(IMSAdminBase* pAdmin, METADATA_HANDLE hBase, WCHAR *pchKey, 
                                        WCHAR **ppchDllPath) {
    HRESULT             hr = S_OK;
    METADATA_RECORD     md;
    WCHAR               *pchData = NULL;
    WCHAR               *pchSrc;

    // Init return values
    *ppchDllPath = NULL;

    // Get the multi-string Script Maps property
    hr = GetMultiStringProperty(pAdmin, hBase, pchKey, MD_SCRIPT_MAPS, &md);
    ON_ERROR_EXIT();
    
    pchData = (WCHAR*) md.pbMDData;
    pchSrc = pchData;
    
    do {
        WCHAR   *pchToken;
        WCHAR   *pchDelim = L",";
        int     len;

        // Have to read the length here because wcstok will modify the content of pchSrc
        len = lstrlenW(pchSrc) + 1;

        // Check if the entry contains the module
        if (HasAspnetDll(pchSrc)) {
            
            // Now get the full DLL path from the map.  The path is the second
            // token in the string, separated by commas.
            if (wcstok(pchSrc, pchDelim) != NULL) {
                pchToken = wcstok(NULL, pchDelim);
                if (pchToken != NULL) {
                    // We found the path.  Copy it and leave
                    *ppchDllPath = DupStr(pchToken);
                    ON_OOM_EXIT(*ppchDllPath);
                    break;
                }
            }
        }
            
        pchSrc += len;
    } while (*pchSrc != L'\0');

    if (*ppchDllPath == NULL) {
        EXIT_WITH_WIN32_ERROR(ERROR_NOT_FOUND);
    }

Cleanup:
    delete [] pchData;

    return hr;
}


HRESULT
GetRootVersion(IMSAdminBase* pAdmin, ASPNETVER *pVer) {
    HRESULT     hr = S_OK;
    WCHAR       *pchDllPath = NULL;

    pVer->Reset();
    
    hr = GetDllPathFromScriptMaps(pAdmin, METADATA_MASTER_ROOT_HANDLE, KEY_LMW3SVC, 
                                    &pchDllPath);
    ON_ERROR_EXIT();

    hr = g_smrm.FindDllVer(pchDllPath, pVer);
    ON_ERROR_EXIT();
  
Cleanup:
    delete [] pchDllPath;
    return hr;
}


/**
 * This function compares the Isapi DLL in the provided key with the current module.
 *
 * Parameters:
 *  pAdmin
 *  hBase       - Base handle for opening the provided key
 *  pchKey      - Path of key to open
 *  pdwRes      - Major result of comparison.  See enum COMPARE_RESULTS for details.
 *  pfIsLower   - TRUE if current is lower than key version
 *  pKeyDllPath    - (optional) Path of the dll at key.  Caller has to free memory
 */
HRESULT
CompareCurrentWithKey(IMSAdminBase* pAdmin, METADATA_HANDLE hBase, 
                            WCHAR *pchKey, DWORD *pdwRes, BOOL *pfIsLower,
                            WCHAR **pKeyDllPath) {
    HRESULT hr;
    WCHAR   *pchDllPath = NULL;

    // Init
    *pdwRes = COMPARE_UNDEF;
    *pfIsLower = FALSE;
    if (pKeyDllPath) {
        *pKeyDllPath = NULL;
    }
    
    hr = GetDllPathFromScriptMaps(pAdmin, hBase, pchKey, &pchDllPath);
    if (hr == HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND)) {
        *pdwRes = COMPARE_SM_NOT_FOUND;
        hr = S_OK;
        EXIT();
    }
    else if (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
        // Couldn't find any aspnet dll path in script maps
        *pdwRes = COMPARE_ASPNET_NOT_FOUND;
        hr = S_OK;
        EXIT();
    }

    ON_ERROR_EXIT();

    hr = CompareDllsVersion((WCHAR*)Names::IsapiFullPath(), pchDllPath,
                pdwRes, pfIsLower);
    ON_ERROR_EXIT();
    
    ASSERT(*pdwRes != COMPARE_FIRST_FILE_MISSING);

    if (pKeyDllPath) {
        *pKeyDllPath = pchDllPath;
        pchDllPath = NULL;
    }
    
Cleanup:
    delete [] pchDllPath;
    
    return hr;
}


/**
 * This function will read the version installed at the root, and write it to
 * at HKLM\Software\Microsoft\ASP.NET\RootVer.  If we hit an error, or couldn't
 * find ASP.NET DLL at root, we will write 0.0.0.0 instead.
 */
HRESULT
WriteRootVersion(IMSAdminBase* pAdmin) {
    HKEY        hKey = NULL;
    WCHAR       sVer[MAX_PATH];
    HRESULT     hr = S_OK;
    ASPNETVER   *pVer = NULL;
    LONG        lRet;

    pVer = new ASPNETVER;
    ON_OOM_EXIT(pVer);

    memset(sVer, 0, MAX_PATH*sizeof(WCHAR));

    hr = GetRootVersion(pAdmin, pVer);
    if (hr) {
        // If there is an error, write 0.0.0.0 instead
        pVer->Reset();
        hr = S_OK;
    }

    pVer->ToString(sVer, MAX_PATH-1);

    lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGPATH_MACHINE_APP_L, 0, L"", 
                REG_OPTION_NON_VOLATILE, 
                KEY_ALL_ACCESS, NULL, &hKey, NULL);
    ON_WIN32_ERROR_EXIT(lRet);
    
    lRet = RegSetValueEx(hKey, REGVAL_ROOTVER, 0, REG_SZ, (const BYTE*)sVer, (lstrlenW(sVer) + 1) * sizeof(WCHAR));
    ON_WIN32_ERROR_EXIT(lRet);
    
Cleanup:
    if (hKey)
        RegCloseKey(hKey);
    
    if (pVer)
        delete pVer;
    
    return hr;
}


inline BOOL
IsRootKey(WCHAR *pchKey) {
    return (_wcsicmp(KEY_LMW3SVC_SLASH, pchKey) == 0);
}


WCHAR *
GetIISAbsolutePath(WCHAR *pchPath) {
    WCHAR       *pchDupPath = NULL;
    int         len;

    len = lstrlenW(pchPath) + 6; // Worst case, need to add "/LM/" + ending "/" + NULL

    pchDupPath = new WCHAR[len];
    if (!pchDupPath)
        return NULL;

    StringCchCopyW(pchDupPath, len, L"/LM");

    if (pchPath[0] != '/') {
        StringCchCatW(pchDupPath, len, L"/");
    }

    StringCchCatW(pchDupPath, len, pchPath);
    
    if (pchPath[lstrlenW(pchPath)-1] != L'/') {
        StringCchCatW(pchDupPath, len, L"/");
    }

    // Convert all backward slash to forward slash.  All functions expect only
    // forward slash
    for(WCHAR *pchCur = pchDupPath; *pchCur != '\0'; pchCur++) {
        if (*pchCur == L'\\') {
            *pchCur = L'/';
        }
    }

    return pchDupPath;
}


/**
 *  Get inherited String or Multi-string property
 */
HRESULT
GetInheriedStringMSRecursive(IMSAdminBase *pAdmin, WCHAR *pchKey, DWORD dwProp,
                                WCHAR **ppchProp, BOOL bMultiString) {
    HRESULT         hr = S_OK;
    METADATA_RECORD md;
    WCHAR           *pchLast;

    // We expect all path starting with /LM/
    ASSERT(_wcsnicmp(pchKey, KEY_LM_SLASH, wcslen(KEY_LM_SLASH)) == 0);

    if (bMultiString) {
        hr = GetMultiStringProperty(pAdmin, METADATA_MASTER_ROOT_HANDLE, 
                            pchKey, dwProp, &md);
    }
    else {
        hr = GetStringProperty(pAdmin, METADATA_MASTER_ROOT_HANDLE, 
                            pchKey, dwProp, &md);
    }
    if (hr == HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND)) {
        if (_wcsicmp(pchKey, KEY_LM_SLASH) == 0) {
            // We have reached the top (ie. /LM/).
            return HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND);
        }

        pchLast = &pchKey[lstrlenW(pchKey)-2];
        if (pchLast <= pchKey) {
            ASSERT(pchLast > pchKey);
            return HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
        }

        ASSERT(*(pchLast+1) == '/');

        while(*pchLast != '/') {
            // The input parameter is malformed and doesn't contain a leading '/'
            ASSERT(pchLast != pchKey);
            pchLast--;
        }

        *(pchLast+1) = '\0';
        return GetInheriedStringMSRecursive(pAdmin, pchKey, dwProp, ppchProp, bMultiString);
        
    }
    else {
        ON_ERROR_EXIT();
        *ppchProp = (WCHAR*) md.pbMDData;
    }

Cleanup:
    return hr;
}


/**
 *  Return the inherited scriptmap property at pchKey.
 *
 *  Params:
 *  pAdmin          IMSAdminBase
 *  pchKey          Normalized key path
 *  ppchInheritedSM Returned inherited scripmap.
 */
HRESULT
GetInheritedScriptMap(IMSAdminBase *pAdmin, WCHAR *pchKey, WCHAR **ppchInheritedSM) {
    HRESULT     hr = S_OK;
    WCHAR       *pchDupPath = NULL;

    *ppchInheritedSM = NULL;

    pchDupPath = DupStr(pchKey);
    ON_OOM_EXIT(pchDupPath);

    hr = GetInheriedStringMSRecursive(pAdmin, pchDupPath, MD_SCRIPT_MAPS, ppchInheritedSM, true);
    ON_ERROR_EXIT();

Cleanup:
    if (pchDupPath)
        delete [] pchDupPath;
    
    return hr;
}

/**
 * This function will:
 *      - Installs aspnet dll on all aspnet-free Scriptmaps
 *      - Replace aspnet dll on all scriptmaps that has aspnet dll with
 *        a lower version
 *
 * Params:
 *  pAdmin      - IMSAdminBase object
 *  pchKeyPath  - The Key to start with.  Must be an absolute path.  (e.g. /lm/w3svc/n/root/)
 *  pchDllInstall     - Full path of the aspnet DLL to install
 *  fRecursive  - Register recursively down the tree
 *  fIgnoreVer
 *              - If TRUE, we will ignore version comparison when replacing scriptmap
 */
HRESULT
RegisterScriptMaps(IMSAdminBase* pAdmin, WCHAR *pchKeyPath, 
            const WCHAR *pchDllInstall, BOOL fRecursive, BOOL fIgnoreVer) {
    HRESULT         hr = S_OK;
    METADATA_HANDLE lmHandle = NULL;
    WCHAR           *pchPaths = NULL, *path, *pchInheritedSM = NULL, *pchDllKey = NULL;
    METADATA_RECORD md;
    BOOL            fGetDataPathsAgain = FALSE;
    BOOL            fCreateKey = FALSE;
    BOOL            fCheckRootTouched = FALSE;  // If we should check if the root key is touched or not

    CSetupLogging::Log(1, "RegisterScriptMaps", 0, "Registering scriptmap properties in IIS metabase");        
    
    fCheckRootTouched = IsRootKey(pchKeyPath);

    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            L"/",
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &lmHandle);

    ON_ERROR_EXIT();

    if (fRecursive) {
        hr = GetDataPaths(pAdmin, lmHandle, pchKeyPath, MD_SCRIPT_MAPS, 
                            MULTISZ_METADATA, &pchPaths);
        ON_ERROR_EXIT();

        // If we cannot find the scriptmap at the base key, create one.
        if (_wcsicmp(pchKeyPath, pchPaths) != 0) {
            fGetDataPathsAgain = TRUE;
            fCreateKey = TRUE;
        }
    }
    else {
        BOOL    fFound;
        
        md.dwMDIdentifier = MD_SCRIPT_MAPS;
        md.dwMDUserType = IIS_MD_UT_FILE;
        md.dwMDDataType = MULTISZ_METADATA;
        
        hr = CheckMDProperty(pAdmin, lmHandle, pchKeyPath, &md, &fFound);
        ON_ERROR_EXIT();

        if (!fFound) {
            fCreateKey = TRUE;
        }

        // Create the pchPaths.  Needs two nulls for a multi-string.

        size_t size = lstrlenW(pchKeyPath) + 2;
        pchPaths = new (NewClear) WCHAR[size]; 
        ON_OOM_EXIT(pchPaths);

        StringCchCopyW(pchPaths, size, pchKeyPath);
    }
    
    if (fCreateKey) {
        WCHAR   *pchSM;
        
        hr = GetInheritedScriptMap(pAdmin, pchKeyPath, &pchInheritedSM);
        if (hr) {
            // If we fail to get the inherited scriptmap, let's continue 
            // using an emtpy one.
            pchSM = L"\0";
        }
        else {
            pchSM = pchInheritedSM;
        }
        
        md.dwMDIdentifier = MD_SCRIPT_MAPS;
        md.dwMDAttributes = METADATA_INHERIT;
        md.dwMDUserType = IIS_MD_UT_FILE;
        md.dwMDDataType = MULTISZ_METADATA;
        md.pbMDData = (unsigned char*) pchSM;
        md.dwMDDataLen = (wcslenms(pchSM)+1)*sizeof(WCHAR);
        md.dwMDDataTag = 0;

        hr = pAdmin->SetData(lmHandle, pchKeyPath, &md);
        ON_ERROR_EXIT();
    }

    if (fGetDataPathsAgain) {
        delete [] pchPaths;
        pchPaths = NULL;

        hr = GetDataPaths(pAdmin, lmHandle, pchKeyPath, MD_SCRIPT_MAPS, MULTISZ_METADATA, &pchPaths);
        ON_ERROR_EXIT();
    }

    // Go thru all the keys that contains a Scriptmap, and install aspnet Dll on
    // those appropriate ones.
    
    for (path = pchPaths; *path != L'\0'; path += lstrlenW(path) + 1) {

        BOOL    fInstall, fAspnetFound, fIsLower;
        DWORD   dwResult;

        // By default, we always install. We then compare our version with that in the key
        // and decide if we will change our mind.
        fInstall = TRUE;
        fAspnetFound = TRUE;

        hr = CompareCurrentWithKey(pAdmin, lmHandle, path, &dwResult, &fIsLower, &pchDllKey);
        ON_ERROR_EXIT();

        ASSERT(!(dwResult & COMPARE_SM_NOT_FOUND));
        ASSERT(!(dwResult & COMPARE_UNDEF));
        ASSERT(!(dwResult & COMPARE_FIRST_FILE_MISSING));

        if (!!(dwResult & (COMPARE_ASPNET_NOT_FOUND|COMPARE_SECOND_FILE_MISSING))) {
            // We will install if asp.net isn't found in the key, or if the
            // DLL it pointed to is missing
            fAspnetFound = FALSE;
        } else if (!!(dwResult & COMPARE_SAME_PATH)) {
            // They have exactly the same path.  Don't install
            fInstall = FALSE;
        }
        else if (!fIgnoreVer) {
            ASSERT(!!(dwResult & (COMPARE_SAME|COMPARE_DIFFERENT)));
            
            // If our version is lower, forget it
            if (fIsLower) {
                fInstall = FALSE;
            }
        }
        
        if (fInstall) {
            if (fAspnetFound) {
                ASSERT(pchDllKey != NULL);

                hr = g_smrm.ChangeVersion(pAdmin, lmHandle, path, pchDllKey, pchDllInstall);
                ON_ERROR_EXIT();
            }
            else {
                // Clean install
                hr = SCRIPTMAP_REGISTER_MANAGER::CleanInstall(pAdmin, lmHandle, path, pchDllInstall,
                                                    (dwResult != COMPARE_ASPNET_NOT_FOUND));
                ON_ERROR_EXIT();
            }

            // If we have touched the root key, write in the registry the new root key version
            if (fCheckRootTouched) {
                if (IsRootKey(path)) {
                    hr = WriteRootVersion(pAdmin);
                    ON_ERROR_CONTINUE();

                    hr = S_OK;

                    fCheckRootTouched = FALSE;
                }
            }
 
        }

        if (pchDllKey) {
            delete [] pchDllKey;
            pchDllKey = NULL;
        }
    }

Cleanup:
    CSetupLogging::Log(hr, "RegisterScriptMaps", 0, "Registering scriptmap properties in IIS metabase");        
    
    if (lmHandle != NULL) {
        pAdmin->CloseKey(lmHandle);
    }

    delete [] pchPaths;
    delete [] pchDllKey;

    return hr;
}

/*
 * This function will remove a specified module from all Scriptmaps, and optionally
 * replace it with another module.
 *
 * Parameters:
 *  pAdmin      IMSAdminBase
 *  module      The module to unregister
 *  NewModule   If non-NULL, replace unregistered module with this one
 */
HRESULT
UnregisterScriptMaps(IMSAdminBase* pAdmin, WCHAR *pchKeyPath, 
                    const WCHAR * module, WCHAR *NewModule, BOOL fRecursive) {
    HRESULT         hr;
    METADATA_HANDLE lmHandle = NULL;
    WCHAR           *pchPaths = NULL, *path;
    BOOL            fCheckRootTouched = FALSE;  // If we should check if the root key is touched or not

    CSetupLogging::Log(1, "UnregisterScriptMaps", 0, "Unregistering scriptmap properties in IIS metabase");        
    
    fCheckRootTouched = IsRootKey(pchKeyPath);

    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            L"/",
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &lmHandle);

    ON_ERROR_EXIT();

    if (fRecursive) {
        hr = GetDataPaths(pAdmin, lmHandle, pchKeyPath, MD_SCRIPT_MAPS, MULTISZ_METADATA, &pchPaths);
        ON_ERROR_EXIT();
    }
    else {
        // Create the pchPaths.  Needs two nulls for a multi-string.
        size_t size = lstrlenW(pchKeyPath) + 2;
        pchPaths = new (NewClear) WCHAR[size]; 
        ON_OOM_EXIT(pchPaths);

        StringCchCopyW(pchPaths, size, pchKeyPath);
    }

    for (path = pchPaths; *path != L'\0'; path += lstrlenW(path) + 1) {
        if (NewModule != NULL) {
            hr = g_smrm.ChangeVersion(pAdmin, lmHandle, path, module, NewModule);
            ON_ERROR_EXIT();
        }
        else {
            hr = RemoveStringFromMultiStringProp(pAdmin, lmHandle, path, MD_SCRIPT_MAPS, 
                            module, MULTISZ_MATCHING_ANY, TRUE);
            if (hr == HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND)) {
                // It's okay if we couldn't find the scriptmap property
                hr = S_OK;
            }
            ON_ERROR_EXIT();
        }

        // If we have touched the root key, write in the registry the new root key version
        if (fCheckRootTouched) {
            if (IsRootKey(path)) {
                hr = WriteRootVersion(pAdmin);
                ON_ERROR_CONTINUE();

                hr = S_OK;

                fCheckRootTouched = FALSE;
            }
        }
 
    }

Cleanup:
    CSetupLogging::Log(hr, "UnregisterScriptMaps", 0, "Unregistering scriptmap properties in IIS metabase");        
    
    if (lmHandle != NULL) {
        pAdmin->CloseKey(lmHandle);
    }

    delete [] pchPaths;

    return hr;
}

BOOL
IsNumericString(WCHAR *pchString) {
    int     i;
    BOOL    fRet = TRUE;

    i = lstrlenW(pchString) - 1;
    while(i >= 0) {
        if (!iswdigit(pchString[i])) {
            fRet = FALSE;
            break;
        }

        i--;
    }
    
    return fRet;
}


HRESULT
RegisterFilter(IMSAdminBase* pAdmin, const WCHAR *pchModule, ASPNETVER *pver) {
    HRESULT         hr;
    METADATA_HANDLE w3svcHandle = NULL;
    METADATA_RECORD md;
    DWORD           dwValue;
    WCHAR           *pchFilterKey = NULL;
    WCHAR           *pchAlloc = NULL;
    WCHAR           *pchFilterName = NULL;
    WCHAR           *pchFilterNameAlloc = NULL;

    CSetupLogging::Log(1, "RegisterFilter", 0, "Registering ISAPI Filter in IIS metabase");        
    
    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            KEY_LMW3SVC,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &w3svcHandle);

    ON_ERROR_EXIT();

    // Create filter key
    if (pver == NULL || pver->Equal(VER_PRODUCTVERSION_STR_L)) {
        pchFilterKey = KEY_ASPX_FILTER;
        pchFilterName = FILTER_NAME_L;
    }
    else
    {
        WCHAR   ver[128];

        ZeroMemory(&ver, sizeof(ver));
        pver->ToString(ver, sizeof(ver)/sizeof(WCHAR)-1);
        
        {
      size_t size = KEY_ASPX_FILTER_PREFIX_LEN + lstrlenW(ver) + 1;
      pchAlloc = new WCHAR[size];
      ON_OOM_EXIT(pchAlloc);
      
      pchFilterKey = pchAlloc;
      StringCchCopyW(pchFilterKey, size, KEY_ASPX_FILTER_PREFIX);
      StringCchCatW(pchFilterKey, size, ver);
    };

    {
      size_t size = FILTER_ASPNET_PREFIX_LEN + lstrlenW(ver) + 1;
      pchFilterNameAlloc = new WCHAR[size];
      ON_OOM_EXIT(pchFilterNameAlloc);
        
      pchFilterName = pchFilterNameAlloc;
      StringCchCopyW(pchFilterName, size, FILTER_ASPNET_PREFIX);
      StringCchCatW(pchFilterName, size, ver);
    }
    }
    
    // Delete if it still exists
    hr = pAdmin->DeleteKey(w3svcHandle, pchFilterKey);
    ON_ERROR_CONTINUE();
    
    hr = pAdmin->AddKey(w3svcHandle, pchFilterKey);
    ON_ERROR_EXIT();

    // Add my KeyType (IIsFilter)
    md.dwMDIdentifier = MD_KEY_TYPE;
    md.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    md.dwMDUserType = IIS_MD_UT_SERVER;
    md.dwMDDataType = STRING_METADATA;
    md.pbMDData = (unsigned char*) KEY_FILTER_KEYTYPE;
    md.dwMDDataLen = sizeof(KEY_FILTER_KEYTYPE);
    md.dwMDDataTag = 0;

    hr = pAdmin->SetData(w3svcHandle, pchFilterKey, &md);
    ON_ERROR_EXIT();

    // Add my FilterDescription (ASP.NET Filter)
    md.dwMDIdentifier = MD_FILTER_DESCRIPTION;
    md.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    md.dwMDUserType = IIS_MD_UT_SERVER;
    md.dwMDDataType = STRING_METADATA;
    md.pbMDData = (unsigned char*) FILTER_DESCRIPTION;
    md.dwMDDataLen = sizeof(FILTER_DESCRIPTION);
    md.dwMDDataTag = 0;

    hr = pAdmin->SetData(w3svcHandle, pchFilterKey, &md);
    ON_ERROR_EXIT();

    // Add my FilterImagePath
    md.dwMDIdentifier = MD_FILTER_IMAGE_PATH;
    md.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    md.dwMDUserType = IIS_MD_UT_SERVER;
    md.dwMDDataType = STRING_METADATA;
    md.pbMDData = (unsigned char*) pchModule;
    md.dwMDDataLen = (lstrlenW(pchModule) + 1) * sizeof(WCHAR);
    md.dwMDDataTag = 0;

    hr = pAdmin->SetData(w3svcHandle, pchFilterKey, &md);
    ON_ERROR_EXIT();

    // Add EnableCache for IIS6
    dwValue = 1;
    md.dwMDIdentifier = MD_FILTER_ENABLE_CACHE;
    md.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    md.dwMDUserType = IIS_MD_UT_SERVER;
    md.dwMDDataType = DWORD_METADATA;
    md.pbMDData = (unsigned char*) &dwValue;
    md.dwMDDataLen = sizeof(DWORD);
    md.dwMDDataTag = 0;

    hr = pAdmin->SetData(w3svcHandle, pchFilterKey, &md);
    ON_ERROR_EXIT();

    // Add filter to FilterLoadOrder
    hr = AppendListProperty(pAdmin, w3svcHandle, PATH_FILTERS, MD_FILTER_LOAD_ORDER, pchFilterName);
    ON_ERROR_EXIT();

Cleanup:
    CSetupLogging::Log(hr, "RegisterFilter", 0, "Registering ISAPI Filter in IIS metabase");        
    
    if (w3svcHandle) {
        pAdmin->CloseKey(w3svcHandle);
    }

    delete [] pchAlloc;
    delete [] pchFilterNameAlloc;

    return hr;
}

HRESULT 
UnregisterFilter(IMSAdminBase* pAdmin, const WCHAR* module) {
    HRESULT         hr = S_OK;
    METADATA_HANDLE w3svcHandle = NULL;
    WCHAR           *pchPaths = NULL;
    WCHAR           *path;
    WCHAR           *pchName, *pchNameAlloc, *pchPathFilters;
    METADATA_RECORD md;
    WCHAR           *pchFilterImagePath = NULL;
    bool            containsModule;
    WCHAR           ch;
    int             iLen;

    CSetupLogging::Log(1, "UnregisterFilter", 0, "Unregistering ISAPI Filter in IIS metabase");        
    
    if (module == ASPNET_ALL_VERS) {
        int i;
        // Cleanup ALL versions of Aspnet DLLs
        for (i = 0; i < ARRAY_SIZE(g_AspnetDllNames); i++) {
            hr = UnregisterFilter(pAdmin, g_AspnetDllNames[i]);
            ON_ERROR_EXIT();
        }
    }
        
    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            KEY_LMW3SVC,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &w3svcHandle);

    ON_ERROR_EXIT();

    if (module == ASPNET_ALL_VERS) {
        // Remove all filter starts with "ASP.NET_" from FilterLoadOrder
        hr = RemoveListProperty(pAdmin, w3svcHandle, PATH_FILTERS, MD_FILTER_LOAD_ORDER, 
                FILTER_ASPNET_PREFIX, TRUE, FALSE);
        if (hr == HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND)) {
            hr = S_OK;
        }
        ON_ERROR_EXIT();
        
        // We're done with all the job for "all versions". Exit.
        EXIT();
    }

    // Get paths containing any aspnet dll in the filter image path
    hr = GetDataPaths(pAdmin, w3svcHandle, L"/", MD_FILTER_IMAGE_PATH, STRING_METADATA, &pchPaths);
    ON_ERROR_EXIT();

    for (path = pchPaths; *path != L'\0'; path += lstrlenW(path) + 1) {
        // Get all values of the filter image path
        hr = GetStringProperty(pAdmin, w3svcHandle, path, MD_FILTER_IMAGE_PATH, &md);
        ON_ERROR_CONTINUE();
        if (hr != S_OK)
            continue;

        // check if they contain our module name
        pchFilterImagePath = (WCHAR*) md.pbMDData;
        containsModule = wcsistr(pchFilterImagePath, (WCHAR*)module);
        delete [] pchFilterImagePath;
        if (!containsModule)
            continue;
            
        pchNameAlloc = pchName = DupStr(path);
        ON_OOM_CONTINUE(pchNameAlloc);
        if (pchNameAlloc == NULL)
            continue;

        ON_OOM_EXIT(pchName);
        
        // Get filter name from the path
        iLen = lstrlenW(pchName);

        if (iLen < 1)
            EXIT_WITH_HRESULT(E_UNEXPECTED);

        ASSERT(pchName[iLen - 1] == L'/');
        if    (pchName[iLen - 1] !=  L'/')
            EXIT_WITH_HRESULT(E_UNEXPECTED);


        pchName[lstrlenW(pchName)-1] = L'\0';
        pchName = wcsrchr(pchName, L'/');
        ASSERT(pchName != NULL);
        if    (pchName == NULL)
            EXIT_WITH_HRESULT(E_UNEXPECTED);

        pchName++;
        ch = *pchName;
        *pchName = L'\0';

        // Get path to Filters key
        pchPathFilters = DupStr(pchNameAlloc);
        ON_OOM_CONTINUE(pchPathFilters);
        if (!pchPathFilters) {
            delete [] pchNameAlloc;
            continue;
        }

        *pchName = ch;
        pchName[-1] = L'\0';

        // Remove filter from FilterLoadOrder
        hr = RemoveListProperty(pAdmin, w3svcHandle, pchPathFilters, MD_FILTER_LOAD_ORDER, 
                                pchName, FALSE, FALSE);
        ON_ERROR_CONTINUE();

        delete [] pchNameAlloc;
        delete [] pchPathFilters;

        // Delete my filter keys
        hr = pAdmin->DeleteKey(w3svcHandle, path);
        ON_ERROR_CONTINUE();
    }

Cleanup:
    CSetupLogging::Log(hr, "UnregisterFilter", 0, "Unregistering ISAPI Filter in IIS metabase");        
    
    if (w3svcHandle != NULL) {
        pAdmin->CloseKey(w3svcHandle);
    }

    delete [] pchPaths;

    return hr;

}


HRESULT 
RegisterDefaultDocument(IMSAdminBase* pAdmin, WCHAR *pchDefaultDoc) {
    HRESULT         hr = S_OK;
    METADATA_HANDLE w3svcHandle = NULL;
    METADATA_RECORD md;
    WCHAR           *pchPaths = NULL;
    WCHAR           *path;
    bool            rootDefaultDoc;
    
    CSetupLogging::Log(1, "RegisterDefaultDocument", 0, "Registering DefaultDoc properties in IIS metabase");        

// CONSIDER:
// Need to do it on a per-path basis
    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            KEY_LMW3SVC,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &w3svcHandle);

    ON_ERROR_EXIT();

    hr = GetDataPaths(pAdmin, w3svcHandle, L"/", MD_DEFAULT_LOAD_FILE, STRING_METADATA, &pchPaths);
    ON_ERROR_EXIT();

    rootDefaultDoc = false;
    if (_wcsicmp(pchPaths, L"/") == 0) {
        rootDefaultDoc = true;
    }

    for (path = pchPaths; *path != L'\0'; path += lstrlenW(path) + 1) {
        hr = AppendListProperty(pAdmin, w3svcHandle, path, MD_DEFAULT_LOAD_FILE, pchDefaultDoc);
        ON_ERROR_EXIT();
    }

    if (!rootDefaultDoc) {
        md.dwMDIdentifier = MD_DEFAULT_LOAD_FILE;
        md.dwMDAttributes = METADATA_INHERIT;
        md.dwMDUserType = IIS_MD_UT_FILE;
        md.dwMDDataType = STRING_METADATA;
        md.pbMDData = (unsigned char *) pchDefaultDoc;
        md.dwMDDataLen = (lstrlenW(pchDefaultDoc) + 1) * sizeof(pchDefaultDoc[0]);
        md.dwMDDataTag = 0;

        hr = pAdmin->SetData(w3svcHandle, L"/", &md);
        ON_ERROR_EXIT();
    }

Cleanup:
    CSetupLogging::Log(hr, "RegisterDefaultDocument", 0, "Registering DefaultDoc properties in IIS metabase");        
    
    if (w3svcHandle != NULL) {
        pAdmin->CloseKey(w3svcHandle);
    }

    delete [] pchPaths;

    return hr;
}


HRESULT 
UnregisterDefaultDocument(IMSAdminBase* pAdmin, const WCHAR *pchDefDocs) {
    HRESULT         hr = S_OK;
    METADATA_HANDLE w3svcHandle = NULL;
    WCHAR           *pchPaths = NULL;
    WCHAR           *path;
    CStrAry         aryDefDocs;     // Dynamic array of default document strings
    WCHAR           *pchBuf = NULL;
    WCHAR           *pchDelim = L",";
    WCHAR           *pchTok;
    int             i;
    
    CSetupLogging::Log(1, "UnregisterDefaultDocument", 0, "Unregistering DefaultDoc properties in IIS metabase");        
    
    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            KEY_LMW3SVC,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &w3svcHandle);

    ON_ERROR_EXIT();

    hr = GetDataPaths(pAdmin, w3svcHandle, L"/", MD_DEFAULT_LOAD_FILE, STRING_METADATA, &pchPaths);
    ON_ERROR_EXIT();

    // pchDefDocs is a comma delimited.  Take out all default document strings.
    pchBuf = new WCHAR[lstrlenW(pchDefDocs)+1];
    ON_OOM_EXIT(pchBuf);
    StringCchCopyW(pchBuf, lstrlenW(pchDefDocs)+1, pchDefDocs);
    
    pchTok = wcstok(pchBuf, pchDelim);
    while (pchTok) {

        hr = aryDefDocs.Append(pchTok);
        ON_ERROR_EXIT();
        
        pchTok = wcstok(NULL, pchDelim);
    }
    
    for (path = pchPaths; *path != L'\0'; path += lstrlenW(path) + 1) {
        for (i=0; i < aryDefDocs.Size(); i++) {
            hr = RemoveListProperty(pAdmin, w3svcHandle, path, 
                                    MD_DEFAULT_LOAD_FILE, (WCHAR*)aryDefDocs[i], FALSE, TRUE);
            ON_ERROR_EXIT();
        }
    }

Cleanup:
    CSetupLogging::Log(hr, "UnregisterDefaultDocument", 0, "Unregistering DefaultDoc properties in IIS metabase");        
    
    if (w3svcHandle != NULL) {
        pAdmin->CloseKey(w3svcHandle);
    }

    delete [] pchPaths;
    delete [] pchBuf;

    return hr;
}


HRESULT
UnregisterMimeMap(IMSAdminBase *pAdmin, const WCHAR *pchMM)
{
    HRESULT         hr = S_OK;
    METADATA_HANDLE hKey;
    WCHAR           *pchExt = NULL, *pchType = NULL;
    WCHAR           *pchBuf = NULL, *pchBufExt = NULL;
    WCHAR           *pchDelim = L",";
    int             iLen;
    
    CSetupLogging::Log(1, "UnregisterMimeMap", 0, "Unregistering MimeMap property in IIS metabase");        
    
    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            KEY_MIMEMAP,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &hKey);

    pchBuf = new WCHAR[lstrlenW(pchMM)+1];
    ON_OOM_EXIT(pchBuf);
    StringCchCopyW(pchBuf, lstrlenW(pchMM)+1, pchMM);

    // Grab the extension and type pair from the comma delimited string
    pchExt = wcstok(pchBuf, pchDelim);
    if (pchExt)
        pchType = wcstok(NULL, pchDelim);
    
    while (pchExt && pchType) {

        // We need an exact match for the extension.  Append comma to the end
        iLen = lstrlenW(pchExt)+2;
        WCHAR * pchRealloc = new (pchBufExt, NewReAlloc) WCHAR[iLen];
        ON_OOM_EXIT(pchRealloc);
        pchBufExt = pchRealloc;

        StringCchCopyW(pchBufExt, iLen, pchExt);
        StringCchCatW(pchBufExt, iLen, L",");

        hr = RemoveStringFromMultiStringProp(pAdmin, hKey, L"/", MD_MIME_MAP, 
                            pchBufExt, MULTISZ_MATCHING_PREFIX, FALSE);
        ON_ERROR_EXIT();
        
        // Grab the next extension and type pair
        pchExt = wcstok(NULL, pchDelim);
        if (pchExt)
            pchType = wcstok(NULL, pchDelim);
    }

Cleanup:
    CSetupLogging::Log(hr, "UnregisterMimeMap", 0, "Unregistering MimeMap property in IIS metabase");        
    
    if (hKey != NULL) {
        pAdmin->CloseKey(hKey);
    }
    
    delete [] pchBuf;
    delete [] pchBufExt;
    return hr;
}


HRESULT
RegisterMimeMap(IMSAdminBase *pAdmin, WCHAR *pchMM)
{
    HRESULT         hr = S_OK;
    METADATA_HANDLE hKey = NULL;
    METADATA_RECORD md;
    BOOL            fFound;
    WCHAR           *pchAppend = NULL;
    WCHAR           *pchExt = NULL, *pchType = NULL;
    WCHAR           *pchDelim = L",";
    WCHAR           *pchBuf = NULL;

    CSetupLogging::Log(1, "RegisterMimeMap", 0, "Registering MimeMap property in IIS metabase");        
    
    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            KEY_MIMEMAP,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &hKey);

    ON_ERROR_EXIT();

    // Init md
    memset(&md, 0, sizeof(md));

    // Check if there is a MimeMap property at all in that key.
    // If not, create an empty one.
    
    md.dwMDIdentifier = MD_MIME_MAP;
    md.dwMDAttributes = METADATA_INHERIT;
    md.dwMDUserType = IIS_MD_UT_FILE;
    md.dwMDDataType = MULTISZ_METADATA;
    
    hr = CheckMDProperty(pAdmin, hKey, L"/", &md, &fFound);
    ON_ERROR_EXIT();
    
    if (!fFound) {
        md.pbMDData = (unsigned char*) L"\0";
        md.dwMDDataLen = sizeof(L"\0");
        md.dwMDDataTag = 0;

        hr = pAdmin->SetData(hKey, L"/", &md);
        ON_ERROR_EXIT();
    }

    pchBuf = new WCHAR[lstrlenW(pchMM)+1];
    ON_OOM_EXIT(pchBuf);
    StringCchCopyW(pchBuf, lstrlenW(pchMM)+1, pchMM);

    // Grab the extension and type pair from the comma delimited string
    pchExt = wcstok(pchBuf, pchDelim);
    if (pchExt)
        pchType = wcstok(NULL, pchDelim);

    while (pchExt && pchType) {
        int len;

        // Need to include the terminating null and the ','
        len = lstrlenW(pchExt) + lstrlenW(pchType) + 2;
        WCHAR * pchRealloc = new (pchAppend, NewReAlloc) WCHAR[len];
        ON_OOM_EXIT(pchRealloc);
        pchAppend = pchRealloc;

        StringCchCopyW(pchAppend, len, pchExt);
        StringCchCatW(pchAppend, len, L",");
        StringCchCatW(pchAppend, len, pchType);

        hr = AppendStringToMultiStringProp(pAdmin, hKey, L"/", MD_MIME_MAP, pchAppend, TRUE);
        ON_ERROR_EXIT();
        
        // Grab the next extension and type pair
        pchExt = wcstok(NULL, pchDelim);
        if (pchExt)
            pchType = wcstok(NULL, pchDelim);
    }

Cleanup:
    CSetupLogging::Log(hr, "RegisterMimeMap", 0, "Registering MimeMap property in IIS metabase");        
    
    if (hKey != NULL) {
        pAdmin->CloseKey(hKey);
    }

    delete [] pchAppend;
    delete [] pchBuf;
    
    return hr;
}


HRESULT 
RegisterCustomHeader(IMSAdminBase* pAdmin, WCHAR *pchCustomHeader) {
    HRESULT         hr = S_OK;
    METADATA_HANDLE w3svcHandle = NULL;
    METADATA_RECORD md;
    WCHAR           *pchPaths = NULL;
    WCHAR           *path;
    WCHAR           *msCustom = NULL;
    bool            rootHeader;
    
    CSetupLogging::Log(1, "RegisterCustomHeader", 0, "Registering custom header properties in IIS metabase");        

    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            KEY_LMW3SVC,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &w3svcHandle);

    ON_ERROR_EXIT();

    hr = GetDataPaths(pAdmin, w3svcHandle, L"/", MD_HTTP_CUSTOM, MULTISZ_METADATA, &pchPaths);
    ON_ERROR_EXIT();

    rootHeader = false;
    if (_wcsicmp(pchPaths, L"/") == 0) {
        rootHeader = true;
    }

    for (path = pchPaths; *path != L'\0'; path += lstrlenW(path) + 1) {
        hr = AppendStringToMultiStringProp( pAdmin, w3svcHandle, path,
                        MD_HTTP_CUSTOM, pchCustomHeader, TRUE);
        ON_ERROR_EXIT();
    }

    if (!rootHeader) {
        int len = lstrlenW(pchCustomHeader) + 2;
        
        msCustom = new (NewClear) WCHAR[len];
        ON_OOM_EXIT(msCustom);
        
        StringCchCopyW(msCustom, len, pchCustomHeader);
        
        md.dwMDIdentifier = MD_HTTP_CUSTOM;
        md.dwMDAttributes = METADATA_INHERIT;
        md.dwMDUserType = IIS_MD_UT_FILE;
        md.dwMDDataType = MULTISZ_METADATA;
        md.pbMDData = (unsigned char *) msCustom;
        md.dwMDDataLen = len * sizeof(msCustom[0]);
        md.dwMDDataTag = 0;

        hr = pAdmin->SetData(w3svcHandle, L"/", &md);
        ON_ERROR_EXIT();
    }

Cleanup:
    CSetupLogging::Log(hr, "RegisterCustomHeader", 0, "Register custom header properties in IIS metabase");        
    
    if (w3svcHandle != NULL) {
        pAdmin->CloseKey(w3svcHandle);
    }

    delete [] pchPaths;
    delete [] msCustom;

    return hr;
}


//
// Note:
// If fAllVer is FALSE, we will do exact matching when removing the string from multisz;
// Otherwise, we will do a prefix matching.
// It's done so because it's assumed that even though the Custom header doesn't have a
// version in this version: "X-Powered-By: ASP.NET", but future versions may have
// a trailing version number 
HRESULT 
UnregisterCustomHeader(IMSAdminBase* pAdmin, const WCHAR *pchCustomHeader, BOOL fAllVer) {
    HRESULT         hr = S_OK;
    METADATA_HANDLE w3svcHandle = NULL;
    WCHAR           *pchPaths = NULL;
    WCHAR           *path;
    
    CSetupLogging::Log(1, "UnregisterCustomHeader", 0, "Unregistering custom header properties in IIS metabase");        
    
    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            KEY_LMW3SVC,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &w3svcHandle);

    ON_ERROR_EXIT();

    hr = GetDataPaths(pAdmin, w3svcHandle, L"/", MD_HTTP_CUSTOM, MULTISZ_METADATA, &pchPaths);
    ON_ERROR_EXIT();

    for (path = pchPaths; *path != L'\0'; path += lstrlenW(path) + 1) {
        hr = RemoveStringFromMultiStringProp( pAdmin, w3svcHandle, path,
                        MD_HTTP_CUSTOM, pchCustomHeader, 
                        fAllVer ? MULTISZ_MATCHING_PREFIX : MULTISZ_MATCHING_EXACT, TRUE);
        ON_ERROR_EXIT();
    }

Cleanup:
    CSetupLogging::Log(hr, "UnregisterCustomHeader", 0, "Unregistering custom header properties in IIS metabase");        
    
    if (w3svcHandle != NULL) {
        pAdmin->CloseKey(w3svcHandle);
    }

    delete [] pchPaths;

    return hr;
}


/*
 * The function will all aspnet elements from the metabase.
 *
 * Parameters:
 *  pAdmin          - Base Admin object
 */
HRESULT
RemoveAllVersions(IMSAdminBase *pAdmin) {
    HRESULT         hr = S_OK;
    int             i;
    BOOL            bRes;

    for (i = 0; i < ARRAY_SIZE(g_AspnetDllNames); i++) {
        hr = UnregisterScriptMaps(pAdmin, KEY_LMW3SVC_SLASH, 
                            g_AspnetDllNames[i], NULL, TRUE);
        ON_ERROR_EXIT();
    }

    hr = UnregisterDefaultDocument(pAdmin, DEFAULT_DOC);
    ON_ERROR_EXIT();

    hr = UnregisterMimeMap(pAdmin, MIMEMAP);
    ON_ERROR_EXIT();

    hr = UnregisterInProc(pAdmin, ASPNET_ALL_VERS);
    ON_ERROR_EXIT();

    hr = UnregisterFilter(pAdmin, ASPNET_ALL_VERS);
    ON_ERROR_EXIT();

    hr = CheckIISFeature(SUPPORT_SECURITY_LOCKDOWN, &bRes);
    ON_ERROR_EXIT();

    if (bRes) {
        SECURITY_PROP_MANAGER   mgr(pAdmin); 
        
        hr = mgr.CleanupSecurityLockdown(SECURITY_CLEANUP_ANY_VERSION);
        ON_ERROR_EXIT();
    }

    hr = UnregisterCustomHeader(pAdmin, ASPNET_CUSTOM_HEADER_L, TRUE);
    ON_ERROR_EXIT();
    
Cleanup:

    return hr;
}

/**
 *
 * Register this version of ASP.Net in the IIS metabase.  Please note
 * that we need to enable side-by-side.  That means different versions
 * of ASP.Net can run on the same machine.
 *
 * Important notes:
 * - Aspnet_isapi.dll must be backward compatible in ISAPI Filter because only one
 *   DLL can be registered for the whole machine.  If this assumption is broken
 *   in the future, the new version must be able to handle installing two filters
 *   on the same machine and prioritize them correctly.
 *
 * - Aspnet_isapi.dll must be backward compatible in MimeMap extension.  That means
 *   if we change the content type of one extension in one version, we should not
 *   change its content type again in a later version.
 *
 * - Aspnet_isapi.dll must be backward compatible in Default Document.  That means
 *   all future newer version of Default Document must include those defined in
 *   past versions.
 *
 * - If installing Dll and the Dll at metabase root has the same fullpath, the
 *   installing Dll will simply replace the root Dll.
 *
 * Params:
 *  pchBase             The path to the IIS key from where the installation begins.
 *                      E.g. To install in all websites, pass in "W3SVC"
 *
 *
 */
HRESULT
RegisterIIS(WCHAR *pchBase, DWORD dwFlags) {
    HRESULT         hr;
    IMSAdminBase    *pAdmin = NULL;
    CRegInfo        reginfo;
    WCHAR           *pchAbsPath = NULL;
    BOOL            bRes;
    BOOL            fRecursive  = !!(dwFlags & REGIIS_SM_RECURSIVE);
    BOOL            fInstallSM  = !!(dwFlags & REGIIS_INSTALL_SM);
    BOOL            fInstallOthers = !!(dwFlags & REGIIS_INSTALL_OTHERS);
    BOOL            fSMIgnoreVer = !!(dwFlags & REGIIS_SM_IGNORE_VER);
    BOOL            fFreshInstall = !!(dwFlags & REGIIS_FRESH_INSTALL);
    BOOL            fEnable = !!(dwFlags & REGIIS_ENABLE);

    ASSERT(fInstallSM || fInstallOthers);

    CSetupLogging::Log(1, "RegisterIIS", 0, "Update IIS Metabase to use this ASP.NET isapi");
    
    hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (VOID **) &pAdmin);

    ON_ERROR_EXIT();


    // Get highest version info from registry.  We need that info to determine which
    // "Default Document", Mimemap and Filter to (re)install.
    
    hr = reginfo.InitHighestInfo(NULL);
    if (hr) {
        XspLogEvent(IDS_EVENTLOG_REGISTER_FAILED_GET_HIGHEST,                   
               L"0x%08x", hr);
    }
    ON_ERROR_CONTINUE();    // CRegInfo will use default values if failed.


    if (fInstallSM) {

        // Install asp.net DLL on Scriptmaps
    
        pchAbsPath = GetIISAbsolutePath(pchBase);
        ON_OOM_EXIT(pchAbsPath);

        hr = RegisterScriptMaps(pAdmin, pchAbsPath, Names::IsapiFullPath(), 
                            fRecursive, fSMIgnoreVer);
        ON_ERROR_EXIT();


        // Register asp.net default document if it's a fresh install
        // Please note that we are assuming the default document in this version
        // is the same as that in all previous versions.
        if (fFreshInstall) {
            hr = RegisterDefaultDocument(pAdmin, reginfo.GetHighestVersionDefaultDoc());
            ON_ERROR_EXIT();
        }


        // (Re)install Mimemap using the MM from the highest version
         
        hr = UnregisterMimeMap(pAdmin, reginfo.GetHighestVersionMimemap());
        ON_ERROR_EXIT();
            
        hr = RegisterMimeMap(pAdmin, reginfo.GetHighestVersionMimemap());
        ON_ERROR_EXIT();
    }


    if (fInstallOthers) {        
        // Add new dll and only active to MD_IN_PROCESS_ISAPI_APPS
        
        // Don't register xspispi as inproc under NT4 (ASURT 48035)
        if (GetCurrentPlatform() == APSX_PLATFORM_W2K) {
            int i;
            
            // First delete ALL versions
            hr = UnregisterInProc(pAdmin, ASPNET_ALL_VERS);
            ON_ERROR_EXIT();
            
            hr = RegisterInProc(pAdmin, Names::IsapiFullPath());
            ON_ERROR_EXIT();

            // Register all other active DLLs in InProc
            for (i = 0; i < reginfo.GetActiveDlls()->Size(); i++) {
                hr = RegisterInProc(pAdmin, reginfo.GetActiveDlls()->Item(i));
                ON_ERROR_EXIT();
            }
        }


        // (Re)install ISAPI Filter using the highest version
            
        hr = UnregisterFilter(pAdmin, ASPNET_ALL_VERS);
        ON_ERROR_EXIT();
        
        hr = RegisterFilter(pAdmin, reginfo.GetHighestVersionFilterPath(), reginfo.GetMaxVersion());
        ON_ERROR_EXIT();


        // Add entries to IIS Security lockdown properties
        hr = CheckIISFeature(SUPPORT_SECURITY_LOCKDOWN, &bRes);
        ON_ERROR_EXIT();
        
        if (bRes) {
            // Please note that unlike other steps in this file, we aren't taking
            // the "clean all, and then install all valid entries" approach.
            // One reason is that it's not a very efficient approach, and the
            // bigger reason is that we want to preserve existing settings on
            // the WebSvcExtRestrictionList property.
            //
            // The approach we take is to first remove only the invalid entries,
            // and then add our new entry if it doesn't exist.

            SECURITY_PROP_MANAGER   mgr(pAdmin);
            
            hr = mgr.CleanupSecurityLockdown(SECURITY_CLEANUP_INVALID);
            ON_ERROR_EXIT();
            
            hr = mgr.RegisterSecurityLockdown(fEnable);
            ON_ERROR_EXIT();
        }

        // Install custom header
        hr = UnregisterCustomHeader(pAdmin, ASPNET_CUSTOM_HEADER_L, FALSE);
        ON_ERROR_EXIT();

        hr = RegisterCustomHeader(pAdmin, ASPNET_CUSTOM_HEADER_L);
        ON_ERROR_EXIT();
    }

Cleanup:
    CSetupLogging::Log(hr, "RegisterIIS", 0, "Update IIS Metabase to use this ASP.NET isapi");
    
    if (hr) {
        XspLogEvent(IDS_EVENTLOG_IIS_REGISTER_FAILED, L"%s^0x%08x", PRODUCT_VERSION_L, hr);
    }

    delete [] pchAbsPath;

    if (pAdmin) {
        HRESULT hr2;
        hr2 = pAdmin->SaveData();
        if (hr2) {
            TRACE_ERROR(hr2);
        }
        
        ReleaseInterface(pAdmin);
    }

    CleanupMissingDllMem();

    return hr;
}

/*
 * Uninstall IIS from metabase.  It will also preserve SBS during installation.
 *
 * Procedures:
 *  - Find "next highest" aspnet version in registry
 *  - If not found, do a clean uninstall and exit
 *
 *  - Reinstall next highest version Dll on all SM with the replaced version.
 *  - Remove uninstalled version from InProc
 *  - Reinstall DD from "next highest version"
 *  - Reinstall MM from "next highest version"
 *  - Reinstall isapi filter using "next highest version"
 *
 * Note:
 *  - "Next highest" version means the highest version AFTER the
 *    current Dll is uninstalled.
 * 
 */
HRESULT
UnregisterIIS(BOOL fAllVers) {
    HRESULT         hr = S_OK;
    IMSAdminBase    *pAdmin = NULL;
    CRegInfo        reginfoHighest, reginfoNext;
    ASPNETVER       *pverNewAtRoot = NULL;
    BOOL            bRes;

    CSetupLogging::Log(1, "UnregisterIIS", 0, "Removing IIS Metabase entries");
    
    hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (VOID **) &pAdmin);

    ON_ERROR_EXIT();


    if (fAllVers) {
        // If the caller wants to clean up ALL versions, just do it
        // and exit.
        hr = RemoveAllVersions(pAdmin);
        ON_ERROR_EXIT();
    }
    else {
        // Get the next highest version (by excluding the uninstalled version in the
        // call below)
        
        hr = reginfoNext.InitHighestInfo(&ASPNETVER::ThisVer());
        if (hr) {
            // If an error happened, or if we cannot find a "next highest version", 
            // we'll do a clean uninstall and EXIT.

            if (hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
                XspLogEvent(IDS_EVENTLOG_UNREGISTER_FAILED_NEXT_HIGHEST, L"%s^0x%08x", 
                            PRODUCT_VERSION_L, hr);
            }

            hr = RemoveAllVersions(pAdmin);
            EXIT();
        }

        pverNewAtRoot = reginfoNext.GetMaxVersion();

        // Remove uninstalled version from all matching SM, and replace it with the
        //   next highest version 
        
        hr = UnregisterScriptMaps(pAdmin, KEY_LMW3SVC_SLASH, Names::IsapiFullPath(), 
                                    reginfoNext.GetHighestVersionDllPath(), TRUE);
        ON_ERROR_EXIT();


        // Get highest version info from registry.  We need that info to determine which
        // Mimemap and Filter to uninstall during reinstallation below.
        
        hr = reginfoHighest.InitHighestInfo(NULL);
        ON_ERROR_CONTINUE();    // Use default values if it failed.
        

        // Don't need to do anything to default document, because we are assuming the 
        // default document in this version is the same as that in all previous versions.
        

        // Reinstall Mimemap first by unstalling the "highest version", and then
        // install using the "next highest version".
         
        hr = UnregisterMimeMap(pAdmin, reginfoHighest.GetHighestVersionMimemap());
        ON_ERROR_EXIT();
        
        hr = RegisterMimeMap(pAdmin, reginfoNext.GetHighestVersionMimemap());
        ON_ERROR_EXIT();


        // Just remove current DLL from ISAPI InProc
        if (GetCurrentPlatform() == APSX_PLATFORM_W2K) {
            hr = UnregisterInProc(pAdmin, Names::IsapiFullPath());
            ON_ERROR_EXIT();
        }


        // Reinstall ISAPI Filter using the next highest version
            
        hr = UnregisterFilter(pAdmin, ASPNET_ALL_VERS);
        ON_ERROR_EXIT();
        
        hr = RegisterFilter(pAdmin, reginfoNext.GetHighestVersionFilterPath(), reginfoNext.GetMaxVersion());
        ON_ERROR_EXIT();


        // Remove the entry from IIS Security lockdown properties
        hr = CheckIISFeature(SUPPORT_SECURITY_LOCKDOWN, &bRes);
        ON_ERROR_EXIT();
        
        if (bRes) {
            SECURITY_PROP_MANAGER   mgr(pAdmin);
            
            hr = mgr.CleanupSecurityLockdown(SECURITY_CLEANUP_CURRENT);
            ON_ERROR_EXIT();
        }

        // Unregister custom header
        hr = UnregisterCustomHeader(pAdmin, ASPNET_CUSTOM_HEADER_L, FALSE);
        ON_ERROR_EXIT();
    }

Cleanup:
    CSetupLogging::Log(hr, "UnregisterIIS", 0, "Removing IIS Metabase entries");
    
    if (pAdmin) {
        HRESULT hr2;
        hr2 = pAdmin->SaveData();
        if (hr2) {
            TRACE_ERROR(hr2);
        }
        
        ReleaseInterface(pAdmin);
    }

    if (hr) {
        XspLogEvent(IDS_EVENTLOG_IIS_UNREGISTER_FAILED, L"%s^0x%08x", PRODUCT_VERSION_L, hr);
    }
    else {
        WCHAR   pchMax[MAX_PATH];
        
        if (pverNewAtRoot && pverNewAtRoot->ToString(pchMax, MAX_PATH-1) > 0)
        {
            XspLogEvent(IDS_EVENTLOG_IIS_UNREGISTER_ROOT, L"%s", pchMax);
        }
    }
    
    CleanupMissingDllMem();
    
    return hr;
}


HRESULT
UnregisterObsoleteIIS() {
    HRESULT         hr;
    IMSAdminBase    *pAdmin = NULL;

    CSetupLogging::Log(1, "UnregisterOldISAPI", 0, "Unregistering xspisapi.dll");
    
    hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (VOID **) &pAdmin);

    ON_ERROR_EXIT();


#define OBSOLETE_MODULE_FULL_NAME_L L"XSPISAPI.DLL"

    hr = UnregisterScriptMaps(pAdmin, KEY_LMW3SVC_SLASH, OBSOLETE_MODULE_FULL_NAME_L, NULL, TRUE);
    ON_ERROR_EXIT();

Cleanup:
    CSetupLogging::Log(hr, "UnregisterOldISAPI", 0, "Unregistering xspisapi.dll");
    
    ReleaseInterface(pAdmin);

    return hr;
}


HRESULT
CheckIISState(DWORD *pState) {
    IMSAdminBase    *pAdmin = NULL;
    HRESULT         hr;

    CSetupLogging::Log(1, "CheckIISState", 0, "Check the status of IIS");

    *pState = IIS_STATE_ENABLED;
    
    hr = CoCreateInstance(CLSID_MSAdminBase,
            NULL,
            CLSCTX_ALL,
            IID_IMSAdminBase,
            (VOID **) &pAdmin);
    
    if (hr == HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED)) {
        hr = S_OK;
        *pState = IIS_STATE_DISABLED;
    }
    else if (hr == REGDB_E_CLASSNOTREG) {
        hr = S_OK;
        *pState = IIS_STATE_NOT_INSTALLED;
    }
    ON_ERROR_EXIT();
    
Cleanup:    
    CSetupLogging::Log(hr, "CheckIISState", 0, "Check the status of IIS");

    ReleaseInterface(pAdmin);

    return hr;
}


HRESULT
RemoveAspnetFromKeyIIS(WCHAR *pchBase, BOOL fRecursive) {
    HRESULT         hr = S_OK;
    IMSAdminBase    *pAdmin = NULL;
    WCHAR           *pchAbsPath = NULL;
    int             i;

    hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (VOID **) &pAdmin);

    ON_ERROR_EXIT();

    pchAbsPath = GetIISAbsolutePath(pchBase);
    ON_OOM_EXIT(pchAbsPath);

    for (i = 0; i < ARRAY_SIZE(g_AspnetDllNames); i++) {
        hr = UnregisterScriptMaps(pAdmin, pchAbsPath, 
                            g_AspnetDllNames[i], NULL, fRecursive);
        ON_ERROR_EXIT();
    }

Cleanup:
    delete [] pchAbsPath;
        
    ReleaseInterface(pAdmin);

    return hr;
}


/**
 * Return the root directory of all the websites in IIS
 */
HRESULT
GetAllWebSiteDirs(CStrAry *pcsWebSiteDirs, CStrAry *pcsWebSiteAppRoots) {
    HRESULT         hr = S_OK;
    IMSAdminBase    *pAdmin = NULL;
    METADATA_HANDLE hKey = NULL;
    int             iSubkey, iLen;
    WCHAR           rgchSubkey[METADATA_MAX_NAME_LEN];
    WCHAR           *pchRootKeyPath = NULL;
    WCHAR           *pchRootKeyAppRoot = NULL;
    METADATA_RECORD md;

    memset(&md, 0, sizeof(md));

    hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (VOID **) &pAdmin);

    ON_ERROR_EXIT();

    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            KEY_LMW3SVC,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &hKey);

    ON_ERROR_EXIT();


    // Now we enumerate through all the sites underneath /lm/w3svc
    
    for (iSubkey = 0; ; iSubkey++) {
        
        // First enumerate all /LM/W3SVC/N
        hr = pAdmin->EnumKeys(
                METADATA_MASTER_ROOT_HANDLE,
                KEY_LMW3SVC,
                rgchSubkey,
                iSubkey);

        // Run out of subkey.  End the for loop.
        if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {
            hr = S_OK;
            break;      // End the FOR loop
        }
        ON_ERROR_EXIT();

        // Check to see if it's a website key
        if (IsNumericString(rgchSubkey) != TRUE)
            continue;

        // - Read MD_VR_PATH from W3SVC/n/Root
        // - Add to pcsWebSiteDirs
        
        // Create the root subkey path string

        // Length includes terminating NULL + subkey + length of "/Root"
        iLen = lstrlenW(rgchSubkey) + lstrlenW(SUBKEY_ROOT) + 1;

        WCHAR * pchRealloc = new (pchRootKeyPath, NewReAlloc) WCHAR[iLen];
        ON_OOM_EXIT(pchRealloc);
        pchRootKeyPath = pchRealloc;

        StringCchCopyW(pchRootKeyPath, iLen, rgchSubkey);
        StringCchCatW(pchRootKeyPath, iLen, SUBKEY_ROOT);
        
        hr = GetStringProperty(pAdmin, hKey, pchRootKeyPath, MD_VR_PATH, &md);
        if (hr == HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND)) {
            hr = S_OK;
            continue;
        }

        ON_ERROR_EXIT();

        hr = pcsWebSiteDirs->Append((WCHAR*)md.pbMDData);
        ON_ERROR_EXIT();
        md.pbMDData = NULL;

        // Also get the IIS Path (App Root)
        iLen = lstrlenW(KEY_LMW3SVC) + 1 + lstrlenW(rgchSubkey) + lstrlenW(SUBKEY_ROOT) + 1;

        pchRealloc = new(pchRootKeyAppRoot, NewReAlloc) WCHAR[iLen];
        ON_OOM_EXIT(pchRealloc);
        pchRootKeyAppRoot = pchRealloc;

        StringCchCopyW(pchRootKeyAppRoot, iLen, KEY_LMW3SVC);
        StringCchCatW(pchRootKeyAppRoot, iLen, KEY_SEPARATOR_STR_L);
        StringCchCatW(pchRootKeyAppRoot, iLen, rgchSubkey);
        StringCchCatW(pchRootKeyAppRoot, iLen, SUBKEY_ROOT);
        ASSERT(lstrlenW(pchRootKeyAppRoot) == iLen-1);

        hr = AppendCStrAry(pcsWebSiteAppRoots, pchRootKeyAppRoot);
        ON_ERROR_EXIT();

    }
    
    
Cleanup:
    if (hKey != NULL) {
        pAdmin->CloseKey(hKey);
    }

    delete[] pchRootKeyPath;
    delete[] pchRootKeyAppRoot;
    delete [] md.pbMDData;

    ReleaseInterface(pAdmin);

    return hr;
}


// Used by the config system to identify site-level locking.
// Done by <location path="siteName/childPath" where siteName
// has to match the ServerComment of the site, and cannot
// contain forward-slashes "/".
HRESULT
GetSiteServerComment(WCHAR * path, WCHAR ** pchServerComment) {

    HRESULT         hr;
    IMSAdminBase    *pAdmin = NULL;
    METADATA_HANDLE w3svcHandle = NULL;
    METADATA_RECORD md;

    hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (VOID **) &pAdmin);

    ON_ERROR_EXIT();

    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            KEY_LMW3SVC,
            METADATA_PERMISSION_READ,
            METABASE_REQUEST_TIMEOUT,
            &w3svcHandle);

    ON_ERROR_EXIT();

    hr = GetStringProperty(pAdmin, w3svcHandle, path, MD_SERVER_COMMENT, &md);

    ON_ERROR_EXIT();

    (*pchServerComment) = (WCHAR*)md.pbMDData;

Cleanup:
    if (w3svcHandle != NULL) {
        pAdmin->CloseKey(w3svcHandle);
    }

    ReleaseInterface(pAdmin);

    return hr;
}

HRESULT SetKeyAccessIIS(IMSAdminBase     *pAdmin, WCHAR *wsParent, WCHAR *wsKey, 
                        DWORD dwAccessPerm, DWORD dwDirBrowsing) {
    HRESULT             hr = S_OK;
    IMSAdminBase        *pAdminCreated = NULL;
    METADATA_HANDLE     w3svcHandle = NULL;
    METADATA_RECORD     w3svcRecord;
    DWORD               dwFlags;

    if (pAdmin == NULL) {
        hr = CoCreateInstance(
                CLSID_MSAdminBase,
                NULL,
                CLSCTX_ALL,
                IID_IMSAdminBase,
                (VOID **) &pAdminCreated);

        ON_ERROR_EXIT();

        pAdmin = pAdminCreated;
    }


    // Open the parent directory
    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            wsParent,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &w3svcHandle);

    ON_ERROR_EXIT();


    // Initialize metadata record
    w3svcRecord.dwMDAttributes = METADATA_INHERIT;
    w3svcRecord.dwMDUserType = IIS_MD_UT_FILE;
    w3svcRecord.dwMDDataType = DWORD_METADATA;
    w3svcRecord.dwMDDataLen = sizeof(dwFlags);
    w3svcRecord.pbMDData = (unsigned char*)&dwFlags;


    // First set the access flags
    w3svcRecord.dwMDIdentifier = MD_ACCESS_PERM;
    dwFlags = dwAccessPerm;
    
    hr = pAdmin->SetData( w3svcHandle, wsKey, &w3svcRecord);
    ON_WIN32_ERROR_EXIT(hr);


    // Then set the browse flag
    w3svcRecord.dwMDIdentifier = MD_DIRECTORY_BROWSING;
    dwFlags = dwDirBrowsing;
    
    hr = pAdmin->SetData( w3svcHandle, wsKey, &w3svcRecord);
    ON_WIN32_ERROR_EXIT(hr);

Cleanup:
    if (w3svcHandle) {
        pAdmin->CloseKey(w3svcHandle);
    }

    ReleaseInterface(pAdminCreated);
    return hr;
}


// Called by EcbCallISAPI to set the correct access and browse flags on the
// bin directory of the application
HRESULT SetBinAccessIIS(WCHAR *wsParent) {
    return SetKeyAccessIIS(NULL, wsParent, L"/bin", 0, 0);
}

HRESULT SetClientScriptKeyProperties(WCHAR *wsParent) {
    HRESULT             hr = S_OK;
    IMSAdminBase        *pAdmin = NULL;
    METADATA_RECORD     md;
    METADATA_HANDLE     w3svcHandle = NULL;

    CSetupLogging::Log(1, "SetClientScriptKeyProperties", 0, "Setting client site scripts key properties");
    
    hr = CoCreateInstance(
            CLSID_MSAdminBase,
            NULL,
            CLSCTX_ALL,
            IID_IMSAdminBase,
            (VOID **) &pAdmin);

    ON_ERROR_EXIT();

    // Open the parent directory
    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            wsParent,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &w3svcHandle);

    ON_ERROR_EXIT();

    // Set the key type to "IIsWebDirectory"
    md.dwMDIdentifier = MD_KEY_TYPE;
    md.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    md.dwMDUserType = IIS_MD_UT_SERVER;
    md.dwMDDataType = STRING_METADATA;
    md.pbMDData = (unsigned char*) IIS_CLASS_WEB_DIR_W;
    md.dwMDDataLen = sizeof(IIS_CLASS_WEB_DIR_W);
    md.dwMDDataTag = 0;

    hr = pAdmin->SetData( w3svcHandle, ASPNET_CLIENT_KEY, &md);
    ON_WIN32_ERROR_EXIT(hr);

    pAdmin->CloseKey(w3svcHandle);
    w3svcHandle = NULL;
    
    // Call SetKeyAccessIIS to set the permission flags
    hr = SetKeyAccessIIS(pAdmin, wsParent, ASPNET_CLIENT_KEY, MD_ACCESS_READ, 0);
    ON_ERROR_EXIT();

Cleanup:
    CSetupLogging::Log(hr, "SetClientScriptKeyProperties", 0, "Setting client site scripts key properties");
    
    if (w3svcHandle) {
        pAdmin->CloseKey(w3svcHandle);
    }


    ReleaseInterface(pAdmin);
    return hr;
}

HRESULT
RemoveKeyIIS(WCHAR *pchParent, WCHAR *pchKey) {
    HRESULT             hr = S_OK;
    IMSAdminBase        *pAdmin = NULL;
    METADATA_HANDLE     w3svcHandle = NULL;
    
    hr = CoCreateInstance(
            CLSID_MSAdminBase,
            NULL,
            CLSCTX_ALL,
            IID_IMSAdminBase,
            (VOID **) &pAdmin);

    ON_ERROR_EXIT();

    // Open the parent directory
    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            pchParent,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &w3svcHandle);

    ON_ERROR_EXIT();

    hr = pAdmin->DeleteKey(w3svcHandle, pchKey);
    ON_ERROR_EXIT();
    
Cleanup:
    if (w3svcHandle) {
        pAdmin->CloseKey(w3svcHandle);
    }

    ReleaseInterface(pAdmin);
    return hr;
}


HRESULT
IsIISPathValid(WCHAR *pchPath, BOOL *pfValid) {
    HRESULT             hr = S_OK;
    IMSAdminBase        *pAdmin = NULL;
    METADATA_HANDLE     Handle = NULL;
    WCHAR               *pchAbsPath = NULL;

    *pfValid = FALSE;
    
    hr = CoCreateInstance(
            CLSID_MSAdminBase,
            NULL,
            CLSCTX_ALL,
            IID_IMSAdminBase,
            (VOID **) &pAdmin);

    ON_ERROR_EXIT();

    // Open the parent directory
    pchAbsPath = GetIISAbsolutePath(pchPath);
    ON_OOM_EXIT(pchAbsPath);
    
    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            pchAbsPath,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &Handle);

    if (hr) {
        if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) {
            *pfValid = FALSE;
            hr = S_OK;
        }
        else {
            ON_ERROR_EXIT();
        }
    }
    else {
        *pfValid = TRUE;
    }

Cleanup:
    if (Handle) {
        pAdmin->CloseKey(Handle);
    }

    delete [] pchAbsPath;

    ReleaseInterface(pAdmin);
    return hr;
}


HRESULT
GetIISVerInfoList(ASPNET_VERSION_INFO **ppVerInfo, DWORD *pdwCount) {    
    HRESULT             hr = S_OK;
    CRegInfo            info;
    IMSAdminBase        *pAdmin = NULL;
    ASPNETVER           Ver;
    CASPNET_VER_LIST    VerList;
    int                 i, size;
    ASPNET_VERSION_INFO *pCur, *pVerInfo = NULL;

    *ppVerInfo = NULL;
    *pdwCount = 0;
    
    hr = CoCreateInstance(
            CLSID_MSAdminBase,
            NULL,
            CLSCTX_ALL,
            IID_IMSAdminBase,
            (VOID **) &pAdmin);
    if (hr == S_OK) {
        hr = GetRootVersion(pAdmin, &Ver);
    }
    
    if (hr) {
        // If we cannot get the version at root, just set RootVersion
        // to zeros.
        hr = S_OK;
        Ver.Reset();
    }

    hr = info.GetVerInfoList(&Ver, &VerList);
    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) {
        hr = S_OK;
        EXIT();
    }
    ON_ERROR_EXIT();

    size = VerList.Size();

    if (size == 0) {
        EXIT();
    }
    
    pVerInfo = (ASPNET_VERSION_INFO*) LocalAlloc(LPTR, sizeof(ASPNET_VERSION_INFO) * size);
    ON_OOM_EXIT(pVerInfo);

    for (pCur = pVerInfo, i=0; i < size; i++, pCur++) {
        wcsncpy(pCur->Version, VerList.GetVersion(i), MAX_PATH);
        wcsncpy(pCur->Path, VerList.GetPath(i), MAX_PATH);
        pCur->Status = VerList.GetStatus(i);
    }

    *pdwCount = size;
    *ppVerInfo = pVerInfo;
    pVerInfo = NULL;
    
Cleanup:    
    if (pVerInfo) {
        LocalFree(pVerInfo);
    }
         
    ReleaseInterface(pAdmin);
    return hr;
}


HRESULT
GetIISKeyInfoList(ASPNET_IIS_KEY_INFO **ppKeyInfo, DWORD *pdwCount) {    
    HRESULT             hr = S_OK;
    IMSAdminBase        *pAdmin = NULL;
    METADATA_HANDLE     lmHandle = NULL;
    WCHAR               *pchPaths = NULL, *path;
    ASPNET_IIS_KEY_INFO *pKeyInfo = NULL, *pCur;
    int                 size;
    WCHAR               *pchDllPath = NULL;
    ASPNETVER           Version;

    *ppKeyInfo = NULL;
    *pdwCount = 0;

    hr = CoCreateInstance(
            CLSID_MSAdminBase,
            NULL,
            CLSCTX_ALL,
            IID_IMSAdminBase,
            (VOID **) &pAdmin);

    ON_ERROR_EXIT();

    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            L"/",
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &lmHandle);

    ON_ERROR_EXIT();

    hr = GetDataPaths(pAdmin, lmHandle, L"/", MD_SCRIPT_MAPS, 
                        MULTISZ_METADATA, &pchPaths);
    ON_ERROR_EXIT();

    for (path = pchPaths, size=0; *path != L'\0'; path += lstrlenW(path) + 1, size++) {
        // Count how many entries we have
    }

    // We use LocalAlloc because the memory will be passed outside of this DLL.
    pKeyInfo = (ASPNET_IIS_KEY_INFO*) LocalAlloc(LPTR, size * sizeof(ASPNET_IIS_KEY_INFO));
    ON_OOM_EXIT(pKeyInfo);

    for (path = pchPaths, pCur = pKeyInfo; *path != L'\0'; path += lstrlenW(path) + 1, pCur++) {
        hr = GetDllPathFromScriptMaps(pAdmin, METADATA_MASTER_ROOT_HANDLE, path, 
                                        &pchDllPath);
        if (hr) {
            // If no ASP.NET Dll is found, skip this
            hr = S_OK;
            pCur--;
            size--;
            continue;
        }

        // If it begins with /LM/, truncate /LM/
        if (_wcsnicmp(path, L"/LM/", 4) == 0) {
            wcsncpy(pCur->KeyPath, path+4, MAX_PATH);
        }
        else {
            wcsncpy(pCur->KeyPath, path, MAX_PATH);
        }

        hr = g_smrm.FindDllVer(pchDllPath, &Version);
        if (hr) {
            // If can't read the version, use Zeros
            hr = S_OK;
            Version.Reset();
        }
        
        Version.ToString(pCur->Version, MAX_PATH);

        delete [] pchDllPath;
        pchDllPath = NULL;
    }

    *pdwCount = size;
    if (size > 0) {
        *ppKeyInfo = pKeyInfo;
        pKeyInfo = NULL;
    }

Cleanup:    
    if (lmHandle != NULL) {
        pAdmin->CloseKey(lmHandle);
    }

    if (pKeyInfo) {
        LocalFree(pKeyInfo);
    }

    delete [] pchDllPath;

    delete [] pchPaths;

    ReleaseInterface(pAdmin);
    return hr;
}


HRESULT
GetIISRootVer(ASPNETVER **ppVer) {    
    HRESULT             hr = S_OK;
    IMSAdminBase        *pAdmin = NULL;
    ASPNETVER           *pVer = NULL;

    *ppVer = NULL;
    
    hr = CoCreateInstance(
            CLSID_MSAdminBase,
            NULL,
            CLSCTX_ALL,
            IID_IMSAdminBase,
            (VOID **) &pAdmin);

    ON_ERROR_EXIT();

    pVer = new ASPNETVER;
    ON_OOM_EXIT(pVer);

    hr = GetRootVersion(pAdmin, pVer);
    ON_ERROR_EXIT();

    *ppVer = pVer;
    pVer = NULL;
    
Cleanup:    
    if (pVer) {
        delete pVer;
    }
         
    ReleaseInterface(pAdmin);
    return hr;
}




#if 0
// Written but not used


/**
 *  A helper function to compare two paths.  The function will take care
 *  of the cases where either one or both of the paths are normalized, or
 *  partially normalized.
 *
 *  A normalized path has this format:
 *  /   (for an empty path), or
 *  /subkey1/subkey2/ (for a non-empty path)
 *
 */
int
PathNormalizedCompare(WCHAR *pchPath1, WCHAR *pchPath2) {
    WCHAR   *Start1, *Start2;
    int     len1, len2, len;

    // First, handle the empty path case
    if (wcscmp(L"/", pchPath1) == 0 || wcscmp(L"/", pchPath2) == 0 ) {
        return _wcsicmp(pchPath1, pchPath2);
    }
    

    len = len1 = lstrlenW(pchPath1);
    Start1 = pchPath1;

    if (pchPath1[0] == '/') {
        Start1 = &pchPath1[1];
        len1--;
    }

    if (pchPath1[len-1] == '/') {
        len1--;
    }
    
    len = len2 = lstrlenW(pchPath2);
    Start2 = pchPath2;

    if (pchPath2[0] == '/') {
        Start2 = &pchPath2[1];
        len2--;
    }

    if (pchPath2[len-1] == '/') {
        len2--;
    }

    if (len1 != len2) {
        return len1 - len2;
    }
    
    return _wcsnicmp(Start1, Start2, len1);
}

CStrAry csAppPoolIDs;

CStrAry csAppPoolNames;


/**
 *  Return the inherited Application Pool ID property at pchKey.
 *
 *  Params:
 *  pAdmin          IMSAdminBase
 *  pchKey          Normalized key path
 *  ppchInheritedSM Returned inherited scripmap.
 */
HRESULT
GetInheritedAppPoolID(IMSAdminBase *pAdmin, WCHAR *pchKey, WCHAR **ppchAppPoolID) {
    HRESULT     hr = S_OK;
    WCHAR       *pchDupPath = NULL;

    *ppchAppPoolID = NULL;

    pchDupPath = DupStr(pchKey);
    ON_OOM_EXIT(pchDupPath);

    hr = GetInheriedStringMSRecursive(pAdmin, pchDupPath, MD_APP_APPPOOL_ID, ppchAppPoolID, false);
    ON_ERROR_EXIT();

Cleanup:
    if (pchDupPath)
        delete [] pchDupPath;
    
    return hr;
}

/**
 *  This function will get the inherited application pool name of the supplied
 *  key.
 */
HRESULT
GetAppPoolName(IMSAdminBase *pAdmin, WCHAR *pchKey, WCHAR **ppchAppName) {
    HRESULT         hr;
    WCHAR           *pchAppPoolID = NULL;
    WCHAR           *pchAppNameDup = NULL;
    WCHAR           *pchPath = NULL;
    METADATA_RECORD md;
    int             i, len;
    
    hr = GetInheritedAppPoolID(pAdmin, pchKey, &pchAppPoolID);
    ON_ERROR_EXIT();

    // First find the name from the cache
    for (i=0; i < csAppPoolIDs.Size(); i++) {
        if (_wcsicmp(csAppPoolIDs[i], pchAppPoolID) == 0) {
            ASSERT(csAppPoolNames[i] != NULL);
            *ppchAppName = DupStr(csAppPoolNames[i]);
            ON_OOM_EXIT(*ppchAppName);

            EXIT();
        }
    }

    // We couldn't find it in the cache.  Get the App name from metabase.
    len = lstrlenW(pchAppPoolID) + KEY_APP_POOL_LEN + 1;

    pchPath = new WCHAR[len];
    ON_OOM_EXIT(pchPath);

    StringCchCopyW(pchPath, len, KEY_APP_POOL);
    StringCchCatW(pchPath, len, pchAppPoolID);

    hr = GetStringProperty(pAdmin, METADATA_MASTER_ROOT_HANDLE, pchPath, 
                                MD_APPPOOL_FRIENDLY_NAME, &md);
    ON_ERROR_EXIT();
    
    *ppchAppName = (WCHAR*) md.pbMDData;


    // Save it to the cache
    hr = csAppPoolIDs.Append(pchAppPoolID);
    ON_ERROR_EXIT();
    pchAppPoolID = NULL;

    pchAppNameDup = DupStr(*ppchAppName);
    if (pchAppNameDup == NULL) {
        // Need to rollback
        delete [] csAppPoolIDs[csAppPoolIDs.Size()-1];
        csAppPoolIDs.Delete(csAppPoolIDs.Size()-1);
        
        ON_OOM_EXIT(pchAppNameDup);
    }
    
    hr = csAppPoolNames.Append(pchAppNameDup);
    if (hr) {
        // Need to rollback
        delete [] csAppPoolIDs[csAppPoolIDs.Size()-1];
        csAppPoolIDs.Delete(csAppPoolIDs.Size()-1);
        
        ON_ERROR_EXIT();
    }
    pchAppNameDup = NULL;

Cleanup:
    delete [] pchAppPoolID;
    delete [] pchPath;
    delete [] pchAppNameDup;
    return hr;
}

HRESULT
GetAppPoolIDFromName(WCHAR *pchAppName, WCHAR **ppchAppID) {
    HRESULT         hr;
    int             iSubkey;
    WCHAR           rgchSubkey[METADATA_MAX_NAME_LEN];
    WCHAR *         pchRootKeyPath = NULL;
    IMSAdminBase    *pAdmin = NULL;

    *ppchAppID = NULL;
  
    hr = CoCreateInstance(
            CLSID_MSAdminBase,
            NULL,
            CLSCTX_ALL,
            IID_IMSAdminBase,
            (VOID **) &pAdmin);

    ON_ERROR_EXIT();

    for (iSubkey = 0; ; iSubkey++) {
        int             iLen;
        METADATA_RECORD md;
        BOOL            fMatch;
      
        // Enumerate the subkeys of W3SVC/AppPools
        hr = pAdmin->EnumKeys(
                METADATA_MASTER_ROOT_HANDLE,
                KEY_APP_POOL,
                rgchSubkey,
                iSubkey);

        // Run out of subkey.  End the for loop.
        if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {
            // We still couldn't find it.  Return an error.
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        }
        
        ON_ERROR_EXIT();

        // Read the name from the subkey
        iLen = lstrlenW(rgchSubkey) + lstrlenW(KEY_APP_POOL) + 1;

        WCHAR * pchRealloc = new(pchRootKeyPath, NewReAlloc) WCHAR[iLen];
        ON_OOM_EXIT(pchRealloc);
        pchRootKeyPath = pchRealloc;

        StringCchCopyW(pchRootKeyPath, iLen, KEY_APP_POOL);
        StringCchCatW(pchRootKeyPath, iLen, rgchSubkey);
        
        hr = GetStringProperty(pAdmin, METADATA_MASTER_ROOT_HANDLE, 
                                pchRootKeyPath, MD_APPPOOL_FRIENDLY_NAME, &md);
        if (hr == HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND)) {
            hr = S_OK;
            continue;
        }

        // Do we have a match?
        fMatch = (wcscmp((WCHAR*)md.pbMDData, pchAppName) == 0);
        delete [] md.pbMDData;
        md.pbMDData = NULL;

        if (!fMatch) {
            // No match.  Find the next one
            continue;
        }

        // Okay, we have a match.  Dup the string and exit
        *ppchAppID = DupStr((WCHAR*)rgchSubkey);
        ON_OOM_EXIT(*ppchAppID);

        break;
    }
    
Cleanup:
    delete [] pchRootKeyPath;

    ReleaseInterface(pAdmin);
    
    return hr;
}



/**
 * This function will:
 *      - Write the application pool ID at pchKeyPath; create it if not found
 *      - Write Application Pool ID on all key that has that property (if fRecursive is TRUE)
 *
 * Params:
 *  pAdmin      - IMSAdminBase object
 *  pchKeyPath  - The Key to start with.  Must be an absolute path.  (e.g. /lm/w3svc/n/root/)
 *  pchAppPoolID- The application pool id to set at pchKeyPath
 *  fRecursive  - Register recursively down the tree
 */
HRESULT
RegisterAppPoolID(IMSAdminBase* pAdmin, WCHAR *pchKeyPath, WCHAR *pchAppPoolID, BOOL fRecursive) {
    HRESULT         hr = S_OK;
    METADATA_HANDLE lmHandle = NULL;
    WCHAR           *pchPaths = NULL, *path;
    WCHAR           *pchDummy = L"\0";
    METADATA_RECORD md;

    hr = pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            L"/",
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &lmHandle);

    ON_ERROR_EXIT();

    // Preset some values on md
    md.dwMDIdentifier = MD_APP_APPPOOL_ID;
    md.dwMDAttributes = METADATA_INHERIT;
    md.dwMDUserType = IIS_MD_UT_SERVER;
    md.dwMDDataType = STRING_METADATA;
    md.dwMDDataTag = 0;
            
    if (fRecursive) {
        hr = GetDataPaths(pAdmin, lmHandle, pchKeyPath, MD_APP_APPPOOL_ID, 
                            STRING_METADATA, &pchPaths);
        ON_ERROR_EXIT();

        // If we cannot find the AppPoolId at the base key, create a dummy one
        if (_wcsicmp(pchKeyPath, pchPaths)) {
            // Create a dummy app pool id so that GetDataPaths will include the root
            md.pbMDData = (unsigned char*) pchDummy;
            md.dwMDDataLen = (wcslenms(pchDummy)+1)*sizeof(WCHAR);

            hr = pAdmin->SetData(lmHandle, pchKeyPath, &md);
            ON_ERROR_EXIT();

            // Call GetDataPaths again so that we can include the root
            delete [] pchPaths;
            pchPaths = NULL;

            hr = GetDataPaths(pAdmin, lmHandle, pchKeyPath, MD_APP_APPPOOL_ID, 
                                STRING_METADATA, &pchPaths);
            ON_ERROR_EXIT();
        }
    }
    else {
        // Create the pchPaths.  Needs two nulls for a multi-string.
        pchPaths = new (NewClear) WCHAR[lstrlenW(pchKeyPath) + 2]; 
        ON_OOM_EXIT(pchPaths);

        StringCchCopyW(pchPaths, lstrlenW(pchKeyPath) + 2, pchKeyPath);
    }


    // Go thru all the keys and register the supplied one
    
    md.pbMDData = (unsigned char*) pchAppPoolID;
    md.dwMDDataLen = (wcslenms(pchAppPoolID)+1)*sizeof(WCHAR);

    for (path = pchPaths; *path != L'\0'; path += lstrlenW(path) + 1) {
        hr = pAdmin->SetData(lmHandle, path, &md);
        ON_ERROR_EXIT();
    }

Cleanup:
    if (lmHandle != NULL) {
        pAdmin->CloseKey(lmHandle);
    }

    if (pchPaths) {
        delete [] pchPaths;
    }

    return hr;
}


/**
 * Check if the supplied subkey is one of those top keys.
 * Top keys include:
 *  - /LM/W3SVC/
 *  - /LM/W3SVC/N/
 *  - /LM/W3SVC/N/Root/
 * (where N is an integer)
 *
 * Parameters:
 *  pchKey  - The key to check
 */
BOOL
IsTopKey(WCHAR *pchKey) {
    BOOL    fRet = FALSE;
    int     i = KEY_LMW3SVC_SLASH_LEN;  

    if (_wcsnicmp(KEY_LMW3SVC_SLASH, pchKey, KEY_LMW3SVC_SLASH_LEN) != 0) {
        ASSERT(FALSE);
        return FALSE;
    }

    if (pchKey[i] == '\0') {
        fRet = TRUE;    // Case: /LM/W3SVC/
    }
    else {
        ASSERT(pchKey[i] != '/');
        
        while (iswdigit(pchKey[i]))
            i++;

        if (pchKey[i] == '/') {
            i++;

            if (pchKey[i] == '\0') {
                fRet = TRUE;    // Case: /LM/W3SVC/N/
            }
            else if (_wcsicmp(&pchKey[i], L"root/") == 0) {
                fRet = TRUE;    // case: /LM/W3SVC/N/Root/
            }
        }
    }

    return fRet;
}


/**
 *  For each IIsWebVirtualDir and IIsWebDirectory immediately under /LM/W3SVC/N/ROOT,
 *  if there is no SM, compute & register an inherited SM.
 */
HRESULT
PropagateScriptMaps(IMSAdminBase* pAdmin) {
    HRESULT         hr = S_OK;
    int             iSubkey, iRootSubkey;
    WCHAR           rgchSubkey[METADATA_MAX_NAME_LEN];
    WCHAR           rgchRootSubkey[METADATA_MAX_NAME_LEN];
    int             iLen = 0;
    METADATA_HANDLE w3svcHandle = NULL;
    WCHAR           *pchSMw3svc = NULL;         // Scriptmaps at /lm/w3svc
    WCHAR           *pchSMEffective = NULL;
    WCHAR           *pchRootKeyPath = NULL;     // Path string for /lm/w3svc/n/root
    WCHAR           *pchSiteKeyPath = NULL;     // Path string for /lm/w3svc/n
    WCHAR           *pchSubkeyPath = NULL;      // Path string for keys under /lm/w3vc/n/root
    METADATA_RECORD md;

    // Get the scriptmaps at /lm/w3svc first.  We need it later to calculate
    // an inherited scriptmap.
    if (pchSMw3svc == NULL) {
        hr = GetMultiStringProperty(pAdmin, METADATA_MASTER_ROOT_HANDLE, 
                                KEY_LMW3SVC, MD_SCRIPT_MAPS, &md);
        if (hr == HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND)) {
            // It's legal not to have a scriptmap at /lm/w3svc
            hr = S_OK;
        }
        else {
            ON_ERROR_EXIT();
            pchSMw3svc = (WCHAR*) md.pbMDData;
        }
    }

    // Now we enumerate through all the sites underneath /lm/w3svc
    
    for (iSubkey = 0; ; iSubkey++) {
        
        pchSMEffective = NULL;
        
        // First enumerate all /LM/W3SVC/N
        hr = pAdmin->EnumKeys(
                METADATA_MASTER_ROOT_HANDLE,
                KEY_LMW3SVC,
                rgchSubkey,
                iSubkey);

        // Run out of subkey.  End the for loop.
        if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {
            hr = S_OK;
            break;      // End the FOR loop
        }
        ON_ERROR_EXIT();

        // Check to see if it's a website key
        if (IsNumericString(rgchSubkey) != TRUE)
            continue;

        // Create the root subkey path string

        // Length includes terminating NULL + the '/' char + length of "/Root"
        iLen = lstrlenW(KEY_LMW3SVC) + lstrlenW(rgchSubkey) + lstrlenW(SUBKEY_ROOT) + 2;

        WCHAR * pchRealloc = new (pchSiteKeyPath, NewReAlloc) WCHAR[iLen];
        ON_OOM_EXIT(pchRealloc);
        pchSiteKeyPath = pchRealloc;

        pchRealloc = (WCHAR*) new(pchRootKeyPath, NewReAlloc) WCHAR[iLen];
        ON_OOM_EXIT(pchRealloc);
        pchRootKeyPath = pchRealloc;

        StringCchCopy(pchSiteKeyPath, iLen, KEY_LMW3SVC);
        StringCchCat(pchSiteKeyPath, iLen, L"/");
        StringCchCat(pchSiteKeyPath, iLen, rgchSubkey);

        StringCchCopy(pchRootKeyPath, iLen, pchSiteKeyPath);
        StringCchCat(pchRootKeyPath, iLen, SUBKEY_ROOT);


        // Let's determine the inherited scriptmaps for all the immediate keys
        // of /lm/w3svc/n/root

        // See if we have any overriding scriptmap at /lm/w3svc/n/root or /lm/w3svc/n

        // First get the scriptmaps at /lm/w3svc/n/root
        hr = GetMultiStringProperty(pAdmin, METADATA_MASTER_ROOT_HANDLE, 
                                pchRootKeyPath, MD_SCRIPT_MAPS, &md);
        
        if (hr == HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND)) {

            // If not found, next step is to check /lm/w3svc/n
            hr = GetMultiStringProperty(pAdmin, METADATA_MASTER_ROOT_HANDLE, 
                                    pchSiteKeyPath, MD_SCRIPT_MAPS, &md);
                                    
            if (hr == HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND)) {
                // Still not found.  Use the one at /lm/w3svc
                pchSMEffective = pchSMw3svc;
            }
            else {
                ON_ERROR_EXIT();

                // We have a scripmaps at /lm/w3svc/n.
                pchSMEffective = (WCHAR*) md.pbMDData;
            }
        }
        else {
            ON_ERROR_EXIT();

            // We have a scripmaps at /lm/w3svc/n.
            pchSMEffective = (WCHAR*) md.pbMDData;
        }

        // Need to check pchSMEffictive for NULL because there will still be a wierd but 
        // legal case where there isn't any inherited scriptmaps at all.
        if (pchSMEffective) {

            // Init md
            memset(&md, 0, sizeof(md));
            md.dwMDIdentifier = MD_SCRIPT_MAPS;
            md.dwMDAttributes = METADATA_INHERIT;
            md.dwMDUserType = IIS_MD_UT_FILE;
            md.dwMDDataType = MULTISZ_METADATA;
            md.pbMDData = (unsigned char*) pchSMEffective;
            md.dwMDDataLen = (wcslenms(pchSMEffective) + 1) * sizeof(WCHAR);
            md.dwMDDataTag = 0;
            
            // Now try to enumerate all the immediate subkeys underneath /lm/w3svc/n/root/
            for (iRootSubkey = 0;; iRootSubkey++) {
                BOOL    fRet;
                WCHAR   *rgpchTypes[] = { IIS_CLASS_WEB_DIR_W, IIS_CLASS_WEB_VDIR_W };
                
                hr = pAdmin->EnumKeys(
                        METADATA_MASTER_ROOT_HANDLE,
                        pchRootKeyPath,
                        rgchRootSubkey,
                        iRootSubkey);

                // Run out of subkey.  End the for loop.
                if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {
                    hr = S_OK;
                    break;      // End the FOR loop
                }
                ON_ERROR_EXIT();
                
                // Create the subkey's path
                
                // Length includes terminating NULL + the '/' char
                iLen = lstrlenW(pchRootKeyPath) + lstrlenW(rgchRootSubkey) + 2;

                pchRealloc = new(pchSubkeyPath, NewReAlloc) WCHAR[iLen];
                ON_OOM_EXIT(pchRealloc);
                pchSubkeyPath = pchRealloc;

                StringCchCopy(pchSubkeyPath, iLen, pchRootKeyPath);
                StringCchCat(pchSubkeyPath, iLen, L"/");
                StringCchCat(pchSubkeyPath, iLen, rgchRootSubkey);


                // We are only interested in IIsWebVirtualDir or IIsWebDirectory
                hr = CheckObjectClass(pAdmin, METADATA_MASTER_ROOT_HANDLE, pchSubkeyPath,
                                        rgpchTypes, ARRAY_SIZE(rgpchTypes), &fRet);
                ON_ERROR_EXIT();

                if (fRet) {
                    // If there is no scritmap on the key, add the inherited scritmap on it.
                    hr = CreateMDProperty(pAdmin, METADATA_MASTER_ROOT_HANDLE, 
                                            pchSubkeyPath, &md, FALSE);
                    ON_ERROR_EXIT();
                }
            }

            if (pchSMEffective != pchSMw3svc) {
                delete [] pchSMEffective;
                pchSMEffective = NULL;
            }

        }
    }
    
Cleanup:
    if (w3svcHandle != NULL) {
        pAdmin->CloseKey(w3svcHandle);
    }
    
    if (pchSMEffective != pchSMw3svc) {
        delete [] pchSMEffective;
    }

    delete [] pchSMw3svc;
    delete [] pchRootKeyPath;
    delete [] pchSiteKeyPath;
    delete [] pchSubkeyPath;
    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\regaccount.cxx ===
/**
 * Registration code: Create and manage the ASSPNET_VERSION account 
 * 
 * Copyright (c) 2001 Microsoft Corporation
 */

#include "precomp.h"
#include "nisapi.h"
#include "util.h"
#include "platform_apis.h"
#include "process.h"
#include "_ndll.h"
#include "event.h"
#include "wincrypt.h"
#include "Security.h"
#include "Aclapi.h"
#include "LMERR.H"
#include "lmaccess.h"
#include "lmapibuf.h"
#include "RegAccount.h"
#include <iadmw.h>
#include <iiscnfg.h>
#include "Lm.h"
#include "Dsgetdc.h"
#include "register.h"
#include "regiisutil.h"
#include "Wtsapi32.h"

#define KEY_LMW3SVC         L"/LM/w3svc"
#define METABASE_REQUEST_TIMEOUT 1000

WCHAR  g_szMachineAccountName[100] = L"";
WCHAR  g_szLsaKey[100] = L"";
extern BOOL   g_fInvalidCredentials;
PSID   g_pSidWorld = NULL;
LONG   g_lCreatingWorldSid = 0;
BOOL   g_fIsDCDecided = FALSE;
BOOL   g_fIsDC = FALSE;

HRESULT
CreateGoodPassword(
        LPWSTR  szPwd, 
        DWORD   dwLen);

HRESULT
ResetMachineKeys();


#pragma optimize("", off)
void
XspSecureZeroMemory(
        PVOID  ptr,
        SIZE_T  cnt)
{
    volatile char *vptr = (volatile char *)ptr;    
    while (cnt) {
        *vptr = 0;
        vptr++;
        cnt--;
    }
}
#pragma optimize("", on)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
void
CreateWorldSid()
{
    if (g_pSidWorld != NULL || g_lCreatingWorldSid < 0)
        return;
    HRESULT hr = S_OK;
    if (InterlockedIncrement(&g_lCreatingWorldSid) == 1)
    {
        SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_WORLD_SID_AUTHORITY;
        PSID                     pSid    = NULL;
        
        if (!AllocateAndInitializeSid(&SIDAuth, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pSid))
        {
            g_lCreatingWorldSid = -100;
            EXIT_WITH_LAST_ERROR();            
        }
        g_pSidWorld = pSid;
    }
    else
    {
        for(int iter=0; iter<1000 && g_pSidWorld == NULL && g_lCreatingWorldSid > 1; iter++)
            Sleep(100);
    }

 Cleanup:
    return;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
void
CRegAccount::GetAccountNameFromResourceFile(
        LPWSTR szFullName, 
        DWORD  dwFullName,
        LPWSTR szDescription, 
        DWORD  dwDescription)
{
    ZeroMemory(szDescription, dwDescription * sizeof(WCHAR));
    ZeroMemory(szFullName, dwFullName * sizeof(WCHAR));

    if (!FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, 
                       g_rcDllInstance, IDS_ASPNET_ACCOUNT_FULLNAME, 0, 
                       szFullName, dwFullName - 1, NULL) )
    {      
        StringCchCopy(szFullName, dwFullName, L"ASPNET Machine Account");
    } 
    else 
    {
        int iLen = lstrlenW(szFullName);
        if (szFullName[iLen-2] == L'\r' || szFullName[iLen-2] == L'\n')
            szFullName[iLen-2] = NULL;
        else if (szFullName[iLen-1] == L'\r' || szFullName[iLen-1] == L'\n')
            szFullName[iLen-1] = NULL;
    }

    if (!FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, 
                       g_rcDllInstance, IDS_ASPNET_ACCOUNT_DESCRIPTION, 0, 
                       szDescription, dwDescription - 1, NULL))
    {
        StringCchCopy(szDescription, dwDescription, L"Account used for running the ASPNET worker process (aspnet_wp.exe)");
    } 
    else 
    {
        int iLen = lstrlenW(szDescription);
        if (szDescription[iLen-2] == L'\r' || szDescription[iLen-2] == L'\n')
            szDescription[iLen-2] = NULL;
        else if (szDescription[iLen-1] == L'\r' || szDescription[iLen-1] == L'\n')
            szDescription[iLen-1] = NULL;
    }
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::DoReg()
{
    WCHAR     szPass[100];
    HRESULT   hr     = S_OK;
    PSID      pSid   = NULL;
    BOOL      fWellKnown = FALSE;
    PSID      pSidIIS6[3]   = {NULL, NULL, NULL};
    BOOL      fWellKnownIIS6[3] = {FALSE, FALSE, FALSE};
    int       iter = 0; 
    WCHAR     szDescription[256], szFullName[256];
    WCHAR     szDCPass[256], szDCAcc[256];
    BOOL      fIsDC = FALSE, fNetworkService = FALSE;
    LPCWSTR   szIIS6Accounts[3] = { L"IIS_WPG", L"NT AUTHORITY\\NetworkService", L"NT AUTHORITY\\LocalService"};
    
    InitStrings();

    CSetupLogging::Log(1, "IsDomainController", 0, "Determining if we are running on a domain controller");
    hr = IsDomainController(&fIsDC);
    CSetupLogging::Log(hr, "IsDomainController", 0, "Determining if we are running on a domain controller");
    if (hr != S_OK)
    {
        ON_ERROR_CONTINUE();
        fIsDC = FALSE;
        hr = S_OK;
    }

    if (!fIsDC)
    {
        GetAccountNameFromResourceFile(szFullName, sizeof(szFullName) / sizeof(WCHAR), szDescription, sizeof(szDescription) / sizeof(WCHAR));

        // Create the ASPNET account 
        do 
        {
            CSetupLogging::Log(1, "CreateGoodPassword", 0, "Generating password");
            hr = CreateGoodPassword(szPass, 15);
            CSetupLogging::Log(hr, "CreateGoodPassword", 0, "Generating password");
            ON_ERROR_EXIT();    
            CSetupLogging::Log(1, "CreateUser", 0, "Creating ASPNET account");
            hr = CreateUser(g_szMachineAccountName, szPass, szDescription, szFullName, &pSid, &fWellKnown);
            CSetupLogging::Log(hr, "CreateUser", 0, "Creating ASPNET account");
        } 
        while (++iter < 100 && hr == 0x800708C5);
        ON_ERROR_EXIT();

        CSetupLogging::Log(1, "StoreAccountPasswordInLSA", 0, "Storing ASPNET account password in LSA");
        hr = StoreAccountPasswordInLSA(szPass);
        CSetupLogging::Log(hr, "StoreAccountPasswordInLSA", 0, "Storing ASPNET account password in LSA");
        ON_ERROR_EXIT();
    } 
    else 
    {        
        CSetupLogging::Log(1, "GetAccCredentialsOnDC", 0, "Getting ASPNET Account credentials on DC");
        hr = GetMachineAccountCredentialsOnDC(szDCAcc, ARRAY_SIZE(szDCAcc),
                                              szDCPass, ARRAY_SIZE(szDCPass), &fNetworkService);
        CSetupLogging::Log(hr, "GetAccCredentialsOnDC", 0, "Getting ASPNET Account credentials on DC");
        ON_ERROR_EXIT();
        if (!fNetworkService)
        {
            CSetupLogging::Log(1, "GetPrincipalSID", 0, "Getting Machine Account SID on DC");
            hr = GetPrincipalSID(szDCAcc, &pSid, &fWellKnown);
            CSetupLogging::Log(hr, "GetPrincipalSID", 0, "Getting Machine Account SID on DC");
            ON_ERROR_EXIT();
        }
    }

    for(iter=0; iter<3; iter++)
    {
        CSetupLogging::Log(1, "GetPrincipalSID", 0, "Getting IIS6 specific SID");
        hr = GetPrincipalSID(szIIS6Accounts[iter], &pSidIIS6[iter], &fWellKnownIIS6[iter]);
        CSetupLogging::Log(hr, "GetPrincipalSID", 0, "Getting IIS6 specific SID");
        ON_ERROR_CONTINUE();
    }

    if (pSid != NULL)
    {
        CSetupLogging::Log(1, "ACLAllDirs", 0, "Setting ACLs for the ASPNET account");
        hr = ACLAllDirs(pSid, TRUE, TRUE);
        CSetupLogging::Log(hr, "ACLAllDirs", 0, "Setting ACLs for the ASPNET account");
        ON_ERROR_CONTINUE();
    }

    for(iter=0; iter<3; iter++)
    {
        if (pSidIIS6[iter] != NULL)
        {
            CSetupLogging::Log(1, "ACLAllDirs", 0, "Setting ACLs for a IIS6 account");
            hr = ACLAllDirs(pSidIIS6[iter], TRUE, TRUE);
            CSetupLogging::Log(hr, "ACLAllDirs", 0, "Setting ACLs for a IIS6 account");
            ON_ERROR_CONTINUE();

            if (iter == 1 && hr == S_OK) // NetworkService account
            {
                hr = ACLWinntTempDir(pSidIIS6[iter], TRUE);
                ON_ERROR_CONTINUE();
            }
        }
    }

    CSetupLogging::Log(1, "AddAccountToRegistry", 0, "Adding account name to registry");
    hr = AddAccountToRegistry(fIsDC ? szDCAcc : g_szMachineAccountName);
    CSetupLogging::Log(hr, "AddAccountToRegistry", 0, "Adding account name to registry");
    ON_ERROR_CONTINUE();

    hr = ResetMachineKeys();
    ON_ERROR_CONTINUE();    

    if (pSid != NULL)
    {
        hr = AddAccessToPassportRegKey(pSid);
        ON_ERROR_CONTINUE();    
    }


 Cleanup:
    if (fWellKnown && pSid != NULL)
        FreeSid(pSid);
    else
        DELETE_BYTES(pSid);    

    for(iter=0; iter<3; iter++)
    {
        if (fWellKnownIIS6[iter] && pSidIIS6[iter] != NULL)
            FreeSid(pSidIIS6[iter]);
        else
            DELETE_BYTES(pSidIIS6[iter]);    
    }
    XspSecureZeroMemory(szPass, sizeof(szPass));
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::DoRegForOldVersion()
{
    LPCWSTR   szIIS6Accounts[3] = { L"IIS_WPG", L"NT AUTHORITY\\NetworkService", L"NT AUTHORITY\\LocalService"};
    HRESULT   hr            = S_OK;
    BOOL      fIsDC         = FALSE;
    BOOL      fWellKnown    = FALSE;
    PSID      pSid          = NULL;

    //////////////////////////////////////////////////////////////////////
    // Step 1: Get the SID for the machine account
    InitStrings();
    hr = IsDomainController(&fIsDC);
    ON_ERROR_CONTINUE();

    if (fIsDC)
    {
        hr = DoReg();
        ON_ERROR_EXIT();
        EXIT();
    }

    hr = GetPrincipalSID(L"ASPNET", &pSid, &fWellKnown);
    ON_ERROR_CONTINUE();

    if (pSid == NULL)
    {
        hr = DoReg();
        ON_ERROR_EXIT();
        EXIT();
    }

    //////////////////////////////////////////////////////////////////////
    // Step 2: Set ACLs for ASPNET account
    CSetupLogging::Log(1, "ACLAllDirs", 0, "Setting ACLs for a IIS6 account");
    hr = ACLAllDirs(pSid, TRUE, TRUE);
    CSetupLogging::Log(hr, "ACLAllDirs", 0, "Setting ACLs for a IIS6 account");
    ON_ERROR_CONTINUE();
    
    if (fWellKnown)
        FreeSid(pSid);
    else
        DELETE_BYTES(pSid);
    pSid = NULL;

    //////////////////////////////////////////////////////////////////////
    // Step 3: For each IIS account, set ACLs
    for(int iter=0; iter<ARRAY_SIZE(szIIS6Accounts); iter++)
    {
        CSetupLogging::Log(1, "GetPrincipalSID", 0, "Getting IIS6 specific SID");
        hr = GetPrincipalSID(szIIS6Accounts[iter], &pSid, &fWellKnown);
        CSetupLogging::Log(hr, "GetPrincipalSID", 0, "Getting IIS6 specific SID");
        ON_ERROR_CONTINUE();

        if (pSid == NULL)
            continue;
        CSetupLogging::Log(1, "ACLAllDirs", 0, "Setting ACLs for a IIS6 account");
        hr = ACLAllDirs(pSid, TRUE, TRUE);
        CSetupLogging::Log(hr, "ACLAllDirs", 0, "Setting ACLs for a IIS6 account");
        ON_ERROR_CONTINUE();
        
        if (iter == 1 && hr == S_OK) // NetworkService account: ACL winnt temp dir
        {
            hr = ACLWinntTempDir(pSid, TRUE);
            ON_ERROR_CONTINUE();
        }            
        if (fWellKnown)
            FreeSid(pSid);
        else
            DELETE_BYTES(pSid);
        pSid = NULL;
    }

 Cleanup:    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::UndoReg(
        BOOL fRemoveAll, 
        BOOL fEmpty)
{
    InitStrings();
    HRESULT hr = RemoveReg(g_szMachineAccountName, fEmpty);

    if (fRemoveAll) 
    {
        HKEY hKeyXSP = NULL;

        if (OpenRegistryKey(KEY_ALL_ACCESS, &hKeyXSP) == S_OK)
        {
            DWORD     dwNumAccounts = 0;
            if (RegQueryInfoKey(hKeyXSP, NULL, NULL, NULL, NULL, NULL, NULL, 
                                &dwNumAccounts, NULL, NULL, NULL, NULL) == ERROR_SUCCESS && dwNumAccounts > 0)
            {
                for(int iter = ((int)dwNumAccounts)-1; iter >= 0; iter--)
                {
                    WCHAR  szValue[256];
                    DWORD  dwValSize = 256;
                    ZeroMemory(szValue, sizeof(szValue));
                    if (RegEnumValue(hKeyXSP, iter, szValue, &dwValSize, 
                                     NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
                    {
                        if (szValue[0] != NULL)
                            RemoveReg(szValue, TRUE);
                    }
                }
            }            
            RegCloseKey(hKeyXSP);
        }        
        
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::ACLWinntTempDir(
        PSID    pSid,
        BOOL    fReg)
{
    WCHAR     szTempDir[_MAX_PATH + 10];
    HRESULT   hr     = S_OK;
    DWORD     dwRet;

    dwRet = GetSystemWindowsDirectory(szTempDir, _MAX_PATH+1);
    if (dwRet == 0 || dwRet > _MAX_PATH)
        EXIT_WITH_LAST_ERROR();

    dwRet = lstrlenW(szTempDir);
    if (szTempDir[dwRet-1] != L'\\')
    {
        szTempDir[dwRet++] = L'\\';
        szTempDir[dwRet]   = NULL;
    }
    wcsncpy(&szTempDir[dwRet], L"Temp", _MAX_PATH + 8 - dwRet);
    szTempDir[_MAX_PATH+8] = NULL;

    hr = SetACLOnDir(pSid, szTempDir, 0x00110001, fReg);
    ON_ERROR_EXIT();

 Cleanup:
    return hr;

}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::ACLAllDirs(
        PSID    pSid,
        BOOL    fReg, 
        BOOL    fEmpty)
{
    WCHAR     szTempDir[_MAX_PATH + 100];
    HRESULT   hr     = S_OK;

    szTempDir[0] = NULL;
    
    CSetupLogging::Log(1, "GetTempDir", 0, "Getting location of Temporary ASP.Net directory");
    hr = GetTempDir(szTempDir, _MAX_PATH + 100, fReg);
    CSetupLogging::Log(hr, "GetTempDir", 0, "Getting location of Temporary ASP.Net directory");
    ON_ERROR_CONTINUE();

    // R/W access on Temp
    if (szTempDir[0] != NULL) 
    {
        CSetupLogging::Log(1, "SetACLOnDir", 0, "Setting ACLs on Temporary ASP.Net directory");
        hr = SetACLOnDir(pSid, szTempDir, GENERIC_ALL, fReg);    
        CSetupLogging::Log(hr, "SetACLOnDir", 0, "Setting ACLs on Temporary ASP.Net directory");
        ON_ERROR_CONTINUE();
    }

    // Read accesses on Install and config
    CSetupLogging::Log(1, "SetACLOnDir", 0, "Setting ACLs on install root directory");
    hr = SetACLOnDir(pSid, Names::InstallDirectory(), GENERIC_READ | GENERIC_EXECUTE, fReg);
    CSetupLogging::Log(hr, "SetACLOnDir", 0, "Setting ACLs on install root directory");
    ON_ERROR_CONTINUE();

    CSetupLogging::Log(1, "SetACLOnDir", 0, "Setting ACLs on config directory");
    hr = SetACLOnDir(pSid, Names::GlobalConfigDirectory(), GENERIC_READ | GENERIC_EXECUTE, fReg);
    CSetupLogging::Log(hr, "SetACLOnDir", 0, "Setting ACLs on config directory");
    ON_ERROR_CONTINUE();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


HRESULT
CRegAccount::RemoveReg(
        LPCWSTR szUser, 
        BOOL    fEmpty)
{
    HRESULT hr         = S_OK;
    DWORD   dwErr      = 0;
    PSID    pSid       = NULL;
    BOOL    fWellKnown = FALSE;

    if (szUser == NULL || szUser[0] == NULL)
        EXIT_WITH_HRESULT(E_INVALIDARG);
 
    CSetupLogging::Log(1, "GetPrincipalSID", 0, "Getting Machine Account SID on DC");
    hr = GetPrincipalSID(szUser, &pSid, &fWellKnown);
    CSetupLogging::Log(hr, "GetPrincipalSID", 0, "Getting Machine Account SID on DC");
    ON_ERROR_CONTINUE();

    if (lstrcmpiW(szUser, L"ASPNET") != 0)
        fEmpty = FALSE;

    if (pSid != NULL) 
    {
        // Remove user from Guests group
        if (fEmpty)
        {
            CSetupLogging::Log(1, "RegisterAccountToLocalGroup", 0, "Removing Machine account from Guests group");
            hr = RegisterAccountToLocalGroup(szUser, TEXT("Guests"), FALSE, pSid);
            CSetupLogging::Log(hr, "RegisterAccountToLocalGroup", 0, "Removing Machine account from Guests group");
            ON_ERROR_CONTINUE();
            CSetupLogging::Log(1, "RegisterAccountToLocalGroup", 0, "Removing Machine account from Users group");
            hr = RegisterAccountToLocalGroup(szUser, TEXT("Users"), FALSE, pSid);
            CSetupLogging::Log(hr, "RegisterAccountToLocalGroup", 0, "Removing Machine account from Users group");
            ON_ERROR_CONTINUE();
        }

        CSetupLogging::Log(1, "ACLAllDirs", 0, "Setting ACLs for the ASPNET account");
        hr = ACLAllDirs(pSid, FALSE, fEmpty);
        CSetupLogging::Log(hr, "ACLAllDirs", 0, "Setting ACLs for the ASPNET account");
        ON_ERROR_CONTINUE();
    }

    if (fEmpty)
    {
        // Disable the user account
        CSetupLogging::Log(1, "EnableUserAccount", 0, "Disabling ASPNET account");
        hr = EnableUserAccount(szUser, FALSE);
        CSetupLogging::Log(hr, "EnableUserAccount", 0, "Disabling ASPNET account");
        if (hr != S_OK)
        {
            ON_ERROR_CONTINUE();
            
            // Delete the user if we can not disable it
            CSetupLogging::Log(1, "NetUserDel", 0, "Deleting ASPNET account");
            dwErr = NetUserDel(NULL, szUser);
            if (dwErr != NERR_Success && dwErr != NERR_UserNotFound)
                hr = HRESULT_FROM_WIN32(dwErr);                
            else
                hr = S_OK;
            
            CSetupLogging::Log(hr, "NetUserDel", 0, "Deleting ASPNET account");
            ON_ERROR_EXIT();
        }

        //  hr = RegisterAccountUserRights(FALSE, pSid);
        //  ON_ERROR_CONTINUE();

        CSetupLogging::Log(1, "RemoveAccountFromRegistry", 0, "Removing ASPNET account from registry");
        hr = RemoveAccountFromRegistry(szUser);
        CSetupLogging::Log(hr, "RemoveAccountFromRegistry", 0, "Removing ASPNET account from registry");
        ON_ERROR_CONTINUE();
    }

 Cleanup:
    if (fWellKnown && pSid != NULL)
        FreeSid(pSid);
    else
        DELETE_BYTES(pSid);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::AddSidToToken(
        HANDLE   hToken, 
        PSID     pSid,
        LPBOOL   pfAlreadyPresent)
{
    HRESULT                hr        = S_OK;
    BOOL                   fRet      = FALSE;
    SECURITY_INFORMATION   si        = DACL_SECURITY_INFORMATION;
    PSECURITY_DESCRIPTOR   pSDSelf   = NULL;
    PSECURITY_DESCRIPTOR   pSDAbs    = NULL;
    DWORD                  dwNeed    = 0;
    PACL                   pACLOrig  = NULL;
    PACL                   pACLNew   = NULL;
    BOOL                   fDefault  = FALSE;
    BOOL                   fPresent  = FALSE;
    PACL                   pDACL     = NULL;
    PACL                   pSACL     = NULL;
    PSID                   pOwner    = NULL;
    PSID                   pPriGrp   = NULL;
    DWORD                  dwPriGrp = 0, dwOwner = 0, dwSACL = 0, dwDACL = 0, dwAbs = 0;
    BYTE                   sBuffer[4000];
    LPBYTE                 dBuffers[3]   = { NULL, NULL, NULL};
    int                    iter;
    DWORD                  dwSPosUsed = 0;
    LPBYTE                 pBuffer = NULL;
    

    if (hToken == NULL || pSid == NULL)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    pSDSelf = (PSECURITY_DESCRIPTOR) sBuffer;
    fRet = GetUserObjectSecurity(hToken, &si, pSDSelf, 4000, &dwNeed);
    if (fRet == FALSE && dwNeed > 4000)
    {
        dBuffers[0] = new (NewClear) BYTE[dwNeed];
        ON_OOM_EXIT(dBuffers[0]);
        pSDSelf = (PSECURITY_DESCRIPTOR) dBuffers[0];
        fRet = GetUserObjectSecurity(hToken, &si, pSDSelf, dwNeed, &dwNeed);
    }
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

    if (dwNeed < 4000)
        dwSPosUsed = dwNeed;
    
    dwNeed = GetSecurityDescriptorLength(pSDSelf);
    ON_ZERO_EXIT_WITH_LAST_ERROR(dwNeed);
        
    fRet = GetSecurityDescriptorDacl(pSDSelf, &fPresent, &pACLOrig, &fDefault);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

    if (fPresent && pACLOrig == NULL)
        EXIT();

    if (DoesAccessExist(pACLOrig, pSid, 0xf01ff) == S_OK)
    {
        (*pfAlreadyPresent) = TRUE;
        EXIT();
    }
    else
    {
        (*pfAlreadyPresent) = FALSE; 
    }

    if (dwNeed + 60 > 4000 - dwSPosUsed)
    {
        dBuffers[1] = new (NewClear) BYTE[dwNeed + 60];
        ON_OOM_EXIT(dBuffers[1]);
        pACLNew = (PACL) dBuffers[1];
    }
    else
    {
        pACLNew = (PACL) (&sBuffer[dwSPosUsed]);
        dwSPosUsed += dwNeed + 60;
    }

    fRet = InitializeAcl(pACLNew, dwNeed + 60, ACL_REVISION);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

    hr = CopyACL(pACLNew, pACLOrig);
    ON_ERROR_EXIT();

    hr = AddAccess(pACLNew, pSid, 0xf01ff, NULL);
    ON_ERROR_EXIT();
    
    if ((*pfAlreadyPresent) == TRUE)
        EXIT();

    // Get Sizes required
    fRet = MakeAbsoluteSD(pSDSelf, NULL, &dwAbs, NULL, &dwDACL, NULL, &dwSACL, NULL, &dwOwner, NULL, &dwPriGrp);
    if (dwAbs + dwDACL + dwSACL + dwOwner + dwPriGrp > 4000 - dwSPosUsed)
    {
        dBuffers[2] = new (NewClear) BYTE[dwAbs + dwDACL + dwSACL + dwOwner + dwPriGrp];
        ON_OOM_EXIT(dBuffers[2]);
        pBuffer = dBuffers[2];
    }
    else
    {
        pBuffer = &sBuffer[dwSPosUsed];
    }

    // change dacl
    pSDAbs  = (PSECURITY_DESCRIPTOR) pBuffer;
    pDACL   = (PACL) (&pBuffer[dwAbs]);
    pSACL   = (PACL) (&pBuffer[dwAbs + dwDACL]);
    pOwner  = (PSID) (&pBuffer[dwAbs + dwDACL + dwSACL]);
    pPriGrp = (PSID) (&pBuffer[dwAbs + dwDACL + dwSACL + dwOwner]);

    fRet = MakeAbsoluteSD(
            pSDSelf,
            pSDAbs,
            &dwAbs,
            pDACL,
            &dwDACL,
            pSACL,
            &dwSACL,
            pOwner,
            &dwOwner,
            pPriGrp,
            &dwPriGrp);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

    fRet = SetSecurityDescriptorDacl(pSDAbs, TRUE, pACLNew, FALSE);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

    si = DACL_SECURITY_INFORMATION;
    fRet = SetUserObjectSecurity(hToken, &si, pSDAbs);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

 Cleanup:
    for(iter=0; iter<3; iter++)
        delete [] (dBuffers[iter]);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HANDLE
CRegAccount::CreateWorkerProcessToken(
        WCHAR * szUser, 
        WCHAR * szPass,
        PSID  * ppSid)
{
    WCHAR               szWUser[USERNAME_PASSWORD_LENGTH];
    WCHAR               szWPass[USERNAME_PASSWORD_LENGTH];
    HRESULT             hr       = S_OK;
    HANDLE              hToken   = NULL;
    PACL                pACL     = NULL;
    BOOL                fWellKnown = FALSE;
    DWORD               dwSidLen;
    PSID                pSid2;
    BOOL                fDC = FALSE;

    if (szUser == NULL || szPass == NULL)
        EXIT_WITH_HRESULT(E_INVALIDARG);
         
    InitStrings();
    StringCchCopyToArrayW(szWUser, szUser);
    StringCchCopyToArrayW(szWPass, szPass);

    if (lstrcmpiW(szWUser, L"SYSTEM") == 0)
    {
        if (lstrcmpiW(szWPass, L"autogenerate") == 0)
        {
            EXIT();
        }
        else
        {
            EXIT_WITH_HRESULT(E_UNEXPECTED);
        }
    }

    if (lstrcmpiW(szWUser, L"machine") == 0)
    {
        hr = IsDomainController(&fDC);
        if (hr != S_OK)
        {
            ON_ERROR_CONTINUE();
            fDC = FALSE;
            hr = S_OK;
        }
        if (!fDC)
        {
            StringCchCopyToArrayW(szWUser, g_szMachineAccountName);        
            // Get Password
            if (lstrcmpiW(szWPass, L"autogenerate") == 0)
            {
                XspSecureZeroMemory(szWPass, sizeof(szWPass));
                hr = GetAccountPasswordFromLSA(szWPass, sizeof(szWPass) / sizeof(WCHAR));
            }
        }
        else
        {
            BOOL fNetworkSerive;
            hr = GetMachineAccountCredentialsOnDC(
                    szWUser, ARRAY_SIZE(szWUser),
                    szWPass, ARRAY_SIZE(szWPass),
                    &fNetworkSerive);
        }
        ON_ERROR_EXIT();
    }
        
    hToken = (HANDLE) CreateUserToken(szWUser, szWPass, FALSE, NULL, 0);
    ON_ZERO_EXIT_WITH_LAST_ERROR(hToken);    

    hr = GetPrincipalSID(szWUser, ppSid, &fWellKnown);
    ON_ERROR_CONTINUE();
    if (hr == S_OK && fWellKnown && IsValidSid(*ppSid))
    {
        dwSidLen = GetLengthSid(*ppSid);
        pSid2 = (PSID) NEW_CLEAR_BYTES(dwSidLen + 20);
        if (pSid2 != NULL && CopySid(dwSidLen + 20, pSid2, *ppSid))
        {
            FreeSid(*ppSid);
            (*ppSid) = pSid2;            
        }
        else
        {
            FreeSid(*ppSid);
            (*ppSid) = NULL;            
        }
    }

    hr = S_OK;

 Cleanup:
    if (hr != S_OK)
    {
        if (hToken != NULL)
            CloseHandle(hToken);
        hToken = INVALID_HANDLE_VALUE;
    }

    DELETE_BYTES(pACL);
   
    g_fInvalidCredentials = (hToken == (HANDLE) -1);
    XspSecureZeroMemory(szWUser, sizeof(szWUser));
    XspSecureZeroMemory(szWPass, sizeof(szWPass));
    return hToken;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::AddAccess (
        PACL   pAcl,
        PSID   pSid,
        DWORD  dwAccess,
        LPBOOL pIfDoNothing)
{
    HRESULT                 hr = S_OK;
    BOOL                    fRet;
    ACL_SIZE_INFORMATION    oAclInfo;
    ACE_HEADER *            pAceHeader = NULL;

    if (pAcl == NULL || pSid == NULL)
        EXIT_WITH_HRESULT(E_INVALIDARG);
    
    if (pIfDoNothing != NULL && DoesAccessExist(pAcl, pSid, dwAccess) == S_OK) 
    {
        *pIfDoNothing = TRUE;
        EXIT();
    }

    fRet = AddAccessAllowedAce(pAcl, ACL_REVISION, dwAccess, pSid);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);
    
    fRet = GetAclInformation(pAcl, &oAclInfo, sizeof(oAclInfo), AclSizeInformation);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);
    
    fRet = GetAce(pAcl, oAclInfo.AceCount - 1, (void **) &pAceHeader);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);
    ON_ZERO_EXIT_WITH_LAST_ERROR(pAceHeader);

    pAceHeader->AceFlags = (BYTE) (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);
    
 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::DoesAccessExist(
        PACL   pAcl,
        PSID   pSid,
        DWORD  dwAccess)
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    HRESULT               hr        = S_OK;
    ACE_HEADER *          aceHeader = NULL;
    DWORD                 dwMask    = 0;
    
     if (pAcl == NULL || pSid == NULL || dwAccess == 0)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    ZeroMemory(&aclSizeInfo, sizeof(aclSizeInfo));
    if (!GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
        EXIT_WITH_LAST_ERROR();

    if (g_pSidWorld == NULL)
        CreateWorldSid();
    for (int dwAce = (int) aclSizeInfo.AceCount-1; dwAce >= 0; dwAce--)
    {
        aceHeader = NULL;
        if (!GetAce(pAcl, dwAce, (LPVOID *) &aceHeader) || aceHeader == NULL)
        {
            TRACE_ERROR(GetLastWin32Error()); 
            continue;
        }
        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            PSID   pSidThis = (PSID) &((ACCESS_ALLOWED_ACE *) aceHeader)->SidStart;
            if ((g_pSidWorld != NULL && EqualSid(pSid, g_pSidWorld)) || EqualSid(pSid, pSidThis))
            {
                dwMask |= ((ACCESS_ALLOWED_ACE *) aceHeader)->Mask;
                if (dwMask & GENERIC_ALL)
                    dwMask |= GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE;
    
                if ((dwAccess & dwMask) == dwAccess)
                    EXIT();
            }
        }
    }

    hr = S_FALSE;

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::CreateTempDir()
{
    WCHAR     szTempDir[_MAX_PATH + 100];
    HRESULT   hr     = S_OK;
    PSID      pSid   = NULL;
    BOOL      fWellKnown = FALSE;

    InitStrings();

    hr = GetPrincipalSID(g_szMachineAccountName, &pSid, &fWellKnown);
    ON_ERROR_EXIT();

    hr = GetTempDir(szTempDir, _MAX_PATH + 100, TRUE);
    ON_ERROR_EXIT();

    hr = SetACLOnDir(pSid, szTempDir, GENERIC_ALL, TRUE);    
    ON_ERROR_EXIT();

 Cleanup:
    if (fWellKnown && pSid != NULL)
        FreeSid(pSid);
    else
        DELETE_BYTES(pSid);    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void
CRegAccount::InitStrings()
{    
    if (g_szMachineAccountName[0] == NULL)
        StringCchCopyToArrayW(g_szMachineAccountName, L"ASPNET");    

    if (g_szLsaKey[0] == NULL)
        StringCchCopyToArrayW(g_szLsaKey, PRODUCT_STRING_L(WP_PASSWORD));
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::StoreAccountPasswordInLSA (
        LPCWSTR   szPass)
{
    LSA_HANDLE            hLasPolicy        = NULL;
    HRESULT               hr                = S_OK;
    LSA_UNICODE_STRING    szLsaKeyName;
    LSA_UNICODE_STRING    szLsaPass;
    LSA_OBJECT_ATTRIBUTES objAttribs;
    DWORD                 dwErr;

    if (szPass == NULL)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    InitStrings();
    ZeroMemory(&objAttribs,        sizeof(objAttribs));
    ZeroMemory(&szLsaKeyName,      sizeof(szLsaKeyName));

    szLsaKeyName.Length = szLsaKeyName.MaximumLength = (unsigned short) (lstrlenW(g_szLsaKey) * sizeof(WCHAR));
    szLsaKeyName.Buffer = (WCHAR *) g_szLsaKey;
    
    dwErr = LsaOpenPolicy(NULL,
                          &objAttribs,
                          POLICY_ALL_ACCESS,
                          &hLasPolicy);
    if (dwErr != STATUS_SUCCESS)
    {
        EXIT_WITH_WIN32_ERROR(LsaNtStatusToWinError(dwErr));
    }

    szLsaPass.Length = szLsaPass.MaximumLength = (unsigned short) lstrlenW(szPass) * sizeof(WCHAR);
    szLsaPass.Buffer = (WCHAR *) szPass; 
    dwErr = LsaStorePrivateData( hLasPolicy, 
                                 &szLsaKeyName, 
                                 &szLsaPass);
    if (dwErr != STATUS_SUCCESS)
    {
        EXIT_WITH_WIN32_ERROR(LsaNtStatusToWinError(dwErr));
    }

 Cleanup:
    if (hLasPolicy != NULL)
        LsaClose(hLasPolicy);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::GetStateServerAccCredentials (
        LPWSTR   szName,
        int      iNameSize,
        LPWSTR   szPass,
        int      iPassSize)
{
    if (szName == NULL || iNameSize < 1 || szPass == NULL || iPassSize < 1)
        return E_INVALIDARG;

    HRESULT       hr       = S_OK;
    BOOL          fIsDC    = FALSE;
    BOOL          fNetSvc  = FALSE;
    PSID          pSid     = NULL;
    BOOL          fWellKnown = FALSE;

    hr = GetPrincipalSID(L"NT AUTHORITY\\NetworkService", &pSid, &fWellKnown);
    if (hr == S_OK && pSid != NULL)
    {
        StringCchCopyW(szName, iNameSize, L"NT AUTHORITY\\NetworkService");
        XspSecureZeroMemory(szPass, (iPassSize - 1) * sizeof(WCHAR));
        if (fWellKnown && pSid != NULL)
            FreeSid(pSid);
        else
            DELETE_BYTES(pSid);        
        EXIT();
    }

    InitStrings();
    hr = IsDomainController(&fIsDC);
    if (hr != S_OK)
    {
        ON_ERROR_CONTINUE();
        fIsDC = FALSE;
        hr = S_OK;
    }

    if (!fIsDC)
    {
        StringCchCopyW(szName, iNameSize, g_szMachineAccountName);
        hr = GetAccountPasswordFromLSA(szPass, iPassSize);
        ON_ERROR_EXIT();
    }
    else
    {
        hr = GetMachineAccountCredentialsOnDC(
                szName, iNameSize, 
                szPass, iPassSize,
                &fNetSvc);
        ON_ERROR_EXIT();
    }

 Cleanup:
    return hr;

}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::GetAccountPasswordFromLSA (
        LPWSTR   szRet,
        int      iSize)
{
    LSA_HANDLE            hLasPolicy        = NULL;
    HRESULT               hr                = S_OK;
    PLSA_UNICODE_STRING   pszLsaData        = NULL; 
    LSA_UNICODE_STRING    szLsaKeyName;
    LSA_OBJECT_ATTRIBUTES objAttribs;
    DWORD                 dwErr;

    if (szRet == NULL || iSize < 1)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    InitStrings();

    ZeroMemory(&objAttribs,        sizeof(objAttribs));
    ZeroMemory(&szLsaKeyName,      sizeof(szLsaKeyName));

    szLsaKeyName.Length = szLsaKeyName.MaximumLength = (unsigned short) (lstrlenW(g_szLsaKey) * sizeof(WCHAR));
    szLsaKeyName.Buffer = (WCHAR *) g_szLsaKey;
    
    dwErr = LsaOpenPolicy(NULL,
                          &objAttribs,
                          POLICY_ALL_ACCESS,
                          &hLasPolicy);
    if (dwErr != STATUS_SUCCESS)
    {
        EXIT_WITH_WIN32_ERROR(LsaNtStatusToWinError(dwErr));
    }

    dwErr = LsaRetrievePrivateData(hLasPolicy, 
                                   &szLsaKeyName, 
                                   &pszLsaData);
    if (dwErr != STATUS_SUCCESS)
    {
        EXIT_WITH_WIN32_ERROR(LsaNtStatusToWinError(dwErr));
    }

    if (pszLsaData == NULL  || pszLsaData->Buffer == NULL || (pszLsaData->Length / 2) >=  iSize )
        EXIT_WITH_HRESULT(E_FAIL);

    wcsncpy(szRet, pszLsaData->Buffer, pszLsaData->Length/2);

 Cleanup:
    if (hLasPolicy != NULL)
        LsaClose(hLasPolicy);
    if (pszLsaData != NULL)
        LsaFreeMemory(pszLsaData);

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::GetTempDir(
        LPWSTR szDir,
        int    iSize,
        BOOL   fCreateIfNotExists)
{    
    HRESULT    hr        = S_OK;
    LPCWSTR    szInstall = Names::InstallDirectory();
    int        iLast;
    DWORD      dwAtt;

    if (szDir == NULL || iSize < 1)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    if (szInstall == NULL || iSize < 40 || lstrlenW(szInstall) > iSize - 40)
    {
        EXIT_WITH_HRESULT(E_UNEXPECTED);
    }

    ZeroMemory(szDir, iSize * sizeof(WCHAR));
    StringCchCopy(szDir, iSize, szInstall);
    iLast = lstrlenW(szDir) - 1;

    if(iLast > 0 && szDir[iLast] != L'\\')
        szDir[iLast+1] = L'\\';
    StringCchCat(szDir, iSize, ASPNET_TEMP_DIR_L);

    dwAtt = GetFileAttributes(szDir);
    
    if (dwAtt == (DWORD) -1)
    { // Doesn't exist
        if (fCreateIfNotExists)
        {
            if (!CreateDirectory(szDir, NULL))
            {
                EXIT_WITH_LAST_ERROR();
            }
        }
        else
        {
            szDir[0] = NULL;
            EXIT();
        }
    }
    else
    {
        if (!(dwAtt & FILE_ATTRIBUTE_DIRECTORY))
        { // Not a dir
            EXIT_WITH_HRESULT(E_UNEXPECTED);
        }
    }

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::SetACLOnDir(
        PSID        pSid,
        LPCWSTR     szDir,
        DWORD       dwAccessMask,
        BOOL        fAddAccess)
{
    PSECURITY_DESCRIPTOR pSD   = NULL;
    DWORD                dwReq = 0;
    BOOL                 fRet  = FALSE;
    BOOL                 fPresent;
    BOOL                 fDefault;
    PACL                 pACL = NULL;
    PACL                 pACL2 = NULL;
    HRESULT              hr = S_OK;
    BOOL                 fIfDoNothing = FALSE;

    if (szDir == NULL || pSid == NULL)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    pSD = (PSECURITY_DESCRIPTOR) NEW_CLEAR_BYTES(4096);
    ON_OOM_EXIT(pSD);

    InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
    fRet = GetFileSecurity(
            szDir, 
            DACL_SECURITY_INFORMATION,
            pSD,
            4096,
            &dwReq);

    if (!fRet && dwReq > 4096)
    {
        delete pSD;
        pSD = (PSECURITY_DESCRIPTOR) NEW_CLEAR_BYTES(dwReq);
        ON_OOM_EXIT(pSD);

        fRet = GetFileSecurity(
                szDir, 
                DACL_SECURITY_INFORMATION,
                pSD,
                dwReq,
                &dwReq);
    }
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

    fRet = GetSecurityDescriptorDacl(
            pSD, 
            &fPresent, 
            &pACL, 
            &fDefault);  
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

    if (!fPresent || pACL == NULL)
    {
        EXIT();
    }
    
    if (dwReq < 4096)
        dwReq = 4096;
        
    pACL2 = (PACL) NEW_CLEAR_BYTES(dwReq + 1024);
    ON_OOM_EXIT(pACL2);

    InitializeAcl(pACL2, dwReq+1024, ACL_REVISION);
    hr = CopyACL(pACL2, pACL);
    ON_ERROR_EXIT();
    

    if (fAddAccess)
    {
        hr = AddAccess(pACL2, pSid, dwAccessMask, &fIfDoNothing);
    }
    else
    {
        hr = RemoveACL(pACL2, pSid);
    }
    ON_ERROR_EXIT();

    if (! fIfDoNothing)  
    {
        dwReq = SetNamedSecurityInfo(
                (LPWSTR) szDir,
                SE_FILE_OBJECT,
                DACL_SECURITY_INFORMATION,
                NULL,
                NULL,
                pACL2,
                NULL);
        
        if (dwReq != ERROR_SUCCESS)
        {
            EXIT_WITH_WIN32_ERROR(dwReq);
        }
    }
    
    
 Cleanup:
    DELETE_BYTES(pSD);
    DELETE_BYTES(pACL2);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////// Copied code /////////////////////////////////////

HRESULT
CRegAccount::RemoveACL(
        PACL pAcl, 
        PSID pSid)
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    HRESULT               hr        = S_OK;
    PSID                  pSidAce   = NULL;
    ACE_HEADER *          aceHeader = NULL;

    if (pAcl == NULL || pSid == NULL)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    ZeroMemory(&aclSizeInfo, sizeof(aclSizeInfo));
    if (!GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
        EXIT_WITH_LAST_ERROR();

    for (int dwAce = (int) aclSizeInfo.AceCount-1; dwAce >= 0; dwAce--)
    {
        aceHeader = NULL;
        if (!GetAce(pAcl, dwAce, (LPVOID *) &aceHeader) || aceHeader == NULL)
        {
            TRACE_ERROR(GetLastWin32Error()); 
            continue;
        }
        switch(aceHeader->AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
            pSidAce = (PSID) &((ACCESS_ALLOWED_ACE *) aceHeader)->SidStart;
            break;
        case ACCESS_DENIED_ACE_TYPE:
            pSidAce = (PSID) &((ACCESS_DENIED_ACE *) aceHeader)->SidStart;
            break;
        case SYSTEM_AUDIT_ACE_TYPE:
            pSidAce = (PSID) &((SYSTEM_AUDIT_ACE *) aceHeader)->SidStart;
            break;
        default:
            pSidAce = NULL;
        }

        if (pSidAce != NULL && EqualSid(pSid, pSidAce))
        {
            DeleteAce(pAcl, dwAce);
        }
    }

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::CopyACL(
        PACL pDest, 
        PACL pSrc)
{
    ACL_SIZE_INFORMATION   aclSizeInfo;
    HRESULT                hr = S_OK;

    if (pSrc == NULL)
        EXIT();

    ZeroMemory(&aclSizeInfo, sizeof(aclSizeInfo));
    if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
        EXIT_WITH_LAST_ERROR();

    // Copy all of the ACEs to the new ACL
    for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
    {
        LPVOID pAce;
        pAce = NULL;
        if (!GetAce(pSrc, i, &pAce))
            EXIT_WITH_LAST_ERROR();
        if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, ((ACE_HEADER *) pAce)->AceSize))
            EXIT_WITH_LAST_ERROR();
    }

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//
// Create InternetGuest Account
//
HRESULT
CRegAccount::CreateUser( 
        LPCTSTR szUsername,
        LPCTSTR szPassword,
        LPCTSTR szComment,
        LPCTSTR szFullName,
        PSID *  ppSid,
        BOOL *  pfWellKnown)
{
    INT      err = NERR_Success;
    BYTE *   pBuffer = NULL;
    WCHAR    defGuest[UNLEN+2];
    TCHAR    defGuestGroup[GNLEN+1];
    WCHAR    wchGuestGroup[GNLEN+1];
    WCHAR    wchUsername[UNLEN+1];
    WCHAR    wchPassword[LM20_PWLEN+1];
    HRESULT  hr = S_OK;
    WCHAR    wchComment[MAXCOMMENTSZ+1];
    WCHAR    wchFullName[UNLEN+1];
    DWORD    parm_err;
    USER_INFO_3 * lpui3;
    BOOL     fUserExisted=FALSE;

    hr = GetGuestUserName(defGuest);
    ON_ERROR_EXIT();

    hr = GetGuestGrpName(defGuestGroup);
    ON_ERROR_EXIT();
    
    memset((PVOID)wchUsername, 0, sizeof(wchUsername));
    memset((PVOID)wchPassword, 0, sizeof(wchPassword));
    wcsncpy(wchGuestGroup, defGuestGroup, GNLEN);
    wcsncpy(wchUsername, szUsername, UNLEN);
    wcsncpy(wchPassword, szPassword, LM20_PWLEN);

    err = NetUserGetInfo( NULL, defGuest, 3, &pBuffer );
    if (err != NERR_Success)
        EXIT_WITH_WIN32_ERROR(err);

    memset((PVOID)wchComment, 0, sizeof(wchComment));
    memset((PVOID)wchFullName, 0, sizeof(wchFullName));
    wcsncpy(wchComment, szComment, MAXCOMMENTSZ);
    wcsncpy(wchFullName, szFullName, UNLEN);

    lpui3 = (USER_INFO_3 *)pBuffer;

    lpui3->usri3_name = wchUsername;
    lpui3->usri3_password = wchPassword;
    lpui3->usri3_flags &= ~ UF_ACCOUNTDISABLE;
    lpui3->usri3_flags |= UF_DONT_EXPIRE_PASSWD;
    lpui3->usri3_acct_expires = TIMEQ_FOREVER;

    lpui3->usri3_comment = wchComment;
    lpui3->usri3_usr_comment = wchComment;
    lpui3->usri3_full_name = wchFullName;
    lpui3->usri3_primary_group_id = DOMAIN_GROUP_RID_USERS;


    err = NetUserAdd( NULL, 3, pBuffer, &parm_err );

    if (err == NERR_UserExists)
    { 
        hr = ChangeUserPassword((LPTSTR) szUsername, (LPTSTR) szPassword);
        ON_ERROR_EXIT();

        hr = EnableUserAccount(szUsername, TRUE);
        ON_ERROR_EXIT();

        fUserExisted = TRUE;
        err = NERR_Success;
    }
    
    if (err != NERR_Success)
        EXIT_WITH_WIN32_ERROR(err);

    hr = GetPrincipalSID(szUsername, ppSid, pfWellKnown);
    ON_ERROR_EXIT();

    if (fUserExisted)
    {
        // Remove from Guests group
        RegisterAccountToLocalGroup(szUsername, TEXT("Guests"), FALSE, *ppSid);
    }

    // add it to the Users group
    hr = RegisterAccountToLocalGroup(szUsername, TEXT("Users"), TRUE, *ppSid);
    ON_ERROR_CONTINUE();

    // add certain user rights to this account
    hr = RegisterAccountUserRights(TRUE, *ppSid);
    ON_ERROR_CONTINUE();

    // Uncheck "Allow Logon To Terminal Server" in the Properties dialog for the user (see #113249)
    hr = RegisterAccountDisableLogonToTerminalServer();
    ON_ERROR_CONTINUE();

    hr = S_OK;



 Cleanup:
    if (pBuffer != NULL)
        NetApiBufferFree(pBuffer);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
HRESULT
CRegAccount::EnableUserAccount(
        LPCWSTR  szUser,
        BOOL     fEnable)
{
    if (szUser == NULL)
        return E_INVALIDARG;

    HRESULT           hr     = S_OK;
    DWORD             dwErr  = 0;
    USER_INFO_1 *     pInfo  = NULL;
  
    dwErr = NetUserGetInfo(NULL, szUser, 1, (LPBYTE *) &pInfo);
    if (dwErr != NERR_Success)
        EXIT_WITH_WIN32_ERROR(dwErr);
    if (pInfo == NULL)
        EXIT_WITH_HRESULT(E_POINTER);

    if (fEnable && !(pInfo->usri1_flags & UF_ACCOUNTDISABLE))
        EXIT();
    if (!fEnable && (pInfo->usri1_flags & UF_ACCOUNTDISABLE))
        EXIT();

    if (fEnable)
        pInfo->usri1_flags &= ~ UF_ACCOUNTDISABLE;
    else
        pInfo->usri1_flags |= UF_ACCOUNTDISABLE;
    dwErr = NetUserSetInfo(NULL, szUser, 1, (LPBYTE) pInfo, NULL);
    if (dwErr != NERR_Success)
        EXIT_WITH_WIN32_ERROR(dwErr);

 Cleanup:
    if (pInfo != NULL)
        NetApiBufferFree(pInfo);
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
HRESULT
CRegAccount::GetGuestUserNameForDomain_FastWay(
        LPTSTR   szTargetComputer,
        LPTSTR   szGuestUsrName)
{
    PUSER_MODALS_INFO_2        pUserModalsInfo       = NULL;
    DWORD                      dwErr                 = 0;
    PUCHAR                     pSubCount             = NULL;
    PSID                       pSid                  = NULL;
    PSID                       pSidMachine           = NULL;
    SID_NAME_USE               sidNameUse;
    WCHAR                      szDomainName[DNLEN+1] = L"";
    DWORD                      cchDomainName         = DNLEN+1;
    HRESULT                    hr                    = S_OK;
    PSID_IDENTIFIER_AUTHORITY  pSidIdAuth            = NULL;
    PDWORD                     pSrc                  = NULL;
    PDWORD                     pDest                 = NULL;
    DWORD                      cchName               = UNLEN + 1;
    
    ZeroMemory(szGuestUsrName, sizeof(WCHAR) * cchName);

    dwErr = NetUserModalsGet(szTargetComputer, 2, (LPBYTE *)&pUserModalsInfo);
    if (dwErr != NERR_Success)
        EXIT_WITH_WIN32_ERROR(dwErr);
    if (pUserModalsInfo == NULL)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    pSidMachine = pUserModalsInfo->usrmod2_domain_id;
    if (pSidMachine == NULL || !IsValidSid(pSidMachine))
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    pSubCount = GetSidSubAuthorityCount(pSidMachine);
    if (pSubCount == NULL || (*pSubCount) == 0)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    pSid = (PSID) NEW_CLEAR_BYTES(GetSidLengthRequired(*pSubCount + 1));
    ON_OOM_EXIT(pSid);
    
    pSidIdAuth = GetSidIdentifierAuthority(pSidMachine);
    if (pSidIdAuth == NULL)
        EXIT_WITH_HRESULT(E_UNEXPECTED);
        
    dwErr = InitializeSid(pSid, pSidIdAuth, (BYTE)(*pSubCount+1)); 
    ON_ZERO_EXIT_WITH_LAST_ERROR(dwErr);
    
    for (DWORD iter = 0; iter < *pSubCount; iter++)
    {
        pSrc  = GetSidSubAuthority(pSidMachine, iter);
        ON_ZERO_EXIT_WITH_LAST_ERROR(pSrc);

        pDest = GetSidSubAuthority(pSid, iter);
        ON_ZERO_EXIT_WITH_LAST_ERROR(pDest);
        
        *pDest = *pSrc;
    }

    pDest = GetSidSubAuthority(pSid, *pSubCount);
    ON_ZERO_EXIT_WITH_LAST_ERROR(pDest);
    
    *pDest = DOMAIN_USER_RID_GUEST;
    dwErr = LookupAccountSid(
            szTargetComputer,
            pSid,
            szGuestUsrName,
            &cchName,
            szDomainName,
            &cchDomainName,
            &sidNameUse);
    ON_ZERO_EXIT_WITH_LAST_ERROR(dwErr);

 Cleanup:
    if (pUserModalsInfo != NULL)
        NetApiBufferFree(pUserModalsInfo);
    DELETE_BYTES(pSid);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::GetGuestUserName(
        LPTSTR lpOutGuestUsrName)
{
    return GetGuestUserNameForDomain_FastWay(NULL, lpOutGuestUsrName);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::GetUsersGroupName(
        LPWSTR szName,
        DWORD  iNameSize)
{

    ZeroMemory(szName, sizeof(WCHAR) * iNameSize);

    HRESULT                  hr            = S_OK;
    PSID                     pSid          = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuthNT     = SECURITY_NT_AUTHORITY;
    WCHAR                    szDomain[DNLEN+1] = L"";
    DWORD                    cchDomainName = DNLEN+1;
    SID_NAME_USE             sidNameUse;

    if (!AllocateAndInitializeSid(
                &SIDAuthNT, 2,
                SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_USERS,
                0, 0, 0, 0, 0, 0,
                &pSid))
    {
        EXIT_WITH_LAST_ERROR();
    }

    if (!LookupAccountSid(
                NULL,
                pSid,
                szName,
                &iNameSize,
                szDomain,
                &cchDomainName,
                &sidNameUse))
    {
        EXIT_WITH_LAST_ERROR();
    }

 Cleanup:
    if (pSid != NULL)
        FreeSid(pSid);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::GetGuestGrpName(
        LPTSTR lpGuestGrpName)
{
    HRESULT hr = S_OK;
    BOOL    fRet;
    LPCTSTR ServerName = NULL; // local machine
    // use UNLEN because DNLEN is too small
    DWORD cbName = UNLEN+1;
    TCHAR ReferencedDomainName[UNLEN+1];
    DWORD cbReferencedDomainName = sizeof(ReferencedDomainName) / sizeof(WCHAR);
    SID_NAME_USE sidNameUse = SidTypeUser;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID GuestsSid = NULL;

    fRet = AllocateAndInitializeSid(&NtAuthority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_GUESTS,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    &GuestsSid);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

    fRet = LookupAccountSid(ServerName,
                            GuestsSid,
                            lpGuestGrpName,
                            &cbName,
                            ReferencedDomainName,
                            &cbReferencedDomainName,
                            &sidNameUse);

    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

 Cleanup:
    if (GuestsSid != NULL)
        FreeSid(GuestsSid);
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::RegisterAccountToLocalGroup(
        LPCTSTR szAccountName,
        LPCTSTR szLocalGroupName,
        BOOL fAction,
        PSID pSid)
{
    HRESULT hr = S_OK;
    int err = 0;
    TCHAR szLocalizedLocalGroupName[GNLEN + 1];
    LOCALGROUP_MEMBERS_INFO_0 buf;

    // Get the localized LocalGroupName
    if (_wcsicmp(szLocalGroupName, TEXT("Guests")) == 0)
    {
        hr = GetGuestGrpName(szLocalizedLocalGroupName);
        ON_ERROR_EXIT();        
    } else if (_wcsicmp(szLocalGroupName, TEXT("Users")) == 0)
    {
        hr = GetUsersGroupName(szLocalizedLocalGroupName, sizeof(szLocalizedLocalGroupName) / sizeof(WCHAR));
        ON_ERROR_EXIT();        
    }
    else
    {
        StringCchCopyToArrayW(szLocalizedLocalGroupName, szLocalGroupName);
    }

    // transfer szLocalGroupName to WCHAR
    WCHAR wszLocalGroupName[_MAX_PATH];
    StringCchCopyToArrayW(wszLocalGroupName, szLocalizedLocalGroupName);


    buf.lgrmi0_sid = pSid;

    if (fAction)
    {
        err = NetLocalGroupAddMembers(NULL, wszLocalGroupName, 0, (LPBYTE)&buf, 1);
        if (err != NERR_Success && err != ERROR_MEMBER_IN_ALIAS)
            EXIT_WITH_WIN32_ERROR(err);
    }
    else
    {
        NetLocalGroupDelMembers(NULL, wszLocalGroupName, 0, (LPBYTE)&buf, 1);
    }

 Cleanup:

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::RegisterAccountUserRights(
        BOOL fAction,
        PSID pSid)
{
    int err;
    HRESULT hr = S_OK;

    LSA_UNICODE_STRING UserRightString;
    LSA_HANDLE PolicyHandle = NULL;

    err = OpenPolicy(NULL, POLICY_ALL_ACCESS,&PolicyHandle);
    if (err != STATUS_SUCCESS)
    {
        EXIT_WITH_WIN32_ERROR(LsaNtStatusToWinError(err));
    }

    if (fAction) 
    {
        InitLsaString(&UserRightString, SE_NETWORK_LOGON_NAME);
        LsaAddAccountRights(PolicyHandle, pSid, &UserRightString, 1);
        InitLsaString(&UserRightString, SE_BATCH_LOGON_NAME);
        LsaAddAccountRights(PolicyHandle, pSid, &UserRightString, 1);
        InitLsaString(&UserRightString, L"SeDenyInteractiveLogonRight");
        LsaAddAccountRights(PolicyHandle, pSid, &UserRightString, 1);
        InitLsaString(&UserRightString, SE_SERVICE_LOGON_NAME);
        LsaAddAccountRights(PolicyHandle, pSid, &UserRightString, 1);
	//SE_DENY_REMOTE_INTERACTIVE_LOGON_NAME does not exist on win2k, 
	//but we call it regardless.  RegisterAccountDisableLogonToTerminalServer()
	//will disable TS logon on win2k.
        InitLsaString(&UserRightString, SE_DENY_REMOTE_INTERACTIVE_LOGON_NAME);
        LsaAddAccountRights(PolicyHandle, pSid, &UserRightString, 1);
        InitLsaString(&UserRightString, L"SeImpersonatePrivilege");
        LsaAddAccountRights(PolicyHandle, pSid, &UserRightString, 1);
    }
    else 
    {
        InitLsaString(&UserRightString, SE_INTERACTIVE_LOGON_NAME);
        LsaRemoveAccountRights(PolicyHandle, pSid, FALSE, &UserRightString,1);
        InitLsaString(&UserRightString, SE_NETWORK_LOGON_NAME);
        LsaRemoveAccountRights(PolicyHandle, pSid, FALSE, &UserRightString,1);
        InitLsaString(&UserRightString, SE_BATCH_LOGON_NAME);
        LsaRemoveAccountRights(PolicyHandle, pSid, FALSE, &UserRightString,1);
        InitLsaString(&UserRightString, L"SeDenyInteractiveLogonRight");
        LsaRemoveAccountRights(PolicyHandle, pSid, FALSE, &UserRightString, 1);
        InitLsaString(&UserRightString, SE_SERVICE_LOGON_NAME);
        LsaRemoveAccountRights(PolicyHandle, pSid, FALSE, &UserRightString,1);
        InitLsaString(&UserRightString, SE_DENY_REMOTE_INTERACTIVE_LOGON_NAME);
        LsaRemoveAccountRights(PolicyHandle, pSid, FALSE, &UserRightString, 1);
        InitLsaString(&UserRightString, L"SeImpersonatePrivilege");
        LsaRemoveAccountRights(PolicyHandle, pSid, FALSE, &UserRightString, 1);
    }

    LsaClose(PolicyHandle);

 Cleanup:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::RegisterAccountDisableLogonToTerminalServer() {

  //WTSSetUserConfig will disable TS logon for the account on win2k.

  HRESULT hr = S_OK;
  DWORD allowLogon = 0;
  BOOL success = 0;

  CSetupLogging::Log(1, "DiableLogonToTerminalServer", 0, "Unchecking \"Allow logon to terminal server\".");

  success = WTSSetUserConfigW(
		    WTS_CURRENT_SERVER_NAME,
		    g_szMachineAccountName, 
		    WTSUserConfigfAllowLogonTerminalServer, 
		    (LPTSTR)&allowLogon, 
		    sizeof(DWORD)
		    );

  ON_ZERO_EXIT_WITH_LAST_ERROR(success);

 Cleanup:
  CSetupLogging::Log(hr, "DiableLogonToTerminalServer", 0, "Unchecked \"Allow logon to terminal server\".");  
  return hr;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::GetPrincipalSID (
        LPCTSTR Principal,
        PSID * Sid,
        BOOL * pbWellKnownSID)
{
    BOOL fRet;
    HRESULT hr = S_OK;
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority = NULL;
    BYTE Count = 0;
    DWORD dwRID[8];
    TCHAR pszPrincipal[MAX_PATH];
    WCHAR szCompName[256] = L"";
    DWORD dwCompName = 255;

    ZeroMemory(dwRID, sizeof(dwRID));

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));

    ASSERT(lstrlenW(Principal) < MAX_PATH);
    StringCchCopyToArrayW(pszPrincipal, Principal);
    _wcslwr(pszPrincipal);
    LPTSTR szSlash = wcschr(pszPrincipal, L'\\');
    LPTSTR szStart = ((szSlash == NULL) ? pszPrincipal : &szSlash[1]);

    if ( wcscmp(szStart, TEXT("administrators")) == 0 ) {
        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;
    } else if ( wcscmp(szStart, TEXT("system")) == 0) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;
    } else if ( wcscmp(szStart, TEXT("interactive")) == 0) {
        // INTERACTIVE
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;
    } else if ( wcscmp(szStart, TEXT("everyone")) == 0) {
        // Everyone
        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;
    } else {
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID) {
        fRet = AllocateAndInitializeSid(pSidIdentifierAuthority,
                                        (BYTE)Count,
                                        dwRID[0],
                                        dwRID[1],
                                        dwRID[2],
                                        dwRID[3],
                                        dwRID[4],
                                        dwRID[5],
                                        dwRID[6],
                                        dwRID[7],
                                        Sid);
        
    } 
    else 
    {
        // get regular account sid
        DWORD        sidSize;
        TCHAR        refDomain [256] = L"";
        DWORD        refDomainSize;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        fRet = LookupAccountName (NULL,
                                  pszPrincipal,
                                  *Sid,
                                  &sidSize,
                                  refDomain,
                                  &refDomainSize,
                                  &snu);
        if (!fRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER) 
        {
            *Sid = (PSID) NEW_CLEAR_BYTES(sidSize);
            ON_OOM_EXIT(*Sid);
            refDomainSize = 255;
            
            fRet = LookupAccountName (NULL,
                                      pszPrincipal,
                                      *Sid,
                                      &sidSize,
                                      refDomain,
                                      &refDomainSize,
                                      &snu);
        }

        if (fRet && refDomain[0] != NULL && _wcsicmp(refDomain, L"BUILTIN") != 0 && wcschr(pszPrincipal, L'\\') == NULL)
        {
            if (GetComputerName(szCompName, &dwCompName) && szCompName[0] != NULL)
            {
                szCompName[255] = NULL;
                if (_wcsicmp(szCompName, refDomain) != 0)
                {
                    DELETE_BYTES(*Sid);
                    (*Sid) = NULL;
                    EXIT_WITH_HRESULT(E_UNEXPECTED);
                }
            }

        }
    }
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

 Cleanup:    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::ChangeUserPassword(
        LPTSTR szUserName, 
        LPTSTR szNewPassword)
{
    HRESULT hr = S_OK;
    USER_INFO_1003  pi1003; 
    NET_API_STATUS  nas; 

    TCHAR szRawComputerName[CNLEN + 10];
    DWORD dwLen = CNLEN + 10;
    TCHAR szComputerName[CNLEN + 10];
    TCHAR szCopyOfUserName[UNLEN+10];
    TCHAR szTempFullUserName[(CNLEN + 10) + (UNLEN+1)];
    LPTSTR pch = NULL;

    szComputerName[0] = NULL;
    StringCchCopyToArrayW(szCopyOfUserName, szUserName);

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeUserPassword().Start.name=%s,pass=%s"),szCopyOfUserName,szNewPassword));

    if ( !GetComputerName( szRawComputerName, &dwLen ))
        EXIT_WITH_LAST_ERROR();

    // Make a copy to be sure not to move the pointer around.
    StringCchCopyToArrayW(szTempFullUserName, szCopyOfUserName);
    // Check if there is a "\" in there.
    pch = wcschr(szTempFullUserName, '\\');
    if (pch) 
    {
        // szCopyOfUserName should now go from something like this:
        // mycomputer\myuser
        // to this myuser
        StringCchCopyToArrayW(szCopyOfUserName, pch+1);
        // trim off the '\' character to leave just the domain\computername so we can check against it.
        *pch = '\0';
        // compare the szTempFullUserName with the local computername.
        if (0 == _wcsicmp(szRawComputerName, szTempFullUserName))
        {
            // the computername\username has a hardcoded computername in it.
            // lets try to get only the username
            // look szCopyOfusername is already set
        }
        else
        {
            // the local computer machine name
            // and the specified username are different, so get out
            // and don't even try to change this user\password since
            // it's probably a domain\username

            // return true -- saying that we did in fact change the passoword.
            // we really didn't but we can't
            EXIT();
        }
    }

    // Make sure the computername has a \\ in front of it
    if ( szRawComputerName[0] != '\\' )
    {StringCchCopyToArrayW(szComputerName, L"\\\\");}
    StringCchCatToArrayW(szComputerName, szRawComputerName);
    // 
    // administrative over-ride of existing password 
    // 
    // by this time szCopyOfUserName
    // should not look like mycomputername\username but it should look like username.
    pi1003.usri1003_password = szNewPassword;
    nas = NetUserSetInfo(
            szComputerName,   // computer name 
            szCopyOfUserName, // username 
            1003,             // info level 
            (LPBYTE)&pi1003,  // new info 
            NULL 
            ); 

    if(nas != NERR_Success) 
        EXIT_WITH_WIN32_ERROR(nas);


 Cleanup:
    return hr;
} 

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void 
CRegAccount::InitLsaString(
        PLSA_UNICODE_STRING  LsaString,
        LPWSTR               str)
{
    DWORD StringLength;

    if (str == NULL)
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = lstrlenW(str);
    LsaString->Buffer = str;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

DWORD
CRegAccount::OpenPolicy(
        LPTSTR ServerName,
        DWORD DesiredAccess,
        PLSA_HANDLE PolicyHandle)
{
    DWORD Error;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server = NULL;
    SECURITY_QUALITY_OF_SERVICE QualityOfService;

    QualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    QualityOfService.ImpersonationLevel = SecurityImpersonation;
    QualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    QualityOfService.EffectiveOnly = FALSE;

    //
    // The two fields that must be set are length and the quality of service.
    //
    ObjectAttributes.Length = sizeof(LSA_OBJECT_ATTRIBUTES);
    ObjectAttributes.RootDirectory = NULL;
    ObjectAttributes.ObjectName = NULL;
    ObjectAttributes.Attributes = 0;
    ObjectAttributes.SecurityDescriptor = NULL;
    ObjectAttributes.SecurityQualityOfService = &QualityOfService;

    if (ServerName != NULL)
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString,ServerName);
        Server = &ServerString;
    }
    //
    // Attempt to open the policy for all access
    //
    Error = LsaOpenPolicy(Server,&ObjectAttributes,DesiredAccess,PolicyHandle);
    return(Error);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::RemoveAccountFromRegistry(
        LPCWSTR szUser)
{
    HKEY      hKeyXSP = NULL;
    HRESULT   hr      = S_OK;

    hr = OpenRegistryKey(KEY_SET_VALUE, &hKeyXSP);
    ON_ERROR_EXIT();
    
    RegDeleteValue(hKeyXSP, szUser); // Ignore failure
 Cleanup:
    if (hKeyXSP != NULL)
        RegCloseKey(hKeyXSP);
    return hr;
}
    
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::OpenRegistryKey(
        DWORD   dwAccess, 
        HKEY *  phKey)
{
    HKEY      hKeyXSP   = NULL;
    HRESULT   hr        = S_OK;

    DWORD     dwErr     = 0;

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_MACHINE_APP_L, 
                         0, KEY_ALL_ACCESS, &hKeyXSP);

    if (dwErr != ERROR_SUCCESS)
        EXIT_WITH_WIN32_ERROR(dwErr);    

    dwErr = RegOpenKeyEx(hKeyXSP, L"MachineAccounts", 
                         0, dwAccess, phKey);

    // Try to create it
    if (dwErr != ERROR_SUCCESS)
    {
        dwErr = RegCreateKeyEx(hKeyXSP, L"MachineAccounts", 0, NULL, 0,
                               dwAccess, NULL, phKey, NULL);
    }

    if (dwErr != ERROR_SUCCESS)
        EXIT_WITH_WIN32_ERROR(dwErr);

 Cleanup:
    if (hKeyXSP != NULL)
        RegCloseKey(hKeyXSP);
    if (hr != S_OK && phKey != NULL && (*phKey) != NULL)
    {
        RegCloseKey(*phKey);
        (*phKey) = NULL;
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::AddAccountToRegistry(
        LPCWSTR szUser)
{
    HKEY      hKeyXSP = NULL;
    HRESULT   hr      = S_OK;
    DWORD     dwErr   = 0;
    DWORD     dwValue = 0;

    hr = OpenRegistryKey(KEY_SET_VALUE, &hKeyXSP);
    ON_ERROR_EXIT();

    dwErr = RegSetValueEx(hKeyXSP, szUser, 0,
                          REG_DWORD, (BYTE *) &dwValue, sizeof(DWORD));

    if (dwErr != ERROR_SUCCESS)
        EXIT_WITH_WIN32_ERROR(dwErr);
 Cleanup:
    if (hKeyXSP != NULL)
        RegCloseKey(hKeyXSP);
    return hr;
}   

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::IsDomainController(
        LPBOOL   pDC)
{    
    if (pDC == NULL)
        return E_INVALIDARG;
    
    if (g_fIsDCDecided)
    {        (*pDC) = g_fIsDC;
        return S_OK;
    }

    HRESULT         hr     = S_OK;
    LPBYTE          pBuf   = NULL;
    NET_API_STATUS  dwRet  = 0;


    dwRet = NetServerGetInfo(NULL, 101, &pBuf);
    if(dwRet != NERR_Success) 
        EXIT_WITH_WIN32_ERROR(dwRet);

    if (pBuf == NULL)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    (*pDC) = ((((PSERVER_INFO_101) pBuf)->sv101_type & SV_TYPE_DOMAIN_CTRL) || (((PSERVER_INFO_101) pBuf)->sv101_type & SV_TYPE_DOMAIN_BAKCTRL));

    g_fIsDC = (*pDC);
    g_fIsDCDecided = TRUE;
    NetApiBufferFree(pBuf);

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRegAccount::GetMachineAccountCredentialsOnDC(
        LPWSTR   szAccount,
        DWORD    dwAccSize,
        LPWSTR   szPassword,
        DWORD    dwPassSize,
        LPBOOL   pfNetworkService)
{
    if (szAccount == NULL || dwAccSize < 30 || dwAccSize > 1000000 || 
        szPassword == NULL || dwPassSize == 0 || dwPassSize > 1000000 || 
        pfNetworkService == NULL)
    {
        return E_INVALIDARG;
    }
    // Try Network service
    HRESULT             hr     = S_OK;
    IMSAdminBase *      pAdmin = NULL;
    METADATA_HANDLE     hMetaData = NULL;
    METADATA_RECORD     recMetaData;
    PSID                pSid     = NULL;
    BOOL                fWellKnown = FALSE;

    hr = GetPrincipalSID(L"NT AUTHORITY\\NetworkService", &pSid, &fWellKnown);
    if (hr == S_OK)
    {
        if (fWellKnown && pSid != NULL)
            FreeSid(pSid);
        else
            DELETE_BYTES(pSid);        
        (*pfNetworkService) = TRUE;
        if (dwAccSize > (DWORD) lstrlenW(L"NT AUTHORITY\\NetworkService") && dwPassSize > 0)
        {
            StringCchCopy(szAccount, dwAccSize, L"NT AUTHORITY\\NetworkService");
            XspSecureZeroMemory(szPassword, (dwPassSize - 1) * sizeof(WCHAR));
            EXIT();
        }
        EXIT_WITH_WIN32_ERROR(ERROR_INSUFFICIENT_BUFFER);
    }

    (*pfNetworkService) = FALSE;

    hr = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_ALL, 
                          IID_IMSAdminBase, (VOID **) &pAdmin);
    ON_ERROR_EXIT();
    hr = pAdmin->OpenKey(METADATA_MASTER_ROOT_HANDLE, KEY_LMW3SVC, 
                         METADATA_PERMISSION_READ, METABASE_REQUEST_TIMEOUT, &hMetaData);
    ON_ERROR_EXIT();

    ZeroMemory(&recMetaData, sizeof(recMetaData));
    hr = GetStringProperty(pAdmin, hMetaData, L"/", MD_WAM_USER_NAME, &recMetaData);
    ON_ERROR_EXIT();
    if (recMetaData.pbMDData == NULL)
        EXIT_WITH_HRESULT(E_UNEXPECTED);
    if ((DWORD) lstrlenW((LPCWSTR)recMetaData.pbMDData) < dwAccSize)
    {
        StringCchCopy(szAccount, dwAccSize, (LPCWSTR) recMetaData.pbMDData);
        delete [] recMetaData.pbMDData;
    }
    else
    {
        delete [] recMetaData.pbMDData;
        EXIT_WITH_WIN32_ERROR(ERROR_INSUFFICIENT_BUFFER);
    }

    if (wcschr(szAccount, L'\\') == NULL)
    {
        DS_DOMAIN_TRUSTS * pDomains      = NULL;
        ULONG             lCount         = 0;
        BOOL              fAddedDomain   = FALSE;
        WCHAR             szAll[256];

        if (DsEnumerateDomainTrusts(NULL, DS_DOMAIN_PRIMARY, &pDomains, &lCount) == NO_ERROR && pDomains != NULL)
        {
            if (lCount > 0)
            {
                DWORD dwLen = lstrlenW(pDomains->NetbiosDomainName) + lstrlenW(szAccount) + 1;

                if (dwLen < dwAccSize && dwLen < 256)
                {
                    StringCchCopyToArrayW(szAll, pDomains->NetbiosDomainName);
                    StringCchCatToArrayW(szAll, L"\\");
                    StringCchCatToArrayW(szAll, szAccount);
                    StringCchCopy(szAccount, dwAccSize, szAll);
                    fAddedDomain = TRUE;
                }
            }
            NetApiBufferFree(pDomains);
        }
        if (!fAddedDomain)
        {
            StringCchCopyToArrayW(szAll, L".\\");
            StringCchCatToArrayW(szAll, szAccount);
            StringCchCopy(szAccount, dwAccSize, szAll);
        }
    }


    ZeroMemory(&recMetaData, sizeof(recMetaData));
    hr = GetStringProperty(pAdmin, hMetaData, L"/", MD_WAM_PWD, &recMetaData);
    ON_ERROR_EXIT();
    if (recMetaData.pbMDData == NULL)
        EXIT_WITH_HRESULT(E_UNEXPECTED);
    if ((DWORD) lstrlenW((LPCWSTR)recMetaData.pbMDData) < dwPassSize)
    {
        StringCchCopy(szPassword, dwPassSize, (LPCWSTR)recMetaData.pbMDData);
        delete [] recMetaData.pbMDData;
    }
    else
    {
        delete [] recMetaData.pbMDData;
        EXIT_WITH_WIN32_ERROR(ERROR_INSUFFICIENT_BUFFER);
    }

 Cleanup:
    if (hMetaData != NULL && pAdmin != NULL)
        pAdmin->CloseKey(hMetaData);
    if (pAdmin != NULL)
        pAdmin->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////// Copied from http://swiweb/Resources/RandPwd/GoodPassword.htm ///////

// password categories
enum 
{
    STRONG_PWD_UPPER  = 0, 
    STRONG_PWD_LOWER  = 1, 
    STRONG_PWD_NUM    = 2, 
    STRONG_PWD_PUNC   = 3
};

#define STRONG_PWD_CATS (STRONG_PWD_PUNC + 1)
#define NUM_LETTERS  26
#define NUM_DIGITS   10
#define MIN_PWD_LEN   8
#define NUM_PUNC     32

WCHAR  szPunc      [NUM_PUNC+1]     = L"!@#$%^&*()_-+=[{]};:\'\"<>,./?\\|~`";
WCHAR  szDigits    [NUM_DIGITS+1]   = L"0123456789";
WCHAR  szUpLetters [NUM_LETTERS+1]  = L"ABCDEFGHIJKLMNOPQRSTUVWXYZ";
WCHAR  szLowLetters[NUM_LETTERS+1]  = L"abcdefghijklmnopqrstuvwxyz";

// password must contain at least one each of: 
// uppercase, lowercase, punctuation and numbers
HRESULT
CRegAccount::CreateGoodPassword(
        LPWSTR  szPwd, 
        DWORD   dwLen) 
{
    if (dwLen < MIN_PWD_LEN+1 || szPwd == NULL)
        return E_INVALIDARG;

    HCRYPTPROV    hProv                         = NULL;
    HRESULT       hr                            = S_OK; 
    DWORD         iter                          = 0;
    LPBYTE        pPwdPattern                   = new (NewClear) BYTE[dwLen];
    LPBYTE        pPwdBytes                     = new (NewClear) BYTE[dwLen];
    BOOL          fFound[STRONG_PWD_CATS];

    ON_OOM_EXIT(pPwdPattern);
    ON_OOM_EXIT(pPwdBytes);

    if (CryptAcquireContext(&hProv,NULL,NULL,PROV_RSA_FULL,CRYPT_VERIFYCONTEXT) == FALSE) 
        EXIT_WITH_LAST_ERROR();

    // zero it out and decrement the size to allow for trailing '\0'
    ZeroMemory(szPwd, dwLen * sizeof(WCHAR));
    dwLen--;
    
    // generate a pwd pattern, each byte is in the range 
    // (0..255) mod STRONG_PWD_CATS
    // this indicates which character pool to take a char from
    do 
    {
        ZeroMemory(fFound, sizeof(fFound));

        if (!CryptGenRandom(hProv, dwLen, pPwdPattern))
            EXIT_WITH_LAST_ERROR();
       
        for (iter=0; iter<dwLen; iter++) 
            fFound[pPwdPattern[iter] % STRONG_PWD_CATS] = TRUE;

        // check that each character category is in the pattern
    } while (!(fFound[STRONG_PWD_UPPER] && fFound[STRONG_PWD_LOWER] && fFound[STRONG_PWD_PUNC] && fFound[STRONG_PWD_NUM]));

    // populate password with random data 
    // this, in conjunction with pPwdPattern, is
    // used to determine the actual data
    if (!CryptGenRandom(hProv, dwLen, pPwdBytes))
        EXIT_WITH_LAST_ERROR();

    for (iter=0; iter<dwLen; iter++) 
    { 
        // there is a bias in each character pool because of the % function
        switch (pPwdPattern[iter] % STRONG_PWD_CATS)
        {
        case STRONG_PWD_UPPER: 
            szPwd[iter] = szUpLetters[pPwdBytes[iter] % NUM_LETTERS];
            break;

        case STRONG_PWD_LOWER: 
            szPwd[iter] = szLowLetters[pPwdBytes[iter] % NUM_LETTERS];
            break;

        case STRONG_PWD_NUM:   
            szPwd[iter] = szDigits[pPwdBytes[iter] % NUM_DIGITS];
            break;

        case STRONG_PWD_PUNC:
            szPwd[iter] = szPunc[pPwdBytes[iter] % NUM_PUNC];
            break;
        default: 
            EXIT_WITH_HRESULT(E_UNEXPECTED);
        }
    }

 Cleanup:
    delete [] pPwdPattern;
    delete [] pPwdBytes;
    if (hProv != NULL) 
        CryptReleaseContext(hProv,0);

    return hr;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
HRESULT
CRegAccount::AddAccessToPassportRegKey(
        PSID   pSid)
{
    HKEY                   hKey      = NULL;
    HRESULT                hr        = S_OK;
    DWORD                  dwErr     = 0;
    DWORD                  dwSize    = 0;
    PSECURITY_DESCRIPTOR   pSDSelf   = NULL;
    SECURITY_DESCRIPTOR    sd;
    PACL                   pACLNewTemp= NULL;
    PACL                   pACLNew   = NULL;
    PACL                   pACLOrig  = NULL;
    BOOL                   fRet      = FALSE;
    BOOL                   fPresent  = FALSE;
    BOOL                   fDefault  = FALSE;
    PEXPLICIT_ACCESS       pExp      = NULL;

    //////////////////////////////////////////////////////////////////
    // Step 1: Open the key
    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Passport\\KeyData", 
                         0, KEY_ALL_ACCESS, &hKey);
    if (dwErr != ERROR_SUCCESS)
        EXIT_WITH_WIN32_ERROR(dwErr);    

    //////////////////////////////////////////////////////////////////
    // Step 2: Get the security-decriptor of the key
    pSDSelf = (PSECURITY_DESCRIPTOR) NEW_CLEAR_BYTES(dwSize = 1000);
    ON_OOM_EXIT(pSDSelf);

    dwErr = RegGetKeySecurity(hKey, DACL_SECURITY_INFORMATION, pSDSelf, &dwSize);
    if (dwErr == ERROR_INSUFFICIENT_BUFFER)
    {
        DELETE_BYTES(pSDSelf);
        pSDSelf = (PSECURITY_DESCRIPTOR) NEW_CLEAR_BYTES(dwSize);
        ON_OOM_EXIT(pSDSelf);
        dwErr = RegGetKeySecurity(hKey, DACL_SECURITY_INFORMATION, pSDSelf, &dwSize);
    }
    if (dwErr != ERROR_SUCCESS)
        EXIT_WITH_WIN32_ERROR(dwErr);    

    //////////////////////////////////////////////////////////////////
    // Step 3: Get the DACL from the security descriptor
    dwSize = GetSecurityDescriptorLength(pSDSelf);
    ON_ZERO_EXIT_WITH_LAST_ERROR(dwSize);
        
    fRet = GetSecurityDescriptorDacl(pSDSelf, &fPresent, &pACLOrig, &fDefault);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

    if (fPresent && pACLOrig == NULL)
        EXIT();

    if (DoesAccessExist(pACLOrig, pSid, KEY_READ) == S_OK)
    {
        EXIT();
    }

    //////////////////////////////////////////////////////////////////
    // Step 4: Add access for the pSid to the DACL 
    pACLNewTemp =  (PACL) NEW_CLEAR_BYTES(100);
    ON_OOM_EXIT(pACLNewTemp);

    fRet = InitializeAcl(pACLNewTemp, 100, ACL_REVISION);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

    hr = AddAccess(pACLNewTemp, pSid, KEY_READ, NULL);
    ON_ERROR_EXIT();

    dwErr = GetExplicitEntriesFromAcl(pACLNewTemp, &dwSize, &pExp);
    if (dwErr != ERROR_SUCCESS)
        EXIT_WITH_WIN32_ERROR(dwErr);    
    ASSERT(dwSize == 1);
    dwErr = SetEntriesInAcl(dwSize, pExp, pACLOrig, &pACLNew);
    if (dwErr != ERROR_SUCCESS)
        EXIT_WITH_WIN32_ERROR(dwErr);    

    //////////////////////////////////////////////////////////////////
    // Step 5: Create new seciurity descriptor in Absolute format
    if(!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
        EXIT_WITH_LAST_ERROR();

    if(!SetSecurityDescriptorDacl(&sd, TRUE, pACLNew, FALSE))
        EXIT_WITH_LAST_ERROR();
    
    //////////////////////////////////////////////////////////////////
    // Step 7: Change the reg security
    dwErr = RegSetKeySecurity(hKey, DACL_SECURITY_INFORMATION, &sd);
    if (dwErr != ERROR_SUCCESS)
        EXIT_WITH_WIN32_ERROR(dwErr);        

 Cleanup:
    if (hKey != NULL)
        RegCloseKey(hKey);
    if (pSDSelf != NULL)
        DELETE_BYTES(pSDSelf);
    if (pACLNewTemp != NULL)
        DELETE_BYTES(pACLNewTemp);
    if (pACLNew != NULL)
        LocalFree(pACLNew);
    if (pExp != NULL)
        LocalFree(pExp);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\regaccount.h ===
/**
 * RegAccount header file
 *
 * Copyright (c) 2001 Microsoft Corporation
 */

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _RegAccount_H
#define _RegAccount_H

#include "Ntsecapi.h"
typedef PVOID SAM_HANDLE, *PSAM_HANDLE;  // ntsubauth

#define USERNAME_PASSWORD_LENGTH 104

extern WCHAR  g_szMachineAccountName[100];

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CRegAccount
{
public:    
    static HRESULT     DoReg                     ();
    static HRESULT     DoRegForOldVersion        ();
    static HRESULT     UndoReg                   (BOOL fRemoveAll, BOOL fEmpty);
    static HANDLE      CreateWorkerProcessToken  (WCHAR * szUser, WCHAR * szPass, PSID * ppSid);
    static HRESULT     AddAccess                 (PACL pAcl, PSID pSid, DWORD dwAccess, LPBOOL pIfDoNothing);
    static HRESULT     CreateTempDir             ();

    static HRESULT     GetPrincipalSID           (LPCTSTR Principal, PSID * Sid, BOOL * pbWellKnownSID);
    static HRESULT     CopyACL                   (PACL pDest, PACL pSrc);
    static HRESULT     AddSidToToken             (HANDLE hToken, PSID pSid, LPBOOL pfAlreadyPresent);

    static HRESULT     GetStateServerAccCredentials ( LPWSTR   szName,
                                                      int      iNameSize,
                                                      LPWSTR   szPass,
                                                      int      iPassSize);
        
private:
    static HRESULT     GetAccountPasswordFromLSA (LPWSTR szRet, int iSize);

    static HRESULT
    RemoveReg(
            LPCWSTR szUser,
            BOOL    fEmpty);

    static HRESULT
    StoreAccountPasswordInLSA (
            LPCWSTR szPass);
    
    static HRESULT
    RemoveACL(
            PACL pAcl, 
            PSID pSid);

    static HRESULT 
    GetTempDir(
            LPWSTR szDir,
            int    iSize,
            BOOL   fCreateIfNotExists);

    static HRESULT 
    SetACLOnDir(
            PSID        pSid,
            LPCWSTR     szDir,
            DWORD       dwAccessMask,
            BOOL        fAddAccess);

    static HRESULT
    ACLAllDirs(
        PSID    pSid,
        BOOL    fReg,
        BOOL    fEmpty);

    static void
    InitStrings();

    static HRESULT
    CreateGoodPassword(
            LPWSTR  szPwd, 
            DWORD   dwLen);


    static HRESULT 
    CreateUser( 
            LPCTSTR szUsername,
            LPCTSTR szPassword,
            LPCTSTR szComment,
            LPCTSTR szFullName,
            PSID *  ppSid,
            BOOL *  pfWellKnown);

    static HRESULT 
    GetGuestUserNameForDomain_FastWay(
            LPTSTR szDomainToLookUp,
            LPTSTR lpGuestUsrName);

    static HRESULT 
    GetGuestUserName_SlowWay(
            LPWSTR lpGuestUsrName);
    static HRESULT 
    GetGuestUserName(
            LPTSTR lpOutGuestUsrName);

    static HRESULT 
    GetGuestGrpName(
            LPTSTR lpGuestGrpName);

    static HRESULT 
    RegisterAccountToLocalGroup(
            LPCTSTR szAccountName,
            LPCTSTR szLocalGroupName,
            BOOL    fAction,
            PSID    pSid);

    static HRESULT 
    RegisterAccountUserRights(
            BOOL    fAction,
            PSID    pSid);

    static HRESULT 
    RegisterAccountDisableLogonToTerminalServer();


    static HRESULT
    ChangeUserPassword(
            LPTSTR szUserName, 
            LPTSTR szNewPassword);

    static void 
    InitLsaString(
            PLSA_UNICODE_STRING  LsaString,
            LPWSTR               str);

    static DWORD
    OpenPolicy(
            LPTSTR ServerName,
            DWORD DesiredAccess,
            PLSA_HANDLE PolicyHandle);

    static HRESULT
    RemoveAccountFromRegistry(
            LPCWSTR szUser);
    
    static HRESULT
    AddAccountToRegistry(
            LPCWSTR szUser);
    
    static HRESULT
    OpenRegistryKey(
            DWORD   dwAccess, 
            HKEY *  hKey);

    static HRESULT
    DoesAccessExist(
            PACL    pAcl, 
            PSID    pSid, 
            DWORD   dwAccess);
    
    static HRESULT
    GetUsersGroupName(
            LPWSTR szName,
            DWORD  iNameSize);
    static HRESULT
    EnableUserAccount(
            LPCWSTR  szUser,
            BOOL     fEnable);

    static HRESULT
    IsDomainController(
            LPBOOL   pDC);


    static HRESULT
    GetMachineAccountCredentialsOnDC(
            LPWSTR   szAccount,
            DWORD    dwAccSize,
            LPWSTR   szPassword,
            DWORD    dwPassSize,
            LPBOOL   pfNetworkService);

    static void
    GetAccountNameFromResourceFile(
            LPWSTR szFullName, 
            DWORD  dwFullName,
            LPWSTR szDesciption, 
            DWORD  dwDesciption);

    static HRESULT
    ACLWinntTempDir(
            PSID   pSid,
            BOOL   fAdd);

    static HRESULT
    AddAccessToPassportRegKey(
            PSID   pSid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\regiisutil.cxx ===
/**
 * Regiisutil.cxx
 * 
 * Helper class for regiis.cxx
 * 
 * Copyright (c) 2002, Microsoft Corporation
 * 
 */

#include "precomp.h"
#include "_ndll.h"
#include <iadmw.h>
#include <iiscnfg.h>
#include "regiis.h"
#include "register.h"
#include "regiisutil.h"
#include "ary.h"
#include "hashtable.h"
#include "event.h"
#include "aspnetver.h"
#include "ciisinfo.h"
#include "platform_apis.h"


//
// !! Note: If you new add extensions to the table below, you must
//          also update XSP_SUPPORTED_EXTS in names.h
//  
SCRIPTMAP_PREFIX g_scriptMapPrefixes[] = {
    { L".asax,",        TRUE },
    { L".ascx,",        TRUE }, 
    { L".ashx,",        FALSE },
    { L".asmx,",        FALSE },
    { L".aspx,",        FALSE },
    { L".axd,",         FALSE },
    { L".vsdisco,",     FALSE },
    { L".rem,",         FALSE },
    { L".soap,",        FALSE },
    { L".config,",      TRUE },
    { L".cs,",          TRUE },
    { L".csproj,",      TRUE },
    { L".vb,",          TRUE },
    { L".vbproj,",      TRUE },
    { L".webinfo,",     TRUE },
    { L".licx,",        TRUE },
    { L".resx,",        TRUE },
    { L".resources,",   TRUE }
};



/////////////////////////////////////////////////////////////////
// Class SCRIPTMAP_REGISTER_MANAGER
/////////////////////////////////////////////////////////////////


void DllToVerCleanup(void *pValue, void * pArgument) {
    delete ((ASPNETVER*)pValue);
}

void CompResCleanup(void *pValue, void * pArgument) {
    delete ((EXTS_COMPARISON_RESULT*)pValue);
}

SCRIPTMAP_REGISTER_MANAGER::SCRIPTMAP_REGISTER_MANAGER()
{
    m_fInited = FALSE;
}


SCRIPTMAP_REGISTER_MANAGER::~SCRIPTMAP_REGISTER_MANAGER()
{
    if (!m_fInited) {
        return;
    }

    // Cleanup the hashtables
    m_htDllToVer.Enumerate(DllToVerCleanup, NULL);
    m_htCompRes.Enumerate(CompResCleanup, NULL);
}

HRESULT
SCRIPTMAP_REGISTER_MANAGER::Init()
{
    HRESULT hr = S_OK;

    hr = m_htDllToVer.Init(4);
    ON_ERROR_EXIT();

    hr = m_htCompRes.Init(4);
    ON_ERROR_EXIT();

    m_fInited = TRUE;
Cleanup:
    
    return hr;
}


long
SCRIPTMAP_REGISTER_MANAGER::HashFromString(const WCHAR *pchStr) {
    long    hash = 0;

    for(; *pchStr != '\0'; pchStr++) {
        hash += (long)(*pchStr);
    }

    return hash;
}


/**
 *  Find the version of a DLL. It will look into its hashtable first.
 *
 *  Parameters:
 *  pchDll      The DLL we are interested in
 *  pVer        Returned value
 */
HRESULT
SCRIPTMAP_REGISTER_MANAGER::FindDllVer(const WCHAR *pchDll, ASPNETVER *pVer) {
    HRESULT             hr = S_OK;
    void *              pHolder = NULL;
    ASPNETVER *         pVerNew = NULL;
    int                 keyLen;
    long                keyHash;
    
    if (!m_fInited) {
        hr = Init();
        ON_ERROR_EXIT();
    }

    // If the version equals this version, it's easy
    if (_wcsicmp(pchDll, Names::IsapiFullPath()) == 0) {
        *pVer = ASPNETVER::ThisVer();
        ASSERT(pVer->IsValid());
        EXIT();
    }

    keyLen = lstrlenW(pchDll) * sizeof(WCHAR);
    keyHash = HashFromString(pchDll);

    // Find it in the hashtable    
    hr = m_htDllToVer.Find((BYTE*)pchDll, keyLen, keyHash, &pHolder);
    if (hr == S_OK) {
        *pVer = *((ASPNETVER*) pHolder);
    }
    else {
        VS_FIXEDFILEINFO    info;
        
        // Not found.  Read it from the file system.
        hr = GetFileVersion(pchDll, &info);
        if (hr) {
            // Always return ERROR_FILE_NOT_FOUND if we fail to get the file version
            // See URT 128253
            EXIT_WITH_WIN32_ERROR(ERROR_FILE_NOT_FOUND);
        }

        pVer->Init(&info);
        ASSERT(pVer->IsValid());

        // Save it in the hashtable
        pVerNew = new ASPNETVER;
        *pVerNew = *pVer;
        
        hr = m_htDllToVer.Insert((BYTE*)pchDll, keyLen, keyHash, pVerNew);
        ON_ERROR_EXIT();

        pVerNew = NULL;
    }

Cleanup:
    delete pVerNew;
    return hr;
}

void
SCRIPTMAP_REGISTER_MANAGER::GetCompareKey(
            ASPNETVER *pVerFrom, ASPNETVER *pVerTo, WCHAR pchKey[], DWORD count)
{
    DWORD iEnd;
    
    ZeroMemory(pchKey, sizeof(WCHAR)*count);
    pVerFrom->ToString(pchKey, count-1);

    iEnd = lstrlenW(pchKey);
    // Assuming 4 digits per ver number, max length of a version string is 19
    ASSERT(iEnd + 1 + 19 + 1 <= count);
    pchKey[iEnd++] = ':';
    
    pVerTo->ToString(&(pchKey[iEnd]), count-iEnd-1);
}

HRESULT
SCRIPTMAP_REGISTER_MANAGER::CompareExtensions(
                    ASPNETVER *pVerFrom, ASPNETVER *pVerTo, 
                    EXTS_COMPARISON_RESULT **ppRes) 
{
    HRESULT     hr = S_OK;
    WCHAR       szKey[100];
    int         keyLen;
    long        keyHash;
    void *      pHolder;
    
    EXTS_COMPARISON_RESULT  *pRes = NULL;

    *ppRes = NULL;
    
    GetCompareKey(pVerFrom, pVerTo, szKey, ARRAY_SIZE(szKey));
    
    keyLen = lstrlenW(szKey)*sizeof(WCHAR);
    keyHash = HashFromString(szKey);
    
    hr = m_htCompRes.Find((BYTE*)szKey, keyLen, keyHash, &pHolder);
    if (hr == S_OK) {
        *ppRes = (EXTS_COMPARISON_RESULT*)pHolder;
    }
    else {
        pRes = new EXTS_COMPARISON_RESULT;
        ON_OOM_EXIT(pRes);

        hr = pRes->Compare(pVerFrom, pVerTo);
        ON_ERROR_EXIT();

        hr = m_htCompRes.Insert((BYTE*)szKey, keyLen, keyHash, (void *)pRes);
        ON_ERROR_EXIT();

        *ppRes = pRes;
        pRes = NULL;
    }

Cleanup:
    delete pRes;
    return hr;
}


HRESULT
SCRIPTMAP_REGISTER_MANAGER::UpdateScriptmapString(WCHAR **pmsOrg, EXTS_COMPARISON_RESULT *pCompRes,
                                    const WCHAR *pchDllFrom, const WCHAR *pchDllTo)
{
    HRESULT     hr = S_OK;
    CSMPrefixAry *  pary;
    int         iCur;
    BOOL        fEmpty;
    WCHAR *     pchAppend = NULL;
    SCRIPTMAP_PREFIX  * psmprefix;

    // Step 1: Convert all occurence of old aspnet dll to new dll
    hr = ReplaceStringInMultiString(pmsOrg, pchDllFrom, pchDllTo);
    ON_ERROR_EXIT();
    
    // Step 2: Go thru each entry in the new scriptmap,
    // and remove obsolete extensions

    // Get the obsolete extensions.  Please note that in this
    // version the string include both the extension and the
    // forbidden flag
    pary = pCompRes->ObsoleteExts();

    for(iCur=0; iCur < pary->Size(); iCur++) {
        psmprefix = (*pary)[iCur];
        
        // Now remove the obsolete extension from pchSM
        RemoveStringFromMultiString(*pmsOrg, psmprefix->wszExt, MULTISZ_MATCHING_PREFIX, &fEmpty);
    }

    // Step 3: Add new extensions
    pary = pCompRes->NewExts();

    for(iCur=0; iCur < pary->Size(); iCur++) {
        WCHAR * pchSuffix;
        int     lenAppend, len;
        
        psmprefix = (*pary)[iCur];
        
        // For extensions that map to Forbidden handler, we also add
        // MD_SCRIPTMAPFLAG_CHECK_PATH_INFO to the flag embedded in the config
        // string
        if (GetCurrentPlatform() == APSX_PLATFORM_W2K) {
            pchSuffix = psmprefix->bForbidden ? 
                            SCRIPT_MAP_SUFFIX_W2K_FORBIDDEN : SCRIPT_MAP_SUFFIX_W2K;
        }
        else {
            pchSuffix = psmprefix->bForbidden ? 
                            SCRIPT_MAP_SUFFIX_NT4_FORBIDDEN : SCRIPT_MAP_SUFFIX_NT4;
        }

        lenAppend = lstrlenW(pchDllTo) + lstrlenW(pchSuffix);
    
        len = lenAppend + lstrlenW(psmprefix->wszExt);
        WCHAR * pchRealloc = new(pchAppend, NewReAlloc) WCHAR[len + 1];
        ON_OOM_EXIT(pchRealloc);
        pchAppend = pchRealloc;

        StringCchCopyW(pchAppend, len+1, psmprefix->wszExt);
        StringCchCatW(pchAppend, len+1, pchDllTo);
        StringCchCatW(pchAppend, len+1, pchSuffix);

        hr = AppendStringToMultiString(pmsOrg, pchAppend);
        ON_ERROR_EXIT();
    }
    
Cleanup:
    delete [] pchAppend;
    return hr;
}

//
// If verFrom is v1 (3705), we need to add MD_SCRIPTMAPFLAG_CHECK_PATH_INFO to
// the third argument for those extensions which mapped to Forbidden handler
//
HRESULT
SCRIPTMAP_REGISTER_MANAGER::FixForbiddenHandlerForV1(ASPNETVER *pverFrom, WCHAR *pData)
{
    HRESULT                 hr = S_OK;
    ASPNETVER               v1(ASPNET_V1);
    WCHAR                   *pchCur;
    WCHAR *                 v1ForbiddenExts[] = {
                                L".asax,",
                                L".ascx,",
                                L".config,",
                                L".cs,",
                                L".csproj,",
                                L".vb,",
                                L".vbproj,",
                                L".webinfo,",
                                L".licx,",
                                L".resx,",
                                L".resources,"
                            };

    if (*pverFrom != v1) {
        // Skip if we're not migrating from v1
        EXIT();
    }

    // Loop thru each string in the multiSz property.  If the string contains the
    // forbidden extension, make sure MD_SCRIPTMAPFLAG_CHECK_PATH_INFO is added
    // to the flag field.
    pchCur = pData;
    do {
        int len = lstrlenW(pchCur) + 1;

        for (int i=0; i < ARRAY_SIZE(v1ForbiddenExts); i++) {
            if (_wcsnicmp(pchCur,  v1ForbiddenExts[i], lstrlenW(v1ForbiddenExts[i])) == 0) {
                WCHAR *pchFlag = pchCur;

                pchFlag += lstrlenW(v1ForbiddenExts[i]);    

                // We now point to the isapi path.  Skip it.
                while(*pchFlag != ',' && *pchFlag != NULL) {
                    pchFlag++;
                }

                if (*pchFlag == ',') {
                    // The next character is the flag we want to change
                    pchFlag++;

                    // Since IIS only has two flags, 0x1 and 0x4, we will take
                    // a simpler approach.
                    if (wcsncmp(pchFlag, L"0,", 2) == 0) {      // No Flag
                        // Add MD_SCRIPTMAPFLAG_CHECK_PATH_INFO
                        *pchFlag = '4';         
                    } else if (wcsncmp(pchFlag, L"1,", 2) == 0) {   // Only MD_SCRIPTMAPFLAG_SCRIPT
                        // Add MD_SCRIPTMAPFLAG_CHECK_PATH_INFO
                        *pchFlag = '5';         
                    }
                }

                break;
            }
        }
        
        pchCur += len;
    } while (*pchCur != L'\0');
    

Cleanup:
    return hr;
}

/**
 *  Convert the scriptmap of a specific key from one DLL to another DLL
 *
 *  Parameters:
 *  pchDllFrom
 *  pchDllTo
 *  pchKey
 */
HRESULT 
SCRIPTMAP_REGISTER_MANAGER::ChangeVersion( IMSAdminBase *pAdmin, METADATA_HANDLE keyHandle, 
                        const WCHAR *pchKey, const WCHAR *pchDllFrom, const WCHAR *pchDllTo )
{
    HRESULT                 hr = S_OK;
    ASPNETVER               verFrom, verTo;
    EXTS_COMPARISON_RESULT *pCompRes;
    METADATA_RECORD         md;
    WCHAR  *                pData = NULL;
        
    if (!m_fInited) {
        hr = Init();
        ON_ERROR_EXIT();
    }

    // Find out the versions of the two DLLs
    hr = FindDllVer(pchDllFrom, &verFrom);
    ON_ERROR_EXIT();

    hr = FindDllVer(pchDllTo, &verTo);
    ON_ERROR_EXIT();

    // Find out the delta between the two sets of supported extensions
    hr = CompareExtensions(&verFrom, &verTo, &pCompRes);
    ON_ERROR_EXIT();

    // Read the scriptmap property at the key
    hr = GetMultiStringProperty(pAdmin, keyHandle, (WCHAR*)pchKey, MD_SCRIPT_MAPS, &md);
    ON_ERROR_EXIT();

    pData = (WCHAR*) md.pbMDData;

    // Update the scriptmap property (multistring) based on the comparison result
    hr = UpdateScriptmapString(&pData, pCompRes, pchDllFrom, pchDllTo);
    ON_ERROR_EXIT();

    // If verFrom is v1 (3705), we need to add MD_SCRIPTMAPFLAG_CHECK_PATH_INFO to
    // the third argument for those extensions which mapped to Forbidden handler
    hr = FixForbiddenHandlerForV1(&verFrom, pData);
    ON_ERROR_EXIT();

    // Set the updated property on the key

    // copy terminating null
    md.pbMDData = (unsigned char*) pData;
    md.dwMDDataLen = (wcslenms(pData) + 1) * sizeof(pData[0]);
    hr = pAdmin->SetData(keyHandle, pchKey, &md);
    ON_ERROR_EXIT();
    
Cleanup:
    delete [] pData;
    return hr;
}


HRESULT
SCRIPTMAP_REGISTER_MANAGER::CleanInstall(IMSAdminBase *pAdmin, METADATA_HANDLE keyHandle, 
                                const WCHAR *pchKey, const WCHAR *pchDll, BOOL fRemoveFirst)
{
    HRESULT hr = S_OK;
    
    // First remove aspnet dll if exist.
    if (fRemoveFirst) {
        hr = RemoveAspnetDllFromMulti(pAdmin, keyHandle, MD_SCRIPT_MAPS, pchKey);
        ON_ERROR_EXIT();
    }

    hr = WriteAspnetDllOnOneScriptMap(pAdmin, keyHandle, pchKey, pchDll);
    ON_ERROR_EXIT();

Cleanup:
    return hr;
}




/////////////////////////////////////////////////////////////////
// Class EXTS_COMPARISON_RESULT
/////////////////////////////////////////////////////////////////


void
CleanupCSMPrefixAry(CSMPrefixAry *pary) {
    int i;
    
    for (i = 0; i < pary->Size(); i++) {
        SCRIPTMAP_PREFIX *  p = (*pary)[i];

        delete p->wszExt;
        delete p;
    }
    
    pary->DeleteAll();
}


EXTS_COMPARISON_RESULT::~EXTS_COMPARISON_RESULT() {
    CleanupCSMPrefixAry(&m_aryObsoleteExts);
    CleanupCSMPrefixAry(&m_aryNewExts);
}

HRESULT
EXTS_COMPARISON_RESULT::GetExtsFromRegistry(ASPNETVER *pVer, WCHAR ** ppchExts)
{
    HRESULT hr = S_OK;
    WCHAR   sSubkey[MAX_PATH];
    HKEY    hSubkey = NULL;

    *ppchExts = NULL;

    // Read SupportedExts from the registry
    hr = CRegInfo::OpenVersionKey(pVer, sSubkey, ARRAY_SIZE(sSubkey), &hSubkey);
    ON_ERROR_EXIT();
    
    hr = CRegInfo::ReadRegValue(hSubkey, sSubkey, REGVAL_SUPPORTED_EXTS, ppchExts);
    ON_ERROR_EXIT();
    
Cleanup:
    if (hSubkey)
        RegCloseKey(hSubkey);

    return hr;
}


/**
 *  Compare pchExts1 and pchExts2, and find out what extensions are excluded in pchExts2.
 *  All excluded extensions are added to pcsExcluded
 */
HRESULT
EXTS_COMPARISON_RESULT::FindExcludedExts(WCHAR *pchExts1, WCHAR *pchExts2, CSMPrefixAry *paryExcluded)
{
    HRESULT     hr = S_OK;
    WCHAR *     pchCur;
    WCHAR *     pchRealExt = NULL;
    SCRIPTMAP_PREFIX  * pSMPrefix = NULL;

    // Enumerate all extensions in pchExts1, and for each, see if
    // it's included in pchExts2
    for(pchCur = pchExts1; *pchCur != '\0';) {
        WCHAR   szExt[128];
        int     iCur = 0;
        bool    fFirstCommaHit = FALSE;

        ZeroMemory(szExt, sizeof(szExt));

        // Read the current extension
        while(1) {
            // We shouldn't hit null before we hit ','
            if (*pchCur == '\0') {
                ASSERT(FALSE);
                EXIT_WITH_WIN32_ERROR(ERROR_INVALID_DATA);
            }
            
            szExt[iCur] = *pchCur;
            pchCur++;
            
            if (szExt[iCur] == ',') {
                if (fFirstCommaHit) {
                    break;
                }
                else {
                    fFirstCommaHit = TRUE;
                }
            }

            iCur++;
            
            if (iCur == sizeof(szExt)) {
                ASSERT(FALSE);
                EXIT_WITH_WIN32_ERROR(ERROR_INVALID_DATA);
            }
        }

        // We got the extension.  Let's find out if it's included in
        // the "To" version.
        if (wcsstr(pchExts2, szExt) == NULL) {
            BOOL    bForbidden;
            WCHAR * pchCur;
            
            // Skip the trailing forbidden flag
            pchRealExt = DupStr(szExt);
            ON_OOM_EXIT(pchRealExt);

            pchCur = pchRealExt; 
            while (*pchCur != L',' && *pchCur != L'\0') {
                pchCur++;
            }

            // We expect a comma before a NULL
            if (*pchCur == L'\0') {
                ASSERT(FALSE);
                EXIT_WITH_WIN32_ERROR(ERROR_INVALID_DATA);
            }

            // Find out if it's mapped to the forbidden handler
            pchCur++;
            ASSERT(*pchCur == L'0' || *pchCur == L'1');
            bForbidden = (*pchCur == L'1');

            // All we want is the extension part in pchRealExt
            *(pchCur) = L'\0';

            // Save the info about the extension
            pSMPrefix = new SCRIPTMAP_PREFIX;
            ON_OOM_EXIT(pSMPrefix);

            pSMPrefix->wszExt = pchRealExt;
            pSMPrefix->bForbidden = bForbidden;
            
            hr = paryExcluded->Append(pSMPrefix);
            ON_ERROR_EXIT();

            pSMPrefix = NULL;
            pchRealExt = NULL;
        }
    }

Cleanup:
    delete [] pchRealExt;
    delete pSMPrefix;
    
    return hr;
}

HRESULT 
EXTS_COMPARISON_RESULT::Compare(ASPNETVER *pVerFrom, ASPNETVER *pVerTo)
{
    HRESULT     hr = S_OK;
    WCHAR *     pchExtsFrom = NULL;
    WCHAR *     pchExtsFromAlloc = NULL;
    WCHAR *     pchExtsTo = NULL;
    WCHAR *     pchExtsToAlloc = NULL;
    
    // Consider: optimize the case where the two extension strings are identical
    
    // Read the extension strings from the registry
    hr = GetExtsFromRegistry(pVerFrom, &pchExtsFromAlloc);
    if (hr) {
        if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) ||
            hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) {
            // Not found.  Assume it's v1 or SP1
            pchExtsFrom = SUPPORTED_EXTS_v1;
            hr = S_OK;
        }
        else {
            ON_ERROR_EXIT();
        }
    }
    else {
        pchExtsFrom = pchExtsFromAlloc;
    }

    hr = GetExtsFromRegistry(pVerTo, &pchExtsToAlloc);
    if (hr) {
        if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) ||
            hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) {
            // Not found.  Assume it's v1 or SP1
            pchExtsTo = SUPPORTED_EXTS_v1;
            hr = S_OK;
        }
        else {
            ON_ERROR_EXIT();
        }
    }
    else {
        pchExtsTo = pchExtsToAlloc;
    }

    ASSERT(pchExtsFrom != NULL);
    ASSERT(pchExtsTo != NULL);

    // Find out what extension becomes obsolete
    hr = FindExcludedExts(pchExtsFrom, pchExtsTo, &m_aryObsoleteExts);
    ON_ERROR_EXIT();
    
    // Find out what new extensions are added in "To" by reversing the parameters
    hr = FindExcludedExts(pchExtsTo, pchExtsFrom, &m_aryNewExts);
    ON_ERROR_EXIT();
    
Cleanup:
    delete [] pchExtsFromAlloc;
    delete [] pchExtsToAlloc;
    
    return hr;
}


////////////////////////////////////////////////////////////
// Class SECURITY_PROP_MANAGER
////////////////////////////////////////////////////////////

//
// pchStr is an string from one of the following multi-string IIS metabase property:
// 1. ApplicationDependencies (format: AppName;GroupID,GroupID... )
// 2. WebSvcExtRestrictionList (format: AllowDenyFlag,ExtensionPhysicalPath,UIDeletableFlag,GroupID,Description)
//
// In either case, GroupID has this format "ASP.NET vX.X.XXXX".
// 
// So we'll look for "ASP.NET vX.X.XXXX" in pchStr, and if found:
// 
// If m_mode == SECURITY_CLEANUP_INVALID:
// Check our registry to see  if the version it points is installed and valid.
// If so, return FALSE because we want to preserve it.  If not, return TRUE so that our caller,
// RemoveStringFromMultiString(), will remove this entry from the property.
//
// If m_mode == SECURITY_CLEANUP_CURRENT:
// Check to see if it's the current version.  If so, return TRUE so that it can be
// removed.
//
// If m_mode == SECURITY_CLEANUP_ANY_VERSION:
// Just remove it.
// 

BOOL
SECURITY_PROP_MANAGER::SecurityDetectVersion(WCHAR *pchStr) {
    HRESULT hr = S_OK;
    WCHAR * pchDup = NULL;
    WCHAR * pchVer = NULL;
    WCHAR * pchToken;
    BOOL    fRemove = FALSE;    // Assume the version is good
    DWORD   dwMajor = 0, dwMinor = 0, dwBuild = 0;
    ASPNETVER   ver, verCur;

    // A token is valid if
    // 1. The token starts with "ASP.NET v"
    // 2. The remaining string has the format "x.x.x"
    #define GET_VERSION_FROM_TOKEN(x)   \
        (wcsncmp(x, IIS_GROUP_ID_PREFIX, IIS_GROUP_ID_PREFIX_LEN) == 0 &&   \
         swscanf(x, IIS_GROUP_ID_PREFIX L"%d.%d.%d", &dwMajor, &dwMinor, &dwBuild) == 3)

    // We need to modify the content of pchStr. So let's modify a copy of it instead.
    pchDup = DupStr(pchStr);
    ON_OOM_EXIT(pchDup);

    // Let's find the group id from the string.
    if (m_prop == MD_APP_DEPENDENCIES) {
        WCHAR * pchCur;

        // Format = AppName;GroupID,GroupID... 
        
        // The group id can be found after the first semi-colon.
        pchCur = wcschr(pchDup, L';');
        if (pchCur != NULL) {
            pchCur++;
            
            pchToken = wcstok(pchCur, L",");
            while(pchToken != NULL) {
                if (GET_VERSION_FROM_TOKEN(pchToken)) {
                    pchVer = pchToken;
                    break;
                }
                pchToken = wcstok(NULL, L",");
            }
        }
    }
    else {
        // Format = AllowDenyFlag,ExtensionPhysicalPath,UIDeletableFlag,GroupID,Description 
        
        // The group id is the 4th token
        int c = 4;

        pchToken = wcstok(pchDup, L",");
        while(pchToken != NULL) {
            if (--c == 0) {
                if (GET_VERSION_FROM_TOKEN(pchToken)) {
                    pchVer = pchToken;
                }
                break;
            }
            pchToken = wcstok(NULL, L",");
        }
    }

    if (pchVer == NULL) {
        // The group ID isn't found. Maybe it's not ours.
        // To be safe, don't remove it.
        fRemove = FALSE;
        EXIT();
    }

    ver.Init(dwMajor, dwMinor, dwBuild);

    if (m_mode == SECURITY_CLEANUP_INVALID) {
        //
        // Figure out if ver is valid or not.
        //
        
        // Initialize m_installedVersions on demand
        if (!m_finstalledVersionsInit) {
            CRegInfo    cinfo;
            
            // cinfo.GetVerInfoList will get us a list of all version installed
            // on this machine.
            hr = cinfo.GetVerInfoList(NULL, &m_installedVersions);
            ON_ERROR_EXIT();

            m_finstalledVersionsInit = TRUE;
        }

        for (int i=0; i < m_installedVersions.Size(); i++) {
            // Read the version from m_installedVersions and compare with ver
            // 1. If ver isn't found in m_installedVersions, this well-formed group id isn't 
            //    installed.  Remove it.
            // 2. If ver is found but m_installedVersions shows the DLL is missing, this 
            //    well-formed group id is not valid.  Remove it.
            // 3. Otherwise, it's a valid group id.  Don't remove it.

            verCur.Init(m_installedVersions.GetVersion(i));

            if (ver != verCur) {
                // Not the same version.  Skip.
                continue;
            }

            // Now check the status of verCur
            if ((m_installedVersions.GetStatus(i) & ASPNET_VERSION_STATUS_VALID) == 0) {
                // ver is found but m_installedVersions shows the DLL is missing, this well-formed group id
                // is not valid.  Remove it.
                fRemove = TRUE;
                EXIT();
            }

            // We know it's a good group id.  Don't remove it.
            fRemove = FALSE;
            EXIT();
        }

        // If we get here, it means the group id is well-formed but isn't found in m_installedVersions.
        // Remove it.
        fRemove = TRUE;
    }
    else if (m_mode == SECURITY_CLEANUP_CURRENT) {
        //
        // Figure out if ver == current version or not
        //
        if (ver == ASPNETVER::ThisVer()) {
            // Same version.  Remove it.
            fRemove = TRUE;
        }
        else {
            fRemove = FALSE;
        }
    }
    else {
        // Asking for all versions.  Since it's a well formed group-id, just remove it.
        fRemove = TRUE;
    }

Cleanup:
    delete [] pchDup;
    return fRemove;
}

//
// This function will remove certain asp.net entries in MD_APP_DEPENDENCIES and
// MD_WEB_SVC_EXT_RESTRICTION_LIST.  The type of entries we remove depends on "mode":
//
// If mode == SECURITY_CLEANUP_INVALID, we'll remove invalid entry.
// By invalid we mean entries that:
// 1. Has a group Group ID in the entry, and
// 2. We verify that the DLL it points to is invalid.
//
// If mode == SECURITY_CLEANUP_CURRENT, we will remove current version.
//
// If mode == SECURITY_CLEANUP_ANY_VERSION, we will remove all versions found.
//
HRESULT 
SECURITY_PROP_MANAGER::CleanupSecurityLockdown(SECURITY_CLEANUP_MODE mode)
{
    HRESULT         hr = S_OK;
    METADATA_HANDLE w3svc = NULL;
    METADATA_RECORD md;
    WCHAR       *   pchDup = NULL;
    WCHAR       *   msStr = NULL;
    DWORD           rgMDToCleanup[] = { MD_APP_DEPENDENCIES, MD_WEB_SVC_EXT_RESTRICTION_LIST };
    
    CSetupLogging::Log(1, "CleanupSecurityLockdown", 0, "Cleaning up security lockdown data in IIS metabase");        
    
    hr = m_pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            KEY_LMW3SVC,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &w3svc);
    ON_ERROR_EXIT();

    m_mode = mode;

    for (int i = 0; i < ARRAY_SIZE(rgMDToCleanup); i++) {
        m_prop = rgMDToCleanup[i];
        
        hr = GetMultiStringProperty(m_pAdmin, w3svc, L"/", m_prop, &md);
        if (hr && hr != HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND)) {
            ON_ERROR_EXIT();
        }

        if (hr == S_OK) {
            msStr = (WCHAR*)md.pbMDData;
            
            if (RemoveStringFromMultiStringEx(msStr, IIS_GROUP_ID_PREFIX_L, MULTISZ_MATCHING_ANY, NULL, this)) {
                // set the new value

                // copy terminating null
                md.pbMDData = (unsigned char*) msStr;
                md.dwMDDataLen = (wcslenms(msStr) + 1) * sizeof(msStr[0]);
                hr = m_pAdmin->SetData(w3svc, L"/", &md);
                ON_ERROR_EXIT();
            }

            delete [] msStr;
            msStr = NULL;
        }
        
        hr = S_OK;
    }

Cleanup:
    CSetupLogging::Log(hr, "CleanupSecurityLockdown", 0, "Cleaning up security lockdown data in IIS metabase");        
    
    if (w3svc != NULL) {
        m_pAdmin->CloseKey(w3svc);
    }

    delete [] pchDup;
    delete [] msStr;

    return hr;
}


//
// This function will add current entry to MD_APP_DEPENDENCIES and MD_WEB_SVC_EXT_RESTRICTION_LIST.
// Please note that this function will check for its existence
// before adding itself.
//
HRESULT 
SECURITY_PROP_MANAGER::RegisterSecurityLockdown(BOOL fEnable)
{
    HRESULT         hr = S_OK;
    METADATA_HANDLE w3svc = NULL;
    METADATA_RECORD md;
    WCHAR *         pchAppDep = NULL;
    WCHAR *         pchExtRestList = NULL;
    int             len;
    WCHAR *         pchRead = NULL;
    BOOL            fExist;
    
    CSetupLogging::Log(1, "RegisterSecurityLockdown", 0, "Modifying security lockdown data in IIS metabase");        
    
    hr = m_pAdmin->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            KEY_LMW3SVC,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_REQUEST_TIMEOUT,
            &w3svc);

    // Add to the ApplicationDependencies property
    len =   lstrlenW(IIS_APP_NAME_L) +          // AppName
            1 +                                 // semi-colon
            lstrlenW(IIS_GROUP_ID_L) +          // Group ID
            1;                                  // null

    pchAppDep = new WCHAR[len];
    ON_OOM_EXIT(pchAppDep);

    StringCchCopyW(pchAppDep, len, IIS_APP_NAME_L);
    StringCchCatW(pchAppDep, len, L";");
    StringCchCatW(pchAppDep, len, IIS_GROUP_ID_L);

    // Check if we exist.  If so, skip it.
    fExist = FALSE;
    
    hr = GetMultiStringProperty(m_pAdmin, w3svc, L"/", MD_APP_DEPENDENCIES, &md);
    if (hr && hr != HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND)) {
        ON_ERROR_EXIT();
    }

    if (hr == S_OK) {
        pchRead = (WCHAR*)md.pbMDData;
        if (FindStringInMultiString(pchRead, pchAppDep) != NULL) {
            fExist = TRUE;
        }

        delete [] pchRead;
        pchRead = NULL;
    }
    else {
        hr = S_OK;
    }

    if (!fExist) {
        hr = AppendStringToMultiStringProp(m_pAdmin, w3svc, L"/", MD_APP_DEPENDENCIES, pchAppDep, FALSE);
        ON_ERROR_EXIT();
    }

    // Add to the WebSvcExtRestrictionList property

    len =   1 +                                 // AllowDenyFlag
            1 +                                 // comma
            lstrlenW(Names::IsapiFullPath()) +  // ExtensionPhysicalPath 
            1 +                                 // comma
            1 +                                 // UIDeletableFlag 
            1 +                                 // comma
            lstrlenW(IIS_GROUP_ID_L) +          // Group ID
            1 +                                 // comma
            lstrlenW(IIS_APP_DESCRIPTION_L) +   // Description 
            1;                                  // null

    pchExtRestList = new WCHAR[len];
    ON_OOM_EXIT(pchExtRestList);

    StringCchCopyW(pchExtRestList, len, fEnable ? L"1" : L"0");  // AllowDenyFlag
    StringCchCatW(pchExtRestList, len, L",");
    StringCchCatW(pchExtRestList, len, Names::IsapiFullPath());// ExtensionPhysicalPath 
    StringCchCatW(pchExtRestList, len, L",");
    StringCchCatW(pchExtRestList, len, L"0");   // UIDeletableFlag 
    StringCchCatW(pchExtRestList, len, L",");
    StringCchCatW(pchExtRestList, len, IIS_GROUP_ID_L);// Group ID
    StringCchCatW(pchExtRestList, len, L",");
    StringCchCatW(pchExtRestList, len, IIS_APP_DESCRIPTION_L);//Description

    // Check if we exist.  If so, skip it.  We will try both 0 and 1 for the AllowDenyFlag
    fExist = FALSE;
    
    hr = GetMultiStringProperty(m_pAdmin, w3svc, L"/", MD_WEB_SVC_EXT_RESTRICTION_LIST, &md);
    if (hr && hr != HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND)) {
        ON_ERROR_EXIT();
    }

    if (hr == S_OK) {
        pchRead = (WCHAR*)md.pbMDData;
        if (FindStringInMultiString(pchRead, pchExtRestList) != NULL) {
            fExist = TRUE;
        }
        else {
            // Switching the AllowDenyFlag
            WCHAR   allowDeny = pchExtRestList[0];

            if (allowDeny == L'0') {
                pchExtRestList[0] = L'1';
            }
            else {
                pchExtRestList[0] = L'0';
            }

            // Find again
            if (FindStringInMultiString(pchRead, pchExtRestList) != NULL) {
                fExist = TRUE;
            }
            
            // Revert back to original
            pchExtRestList[0] = allowDeny;
        }
        
        delete [] pchRead;
        pchRead = NULL;
    }
    else {
        hr = S_OK;
    }

    if (!fExist) {
        hr = AppendStringToMultiStringProp(m_pAdmin, w3svc, L"/", MD_WEB_SVC_EXT_RESTRICTION_LIST, pchExtRestList, FALSE);
        ON_ERROR_EXIT();
    }

Cleanup:
    CSetupLogging::Log(hr, "RegisterSecurityLockdown", 0, "Modifying security lockdown data in IIS metabase");        
    
    if (w3svc != NULL) {
        m_pAdmin->CloseKey(w3svc);
    }

    delete [] pchAppDep;
    delete [] pchExtRestList;
    delete [] pchRead;

    return hr;
}



////////////////////////////////////////////////////////////
// Utility functions
////////////////////////////////////////////////////////////


/**
 * Get's a multi-string property from the metabase. Allocs memory
 * for the multi-string if successful, and returns it in pdm->pdbData.
 * 
 * @param pAdmin           Administration object.
 * @param keyHandle        Metabase key.
 * @param pchPath          Path of property relative to key.
 * @param dwMDIdentifier   Id of the property.
 * @param pmd              Results of the GetData call.
 */
HRESULT
GetMultiStringProperty(
        IMSAdminBase    *pAdmin,
        METADATA_HANDLE keyHandle,
        const WCHAR    *pchPath,
        DWORD           dwMDIdentifier,
        METADATA_RECORD *pmd) {

    HRESULT hr;
    WCHAR   chDummy;
    DWORD   size;
    WCHAR * pchData = NULL;
    DWORD   cchar;

    // First get with zero-size buffer
    chDummy = L'\0';
    pmd->dwMDIdentifier = dwMDIdentifier;
    pmd->dwMDAttributes = METADATA_NO_ATTRIBUTES;
    pmd->dwMDUserType = 0;
    pmd->dwMDDataType = MULTISZ_METADATA;
    pmd->pbMDData = (unsigned char *) &chDummy;
    pmd->dwMDDataLen = 0;
    pmd->dwMDDataTag = 0;

    hr = pAdmin->GetData(keyHandle, pchPath, pmd, &size);
    ASSERT(hr != S_OK);
    if (hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        EXIT();

    // Create buffer of proper size and get again
    cchar = (size)/sizeof(pchData[0]);
    pchData = new WCHAR[cchar]; 
    ON_OOM_EXIT(pchData);

    pmd->pbMDData = (unsigned char *) pchData;
    pmd->dwMDDataLen = size;

    hr = pAdmin->GetData(keyHandle, pchPath, pmd, &size);
    ON_ERROR_EXIT();

    // Make sure the multi-string is well formed.  The last two bytes must be zeros.
    if (cchar < 2) {
        EXIT_WITH_WIN32_ERROR(ERROR_FILE_CORRUPT);
    }
    if (!(pchData[cchar-1] == NULL && pchData[cchar-2] == NULL)) {
        EXIT_WITH_WIN32_ERROR(ERROR_FILE_CORRUPT);
    }

    // Don't delete on success
    pchData = NULL;

Cleanup:
    if (hr) {
        pmd->pbMDData = NULL;
        pmd->dwMDDataLen = 0;
    }

    delete [] pchData;
    return hr;
}


/**
 * Get's a string property from the metabase. Allocs memory
 * for the string if successful, and returns it in pdm->pdbData.
 * 
 * @param pAdmin           Administration object.
 * @param keyHandle        Metabase key.
 * @param pchPath          Path of property relative to key.
 * @param dwMDIdentifier   Id of the property.
 * @param pmd              Results of the GetData call.
 */
HRESULT
GetStringProperty(
        IMSAdminBase    *pAdmin,
        METADATA_HANDLE keyHandle,
        const WCHAR    *pchPath,
        DWORD           dwMDIdentifier,
        METADATA_RECORD *pmd) {

    HRESULT hr;
    WCHAR   chDummy;
    DWORD   size;
    WCHAR * pchData = NULL;

    // First get with zero-size buffer
    chDummy = L'\0';
    pmd->dwMDIdentifier = dwMDIdentifier;
    pmd->dwMDAttributes = METADATA_NO_ATTRIBUTES;
    pmd->dwMDUserType = 0;
    pmd->dwMDDataType = STRING_METADATA;
    pmd->pbMDData = (unsigned char *) &chDummy;
    pmd->dwMDDataLen = 0;
    pmd->dwMDDataTag = 0;

    hr = pAdmin->GetData(keyHandle, pchPath, pmd, &size);
    ASSERT(hr != S_OK);
    if (hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        EXIT();

    // Create buffer of proper size and get again
    pchData = new WCHAR[(size)/sizeof(pchData[0])]; 
    ON_OOM_EXIT(pchData);

    pmd->pbMDData = (unsigned char *) pchData;
    pmd->dwMDDataLen = size;

    hr = pAdmin->GetData(keyHandle, pchPath, pmd, &size);
    ON_ERROR_EXIT();

    // Don't delete buffer on success
    pchData = NULL;

Cleanup:
    if (hr) {
        pmd->pbMDData = NULL;
        pmd->dwMDDataLen = 0;
    }

    delete [] pchData;
    return hr;
}


/**
 * The length of a multi-string string. Includes the nulls
 * of each string, omits the final terminator.
 */
int
wcslenms(const WCHAR * pch) {
    int len;
    int total;

    total = 0;
    do {
        len = lstrlenW(pch) + 1;
        total += len;
        pch += len;
    } while (*pch);

    return total;
}

const WCHAR *
FindStringInMultiString(const WCHAR *msStr, const WCHAR *str) {
    const WCHAR * pchCurrent = msStr;
    
    do {
        if (wcscmp(pchCurrent, str) == 0) {
            return pchCurrent;
        }

        pchCurrent += lstrlenW(pchCurrent) + 1;
    } while (*pchCurrent != L'\0');

    return NULL;
}


/**
 * Add a string to a multistring property. If the property doesn't exist,
 * create it.
 * 
 * @param pAdmin           Administration object.
 * @param keyHandle        Metabase key.
 * @param pchPath          Path of property relative to key.
 * @param dwMDIdentifier   Id of the property.
 * @param pchAppend        String to append.
 * @param fInheritable     When creating new property, is it inheritable or not?
 */
HRESULT
AppendStringToMultiStringProp(
        IMSAdminBase    *pAdmin,
        METADATA_HANDLE keyHandle,
        const WCHAR    *pchPath,
        DWORD           dwMDIdentifier,
        const WCHAR     *pchAppend,
        BOOL            fInheritable) {

    HRESULT         hr;
    WCHAR           *pchCurrent = NULL;
    METADATA_RECORD md;

    // get the property
    hr = GetMultiStringProperty(pAdmin, keyHandle, pchPath, dwMDIdentifier, &md);
    if (hr == S_OK) {
        pchCurrent = (WCHAR*) md.pbMDData;
    }
    else {
        if (fInheritable) {
            // when creating a new property, allow it to be inherited
            md.dwMDAttributes = METADATA_INHERIT;
        }
    }

    hr = AppendStringToMultiString(&pchCurrent, pchAppend);
    ON_ERROR_EXIT();

    // set the value
    md.pbMDData = (unsigned char*) pchCurrent;
    md.dwMDDataLen = (wcslenms(pchCurrent) + 1) * sizeof(WCHAR);
    hr = pAdmin->SetData(keyHandle, pchPath, &md);
    ON_ERROR_EXIT();

Cleanup:
    delete [] pchCurrent;

    return hr;
}


HRESULT AppendStringToMultiString(       WCHAR **pmsStr, const WCHAR *pchAppend)
{
    HRESULT         hr = S_OK;
    WCHAR           *pchCurrent = NULL;
    WCHAR           *pchNew = NULL;
    int             lenCurrent = 0;
    int             lenAppend;

    lenAppend = lstrlenW(pchAppend);

    pchCurrent = *pmsStr;
    if (pchCurrent && pchCurrent[0] != L'\0')  {
        // alloc a new buffer and append the string
        lenCurrent = wcslenms(pchCurrent);
        pchNew = new WCHAR[lenCurrent + lenAppend + 2];
        ON_OOM_EXIT(pchNew);

        CopyMemory(pchNew, pchCurrent, lenCurrent * sizeof(pchCurrent[0]));
        StringCchCopy(&pchNew[lenCurrent], lenAppend+2, pchAppend);
        pchNew[lenCurrent + lenAppend + 1] = L'\0';
    }
    else {
        // The caller fail to read the property, or the property is an empty string
        
        // alloc a new buffer with enough room for the second terminating null
        pchNew = new WCHAR[lenAppend + 2];
        ON_OOM_EXIT(pchNew);

        CopyMemory(pchNew, pchAppend, (lenAppend + 1) * sizeof(pchAppend[0]));
        pchNew[lenAppend + 1] = L'\0';
    }

    delete [] *pmsStr;
    *pmsStr = pchNew;
    pchNew = NULL;

Cleanup:
    delete [] pchNew;

    return hr;
}


/**
 * Remove an entire string from multistring property if the string
 * to remove case-insensitively matches either the prefix or a portion 
 * of it.
 * 
 * @param pAdmin           Administration object.
 * @param keyHandle        Metabase key.
 * @param pchPath          Path of property relative to key.
 * @param dwMDIdentifier   Id of the property.
 * @param pchRemove        String to remove
 * @param matching         Mode to use for matching the string inside the multisz 
 * @param fDeleteEmpty     Delete the property if it becomes empty
 */
HRESULT
RemoveStringFromMultiStringProp(
        IMSAdminBase    *pAdmin,
        METADATA_HANDLE keyHandle,
        const WCHAR    *pchPath,
        DWORD           dwMDIdentifier,
        const WCHAR     *pchRemove,
        MULTISZ_MATCHING_MODE matching,
        BOOL            fDeleteEmpty) {

    HRESULT         hr;
    WCHAR           *pchCurrent = NULL;
    METADATA_RECORD md;
    BOOL            fEmpty, altered;

    // Get the current value of the multistring property
    hr = GetMultiStringProperty(pAdmin, keyHandle, pchPath, dwMDIdentifier, &md);
    pchCurrent = (WCHAR*) md.pbMDData;
    ON_ERROR_EXIT();

    altered = RemoveStringFromMultiString(pchCurrent, pchRemove,  matching, &fEmpty);
    
    if (altered) {
        // if we removed everything, delete the property
        if (fEmpty && fDeleteEmpty) {
            hr = pAdmin->DeleteData(keyHandle, pchPath, dwMDIdentifier, MULTISZ_METADATA);
            ON_ERROR_EXIT();
        }
        else {
            // set the new value

            // copy terminating null
            md.pbMDData = (unsigned char*) pchCurrent;
            md.dwMDDataLen = (wcslenms(pchCurrent) + 1) * sizeof(pchCurrent[0]);
            hr = pAdmin->SetData(keyHandle, pchPath, &md);
            ON_ERROR_EXIT();
        }
    }

Cleanup:
    delete [] pchCurrent;

    return hr;
}

BOOL
RemoveStringFromMultiString( WCHAR *msStr, const WCHAR *pchRemove,  MULTISZ_MATCHING_MODE matching,
                                BOOL *pfEmpty)
{
    return RemoveStringFromMultiStringEx(msStr, pchRemove, matching, 
                    pfEmpty, NULL);
}

BOOL
RemoveStringFromMultiStringEx( WCHAR *msStr, const WCHAR *pchRemove,  MULTISZ_MATCHING_MODE matching,
                                BOOL *pfEmpty, SECURITY_PROP_MANAGER *pSecPropMgr)
{
    int             len, lenRemove;
    WCHAR           *pchSrc, *pchDst;
    bool            altered;

    if (pfEmpty) {
        *pfEmpty = FALSE;
    }

    // Copy strings within block that do not contain pchRemove
    pchSrc = pchDst = msStr;
    altered = false;
    lenRemove = lstrlenW(pchRemove);
    do {
        BOOL    fMatch = FALSE;
        
        len = lstrlenW(pchSrc) + 1;

        switch(matching) {
            case MULTISZ_MATCHING_PREFIX:
                fMatch = (_wcsnicmp(pchSrc, pchRemove, lenRemove) == 0);
                break;

            case MULTISZ_MATCHING_EXACT:
                fMatch = (_wcsicmp(pchSrc, pchRemove) == 0);
                break;

            case MULTISZ_MATCHING_ANY:
                fMatch = (wcsistr(pchSrc, (WCHAR*)pchRemove) != NULL);
                break;
                
            default:
                ASSERT(FALSE);
        }

        if (fMatch && pSecPropMgr) {
            // The caller is using SecurityPropManager to do extra checking.  If this function call
            // returns TRUE, we will proceed to remove it.
            fMatch = pSecPropMgr->SecurityDetectVersion(pchSrc);
        }
        
        if (fMatch) {
            altered = true;
        }
        else {
            StringCchCopyW(pchDst, len, pchSrc);
            pchDst += len;
        }

        pchSrc += len;
    } while (*pchSrc != L'\0');

    if (altered) {
        if (pchDst == msStr) {
            // Everything is removed.
            if (pfEmpty) {
                *pfEmpty = TRUE;
            }

            pchDst[0] = pchDst[1] = L'\0';
        }
        else {
            pchDst[0] = L'\0';
        }
    }

    return altered;
}


HRESULT RemoveAspnetDllFromMulti(IMSAdminBase *pAdmin, METADATA_HANDLE w3svcHandle, 
                                DWORD dwMDId, const WCHAR *path) {
    HRESULT hr = S_OK;
    int     i;

    for (i = 0; i < g_AspnetDllNamesSize; i++) {
        hr = RemoveStringFromMultiStringProp(pAdmin, w3svcHandle, path, dwMDId, 
                    g_AspnetDllNames[i], MULTISZ_MATCHING_ANY, FALSE);
        ON_ERROR_EXIT();
    }

Cleanup:
    return hr;
}


HRESULT
WriteAspnetDllOnOneScriptMap(IMSAdminBase* pAdmin, METADATA_HANDLE w3svcHandle, 
                            const WCHAR *pchKeyPath, const WCHAR *pchDllPath) {
    HRESULT         hr = S_OK;
    WCHAR           *pchSuffix;
    int             lenAppend;
    WCHAR           *pchAppend = NULL;
    int             len, i;
    
    for (i = 0; i < ARRAY_SIZE(g_scriptMapPrefixes); i++) {
        // For extensions that map to Forbidden handler, we also add
        // MD_SCRIPTMAPFLAG_CHECK_PATH_INFO to the flag embedded in the config
        // string
        if (GetCurrentPlatform() == APSX_PLATFORM_W2K) {
            pchSuffix = g_scriptMapPrefixes[i].bForbidden ? 
                            SCRIPT_MAP_SUFFIX_W2K_FORBIDDEN : SCRIPT_MAP_SUFFIX_W2K;
        }
        else {
            pchSuffix = g_scriptMapPrefixes[i].bForbidden ? 
                            SCRIPT_MAP_SUFFIX_NT4_FORBIDDEN : SCRIPT_MAP_SUFFIX_NT4;
        }

        lenAppend = lstrlenW(pchDllPath) + lstrlenW(pchSuffix);
    
        len = lenAppend + lstrlenW(g_scriptMapPrefixes[i].wszExt);
        WCHAR * pchRealloc = new(pchAppend, NewReAlloc) WCHAR[len + 1];
        ON_OOM_EXIT(pchRealloc);
        pchAppend = pchRealloc;
    
        StringCchCopyW(pchAppend, len+1, g_scriptMapPrefixes[i].wszExt);
        StringCchCatW(pchAppend, len+1, pchDllPath);
        StringCchCatW(pchAppend, len+1, pchSuffix);

        hr = AppendStringToMultiStringProp(pAdmin, w3svcHandle, pchKeyPath, 
                            MD_SCRIPT_MAPS, pchAppend, TRUE);

        ON_ERROR_EXIT();
    }

Cleanup:
    delete [] pchAppend;

    return hr;
}

HRESULT
ReplaceStringInMultiString(WCHAR **ppchSM, const WCHAR *pchFrom, const WCHAR *pchTo)
{
    HRESULT     hr = S_OK;
    int         total, size, lenFrom, lenTo;
    WCHAR       *pchSrc, *pchDst;
    WCHAR       *pchNew = NULL;

    ASSERT(*ppchSM != NULL);

    lenTo = lstrlenW(pchTo);
    lenFrom = lstrlenW(pchFrom);

    // First see how many matchings do we have
    total = 0;
    pchSrc = *ppchSM;
    do {
        if (wcsistr(pchSrc, pchFrom) != NULL) {
            total++;
        }
        
        pchSrc += lstrlenW(pchSrc) + 1;
    } while (*pchSrc);

    if (total == 0) {
        // Not a single match.  Job done.
        EXIT();
    }

    // Calculate the new buffer size
    size = wcslenms(*ppchSM) + ((lenTo - lenFrom) * total) + 1;

    pchNew = new WCHAR[size];
    ON_OOM_EXIT(pchNew);
    ZeroMemory(pchNew, sizeof(WCHAR)*size);

    // Copy each string to new buffer, with modification for replacing
    pchSrc = *ppchSM;
    pchDst = pchNew;
    do {
        WCHAR   *pchMatchInSrc;
        
        pchMatchInSrc = wcsistr(pchSrc, pchFrom);
        
        if (pchMatchInSrc == NULL) {
            // Nothing to replace.  Easy.
            StringCchCopyW(pchDst, size, pchSrc);
        }
        else {
            WCHAR * pchRemaining;
            int     len;

            ASSERT(wcsistr(pchSrc, pchFrom) != NULL);

            // Copy the part before pchFrom
            len = (int)(pchMatchInSrc - pchSrc);
            StringCchCopyNW(pchDst, size, pchSrc, len);
            pchDst[len] = L'\0';
            
            // Append the replacing string
            StringCchCatW(pchDst, size, pchTo);

            // Append the remaining characters from the source string
            pchRemaining = pchMatchInSrc + lenFrom;
            StringCchCatW(pchDst, size, pchRemaining);
        }
        
        pchSrc += lstrlenW(pchSrc) + 1;
        pchDst += lstrlenW(pchDst) + 1;
    } while (*pchSrc);
    
    *pchDst = L'\0';

    // Return the new buffer
    delete [] *ppchSM;
    *ppchSM = pchNew;
    pchNew = NULL;

Cleanup:
    delete [] pchNew;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\register.cxx ===
/**
 * ASP.NET Registration function. 
 *
 * Copyright (C) Microsoft Corporation, 1998
 */

#include "precomp.h"
#include "_ndll.h"
#include "ndll.h"
#include "event.h"
#include "ciisinfo.h"
#include "regaccount.h"
#include "loadperf.h"
#include <sddl.h>
#include <iiscnfg.h>
#include <aspnetver.h>
#include <aspnetverlist.h>
#include "register.h"


//**********************************************************************
// 
// FUNCTION:  IsAdmin - This function checks the token of the 
//            calling thread to see if the caller belongs to
//            the Administrators group.
// 
// PARAMETERS:   none
// 
// RETURN VALUE: TRUE if the caller is an administrator on the local
//            machine.  Otherwise, FALSE.
// 
//**********************************************************************
BOOL IsAdmin() {
    BOOL b;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup; 
    
    b = AllocateAndInitializeSid(
        &NtAuthority,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &AdministratorsGroup); 
    if(b) 
    {
        if (!CheckTokenMembership( NULL, AdministratorsGroup, &b)) 
        {
             b = FALSE;
        } 
        FreeSid(AdministratorsGroup); 
    }

    return(b);
}


HRESULT
WaitForServiceState(SC_HANDLE hService, DWORD desiredState)
{
    HRESULT         hr = S_OK;
    DWORD           result;
    int             c;
    SERVICE_STATUS  serviceStatus;

    c = WAIT_FOR_SERVICE;
    for (;;)
    {
        result = QueryServiceStatus(hService, &serviceStatus);
        ON_ZERO_EXIT_WITH_LAST_ERROR(result);

        if (serviceStatus.dwCurrentState == desiredState)
            EXIT();

        if (--c == 0)
            EXIT_WITH_WIN32_ERROR(ERROR_SERVICE_REQUEST_TIMEOUT);

        Sleep(1000);
    }

Cleanup:
    return hr;
}



HRESULT 
StopSingleService(SC_HANDLE hSCM, SC_HANDLE hService, DWORD * lastStatus)
{
    HRESULT         hr = S_OK;
    int             result;
    SERVICE_STATUS  serviceStatus;
    DWORD           dummylastStatus;

    CSetupLogging::Log(1, "StopSingleService", 0, "Stopping service");        
    
    if (lastStatus == NULL)
    {
        lastStatus = &dummylastStatus;
    }

    *lastStatus = SERVICE_STOPPED;

    //
    // Get the last status
    // 
    CSetupLogging::Log(1, "QueryServiceStatus", 0, "Finding out service state");        
    result = QueryServiceStatus(hService, &serviceStatus);
    ON_ZERO_CONTINUE_WITH_LAST_ERROR(result);
    CSetupLogging::Log(hr, "QueryServiceStatus", 0, "Finding out service state");        
    if (hr == S_OK)
    {
        *lastStatus = serviceStatus.dwCurrentState;
    }
    else
    {
        hr = S_OK;
    }

    //
    // Ask the service to stop.
    //
    CSetupLogging::Log(1, "ControlService", 0, "Shutting down service");        
    result = ControlService(hService, SERVICE_CONTROL_STOP, &serviceStatus);
    if (!result)
    {
        hr = GetLastWin32Error();
        if (hr == HRESULT_FROM_WIN32(ERROR_SERVICE_CANNOT_ACCEPT_CTRL) ||
            hr == HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE))
        {
            /*
             * NB: On NT 4, serviceStatus is not set, so we must query.
             */

            result = QueryServiceStatus(hService, &serviceStatus);
            ON_ZERO_CONTINUE_WITH_LAST_ERROR(result);

            if (    result && (
                    serviceStatus.dwCurrentState == SERVICE_STOPPED || 
                    serviceStatus.dwCurrentState == SERVICE_STOP_PENDING))
            {
                hr = S_OK;
            }
        }

        if (hr != S_OK)
            CSetupLogging::Log(hr, "ControlService", 0, "Shutting down service");        
        ON_ERROR_EXIT();
    }

    CSetupLogging::Log(hr, "ControlService", 0, "Shutting down service");        

    CSetupLogging::Log(1, "WaitForServiceState", 0, "Waiting for service to shut down");        
    hr = WaitForServiceState(hService, SERVICE_STOPPED);
    CSetupLogging::Log(hr, "WaitForServiceState", 0, "Waiting for service to shut down");        
    ON_ERROR_EXIT();

Cleanup:
    CSetupLogging::Log(hr, "StopSingleService", 0, "Stopping service");        

    return hr;
}

/**
 * This function will:
 *  1. Convert wszStr to ANSI string
 *  2. Concatenate szPrefix and the string obtained from step #1
 *
 *  However, if we run out of memory, it will return szPrefix instead.  The caller has
 *  to free the memory, if any, returned in pszFree
 *
 *  Parameters:
 *  pszFree     - If non-NULL, the caller has to free it.
 */
CHAR *
SpecialStrConcatForLogging(const WCHAR *wszStr, CHAR *szPrefix, CHAR **pszFree) {
    HRESULT hr = S_OK;
    CHAR   *szStr = NULL;

    // If the function fail, we will return szPrefix
    CHAR   *szRet = szPrefix;

    // Init
    *pszFree =  NULL;

    // Convert wszStr to multibyte string
    hr = WideStrToMultiByteStr((WCHAR*)wszStr, &szStr, CP_ACP);
    ON_ERROR_EXIT();

    // Concatenate szPrefix and the multibyte string
    size_t size = lstrlenA(szStr) + lstrlenA(szPrefix) + 1;
    *pszFree = new CHAR[size];
    ON_OOM_EXIT(*pszFree);
    
    StringCchCopyA(*pszFree, size, szPrefix);
    StringCchCatA(*pszFree, size, szStr);
    szRet = *pszFree;

Cleanup:
    delete [] szStr;
    return szRet;
}

HRESULT 
GetServiceStatus(DWORD * status, WCHAR* serviceName)
{
    HRESULT         hr = S_OK;
    SC_HANDLE       hSCM = NULL;
    SC_HANDLE       hService = NULL;
    int             result;
    SERVICE_STATUS  ss;
    CHAR *          szLogAlloc = NULL;
    CHAR *          szLog;

    szLog = SpecialStrConcatForLogging(serviceName, "Querying status of a service: ", &szLogAlloc);
    CSetupLogging::Log(1, "GetServiceStatus", 0, szLog);
    
    *status = SERVICE_STOPPED;

    //
    // Open a handle to the Service.
    //
    CSetupLogging::Log(1, "OpenSCManager", 0, "Connecting to Service Manager");        
    hSCM = OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT);
    ON_ZERO_CONTINUE_WITH_LAST_ERROR(hSCM);
    CSetupLogging::Log(hr, "OpenSCManager", 0, "Connecting to Service Manager");        
    ON_ERROR_EXIT();

    CSetupLogging::Log(1, "OpenService", 0, "Opening Service handle");        
    hService = OpenService(
            hSCM,
            serviceName,
            SERVICE_QUERY_STATUS | SERVICE_INTERROGATE | SERVICE_STOP);

    if (hService == NULL) 
    {
        hr = GetLastWin32Error();
        if (hr == HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST))
        {
            hr = S_OK;
        }
        CSetupLogging::Log(hr, "OpenService", 0, "Opening Service handle");        

        EXIT();
    }

    CSetupLogging::Log(hr, "OpenService", 0, "Opening Service handle");        
        
    //
    // Get the last status
    // 
    CSetupLogging::Log(1, "QueryServiceStatus", 0, "Finding out service state");        
    result = QueryServiceStatus(hService, &ss);
    ON_ZERO_CONTINUE_WITH_LAST_ERROR(result);
    CSetupLogging::Log(hr, "QueryServiceStatus", 0, "Finding out service state");        
    ON_ERROR_EXIT();
    
    *status = ss.dwCurrentState;

Cleanup:
    CSetupLogging::Log(hr, "GetServiceStatus", 0, szLog);

    delete [] szLogAlloc;
    
    if (hService != NULL) 
    {
        VERIFY(CloseServiceHandle(hService));
    }

    if (hSCM != NULL)  
    {
        VERIFY(CloseServiceHandle(hSCM));
    }

    return hr;
}



HRESULT 
StopServiceByName(DWORD * lastStatus, WCHAR* serviceName)
{
    HRESULT         hr = S_OK;
    SC_HANDLE       hSCM = NULL;
    SC_HANDLE       hService = NULL;
    DWORD           dummylastStatus;
    CHAR *          szLogAlloc = NULL;
    CHAR *          szLog;

    szLog = SpecialStrConcatForLogging(serviceName, "Stopping service: ", &szLogAlloc);
    CSetupLogging::Log(1, "StopServiceByName", 0, szLog);
    
    if (lastStatus == NULL)
    {
        lastStatus = &dummylastStatus;
    }

    *lastStatus = SERVICE_STOPPED;

    //
    // Open a handle to the Service.
    //
    CSetupLogging::Log(1, "OpenSCManager", 0, "Connecting to Service Manager");        
    hSCM = OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT);
    ON_ZERO_CONTINUE_WITH_LAST_ERROR(hSCM);
    CSetupLogging::Log(hr, "OpenSCManager", 0, "Connecting to Service Manager");        
    ON_ERROR_EXIT();

    CSetupLogging::Log(1, "OpenService", 0, "Opening Service handle");        
    hService = OpenService(
            hSCM,
            serviceName,
            SERVICE_QUERY_STATUS | SERVICE_INTERROGATE | SERVICE_STOP);

    if (hService == NULL) 
    {
        hr = GetLastWin32Error();
        if (hr == HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST))
        {
            hr = S_OK;
        }
        CSetupLogging::Log(hr, "OpenService", 0, "Opening Service handle");        

        EXIT();
    }

    CSetupLogging::Log(hr, "OpenService", 0, "Opening Service handle");        
        
    hr = StopSingleService(hSCM, hService, lastStatus);
    ON_ERROR_EXIT();
    
Cleanup:
    CSetupLogging::Log(hr, "StopServiceByName", 0, szLog);

    delete [] szLogAlloc;

    if (hService != NULL) 
    {
        VERIFY(CloseServiceHandle(hService));
    }

    if (hSCM != NULL)  
    {
        VERIFY(CloseServiceHandle(hSCM));
    }

    return hr;
}

HRESULT
StartServiceByName(WCHAR *pchServiceName, DWORD lastStatus)
{
    HRESULT         hr = S_OK;
    int             result;
    SC_HANDLE       hSCM = NULL;
    SC_HANDLE       hService = NULL;
    SERVICE_STATUS  serviceStatus;
    CHAR *          szLogAlloc = NULL;
    CHAR *          szLog;

    szLog = SpecialStrConcatForLogging(pchServiceName, "Starting service: ", &szLogAlloc);
    CSetupLogging::Log(1, "StartServiceByName", 0, szLog);        

    if (lastStatus != SERVICE_RUNNING && lastStatus != SERVICE_PAUSED) {
        EXIT();
    }

    //
    // Open a handle to the Service.
    //
    CSetupLogging::Log(1, "OpenSCManager", 0, "Connecting to Service Manager");        
    hSCM = OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT);
    ON_ZERO_CONTINUE_WITH_LAST_ERROR(hSCM);
    CSetupLogging::Log(hr, "OpenSCManager", 0, "Connecting to Service Manager");        
    ON_ERROR_EXIT();

    CSetupLogging::Log(1, "OpenService", 0, "Opening Service handle");        
    hService = OpenService(
            hSCM,
            pchServiceName,
            SERVICE_QUERY_STATUS | SERVICE_INTERROGATE | SERVICE_START | SERVICE_PAUSE_CONTINUE);
    
    ON_ZERO_CONTINUE_WITH_LAST_ERROR(hService);
    CSetupLogging::Log(hr, "OpenService", 0, "Opening Service handle");        
    ON_ERROR_EXIT();


    CSetupLogging::Log(1, "StartService", 0, "Starting service");        
    result = StartService(hService, 0, NULL);
    ON_ZERO_CONTINUE_WITH_LAST_ERROR(result);
    CSetupLogging::Log(hr, "StartService", 0, "Starting service");        
    ON_ERROR_EXIT();
    
    if (lastStatus == SERVICE_PAUSED)
    {
        CSetupLogging::Log(1, "WaitForServiceState", 0, "Waiting for service to start");        
        hr = WaitForServiceState(hService, SERVICE_RUNNING);
        CSetupLogging::Log(hr, "WaitForServiceState", 0, "Waiting for service to start");        
        ON_ERROR_EXIT();

        CSetupLogging::Log(1, "ControlService", 0, "Pausing service");        
        result = ControlService(hService, SERVICE_CONTROL_PAUSE, &serviceStatus);
        ON_ZERO_CONTINUE_WITH_LAST_ERROR(result);
        CSetupLogging::Log(hr, "ControlService", 0, "Pausing service");        
        ON_ERROR_EXIT();
    }
    else {
        CSetupLogging::Log(1, "WaitForServiceState", 0, "Waiting for service to start");        
        hr = WaitForServiceState(hService, SERVICE_RUNNING);
        CSetupLogging::Log(hr, "WaitForServiceState", 0, "Waiting for service to start");        
        ON_ERROR_EXIT();
    }

Cleanup:
    CSetupLogging::Log(hr, "StartServiceByName", 0, szLog);        

    delete [] szLogAlloc;

    if (hService != NULL) 
    {
        VERIFY(CloseServiceHandle(hService));
    }

    if (hSCM != NULL)  
    {
        VERIFY(CloseServiceHandle(hSCM));
    }

    return hr;
}


HRESULT
StopService( SC_HANDLE hSCM, SC_HANDLE hService, CStrAry *pDepSvcs, 
                CDwordAry *pDepSvcsState ) {

    HRESULT                 hr = S_OK;
    ENUM_SERVICE_STATUS     ess;
    SERVICE_STATUS          ss;
    WCHAR                   *pchName = NULL;
    LPENUM_SERVICE_STATUS   lpDependencies = NULL;
    SC_HANDLE               hDepService = NULL;
    BOOL                    fRet;
    DWORD                   i, dwBytesNeeded, dwCount;

    // Make sure the service is not already stopped
    CSetupLogging::Log(1, "QueryServiceStatus", 0, "Finding out service state");        
    fRet = QueryServiceStatus( hService, &ss );
    ON_ZERO_CONTINUE_WITH_LAST_ERROR(fRet);
    CSetupLogging::Log(hr, "QueryServiceStatus", 0, "Finding out service state");        
    ON_ERROR_EXIT();

    if ( ss.dwCurrentState == SERVICE_STOPPED ) 
        EXIT();

    // If a stop is pending, just wait for it
    if ( ss.dwCurrentState == SERVICE_STOP_PENDING ) {
        CSetupLogging::Log(1, "WaitForServiceState", 0, "Waiting for service to shut down");        
        hr = WaitForServiceState(hService, SERVICE_STOPPED);
        CSetupLogging::Log(hr, "WaitForServiceState", 0, "Waiting for service to shut down");        
        ON_ERROR_EXIT();
        EXIT();
    }

    // If the service is running, dependencies must be stopped first

    // Pass a zero-length buffer to get the required buffer size
    CSetupLogging::Log(1, "EnumDependentServices", 0, "Enumerating dependent services");        
    if ( EnumDependentServices( hService, SERVICE_ACTIVE, 
        lpDependencies, 0, &dwBytesNeeded, &dwCount ) ) {

        CSetupLogging::Log(S_OK, "EnumDependentServices", 0, "Enumerating dependent services");        
        // If the Enum call succeeds, then there are no dependent
        // services so do nothing

    } else {

        if ( GetLastError() != ERROR_MORE_DATA )
        {
            CONTINUE_WITH_LAST_ERROR();
            CSetupLogging::Log(hr, "EnumDependentServices", 0, "Enumerating dependent services");        
            ON_ERROR_EXIT();
        }

        // Allocate a buffer for the dependencies
        lpDependencies = (LPENUM_SERVICE_STATUS) NEW_CLEAR_BYTES(dwBytesNeeded);
        ON_OOM_CONTINUE(lpDependencies);
        if (hr) {
            CSetupLogging::Log(hr, "EnumDependentServices", 0, "Enumerating dependent services");
            ON_ERROR_EXIT();
        }

        // Enumerate the dependencies
        fRet = EnumDependentServices( hService, SERVICE_ACTIVE, 
                lpDependencies, dwBytesNeeded, &dwBytesNeeded,
                &dwCount );
        ON_ZERO_CONTINUE_WITH_LAST_ERROR(fRet);
        CSetupLogging::Log(hr, "EnumDependentServices", 0, "Enumerating dependent services");        
        ON_ERROR_EXIT();

        for ( i = 0; i < dwCount; i++ ) {

            ess = *(lpDependencies + i);

            // Open the service
            CSetupLogging::Log(1, "OpenService", 0, "Opening Service handle");        
            hDepService = OpenService( hSCM, ess.lpServiceName, 
                    SERVICE_STOP | SERVICE_QUERY_STATUS );
            ON_ZERO_CONTINUE_WITH_LAST_ERROR(hDepService);
            CSetupLogging::Log(hr, "OpenService", 0, "Opening Service handle");        
            ON_ERROR_EXIT();
            
            // Remember them so that we can restart them later.
            pchName = DupStr(ess.lpServiceName);
            ON_OOM_EXIT(pchName);
            hr = pDepSvcs->Append(pchName);
            ON_ERROR_EXIT();
            pchName = NULL;
            
            hr = pDepSvcsState->AppendIndirect(&(ess.ServiceStatus.dwCurrentState));
            ON_ERROR_EXIT();
            
            // Stop the single service
            hr = StopSingleService(hSCM, hDepService, NULL);
            ON_ERROR_EXIT();
        }
    } 

    // Stop the main service
    hr = StopSingleService(hSCM, hService, NULL);
    ON_ERROR_EXIT();
    
Cleanup:
    if (lpDependencies)
        DELETE_BYTES(lpDependencies);

    if (hDepService)
        CloseServiceHandle( hDepService );
    
    return hr;
}

HRESULT RestartW3svc(DWORD dwOriginalW3svcStatus, DWORD dwOriginalIISAdminStatus) {

    SC_HANDLE   hSCM = NULL;
    SC_HANDLE   hService = NULL;
    CStrAry     DepSvcs;
    CDwordAry   DepSvcsState;
    HRESULT     hr = S_OK;
    int         i;
    char        *szLog1, *szLog2;
    WCHAR *     wszStopSvc;

    CSetupLogging::Log(1, "RestartW3svc", 0, "Restarting W3SVC");        
    
    XspLogEvent(IDS_EVENTLOG_RESTART_W3SVC_BEGIN, NULL);

    // - If IISAdmin was originally stopped, just stop IISAdmin now and we're done.
    // - If IISAdmin was originally started or paused, since we haven't touched
    //   IISAdmin during our reg/unreg, we can leave it along. Just put w3svc 
    //   back to its original status.
    if (dwOriginalIISAdminStatus == SERVICE_STOPPED) {
        szLog1 = "Opening handle to IISAdmin";
        szLog2 = "Stopping IISAdmin";
        wszStopSvc = IISADMIN_SERVICE_NAME_L;
    }
    else {
        szLog1 = "Opening handle to W3SVC";
        szLog2 = "Stopping W3SVC";
        wszStopSvc = W3SVC_SERVICE_NAME_L;
    }

    // Open the SCM database
    CSetupLogging::Log(1, "OpenSCManager", 0, "Connecting to Service Manager");        
    hSCM = OpenSCManager( NULL, NULL, SC_MANAGER_CONNECT );
    ON_ZERO_CONTINUE_WITH_LAST_ERROR(hSCM);
    CSetupLogging::Log(hr, "OpenSCManager", 0, "Connecting to Service Manager");        
    ON_ERROR_EXIT();


    // Open the specified service
    CSetupLogging::Log(1, "OpenService", 0, szLog1);        
    hService = OpenService( hSCM, wszStopSvc, SERVICE_STOP
            | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS );
    ON_ZERO_CONTINUE_WITH_LAST_ERROR(hService);
    CSetupLogging::Log(hr, "OpenService", 0, szLog1);        
    ON_ERROR_EXIT();
    
    CSetupLogging::Log(1, "StopService", 0, szLog2);        
    hr = StopService( hSCM, hService, &DepSvcs, &DepSvcsState ) ;
    CSetupLogging::Log(hr, "StopService", 0, szLog2);        
    ON_ERROR_EXIT();

    if (dwOriginalIISAdminStatus == SERVICE_STOPPED) {
        // If IISAdmin was originally stopped, we have just stopped it above and we're done.
        EXIT();
    }

    // If w3svc was orginally stopped, we're done.
    if (dwOriginalW3svcStatus == SERVICE_STOPPED) {
        EXIT();
    }
    
    // Reset it to its original status, recorded before we run the master reg/unreg function
    
    hr = StartServiceByName(W3SVC_SERVICE_NAME_L, dwOriginalW3svcStatus);
    ON_ERROR_EXIT();

    // Restart all active dependent services in reverse order
    // (For reason of reverse ordering, see Win32 API EnumDependentServices.)
    for (i=DepSvcs.Size()-1; i >= 0; i--) {
        hr = StartServiceByName(DepSvcs[i], DepSvcsState[i]);
        ON_ERROR_CONTINUE();
    }

Cleanup:
    CSetupLogging::Log(hr, "RestartW3svc", 0, "Restarting W3SVC");        
    
    XspLogEvent(IDS_EVENTLOG_RESTART_W3SVC_FINISH, NULL);

    CleanupCStrAry(&DepSvcs);
    
    if ( hService )
        CloseServiceHandle( hService );

    if ( hSCM )
        CloseServiceHandle( hSCM );
    
    if (hr) {
        XspLogEvent(IDS_EVENTLOG_RESTART_W3SVC_FAILED, L"0x%08x", hr);
    }

    return hr;
} 

HRESULT DeletePerfKey(WCHAR* serviceName) {
    HRESULT hr = 0;
    HKEY serviceKey = NULL;
    WCHAR * servicePath;

    // Allocate enough for service path, service name (which includes the trailing "\")and NULL ending
    servicePath = new WCHAR[wcslen(REGPATH_SERVICES_KEY_L) + wcslen(serviceName) + 1];
    ON_OOM_EXIT(servicePath);
    hr = StringCchPrintf(servicePath, wcslen(REGPATH_SERVICES_KEY_L) + wcslen(serviceName) + 1, L"%s%s", REGPATH_SERVICES_KEY_L, serviceName);
    ON_ERROR_EXIT();
    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, servicePath, 0, KEY_ALL_ACCESS, &serviceKey);
    ON_WIN32_ERROR_EXIT(hr);

    // Don't care for errors here, which probably means it has subkeys that we didn't add...
    RegDeleteKey(serviceKey, L"Linkage");
    RegDeleteKey(serviceKey, L"Performance");
    RegDeleteKey(serviceKey, L"Names");
    RegCloseKey(serviceKey);

    // Delete the service key itself
    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_SERVICES_KEY_L, 0, KEY_ALL_ACCESS, &serviceKey);
    ON_WIN32_ERROR_EXIT(hr);

    // Don't care for errors here, which probably means it has subkeys that we didn't add...
    RegDeleteKey(serviceKey, serviceName);
    RegCloseKey(serviceKey);

Cleanup:
    if (servicePath != NULL) {
        delete [] servicePath;
    }

    return hr;
}

struct ServiceName {
    WCHAR * Name;
    ServiceName * Next;
};

ServiceName* PushServiceName(ServiceName * head, WCHAR * nameToAdd) {
    ServiceName * newName = new ServiceName;
    if (newName == NULL) {
        return NULL;
    }
    
    newName->Name = nameToAdd;
    if (head == NULL) {
        head = newName;
        newName->Next = NULL;
        return head;
    }

    newName->Next = head;
    return newName;
}

ServiceName* PopServiceName(ServiceName * head, WCHAR ** nameToReturn) {
    if (head == NULL) {
        *nameToReturn = NULL;
        return NULL;
    }

    ServiceName * newHead;
    *nameToReturn = head->Name;
    newHead = head->Next;
    delete head;
    
    return newHead;
}

int IsAspNet(WCHAR * name) {
    WCHAR * serviceName = PERF_SERVICE_PREFIX_L;
    for (int i = 0; i < PERF_SERVICE_PREFIX_LENGTH; i++) {
        if (name[i] == NULL || name[i] != serviceName[i]) {
            return -1;
        }
    }

    // If it's only ASP.NET, skip it
    if (name[i] == '\0') {
        return -1;
    }

    return 0;
}

HRESULT GetLibraryValue(WCHAR * serviceName, WCHAR ** libraryValue) {
    HRESULT hr = S_OK;
    DWORD keyType = 0;
    HKEY performanceKey = NULL;
    WCHAR * performanceName;
    DWORD libraryLength; 

    *libraryValue = NULL;

    // Get the length for the service key, service name, performance, the 2 "\" and the NULL ending
    performanceName = new WCHAR[wcslen(REGPATH_SERVICES_KEY_L) + wcslen(serviceName) + wcslen(L"Performance") + 3];
    ON_OOM_EXIT(performanceName);

    StringCchPrintf(performanceName, wcslen(REGPATH_SERVICES_KEY_L) + wcslen(serviceName) + wcslen(L"Performance") + 3, L"%s\\%s\\%s", REGPATH_SERVICES_KEY_L, serviceName, L"Performance");
    ON_ERROR_EXIT();
    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, performanceName, 0, KEY_READ, &performanceKey);
    ON_WIN32_ERROR_EXIT(hr);

    libraryLength = MAX_PATH * sizeof(WCHAR) + sizeof(WCHAR); 
    *libraryValue = new WCHAR[libraryLength];
    ON_OOM_EXIT(*libraryValue);
    hr = RegQueryValueEx(performanceKey, L"Library", 0, &keyType, (LPBYTE) *libraryValue, &libraryLength);
    if (hr != ERROR_SUCCESS) {
        EXIT_WITH_WIN32_ERROR(hr);
    }

    // Don't do anything if value type is not string or environment expandable string
    if (keyType != REG_SZ) {
        hr = ERROR_DATATYPE_MISMATCH;
        *libraryValue = NULL;
        EXIT_WITH_WIN32_ERROR(hr);
    }
    else {
        // If it got here, everything went ok.
        hr = S_OK;
    }

Cleanup:
    if (performanceKey != NULL) {
        RegCloseKey(performanceKey);
    }

    if (performanceName != NULL) {
        delete [] performanceName;
    }

    return hr;
 }

#define PERF_VERSIONED_ENTRY_POINTS(x) WCHAR * x [] = {L"OpenVersionedPerfData", L"CloseVersionedPerfData", L"CollectVersionedPerfData"};
#define PERF_GENERIC_ENTRY_POINTS(x) WCHAR* x [] = {L"OpenPerfCommonData", L"ClosePerfCommonData", L"CollectPerfCommonData"};

HRESULT CreatePerfCounterEntryPoints(WCHAR * regPath, WCHAR ** entryPoints)
{
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    DWORD disposition;
    LONG retCode;

    retCode = RegCreateKeyEx(HKEY_LOCAL_MACHINE, regPath, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &disposition);
    ON_WIN32_ERROR_EXIT(retCode);

    retCode = RegSetValueEx(hKey, L"Library", 0, REG_SZ, (BYTE *) Names::IsapiFullPath(), (DWORD) (wcslen(Names::IsapiFullPath()) + 1) * sizeof(Names::IsapiFullPath()[0]));
    ON_WIN32_ERROR_EXIT(retCode);
  
    retCode = RegSetValueEx(hKey, L"Open", 0, REG_SZ, (BYTE *) entryPoints[0], (DWORD) (wcslen(entryPoints[0]) + 1) * sizeof(entryPoints[0][0]));
    ON_WIN32_ERROR_EXIT(retCode);

    retCode = RegSetValueEx(hKey, L"Close", 0, REG_SZ, (BYTE *) entryPoints[1], (DWORD) (wcslen(entryPoints[1]) + 1) * sizeof(entryPoints[1][0]));
    ON_WIN32_ERROR_EXIT(retCode);

    retCode = RegSetValueEx(hKey, L"Collect", 0, REG_SZ, (BYTE *) entryPoints[2], (DWORD) (wcslen(entryPoints[2]) + 1) * sizeof(entryPoints[2][0]));
    ON_WIN32_ERROR_EXIT(retCode);

Cleanup:
    if (hKey != NULL)
        RegCloseKey(hKey);
    return hr;
}


#define PERF_DELETE_VALUES(x) WCHAR* x [] = {L"First Counter", L"Last Counter", L"First Help", L"Last Help", L"Object List"};
#define PERF_DELETE_VALUES_COUNT 5

HRESULT InstallGenericPerfCounters(void)
{
    HRESULT hr = S_OK;
    WCHAR cmdLine[MAX_PATH * 2];
    PERF_GENERIC_ENTRY_POINTS(genericEntryPoints);

    CSetupLogging::Log(1, "InstallGenericPerfCounters", 0, "Install common performance counters");
    
    // Uninstall the common perf counters
    StringCchCopyToArrayW(cmdLine, L"u ASP.NET");
    UnloadPerfCounterTextStrings(cmdLine, TRUE);

    // Create the entry points for the generic perf counter
    CreatePerfCounterEntryPoints(REGPATH_PERF_GENERIC_PERFORMANCE_KEY_L, genericEntryPoints);

    // Install the common name counters
    cmdLine[0] = L'\0';
    // An extra "l " is prepended to get around Q188769
    StringCchCatToArrayW(cmdLine, L"l \"");
    StringCchCatToArrayW(cmdLine, Names::InstallDirectory());
    StringCchCatToArrayW(cmdLine, L"\\" PERF_INI_COMMON_FULL_NAME_L);
    StringCchCatToArrayW(cmdLine, L"\"");
        
    // Lenght of cmdline minus length of non-path characters
    if (lstrlenW(cmdLine) - 4 >= MAX_PATH) {
        EXIT_WITH_WIN32_ERROR(ERROR_FILENAME_EXCED_RANGE);
    }
    
    hr = LoadPerfCounterTextStrings(cmdLine, TRUE);
    ON_WIN32_ERROR_EXIT(hr);

Cleanup:
    CSetupLogging::Log(hr, "InstallGenericPerfCounters", 0, "Install common performance counters");

    return hr;
}

HRESULT LookupAccount(LPCWSTR pwcsPrincipal, PSID * Sid)
{
    HRESULT hr = S_OK;
    WCHAR * refDomain = NULL;
    DWORD refDomainSize = 0;
    WCHAR wcsCompName[256] = L"";
    DWORD dwCompName = (sizeof(wcsCompName) / sizeof(wcsCompName[0])) - 1;
    SID_NAME_USE snu;
    PSID tmpSid = NULL;
    DWORD sidSize = 0;
    BOOL fRet;

    ASSERT(wcschr(pwcsPrincipal, L'\\') == NULL);

    // Call this once to get the buffer sizes needed
    fRet = LookupAccountName(NULL, pwcsPrincipal, NULL, &sidSize, NULL, &refDomainSize, &snu);

    // The call is supposed to fail -- if it succeeds or the error is NOT insufficient buffer, exit
    if (fRet)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    hr = GetLastWin32Error();
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        hr = S_OK;
    }
    ON_ERROR_EXIT();
        
    // Allocate the Sid
    tmpSid = (PSID) NEW_CLEAR_BYTES(sidSize);
    ON_OOM_EXIT(tmpSid);

    // Allocate the domain name
    refDomain = new WCHAR[refDomainSize];
    ON_OOM_EXIT(refDomain);

    // Do the real lookup
    fRet = LookupAccountName (NULL,
                              pwcsPrincipal,
                              tmpSid,
                              &sidSize,
                              refDomain,
                              &refDomainSize,
                              &snu);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

    // If domain is not "BUILTIN", check and see if it's this local computer name
    if (_wcsicmp(refDomain, L"BUILTIN") != 0) 
    {
        ON_ZERO_EXIT_WITH_LAST_ERROR(GetComputerName(wcsCompName, &dwCompName));

        if (_wcsicmp(wcsCompName, refDomain) != 0)
            EXIT_WITH_HRESULT(E_FAIL);
    }
    
    *Sid = tmpSid;
    tmpSid = NULL;
    
Cleanup:
    DELETE_BYTES(tmpSid);
    delete [] refDomain;
    
    return hr;
}

//
// CreateSd
//
// Creates a SECURITY_DESCRIPTOR with specific DACLs.  Modify the code to
// change. 
//
// Caller must free the returned buffer if not NULL.
//
HRESULT CreatePerfCounterSd(PSECURITY_DESCRIPTOR * descriptor)
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR Sd = NULL;
    LONG AclSize;
    DWORD UserCount;
    PSID Users[5];  // The index are: 0 - BuiltInAdministrators
                    //                1 - LocalSystem
                    //                2 - AuthenticatedUsers
                    //                3 - ASPNET
                    //                4 - IISWPG

    ZeroMemory(Users, sizeof(Users));

    //
    // An SID is built from an Identifier Authority and a set of Relative IDs
    // (RIDs).  The Authority of interest to us SECURITY_NT_AUTHORITY.
    //
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    //
    // Each RID represents a sub-unit of the authority.  Two of the SIDs we
    // want to build, Local Administrators, and Power Users, are in the "built
    // in" domain.  The other SID, for Authenticated users, is based directly
    // off of the authority.
    //     
    // For examples of other useful SIDs consult the list in
    // \nt\public\sdk\inc\ntseapi.h.
    //
    if (!AllocateAndInitializeSid(&NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0,0,0,0,0,0, &Users[0])) 
        EXIT_WITH_LAST_ERROR();
    
    if (!AllocateAndInitializeSid(&NtAuthority, 1, SECURITY_LOCAL_SYSTEM_RID, 0,0,0,0,0,0,0, &Users[1]))
        EXIT_WITH_LAST_ERROR();

    if (!AllocateAndInitializeSid(&NtAuthority, 1, SECURITY_AUTHENTICATED_USER_RID, 0,0,0,0,0,0,0, &Users[2]))
        EXIT_WITH_LAST_ERROR();

    hr = LookupAccount(L"ASPNET", &Users[3]);
    ON_ERROR_CONTINUE(); hr = S_OK;

    hr = LookupAccount(L"IIS_WPG", &Users[4]);
    ON_ERROR_CONTINUE(); hr = S_OK;

    UserCount = 0;

    for (int i = 0; i < 5; i++) {
        if (Users[i] != NULL)
            UserCount++;
    }
    
    // Calculate the size of and allocate a buffer for the DACL, we need
    // this value independently of the total alloc size for ACL init.

    // "- sizeof (LONG)" represents the SidStart field of the
    // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
    // SID, this field is counted twice.

    AclSize = sizeof (ACL) +
        (UserCount * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (LONG)));

    for (int i = 0; i < 5; i++) {
        if (Users[i] != NULL) {
            AclSize += GetLengthSid(Users[i]);
        }
    }

    Sd = (PSECURITY_DESCRIPTOR) NEW_BYTES(SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);
    ON_OOM_EXIT(Sd);

    ACL *Acl;
    Acl = (ACL *)((BYTE *)Sd + SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (!InitializeAcl(Acl, AclSize, ACL_REVISION)) 
        EXIT_WITH_LAST_ERROR();

    // Set GENERIC_ALL for Admin
    if (!AddAccessAllowedAce(Acl, ACL_REVISION, GENERIC_ALL, Users[0])) 
        EXIT_WITH_LAST_ERROR();

    // Set GENERIC_ALL for LocalSystem
    if (!AddAccessAllowedAce(Acl, ACL_REVISION, GENERIC_ALL, Users[1])) 
        EXIT_WITH_LAST_ERROR();

    // Set GENERIC_READ for AuthenticatedUsers
    if (!AddAccessAllowedAce(Acl, ACL_REVISION, GENERIC_READ, Users[2])) 
        EXIT_WITH_LAST_ERROR();

    // Set GENERIC_READ | GENERIC_WRITE for ASPNET
    if (Users[3] != NULL)
        if (!AddAccessAllowedAce(Acl, ACL_REVISION, GENERIC_READ | GENERIC_WRITE, Users[3])) 
            EXIT_WITH_LAST_ERROR();

    // Set GENERIC_READ | GENERIC_WRITE for IISWPG
    if (Users[4] != NULL)
        if (!AddAccessAllowedAce(Acl, ACL_REVISION, GENERIC_READ | GENERIC_WRITE, Users[4])) 
            EXIT_WITH_LAST_ERROR();

    if (!InitializeSecurityDescriptor(Sd, SECURITY_DESCRIPTOR_REVISION)) 
        EXIT_WITH_LAST_ERROR();

    if (!SetSecurityDescriptorDacl(Sd, TRUE, Acl, FALSE)) 
        EXIT_WITH_LAST_ERROR();

    *descriptor = Sd;
    Sd = NULL;

Cleanup:
    for (int i = 0; i < 3; i++) {
        FreeSid(Users[i]);
    }
    
    for (int i = 3; i < 5; i++) {
        DELETE_BYTES(Users[i]);
    }

    DELETE_BYTES(Sd);
        
    return hr;
}

HRESULT CreateVersionedPerfKeys()
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSd = NULL;
    SECURITY_ATTRIBUTES sa;
    HKEY hKey = NULL;
    DWORD disposition;
    LONG retCode;
    PERF_VERSIONED_ENTRY_POINTS(versionedEntryPoints);

    // Create entry points for the perf dll
    hr = CreatePerfCounterEntryPoints(REGPATH_PERF_VERSIONED_PERFORMANCE_KEY_L, versionedEntryPoints);
    ON_ERROR_EXIT();

    // Create the SD for the Names registry entry
    hr = CreatePerfCounterSd(&pSd);
    ON_ERROR_EXIT();

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = pSd;
    sa.bInheritHandle = FALSE;

    // Create the Names registry entry
    retCode = RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGPATH_PERF_VERSIONED_NAMES_KEY_L, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, &sa, &hKey, &disposition);
    ON_WIN32_ERROR_EXIT(retCode);
Cleanup:
    if (pSd)
        MemFree(pSd);

    if (hKey)
        RegCloseKey(hKey);

    return hr;
}


/*
    Here's the deal for installing perf counters.  Because that ASP.NET must be able to run side-by-side, 
    there needed to be a way of having the perf counters also run side-by-side.  The scheme is as follow:

    1. When ASP.NET registers the counters, it puts the full path to the perf dll in the "Library" key.  It 
       also registers what is the same set of counters under the "ASP.NET" service key with a non-versioned
       name for the categories.
    2. Since multiple versions of the counters may be installed, the service name must also be versioned.
       This is accomplished by making the service name be of the format "ASP.NET_x.x.xxx.x".  Each subsequent
       version will install a new versioned name, so they won't clobber each other.  The user strings in the
       ini file are also modified accordingly.
    3. The code also tries to do some cleanup of old/overridable entries.  Basically it does a search through
       the perf counters and anything starting with "ASP.NET" that also has the "Library" key pointing to the 
       same dll as the new one gets nuked.  This should eliminate any doubling or cluttering of these counters.

*/
HRESULT 
InstallVersionedPerfCounters(void)
{
    HRESULT hr;
    WCHAR cmdLine[MAX_PATH * 2];
    WCHAR keyName[MAX_PATH * 2 + sizeof(WCHAR)];
    DWORD index = 0;
    DWORD nameLength;
    HKEY servicesKey = NULL;
    ServiceName * toBeDeleted = NULL;
    WCHAR * currentDllPath = NULL;
    
    CSetupLogging::Log(1, "InstallVersionedPerfCounters", 0, "Install the ASP.NET Perfomanace counters");

    // Create the perf counter pipe name holder registry key
    // Setup the perf counter's "names" key with the proper ACL's
    hr = CreateVersionedPerfKeys();
    ON_ERROR_EXIT();
    
    cmdLine[0] = L'\0';
    // An extra "l " is prepended to get around Q188769
    StringCchCatToArrayW(cmdLine, L"l \"");
    StringCchCatToArrayW(cmdLine, Names::InstallDirectory());
    StringCchCatToArrayW(cmdLine, L"\\" PERF_INI_FULL_NAME_L);
    StringCchCatToArrayW(cmdLine, L"\"");

    // Lenght of cmdline minus length of non-path characters
    if (lstrlenW(cmdLine) - 4 >= MAX_PATH) {
        EXIT_WITH_WIN32_ERROR(ERROR_FILENAME_EXCED_RANGE);
    }
    
    hr = LoadPerfCounterTextStrings(cmdLine, TRUE);
    ON_WIN32_ERROR_EXIT(hr);

    // Cleanup the registry and remove redundant perf counter entries mapping to the same dll

    // Get the current dll path for this service
    hr = GetLibraryValue(PERF_SERVICE_VERSION_NAME_L, &currentDllPath);
    ON_ERROR_EXIT();

    // Open the system's "Services" key and start enumerating them
    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_SERVICES_KEY_L, 0, KEY_READ, &servicesKey);
    ON_WIN32_ERROR_EXIT(hr);

    while (hr != ERROR_NO_MORE_ITEMS) {
        FILETIME fileTime;
        nameLength = MAX_PATH * 2 + sizeof(WCHAR);
        hr = RegEnumKeyEx(servicesKey, index, (LPWSTR) &keyName, &nameLength, 0, 0, 0, &fileTime);
        if (hr == ERROR_SUCCESS) {
            // If the name starts with "ASP.NET", check its innards
            if (IsAspNet(keyName) == 0) {
                // If the service name is not the one that was just installed, take a look inside
                if (wcscmp(keyName, PERF_SERVICE_VERSION_NAME_L) != 0) {
                    // Get its "Library" value.  If the value doesn't exist or is not a string, skip it.
                    WCHAR * value;
                    hr = GetLibraryValue(keyName, &value);
                    ON_ERROR_CONTINUE();
                    if ((value == NULL) || (_wcsicmp(value, currentDllPath) == 0)) {
                        // Ah, ha! It's a string and it's the same as the currently installed one.  Remember
                        // it for removal, since the API doesn't like having entries mucked with while enumerating
                        // NOTE: A copy is needed because the "keyName" buffer will be reused
                        WCHAR * keyNameCopy = new WCHAR[nameLength + 1];
                        ON_OOM_EXIT(keyNameCopy);
                        StringCchCopyW(keyNameCopy, nameLength+1, keyName);
                        toBeDeleted = PushServiceName(toBeDeleted, keyNameCopy);
                        ON_OOM_EXIT(toBeDeleted);
                    }
                 }
            }
        }
        index++;
    }

    // Go through the list of entries and delete each key
    while (toBeDeleted) {
        WCHAR * name;
        toBeDeleted = PopServiceName(toBeDeleted, &name);
        DeletePerfKey(name);
        delete [] name;
    }

    // If it got here, then everything went ok!
    hr = S_OK;

Cleanup:
    CSetupLogging::Log(hr, "InstallVersionedPerfCounters", 0, "Install the ASP.NET Perfomanace counters");
    
    if (servicesKey != NULL) {
        RegCloseKey(servicesKey);
    }

    if (currentDllPath != NULL) {
        delete [] currentDllPath;
    }

    return hr;
}

HRESULT 
UninstallPerfCounters(WCHAR *pchVersion, BOOL updateCommon)
{
    HRESULT hr = S_OK;
    CRegInfo reginfoNext;
    WCHAR cmdLine[MAX_PATH * 2];
    DWORD sc;
    HKEY hKey = NULL;

    CSetupLogging::Log(1, "UninstallPerfCounters", 0, "Uninstalling performance counters");
    
    // Uninstall the current version
    cmdLine[0] = L'\0';
    // An extra "u " is prepended to get around Q188769
    StringCchCatToArrayW(cmdLine, L"u \"");
    StringCchCatToArrayW(cmdLine, pchVersion);
    StringCchCatToArrayW(cmdLine, L"\"");
    UnloadPerfCounterTextStrings(cmdLine, TRUE);

    // Delete the versioned perf key
    DeletePerfKey(PERF_SERVICE_VERSION_NAME_L);

    // If we're supposed to update the common "ASP.NET" counter, 
    // get the common "ASP.NET" counter point to the next higher version
    if (updateCommon) {
        hr = reginfoNext.InitHighestInfo(&ASPNETVER::ThisVer());
        if (hr) {
            // If an error happened, or if we cannot find a "next highest version", 
            // remove the "ASP.NET" common key and return

            if (hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
                XspLogEvent(IDS_EVENTLOG_UNREGISTER_FAILED_NEXT_HIGHEST, L"Perf Counter %s^0x%08x", 
                            PRODUCT_VERSION_L, hr);
            }

            hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_SERVICES_KEY_L, 0, KEY_ALL_ACCESS, &hKey);
            sc = SHDeleteKey(hKey, REGPATH_PERF_GENERIC_ROOT_KEY_L);
            if (sc == ERROR_FILE_NOT_FOUND || sc == ERROR_PATH_NOT_FOUND) {
                sc = S_OK;
            }
            ON_WIN32_ERROR_EXIT(sc);
        }
        else {
            // Else, if we found the next highest one, uninstall this version and install the next one
            // An extra "l " is prepended to get around Q188769
            StringCchCatToArrayW(cmdLine, L"u ASP.NET");
            UnloadPerfCounterTextStrings(cmdLine, TRUE);

            hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_PERF_GENERIC_PERFORMANCE_KEY_L, 0, KEY_ALL_ACCESS, &hKey);
            ON_WIN32_ERROR_EXIT(hr);

            // Reset the library key
            hr = RegSetValueEx(hKey, 
                               L"Library", 
                               0, 
                               REG_SZ, 
                               (const BYTE*) reginfoNext.GetHighestVersionDllPath(),
                               (DWORD) ((wcslen(reginfoNext.GetHighestVersionDllPath()) + 1) * sizeof(WCHAR)));
            ON_WIN32_ERROR_EXIT(hr);
            
            cmdLine[0] = L'\0';
            // An extra "l " is prepended to get around Q188769
            StringCchCatToArrayW(cmdLine, L"l \"");
            StringCchCatToArrayW(cmdLine, reginfoNext.GetHighestVersionInstallPath());
            StringCchCatToArrayW(cmdLine, L"\\");
            StringCchCatToArrayW(cmdLine, L"aspnet_");

            StringCchCatToArrayW(cmdLine, L"perf2.ini\"");

            // Lenght of cmdline minus length of non-path characters
            if (lstrlenW(cmdLine) - 4 >= MAX_PATH) {
                EXIT_WITH_WIN32_ERROR(ERROR_FILENAME_EXCED_RANGE);
            }
            
            hr = LoadPerfCounterTextStrings(cmdLine, TRUE);
            ON_WIN32_ERROR_EXIT(hr);
        }
    }

Cleanup:
    CSetupLogging::Log(hr, "UninstallPerfCounters", 0, "Uninstalling performance counters");
    
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
   
    return hr;
}

HRESULT
UninstallAllPerfCounters(void)
{
    CStrAry csKeys;
    HRESULT hr = S_OK;
    int     iKey;
    
    CSetupLogging::Log(1, "UninstallAllPerfCounters", 0, "Uninstalling all performance counters");
    
    hr = CRegInfo::EnumKeyWithVer(REGPATH_SERVICES_KEY_L, NULL, &csKeys);
    ON_ERROR_EXIT();

    // Go through the list of entries and delete each key
    for( iKey = 0; iKey < csKeys.Size(); iKey++ ) {
        hr = UninstallPerfCounters(csKeys[iKey], false);
        ON_ERROR_CONTINUE();
    }
        
Cleanup:
    CSetupLogging::Log(hr, "UninstallAllPerfCounters", 0, "Uninstalling all performance counters");
    CleanupCStrAry(&csKeys);
    return hr;
}


HRESULT
CreateListSiteClientScriptDir(WCHAR *pchDir, CStrAry *pcsDstDirs, DWORD dwFlags) {
    HRESULT     hr = S_OK;
    WCHAR       *pchPath = NULL, *pchPathAllVer = NULL;
    int         len, i;
    BOOL        fListOnly = !!(dwFlags & SETUP_SCRIPT_FILES_REMOVE);
    BOOL        fAllVers = !!(dwFlags & SETUP_SCRIPT_FILES_ALLVERS);
    CStrAry     csSubDirs;
    SECURITY_ATTRIBUTES sa;

    // Create the DACL for the directory to be created.
    // Access is: SYSTEM:Full, Admin:Full, Users:Read, Everyone:Read
    WCHAR wcsSD[] = L"D:(A;OICI;GA;;;SY)(A;OICI;GA;;;BA)(A;OICI;GR;;;BU)(A;OICI;GR;;;WD)";  

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = FALSE;
    sa.lpSecurityDescriptor = NULL;
    ON_ZERO_EXIT_WITH_LAST_ERROR(ConvertStringSecurityDescriptorToSecurityDescriptor(wcsSD, 
                                                                                     SDDL_REVISION_1, 
                                                                                     &(sa.lpSecurityDescriptor), 
                                                                                     NULL));
    len = lstrlenW(pchDir)
          + 1                           // Path-Separator
          + lstrlenW(ASPNET_CLIENT_DIR_L) // "aspnet_client"
          + 1                           // Path-Separator
          + lstrlenW(ASPNET_CLIENT_SYS_WEB_DIR_L) // "system_web"
          + 1;                           // Terminating NULL

    if (!fAllVers) {
        len += 1                           // Path-Separator
               + lstrlenW(VER_UNDERSCORE_PRODUCTVERSION_STR_L);  // Version string
    }

    if (len > MAX_PATH) {
        EXIT_WITH_WIN32_ERROR(ERROR_FILENAME_EXCED_RANGE);
    }

    pchPath = new WCHAR[len];
    ON_OOM_EXIT(pchPath);
    
    // First create "\aspnet_client" subdir
    StringCchCopyW(pchPath, len, pchDir);
    StringCchCatW(pchPath, len, PATH_SEPARATOR_STR_L);
    StringCchCatW(pchPath, len, ASPNET_CLIENT_DIR_L);

    if (!fListOnly) {
        CSetupLogging::Log(1, "CreateDirectory", 0, "Creating aspnet_client directory");
        if (!CreateDirectory(pchPath, &sa)) {
            if (GetLastError() != ERROR_ALREADY_EXISTS) {
                CONTINUE_WITH_LAST_ERROR();
                CSetupLogging::Log(hr, "CreateDirectory", 0, "Creating aspnet_client directory");        
                ON_ERROR_EXIT();
            }
        }
        CSetupLogging::Log(S_OK, "CreateDirectory", 0, "Creating aspnet_client directory");        
    }

    // Then the assembly name
    StringCchCatW(pchPath, len, PATH_SEPARATOR_STR_L);
    StringCchCatW(pchPath, len, ASPNET_CLIENT_SYS_WEB_DIR_L);
    
    if (!fListOnly) {
        CSetupLogging::Log(1, "CreateDirectory", 0, "Creating system_web sub-directory in aspnet_client directory");
        if (!CreateDirectory(pchPath, &sa)) {
            if (GetLastError() != ERROR_ALREADY_EXISTS) {
                CONTINUE_WITH_LAST_ERROR();
                CSetupLogging::Log(hr, "CreateDirectory", 0, "Creating aspnet_client\\system_web directory");
                ON_ERROR_EXIT();
            }
        }
        CSetupLogging::Log(S_OK, "CreateDirectory", 0, "Creating aspnet_client\\system_web directory");
    }

    if (fAllVers) {
        int     lenBasePath = lstrlenW(pchPath);
        int     lenPathVer;

        // Enumerate the directory and find out all "version" sub-dirs
        CSetupLogging::Log(1, "ListDir", 0, "Listing directory");        
        hr = ListDir(pchPath, LIST_DIR_DIRECTORY, &csSubDirs);
        if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) {
            hr = S_OK;
        }
        CSetupLogging::Log(hr, "ListDir", 0, "Listing directory");        
        ON_ERROR_EXIT();

        for (i = 0; i < csSubDirs.Size(); i++) {
            DWORD   dw1, dw2, dw3, dw4; // Just temp variable.

            // Skip all directories that don't have a version format
            if (swscanf(csSubDirs[i], L"%d_%d_%d_%d",
                            &dw1, &dw2, &dw3, &dw4) != 4) {
                continue;
            }

            lenPathVer = lenBasePath
                         + 1        // Path separator
                         + lstrlenW(csSubDirs[i])
                         + 1;       // Terminating NULL

            pchPathAllVer = new WCHAR[lenPathVer];
            ON_OOM_EXIT(pchPathAllVer);

            StringCchCopyW(pchPathAllVer, lenPathVer, pchPath);
            StringCchCatW(pchPathAllVer, lenPathVer, PATH_SEPARATOR_STR_L);
            StringCchCatW(pchPathAllVer, lenPathVer, csSubDirs[i]);
            ASSERT(lstrlenW(pchPathAllVer) == lenPathVer-1);
            ASSERT(lstrlenW(pchPathAllVer) < MAX_PATH);

            hr = pcsDstDirs->Append(pchPathAllVer);
            ON_ERROR_EXIT();
            
            pchPathAllVer = NULL;
        }
    }
    else {
        
        // Then the version
        StringCchCatUnsafeW(pchPath, PATH_SEPARATOR_STR_L);
        StringCchCatUnsafeW(pchPath, VER_UNDERSCORE_PRODUCTVERSION_STR_L);

        if (!fListOnly) {
            CSetupLogging::Log(1, "CreateDirectory", 0, "Creating aspnet_client\\system_web\\version directory");        
            if (!CreateDirectory(pchPath, &sa)) {
                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    CONTINUE_WITH_LAST_ERROR();
                    CSetupLogging::Log(hr, "CreateDirectory", 0, "Creating aspnet_client\\system_web\\version directory");
                    ON_ERROR_EXIT();                    
                }
            }
            CSetupLogging::Log(S_OK, "CreateDirectory", 0, "Creating aspnet_client\\system_web\\version directory");
        }

        ASSERT(lstrlenW(pchPath) == len-1);
        
        hr = AppendCStrAry(pcsDstDirs, pchPath);
        ON_ERROR_EXIT();
    }
    
Cleanup:
    CleanupCStrAry(&csSubDirs);
    LocalFree(sa.lpSecurityDescriptor);

    delete [] pchPathAllVer;
    delete [] pchPath;
    
    return hr;
}


HRESULT
SetupSiteClientScriptFiles(CStrAry *pcsDstDirs, CStrAry *pcsScriptFiles, DWORD dwFlags) {
    HRESULT     hr = S_OK;
    WCHAR       *pchSrcFile = NULL;
    WCHAR       *pchSrcFilePath = NULL;
    WCHAR       *pchDstFilePath = NULL;
    WCHAR       *pchDst;
    BOOL        fRet;
    int         iFile, iDir, len;
    BOOL        fRemove = !!(dwFlags & SETUP_SCRIPT_FILES_REMOVE);
//    BOOL        fAllVers = !!(dwFlags & SETUP_SCRIPT_FILES_ALLVERS);

    for (iDir=0; iDir < pcsDstDirs->Size(); iDir++) {
        pchDst = (*pcsDstDirs)[iDir];
        
        for (iFile=0; iFile < pcsScriptFiles->Size(); iFile++) {
            pchSrcFile = (*pcsScriptFiles)[iFile];

            if (!fRemove) {
                // Create the fullpath of the source file
                len = lstrlenW(Names::ClientScriptSrcDir())
                      + 1                   // Path separator
                      + lstrlenW(pchSrcFile)// The source file
                      + 1;                  // Terminating NULL

                WCHAR * pchRealloc =  new(pchSrcFilePath, NewReAlloc) WCHAR[len];
                ON_OOM_EXIT(pchRealloc);
                pchSrcFilePath = pchRealloc;

                StringCchCopyW(pchSrcFilePath, len, Names::ClientScriptSrcDir());
                StringCchCatW(pchSrcFilePath, len, PATH_SEPARATOR_STR_L);
                StringCchCatW(pchSrcFilePath, len, pchSrcFile);
                ASSERT(lstrlenW(pchSrcFilePath) == len-1);
            }

            // Create the fullpath of the dst file
            len = lstrlenW(pchDst)
                  + 1                   // Path separator
                  + lstrlenW(pchSrcFile)// The dst file (== src file)
                  + 1;                  // Terminating NULL
                  
            WCHAR * pchRealloc =  new(pchDstFilePath, NewReAlloc) WCHAR[len];
            ON_OOM_EXIT(pchRealloc);
            pchDstFilePath = pchRealloc;

            StringCchCopyW(pchDstFilePath, len, pchDst);
            StringCchCatW(pchDstFilePath, len, PATH_SEPARATOR_STR_L);
            StringCchCatW(pchDstFilePath, len, pchSrcFile);
            ASSERT(lstrlenW(pchDstFilePath) == len-1);

            if (fRemove) {
                // Delete the file if exists
                if (PathFileExists(pchDstFilePath)) {
                    if (lstrlenW(pchDstFilePath) >= MAX_PATH) {
                        fRet = FALSE;
                        hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
                    }
                    else {
                        CSetupLogging::Log(1, "DeleteFile", 0, "Deleting file");        
                        fRet = DeleteFile(pchDstFilePath);
                        ON_ZERO_CONTINUE_WITH_LAST_ERROR(fRet);
                        CSetupLogging::Log(hr, "DeleteFile", 0, "Deleting file");        
                    }

                    if (!fRet) {
                        XspLogEvent(IDS_EVENTLOG_REMOVE_CLIENT_SIDE_SCRIPT_FILES_SPECIFIC_FAILED,
                                    L"%s^%08x", pchDstFilePath, hr);
                        ON_ERROR_EXIT();
                    }
                }
            }
            else {
                if (lstrlenW(pchSrcFilePath) >= MAX_PATH || lstrlenW(pchDstFilePath) >= MAX_PATH) {
                    fRet = FALSE;
                    hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
                }
                else {
                    // Copy the file
                    CSetupLogging::Log(1, "CopyFile", 0, "Copying file");        
                    fRet = CopyFile(pchSrcFilePath, pchDstFilePath, FALSE);
                    ON_ZERO_CONTINUE_WITH_LAST_ERROR(fRet);
                    CSetupLogging::Log(hr, "CopyFile", 0, "Copying file");        
                }
                if (!fRet) {
                    XspLogEvent(IDS_EVENTLOG_COPY_CLIENT_SIDE_SCRIPT_FILES_SPECIFIC_FAILED,
                                L"%s^%s^%08x", pchSrcFilePath, pchDstFilePath, hr);
                    ON_ERROR_EXIT();
                }
            }
        }
    }
    
Cleanup:
    delete [] pchSrcFilePath;
    delete [] pchDstFilePath;
    
    return hr;
}


HRESULT
RemoveSiteClientScriptDir(WCHAR *pchBaseDir, CStrAry *pcsDirs) {
    HRESULT     hr = S_OK;
    int         iDir;
    WCHAR       *pchDir = NULL, *pchLast, *pchBaseDirNoBackslash = NULL;
    BOOL        fRet;
    
    CSetupLogging::Log(1, "RemoveSiteClientScriptDir", 0, "Removing client site scripts dirs");        

    // Remove any potential trailing backslash in pchBaseDir, for the sake
    // of accurate string comparson
    pchBaseDirNoBackslash = DupStr(pchBaseDir);
    ON_OOM_EXIT(pchBaseDirNoBackslash);
    PathRemoveBackslash(pchBaseDir);

    // Go thru each directory and try to remove it and all its parent
    // directories (if non-empy), up to pchBaseDirNoBackslash
    for (iDir=0; iDir < pcsDirs->Size(); iDir++) {
        if (lstrlenW((*pcsDirs)[iDir]) >= MAX_PATH) {
            XspLogEvent(IDS_EVENTLOG_REMOVE_CLIENT_SIDE_SCRIPT_DIR_FAILED,
                    L"%s^%08x", (*pcsDirs)[iDir], 
                    HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE));
            continue;
        }
        
        pchDir = DupStr((*pcsDirs)[iDir]);
        ON_OOM_EXIT(pchDir);

        // Move up and remove all directories, until we are either at the base dir,
        // or if any directory is non-empty
        while(_wcsicmp(pchDir, pchBaseDirNoBackslash) != 0 &&
              PathIsDirectory(pchDir) &&
              PathIsDirectoryEmpty(pchDir)) {

            CSetupLogging::Log(1, "RemoveDirectory", 0, "Removing directory");        
            fRet = RemoveDirectory(pchDir);
            ON_ZERO_CONTINUE_WITH_LAST_ERROR(fRet);
            CSetupLogging::Log(hr, "RemoveDirectory", 0, "Removing directory");        
            if (!fRet) {
                XspLogEvent(IDS_EVENTLOG_REMOVE_CLIENT_SIDE_SCRIPT_DIR_FAILED,
                    L"%s^%08x", pchDir, hr);
                break;
            }

            // Move to the parent directory
            pchLast = &pchDir[lstrlenW(pchDir)];
            while (*pchLast != PATH_SEPARATOR_CHAR_L) {
                pchLast--;
                ASSERT(pchLast >= pchDir);
            }
            *pchLast = '\0';
        }

        delete [] pchDir;
        pchDir = NULL;
        hr = S_OK;
    }
    
Cleanup:
    CSetupLogging::Log(hr, "RemoveSiteClientScriptDir", 0, "Removing client site scripts dirs");        
    
    delete [] pchDir;
    delete [] pchBaseDirNoBackslash;
    return hr;
}


HRESULT
RemoveSiteClientScriptIISKey(WCHAR *pchAppRoot, WCHAR *pchSiteDir) {
    HRESULT     hr = S_OK;
    WCHAR       *pchPath = NULL;
    int         len;

    CSetupLogging::Log(1, "RemoveSiteClientScriptIISKey", 0, "Removing client site scripts IIS Keys");
    
    // If the aspnet_client directory hasn't been deleted, then just
    // leave don't remove the IIS key.
    len = lstrlenW(pchSiteDir)
          + 1       // path separator
          + lstrlenW(ASPNET_CLIENT_DIR_L)
          + 1;      // terminating NULL
          
    pchPath = new WCHAR[len];
    ON_OOM_EXIT(pchPath);

    StringCchCopyW(pchPath, len, pchSiteDir);
    StringCchCatW(pchPath, len, PATH_SEPARATOR_STR_L);
    StringCchCatW(pchPath, len, ASPNET_CLIENT_DIR_L);
    
    if (PathIsDirectory(pchPath)) {
        EXIT();
    }

    CSetupLogging::Log(1, "RemoveKeyIIS", 0, "Removing IIS Key");        
    hr = RemoveKeyIIS(pchAppRoot, ASPNET_CLIENT_DIR_L);
    CSetupLogging::Log(hr, "RemoveKeyIIS", 0, "Removing IIS Key");        
    ON_ERROR_EXIT();
    
Cleanup:
    CSetupLogging::Log(hr, "RemoveSiteClientScriptIISKey", 0, "Removing client site scripts IIS Keys");

    delete [] pchPath;
    return hr;
}


/**
 * The function will copy/delete client script files, depending
 * on the flags passed in.  It also set/delete the key in IIS
 * metabase to restrict the access.
 */
HRESULT
SetupClientScriptFiles(DWORD dwFlags) {
    HRESULT     hr = S_OK;
    CStrAry     csWebSiteDirs;
    CStrAry     csWebSiteAppRoot;
    CStrAry     csScriptFiles;
    CStrAry     csDstDirs;
    int         i;
    BOOL        fRemove = !!(dwFlags & SETUP_SCRIPT_FILES_REMOVE);
    
    CSetupLogging::Log(1, "SetupClientScriptFiles", 0, "Installing client script files");        

    // Get a list of home directory + app root of all websites
    CSetupLogging::Log(1, "GetAllWebSiteDirs", 0, "Getting all web site dirs");        
    hr = GetAllWebSiteDirs(&csWebSiteDirs, &csWebSiteAppRoot);
    CSetupLogging::Log(hr, "GetAllWebSiteDirs", 0, "Getting all web site dirs");        
    ON_ERROR_EXIT();

    // Build up a list of source script files
    CSetupLogging::Log(1, "ListDir", 0, "Enumerating all client script source dirs");        
    hr = ListDir(Names::ClientScriptSrcDir(), LIST_DIR_FILE, &csScriptFiles);
    CSetupLogging::Log(hr, "ListDir", 0, "Enumerating all client script source dirs");        
    if (hr) {
        XspLogEvent(IDS_EVENTLOG_READ_CLIENT_SIDE_SCRIPT_FILES_FAILED, 
                                        L"%08x", hr);
        ON_ERROR_EXIT();
    }
        
    
    for (i=0; i < csWebSiteDirs.Size(); i++) {
        // Create or list the aspnet_client directory for each website
        CSetupLogging::Log(1, "CreateListSiteClientScriptDir", 0, "Creating list of client site scripts dirs");        
        hr = CreateListSiteClientScriptDir(csWebSiteDirs[i], &csDstDirs, dwFlags);
        CSetupLogging::Log(hr, "CreateListSiteClientScriptDir", 0, "Creating list of client site scripts dirs");        
        if (hr) {
            XspLogEvent(fRemove ? IDS_EVENTLOG_LISTING_CLIENT_SIDE_SCRIPT_DIR_FAILED:
                        IDS_EVENTLOG_CREATE_CLIENT_SIDE_SCRIPT_DIR_FAILED,
                        L"%s^%08x", csWebSiteDirs[i], hr);
            continue;
        }

        // Copy or remove the client script files
        CSetupLogging::Log(1, "SetupSiteClientScriptFiles", 0, "Setting up client site scripts dirs");        
        hr = SetupSiteClientScriptFiles(&csDstDirs, &csScriptFiles, dwFlags);
        CSetupLogging::Log(hr, "SetupSiteClientScriptFiles", 0, "Setting up client site scripts dirs");        
        if (hr) {
            XspLogEvent(fRemove ? IDS_EVENTLOG_REMOVE_CLIENT_SIDE_SCRIPT_FILES_FAILED:
                        IDS_EVENTLOG_COPY_CLIENT_SIDE_SCRIPT_FILES_FAILED,
                        L"%s^%08x", csWebSiteDirs[i], hr);
            continue;
        }

        //Remove the directory, if it's empty
        if (fRemove) {
            hr = RemoveSiteClientScriptDir(csWebSiteDirs[i], &csDstDirs);
            // The above function will log an event if error happens.
            continue;
        }

        CleanupCStrAry(&csDstDirs);

        if (fRemove) {
            hr = RemoveSiteClientScriptIISKey(csWebSiteAppRoot[i], csWebSiteDirs[i]);
            if (hr) {
                XspLogEvent(IDS_EVENTLOG_REMOVE_CLIENT_SIDE_SCRIPT_IIS_KEY_ACCESS_FAILED,
                        L"%s^%08x", csWebSiteAppRoot[i], hr);
                continue;
            }
        }
        else {
            // Set read-only access in IIS for the created subdir
            hr = SetClientScriptKeyProperties(csWebSiteAppRoot[i]);
            if (hr) {
                XspLogEvent(IDS_EVENTLOG_SET_CLIENT_SIDE_SCRIPT_IIS_KEY_ACCESS_FAILED,
                        L"%s^%08x", csWebSiteAppRoot[i], hr);
                continue;
            }
        }
    }
    
Cleanup:
    CSetupLogging::Log(hr, "SetupClientScriptFiles", 0, "Installing client script files");        
    
    CleanupCStrAry(&csWebSiteDirs);
    CleanupCStrAry(&csWebSiteAppRoot);
    CleanupCStrAry(&csScriptFiles);
    CleanupCStrAry(&csDstDirs);
    
    return hr;
}


STDAPI
InstallStateService() {
    HRESULT     hr;
    BOOL        rc;
    DWORD       err;
    WCHAR       szwAccount[USERNAME_PASSWORD_LENGTH + 2];
    WCHAR       szwPass[USERNAME_PASSWORD_LENGTH];
    SC_HANDLE   hSCM = NULL;
    SC_HANDLE   hService = NULL;
    SC_LOCK     scLock = NULL;
    int         c;
    CStateServerRegInfo ssreg;
    
    CSetupLogging::Log(1, "InstallStateService", 0, "Install the ASP.NET State Service");

    // Remember custom settings
    ssreg.Read();

    // If current one is highest, uninstall and reinstall StateService
    hr = InstallInfSections(g_DllInstance, true, L"StateService.Uninstall\0");
    ON_ERROR_CONTINUE();

    hr = InstallInfSections(g_DllInstance, true, L"StateService.Install\0");
    ON_ERROR_EXIT();

    // Write back custom settings
    ssreg.Set();

    // Get the account and password
    ZeroMemory(szwPass, sizeof(szwPass));
    ZeroMemory(szwAccount, sizeof(szwAccount));
    CSetupLogging::Log(1, "GetStateServerAccCredentials", 0, "Getting credentials for state service account");            
    hr = CRegAccount::GetStateServerAccCredentials(szwAccount, ARRAY_SIZE(szwAccount), szwPass, ARRAY_SIZE(szwPass));
    CSetupLogging::Log(hr, "GetStateServerAccCredentials", 0, "Getting credentials for state service account");            
    ON_ERROR_EXIT();

    if (wcschr(szwAccount, L'\\') == NULL) // If there is no domain name
    {
        DWORD dwLen = lstrlenW(szwAccount);
        if (dwLen < USERNAME_PASSWORD_LENGTH && dwLen < ARRAY_SIZE(szwAccount)-2)
        {
            WCHAR   szTemp[USERNAME_PASSWORD_LENGTH+2];
            StringCchCopyToArrayW(szTemp, L".\\");
            StringCchCatToArrayW(szTemp, szwAccount);
            StringCchCopyToArrayW(szwAccount, szTemp);
        }
    }

    // Open a handle to the Service.
    CSetupLogging::Log(1, "OpenSCManager", 0, "Connecting to Service Manager");        
    hSCM = OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT | SC_MANAGER_LOCK);
    ON_ZERO_CONTINUE_WITH_LAST_ERROR(hSCM);
    CSetupLogging::Log(hr, "OpenSCManager", 0, "Connecting to Service Manager");        
    ON_ERROR_EXIT();

    c = WAIT_FOR_SERVICE;
    CSetupLogging::Log(1, "LockServiceDatabase", 0, "Locking service database");        
    for (;;) {
        scLock = LockServiceDatabase(hSCM);
        if (scLock != NULL) {
            CSetupLogging::Log(S_OK, "LockServiceDatabase", 0, "Locking service database");        
            break;
        }

        err = GetLastError(); // bugbug -- ManuVa: changed GetLastWin32Error() to GetLastError()
        if (err != ERROR_SERVICE_DATABASE_LOCKED) {
            CSetupLogging::Log(HRESULT_FROM_WIN32(err), "LockServiceDatabase", 0, "Locking service database");
            EXIT_WITH_WIN32_ERROR(err);
        }

        if (--c == 0) {
            CSetupLogging::Log(HRESULT_FROM_WIN32(ERROR_SERVICE_REQUEST_TIMEOUT), 
                               "LockServiceDatabase", 0, "Locking service database");
            EXIT_WITH_WIN32_ERROR(ERROR_SERVICE_REQUEST_TIMEOUT);
        }

        Sleep(1000);
    }


    CSetupLogging::Log(1, "OpenService", 0, "Opening Service handle");        
    hService = OpenService(hSCM, STATE_SERVICE_NAME_L, SERVICE_CHANGE_CONFIG);
    ON_ZERO_CONTINUE_WITH_LAST_ERROR(hService);
    CSetupLogging::Log(hr, "OpenService", 0, "Opening Service handle");        
    ON_ERROR_EXIT();

    CSetupLogging::Log(1, "ChangeServiceConfig", 0, "Changing service configuration");
    rc = ChangeServiceConfig(
        hService, SERVICE_WIN32_OWN_PROCESS, SERVICE_NO_CHANGE, SERVICE_NO_CHANGE,
        NULL, NULL, NULL, NULL, szwAccount, szwPass, NULL);
    ON_ZERO_CONTINUE_WITH_LAST_ERROR(rc);
    CSetupLogging::Log(hr, "ChangeServiceConfig", 0, "Changing service configuration");

    if (rc == 0) {
        // Disable the service if it can't use the ASPNET account
        CSetupLogging::Log(1, "ChangeServiceConfig", 0, "Changing service configuration");
        rc = ChangeServiceConfig(
            hService, SERVICE_WIN32_OWN_PROCESS, SERVICE_DISABLED, SERVICE_NO_CHANGE,
            NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        
        ON_ZERO_CONTINUE_WITH_LAST_ERROR(rc);
        CSetupLogging::Log(hr, "ChangeServiceConfig", 0, "Changing service configuration");
        ON_ERROR_EXIT();
    }

Cleanup:
    CSetupLogging::Log(hr, "InstallStateService", 0, "Install the ASP.NET State Service");
    
    if (hService != NULL) {
        VERIFY(CloseServiceHandle(hService));
    }

    if (scLock != NULL) {
        VERIFY(UnlockServiceDatabase(scLock));
    }

    if (hSCM != NULL) {
        VERIFY(CloseServiceHandle(hSCM));
    }

    ZeroMemory(szwPass, sizeof(szwPass));

    return hr;
}

/*
 **
 *  Cleanup all the files and subdirs underneath for each version
 *  specified in plist
 */
HRESULT
CleanupTempDir(CASPNET_VER_LIST *plist)
{
    HRESULT hr = S_OK;
    int     i;
    WCHAR   *szDir = NULL, *szInstallPath;
    int     iSize, iLast;

    CSetupLogging::Log(1, "CleanupTempDir", 0, "Deleting the Temporary ASP.NET directory");        

    for(i=0; i < plist->Size(); i++) {
        szInstallPath = plist->GetInstallPath(i);
        ASSERT(szInstallPath != NULL);

        iSize = lstrlenW(szInstallPath) +
                1 +                         // "\\"
                lstrlenW(ASPNET_TEMP_DIR_L) +
                1;                          // "\0"

        szDir = new (NewClear) WCHAR[iSize];
        ON_OOM_EXIT(szDir);
            
        StringCchCopyW(szDir, iSize, szInstallPath);
        iLast = lstrlenW(szDir) - 1;

        if(iLast > 0 && szDir[iLast] != L'\\')
            szDir[iLast+1] = L'\\';
        
        StringCchCatW(szDir, iSize, ASPNET_TEMP_DIR_L);
        hr = RemoveDirectoryRecursively(szDir, FALSE);
        ON_ERROR_CONTINUE();

        delete [] szDir;
        szDir = NULL;
    }
    
Cleanup:
    CSetupLogging::Log(hr, "CleanupTempDir", 0, "Deleting the Temporary ASP.NET directory");        
    
    delete [] szDir;
    
    return hr;
}

void
PreRegisterCleanup()
{
    HRESULT hr;

    CSetupLogging::Log(1, "PreRegisterCleanup", 0, "Pre Registration cleanup");
    
    // Cleanup all redundant registry keys that share the same Dll path
    hr = CRegInfo::RegCleanup(REG_CLEANUP_SAME_PATH);
    ON_ERROR_CONTINUE();

    // Don't fail without perf counters
    hr = UninstallPerfCounters(PERF_SERVICE_VERSION_NAME_L, false);
    ON_ERROR_CONTINUE();

    hr = InstallInfSections(g_DllInstance, true, L"XSP.UninstallPerVer\0");
    ON_ERROR_CONTINUE();
    
    CSetupLogging::Log(S_OK, "PreRegisterCleanup", 0, "Pre Registration cleanup");
}

void
Unregister(DWORD unregMode, BOOL fRestartW3svc)
{
    HRESULT     hr;
    BOOL        fEmpty = FALSE;
    DWORD       dwScriptFlags;
    DWORD       lastStatusStateServer;
    DWORD       lastStatusW3svc;
    DWORD       lastStatusIISAdmin;
    DWORD       IISState;
    CASPNET_VER_LIST VerList;
        
    XspLogEvent(IDS_EVENTLOG_UNREGISTER_BEGIN, L"%s", PRODUCT_VERSION_L);
    CSetupLogging::Init(FALSE);

    // Remember IISAdmin original status.
    // Have to call this before CheckIISState is called.
    hr = GetServiceStatus(&lastStatusIISAdmin, IISADMIN_SERVICE_NAME_L);
    ON_ERROR_CONTINUE();
    
    hr = CheckIISState(&IISState);
    ON_ERROR_CONTINUE();

    // Remember W3svc original status
    hr = GetServiceStatus(&lastStatusW3svc, W3SVC_SERVICE_NAME_L);
    ON_ERROR_CONTINUE();

    // Don't fail without state service
    hr = StopServiceByName(&lastStatusStateServer, STATE_SERVICE_NAME_L);
    ON_ERROR_CONTINUE();

    if (IISState == IIS_STATE_ENABLED) {
        // Don't fail without IIS
        hr = UnregisterObsoleteIIS();
        ON_ERROR_CONTINUE();
    }

    // Cleanup all redundant registry keys that share the same path
    hr = CRegInfo::RegCleanup(REG_CLEANUP_SAME_PATH);
    ON_ERROR_CONTINUE();

    if (IISState == IIS_STATE_ENABLED) {
        // Don't fail without IIS
        hr = UnregisterIIS(unregMode == UNREG_MODE_FULL);
        ON_ERROR_CONTINUE();
    }

    // Need to remember the directory(s) to delete when cleaning the
    // Temporary directory later on.
    if (unregMode == UNREG_MODE_FULL) {
        CRegInfo    reginfo;
        
        // We need to remember all the versions and their installation path
        // because we want to cleanup the Temporary directories after
        // we have restarted IIS, but by that time all registries will
        // be deleted
        reginfo.GetVerInfoList(NULL, &VerList);
        ON_ERROR_CONTINUE();
    }
    else {
        // Just add the current version
        VerList.Add((WCHAR*)PRODUCT_VERSION_L, 0, (WCHAR*)Names::IsapiFullPath(), (WCHAR*)Names::InstallDirectory());
        ON_ERROR_CONTINUE();
    }
    
    if (unregMode == UNREG_MODE_FULL) {
        // Remove Worker process account
        CSetupLogging::Log(1, "DisablingASPNETAccount", 0, "Disabling ASPNET account and removing ACLs");
        hr = CRegAccount::UndoReg(TRUE, TRUE);
        ON_ERROR_CONTINUE();
        CSetupLogging::Log(hr, "DisablingASPNETAccount", 0, "Disabling ASPNET account and removing ACLs");

        fEmpty = TRUE;
    }
    else  {
        // Cleanup the current version if doing a "unreg".
        // Please note that if we're doing a "full-unreg", then the call to
        // InstallInfSections later will take care of registry cleanup.

        ASSERT(unregMode == UNREG_MODE_DLLUNREGISTER);
        
        // Don't fail without perf counters
        hr = UninstallPerfCounters(PERF_SERVICE_VERSION_NAME_L, true);
        ON_ERROR_CONTINUE();

        hr = InstallInfSections(g_DllInstance, true, L"XSP.UninstallPerVer\0");
        ON_ERROR_CONTINUE();
        
        // Check if there is any version left in the registry
        hr = CRegInfo::IsAllVerDeleted(&fEmpty);
        ON_ERROR_CONTINUE();

        // Remove Worker process account
        CSetupLogging::Log(1, "DisablingASPNETAccount", 0, "Disabling ASPNET account and removing ACLs");
        hr = CRegAccount::UndoReg(FALSE, fEmpty);
        ON_ERROR_CONTINUE();
        CSetupLogging::Log(hr, "DisablingASPNETAccount", 0, "Disabling ASPNET account and removing ACLs");
        
        // If there is still some version(s) left, we load the library
        // of the highest version, and call InstallStateServer from that
        // version to install the State Service
        if (!fEmpty) {
            do {
                CRegInfo                regInfo;
                HINSTANCE               hMod = NULL;
                LPFNINSTALLSTATESERVICE lpfnDllFunc = NULL;

                CSetupLogging::Log(1, "GetPreviousVersion", 0, "Getting previously installed ASP.NET isapi information");
                hr = regInfo.InitHighestInfo(NULL);
                CSetupLogging::Log(hr, "GetPreviousVersion", 0, "Getting previously installed ASP.NET isapi information");
                if (hr) {
                    ON_ERROR_CONTINUE();
                    break;
                }

                CSetupLogging::Log(1, "LoadIsapi", 0, "Loading previously installed ASP.NET isapi");
                hMod = LoadLibraryEx(regInfo.GetHighestVersionDllPath(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
                CSetupLogging::Log(hr, "LoadIsapi", 0, "Loading previously installed ASP.NET isapi");
                if (hMod == NULL) {
                    ON_ZERO_CONTINUE_WITH_LAST_ERROR(hMod);
                    break;
                }
                
                lpfnDllFunc = (LPFNINSTALLSTATESERVICE)GetProcAddress(hMod, "InstallStateService");
                ON_ZERO_CONTINUE_WITH_LAST_ERROR(lpfnDllFunc);

                if (lpfnDllFunc != NULL) {
                    // call the function
                    CSetupLogging::Log(1, "InstallStateService", 0, "Installing previously installed ASP.NET state service");
                    hr = lpfnDllFunc();
                    ON_ERROR_CONTINUE();
                    CSetupLogging::Log(hr, "InstallStateService", 0, "Installing previously installed ASP.NET state service");
                }

                VERIFY(FreeLibrary(hMod));
                hMod = NULL;
            } while (0);

            hr = S_OK;
        }
    }

    if (fEmpty) {
        // Do a final cleanup.
        hr = UninstallAllPerfCounters();
        ON_ERROR_CONTINUE();
        
        // Cleanup related keys (i.e. other than those under Software) of all versions
        hr = CRegInfo::RemoveRelatedKeys(NULL);
        ON_ERROR_CONTINUE();

        hr = InstallInfSections(g_DllInstance, true, L"StateService.Uninstall\0");
        ON_ERROR_CONTINUE();

        hr = InstallInfSections(g_DllInstance, true, L"XSP.UninstallAllVer\0");
        ON_ERROR_CONTINUE();
    }

    // Remove the client script files
    dwScriptFlags = SETUP_SCRIPT_FILES_REMOVE;
    if (unregMode == UNREG_MODE_FULL)
        dwScriptFlags |= SETUP_SCRIPT_FILES_ALLVERS;

    if (IISState == IIS_STATE_ENABLED) {
        hr = SetupClientScriptFiles(dwScriptFlags);
        ON_ERROR_CONTINUE();
    }

    if (!fEmpty) {
        // Don't fail without state service
        hr = StartServiceByName(STATE_SERVICE_NAME_L, lastStatusStateServer);
        ON_ERROR_CONTINUE();
    }

    if (fRestartW3svc && IISState == IIS_STATE_ENABLED) {
        // Restart W3svc in order to save all metabase changes to disk.
        hr = RestartW3svc(lastStatusW3svc, lastStatusIISAdmin);
        ON_ERROR_CONTINUE();
    }
    
    // Remove all files from Temporary ASP.NET Files directories
    // It is better to call this after we have restarted IIS to reduce
    // the chance that our worker process is holding on to some files.
    hr = CleanupTempDir(&VerList);
    ON_ERROR_CONTINUE();

    if (IISState != IIS_STATE_ENABLED) {
        XspLogEvent(IDS_EVENTLOG_UNREGISTER_IIS_DISABLED, NULL);
    }

    XspLogEvent(IDS_EVENTLOG_UNREGISTER_FINISH, L"%s^%s", PRODUCT_VERSION_L, CSetupLogging::LogFileName());
    CSetupLogging::Close();
}

/**
 *  Compare this version with the highest one installed on the machine
 *  
 */
HRESULT
IsCurrentHighest(BOOL *pfHighest, BOOL *pFresh) {
    ASPNETVER               verHighest;
    HRESULT                 hr = S_OK;

    CSetupLogging::Log(1, "IsCurrentHighest", 0, "Determining if current ASP.NET isapi has the highest version");        
    
    *pfHighest = FALSE;
    *pFresh = FALSE;

    hr = CRegInfo::GetHighestVersion(&verHighest);
    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ||
        hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) {
        *pfHighest = TRUE;
        *pFresh = TRUE;
        hr = S_OK;
        EXIT();
    }

    ON_ERROR_EXIT();

    if (ASPNETVER::ThisVer() >= verHighest) {
        *pfHighest = TRUE;
    }

Cleanup:
    CSetupLogging::Log(hr, "IsCurrentHighest", 0, "Determining if current ASP.NET isapi has the highest version");        
    return hr;
}


/**
 *  The main function for installing ASP.NET
 *
 *  Parameters:
 *  pchBase     - The base key from which to start installing
 */
HRESULT
Register(WCHAR *pchBase, DWORD dwFlags) {    
    HRESULT     hr;
    DWORD       lastStatusStateServer = SERVICE_STOPPED;
    DWORD       lastStatusW3svc = SERVICE_STOPPED;
    DWORD       lastStatusIISAdmin = SERVICE_STOPPED;
    DWORD       dwRegiisFlags = 0;
    BOOL        fCurrentHighest = FALSE;
    BOOL        fFresh = FALSE;
    DWORD       IISState;

    BOOL    fIgnoreVer      = !!(dwFlags & ASPNET_REG_NO_VER_COMPARISON);
    BOOL    fRecursive      = !!(dwFlags & ASPNET_REG_RECURSIVE);
    BOOL    fRestartW3svc   = !!(dwFlags & ASPNET_REG_RESTART_W3SVC);
    BOOL    fSkipSM         = !!(dwFlags & ASPNET_REG_SKIP_SCRIPTMAP);
    BOOL    fSMOnly         = !!(dwFlags & ASPNET_REG_SCRIPTMAP_ONLY);
    BOOL    fEnable         = !!(dwFlags & ASPNET_REG_ENABLE);
    
    CSetupLogging::Init(TRUE);

    ASSERT(!(fSMOnly && fSkipSM));

    // Remember IISAdmin original status.
    // Have to call this before CheckIISState is called.
    hr = GetServiceStatus(&lastStatusIISAdmin, IISADMIN_SERVICE_NAME_L);
    ON_ERROR_CONTINUE();
        
    hr = CheckIISState(&IISState);
    ON_ERROR_CONTINUE();

    // If we are only manipulating the Scriptmap, exit now if IIS isn't enabled
    if (fSMOnly && IISState != IIS_STATE_ENABLED) {
        if (IISState == IIS_STATE_DISABLED) {
            hr = HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
        }
        else {
            hr = REGDB_E_CLASSNOTREG;
        }

        ON_ERROR_EXIT();
    }

    // If the caller is registering only the scriptmap, we need to make
    // sure this version has been registered already
    if (fSMOnly) {
        BOOL    bInstalled;
        
        hr = CRegInfo::IsVerInstalled(&ASPNETVER::ThisVer(), &bInstalled);
        ON_ERROR_EXIT();

        if (!bInstalled) {
            EXIT_WITH_WIN32_ERROR(ERROR_PRODUCT_UNINSTALLED);
        }
    }

    if (fRestartW3svc) {
        // Remember W3svc original status
        hr = GetServiceStatus(&lastStatusW3svc, W3SVC_SERVICE_NAME_L);
        ON_ERROR_CONTINUE();
    }

    // Figure out if this is the highest
    hr = IsCurrentHighest(&fCurrentHighest, &fFresh);
    if (hr) {
        XspLogEvent(IDS_EVENTLOG_REGISTER_FAILED_COMPARE_HIGHEST, L"0x%08x", hr);
    }
    ON_ERROR_EXIT();

    if (!fSMOnly) {
        XspLogEvent(IDS_EVENTLOG_REGISTER_BEGIN, L"%s", PRODUCT_VERSION_L);

        // Don't fail without state service
        hr = StopServiceByName(&lastStatusStateServer, STATE_SERVICE_NAME_L);
        ON_ERROR_CONTINUE();

        if (IISState == IIS_STATE_ENABLED) {
            // Don't fail without IIS
            hr = UnregisterObsoleteIIS();
            ON_ERROR_CONTINUE();
        }

        // Cleanup some registry entries before the registration
        PreRegisterCleanup();

        hr = InstallInfSections(g_DllInstance, true, L"XSP.InstallPerVer\0");
        ON_ERROR_EXIT();
    }

    if (IISState == IIS_STATE_ENABLED) {
        // Determine what flags to pass to RegisterIIS
        // By default, install both scriptmap and other stuff
        dwRegiisFlags = REGIIS_INSTALL_SM | REGIIS_INSTALL_OTHERS;
        
        if (fRecursive) {
            dwRegiisFlags |= REGIIS_SM_RECURSIVE;
        }

        if (fSkipSM) {
            dwRegiisFlags &= (~REGIIS_INSTALL_SM);
        }

        if (fSMOnly) {
            dwRegiisFlags &= (~REGIIS_INSTALL_OTHERS);
        }

        if (fIgnoreVer) {
            dwRegiisFlags |= REGIIS_SM_IGNORE_VER;
        }

        if (fFresh) {
            dwRegiisFlags |= REGIIS_FRESH_INSTALL;
        }

        if (fEnable) {
            dwRegiisFlags |= REGIIS_ENABLE;
        }

        // Don't fail without IIS
        hr = RegisterIIS(pchBase, dwRegiisFlags);
        ON_ERROR_CONTINUE();
    }

    if (!fSMOnly) {
        if (fCurrentHighest) {

            // Create worker process account
            hr = CRegAccount::DoReg();
            ON_ERROR_CONTINUE();

            // note that the worker process account must be installed
            // in order to install the state service.
            hr = InstallStateService();
            ON_ERROR_CONTINUE();
        }
        else {
            hr = CRegAccount::DoRegForOldVersion();
            ON_ERROR_CONTINUE();
        }
            

        // Don't fail without perf counters
        hr = InstallVersionedPerfCounters();
        ON_ERROR_CONTINUE();
        
        // If we're the highest, take over the common ASP.NET perf counter name
        if (fCurrentHighest) {
            hr = InstallGenericPerfCounters();
            ON_ERROR_CONTINUE();
        }

        if (IISState == IIS_STATE_ENABLED) {
            hr = SetupClientScriptFiles(0);
            ON_ERROR_CONTINUE();
        }

        // Don't fail without state service
        hr = StartServiceByName(STATE_SERVICE_NAME_L, lastStatusStateServer);
        ON_ERROR_CONTINUE();
    }

    if (fRestartW3svc && IISState == IIS_STATE_ENABLED) {
        // Restart W3svc in order to save all metabase changes to disk.
        hr = RestartW3svc(lastStatusW3svc, lastStatusIISAdmin);
        ON_ERROR_CONTINUE();
    }
    
    hr = S_OK;

    if (!fSMOnly) {
        if (IISState != IIS_STATE_ENABLED) {
            XspLogEvent(IDS_EVENTLOG_REGISTER_IIS_DISABLED, NULL);
        }
    
        XspLogEvent(IDS_EVENTLOG_REGISTER_FINISH, L"%s^%s", PRODUCT_VERSION_L, CSetupLogging::LogFileName());
    }
    
Cleanup:
    CSetupLogging::Close();
    return hr;
}

STDAPI 
DllRegisterServer()
{
    DWORD   dwFlags =   ASPNET_REG_RECURSIVE |
                        ASPNET_REG_RESTART_W3SVC;
    
    SetEventCateg((WORD)IDS_CATEGORY_SETUP);
    
    if (!IsAdmin()) {
        XspLogEvent(IDS_EVENTLOG_INSTALL_NO_ADMIN_RIGHT, NULL);
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    return Register(KEY_W3SVC, dwFlags);
}

STDAPI 
DllUnregisterServer()
{
    SetEventCateg((WORD)IDS_CATEGORY_UNINSTALL);
    
    if (!IsAdmin()) {
        XspLogEvent(IDS_EVENTLOG_UNINSTALL_NO_ADMIN_RIGHT, NULL);
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    
    Unregister(UNREG_MODE_DLLUNREGISTER, TRUE);
    
    return S_OK;
}

STDAPI
RegisterISAPI()
{
    DWORD   dwFlags = ASPNET_REG_RECURSIVE | ASPNET_REG_RESTART_W3SVC;
    
    if (!IsAdmin()) 
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        
    SetEventCateg((WORD)IDS_CATEGORY_SETUP);
    return Register(KEY_W3SVC, dwFlags);
}


STDAPI
RegisterISAPIEx(WCHAR *pchBase, DWORD dwFlags)
{
    if (!IsAdmin())
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        
    SetEventCateg((WORD)IDS_CATEGORY_SETUP);
    return Register(pchBase, dwFlags);
}


/**
 * This simple wrapper function is provided so that 
 * we can call the registration function by linking
 * aspnet_isapi.lib. We cannot use DllRegisterServer
 * directly because we get warnings if we remove the
 * private attribute.
 */

STDAPI
UnregisterISAPI(BOOL fAll, BOOL fRestartW3svc)
{
    
    if (!IsAdmin()) 
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        
    SetEventCateg((WORD)IDS_CATEGORY_UNINSTALL);
    Unregister(fAll ? UNREG_MODE_FULL : UNREG_MODE_DLLUNREGISTER, fRestartW3svc);
    return S_OK;
}

STDAPI
RemoveAspnetFromIISKey(WCHAR *pchBase, BOOL fRecursive)
{
    if (!IsAdmin())
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        
    return RemoveAspnetFromKeyIIS(pchBase, fRecursive);
}


STDAPI
ValidateIISPath(WCHAR *pchPath, BOOL *pfValid)
{
    if (!IsAdmin())
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        
    return IsIISPathValid(pchPath, pfValid);
}


STDAPI
CheckIISFeature(IIS_SUPPORT_FEATURE support, BOOL *pbResult){
    DWORD   dwMajor, dwMinor;
    HRESULT hr;

    *pbResult = FALSE;

    hr = CRegInfo::GetIISVersion( &dwMajor, &dwMinor );
    ON_ERROR_EXIT();

    switch(support) {
    case SUPPORT_SECURITY_LOCKDOWN:
        if (dwMajor >= 6) {
            *pbResult = TRUE;
        }
        break;
        
    default:
        break;
    }

Cleanup:
    return hr;
}


STDAPI
ListAspnetInstalledVersions(ASPNET_VERSION_INFO **ppVerInfo, DWORD *pdwCount)
{
    if (!IsAdmin())
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        
    return GetIISVerInfoList(ppVerInfo, pdwCount);
}


STDAPI
ListAspnetInstalledIISKeys(ASPNET_IIS_KEY_INFO **ppKeyInfo, DWORD *pdwCount)
{
    if (!IsAdmin())
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        
    return GetIISKeyInfoList(ppKeyInfo, pdwCount);
}


STDAPI
CopyClientScriptFiles()
{
    if (!IsAdmin())
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        
    return SetupClientScriptFiles(0);
}


STDAPI
RemoveClientScriptFiles(BOOL fAllVersion)
{
    DWORD   dwScriptFlags;
    
    if (!IsAdmin())
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        
    dwScriptFlags = SETUP_SCRIPT_FILES_REMOVE;
    if (fAllVersion)
        dwScriptFlags |= SETUP_SCRIPT_FILES_ALLVERS;
    
    return SetupClientScriptFiles(dwScriptFlags);
}


void
GetExistingVersion(CHAR *pchVersion, DWORD dwCount) {
    StringCchCopyA(pchVersion, dwCount, PRODUCT_VERSION);
    return;
}


/****************************************************************
 *
 * Old registration code, kept around in case we need it again.
 *
 ****************************************************************/

// removed because we don't want to be dependent on cat.lib

#if 0

HRESULT
RegisterConfigDirectory()
{
    HKEY hKey = NULL;
    WCHAR configPath[MAX_PATH];
    int len;

    len = GetMachineConfigDirectory(L"URT", configPath, MAX_PATH);

    if (0 < len)
    {
        RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGPATH_MACHINE_APP_L, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);
        if(hKey)
        {
            RegSetValueEx(hKey, L"ConfigDir", 0, REG_SZ, (const BYTE*)configPath, (len + 1) * sizeof(WCHAR));
            RegCloseKey(hKey);
        }
    }

    return S_OK;
}

HRESULT
UnregisterConfigDirectory()
{
    RegDeleteValue(HKEY_LOCAL_MACHINE, REGPATH_MACHINE_APP_L L"\\ConfigDir");

    return S_OK;
}

#endif



#if 0
no longer changing environment variables in setup.

HRESULT
AppendRegistryValue(HKEY hRootKey, WCHAR *subkey, WCHAR *value, WCHAR *path)
{
    HRESULT hr = S_OK;
    DWORD cbData, dwType;
    WCHAR *fullPath = NULL;
    WCHAR *instance;
    HKEY hKey = NULL;

    if(ERROR_SUCCESS != RegOpenKeyEx(hRootKey, subkey, 0, 
        KEY_QUERY_VALUE | KEY_SET_VALUE, &hKey))
    {
        EXIT_WITH_LAST_ERROR();
    }

    // Find how big the value is (and if it is not there, it is also ok)
    cbData = 0;
    RegQueryValueEx(hKey, value, NULL, &dwType, NULL, &cbData);

    // We need as much space plus space for path, for ";" and for terminating NULL
    cbData += (lstrlen(path) + 2) * sizeof(WCHAR);
    fullPath = new WCHAR[cbData];
    ON_OOM_EXIT(fullPath);
    fullPath[0] = 0;

    // Get the value and its type 
    if(ERROR_SUCCESS != RegQueryValueEx(hKey, value, NULL, 
        &dwType, (BYTE *)fullPath, &cbData))
    {
        dwType = REG_SZ;
    }

    // Check if this path is already present
    instance = wcsstr(fullPath, path);
    cbData = lstrlen(path);

    if (instance == NULL || (instance[cbData] != L';' && instance[cbData] != 0))
    {
        // Substring not found or it does not end with ";" or "\0" -- append
        DWORD len = lstrlen(fullPath);
        if(len && fullPath[len-1] != L';') lstrcat(fullPath, L";");
        lstrcat(fullPath, path);
        cbData = (lstrlen(fullPath) + 1) * sizeof(WCHAR);
        if(ERROR_SUCCESS != RegSetValueEx(hKey, value, 0, dwType, 
            (CONST BYTE *)fullPath, cbData))
        {
            EXIT_WITH_LAST_ERROR();
        }
    }

Cleanup:
    delete [] fullPath;
    if(hKey != NULL) RegCloseKey(hKey);

    return hr;
}

HRESULT
RemoveRegistryValue(HKEY hRootKey, WCHAR *subkey, WCHAR *value, WCHAR *path)
{
    HRESULT hr = S_OK;
    DWORD cbData, dwType;
    WCHAR *fullPath = NULL;
    WCHAR *instance;
    HKEY hKey = NULL;

    if(ERROR_SUCCESS != RegOpenKeyEx(hRootKey, subkey, 0, 
        KEY_QUERY_VALUE | KEY_SET_VALUE, &hKey))
    {
        EXIT_WITH_LAST_ERROR();
    }

    // Find how big the value is (and if it is not there, it is also ok)
    cbData = 0;
    RegQueryValueEx(hKey, value, NULL, &dwType, NULL, &cbData);
        cbData += sizeof(WCHAR);
    fullPath = new WCHAR[cbData];
    ON_OOM_EXIT(fullPath);
    fullPath[0] = 0;

    // Get the value and its type 
    if(ERROR_SUCCESS != RegQueryValueEx(hKey, value, NULL, 
        &dwType, (BYTE *)fullPath, &cbData))
    {
        dwType = REG_SZ;
    }

    // Check if this path is present
    instance = wcsstr(fullPath, path);
    cbData = lstrlen(path);

    if  (instance != NULL && (instance[cbData] == L';' || instance[cbData] == 0))
    {
        DWORD cbBytesToMove;

        if(instance[cbData] == L';') cbData++;
        
        cbBytesToMove = (lstrlen(instance) - cbData + 1) * sizeof(WCHAR);
        if(cbBytesToMove)
                MoveMemory(instance, instance + cbData, cbBytesToMove);
        cbData = (lstrlen(fullPath) + 1) * sizeof(WCHAR);
        if  (ERROR_SUCCESS != RegSetValueEx(
                hKey, value, 0, dwType, (CONST BYTE *)fullPath, cbData))
        {
            EXIT_WITH_LAST_ERROR();
        }
    }

Cleanup:
    delete [] fullPath;
    if(hKey != NULL) RegCloseKey(hKey);

    return hr;
}

HRESULT
BroadcastEnvironmentUpdate()
{
    HRESULT hr = S_OK;
    DWORD result;
    DWORD dwReturnValue;

    result = SendMessageTimeout(
            HWND_BROADCAST, WM_SETTINGCHANGE, 0,
            (LPARAM) L"Environment", SMTO_ABORTIFHUNG, 5000, &dwReturnValue);

    ON_ZERO_EXIT_WITH_LAST_ERROR(result);

Cleanup:
    return hr;
}
#endif


#if 0
From registering performance counters

    DWORD result;
    LONG (__stdcall *LoadPerfCounterStrings)(LPTSTR lpCommandLine, BOOL bQuiet) = NULL;
    
    hLoad = LoadLibrary(L"LOADPERF.DLL");
    if(hLoad == NULL) EXIT_WITH_LAST_ERROR();

    LoadPerfCounterStrings = 
        (LONG (__stdcall *)(LPTSTR, BOOL)) 
        GetProcAddress(hLoad, "LoadPerfCounterTextStringsW");

    if(LoadPerfCounterStrings == NULL) EXIT_WITH_LAST_ERROR();

    // Q188769
    lstrcpy(cmdLine, L"X ");
    lstrcat(cmdLine, g_XspDirectory);
    lstrcat(cmdLine, L"\\" PERF_INI_FULL_NAME_L);
    result = LoadPerfCounterStrings(cmdLine, TRUE);

    if(result != ERROR_SUCCESS) EXIT_WITH_WIN32_ERROR(result);

#endif

#if 0    
From unregistering performance counters

    DWORD result;
    LONG (__stdcall *UnloadPerfCounterStrings)(LPTSTR lpCommandLine, BOOL bQuiet) = NULL;
    hLoad = LoadLibrary(L"LOADPERF.DLL");
    if(hLoad == NULL) EXIT_WITH_LAST_ERROR();

    UnloadPerfCounterStrings = 
        (LONG (__stdcall *)(LPTSTR, BOOL)) 
        GetProcAddress(hLoad, "UnloadPerfCounterTextStringsW");
    if(UnloadPerfCounterStrings == NULL) EXIT_WITH_LAST_ERROR();

    // Q188769
    result = UnloadPerfCounterStrings(L"X " PERF_SERVICE_NAME_L, TRUE);

    if(result != ERROR_SUCCESS) EXIT_WITH_WIN32_ERROR(result);
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CSetupLogging * CSetupLogging::g_pThis = NULL;
const char *    CSetupLogging::m_szError = "failed with HRESULT";
const char *    CSetupLogging::m_szError2 = "HRESULT for failure ";
const char *    CSetupLogging::m_szSuccess = "Success ";
const char *    CSetupLogging::m_szFailure = "Failure ";
const char *    CSetupLogging::m_szStarting = "Starting";

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void        
CSetupLogging::Init(BOOL fRegOrUnReg)
{
    if (g_pThis == NULL)
        g_pThis = new CSetupLogging(fRegOrUnReg);    
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void        
CSetupLogging::Close()
{
    if (g_pThis != NULL)
        delete g_pThis;
    g_pThis = NULL;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
void
CSetupLogging::CreateLogFile()
{
    WCHAR   szTempPath    [_MAX_PATH+1];
    HRESULT hr            = S_OK;

    m_hFile = NULL;

    ZeroMemory(szTempPath, sizeof(szTempPath));

    if (!GetTempPath(_MAX_PATH, szTempPath))
        EXIT_WITH_LAST_ERROR();

    for(int iter=0; iter<10; iter++)
    {
        if (iter != 0) {
	  hr = StringCchPrintfW(m_szFileName, ARRAY_SIZE(m_szFileName), L"%sASPNETSetup%d.log", szTempPath, iter);
	  ON_ERROR_EXIT();
	}
        else {
	  hr = StringCchPrintfW(m_szFileName, ARRAY_SIZE(m_szFileName), L"%sASPNETSetup.log", szTempPath);
	  ON_ERROR_EXIT();
	}
        m_hFile = CreateFile(m_szFileName, GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
        if (m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE)
        {
            SetFilePointer(m_hFile, 0, NULL, FILE_END);
            break;
        }
        else
        {
            CONTINUE_WITH_LAST_ERROR();
        }
    }

 Cleanup:
    if (m_hFile == INVALID_HANDLE_VALUE)
        m_hFile = NULL;
    return;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CSetupLogging::CSetupLogging(BOOL fRegOrUnReg)
{
    InitializeCriticalSection(&m_csSync);
    CreateLogFile();
    
    if (m_hFile == NULL)
        return;

    m_iNumTabs = 0;

    DWORD   dwWritten = 0;
    char    szDate[100], szIsapi[_MAX_PATH], szBuf[_MAX_PATH*5+1];
    char  * szSetupLog;
    char  * szIsapiRC;

    ZeroMemory(szIsapi,     sizeof(szIsapi));
    ZeroMemory(szDate,      sizeof(szDate));
    ZeroMemory(szBuf,       sizeof(szBuf));


    szSetupLog =  "Starting ASP.NET Setup at:";
    if (fRegOrUnReg) {
        szIsapiRC = "Registering ASP.NET isapi:";
    } 
    else {
        szIsapiRC = "Unregistering ASP.NET isapi:";
    }
    WideCharToMultiByte(CP_ACP, 0, Names::IsapiFullPath(), -1, szIsapi, ARRAY_SIZE(szIsapi), NULL, NULL);
    GetDateTimeStamp(szDate, ARRAY_SIZE(szDate));

    StringCchPrintfA(szBuf, ARRAY_SIZE(szBuf), "********************************************************************************\r\n**** %s %s\r\n**** %s %s\r\n********************************************************************************\r\n\r\n", 
            szSetupLog, szDate, szIsapiRC, szIsapi);

    WriteFile(m_hFile, szBuf, lstrlenA(szBuf), &dwWritten, NULL);
    FlushFileBuffers(m_hFile);     
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CSetupLogging::~CSetupLogging()
{
    if (m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE)
        CloseHandle(m_hFile);
    DeleteCriticalSection(&m_csSync);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
void
CSetupLogging::LoadStr(
        UINT      iStringID,
        LPCSTR    szDefString,
        LPSTR     szString,
        DWORD     dwStringSize)
{
    if (szString != NULL && dwStringSize > 0)
        ZeroMemory(szString, dwStringSize);

    if (iStringID == 0 || !FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE, g_rcDllInstance, iStringID, 0, szString, dwStringSize, NULL))
    {
        if (szDefString != NULL && lstrlenA(szDefString) < (int) dwStringSize)
            StringCchCopyA(szString, dwStringSize, szDefString);
    }
    for(int iter=0; szString[iter] != NULL; iter++)
        if (szString[iter] == '\r' || szString[iter] == '\n')
            szString[iter] = ' ';
    int iLen = lstrlenA(szString);
    while(iLen > 0 && (szString[iLen-1] == ' ' || szString[iLen-1] == '\r' || szString[iLen-1] == '\n' || szString[iLen-1] == '\t'))
    {
        szString[iLen-1] = NULL;
        iLen--;
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
void
CSetupLogging::GetDateTimeStamp(
        LPSTR     szString,
        DWORD     dwStringSize)
{
    
    char szTemp1[20];
    char szTemp2[20];
    ZeroMemory(szTemp1, sizeof(szTemp1));
    ZeroMemory(szTemp2, sizeof(szTemp2));
                
    GetDateFormatA(LOCALE_USER_DEFAULT, 0, NULL, "yyyy'-'MM'-'dd", szTemp1, sizeof(szTemp1));
    GetTimeFormatA(LOCALE_USER_DEFAULT, 0, NULL, "HH':'mm':'ss", szTemp2, sizeof(szTemp2));

    if (szTemp2[0] == NULL)
        StringCchCopyToArrayA(szTemp2, "Unknown Time");
    if (szTemp1[0] == NULL)
        StringCchCopyToArrayA(szTemp1, "Unknown Date");

    if (lstrlenA(szTemp1) + lstrlenA(szTemp2) + 2 > (int) dwStringSize)
        return;

    StringCchCopyA(szString, dwStringSize, szTemp1);
    StringCchCatA(szString, dwStringSize, " ");
    StringCchCatA(szString, dwStringSize, szTemp2);
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void
CSetupLogging::Log(
        HRESULT   hr,
        LPCSTR    szAPI,
        UINT      iActionStrID,
        LPCSTR    szAction)
{
    if (g_pThis == NULL || g_pThis->m_hFile == NULL)
        return;
    char    szBuf[1024];
    DWORD   dwWritten  = 0;

    g_pThis->PrepareLogEntry(hr, szAPI, iActionStrID, szAction, szBuf, ARRAY_SIZE(szBuf));
    EnterCriticalSection(&g_pThis->m_csSync);
    WriteFile(g_pThis->m_hFile, szBuf, lstrlenA(szBuf), &dwWritten, NULL);
    FlushFileBuffers(g_pThis->m_hFile);    
    LeaveCriticalSection(&g_pThis->m_csSync);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void
CSetupLogging::PrepareLogEntry (
        HRESULT   hrError,
        LPCSTR    szAPI,
        UINT      iActionStrID,
        LPCSTR    szAction,
        LPSTR     szBuf,
        int       iBufSize)
{
    int     iPos       = 0;
    HRESULT hr         = S_OK;
    int     iter       = 0;


    if (iBufSize < 3)
        return;

    ZeroMemory(szBuf, iBufSize);
    iBufSize -= 3; // \r \n \ts and NULL

    GetDateTimeStamp(&szBuf[iPos], iBufSize - iPos);
    iPos += lstrlenA(&szBuf[iPos]);
    if (iPos >= iBufSize - m_iNumTabs - 1)
        EXIT();
    if (hrError == 1)
        m_iNumTabs ++;
    if (m_iNumTabs <= 0)
    {
        ASSERT(FALSE);
        m_iNumTabs = 1;
    }
    memset(&szBuf[iPos], '\t', m_iNumTabs);
    iPos += m_iNumTabs;
    if (hrError != 1)
        m_iNumTabs--;

    if (hrError == S_OK)
        strncpy(&szBuf[iPos], m_szSuccess, iBufSize - iPos);
    else if (hrError == 1)
        strncpy(&szBuf[iPos], m_szStarting,iBufSize - iPos);
    else
        strncpy(&szBuf[iPos], m_szFailure, iBufSize - iPos);

    iPos += lstrlenA(&szBuf[iPos]);
    if (iPos >= iBufSize-1)
        EXIT();
    szBuf[iPos++] = '\t';

    LoadStr(iActionStrID, szAction, &szBuf[iPos], iBufSize - iPos);
    iPos += lstrlenA(&szBuf[iPos]);
    if (iPos >= iBufSize)
        EXIT();
    
    if (hrError != S_OK && hrError != 1)
    {
        if (iPos >= iBufSize-2)
            EXIT();
        szBuf[iPos++] = ':';
        szBuf[iPos++] = ' ';

        if (szAPI != NULL)
        {
            strncpy(&szBuf[iPos], szAPI,iBufSize - iPos);
            iPos += lstrlenA(&szBuf[iPos]);            
            if (iPos >= iBufSize - 10)
                EXIT();
            strncpy(&szBuf[iPos], m_szError, iBufSize - iPos);
        }
        else
        {
            strncpy(&szBuf[iPos], m_szError2, iBufSize - iPos);
        }

        iPos += lstrlenA(&szBuf[iPos]);
        if (iPos >= iBufSize-10)
            EXIT();

        _ultoa(hrError, &szBuf[iPos], 16);
        iPos += lstrlenA(&szBuf[iPos]);
        if (iPos >= iBufSize-3)
            EXIT();
        StringCchCopyA(&szBuf[iPos], iBufSize - iPos, ": \'");
        iPos += lstrlenA(&szBuf[iPos]);
        FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                       NULL, hrError, LANG_SYSTEM_DEFAULT, &szBuf[iPos], iBufSize - iPos, NULL);        
        iPos += lstrlenA(&szBuf[iPos]);
        if (iPos >= iBufSize-1)
            EXIT();
        szBuf[iPos++] = '\'';
    }

 Cleanup:
    // Remove \r and \n
    for(iter=0; szBuf[iter] != NULL; iter++)
        if (szBuf[iter] == '\r' || szBuf[iter] == '\n')
            szBuf[iter] = ' ';

    // Add \r and \n at the end
    szBuf[iter] = '\r';
    szBuf[iter+1] = '\n';
    szBuf[iter+2] = NULL;

    return;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

WCHAR *
CSetupLogging::LogFileName() {
    if (g_pThis == NULL || g_pThis->m_hFile == NULL)
        return L"";
    else
        return g_pThis->m_szFileName;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CStateServerRegInfo::CStateServerRegInfo() {
    m_ARCExist = false;
    m_PortExist = false;
}

void
CStateServerRegInfo::Read() {
    HRESULT hr;
    HKEY    key = NULL;
    int     err;
    DWORD   value;
    DWORD   size = sizeof(DWORD);

    err = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        REGPATH_STATE_SERVER_PARAMETERS_KEY_L,
        0,
        KEY_READ,
        &key);
    ON_WIN32_ERROR_EXIT(err);

    err = RegQueryValueEx(key, REGVAL_STATEPORT, NULL, NULL, (BYTE *)&value, &size);
    if (err == ERROR_SUCCESS) {
        m_PortExist = true;
        m_Port = value;
    }

    err = RegQueryValueEx(key, REGVAL_STATEALLOWREMOTE, NULL, NULL, (BYTE *)&value, &size);
    if (err == ERROR_SUCCESS) {
        m_ARCExist = true;
        m_ARC = value;
    }

Cleanup:    
    if (key)
        RegCloseKey(key);
    
    return;
}

void
CStateServerRegInfo::Set() {
    HRESULT hr = S_OK;
    HKEY    key = NULL;
    int     err;
    DWORD   value;

    if (!m_ARCExist && !m_PortExist) {
        EXIT();
    }

    err = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        REGPATH_STATE_SERVER_PARAMETERS_KEY_L,
        0,
        KEY_WRITE,
        &key);
    ON_WIN32_ERROR_EXIT(err);

    if (m_PortExist) {
        value = m_Port;
        err = RegSetValueEx(key, REGVAL_STATEPORT, NULL, REG_DWORD, (BYTE *)&value, sizeof(value));
        ON_WIN32_ERROR_CONTINUE(err);
    }
    
    if (m_ARCExist) {
        value = m_ARC;
        err = RegSetValueEx(key, REGVAL_STATEALLOWREMOTE, NULL, REG_DWORD, (BYTE *)&value, sizeof(value));
        ON_WIN32_ERROR_CONTINUE(err);
    }
    
Cleanup:    
    if (key)
        RegCloseKey(key);
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\responsecontext.cxx ===
/**
 * Request Context cxx file
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

#include "precomp.h"
#include "ProcessTableManager.h"
#include "util.h"
#include "AckReceiver.h"
#include "ResponseContext.h"

CResponseContextHolder * CResponseContextHolder::g_pResponseContextHolder = NULL;
LONG g_lCreatingRequestContextTable = 0;
/////////////////////////////////////////////////////////////////////////////
void
CResponseContextBucket::AddToList(CResponseContext * pNode)
{
    pNode->pNext = NULL;

    m_lLock.AcquireWriterLock();
    if (m_pTail == NULL)
    {
        ASSERT(m_pHead == NULL);
        m_pHead = m_pTail = pNode;
    }
    else
    {
        ASSERT(m_pHead != NULL);
        m_pTail->pNext = pNode;
        m_pTail = pNode;
    }
    m_lLock.ReleaseWriterLock();
}
/////////////////////////////////////////////////////////////////////////////
CResponseContext *
CResponseContextBucket::RemoveFromList(LONG lID)
{
    if (m_pHead == NULL)
        return NULL;
    CResponseContext * pRet   = NULL;
    CResponseContext * pPrev  = NULL;
    
    m_lLock.AcquireWriterLock();

    for (CResponseContext * pNode=m_pHead; pNode != NULL; pNode = pNode->pNext)
    {
        if (pNode->lID == lID)
        {
            if (pPrev != NULL)
                pPrev->pNext = pNode->pNext;
            else
                m_pHead = pNode->pNext;

            if (m_pTail == pNode)
                m_pTail = pPrev;

            pRet = pNode;
            break;
        }

        pPrev = pNode;
    }

    m_lLock.ReleaseWriterLock();
    return pRet;
}

/////////////////////////////////////////////////////////////////////////////
CResponseContextHolder::CResponseContextHolder()
{
    m_lID = 1;
    ZeroMemory(m_oHashTable, sizeof(m_oHashTable));
}

/////////////////////////////////////////////////////////////////////////////
CResponseContext *
CResponseContextHolder::Add(const CResponseContext & oResponseContext)
{
    if (g_pResponseContextHolder == NULL)
    {
        LONG lVal = InterlockedIncrement(&g_lCreatingRequestContextTable);
        if (lVal == 1 && !g_pResponseContextHolder)
        {
            g_pResponseContextHolder = new CResponseContextHolder();
            if (!g_pResponseContextHolder)
                return NULL;
        }
        else
        {
            // Sleep at most a minute
            for(int iter=0; iter<600 && !g_pResponseContextHolder; iter++)
                Sleep(100);
            if (g_pResponseContextHolder == NULL)
                return NULL;
        }
        InterlockedDecrement(&g_lCreatingRequestContextTable);
    }

    CResponseContext * pNode = new (NewClear) CResponseContext;
    if (pNode == NULL)
        return NULL;
    memcpy(pNode, &oResponseContext, sizeof(CResponseContext));
    pNode->lID = InterlockedIncrement(&g_pResponseContextHolder->m_lID);
    if (pNode->lID == 0)
        pNode->lID = InterlockedIncrement(&g_pResponseContextHolder->m_lID);
        
    LONG lHash = GetHashIndex(pNode->lID);
    g_pResponseContextHolder->m_oHashTable[lHash].AddToList(pNode);

    return pNode;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CResponseContext * 
CResponseContextHolder::Remove(LONG lResponseContextID)
{
    if (lResponseContextID == 0 || g_pResponseContextHolder == NULL)
        return NULL;

    LONG lHash = GetHashIndex(lResponseContextID);
    return g_pResponseContextHolder->m_oHashTable[lHash].RemoveFromList(lResponseContextID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\requesttablemanager.cxx ===
/**
 * Process Model: AckReceiver defn file 
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

#include "precomp.h"
#include "ProcessTableManager.h"
#include "util.h"
#include "AckReceiver.h"
#include "RequestTableManager.h"
#include "ecbimports.h"
#include "PerfCounters.h"

/////////////////////////////////////////////////////////////////////////////
// This file decl the classes:
//  1. CRequestEntry: Holds info for a request.
//
//  2. CLinkListNode: CRequestEntry + a pointer so that it can be held in a
//                    linked list.
//
//  3. CBucket: A hash table bucket. It has a linked list of 
//                      CLinkListNode and a read-write spin lock
//
//  4. CRequestTableManager: Manages the table. Provides static public
//               functions to add, delete and search for requests.
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

// Globals
CRequestTableManager * CRequestTableManager::g_pRequestTableManager = NULL;
LONG                   g_lCreatingRequestTable                      = 0;
LONG                   g_lDestroyingRequestTable                    = 0;
LONG                   g_lNumRequestsInTable                        = 0;
LONG                   g_lNumRequestsBlockedAndDeleted              = 0;
LONG                   g_lNumRequestsNotBlockedAndDeleted           = 0;
LONG                   g_lNumRequestsNotDisposed                    = 0;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CBucket defination

/////////////////////////////////////////////////////////////////////////////
// DTor
CBucket::~CBucket()
{
    for(CLinkListNode * pNode = m_pHead; pNode != NULL; pNode = m_pHead)
    {
        m_pHead = pNode->pNext;
        delete pNode;
    }
}


/////////////////////////////////////////////////////////////////////////////
// Add a request to this bucket
HRESULT
CBucket::AddToList(CLinkListNode * pNode)
{
    m_oLock.AcquireWriterLock();

    pNode->pNext = m_pHead;
    m_pHead = pNode;

    m_oLock.ReleaseWriterLock();

    InterlockedIncrement(&g_lNumRequestsInTable);
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// 
HRESULT
CBucket::AddWorkItem(LONG lReqID, EWorkItemType eType, BYTE * pMsg)
{
    HRESULT hr = E_FAIL;
    m_oLock.AcquireReaderLock();

    ////////////////////////////////////////////////////////////
    // Step 1: Find the request
    for (CLinkListNode * pNode=m_pHead; pNode != NULL; pNode = pNode->pNext)
    {
        if (pNode->oReqEntry.lRequestID == lReqID) // Found it!
        {
            hr = S_OK;
            CRequestEntry & oEntry = pNode->oReqEntry;

            ////////////////////////////////////////////////////////////
            // Step 2: Lock the oWorkItem list
            oEntry.oLock.AcquireWriterLock();
            
            ////////////////////////////////////////////////////////////
            // Step 3: Create the new work-item node
            CWorkItem *  pNew  = new CWorkItem;
            
            // Check allocation
            if (pNew == NULL)
                oEntry.oLock.ReleaseWriterLock();
            ON_OOM_EXIT(pNew);

            ////////////////////////////////////////////////////////////
            // Step 4: Set node properties
            pNew->pMsg          = pMsg;
            pNew->eItemType     = eType;
            pNew->pNext         = NULL;

            ////////////////////////////////////////////////////////////
            // Step 5: If it's new, add to the end of oWorkItem list
            if (oEntry.pLastWorkItem != NULL)
            {
                oEntry.pLastWorkItem->pNext = pNew;
            }
            else
            {
                ASSERT(oEntry.pFirstWorkItem == NULL);
                ASSERT(oEntry.lNumWorkItems == 0);
                oEntry.pFirstWorkItem = pNew;
            }
            oEntry.pLastWorkItem = pNew;
            InterlockedIncrement(&oEntry.lNumWorkItems);

            ////////////////////////////////////////////////////////////
            // Step 6: Release all locks and exit
            oEntry.oLock.ReleaseWriterLock();            
            EXIT();
        }
    }

 Cleanup:
    m_oLock.ReleaseReaderLock();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// 
HRESULT
CBucket::RemoveWorkItem(LONG lReqID, EWorkItemType & eType, BYTE ** ppMsg)
{
    if (ppMsg == NULL)
        return E_INVALIDARG;

    HRESULT hr = E_FAIL;
    m_oLock.AcquireReaderLock();

    ////////////////////////////////////////////////////////////
    // Step 1: Find the request
    for (CLinkListNode * pNode=m_pHead; pNode != NULL; pNode = pNode->pNext)
    {
        if (pNode->oReqEntry.lRequestID == lReqID) // Found the request
        {
            CRequestEntry & oEntry = pNode->oReqEntry;
            CWorkItem *     pDel   = NULL;

            ////////////////////////////////////////////////////////////
            // Step 3: Lock the oWorkItem list
            oEntry.oLock.AcquireWriterLock();

            ////////////////////////////////////////////////////////////
            // Step 4: See if there are any work items
            if (oEntry.lNumWorkItems == 0)
            {
                oEntry.oLock.ReleaseWriterLock();            
                EXIT_WITH_SUCCESSFUL_HRESULT(S_FALSE);
            }
            ASSERT(oEntry.pFirstWorkItem != NULL);
            ASSERT(oEntry.pLastWorkItem != NULL);


            ////////////////////////////////////////////////////////////
            // Step 5: Copy the work item
            (*ppMsg)     = oEntry.pFirstWorkItem->pMsg;
            eType        = oEntry.pFirstWorkItem->eItemType;
            
           
            ////////////////////////////////////////////////////////////
            // Step 6: Del the work item
            InterlockedDecrement(&oEntry.lNumWorkItems);
            pDel = oEntry.pFirstWorkItem;

            if (oEntry.lNumWorkItems == 0)
            {
                ASSERT(pDel == oEntry.pFirstWorkItem);
                ASSERT(pDel == oEntry.pLastWorkItem);
                oEntry.pFirstWorkItem = NULL;
                oEntry.pLastWorkItem = NULL;
            }
            else
            {
                ASSERT(pDel != oEntry.pLastWorkItem);
                oEntry.pFirstWorkItem = pDel->pNext;
                ASSERT(oEntry.pFirstWorkItem != NULL);
            }

            delete pDel;            

            ////////////////////////////////////////////////////////////
            // Step 7: Release all locks and exit
            oEntry.oLock.ReleaseWriterLock();
            EXIT_WITH_SUCCESSFUL_HRESULT(S_OK);
        }
    }

 Cleanup:
    m_oLock.ReleaseReaderLock();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Retrive a copy of a request node
HRESULT
CBucket::GetRequest(LONG  lReqID, CRequestEntry & oEntry)
{
    HRESULT hr = E_FAIL;

    m_oLock.AcquireReaderLock();
    for (CLinkListNode * pNode=m_pHead; pNode != NULL; pNode = pNode->pNext)
    {
        if (pNode->oReqEntry.lRequestID == lReqID)
        {
            memcpy(&oEntry, &pNode->oReqEntry, sizeof(oEntry));            
            EXIT_WITH_SUCCESSFUL_HRESULT(S_OK);            
        }
    }

 Cleanup:
    m_oLock.ReleaseReaderLock();
    ZeroMemory((LPBYTE) &oEntry.oLock, sizeof(oEntry.oLock));
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Update the status of a request
HRESULT
CBucket::UpdateRequestStatus(LONG lReqID, ERequestStatus eStatus)
{
    HRESULT hr = E_FAIL;

    m_oLock.AcquireReaderLock();
    for (CLinkListNode * pNode=m_pHead; pNode != NULL; pNode = pNode->pNext)
    {
        if (pNode->oReqEntry.lRequestID == lReqID)
        {
            pNode->oReqEntry.eStatus = eStatus;
            EXIT_WITH_SUCCESSFUL_HRESULT(S_OK);            
        }
    }

 Cleanup:
    m_oLock.ReleaseReaderLock();
    return hr;
}
/////////////////////////////////////////////////////////////////////////////
// Remove a node from this bucket
HRESULT
CBucket::RemoveFromList(LONG  lReqID)
{
    if (m_pHead == NULL)
        return E_FAIL;

    CLinkListNode * pPrev   = NULL;
    CLinkListNode * pRemove = NULL;

    m_oLock.AcquireWriterLock();
    for (CLinkListNode * pNode=m_pHead; pNode != NULL; pNode = pNode->pNext)
    {
        if (pNode->oReqEntry.lRequestID == lReqID)
        {
            if (pPrev != NULL)
                pPrev->pNext = pNode->pNext;
            else
                m_pHead = pNode->pNext;
            pRemove = pNode;
            break;
        }

        pPrev = pNode;
    }
    m_oLock.ReleaseWriterLock();

    if (pRemove != NULL)
    {
        CRequestEntry & oEntry = pRemove->oReqEntry;
        for(int iter=0; iter<oEntry.lNumWorkItems; iter++)
        {
            ASSERT(oEntry.pFirstWorkItem != NULL);
            if (oEntry.pFirstWorkItem == NULL)
                break;

            CWorkItem * pDel = oEntry.pFirstWorkItem;
            oEntry.pFirstWorkItem = oEntry.pFirstWorkItem->pNext;
            switch(pDel->eItemType)
            {
            case EWorkItemType_SyncMessage:
                oEntry.pProcess->ProcessSyncMessage((CSyncMessage *)pDel->pMsg, TRUE);
                break;
            case EWorkItemType_ASyncMessage:
                delete [] pDel->pMsg;
                break;
            case EWorkItemType_CloseWithError:                
                break;
            }
            
            delete pDel;
        }

        InterlockedDecrement(&g_lNumRequestsInTable);
        delete pRemove;        
        return S_OK;
    }
    return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
// Get number of requests matching the CProcessEntry value and ERequestStatus
LONG
CBucket::GetNumRequestsForProcess(CProcessEntry *  pProcess, 
                                          ERequestStatus   eStatus)
{
    LONG  lRetValue = 0;

    m_oLock.AcquireReaderLock();

    for (CLinkListNode * pNode=m_pHead; pNode != NULL; pNode = pNode->pNext)
    {
        if (pNode->oReqEntry.pProcess == pProcess)
        {
            if ( eStatus == ERequestStatus_DontCare || 
                 eStatus == pNode->oReqEntry.eStatus)
            {
                lRetValue++;
            }
        }
    }

    m_oLock.ReleaseReaderLock();
    return lRetValue;
}

/////////////////////////////////////////////////////////////////////////////
// Reassign request for pProcessOld to pProcessNew, if matching eStatus
void
CBucket::ReassignRequestsForProcess(CProcessEntry *  pProcessOld, 
                                            CProcessEntry *  pProcessNew, 
                                            ERequestStatus   eStatus)
{
    m_oLock.AcquireReaderLock();

    for (CLinkListNode * pNode=m_pHead; pNode != NULL; pNode = pNode->pNext)
    {
        if (pNode->oReqEntry.pProcess == pProcessOld)
        {
            if ( eStatus == ERequestStatus_DontCare   || 
                 eStatus == pNode->oReqEntry.eStatus  )
            {
                pNode->oReqEntry.pProcess = pProcessNew;
            }
        }
    }

    m_oLock.ReleaseReaderLock();
}

/////////////////////////////////////////////////////////////////////////////
// Delete Requests for pProcess, if matching eStatus
void
CBucket::DeleteRequestsForProcess(CProcessEntry *  pProcess, 
                                          ERequestStatus   eStatus)
{
    LONG lNum = GetNumRequestsForProcess(pProcess, eStatus);
    if (lNum < 1)
        return;


    m_oLock.AcquireWriterLock();

    CLinkListNode *       pDelHead  = NULL;    
    CLinkListNode *       pNext     = NULL;
    CLinkListNode *       pPrev     = NULL;
        
    for (CLinkListNode * pNode = m_pHead; pNode != NULL; pNode = pNext)
    {
        pNext = pNode->pNext;
        
        if (pNode->oReqEntry.pProcess == pProcess)
        {
            if ( eStatus == ERequestStatus_DontCare   || 
                 eStatus == pNode->oReqEntry.eStatus   )
            {
                // remove from the list
                if (pPrev != NULL)
                    pPrev->pNext = pNode->pNext;
                else
                    m_pHead = pNode->pNext;
                
                // insert this node into the delete list
                pNode->pNext = pDelHead;
                pDelHead = pNode;
            }
            else
            {     
                pPrev = pNode;
            }
        }
    }

    m_oLock.ReleaseWriterLock();

    // free the delete list
    for (pNode = pDelHead; pNode != NULL; pNode = pNext)
    {
        if (pNode->oReqEntry.lBlock)
        {
            InterlockedIncrement(&g_lNumRequestsBlockedAndDeleted);
        }
        else
        {
            CRequestEntry & oEntry = pNode->oReqEntry;
            for(int iter=0; iter<oEntry.lNumWorkItems; iter++)
            {
                ASSERT(oEntry.pFirstWorkItem != NULL);
                if (oEntry.pFirstWorkItem == NULL)
                    break;

                CWorkItem * pDel = oEntry.pFirstWorkItem;
                oEntry.pFirstWorkItem = oEntry.pFirstWorkItem->pNext;
                switch(pDel->eItemType)
                {
                case EWorkItemType_SyncMessage:
                    oEntry.pProcess->ProcessSyncMessage((CSyncMessage *)pDel->pMsg, TRUE);
                    break;
                case EWorkItemType_ASyncMessage:
                    delete [] pDel->pMsg;
                    break;
                case EWorkItemType_CloseWithError:                
                    break;
                }            
                delete pDel;
            }
            InterlockedIncrement(&g_lNumRequestsNotBlockedAndDeleted);
            EcbDoneWithSession(pNode->oReqEntry.iECB, 1, 10);            
        }

        pNext = pNode->pNext;
        InterlockedDecrement(&g_lNumRequestsInTable);
        delete pNode;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
void
CBucket::GetRequestsIDsForProcess(CProcessEntry * pProcess, 
                                          ERequestStatus  eStatus, 
                                          LONG *          pReqIDArray, 
                                          int             iReqIDArraySize, 
                                          int &           iStartPoint)
{
    if (!pReqIDArray || iStartPoint >= iReqIDArraySize)
        return;

    m_oLock.AcquireReaderLock();
    for (CLinkListNode * pNode=m_pHead; pNode != NULL; pNode = pNode->pNext)
    {
        if (pNode->oReqEntry.pProcess == pProcess)
        {
            if ( eStatus == ERequestStatus_DontCare || 
                 eStatus == pNode->oReqEntry.eStatus)
            {
                pReqIDArray[iStartPoint++] = pNode->oReqEntry.lRequestID;
                if (iStartPoint >= iReqIDArraySize)
                    break;
            }
        }
    }

    m_oLock.ReleaseReaderLock();    
}

/////////////////////////////////////////////////////////////////////////////
//
HRESULT
CBucket::BlockWorkItemsQueue(LONG lReqID, BOOL fBlock)
{
    HRESULT hr = E_FAIL;

    m_oLock.AcquireReaderLock();
    for (CLinkListNode * pNode=m_pHead; pNode != NULL; pNode = pNode->pNext)
    {
        if (pNode->oReqEntry.lRequestID == lReqID)
        {
            hr = S_OK;

            if (fBlock == FALSE)
            {
                pNode->oReqEntry.lBlock = 0;
                hr = S_OK;
            }
            else
            {
                if (InterlockedCompareExchange(&pNode->oReqEntry.lBlock, 1, 0) == 0)
                    hr = S_OK;
                else
                    hr = S_FALSE;
            }
            break;
        }
    }

    m_oLock.ReleaseReaderLock();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
BOOL
CBucket::AnyWorkItemsInQueue(LONG     lReqID)
{
    BOOL fRet = FALSE;

    m_oLock.AcquireReaderLock();
    for (CLinkListNode * pNode=m_pHead; pNode != NULL; pNode = pNode->pNext)
    {
        if (pNode->oReqEntry.lRequestID == lReqID)
        {
            fRet = (pNode->oReqEntry.lNumWorkItems > 0);
            break;
        }
    }

    m_oLock.ReleaseReaderLock();
    return fRet;
}

/////////////////////////////////////////////////////////////////////////////

LONG
CBucket::DisposeAllRequests()
{
    if (m_pHead == NULL)
        return 0;

    m_oLock.AcquireWriterLock();

    LONG            lReturn = 0;
    CLinkListNode * pPrev   = m_pHead;
    CLinkListNode * pNode   = m_pHead;

    while(pNode != NULL)
    {
        CLinkListNode * pNext = pNode->pNext;
        if (pNode->oReqEntry.lBlock != 0)
        {
            lReturn++;
            pPrev = pNode;
        }
        else
        {
            if (m_pHead == pNode)
            {
                ASSERT(pPrev == pNode);
                m_pHead = pPrev = pNext;
            }
            else
            {
                ASSERT(pPrev != pNode && pPrev != NULL);
                pPrev->pNext = pNext;
            }

            InterlockedDecrement(&g_lNumRequestsInTable);
            EcbDoneWithSession(pNode->oReqEntry.iECB, 1, 3);
            delete pNode;
        }

        pNode = pNext;
    }

    m_oLock.ReleaseWriterLock();
    return lReturn;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Static wrapper functions
HRESULT
CRequestTableManager::AddRequestToTable(CRequestEntry &  oEntry)
{
    HRESULT hr = S_OK;

    if (!g_pRequestTableManager)
    {
        LONG lVal = InterlockedIncrement(&g_lCreatingRequestTable);
        if (lVal == 1 && !g_pRequestTableManager)
        {
            g_pRequestTableManager = new CRequestTableManager();
            ON_OOM_EXIT(g_pRequestTableManager);
        }
        else
        {
            // Sleep at most a minute
            for(int iter=0; iter<600 && !g_pRequestTableManager; iter++)
                Sleep(100);
            if (g_pRequestTableManager == NULL)
            {
                EXIT_WITH_WIN32_ERROR(ERROR_TIMEOUT);
            }
        }
        InterlockedDecrement(&g_lCreatingRequestTable);
    }

    hr = g_pRequestTableManager->PrivateAddRequestToTable(oEntry);
    EXIT();

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRequestTableManager::UpdateRequestStatus(LONG             lReqID, 
                                          ERequestStatus   eStatus)
{
    if (g_pRequestTableManager == NULL)
        return E_FAIL;

    // Get the Hash index
    int      iHash = GetHashIndex(lReqID);
    return g_pRequestTableManager->m_oHashTable[iHash].UpdateRequestStatus(lReqID, 
                                                                           eStatus);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CRequestTableManager::RemoveRequestFromTable(LONG  lReqID)
{
    if (g_pRequestTableManager == NULL)
        return E_FAIL;

    // Get the Hash index
    int      iHash = GetHashIndex(lReqID);
    return g_pRequestTableManager->m_oHashTable[iHash].RemoveFromList(lReqID);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CRequestTableManager::GetRequest(LONG  lReqID, CRequestEntry & oEntry)
{
    if (g_pRequestTableManager == NULL)
        return E_FAIL;

    // Get the Hash index
    int      iHash = GetHashIndex(lReqID);
    return g_pRequestTableManager->m_oHashTable[iHash].GetRequest(lReqID, oEntry);
}
/////////////////////////////////////////////////////////////////////////////

LONG  
CRequestTableManager::GetNumRequestsForProcess(CProcessEntry *  pProcess, 
                                               ERequestStatus   eStatus)
{
    if (g_pRequestTableManager == NULL)
        return 0;

    LONG     lRetValue   = 0;
    int      iSize       = HASH_TABLE_SIZE;

    for(int iter=0; iter<iSize; iter++)
        lRetValue += g_pRequestTableManager->m_oHashTable[iter].GetNumRequestsForProcess(
                                                                  pProcess,
                                                                  eStatus);

    return lRetValue;
}

/////////////////////////////////////////////////////////////////////////////

void
CRequestTableManager::ReassignRequestsForProcess(CProcessEntry* pProcessOld,
                                                 CProcessEntry* pProcessNew,
                                                 ERequestStatus eStatus)
{
    if (g_pRequestTableManager == NULL)
        return;

    for(int iter=0; iter<HASH_TABLE_SIZE; iter++)
        g_pRequestTableManager->m_oHashTable[iter].ReassignRequestsForProcess(
                                                      pProcessOld, 
                                                      pProcessNew, 
                                                      eStatus);

}

/////////////////////////////////////////////////////////////////////////////

void
CRequestTableManager::DeleteRequestsForProcess(CProcessEntry * pProcess,
                                               ERequestStatus  eStatus)
{
    if (g_pRequestTableManager == NULL)
        return;

    for(int iter=0; iter<HASH_TABLE_SIZE; iter++)
        g_pRequestTableManager->m_oHashTable[iter].DeleteRequestsForProcess(
                                                      pProcess, 
                                                      eStatus);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CRequestTableManager::AddWorkItem(LONG           lReqID, 
                                  EWorkItemType  eType, 
                                  BYTE *         pMsg)
{
    if (g_pRequestTableManager == NULL)
        return E_FAIL;

    int      iHash = GetHashIndex(lReqID);
    return g_pRequestTableManager->m_oHashTable[iHash].AddWorkItem(lReqID, 
                                                                   eType, 
                                                                   pMsg);
}
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRequestTableManager::RemoveWorkItem(LONG            lReqID,
                                     EWorkItemType & eType, 
                                     BYTE **         pMsg)
{
    if (g_pRequestTableManager == NULL)
        return E_FAIL;

    int      iHash = GetHashIndex(lReqID);
    return g_pRequestTableManager->m_oHashTable[iHash].RemoveWorkItem(lReqID,
                                                             eType,
                                                             pMsg);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CRequestTableManager::BlockWorkItemsQueue(LONG lReqID, BOOL  fBlock)
{
    if (g_pRequestTableManager == NULL)
        return E_FAIL;

    int      iHash = GetHashIndex(lReqID);
    return g_pRequestTableManager->m_oHashTable[iHash].BlockWorkItemsQueue(lReqID, fBlock);
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CRequestTableManager::AnyWorkItemsInQueue(LONG lReqID)
{
    if (g_pRequestTableManager == NULL)
        return E_FAIL;

    int      iHash = GetHashIndex(lReqID);
    return g_pRequestTableManager->m_oHashTable[iHash].AnyWorkItemsInQueue(lReqID);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CRequestTableManager::GetRequestsIDsForProcess(CProcessEntry * pProcess,
                                               ERequestStatus eStatus,
                                               LONG * pReqIDArray, 
                                               int    iReqIDArraySize)
{
    if (g_pRequestTableManager == NULL)
        return E_FAIL;

    int      iSize       = HASH_TABLE_SIZE;
    int      iFillPoint  = 0;

    for(int iter=0; iter<iSize; iter++)
        g_pRequestTableManager->m_oHashTable[iter].GetRequestsIDsForProcess(
                                                     pProcess, 
                                                     eStatus, 
                                                     pReqIDArray, 
                                                     iReqIDArraySize, 
                                                     iFillPoint);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

void
CRequestTableManager::Destroy()
{
    if (g_pRequestTableManager == NULL)
        return;

    LONG lVal = InterlockedIncrement(&g_lDestroyingRequestTable);
    if (lVal == 1 && g_pRequestTableManager)
    {
        delete g_pRequestTableManager;
        g_pRequestTableManager = NULL;
        g_lCreatingRequestTable = g_lDestroyingRequestTable = 0;
    }
}

/////////////////////////////////////////////////////////////////////////////

void
CRequestTableManager::DisposeAllRequests()
{
    if (g_pRequestTableManager == NULL)
        return;

    for(int iNumSeconds = 0; iNumSeconds<30; iNumSeconds++) // Stay in this loop for 30 seconds
    {
        g_lNumRequestsNotDisposed = 0;
        for(int iter=0; iter<HASH_TABLE_SIZE; iter++)
        {
            g_lNumRequestsNotDisposed += g_pRequestTableManager->m_oHashTable[iter].DisposeAllRequests();
        }
        if (g_lNumRequestsNotDisposed)
            Sleep(1000); // Sleep 1 second
        else
            break;
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Non Static functions

/////////////////////////////////////////////////////////////////////////////
// CTor
/*
CRequestTableManager::CRequestTableManager()
    : m_lRequestID  (0)
{
    ZeroMemory(m_oHashTable, sizeof(m_oHashTable));
}
*/
/////////////////////////////////////////////////////////////////////////////
// DTor
CRequestTableManager::~CRequestTableManager()
{

}

/////////////////////////////////////////////////////////////////////////////
// 
HRESULT
CRequestTableManager::PrivateAddRequestToTable(CRequestEntry &  oEntry)
{
    HRESULT                hr    = S_OK;
    CLinkListNode        * pNode = new CLinkListNode;    
    ON_OOM_EXIT(pNode);

    // Prepare the node
    memcpy((LPVOID) &pNode->oReqEntry, (LPVOID) &oEntry, sizeof(oEntry));
    pNode->pNext = NULL;

    // Get the request ID
    pNode->oReqEntry.lRequestID = InterlockedIncrement(&m_lRequestID);
    oEntry.lRequestID = pNode->oReqEntry.lRequestID;

    GetSystemTimeAsFileTime((FILETIME *) &((pNode->oReqEntry).qwRequestStartTime));

    // Add it to the hash table
    return m_oHashTable[GetHashIndex(oEntry.lRequestID)].AddToList(pNode);

 Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\register.h ===
/**
 * register.h
 *
 * Some helper functions and types from register.cxx
 * 
 * Copyright (c) 2001, Microsoft Corporation
 * 
 */

#pragma once

enum {
    UNREG_MODE_DLLREGISTER,
    UNREG_MODE_DLLUNREGISTER,
    UNREG_MODE_FULL
};

#define SETUP_SCRIPT_FILES_REMOVE   0x00000001
#define SETUP_SCRIPT_FILES_ALLVERS  0x00000002

typedef HRESULT (CALLBACK* LPFNINSTALLSTATESERVICE)();

#define WAIT_FOR_SERVICE 60


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CSetupLogging
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();
    
    static void        Init   (BOOL fRegOrUnReg);
    static void        Close  ();    
    static void        Log    (HRESULT   hr,
                               LPCSTR    szAPI,
                               UINT      iActionStrID,
                               LPCSTR    szAction);
    static WCHAR *     LogFileName();
    
    static const char *      m_szError;
    static const char *      m_szError2;
    static const char *      m_szFailure;
    static const char *      m_szSuccess;
    static const char *      m_szStarting;

private:
    static CSetupLogging *    g_pThis;
    ~CSetupLogging            ();
    CSetupLogging             (BOOL fRegOrUnReg);

    void   PrepareLogEntry    (HRESULT   hr,
                               LPCSTR    szAPI,
                               UINT      iActionStrID,
                               LPCSTR    szAction,
                               LPSTR     szBuf,
                               int       iBufSize);

    void   CreateLogFile     ();
    
    void   LoadStr           (UINT      iStringID,
                              LPCSTR    szDefString,
                              LPSTR     szString,
                              DWORD     dwStringSize);
    void  GetDateTimeStamp   (LPSTR     szString,
                              DWORD     dwStringSize);


    HANDLE                    m_hFile;
    CRITICAL_SECTION          m_csSync;
    int                       m_iNumTabs;
    WCHAR                     m_szFileName  [_MAX_PATH+22];
    
};

CHAR *
SpecialStrConcatForLogging(const WCHAR *wszStr, CHAR *szPrefix, CHAR **pszFree);


class CStateServerRegInfo {
public:
    CStateServerRegInfo();
    void    Read();
    void    Set();
    
private:
    DWORD   m_ARC;      // AllowRemoteConnection
    DWORD   m_Port;
    
    bool    m_ARCExist:1;
    bool    m_PortExist:1;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\reginf.cxx ===
/**
 * reginf.cxx
 * 
 * Registers an inf file.
 * 
 * Copyright (c) 1998-2000, Microsoft Corporation
 */

#include "precomp.h"
#include "_ndll.h"
#include "event.h"
#include "register.h"

#define IS_RESOURCE(x)     ( (((LPSTR)(x)) != NULL) && IS_INTRESOURCE(x) )

HRESULT
FormatResourceMessageW(
        UINT    messageId, 
        LPWSTR * buffer) 
{
    DWORD    dwRet   = 0;
    HRESULT  hr      = S_OK;
    
    for(int iSize = 256; iSize < 1024 * 1024 - 1; iSize *= 2)
    {
        (*buffer) = new (NewClear) WCHAR[iSize];
        ON_OOM_EXIT(*buffer);

        dwRet = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE, 
                               g_rcDllInstance, messageId, 0, *buffer, iSize, NULL);

        if (dwRet != 0)
            EXIT(); // succeeded!
        
        // Free buffer
        delete [] (*buffer);
        (*buffer) = NULL;
        
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            EXIT_WITH_LAST_ERROR(); // Failed due to error
    }

 Cleanup:
    return hr;
}

typedef struct _StrEntry {
    LPCWSTR pszName;            // String to substitute
    VOID *  pvValue;            // Replacement string or string resource
    BOOL    fString;
} STRENTRY;

typedef struct _StrTable {
    DWORD       cEntries;       // Number of entries in the table
    STRENTRY *  pse;            // Array of entries
} STRTABLE;

BOOL
AddPath(LPWSTR szPath, LPWSTR szName)
{
    LPWSTR szTmp;
    size_t cchPath = 0;
    size_t cchName = 0;
    if (S_OK != StringCchLengthW(szPath, MAX_PATH, &cchPath)) return FALSE;
    if (S_OK != StringCchLengthW(szName, MAX_PATH, &cchName)) return FALSE;

    // Find end of the string
    szTmp = szPath + cchPath;

    // If no trailing backslash then add one
    if ( szTmp > szPath && *(CharPrev( szPath, szTmp )) != L'\\')
    {
      if (cchPath + cchName + 2 < ARRAY_SIZE(szTmp))
      {
        *(szTmp++) = L'\\';
      }
      else
      {
	return FALSE;
      }
    }

    if (S_OK != StringCchCopy( szTmp, cchName + 1, szName )) return FALSE;

    return TRUE;
}

BOOL 
IsGoodDir( LPWSTR szPath )
{
    DWORD   dwAttribs;
    HANDLE  hFile;
    WCHAR   szTestFile[MAX_PATH];

    StringCchCopyToArrayW( szTestFile, szPath );
    if (!AddPath( szTestFile, L"TMP4352$.TMP" )) {
      return FALSE;
    }
    DeleteFile( szTestFile );
    hFile = CreateFile(
            szTestFile, GENERIC_WRITE, 0, NULL, CREATE_NEW,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE, NULL );

    if ( hFile == INVALID_HANDLE_VALUE )  
        return FALSE;

    CloseHandle(hFile);

    dwAttribs = GetFileAttributes(szPath);
    if ((dwAttribs != 0xFFFFFFFF) && (dwAttribs & FILE_ATTRIBUTE_DIRECTORY))
        return TRUE;

    return FALSE;
}

HRESULT 
CreateInfFile(HMODULE hm, LPWSTR pszInfFileName, BOOL *pfFileCreated)
{
    HRESULT hr = S_OK;
    DWORD   ret;
    WCHAR   szInfFilePath[MAX_PATH] = L"";
    LPVOID  pvInfData;
    HRSRC   hrsrcInfData;
    DWORD   cbInfData, cbWritten;
    HANDLE  hfileInf = INVALID_HANDLE_VALUE;

    *pfFileCreated = FALSE;

    if (GetTempPath(ARRAY_SIZE(szInfFilePath), szInfFilePath) > ARRAY_SIZE(szInfFilePath))
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    if (!IsGoodDir(szInfFilePath))
    {
        ret = GetWindowsDirectory(szInfFilePath, ARRAY_SIZE(szInfFilePath));
        ON_ZERO_EXIT_WITH_LAST_ERROR(ret);  
          
        if (ret > ARRAY_SIZE(szInfFilePath))
            EXIT_WITH_HRESULT(E_UNEXPECTED);            
    }

    ret = GetTempFileName(szInfFilePath, L"RGI", 0, pszInfFileName);
    ON_ZERO_EXIT_WITH_LAST_ERROR(ret);

    hrsrcInfData = FindResource(hm, L"REGINST", L"REGINST");
    ON_ZERO_EXIT_WITH_LAST_ERROR(hrsrcInfData);

    cbInfData = SizeofResource(hm, hrsrcInfData);
    pvInfData = LockResource(LoadResource(hm, hrsrcInfData));
    ON_ZERO_EXIT_WITH_LAST_ERROR(pvInfData);

    hfileInf = CreateFile(pszInfFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL, NULL);
    if (hfileInf == INVALID_HANDLE_VALUE)
        EXIT_WITH_LAST_ERROR();

    *pfFileCreated = TRUE;
    
    ret = WriteFile(hfileInf, pvInfData, cbInfData, &cbWritten, NULL);
    if (ret == FALSE)
        EXIT_WITH_LAST_ERROR();
    
    if (cbWritten != cbInfData)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

Cleanup:
    if (hfileInf != INVALID_HANDLE_VALUE)
    {
        VERIFY(CloseHandle(hfileInf));
    }

    return hr;
}

HRESULT 
WriteCallerStrings(LPWSTR pszInfFileName, HMODULE hm, STRTABLE * pstTable)
{
    HRESULT     hr = S_OK;
    LPWSTR      pValue  = NULL;
    DWORD       i;
    STRENTRY *  pse;
    WCHAR       szQuoteValue[MAX_PATH];
    LPCWSTR     lpValue;     
    DWORD       ret;

    for (i=0, pse=pstTable->pse; i<pstTable->cEntries; i++, pse++)
    {
        if (!pse->fString)
        {
            if (pValue != NULL) {
                delete [] pValue;
                pValue = NULL;
            }
            
            hr = FormatResourceMessageW( PtrToUint(pse->pvValue), &pValue );
            ON_ERROR_EXIT();
            
            lpValue = pValue;
        }
        else
        {
            lpValue = (LPCWSTR)pse->pvValue;
        }

        ON_ZERO_EXIT_WITH_LAST_ERROR(lpValue);
        if ( lpValue[0] != L'"' )
        {
            // if no quote, insert it
            szQuoteValue[0] = L'"';
	    szQuoteValue[1] = L'\0';
	    StringCchCatToArrayW( szQuoteValue, lpValue );
            StringCchCatToArrayW( szQuoteValue, L"\"" );
            lpValue = szQuoteValue;
        }

        ret = WritePrivateProfileString(L"Strings", pse->pszName, lpValue, pszInfFileName);        
        ON_ZERO_EXIT_WITH_LAST_ERROR(ret);
    }

Cleanup:
    if (pValue != NULL) {
        delete [] pValue;
    }
    return hr;
}

STDAPI
InstallInfSections(HMODULE hmod, bool installServices, const WCHAR *action)
{
    HRESULT     hr = S_OK;
    BOOL        fFileCreated = FALSE;
    DWORD       ret;
    STRENTRY    seReg[] = 
    { 
        { L"AspNet_StateDescription", (PVOID)UintToPtr(IDS_ASPNET_STATE_DESCRIPTION), FALSE},
        { L"AspNet_StateDisplayName", (PVOID)UintToPtr(IDS_ASPNET_STATE_DISPLAY_NAME), FALSE},
        { L"XSP_INSTALL_DIR", (PVOID)Names::InstallDirectory(), TRUE },
        { L"XSP_INSTALL_DLL_FULLPATH", (PVOID)Names::IsapiFullPath(), TRUE },
        { L"XSP_EVENT_DLL_FULLPATH", (PVOID)Names::RcFullPath(), TRUE },
        { L"XSP_INSTALLED_VER", (PVOID)PRODUCT_VERSION_L, TRUE},
        { L"XSP_DEFAULT_DOC", (PVOID)DEFAULT_DOC, TRUE},
        { L"XSP_MIMEMAP", (PVOID)MIMEMAP, TRUE},
        { L"XSP_SUPPORTED_EXTS", (PVOID)SUPPORTED_EXTS, TRUE},
    };

    STRTABLE    stReg = { ARRAY_SIZE(seReg), seReg };
    WCHAR       szInfFileName[MAX_PATH] = {L'\0'};
    HINF        hinf = INVALID_HANDLE_VALUE;
    CHAR *      szLogAlloc = NULL;
    CHAR *      szLog;

    szLog = SpecialStrConcatForLogging(action, "Executing inf section: ", &szLogAlloc);
    CSetupLogging::Log(1, "InstallInfSections", 0, szLog);
    
    //
    // Create the INF file.
    //
    hr = CreateInfFile(hmod, szInfFileName, &fFileCreated);
    ON_ERROR_EXIT();

    //
    // Write out the user supplied strings.
    //
    hr = WriteCallerStrings(szInfFileName, hmod, &stReg);
    ON_ERROR_EXIT();

    //
    // Open the INF file.
    //
    hinf = SetupOpenInfFile(szInfFileName, NULL, INF_STYLE_WIN4, NULL);
    if (hinf == INVALID_HANDLE_VALUE)
        EXIT_WITH_LAST_ERROR();

    // Install each section
    for (; *action; action += wcslen(action) + 1)
    {
        //
        // Execute the INF engine on the INF.
        //
        ret = SetupInstallFromInfSection(
                NULL, hinf, action, SPINST_ALL,
                NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        ON_ZERO_EXIT_WITH_LAST_ERROR(ret);

        if (installServices)
        {
            ret = SetupInstallServicesFromInfSection(hinf, action, 0);
            ON_ZERO_EXIT_WITH_LAST_ERROR(ret);
        }
    }

Cleanup:
    CSetupLogging::Log(hr, "InstallInfSections", 0, szLog);

    delete [] szLogAlloc;
    
    if (hinf != INVALID_HANDLE_VALUE)
    {
        SetupCloseInfFile(hinf);
    }

    //
    // Delete the INF file.
    //
    if (fFileCreated)
    {
        BOOL    fResult;

        fResult = DeleteFile(szInfFileName);
        if (fResult == 0) {
            DWORD   error = GetLastError();
            error = error;
            ASSERT(error == 0);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\requesttablemanager.h ===
/**
 * RequestTableManager header file
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

/////////////////////////////////////////////////////////////////////////////
// This file decl the classes:
//  1. CRequestEntry: Holds info for a request.
//
//  2. CLinkListNode: CRequestEntry + a pointer so that it can be held in a
//                    linked list.
//
//  3. CBucket: A hash table bucket. It has a linked list of 
//                      CLinkListNode and a read-write spin lock
//
//  4. CRequestTableManager: Manages the table. Provides static public
//               functions to add, delete and search for requests.
/////////////////////////////////////////////////////////////////////////////

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _RequestTableManager_H
#define _RequestTableManager_H
#define HASH_TABLE_SIZE            0x400 // 1024 (must be a power of 2) 
#define HASH_TABLE_SIZE_MINUS_1    0x3ff

#include "MessageDefs.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Status of a request in  the table
enum ERequestStatus
{
    // Used only while searching for any request -- Never stored
    ERequestStatus_DontCare,  

    // Request is currently unassigned: Currently not used
    ERequestStatus_Unassigned,

    // Request has been sent to worker process, but has not been acknowledged
    ERequestStatus_Pending,  

    // Request is executing at the worker process   
    ERequestStatus_Executing,

    // Request is complete: Currently not used
    ERequestStatus_Complete    
};

/////////////////////////////////////////////////////////////////////////////
// 
enum EWorkItemType
{
    EWorkItemType_SyncMessage,
    EWorkItemType_ASyncMessage,
    EWorkItemType_CloseWithError
};

struct CWorkItem
{
    EWorkItemType  eItemType;
    BYTE      *    pMsg;
    CWorkItem *    pNext;
};

/////////////////////////////////////////////////////////////////////////////
// Forward decl.
class  CProcessEntry;

/////////////////////////////////////////////////////////////////////////////
// Request node
struct CRequestEntry
{
    CRequestEntry() : oLock("CRequestEntry") {}

    // Unique ID
    LONG             lRequestID;  

    // Current status: Typically Pending or Executing
    ERequestStatus   eStatus;

	// Request start time
    __int64   qwRequestStartTime;     // start time of the request

    // Process executing this
    CProcessEntry *  pProcess;

    // The ECB, etc, associated with the request
    EXTENSION_CONTROL_BLOCK * iECB;

    // Linked list of workitems...
    //CWorkItem        oWorkItem;
    CWorkItem *      pFirstWorkItem;
    CWorkItem *      pLastWorkItem;
    LONG             lNumWorkItems;
    

    // Lock for serialized access to CWorkItem 
    CReadWriteSpinLock   oLock;

    LONG             lBlock;
private:
    NO_COPY(CRequestEntry);
};

/////////////////////////////////////////////////////////////////////////////
// Linked list node encapsulating CRequestEntry
struct CLinkListNode
{
    CLinkListNode() {}
    NO_COPY(CLinkListNode);

    CLinkListNode   * pNext;
    CRequestEntry   oReqEntry;
};

/////////////////////////////////////////////////////////////////////////////
// Hash Table node that has a linked list of requests
class CBucket
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    // CTor
    CBucket() : m_oLock("RequestTableManager::CBucket") {
    }

    // DTor
    ~CBucket                ();

    // Add a request to the Hash bucket
    HRESULT         AddToList                 (CLinkListNode *   pNode);

    // Remove a request from this Hash Bucket
    HRESULT         RemoveFromList            (LONG              lReqID);

    // Get num of request with this pProcess and eStatus values
    LONG            GetNumRequestsForProcess  (CProcessEntry *   pProcess,
                                               ERequestStatus    eStatus);

    // Change all pProcessOld to pProcessNew
    void            ReassignRequestsForProcess (CProcessEntry * pProcessOld,
                                                CProcessEntry * pProcessNew,
                                                ERequestStatus  eStatus);

    // Nuke all nodes with this pProcess and eStatus
    void            DeleteRequestsForProcess   (CProcessEntry *   pProcess,
                                                ERequestStatus    eStatus);

    // Get the Request ID's for this process with this status
    void            GetRequestsIDsForProcess    (CProcessEntry *   pProcess,
                                                 ERequestStatus    eStatus,
                                                 LONG *   pReqIDArray,
                                                 int      iReqIDArraySize,
                                                 int &    iStartPoint);

    HRESULT         GetRequest                 (LONG            lReqID, 
                                                CRequestEntry & oEntry);


    // Add a work item to a request
    HRESULT         AddWorkItem                 (LONG           lReqID, 
                                                 EWorkItemType  eType,
                                                 BYTE *         pMsg);

    // Add a work item to a request
    HRESULT         RemoveWorkItem              (LONG            lReqID, 
                                                 EWorkItemType & eType,
                                                 BYTE **         pMsg);

    
    HRESULT         UpdateRequestStatus         (LONG     lReqID,
                                                 ERequestStatus eStatus);


    HRESULT         BlockWorkItemsQueue         (LONG     lReqID, BOOL fBlock);

    BOOL            AnyWorkItemsInQueue         (LONG     lReqID);

    LONG            DisposeAllRequests          ();

private:    
    // Private Data
    CLinkListNode   *            m_pHead; // for the linked list
    CReadWriteSpinLock           m_oLock;
};

/////////////////////////////////////////////////////////////////////////////
// The Request Table Manager that is visible to the outside world:
//   Accessed via public static functions

class CRequestTableManager
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    // Add a request to the Request Table: The Manager assigns the oEntry.dwRequestID
    static HRESULT AddRequestToTable       (CRequestEntry &  oEntry);

    // Update the status of a request: Set it to eStatus
    static HRESULT UpdateRequestStatus     (LONG              lReqID, 
                                            ERequestStatus    eStatus);

    // Remove a request from the table
    static HRESULT RemoveRequestFromTable  (LONG              lReqID);

    // Get a request
    static HRESULT GetRequest              (LONG             lReqID,
                                            CRequestEntry &  oEntry);

    // Add a work item to a request
    static HRESULT AddWorkItem             (LONG           lReqID, 
                                            EWorkItemType  eType,
                                            BYTE *         pMsg);

    // Add a work item to a request
    static HRESULT RemoveWorkItem          (LONG              lReqID,
                                            EWorkItemType  &  eType,
                                            BYTE **           pMsg);

    // Get Number of request with values pProcess and eStatus
    static LONG    GetNumRequestsForProcess  (
                        CProcessEntry *  pProcess, // Proccess to grep for
                        // Match only if eStatus matches or eStatus==DontCare
                        ERequestStatus   eStatus = ERequestStatus_DontCare);
    

    // Reassign all requests to new one
    static void    ReassignRequestsForProcess (
                         CProcessEntry *  pProcessOld,  // Old Value
                         CProcessEntry *  pProcessNew,  // New Value
                         // Reassign only if eStatus matches
                         ERequestStatus   eStatus = ERequestStatus_Pending);


    // Delete all request for a process
    static void    DeleteRequestsForProcess (
                         CProcessEntry * pProcess,
                         ERequestStatus  eStatus = ERequestStatus_DontCare);


    // Get the Request ID's for this process with this status
    static HRESULT GetRequestsIDsForProcess (
                         CProcessEntry *  pProcess,
                         ERequestStatus   eStatus,
                         LONG *           pReqIDArray,
                         int              iReqIDArraySize);

    static HRESULT BlockWorkItemsQueue      (LONG     lReqID, BOOL fBlock);

    static BOOL    AnyWorkItemsInQueue      (LONG     lReqID);

    // Destroy: Cleanup on exit
    static void    Destroy                  ();

    static void    DisposeAllRequests       ();

private:

    // CTor and DTor
    //CRequestTableManager                    ();
    ~CRequestTableManager                   ();

    // Private functions that do the actual work of the statics ablove
    HRESULT   PrivateAddRequestToTable         (CRequestEntry &  oEntry);


    // Get the hash index from the RequestID
    static int    GetHashIndex (LONG             lReqID) 
        { return (lReqID & HASH_TABLE_SIZE_MINUS_1); }


    ////////////////////////////////////////////////////////////
    // Private Data

    // The Real table
    CBucket                        m_oHashTable[HASH_TABLE_SIZE];

    // Current Request ID number: Used to assign new numbers
    LONG                           m_lRequestID;

    // Singleton instance of this class
    static CRequestTableManager *  g_pRequestTableManager;
};

/////////////////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\regiisutil.h ===
/**
 * regiisutil.h
 *
 * Header file for regiisutil.cxx
 * 
 * Copyright (c) 2002, Microsoft Corporation
 * 
 */
#pragma once

#include "_ndll.h"
#include <iadmw.h>
#include "regiis.h"
#include "aspnetverlist.h"
#include "ary.h"
#include "hashtable.h"

typedef CPtrAry<SCRIPTMAP_PREFIX *>   CSMPrefixAry;

class EXTS_COMPARISON_RESULT {
public:
    DECLARE_MEMCLEAR_NEW_DELETE();
    
    ~EXTS_COMPARISON_RESULT();
    
    HRESULT         Compare(ASPNETVER *pVer1, ASPNETVER *pVer2);
    CSMPrefixAry*   ObsoleteExts() { return &m_aryObsoleteExts; }
    CSMPrefixAry*   NewExts() { return &m_aryNewExts; }
    
private:
    HRESULT     GetExtsFromRegistry(ASPNETVER *pVer, WCHAR ** ppchExts);
    HRESULT     FindExcludedExts(WCHAR *pchExts1, WCHAR *pchExts2, CSMPrefixAry *paryExcluded);
    
    CSMPrefixAry     m_aryObsoleteExts;
    CSMPrefixAry     m_aryNewExts;
};


class SCRIPTMAP_REGISTER_MANAGER {
public:
    DECLARE_MEMCLEAR_NEW_DELETE();
    
    SCRIPTMAP_REGISTER_MANAGER();
    ~SCRIPTMAP_REGISTER_MANAGER();

    HRESULT ChangeVersion( IMSAdminBase *pAdmin, METADATA_HANDLE keyHandle, const WCHAR *pchKey,
                        const WCHAR *pchDllFrom, const WCHAR *pchDllTo );
    
    HRESULT FindDllVer(const WCHAR *pchDll, ASPNETVER *pVer);

    static HRESULT  CleanInstall(IMSAdminBase *pAdmin, METADATA_HANDLE keyHandle, 
                                const WCHAR *pchKey, const WCHAR *pchDll, BOOL fRemoveFirst);
private:    
    HRESULT     Init();
    long        HashFromString(const WCHAR *pchStr);
    void        GetCompareKey(ASPNETVER *pVerFrom, ASPNETVER *pVerTo, WCHAR pchKey[], DWORD count);
    HRESULT     CompareExtensions(ASPNETVER *pVerFrom, ASPNETVER *pVerTo, 
                                        EXTS_COMPARISON_RESULT **ppRes);
    HRESULT     UpdateScriptmapString(WCHAR **pmsOrg, EXTS_COMPARISON_RESULT *pCompRes,
                                        const WCHAR *pchDllFrom, const WCHAR *pchDllTo);
    HRESULT     FixForbiddenHandlerForV1(ASPNETVER *pverFrom, WCHAR *pData);

    
    HashtableGeneric    m_htDllToVer;     // Hashtable for Dll path to version
    HashtableGeneric    m_htCompRes;    // Hashtable for extension comparison results
    
    BOOL        m_fInited;
};



////////////////////////////////////////////////////////////
// Helper class for managing the IIS6 security wizard properties
////////////////////////////////////////////////////////////

#ifndef MD_APP_DEPENDENCIES
#define MD_APP_DEPENDENCIES                                 (IIS_MD_HTTP_BASE+167)
#endif

#ifndef MD_WEB_SVC_EXT_RESTRICTION_LIST
#define MD_WEB_SVC_EXT_RESTRICTION_LIST                     (IIS_MD_HTTP_BASE+168)
#endif

typedef enum {
    SECURITY_CLEANUP_INVALID,
    SECURITY_CLEANUP_CURRENT,
    SECURITY_CLEANUP_ANY_VERSION,
}   SECURITY_CLEANUP_MODE;


class SECURITY_PROP_MANAGER {
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    SECURITY_PROP_MANAGER(IMSAdminBase *pAdmin) 
    { 
        m_pAdmin = pAdmin;
        m_finstalledVersionsInit = FALSE;
    }

    BOOL    SecurityDetectVersion(WCHAR *pchStr);
    HRESULT CleanupSecurityLockdown(SECURITY_CLEANUP_MODE mode);
    HRESULT RegisterSecurityLockdown(BOOL fEnable);
    
private:    
    BOOL                    m_finstalledVersionsInit;
    CASPNET_VER_LIST        m_installedVersions;

    SECURITY_CLEANUP_MODE   m_mode;
    DWORD                   m_prop;
    IMSAdminBase *          m_pAdmin;
};


////////////////////////////////////////////////////////////
// Utility functions
////////////////////////////////////////////////////////////

HRESULT GetMultiStringProperty( IMSAdminBase *pAdmin, METADATA_HANDLE keyHandle,
                                const WCHAR *pchPath, DWORD  dwMDIdentifier, METADATA_RECORD *pmd);

HRESULT GetStringProperty( IMSAdminBase    * pAdmin, METADATA_HANDLE keyHandle,
                                const WCHAR *pchPath, DWORD dwMDIdentifier, METADATA_RECORD *pmd);

int     wcslenms(const WCHAR *pch);

const WCHAR * FindStringInMultiString(const WCHAR *msStr, const WCHAR *str);

typedef enum {
    MULTISZ_MATCHING_PREFIX,
    MULTISZ_MATCHING_EXACT,
    MULTISZ_MATCHING_ANY
} MULTISZ_MATCHING_MODE;

BOOL    RemoveStringFromMultiString( WCHAR *msStr, const WCHAR *pchRemove,  
                                MULTISZ_MATCHING_MODE matching, BOOL *pfEmpty);

BOOL    RemoveStringFromMultiStringEx( WCHAR *msStr, const WCHAR *pchRemove,  
                                MULTISZ_MATCHING_MODE matching, BOOL *pfEmpty, 
                                SECURITY_PROP_MANAGER *pSecPropMgr);

HRESULT RemoveStringFromMultiStringProp(         IMSAdminBase *pAdmin, METADATA_HANDLE keyHandle,
                                const WCHAR *pchPath, DWORD  dwMDIdentifier,
                                const WCHAR *pchRemove,  MULTISZ_MATCHING_MODE matching,
                                BOOL fDeleteEmpty);

HRESULT AppendStringToMultiString(       WCHAR **pmsStr, const WCHAR *pchAppend);

HRESULT AppendStringToMultiStringProp(        IMSAdminBase *pAdmin, METADATA_HANDLE keyHandle,
                                const WCHAR *pchPath, DWORD dwMDIdentifier,
                                const WCHAR *pchAppend, BOOL fInheritable);

HRESULT RemoveAspnetDllFromMulti(IMSAdminBase *pAdmin, METADATA_HANDLE w3svcHandle, 
                                DWORD dwMDId, const WCHAR *path);

HRESULT WriteAspnetDllOnOneScriptMap(IMSAdminBase* pAdmin, METADATA_HANDLE w3svcHandle, 
                                const WCHAR *pchKeyPath, const WCHAR *pchDllPath);

HRESULT ReplaceStringInMultiString(WCHAR **ppchSM, const WCHAR *pchFrom, const WCHAR *pchTo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\responsecontext.h ===
/**
 * ResponseContext header file
 *
 * Copyright (c) 1999 Microsoft Corporation
 */

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _ResponseContext_H
#define _ResponseContext_H
#define REQ_CONTEXT_HASH_TABLE_SIZE            0x400 // 1024 (must be a power of 2) 
#define REQ_CONTEXT_HASH_TABLE_SIZE_MINUS_1    0x3ff

#include "MessageDefs.h"

class CProcessEntry;
struct CAsyncPipeOverlapped;

struct CResponseContext
{
    LONG                     lID;
    CProcessEntry *          pProcessEntry;
    CAsyncPipeOverlapped *   pOver;
    BOOL                     fInAsyncWriteFunction;
    BOOL                     fSyncCallback;
    DWORD                    dwThreadIdOfAsyncWriteFunction;
    EXTENSION_CONTROL_BLOCK* iECB;
    CResponseContext *       pNext;    
};

/////////////////////////////////////////////////////////////////////////////
// Hash Table node that has a linked list of requests
struct CResponseContextBucket
{
    CResponseContextBucket() : m_lLock("CResponseContextBucket") {
    }

    // Add a request to the Hash bucket
    void                 AddToList            (CResponseContext * pNode);

    // Remove a request from this Hash Bucket
    CResponseContext *   RemoveFromList       (LONG              lID);

    CResponseContext *   m_pHead; // for the linked list
    CResponseContext *   m_pTail; // for the linked list
    CReadWriteSpinLock   m_lLock;
};

/////////////////////////////////////////////////////////////////////////////
// The Request Table Manager that is visible to the outside world:
//   Accessed via public static functions

class CResponseContextHolder
{
public:
    static CResponseContext * Add    (const CResponseContext & oResponseContext);
    static CResponseContext * Remove (LONG lResponseContextID);

private:

    // CTor
    CResponseContextHolder     ();

    // Get the hash index from the RequestID
    static int    GetHashIndex (LONG lReqID)  { return (lReqID & REQ_CONTEXT_HASH_TABLE_SIZE_MINUS_1); }

    // The Real table
    CResponseContextBucket         m_oHashTable[REQ_CONTEXT_HASH_TABLE_SIZE];

    // Current Request ID number: Used to assign new numbers
    LONG                           m_lID;

    // Singleton instance of this class
    static CResponseContextHolder *  g_pResponseContextHolder;
};

/////////////////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\securityapi.cxx ===
/**
 * Security callback functions though N/Direct.
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

#include "precomp.h"
#include "lmaccess.h"
#include "lmapibuf.h"
#include "LMERR.H"
#include "util.H"
#include "dbg.h"
#include "Ntsecapi.h"
#include "names.h"
#include "product_version.h"
#include "regaccount.h"

#define  SZ_NT_ANONONYMOUS            L"NT AUTHORITY\\ANONYMOUS"
#define  SZ_AUTOGEN_KEYS              L"L$" PRODUCT_NAME_L L"AutoGenKeys"  VER_PRODUCTVERSION_STR_L
#define  SZ_AUTOGEN_KEYS_EVENT        PRODUCT_NAME_L L"AutoGenKeys"  VER_PRODUCTVERSION_STR_L L"Event"
#define  AUTOGEN_KEYS_SIZE            88
#define  NUM_LOGON_TYPES              5
#define  COOKIE_AUTH_TICKET_START     8
#define  DW_KEY_FORMAT_CRYPT          1
#define  DW_KEY_FORMAT_CLEAR          2
#define  SZ_AUTOGEN_KEYS_ENTROPY      L"ASP.NET AutoGenKeys Entropy"
#define  SZ_AUTOGEN_KEYS_PASS         L"ASP.NET AutoGenKeys Password"
#define  SZ_REG_AUTOGEN_KEY_FORMAT    L"AutoGenKeyFormat"
#define  SZ_REG_AUTOGEN_KEY_TIME      L"AutoGenKeyCreationTime"
#define  SZ_REG_AUTOGEN_KEY           L"AutoGenKey"

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

BOOL    g_fRunningOnXspToolOrIE          = FALSE;
BOOL    g_fRunningOnXspToolOrIEChecked   = FALSE;

BYTE *  g_pCookieAuthEncryptionKey       = NULL;
long    g_iCreateCookieAuthEncryptionKey = 0;

BYTE *  g_pCookieAuthValidationKey       = NULL;
long    g_iCreateCookieAuthValidationKey = 0;

DWORD   g_dwLogonType[NUM_LOGON_TYPES] = {LOGON32_LOGON_BATCH,
                                          LOGON32_LOGON_SERVICE,
                                          LOGON32_LOGON_INTERACTIVE,
                                          LOGON32_LOGON_NETWORK_CLEARTEXT,
                                          LOGON32_LOGON_NETWORK};

BOOL    g_fLogonTypePrimaryToken[NUM_LOGON_TYPES] = {TRUE, TRUE, TRUE, TRUE, FALSE};
LONG    g_lNumTokensCreated = 0;
BYTE    g_pAutogenKey[AUTOGEN_KEYS_SIZE];
long    g_iAutogenKeyCreate = 0;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// Forwards
HRESULT 
GetSecurityDescriptor  (HANDLE                   hFile, 
                        PSECURITY_DESCRIPTOR *   ppSecDecriptor);

HRESULT
CheckUserAccess        (HANDLE                   hUserAccessToken, 
                        PSECURITY_DESCRIPTOR     pSecDecriptor,
                        int                      iAccess,
                        BOOL *                   pHasAccess);
BOOL
CheckIfRunningOnXspToolOrIE ();

BOOL
MyWebRunningOnMyWeb();

HANDLE
__stdcall
GetCurrentToken();

HRESULT
GetAutogenKeysSingleThread(
        LPBYTE    pDefaultKey);

HRESULT
OpenLSAPolicy(
        LSA_HANDLE * phLasPolicy);

HRESULT
DoesKeyExist(
        LSA_HANDLE hLasPolicy);

HRESULT
StoreKeyInLSA(
        LSA_HANDLE hLasPolicy,
        LPBYTE     pBuf);

HRESULT
GetKeyFromHKCURegistry(
        LPBYTE    pKey,
        DWORD     dwSize);

HRESULT
CryptKeyToStoreInReg(
        LPBYTE   pKey,
        DWORD    dwKeySize,
        LPBYTE   pBuf,
        LPDWORD  pdwBufSize,
        LPDWORD  pdwFormat);

HRESULT
UnCryptKeyFromReg(
        LPBYTE   pKey,
        DWORD    dwKeySize,
        LPBYTE   pBuf,
        DWORD    dwBufSize,
        DWORD    dwFormat);

HRESULT
AddProcessSidToObjectDACL(
        HANDLE   hHandle);
PSID
GetSidFromToken(
        HANDLE   hToken);

PSID
GetGuestUserSid();

HRESULT
ExtractUserName(
        LPCWSTR  szFullName, 
        LPWSTR   szName, 
        DWORD    dwNameSize,
        LPWSTR   szDomain,
        DWORD    dwDomainSize);

HRESULT
CallLogonUser(
        LPWSTR   szName, 
        LPWSTR   szDomain,
        LPWSTR   szPass,
        HANDLE * phToken,
        LPBOOL   pfPrimaryToken);

HRESULT
ChangeTokenType(
        HANDLE * phToken,
        BOOL     fImpersonationToken);

BOOL
IsTokenAnonymousUser(
        HANDLE   hToken);
        
BOOL
MachineKeyWasCreatedAfterInstall();

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

int 
__stdcall
GetUserNameFromToken (
        HANDLE        token, 
        LPWSTR        buffer,
        int           size)
{
    BYTE          bufStatic [2048];
    DWORD         dwSize          = sizeof(bufStatic);
    LPBYTE        pUser           = bufStatic;
    HRESULT       hr              = S_OK;
    DWORD         dwName          = 256;
    DWORD         dwDomain        = 256;
    SID_NAME_USE  nameUse;
    int           iReq            = 0;
    WCHAR         szName   [256];
    WCHAR         szDomain [256];
    DWORD         dwRequire       = 0;
    BOOL          fRet;

    if (GetTokenInformation(HANDLE(token), TokenUser, (LPVOID)pUser, dwSize, &dwRequire) == FALSE)
    {
        if (dwRequire > dwSize)
        {
            pUser = new BYTE[dwRequire];
            ON_OOM_EXIT(pUser);

            fRet = GetTokenInformation(HANDLE(token), TokenUser, (LPVOID)pUser, dwRequire, &dwRequire);
            ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);
        }
        else 
        {
            EXIT_WITH_LAST_ERROR();
        }
    }
    
    fRet = LookupAccountSid(NULL, ((TOKEN_USER *)pUser)->User.Sid, szName, &dwName, szDomain, &dwDomain,  &nameUse);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

    iReq = lstrlenW(szDomain) + lstrlenW(szName) + 2;
    if (iReq > size)
    {
        iReq = -iReq;
    }
    else
    {
        iReq = 1;
        StringCchCopyW(buffer, size, szDomain);
        StringCchCatW(buffer, size, L"\\");
        StringCchCatW(buffer, size, szName);
    }

 Cleanup:
    if (pUser != NULL && pUser != bufStatic)
        delete [] pUser;

    if (hr == S_OK)
        return iReq;

    else
        return 0;
}

//////////////////////////////////////////////////////////////////////

HANDLE
__stdcall
CreateUserToken (
       LPCWSTR   name, 
       LPCWSTR   password,
       BOOL      fImpersonationToken,
       LPWSTR    szError,
       int       iErrorSize)
{
    WCHAR         szDomain      [256];
    WCHAR         szName        [256];
    WCHAR         szPass        [256];
    HANDLE        hToken        = NULL;
    HRESULT       hr            = S_OK;
    BOOL          fPrimaryToken = TRUE;


    ZeroMemory(szDomain, sizeof(szDomain));
    ZeroMemory(szName, sizeof(szName));
    ZeroMemory(szPass, sizeof(szPass));
    
    if (name == NULL || password == NULL || lstrlenW(name) > 250 || lstrlenW(password) > 255)
        EXIT_WITH_HRESULT(E_INVALIDARG);    

    hr = ExtractUserName(name, szName, ARRAY_SIZE(szName), szDomain, ARRAY_SIZE(szDomain));
    ON_ERROR_EXIT();

    hr = StringCchCopyToArrayW(szPass, password);
    ON_ERROR_EXIT();

    hr = CallLogonUser(szName, szDomain, szPass, &hToken, &fPrimaryToken);
    if (hr == E_ACCESSDENIED)
    {
        // Revert the thread token and try
        HANDLE hCurToken = GetCurrentToken();
        if (hCurToken == NULL)
            EXIT_WITH_HRESULT(E_ACCESSDENIED);
        if (!SetThreadToken(NULL, NULL))
        {
            CloseHandle(hCurToken);
            EXIT_WITH_LAST_ERROR();   
        }

        hr = CallLogonUser(szName, szDomain, szPass, &hToken, &fPrimaryToken);
        SetThreadToken(NULL, hCurToken);
        CloseHandle(hCurToken);
    }
    ON_ERROR_EXIT();

    if ((fImpersonationToken && fPrimaryToken) || (!fImpersonationToken && !fPrimaryToken))
    {
        hr = ChangeTokenType(&hToken, fImpersonationToken);
        ON_ERROR_EXIT();
    }

    if (_wcsicmp(name, SZ_NT_ANONONYMOUS) != 0 && IsTokenAnonymousUser(hToken))
    {
        InterlockedDecrement(&g_lNumTokensCreated);                
        CloseHandle(hToken);
        hToken = NULL;
        EXIT_WITH_HRESULT(E_FAIL);
    }

    hr = AddProcessSidToObjectDACL(hToken);
    ON_ERROR_CONTINUE(); // Not a critical failure: best effort to set the process's sid in the token's dacl
    
    hr = S_OK;

Cleanup:
    if (hr == S_OK)
        return hToken;

    if (hToken != NULL)
    {
        InterlockedDecrement(&g_lNumTokensCreated);                
        CloseHandle(hToken);
    }

    if (szError != NULL && iErrorSize > 0)
    {
        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL, hr, LANG_SYSTEM_DEFAULT, szError, iErrorSize, NULL);
    }

    return NULL;
}

//////////////////////////////////////////////////////////////////////

HANDLE
__stdcall
GetCurrentToken()
{
    HANDLE   hToken = NULL;
    HRESULT  hr = S_OK;
    BOOL     fRet;

    fRet = OpenThreadToken( GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &hToken);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);
    InterlockedIncrement(&g_lNumTokensCreated);

 Cleanup:
    if (hr == S_OK)
        return hToken;

    return NULL;
}

//////////////////////////////////////////////////////////////////////

int
__stdcall
GetGroupsForUser (
     HANDLE   iToken, 
     LPWSTR   str,
     int      iSize)
{
    BYTE           bufStatic [2048];
    LPBYTE         buf             = bufStatic;
    DWORD          dwSize          = sizeof(bufStatic);
    DWORD          dwRequire       = 0;
    TOKEN_GROUPS * pGroups         = NULL;
    int            iFillPos        = 0;
    BOOL           fOverflow       = FALSE;
    DWORD          iter            = 0;
    HRESULT        hr              = S_OK;
    BOOL           fRet;

    ZeroMemory(str, iSize * sizeof(WCHAR));

    if (GetTokenInformation(iToken, TokenGroups, (LPVOID)buf, dwSize, &dwRequire) == FALSE)
    {
        if (dwRequire > dwSize)
        {
            buf = new BYTE[dwRequire];
            ON_OOM_EXIT(buf);

            fRet = GetTokenInformation(iToken, TokenGroups, (LPVOID)buf, dwRequire, &dwRequire);
            ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);
        }
        else 
        {
            EXIT_WITH_LAST_ERROR();
        }
    }

    pGroups = (TOKEN_GROUPS *) buf;
    for(iter=0; iter<pGroups->GroupCount; iter++)
    {
        WCHAR         szName [256], szDomain [256];
        DWORD         dwName = 256, dwDomain = 256;
        SID_NAME_USE  nameUse;

        szName[0] = szDomain[0] = NULL;

        BOOL fRet = LookupAccountSid(NULL, pGroups->Groups[iter].Sid, 
                                     szName, &dwName, 
                                     szDomain, &dwDomain,  
                                     &nameUse);

        ON_ZERO_CONTINUE_WITH_LAST_ERROR(fRet);
        if (fRet == FALSE)
            continue;
    
        int iDomain = lstrlenW(szDomain);
        int iName   = lstrlenW(szName);
        int iReq    = iDomain + iName + 1 + ((iDomain > 0) ? 1 : 0);
 
        if (iReq + iFillPos < iSize)
        {
            if (iFillPos > 0)
                str[iFillPos++] = L'\t';

            if (iDomain > 0)
            {
                wcsncpy(&str[iFillPos], szDomain, iDomain);
                iFillPos += iDomain;
                str[iFillPos++] = L'\\';
            }

            wcsncpy(&str[iFillPos], szName, iName);
            iFillPos += iName;
        }
        else
        {
            fOverflow = TRUE;
            iFillPos += iReq;
        }
    }

 Cleanup:
    if (buf != NULL && buf != bufStatic)
        delete [] buf;

    if (fOverflow)
        return -(iFillPos + 1);

    return iFillPos;
}

/////////////////////////////////////////////////////////////////////////////

PSECURITY_DESCRIPTOR
__stdcall
GetFileSecurityDescriptor(
        LPCWSTR szFile)
{
    PSECURITY_DESCRIPTOR  pSecDesc = (void *) -1;
    HANDLE                hFile    = INVALID_HANDLE_VALUE;
    HRESULT               hr       = S_OK;

    if (szFile == NULL)
        return (PSECURITY_DESCRIPTOR) -1;

    hFile = CreateFile( szFile, 
                        GENERIC_READ, 
                        FILE_SHARE_WRITE | FILE_SHARE_DELETE | FILE_SHARE_READ, 
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        DWORD dwErr = GetLastError();
        if (dwErr == ERROR_FILE_NOT_FOUND || dwErr == ERROR_PATH_NOT_FOUND)
            return 0;

        EXIT_WITH_LAST_ERROR();
    }

    hr = GetSecurityDescriptor(hFile, &pSecDesc);
    ON_ERROR_EXIT();

 Cleanup:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    if (hr != S_OK)
        pSecDesc = (void *) -1;

    return pSecDesc;
}

/////////////////////////////////////////////////////////////////////////////

void
__stdcall
FreeFileSecurityDescriptor(PVOID iSecDesc)
{
    if ((INT_PTR)iSecDesc != 0 && (INT_PTR)iSecDesc != -1)
        delete iSecDesc;
}

/////////////////////////////////////////////////////////////////////////////

BOOL
__stdcall
IsAccessToFileAllowed(
        HANDLE                  iSecurityDesc, 
        PSECURITY_DESCRIPTOR    iThreadToken,
        int                     iAccess)
{
    if (!g_fRunningOnXspToolOrIEChecked)
    {
        g_fRunningOnXspToolOrIE = CheckIfRunningOnXspToolOrIE();
        g_fRunningOnXspToolOrIEChecked = TRUE;
    }

    if (g_fRunningOnXspToolOrIE)
        return TRUE;


    if (iSecurityDesc == (PSECURITY_DESCRIPTOR) (-1))
        return FALSE;

    if (iSecurityDesc == 0)
        return TRUE;

    HRESULT   hr         = S_OK;
    BOOL      fHasAccess = FALSE;

    hr = CheckUserAccess( iThreadToken, 
                          iSecurityDesc,
                          iAccess,
                          &fHasAccess);

    ON_ERROR_EXIT();

 Cleanup:
    if (hr != S_OK)
        fHasAccess = FALSE;

    return fHasAccess;
}
 
/////////////////////////////////////////////////////////////////////////////

HRESULT
GetSecurityDescriptor(
    HANDLE hFile,
    PSECURITY_DESCRIPTOR *ppSecDecriptor)
{
    ULONG size = 128;  // init size for the security descriptor
    UINT  err;

    do
    {
        //
        // Allocate the buffer
        //

        void * pBuf = new BYTE[size];

        if (pBuf == NULL)
        {
            *ppSecDecriptor = NULL;
            return E_OUTOFMEMORY;
        }

        //
        //  Call the API
        //

        BOOL rc = GetKernelObjectSecurity(
                        hFile,
                        OWNER_SECURITY_INFORMATION |
                        GROUP_SECURITY_INFORMATION |
                        DACL_SECURITY_INFORMATION,
                        (PSECURITY_DESCRIPTOR) pBuf,
                        size,
                        &size
                        );

        if (rc)
        {
            // succeded
            *ppSecDecriptor = (PSECURITY_DESCRIPTOR)pBuf;
            return S_OK;
        }

        delete [] pBuf;
        err = GetLastError();
    }

    while (err == ERROR_INSUFFICIENT_BUFFER);

    //
    //  Ended with error
    //

    *ppSecDecriptor = NULL;

    if (err == ERROR_NOT_SUPPORTED)
    {
        // File system doesn't have any security descriptors
        return S_OK;
    }
    else
    {
        // Some unknown error
        return E_FAIL;
    }

}

//////////////////////////////////////////////////////////////////////////////////
//
// To check if the given user has rights to access the secutiry descriptor
//
//////////////////////////////////////////////////////////////////////////////////

HRESULT
CheckUserAccess(
    HANDLE                  hUserAccessToken,
    PSECURITY_DESCRIPTOR    pSecDescriptor,
    int                     iAccess,
    BOOL *                  pHasAccess)
{
    //
    // No security descriptor - access granted
    //

    if (pSecDescriptor == NULL)
    {
        *pHasAccess = TRUE;
        return S_OK;
    }

    //
    //  Build up the arguments to call AccessCheck()
    //

    GENERIC_MAPPING gm = {      // generic mapping struct
        FILE_GENERIC_READ,
        FILE_GENERIC_WRITE,
        FILE_GENERIC_EXECUTE,
        FILE_ALL_ACCESS
        };

    DWORD psBuf[32];                                // privilege set buffer
    DWORD psSize = sizeof(psBuf);                   // privilege set size
    PRIVILEGE_SET *pPs = (PRIVILEGE_SET *)psBuf;    // privilege set struct
    pPs->PrivilegeCount = 0;

    DWORD grantedAccess;      // granted access mask
    BOOL  accessStatus;       // access status flag

    DWORD                dwAccessDesired = 0;
    GENERIC_MAPPING      GenericMapping;
    if (iAccess & 0x1)
      dwAccessDesired |= ACCESS_READ;
    if (iAccess & 0x2)
      dwAccessDesired |= ACCESS_WRITE;
    
    ZeroMemory(&GenericMapping, sizeof(GenericMapping));
    GenericMapping.GenericRead = ACCESS_READ;
    GenericMapping.GenericWrite = ACCESS_WRITE;
    GenericMapping.GenericExecute = 0;
    GenericMapping.GenericAll = ACCESS_READ | ACCESS_WRITE;
    MapGenericMask(&dwAccessDesired, &GenericMapping);
    
    //
    //  Call AccessCheck()
    //

    HRESULT hr = S_OK;

    if (AccessCheck(
            pSecDescriptor,     // pointer to security descriptor
            hUserAccessToken,   // handle to client access token
            dwAccessDesired,    // access mask to request
            &gm,                // addr of generic-mapping structure
            pPs,                // addr of privilege-set structure
            &psSize,            // addr of size of privilege-set structure
            &grantedAccess,     // addr of granted access mask
            &accessStatus       // addr of flag (gets TRUE if access granted)
            ))
    {
        *pHasAccess = accessStatus;
    }
    else
    {
        *pHasAccess = FALSE;
        EXIT_WITH_LAST_ERROR();
    }

Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Ticket format:
//  Byte: Version
//  Unicode String: name
//  8 bytes: issue date
//  Byte: Is persistent
//  8 bytes: expire date
//  Unicode string: user data
HRESULT
CookieAuthParseTicket (
        BYTE *      pData,
        int         iDataLen,
        LPWSTR      szName,
        int         iNameLen,
        LPWSTR      szData,
        int         iUserDataLen,
        LPWSTR      szPath,
        int         iPathLen,
        BYTE *      pBytes,
        __int64 *   pDates)
{
    if ( pData  == NULL || iDataLen < COOKIE_AUTH_TICKET_START + 10 || 
         szName == NULL || iNameLen < 1  ||
         szData == NULL || iUserDataLen < 1  ||
         szPath == NULL || iPathLen < 1  ||
         pBytes == NULL || pDates == NULL )
    {
        return E_INVALIDARG;
    }

    int          iPos  = COOKIE_AUTH_TICKET_START;
    int          iNext = 0;
    WCHAR *      szStr;
    HRESULT      hr = S_OK;
    int          iWCharsRem;

    ////////////////////////////////////////////////////////////
    // Step 1: Copy the version
    pBytes[0] = pData[iPos++];

    ////////////////////////////////////////////////////////////
    // Step 2: Copy the name
    szStr = (WCHAR *) &pData[iPos];
    
    for(iNext = 0; iNext < (iDataLen-iPos)/2 && szStr[iNext] != NULL && iNext < iNameLen; iNext++)
        szName[iNext] = szStr[iNext];

    if (iNext >= (iDataLen-iPos)/2 || iNext >= iNameLen)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    szName[iNext] = NULL;
    iPos += 2*(iNext+1);

    ////////////////////////////////////////////////////////////
    // Step 3: Copy the issue date
    if (iPos > iDataLen + 8)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    memcpy(pDates, &pData[iPos], 8);
    iPos += 8;

    ////////////////////////////////////////////////////////////
    // Step 4: Copy the IsPersistent bytes
    if (iPos > iDataLen + 1)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    memcpy(&pBytes[1], &pData[iPos], 1);
    iPos += 1;


    ////////////////////////////////////////////////////////////
    // Step 3: Copy the expires date
    if (iPos > iDataLen + 8)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    memcpy(&pDates[1], &pData[iPos], 8);
    iPos += 8;

    ////////////////////////////////////////////////////////////
    // Step 4: Copy the user-data string
    szStr = (WCHAR *) &pData[iPos];
    iWCharsRem = (iDataLen-iPos)/2;
    for(iNext = 0; szStr[iNext] != NULL; iNext++)
    {
        if (iNext >= iWCharsRem || iNext >= iUserDataLen)
            EXIT_WITH_HRESULT(E_UNEXPECTED);
        szData[iNext] = szStr[iNext];
    }

    szData[iNext] = NULL;
    iPos += 2*(iNext+1);

    ////////////////////////////////////////////////////////////
    // Step 5: Copy the path string
    szStr = (WCHAR *) &pData[iPos];
    iWCharsRem = (iDataLen - iPos)/2;
    for(iNext = 0; szStr[iNext] != NULL; iNext++)
    {
        if (iNext >= iWCharsRem || iNext >= iPathLen)
            EXIT_WITH_HRESULT(E_UNEXPECTED);
        szPath[iNext] = szStr[iNext];
    }
    szPath[iNext] = NULL;

    // Check if we consumed all the data
    if (iWCharsRem > iNext + 1)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

int
CookieAuthConstructTicket (
        BYTE *      pData,
        int         iDataLen,
        LPCWSTR     szName,
        LPCWSTR     szData,
        LPCWSTR     szPath,
        BYTE *      pBytes,
        __int64 *   pDates )
{
    HRESULT      hr    = S_OK;
    int          iPos  = COOKIE_AUTH_TICKET_START;
    int          iNext = 0;
    WCHAR *      szStr;


    if ( pData  == NULL || iDataLen < COOKIE_AUTH_TICKET_START+10  || 
         szName == NULL || szData == NULL || szPath == NULL ||
         pBytes == NULL || pDates == NULL )
    {
        EXIT_WITH_HRESULT(E_INVALIDARG);
    }

    ////////////////////////////////////////////////////////////
    // Step 1: Copy the version
    pData[iPos++] = pBytes[0];

    ////////////////////////////////////////////////////////////
    // Step 2: Copy the name
    szStr = (WCHAR *) &pData[iPos];
    iNext = lstrlenW(szName);
    if (iNext*2 + 2 + iPos > iDataLen)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    StringCchCopyW(szStr, iNext+1, szName);

    iPos += 2*(iNext+1);

    ////////////////////////////////////////////////////////////
    // Step 3: Copy the issue date
    if (iPos > iDataLen + 8)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    memcpy(&pData[iPos], pDates, 8);
    iPos += 8;

    ////////////////////////////////////////////////////////////
    // Step 4: Copy the IsPersistent bytes
    if (iPos > iDataLen + 1)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    memcpy(&pData[iPos], &pBytes[1], 1);
    iPos += 1;

    ////////////////////////////////////////////////////////////
    // Step 3: Copy the expires date
    if (iPos > iDataLen + 8)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    memcpy(&pData[iPos], &pDates[1], 8);
    iPos += 8;

    ////////////////////////////////////////////////////////////
    // Step 4: Copy the user-data string
    szStr = (WCHAR *) &pData[iPos];
    iNext = lstrlenW(szData);
    if (iNext*2 + 2 + iPos > iDataLen)
        EXIT_WITH_HRESULT(E_UNEXPECTED);
    StringCchCopyW(szStr, iNext+1, szData);
    iPos += 2*(iNext+1);

    szStr = (WCHAR *) &pData[iPos];
    iNext = lstrlenW(szPath);
    if (iNext*2 + 2 + iPos > iDataLen)
        EXIT_WITH_HRESULT(E_UNEXPECTED);
    StringCchCopyW(szStr, iNext+1, szPath);

    iPos += 2*(iNext+1);

 Cleanup:
    if (hr == S_OK)
        return iPos;
    else
        return hr;
}

/////////////////////////////////////////////////////////////////////////////

BOOL
CheckIfRunningOnXspToolOrIE ()
{
#if MYWEB
    if (MyWebRunningOnMyWeb())
        return TRUE;
#endif

    return !_wcsicmp(Names::ExeFileName(), L"xsptool.exe");
}

/////////////////////////////////////////////////////////////////////////////
BOOL
GetAutogenKeys(
        LPBYTE    pDefaultKey,
        int       iBufSizeIn, 
        LPBYTE    pBuf, 
        int       iBufSizeOut)
{
    if (pBuf == NULL || pDefaultKey == NULL || iBufSizeIn != AUTOGEN_KEYS_SIZE || iBufSizeOut != AUTOGEN_KEYS_SIZE)
        return FALSE;

    // Let one thread create the key
    if (g_iAutogenKeyCreate < 10000 && InterlockedIncrement(&g_iAutogenKeyCreate) == 1)
    {
        if (GetAutogenKeysSingleThread(pDefaultKey) != S_OK)
        { 
            memcpy(g_pAutogenKey, pDefaultKey, AUTOGEN_KEYS_SIZE);
        }
        g_iAutogenKeyCreate = 10000;
    }
    
    // Make threads wait while key is created (g_iAutogenKeyCreate < 10000)
    for(int iter=0; iter<600 && g_iAutogenKeyCreate < 10000; iter++) // Sleep at most a minute
        Sleep(100);

    // Copy in the key from g_pAutogenKey
    memcpy(pBuf, g_pAutogenKey, AUTOGEN_KEYS_SIZE);
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
GetAutogenKeysSingleThread(
        LPBYTE    pDefaultKey)
{
    LSA_HANDLE   hLasPolicy      = NULL;
    HRESULT      hr              = S_OK;
    HANDLE       hEvent          = INVALID_HANDLE_VALUE;
    
    ////////////////////////////////////////////////////////////
    // Step 1: Open LSA Store
    hr = OpenLSAPolicy(&hLasPolicy);
    if (hr != S_OK)
    {
        ON_ERROR_CONTINUE();
        hr = GetKeyFromHKCURegistry(pDefaultKey, AUTOGEN_KEYS_SIZE);
        ON_ERROR_EXIT();
        memcpy(g_pAutogenKey, pDefaultKey, AUTOGEN_KEYS_SIZE); 
        EXIT();
    }
    
    ////////////////////////////////////////////////////////////
    // Step 2: See if key is present in store
    hr = DoesKeyExist(hLasPolicy);
    if (hr == S_OK)
        EXIT();

    ////////////////////////////////////////////////////////////
    // Step 3: Cross process sync before we attempt to store in LSA
    hEvent = CreateEvent(NULL, TRUE, TRUE, SZ_AUTOGEN_KEYS_EVENT);
    ON_ZERO_EXIT_WITH_LAST_ERROR(hEvent);
    WaitForSingleObject(hEvent, 30 * 1000); // Wait at most 30 seconds: ignore failure

    ////////////////////////////////////////////////////////////
    // Step 4: See if key is present in store: Maybe some other process stored it
    hr = DoesKeyExist(hLasPolicy);
    if (hr == S_OK)
        EXIT();
    
    ////////////////////////////////////////////////////////////
    // Step 5: Store key and exit
    hr = StoreKeyInLSA(hLasPolicy, pDefaultKey);
    ON_ERROR_EXIT();

 Cleanup:
    if (hLasPolicy != NULL)
        LsaClose(hLasPolicy);
    if (hEvent != INVALID_HANDLE_VALUE)
    {
        SetEvent(hEvent);
        CloseHandle(hEvent);
    }

    return hr;
}        

/////////////////////////////////////////////////////////////////////////////

HRESULT
OpenLSAPolicy(
        LSA_HANDLE * phLasPolicy)
{
    HRESULT                hr        = S_OK;
    LSA_OBJECT_ATTRIBUTES  objAttribs;
    DWORD                  dwErr;

    ZeroMemory(&objAttribs, sizeof(objAttribs));
    dwErr = LsaOpenPolicy(NULL, &objAttribs, POLICY_ALL_ACCESS, phLasPolicy);
    if ( dwErr != STATUS_SUCCESS)
        EXIT_WITH_WIN32_ERROR(LsaNtStatusToWinError(dwErr));

 Cleanup:
    if (hr != S_OK)
        (*phLasPolicy) = NULL;
    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
DoesKeyExist(
        LSA_HANDLE hLasPolicy)
{
    HRESULT               hr                = S_OK;
    PLSA_UNICODE_STRING   pszLsaData        = NULL; 
    LSA_UNICODE_STRING    szLsaKeyName;
    DWORD                 dwErr;

    szLsaKeyName.Length = szLsaKeyName.MaximumLength = (unsigned short) (lstrlenW(SZ_AUTOGEN_KEYS) * sizeof(WCHAR));
    szLsaKeyName.Buffer = (WCHAR *) SZ_AUTOGEN_KEYS;

    dwErr = LsaRetrievePrivateData(hLasPolicy, &szLsaKeyName, &pszLsaData);
    if ( dwErr != STATUS_SUCCESS)
        EXIT_WITH_WIN32_ERROR(LsaNtStatusToWinError(dwErr));

    if ( pszLsaData == NULL || pszLsaData->Buffer == NULL || pszLsaData->Length != AUTOGEN_KEYS_SIZE)
        EXIT_WITH_HRESULT(E_UNEXPECTED);
    
    memcpy(g_pAutogenKey, pszLsaData->Buffer, AUTOGEN_KEYS_SIZE); 

 Cleanup:
    if (pszLsaData != NULL)
        LsaFreeMemory(pszLsaData);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
StoreKeyInLSA(
        LSA_HANDLE hLasPolicy,
        LPBYTE     pBuf)
{
    HRESULT               hr                = S_OK;
    LSA_UNICODE_STRING    szLsaKeyName;
    LSA_UNICODE_STRING    szLsaTemp;
    DWORD                 dwErr;

    szLsaKeyName.Length = szLsaKeyName.MaximumLength = (unsigned short) (lstrlenW(SZ_AUTOGEN_KEYS) * sizeof(WCHAR));
    szLsaKeyName.Buffer = (WCHAR *) SZ_AUTOGEN_KEYS;

    szLsaTemp.Length = szLsaTemp.MaximumLength = (unsigned short) AUTOGEN_KEYS_SIZE;
    szLsaTemp.Buffer = (WCHAR *) pBuf; 

    dwErr = LsaStorePrivateData( hLasPolicy, &szLsaKeyName, &szLsaTemp);
    if ( dwErr != STATUS_SUCCESS)
        EXIT_WITH_WIN32_ERROR(LsaNtStatusToWinError(dwErr));

    memcpy(g_pAutogenKey, pBuf, AUTOGEN_KEYS_SIZE); 
 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
GetKeyFromHKCURegistry(
        LPBYTE    pKey,
        DWORD     dwKeySize)
{
    if (pKey == NULL || dwKeySize < 1)
        return E_INVALIDARG;
    
    HRESULT   hr           = S_OK;
    HKEY      hRegKey      = NULL;
    BYTE      buf[1024];
    DWORD     dwSize, dwType, dwFormat, dwFormatSize, dwFormatType;

    ////////////////////////////////////////////////////////////
    // Step 1: Open the reg key
    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGPATH_MACHINE_APP_L, 0, 
                     KEY_READ | KEY_WRITE, &hRegKey) != ERROR_SUCCESS)
    {
        if (RegCreateKeyEx(HKEY_CURRENT_USER, REGPATH_MACHINE_APP_L, 0, NULL, 0, 
                           KEY_READ | KEY_WRITE, NULL, &hRegKey, NULL) != ERROR_SUCCESS)
        {
            hRegKey = NULL;
            EXIT_WITH_LAST_ERROR();
        }
    }

    ////////////////////////////////////////////////////////////
    // Step 2: Read the reg key
    ZeroMemory(buf, sizeof(buf));
    dwSize        = sizeof(buf);
    dwFormatSize  = sizeof(DWORD);
    if ( RegQueryValueEx(hRegKey, SZ_REG_AUTOGEN_KEY_FORMAT, 0, &dwFormatType, (BYTE *) &dwFormat, &dwFormatSize) == ERROR_SUCCESS &&
         dwFormatType == REG_DWORD &&
         RegQueryValueEx(hRegKey, SZ_REG_AUTOGEN_KEY, 0, &dwType, buf, &dwSize) == ERROR_SUCCESS &&
         MachineKeyWasCreatedAfterInstall())
    {
        hr = UnCryptKeyFromReg(pKey, dwKeySize, buf, dwSize, dwFormat);
        if (hr == S_OK)
            EXIT();
        ON_ERROR_CONTINUE();
    }

    ////////////////////////////////////////////////////////////
    // Step 3: If key doesn't exists, Crypt the key and store
    dwSize = sizeof(buf);        
    hr = CryptKeyToStoreInReg(pKey, dwKeySize, buf, &dwSize, &dwFormat);
    if (hr == S_OK)
    {
        if ( RegSetValueEx(hRegKey, SZ_REG_AUTOGEN_KEY_FORMAT, 0, REG_DWORD, (LPBYTE) &dwFormat, sizeof(dwFormat)) == ERROR_SUCCESS &&
             RegSetValueEx(hRegKey, SZ_REG_AUTOGEN_KEY, 0, REG_BINARY, buf, dwSize) == ERROR_SUCCESS)
        {
            FILETIME tKeyTime;
            GetSystemTimeAsFileTime(&tKeyTime);
            RegSetValueEx(hRegKey, SZ_REG_AUTOGEN_KEY_TIME, 0, REG_QWORD, (LPBYTE) &tKeyTime, sizeof(tKeyTime));
            EXIT();
        }
    }
    else
    {
        ON_ERROR_CONTINUE();
    }

    ////////////////////////////////////////////////////////////
    // Step 4: If storing in crypt format failed, try storing without crypt 
    dwFormat = DW_KEY_FORMAT_CLEAR;
    if (RegSetValueEx(hRegKey, SZ_REG_AUTOGEN_KEY_FORMAT, 0, REG_DWORD, (LPBYTE) &dwFormat, sizeof(DWORD)) == ERROR_SUCCESS &&
        RegSetValueEx(hRegKey, SZ_REG_AUTOGEN_KEY, 0, REG_BINARY, pKey, dwKeySize) == ERROR_SUCCESS)
    {
        FILETIME tKeyTime;
        GetSystemTimeAsFileTime(&tKeyTime);
        RegSetValueEx(hRegKey, SZ_REG_AUTOGEN_KEY_TIME, 0, REG_QWORD, (LPBYTE) &tKeyTime, sizeof(tKeyTime));
        hr = S_OK;
        EXIT();
    }
    
    EXIT_WITH_LAST_ERROR();
 Cleanup:
    if (hRegKey != NULL)
        RegCloseKey(hRegKey);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CryptKeyToStoreInReg(
        LPBYTE   pKey,
        DWORD    dwKeySize,
        LPBYTE   pBuf,
        LPDWORD  pdwBufSize,
        LPDWORD  pdwFormat)
{
    if (pKey == NULL || dwKeySize < 1 || pBuf == NULL || pdwBufSize == NULL || (*pdwBufSize) < 1 || pdwFormat == NULL)
        return E_INVALIDARG;

    HRESULT     hr = S_OK;
    DATA_BLOB   dataIn, dataOut, dataEnt;

    dataIn.cbData = dwKeySize;
    dataIn.pbData = pKey;
    dataOut.cbData = 0;
    dataOut.pbData = NULL;
    dataEnt.cbData = lstrlenW(SZ_AUTOGEN_KEYS_ENTROPY) * sizeof(WCHAR) + sizeof(WCHAR);
    dataEnt.pbData = (LPBYTE) SZ_AUTOGEN_KEYS_ENTROPY;
    
    if (CryptProtectData(&dataIn, SZ_AUTOGEN_KEYS_PASS, &dataEnt, NULL, NULL, CRYPTPROTECT_UI_FORBIDDEN, &dataOut))
    {
        if ((*pdwBufSize) < dataOut.cbData)
            EXIT_WITH_WIN32_ERROR(ERROR_INSUFFICIENT_BUFFER);
        memcpy(pBuf, dataOut.pbData, dataOut.cbData);
        (*pdwBufSize) = dataOut.cbData;
        (*pdwFormat) = DW_KEY_FORMAT_CRYPT;
    }
    else
    {   
        dataOut.pbData = NULL;
        if ((*pdwBufSize) < dwKeySize)
            EXIT_WITH_WIN32_ERROR(ERROR_INSUFFICIENT_BUFFER);
        memcpy(pBuf, pKey, dwKeySize);
        (*pdwBufSize) = dwKeySize;
        (*pdwFormat) = DW_KEY_FORMAT_CLEAR;
    }

    hr = S_OK;
 Cleanup:
    if (dataOut.pbData != NULL)
        LocalFree(dataOut.pbData);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
UnCryptKeyFromReg(
        LPBYTE   pKey,
        DWORD    dwKeySize,
        LPBYTE   pBuf,
        DWORD    dwBufSize,
        DWORD    dwFormat)
{
    if (pKey == NULL || dwKeySize < 1 || pBuf == NULL || dwBufSize < 1)
        return E_INVALIDARG;

    if (dwFormat != DW_KEY_FORMAT_CLEAR && dwFormat != DW_KEY_FORMAT_CRYPT) 
        return E_INVALIDARG;

    HRESULT  hr = S_OK;
    DATA_BLOB   dataIn, dataOut, dataEnt;
    dataIn.cbData = dwBufSize;
    dataIn.pbData = pBuf;
    dataOut.cbData = 0;
    dataOut.pbData = NULL;
    dataEnt.cbData = lstrlenW(SZ_AUTOGEN_KEYS_ENTROPY) * sizeof(WCHAR) + sizeof(WCHAR);
    dataEnt.pbData = (LPBYTE) SZ_AUTOGEN_KEYS_ENTROPY;

    if (dwFormat == DW_KEY_FORMAT_CLEAR)
    {        
        if(dwBufSize != dwKeySize)
            EXIT_WITH_HRESULT(E_INVALIDARG);
        memcpy(pKey, pBuf, dwBufSize);
    }
    else
    {    
        if (!CryptUnprotectData(&dataIn, NULL, &dataEnt, NULL, NULL, CRYPTPROTECT_UI_FORBIDDEN, &dataOut))
        {
            dataOut.pbData = NULL;
            EXIT_WITH_LAST_ERROR();
        }

        if (dwKeySize != dataOut.cbData)
        {
            EXIT_WITH_HRESULT(E_UNEXPECTED);
        }
        memcpy(pKey, dataOut.pbData, dwKeySize);
    }
 Cleanup:
    if (dataOut.pbData != NULL)
        LocalFree(dataOut.pbData);

    return hr;    
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
AddProcessSidToObjectDACL(
        HANDLE   hHandle)
{
    if (hHandle == NULL)
        return E_INVALIDARG;

    HRESULT      hr            = S_OK;
    HANDLE       hProcessToken = NULL;
    BOOL         fRet          = FALSE;
    BYTE         bufStatic [2048];
    DWORD        dwSize          = sizeof(bufStatic);
    LPVOID       pUser           = bufStatic;
    HANDLE       hThreadToken    = NULL;
    
    fRet = OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hProcessToken);    
    ON_ZERO_CONTINUE_WITH_LAST_ERROR(fRet);

    if (!fRet)
    {
        hThreadToken = GetCurrentToken();
        if (hThreadToken == NULL)
            EXIT_WITH_HRESULT(E_ACCESSDENIED);
        if (!SetThreadToken(NULL, NULL))
        {
            CloseHandle(hThreadToken);   
            hThreadToken = NULL;
            EXIT_WITH_LAST_ERROR();   
        }        
        fRet = OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hProcessToken);    
        ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);
    }

    ZeroMemory(bufStatic, sizeof(bufStatic));
    fRet = GetTokenInformation(hProcessToken, TokenUser, pUser, dwSize, &dwSize);
    ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);

    hr = CRegAccount::AddSidToToken(hHandle, ((TOKEN_USER *)pUser)->User.Sid, &fRet);
    ON_ERROR_EXIT();

 Cleanup:
    if (hThreadToken != NULL)
    {
        SetThreadToken(NULL, hThreadToken);
        CloseHandle(hThreadToken);   
    }
    if (hProcessToken)
        CloseHandle(hProcessToken);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

PSID
GetSidFromToken(
        HANDLE   hToken)
{
    if (hToken == NULL)
        return NULL;
    HRESULT       hr              = S_OK;
    PSID          pSid            = NULL;
    BYTE          bufStatic [2048];
    DWORD         dwSize          = sizeof(bufStatic);
    LPVOID        pUser           = bufStatic;
    DWORD         dwRequire       = 0;

    if ( !GetTokenInformation(hToken, TokenUser, pUser, dwSize, &dwRequire) || 
         !IsValidSid(((TOKEN_USER *)pUser)->User.Sid))
    {
        EXIT_WITH_LAST_ERROR();
    }

    dwSize = GetLengthSid(((TOKEN_USER *)pUser)->User.Sid);
    if (dwSize == 0 || dwSize > 2048)
        EXIT_WITH_LAST_ERROR();
    pSid = (PSID) new BYTE[dwSize];
    ON_OOM_EXIT(pSid);
    if (!CopySid(dwSize, pSid, ((TOKEN_USER *)pUser)->User.Sid))
        EXIT_WITH_LAST_ERROR();
 Cleanup:
    if (hr != S_OK)
    {
        DELETE_BYTES(pSid);
        return NULL;
    }
    return pSid;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

PSID
GetGuestUserSid()
{
    PUSER_MODALS_INFO_2        pUserModalsInfo       = NULL;
    DWORD                      dwErr                 = 0;
    PUCHAR                     pSubCount             = NULL;
    PSID                       pSid                  = NULL;
    PSID                       pSidMachine           = NULL;
    HRESULT                    hr                    = S_OK;
    PSID_IDENTIFIER_AUTHORITY  pSidIdAuth            = NULL;
    PDWORD                     pSrc                  = NULL;
    PDWORD                     pDest                 = NULL;
    
    dwErr = NetUserModalsGet(NULL, 2, (LPBYTE *)&pUserModalsInfo);
    if (dwErr != NERR_Success)
        EXIT_WITH_WIN32_ERROR(dwErr);
    if (pUserModalsInfo == NULL)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    pSidMachine = pUserModalsInfo->usrmod2_domain_id;
    if (pSidMachine == NULL || !IsValidSid(pSidMachine))
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    pSubCount = GetSidSubAuthorityCount(pSidMachine);
    if (pSubCount == NULL || (*pSubCount) == 0)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    pSid = (PSID) NEW_CLEAR_BYTES(GetSidLengthRequired(*pSubCount + 1));
    ON_OOM_EXIT(pSid);
    
    pSidIdAuth = GetSidIdentifierAuthority(pSidMachine);
    if (pSidIdAuth == NULL)
        EXIT_WITH_HRESULT(E_UNEXPECTED);
        
    dwErr = InitializeSid(pSid, pSidIdAuth, (BYTE)(*pSubCount+1)); 
    ON_ZERO_EXIT_WITH_LAST_ERROR(dwErr);
    
    for (DWORD iter = 0; iter < *pSubCount; iter++)
    {
        pSrc  = GetSidSubAuthority(pSidMachine, iter);
        ON_ZERO_EXIT_WITH_LAST_ERROR(pSrc);

        pDest = GetSidSubAuthority(pSid, iter);
        ON_ZERO_EXIT_WITH_LAST_ERROR(pDest);
        
        *pDest = *pSrc;
    }

    pDest = GetSidSubAuthority(pSid, *pSubCount);
    ON_ZERO_EXIT_WITH_LAST_ERROR(pDest);
    
    *pDest = DOMAIN_USER_RID_GUEST;

 Cleanup:
    if (pUserModalsInfo != NULL)
        NetApiBufferFree(pUserModalsInfo);
    if (hr != S_OK)
    {
        DELETE_BYTES(pSid);
        return NULL;
    }
    return pSid;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
ResetMachineKeys()
{
    HRESULT               hr = S_OK;
    LSA_HANDLE            hLasPolicy = NULL;
    LSA_UNICODE_STRING    szLsaKeyName;
    DWORD                 dwErr;
    HKEY                  hKeyXSP = NULL;

    hr = OpenLSAPolicy(&hLasPolicy);
    ON_ERROR_EXIT();

    szLsaKeyName.Length = szLsaKeyName.MaximumLength = (unsigned short) (lstrlenW(SZ_AUTOGEN_KEYS) * sizeof(WCHAR));
    szLsaKeyName.Buffer = (WCHAR *) SZ_AUTOGEN_KEYS;

    dwErr = LsaStorePrivateData( hLasPolicy, &szLsaKeyName, NULL);
    if ( dwErr != STATUS_SUCCESS)
        ON_WIN32_ERROR_CONTINUE(LsaNtStatusToWinError(dwErr));

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_MACHINE_APP_L,
                     0, KEY_WRITE, &hKeyXSP) == ERROR_SUCCESS)
    {
        FILETIME timeNow;
        GetSystemTimeAsFileTime(&timeNow);
        RegSetValueEx(hKeyXSP, L"LastInstallTime", 0, REG_QWORD, (LPBYTE) &timeNow, sizeof(timeNow));
        RegCloseKey(hKeyXSP);
    }
    
 Cleanup:
    if (hLasPolicy != NULL)
        LsaClose(hLasPolicy);
    return hr;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
ExtractUserName(
        LPCWSTR  szFullName, 
        LPWSTR   szName, 
        DWORD    dwNameSize,
        LPWSTR   szDomain,
        DWORD    dwDomainSize)
{
    WCHAR * pSlash = wcschr(szFullName, L'\\');
    if (pSlash == NULL) // No domain?
    {
        wcsncpy(szName, szFullName, dwNameSize);
        StringCchCopyW(szDomain, dwDomainSize, L".");
    }
    else
    {
        // Copy the name
        wcsncpy(szName,  &pSlash[1], dwNameSize);

        // Copy domain: szFullName till the slash
        for(DWORD iter=0; iter<dwDomainSize-1 && szFullName[iter] != L'\\' && szFullName[iter] != NULL; iter++)
            szDomain[iter] = szFullName[iter];
    }

    // Make sure strings are terminated properly
    szName[dwNameSize-1] = NULL;
    szDomain[dwDomainSize-1] = NULL;    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
CallLogonUser(
        LPWSTR   szName, 
        LPWSTR   szDomain,
        LPWSTR   szPass,
        HANDLE * phToken,
        LPBOOL   pfPrimaryToken)
{
    BOOL      fGotAccessDenied = FALSE;
    BOOL      fRet;
    HRESULT   hr = E_FAIL;
    
    for(int iter=0; iter<NUM_LOGON_TYPES; iter++)
    {        
        fRet = LogonUser(szName, szDomain, szPass, g_dwLogonType[iter], 
                         LOGON32_PROVIDER_DEFAULT, phToken);
        ON_ZERO_CONTINUE_WITH_LAST_ERROR(fRet);   

        if (fRet)
        {
            *pfPrimaryToken = g_fLogonTypePrimaryToken[iter];
            hr = S_OK;
            EXIT();
        }
        else
        {
            if (hr == E_ACCESSDENIED)
                fGotAccessDenied = TRUE;
        }
    }
    

 Cleanup:
    if (hr != S_OK && fGotAccessDenied)
        hr = E_ACCESSDENIED;
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


HRESULT
ChangeTokenType(
        HANDLE * phToken,
        BOOL     fImpersonationToken)
{
    SECURITY_ATTRIBUTES    sa;
    HANDLE                 hNewToken = NULL;
    HRESULT                hr = S_OK;

    ZeroMemory(&sa, sizeof(sa));        
    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;

    if (!DuplicateTokenEx(*phToken, TOKEN_ALL_ACCESS,
                          &sa, SecurityImpersonation,
                          fImpersonationToken ? TokenImpersonation : TokenPrimary,
                          &hNewToken))
    {        
        EXIT_WITH_LAST_ERROR();
    }

    CloseHandle(*phToken);
    *phToken = hNewToken;

 Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


BOOL
IsTokenAnonymousUser(
        HANDLE   hToken)
{
    BOOL     fIsAnonymous  = FALSE;
    PSID     pSid          = GetSidFromToken(hToken);
    PSID     pSidAnonymous = GetGuestUserSid();
    HRESULT  hr            = S_OK;

    if (pSid == NULL || pSidAnonymous == NULL)
        EXIT_WITH_LAST_ERROR();

    fIsAnonymous = EqualSid(pSidAnonymous, pSid);
    
 Cleanup:    
    DELETE_BYTES(pSidAnonymous);
    DELETE_BYTES(pSid);
    return fIsAnonymous;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
BOOL
MachineKeyWasCreatedAfterInstall()
{
    HRESULT   hr          = S_OK;
    HKEY      hRegCU      = NULL;
    HKEY      hRegLM      = NULL;
    DWORD     dwTypeLM, dwTypeCU, dwCUSize = sizeof(FILETIME), dwLMSize = sizeof(FILETIME);
    BOOL      fRet        = FALSE;
    FILETIME  tCU, tLM;
    
    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGPATH_MACHINE_APP_L, 0, KEY_READ, &hRegCU) != ERROR_SUCCESS)
    {
        EXIT_WITH_LAST_ERROR();
    }

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_MACHINE_APP_L, 0, KEY_READ, &hRegLM) != ERROR_SUCCESS)
    {
        EXIT_WITH_LAST_ERROR();
    }
    if (RegQueryValueEx(hRegCU, SZ_REG_AUTOGEN_KEY_TIME, 0, &dwTypeCU, (BYTE *) &tCU, &dwCUSize) != ERROR_SUCCESS || dwTypeCU != REG_QWORD)
    {
        EXIT_WITH_LAST_ERROR();
    }

    if (RegQueryValueEx(hRegLM, L"LastInstallTime", 0, &dwTypeLM, (BYTE *) &tLM, &dwLMSize) != ERROR_SUCCESS)
    {
        EXIT_WITH_LAST_ERROR();
    }

    if (dwTypeLM != REG_QWORD || dwTypeCU != REG_QWORD)
    {
        EXIT_WITH_HRESULT(E_UNEXPECTED);
    }

    if (CompareFileTime(&tLM, &tCU) < 0)
    {
        fRet = TRUE;
    }
    

 Cleanup:
    if (hRegCU != NULL)
        RegCloseKey(hRegCU);
    if (hRegLM != NULL)
        RegCloseKey(hRegLM);
    return fRet;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT
GetCredentialFromRegistry(
        LPCWSTR  szRegKey,
        LPWSTR   szDest,
        DWORD    dwSize)
{
    if (szRegKey == NULL || szRegKey[0] == NULL || szDest == NULL || dwSize < 10)
        return E_INVALIDARG;

    WCHAR *     szPoint1 = NULL;
    WCHAR *     szPoint2 = NULL;
    HRESULT     hr       = S_OK;
    HKEY        hReg     = NULL;
    DWORD       dwType   = 0;
    BYTE        buf[1024];
    DWORD       dwRegSize= sizeof(buf);
    DATA_BLOB   dataIn, dataOut;
    WCHAR       szReg[1024];
    
    if (lstrlenW(szRegKey) >= ARRAY_SIZE(szReg))
        return E_INVALIDARG;
    StringCchCopyW(szReg, ARRAY_SIZE(szReg), szRegKey);

    dataOut.cbData = 0;
    dataOut.pbData = NULL;

    szPoint1 = wcschr(szReg, L':');
    if (szPoint1 == NULL)
        EXIT_WITH_HRESULT(E_UNEXPECTED);
    szPoint1++;
    szPoint2 = wcschr(szPoint1, L'\\');
    if (szPoint2 == NULL)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    szPoint2[0] = NULL;
    szPoint2++;
    
    if (_wcsicmp(szPoint1, L"HKLM") != 0 && _wcsicmp(szPoint1, L"HKEY_LOCAL_MACHINE") != 0)
        EXIT_WITH_HRESULT(E_UNEXPECTED);
        
    szPoint1 = szPoint2;
    szPoint2 = wcschr(szPoint1, L',');
    if (szPoint2 == NULL)
        EXIT_WITH_HRESULT(E_UNEXPECTED);
    
    szPoint2[0] = NULL;
    szPoint2++;
    if (lstrlen(szPoint2) == 0 || lstrlen(szPoint1) == 0)
        EXIT_WITH_HRESULT(E_UNEXPECTED);
        
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPoint1, 0, KEY_READ, &hReg) != ERROR_SUCCESS)
        EXIT_WITH_LAST_ERROR();

    if (RegQueryValueEx(hReg, szPoint2, NULL, &dwType, buf, &dwRegSize) != ERROR_SUCCESS)
        EXIT_WITH_LAST_ERROR();

    if (dwType != REG_BINARY)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    dataIn.cbData = dwRegSize;
    dataIn.pbData = buf;
    
    if (!CryptUnprotectData(&dataIn, NULL, NULL, NULL, NULL, CRYPTPROTECT_UI_FORBIDDEN, &dataOut))
    {
        dataOut.pbData = NULL;
        EXIT_WITH_LAST_ERROR();
    }

    dwRegSize = dataOut.cbData / sizeof(WCHAR);
    if (dwRegSize >= dwSize)
        EXIT_WITH_HRESULT(E_UNEXPECTED);
    wcsncpy(szDest, (LPCWSTR) dataOut.pbData, dwRegSize);
    szDest[dwRegSize] = NULL;

 Cleanup:
    if (hr != S_OK)
        wcsncpy(szDest, L"Unable to get credential from registry", dwSize-1);        
    szDest[dwSize-1] = NULL;
    if (hReg != NULL)
        RegCloseKey(hReg);
    if (dataOut.pbData != NULL)
        LocalFree(dataOut.pbData);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\ssdirect.cxx ===
/**
 * ssdirect.cxx
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

#include "precomp.h"
#include "dbg.h"
#include "util.h"
#include "nisapi.h"
#include "xspstate.h"

#define TAG_STATE_CLIENT L"StateClient"

#define TICKS_MAX 3155378975999999999

struct SessionNDMakeRequestResults {
    SOCKET   socket;
    int      httpStatus;
    int      timeout;
    int      contentLength;
    void *   content;    
    int      lockCookie;
    _int64   lockDate;
    int      lockAge;
};

CReadWriteSpinLock g_lockInitWinsock("WinsockInit");

extern "C"
int __stdcall
SessionNDConnectToService(WCHAR * server) {
    static bool  s_winsockInit;
    static bool  s_serviceInit;

    HRESULT     hr = S_OK;  
    int         err;        
    int         result;
    WSADATA     wsaData;    
    SC_HANDLE   hSCM = NULL;
    SC_HANDLE   hService = NULL;

    /*
     * Initialize winsock.
     */
    if (!s_winsockInit) {
        g_lockInitWinsock.AcquireWriterLock();
        __try {
            if (!s_winsockInit) {
                err = WSAStartup(0x0202, &wsaData);
                ON_WIN32_ERROR_EXIT(err);

                s_winsockInit = true;
            }
        }
        __finally {
            g_lockInitWinsock.ReleaseWriterLock();
        }
    }

    server;
    result;
#if 0
    if (!s_serviceInit) {
        s_serviceInit = true;

        /*
         * Try to start the service. Don't worry if you can't,
         * though, since we may be unable to access it. Just because
         * we can't access it doesn't mean it is not running.
         */

        if (_wcsicmp(server, L"localhost") == 0) {
            server = NULL;
        }

        hSCM = OpenSCManager(server, NULL, SC_MANAGER_CONNECT);
        ON_ZERO_CONTINUE_WITH_LAST_ERROR(hSCM);

        if (hSCM) {
            hService = OpenService(hSCM, STATE_SERVICE_NAME_L, SERVICE_START);
            ON_ZERO_CONTINUE_WITH_LAST_ERROR(hSCM);

            if (hService) {
                result = StartService(hService, 0, NULL);
                if (result == FALSE) {
                    hr = GetLastWin32Error();
                    if (hr == HRESULT_FROM_WIN32(ERROR_SERVICE_ALREADY_RUNNING)) {
                        hr = S_OK;
                    }

                    ON_ERROR_CONTINUE();
                }
            }
        }

        hr = S_OK;
    }
#endif

Cleanup:
    if (hService) {
        CloseServiceHandle(hService);
    }

    if (hSCM) {
        CloseServiceHandle(hSCM);
    }

    return hr;
}


HRESULT
EnsureConnected(SOCKET * ps, char * server, int port, int timeout) {
    HRESULT             hr = S_OK;  
    int                 result;     
    struct hostent      *ph;        
    unsigned int        iaddr;
    struct sockaddr_in  saddr;
    BOOL                nodelay;

    if (*ps == INVALID_SOCKET) {
        /*
         * No cleanup needed.
         */
    }
    else if (!IsSocketConnected(*ps)) {
        result = closesocket(*ps);
        ON_SOCKET_ERROR_CONTINUE(result);

        *ps = INVALID_SOCKET;
    }
    else {
        return S_OK;
    }

    /*
     * Get the address into the sockaddr_in structure
     */
    ZeroMemory(&saddr, sizeof(saddr));
    saddr.sin_family = AF_INET;
    saddr.sin_port = htons((USHORT) port);

    /* Convert nnn.nnn address to a usable one */
    iaddr = inet_addr(server);
    if (iaddr != INADDR_NONE) {
        ASSERT(sizeof(saddr.sin_addr) == sizeof(iaddr));
        CopyMemory(&(saddr.sin_addr), (char *)&iaddr, sizeof(iaddr));
    }
    else {
        ph = gethostbyname(server);
        ON_ZERO_EXIT_WITH_LAST_SOCKET_ERROR(ph);

        ASSERT(ph->h_length == 4);
        CopyMemory(&(saddr.sin_addr), ph->h_addr, ph->h_length);
    }

    /*
     * Create a socket.
     */
    *ps = socket(AF_INET, SOCK_STREAM, 0);
    if (*ps == INVALID_SOCKET) 
        EXIT_WITH_LAST_SOCKET_ERROR();

    nodelay = TRUE;
    result = setsockopt(*ps, IPPROTO_TCP, TCP_NODELAY, (char *) &nodelay, sizeof(nodelay));
    ON_SOCKET_ERROR_EXIT(result);

    timeout *= 1000; // in milliseconds
    
    result = setsockopt(*ps, SOL_SOCKET, SO_SNDTIMEO, (char *) &timeout, sizeof(timeout));
    ON_SOCKET_ERROR_EXIT(result);

    result = setsockopt(*ps, SOL_SOCKET, SO_RCVTIMEO, (char *) &timeout, sizeof(timeout));
    ON_SOCKET_ERROR_EXIT(result);

    /*
     * Connect.
     */
    result = connect(*ps, (struct sockaddr*)&saddr, sizeof(saddr));
    ON_SOCKET_ERROR_EXIT(result);

Cleanup:
    if (hr) {
        if (*ps != INVALID_SOCKET) {
            result = closesocket(*ps);
            ON_SOCKET_ERROR_CONTINUE(result);

            *ps = INVALID_SOCKET;
        }
    }

    return hr;
}


HRESULT
WriteRequest(
        SOCKET  s,
        char    *server, 
        int     verb, 
        char    *uri, 
        int     exclusive,        
        int     timeout,          
        int     lockCookie,
        BYTE    *body,
        int     cb) {
    #define WRITE_HEADERS_SIZE 2048

    static char * s_verbs[] = {"", "GET ", "PUT ", "DELETE ", "HEAD "};
    static int    s_verblengths[] = {0, 4, 4, 7, 5};

    static char   s_version[] = " HTTP/1.1\r\n";
    static char   s_hostserver[] = "Host: ";

    static char * s_exclusives[] = {"", "Exclusive: acquire\r\n", "Exclusive: release\r\n"};
    static int    s_exclusivelengths[] = {0, 20, 20};

    static char   s_timeout[] = "Timeout:";
    static char   s_lockCookie[] = "LockCookie:";
    static char   s_contentlength[] = "Content-Length:";
    static char   s_newline[] = "\r\n";

    HRESULT hr = S_OK;
    int     result;
    char    writebuf[WRITE_HEADERS_SIZE];
    char    temp[20];
    int     templen;
    char *  pwrite;
    WSABUF  wsabuf[2];
    int     cBuffers;
    DWORD   cbSent;

    pwrite = writebuf;

    #define COPY_STRING_LEN(s, len) \
        if (PtrToUlong(pwrite - writebuf) + len > ARRAY_SIZE(writebuf)) EXIT_WITH_WIN32_ERROR(ERROR_INTERNAL_ERROR); \
        CopyMemory(pwrite, s, len); \
        pwrite += len;

    #define COPY_STRING(s)                      \
        templen = lstrlenA(s);                  \
        COPY_STRING_LEN(s, templen);

    #define COPY_NUMBER(n)                      \
        _itoa(n, temp, 10);                     \
        COPY_STRING(temp);                      \

    /*
     * Write request to client.
     * First, write the request line.
     */
    COPY_STRING_LEN(s_verbs[verb], s_verblengths[verb]);
    COPY_STRING(uri);
    COPY_STRING_LEN(s_version, sizeof(s_version) - 1);

    /*
     * Write mandatory headers.
     */
    COPY_STRING_LEN(s_hostserver, sizeof(s_hostserver) - 1);
    COPY_STRING(server);
    COPY_STRING_LEN(s_newline, sizeof(s_newline) - 1);

    /*
     * Write optional headers.
     */
    if (verb == STATE_VERB_GET) {
        /* Exclusive */
        COPY_STRING_LEN(s_exclusives[exclusive], s_exclusivelengths[exclusive]);
    }
    else if (verb == STATE_VERB_PUT) {
        ASSERT(cb > 0);

        /* Timeout */
        COPY_STRING_LEN(s_timeout, sizeof(s_timeout) - 1);
        COPY_NUMBER(timeout);
        COPY_STRING_LEN(s_newline, sizeof(s_newline) - 1);

        /* Content-Length */
        COPY_STRING_LEN(s_contentlength, sizeof(s_contentlength) - 1);
        COPY_NUMBER(cb);
        COPY_STRING_LEN(s_newline, sizeof(s_newline) - 1);
    }

    switch (verb) {
        case STATE_VERB_HEAD:
            break;

        case STATE_VERB_GET:
            if (exclusive != STATE_EXCLUSIVE_RELEASE)
                break;

            // fall-through
        default: 
            /* LockCookie */
            COPY_STRING_LEN(s_lockCookie, sizeof(s_lockCookie) - 1);
            COPY_NUMBER(lockCookie);
            COPY_STRING_LEN(s_newline, sizeof(s_newline) - 1);
            break;
    }

    COPY_STRING_LEN(s_newline, sizeof(s_newline) - 1);

    // This terminating null is not sent over, but is useful for debugging
    ASSERT(PtrToUlong(pwrite - writebuf) <= ARRAY_SIZE(writebuf));
    *pwrite = '\0';

    TRACE1(TAG_STATE_CLIENT, L"Writing header %d bytes", pwrite - writebuf);

    cBuffers = 1;
    wsabuf[0].len = PtrToUlong(pwrite - writebuf);
    wsabuf[0].buf = writebuf;

    if (verb == STATE_VERB_PUT) {
        TRACE1(TAG_STATE_CLIENT, L"Writing body %d bytes", cb);

        cBuffers = 2;
        wsabuf[1].len = cb;
        wsabuf[1].buf = (char *) body;
    }

    result = WSASend(s, wsabuf, cBuffers, &cbSent, 0, NULL, NULL);
    ON_SOCKET_ERROR_EXIT(result);

    ASSERT(cbSent == wsabuf[0].len + ((cBuffers == 2) ? wsabuf[1].len : 0));

Cleanup:
    TRACE1(TAG_STATE_CLIENT, L"Returning from WriteRequest, hr=0x%.8x", hr);
    return hr;
}

HRESULT
ReadResponse(SOCKET s, SessionNDMakeRequestResults *presults) {
    #define READ_HEADERS_SIZE 2048

    HRESULT hr = S_OK;
    int     result;
    char    readbuf[READ_HEADERS_SIZE+1];
    int     bufsize, cbRead, cbBodyRead;
    char    *pread, *pendHeaders;
    int     httpStatus;
    int     n, contentLength = -1;
    BYTE    *body = NULL;
    bool    doneWithHeaders;
    bool    foundHeader;
    char    *pchl;
    _int64  n64;

    /*
     * Read in the headers.
     */
    bufsize = READ_HEADERS_SIZE * sizeof(char);
    cbRead = 0;
    pread = readbuf;
    for (;;) {
        TRACE1(TAG_STATE_CLIENT, L"Reading %d bytes for header", bufsize);
        result = recv(s, readbuf + cbRead, bufsize, 0);
        ON_SOCKET_ERROR_EXIT(result);

        if (result <= 0) {
            ASSERT(result == 0);

            /*
             * Connection was closed, but we still need data, so fail.
             */
            EXIT_WITH_HRESULT(E_FAIL);
        }

        cbRead += result;
        bufsize -= result;
        readbuf[cbRead] = '\0';
        pendHeaders = strstr(pread, "\r\n\r\n");
        if (pendHeaders != NULL)
            break;

        if (bufsize == 0) {
            /*
             * Header too big, fail.
             */
            EXIT_WITH_HRESULT(E_FAIL);
        }

        pread = max(pread, readbuf + cbRead - 3);
    }

    TRACE1(TAG_STATE_CLIENT, L"Parsing buffer of %d bytes", cbRead);

    /*
     * Parse response line
     */

    // check for HTTP/1.0 or HTTP/1.1 at the beginning of the line
    // this was inadvertently ommitted in RTM and Everett, but it
    // will be added in Whidbey
    pread = readbuf;
    if (!STREQUALS(&pread, "HTTP/1.1 ")) {
        STREQUALS(&pread, "HTTP/1.0 ");
    }

    httpStatus = strtol(pread, &pchl, 10);
    if (httpStatus < 0 || httpStatus == LONG_MAX || pchl == pread)
        EXIT_WITH_HRESULT(E_INVALIDARG);

    presults->httpStatus = httpStatus;
    if (httpStatus != 200 && httpStatus != 423)
        EXIT();

    /* skip the error description */
    pread = strstr(pread, "\r\n");
    ASSERT(pread != NULL);
    ON_ZERO_EXIT_WITH_HRESULT(pread, E_UNEXPECTED);
    pread += 2;

    /*
     * Parse headers.
     */
    doneWithHeaders = false;
    do {
        foundHeader = false;
        switch (*pread) {
            case '\r':
                if (STREQUALS(&pread, "\r\n")) {
                    /*
                     * End of headers.
                     */
                    foundHeader = true;
                    doneWithHeaders = true;
                }
                break;
    
            case 'C':
                if (STREQUALS(&pread, "Content-Length:")) {
                    foundHeader = true;
                    contentLength = strtol(pread, &pchl, 10);
                    if (contentLength < 0 || contentLength == LONG_MAX || pchl == pread)
                        EXIT_WITH_HRESULT(E_INVALIDARG);
        
                    pread = pchl;
                    if (!STREQUALS(&pread, "\r\n"))
                        EXIT_WITH_HRESULT(E_INVALIDARG);
    
                    presults->contentLength = contentLength;
                }
                break;
    
            case 'T':
                if (STREQUALS(&pread, "Timeout:")) {
                    foundHeader = true;
                    n = strtol(pread, &pchl, 10);
                    if (n < 0 || n == LONG_MAX || pchl == pread)
                        EXIT_WITH_HRESULT(E_INVALIDARG);
        
                    pread = pchl;
                    if (!STREQUALS(&pread, "\r\n"))
                        EXIT_WITH_HRESULT(E_INVALIDARG);
    
                    presults->timeout = n;
                }
                break;

            case 'L': {
                /* buffer is guaranteed to contain 4 more bytes ("\r\n\r\n") */
                switch (pread[4]) {
                    case 'C':
                        if (STREQUALS(&pread, "LockCookie:")) {
                            foundHeader = true;
                            n = strtol(pread, &pchl, 10);
                            if (n < 0 || n == LONG_MAX || pchl == pread)
                                EXIT_WITH_HRESULT(E_INVALIDARG);
    
                            pread = pchl;
                            if (!STREQUALS(&pread, "\r\n"))
                                EXIT_WITH_HRESULT(E_INVALIDARG);
    
                            presults->lockCookie = n;
                        }
                        break;

                    case 'D':
                        if (STREQUALS(&pread, "LockDate:")) {
                            foundHeader = true;
                            n64 = _atoi64(pread);
                            if (n64 == 0)
                                EXIT_WITH_HRESULT(E_INVALIDARG);

                            ASSERT(0 <= n64 && n64 <= TICKS_MAX);

                            while (isdigit(*pread) || *pread == ' ' || *pread == '\t') {
                                pread++;
                            }

                            if (!STREQUALS(&pread, "\r\n"))
                                EXIT_WITH_HRESULT(E_INVALIDARG);
    
                            presults->lockDate = n64;
                        }
                        break;

                    case 'A':
                        if (STREQUALS(&pread, "LockAge:")) {
                            foundHeader = true;
                            n = strtol(pread, &pchl, 10);
                            if (n < 0 || n == LONG_MAX || pchl == pread)
                                EXIT_WITH_HRESULT(E_INVALIDARG);

                            pread = pchl;
                            if (!STREQUALS(&pread, "\r\n"))
                                EXIT_WITH_HRESULT(E_INVALIDARG);

                            presults->lockAge = n;
                        }
                        break;
                }
                break;
            }
        }

        if (!foundHeader) {
            pread = strstr(pread, "\r\n");
            ASSERT(pread != NULL);
            ON_ZERO_EXIT_WITH_HRESULT(pread, E_UNEXPECTED);
            pread += 2;
        }
    }  while (!doneWithHeaders);

    if (contentLength <= 0)
        EXIT();

    /*
     * Copy any body bytes in the header buffer.
     */
    cbBodyRead = cbRead - (int)(pread - readbuf);
    if (contentLength < cbBodyRead) {
        /* We've read more bytes than the content-length. Something is wrong */
        ASSERT(!(contentLength < cbBodyRead));
        EXIT_WITH_HRESULT(E_FAIL);
    }

    body = new (NewClear) BYTE[contentLength];
    ON_OOM_EXIT(body);
    
    bufsize = contentLength;
    CopyMemory(body, pread, cbBodyRead);
    bufsize -= cbBodyRead;

    /*
     * Read the remaining bytes.
     */
    while (bufsize > 0) {
        TRACE1(TAG_STATE_CLIENT, L"Reading %d bytes for body", bufsize);
        result = recv(s, (char *)(body + contentLength - bufsize), bufsize, 0);
        ON_SOCKET_ERROR_EXIT(result);

        if (result <= 0) {
            ASSERT(result == 0);

            /*
             * Connection was closed, but we still need headers, so fail.
             */
            EXIT_WITH_HRESULT(E_FAIL);
        }

        bufsize -= result;
    }

    if (httpStatus == 200) {
        presults->content = (void*) body;
        body = NULL;
    }

Cleanup:
    TRACE2(TAG_STATE_CLIENT, L"Returning from ReadResponse, hr=0x%.8x, httpstatus=%d", hr, presults->httpStatus);
    delete [] body;
    return hr;
}

extern "C"
int __stdcall
SessionNDMakeRequest(
    SOCKET  socket,    
    char *  server,
    int     port,
    int     networkTimeout,
    int     verb,      
    char *  uri,       
    int     exclusive,
    int     timeout,
    int     lockCookie,
    BYTE *  body,      
    int     cb,        
    SessionNDMakeRequestResults *presults)
{
    HRESULT     hr = S_OK;  
    int         result;

    ZeroMemory(presults, sizeof(*presults));
    presults->lockAge = -1;

    /*
     * Connect to the state server.
     */
    hr = EnsureConnected(&socket, server, port, networkTimeout);
    ON_ERROR_EXIT();

    presults->socket = socket;

    hr = WriteRequest(socket, server, verb, uri, exclusive, timeout, lockCookie, body, cb);
    ON_ERROR_EXIT();

    hr = ReadResponse(socket, presults);
    ON_ERROR_EXIT();

Cleanup:
    if (hr == S_OK) {
        switch (presults->httpStatus) {
            // Known status codes in the protocol
            case 200:
            case 404:
            case 423:
                break;

            // Unknown status code
            default:
                hr = E_UNEXPECTED;
                break;
        }
    }

    if (hr) {
        if (socket != INVALID_SOCKET) {
            result = closesocket(socket);
            ON_SOCKET_ERROR_CONTINUE(result);
        }

        presults->socket = INVALID_SOCKET;
    }

    return hr;
}

extern "C"
void __stdcall
SessionNDGetBody(BYTE * id, BYTE * body, int cb) {
    CopyMemory(body, id, cb);
    delete [] id;
}

extern "C"
void __stdcall
SessionNDCloseConnection(int socket) {
    HRESULT hr;
    int result = closesocket(socket);
    ON_SOCKET_ERROR_CONTINUE(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\ent\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\threadpool.cxx ===
/**
 * Thread pool related stuff
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

#include "precomp.h"
#include "dbg.h"
#include "util.h"
#include "nisapi.h"
#include "completion.h"
#include "names.h"

#include <mscoree.h>

//
//  Globals
//

BOOL g_fUsingCorThreadPool = TRUE;
ICorThreadpool *g_pCorThreadpool = NULL;
HRESULT g_hrThreadPoolInitFailed = S_OK;

DWORD g_MaxClrWorkerThreads = 0;
DWORD g_MaxClrIoThreads = 0;

namespace THREADPOOL
{
    HANDLE g_CompletionPort;        // The completion port

    //
    // Configuration parameters
    //

    long g_DefaultMaxThreadsPerCPU = 25;    // Default absolute max number of threads/cpu
    long g_MinThreadsPerCPU = 2;            // Never restrict adjusted max below this     
    long g_MaxFreeThreadsPerCPU = 2;        // Start deleting free threads above this
    long g_ThreadExitDelay = 1500;          // Dont exit threads more often than this
    long g_ThreadEnterExitDelay = 20000;    // Dont exit threads more sooner than this after enter

    long g_CpuUtilizationVeryLow = 20;      // Shrink thread pool when below this
    long g_CpuUtilizationLow = 50;          // Create more threads when below this
    long g_CpuUtilizationHigh = 80;         // Remove threads when about this
    long g_ThreadGateDelay = 3000;          // Measuring period

    long g_ThreadWaitMsec = 60000;          // Wait in GetQueuedCompletionStatus

    long g_NumProcessors = 1;               // # of CPUs (calculated on init)

    //
    // Thread gating settings
    //

    long g_NumThreadsLimit;         // Current limit of number of threads
    long g_CpuUtilization;          // Current CPU utilization
    long g_NumThreadsLimitMin;      // Min value for the limit
    long g_NumThreadsLimitMax;      // Max value for the limit

    //
    // Thread deletion settings
    //

    long g_MaxFreeThreads;          // Delete when above that
    __int64 g_LastThreadExitTime;   // Last time thread exited
    CReadWriteSpinLock g_LastThreadExitTimeLock("g_LastThreadExitTimeLock");  // To allow atomic updates

    //
    // Runtime counters
    //

    long g_NumThreads;              // Current number of threads
    long g_NumFreeThreads;          // Current number of free threads
    long g_NumCurrentCalls;         // Current number of outstanding workitems
};

using namespace THREADPOOL;

//  Prototypes for local functions
DWORD WINAPI    ThreadPoolThreadProc(void *pArg);
DWORD WINAPI    ThreadGateThreadProc(void *pArg);
HRESULT         LaunchOneThread(LPTHREAD_START_ROUTINE threadProc);
__int64         GetLastThreadExitTime();
void            UpdateLastThreadExitTime(__int64 msec);
void            GrowThreadPoolIfNeeded();

void  __stdcall CorThreadPoolCompletionCallback(DWORD, DWORD, LPOVERLAPPED);
DWORD __stdcall CorThreadPoolWorkitemCallback(LPVOID);

BOOL            RunningOnInetinfo     ();
extern BOOL     ProcessModelIsEnabled ();
//
//  Helper function to get current time as msecs
//

inline __int64 GetMsecCount()
{
    __int64 now;
    GetSystemTimeAsFileTime((FILETIME *) &now);
    return (now / TICKS_PER_MSEC);
}

/**
 * Starts the thread pool operation.
 */
HRESULT
InitThreadPool()
{
    HRESULT     hr = S_OK;
    IUnknown *pHost = NULL;
    BOOL needCoUninit = FALSE;

    // Get the thread limit from the registry

    HKEY        hKey = NULL;
    int         maxThreads = -1;
    BOOL        fRunningOnInetinfo = RunningOnInetinfo();
    BOOL        fProcessModelIsEnabled = (fRunningOnInetinfo && ProcessModelIsEnabled());

    g_fUsingCorThreadPool = !fProcessModelIsEnabled;

    RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_MACHINE_APP_L, 0, KEY_READ, &hKey); 
    if (hKey != NULL) 
    {
        DWORD dwValue = 0, dwType = 0, cbData;

        cbData = sizeof(dwValue);

        if ( RegQueryValueEx(hKey, PRODUCT_NAME_L L"Threads", NULL, &dwType, 
                             (LPBYTE) &dwValue, &cbData) == ERROR_SUCCESS && 
             dwType == REG_DWORD)
        {
            if (dwValue > 0)
            {
                // some other value is set -- use it
                maxThreads = dwValue;    
            }
        }
        if (!fProcessModelIsEnabled)
        {
            cbData = sizeof(dwValue);

            if ( RegQueryValueEx(hKey, L"UseCorThreadpool", NULL, &dwType, 
                                 (LPBYTE) &dwValue, &cbData) == ERROR_SUCCESS && 
                 dwType == REG_DWORD)
            {
                g_fUsingCorThreadPool = (dwValue != 0);
            }
        }

        RegCloseKey(hKey);
    }

    if (g_fUsingCorThreadPool)
    {
        hr = EnsureCoInitialized(&needCoUninit);
        ON_ERROR_EXIT();

        // Select EE Flavor (server vs. workstation build)
        hr = SelectRuntimeFlavor(&pHost);
        ON_ERROR_EXIT();

        if (pHost == NULL) 
        {
            // Create runtime host and QI it for ICorThreadpool
            hr = CoCreateInstance(
                    CLSID_CorRuntimeHost, 
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_ICorThreadpool, 
                    (void **)&g_pCorThreadpool);
            ON_ERROR_CONTINUE();
        }
        else 
        {
            // If we got a pHost back from the SelectRuntimeFlavor call, use it to get the thread pool
            hr = pHost->QueryInterface(IID_ICorThreadpool, (void **)&g_pCorThreadpool);
            ON_ERROR_CONTINUE();
        }

        if (hr != S_OK || g_pCorThreadpool == NULL)
        {
            g_hrThreadPoolInitFailed = ((hr==S_OK) ? E_FAIL : hr);
            g_fUsingCorThreadPool = FALSE;
            g_pCorThreadpool = NULL;
        }

        // configure limits
        if (g_pCorThreadpool != NULL && g_MaxClrWorkerThreads > 0 && g_MaxClrIoThreads > 0) {
            // multiply by # of CPUs
            int cpuCount = GetCurrentProcessCpuCount();
            hr = g_pCorThreadpool->CorSetMaxThreads(g_MaxClrWorkerThreads*cpuCount, g_MaxClrIoThreads*cpuCount);
            ON_ERROR_CONTINUE();
        }

        // don't couninit -- it could unload cor
        EXIT();
    }

    // Get number of CPUs

    SYSTEM_INFO si;
    GetSystemInfo(&si);
    g_NumProcessors = si.dwNumberOfProcessors > 0 ? si.dwNumberOfProcessors : 1;

    // Configure thread deletion settings

    g_MaxFreeThreads = g_MaxFreeThreadsPerCPU * g_NumProcessors;
    g_LastThreadExitTime = GetMsecCount();
    //g_LastThreadExitTimeLock = 0;

    // Configure thread gating

    g_NumThreadsLimitMax = maxThreads > 0 ? maxThreads : g_DefaultMaxThreadsPerCPU * g_NumProcessors;
    g_NumThreadsLimitMin = g_MinThreadsPerCPU * g_NumProcessors;

    if (g_NumThreadsLimitMin > g_NumThreadsLimitMax)
        g_NumThreadsLimitMin = g_NumThreadsLimitMax;

    g_NumThreadsLimit = g_NumThreadsLimitMin;
    g_CpuUtilization = 0;

    // Init settings

    g_NumThreads = 0;
    g_NumFreeThreads = 0;
    g_NumCurrentCalls = 0;

    // Launch thread gating thread

    hr = LaunchOneThread(ThreadGateThreadProc);
    ON_ERROR_EXIT();

    // Create the completion port

    g_CompletionPort = CreateIoCompletionPort(
                            INVALID_HANDLE_VALUE, 
                            NULL, 
                            0, 
                            0);

    if (g_CompletionPort == NULL) 
        EXIT_WITH_LAST_ERROR();

    // Launch the 1st thread

    InterlockedIncrement(&g_NumThreads);
    hr = LaunchOneThread(ThreadPoolThreadProc);
    if (hr != S_OK)
        InterlockedDecrement(&g_NumThreads);
    ON_ERROR_EXIT();
    
Cleanup:
    ReleaseInterface(pHost);

    if (needCoUninit)
        CoUninitialize();

    return hr;
}

/**
 * Drain -- wait till all threads are waiting in GetQueuedCompletionStatus
 */
HRESULT  __stdcall
DrainThreadPool(int timeout)
{
    HRESULT hr = S_OK;
    __int64 startTime = 0, endTime = 0;

    if (g_fUsingCorThreadPool)
        EXIT();

    if (timeout > 0)
    {
        startTime = GetMsecCount();
        endTime = startTime + timeout;
    }

    // Drain calls from the system
    while (g_NumCurrentCalls > 0 || g_NumThreads != g_NumFreeThreads)
    {
        Sleep(100);

        if (timeout > 0)
        {
            if (GetMsecCount() >= endTime)
                EXIT_WITH_HRESULT(HRESULT_FROM_WIN32(ERROR_TIMEOUT));
        }
    }

Cleanup:
    return hr;
}


/**
 * Associate HANDLE with the completion port.
 */
extern "C"
HRESULT  __stdcall
AttachHandleToThreadPool(HANDLE handle)
{
    HRESULT hr = S_OK;

    if (g_fUsingCorThreadPool)
    {
        hr = g_pCorThreadpool->CorBindIoCompletionCallback(
                                    handle, 
                                    CorThreadPoolCompletionCallback);
        ON_ERROR_EXIT();
    }
    else
    {
        HANDLE h = CreateIoCompletionPort(
                        handle,
                        g_CompletionPort,
                        0,  // key is 0
                        0);

        if (h == NULL)
            EXIT_WITH_LAST_ERROR();
    }

Cleanup:
    return hr;
}

/**
 * Post manual completion to the thread pool.
 */
extern "C"
HRESULT  __stdcall
PostThreadPoolCompletion(ICompletion *pCompletion)
{
    BOOL ret;
    HRESULT hr = S_OK;

    if (g_fUsingCorThreadPool)
    {
        BOOL fRet = 0;

        hr = g_pCorThreadpool->CorQueueUserWorkItem(
                                    CorThreadPoolWorkitemCallback, 
                                    pCompletion, 
                                    TRUE,
                                    &fRet);
        ON_ERROR_EXIT();
        ON_ZERO_EXIT_WITH_LAST_ERROR(fRet);
    }
    else
    {
        InterlockedIncrement(&g_NumCurrentCalls);

        // Post the completion

        ret = PostQueuedCompletionStatus(
                    g_CompletionPort,
                    0,
                    (ULONG_PTR)pCompletion,
                    NULL);

        if (!ret)
        {
            InterlockedDecrement(&g_NumCurrentCalls);
            EXIT_WITH_LAST_ERROR();
        }

        //  Launch additional thread if needed (possibly grow the thread pool)

        GrowThreadPoolIfNeeded();
    }

Cleanup:
    return hr;
}

/**
 * Get limit for CLR thread pool
 */

DWORD
GetClrThreadPoolLimit() 
{
    DWORD maxWorker = 0, maxIo = 0;

    if (g_pCorThreadpool != NULL)
        g_pCorThreadpool->CorGetMaxThreads(&maxWorker, &maxIo);

    return maxWorker + maxIo;
}

/**
 * Remember limits for CLR thread pool
 */
extern "C"
HRESULT  __stdcall
SetClrThreadPoolLimits(DWORD maxWorkerThreads, DWORD maxIoThreads, BOOL setNowAndDontAdjustForCpuCount)
{
    HRESULT hr = S_OK;

    if (setNowAndDontAdjustForCpuCount)
    {
        if (g_pCorThreadpool != NULL) 
        {
            hr = g_pCorThreadpool->CorSetMaxThreads(maxWorkerThreads, maxIoThreads);
            ON_ERROR_EXIT();
        }
    }
    else
    {
        g_MaxClrWorkerThreads = maxWorkerThreads;
        g_MaxClrIoThreads = maxIoThreads;
    }

Cleanup:
    return hr;
}

/**
 * Launch additional thread.
 */
HRESULT
LaunchOneThread(LPTHREAD_START_ROUTINE threadProc)
{
    HRESULT hr = S_OK;
    HANDLE threadHandle;
    DWORD threadId;

    threadHandle = CreateThread(
                        NULL, 
                        0, 
                        threadProc, 
                        NULL, 
                        0, 
                        &threadId
                        );

    if (threadHandle == NULL)
        EXIT_WITH_LAST_ERROR();

    CloseHandle(threadHandle);

    // don't remove threads soon after creation
    UpdateLastThreadExitTime(GetMsecCount() + g_ThreadEnterExitDelay);

Cleanup:
    return hr;
}

/**
 * Get last time a thread exited -- not to exit others too soon
 */
__int64 
GetLastThreadExitTime()
{
    __int64 r = 0;

    if (g_LastThreadExitTimeLock.TryAcquireWriterLock()) // SpinLockTryAcquireWrite(&g_LastThreadExitTimeLock))
    {
        r = g_LastThreadExitTime;
        g_LastThreadExitTimeLock.ReleaseWriterLock();
    }

    return r;
}

/**
 * Update last time a thread exited -- not to exit others too soon
 */
void 
UpdateLastThreadExitTime(__int64 msec)
{
    if (g_LastThreadExitTimeLock.TryAcquireWriterLock()) // SpinLockTryAcquireWrite(&g_LastThreadExitTimeLock))
    {
        g_LastThreadExitTime = msec;
        g_LastThreadExitTimeLock.ReleaseWriterLock();
    }
}

/**
 * Determine if the current thread can exit safely (no I/O pending).
 */
BOOL IsCurrentThreadExitable()
{
    // Don't exit too often

    BOOL tooSoon = TRUE;

    {
        __int64 now = GetMsecCount();

        if (now > GetLastThreadExitTime() + g_ThreadExitDelay)
        {
            tooSoon = FALSE;
            UpdateLastThreadExitTime(now);
        }
    }

    if (tooSoon)
        return FALSE;

    // Check for pending IO

    BOOL hasPendingIO = TRUE;

    {
        NTSTATUS Status;
        ULONG IsIoPending;

        Status = g_pfnNtQueryInformationThread(GetCurrentThread(),
                                          ThreadIsIoPending,
                                          &IsIoPending,
                                          sizeof(IsIoPending),
                                          NULL);

        if (NT_SUCCESS(Status) && !IsIoPending)
            hasPendingIO = FALSE;
    }

    if (hasPendingIO)
        return FALSE;

    // Can exit this thread

    return TRUE;
}

/**
 * Thread proc for the thread that waits on the completion port.
 */
DWORD WINAPI
ThreadPoolThreadProc(void *)
{
    BOOL    ret;
    HRESULT hr;
    DWORD numBytes;
    ULONG_PTR key;
    LPOVERLAPPED pOverlapped;
    ICompletion *pCompletion;

    TRACE1(L"TP", L"Entering thread. %d threads active", g_NumThreads);

    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    for (;;)
    {
        // Check the exit condition

        if (g_NumFreeThreads > g_MaxFreeThreads || g_NumThreads > g_NumThreadsLimit)
        {
            if (IsCurrentThreadExitable())
                break;
        }

        // Wait for next completion

        InterlockedIncrement(&g_NumFreeThreads);

        hr = S_OK;
        ret = GetQueuedCompletionStatus(
                    g_CompletionPort,
                    &numBytes,
                    &key,
                    &pOverlapped,
                    g_ThreadWaitMsec
                    );

        InterlockedDecrement(&g_NumFreeThreads);

        // Check if the thread needs to exit
        if (ret == 0 && GetLastError() == WAIT_TIMEOUT)
            continue;

        ON_ZERO_CONTINUE_WITH_LAST_ERROR(ret);
        if (hr == HRESULT_FROM_WIN32(WAIT_TIMEOUT))
            continue;

        // Special completion with 'Quit' instruction
        if (key == 0 && pOverlapped == NULL)
            break;

        // Launch another thread to make sure there's someone listening
        GrowThreadPoolIfNeeded();

        // Find the completion object
        if (key != 0)
        {
           // Completion is the key if not null
            pCompletion = (ICompletion *)key;
        }
        else
        {
            // For 0 keys OVERLAPPED_COMPLETION is used instead of OVERLAPPED
            pCompletion = ((OVERLAPPED_COMPLETION *)pOverlapped)->pCompletion;
        }

        // Call the completion
        __try {
            hr = pCompletion->ProcessCompletion(hr, numBytes, pOverlapped);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            hr = HRESULT_FROM_WIN32(_exception_code());
        }

        ON_ERROR_CONTINUE();

        InterlockedDecrement(&g_NumCurrentCalls);
    }

    CoUninitialize();

    InterlockedDecrement(&g_NumThreads);  // incremented in GrowThreadPool function

    TRACE1(L"TP", L"Exiting thread. %d threads active", g_NumThreads);

    return 0;
}

/**
 * Thread proc for the thread gating that measures CPU utilization and
 * adjust maximum number of threads
 */
DWORD WINAPI
ThreadGateThreadProc(void *)
{
    HRESULT hr = S_OK;

    // SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION prefix redefined with __int64
    struct CPU_PERF_INFO { __int64 IdleTime; __int64 KernelTime; __int64 UserTime; };
    CPU_PERF_INFO *pOldInfo = NULL, *pNewInfo = NULL;
    int infoSize;
    __int64 reading;
    long oldLimit, newLimit;

    // Alloc structures

    infoSize = g_NumProcessors * sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION);

    pOldInfo = (CPU_PERF_INFO *) new BYTE[infoSize];
    ON_OOM_EXIT(pOldInfo);

    pNewInfo = (CPU_PERF_INFO *)new BYTE[infoSize];
    ON_OOM_EXIT(pNewInfo);

    // Get first reading
    g_pfnNtQuerySystemInformation(SystemProcessorPerformanceInformation, pOldInfo, infoSize, NULL);

    for (;;)
    {
        // Trace
        TRACE4(L"TP", L"Reading: %ld; Threads: %ld of %ld (%ld free).", g_CpuUtilization, g_NumThreads, g_NumThreadsLimit, g_NumFreeThreads);

        // Sleep
        Sleep(g_ThreadGateDelay);

        // Get next reading
        g_pfnNtQuerySystemInformation(SystemProcessorPerformanceInformation, pNewInfo, infoSize, NULL);

        // Calculate CPU utilization
        {
            __int64 cpuIdleTime = 0, cpuUserTime = 0, cpuKernelTime = 0;
            __int64 cpuBusyTime, cpuTotalTime;

            for (int i = 0; i < g_NumProcessors; i++) 
            {
                cpuIdleTime   += (pNewInfo[i].IdleTime   - pOldInfo[i].IdleTime);
                cpuUserTime   += (pNewInfo[i].UserTime   - pOldInfo[i].UserTime);
                cpuKernelTime += (pNewInfo[i].KernelTime - pOldInfo[i].KernelTime);
            }

            cpuTotalTime  = cpuUserTime + cpuKernelTime;
            cpuBusyTime   = cpuTotalTime - cpuIdleTime;

            __int64 cpuTotalTime100 = cpuTotalTime / 100;
            if (cpuTotalTime100 == 0)
                cpuTotalTime100 = 1;

            reading = (cpuBusyTime / cpuTotalTime100);
        }

        // Preserve reading
        memcpy(pOldInfo, pNewInfo, infoSize);

        g_CpuUtilization = (long)reading;

        // Adjust the maximum number of threads

        newLimit = oldLimit = g_NumThreadsLimit;

        if (g_CpuUtilization > g_CpuUtilizationHigh)
        {
            if (oldLimit > g_NumThreadsLimitMin)
                newLimit = oldLimit-1;
        }
        else if (g_CpuUtilization < g_CpuUtilizationLow)
        {
            if (oldLimit < g_NumThreadsLimitMax && g_NumFreeThreads == 0 && g_NumThreads >= oldLimit)
                newLimit = oldLimit+1;
            else if (g_CpuUtilization < g_CpuUtilizationVeryLow && oldLimit > g_NumThreadsLimitMin && g_NumFreeThreads > g_MaxFreeThreads)
                newLimit = oldLimit-1;
        }

        if (newLimit != oldLimit)
            InterlockedCompareExchange(&g_NumThreadsLimit, newLimit, oldLimit);
    }

Cleanup:

    DELETE_BYTES(pOldInfo);
    DELETE_BYTES(pNewInfo);
    
    return 0;
}


/**
 * Grow thread pool to ensure there is a free thread.
 * Take gating into account
 */
void
GrowThreadPoolIfNeeded()
{
    if (g_NumFreeThreads == 0)
    {
        // adjust limit if neeeded

        if (g_NumThreads >= g_NumThreadsLimit)
        {
            long limit = g_NumThreadsLimit;

            if (limit < g_NumThreadsLimitMax && g_CpuUtilization < g_CpuUtilizationLow)
                InterlockedCompareExchange(&g_NumThreadsLimit, limit+1, limit);
        }

        // launch new thread if under limit

        if (g_NumThreads < g_NumThreadsLimit && g_NumFreeThreads == 0)
        {
            InterlockedIncrement(&g_NumThreads);
            if (LaunchOneThread(ThreadPoolThreadProc) != S_OK)
                InterlockedDecrement(&g_NumThreads);
        }
    }
}

//
// Integration with the COR thread pool
//

void __stdcall
CorThreadPoolCompletionCallback(DWORD dwErrorCode,
                                DWORD dwNumBytes,
                                LPOVERLAPPED pOverlapped)
{
    ICompletion *pCompletion;
    HRESULT hr;

    MarkThreadForRuntime();

    if (pOverlapped != NULL)
    {
        pCompletion = ((OVERLAPPED_COMPLETION *)pOverlapped)->pCompletion;
        hr = (dwErrorCode != 0) ? HRESULT_FROM_WIN32(dwErrorCode) : S_OK;
        __try {
            hr = pCompletion->ProcessCompletion(hr, dwNumBytes, pOverlapped);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            hr = HRESULT_FROM_WIN32(_exception_code());
        }
    
        ON_ERROR_CONTINUE();
    }
}

DWORD __stdcall
CorThreadPoolWorkitemCallback(LPVOID pContext)
{
    HRESULT hr;
    ICompletion *pCompletion;

    MarkThreadForRuntime();

    if (pContext != NULL)
    {
        pCompletion = (ICompletion *)pContext;
        __try {
            hr = pCompletion->ProcessCompletion(S_OK, 0, NULL);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            hr = HRESULT_FROM_WIN32(_exception_code());
        }

        ON_ERROR_CONTINUE();
    }

    return 0;
}

BOOL
RunningOnInetinfo()
{
    return !_wcsicmp(Names::ExeFileName(), L"inetinfo.exe");
}

//
// Exposing the ability to post work items from managed code
//

// delegate WorkItemCallback
typedef void (__stdcall *PFN_WORKITEM_CB)();

// helper class
class WorkItemCompletion : public Completion {

private:
    PFN_WORKITEM_CB _callback;

public:
    WorkItemCompletion(PFN_WORKITEM_CB callback) {
        _callback = callback;
    }

    // ICompletion interface
    STDMETHOD(ProcessCompletion)(HRESULT, int, LPOVERLAPPED) {
        (*_callback)();     // execute work item
        Release();
        return S_OK;
    }
};

// exported function for calls from managed code
int __stdcall
PostThreadPoolWorkItem(PFN_WORKITEM_CB callback) {
    HRESULT hr = S_OK;
    WorkItemCompletion *pCompletion = NULL;

    pCompletion = new WorkItemCompletion(callback);
    ON_OOM_EXIT(pCompletion);

    pCompletion->AddRef();
    hr = PostThreadPoolCompletion(pCompletion);
    if (hr != S_OK)
        pCompletion->Release();
    ON_ERROR_EXIT();

Cleanup:
    ReleaseInterface(pCompletion);
    return (hr == S_OK) ? 1 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\exp\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\redist\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\std\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\sources.inc ===
!include $(DNAROOT)\src\xsp\place.inc

!if "$(ASPNET_PRODUCT)" == "redist"
SYNCHRONIZE_BLOCK=1
SYNCHRONIZE_DRAIN=1
!endif

TARGETNAME=$(ASPNET_NAME_PREFIX)isapi
TARGETPATH=$(O)
TARGETTYPE=DYNLINK

DLLDEF=$(O)\isapi.def
DLLENTRY=_DllMainCRTStartup

PRECOMPILED_CXX=1
PRECOMPILED_SHARED_INCLUDE=precomp.h
PRECOMPILED_SHARED_PCH=..\..\inc\$(ASPNET_PRODUCT)\$(O)\precomp.pch

DELAYLOAD=\
    advapi32.dll    ;\
    crypt32.dll     ;\
    Loadperf.dll    ;\
    mscoree.dll     ;\
    netapi32.dll    ;\
    ole32.dll       ;\
    oleaut32.dll    ;\
    setupapi.dll    ;\
    Shlwapi.dll     ;\
    version.dll     ;\
    ws2_32.dll      ;\
    wtsapi32.dll	

NTTARGETFILE0=$(O)\selfreg.inf \

!if $(ASPNET_PRODUCT_ID) == $(ASPNET_PRODUCT_REDIST)
HACKSYSTEM32FILES=
!else
HACKSYSTEM32FILES=$(URTTARGET)\$(ASPNET_PRODUCT)\mscoree.dll \
                  $(URTTARGET)\$(ASPNET_PRODUCT)\msvcr70.dll

!endif

NTTARGETFILES=$(HACKSYSTEM32FILES)

TARGETLIBS=\
        $(SDK_LIB_PATH)\advapi32.lib    \
        $(SDK_LIB_PATH)\crypt32.lib     \
        $(SDK_LIB_PATH)\kernel32.lib    \
        $(SDK_LIB_PATH)\loadperf.lib    \
        $(URTSDKTARGET)\lib\mscoree.lib \
        $(SDK_LIB_PATH)\netapi32.lib    \
        $(SDK_LIB_PATH)\ole32.lib       \
        $(SDK_LIB_PATH)\oleaut32.lib    \
        $(SDK_LIB_PATH)\setupapi.lib    \
        $(SDK_LIB_PATH)\Shlwapi.lib     \
        $(SDK_LIB_PATH)\user32.lib      \
        $(SDK_LIB_PATH)\uuid.lib        \
        $(SDK_LIB_PATH)\version.lib     \
        $(SDK_LIB_PATH)\ws2_32.lib      \
        $(SDK_LIB_PATH)\userenv.lib     \
        $(SDK_LIB_PATH)\wtsapi32.lib    \

LINKLIBS=\
        $(XSPBASEDIR)\inc\$(ASPNET_PRODUCT)\$(O)\precomp.lib          \
        $(XSPBASEDIR)\util\$(ASPNET_PRODUCT)\$(O)\util.lib            \

MISCFILES=..\aspnet.mof \
          ..\aspnet.mof.uninstall

SOURCES=                                   \
        ..\xspisapi.rc                     \
        ..\aspnet.mof                      \
        ..\ackreceiver.cxx                 \
        ..\aspcompat.cxx                   \
        ..\aspcompat_intrinsics.cxx        \
        ..\aspnetetw.cxx                   \
        ..\aspnetver.cxx                   \
        ..\aspnetverlist.cxx               \
        ..\asyncpipe.cxx                   \
        ..\attachdebugger.cxx              \
        ..\ciisinfo.cxx                    \
        ..\cpuentry.cxx                    \
        ..\curproc.cxx                     \
        ..\customerror.cxx                 \
        ..\dbgdirect.cxx                   \
        ..\debug.cxx                       \
        ..\dirmoncompletion.cxx            \
        ..\ecbdirect.cxx                   \
        ..\etw.cxx                         \
        ..\event.cxx                       \
        ..\getconfig.cxx                   \
        ..\historytable.cxx                \
        ..\healthmonitor.cxx               \
        ..\httpcompletion.cxx              \
        ..\httpextproc.cxx                 \
        ..\instrumentedmutex.cxx           \
        ..\main.cxx                        \
        ..\names.cxx                       \
        ..\passport.cxx                    \
        ..\perfcounterclient.cxx           \
        ..\perfcounterserver.cxx           \
        ..\platform_apis.cxx               \
        ..\processentry.cxx                \
        ..\processtablemanager.cxx         \
        ..\regaccount.cxx                  \
        ..\regiis.cxx                      \
        ..\regiisutil.cxx                  \
        ..\reginf.cxx                      \
        ..\register.cxx                    \
        ..\requesttablemanager.cxx         \
        ..\responsecontext.cxx             \
        ..\securityapi.cxx                 \
        ..\ssdirect.cxx                    \
        ..\threadpool.cxx                  \
        ..\timeclass.cxx                   \
        ..\transactions.cxx                \
        ..\util.cxx                        \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\timeclass.cxx ===
/**
 * Process Model: TimeClass defn file
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "TimeClass.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

TimeClass::TimeClass()
{
    m_fSet = FALSE;
    m_ulTime = 0;
}

/////////////////////////////////////////////////////////////////////////////

void
TimeClass::SnapCurrentTime()
{
    GetSystemTimeAsFileTime((FILETIME *) &m_ulTime);
    m_fSet = TRUE;
}

/////////////////////////////////////////////////////////////////////////////

DWORD
TimeClass::AgeInSeconds()
{
    if (m_fSet == FALSE)
        return 0;

    __int64    ulTime;
    GetSystemTimeAsFileTime((FILETIME *) &ulTime);

    ulTime -= m_ulTime;
    ulTime /= 10000000;

    return DWORD(ulTime & 0xffffffff);
}

/////////////////////////////////////////////////////////////////////////////

DWORD
TimeClass::DiffInSeconds (const TimeClass & t1, const TimeClass & t2)
{
    __int64 uld = t1.m_ulTime - t2.m_ulTime;
    uld /= 10000000;
    return DWORD(uld & 0xffffffff);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\perfstringsmerger\redist\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\transactions.cxx ===
/**
 * Transactions support for managed code
 * 
 * Copyright (c) 2000 Microsoft Corporation
 */

#include "precomp.h"
#include "dbg.h"
#include "util.h"
#include "nisapi.h"
#include "platform_apis.h"
#include <comsvcs.h>

// Unmanaged definition for the callback delegate
typedef int (__stdcall *PFN_TRANSACTED_CALL)();

// Defines for the return value
#define TRANSACTED_CALL_STATE_COMMIT_PENDING    0
#define TRANSACTED_CALL_STATE_ABORT_PENDING     1
#define TRANSACTED_CALL_STATE_ERROR             2

// forward decls
HRESULT TransactManagedCallbackViaServiceDomainAPIs(PFN_TRANSACTED_CALL callback, int mode, BOOL *pfAborted);
HRESULT TransactManagedCallbackViaHelperComponents(PFN_TRANSACTED_CALL callback, int mode, BOOL *pfAborted);

// Function called from managed code that wraps callback to managed code
// in a transaction
int __stdcall
TransactManagedCallback(PFN_TRANSACTED_CALL callback, int mode) {
    HRESULT hr = S_OK;
    BOOL needCoUninit = FALSE;
    BOOL fAborted = FALSE;

    // CoInitialize
    hr = EnsureCoInitialized(&needCoUninit);
    ON_ERROR_EXIT();

    if (PlatformHasServiceDomainAPIs()) {
        // On Whistler use CoEnterServiceDomain / CoExitServiceDomain
        hr = TransactManagedCallbackViaServiceDomainAPIs(callback, mode, &fAborted);
        ON_ERROR_EXIT();
    }
    else {
        // On Win2k use IIS Utilities package
        hr = TransactManagedCallbackViaHelperComponents(callback, mode, &fAborted);
        ON_ERROR_EXIT();
    }

Cleanup:
    if (needCoUninit)
        CoUninitialize();

    if (hr != S_OK)
        return -1;

    return fAborted ? 0 : 1;
}

// Helper function to set aborted flag after the call into managed code
BOOL DetermineIfAborted(int state)
{
    HRESULT hr = S_OK;
    BOOL aborted = TRUE;
    IObjectContext *pContext = NULL;

    hr = PlatformGetObjectContext((void **)&pContext);
    ON_ERROR_EXIT();

    switch (state) 
    {
        case TRANSACTED_CALL_STATE_COMMIT_PENDING:
            // do final SetComplete
            hr = pContext->SetComplete();

            if (hr == S_OK)
            {
                aborted = FALSE;
            }
            else if (hr == CONTEXT_E_ABORTED) 
            { 
                // another component aborted
                aborted = TRUE;
                hr = S_OK;
            }
            else if (hr != S_OK)
            {
                // some random error
                aborted = TRUE;
                EXIT_WITH_HRESULT(hr);
            }
            break;

        case TRANSACTED_CALL_STATE_ABORT_PENDING:
            aborted = TRUE;
            // have to call SetAbort for the nested transaction case
            // when propagating the parent status
            hr = pContext->SetAbort();
            ON_ERROR_CONTINUE();
            break;

        case TRANSACTED_CALL_STATE_ERROR:
            // force SetAbort if error
            aborted = TRUE;
            hr = pContext->SetAbort();
            ON_ERROR_CONTINUE();
            break;
    }

Cleanup:
    if (pContext != NULL)
        pContext->Release();

    return aborted;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Transaction implementation via ASP-classic registered objects
//////////////////////////////////////////////////////////////////////////////////////////////////

//  Begin definitions takend from ASP-classic ********************************

// CLSIDs for the 4 transacted objects registered by ASP classic in Win2k
struct __declspec(uuid("14D09170-9CDC-11D1-8C4A-00C04FC324A4")) _ASP_ASPObjectContextTxNotSupported;
struct __declspec(uuid("14D0916F-9CDC-11D1-8C4A-00C04FC324A4")) _ASP_ASPObjectContextTxSupported;
struct __declspec(uuid("14D0916D-9CDC-11D1-8C4A-00C04FC324A4")) _ASP_ASPObjectContextTxRequired;
struct __declspec(uuid("14D0916E-9CDC-11D1-8C4A-00C04FC324A4")) _ASP_ASPObjectContextTxRequiresNew;

// Interface (not COM) on which ASP callback from transacted objects happens

struct _ASP_CScriptEngine : IUnknown
{
//	virtual HRESULT AddScriptlet(LPCOLESTR wstrScript) = 0;
//	virtual HRESULT AddObjects(BOOL fPersistNames) = 0;
//	virtual HRESULT AddAdditionalObject(LPWSTR strObjName, BOOL fPersistNames) = 0;
	virtual HRESULT Call(LPCOLESTR strEntryPoint) = 0;
	virtual HRESULT CheckEntryPoint(LPCOLESTR strEntryPoint) = 0;
	virtual HRESULT MakeEngineRunnable() = 0;
	virtual HRESULT ResetScript() = 0;
	virtual HRESULT AddScriptingNamespace() = 0;
	virtual VOID Zombify() = 0;
	virtual HRESULT InterruptScript(BOOL fAbnormal) = 0;
	virtual BOOL FScriptTimedOut() = 0;
	virtual BOOL FScriptHadError() = 0;
	virtual HRESULT UpdateLocaleInfo() = 0;
};

// Interface implemented by the transacted objects

struct __declspec(uuid("D97A6DA2-9C1C-11D0-9C3C-00A0C922E764")) _ASP_IASPObjectContextCustom;

struct _ASP_IASPObjectContextCustom : IUnknown
{
    virtual HRESULT __stdcall SetComplete ( ) = 0;
    virtual HRESULT __stdcall SetAbort ( ) = 0;
    virtual HRESULT __stdcall Call(_ASP_CScriptEngine *pScriptEngine, LPCOLESTR strEntryPoint, BOOL *pfAborted) = 0;
    virtual HRESULT __stdcall ResetScript(_ASP_CScriptEngine *pScriptEngine) = 0;
};

//  End definitions takend from ASP-classic **********************************

//   Helper class that implements _ASP_CScriptEngine
struct HelperScriptEngine : _ASP_CScriptEngine
{
    // 'implementation' of IUnknown

    STDMETHOD(QueryInterface)(REFIID iid, void **ppvObj) {
        if (iid == IID_IUnknown || iid == IID_IDispatch) {
            TRACE(L"Transactions", L"CScriptEngine::QueryInterface(simple)");
            AddRef();
            *ppvObj = this;
            return S_OK;
        }
        else if (iid == IID_IMarshal) {
            TRACE(L"Transactions", L"CScriptEngine::QueryInterface(IMarhal)");
            if (_pFTM == NULL) {
                HRESULT hr = CoCreateFreeThreadedMarshaler(this, &_pFTM);
                if (hr != S_OK)
                    return hr;
            }
            return _pFTM->QueryInterface(iid, ppvObj);
        }
        else {
            return E_NOINTERFACE;
        }
    }

    STDMETHOD_(ULONG, AddRef)() {
        TRACE(L"Transactions", L"CScriptEngine::AddRef");
        return 13;
    }

    STDMETHOD_(ULONG, Release)() {
        TRACE(L"Transactions", L"CScriptEngine::Release");
        return 13;
    }

    // 'implementation' of _ASP_CScriptEngine

/*
    virtual HRESULT AddScriptlet(LPCOLESTR) {
        TRACE(L"Transactions", L"CScriptEngine::AddScriptlet");
        return S_OK; 
    }

	virtual HRESULT AddObjects(BOOL) {
        TRACE(L"Transactions", L"CScriptEngine::AddObjects");
        return S_OK; 
    }

	virtual HRESULT AddAdditionalObject(LPWSTR, BOOL) {
        TRACE(L"Transactions", L"CScriptEngine::AddAdditionalObject");
        return S_OK; 
    }
*/

    virtual HRESULT Call(LPCOLESTR) {
        TRACE(L"Transactions", L"CScriptEngine::Call begin");
        int state = (*_TheCallback)();
        _aborted = DetermineIfAborted(state);
        TRACE2(L"Transactions", L"CScriptEngine::Call end: state=%d aborted=%d", state, _aborted);
        return E_FAIL; // to disable auto SetComplete by the ASP code
    }

	virtual HRESULT CheckEntryPoint(LPCOLESTR) {
        TRACE(L"Transactions", L"CScriptEngine::CheckEntryPoint");
        return S_OK; 
    }

	virtual HRESULT MakeEngineRunnable() {
        TRACE(L"Transactions", L"CScriptEngine::MakeEngineRunnable");
        return S_OK; 
    }

	virtual HRESULT ResetScript() {
        TRACE(L"Transactions", L"CScriptEngine::ResetScript");
        return S_OK; 
    }

	virtual HRESULT AddScriptingNamespace() {
        TRACE(L"Transactions", L"CScriptEngine::AddScriptingNamespace");
        return S_OK; 
    }

    virtual VOID Zombify() {
        TRACE(L"Transactions", L"CScriptEngine::Zombify");
        return; 
    }

	virtual HRESULT InterruptScript(BOOL) {
        TRACE(L"Transactions", L"CScriptEngine::InterruptScript");
        return S_OK; 
    }

    virtual BOOL FScriptTimedOut() {
        TRACE(L"Transactions", L"CScriptEngine::FScriptTimedOut");
        return FALSE; 
    }

	virtual BOOL FScriptHadError() {
        TRACE(L"Transactions", L"CScriptEngine::FScriptHadError");
        return FALSE; 
    }

	virtual HRESULT UpdateLocaleInfo() {
        TRACE(L"Transactions", L"CScriptEngine::UpdateLocaleInfo");
        return S_OK; 
    }

    // the callback to call inside Call()

    PFN_TRANSACTED_CALL _TheCallback;
    BOOL                _aborted;
    IUnknown           *_pFTM;
};

// Function called from managed code that wraps callback to managed code
// in a transaction
HRESULT TransactManagedCallbackViaHelperComponents(PFN_TRANSACTED_CALL callback, int mode, BOOL *pfAborted)
{
    HRESULT hr = S_OK;
    IObjectContext *pContext = NULL;
    _ASP_IASPObjectContextCustom *pTxnContext = NULL;
    CLSID clsid;
    HelperScriptEngine helper;
    helper._pFTM = NULL;
    helper._aborted = FALSE;

    // Find class id for the transaction mode

    if (mode < 1 || mode > 4)
        EXIT_WITH_HRESULT(E_UNEXPECTED);

    if (GetCurrentPlatform() == APSX_PLATFORM_W2K) 
    {
        switch (mode)
        {
            case 1: 
                clsid = __uuidof(_ASP_ASPObjectContextTxNotSupported);  
                break;
            case 2:
                clsid = __uuidof(_ASP_ASPObjectContextTxSupported);     
                break;
            case 3: 
                clsid = __uuidof(_ASP_ASPObjectContextTxRequired);      
                break;
            case 4: 
                clsid = __uuidof(_ASP_ASPObjectContextTxRequiresNew);
                break;
        }
    }
    else
    {
        EXIT_WITH_HRESULT(E_NOTIMPL);
    }


    // Create the ASP-classic transacted object

    hr = PlatformGetObjectContext((void **)&pContext);

    if (hr == S_OK)
    {
        // MTS context available -- use it

        hr = pContext->CreateInstance(
                clsid,
                __uuidof(_ASP_IASPObjectContextCustom),
                (LPVOID*)&pTxnContext);

        ON_ERROR_EXIT();
    }
    else if (hr == CONTEXT_E_NOCONTEXT)
    {
        // MTS context not available -- use CoCreateInstance

        hr = CoCreateInstance(
                clsid,
                NULL,
                CLSCTX_INPROC_SERVER,
                __uuidof(_ASP_IASPObjectContextCustom),
                (LPVOID*)&pTxnContext);

        ON_ERROR_EXIT();
    }
    else
    {
        EXIT_WITH_HRESULT(hr);
    }

    // Make the call through the transacted object

    helper._TheCallback = callback;
    hr = pTxnContext->Call(&helper, L"", pfAborted);
    *pfAborted = (hr == CONTEXT_E_ABORTED || hr == CONTEXT_E_ABORTING) ? TRUE : helper._aborted;
    hr = S_OK; // ignore other errors

Cleanup:
    if (helper._pFTM != NULL)
        helper._pFTM->Release();
    if (pTxnContext != NULL)
        pTxnContext->Release();
    if (pContext != NULL)
        pContext->Release();

    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// Transaction implementation via CoEnterServiceDomain / CoExitServiceDomain
//////////////////////////////////////////////////////////////////////////////////////////////////

// guids and interfaces from Whistler

struct __declspec(uuid("ecabb0c8-7f19-11d2-978e-0000f8757e2a")) _WHISTLER_CServiceConfig;

typedef enum tagCSC_InheritanceConfig {
    CSC_Inherit = 0, 
    CSC_Ignore = CSC_Inherit + 1 
} CSC_InheritanceConfig;

struct __declspec(uuid("92186771-d3b4-4d77-a8ea-ee842d586f35")) _WHISTLER_IServiceInheritanceConfig;

struct _WHISTLER_IServiceInheritanceConfig : IUnknown {
    virtual HRESULT __stdcall ContainingContextTreatment(CSC_InheritanceConfig inheritanceConfig) = 0;
};

typedef enum tagCSC_TransactionConfig {
    CSC_NoTransaction = 0,
    CSC_IfContainerIsTransactional = CSC_NoTransaction + 1,
    CSC_CreateTransactionIfNecessary = CSC_IfContainerIsTransactional + 1,
    CSC_NewTransaction = CSC_CreateTransactionIfNecessary + 1
} CSC_TransactionConfig;

struct __declspec(uuid("772b3fbe-6ffd-42fb-b5f8-8f9b260f3810")) _WHISTLER_IServiceTransactionConfig;

struct _WHISTLER_IServiceTransactionConfig : IUnknown {
    virtual HRESULT __stdcall ConfigureTransaction(CSC_TransactionConfig transactionConfig) = 0;
    // other methods we don't call
};

struct __declspec(uuid("61F589E8-3724-4898-A0A4-664AE9E1D1B4")) _WHISTLER_ITransactionStatus;

struct _WHISTLER_ITransactionStatus : IUnknown {
    virtual HRESULT __stdcall SetTransactionStatus(HRESULT hr) = 0;
    virtual HRESULT __stdcall GetTransactionStatus(HRESULT *phr) = 0;
};

// error codes
#define _WHISTLER_E_NOTRANSACTION 0x8004D00E

// helper class that implements _WHISTLER_ITransactionStatus
class TransactionStatusHelper : public _WHISTLER_ITransactionStatus {
private:
    ULONG _refs;
    HRESULT _hr;

public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    TransactionStatusHelper() {
        _refs = 1;
        _hr = S_OK;
    }

    // implementation of IUnknown
    STDMETHOD(QueryInterface)(REFIID iid, void **ppvObj) {
        if (iid == IID_IUnknown || iid == IID_IDispatch || iid == __uuidof(_WHISTLER_ITransactionStatus)) {
            AddRef();
            *ppvObj = this;
            return S_OK;
        }
        else {
            return E_NOINTERFACE;
        }
    }

    STDMETHOD_(ULONG, AddRef)() {
        return ++_refs;
    }

    STDMETHOD_(ULONG, Release)() {
        if (--_refs == 0) {
            delete this;
            return 0;
        }

        return _refs;
    }

    // implementation of _WHISTLER_ITransactionStatus
    STDMETHOD(SetTransactionStatus)(HRESULT hr) {
        _hr = hr;
        TRACE1(L"Transactions", L"ITransactionStatus::SetTransactionStatus(%08x)", hr); 
        return S_OK;
    }

    STDMETHOD(GetTransactionStatus)(HRESULT *phr) {
        *phr = _hr;
        return S_OK;
    }

    // check if aborted
    BOOL IsAborted() {
        return (SUCCEEDED(_hr) || _hr == _WHISTLER_E_NOTRANSACTION) ? FALSE : TRUE;
    }
};

// helper to create config object
HRESULT CreateServiceDomainConfig(int mode, IUnknown **ppConfigObject) {
    HRESULT hr = S_OK;
    IUnknown *pServiceConfig = NULL;
    _WHISTLER_IServiceInheritanceConfig *pIInheritConfig = NULL;
    _WHISTLER_IServiceTransactionConfig *pITransConfig = NULL;

	hr = CoCreateInstance(__uuidof(_WHISTLER_CServiceConfig), NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&pServiceConfig);
    ON_ERROR_EXIT();

    hr = pServiceConfig->QueryInterface(__uuidof(_WHISTLER_IServiceInheritanceConfig), (void **)&pIInheritConfig);
    ON_ERROR_EXIT();

    hr = pIInheritConfig->ContainingContextTreatment(CSC_Inherit);
    ON_ERROR_EXIT();

    hr = pServiceConfig->QueryInterface(__uuidof(_WHISTLER_IServiceTransactionConfig), (void **)&pITransConfig);
    ON_ERROR_EXIT();

    CSC_TransactionConfig transConfig = CSC_NoTransaction;

    switch (mode) {
        case 1: 
            transConfig = CSC_NoTransaction;
            break;
        case 2:
            transConfig = CSC_IfContainerIsTransactional;
            break;
        case 3: 
            transConfig = CSC_CreateTransactionIfNecessary;
            break;
        case 4: 
            transConfig = CSC_NewTransaction;
            break;
    }

    hr = pITransConfig->ConfigureTransaction(transConfig);
    ON_ERROR_EXIT();

Cleanup:
    if (hr == S_OK) {
        pServiceConfig->AddRef();
        *ppConfigObject = pServiceConfig;
    }

    ReleaseInterface(pIInheritConfig);
    ReleaseInterface(pITransConfig);
    ReleaseInterface(pServiceConfig);
    return hr;
}

HRESULT TransactManagedCallbackViaServiceDomainAPIs(PFN_TRANSACTED_CALL callback, int mode, BOOL *pfAborted) {
    HRESULT hr = S_OK;
    IUnknown *pConfigObject = NULL;
    TransactionStatusHelper *pStatus = NULL;
    BOOL serviceDomainEntered = FALSE;
    BOOL fAborted = FALSE;
    int state;

    // create config object
    hr = CreateServiceDomainConfig(mode, &pConfigObject);
    ON_ERROR_EXIT();

    // create status object
    pStatus = new TransactionStatusHelper();
    ON_OOM_EXIT(pStatus);

    // enter service domain
    hr = PlatformEnterServiceDomain(pConfigObject);
    ON_ERROR_EXIT();

    TRACE(L"Transactions", L"Entered Service Domain"); 
    serviceDomainEntered = TRUE;

    // call managed code
    __try {
        state = (*callback)();
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        state = TRANSACTED_CALL_STATE_ERROR;
    }

    // find out if aborted
    if (DetermineIfAborted(state))
        fAborted = TRUE;

    TRACE2(L"Transactions", L"Managed code codeback returned %d, aborted=%d", state, fAborted); 

Cleanup:
    // exit service domain
    if (serviceDomainEntered) {
        PlatformLeaveServiceDomain(pStatus);

        // remember if aborted
        if (pStatus->IsAborted())
            fAborted = TRUE;

        TRACE(L"Transactions", L"Left Service Domain"); 
    }

    if (hr != S_OK)
        fAborted = TRUE;

    ReleaseInterface(pStatus);
    ReleaseInterface(pConfigObject);
    *pfAborted = fAborted;
    TRACE2(L"Transactions", L"Returning from TransactManagedCallbackViaServiceDomainAPIs: hr=%08x, aborted=%d", hr, fAborted); 
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\rc\ent\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\util.cxx ===
/**
 * util.cxx
 * 
 * Misc utilities.
 * 
 * Copyright (c) 1998-2001, Microsoft Corporation
 * 
 */


#include "precomp.h"
#include "_ndll.h"
#include "nisapi.h"

void
CleanupCStrAry(CStrAry *pcstrary) {
    int i;
    
    for (i = 0; i < pcstrary->Size(); i++) {
        delete [] (*pcstrary)[i];
    }
    
    pcstrary->DeleteAll();
}


/**
 * This function will make a copy of pchStr, and append that copy to
 * pcstrary.  Please note that pcstrary should free the allocated memory
 * when it's done with them.
 */
HRESULT
AppendCStrAry(CStrAry *pcstrary, WCHAR *pchStr) {
    HRESULT hr = S_OK;
    WCHAR   *pchDup = NULL;

    pchDup = DupStr(pchStr);
    ON_OOM_EXIT(pchDup);

    hr = pcstrary->Append(pchDup);
    ON_ERROR_EXIT();

    pchDup = NULL;

Cleanup:
    delete [] pchDup;
    return hr;
}


/**
 * This function will list all the files and sub-directories of a given
 * directory, and add them to pcsEntries
 *
 * Params:
 *  pchDir      The directory to enumerate
 *  dwFlags     LIST_DIR_FILE - Files will be included
 *              LIST_DIR_DIRECTORY - Directory will be included
 *  pcsEntries  Output.  Caller has to free each string in the result array
 */
HRESULT
ListDir(LPCWSTR pchDir, DWORD dwFlags, CStrAry *pcsEntries) {
    HRESULT     hr = S_OK;
    HANDLE      hFind = NULL;
    WIN32_FIND_DATA FindFileData;
    WCHAR       pchPath[MAX_PATH];
    BOOL        fWantFile = !!(dwFlags & LIST_DIR_FILE);
    BOOL        fWantDir = !!(dwFlags & LIST_DIR_DIRECTORY);
    BOOL        fIsDir;

    if (wcslen(pchDir) + 3 > MAX_PATH) {
        EXIT_WITH_WIN32_ERROR(ERROR_FILENAME_EXCED_RANGE);
    }

    StringCchCopyToArrayW(pchPath, pchDir);
    StringCchCatToArrayW(pchPath, L"\\*");
    
    hFind = FindFirstFile(pchPath, &FindFileData);
    if (hFind == INVALID_HANDLE_VALUE) {
        EXIT_WITH_LAST_ERROR();
    }

    while(1) {
        fIsDir = !!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);

        if ((fIsDir && fWantDir) ||
            (!fIsDir && fWantFile)) {
            hr = AppendCStrAry(pcsEntries, FindFileData.cFileName);
            ON_ERROR_EXIT();
        }

        if (!FindNextFile(hFind, &FindFileData)) {
            if (GetLastError() == ERROR_NO_MORE_FILES) {
                break;
            }
            else {
                EXIT_WITH_LAST_ERROR();
            }
        }
    }
    
Cleanup:
    if (hFind) {
        FindClose(hFind);
    }
    
    return hr;
}


/**
 * Recursive function called by RemoveDirectoryRecursively
 */
HRESULT
RemoveDirectoryRecursiveFunc(LPWSTR pszPath, BOOL bRoot, BOOL bDeleteRoot)
{
    HRESULT hr = S_OK;
    WCHAR           *szBuffer = NULL;
    HANDLE          hFile;
    WIN32_FIND_DATA w32fd;
    int             size, iLast;

    ASSERT(pszPath != NULL);

    // Add \\*.* to the end
    size = lstrlenW(pszPath) + 5;   // "\\*.*\0"

    szBuffer = new WCHAR[size];
    ON_OOM_EXIT(szBuffer);
        
    StringCchCopyW(szBuffer, size, pszPath);
    iLast = lstrlenW(szBuffer) - 1;
    if(iLast >= 0 && szBuffer[iLast] != L'\\') {
        StringCchCatW(szBuffer, size, L"\\");
    }
    StringCchCatW(szBuffer, size, L"*.*");
    

    // Go thru all the items in the directory: 
    // - if it's a dir, call this function recursively; 
    // - if it's a file, just delete it.
    // At the end, this function will delete pszPath (unless told not to)
    
    hFile = FindFirstFile(szBuffer, &w32fd);
    if (hFile == INVALID_HANDLE_VALUE)
        EXIT_WITH_LAST_ERROR();

    while (1){
        if (w32fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY){
            if (lstrcmp(w32fd.cFileName, L".") == 0 || lstrcmp(w32fd.cFileName, L"..") == 0) {
                // Do nothing for . or ..
            }
            else {
                // Recursively remove the files and dirs inside this directory
                
                size = (lstrlenW(pszPath) +         // Path
                        1 +                         // "\\"
                        lstrlenW(w32fd.cFileName) + // Length of filename
                        1                           // "\0"
                        ) * sizeof(WCHAR);

                szBuffer = new (szBuffer, NewReAlloc) WCHAR[size];
                ON_OOM_EXIT(szBuffer);
                    
                StringCchCopyW(szBuffer, size, pszPath);
                StringCchCatW(szBuffer, size, L"\\");
                StringCchCatW(szBuffer, size, w32fd.cFileName);

                RemoveDirectoryRecursiveFunc(szBuffer, FALSE, FALSE);
            }
        }
        else{

            // Delete the file

            size = (lstrlenW(pszPath) +         // Path
                    1  +                        // "\\"
                    lstrlenW(w32fd.cFileName) + // Length of filename
                    1                           // "\0"
                    ) * sizeof(WCHAR);

            szBuffer = new (szBuffer, NewReAlloc) WCHAR[size];
            ON_OOM_EXIT(szBuffer);
                    
            StringCchCopyW(szBuffer, size, pszPath);
            StringCchCatW(szBuffer, size, L"\\");
            StringCchCatW(szBuffer, size, w32fd.cFileName);

            DeleteFile(szBuffer);
        }
        
        if (!FindNextFile(hFile, &w32fd)){
            if (GetLastError() == ERROR_NO_MORE_FILES) {
                break;
            } 
            else {
                EXIT_WITH_LAST_ERROR();
            }
        }

    }

    FindClose(hFile);

    if (bRoot && !bDeleteRoot) {
        // Don't blow away root directory if told not to
    }
    else {
        //
        // blow away the directory
        //
        RemoveDirectory(pszPath);
    }
    
Cleanup:    
    delete [] szBuffer;
    return hr;
}


/**
 * This function will remove all the files and subdirs underneath
 * a directory, and optionally remove that directory at the end.
 */
HRESULT
RemoveDirectoryRecursively(WCHAR *wszDir, BOOL bRemoveRoot)
{
    return RemoveDirectoryRecursiveFunc(wszDir, TRUE, bRemoveRoot);
}

/**
 * Enables debug privlege
 */
VOID
DebugPriv(VOID)
{
    HANDLE Token ;
    UCHAR Buf[ sizeof( TOKEN_PRIVILEGES ) + sizeof( LUID_AND_ATTRIBUTES ) ];
    PTOKEN_PRIVILEGES Privs ;
    
    if (OpenProcessToken( GetCurrentProcess(),
                          MAXIMUM_ALLOWED,
                          &Token )) {

        Privs = (PTOKEN_PRIVILEGES) Buf ;        
        Privs->PrivilegeCount = 1 ;
        Privs->Privileges[0].Luid.LowPart = 20L ;
        Privs->Privileges[0].Luid.HighPart = 0 ;
        Privs->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED ;
        
        AdjustTokenPrivileges( Token,
                               FALSE,
                               Privs,
                               0,
                               NULL,
                               NULL );
        
        CloseHandle( Token );
    }
}

/**
 * Calls DebugBreak in another process. The handle should be opened with PROCESS_ALL_ACCESS.
 */
BOOL
RemoteBreakIntoProcess(HANDLE hProcess) 
{
    LPTHREAD_START_ROUTINE DbgBreakPoint;
    HMODULE ntdll;
    HANDLE hThread;

    DebugPriv();

    if (hProcess)
    {
        ntdll = GetModuleHandleA("ntdll.dll");

        if (ntdll) {

            DbgBreakPoint = (LPTHREAD_START_ROUTINE)GetProcAddress(ntdll, "DbgBreakPoint");

            if ((hThread = CreateRemoteThread(hProcess, 0, 32768, DbgBreakPoint, 0, 0, 0)) != NULL)
            {
                CloseHandle(hThread);
                return TRUE;
            }
        }
    }
    return FALSE;
}

/**
 * Detect if the current process is under a debugger.
 */
BOOL
IsUnderDebugger()
{
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId());
    if (hProcess == NULL) return FALSE;
    BOOL result = IsUnderDebugger(hProcess);
    CloseHandle(hProcess);
    return result;
}


/**
 * Detect if a process is under a native debugger.
 */
BOOL
IsUnderDebugger(HANDLE hProcess)
{
    if (hProcess == NULL || hProcess == INVALID_HANDLE_VALUE) return FALSE;
    NTSTATUS                    Status = 0;
    BOOLEAN                     bDebug = FALSE;
    UINT_PTR                    Peb    = 0;
    PROCESS_BASIC_INFORMATION   ProcessBasicInfo;

    ZeroMemory(&ProcessBasicInfo, sizeof(ProcessBasicInfo));

    Status = g_pfnNtQueryInformationProcess(hProcess, 
                                            ProcessBasicInformation, 
                                            &ProcessBasicInfo, 
                                            sizeof(ProcessBasicInfo), 
                                            NULL);

    if (!NT_SUCCESS(Status))
    {
        return FALSE;
    }

    Peb = (UINT_PTR) ProcessBasicInfo.PebBaseAddress;
    
    if (!ReadProcessMemory(hProcess, (LPVOID)(Peb + FIELD_OFFSET(PEB, BeingDebugged)), &bDebug, sizeof(bDebug), NULL )) 
    {
        return FALSE;
    }
    
    return bDebug;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\rc\exp\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\rc\redist\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\rc\std\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\rc\makefile.inc ===
$(O)\xsprc.res : ..\xsprc.rc $(O)\msg.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\perfstringsmerger\makefile.inc ===
$(O)\$(PERF_LOC_VERSIONED_INI) : $(O)\$(TARGETNAME).exe
        $(O)\$(TARGETNAME) $(DNAROOT)\src\xsp\inc\$(ASPNET_PRODUCT)\$(O)\aspnet_perf_enu.ini $(DNAROOT)\src\xsp\inc\aspnetperflocalized.txt $(O)\aspnet_perf.ini
        
$(O)\$(PERF_LOC_GENERIC_INI) : $(O)\$(TARGETNAME).exe
        $(O)\$(TARGETNAME) $(DNAROOT)\src\xsp\inc\$(ASPNET_PRODUCT)\$(O)\aspnet_perf2_enu.ini $(DNAROOT)\src\xsp\inc\aspnetperflocalized.txt $(O)\aspnet_perf2.ini
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\regcomp\ent\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\isapi\_ndll.h ===
/**
 * _ndll
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

#pragma once 

#include <fxver.h>
#include "ndll.h"
#include "names.h"
#include "pm.h"
#include "ary.h"
#include "aspnetver.h"

typedef CPtrAry<WCHAR *>   CStrAry;
typedef CDataAry<DWORD>    CDwordAry;

extern HINSTANCE g_DllInstance;
extern HINSTANCE g_rcDllInstance;

extern DWORD     g_tlsiEventCateg;


#define RESOURCE_STRING_MAX 1024

#define LIST_DIR_FILE               0x00000001
#define LIST_DIR_DIRECTORY          0x00000002

#define IIS_STATE_DISABLED          0x00000001
#define IIS_STATE_NOT_INSTALLED     0x00000002
#define IIS_STATE_ENABLED           0x00000004

/* regiis.cxx */

HRESULT RegisterIIS(WCHAR *pchBase, DWORD dwFlags);
HRESULT UnregisterObsoleteIIS();
HRESULT CheckIISState(DWORD *pState);
HRESULT UnregisterIIS(BOOL fAllVers);
HRESULT GetSiteServerComment(WCHAR * path, WCHAR ** pchServerComment);
HRESULT SetBinAccessIIS(WCHAR *path);
HRESULT GetAllWebSiteDirs(CStrAry *pcsWebSiteDirs, CStrAry *pcsWebSiteAppRoots);
DWORD   CompareAspnetVersions(ASPNETVER *pver1, ASPNETVER *pver2);
HRESULT SetClientScriptKeyProperties(WCHAR *wsParent);
HRESULT RemoveKeyIIS(WCHAR *pchParent, WCHAR *pchKey);
HRESULT IsIISPathValid(WCHAR *pchPath, BOOL *pfValid);
HRESULT GetIISVerInfoList(ASPNET_VERSION_INFO **ppVerInfo, DWORD *pdwCount);
HRESULT GetIISKeyInfoList(ASPNET_IIS_KEY_INFO **ppKeyInfo, DWORD *pdwCount);
HRESULT RemoveAspnetFromKeyIIS(WCHAR *pchBase, BOOL fRecursive);
HRESULT GetIISRootVer(ASPNETVER **ppVer);


/* util.cxx */

void    CleanupCStrAry(CStrAry *pcstrary);
HRESULT AppendCStrAry(CStrAry *pcstrary, WCHAR *pchStr);
HRESULT ListDir(LPCWSTR pchDir, DWORD dwFlags, CStrAry *pcsEntries);
HRESULT RemoveDirectoryRecursively(WCHAR *wszDir, BOOL bRemoveRoot);
BOOL RemoteBreakIntoProcess(HANDLE hProcess);
BOOL IsUnderDebugger();
BOOL IsUnderDebugger(HANDLE hProcess);


#define WIDESTR2(x) L##x
#define WIDESTR(x)  WIDESTR2(x)

#define FILTER_DESCRIPTION_CHAR PRODUCT_NAME    " Cookieless Session Filter"
#define FILTER_DESCRIPTION      PRODUCT_NAME_L L" Cookieless Session Filter"

HANDLE
__stdcall
CreateUserToken (
       LPCWSTR   name, 
       LPCWSTR   password,
       BOOL      fImpersonationToken,
       LPWSTR    szError,
       int       iErrorSize);

#define PRODUCT_VERSION_L VER_PRODUCTVERSION_ZERO_QFE_STR_L
#define PRODUCT_VERSION     VER_PRODUCTVERSION_ZERO_QFE_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\rc\sources.inc ===
!include $(DNAROOT)\src\xsp\place.inc

TARGETNAME      =$(ASPNET_NAME_PREFIX)rc
TARGETPATH      =$(O)
TARGETTYPE      =DYNLINK

RESOURCE_ONLY_DLL=1

SOURCES=                \
    ..\msg.mc           \
    ..\xsprc.rc         \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\perfstringsmerger\sources.inc ===
!include $(DNAROOT)\src\xsp\place.inc

!if "$(ASPNET_PRODUCT)" == "redist"
SYNCHRONIZE_BLOCK=1
!endif

TARGETNAME=MergePerfStrings
TARGETTYPE=NOTARGET
TARGETPATH=$(O)
COMPLUSTYPE=EXE

NO_BINPLACE=1

PERF_LOC_VERSIONED_INI=$(ASPNET_NAME_PREFIX)perf.ini
PERF_LOC_GENERIC_INI=$(ASPNET_NAME_PREFIX)perf2.ini

COMPONENT_NO_DOC=1

COMPLUSIMPORTS = $(URTTARGET)\System.dll

SOURCES=

CSHARP_SOURCES = ..\PerfStringsMerger.cs \

!if $(PASS2)
NTTARGETFILES=$(O)\$(PERF_LOC_VERSIONED_INI) $(O)\$(PERF_LOC_GENERIC_INI)
MISCFILES=$(O)\$(PERF_LOC_VERSIONED_INI) $(O)\$(PERF_LOC_GENERIC_INI)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\regcomp\exp\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\regcomp\redist\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\regcomp\std\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\regexes\ent\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\regexes\exp\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\regcomp\sources.inc ===
!IF 0

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

!include $(DNAROOT)\src\xsp\place.inc

TARGETNAME=RegexPreCompiler
TARGETTYPE=NOTARGET
TARGETPATH=$(O)
COMPLUSTYPE=EXE

!if "$(ASPNET_PRODUCT)" == "redist"
SYNCHRONIZE_BLOCK=1
!endif

COMPONENT_NO_DOC=1

COMPLUSIMPORTS = $(URTTARGET)\System.dll

SOURCES=..\RegexPreCompiler.rc

CSHARP_SOURCES = ..\*.cs \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\regexes\redist\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\regexes\std\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\regiis\exp\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\perfstringsmerger\perfstringsmerger.cs ===
//------------------------------------------------------------------------------
// <copyright file="PerfStringsMerger.cs" company="Microsoft">
//     Copyright 2002 (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web
{
    using System;
    using System.Collections;
    using System.IO;
    using System.Text.RegularExpressions;

//
//  This is a small utility exe used during the build system to merge
//  the localized perf counter strings with the ENU (English - US) file.
//  This is done by parsing the ENU perf ini file, then parsing the file
//  containing the localized strings, checking that all localized entries
//  either exist (adding the ENU strings in their stead if not there) and
//  then writting the resulting, merged file as a Unicode text file.
//
//  File formats:
//
//  The ENU perf ini file (generated during the "inc" directory build) has 
//  4 sections preambled with []'s.  They are [info], [languages], [objects]
//  and [text].  Here's a sample of it:
//
// ------ 
//
//  [info]
//  drivername=ASP.NET_1.0.4023.0
//  symbolfile=aspnet_perf.h
//
//  [languages]
//  000=Neutral
//  009=English
//
//  [objects]
//  OBJECT_1_009_NAME=ASP.NET v1.0.4023.0
//  OBJECT_2_009_NAME=ASP.NET Apps v1.0.4023.0
//
//  [text]
//  OBJECT_1_009_NAME=ASP.NET v1.0.4023.0
//  OBJECT_1_009_HELP=ASP.NET v1.0.4023.0 global performance counters
//  OBJECT_2_009_NAME=ASP.NET Apps v1.0.4023.0
//  OBJECT_2_009_HELP=ASP.NET v1.0.4023.0 application performance counters
//
//  ASPNET_APPLICATION_RESTARTS_009_NAME=Application Restarts
//  ASPNET_APPLICATION_RESTARTS_009_HELP=Number of times the application has been restarted during the web server's lifetime.
//
// ------
//  
//  The [info] section contains the service name and symbol file related with this ini file.
//  The [languages] section lists the language id and text string of each localized set of 
//  perf counter strings in this file.
//  The [objects] section lists the perf counter categories (or objects) defined
//  The [text] section finally contains the bulk of the string, each name containing a localized perf
//  counter description text.
//
//  The localized strings file is similar to the regular ini file, but with the [info] and [objects] sections
//  missing, as well as the English strings.  This separation is done on purpose, to allow a separate file that
//  is not essential for the build, but that can be modified and checked in by the localization team.
//
//  This utility will parse each section separately, storing the data either as is (in the case of [info] and
//  [objects] section, or as sorted list by language (specifically the [text] section).  It'll read the
//  ENU ini file first, since that's the canonical set of perf counters.  It'll then read the localized strings
//  file, then it'll scan and ensure that each ENU description text is matched up in each language with a localized
//  version.  If the localized string is missing, it'll add the ENU one as its description, along with a prefix
//  of "(Loc)" to emphasize to testers and localization folks that a perf counter string needs to be looked at.
//


    class TextDescription
    {
        public string Name = null;
        public string Help = null;
    }

    class CounterStrings
    {
        public string Language;
        public SortedList Objects = new SortedList();
        public SortedList Description = new SortedList();
    }

    public enum SectionModeEnum
    {
        NoSection = 0,
        InfoSection = 1,
        LanguagesSection = 2,
        ObjectsSection = 3,
        TextSection = 4
    }

    public class PerfStringsMerger 
    {
        SortedList _descByLang = new SortedList();   // Key is language Id, value is CounterStrings
        ArrayList _infoStrings = new ArrayList();
        ArrayList _objectsStrings = new ArrayList();

        string _driverVersion = "";

        static void PrintError(string msg)
        {
            Console.WriteLine("PerfStringsMerger : error 0001: " + msg);
        }

        static void PrintWarning(string msg)
        {
            Console.WriteLine("PerfStringsMerger : warning 0001: " + msg);
        }
        
        public static void Main(string[] args) 
        {
            try {
                if (args.Length != 3) {
                    PrintError("Usage: MergePerfStrings inputIniFile perfTextFile outputIniFile");
                    return;
                }

                PerfStringsMerger mpf = new PerfStringsMerger();

                // Read the english ini file (no texts)
                mpf.ReadIniFile(args[0], true);

                // Read the localized strings modified ini file
                mpf.ReadIniFile(args[1], false);

                // Merge the data and write out the result
                mpf.MergeAndWrite(args[2]);
            }
            catch (Exception e) {
                PrintError("Exception during run: " + e);
                Environment.Exit(1);
            }
        }

        public string VersionMatchEvaluator(Match match)
        {
            if (_driverVersion != "") {
                if (match.Value[0] == ' ') {
                    return " " + _driverVersion;
                }
            }
            return _driverVersion;
        }

        void ReadIniFile(string inputFile, bool isEnuFile)
        {
            FileStream inputStream = null;
            StreamReader reader = null;
            Regex descRegex = new Regex("^([a-zA-Z]+)_(\\w+)_([0-9a-fA-F]{3})_(\\w{4})=(.*)");
            Regex languageIdRegex = new Regex("^([0-9a-fA-F]{3})=(.+)");
            Regex driverVersionRegex = new Regex("^drivername=ASP.NET_([0-9\\.]+)");
            string s;
            Match match;
            SectionModeEnum sectionMode = SectionModeEnum.NoSection;
            CounterStrings langStrs;
            TextDescription desc = null;
            string prefix;
            string name;
            string langId;
            string nameType;
            string description;
            bool isEnuLangId;

            inputStream = File.Open(inputFile, FileMode.Open, FileAccess.Read);
            reader = new StreamReader(inputStream);

             try {
                while ((s = reader.ReadLine()) != null) {
                    // Is it a zero length or a comment?  Skip it.
                    if (s.Length == 0 || s[0] == ';') {
                        continue;
                    }
                    else if (s[0] == '[') {
                        if (s == "[info]") {
                            sectionMode = SectionModeEnum.InfoSection;
                            if (!isEnuFile) {
                                PrintError("Localized string file must NOT have an [info] section");
                            }
                        }
                        else if (s == "[languages]") {
                            sectionMode = SectionModeEnum.LanguagesSection;
                        }
                        else if (s == "[objects]") {
                            sectionMode = SectionModeEnum.ObjectsSection;
                            if (!isEnuFile) {
                                PrintError("Localized string file must NOT have an [objects] section");
                            }
                        }
                        else if (s == "[text]") {
                            sectionMode = SectionModeEnum.TextSection;
                        }
                        else {
                            PrintError("Unknown section: " + s);
                        }
                    }
                    else {
                        switch (sectionMode) {
                            case SectionModeEnum.InfoSection:
                                if ((match = driverVersionRegex.Match(s)).Success) {
                                    _driverVersion = "v" + match.Groups[1].Captures[0].Value;
                                }
                                _infoStrings.Add(s);
                                break;
                            case SectionModeEnum.ObjectsSection:
                                _objectsStrings.Add(s);
                                break;
                            case SectionModeEnum.LanguagesSection:
                                if ((match = languageIdRegex.Match(s)).Success) {
                                    langId = match.Groups[1].Captures[0].Value.ToUpper();
                                    if (_descByLang[langId] == null) {
                                        langStrs = new CounterStrings();
                                        langStrs.Language = match.Groups[2].Captures[0].Value;
                                        _descByLang.Add(langId, langStrs);
                                    }
                                    else {
                                        if (langId != "009") {
                                            PrintError("Duplicate language id entry: " + langId);
                                        }
                                    }
                                }
                                else {
                                    PrintError("Invalid string in Language section: " + s);
                                }
                                break;
                            case SectionModeEnum.TextSection:
                                if ((match = descRegex.Match(s)).Success) {
                                    prefix = match.Groups[1].Captures[0].Value.ToUpper();
                                    name = match.Groups[2].Captures[0].Value.ToUpper();
                                    langId = match.Groups[3].Captures[0].Value.ToUpper();
                                    nameType = match.Groups[4].Captures[0].Value.ToUpper();
                                    description = match.Groups[5].Captures[0].Value;

                                    if (langId == "009") {
                                        isEnuLangId = true;
                                    }
                                    else {
                                        isEnuLangId = false;
                                    }

                                    if (isEnuFile && (!isEnuLangId)) {
                                        PrintError("Invalid language found in ENU file: " + s);
                                        continue;
                                    }
                                    
                                    langStrs = (CounterStrings) _descByLang[langId];
                                    if (langStrs == null) {
                                        PrintError("Unknown language id found: " + langId + " in string " + s);
                                    }
                                    else if (prefix == "OBJECT" || prefix == "ASPNET") {
                                        if (prefix == "OBJECT") {
                                            desc = (TextDescription) langStrs.Objects[name];

                                            if (desc == null) {
                                                desc = new TextDescription();
                                                langStrs.Objects.Add(name, desc);
                                            }
                                        }
                                        else if (prefix == "ASPNET") {
                                            desc = (TextDescription) langStrs.Description[name];
                                            if (desc == null) {
                                                if (!isEnuFile && isEnuLangId) {
                                                    PrintError("Stale description entry for English in localized strings file: " + s);
                                                }
                                                desc = new TextDescription();
                                                langStrs.Description.Add(name, desc);
                                            }
                                        }

                                        if (nameType == "NAME") {
                                            if (desc.Name != null) {
                                                if (!isEnuLangId) {
                                                    PrintError("Duplicate NAME entry: " + s);
                                                }
                                            }
                                            desc.Name = description;
                                        }
                                        else if (nameType == "HELP") {
                                            if (desc.Help != null) {
                                                if (!isEnuLangId) {
                                                    PrintError("Duplicate HELP entry: " + s);
                                                }
                                            }
                                            desc.Help = description;
                                        }
                                        else {
                                            PrintError("Invalid performance description string: " + s);
                                        }
                                    }
                                    else {
                                        PrintError("Unknown string prefix: " + s);
                                    }
                                }
                                else {
                                    PrintError("Invalid string in Text section: " + s);
                                }
                                break;
                            default:
                                PrintError("Invalid string: " + s);
                                break;
                        }
                    }
                }
            }
            finally {
                if (reader != null) {
                    reader.Close();
                }
            }
        }

        void MergeAndWrite(string outFile)
        {
            FileStream outputStream = null;
            StreamWriter writer = null;
            IDictionaryEnumerator locEnum;
            IDictionaryEnumerator descEnum;
            IDictionaryEnumerator objDescEnum;
            CounterStrings locStrings;
            TextDescription desc;
            TextDescription locDesc;
            TextDescription enuDesc;
            CounterStrings enuStrings;
            Regex versionRegex = new Regex(" ?%ASPNET_VER%");
            Regex appsRegex = new Regex("Apps");
                
            // If some language doesn't contain the proper localized string,
            // add the Engligh version with the "(loc)" prefix

            // Ensure that we have ENU strings
            enuStrings = (CounterStrings) _descByLang["009"];
            if (enuStrings == null) {
                PrintError("No English performance strings!");
                return;
            }

            // And that all ENU entries are filled out
            objDescEnum = enuStrings.Objects.GetEnumerator();
            while (objDescEnum.MoveNext()) {
                enuDesc = (TextDescription) objDescEnum.Value;
                if (enuDesc.Name == null || enuDesc.Name == "") {
                    PrintError("Missing ENU Name description for object: " + objDescEnum.Key);
                }
                if (enuDesc.Help == null || enuDesc.Help == "") {
                    PrintError("Missing ENU Help description for object: " + objDescEnum.Key);
                }
            }
            descEnum = enuStrings.Description.GetEnumerator();
            while (descEnum.MoveNext()) {
                enuDesc = (TextDescription) descEnum.Value;
                if (enuDesc.Name == null || enuDesc.Name == "") {
                    PrintError("Missing ENU Name description for perf counter: " + descEnum.Key);
                }
                if (enuDesc.Help == null || enuDesc.Help == "") {
                    PrintError("Missing ENU Help description for perf counter: " + descEnum.Key);
                }
            }

            locEnum = _descByLang.GetEnumerator();
            while (locEnum.MoveNext()) {
                locStrings = (CounterStrings) locEnum.Value;

                // Check if we're missing all descriptions for a language and issue a single error
                if (locStrings.Objects.Count == 0 && locStrings.Description.Count == 0) {
                    PrintWarning("Missing all localized descriptions for language: " + locEnum.Key);
                    continue;
                }

                // Check the "OBJECT" strings
                // Go through the ENU object strings and check to see if there's a localized
                // version of each.  If not, copy the ENU one over.
                objDescEnum = enuStrings.Objects.GetEnumerator();
                while (objDescEnum.MoveNext()) {
                    // Get the ENU description
                    enuDesc = (TextDescription) objDescEnum.Value;

                    // Look up the localized description
                    locDesc = (TextDescription) locStrings.Objects[objDescEnum.Key];

                    // If either NAME, HELP or both are missing, fill it in and issue warning.
                    if (locDesc == null) {
                        locDesc = new TextDescription();
                        locStrings.Objects[objDescEnum.Key] = locDesc;
                    }
                    if (locDesc.Name == null) {
                        locDesc.Name = "(Loc) " + enuDesc.Name;
                        PrintWarning("Language '" + locEnum.Key + "' doesn't contain object name for object '" + objDescEnum.Key + "'");
                    }
                    if (locDesc.Help == null) {
                        locDesc.Help = "(Loc) " + enuDesc.Help;
                        PrintWarning("Language '" + locEnum.Key + "' doesn't contain object help for object '" + objDescEnum.Key + "'");
                    }
                }


                // Next, go through the localized strings and see if it contains an object description
                // not in the ENU.  If so, that's an error.
                objDescEnum = locStrings.Objects.GetEnumerator();
                while (objDescEnum.MoveNext()) {
                    locDesc = (TextDescription) objDescEnum.Value;
                    enuDesc = (TextDescription) enuStrings.Objects[objDescEnum.Key];

                    if (enuDesc == null) {
                        PrintError("Localized strings contains object definition not in ENU listing: " + locDesc.Name);
                    }
                }

                // Check the individual perf strings
                descEnum = enuStrings.Description.GetEnumerator();
                while (descEnum.MoveNext()) {

                    // Look up the ENU's key in the localized string's table
                    desc = (TextDescription) locStrings.Description[descEnum.Key];

                    // No localized version of either help or name -- add the English ones
                    if (desc == null) {
                        desc = new TextDescription();
                        locStrings.Description.Add(descEnum.Key, desc);
                    }

                    // Ensure that both the name and help are there

                    // If name is missing, copy the English one over
                    if (desc.Name == null) {
                        desc.Name = "(Loc) " + ((TextDescription) enuStrings.Description[descEnum.Key]).Name;
                        PrintWarning("Language '" + locEnum.Key + "' doesn't contain NAME description for counter '" + descEnum.Key + "'");
                    }
                    
                    // If help is missing, add the "need to localize" note
                    if (desc.Help == null) {
                        desc.Help = "(Loc) Need to localize the help string for this counter!";
                        PrintWarning("Language '" + locEnum.Key + "' doesn't contain HELP description for counter '" + descEnum.Key + "'");
                    }
                }

                // Check and see if localized strings have outdated perf strings
                if (enuStrings.Description.Count != locStrings.Description.Count) {
                    descEnum = locStrings.Description.GetEnumerator();

                    while (descEnum.MoveNext()) {
                        if (enuStrings.Description[descEnum.Key] == null) {
                            PrintError("Warning: Localized strings contains outdated performance strings: " + "ASPNET_" + descEnum.Key + "_" + locEnum.Key);
                        }
                    }
                }
            }

            // Add the neutral language by creating a counterstrings that references all the ENU strings
            CounterStrings neutral = new CounterStrings();
            neutral.Language = "Neutral";
            neutral.Objects = enuStrings.Objects;
            neutral.Description = enuStrings.Description;
            _descByLang.Add("000", neutral);


            // Write the resulting ini file
            outputStream = File.Create(outFile);
            writer = new StreamWriter(outputStream, new System.Text.UnicodeEncoding());

            try {
                writer.WriteLine("[info]");
                for (int i = 0; i < _infoStrings.Count; i++) {
                    writer.WriteLine(_infoStrings[i]);
                }

                locEnum = _descByLang.GetEnumerator();

                writer.WriteLine("");
                writer.WriteLine("[languages]");
                while (locEnum.MoveNext()) {
                    locStrings = (CounterStrings) locEnum.Value;
                    writer.WriteLine(locEnum.Key + "=" + locStrings.Language);
                }

                writer.WriteLine("");
                writer.WriteLine("[objects]");
                for (int i = 0; i < _objectsStrings.Count; i++) {
                    writer.WriteLine(_objectsStrings[i]);
                }

                writer.WriteLine("");
                writer.WriteLine("[text]");
                locEnum.Reset();

                while (locEnum.MoveNext()) {
                    locStrings = (CounterStrings) locEnum.Value;

                    writer.WriteLine("");
                    writer.WriteLine(";;");
                    writer.WriteLine(";;  ASP.NET - " + locStrings.Language);
                    writer.WriteLine(";;");
                    writer.WriteLine("");

                    objDescEnum = locStrings.Objects.GetEnumerator();
                    while (objDescEnum.MoveNext()) {
                        desc = (TextDescription) objDescEnum.Value;

                        // If generating the non-versioned ini files, replace "Apps" in the
                        // object description with "Applications".
                        if (_driverVersion == "") {
                            desc.Name = appsRegex.Replace(desc.Name, "Applications");
                            desc.Help = appsRegex.Replace(desc.Help, "Applications");
                        }
                        writer.WriteLine("OBJECT_" + objDescEnum.Key + "_" + locEnum.Key + "_NAME=" + versionRegex.Replace(desc.Name, new MatchEvaluator(this.VersionMatchEvaluator)));
                        writer.WriteLine("OBJECT_" + objDescEnum.Key + "_" + locEnum.Key + "_HELP=" + versionRegex.Replace(desc.Help, new MatchEvaluator(this.VersionMatchEvaluator)));
                    }

                    writer.WriteLine("");
                    descEnum = locStrings.Description.GetEnumerator();

                    while (descEnum.MoveNext()) {
                        desc = (TextDescription) descEnum.Value;

                        writer.WriteLine("ASPNET_" + descEnum.Key + "_" + locEnum.Key + "_NAME=" + versionRegex.Replace(desc.Name, new MatchEvaluator(this.VersionMatchEvaluator)));
                        writer.WriteLine("ASPNET_" + descEnum.Key + "_" + locEnum.Key + "_HELP=" + versionRegex.Replace(desc.Help, new MatchEvaluator(this.VersionMatchEvaluator)));
                        writer.WriteLine("");
                    }
                }
            }
            finally {
                if (writer != null) {
                    writer.Close();
                }
            }
        }       
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\regiis\std\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\regexes\sources.inc ===
!IF 0

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

!include $(DNAROOT)\src\xsp\place.inc

TARGETNAME=System.Web.RegularExpressions
TARGETTYPE=NOTARGET
TARGETPATH=$(O)
COMPLUSTYPE=DLL

!if "$(ASPNET_PRODUCT)" == "redist"
SYNCHRONIZE_BLOCK=1
!endif

COMPONENT_NO_DOC=1

ALLOW_PARTIALTRUSTCALLS=1

!if $(PASS2)
NTTARGETFILES=$(TARGETPATH)\$(TARGETNAME).$(TARGETEXT)
!endif

SOURCES=..\regexes.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\regexes\makefile.inc ===
$(TARGETPATH)\$(TARGETNAME).$(TARGETEXT) : $(POLICY_DEPS) $(O)\AssemblyAttributes.il
        cd $(TARGETPATH)
	RegexPreCompiler.exe
        cd $(MAKEDIR)
        -del $(TARGETPATH)\$(TARGETNAME).$(TARGETEXT).preatt
        ren $(TARGETPATH)\$(TARGETNAME).$(TARGETEXT) $(TARGETNAME).$(TARGETEXT).preatt
        $(ILDASM) $(ILDASM_FLAGS) /out=$(TARGETPATH)\$(TARGETNAME).il $(TARGETPATH)\$(TARGETNAME).$(TARGETEXT).preatt
        -del $(TARGETNAME).merged.il
        $(MERGEATTRIBUTES) $(TARGETPATH)\$(TARGETNAME).il $(TARGETPATH)\AssemblyAttributes.il /out $(TARGETPATH)\$(TARGETNAME).merged.il
        $(ILASM_COMMAND) /out:$(TARGETPATH)\$(TARGETNAME).$(TARGETEXT) $(TARGETPATH)\$(TARGETNAME).merged.il
        $(SIGN_COMMAND)
        $(BINPLACE_CMD)
        $(INSTALL_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\regcomp\regexprecompiler.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegexPreCompiler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   RegexPreCompiler.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System {

    using System;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Resources;
    using System.Text.RegularExpressions;

    // these are needed for some of the custom assembly attributes
    using System.Runtime.InteropServices;
    using System.Diagnostics;

    public class Rgc {
        public static int Main(string[] args) {

            // get the current assembly and its attributes
            Assembly assembly = Assembly.GetExecutingAssembly();
            AssemblyName an = assembly.GetName();

            // get the ASP.NET regular expressions 
            RegexCompilationInfo[] regexes = GetAspnetRegexes();
            an.Name = "System.Web.RegularExpressions";

            Regex.CompileToAssembly(regexes, an);
            
            return 0;
        }


        private static CustomAttributeBuilder MakeCustomAttributeBuilder(Type attrib, Type param1, Object value) {
            Type[] t = new Type[1];
            t[0] = param1;


            Object[] v = new Object[1];
            v[0] = value;

            return new CustomAttributeBuilder(attrib.GetConstructor(t), v);
        }

        private static RegexCompilationInfo[] GetAspnetRegexes() {
            string directiveRegexString = "<%\\s*@" +
                "(" +
                "\\s*(?<attrname>\\w+(?=\\W))(" +               // Attribute name
                "\\s*(?<equal>=)\\s*\"(?<attrval>[^\"]*)\"|" +  // ="bar" attribute value
                "\\s*(?<equal>=)\\s*'(?<attrval>[^']*)'|" +     // ='bar' attribute value
                "\\s*(?<equal>=)\\s*(?<attrval>[^\\s%>]*)|" +   // =bar attribute value
                "(?<equal>)(?<attrval>\\s*?)" +                 // no attrib value (with no '=')
                ")" +
                ")*" +
                "\\s*?%>";

            RegexOptions regexOptions = RegexOptions.Singleline | RegexOptions.Multiline;
            RegexCompilationInfo[] regexes = new RegexCompilationInfo[15];

            /*
            tagRegex = new Regex(
                "\\G<(?<tagname>[\\w:\\.]+)" +
                "(" +
                "\\s+(?<attrname>[-\\w]+)(" +           // Attribute name
                "\\s*=\\s*\"(?<attrval>[^\"]*)\"|" +    // ="bar" attribute value
                "\\s*=\\s*'(?<attrval>[^']*)'|" +       // ='bar' attribute value
                "\\s*=\\s*(?<attrval><%#.*?%>)|" +      // =<%#expr%> attribute value
                "\\s*=\\s*(?<attrval>[^\\s=/>]*)|" +    // =bar attribute value
                "(?<attrval>\\s*?)" +                   // no attrib value (with no '=')
                ")" +
                ")*" +
                "\\s*(?<empty>/)?>", regexOptions);*/
            regexes[0] = new RegexCompilationInfo("\\G<(?<tagname>[\\w:\\.]+)" +
                                                    "(" +
                                                    "\\s+(?<attrname>[-\\w]+)(" +           // Attribute name
                                                    "\\s*=\\s*\"(?<attrval>[^\"]*)\"|" +    // ="bar" attribute value
                                                    "\\s*=\\s*'(?<attrval>[^']*)'|" +       // ='bar' attribute value
                                                    "\\s*=\\s*(?<attrval><%#.*?%>)|" +      // =<%#expr%> attribute value
                                                    "\\s*=\\s*(?<attrval>[^\\s=/>]*)|" +    // =bar attribute value
                                                    "(?<attrval>\\s*?)" +                   // no attrib value (with no '=')
                                                    ")" +
                                                    ")*" +
                                                    "\\s*(?<empty>/)?>", 
                                                regexOptions,
                                                "TagRegex",
                                                "System.Web.RegularExpressions",
                                                true);
            
            //directiveRegex = new Regex("\\G" + directiveRegexString, regexOptions);
            regexes[1] = new RegexCompilationInfo("\\G" + directiveRegexString, 
                                                regexOptions, 
                                                "DirectiveRegex",
                                                "System.Web.RegularExpressions",
                                                true);

            //endtagRegex = new Regex("\\G</(?<tagname>[\\w:\\.]+)\\s*>", regexOptions);
            regexes[2] = new RegexCompilationInfo("\\G</(?<tagname>[\\w:\\.]+)\\s*>", 
                                                regexOptions, 
                                                "EndTagRegex",
                                                "System.Web.RegularExpressions",
                                                true);

            //aspCodeRegex = new Regex("\\G<%(?!@)(?<code>.*?)%>", regexOptions);
            regexes[3] = new RegexCompilationInfo("\\G<%(?!@)(?<code>.*?)%>", 
                                                regexOptions, 
                                                "AspCodeRegex",
                                                "System.Web.RegularExpressions",
                                                true);
            
            //aspExprRegex = new Regex("\\G<%\\s*?=(?<code>.*?)?%>", regexOptions);
            regexes[4] = new RegexCompilationInfo("\\G<%\\s*?=(?<code>.*?)?%>", 
                                                regexOptions, 
                                                "AspExprRegex",
                                                "System.Web.RegularExpressions",
                                                true);
            
            //databindExprRegex = new Regex("\\G<%#(?<code>.*?)?%>", regexOptions);
            regexes[5] = new RegexCompilationInfo("\\G<%#(?<code>.*?)?%>", 
                                                regexOptions, 
                                                "DatabindExprRegex",
                                                "System.Web.RegularExpressions",
                                                true);

            //commentRegex = new Regex("\\G<%--(([^-]*)-)*?-%>", regexOptions);
            regexes[6] = new RegexCompilationInfo("\\G<%--(([^-]*)-)*?-%>", 
                                                regexOptions, 
                                                "CommentRegex",
                                                "System.Web.RegularExpressions",
                                                true);

            //includeRegex = new Regex("\\G<!--\\s*#(?i:include)\\s*(?<pathtype>[\\w]+)\\s*=\\s*[\"']?(?<filename>[^\\\"']*?)[\"']?\\s*-->", regexOptions);
            regexes[7] = new RegexCompilationInfo("\\G<!--\\s*#(?i:include)\\s*(?<pathtype>[\\w]+)\\s*=\\s*[\"']?(?<filename>[^\\\"']*?)[\"']?\\s*-->", 
                                                regexOptions, 
                                                "IncludeRegex",
                                                "System.Web.RegularExpressions",
                                                true);

            //textRegex = new Regex("\\G[^<]+", regexOptions);
            regexes[8] = new RegexCompilationInfo("\\G[^<]+", 
                                                regexOptions, 
                                                "TextRegex",
                                                "System.Web.RegularExpressions",
                                                true);

            //gtRegex = new Regex("[^%]>", regexOptions);
            regexes[9] = new RegexCompilationInfo("[^%]>", 
                                                regexOptions, 
                                                "GTRegex",
                                                "System.Web.RegularExpressions",
                                                true);

            //ltRegex = new Regex("<", regexOptions);
            regexes[10] = new RegexCompilationInfo("<[^%]", 
                                                regexOptions, 
                                                "LTRegex",
                                                "System.Web.RegularExpressions",
                                                true);

            //serverTagsRegex = new Regex("<%(?!#)(([^%]*)%)*?>", regexOptions);
            regexes[11] = new RegexCompilationInfo("<%(?!#)(([^%]*)%)*?>", 
                                                regexOptions, 
                                                "ServerTagsRegex",
                                                "System.Web.RegularExpressions",
                                                true);

            //runatServerRegex = new Regex("runat\\W*server", regexNoCaseOptions);
            regexes[12] = new RegexCompilationInfo("runat\\W*server", 
                                                regexOptions | RegexOptions.IgnoreCase | RegexOptions.CultureInvariant, 
                                                "RunatServerRegex",
                                                "System.Web.RegularExpressions",
                                                true);

            //simpleDirectiveRegex = new Regex(directiveRegexString, regexOptions);
            regexes[13] = new RegexCompilationInfo(directiveRegexString, 
                                                regexOptions, 
                                                "SimpleDirectiveRegex",
                                                "System.Web.RegularExpressions",
                                                true);

            //databindRegex = new Regex(@"\G\s*<%\s*?#(?<code>.*?)?%>\s*\z", regexOptions);
            regexes[14] = new RegexCompilationInfo(@"\G\s*<%\s*?#(?<code>.*?)?%>\s*\z", 
                                                regexOptions, 
                                                "DataBindRegex",
                                                "System.Web.RegularExpressions",
                                                true);

            return regexes;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\state\blockmem.cxx ===
/**
 * tracker
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

#include "precomp.h"
#include "stweb.h"

#define MIN_BLOCK_SIZE      0X00000040  // 64 bytes
#define MAX_BLOCK_SIZE      0x00080000  // 512 K
#define HEAP_HEADER_SIZE    8

BlockMemHeapInfo BlockMem::s_heaps[NUM_HEAP_ENTRIES];
HANDLE BlockMem::s_lfh;

int
BlockMem::IndexFromSize(unsigned int size) {
    int             index;
    unsigned int    block;

    // set an initial block - with 2 extra checks we can
    // eliminate testing the top bits
    if ((size & 0xFFFF0000) != 0) {
        if ((size & 0xFF000000) != 0) {
            block = 0x80000000;
            index = 64;
        }
        else {
            block = 0x00800000;
            index = 48;
        }
    }
    else {
        if ((size & 0x0000FF00) != 0) {
            block = 0x00008000;
            index = 32;
        }
        else {
            block = 0x00000080;
            index = 16;
        }
    }

    while (block > size) {
        block >>= 1;
        index -= 2;
    }
    
    if (block < size) {
        index++;
        if (block + (block >> 1) < size) {
            index++;
        }
    }

    return index;
}

// Windows XP header definitions that we don't get
// because our build targets Windows2000
typedef enum _HEAP_INFORMATION_CLASS {

    HeapCompatibilityInformation

} HEAP_INFORMATION_CLASS;

typedef BOOL (WINAPI *PFN_HeapSetInformation) (
    IN HANDLE HeapHandle, 
    IN HEAP_INFORMATION_CLASS HeapInformationClass,
    IN PVOID HeapInformation OPTIONAL,
    IN SIZE_T HeapInformationLength OPTIONAL
    );

HRESULT
BlockMem::Init() {
    HRESULT         hr = S_OK;
    unsigned int    size, oldSize;
    int             index;
    int             minIndex;
    HANDLE          heap;
    int             i;
    BOOL            rc;
    ULONG           heapInformationValue;
    HMODULE         hmod;
    PFN_HeapSetInformation  pfnHeapSetInformation;


    // try to use the LFH
    rc = 0;
    hmod = LoadLibrary(L"kernel32.dll");
    if (hmod != NULL) {
        pfnHeapSetInformation = (PFN_HeapSetInformation) GetProcAddress(hmod, "HeapSetInformation");
        if (pfnHeapSetInformation != NULL) {
            s_lfh = HeapCreate(0, 0, 0);
            if (s_lfh != NULL) {
                heapInformationValue = 2;
                rc = (*pfnHeapSetInformation)(
                        s_lfh, HeapCompatibilityInformation, &heapInformationValue, sizeof(heapInformationValue));
            }
        }

        FreeLibrary(hmod);
    }

    // if can't use LFH, create our own
    if (rc == 0) {
        if (s_lfh != NULL) {
            HeapDestroy(s_lfh);
            s_lfh = NULL;
        }

        // Allocate heaps for each block size
        // Block sizes follow this pattern:
        //      0x10, 0x18, 0x20, 0x30, 0x40, 0x60, 0x80, 0xc0, 0x100, 0x180, ...
        // This gives an average of 15% wasted space across allocations

        oldSize = 0;
        size = MIN_BLOCK_SIZE;
        index = IndexFromSize(size);
        minIndex = index;

        while (size <= MAX_BLOCK_SIZE) {
            for (i = 0; i < 2; i++) {
                if (size <= MAX_BLOCK_SIZE) {
                    heap = HeapCreate(0, 0, 0);
                    ON_ZERO_EXIT_WITH_LAST_ERROR(heap);

                    s_heaps[index].heap = heap;
                    s_heaps[index].size = size;

                    if (i == 0) {
                        oldSize = size;
                        size |= (size >> 1);
                    }
                    else {
                        size = (oldSize << 1);
                    }

                    index++;
                }
            }
        }

        // Round up smallest allocations to MIN_BLOCK_SIZE
        for (i = 0; i < minIndex; i++) {
            s_heaps[i].heap = s_heaps[minIndex].heap; 
            s_heaps[i].size = s_heaps[minIndex].size;
        }

        // Use one heap for all items greater than MAX_BLOCK_SIZE,
        // which are allocated to their natural size rather than a block.
        // we hope there are not many allocations greater than MAX_BLOCK_SIZE
        heap = HeapCreate(0, 0, 0);
        ON_ZERO_EXIT_WITH_LAST_ERROR(heap);

        while (index < ARRAY_SIZE(s_heaps)) {
            s_heaps[index].heap = heap;
            s_heaps[index].size = ~0U; // marker for alloc to use natural size

            index++;
        }
    }

Cleanup:
    return hr;
}

void *  
BlockMem::Alloc(unsigned int size) {
    if (s_lfh != NULL) {
        return HeapAlloc(s_lfh, 0, size);
    }
    else {
        unsigned int    newSize;
        int             index;
        HANDLE          heap;
        HANDLE *        p;

        // Adjust size to account for heap handle
        newSize = size + sizeof(HANDLE);

        // We want allocations to line-up on block boundaries, 
        // so account for the fact that NT heap allocations have
        // an 8 byte header.
        index = IndexFromSize(newSize + HEAP_HEADER_SIZE);

        heap = s_heaps[index].heap;

        // Use the block size if not greater than MAX_BLOCK_SIZE
        if (s_heaps[index].size != ~0U) {
            newSize = s_heaps[index].size - HEAP_HEADER_SIZE;
        }

        // Allocate from the chosen heap
        p = (HANDLE *) HeapAlloc(heap, 0, newSize);
        if (p != NULL) {
            // Stuff in the heap handle and adjust pointer to alloc'd item
            *p = heap;
            p += 1;

        }

        return (void *) p;
    }
}

void
BlockMem::Free(void * p) {
    if (p != NULL) {
        if (s_lfh != NULL) {
            HeapFree(s_lfh, 0, p);
        }
        else {
            HANDLE *    ph;
            HANDLE      heap;

            // Retrieve the heap handle and adjust pointer
            ph = (HANDLE *) p;
            ph -= 1;
            heap = *ph;

            // Free the item
            HeapFree(heap, 0, ph);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\regiis\sources.inc ===
!include $(DNAROOT)\src\xsp\place.inc

!if "$(ASPNET_PRODUCT)" == "redist"
SYNCHRONIZE_BLOCK=1
!endif

TARGETNAME=$(ASPNET_NAME_PREFIX)regiis
TARGETPATH=$(O)
TARGETTYPE=PROGRAM

UMENTRY=wmain
UMTYPE=console

PRECOMPILED_CXX=1
PRECOMPILED_SHARED_INCLUDE=precomp.h
PRECOMPILED_SHARED_PCH=..\..\inc\$(ASPNET_PRODUCT)\$(O)\precomp.pch

TARGETLIBS= \
        $(SDK_LIB_PATH)\kernel32.lib            \
        $(SDK_LIB_PATH)\user32.lib              \
        $(SDK_LIB_PATH)\uuid.lib                \
        $(SDK_LIB_PATH)\ole32.lib               \
        $(SDK_LIB_PATH)\oleaut32.lib            \
        $(SDK_LIB_PATH)\advapi32.lib            \
        $(SDK_LIB_PATH)\comdlg32.lib            \
        $(SDK_LIB_PATH)\version.lib             \
        $(XSPBASEDIR)\isapi\$(ASPNET_PRODUCT)\$(O)\$(ASPNET_NAME_PREFIX)isapi.lib   \
        $(URTSDKTARGET)\lib\mscoree.lib         \

LINKLIBS=\
        $(XSPBASEDIR)\inc\$(ASPNET_PRODUCT)\$(O)\precomp.lib      \
        $(XSPBASEDIR)\util\$(ASPNET_PRODUCT)\$(O)\util.lib        \

SOURCES=                        \
        ..\regiis.rc            \
        ..\main.cxx             \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\regiis\main.cxx ===
/**
 * ASP.NET Tool main module.
 * 
 * Copyright (c) 1998 Microsoft Corporation
 */

#include "precomp.h"
#include "names.h"
#include "event.h"
#include "ndll.h"
#include <sddl.h>

DEFINE_DBG_COMPONENT(PRODUCT_STRING_L(regiis.exe));

HINSTANCE   GetRCInstance();

#define KEY_W3SVC           L"w3svc"

// Options
#define DO_UNDEFINED                    0x00000000
#define DO_HELP                         0x00000001
#define DO_UNINSTALL                    0x00000002
#define DO_INSTALL                      0x00000004
#define DO_REGISTER_ONLY                0x00000008
#define DO_REPLACE                      0x00000010
#define DO_REGSCRIPTMAP                 0x00000020
#define DO_REMOVEONPATH                 0x00000040
#define DO_VERSIONLIST                  0x00000080
#define DO_KEYLIST                      0x00000100
#define DO_COPYSCRIPTS                  0x00000200
#define DO_REMOVESCRIPTS                0x00000400
#define DO_NO_W3SVC_RESTART             0x00001000
#define DO_ENABLE                       0x00002000

// Extra information about an action
#define DO_EXTRA_NON_RECURSIVE          0x00000001
#define DO_EXTRA_ALL_VERSION            0x00000002


CHAR    g_VerA[MAX_PATH];
BOOL    g_fErrorPrinted = FALSE;
BOOL    g_fWrongParam = FALSE;
WCHAR  *g_KeyPath = NULL;
CHAR   *g_KeyPathA = NULL;
DWORD   g_dwActions = 0;
DWORD   g_dwExtra = 0;

HRESULT PrintWideStrAsDBCS(WCHAR *wszStr, CHAR *szFormat) {
    CHAR *  converted = NULL;
    HRESULT hr = S_OK;
    
    hr = WideStrToMultiByteStr(wszStr, &converted, CP_ACP);
    ON_ERROR_EXIT();

    printf(szFormat, converted);

Cleanup:
    delete [] converted;
    return hr;
}

HRESULT PrintString(DWORD id, CHAR *rgFillin[]) {
    DWORD   dwRet;
    HRESULT hr = S_OK;
    PVOID   pAllocText = NULL;
    DWORD   flags = FORMAT_MESSAGE_FROM_HMODULE|FORMAT_MESSAGE_ALLOCATE_BUFFER;

    if (rgFillin != NULL) {
        flags |= FORMAT_MESSAGE_ARGUMENT_ARRAY;
    }

    dwRet = FormatMessageA(flags,GetRCInstance(), id, 0, 
                    (LPSTR)&pAllocText, 0, (va_list *)rgFillin);
    ON_ZERO_EXIT_WITH_LAST_ERROR(dwRet);
    
    printf((LPSTR)pAllocText);

Cleanup:    
    LocalFree(pAllocText);

    return hr;
}

HRESULT PrintStringNoNewLine(DWORD id, CHAR *rgFillin[]) {
    DWORD   dwRet;
    HRESULT hr = S_OK;
    PVOID   pAllocText = NULL;
    DWORD   flags = FORMAT_MESSAGE_FROM_HMODULE|FORMAT_MESSAGE_ALLOCATE_BUFFER;
    CHAR *  pch;

    if (rgFillin != NULL) {
        flags |= FORMAT_MESSAGE_ARGUMENT_ARRAY;
    }
    
    dwRet = FormatMessageA(flags,GetRCInstance(), id, 0, 
                    (LPSTR)&pAllocText, 0, (va_list *)rgFillin);
    ON_ZERO_EXIT_WITH_LAST_ERROR(dwRet);

    // Take out the ending null
    pch = (CHAR*)pAllocText;
    while(*pch != '\0') {
        if (*pch == '\n' || *pch == '\r') {
            *pch = '\0';
            break;
        }

        pch++;
    }
    
    printf((LPSTR)pAllocText);

Cleanup:    
    LocalFree(pAllocText);

    return hr;
}

HRESULT PrintHelp()
{
    CHAR * rgFillin[] = { 
            g_VerA,
            VER_LEGALCOPYRIGHT_STR,
            PRODUCT_STRING(regiis.exe),
            PRODUCT_STRING(regiis.exe),
            PRODUCT_STRING(regiis.exe)
            };
    
    if (g_fWrongParam)
    {
        PrintString(IDS_REGIIS_INVALID_ARGUMENTS, NULL);
        g_fErrorPrinted = TRUE;
    }

    PrintString(IDS_REGIIS_USAGE, rgFillin);

    return S_OK;
}

HRESULT
CopyScripts() {
    HRESULT hr;
    CHAR * rgFillin[] = { g_VerA };
    
    PrintString(IDS_REGIIS_START_COPY_CLIENT_SIDE_SCRIPT_FILES, rgFillin);
    
    hr = CopyClientScriptFiles();
    ON_ERROR_EXIT();

    PrintString(IDS_REGIIS_FINISH_COPY_CLIENT_SIDE_SCRIPT_FILES, rgFillin);
    
Cleanup:
    return hr;
}

HRESULT
RemoveScripts() {    
    HRESULT hr;
    BOOL    fAll = !!(g_dwExtra & DO_EXTRA_ALL_VERSION);
    CHAR *  rgFillin[] = { g_VerA };

    if (fAll) {
        PrintString(IDS_REGIIS_START_REMOVE_CLIENT_SIDE_SCRIPT_FILES_ALL_VERSIONS, NULL);
    }
    else {
        PrintString(IDS_REGIIS_START_REMOVE_CLIENT_SIDE_SCRIPT_FILES, rgFillin);
    }
        
    hr = RemoveClientScriptFiles(fAll);
    ON_ERROR_EXIT();

    if (fAll) {
        PrintString(IDS_REGIIS_FINISH_REMOVE_CLIENT_SIDE_SCRIPT_FILES_ALL_VERSIONS, NULL);
   }
    else {
        PrintString(IDS_REGIIS_FINISH_REMOVE_CLIENT_SIDE_SCRIPT_FILES, rgFillin);
    }

Cleanup:
    return hr;
}


HRESULT
Uninstall() {    
    HRESULT hr;
    BOOL    fRestartW3svc = !(g_dwActions & DO_NO_W3SVC_RESTART);
    BOOL    fAll = !!(g_dwExtra & DO_EXTRA_ALL_VERSION);
    CHAR *  rgFillin[] = { g_VerA };

    if (fAll) {
        PrintString(IDS_REGIIS_START_UNINSTALL_ALL_VERSIONS, NULL);
    }
    else {
        PrintString(IDS_REGIIS_START_UNINSTALL, rgFillin);
    }

    hr = UnregisterISAPI(fAll, fRestartW3svc);
    ON_ERROR_EXIT();

    if (fAll) {
        PrintString(IDS_REGIIS_FINISH_UNINSTALL_ALL_VERSIONS, NULL);
    }
    else {
        PrintString(IDS_REGIIS_FINISH_UNINSTALL, rgFillin);
    }
    
Cleanup:
    return hr;
}


HRESULT Replace()
{
    DWORD dwFlags = ASPNET_REG_NO_VER_COMPARISON |
                    ASPNET_REG_RECURSIVE;
    BOOL    fRestartW3svc = !(g_dwActions & DO_NO_W3SVC_RESTART);
    HRESULT hr;
    CHAR *  rgFillin[] = { g_VerA };

    PrintString(IDS_REGIIS_START_REPLACE_SCRIPTMAPS, rgFillin);

    if (fRestartW3svc) {
        dwFlags |= ASPNET_REG_RESTART_W3SVC;
    }
    
    hr = RegisterISAPIEx(KEY_W3SVC, dwFlags);
    ON_ERROR_EXIT();
    
    PrintString(IDS_REGIIS_FINISH_REPLACE_SCRIPTMAPS, rgFillin);
    
Cleanup:
    return hr;
}

HRESULT Install(BOOL fSkipScriptmap)
{
    DWORD   dwFlags = ASPNET_REG_RECURSIVE;
    BOOL    fRestartW3svc = !(g_dwActions & DO_NO_W3SVC_RESTART);
    BOOL    fEnable = !!(g_dwActions & DO_ENABLE);

    if (fRestartW3svc) {
        dwFlags |= ASPNET_REG_RESTART_W3SVC;
    }

    if (fSkipScriptmap) {
        dwFlags |= ASPNET_REG_SKIP_SCRIPTMAP;
    }

    if (fEnable) {
        dwFlags |= ASPNET_REG_ENABLE;
    }

    return RegisterISAPIEx(KEY_W3SVC, dwFlags);
}

HRESULT
InstallASPNET() {    
    HRESULT hr;
    CHAR *  rgFillin[] = { g_VerA };

    PrintString(IDS_REGIIS_START_INSTALL, rgFillin);

    hr = Install(FALSE);
    ON_ERROR_EXIT();
    
    PrintString(IDS_REGIIS_FINISH_INSTALL, rgFillin);

Cleanup:
    return hr;
}


HRESULT
InstallASPNETwithNoSM() {    
    HRESULT hr;
    CHAR *  rgFillin[] = { g_VerA };

    PrintString(IDS_REGIIS_START_INSTALL_WITHOUT_SCRIPTMAPS, rgFillin);
    
    hr = Install(TRUE);
    ON_ERROR_EXIT();
    
    PrintString(IDS_REGIIS_FINISH_INSTALL_WITHOUT_SCRIPTMAPS, rgFillin);

Cleanup:
    return hr;
}

HRESULT DisplayInstalledVersion()
{
    ASPNET_VERSION_INFO *rgVerInfo = NULL;
    DWORD               dwCount, i;
    HRESULT             hr;
    DWORD               dwStatus;

    hr = ListAspnetInstalledVersions(&rgVerInfo, &dwCount);
    ON_ERROR_EXIT();

    if (dwCount == 0) {
        PrintString(IDS_REGIIS_CANNOT_FIND_ANY_INSTALLED_VERSION, NULL);
    }
    else {
        for (i=0; i < dwCount; i++) {
            wprintf(L"%s", rgVerInfo[i].Version);

            wprintf(L"\t");
            
            dwStatus = rgVerInfo[i].Status;

            if (!!(dwStatus & ASPNET_VERSION_STATUS_VALID)) {
                if (!!(dwStatus & ASPNET_VERSION_STATUS_ROOT)) {
                    PrintStringNoNewLine(IDS_REGIIS_VALID_ROOT, NULL);
                }
                else {
                    PrintStringNoNewLine(IDS_REGIIS_VALID, NULL);
                    wprintf(L"\t");
                }
            }
            else {
                PrintStringNoNewLine(IDS_REGIIS_INVALID, NULL);
                wprintf(L"\t");
            }
                
            wprintf(L"\t");

            hr = PrintWideStrAsDBCS(rgVerInfo[i].Path, "%s\n");
            ON_ERROR_EXIT();
        }
    }

Cleanup:
    LocalFree(rgVerInfo);
    return hr;
}

HRESULT DisplayInstalledKey()
{
    ASPNET_IIS_KEY_INFO *rgKeyInfo = NULL;
    DWORD               dwCount, i;
    HRESULT             hr;

    hr = ListAspnetInstalledIISKeys(&rgKeyInfo, &dwCount);
    ON_ERROR_EXIT();

    if (dwCount == 0) {
        PrintString(IDS_REGIIS_CANNOT_FIND_ANY_INSTALLED_VERSION, NULL);
    }
    else {
        for (i=0; i < dwCount; i++) {
            hr = PrintWideStrAsDBCS(rgKeyInfo[i].KeyPath, "%s");
            ON_ERROR_EXIT();

            wprintf(L"\t");
            
            wprintf(L"%s", rgKeyInfo[i].Version);

            wprintf(L"\n");
        }
    }

Cleanup:
    LocalFree(rgKeyInfo);
    return hr;
}


HRESULT RegScriptmap()
{
    HRESULT hr;
    BOOL    fValid;
    DWORD   dwFlags;
    BOOL    fRecursive = !(g_dwExtra & DO_EXTRA_NON_RECURSIVE);
    BOOL    fRestartW3svc = !(g_dwActions & DO_NO_W3SVC_RESTART);
    CHAR    error[30];
    CHAR *  rgFillin[] = { g_VerA, g_KeyPathA };
    CHAR *  rgFillin2[] = { g_KeyPathA, error };
    CHAR *  rgFillin3[] = { g_KeyPathA };

    if (fRecursive) {
        PrintString(IDS_REGIIS_START_REGISTER_SCRIPTMAP_RECURSIVELY, rgFillin);
    }
    else {
        PrintString(IDS_REGIIS_START_REGISTER_SCRIPTMAP, rgFillin);
    }

    hr = ValidateIISPath(g_KeyPath, &fValid);
    if (hr) {
        StringCchPrintfA(error, ARRAY_SIZE(error), "0x%08x", hr);
            
        PrintString(IDS_REGIIS_ERROR_VALIDATING_IIS_PATH, rgFillin2);
        
        g_fErrorPrinted = TRUE;
        EXIT();
    }

    if (!fValid) {
        PrintString(IDS_REGIIS_ERROR_IIS_PATH_INVALID, rgFillin3);
        
        g_fErrorPrinted = TRUE;
        EXIT_WITH_WIN32_ERROR(ERROR_PATH_NOT_FOUND);
    }
    
    dwFlags =   ASPNET_REG_NO_VER_COMPARISON |
                ASPNET_REG_SCRIPTMAP_ONLY;

    if (fRecursive) {
        dwFlags |= ASPNET_REG_RECURSIVE;
    }

    if (fRestartW3svc) {
        dwFlags |= ASPNET_REG_RESTART_W3SVC;
    }
    
    hr = RegisterISAPIEx(g_KeyPath, dwFlags);
    ON_ERROR_EXIT();

    if (fRecursive) {
        PrintString(IDS_REGIIS_FINISH_REGISTER_SCRIPTMAP_RECURSIVELY, rgFillin);
    }
    else {
        PrintString(IDS_REGIIS_FINISH_REGISTER_SCRIPTMAP, rgFillin);
    }

    
Cleanup:
    return hr;
}


HRESULT RemoveOnPath()
{
    HRESULT hr;
    BOOL    fValid;
    BOOL    fRecursive = !(g_dwExtra & DO_EXTRA_NON_RECURSIVE);
    CHAR    error[30];
    CHAR *  rgFillin[] = { g_KeyPathA };
    CHAR *  rgFillin2[] = { g_KeyPathA, error };
    CHAR *  rgFillin3[] = { g_KeyPathA };

    if (fRecursive) {
        PrintString(IDS_REGIIS_START_REMOVE_SCRIPTMAP_RECURSIVELY, rgFillin);
    }
    else {
        PrintString(IDS_REGIIS_START_REMOVE_SCRIPTMAP, rgFillin);
    }
    
    hr = ValidateIISPath(g_KeyPath, &fValid);
    if (hr) {
        StringCchPrintfA(error, ARRAY_SIZE(error), "0x%08x", hr);
            
        PrintString(IDS_REGIIS_ERROR_VALIDATING_IIS_PATH, rgFillin2);
        
        g_fErrorPrinted = TRUE;
        EXIT();
    }

    if (!fValid) {
        PrintString(IDS_REGIIS_ERROR_IIS_PATH_INVALID, rgFillin3);
        
        g_fErrorPrinted = TRUE;
        EXIT_WITH_WIN32_ERROR(ERROR_PATH_NOT_FOUND);
    }
    
    hr = RemoveAspnetFromIISKey(g_KeyPath, fRecursive);
    ON_ERROR_EXIT();
    
    if (fRecursive) {
        PrintString(IDS_REGIIS_FINISH_REMOVE_SCRIPTMAP_RECURSIVELY, rgFillin);
    }
    else {
        PrintString(IDS_REGIIS_FINISH_REMOVE_SCRIPTMAP, rgFillin);
    }
    
Cleanup:
    return hr;
}


typedef HRESULT (*ACTION_CALLBACK)();

typedef struct {
    DWORD           dwOption;               // The option specified by this command
    DWORD           dwExtraFlag;            // Extra information on top of option
    WCHAR *         pchOption;              // The string for this option
    ACTION_CALLBACK callback;               // Callback function to execute this option
    DWORD           dwCompatOptions;        // Other options compatible with this one
                                            // Ignored if callback == NULL
    UINT            uiPriority;             // If > 1 option is specified, option with a higher
                                            // priority will be executed first.  0 = highest
} OPTION_MAP;

OPTION_MAP  g_optionMap[] = {
    {   DO_HELP,            0,                      L"?",   PrintHelp,              0, 0 },
    {   DO_UNINSTALL,       0,                      L"u",   Uninstall,              DO_NO_W3SVC_RESTART, 0 },
    {   DO_INSTALL,         0,                      L"i",   InstallASPNET,          DO_NO_W3SVC_RESTART|DO_ENABLE, 0 },
    {   DO_REGISTER_ONLY,   0,                      L"ir",  InstallASPNETwithNoSM,  DO_NO_W3SVC_RESTART|DO_ENABLE, 0 },
    {   DO_REPLACE,         0,                      L"r",   Replace,                DO_NO_W3SVC_RESTART, 0 },      
    {   DO_REGSCRIPTMAP,    0,                      L"s",   RegScriptmap,           DO_NO_W3SVC_RESTART, 0 },
    {   DO_REMOVEONPATH,    0,                      L"k",   RemoveOnPath,           DO_NO_W3SVC_RESTART, 0 },
    {   DO_VERSIONLIST,     0,                      L"lv",  DisplayInstalledVersion,0, 0 },
    {   DO_KEYLIST,         0,                      L"lk",  DisplayInstalledKey,    0, 0 },
    {   DO_COPYSCRIPTS,     0,                      L"c",   CopyScripts,            0, 0 },
    {   DO_REMOVESCRIPTS,   0,                      L"e",   RemoveScripts,          0, 0 },
    {   DO_REGSCRIPTMAP,    DO_EXTRA_NON_RECURSIVE, L"sn",  RegScriptmap,           DO_NO_W3SVC_RESTART, 0 },
    {   DO_UNINSTALL,       DO_EXTRA_ALL_VERSION,   L"ua",  Uninstall,              DO_NO_W3SVC_RESTART, 0 },
    {   DO_REMOVEONPATH,    DO_EXTRA_NON_RECURSIVE, L"kn",  RemoveOnPath,           DO_NO_W3SVC_RESTART, 0 },
    {   DO_REMOVESCRIPTS,   DO_EXTRA_ALL_VERSION,   L"ea",  RemoveScripts,          0, 0 },
    {   DO_NO_W3SVC_RESTART,0,                      L"norestart",NULL,              0, 0 },
    {   DO_ENABLE,          0,                      L"enable",NULL,                 0, 0 },
};


void
GetOption(WCHAR *pchArg, DWORD *pdwOption, DWORD *pdwExtra) {
    *pdwOption = DO_UNDEFINED;
    *pdwExtra = 0;
    
    if (pchArg[0] != '-' &&
        pchArg[0] != '/') {
        return;
    }

    for (int i = 0; i < ARRAY_SIZE(g_optionMap); i++) {
        if (_wcsicmp(g_optionMap[i].pchOption, &(pchArg[1])) == 0) {
            *pdwOption = g_optionMap[i].dwOption;
            *pdwExtra = g_optionMap[i].dwExtraFlag;
            break;
        }
    }
    
    return;
}


BOOL
ActionsCompatible() {
    DWORD   dwTotalMask = 0;

    for (int i = 0; i < ARRAY_SIZE(g_optionMap); i++) {
        dwTotalMask |= g_optionMap[i].dwOption;
    }

    for (int i = 0; i < ARRAY_SIZE(g_optionMap); i++) {
        if (!!(g_dwActions & g_optionMap[i].dwOption) &&
            g_optionMap[i].callback != NULL) {
            // An action with a real callback is specified

            DWORD   dwIncompatMask;

            // Calculate the incompatible mask for this option
            // Don't forget that it's always compatible with itself
            dwIncompatMask = dwTotalMask & 
                    ~(g_optionMap[i].dwCompatOptions | g_optionMap[i].dwOption);

            // Make sure we don't have any incompatible option here
            if (!!(dwIncompatMask & g_dwActions)) {
                return FALSE;
            }
        }
    }

    return TRUE;
}


/**
 * Main function for ASP.NET Tool
 */
extern "C" int __cdecl
wmain(
    int argc, 
    WCHAR* argv[]
    )
{
    HRESULT hr = S_OK;
    DWORD   dwOption, dwExtra;
    
    CoInitializeEx(0, COINIT_MULTITHREADED);

    GetExistingVersion(g_VerA, MAX_PATH);

    if (argc == 1) {
        g_dwActions = DO_HELP;
    }
    else {
        for (int i = 1; i < argc; i++)
        {
            GetOption(argv[i], &dwOption, &dwExtra);

            // Make sure we have a valid argument
            if (dwOption == DO_UNDEFINED) {
                g_fWrongParam = TRUE;
                g_dwActions = DO_HELP;
                break;
            }
            
            // Special action on some options
            if (!!(dwOption & DO_REGSCRIPTMAP) ||
                !!(dwOption & DO_REMOVEONPATH)) {
                // For -s, -sn, -k and -kn, we need a path
                i++;
                if (i >= argc) {
                    g_fWrongParam = TRUE;
                    g_dwActions = DO_HELP;
                    break;
                }

                g_KeyPath = argv[i];
                hr = WideStrToMultiByteStr(g_KeyPath, &g_KeyPathA, CP_ACP);
                ON_ERROR_EXIT();
            }

            if (dwOption == DO_HELP) {
                g_dwActions = DO_HELP;
                break;
            }

            // Accumulate the options
            g_dwActions |= dwOption;
            g_dwExtra |= dwExtra;
        }
    }

    // Make sure all specified options are compatible with each other
    if (!ActionsCompatible()) {
        PrintString(IDS_REGIIS_ERROR_OPTIONS_INCOMPATIBLE, NULL);
        hr = S_OK;
        
        g_dwActions = 0;
    }

    // Execute all actions specified by the user
    while(1) {
        int i;
        
        for (i = 0; i < ARRAY_SIZE(g_optionMap); i++) {
            int     iExecute = -1;
            UINT    uiHighest = UINT_MAX;
            
            // See if g_dwActions contain a real action (.callback != null)
            if (g_optionMap[i].callback != NULL &&
                !!(g_dwActions & g_optionMap[i].dwOption)) {

                // We execute all options in the order of priority
                // Let's pick the one with highest priority. (zero = highest priority)
                if (g_optionMap[i].uiPriority < uiHighest) {
                    iExecute = i;
                    uiHighest = g_optionMap[i].uiPriority;
                }
            }

            if (iExecute != -1) {
                hr = (*(g_optionMap[iExecute].callback))();
                ON_ERROR_EXIT();

                // We are done with this action.
                g_dwActions &= (~g_optionMap[iExecute].dwOption);
            }
        }

        if (i == ARRAY_SIZE(g_optionMap)) {
            // no more action.
            break;
        }
    }


Cleanup:
    if (hr) {
        if (!g_fErrorPrinted) {
            CHAR    error[30];
            CHAR *  rgFillin[] = { error };
                
            StringCchPrintfA(error, ARRAY_SIZE(error), "0x%08x", hr);
            
            PrintString(IDS_REGIIS_ERROR, rgFillin);
        }
        
        switch (HRESULT_CODE(hr)) {
        case HRESULT_CODE(REGDB_E_CLASSNOTREG):
            PrintString(IDS_REGIIS_ERROR_IIS_NOT_INSTALLED, NULL);
            break;
            
        case ERROR_SERVICE_DISABLED:
            PrintString(IDS_REGIIS_ERROR_IIS_DISABLED, NULL);
            break;
            
        case ERROR_ACCESS_DENIED:
            PrintString(IDS_REGIIS_ERROR_NO_ADMIN_RIGHTS, NULL);
            break;
            
        case ERROR_PRODUCT_UNINSTALLED:
            PrintString(IDS_REGIIS_ERROR_ASPNET_NOT_INSTALLED, NULL);
            break;
        }
    }

    delete [] g_KeyPathA;
    
    CoUninitialize();
    return hr ? 1 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\xsp\state\readbuf.cxx ===
/**
 * readbuf.cxx
 * 
 * Copyright (c) 1998-1999, Microsoft Corporation
 * 
 */

#include "precomp.h"
#include "stweb.h"

/**
 *  The main function is to allocate the buffer
 */
HRESULT
ReadBuffer::Init(Tracker * ptracker, ReadBuffer * pReadBuffer, int * toread)
{
    HRESULT hr = S_OK;
    int     cchLeftover;

    _ptracker = ptracker;
    _contentLength = -1;
    _iContent = -1;
    _timeout = -1;
    _exclusive = -1;

    if (pReadBuffer != NULL)
    {
        cchLeftover = pReadBuffer->_cchHeaderRead - pReadBuffer->_iCurrent;
        *toread = (cchLeftover > 0) ? cchLeftover : -1;
    }
    else
    {
        cchLeftover = 0;
    }

    _cchHeader = max(cchLeftover, READ_BUF_SIZE);
    _achHeader = new char[_cchHeader + 1];
    ON_OOM_EXIT(_achHeader);

    if (cchLeftover > 0)
    {
        CopyMemory(_achHeader, &pReadBuffer->_achHeader[_iCurrent], cchLeftover + 1);
    }

Cleanup:
    return hr;
}


ReadBuffer::~ReadBuffer()
{
    delete [] _pwcUri;
    delete [] _achHeader;

    if (_psi != NULL) {
        _psi->Release();
    }
}


HRESULT
ReadBuffer::ParseHeader()
{
    HRESULT hr = S_OK;
    char    chContent;
    DWORD   verb1, verb2;
    char    *pchCurrent;
    DWORD   *pdwCurrent;
    char    *pchUri;
    char    *pchl;
    bool    doneWithHeaders;
    bool    foundHeader;

    chContent = _achHeader[_iContent];
    _achHeader[_iContent] = '\0';

    /*
     * Get the verb. If successful, pchCurrent is updated to point to uri;
     */
    pchCurrent = _achHeader;
    pdwCurrent = (DWORD *)(void*)pchCurrent;
    verb1 = *pdwCurrent++;
    switch (verb1)
    {
    case ' TEG':
        _verb = STATE_VERB_GET;
        pchCurrent += 4;
        break;

    case ' TUP':
        _verb = STATE_VERB_PUT;
        pchCurrent += 4;
        break;

    case 'ELED':
        verb2 = *pdwCurrent;
        if ((verb2 & 0x00FFFFFF) == '\0 ET')
        {
            _verb = STATE_VERB_DELETE;
            pchCurrent += 7;
            break;
        }

        EXIT_WITH_HRESULT(E_INVALIDARG);

    case 'DAEH':
        pchCurrent += 4;
        if (*pchCurrent == ' ')
        {
            _verb = STATE_VERB_HEAD;
            pchCurrent++;
            break;
        }

        EXIT_WITH_HRESULT(E_INVALIDARG);

    default:
        EXIT_WITH_HRESULT(E_INVALIDARG);
    }

    /*
     * Get the URI.
     */

    pchUri = pchCurrent;
    pchCurrent = strchr(pchUri, ' ');
    if (pchCurrent == NULL || pchCurrent == pchUri)
        EXIT_WITH_HRESULT(E_INVALIDARG);
        
    *pchCurrent = '\0';
    _pwcUri = DupStrW(pchUri);
    ON_OOM_EXIT(_pwcUri);
    *pchCurrent = ' ';

    /*
     * Verify version.
     */

    pchCurrent++;
    if (!STREQUALS(&pchCurrent, "HTTP/1.1\r\n"))
        EXIT_WITH_HRESULT(E_INVALIDARG);

    doneWithHeaders = false;
    do
    {
        foundHeader = false;
        switch (*pchCurrent)
        {
        case '\r':
            if (STREQUALS(&pchCurrent, "\r\n"))
            {
                /*
                 * End of headers.
                 */
                foundHeader = true;
                doneWithHeaders = true;
            }
            break;

        case 'C':
            if (STREQUALS(&pchCurrent, "Content-Length:"))
            {
                foundHeader = true;
                _contentLength = strtol(pchCurrent, &pchl, 10);
                if (_contentLength < 0 || _contentLength == LONG_MAX || pchl == pchCurrent)
                    EXIT_WITH_HRESULT(E_INVALIDARG);
    
                pchCurrent = pchl;
                if (!STREQUALS(&pchCurrent, "\r\n"))
                    EXIT_WITH_HRESULT(E_INVALIDARG);
            }
            break;

        case 'L':
            if (STREQUALS(&pchCurrent, "LockCookie:"))
            {
                foundHeader = true;
                _lockCookie = strtol(pchCurrent, &pchl, 10);
                if (_lockCookie < 0 || _lockCookie == LONG_MAX || pchl == pchCurrent)
                    EXIT_WITH_HRESULT(E_INVALIDARG);

                _lockCookieExists = 1;
                pchCurrent = pchl;
                if (!STREQUALS(&pchCurrent, "\r\n"))
                    EXIT_WITH_HRESULT(E_INVALIDARG);
            }
            break;

        case 'E':
            if (STREQUALS(&pchCurrent, "Exclusive: "))
            {
                foundHeader = true;
                if (STREQUALS(&pchCurrent, "acquire\r\n"))
                {
                    _exclusive = STATE_EXCLUSIVE_ACQUIRE;
                }
                else if (STREQUALS(&pchCurrent, "release\r\n"))
                {
                    _exclusive = STATE_EXCLUSIVE_RELEASE;
                }
                else
                {
                    EXIT_WITH_HRESULT(E_INVALIDARG);
                }
            }
            break;

        case 'T':
            if (STREQUALS(&pchCurrent, "Timeout:"))
            {
                foundHeader = true;
                _timeout = strtol(pchCurrent, &pchl, 10);
                if (_timeout < 0 || _timeout == LONG_MAX || pchl == pchCurrent)
                    EXIT_WITH_HRESULT(E_INVALIDARG);
    
                pchCurrent = pchl;
                if (!STREQUALS(&pchCurrent, "\r\n"))
                    EXIT_WITH_HRESULT(E_INVALIDARG);
            }
            break;
        }

        if (!foundHeader)
        {
            pchCurrent = strstr(pchCurrent, "\r\n");
            ASSERT(pchCurrent != NULL);
            ON_ZERO_EXIT_WITH_HRESULT(pchCurrent, E_UNEXPECTED);
            pchCurrent += 2;
        }
    }  while (!doneWithHeaders);

    /*
     * Validate headers.
     */
    switch (_verb)
    {
    case STATE_VERB_PUT:
        if (_contentLength <= 0)
            EXIT_WITH_HRESULT(E_INVALIDARG);

        break;

    default:
        if (_contentLength > 0)
            EXIT_WITH_HRESULT(E_INVALIDARG);

        break;
    }

Cleanup:
    _achHeader[_iContent] = chContent;
    return hr;
}

/**
 * Params:
 *  numBytes    # of bytes of new data read from socket
 *              -1 means WSARecv isn't called yet.
 *
 * Returns:
 *  S_OK        No more to read
 *  S_FALSE     More to read.
 */
HRESULT
ReadBuffer::ReadRequest(DWORD numBytes) 
{
    HRESULT hr = S_OK;
    void *  pvRead = NULL;
    int     cbNeeded = -1;  // # of bytes to read in the next call to Tracker::Read
    char *  pchEndOfHeader;
    int     cchContentInHeader;
    char *  pchOldHeader = NULL;

    if (numBytes == 0)
    {
        /*
         * The connection has been gracefully closed. Return an 
         * error so we close too.
         */
        hr = HRESULT_FROM_WIN32(ERROR_GRACEFUL_DISCONNECT);
        goto Cleanup;
    }

    /*
     * Parse the bytes read so far. numBytes is -1 on the 
  