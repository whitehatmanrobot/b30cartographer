            {
                //
                // Both diffs >= 100.
                //
                bCompareByName = true;
            }
            if (bCompareByName)
            {
                goto CompareNames;
            }
            else
            {
                //
                // Diffs aren't in the same range so sort
                // based on the difference between the two fonts.
                //
                iRet = nDiff1 - nDiff2;
            }
        }

        break;
    }


ReturnCompareResult:

    if (!m_bSortAscending && !bNoNegateResult)
    {
        //
        // Sort descending.  Invert comparison result.
        //
        iRet *= -1;
    }
    return iRet;
}



int CFontView::RegisterWindowClass( )
{
    DEBUGMSG( (DM_TRACE2, TEXT( "FONTEXT: CFontView::RegisterWindowClass" ) ) );
    WNDCLASS wndclass;

    //
    //  If the class was already regestered return success
    //

    if( GetClassInfo( g_hInst, g_szViewClass, &wndclass ) )
    {
       DEBUGMSG( (DM_TRACE2, TEXT( "FONTEXT: CFontView - class already regestered" ) ) );
       return( 1 );
    }

    wndclass.style         = CS_PARENTDC | CS_DBLCLKS;
    wndclass.lpfnWndProc   = FontViewWndProc;
    wndclass.cbClsExtra    = 0;
    wndclass.cbWndExtra    = DLGWINDOWEXTRA;

    wndclass.hInstance     = g_hInst;
    wndclass.hIcon         = NULL;
    wndclass.hCursor       = LoadCursor( NULL, IDC_ARROW );
    wndclass.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
    wndclass.lpszMenuName  = NULL;
    wndclass.lpszClassName = g_szViewClass;

    return( RegisterClass( &wndclass ) );
}


void CFontView::SortObjects( )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "CFontView::SortObjects called" ) ) );
    // DEBUGBREAK;

    ListView_SortItems( m_hwndList, iCompare, ( LPARAM)this );

    DEBUGMSG( (DM_TRACE1, TEXT( "CFontView::SortObjects done" ) ) );
}

void CFontView::FillObjects( )
{
    HCURSOR hCurs;
    SHELLSTATE ss;
    DWORD fShellState = SSF_SHOWALLOBJECTS;

    hCurs = SetCursor( LoadCursor( NULL, IDC_WAIT ) );

    //
    // Retrieve the "Show compressed files in alternate color" shell setting.
    // Do this here so we respond to the user changing this setting in View-Options.
    //
    fShellState |= SSF_SHOWCOMPCOLOR;

    SHGetSetSettings(&ss, fShellState, FALSE);
    m_bShowHiddenFonts = ss.fShowAllObjects;
    m_bShowCompColor = ss.fShowCompColor;

    if( m_bFamilyOnly )
    {
        if (!m_poFontManager->bWaitOnFamilyReset( ))
        {
            //
            // Got a "terminate" signal while waiting on the
            // family reset thread.  Don't continue.
            //
            return;
        }
    }

    CFontList * poList = m_poFontManager->poLockFontList( );

    //
    //  The current selection.
    //

    CFontList * poSel;

    SendMessage( m_hwndList, WM_SETREDRAW, FALSE, 0 );

    //
    //  Save the current selection, if any, off.
    //
    if( FAILED( GetFontList( &poSel, SVGIO_SELECTION ) ) )
        poSel = 0;

    //
    // Call CFontClass::Release for all font objects contained in the ListView.
    //
    ReleaseFontObjects();

    ListView_DeleteAllItems( m_hwndList );

    m_iHidden = 0;

    if( poList )
    {
        int iCount = poList->iCount( );
        CFontClass * poFont;

        //
        //  Tell the ListView how many objects we have.
        //
        ListView_SetItemCount( m_hwndList, iCount );

        DEBUGMSG( (DM_TRACE1, TEXT( "FillObjects..." ) ) );

        for( int i = 0; i < iCount; i++)
        {
            poFont = poList->poObjectAt( i );
            if (poFont)
            {
                if (m_bShowHiddenFonts || 0 == (FILE_ATTRIBUTE_HIDDEN & poFont->dwGetFileAttributes()))
                {
                    if( !m_bFamilyOnly || poFont->bFamilyFont( ) )
                        AddObject( poFont );
                    else
                        m_iHidden++;
                }
            }
        }

        DEBUGMSG( (DM_TRACE1, TEXT( "   ...donE\n" ) ) );

        m_poFontManager->vReleaseFontList( );
    }

    SortObjects( );

    //
    //  Reselect the items that were selected before.
    //

    UINT  nState;

    if(poSel)
    {
        if (poSel->iCount())
        {
            int iCount = poSel->iCount( );
            int i;
            int idx;
            LV_FINDINFO lvf;

            lvf.flags = LVFI_PARAM;

            for( i = 0; i < iCount; i++ )
            {
                lvf.lParam = (LPARAM) poSel->poObjectAt( i );
                if( ( idx = ListView_FindItem( m_hwndList, -1, &lvf ) ) > (-1) )
                {
                    nState = ListView_GetItemState( m_hwndList, idx, LVIS_SELECTED );
                    nState |= LVIS_SELECTED;

                    ListView_SetItemState( m_hwndList, idx, nState, LVIS_SELECTED );

                    if( !i )
                        ListView_EnsureVisible( m_hwndList, idx, TRUE );
                }
            }

            poSel->vDetachAll( );
        }
        delete poSel;
    }
    else
    {
        ListView_SetItemState( m_hwndList, 0, LVIS_FOCUSED, LVIS_FOCUSED );
    }

    SendMessage( m_hwndList, WM_SETREDRAW, TRUE, 0 );

    int ciParts[] = {-1};

    LRESULT lRet;

    m_psb->SendControlMsg( FCW_STATUS, SB_SETPARTS,
                           sizeof( ciParts )/sizeof( ciParts[ 0 ] ),
                           (LPARAM)ciParts, &lRet );

    UpdateSelectedCount( );

    SetCursor( hCurs );
}


int CFontView::AddObject( CFontClass * poFont )
{
    LV_ITEM item;

    // DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT:AddObject" ) ) );
    // DEBUGBREAK;


#ifdef _DEBUG
    if( !poFont )
    {
        DEBUGMSG( ( DM_ERROR, TEXT( "AddObject() -- poFont is NULL!" ) ) );
        DEBUGBREAK;
    }
#endif

    poFont->AddRef();  // ListView will hold a pointer.

    item.mask     = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    item.iItem    = 0x7fff;     // add at end
    item.iSubItem = 0;

    item.iImage  = ItemImageIndex(poFont);
    item.pszText = LPSTR_TEXTCALLBACK;
    item.lParam  = (LPARAM) poFont;

    //
    //  If the file isn't in the fonts dir, make it look like a link.
    //
    item.state     = 0;
    item.stateMask = LVIS_OVERLAYMASK;

    if( !poFont->bOnSysDir( ) )
        item.state |= INDEXTOOVERLAYMASK( 1 );

    return( ListView_InsertItem( m_hwndList, &item ) );
}


HRESULT  CFontView::GetUIObjectFromItem( REFIID riid,
                                         LPVOID FAR *ppobj,
                                         UINT nItem )
{
    CFontData * poData;
    CFontList * poList;

    HRESULT  hr = GetFontList( &poList, nItem );

    *ppobj = 0;

    if( SUCCEEDED( hr ) )
    {
       hr = E_OUTOFMEMORY;
       poData = new CFontData;

       if(poData)
       {
           if (poData->bInit(poList))
           {
              poData->AddRef( );
              hr = poData->QueryInterface( riid, ppobj );
              poData->Release( );
           }
           else
           {
              delete poData;
           }
       }
       if (FAILED(hr))
       {
           delete poList;
       }
    }
    return hr;
}

LRESULT CFontView::BeginDragDrop( NM_LISTVIEW FAR * lpn )
{
    LPDATAOBJECT   pdtobj;
    POINT          ptOffset = lpn->ptAction;
    DWORD          dwEffect = DROPEFFECT_MOVE | DROPEFFECT_COPY | DROPEFFECT_LINK;
    CFontList *    poList   = 0;


    //
    //  Store the fact that we started in our window.
    //

    m_bDragSource = TRUE;

    //
    //  Save the anchor point.
    //
       // todo

    //
    //  Get the screen point.
    //

    ClientToScreen( m_hwndList, &ptOffset );


    if(SUCCEEDED(GetUIObjectFromItem(IID_IDataObject,
                                     (void **)&pdtobj,
                                     SVGIO_SELECTION)))
    {
        IDragSourceHelper* pDragSource;
        HRESULT hr = SHCoCreateInstance(NULL,
                                        &CLSID_DragDropHelper,
                                        NULL,
                                        IID_IDragSourceHelper,
                                        (void **)&pDragSource);
        if (SUCCEEDED(hr))
        {
            hr = pDragSource->InitializeFromWindow(m_hwndList, &ptOffset, pdtobj);
            pDragSource->Release();
            
            if (SUCCEEDED(hr))
            {
                CFontData *pFontData = (CFontData *)pdtobj;
                //
                //  If we're going to allow a move, then we have to remove the font
                //  from GDI. Otherwise the move will fail 'cause GDI has the
                //  the file open/locked.
                //
                pFontData->bRFR( );
                pFontData->SetPreferredDropEffect(DROPEFFECT_MOVE);
                pFontData->SetPerformedDropEffect(DROPEFFECT_NONE);
                pFontData->SetLogicalPerformedDropEffect(DROPEFFECT_NONE);

                SHDoDragDrop( m_hwndView, pdtobj, NULL, dwEffect, &dwEffect );

                if( DROPEFFECT_MOVE == pFontData->GetLogicalPerformedDropEffect())
                {
                    m_poFontManager->vToBeRemoved(pFontData->poCloneList());
                }
                else
                {
                    pFontData->bAFR( );
                }
            }
       }

       DAD_SetDragImage( NULL, NULL );
       pdtobj->Release( );
    }

    m_bDragSource = FALSE;

    return 0;
}



int CFontView::OnActivate( UINT uState )
{
    if( m_uState != uState )
    {
        HMENU hMenu;

        OnDeactivate( );

        hMenu = CreateMenu( );

        if( hMenu )
        {
            HMENU hMergeMenu;
            OLEMENUGROUPWIDTHS mwidth = { { 0, 0, 0, 0, 0, 0 } };

            m_hmenuCur = hMenu;
            m_psb->InsertMenusSB( hMenu, &mwidth );

            if( uState == SVUIA_ACTIVATE_FOCUS )
            {
                hMergeMenu = LoadMenu( g_hInst,
                                       MAKEINTRESOURCE( MENU_DEFSHELLVIEW ) );

                if( hMergeMenu )
                {
                      MergeFileMenu( hMenu, GetSubMenu( hMergeMenu, 0 ) );
                      MergeEditMenu( hMenu, GetSubMenu( hMergeMenu, 1 ) );
                      MergeViewMenu( hMenu, GetSubMenu( hMergeMenu, 2 ) );
                      MergeHelpMenu( hMenu, GetSubMenu( hMergeMenu, 3 ) );
                      DestroyMenu( hMergeMenu );
                }
            }
            else
            {
                //
                //  SVUIA_ACTIVATE_NOFOCUS
                //

                hMergeMenu = LoadMenu( g_hInst,
                                       MAKEINTRESOURCE( MENU_DEFSHELLVIEW ) );

                if( hMergeMenu )
                {
                   MergeFileMenu( hMenu, GetSubMenu( hMergeMenu, 0 ) );
                   MergeEditMenu( hMenu, GetSubMenu( hMergeMenu, 1 ) );
                   MergeViewMenu( hMenu, GetSubMenu( hMergeMenu, 2 ) );
                   MergeHelpMenu( hMenu, GetSubMenu( hMergeMenu, 3 ) );
                   DestroyMenu( hMergeMenu );
                }
            }
            BOOL bRemovePreviewMenuItem = (CLICKMODE_DOUBLE == m_iViewClickMode);

            if (bRemovePreviewMenuItem)
            {
                //
                // If Tooltip font samples are not in the build, or if
                // the view is in double-click (std windows) mode, we need
                // to remove the "Preview" item from the "View" menu.
                //
                HMENU hmenuView = GetSubMenu(hMenu, 2);
                if (NULL != hmenuView)
                    DeleteMenu(hmenuView, IDM_VIEW_PREVIEW, MF_BYCOMMAND);
            }

            m_psb->SetMenuSB( hMenu, NULL, m_hwndView );
        }

        m_uState = uState;
    }

    return( 1 );
}


int CFontView::OnDeactivate( )
{
    if( m_uState != SVUIA_DEACTIVATE )
    {
        m_psb->SetMenuSB( NULL, NULL, NULL );
        m_psb->RemoveMenusSB( m_hmenuCur );

        DestroyMenu( m_hmenuCur );

        m_hmenuCur = NULL;
        m_uState = SVUIA_DEACTIVATE;
    }

    return( 1 );
}


int CFontView::MergeToolbar( )
{
    static TBBUTTON tbButtons[] = {
       {0,    IDM_VIEW_ICON,    TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0, 0, -1 /* IDS_TB_FONTS */ },
       {1,    IDM_VIEW_LIST,    TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0, 0, -1 /* IDS_TB_FAMILY */ },
       {2,    IDM_VIEW_PANOSE,  TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0, 0, -1 /* IDS_TB_FAMILY */ },
       {3,    IDM_VIEW_DETAILS, TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0, 0, -1 /* IDS_TB_PANOSE */ }
     };

#define BUTTONCOUNT (sizeof( tbButtons ) / sizeof( TBBUTTON ) )


    //
    //  Add the bitmaps to the cabinet's toolbar (when do we remove them?)
    //


    TBADDBITMAP tbad;

    tbad.hInst = g_hInst;
    tbad.nID   = IDB_TOOLICONS;

    m_psb->SendControlMsg( FCW_TOOLBAR, TB_ADDBITMAP, 7,
                           (LPARAM) &tbad, (LRESULT*) &m_iFirstBitmap );

    DEBUGMSG( (DM_TRACE2, TEXT( "FONTEXT: CFontView::MergeToolbar iFirstBitmap = %d" ),
              m_iFirstBitmap ) );

    //
    //  set the buttons' bitmap indexes then add them to the toolbar
    //

    int i, iSepCount;

    for( i = 0, iSepCount = 0; i < BUTTONCOUNT; i++ )
    {
        if( tbButtons[ i ].fsStyle != TBSTYLE_SEP )
            tbButtons[ i ].iBitmap = i + m_iFirstBitmap - iSepCount;
        else
            iSepCount++;
    }

    m_psb->SetToolbarItems( tbButtons, BUTTONCOUNT, /* FCT_ADDTOEND */ FCT_MERGE );

    return( 1 );
}


#define MAX_FONTSIGNATURE         16   // length of font signature string

INT_PTR CALLBACK CFontView::FontViewDlgProc( HWND hWnd,
                                             UINT message,
                                             WPARAM wParam,
                                             LPARAM lParam )
{
    switch( message )
    {
    case WM_INITDIALOG:
        {
        DEBUGMSG( (DM_MESSAGE_TRACE1,
                  TEXT( "FONTEXT: FontViewWndProc WM_INITDIALOG" ) ) );


       CFontView* prv = (CFontView*)lParam;

#ifdef _DEBUG

        if( !prv )
        {
            DEBUGMSG( (DM_ERROR,TEXT( "FONTEXT: WM_CREATE: Invalid prv" ) ) );
            DEBUGBREAK;
        }
#endif

        SetWindowLongPtr( hWnd, DWLP_USER, (LONG_PTR) prv );

        prv->m_hwndView = hWnd;
        prv->m_hwndList = CreateWindowEx(
                                   WS_EX_CLIENTEDGE,
                                   WC_LISTVIEW, TEXT( "A List View" ),
                                   WSFromViewMode( prv->m_idViewMode ),
                                   0, 0, 50, 50,
                                   hWnd, (HMENU) WID_LISTVIEW, g_hInst, NULL );


        if( !prv->m_hwndList )
        {
           DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: ListView CreateWindowEx failed" ) ) );
           return( 0 );
        }

        prv->m_dwDateFormat = FDTF_DEFAULT;

        WORD  wLCIDFontSignature[MAX_FONTSIGNATURE];
        //
        // Let's verify this is a RTL (BiDi) locale. call GetLocaleInfo with
        // LOCALE_FONTSIGNATURE which always gives back 16 WORDs.
        //
        if( GetLocaleInfo( GetUserDefaultLCID() ,
                         LOCALE_FONTSIGNATURE ,
                         (LPTSTR) wLCIDFontSignature ,
                         ARRAYSIZE(wLCIDFontSignature)) )
        {
            // Let's verify the bits we have a BiDi UI locale
            // see \windows\winnls\data\other\locale.txt                          ****
            // FONTSIGNATURE          \x60af\x8000\x3848\x1000\x0008\x0000\x0000\x0800\x0040\x0000\x0000\x2000\x0040\x0000\x0000\x2008
            // if this locale is BiDi UI the 8h word will be 0x0800 else it will be 0x0000 and it does not have any #define name.

            if( wLCIDFontSignature[7] & 0x0800 )
            {
                //Get the real list view windows ExStyle.
                DWORD dwLVExStyle = GetWindowLong(prv->m_hwndList, GWL_EXSTYLE);
                if ((BOOLIFY(dwLVExStyle & WS_EX_RTLREADING)) != (BOOLIFY(dwLVExStyle & WS_EX_LAYOUTRTL)))
                    prv->m_dwDateFormat |= FDTF_RTLDATE;
                else
                    prv->m_dwDateFormat |= FDTF_LTRDATE;
            }
         }

        //
        // Set the listview click mode to conform to the user's preference settings
        // in the shell.  Can be either CLICKMODE_SINGLE or CLICKMODE_DOUBLE.
        //
        prv->SetListviewClickMode();

        prv->m_hAccel = LoadAccelerators( g_hInst, MAKEINTRESOURCE( ACCEL_DEF ) );

        //
        //  Create the ComboBox
        //

        prv->m_hwndCombo = GetDlgItem( hWnd, ID_CB_PANOSE );

        //
        //  Remember the default size of the combo. We won't resize it to
        //  anything bigger than this.

        {
            RECT r;

            GetClientRect( prv->m_hwndCombo, &r );
            prv->m_nComboWid = r.right - r.left;
        }

        //
        //  Create the Text description for the combo box
        //

        prv->m_hwndText = GetDlgItem( hWnd, ID_TXT_SIM );

        int IDC_NUMITEMS (IDI_LASTFONTICON - IDI_FIRSTFONTICON + 1);

        UINT uFlags = ILC_MASK | ILC_COLOR32;

        if ( GetWindowLongPtr(prv->m_hwndList , GWL_EXSTYLE) & WS_EX_LAYOUTRTL )
        {
             uFlags |= ILC_MIRROR;
        }
        
        prv->m_hImageList = ImageList_Create( 32, 32, uFlags, IDC_NUMITEMS, 0 );
        prv->m_hImageListSmall = ImageList_Create( 16, 16, uFlags, IDC_NUMITEMS, 0 );

        //
        //  Load our icons.
        //

        HICON hIcon;
        HICON hIconSmall;
        UINT  i;

        for(  i = IDI_FIRSTFONTICON; i <= IDI_LASTFONTICON; i++ )
        {
            hIcon = (HICON) LoadImage( g_hInst, MAKEINTRESOURCE( i ),
                                       IMAGE_ICON, 0, 0,
                                       LR_DEFAULTCOLOR | LR_DEFAULTSIZE );
            if( hIcon )
            {
               ImageList_AddIcon( prv->m_hImageList, hIcon );

               hIconSmall = (HICON) LoadImage( g_hInst, MAKEINTRESOURCE( i ),
                                               IMAGE_ICON, 16, 16,
                                               LR_DEFAULTCOLOR );

               if( hIconSmall )
               {
                    ImageList_AddIcon( prv->m_hImageListSmall, hIconSmall );
                    DestroyIcon( hIconSmall );
               }

               DestroyIcon( hIcon );
            }
        }

        //
        //  Extract the link icon from SHELL32.DLL
        //

        ExtractIconEx( TEXT( "SHELL32.DLL" ), IDI_X_LINK - 1, &hIcon,
                       &hIconSmall, 1 );

        if( hIcon )
        {
            ImageList_AddIcon( prv->m_hImageList, hIcon );
            DestroyIcon( hIcon );

            if( hIconSmall )
            {
                ImageList_AddIcon( prv->m_hImageListSmall, hIconSmall );
                DestroyIcon( hIconSmall );
            }
            IDC_NUMITEMS++;  // Add 1 for "link" icon.
        }

        //
        //  Specify the overlay images.
        //

        ImageList_SetOverlayImage( prv->m_hImageList, IDC_NUMITEMS - 1, 1 );
        ImageList_SetOverlayImage( prv->m_hImageListSmall, IDC_NUMITEMS - 1, 1 );

        ListView_SetImageList( prv->m_hwndList, prv->m_hImageList, LVSIL_NORMAL );
        ListView_SetImageList( prv->m_hwndList, prv->m_hImageListSmall, LVSIL_SMALL );

        ListView_SetExtendedListViewStyleEx(prv->m_hwndList, 
                                            LVS_EX_LABELTIP, 
                                            LVS_EX_LABELTIP);

#undef IDC_NUMITEMS

        DEBUGMSG( (DM_MESSAGE_TRACE1, TEXT( "FONTEXT: FontViewWndProc WM_INITDIALOG" ) ) );

        //
        //  We need to retrieve more information if we are in details or
        //  panose view.
        //

        if( prv->m_idViewMode == IDM_VIEW_PANOSE )
        {
            prv->vLoadCombo( );
            SetListColumns( prv->m_hwndList, PAN_COL_COUNT, PanoseColumns );
            prv->UpdatePanColumn( );
        }
        else if( prv->m_idViewMode == IDM_VIEW_DETAILS )
        {
            SetListColumns( prv->m_hwndList, FILE_COL_COUNT, FileColumns );
        }

        //
        // Create and initialize the tooltip window.
        //
        prv->CreateToolTipWindow();

        //
        // Register with the shell for file-attribute change notifications.
        //
        SHChangeNotifyEntry fsne;
        fsne.pidl        = NULL;
        fsne.fRecursive  = FALSE;

        prv->m_uSHChangeNotifyID = SHChangeNotifyRegister(prv->m_hwndView,
                                                          SHCNRF_NewDelivery | SHCNRF_ShellLevel,
                                                          SHCNE_UPDATEIMAGE | SHCNE_DISKEVENTS,
                                                          WM_SHELL_CHANGE_NOTIFY,
                                                          1,
                                                          &fsne);

        SetWindowPos(prv->m_hwndCombo,
                     prv->m_hwndList,
                     0, 0, 0, 0,
                     SWP_NOSIZE |
                     SWP_NOMOVE);

        //
        //  Return 0 so SetFocus() doesn't get called.
        //

        return( 0 );
        }
        break;

    default:
        break;
    }

    return( 0 );
}


LRESULT CALLBACK CFontView::FontViewWndProc( HWND hWnd,
                                             UINT message,
                                             WPARAM wParam,
                                             LPARAM lParam )
{
    DEBUGMSG( (DM_MESSAGE_TRACE2, TEXT( "FONTEXT: FontViewWndProc Called m=0x%x wp=0x%x lp=0x%x" ),
              message, wParam, lParam) );

    CFontView* prv = (CFontView*) GetWindowLongPtr( hWnd, DWLP_USER );

    //
    //  'prv' won't be valid for any messages that comes before WM_CREATE
    //

    if( prv )
        return( prv->ProcessMessage( hWnd, message, wParam, lParam ) );
    else
        return( DefDlgProc( hWnd, message, wParam, lParam ) );

    return( 0 );
}


typedef struct {
   UINT  nMenuID;
   UINT  nStatusID;
} MENU_STATUS;


const MENU_STATUS MenuStatusMap[] = {
   {IDM_FILE_SAMPLE     , IDST_FILE_SAMPLE    },
   {IDM_FILE_PRINT      , IDST_FILE_PRINT     },
   {IDM_FILE_INSTALL    , IDST_FILE_INSTALL   },
   {IDM_FILE_LINK       , IDST_FILE_LINK      },
   {IDM_FILE_DEL        , IDST_FILE_DEL       },
   {IDM_FILE_RENAME     , IDST_FILE_RENAME    },
   {IDM_FILE_PROPERTIES , IDST_FILE_PROPERTIES},

   {IDM_EDIT_SELECTALL   , IDST_EDIT_SELECTALL    },
   {IDM_EDIT_SELECTINVERT, IDST_EDIT_SELECTINVERT },
   {IDM_EDIT_CUT         , IDST_EDIT_CUT          },
   {IDM_EDIT_COPY        , IDST_EDIT_COPY         },
   {IDM_EDIT_PASTE       , IDST_EDIT_PASTE        },
   {IDM_EDIT_UNDO        , IDST_EDIT_UNDO         },

   {IDM_VIEW_ICON       , IDST_VIEW_ICON    },
   {IDM_VIEW_LIST       , IDST_VIEW_LIST    },
   {IDM_VIEW_PANOSE     , IDST_VIEW_PANOSE  },
   {IDM_VIEW_DETAILS    , IDST_VIEW_DETAILS },

   {IDM_VIEW_VARIATIONS , IDST_VIEW_VARIATIONS },
   {IDM_VIEW_PREVIEW    , IDST_VIEW_PREVIEW },

   {IDM_HELP_TOPIC      , IDST_HELP_TOPICS },

   // THIS MUST BE LAST !!!!!!
   //
   {IDX_NULL, 0}

};


//
//  This is to put messages in the status bar
//

int CFontView::OnMenuSelect( HWND hWnd,
                             UINT nID,      // Menu item or Popup menu id
                             UINT nFlags,   // Menu flags
                             HMENU hMenu )  // HANDLE of menu clicked.
{
    UINT  nStat = IDX_NULL;

    //
    //  Is the menu closing? i.e. the user pressed escape.
    //

    if( (LOWORD( nFlags ) == 0xffff ) && (hMenu == 0 ) )
    {
            StatusPop( );
            return( 0 );
    }

    //
    //  What to do if this is a popup?
    //

    if( !(nFlags & MF_POPUP ) )
    {
        const MENU_STATUS * pms = MenuStatusMap;

        //
        //  Walk the id to status map
        //

        for(  ; pms->nMenuID != IDX_NULL; pms++ )
        {
            if( pms->nMenuID == nID )
            {
               nStat = pms->nStatusID;
               break;
            }
        }
    }

    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: OnMenuSelect: MenuID: %d   StatusID: %d" ),
               nID, nStat) );

    if( nStat == IDX_NULL )
    {
       StatusClear( );
    }
    else
    {
       StatusPush( nStat );
    }

    return( 0 );
}


inline int InRange( UINT id, UINT idFirst, UINT idLast )
{
    return( (id-idFirst) <= (idLast-idFirst) );
}


int CFontView::OnCommand( HWND hWnd,
                          UINT message,
                          WPARAM wParam,
                          LPARAM lParam )
{
    DEBUGMSG( (DM_MESSAGE_TRACE1, TEXT( "FONTEXT: CFontView::OnCommand Called m=0x%x wp=0x%x lp=0x%x" ),
             message, wParam, lParam) );

    HMENU hMenu = m_hmenuCur;
    UINT uID = GET_WM_COMMAND_ID( wParam, lParam );


    switch( uID )
    {
    case IDM_FILE_DEL:
        OnCmdDelete( );
        break;

    case IDM_EDIT_CUT:
    case IDM_EDIT_COPY:
        OnCmdCutCopy( uID );
        break;

    case IDM_EDIT_PASTE:
        OnCmdPaste( );
        break;

    case ID_CB_PANOSE:
        switch( GET_WM_COMMAND_CMD( wParam, lParam ) )
        {
        case CBN_SELCHANGE:
            {
            DEBUGMSG( (DM_TRACE1,TEXT( "CBN_SELCHANGE" ) ) );

            int iSlot = (int)::SendMessage( m_hwndCombo,  CB_GETCURSEL, 0, 0 );

            if( iSlot != CB_ERR )
                m_poPanose = (CFontClass *)::SendMessage( m_hwndCombo,
                                                          CB_GETITEMDATA,
                                                          iSlot,
                                                          0 );
            else
                m_poPanose = NULL;

            if (FFCOL_PANOSE != m_iSortColumn)
            {
                m_bSortAscending = TRUE;
                m_iSortColumn    = FFCOL_PANOSE;
            }

            SortObjects( );
            m_iSortLast = FFCOL_PANOSE;

            UpdatePanColumn( );

            }
            break;

         default:
            return 0;
         }
         break;

    case IDM_FILE_PROPERTIES:
        OnCmdProperties( );
        break;

    case IDM_EDIT_SELECTALL:
    case IDM_EDIT_SELECTINVERT:
        vToggleSelection( uID == IDM_EDIT_SELECTALL );
        break;

    case IDM_VIEW_VARIATIONS:
        m_bFamilyOnly = !m_bFamilyOnly;

        if ( m_bFamilyOnly &&
            m_poFontManager &&
            m_poFontManager->bFamiliesNeverReset() )
        {
            m_poFontManager->vResetFamilyFlags();
        }

        FillObjects( );

        break;

    case IDM_VIEW_PREVIEW:
        m_bShowPreviewToolTip = !m_bShowPreviewToolTip;
        SendMessage(m_hwndToolTip, TTM_ACTIVATE, m_bShowPreviewToolTip, 0);
        break;

    case IDM_VIEW_ICON:
        m_ViewModeReturn = FVM_ICON;
        goto DoSetViewMode;

    case IDM_VIEW_LIST:
        m_ViewModeReturn = FVM_LIST;
        goto DoSetViewMode;

    case IDM_VIEW_DETAILS:
    case IDM_VIEW_PANOSE:
        m_ViewModeReturn = FVM_DETAILS;
        goto DoSetViewMode;

DoSetViewMode:
        SetViewMode( (UINT)wParam );
        break;

    case IDM_FILE_SAMPLE:
        OpenCurrent( );
        break;

    case IDM_FILE_PRINT:
        PrintCurrent( );
        break;

    case IDM_FILE_INSTALL:
//        if( bCPAddFonts( m_hwndParent ) )
        if( bCPAddFonts( m_hwndView ) )
        {
            vCPWinIniFontChange( );
        }
        break;

    case IDM_POPUP_MOVE:
        DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: OnCommand: IDM_POPUP_MOVE" ) ) );
        m_dwEffect = DROPEFFECT_MOVE;
        break;

    case IDM_POPUP_COPY:
        DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: OnCommand: IDM_POPUP_COPY" ) ) );
        m_dwEffect = DROPEFFECT_COPY;
        break;

    case IDM_POPUP_LINK:
        DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: OnCommand: IDM_POPUP_LINK" ) ) );
        m_dwEffect = DROPEFFECT_LINK;
        break;

    case IDCANCEL:
    case IDM_POPUP_CANCEL:
        DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: OnCommand: IDM_POPUP_CANCEL" ) ) );
        m_dwEffect = DROPEFFECT_NONE;
        break;

    case IDM_HELP_TOPIC:
        OnHelpTopics(m_hwndView);
        return 0;
    }

    return( 1L );

}

void
CFontView::OnHelpTopics(
    HWND hWnd
    )
{
    if (!IsOS(OS_ANYSERVER))
    {
        //
        // If not on server, launch Help & Support to the proper topic.
        //
        SHELLEXECUTEINFOW sei = {0};
        sei.cbSize = sizeof(sei);
        sei.lpFile = L"hcp://services/subsite?node=Unmapped/Control_Panel&select=Unmapped/Control_Panel/Appearance_and_Themes/Fonts";
        sei.hwnd   = m_hwndView;
        sei.nShow  = SW_NORMAL;
        ShellExecuteExW(&sei);
    }
    else
    {
        typedef HWND (WINAPI * PFNHTMLHELPA)(HWND, LPCSTR, UINT, ULONG_PTR);
        
        //
        // We're on server.  Launch winhelp.
        //
        if (NULL == m_hmodHHCtrlOcx)
        {
            //
            // Don't want to statically link to hhctrl.ocx so we load it on demand.
            // We'll call FreeLibrary in the CFontView dtor.
            //
            m_hmodHHCtrlOcx = LoadLibrary(TEXT("hhctrl.ocx"));
        }
        if (NULL != m_hmodHHCtrlOcx)
        {
            PFNHTMLHELPA pfnHelp = (PFNHTMLHELPA)GetProcAddress(m_hmodHHCtrlOcx, "HtmlHelpA");
            if (NULL != pfnHelp)
            {
                const char szHtmlHelpFileA[]  = "FONTS.CHM > windefault";
                const char szHtmlHelpTopicA[] = "windows_fonts_overview.htm";

                (*pfnHelp)(hWnd,
                           szHtmlHelpFileA,
                           HH_DISPLAY_TOPIC,
                           (DWORD_PTR)szHtmlHelpTopicA);
            }
        }
    }
}


//
// This code was taken from shell32's defview.
//
void
CFontView::UpdateUnderlines(
    void
    )
{
    DWORD cb;
    DWORD dwUnderline = ICON_IE;
    DWORD dwExStyle;

    //
    // Read the icon underline settings.
    //
    cb = sizeof(dwUnderline);
    SHRegGetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
                    TEXT("IconUnderline"),
                    NULL,
                    &dwUnderline,
                    &cb,
                    FALSE,
                    &dwUnderline,
                    cb);

    //
    // If it says to use the IE link settings, read them in.
    //
    if (dwUnderline == ICON_IE)
    {
        dwUnderline = ICON_YES;

        TCHAR szUnderline[8];
        cb = sizeof(szUnderline);
        SHRegGetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                        TEXT("Anchor Underline"),
                        NULL,
                        szUnderline,
                        &cb,
                        FALSE,
                        szUnderline,
                        cb);

        //
        // Convert the string to an ICON_ value.
        //
        if (!lstrcmpi(szUnderline, TEXT("hover")))
            dwUnderline = ICON_HOVER;
        else if (!lstrcmpi(szUnderline, TEXT("no")))
            dwUnderline = ICON_NO;
        else
            dwUnderline = ICON_YES;
    }

    //
    // Convert the ICON_ value into an LVS_EX value.
    //
    switch (dwUnderline)
    {
        case ICON_NO:
            dwExStyle = 0;
            break;

        case ICON_HOVER:
            dwExStyle = LVS_EX_UNDERLINEHOT;
            break;

        case ICON_YES:
            dwExStyle = LVS_EX_UNDERLINEHOT | LVS_EX_UNDERLINECOLD;
            break;
    }

    //
    // Set the new LVS_EX_UNDERLINE flags.
    //
    ListView_SetExtendedListViewStyleEx(m_hwndList,
                                        LVS_EX_UNDERLINEHOT |
                                        LVS_EX_UNDERLINECOLD,
                                        dwExStyle);
}


//
// Set the proper listview "click mode" depending upon the user's
// preferences in the shell.
// Returns: New click mode. CLICKMODE_SINGLE or CLICKMODE_DOUBLE.
//
CFontView::CLICKMODE
CFontView::SetListviewClickMode(
    VOID
    )
{
    SHELLSTATE ss;
    DWORD dwStyle;
    BOOL bSingleClick;

    //
    // Get the current double-click setting in the shell (user pref).
    //
    SHGetSetSettings(&ss, SSF_WIN95CLASSIC | SSF_DOUBLECLICKINWEBVIEW, FALSE);

    //
    // Get the current listview style bits.
    //
    dwStyle = ListView_GetExtendedListViewStyle(m_hwndList);

    //
    // We get single-click if user wants no web view or single-click in web view.
    // SINGLECLICK = WEBVIEW && !DBLCLICKINWEBVIEW
    //
    bSingleClick = !ss.fWin95Classic && !ss.fDoubleClickInWebView;

    if (bSingleClick)
    {
        if (0 == (dwStyle & LVS_EX_ONECLICKACTIVATE))
        {
            //
            // User wants single click but list is double click..
            // Set listview to single-click mode.
            //
            ListView_SetExtendedListViewStyleEx(m_hwndList,
                                               LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE | LVS_EX_TWOCLICKACTIVATE,
                                               LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE);
        }
    }
    else if (dwStyle & LVS_EX_ONECLICKACTIVATE)
    {
        //
        // Turn off preview tooltips.
        //
        m_bShowPreviewToolTip = FALSE;
        SendMessage(m_hwndToolTip, TTM_ACTIVATE, m_bShowPreviewToolTip, 0);

        //
        // User wants double click but list is single click.
        // Set listview to double click mode.
        //
        ListView_SetExtendedListViewStyleEx(m_hwndList,
                                           LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE | LVS_EX_TWOCLICKACTIVATE,
                                           0);
    }
    m_iViewClickMode = bSingleClick ? CLICKMODE_SINGLE : CLICKMODE_DOUBLE;

    UpdateUnderlines();

    return m_iViewClickMode;
}


void CFontView::UpdateSelectedCount( )
{
    int iCount;
    int iTemplate;
    TCHAR szText[ 128 ];
    TCHAR szStatus[ 128 ];

    iCount = (int) SendMessage( m_hwndList, LVM_GETSELECTEDCOUNT, 0, 0 );

    iTemplate = IDS_SELECTED_FONT_COUNT;

    if( !iCount )
    {
        iCount = (int) SendMessage( m_hwndList, LVM_GETITEMCOUNT, 0, 0 );
        iTemplate = IDS_TOTAL_FONT_COUNT;

        if( m_iHidden )
        {
            iTemplate = IDS_TOTAL_AND_HIDDEN_FONT_COUNT;
        }
    }

    LoadString( g_hInst, iTemplate, szText, ARRAYSIZE( szText ) );

    StringCchPrintf( szStatus, ARRAYSIZE(szStatus), szText, iCount, m_iHidden );

    HWND hwndStatus;

    m_psb->GetControlWindow( FCW_STATUS, &hwndStatus );

    SendMessage( hwndStatus, SB_SETTEXT, 0, (LPARAM) szStatus );
}


//
// Update a font object in the font view following a shell change notification.
// This picks up the color change (if desired by user) and the change to the
// attributes column in details view.
//
void CFontView::UpdateFontViewObject(CFontClass *pFont)
{
    if (NULL != pFont)
    {
        int i = 0;
        LV_FINDINFO lvfi;
        lvfi.flags    = LVFI_PARAM;
        lvfi.psz      = NULL;
        lvfi.lParam   = (LPARAM)pFont;

        //
        // Get the list view index for the object and redraw it.
        //
        i = ListView_FindItem(m_hwndList, -1, &lvfi);
        if (-1 != i)
        {
            ListView_RedrawItems(m_hwndList, i, i);
        }
    }
}


//
// Handles a shell change notification.
// If the path passed in the notification is the path to a font file in the folder,
// the function invalidates the font's cached file attributes and updates the
// object's visual appearance.
//
int CFontView::OnShellChangeNotify(WPARAM wParam, LPARAM lParam)
{
    LPSHChangeNotificationLock pshcnl;
    LPITEMIDLIST *ppidl = NULL;
    LONG lEvent = 0;

    pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, &ppidl, &lEvent);
        
    if (NULL != pshcnl && NULL != ppidl && NULL != *ppidl)
    {
        LPITEMIDLIST pidlPath = *ppidl;

        TCHAR szPath[MAX_PATH];
        LPTSTR pszFileName = NULL;

        if (SHGetPathFromIDList(pidlPath, szPath))
        {
            pszFileName = PathFindFileName(szPath);
            CFontClass *pFont = m_poFontManager->poSearchFontListFile(pszFileName);

            if (NULL != pFont)
            {
                //
                // This event applies to a font object.
                // Invalidate the font object's cached file attributes.
                // Update the font object's visual appearance.
                //
                pFont->InvalidateFileAttributes();
                UpdateFontViewObject(pFont);
            }
        }
        SHChangeNotification_Unlock(pshcnl);
    }
    return (int)lParam;
}


//
// Handle custom draw notification from list view.
// This is where we tell the list view to draw the item in
// normal (uncompressed) or alternate (compressed) color.
// Note this is for NT only.  Non-NT tells the listview
// control to use the default color.
//
int CFontView::OnCustomDrawNotify(LPNMHDR lpn)
{
    LPNMLVCUSTOMDRAW lpCD = (LPNMLVCUSTOMDRAW)lpn;

    if (WID_LISTVIEW == lpn->idFrom)
    {
        switch (lpCD->nmcd.dwDrawStage)
        {
            case CDDS_PREPAINT:
                return m_bShowCompColor ? CDRF_NOTIFYITEMDRAW : CDRF_DODEFAULT;

            case CDDS_ITEMPREPAINT:
                {
                    CFontClass * poFont = (CFontClass *)( lpCD->nmcd.lItemlParam );
                    if (NULL != poFont)
                    {
                        if (DWORD(-1) != poFont->dwGetFileAttributes() &&
                            poFont->dwGetFileAttributes() & FILE_ATTRIBUTE_COMPRESSED)
                        {
                            lpCD->clrText = g_crAltColor;
                        }
                    }
                    return CDRF_DODEFAULT;
                }
        }
    }
    return CDRF_DODEFAULT;
}



int CFontView::OnNotify( LPNMHDR lpn )
{
    NM_LISTVIEW FAR * pnmv = (NM_LISTVIEW FAR *) lpn;

    // DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT - WM_NOTIFY with code: %d(%x)" ), ((NMHDR*)lParam)->code, ((NMHDR*)lParam)->code ) );

    switch( lpn->code )
    {
    case TBN_BEGINDRAG:
        OnMenuSelect( 0, ((LPTBNOTIFY) lpn)->iItem, 0, 0 );
        break;

    case TBN_ENDDRAG:
        StatusPop( );
        break;

    case NM_CUSTOMDRAW:
        return OnCustomDrawNotify(lpn);

    case LVN_ITEMACTIVATE:
        OnLVN_ItemActivate((LPNMITEMACTIVATE)lpn);
        break;

    case LVN_BEGINDRAG:
    case LVN_BEGINRDRAG:
        BeginDragDrop( pnmv );
        break;

    case LVN_HOTTRACK:
        LV_OnHoverNotify((LPNMLISTVIEW)lpn);
        break;

    case LVN_GETINFOTIP:
        LV_OnGetInfoTip((LPNMLVGETINFOTIP)lpn);
        break;        

    case LVN_GETDISPINFO:
        {
        LV_DISPINFO FAR *pnmv = (LV_DISPINFO FAR *) lpn;
        CFontClass * poFont = (CFontClass *)( pnmv->item.lParam );
        UINT mask = pnmv->item.mask;

        //
        // DEBUGMSG( (DM_MESSAGE_TRACE1, TEXT( "FONTEXT: LVN_GETDISPINFO for item %d, subitem %d" ),
        //      pnmv->item.iItem, pnmv->item.iSubItem) );

        if( mask & LVIF_TEXT )
        {
            // DEBUGMSG( (DM_MESSAGE_TRACE1, TEXT( "   Wants text information" ) ) );

            static TCHAR szText[ 64 ];

            //
            //  The text we get depends on the view we are currently in.
            //

            switch( m_idViewMode )
            {
            default:
            // case IDM_VIEW_ICON:
            // case IDM_VIEW_LIST:
                if( m_bFamilyOnly )
                    poFont->vGetFamName( szText, ARRAYSIZE(szText) );
                else
                    poFont->vGetName( szText, ARRAYSIZE(szText) );
                break;

            case IDM_VIEW_PANOSE:
                switch( pnmv->item.iSubItem )
                {
                default:
                // case 0:
                    if( m_bFamilyOnly )
                        poFont->vGetFamName( szText, ARRAYSIZE(szText) );
                    else
                        poFont->vGetName( szText, ARRAYSIZE(szText) );
                    break;

                case 1:  // Panose match info.
                    if( !m_poPanose )
                        szText[ 0 ] =0;
                    else if( !poFont->bHavePANOSE( ) )
                    {
                        LoadString( g_hInst, IDS_NO_PAN_INFO, szText,
                                    ARRAYSIZE( szText ) );
                    }
                    else
                    {
                        USHORT nDiff = m_poFontManager->nDiff( m_poPanose,
                                                               poFont );

                        if( nDiff < 30 )
                            LoadString( g_hInst, IDS_PAN_VERY_SIMILAR, szText,
                                        ARRAYSIZE( szText ) );
                        else if( nDiff < 100 )
                            LoadString( g_hInst, IDS_PAN_SIMILAR, szText,
                                        ARRAYSIZE( szText ) );
                        else
                            LoadString( g_hInst, IDS_PAN_NOT_SIMILAR, szText,
                                        ARRAYSIZE( szText ) );
                    }
                    break;
                }
                break;

            case IDM_VIEW_DETAILS:
                switch( pnmv->item.iSubItem )
                {
                default:
                case 0:
                    poFont->vGetName( szText, ARRAYSIZE(szText) );
                    break;

                case 1:
                    poFont->vGetFileName( szText, ARRAYSIZE(szText) );
                    break;

                case 2:  // Size
                    {
                    TCHAR szFmt[ 64 ];

                    LoadString( g_hInst, IDS_FMT_FILEK, szFmt,
                                ARRAYSIZE( szFmt ) );

                    StringCchPrintf( szText, ARRAYSIZE(szText), szFmt, poFont->dCalcFileSize( ) );
                    }
                    break;

                case 3:  // Modification date and time.
                    {
                        FILETIME ft;
                        DWORD dwFormat = m_dwDateFormat;

                        szText[ 0 ] = 0;

                        if( poFont->GetFileTime( &ft ) )
                        {
                            SHFormatDateTime(&ft, &dwFormat, szText, ARRAYSIZE(szText));
                        }
                    }
                    break;

                case 4:  // File attributes.
                    BuildAttributeString(poFont->dwGetFileAttributes(),
                                         szText,
                                         ARRAYSIZE(szText));
                    break;

                }
                break;
            }  // switch

            StringCchCopy(pnmv->item.pszText, pnmv->item.cchTextMax, szText);
        } // LVIF_TEXT
        } // LVN_GETDISPINFO
        break;


    case LVN_ITEMCHANGED:
        if( pnmv->uChanged & LVIF_STATE &&
            ( (pnmv->uNewState ^ pnmv->uOldState) & LVIS_SELECTED) )
        {
            UpdateSelectedCount( );
        }
        break;


    case LVN_COLUMNCLICK:
    {
        //
        //  start and stops busy cursor
        //

        WaitCursor cWaiter;

        m_iSortColumn = pnmv->iSubItem;
        if (m_iSortColumn != m_iSortLast)
        {
            //
            // Selected new column.  Reset sort order.
            //
            m_bSortAscending = TRUE;
        }
        else
        {
            //
            // Column selected for a second time. Invert the sort order.
            //
            m_bSortAscending = !m_bSortAscending;
        }

        SortObjects( );

        m_iSortLast = m_iSortColumn;

        break;
    }

    case TTN_NEEDTEXT:
         if( lpn->idFrom >= IDM_VIEW_ICON && lpn->idFrom <= IDM_VIEW_DETAILS )
         {
            //
            //  Query for some text to display for the toolbar.
            //

            LPTOOLTIPTEXT lpt = (LPTOOLTIPTEXT)lpn;

            lpt->lpszText = (LPTSTR) MAKEINTRESOURCE( IDS_VIEW_ICON
                                                      + lpn->idFrom
                                                      - IDM_VIEW_ICON );
            lpt->hinst = g_hInst;
        }
        break;

    case NM_SETFOCUS:
        //
        //   We should call IShellBrowser::OnViewWindowActive() before
        //   calling its InsertMenus().
        //

        m_psb->OnViewWindowActive( this );

        //
        // Only call OnActivate() if UIActivate() has been called.
        // If OnActivate() is called before UIActivate(), the menus
        // are merged before IShellView is properly activated.
        // This results in missing menu items.
        //
        if (m_bUIActivated)
            OnActivate( SVUIA_ACTIVATE_FOCUS );

        break;

    } // switch( notify code )

    return( 0 );
}


void
CFontView::LV_OnGetInfoTip(
    LPNMLVGETINFOTIP lpnm
    )
{
    LVITEM item;

    item.iItem    = lpnm->iItem;
    item.iSubItem = 0;
    item.mask     = LVIF_PARAM;
    if (ListView_GetItem(m_hwndList, &item) && 0 != item.lParam)
    {
        NMLVDISPINFO lvdi;
        ZeroMemory(&lvdi, sizeof(lvdi));

        lvdi.hdr.code        = LVN_GETDISPINFO;
        lvdi.hdr.hwndFrom    = m_hwndList;
        lvdi.item.iItem      = lpnm->iItem;
        lvdi.item.iSubItem   = lpnm->iSubItem;
        lvdi.item.mask       = LVIF_TEXT;
        lvdi.item.pszText    = lpnm->pszText;
        lvdi.item.cchTextMax = lpnm->cchTextMax;
        lvdi.item.lParam     = item.lParam;
        OnNotify((LPNMHDR)&lvdi);
    }
}    



//
// Handle an item in the listview being clicked with the mouse.
//
VOID
CFontView::OnLVN_ItemActivate(
    LPNMITEMACTIVATE pnma
    )
{
    if (LVKF_ALT & pnma->uKeyFlags)
    {
        //
        // ALT+Click --> Properties page.
        // Click (dbl or single) dependent on user's settings.
        //
        OnCmdProperties();
    }
    else
    {
        //
        // Opening a font invokes the font viewer.
        //
        OpenCurrent();
    }
}


//
// Determine which icon represents a font.
//
INT
CFontView::ItemImageIndex(
    CFontClass *poFont
    )
{
    //
    // All indexes are offsets in the imagelist.
    // Default to an FON file.
    //
    INT iImage = IDI_FON - IDI_FIRSTFONTICON;

    //
    // First check for TTC because TTC is also TrueType.
    //
    if(poFont->bTTC())
    {
        iImage = IDI_TTC - IDI_FIRSTFONTICON;
    }
    else if (poFont->bOpenType() || poFont->bTrueType())
    {
        //
        // Use our IExtractIcon icon handler to determine
        // which icon to display for the TrueType or OpenType font.
        //
        // FEATURE:  The problem with this is that it opens the
        //          font files for a second time.  Font files
        //          are opened for identification when they're
        //          first loaded into the folder.  Ideally, we would
        //          identify the appropriate icon at that point.
        //          I don't want to mess with that code right now.
        //          This code path will result in exactly the same icon
        //          used by the shell so this will ensure consistency.
        //          [brianau - 6/13/97]
        //
        TCHAR szFileName[MAX_PATH];
        poFont->bGetFQName(szFileName, ARRAYSIZE(szFileName));

        iImage = IDI_TTF;
        if (SUCCEEDED(m_IconHandler.Load(szFileName, 0)))
        {
            UINT uFlags = 0;
            m_IconHandler.GetIconLocation(GIL_FORSHELL,
                                          L"", // Force call to wide-char version.
                                          0,
                                          &iImage,
                                          &uFlags);
        }
        ASSERT(IDI_OTFp == iImage ||
               IDI_OTFt == iImage ||
               IDI_TTF  == iImage);

        iImage -= IDI_FIRSTFONTICON;
    }
    else if(poFont->bType1())
    {
        iImage = IDI_T1 - IDI_FIRSTFONTICON;
    }

    return iImage;
}



void CFontView::OnDropFiles( HDROP hDrop, DWORD dwEffect )
{
    FullPathName_t szFile;
    BOOL           bAdded = FALSE;

    //
    //  Starts and stops busy cursor
    //

    WaitCursor    cWaiter;
    UINT cnt = ::DragQueryFile( hDrop, (UINT)-1, NULL, 0 );

    for( UINT i = 0; i < cnt; )
    {
        ::DragQueryFile( hDrop, i, szFile, ARRAYSIZE( szFile ) );

        StatusPush( szFile );

        switch( CPDropInstall( m_hwndView,
                               szFile,
                               ARRAYSIZE(szFile),
                               dwEffect,
                               NULL,
                               (int) (cnt - ++i) ) )
        {
        case CPDI_SUCCESS:
            bAdded = TRUE;
            break;

        case CPDI_FAIL:
            break;

        case CPDI_CANCEL:
            i = cnt; // leave the loop;
            break;
        }

        StatusPop( );
    }

    ::DragFinish( hDrop );

    if( bAdded )
    {
        vCPWinIniFontChange( );
    }

}


void CFontView::UpdateMenuItems( HMENU hMenu )
{
    CheckMenuRadioItem( hMenu,
                        IDM_VIEW_ICON,
                        IDM_VIEW_DETAILS,
                        m_idViewMode,
                        MF_BYCOMMAND );

    //
    //  Enable and disable those items based on selection.
    //

    UINT nFlag = ((iCurrentSelection( ) > 0 ) ? cLiveMenu : cDeadMenu );


    EnableMenuItem( hMenu, IDM_FILE_SAMPLE    , nFlag );
    EnableMenuItem( hMenu, IDM_FILE_PRINT     , nFlag );
    EnableMenuItem( hMenu, IDM_FILE_DEL       , nFlag );
    EnableMenuItem( hMenu, IDM_FILE_PROPERTIES, nFlag );
    EnableMenuItem( hMenu, IDM_EDIT_COPY      , nFlag );

    //
    //  If there is a file with a format on the clipboard that we can
    //  understand, then enable the menu.
    //

    nFlag = ((IsClipboardFormatAvailable( CF_HDROP ) ) ? cLiveMenu : cDeadMenu );

    EnableMenuItem( hMenu, IDM_EDIT_PASTE     , nFlag );

    //
    //  Are we hiding the variations of a font?
    //
    CheckMenuItem( hMenu, IDM_VIEW_VARIATIONS, m_bFamilyOnly ? MF_CHECKED
                                                             : MF_UNCHECKED );

    CheckMenuItem(hMenu, IDM_VIEW_PREVIEW, m_bShowPreviewToolTip ? MF_CHECKED
                                                                 : MF_UNCHECKED );
}


void CFontView::UpdateToolbar( )
{
    LRESULT    lRet;

    m_psb->SendControlMsg( FCW_TOOLBAR, TB_CHECKBUTTON,
                           m_idViewMode, MAKELONG( TRUE, 0 ), &lRet );

}


HRESULT CFontView::GetFontList( CFontList **ppoList, UINT nItem )
{
    BOOL        bDeleteFam = m_bFamilyOnly;
    CFontClass* lpFontRec;
    LV_ITEM     Item;

    *ppoList = 0;

    if( nItem != SVGIO_SELECTION )
    {
        return ResultFromScode( E_FAIL );
    }

    //
    //  Build up a list of the fonts to be deleted
    //

    CFontList * poList = new CFontList( 10, 10 );
    if(poList)
    {
        if (!poList->bInit())
        {
            delete poList;
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }

    //
    //  Save it.
    //

    *ppoList = poList;

    //
    //  Start at the beginning.
    //

    int i = -1;

    UINT  nFlags = LVNI_SELECTED | LVNI_ALL;

    Item.mask = LVIF_PARAM;

    while( ( i = ListView_GetNextItem( m_hwndList, i, nFlags ) ) != -1 )
    {
        Item.iItem = i;
        Item.iSubItem = 0;

        ListView_GetItem( m_hwndList, &Item );

        lpFontRec = ( CFontClass *)Item.lParam;

        //
        //  If this font represents a whole family, then delete the whole
        //  family.
        //

        if( m_bFamilyOnly )
            m_poFontManager->vGetFamily( lpFontRec, poList );
        else
            poList->bAdd( lpFontRec );

    }  //  End of loop on selected fonts.

    return NOERROR;
}


void CFontView::OnCmdPaste( )
{
    //
    //  associate it with current task
    //

    if( OpenClipboard( NULL ) )
    {
        HGLOBAL hmem = GetClipboardData( CF_HDROP );

        if( hmem )
        {
            //
            // There is a CF_HDROP. Create CIDLData from it.
            //

            UINT  cb    = (UINT)GlobalSize( hmem );
            HDROP hdrop = (HDROP) GlobalAlloc( GPTR, cb );

            if( hdrop )
            {
                hmemcpy( (LPVOID)hdrop, GlobalLock( hmem ), cb );

                GlobalUnlock( hmem );

                OnDropFiles( hdrop, DROPEFFECT_COPY );

                //
                //  We already free this in OnDropFiles, so don't free again
                //
                //  GlobalFree( hdrop );
                //
            }
        }
        CloseClipboard( );
    }
}


void CFontView::OnCmdCutCopy( UINT nID )
{
    LPDATAOBJECT   pdtobj;


    if( SUCCEEDED( GetUIObjectFromItem( IID_IDataObject,
                                        (void **) &pdtobj,
                                        SVGIO_SELECTION ) ) )
    {
        FFSetClipboard( pdtobj );

        pdtobj->Release( );
    }
}


void CFontView::OnCmdDelete( )
{
    BOOL        bDeleteFile = FALSE;
    BOOL        bSomeDel    = FALSE;
    CFontList * poList;


    if( !SUCCEEDED( GetFontList( &poList, SVGIO_SELECTION ) ) )
    {
        iUIErrMemDlg(m_hwndList);
        return;
    }

    //
    //  Update our view and notify other apps of font changes.
    //

    if( poList->iCount( ) )
    {
        //
        //  warn first so that canceling out now won't nuke all the fonts
        //  you have selected in
        //
        if( iUIMsgBox( m_hwndList, IDSI_FMT_DELETECONFIRM, IDS_MSG_CAPTION,
                       MB_YESNO | MB_ICONEXCLAMATION, NULL ) == IDYES )
        {
           m_poFontManager->vDeleteFontList( poList );
        }
    }

    //
    //  empty the font list. They are all deleted anyway.
    //

    poList->vDetachAll( );
    delete poList;
}


void CFontView::OnCmdProperties( )
{
    CFontClass*    poFont;
    BOOL           bDeleteFam  = m_bFamilyOnly;
    BOOL           bDeleteFile = FALSE;
    BOOL           bSomeDel    = FALSE;
    BOOL           bYesAll     = FALSE;

    FullPathName_t szFile = {0};

    LV_ITEM          Item;
    SHELLEXECUTEINFO se;

    static TCHAR  szCmd[] = TEXT( "Properties" );

    //
    //  Start at the beginning.
    //

    int i = -1;

    UINT  nFlags = LVNI_SELECTED | LVNI_ALL;


    Item.mask = LVIF_PARAM;

    while( ( i = ListView_GetNextItem( m_hwndList, i, nFlags ) ) != -1 )
    {
        Item.iItem    = i;
        Item.iSubItem = 0;

        ListView_GetItem( m_hwndList, &Item );

        poFont = (CFontClass *) Item.lParam;

        poFont->vGetDirFN( szFile, ARRAYSIZE(szFile) );

        memset( &se, 0, sizeof( se ) );

        se.cbSize = sizeof( se );
        se.fMask  = SEE_MASK_INVOKEIDLIST;
        se.hwnd   = m_hwndView;
        se.lpVerb = szCmd;
        se.lpFile = szFile;
        se.nShow  = 1;

        ShellExecuteEx( &se );
    }
}


void CFontView::OldDAD_DropTargetLeaveAndReleaseData(void)
{
    DragLeave();

    if (NULL != m_pdtobjHdrop)
    {
        m_pdtobjHdrop->Release();
        m_pdtobjHdrop = NULL;
    }
}


//
// CFontView::OldDAD_HandleMessages
//
// This function handles all messages associated with Win3.1-style drag-and-drop operations.
// The code was copied from a similar implementation in DEFVIEWX.C.  Minor changes have been
// made to create CFontView member functions and to produce the correct drag-and-drop
// behavior for the font folder.
//
LRESULT CFontView::OldDAD_HandleMessages(UINT message, WPARAM wParam, const DROPSTRUCT *lpds)
{
    DWORD dwAllowedDADEffect = DROPEFFECT_COPY | DROPEFFECT_MOVE | DROPEFFECT_LINK;

    //
    // We don't need to do this hack if NT defined POINT as typedef POINTL.
    //
    union {
        POINT ptScreen;
        POINTL ptlScreen;
    } drop;

    ASSERT(SIZEOF(drop.ptScreen)==SIZEOF(drop.ptlScreen));

    if (NULL != lpds)   // Notes: lpds is NULL, if uMsg is WM_DROPFILES.
    {
        drop.ptScreen = lpds->ptDrop;
        ClientToScreen(GetViewWindow(), &drop.ptScreen);
    }

    switch (message)
    {
        case WM_DRAGSELECT:

            //
            // WM_DRAGSELECT is sent to a sink whenever an new object is dragged inside of it.
            // wParam: TRUE if the sink is being entered, FALSE if it's being exited.
            //
            if (wParam)
            {
                if (NULL != m_pdtobjHdrop)
                {
                    //
                    // can happen if old target fails to generate drag leave properly
                    //
                    OldDAD_DropTargetLeaveAndReleaseData();
                }

                if (SUCCEEDED(CIDLData_CreateFromIDArray(NULL, 0, NULL, &m_pdtobjHdrop)))
                {
                    //
                    // promise the CF_HDROP by setting a NULL handle
                    // indicating that this dataobject will have an hdrop at Drop() time
                    //
                    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
                    STGMEDIUM medium;

                    medium.tymed          = TYMED_HGLOBAL;
                    medium.hGlobal        = (HGLOBAL)NULL;
                    medium.pUnkForRelease = NULL;

                    m_pdtobjHdrop->SetData(&fmte, &medium, TRUE);

                    DWORD dwMouseKey = MK_LBUTTON;
                    if (GetAsyncKeyState(VK_SHIFT) & 0x80000000)
                        dwMouseKey |= MK_SHIFT;

                    DragEnter(m_pdtobjHdrop, dwMouseKey, drop.ptlScreen, &dwAllowedDADEffect);
                    m_dwOldDADEffect = dwAllowedDADEffect;
                }
            }
            else
            {
                OldDAD_DropTargetLeaveAndReleaseData();
            }
            break;

        case WM_DRAGMOVE:
            //
            // WM_DRAGMOVE is sent to a sink as the object is being dragged within it.
            // wParam: Unused
            //
            if (NULL != m_pdtobjHdrop)
            {
                DWORD dwMouseKey = MK_LBUTTON;
                if (GetAsyncKeyState(VK_SHIFT) & 0x80000000)
                    dwMouseKey |= MK_SHIFT;

                DragOver(dwMouseKey, drop.ptlScreen, &dwAllowedDADEffect);
                m_dwOldDADEffect = dwAllowedDADEffect;
            }
            break;

        case WM_QUERYDROPOBJECT:

            switch (lpds->wFmt)
            {
                case DOF_SHELLDATA:
                case DOF_DIRECTORY:
                case DOF_DOCUMENT:
                case DOF_MULTIPLE:
                case DOF_EXECUTABLE:
                    //
                    // assume all targets can accept HDROP if we don't have the data object yet
                    // we will accept the drop
                    //
                    return TRUE;
            }
            return FALSE;           // don't accept

        case WM_DROPOBJECT:
            if (NULL == m_pdtobjHdrop)
                return FALSE;

            //
            // Check the format of dragged object.
            //
            switch (lpds->wFmt)
            {
                case DOF_EXECUTABLE:
                case DOF_DOCUMENT:
                case DOF_DIRECTORY:
                case DOF_MULTIPLE:
                case DOF_PROGMAN:
                case DOF_SHELLDATA:
                    //
                    // We need to unlock this window if this drag&drop is originated
                    // from the shell itself.
                    //
                    DAD_DragLeave();

                    //
                    // The source is Win 3.1 app (probably FileMan), request HDROP.
                    // Send us a WM_DROPFILES with HDROP
                    //
                    return DO_DROPFILE;
            }
            break;

        case WM_DROPFILES:
            OnDropFiles((HDROP)wParam, m_dwOldDADEffect);
            break;
    }

    return 0;   // Unknown format. Don't drop any
}


void FocusOnSomething(HWND hwndLV)
{
    INT iFocus;

    iFocus = ListView_GetNextItem(hwndLV, -1, LVNI_FOCUSED);
    if (-1 == iFocus)
        iFocus = 0;

    ListView_SetItemState(hwndLV, iFocus, LVIS_FOCUSED, LVIS_FOCUSED);
}


LRESULT CFontView::ProcessMessage( HWND hWnd,
                                   UINT message,
                                   WPARAM wParam,
                                   LPARAM lParam )
{
    DEBUGMSG( (DM_MESSAGE_TRACE2, TEXT( "FONTEXT: CFontView::ProcMess Called m=0x%x wp=0x%x lp=0x%x" ),
              message, wParam, lParam ) );

    switch( message )
    {

    //
    // Desktop properties applet sends a WM_WININICHANGE when
    // the icon font is changed.  Just send the message on to the list view control.
    // This causes the list view to update using the new font.
    //
    case WM_WININICHANGE:
        //
        // Only handle this if the "section" is not "fonts".
        // I know this sounds weird but this is to prevent a double update
        // because vCPWinIniFontChange sends a WM_WININICHANGE and a
        // WM_FONTCHANGE whenever fonts are added or deleted to/from the folder.
        // In the WM_WININICHANGE, it sets the section string to "fonts".  We
        // use this to determine that the message came from vCPWinIniFontChange.
        //
        if (0 != lstrcmp((LPCTSTR)lParam, TEXT("fonts")))
        {
            SendMessage( m_hwndList, message, wParam, lParam );

            if (0 == lstrcmp((LPCTSTR)lParam, TEXT("intl")))
            {
                if (IDM_VIEW_DETAILS == m_idViewMode)
                {
                    //
                    // We're in "details" mode and the user might have just
                    // changed the date format.  Update the listview.  This is
                    // how the shell's defview handles this.
                    //
                    InvalidateRect(m_hwndList, NULL, TRUE);
                }
            }            
        }
        
        //
        // When changing from single to double-click mode, the shell broadcasts a WM_SETTINGCHANGE.
        //
        SetListviewClickMode();
        {
            //
            // If we received WM_SETTINGCHANGE because the user changed listview click mode,
            // we want to update the "View" menu to either add or remove the "Preview"
            // menu item.  Deactivating the view and restoring it to it's previous mode
            // does the trick.
            //
            UINT uState = m_uState;
            OnDeactivate();
            OnActivate(uState);
        }
        return 0;

    case WM_FONTCHANGE:
        //
        //  Make sure the FontManager gets refreshed before we draw the
        //  window.
        //
        {
            WaitCursor oWait;
            m_poFontManager->bRefresh( TRUE );
        }
        Refresh( );
        break;


    case WM_INITMENUPOPUP:
        UpdateMenuItems( m_hmenuCur );
        break;

    //
    // Handle drops from Win3.1 (File Manager) apps the same as the shell
    // does in defviewx.c (with a few font folder-specific mods).
    //
    case WM_DROPOBJECT:
    case WM_QUERYDROPOBJECT:
    case WM_DRAGLOOP:
    case WM_DRAGSELECT:
    case WM_DRAGMOVE:
    case WM_DROPFILES:
        return OldDAD_HandleMessages(message, wParam, (const DROPSTRUCT *)lParam);

    case WM_DESTROY:
        {
        m_bUIActivated = FALSE;
        //
        //  Remove ourself from the Clipboard chain.
        //

        ChangeClipboardChain( hWnd, m_hwndNextClip );

        //
        // Call CFontClass::Release() for each font contained in the ListView.
        //
        ReleaseFontObjects();

        return( 1 );
        }


    case WM_CHANGECBCHAIN:
        //
        //  If the next window is closing, repair the chain.
        //

        if( (HWND) wParam == m_hwndNextClip )
            m_hwndNextClip = (HWND) lParam;

        //
        //  Otherwise, pass the message to the next link.
        //

        else if( m_hwndNextClip != NULL )
            SendMessage( m_hwndNextClip, message, wParam, lParam );

        break;

    case WM_DRAWCLIPBOARD:
        //
        //  Notify the next viewer in the chain.
        //

        if( m_hwndNextClip )
            SendMessage( m_hwndNextClip, message, wParam, lParam );

        //
        //  Unhook ourself from the clipboard chain.
        //

        ChangeClipboardChain( hWnd, m_hwndNextClip );
        m_hwndNextClip = NULL;

        break;


    case WM_CONTEXTMENU:
    {
        UINT  nMenu;

        nMenu = (iCurrentSelection( ) > 0 ) ? IDM_POPUPS : IDM_POPUP_NOITEM;

        //
        //  Pop up the context menu.
        //

        HMENU hMenu = LoadMenu( g_hInst, MAKEINTRESOURCE( nMenu ) );

        if( hMenu )
        {
            HMENU hPopup = GetSubMenu( hMenu, 0 );

            if(  hPopup )
            {
                //
                //  Bold the Open menuitem.
                //

                if( nMenu == IDM_POPUPS )
                {
                    MENUITEMINFO iInfo;

                    iInfo.cbSize = sizeof( iInfo );
                    iInfo.fMask = MIIM_STATE;

                    if( GetMenuItemInfo( hMenu, IDM_FILE_SAMPLE, FALSE, &iInfo ) )
                    {
                       iInfo.fState |= MFS_DEFAULT;
                       SetMenuItemInfo( hMenu, IDM_FILE_SAMPLE, FALSE , &iInfo );
                    }
                }
                else
                {
                    UINT nFlag = ( (IsClipboardFormatAvailable( CF_HDROP ) )
                                                    ? cLiveMenu : cDeadMenu );

                    EnableMenuItem( hMenu, IDM_EDIT_PASTE, nFlag );

                    CheckMenuRadioItem(hMenu,
                                       IDM_VIEW_ICON,
                                       IDM_VIEW_DETAILS,
                                       m_idViewMode,
                                       MF_BYCOMMAND);
                }

                DWORD    dwPoint = (DWORD)lParam;

                //
                //  now get the popup positiong:
                //

                if( dwPoint == (DWORD) -1 )
                {
                    POINT pt;
                    int iItem;

                    //
                    //  keyboard...
                    //  Find the selected item
                    //

                    iItem = ListView_GetNextItem( m_hwndList, -1, LVNI_SELECTED );

                    if( iItem != -1 )
                    {
                        RECT rc;
                        int iItemFocus = ListView_GetNextItem( m_hwndList,
                                            -1, LVNI_FOCUSED | LVNI_SELECTED );

                        if( iItemFocus == -1 )
                            iItemFocus = iItem;

                        //
                        //  Note that LV_GetItemRect returns it in client
                        //  coordinate!
                        //

                        ListView_GetItemRect( m_hwndList, iItemFocus,
                                              &rc, LVIR_ICON );

                        pt.x = ( rc.left+rc.right ) / 2;
                        pt.y = ( rc.top+rc.bottom ) / 2;
                    }
                    else
                    {
                        pt.x = pt.y = 0;
                    }

                    MapWindowPoints( m_hwndList, HWND_DESKTOP, &pt, 1 );

                    dwPoint = MAKELONG( pt.x, pt.y );
                }


                TrackPopupMenuEx( hPopup,
                            TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                            GET_X_LPARAM( dwPoint ),  // x pos
                            GET_Y_LPARAM( dwPoint ),  // y pos.
                            m_hwndView,
                            NULL );
            }
            DestroyMenu( hMenu );
        }
    }
    break;

    case WM_COMMAND:
       if( !(GET_WM_COMMAND_ID( wParam, lParam ) > FCIDM_SHVIEWLAST ) )
            return( OnCommand( hWnd, message, wParam, lParam ) );
       break;

    case WM_MENUSELECT:
        return( OnMenuSelect( hWnd, (UINT)LOWORD( wParam ),
                (UINT)HIWORD( wParam ), (HMENU)lParam ) );

    case WM_SETFOCUS:
        if( !m_hwndView )
            //
            //  Ignore if we are destroying hwndView.
            //
            break;

        if( m_hwndList )
        {
            //
            //  pass this to the listview
            //
            SetFocus( m_hwndList );
            UpdateSelectedCount();
            FocusOnSomething(m_hwndList);
        }

        break;

    case WM_SIZE:
        {
        DEBUGMSG( (DM_MESSAGE_TRACE1, TEXT( "FONTEXT: CFontView::ProcessMessage WM_SIZE" ) ) );

        if( wParam != SIZEICONIC )
        {
            //
            // Resize the view.
            // Set "resizing" flag so we know to intercept WM_ERASEBKGND.
            // Helps eliminate flashing of the window during resize.
            //
            m_bResizing = TRUE;
            vShapeView( );
            m_bResizing = FALSE;
        }

        return( 1 );

        }


    case WM_ERASEBKGND:
        if (m_bResizing)
        {
            //
            // Resizing the window.
            // Eat WM_ERASEBKGND so the dialog surface behind the listview
            // isn't repainted.  This helps eliminate flashing of the window during
            // resizing.
            //
            return 1;
        }
        else
        {
            return DefDlgProc(hWnd, message, wParam, lParam);
        }

    case WM_NOTIFY:
        return OnNotify( (LPNMHDR) lParam );

    case WM_SHELL_CHANGE_NOTIFY:
        return OnShellChangeNotify( wParam, lParam );

    default:
        return( DefDlgProc( hWnd, message, wParam, lParam ) );
    } // switch( message )

    return( 0 );
}


BOOL CFontView::OpenCurrent( )
{
    LV_ITEM  Item;

    //
    //  Start at the beginning.
    //

    int  i = -1;
    UINT nFlags = LVNI_SELECTED | LVNI_ALL;


    Item.mask = LVIF_PARAM;

    GetAsyncKeyState( VK_ESCAPE );

    while( ( i = ListView_GetNextItem( m_hwndList, i, nFlags ) ) != -1 )
    {
        if( GetAsyncKeyState( VK_ESCAPE ) & 0x01 )
        {
            break;
        }

        Item.iItem = i;
        Item.iSubItem = 0;

        if( ListView_GetItem( m_hwndList, &Item ) )
        {
            CFontClass * poFont = (CFontClass *)Item.lParam;

            if( !ViewValue( poFont ) )
                return FALSE;
        }
    }
    return TRUE;;
}


BOOL CFontView::PrintCurrent( )
{
    LV_ITEM  Item;
    CFontClass * poFont;

    //
    //  Start at the beginning.
    //

    int i = -1;
    UINT  nFlags = LVNI_SELECTED | LVNI_ALL;


    Item.mask = LVIF_PARAM;

    GetAsyncKeyState( VK_ESCAPE );

    while( ( i = ListView_GetNextItem( m_hwndList, i, nFlags ) ) != -1 )
    {
        if( GetAsyncKeyState( VK_ESCAPE ) & 0x01 )
        {
            break;
        }

        Item.iItem = i;
        Item.iSubItem = 0;

        if( ListView_GetItem( m_hwndList, &Item ) )
        {
            poFont = (CFontClass *)Item.lParam;

            if( !PrintValue( poFont ) )
                return FALSE;
        }
    }

    return TRUE;
}

BOOL CFontView::ViewValue( CFontClass * poFont )
{
    FullPathName_t szFile;
    HINSTANCE      hInst;


    poFont->vGetDirFN( szFile, ARRAYSIZE(szFile) );

    DEBUGMSG( (DM_TRACE1, TEXT( "   Browsing object: %s" ), szFile ) );

    hInst = ShellExecute( m_hwndView, NULL, szFile, szFile, NULL, 1 );

    if( ( (INT_PTR)hInst ) > 32 )
        return TRUE;

    DEBUGMSG( (DM_ERROR, TEXT( "ViewValue failed on %s, %d" ), szFile, hInst) );

    return FALSE;
}


BOOL CFontView::PrintValue( CFontClass * poFont )
{
    FullPathName_t szFile;
    HINSTANCE      hInst;


    poFont->vGetDirFN( szFile, ARRAYSIZE(szFile) );

    DEBUGMSG( (DM_TRACE1, TEXT( "   Browsing object: %s" ), szFile) );

    hInst = ShellExecute( m_hwndView, TEXT( "print" ), szFile, szFile, NULL, 1 );

    if( ( (INT_PTR)hInst ) > 32 )
        return TRUE;

    DEBUGMSG( ( DM_ERROR, TEXT( "ViewValue failed on %s, %d" ), szFile, hInst ) );

    return FALSE;
}


void CFontView::UpdatePanColumn( )
{

    LV_COLUMN  lvc;
    TCHAR      szFmt[ MAX_NAME_LEN ];
    TCHAR      szText[ MAX_NAME_LEN ];


    if( m_idViewMode != IDM_VIEW_PANOSE )
        return;

    if( LoadString( g_hInst, IDS_PAN_COL2, szFmt, ARRAYSIZE( szFmt ) ) )
    {
        TCHAR szName[ MAX_NAME_LEN ];

        if( m_poPanose )
            m_poPanose->vGetName( szName, ARRAYSIZE(szName) );
        else
            szName[ 0 ] = 0;

        StringCchPrintf( szText, ARRAYSIZE(szText), szFmt, szName );
    }
    else
        szText[ 0 ] = 0;

    lvc.mask     = LVCF_TEXT | LVCF_SUBITEM;
    lvc.pszText  = szText;
    lvc.iSubItem = 1;

    ListView_SetColumn( m_hwndList, 1, &lvc );
}


void CFontView::vToggleSelection( BOOL bSelectAll )
{
    //
    //  Start at the beginning.
    //

    int i = -1;

    UINT  nFlags = LVNI_ALL;
    UINT  nState = LVIS_SELECTED;


    while( ( i = ListView_GetNextItem( m_hwndList, i, nFlags ) ) != -1 )
    {
        if( !bSelectAll )
        {
            nState = ListView_GetItemState( m_hwndList, i, LVIS_SELECTED );
            nState = nState ^ LVIS_SELECTED;
        }

        ListView_SetItemState( m_hwndList, i , nState, LVIS_SELECTED );
    }
}


int  CFontView::iCurrentSelection( )
{
    return (int) ListView_GetSelectedCount( m_hwndList );
}


void CFontView::SetViewMode( UINT uMode )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: SetViewMode %d" ), uMode) );

    if( uMode != m_idViewMode )
    {
        UINT  ws = WSFromViewMode( uMode, m_hwndList );

        m_idViewMode = uMode;

        switch( uMode )
        {
        default: // case IDM_VIEW_ICON:
            break;


        case IDM_VIEW_PANOSE:
            //
            //  Make sure the combo box is loaded with the names.
            //
            vLoadCombo( );

            SetListColumns( m_hwndList, PAN_COL_COUNT, PanoseColumns );

            //
            //  The second column contains format text that we can put the
            //  current font name into.
            //

            UpdatePanColumn( );

            break;


         case IDM_VIEW_DETAILS:
            SetListColumns( m_hwndList, FILE_COL_COUNT, FileColumns );
            break;
        }

        ULONG ulOld = SetWindowLong( m_hwndList, GWL_STYLE, ws );

        DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: SetviewMode from %x to %x" ), ulOld, ws) );

        vShapeView( );

        SortObjects( );

        InvalidateRect( m_hwndList, NULL, TRUE );

        UpdateWindow( m_hwndList );

        UpdateToolbar( );
    }
}


void CFontView::vShapeView( )
{
    RECT  rc;
    BOOL  bPanoseView = m_idViewMode == IDM_VIEW_PANOSE;
    int   nCmdShow    = bPanoseView ? SW_SHOW : SW_HIDE;

    //
    // Hide or show panose controls depending on view mode.
    //
    ShowWindow( m_hwndCombo, nCmdShow );
    ShowWindow( m_hwndText, nCmdShow );

    //
    // Get size of dialog (view) so we can size the listview control.
    //
    GetClientRect( m_hwndView, &rc );

    if (bPanoseView)
    {
        //
        // Panose view adds the "List by similarity" combo box
        // and text.  Adjust the top of the listview control to be
        // adjacent to the bottom of the combo box area.
        //
        RECT  rCombo;
        GetWindowRect( m_hwndCombo, &rCombo );
        ScreenToClient( m_hwndView, (LPPOINT)&rCombo );
        ScreenToClient( m_hwndView, ((LPPOINT)&rCombo) + 1 );
        rc.top = rCombo.bottom + 6;
    }

    //
    // Resize the list view control.
    //
    MoveWindow( m_hwndList, rc.left, rc.top, rc.right-rc.left,
                rc.bottom-rc.top, TRUE );
}



    

void CFontView::vLoadCombo( )
{
    int            iAdd;
    FONTNAME     szName;
    FONTNAME     szSelName;
    CFontClass*    lpFontRec;
    CFontList * poFontList = m_poFontManager->poLockFontList( );
    int            iCount = poFontList->iCount( );
    int            iOldSel;

    //
    //  Reset the Panose origin.
    //

    m_poPanose = NULL;

#ifdef _DEBUG
    szName[ ARRAYSIZE( szName ) - 1 ] = 0;
    szSelName[ ARRAYSIZE( szSelName ) - 1 ] = 0;
#endif

    iOldSel = (int)::SendMessage( m_hwndCombo, CB_GETCURSEL, 0, 0 );

    if( iOldSel != CB_ERR )
    {
        ComboGetText(m_hwndCombo, iOldSel, szSelName, ARRAYSIZE(szSelName));
    }
    ::SendMessage( m_hwndCombo, CB_RESETCONTENT, 0, 0 );

    for( int i = 0; i < iCount; ++i )
    {
        lpFontRec = poFontList->poObjectAt( i );

        if( lpFontRec && lpFontRec->bLTDAndPANOSE( ) )
        {
            lpFontRec->vGetName( szName, ARRAYSIZE(szName) );
            iAdd = (int)::SendMessage( m_hwndCombo, CB_ADDSTRING, 0,
                                       (LPARAM)szName );

            ::SendMessage( m_hwndCombo, CB_SETITEMDATA, iAdd,
                           (LPARAM)lpFontRec );
        }
    }

    if( iOldSel == CB_ERR )
    {
        iOldSel = 0;
        ComboGetText(m_hwndCombo, iOldSel, szSelName, ARRAYSIZE(szSelName));
    }

    if( iOldSel != CB_ERR )
    {
        i = (int)::SendMessage( m_hwndCombo, CB_FINDSTRINGEXACT,
                           (WPARAM) -1, (LPARAM) szSelName );

        if( i != CB_ERR )
        {
            m_poPanose = (CFontClass *)::SendMessage( m_hwndCombo,
                                                      CB_GETITEMDATA, i, 0 );
        }
        ::SendMessage( m_hwndCombo, CB_SETCURSEL, i, 0 );
    }

    m_poFontManager->vReleaseFontList( );

    ASSERT( szName[ ARRAYSIZE( szName ) - 1 ] == 0 );
    ASSERT( szSelName[ ARRAYSIZE( szSelName ) - 1 ] == 0 );
}


STDMETHODIMP CFontView::QueryInterface( REFIID riid, void **ppv )
{
    DEBUGMSG( (DM_NOEOL | DM_TRACE1,
             TEXT( "FONTEXT: CFontView::QueryInterface called for " ) ) );
    //
    //  Dump out the riid
    //

    DEBUGREFIID( (DM_TRACE1, riid) );

    static const QITAB qit[] = {
        QITABENT(CFontView, IShellView),
        QITABENT(CFontView, IDropTarget),
        QITABENT(CFontView, IPersistFolder),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


STDMETHODIMP_(ULONG) CFontView::AddRef( void )
{
   DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::AddRef called: %d->%d references" ),
              m_cRef, m_cRef + 1) );

   return( ++m_cRef );
}


STDMETHODIMP_(ULONG) CFontView::Release( void )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::Release called: %d->%d references" ),
             m_cRef, m_cRef - 1) );

    ULONG retval;


    retval = --m_cRef;

    if( !retval )
    {
        DestroyViewWindow( );
        delete this;
    }

    return( retval );
}


//
// *** IOleWindow methods ***
//

STDMETHODIMP CFontView::GetWindow( HWND FAR * lphwnd )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::GetWindow called" ) ) );

    *lphwnd = m_hwndView;
    return S_OK;
}


STDMETHODIMP CFontView::ContextSensitiveHelp( BOOL fEnterMode )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::ContextSensitiveHelp called" ) ) );

    return E_NOTIMPL;
}


//
// *** IShellView methods ***
//
STDMETHODIMP CFontView::TranslateAccelerator( LPMSG msg )
{
    DEBUGMSG( (DM_MESSAGE_TRACE2, TEXT( "FONTEXT: CFontView::TranslateAccelerator called" ) ) );
    DEBUGMSG( (DM_MESSAGE_TRACE2,
       TEXT( "FONTEXT:        hwnd=0x%x, message=0x%x, wParam=0x%x, lParam=0x%lx," ),
       msg->hwnd, msg->message, msg->wParam, msg->lParam) );
    DEBUGMSG( (DM_MESSAGE_TRACE2, TEXT( "FONTEXT:         time=0x%x, pt=?" ),
             msg->time) );


    BOOL fIsVK_TABCycler = IsVK_TABCycler(msg);
    BOOL fIsBackSpace = IsBackSpace(msg);

    if (GetFocus() == m_hwndList)
    {
        if (::TranslateAccelerator(m_hwndView, (HACCEL) m_hAccel, msg))
        {
            // we know we have a normal view, therefore this is
            // the right translate accelerator to use, otherwise the
            // common dialogs will fail to get any accelerated keys.
            return S_OK;
        }
        else if (WM_KEYDOWN == msg->message || WM_SYSKEYDOWN == msg->message)
        {
            // MSHTML eats these keys for frameset scrolling, but we
            // want to get them to our wndproc . . . translate 'em ourself
            //
            switch (msg->wParam)
            {
            case VK_LEFT:
            case VK_RIGHT:
                // only go through here if alt is not down.
                // don't intercept all alt combinations because
                // alt-enter means something (open up property sheet)
                // this is for alt-left/right compat with IE
                // remark: when debugging, if put break point at if statement, function will not work.
                if (GetAsyncKeyState(VK_MENU) < 0)
                    break;
                // fall through
                
            case VK_UP:
            case VK_DOWN:
            case VK_HOME:
            case VK_END:
            case VK_PRIOR:
            case VK_NEXT:
            case VK_RETURN:
            case VK_F10:
                TranslateMessage(msg);
                DispatchMessage(msg);
                return S_OK;
            }
        }

        // suwatch: If this message is neither VK_TABCycler nor Backspace, try send it to ShellBrowser first.
        if (!fIsVK_TABCycler && !fIsBackSpace)
        {
            if (S_OK == m_psb->TranslateAcceleratorSB(msg, 0))
                return S_OK;
        }
    }

    // suwatch: Backspace and all Alt key combination will be handled by default.
    // Backspace will navigate up the tree.
    // We assume all Alt key combo will be handled by default.
    if (fIsBackSpace || GetKeyState(VK_MENU) < 0)
    {
        return S_FALSE;
    }

    //
    //  If the view has the combo box showing, make sure it gets processed
    //  correctly.
    //
    if( m_idViewMode == IDM_VIEW_PANOSE )
    {
        if( msg->message == WM_KEYFIRST || msg->message == WM_KEYDOWN )
        {

            TCHAR ch = GET_WM_CHARTOITEM_CHAR( msg->wParam, msg->lParam );

            if( ch == VK_TAB && GetFocus( ) == m_hwndCombo )
            {
                return S_FALSE;
            }
        }

        //
        // Handle accelerator translations for Panose view mode.
        //
        if( m_hAccel &&  ::TranslateAccelerator( m_hwndView, (HACCEL) m_hAccel, msg ) )
        {
            return S_OK;
        }

        //
        //  This will handle Alt+L and TAB for all other cases.
        //
        if( IsDialogMessage( m_hwndView, msg ) )
        {
            return S_OK;
        }
    }
    //
    //  If the combo box isn't visible, the processing is easier.
    //
    else if( GetFocus( ) != m_hwndList )
    {
        if( IsDialogMessage( m_hwndView, msg ) )
            return S_OK;
    }

    if( m_hAccel &&  ::TranslateAccelerator( m_hwndView, (HACCEL) m_hAccel, msg ) )
        return S_OK;



        
    return S_FALSE;
}


STDMETHODIMP CFontView::EnableModeless( BOOL fEnable )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::EnableModless called" ) ) );
    return( ResultFromScode( E_NOTIMPL ) );
}


STDMETHODIMP CFontView::UIActivate( UINT uState )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::UIActivate called, uState = %d" ), uState) );

    if( uState != SVUIA_DEACTIVATE )
    {
        OnActivate( uState );
        m_bUIActivated = TRUE;
    }
    else
        OnDeactivate( );

    return NOERROR;
}


STDMETHODIMP CFontView::Refresh( )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::Refresh start" ) ) );

    FillObjects( );

    if( m_idViewMode == IDM_VIEW_PANOSE )
        vLoadCombo( );

    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::Refresh Done" ) ) );

    return( NOERROR );
}


STDMETHODIMP CFontView::CreateViewWindow( IShellView FAR* lpPrevView,
                                          LPCFOLDERSETTINGS lpfs,
                                          IShellBrowser FAR* psb,
                                          RECT FAR* prcView,
                                          HWND FAR* phWnd )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::CreateViewWindow called" ) ) );

    //
    //  Should check lpPrevView for validity
    //

    if( !RegisterWindowClass( ) )
    {
        DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: CFontView - Unable to register window class" ) ) );

        // return( ResultFromScode( E_FAIL ) );
    }

    if (FAILED(GetFontManager(&m_poFontManager)))
    {
        return E_FAIL;
    }

    //
    //  Save off the browser and retrieve our settings before we draw
    //  the window.
    //

    m_psb = psb;

    GetSavedViewState( );

    psb->GetWindow( &m_hwndParent );

    //
    // Load the attribute character string.
    //
    if (TEXT('\0') == g_szAttributeChars[0])
    {
        LoadString(g_hInst,
                   IDS_ATTRIB_CHARS,
                   g_szAttributeChars,
                   ARRAYSIZE(g_szAttributeChars));
    }
    //
    // Fetch the alternate color (for compression) if supplied.
    //
    COLORREF clr;
    DWORD cbClr = sizeof(clr);
    if (SUCCEEDED(SKGetValue(SHELLKEY_HKCU_EXPLORER, NULL, c_szAltColor, NULL, &clr, &cbClr)))
    {
        g_crAltColor = clr;
    }

    //
    //  Set the view mode. Never inherit the Panose view. Force the user
    //  to set it.
    //

    if( lpfs )
    {
        switch( lpfs->ViewMode )
        {
        default:
        case FVM_ICON:
            m_idViewMode = IDM_VIEW_ICON;
            break;

        case FVM_SMALLICON:
        case FVM_LIST:
            m_idViewMode = IDM_VIEW_LIST;
            break;

        case FVM_DETAILS:
            m_idViewMode = IDM_VIEW_DETAILS;
            break;
        }

        //
        //  don't save this if ViewMode is 0 (default)
        //

        if( lpfs->ViewMode )
            m_ViewModeReturn = lpfs->ViewMode;

        m_fFolderFlags = lpfs->fFlags;
    }

    DEBUGMSG( (DM_TRACE2, TEXT( "FONTEXT: CFontView::CVW view window rect=(%d,%d,%d,%d)" ),
             prcView->left, prcView->top, prcView->right, prcView->bottom) );

    if( !(m_hwndView = CreateDialogParam( g_hInst,
                                          MAKEINTRESOURCE( ID_DLG_MAIN ),
                                          m_hwndParent,
                                          FontViewDlgProc,
                                          (LPARAM) this ) ) )

    {
        DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: CFontView::CVW CreateWindow failed" ) ) );
        return( ResultFromScode( E_FAIL ) );
    }

    DragAcceptFiles( m_hwndView, TRUE );

    SHRegisterDragDrop( m_hwndView, (LPDROPTARGET)this );

    *phWnd = m_hwndView;

    //
    //  If using a dialog, we need to resize correctly.
    //

    MoveWindow( m_hwndView,
                prcView->left, prcView->top,
                prcView->right - prcView->left,
                prcView->bottom - prcView->top,
                TRUE );

    //
    // Re-read the registry in case new fonts were added while we were away.
    // If we don't do this, any fonts (without files in the fonts directory)
    // added to the registry aren't displayed in the folder list view.
    //
    m_poFontManager->bRefresh( TRUE );

    FillObjects( );

    // SortObjects( );


    ShowWindow( m_hwndView, SW_SHOW );

    // UpdateWindow( m_hwndView );

    //
    //  The BrowserWindow will invalidate us and force a redraw, so
    //  don't do it now.
    //
    //  ValidateRect( m_hwndView, NULL );

    MergeToolbar( );
    UpdateToolbar( );

    return( NOERROR );
}


STDMETHODIMP CFontView::DestroyViewWindow( )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::DestroyViewWindow called" ) ) );

    if( m_hwndView )
    {
        if (0 != m_uSHChangeNotifyID)
            SHChangeNotifyDeregister(m_uSHChangeNotifyID);

        DragAcceptFiles( m_hwndView, FALSE );

        SHRevokeDragDrop( m_hwndView );

        DestroyWindow( m_hwndView );

        m_hwndView = NULL;
    }

    if (NULL != m_hwndToolTip)
    {
        DestroyWindow(m_hwndToolTip);
        m_hwndToolTip = NULL;
    }

    return( NOERROR );
}




VOID
CFontView::LV_OnHoverNotify(
    LPNMLISTVIEW pnmlv
    )
{
    INT iHit = pnmlv->iItem;

    if (m_bShowPreviewToolTip)
    {
        if (iHit != m_iTTLastHit)
        {
            if (-1 == iHit)
            {
                //
                // Hit nowhere.  Deactivate the tooltip.
                //
                SendMessage(m_hwndToolTip, TTM_ACTIVATE, FALSE, 0);
            }
            else
            {
                //
                // Hit on an item.  Set the tooltip font, text and activate
                // the tooltip.  The tooltip is deactivated while the new
                // font and text are loaded so we don't see an incomplete
                // sample.
                //
                SendMessage(m_hwndToolTip, TTM_ACTIVATE, FALSE, 0);
                UpdateFontSample(iHit);
                if (NULL != m_hfontSample)
                {
                    //
                    // If we were able to load the font and create a sample
                    // for display, display the sample in the tooltip window.
                    //
                    SendMessage(m_hwndToolTip, WM_SETFONT, (WPARAM)m_hfontSample, (LPARAM)FALSE);
                    SendMessage(m_hwndToolTip, TTM_ACTIVATE, TRUE, 0);
                }
            }
            //
            // Need to fake out the tooltip window into thinking that the mouse
            // is over a new tool.  Since we have only one tooltip window,
            // the entire listview object is considered a single tool.  If we don't
            // send this message, the tooltip thinks the mouse is always over
            // the "tool" so we never get a new tooltip when we navigate between
            // items in the listview.
            //
            SendMessage(m_hwndToolTip, WM_MOUSEMOVE, 0, 0);
            m_iTTLastHit = iHit;
        }
    }
}


//
// Update the sample font and text to be displayed in the tooltip window
// for a given item in the listview.
//
VOID
CFontView::UpdateFontSample(
    INT iItem
    )
{
    LV_ITEM item;

    if (NULL != m_hfontSample)
    {
        //
        // Delete a previous font.
        //
        DeleteObject(m_hfontSample);
        m_hfontSample = NULL;
    }

    ZeroMemory(&item, sizeof(item));

    item.iItem    = iItem;
    item.iSubItem = 0;
    item.mask     = LVIF_PARAM;

    //
    // Get the current listview item.
    //
    if (ListView_GetItem(m_hwndList, &item))
    {
        CFontClass *pFont = (CFontClass *)item.lParam;
        TCHAR szFontPath[(MAX_PATH * 2) + 1];           // "PathPFM|PathPFB"

        //
        // Get the font file's full path name.
        //
        if (pFont->bGetFQName(szFontPath, ARRAYSIZE(szFontPath)))
        {
            //
            // If font is a Type1 with an associated PFB,
            // create the "XXXXXX.PFM|XXXXXX.PFB" concatenation to give to
            // GDI.
            //
            LPTSTR pszFontPathPfb = (LPTSTR)szFontPath + lstrlen(szFontPath);

            if (pFont->bGetPFB(pszFontPathPfb + 1, ARRAYSIZE(szFontPath) - (UINT)(pszFontPathPfb - szFontPath) - 1))
            {
                *pszFontPathPfb = TEXT('|');
            }

            INT nFonts;
            DWORD cb = sizeof(nFonts);
            //
            // Get number of fonts in font file so we can size the LOGFONT buffer.
            //
            if (GetFontResourceInfoW(szFontPath, &cb, &nFonts, GFRI_NUMFONTS))
            {
                cb = sizeof(LOGFONT) * nFonts;
                LPLOGFONT plf = (LPLOGFONT)LocalAlloc(LPTR, cb);
                if (NULL != plf)
                {
                    //
                    // Read in the LOGFONT data for the font(s).
                    //
                    if (GetFontResourceInfoW((LPTSTR)szFontPath, &cb, plf, GFRI_LOGFONTS))
                    {
                        //
                        // Create the sample font.
                        //
                        HDC hdc = GetDC(m_hwndList);

                        plf->lfHeight = -MulDiv(FONT_SAMPLE_PT_SIZE,
                                                GetDeviceCaps(hdc, LOGPIXELSY),
                                                72);
                        plf->lfWidth = 0;

                        ReleaseDC(m_hwndList, hdc);

                        m_hfontSample = CreateFontIndirect(plf);

                        //
                        // Update the tip text.
                        // We display a different sample for symbol fonts.
                        //
                        TOOLINFO ti;
                        ti.cbSize      = sizeof(TOOLINFO);
                        ti.uFlags      = TTF_IDISHWND | TTF_SUBCLASS;
                        ti.hwnd        = m_hwndView;
                        ti.hinst       = g_hInst;
                        ti.uId         = (UINT_PTR)m_hwndList;
                        ti.lpszText    = SYMBOL_CHARSET == plf->lfCharSet ? m_pszSampleSymbols
                                                                          : m_pszSampleText;

                        SendMessage(m_hwndToolTip, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);
                    }
                    LocalFree(plf);
                }
            }
        }
    }
    //
    // Note:  m_hfontSample can be NULL on return if the font couldn't be loaded.
    //        In such cases, the caller should not display the sample tooltip.
    //
}


BOOL
CFontView::CreateToolTipWindow(
    VOID
    )
{
    BOOL bResult = FALSE;

    m_hwndToolTip = CreateWindowEx(0,
                                   TOOLTIPS_CLASS,
                                   (LPTSTR)NULL,
                                   0,
                                   CW_USEDEFAULT,
                                   CW_USEDEFAULT,
                                   CW_USEDEFAULT,
                                   CW_USEDEFAULT,
                                   m_hwndList,
                                   (HMENU)NULL,
                                   g_hInst,
                                   NULL);

    if (NULL != m_hwndToolTip)
    {
        TOOLINFO ti;

        //
        // Set tooltip timing parameter so that it pops up when the
        // item is hover selected.
        //
        SendMessage(m_hwndToolTip,
                    TTM_SETDELAYTIME,
                    TTDT_AUTOMATIC,
                    (LPARAM)ListView_GetHoverTime(m_hwndList));

        ti.cbSize      = sizeof(TOOLINFO);
        ti.uFlags      = TTF_IDISHWND | TTF_SUBCLASS;
        ti.hwnd        = m_hwndView;
        ti.hinst       = g_hInst;
        ti.uId         = (UINT_PTR)m_hwndList;
        ti.lpszText    = NULL;

        bResult = (BOOL)SendMessage(m_hwndToolTip,
                                    TTM_ADDTOOL,
                                    0,
                                    (LPARAM)&ti);

        //
        // Activate/Deactivate the tooltip based on the user's current
        // preference.
        //
        SendMessage(m_hwndToolTip, TTM_ACTIVATE, m_bShowPreviewToolTip, 0);
    }

    return bResult;
}


STDMETHODIMP CFontView::GetCurrentInfo( LPFOLDERSETTINGS lpfs )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::GetCurrentInfo called" ) ) );

    // *lpfs = m_fs;

    if( lpfs )
    {
        lpfs->ViewMode = m_ViewModeReturn;
        lpfs->fFlags = m_fFolderFlags;
    }

    return( NOERROR );
}


static const TCHAR *c_szTTOnly = TEXT( "TTOnly" );

INT_PTR CALLBACK CFontView::OptionsDlgProc( HWND hDlg,
                                            UINT message,
                                            WPARAM wParam,
                                            LPARAM lParam )
{
    switch( message )
    {

    case WM_INITDIALOG:
      {
        int fWasSet = (GetProfileInt( c_szTrueType, c_szTTOnly, 0 ) ? 1 : 0 );

        CheckDlgButton( hDlg, IDC_TTONLY, fWasSet );

        SetWindowLongPtr( hDlg, DWLP_USER, 0 );

        break;
      }

    case WM_COMMAND:
      {
        UINT uID = GET_WM_COMMAND_ID( wParam, lParam );

        if( uID == IDC_TTONLY &&
            GET_WM_COMMAND_CMD( wParam, lParam ) == BN_CLICKED )
        {
            SendMessage( GetParent( hDlg ), PSM_CHANGED, (WPARAM) hDlg, 0L );
        }
        break;
      }

    case WM_NOTIFY:
        switch( ( (NMHDR*)lParam)->code )
        {
        case PSN_APPLY:
          {
            int fSet = IsDlgButtonChecked( hDlg, IDC_TTONLY ) ? 1 : 0;

            int fWasSet = (GetProfileInt( c_szTrueType, c_szTTOnly, 0 ) ? 1 : 0 );

            if( fSet != fWasSet )
            {
                WriteProfileString( c_szTrueType, c_szTTOnly,
                                    fSet ? TEXT( "1" ) : TEXT( "0" ) );
                SetWindowLongPtr( hDlg, DWLP_USER, TRUE );
            }
            break;
          }
        }

        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, 0 );
        break;

    case WM_DESTROY:
      {
        LONG_PTR fReboot = GetWindowLongPtr( hDlg, DWLP_USER );

        if( fReboot )
        {
            RestartDialogEx(hDlg, 
                            NULL, 
                            EWX_REBOOT, 
                            SHTDN_REASON_FLAG_PLANNED | 
                            SHTDN_REASON_MAJOR_OPERATINGSYSTEM | 
                            SHTDN_REASON_MINOR_RECONFIG);
        }
        break;
      }

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
                    HELP_WM_HELP, (DWORD_PTR)(LPTSTR) rgOptionPropPageHelpIDs);
        break;

    case WM_CONTEXTMENU:
        if (0 != GetDlgCtrlID((HWND)wParam))
        {
            WinHelp((HWND)wParam,
                    NULL,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)((LPTSTR)rgOptionPropPageHelpIDs));
        }
        break;
    }
    return 0;
}


STDMETHODIMP CFontView::AddPropertySheetPages( DWORD dwReserved,
                                               LPFNADDPROPSHEETPAGE lpfn,
                                               LPARAM lparam )
{
    HPROPSHEETPAGE hpage;
    PROPSHEETPAGE psp;

    psp.dwSize      = sizeof( psp );
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = g_hInst;
    psp.pszTemplate = MAKEINTRESOURCE( ID_DLG_OPTIONS );
    psp.pfnDlgProc  = OptionsDlgProc;
    psp.lParam      = 0;

    hpage = CreatePropertySheetPage( &psp );

    if( hpage )
        lpfn( hpage, lparam );

    return( NOERROR );
}


STDMETHODIMP CFontView::GetSavedViewState( void )
{
    HRESULT  hr;
    LPSTREAM pstm;
    ULONG    ulLen = 0;
    ULONG    ulDataLen = sizeof(m_idViewMode);

    ULARGE_INTEGER libCurPos;
    ULARGE_INTEGER libEndPos;
    LARGE_INTEGER  dlibMove = {0, 0};

    ulDataLen += sizeof(m_bShowPreviewToolTip);

    hr = m_psb->GetViewStateStream( STGM_READ, &pstm );

    if( FAILED( hr ) )
        goto backout0;

    pstm->Seek( dlibMove, STREAM_SEEK_CUR, &libCurPos );
    pstm->Seek( dlibMove, STREAM_SEEK_END, &libEndPos );

    ulLen = libEndPos.LowPart - libCurPos.LowPart;

    if(ulLen >= ulDataLen)
    {
        pstm->Seek( *(LARGE_INTEGER *)&libCurPos, STREAM_SEEK_SET, NULL );
        pstm->Read( &m_idViewMode, sizeof( m_idViewMode ), NULL );
        pstm->Read( &m_bShowPreviewToolTip, sizeof(m_bShowPreviewToolTip), NULL);
    }

    pstm->Release( );

backout0:
    return hr;

}


STDMETHODIMP CFontView::SaveViewState( void )
{
    HRESULT  hr;
    LPSTREAM pstm;
    ULARGE_INTEGER libMove = {0,0};
    ULONG ulWrite;
    ULONG ulDataLen = sizeof(m_idViewMode);

    //
    //  Get a stream to work with
    //
    hr = m_psb->GetViewStateStream( STGM_WRITE, &pstm );

    if( FAILED( hr ) )
       goto backout0;

    ulDataLen += sizeof(m_bShowPreviewToolTip);

    //
    //  The stream is at the begining of our data, I think. So write it in
    //  order.
    //
    hr = pstm->Write( &m_idViewMode, sizeof( m_idViewMode ), &ulWrite );
    hr = pstm->Write( &m_bShowPreviewToolTip, sizeof(m_bShowPreviewToolTip), &ulWrite);
    if( FAILED( hr ) )
       goto backout1;

    libMove.LowPart = ulDataLen;

    pstm->SetSize( libMove );

    //
    //  Release the stream.
    //

backout1:

    pstm->Release( );

backout0:

    return hr;
}


STDMETHODIMP CFontView::SelectItem( LPCITEMIDLIST lpvID, UINT uFlags )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::SelectItem called" ) ) );

    return( ResultFromScode( E_NOTIMPL ) );
}

STDMETHODIMP CFontView::GetItemObject( UINT uItem, REFIID riid, LPVOID *ppv )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::SelectItem called" ) ) );

    return( ResultFromScode( E_NOTIMPL ) );
}


//------------------------------------------------------------------------
// IDropTarget Methods.
//
//

STDMETHODIMP CFontView::DragEnter( IDataObject __RPC_FAR *pDataObj,
                                   DWORD grfKeyState,
                                   POINTL pt,
                                   DWORD __RPC_FAR *pdwEffect )
{
    m_grfKeyState = grfKeyState;
    m_dwEffect = DROPEFFECT_NONE;

    //
    //  TODO: We need to know the type of file and where it's coming from
    //  to determine what kind of operation can be done. Replace the TRUE
    //  with something more accurate.
    //

    if( TRUE )
    {
        m_dwEffect = DROPEFFECT_COPY;

        if( grfKeyState & MK_SHIFT )
            m_dwEffect = DROPEFFECT_MOVE;

        DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::DragEnter called" ) ) );

        if( m_hwndView )
        {
            RECT rc;
            POINT pti;

            GetWindowRect( m_hwndParent, &rc );


            //
            // If the font folder window is RTL mirrored, then the client
            // coordinate are measured from the visual right edge. [samera]
            //
            if (GetWindowLong(m_hwndParent, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
                pti.x = rc.right-pt.x;
            else
                pti.x = pt.x-rc.left;
            pti.y = pt.y-rc.top;
            DAD_DragEnterEx2( m_hwndParent, pti, pDataObj );
        }
    }

    *pdwEffect &= m_dwEffect;

    return NOERROR;
}


STDMETHODIMP CFontView::DragOver( DWORD grfKeyState,
                                  POINTL pt,
                                  DWORD __RPC_FAR *pdwEffect )
{
    m_grfKeyState = grfKeyState;

    if( m_dwEffect != DROPEFFECT_NONE )
    {
       m_dwEffect = DROPEFFECT_COPY;

       if( grfKeyState & MK_SHIFT )
          m_dwEffect = DROPEFFECT_MOVE;

        POINT ptt;
        RECT rc;

        GetWindowRect( m_hwndParent, &rc );

        //
        // If the font folder window is RTL mirrored, then the client
        // coordinate are measured from the visual right edge. [samera]
        //
        if (GetWindowLong(m_hwndParent, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
            ptt.x = rc.right-pt.x;
        else
            ptt.x = pt.x-rc.left;
        ptt.y = pt.y-rc.top;

        DAD_DragMove( ptt );
    }

    *pdwEffect &= m_dwEffect;

    return NOERROR;
}


STDMETHODIMP CFontView::DragLeave( void )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::DragLeave called" ) ) );

    if( m_dwEffect != DROPEFFECT_NONE && m_hwndView )
    {
        DAD_DragLeave( );
    }

    return NOERROR;
}


//
//  APPCOMPAT: The TrackPopupMenu does not work, if the hwnd does not have
//   the input focus. We believe this is a bug in USER, but ...
//

BOOL _TrackPopupMenuEx( HMENU hmenu,
                        UINT wFlags,
                        int x,
                        int y,
                     //    int wReserved,
                        HWND hwndOwner,
                        LPCRECT lprc )
{
    int iRet = FALSE;

    HWND hwndDummy = CreateWindow( TEXT( "Static" ), NULL,
                                   0, x, y, 1, 1, HWND_DESKTOP,
                                   NULL, g_hInst, NULL );

    if( hwndDummy )
    {
        //
        //  to restore
        //

        HWND hwndPrev = GetForegroundWindow( );

        SetForegroundWindow( hwndDummy );
        SetFocus( hwndDummy );

        iRet = TrackPopupMenu( hmenu, wFlags, x, y, 0, hwndDummy, lprc );

        //
        //  We MUST unlock the destination window before changing its Z-order.
        //
        //  DAD_DragLeave( );

        if( iRet && ( iRet != IDCANCEL ) )
        {
            //
            //  non-cancel item is selected. Make the hwndOwner foreground.
            //

            SetForegroundWindow( hwndOwner );
            SetFocus( hwndOwner );
        }
        else
        {
            //
            //  The user canceled the menu.
            //  Restore the previous foreground window
            //   (before destroying hwndDummy).
            //

            if( hwndPrev )
            {
                SetForegroundWindow( hwndPrev );
            }
        }

        DestroyWindow( hwndDummy );
    }

    return iRet;
}


STDMETHODIMP CFontView::Drop( IDataObject __RPC_FAR *pDataObj,
                              DWORD grfKeyState,
                              POINTL pt,
                              DWORD __RPC_FAR *pdwEffect )
{
    HRESULT  hr = NOERROR;


    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView::DragEnter called" ) ) );

    if( m_dwEffect != DROPEFFECT_NONE )
    {
       DAD_DragLeave( );

       //
       //  If this is us sourcing the drag, just bail. We may want to save the
       //  points of the icons.
       //

       if( m_bDragSource )
            goto done;

       //
       //  If this is a right-mouse drag, then ask the user what we should
       //  do. Otherwise, just do what is in m_dwEffect.
       //

       if( m_grfKeyState & MK_RBUTTON )
       {
            //
            //  Pop up the context menu.
            //

            HMENU hMenu = LoadMenu( g_hInst,
                                    MAKEINTRESOURCE( IDM_POPUP_DRAGDROP ) );

            if( hMenu )
            {
                HMENU hPopup = GetSubMenu( hMenu, 0 );

                if( hPopup )
                {
                    //
                    //  Bold the Open menuitem.
                    //

                    MENUITEMINFO iInfo;

                    ZeroMemory(&iInfo, sizeof(iInfo));
                    iInfo.cbSize = sizeof( iInfo );
                    iInfo.fMask  = MIIM_STATE;

                    if( GetMenuItemInfo( hMenu, IDM_POPUP_COPY, FALSE, &iInfo ) )
                    {
                        iInfo.fState |= MFS_DEFAULT;
                        SetMenuItemInfo( hMenu, IDM_POPUP_COPY, FALSE , &iInfo );
                    }

                    UINT idCmd = _TrackPopupMenuEx( hPopup,
                                                    TPM_RETURNCMD
                                                    | TPM_LEFTALIGN
                                                    | TPM_LEFTBUTTON
                                                    | TPM_RIGHTBUTTON,
                                                    pt.x,              // x pos
                                                    pt.y,              // y pos.
                                                    m_hwndView,
                                                    NULL );

                    switch( idCmd )
                    {
                    case IDM_POPUP_MOVE:
                       DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: IDM_POPUP_MOVE" ) ) );

                       m_dwEffect = DROPEFFECT_MOVE;
                       break;

                    case IDM_POPUP_COPY:
                       DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: IDM_POPUP_COPY" ) ) );

                       m_dwEffect = DROPEFFECT_COPY;
                       break;

                    case IDM_POPUP_LINK:
                       DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: IDM_POPUP_LINK" ) ) );

                       m_dwEffect = DROPEFFECT_LINK;
                       break;

                    default:
                    // case IDM_POPUP_CANCEL:
                       DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: IDM_POPUP_CANCEL" ) ) );

                       m_dwEffect = DROPEFFECT_NONE;
                       break;
                    }
                }
                DestroyMenu( hMenu );
            }

            //
            //  The right mouse context menu may have cancelled.
            //

            if( m_dwEffect == DROPEFFECT_NONE )
                goto done;
        }

        //
        //  Do the operation. What we do with the source depends on
        //  m_dwEffect.
        //

        InstallDataObject( pDataObj, m_dwEffect, m_hwndView, this );
    }


done:
   return hr;
}


void MergeHelpMenu( HMENU hmenu, HMENU hmenuMerge )
{
    HMENU hmenuHelp = GetMenuFromID( hmenu, FCIDM_MENU_HELP );

    if ( hmenuHelp )
        Shell_MergeMenus( hmenuHelp, hmenuMerge, 0, 0, (UINT) -1, MM_ADDSEPARATOR );
}


void MergeFileMenu( HMENU hmenu, HMENU hmenuMerge )
{
    HMENU hmenuView = GetMenuFromID( hmenu, FCIDM_MENU_FILE );

    if( hmenuView )
        Shell_MergeMenus( hmenuView, hmenuMerge, 0, 0, (UINT) -1, MM_ADDSEPARATOR );
}


void MergeEditMenu( HMENU hmenu, HMENU hmenuMerge )
{
    HMENU hmenuView = GetMenuFromID( hmenu, FCIDM_MENU_EDIT );

    if( hmenuView )
        Shell_MergeMenus( hmenuView, hmenuMerge, 0, 0, (UINT) -1, 0 );
}


void MergeViewMenu( HMENU hmenu, HMENU hmenuMerge )
{
    HMENU hmenuView = GetMenuFromID( hmenu, FCIDM_MENU_VIEW );


    if( hmenuView )
    {
        int index;

        //
        //  Find the last separator in the view menu.
        //

        for( index = GetMenuItemCount( hmenuView ) - 1; index >= 0; index-- )
        {
            UINT mf = GetMenuState( hmenuView, (UINT)index, MF_BYPOSITION );

            if( mf & MF_SEPARATOR )
            {
                //
                //  merge it right above the separator.
                //
                break;
            }
        }

        //
        //  Add the separator above (in addition to existing one if any).
        //

        InsertMenu( hmenuView, index, MF_BYPOSITION | MF_SEPARATOR, 0, NULL );

        //
        //  Then merge our menu between two separators
        //  (or right below if only one).
        //

        if( index != -1 ) index++;

        Shell_MergeMenus( hmenuView, hmenuMerge, (UINT) index, 0, (UINT) -1, 0 );
    }
}


HMENU GetMenuFromID( HMENU hmMain, UINT uID )
{
    MENUITEMINFO miiSubMenu;


    miiSubMenu.cbSize = sizeof( MENUITEMINFO );
    miiSubMenu.fMask  = MIIM_SUBMENU;

    if( !GetMenuItemInfo( hmMain, uID, FALSE, &miiSubMenu ) )
        return NULL;

    return( miiSubMenu.hSubMenu );
}


void SetListColumns( HWND hWnd, UINT iCount, COLUMN_ENTRY * lpCol )
{
    LV_COLUMN lvc;
    UINT      iCol;
    TCHAR     szText[ MAX_NAME_LEN ];     // 64

    const HWND hwndHeader = ListView_GetHeader(hWnd);
    UINT cPrevColCount    = Header_GetItemCount(hwndHeader);

    //
    //  Delete any columns that will go unused.
    //
    while (cPrevColCount > iCount)
    {
        --cPrevColCount;
        ListView_DeleteColumn(hWnd, cPrevColCount);
    }
    //
    //  Initialize the LV_COLUMN structure.
    //

    lvc.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.pszText = szText;

    if( !g_cxM )
    {
        SIZE siz;
        HDC  hdc = GetDC( HWND_DESKTOP );

        SelectFont( hdc, FORWARD_WM_GETFONT( hWnd, SendMessage ) );

        GetTextExtentPoint( hdc, c_szM, 1, &siz );

        ReleaseDC( HWND_DESKTOP, hdc );

        g_cxM = siz.cx;
    }

    for( iCol = 0; iCol < iCount; iCol++, lpCol++ )
    {
        lvc.iSubItem = iCol;

        lvc.cx  = lpCol->m_iWidth * g_cxM;
        lvc.fmt = lpCol->m_iFormat;

        LoadString( g_hInst,
                    lpCol->m_iID,
                    szText,
                    ARRAYSIZE( szText ) );

        if (iCol < (UINT)Header_GetItemCount(hwndHeader))
        {
            //
            // Column already exists.  Just set it's data.
            //
            ListView_SetColumn(hWnd, iCol, &lvc);
        }
        else
        {
            //
            // Create a new column.
            //
            ListView_InsertColumn(hWnd, iCol, &lvc);
        }
    }
}


void CFontView::StatusPush( UINT nStatus )
{
    TCHAR szText[ 128 ];

    if( LoadString( g_hInst, nStatus, szText, ARRAYSIZE( szText ) ) )
        StatusPush( szText );
}


void CFontView::StatusPush( LPTSTR lpsz )
{
    OLECHAR szOle[ 256 ];


    if( m_psb )
    {
        m_psb->SetStatusTextSB( lpsz );
    }
}


void CFontView::StatusPop( )
{
    //
    //  For now, just clear the thing.
    //

    StatusClear( );
}


void CFontView::StatusClear( )
{
    if( m_psb )
    {
        m_psb->SetStatusTextSB( (LPCOLESTR) TEXT( "" ) );
        m_psb->SendControlMsg( FCW_STATUS, SB_SIMPLE, 0, 0L, NULL );
    }
}


// *** IPersist methods ***

STDMETHODIMP CFontView::GetClassID( LPCLSID lpClassID )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView/IPersistFolder ::GetClassID called" ) ) );

    return ResultFromScode( E_NOTIMPL );
}


// *** IPersistFolder methods ***

STDMETHODIMP CFontView::Initialize( LPCITEMIDLIST pidl )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: CFontView/IPersistFolder ::Initialize called" ) ) );

    HRESULT hResult = E_FAIL;
    TCHAR szPersistDataPath[MAX_PATH];

    if (SHGetPathFromIDList(pidl, szPersistDataPath))
    {
        TCHAR szFontsPath[MAX_PATH];

        ::GetFontsDirectory(szFontsPath, ARRAYSIZE(szFontsPath));

        if (0 == lstrcmpi(szFontsPath, szPersistDataPath))
        {
            //
            // Only treat this persistent storage as the font folder if
            // it is the "fonts" directory on the local machine.  Otherwise,
            // the shell should just browse it as a normal shell folder.
            //
            hResult = NO_ERROR;
        }
    }

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\pfont.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// pfont.cpp
//     Explorer Font Folder extension routines
//     Install Fonts dialog.
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"

#include <direct.h>
#include <shlobjp.h>

#include "commdlg.h"
#include "resource.h"
#include "ui.h"
#include "fontman.h"
#include "cpanel.h"
#include "oeminf.h"
#include "dbutl.h"
#include "fonthelp.h"
#include "fontcl.h"
#include "fontfile.h"
#include "dblnul.h"

#define OF_ERR_FNF 2

#define  ID_BTN_COPYFILES  chx2
#define  ID_BTN_HELP       psh15
#define  ID_BTN_SELALL     psh16
#define  ID_LB_FONTFILES   lst1
#define  ID_LB_FONTDIRS    lst2
#define  ID_CB_FONTDISK    cmb2

#define MAX_FF_PROFILE_LEN    48

#define ffupper(c) ( (TCHAR) CharUpper( MAKEINTRESOURCE( c ) ) )

typedef  UINT (CALLBACK *HOOKER) (HWND, UINT, WPARAM, LPARAM);

#define IsDBCSLeadByte(x) (FALSE)

//
// Macros used to get current path from file open dialog.
// Used in FontHookProc.
// Borrowed from file open dlg code.
//
#define CHAR_BSLASH TEXT('\\')
#define CHAR_NULL   TEXT('\0')

#define DBL_BSLASH(sz) \
   (*(TCHAR *)(sz)       == CHAR_BSLASH) && \
   (*(TCHAR *)((sz) + 1) == CHAR_BSLASH)


typedef struct
{  union {  DWORD ItemData;
      struct { WORD  nFileSlot;
            // BOOL  bTrueType; };   EMR: BOOL in win32 is 32 bits!
            // WORD  bTrueType; };   JSC: For NT, make it FontType for T1 support
               WORD  wFontType; };
   }; // end union
} AddITEMDATA;

//
//  WIN.INI sections
//

static TCHAR szINISTrueType[] = TEXT( "TrueType" );
static TCHAR szINISFonts[]    = TEXT( "fonts" );

//
//  WIN.INI keywords
//

static TCHAR szINIKEnable[] = TEXT( "TTEnable" );
static TCHAR szINIKOnly[]   = TEXT( "TTOnly" );

//
// Globals
//

TCHAR szDot[]  = TEXT( "." );

TCHAR szSetupDir[ PATHMAX ];  // For installing
TCHAR szDirOfSrc[ PATHMAX ];  // For installing
FullPathName_t s_szCurDir;    // Remember last directory for file open dialog.


UINT_PTR CALLBACK FontHookProc( HWND, UINT, WPARAM, LPARAM );


static VOID NEAR PASCAL ResetAtomInDescLB( HWND hLB );

BOOL NEAR PASCAL bAddSelFonts( LPTSTR lpszDir, BOOL bNoCopyJob );
BOOL NEAR PASCAL bFileFound( PTSTR  pszPath,  LPTSTR lpszFile );
BOOL NEAR PASCAL bIsCompressed( LPTSTR szFile );
BOOL NEAR PASCAL bFontInstalledNow( PTSTR  szLHS );
BOOL NEAR PASCAL bInstallFont( HWND hwndParent, LPTSTR lpszSrcPath,
                               BOOL bTrueType, PTSTR szLHS, int* iReply );
BOOL bInstallOEMFile( LPTSTR lpszDir, LPTSTR lpszDstName, size_t cchDstName, LPTSTR lpszDesc,
                      WORD wFontType, WORD wCount );

VOID NEAR PASCAL vPathOnSharedDir( LPTSTR lpszFile, LPTSTR lpszPath, size_t cchPath);

extern HWND ghwndFontDlg;

//
// We provide custom help text for only the following:
//
// 1. "Copy fonts to..." checkbox.
// 2. "Select All" push button.
// 3. "List of Fonts" listbox.
//
// All other requests for context-sensitive help text are forwarded
// to the "file open" common dialog for standard text.
//
const static DWORD rgHelpIDs[] =
{
    ID_BTN_COPYFILES, IDH_FONTS_ADD_COPY_TO_FONT_DIR,
    ID_BTN_SELALL,    IDH_FONTS_ADD_SELECTALL,
    ctlLast+1,        IDH_FONTS_ADD_FONTLIST,
    IDC_LIST_OF_FONTS,IDH_FONTS_ADD_FONTLIST,
    0,0
};


//
// Retrieves the text from a drop-down combo box list.
// Use to prevent LB_GETTEXTLEN from overwriting the destination buffer.
//
int 
ListBoxGetText(
    HWND hwndLB,       // Handle to listbox
    int iItem,         // Index of item
    TCHAR *pszBuffer,  // Destination buffer
    size_t cchBuffer   // Size of dest buffer in chars
    )
{
    int iResult = LB_ERR;
    if (0 < cchBuffer)
    {
        *pszBuffer = 0;

        const DWORD cchText = (DWORD)::SendMessage(hwndLB, LB_GETTEXTLEN, iItem, 0) + 1;
        if (1 < cchText)
        {
            LPTSTR pszTemp = (LPTSTR)LocalAlloc(LPTR, cchText * sizeof(*pszTemp));
            if (NULL != pszTemp)
            {
                iResult = (int)::SendMessage( hwndLB, LB_GETTEXT, iItem, (LPARAM)pszTemp );
                if (FAILED(StringCchCopy(pszBuffer, cchBuffer, pszTemp)))
                {
                    iResult = LB_ERR;
                }
                LocalFree(pszTemp);
            }
        }
    }
    return iResult;
}





/*****************************************************************************
   AddFontsDialog - Our add-on to the commdlg font for listing the font names
*****************************************************************************/


class CWnd {
protected:
   CWnd( HWND hWnd = 0 ) : m_hWnd( hWnd ) {};

public:
   HWND  hWnd( ) { return m_hWnd; }

   void UpdateWindow( )
       { ::UpdateWindow( m_hWnd ); }

   BOOL EnableWindow( BOOL bEnable )
       { return ::EnableWindow( m_hWnd, bEnable ); }

   void SetRedraw( BOOL bRedraw = TRUE )
       { ::SendMessage( m_hWnd, WM_SETREDRAW, bRedraw, 0 ); }

   void InvalidateRect( LPCRECT lpRect, BOOL bErase )
       { ::InvalidateRect( m_hWnd, NULL, bErase ); }

   HWND GetDlgItem( int nID ) const
       { return ::GetDlgItem( m_hWnd, nID ); }


protected:
   HWND  m_hWnd;
};

class CListBox : public CWnd
{
public:
   CListBox( UINT id, HWND hParent ) : CWnd( ), m_id( id )
    {   m_hWnd = ::GetDlgItem( hParent, m_id );

        DEBUGMSG( (DM_TRACE1, TEXT( "CListBox: ctor" ) ) );

#ifdef _DEBUG
        if( !m_hWnd )
        {
            DEBUGMSG( (DM_ERROR, TEXT( "CListBox: No hWnd on id %d" ), id ) );
            // DEBUGBREAK;
        }
#endif

    }

   int GetCount( ) const
       { return (int)::SendMessage( m_hWnd, LB_GETCOUNT, 0, 0 ); }

   int GetCurSel( ) const
       { return (int)::SendMessage( m_hWnd, LB_GETCURSEL, 0, 0 ); }

   int GetSelItems( int nMaxItems, LPINT rgIndex ) const
       { return (int)::SendMessage( m_hWnd, LB_GETSELITEMS, nMaxItems, (LPARAM)rgIndex ); }

   int GetSelCount( ) const
       { return (int)::SendMessage( m_hWnd, LB_GETSELCOUNT, 0, 0 ); }

   int SetSel( int nIndex, BOOL bSelect = TRUE )
       { return (int)::SendMessage( m_hWnd, LB_SETSEL, bSelect, nIndex ); }

   int GetText( int nIndex, LPTSTR pszBuffer, size_t cchBuffer ) const
       { return ListBoxGetText(m_hWnd, nIndex, pszBuffer, cchBuffer); }

   DWORD_PTR GetItemData( int nIndex ) const
       { return ::SendMessage( m_hWnd, LB_GETITEMDATA, nIndex, 0 ); }

   INT_PTR SetItemData( int nIndex, DWORD dwItemData )
       { return ::SendMessage( m_hWnd, LB_SETITEMDATA, nIndex, (LPARAM)dwItemData ); }

   void ResetContent( void )
       { ::SendMessage( m_hWnd, LB_RESETCONTENT, 0, 0 ); }

   int  FindStringExact( int nIndexStart, LPCTSTR lpszFind ) const
       { return (int)::SendMessage( m_hWnd, LB_FINDSTRINGEXACT, nIndexStart, (LPARAM)lpszFind ); }

   int  AddString( LPCTSTR lpszItem )
       { return (int)::SendMessage( m_hWnd, LB_ADDSTRING, 0, (LPARAM)lpszItem ); }

private:
   UINT m_id;
};


class CComboBox : public CWnd
{
public:
   CComboBox( UINT id, HWND hParent ) : CWnd( ), m_id( id )
      { m_hWnd = ::GetDlgItem( hParent, m_id );

        DEBUGMSG( (DM_TRACE1, TEXT( "CComboBox: ctor" ) ) );

        if( !m_hWnd )
        {
            DEBUGMSG( (DM_ERROR, TEXT( "CComboBox: No hWnd on id %d" ), id ) );
            // DEBUGBREAK;
        }
      }

   int GetCurSel( ) const
       { return (int)::SendMessage( m_hWnd, CB_GETCURSEL, 0, 0 ); }

private:
   UINT     m_id;
};


class AddFontsDialog : public CWnd // : public FastModalDialog
{
   public   :  // constructor only
                  AddFontsDialog ( );
                  ~AddFontsDialog( );
            void  vAddSelFonts   ( );
            void  vUpdatePctText ( );

            BOOL  bInitialize(void);

            BOOL  bAdded         ( ) {  return m_bAdded; };

            void  vStartFonts    ( ); //  {  m_nFontsToGo = -1; };

            BOOL  bStartState    ( ) {  return m_nFontsToGo == -1; };

            BOOL  bFontsDone     ( ) {  return m_nFontsToGo == 0;  };

            BOOL  bInitialFonts  ( ) { m_nFonts = pListBoxFiles()->GetCount();
                                       m_nFontsToGo = m_nFonts;
                                       return m_nFonts > 0; };

            void  vHoldComboSel  ( ) { m_nSelCombo = pGetCombo()->GetCurSel(); };

            void  vNewComboSel   ( ) { if( m_nSelCombo == -1 ) vStartFonts( );};

            void  vCloseCombo    ( ) { if( m_nSelCombo != pGetCombo( )->GetCurSel( ) )
                                           vStartFonts( );
                                       m_nSelCombo = -1; };

            CListBox * pListBoxDesc  ( )
                                 { return m_poListBoxDesc;};

            CListBox * pListBoxFiles( )
                                 { return m_poListBoxFiles; };

            //
            //  These were added to make up for no MFC
            //

            void EndDialog( int nRet ) { ::EndDialog( m_hWnd, nRet ); }

            void Attach( HWND hWnd )
                           { m_hWnd = hWnd;
                             m_poComboBox = new CComboBox( ID_CB_FONTDISK, hWnd );
                             m_poListBoxDesc = new CListBox( ID_LB_ADD, hWnd );
                             m_poListBoxFiles = new CListBox( ID_LB_FONTFILES, hWnd );}

            void Detach( ) {m_hWnd = 0;
                           if( m_poComboBox ) delete m_poComboBox;
                           if( m_poListBoxDesc ) delete m_poListBoxDesc;
                           if( m_poListBoxFiles ) delete m_poListBoxFiles; }

            void CheckDlgButton( UINT id, BOOL bCheck )
                                 { ::CheckDlgButton( m_hWnd, id, bCheck ); }

            void EndThread(void)
                { SetEvent(m_heventDestruction); }

            LONG AddRef(void);
            LONG Release(void);


   private :
            CComboBox * pGetCombo( ) { return m_poComboBox;};

   public   :  // fields
            CComboBox *    m_poComboBox;
            CListBox *     m_poListBoxFiles;
            CListBox *     m_poListBoxDesc;
            LPOPENFILENAME m_pOpen;
            BOOL           m_bAdded;
            int            m_nSelCombo;
            int            m_nFonts;
            int            m_nFontsToGo;
            HANDLE         m_hThread;
            DWORD          m_dwThreadId;
            HANDLE         m_heventDestruction; // Used to tell threads we're done.
            LONG           m_cRef;              // Instance reference counter.
};


/*****************************************************************************
   DBCS support.
*****************************************************************************/

#define TRUETYPE_SECTION      TEXT( "TrueType fonts" )
#define WIFEFONT_SECTION      TEXT( "Wife fonts" )
#define TRUETYPE_WITH_OEMINF  (WORD)0x8000
#define MAXFILE   MAX_PATH_LEN

static TCHAR szOEMSetup[] = TEXT( "oemsetup.inf" );

TCHAR szSetupInfPath[ PATHMAX ];

typedef struct tagADDFNT {
        CListBox * poListDesc;
        int     nIndex;
        int     which;
} ADDFNT, far *LPADDFNT;



/*************************************************************************
 * FUNCTION: CutOffWhite
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

VOID NEAR PASCAL CutOffWhite( LPTSTR lpLine, size_t cchLine )
{
    TCHAR  szLineBuf[ 120 ];
    LPTSTR lpBuf = szLineBuf;
    LPTSTR lpch;
    size_t cchLineBuf = ARRAYSIZE(szLineBuf);

    for( lpch = lpLine; *lpch && 1 < cchLineBuf; lpch = CharNext( lpch ) )
    {
        if( *lpch==TEXT( ' ' ) || *lpch == TEXT( '\t' ) )
             continue;
        else
        {
            if( IsDBCSLeadByte( *lpch ) )
            {
                *lpBuf++ = *lpch;
                cchLineBuf--;
                if (1 < cchLineBuf)
                {
                    *lpBuf++ = *(lpch + 1);
                    cchLineBuf--;
                }
            }
            else
            {
                *lpBuf++ = *lpch;
                cchLineBuf--;
            }
        }
    }

    *lpBuf = TEXT( '\0' );

    StringCchCopy( lpLine, cchLine, szLineBuf );
}


/*************************************************************************
 * FUNCTION: StrNToAtom
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

ATOM NEAR PASCAL StrNToAtom( LPTSTR lpStr, int n )
{
    TCHAR szAtom[ 80 ];

    //
    //  Take space for NULL
    //

    const int cchAtom = ARRAYSIZE(szAtom);
    StringCchCopy( szAtom, min(cchAtom, n+1), lpStr );

    CutOffWhite( szAtom, ARRAYSIZE(szAtom) );

    return AddAtom( szAtom );
}


/*************************************************************************
 * FUNCTION: ResetAtomInDescLB
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

VOID NEAR PASCAL ResetAtomInDescLB( HWND hLB )
{
    int   nCount;
    DWORD dwData;


    if( nCount = (int) SendMessage( hLB, LB_GETCOUNT, 0, 0L ) )
    {
        while( nCount > 0 )
        {
            nCount--;

            SendMessage( hLB, LB_GETITEMDATA, nCount, (LPARAM) (LPVOID) &dwData );

            //
            //  Atom handle must be C000H through FFFFH
            //

            if( HIWORD( dwData ) >= 0xC000 )
                DeleteAtom( HIWORD( dwData ) );
        }
    }
}


/*************************************************************************
 * FUNCTION: GetNextFontFromInf
 *
 * PURPOSE:
 *          Get font description from Inf scanline, and set it to LB.
 *          Also set ITEMDATA that includes correct index to file listbox,
 *          and 'tag' name string of inf file.
 *
 * RETURNS:
 *
 *************************************************************************/

#define WHICH_FNT_TT    0
#define WHICH_FNT_WIFE  1

WORD FAR PASCAL GetNextFontFromInf( LPTSTR lpszLine, LPADDFNT lpFnt )
{
    TCHAR   szDescName[ 80 ];
    LPTSTR  lpch,lpDscStart;
    WORD    wRet;
    int     nItem;
    ATOM    atmTagName;

    CListBox *  poListDesc = lpFnt->poListDesc;



    //
    //  Presume failure
    //

    wRet = (WORD)-1; /* Presume failure */

    if( lpch = StrChr( lpszLine, TEXT( '=' ) ) )
    {
        //
        //  Get tag string in 'WifeFont' section
        //

        atmTagName = StrNToAtom( lpszLine, (int)(lpch-lpszLine) );

        //
        //  Get description string from right side of '='.
        //  Setup Inf functions in CPSETUP ensure the string
        //  is formatted as key=value with no space between
        //  the key and the value strings.
        //

        lpDscStart = lpch + 1;
        StringCchCopy(szDescName, ARRAYSIZE(szDescName), lpDscStart);

        if( atmTagName && lpDscStart )
        {
           AddITEMDATA OurData;


           OurData.nFileSlot = (WORD)lpFnt->nIndex;
           OurData.wFontType = (lpFnt->which == WHICH_FNT_TT )
                                    ? (atmTagName & ~TRUETYPE_WITH_OEMINF )
                                    : atmTagName;

           if( poListDesc->FindStringExact( -1, szDescName ) == LB_ERR )
           {
                nItem = poListDesc->AddString( szDescName );

                if( nItem != LB_ERR )
                    poListDesc->SetItemData( nItem, OurData.ItemData );
                else
                {
                    DeleteAtom( atmTagName );

                    DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: Error adding string %s" ),
                              szDescName ) );
                }
            }
            else
            {
                DeleteAtom( atmTagName );

                DEBUGMSG( (DM_TRACE1,TEXT( "String %s already in list" ),
                          szDescName) );
            }

            //
            //  Doesn't matter whether already exists
            //

            wRet = NULL;
        }
        else if( atmTagName )
            DeleteAtom( atmTagName );
    }

    return wRet;
}


/*************************************************************************
 * FUNCTION: FindOemInList
 *
 * PURPOSE:
 *          Scan contents of listbox, checking if that is oemsetup.inf.
 *
 * RETURNS:
 *
 *************************************************************************/

BOOL NEAR PASCAL FindOemInList( CListBox * pListFiles,
                                int nFiles,
                                LPINT pIndex,
                                LPTSTR pszInfFileName,
                                size_t cchInfFileName)
{
    int   i;
    TCHAR szFile[ MAXFILE ];


    DEBUGMSG( (DM_TRACE1,TEXT( "FONTEXT: FindOemInList" ) ) );

    for( i = 0; i < nFiles; i++ )
    {
        if( pListFiles->GetText( i, szFile, ARRAYSIZE(szFile) ) != LB_ERR )
        {
            if( !lstrcmpi( szFile, szOEMSetup ) )
            {
                *pIndex = i;
                if (FAILED(StringCchCopy(pszInfFileName, cchInfFileName, szFile )))
                    return FALSE;

                //
                //  found oemsetup.inf ... return index
                //

                return TRUE;
            }
        }
        else
            //
            //  fail
            //
            return FALSE;
    }

    //
    //  not found
    //

    return FALSE;
}


/*****************************************************************************
   Module-global variables
*****************************************************************************/

static AddFontsDialog*  s_pDlgAddFonts = NULL;
static UINT s_iLBSelChange = 0;



/*************************************************************************
 * FUNCTION: AddFontsDialog
 *
 * PURPOSE: class constructor
 *
 * RETURNS:
 *
 *************************************************************************/

AddFontsDialog::AddFontsDialog( )
   : CWnd( ),
      m_bAdded( FALSE ),
      m_poListBoxFiles( 0 ),
      m_poListBoxDesc( 0 ),
      m_hThread( NULL ),
      m_heventDestruction(NULL),
      m_cRef(0)
{
   /* vSetHelpID( IDH_DLG_FONT2 ); */
    AddRef();
}


/*************************************************************************
 * FUNCTION: ~AddFontsDialog
 *
 * PURPOSE: class destructor
 *
 * RETURNS:
 *
 *************************************************************************/

AddFontsDialog::~AddFontsDialog( )
{
    if (NULL != m_heventDestruction)
        CloseHandle(m_heventDestruction);

    if (NULL != m_hThread)
        CloseHandle(m_hThread);
}

//
// AddRef and Release
//
// These functions have the same meaning as in OLE (sort of).
// When the reference count drops to 0, the object is deleted. The return
// values for each carry the same reliability caveat as their OLE counterparts.
// Note that this only works for dynamically-created objects.  If Release() is
// called for an object not created with the C++ "new" operator, the call to
// "delete" will fault.
// Because two different threads access the dialog object through a
// statically-defined pointer.  The AddRef/Release mechanism works well for
// controlling the lifetime of this object and ensuring the object is available
// for each thread.
//
LONG AddFontsDialog::AddRef(void)
{
    LONG cRef = InterlockedIncrement(&m_cRef);
    DEBUGMSG((DM_TRACE1, TEXT("AddFontsDialog::AddRef %d -> %d"), cRef - 1, cRef ));
    return cRef;
}


LONG AddFontsDialog::Release(void)
{
    ASSERT( 0 != m_cRef );
    LONG cRef = InterlockedDecrement(&m_cRef);

    DEBUGMSG((DM_TRACE1, TEXT("AddFontsDialog::Release %d -> %d"), cRef+1, cRef));
    if ( 0 == cRef )
    {
        delete this;
        DEBUGMSG((DM_TRACE1, TEXT("AddFontsDialog: Object deleted.")));
    }

    return cRef;
}


/*************************************************************************
 * FUNCTION: AddFontsDialog::bInitialize
 *
 * PURPOSE:  Do any object initializations that may fail.
 *
 * RETURNS:  TRUE  = Object initialized.
 *           FALSE = Initialization failed.
 *
 *************************************************************************/

BOOL AddFontsDialog::bInitialize(void)
{
    //
    // If the destruction event object hasn't been created, create it.
    // This event object is used to tell the dialog's background thread
    // when to exit.
    //
    if (NULL == m_heventDestruction)
    {
        m_heventDestruction = CreateEvent(NULL,  // No security attrib.
                                          TRUE,  // Manual reset.
                                          FALSE, // Initially non-signaled.
                                          NULL); // Un-named.
    }

    return (NULL != m_heventDestruction);
}


/*************************************************************************
 * FUNCTION: dwThreadProc
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

DWORD dwThreadProc( AddFontsDialog * poFD )
{
    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: BG thread running" ) ) );

    if (NULL != poFD)
    {
        poFD->AddRef();

        if(NULL == poFD->hWnd())
        {
            DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: BG thread window is null!!!" ) ) );
            DEBUGBREAK;
        }

        if (NULL != poFD->m_heventDestruction)
        {
            while( 1 )
            {
                //
                // Tell Dialog Proc to add more items to the dialog's font listbox.
                //
                PostMessage( poFD->hWnd(), WM_COMMAND, (WPARAM)IDM_IDLE, (LPARAM)0 );

                //
                // Wait max of 2 seconds for event to signal.
                // If signaled, exit loop and end thread proc.
                //
                if (WaitForSingleObject(poFD->m_heventDestruction, 2000) == WAIT_OBJECT_0)
                    break;
            }
        }
        poFD->Release();
    }

    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: BG thread completed." ) ) );

    return 0;
}


/*************************************************************************
 * FUNCTION: vStartFonts
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

void  AddFontsDialog::vStartFonts( )
{

    DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT:  ---------- vStartFonts-------" ) ) );

    //
    //  Set the start state.
    //

    m_nFontsToGo = -1;

    //
    //  Create the background thread
    //

    if( !m_hThread )
    {
        m_hThread = CreateThread( NULL,
                                  0,
                                  (LPTHREAD_START_ROUTINE) dwThreadProc,
                                  (LPVOID) this,
                                  IDLE_PRIORITY_CLASS | CREATE_NO_WINDOW,
                                  &m_dwThreadId );
    }

#ifdef _DEBUG
    if( !m_hThread )
    {
        DEBUGMSG( (DM_ERROR, TEXT( "BG Thread not created" ) ) );
        DEBUGBREAK;
    }
#endif

}


/*************************************************************************
 * FUNCTION: vUpdatePctText
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

void  AddFontsDialog::vUpdatePctText( )
{
    int    pct;
    TCHAR  szFontsRead[ 80 ] = {0};
    TCHAR  szTemp[ 80 ] = { TEXT( '\0' ) };

    if( m_nFontsToGo > 0 )
    {
       LoadString( g_hInst, IDSI_FMT_RETRIEVE, szFontsRead, 80 );

       pct = (int) ((long) ( m_nFonts - m_nFontsToGo ) * 100 / m_nFonts );

       StringCchPrintf( szTemp, ARRAYSIZE(szTemp), szFontsRead, pct );
    }

    SetDlgItemText( m_hWnd, ID_SS_PCT, szTemp );
}


BOOL bRemoteDrive( LPCTSTR szDir )
{
    if( szDir[ 0 ] == TEXT( '\\' ) && szDir[ 1 ] == TEXT( '\\' ) )
    {
        //
        //  This is a UNC name
        //

        return( TRUE );
    }

    if( IsDBCSLeadByte( szDir[ 0 ]) || szDir[ 1 ] != TEXT( ':' )
            || szDir[ 2 ] != TEXT( '\\' ) )
    {
        return( FALSE );
    }

    TCHAR szRoot[ 4 ];
    StringCchCopy( szRoot, ARRAYSIZE(szRoot), szDir );

    switch( GetDriveType( szRoot ) )
    {
    case DRIVE_REMOTE:
    case DRIVE_REMOVABLE:
    case DRIVE_CDROM:
        return( TRUE );

    default:
        break;
    }

    return( FALSE );
}


/*************************************************************************
 * FUNCTION: vAddSelFonts
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

void AddFontsDialog :: vAddSelFonts( )
{
    FullPathName_t szCurDir;

    BOOL  bAddFonts  = TRUE;
    BOOL  bCopyFiles = IsDlgButtonChecked( m_hWnd, ID_BTN_COPYFILES );

    if (0 < GetCurrentDirectory( ARRAYSIZE( szCurDir ), szCurDir ))
    {
        if (!lpCPBackSlashTerm( szCurDir, ARRAYSIZE(szCurDir)))
        {
            goto done;
        }
   
        //
        //  If we're not going to copy the font files, but they live on a remote
        //  disk for a removeable disk, we'd better make sure the user understands
        //  the implications
        //

        if( !bCopyFiles )
        {
            if( bRemoteDrive( szCurDir ) &&
                iUIMsgYesNoExclaim(m_hWnd, IDSI_MSG_COPYCONFIRM ) != IDYES )
            {
                goto done;
            }
        }

        //
        //  Save off the current directory. bAddSelFonts( ) may change it.
        //
        TCHAR  szCWD[ MAXFILE ];
        if (0 < GetCurrentDirectory( ARRAYSIZE( szCWD ), szCWD ))
        {
            if( bAddSelFonts( szCurDir, !bCopyFiles ) )
                m_bAdded = TRUE;

            SetCurrentDirectory( szCWD );
        }
    }

    //
    //  From here, we dispose of the dialog appropriately
    //

done:
    if( m_bAdded )
    {
        ResetAtomInDescLB( s_pDlgAddFonts->pListBoxDesc()->hWnd() );

        FORWARD_WM_COMMAND( m_hWnd, IDABORT, 0, 0, PostMessage );
    }
    else
        ShowWindow( m_hWnd, SW_NORMAL );

    return;
}


extern BOOL bRegHasKey( const TCHAR * szKey, TCHAR * szVal = 0, int iValLen = 0 );


/*************************************************************************
 * FUNCTION: bFontInstalledNow
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

BOOL NEAR PASCAL bFontInstalledNow( PTSTR szLHS )
{
    return  bRegHasKey( szLHS );
}


/***************************************************************************
 * FUNCTION: vPathOnSharedDir
 *
 * PURPOSE:  Make a full path name out of the input file name and on the
 *           shared directory
 *
 * RETURNS:  none
 ***************************************************************************/

VOID NEAR PASCAL vPathOnSharedDir( LPTSTR lpszFileOnly, LPTSTR lpszPath, size_t cchPath )
{
    StringCchPrintf(lpszPath, cchPath, TEXT("%s%s"), s_szSharedDir, lpszFileOnly);
}


/***************************************************************************
 * FUNCTION:   vHashToNulls
 *
 * PURPOSE:    Substitute nulls for all the hash (TEXT( '#' )) characters in the input
 *             string - we use this to help with strings that need embedded
 *             nulls but also need to be stored in resource files.
 *
 * RETURNS:    none
 ***************************************************************************/

VOID NEAR PASCAL vHashToNulls( LPTSTR lp )
{
    while( *lp )
        if( *lp == TEXT( '#' ) )
            *lp++ = NULL;
        else
            lp = CharNext( lp );
}



/////////////////////////////////////////////////////////////////////////////
//
// bIsCompressed
//
//  Leave this function as only ANSI because it just checks the header to
//  determine if it is a compress file or not.
//
/////////////////////////////////////////////////////////////////////////////

BOOL bIsCompressed( LPTSTR szFile )
{
    static CHAR szCmpHdr[] = "SZDD\x88\xf0'3";

    BOOL     bRet = FALSE;
    HANDLE   fh;
    CHAR     buf[ ARRAYSIZE( szCmpHdr ) ];


    if( ( fh = wCPOpenFileWithShare( szFile, NULL, 0, OF_READ ) )
              == (HANDLE) INVALID_HANDLE_VALUE )
        return(FALSE);

    buf[ ARRAYSIZE( buf ) - 1 ] = '\0';

    if( MyByteReadFile( fh, buf, ARRAYSIZE( buf ) - 1 )
           && !lstrcmpA( buf, szCmpHdr ) )
        bRet = TRUE;

    MyCloseFile( fh );

    return( bRet );
}


/***************************************************************************
 * FUNCTION:   bFileFound
 *
 * PURPOSE:    Check for existance of the given file - we really want it
 *             not to exist.
 *
 * RETURNS:    BOOL - True if file exists
 ***************************************************************************/

BOOL PASCAL bFileFound( LPTSTR pszFullPath, LPTSTR lpszFileOnly )
{
    if( wCPOpenFileWithShare( pszFullPath, NULL, 0, OF_EXIST )
            != (HANDLE) INVALID_HANDLE_VALUE )
        return TRUE;
    else
        return GetModuleHandle( lpszFileOnly ) != NULL;
}


/////////////////////////////////////////////////////////////////////////////
//
// UniqueFilename
//
//   Guarantee a unique filename in a directory.  Do not overwrite existing
//   files.
//
/////////////////////////////////////////////////////////////////////////////

BOOL PASCAL bUniqueFilename( LPTSTR lpszDst, size_t cchDst, LPTSTR lpszSrc, LPTSTR lpszDir )
{
    TCHAR   szFullPath[PATHMAX];
    LPTSTR  lpszFile, lpszSrcExt, lpszDstExt;
    WORD    digit = 0;


    StringCchCopy( szFullPath, ARRAYSIZE(szFullPath), lpszDir );
    lpszFile = lpCPBackSlashTerm( szFullPath, ARRAYSIZE(szFullPath) );
    if (!lpszFile)
    {
        //
        // Not enough room to append a backslash.
        //
        return FALSE;
    }
    StringCchCopy( lpszFile, ARRAYSIZE(szFullPath) - (lpszFile - szFullPath), lpszSrc );

    if( !(lpszSrcExt = _tcschr( lpszSrc, TEXT( '.' ) ) ) )
        lpszSrcExt = szDot;


    if( wCPOpenFileWithShare( szFullPath, NULL, 0, OF_EXIST ) == INVALID_HANDLE_VALUE )
        goto AllDone;

    if( !(lpszDstExt = _tcschr( lpszFile, TEXT( '.' ) ) ) )
        lpszDstExt = lpszFile + lstrlen( lpszFile );

    while( lpszDstExt - lpszFile < 7 )
        *lpszDstExt++ = TEXT( '_' );

    do
    {
        TCHAR szTemp[ 8 ];

        StringCchPrintf( szTemp, ARRAYSIZE(szTemp), TEXT( "%X" ), digit++ );

        if( digit++ > 0x4000 )
            return( FALSE );

        LPTSTR pszWrite = lpszFile + 8 - lstrlen(szTemp);
        if (FAILED(StringCchCopy( pszWrite, ARRAYSIZE(szFullPath) - (pszWrite - szFullPath), szTemp )) ||
            FAILED(StringCchCat( lpszFile, ARRAYSIZE(szFullPath) - (lpszFile - szFullPath), lpszSrcExt )))
        {
            return( FALSE );
        }
    }
    while( wCPOpenFileWithShare( szFullPath, NULL, 0, OF_EXIST ) != INVALID_HANDLE_VALUE );

AllDone:
    if (FAILED(StringCchCopy( lpszDst, cchDst, lpszFile )))
        return( FALSE );

    return( TRUE );
}


/***************************************************************************
 * FUNCTION: bUniqueOnSharedDir
 *
 * PURPOSE:  Given the source filename, lpszSRc and the directory on which
 *           it resides, lpszDir, make a unique filename by sticking letters
 *           on the end of the name until we get a good one.
 *
 * RETURNS:  BOOL - success of attempt
 ***************************************************************************/

BOOL NEAR PASCAL bUniqueOnSharedDir( LPTSTR lpszUniq, size_t cchUniq, LPTSTR lpszSrc )
{
    TCHAR           szOrigExt[ 5 ];     // Hold input file extension
    FullPathName_t szFullPath;          // Working space for unique name
    LPTSTR          lpszFileOnly;       // Points withing szFullPath
    LPTSTR          lpCh;


    //
    //  Make the full file name out of the input directory and file names.
    //  Hold pointer to where file portion begins
    //

    vPathOnSharedDir( lpszSrc, szFullPath, ARRAYSIZE(szFullPath) );

    lpszFileOnly = PathFindFileName( szFullPath );

    //
    //  Check the full file for existance  - if we couldn't find it, good -
    //  that's what we were shooting for.  Otherwise, make a unique name
    //

    if( bFileFound( szFullPath, lpszFileOnly ) )
    {
        //
        //  Original file not unique
        //

        //
        //  Now we're going to work on making the fake file name.  To make
        //  it easier we're going to force the name length to be at least
        //  7 characters.  We're going to mess with the name in our local
        //  scratch space, to that's where we set the pointers.  We also
        //  hold our extension so that we can shove it on as we iterate thru
        //  the name guesses.
        //

        if( lpCh = StrChr( lpszFileOnly, TEXT( '.' ) ) )
        {
            StringCchCopy( szOrigExt, ARRAYSIZE(szOrigExt), lpCh );

            //
            //  Chop name at extension point.
            //

            *lpCh = 0;
        }
        else
            StringCchCopy( szOrigExt, ARRAYSIZE(szOrigExt), TEXT( "." ) );

        while( lstrlen( lpszFileOnly ) < 7 )
            StringCchCat( lpszFileOnly, ARRAYSIZE(szFullPath) - (lpszFileOnly - szFullPath), TEXT( "_" ) );

        //
        //  Now we're going to try to make the names.  We'll loop through
        //  hex digits, building file names with the digit stuck in the last
        //  spot, followed by our extension.
        //

        WORD digit = 0;
        TCHAR szTemp[ 8 ];


        do
        {
            StringCchPrintf( szTemp, ARRAYSIZE(szTemp), TEXT( "%X" ), digit++ );

            if( digit++ > 0x4000 )
                //
                //  Give up at some point
                //

                return FALSE;

            LPTSTR pszWrite = lpszFileOnly + 8 - lstrlen(szTemp);
            if (FAILED(StringCchCopy( pszWrite, ARRAYSIZE(szFullPath) - (pszWrite - szFullPath), szTemp )) ||
                FAILED(StringCchCat( lpszFileOnly, ARRAYSIZE(szFullPath) - (lpszFileOnly - szFullPath), szOrigExt )))
            {
                return( FALSE );
            }
        } while( bFileFound( szFullPath, lpszFileOnly ) );

    }  // Original file not unique

    //
    //  We now have a unique name, copy it to the output space
    //

    if (FAILED(StringCchCopy( lpszUniq, cchUniq, lpszFileOnly )))
        return FALSE;

    return TRUE;
}


/***************************************************************************
 * FUNCTION: IGetExpandedName
 *
 * PURPOSE:  get the expanded name, but fill in the common extensions if
 *           it's not imbedded in the compressed file.
 *
 *  Some compressed dudes don't have the missing last character imbedded
 *  in the file.  if this is the case, we check to see if it's in the known
 *  extension list above.  If it is, we change the name ourselves
 *
 * RETURNS:  INT - same as LZ functions
 ***************************************************************************/

TCHAR *c_aKnownExtensions[] = {
    TEXT( "ttf" ),
    TEXT( "fon" ),
};


DWORD IGetExpandedName( LPTSTR lpszSrc, LPTSTR lpszDest, UINT cchDest )
{
    LPTSTR lpszDestExt;

    CFontFile file;
    DWORD dwReturn = file.GetExpandedName(lpszSrc, lpszDest, cchDest);

    lpszDestExt = PathFindExtension( lpszDest );

    if( lpszDestExt && *lpszDestExt )
    {
        lpszDestExt++;

        //
        //  is it missing the last character?
        //  assumes that if the uncompressed extension was 2 characters,
        //  it's missing one.
        //

        if( lstrlen( lpszDestExt ) == 2 )
        {
            int i;

            for( i = 0; i < ARRAYSIZE( c_aKnownExtensions ); i++ )
            {
                if( !StrCmpNI( lpszDestExt, c_aKnownExtensions[ i ], 2 ) )
                {
                    //
                    //  matches!  Take it the corresponding full extension
                    //

                    StringCchCopy( lpszDestExt, cchDest - (lpszDestExt - lpszDest), c_aKnownExtensions[ i ]);

                    break;
                }
            }
        }

        //
        //  this preserves the long file name because
        //  getexpandedname always returns the short name
        //

        if( lstrlen( lpszDestExt ) <= 3 )
        {
            TCHAR szExt[ 4 ];

            //
            //  save away the extension
            //

            StringCchCopy( szExt, ARRAYSIZE(szExt), lpszDestExt );

            //
            //  restore the long name
            //

            StringCchCopy( lpszDest, cchDest, lpszSrc );

            lpszDestExt = PathFindExtension( lpszDest );

            //
            //  blast back the new extension
            //

            if( lpszDestExt && *lpszDestExt )
            {
                lpszDestExt++;
                StringCchCopy( lpszDestExt, cchDest - (lpszDestExt - lpszDest), szExt );
            }
        }
    }

    return dwReturn;

}


/***************************************************************************
 * FUNCTION:   bAddSelFonts
 *
 * PURPOSE:    Install all the fonts that are currently selected in the
 *             add dialog
 *
 * RETURNS:    BOOL - True if any fonts have been installed - not necessarily
 *             all that were requested
 ***************************************************************************/

BOOL NEAR PASCAL bAddSelFonts( LPTSTR lpszInDir,
                               BOOL   bNoCopyJob )
{
    FontDesc_t     szLHS;
    FullPathName_t szTruePath;
    FullPathName_t szSelPath;
    FullPathName_t szFontPath;
    FullPathName_t szInDirCopy;
    FILENAME       szDstFile;
    FILENAME       szSelFile;     // Filename from listbox (but Uppercase )
    BOOL           bTrueType;
    BOOL           bNoCopyFile;
    int            nSelSlot;
    AddITEMDATA    OurData;
    int            iReply = 0;
    BOOL           bOnSharedDir    = FALSE;
    BOOL           bFontsInstalled = FALSE;
    CListBox *     pListFiles      = s_pDlgAddFonts->pListBoxFiles( );
    CListBox *     pListDesc       = s_pDlgAddFonts->pListBoxDesc( );
    WaitCursor     cWaiter;          // Starts and stops busy cursor
    WORD           wCount = 0;
    int            iTotalFonts, i = 0;
    //
    // Create "saved" versions of bNoCopyFile and bOnSharedDir
    // so that the original values are used for call to InstallT1Font( )
    // in the "for each file" loop.
    // Code following the call to InstallT1Font modifies bNoCopyFile and
    // bOnSharedDir so that they are incorrect on subsequent calls to
    // InstallT1Font.
    //
    BOOL bNoCopyFileSaved  = FALSE;
    BOOL bOnSharedDirSaved = FALSE;

    BOOL bOwnInstallationMutex = FALSE;
    HWND hwndProgress = NULL;
    CFontManager *poFontManager = NULL;

    //
    //  Determine if the files are already in the shared directory
    //  (which is where they're headed).
    //

    bOnSharedDirSaved = bOnSharedDir = (lstrcmpi( lpszInDir, s_szSharedDir ) == 0);

    bNoCopyFileSaved = bNoCopyFile = (bNoCopyJob || bOnSharedDir);


    iTotalFonts = pListDesc->GetSelCount( );

    if (!iTotalFonts)
        iTotalFonts = 1;

    //
    //  Init Type1 font installation and Progress dialog
    //

    InitPSInstall( );
    hwndProgress = InitProgress( pListDesc->hWnd() );

    //
    //  We're going to loop until we can't get any more fonts from the
    //  the selection list of the description list box
    //

    while(pListDesc->GetSelItems( 1, &nSelSlot ) )
    {
        if (InstallCancelled())
            goto OperationCancelled;

        if (SUCCEEDED(GetFontManager(&poFontManager)))
        {
            //
            // Must own installation mutex to install font.
            //
            INT iUserResponse  = IDRETRY;
            DWORD dwWaitResult = CFontManager::MUTEXWAIT_SUCCESS;

            while( IDRETRY == iUserResponse &&
                   (dwWaitResult = poFontManager->dwWaitForInstallationMutex()) != CFontManager::MUTEXWAIT_SUCCESS )
            {
                if ( CFontManager::MUTEXWAIT_WMQUIT != dwWaitResult )
                    iUserResponse = iUIMsgRetryCancelExclaim(hwndProgress, IDS_INSTALL_MUTEX_WAIT_FAILED, NULL);
                else
                {
                    //
                    // Cancel if thread received WM_QUIT while waiting for mutex.
                    //
                    iUserResponse = IDCANCEL;
                }
            }
            ReleaseFontManager(&poFontManager);

            //
            // If user chose to cancel or we got a WM_QUIT msg, cancel the installation.
            //
            if ( IDCANCEL == iUserResponse )
                goto OperationCancelled;

            bOwnInstallationMutex = TRUE;
        }

        //
        //  While selected desc
        //

        //
        //  Assume we're continuing.
        //

        iReply = 0;

        //
        //  Pull out a selected font, marking as unselected (so we don't grab
        //  again), and get the font name string.
        //

        pListDesc->SetSel( nSelSlot, FALSE );

        pListDesc->GetText( nSelSlot, szLHS, ARRAYSIZE(szLHS) );

        vUIPStatusShow( IDS_FMT_FONTINS, szLHS );

        //
        //  If the current selected font is already installed, don't reinstall
        //  until the user de-installs it.  Inform the user, and drop to
        //  decision handler.
        //

        if( bFontInstalledNow( szLHS ) )
        {
            UINT uMB = (pListDesc->GetSelCount( ) )
                                ? (MB_OKCANCEL | MB_ICONEXCLAMATION )
                                : MB_OK | MB_ICONEXCLAMATION;

            iReply = iUIMsgBox( hwndProgress, IDSI_FMT_ISINSTALLED, IDS_MSG_CAPTION,
                                uMB, szLHS );
            goto ReplyPoint;
        }

        //
        //  Now we can get the corresponding font file name from the files
        //  list box (since we can get its slot).  Force to uppercase for
        //  safety.
        //

        OurData.ItemData = (DWORD)pListDesc->GetItemData( nSelSlot );

        pListFiles->GetText( OurData.nFileSlot, szSelFile, ARRAYSIZE(szSelFile) );

        bTrueType = (OurData.wFontType == TRUETYPE_FONT);

        //
        //  Update the overall progress dialog
        //

        UpdateProgress (iTotalFonts, i + 1, i * 100 / iTotalFonts);

        i++;

        //
        //  Build the complete selected file path name by appending to
        //  the input directory string
        //

        StringCchPrintf(szSelPath, ARRAYSIZE(szSelPath), TEXT("%s%s"), lpszInDir, szSelFile);

        //
        //  Save a copy of the input directory to be used from here on.
        //

        StringCchCopy( szInDirCopy, ARRAYSIZE(szInDirCopy), lpszInDir );

        BOOL    bUpdateWinIni;
        int     ifType;


        if( (OurData.wFontType == TYPE1_FONT)
           || (OurData.wFontType == TYPE1_FONT_NC) )
        {

            bNoCopyFile  = bNoCopyFileSaved;
            bOnSharedDir = bOnSharedDirSaved;

            //
            //  szSelPath has the full source file name
            //
            //  For installations involving the conversion of the Type1
            //  font to TrueType:
            //
            //         "szSelPath" has the destination name of the
            //                     installed TrueType font file.
            //         "szLHS"     is munged to contain "(TrueType)".
            //

            switch( ::InstallT1Font( hwndProgress,
                                     !bNoCopyFile,      //  Copy TT file?
                                     !bNoCopyFile,      //  Copy PFM/PFB files?
                                     bOnSharedDir,      //  Files in Shared Dir?
                                     szSelPath,         //  IN:  PFM File & Dir
                                                        //  OUT: TTF File & Dir
                                     ARRAYSIZE(szSelPath),
                                     szLHS,             //  IN & OUT: Font desc
                                     ARRAYSIZE(szLHS)) )
            {
            case TYPE1_INSTALL_TT_AND_MPS:
                //
                //  The PS font was converted to TrueType and a matching
                //  PostScript font is ALREADY installed.
                //
                // bDeletePSEntry = TRUE;
                //
                //  fall thru....

            case TYPE1_INSTALL_TT_AND_PS:
                //
                //  The PS font was converted to TrueType and the matching
                //  PostScript font was installed.
                //

                ifType = IF_TYPE1_TT;

                //
                //  fall thru....

            case TYPE1_INSTALL_TT_ONLY:
                //
                //
                //  The PS font was converted to TrueType and the matching
                //  PostScript font was NOT installed and a matching PS
                //  font was NOT found.
                //
                //  Setup variables to finish installation of converted
                //  TrueType font file.
                //
                //  NOTE:  In this case "ifType" already equals IF_OTHER
                //

                bUpdateWinIni =
                bTrueType = TRUE;

                goto FinishTTInstall;


            case TYPE1_INSTALL_PS_AND_MTT:
                //
                //  The PostScript font was installed and we found a matching
                //  TrueType font that was already installed.
                //
                //  fall thru....

            case TYPE1_INSTALL_PS_ONLY:
                //
                //  Only the PostScript font was installed.
                //

                bUpdateWinIni = FALSE;
                bFontsInstalled = TRUE;

                goto FinishType1Install;

            case TYPE1_INSTALL_IDYES:
            case TYPE1_INSTALL_IDOK:
            case TYPE1_INSTALL_IDNO:
                //
                //  The font was not installed, but the User wanted to
                //  continue installation.  Continue installation with
                //  the next font.
                //
                //  The font was not installed due to an error somewhere
                //  and the User pressed OK in the MessageBox
                //
                //  OR
                //
                //  The User selected NO in the InstallPSDlg routine.
                //

                bUpdateWinIni = FALSE;
                goto NextSelection;

            case TYPE1_INSTALL_IDCANCEL:
            default:
                //
                //  CANCEL and NOMEM (user already warned)
                //
                goto OperationCancelled;
            }

            //
            //  On leaving this conditional many variables must be set up
            //  correctly to proceed with installation of a TrueType font.
            //
            //  szLHS         - fontname description for listbox display
            //  ifType        - itemdata to attach to TT lbox entry
            //  szSelPath     - filename of source font
            //  bTrueType     - TRUE if Type1 file converted to TT
            //  bUpdateWinIni - FALSE if Type1 file not converted to TT
            //                  and used separatly to determine if [fonts]
            //                  section of win.ini (registry) should be
            //                  updated.
            //

FinishTTInstall:

            //
            //  Determine if TTF file to install is in 'fonts' dir
            //

            StringCchCopy( szFontPath, ARRAYSIZE(szFontPath), szSelPath );


            LPTSTR lpCh = StrRChr( szFontPath, NULL, TEXT( '\\' ) );

            if( lpCh )
            {
                lpCh++;
                *lpCh = TEXT( '\0' );
            }

            bOnSharedDir = lstrcmpi( szFontPath, s_szSharedDir ) == 0;
        }

        //
        //  Start install progress for this font
        //

        ResetProgress( );
        Progress2( 0, szLHS );

        //
        //  Reading OEMSETUP.INF for WIFE/DBCS TT.
        //  if the description is from .inf file, get necessary information
        //  from oemsetup.inf file, based on the information, merge splited
        //  files into single file if exist, and for WIFE font, install font
        //  driver if necessary.
        //

        if( OurData.wFontType > (0xC000 & ~TRUETYPE_WITH_OEMINF ) )
        {
            //
            //  Got a font with oemsetup.inf.
            //

            DEBUGMSG( (DM_TRACE1, TEXT( "Calling bInstallOEMFile %s" ),
                       szSelPath ) );

            // DEBUGBREAK;

            if( !bInstallOEMFile( szInDirCopy, szSelPath, ARRAYSIZE(szSelPath), szLHS,
                                  OurData.wFontType, wCount++ ) )
                goto NextSelection;

            SetCurrentDirectory( lpszInDir );

            DEBUGMSG( (DM_TRACE1, TEXT( "--- After bInstallOEMFile() --- " ) ) );
            DEBUGMSG( (DM_TRACE1, TEXT( "lpszInDir: %s" ) , szInDirCopy) );
            DEBUGMSG( (DM_TRACE1, TEXT( "szSelPath: %s" ) , szSelPath) );
            // DEBUGBREAK;

            bOnSharedDir = TRUE;

            //
            //  Use the newly created file as the one to be installed.
            //

            StringCchCopy( szSelFile, ARRAYSIZE(szSelFile), PathFindFileName( szSelPath ) );

            StringCchCopy( szInDirCopy, ARRAYSIZE(szInDirCopy), szSelPath );

            *(StrRChr( szInDirCopy, NULL, TEXT( '\\' ) ) + 1 ) = 0;

        }

        //
        //  Check if its a valid font file, telling the user the bad news if not
        //

        DWORD dwStatus;
        if( !::bCPValidFontFile( szSelPath, NULL, 0, NULL, FALSE, &dwStatus ) )
        {
            //
            // Display message box informing user about invalid font and why
            // it is invalid.  If user selects Cancel, font installation
            // is aborted.
            //
            iReply = iUIMsgBoxInvalidFont(hwndProgress, szSelPath, szLHS, dwStatus);
            goto ReplyPoint;
        }

        //
        //  A tricky case here - if the file is compressed, it cannot be used
        //  without decompressing, which makes it hard if we're not copying the
        //  file.  Give the user the option to copy this single file, even if
        //  the job is a non-copy job.  An exception: if we've determined that
        //  the job is non-copy (because the source and destination are the
        //  same), but the user's marked it as copy, we'll do an in-place copy
        //  without telling the user what we did.
        //

        bNoCopyFile = bNoCopyJob || bOnSharedDir;

        if( bNoCopyFile && bIsCompressed( szSelPath ) )
        {
            if( bNoCopyJob )
            {
                iReply = iUIMsgYesNoExclaim(hwndProgress, IDSI_FMT_COMPRFILE, szLHS );

                if( iReply != IDYES )
                    goto ReplyPoint;
            }
            bNoCopyFile = FALSE;
        }

        if( bNoCopyFile && (OurData.wFontType == NOT_TT_OR_T1)
            && !bOnSharedDir )
            bNoCopyFile = FALSE;

        //
        //  If we're not copying the file, just make sure the font
        //  file path is copied to szFontPath so the font can be installed
        //  in the call to bInstallFont( ).
        //

        if( bNoCopyFile )
        {
            StringCchCopy(szFontPath, ARRAYSIZE(szFontPath), szSelPath);
        }
        else
        {
            //
            //  The file name might be from a compressed file, so we use LZ to
            //  get the true complete path. From this, we re-extract the name
            //  portion, which we'll use from here on as the file name.
            //
            //  If GetExpandedName() fails, try to use the original path name.
            //

            if( ERROR_SUCCESS != IGetExpandedName( szSelPath, szTruePath, ARRAYSIZE(szSelPath)))
                StringCchCopy( szTruePath, ARRAYSIZE(szTruePath), szSelPath );

            StringCchCopy( szDstFile, ARRAYSIZE(szDstFile), PathFindFileName( szTruePath ) );

            //
            //  Use this true file name to make a unique path name on the
            //  shared directory
            //

            if( !(bUniqueOnSharedDir( szDstFile, ARRAYSIZE(szDstFile), szDstFile ) ) )
            {
                iReply = iUIMsgOkCancelExclaim(hwndProgress, IDSI_FMT_BADINSTALL,
                                                IDSI_CAP_NOCREATE, szLHS );
                goto ReplyPoint;
            }

            //
            //  Finally, we're ready to install the file.  Note that we start
            //  with the original file name and directory. Our destination is
            //  the one we've constructed, on the shared directory.
            //

            if( bCPInstallFile( hwndProgress, szInDirCopy, szSelFile, szDstFile ) )
                vPathOnSharedDir( szDstFile, szFontPath, ARRAYSIZE(szFontPath) );
            else
                goto ReplyPoint;

            Progress2( 50, szLHS );
        }

        //
        //  Install the font (as opposed to the file), if successful we note
        //  that at least one font's been installed.  If there is a problem,
        //  we need to clean up whatever we did before this attempt - most
        //  notably installing above.
        //
        if( bInstallFont(hwndProgress, szFontPath, bTrueType, szLHS, &iReply ) )
            bFontsInstalled = TRUE;
        else if( !bNoCopyFile )
            vCPDeleteFromSharedDir( szDstFile );

        //
        //  If we copied a file that was in the fonts directory, then delete
        //  the source. This will happen in the case of multi-floppy installs.
        //

        if( !bNoCopyFile && bOnSharedDir )
            vCPDeleteFromSharedDir( szSelPath );

        Progress2( 100, szLHS );

        //
        //  Here's where we jump on any diagnostics.  If the user wanted us
        //  to cancel, we return immediately.
        //

ReplyPoint:
        if( iReply == IDCANCEL )
            goto OperationCancelled;


FinishType1Install:

NextSelection:

        if (SUCCEEDED(GetFontManager(&poFontManager)))
        {
            poFontManager->bReleaseInstallationMutex();
            bOwnInstallationMutex = FALSE;
            ReleaseFontManager(&poFontManager);
        }
    }  // While selected desc

    //
    //  Update the overall progress dialog - show a 100% message
    //

    UpdateProgress( iTotalFonts, iTotalFonts, 100 );

    Sleep( 1000 );

//
// Don't update progress indicator if user cancelled out of operation.
//
OperationCancelled:

    TermProgress( );
    TermPSInstall( );

    if (SUCCEEDED(GetFontManager(&poFontManager)))
    {
        if (bOwnInstallationMutex)
        {
            poFontManager->bReleaseInstallationMutex();
        }
        ReleaseFontManager(&poFontManager);
    }

    return bFontsInstalled;
}


/***************************************************************************
 * FUNCTION:   bInstallFont
 *
 * PURPOSE:    Install the font specified by the inputs.  The reply parameter
 *             specifies how, in the event of failure, the user wishes to
 *             proceeed.
 *
 * RETURNS:    BOOL - success of attempt.
 ***************************************************************************/

BOOL NEAR PASCAL bInstallFont( HWND hwndParent,
                               LPTSTR lpszSrcPath,
                               BOOL   bTrueType,
                               PTSTR  szLHS,
                               int*   iReply )
{
    LPTSTR          lpszResource;
    FullPathName_t  szFullPath;
    FullPathName_t  szFontsDir;
    LPTSTR          lpszName;
    BOOL            bSuccess = FALSE;
    BOOL            bInFontsDir = FALSE;


    //
    //  Determine if this file is in the FONTS directory.
    //

    StringCchCopy( szFullPath, ARRAYSIZE(szFullPath), lpszSrcPath );

    lpszName = PathFindFileName( szFullPath );

    if( lpszName == szFullPath )
    {
        bInFontsDir = TRUE;
    }
    else
    {
        *(lpszName-1) = 0;

        GetFontsDirectory( szFontsDir, ARRAYSIZE( szFontsDir ) );

        if( !lstrcmpi( szFontsDir, szFullPath ) )
        {
           bInFontsDir = TRUE;
        }
    }

    //
    //  If it is a TrueType font, the input file will be the TTF.
    //  Generate the corresponding *.FOT file
    //

    if( bInFontsDir )
        lpszResource = lpszName;
    else
        lpszResource = lpszSrcPath;


    //
    //  Add the font resource, and then add the font record to our list.
    //  If these both succeed, we've finally reached the ultimate return point.
    //

    if( AddFontResource( lpszResource ) )
    {
        CFontManager *poFontManager;
        if (SUCCEEDED(GetFontManager(&poFontManager)))
        {
            if(poFontManager->poAddToList(szLHS, lpszResource, NULL) != NULL )
            {
                // WriteProfileString( szINISFonts, szLHS, lpszResource );
                WriteToRegistry( szLHS, lpszResource );
                bSuccess = TRUE;
            }
            ReleaseFontManager(&poFontManager);
            return bSuccess;
        }
        else
        {
            //
            //  Clear if we couldn't add
            //
            RemoveFontResource( lpszResource );
        }
    }
#ifdef _DEBUG
    else
        DEBUGMSG( (DM_ERROR, TEXT( "AddFontResource failed on %s" ),
                   lpszResource ) );
#endif

    //
    //  If we've failed in the final stages, report to the user.  We also
    //  need to clean up any file we've created.
    //

    if( bInFontsDir )
        vCPDeleteFromSharedDir( lpszSrcPath );

    *iReply = iUIMsgOkCancelExclaim(hwndParent, IDSI_FMT_BADINSTALL, IDSI_CAP_NOINSTALL,
                                     szLHS );

    return bSuccess;
}


BOOL HitTestDlgItem(int x, int y, HWND hwndItem)
{
    const POINT pt = { x, y };
    RECT rc;
    GetWindowRect(hwndItem, &rc);
    return PtInRect(&rc, pt);
}


/*************************************************************************
 * FUNCTION: FontHookProc
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/
UINT_PTR CALLBACK FontHookProc( HWND hWnd,
                                UINT iMessage,
                                WPARAM wParam,
                                LPARAM lParam )
{
    switch( iMessage )
    {

    case WM_INITDIALOG:
        DEBUGMSG( (DM_TRACE1, TEXT( "FONTEXT: ------------ WM_INITDIALOG " ) ) );

        s_pDlgAddFonts->Attach( hWnd );

        s_pDlgAddFonts->m_pOpen = (LPOPENFILENAME) lParam;

        s_pDlgAddFonts->CheckDlgButton( ID_BTN_COPYFILES, TRUE );

        s_pDlgAddFonts->vStartFonts( );

        SetFocus( s_pDlgAddFonts->GetDlgItem( IDOK ) );
        break;

    case WM_DESTROY:
        s_pDlgAddFonts->Detach( );
        break;

    case WM_HELP:
        if (IsWindowEnabled(hWnd))
        {
            LPHELPINFO lphi = (LPHELPINFO)lParam;
            if (HELPINFO_WINDOW == lphi->iContextType)
            {
                for (int i = 0; 0 != rgHelpIDs[i]; i += 2)
                {
                    if (lphi->iCtrlId == (int)rgHelpIDs[i])
                    {
                        //
                        // Only display custom help when necessary.
                        // Otherwise, use standard "file open dlg" help.
                        //
                        WinHelp( (HWND)lphi->hItemHandle,
                                 TEXT("fonts.hlp"),
                                 HELP_WM_HELP,
                                 (DWORD_PTR)(LPVOID)rgHelpIDs);

                        return TRUE;
                    }
                }
            }
        }
        break;

    case WM_CONTEXTMENU:
         {
            const x = GET_X_LPARAM(lParam);
            const y = GET_Y_LPARAM(lParam);
            for (int i = 0; 0 != rgHelpIDs[i]; i += 2)
            {
                HWND hwndItem = GetDlgItem(hWnd, rgHelpIDs[i]);
                //
                // This hit test shouldn't be required.  For some reason
                // wParam is the HWND of the dialog whenever the user 
                // right-clicks on some of our template controls.  I can't
                // figure it out but the hit test adjusts for the problem.
                // [brianau - 6/8/99]
                // 
                if ((HWND)wParam == hwndItem || HitTestDlgItem(x, y, hwndItem))
                {
                    //
                    // Only display custom help when necessary.
                    // Otherwise, use standard "file open dlg" help.
                    //
                    WinHelp( (HWND)wParam,
                              TEXT("fonts.hlp"),
                              HELP_CONTEXTMENU,
                              (DWORD_PTR)(LPVOID)rgHelpIDs);
                              
                    return TRUE;
                }                 
            }
        }
        break;

    case WM_COMMAND:
        switch( GET_WM_COMMAND_ID( wParam, lParam ) )
        {
        //
        //  command switch
        //
        case IDM_IDLE:
            vCPFilesToDescs( );
            break;

        case ID_BTN_SELALL:
            //
            //  select all
            //
            s_pDlgAddFonts->pListBoxDesc()->SetSel( -1, TRUE );
            break;

        case ID_BTN_HELP:
            WinHelp( hWnd, TEXT( "WINDOWS.HLP>PROC4" ), HELP_CONTEXT,
                     IDH_WINDOWS_FONTS_ADDNEW_31HELP );
            break;

        case ID_LB_FONTDIRS:
            if( GET_WM_COMMAND_CMD( wParam, lParam ) == LBN_DBLCLK )
                s_pDlgAddFonts->vStartFonts( );
            break;

        case IDOK:
            if( s_pDlgAddFonts->pListBoxDesc()->GetSelCount() > 0 )
                s_pDlgAddFonts->vAddSelFonts( );
            else
                s_pDlgAddFonts->vStartFonts();

            break;

        case IDCANCEL:
        case IDABORT:
            ResetAtomInDescLB( s_pDlgAddFonts->pListBoxDesc()->hWnd() );
            s_pDlgAddFonts->EndDialog( 0 );
            break;

        case ID_LB_ADD:
            // if( HIWORD( lParam ) == LBN_DBLCLK )

            if( GET_WM_COMMAND_CMD( wParam,lParam ) == LBN_DBLCLK )
                s_pDlgAddFonts->vAddSelFonts( );
            break;

        case ID_CB_FONTDISK:
            switch( GET_WM_COMMAND_CMD( wParam, lParam ) )
            {
            //
            //  Switch on combo parameter
            //

            case CBN_DROPDOWN:
                s_pDlgAddFonts->vHoldComboSel();
                break;

            case CBN_CLOSEUP:
                s_pDlgAddFonts->vCloseCombo( );
                break;

            case CBN_SELCHANGE:
                s_pDlgAddFonts->vNewComboSel( );
                break;
           }  // Switch on combo parameter
           break;

        } // command switch
        break;

    default:
        if( iMessage == s_iLBSelChange )
        {
            switch( wParam )
            {
            case ID_CB_FONTDISK:
                switch( HIWORD( lParam ) )
                {
                case CD_LBSELCHANGE:
                    //
                    //  This catches the DriveNotReady case
                    //  This code is hit once before WM_INITDIALOG is handled.
                    //  The check for a valid hWnd prevents a DEBUGBREAK in
                    //  dwThreadProc.
                    //

                    if (NULL != s_pDlgAddFonts->hWnd())
                        s_pDlgAddFonts->vStartFonts( );
                    break;
                }
                //
                // Fall through...
                // We want to capture current directory list selection
                // if either directory or drive changes.
                //
            case ID_LB_FONTDIRS:
               if (HIWORD(lParam) == CD_LBSELCHANGE)
               {
                  int cch     = 0;            // Index into s_szCurDir.
                  int iDirNew = 0;            // Id of directory item open in listbox.
                  BOOL bBufOverflow = FALSE;  // Buffer overflow indicator.

                  //
                  // Build current path selected in directory list box.
                  // We save this path in s_szCurDir so that if the FileOpen dialog is closed and
                  // re-opened, it will start navigating where it last left off.
                  // This path-building code was taken from the common dialog module fileopen.c
                  // The buffer overflow protection was added.
                  //
                  iDirNew = (DWORD)SendMessage( GetDlgItem(hWnd, ID_LB_FONTDIRS), LB_GETCURSEL, 0, 0L );
                  cch = (int)ListBoxGetText(GetDlgItem(hWnd, ID_LB_FONTDIRS), 0, s_szCurDir, ARRAYSIZE(s_szCurDir));
                  if (LB_ERR != cch)
                  {
                      if (DBL_BSLASH(s_szCurDir))
                      {
                          StringCchCat(s_szCurDir, ARRAYSIZE(s_szCurDir), TEXT("\\"));
                          cch++;
                      }

                      for (int idir = 1; !bBufOverflow && idir <= iDirNew; ++idir)
                      {
                          TCHAR szTemp[MAX_PATH + 1]; // Temp buf for directory name.
                          int n = 0;                  // Chars in directory name.

                          n = (int)ListBoxGetText(GetDlgItem(hWnd, ID_LB_FONTDIRS),
                                                 idir,
                                                 szTemp,
                                                 ARRAYSIZE(szTemp));
                          if (LB_ERR == n)
                          {
                              bBufOverflow = TRUE;
                          }
                          else
                          {
                              //
                              // Check if this directory name will overflow s_szCurDir.
                              //
                              if (cch + n < ARRAYSIZE(s_szCurDir))
                              {
                                  //
                                  // We have enough space for this directory name.
                                  // Append it to s_szCurDir, advance the buffer index and
                                  // append a backslash.
                                  //
                                  StringCchCopy(&s_szCurDir[cch],
                                                ARRAYSIZE(s_szCurDir) - cch, 
                                                szTemp);
                                  cch += n;
                                  s_szCurDir[cch++] = CHAR_BSLASH;
                              }
                              else
                                  bBufOverflow = TRUE;  // This will terminate the loop.
                                                        // s_szCurDir will still contain
                                                        // a valid path.  It will just
                                                        // be shy 1 or more directories.
                          }
                      }

                      //
                      // All done.  Terminate it.
                      // Note that this wipes out the final trailing backslash.
                      //
                      if (iDirNew)
                      {
                          s_szCurDir[cch - 1] = CHAR_NULL;
                      }
                   }
               }
               break;
            }
         }
         break;
    } // message switch

    //
    //  commdlg, do your thing
    //

    return FALSE;
}


/***************************************************************************
 * FUNCTION:   vCPDeleteFromSharedDir
 *
 * PURPOSE:    Delete the input file from the shared directory - a cleanup
 *             function for our installation attempts
 *
 * RETURNS:    None
 ***************************************************************************/

VOID FAR PASCAL vCPDeleteFromSharedDir( LPTSTR lpszFileOnly )
{
    FullPathName_t szTempPath;


    vPathOnSharedDir( PathFindFileName( lpszFileOnly ), szTempPath, ARRAYSIZE(szTempPath));

    DeleteFile( szTempPath );
}


/***************************************************************************
 * FUNCTION:   vCPFilesToDescs
 *
 * PURPOSE:    We're during idle here, so try to convert at least one item
 *             from the selected file list to the description list (which is
 *             the one the user can see)
 *
 * RETURNS:    None
 ***************************************************************************/

VOID FAR PASCAL vCPFilesToDescs( )
{
    TCHAR          szNoFonts[ 80 ] = {0};
    BOOL           bSomeDesc;
    int            nDescSlot;
    AddITEMDATA    OurData;
    FullPathName_t szFilePath;
    FontDesc_t     szDesc;
    CListBox*      pListDesc;
    CListBox*      pListFiles;
    MSG            msg;


    if( !s_pDlgAddFonts || !s_pDlgAddFonts->m_nFontsToGo )
        return;

    pListFiles = s_pDlgAddFonts->pListBoxFiles( );
    pListDesc  = s_pDlgAddFonts->pListBoxDesc( );

    if( s_pDlgAddFonts->bStartState( ) )
    {
        //
        //  Reset the atoms that are in here.
        //

        ResetAtomInDescLB( pListDesc->hWnd( ) );

        //
        //  Make sure our focus isn't off in some weird place - force it
        //  to our directory list
        //

        HWND hFocus = ::GetFocus( );

        int iFocusID;


        if( hFocus != NULL )
            iFocusID = ::GetDlgCtrlID( hFocus );
        else
            iFocusID = ID_LB_ADD;

        if( ( iFocusID == (ID_LB_ADD) ) || (iFocusID == (ID_SS_PCT) ) )
        {
            ::SendMessage( s_pDlgAddFonts->hWnd( ), WM_NEXTDLGCTL,
            (WPARAM)GetDlgItem( s_pDlgAddFonts->hWnd( ), ID_LB_FONTDIRS ), 1L );
        }

        pListDesc->ResetContent( );
        pListDesc->UpdateWindow( );

        s_pDlgAddFonts->vUpdatePctText( );

        if( !s_pDlgAddFonts->bInitialFonts( ) )
        {
            bSomeDesc = FALSE;
            goto Done;
        }

        pListDesc->SetRedraw( FALSE );

        //
        //  DBCS. The first time through, look for oemsetup.inf
        //

        {
        int        nFileIndex;
        WORD       wRet;
        ADDFNT     stData;
        TCHAR      szInfFile[ MAXFILE ];
        FontDesc_t szTemp;

        if( FindOemInList( pListFiles, s_pDlgAddFonts->m_nFontsToGo,
                           &nFileIndex, szInfFile, ARRAYSIZE(szInfFile) ) )
        {
            //
            //  save original path to setup.inf
            //

            StringCchCopy( szTemp, ARRAYSIZE(szTemp), szSetupInfPath );

            //
            //  get dir of oemsetup.inf
            //

            GetCurrentDirectory( ARRAYSIZE( szSetupInfPath ), szSetupInfPath );

            if (!lpCPBackSlashTerm( szSetupInfPath, ARRAYSIZE(szSetupInfPath)))
            {
                bSomeDesc = FALSE;
                goto Done;
            }
            if (FAILED(StringCchCat( szSetupInfPath, ARRAYSIZE(szSetupInfPath), szInfFile )))
            {
                bSomeDesc = FALSE;
                goto Done;
            }

            stData.poListDesc = pListDesc;
            stData.nIndex     = nFileIndex;
            stData.which      = WHICH_FNT_WIFE;

            if( ( wRet = ReadSetupInfCB( szSetupInfPath, WIFEFONT_SECTION,
                    (LPSETUPINFPROC) GetNextFontFromInf, &stData ) ) != NULL )
            {
                //
                //  didn't reach to the end of section
                //

                if( wRet == INSTALL+14 )
                    //
                    //  didn't find the section
                    //
                    goto ScanTTInf;
            }
            else
            {
ScanTTInf:
                stData.which = WHICH_FNT_TT;

                wRet = ReadSetupInfCB( szSetupInfPath, TRUETYPE_SECTION,
                                       (LPSETUPINFPROC) GetNextFontFromInf,
                                       &stData );
            }

            //
            //  reset setupinf path global
            //

            if (FAILED(StringCchCopy( szSetupInfPath, ARRAYSIZE(szSetupInfPath), szTemp )))
            {
                bSomeDesc = FALSE;
                goto Done;
            }

            if( wRet && wRet != INSTALL+14 )
            {
                //
                //  Found the section, but invalid format
                //

                bSomeDesc = FALSE;
                goto Done;
            }
        }
        } // End of DBCS section.
    }

    //
    //  We want to read at least one
    //

    goto ReadNext;

    for(  ; s_pDlgAddFonts->m_nFontsToGo; )
    {
        if( PeekMessage( &msg, NULL, 0, 0, PM_NOREMOVE ) )
            return;

ReadNext:

        s_pDlgAddFonts->m_nFontsToGo--;
        s_pDlgAddFonts->vUpdatePctText( );

        OurData.nFileSlot = (WORD)s_pDlgAddFonts->m_nFontsToGo;

        if( pListFiles->GetText( OurData.nFileSlot, szFilePath, ARRAYSIZE(szFilePath) ) == LB_ERR )
            continue;

        WORD  wType;

        DEBUGMSG( (DM_TRACE1, TEXT( "Checking file: %s" ), szFilePath ) );

        if( !::bCPValidFontFile( szFilePath, szDesc, ARRAYSIZE(szDesc), &wType ) )
        {
            DEBUGMSG( (DM_TRACE1, TEXT( "......Invalid" ) ) );
            continue;
        }

        DEBUGMSG( (DM_TRACE1, TEXT( "......Valid.   Desc: %s" ), szDesc) );

        OurData.wFontType = wType;

        //
        //  See if there's already an entry for this font name - if so, don't
        //  add it again.  If there isn't, go ahead and add, setting our
        //  item data block.
        //

        if( pListDesc->FindStringExact( -1, szDesc ) == LB_ERR )
        {
            nDescSlot = pListDesc->AddString( szDesc );

            if( nDescSlot != LB_ERR )
                pListDesc->SetItemData( nDescSlot, OurData.ItemData );
            else
            {
                DEBUGMSG( (DM_ERROR, TEXT( "FONTEXT: Error adding string %s" ),
                           szDesc ) );
                // DEBUGBREAK;
            }
        }
        else
            DEBUGMSG( (DM_TRACE1,TEXT( "String %s already in list" ), szDesc ) );

    }

    s_pDlgAddFonts->vUpdatePctText( );

    bSomeDesc = (pListDesc->GetCount( ) > 0 );

    DEBUGMSG( (DM_TRACE1,TEXT( "Count in ListDesc: %d" ), pListDesc->GetCount( ) ) );
//  DEBUGBREAK;

Done:

    if( !bSomeDesc )
    {
        //
        //  cszNoFonts.LoadString( IDSI_MSG_NOFONTS );
        //

        LoadString( g_hInst, IDSI_MSG_NOFONTS, szNoFonts, ARRAYSIZE( szNoFonts ) );

        pListDesc->AddString( szNoFonts );
    }

    //
    //  Get everything back to the correct state before exiting.
    //  We can select all if we've got at least one item in the description
    //  list box.  Likewise, we can select from the list box itself.
    //  Re-enable redrawing of the box and invalidate to force a redraw.
    //

    // s_pDlgAddFonts->GetDlgItem( ID_BTN_SELALL )->EnableWindow( bSomeDesc );

    ::EnableWindow( s_pDlgAddFonts->GetDlgItem( ID_BTN_SELALL ), bSomeDesc );

    pListDesc->EnableWindow( bSomeDesc );

    pListDesc->SetRedraw( TRUE );

    pListDesc->InvalidateRect( NULL, TRUE );

    pListDesc->UpdateWindow( );
}


/*************************************************************************
 * FUNCTION: CPDropInstall
 *
 * PURPOSE:
 *          iCount - Number of fonts left to install, NOT counting this one
 *
 *
 * RETURNS:
 *
 *************************************************************************/

int FAR PASCAL CPDropInstall( HWND hwndParent,
                              LPTSTR lpszInPath,
                              size_t cchInPath,
                              DWORD  dwEffect ,
                              LPTSTR lpszDestName,
                              int    iCount )
{
    FullPathName_t szTruePath;
    FullPathName_t szFontPath;
    FullPathName_t szSourceDir;
    FILENAME       szInFile;
    FILENAME       szDstFile;
    FontDesc_t     szLHS;
    LPTSTR         lpCh;
    int            iReply;
    WORD           wType;
    BOOL           bTrueType;
    int            iReturn = CPDI_FAIL;
    BOOL           bNoCopyFile;
    UINT           uMB = ( (iCount > 0) ? (MB_OKCANCEL | MB_ICONEXCLAMATION)
                                      : MB_OK | MB_ICONEXCLAMATION );
    DWORD          dwStatus = FVS_MAKE_CODE(FVS_INVALID_STATUS, FVS_FILE_UNK);

    static BOOL s_bInit = FALSE;
    static int  s_iTotal = 1;

    BOOL bOwnInstallationMutex = FALSE;
    HWND hwndProgress = NULL;
    CFontManager *poFontManager = NULL;

    //
    //  Init Type1 font installation and Progress dialog
    //

    if( !s_bInit )
    {
        InitPSInstall( );
        hwndProgress = InitProgress( hwndParent );

        s_iTotal = ( iCount > 0 ) ? ( iCount + 1 ) : 1;

        s_bInit = TRUE;


    }

    GetFontManager(&poFontManager);
    
    //
    // Must own installation mutex to install font.
    //
    if ( NULL != poFontManager )
    {
        INT iUserResponse  = IDRETRY;
        DWORD dwWaitResult = CFontManager::MUTEXWAIT_SUCCESS;

        while( IDRETRY == iUserResponse &&
               (dwWaitResult = poFontManager->dwWaitForInstallationMutex()) != CFontManager::MUTEXWAIT_SUCCESS )
        {
            if ( CFontManager::MUTEXWAIT_WMQUIT != dwWaitResult )
                iUserResponse = iUIMsgRetryCancelExclaim(hwndProgress, IDS_INSTALL_MUTEX_WAIT_FAILED, NULL);
            else
            {
                //
                // Cancel if thread received a WM_QUIT message while waiting.
                //
                iUserResponse = IDCANCEL;
            }
        }

        //
        // If user chose to cancel or we got a WM_QUIT msg, cancel the installation.
        //
        if ( IDCANCEL == iUserResponse )
        {
            iReturn = CPDI_CANCEL;
            goto done;
        }

        bOwnInstallationMutex = TRUE;
    }


    //
    // Update the font number in the progress dialog.
    // Leave the % complete unchanged.
    //
    UpdateProgress( s_iTotal, s_iTotal - iCount,
                  (s_iTotal - iCount - 1) * 100 / s_iTotal );


    //
    //  If this is a type1 font, then convert it and install the resulting
    //  TrueType file.
    //

    // BGK - Add copy/nocopy w/compress here

    bNoCopyFile = (dwEffect == DROPEFFECT_LINK );

    if( !::bCPValidFontFile( lpszInPath, szLHS, ARRAYSIZE(szLHS), &wType, FALSE, &dwStatus ) )
    {
        //
        // Display message informing user that font file is invalid and why.
        // Abort the installation of this font if user pressed Cancel.
        //
        StringCchCopy( szFontPath, ARRAYSIZE(szFontPath), lpszInPath );
        if (iUIMsgBoxInvalidFont(hwndProgress, szFontPath, szLHS, dwStatus) == IDCANCEL)
            iReturn = CPDI_CANCEL;
    }
    else if( bFontInstalledNow( szLHS ) )
    {
        if( iUIMsgBox(hwndProgress, IDSI_FMT_ISINSTALLED, IDS_MSG_CAPTION, uMB, szLHS )
                     == IDCANCEL )
        {
            iReturn = CPDI_CANCEL;
        }

    }
    else
    {
        bTrueType = (wType == TRUETYPE_FONT);

        vUIPStatusShow( IDS_FMT_FONTINS, szLHS );

        BOOL    bUpdateWinIni;
        int     ifType;


        if( (wType == TYPE1_FONT) || (wType == TYPE1_FONT_NC) )
        {
            //
            //  For installations involving the conversion of the Type1
            //  font to TrueType:
            //
            //         "lpszInPath" has the destination name of the
            //                      installed TrueType font file.
            //         "szLHS"      is munged to contain "(TrueType)".
            //

            switch( ::InstallT1Font( hwndProgress,
                                     !bNoCopyFile,    //  Copy TT file?
                                     TRUE,            //  Copy PFM/PFB files?
                                     FALSE,           //  Files in Shared Dir?
                                     lpszInPath,      //  IN:  PFM File & Dir
                                                      //  OUT: TTF File & Dir
                                     cchInPath,
                                     szLHS,           //  IN & OUT: Font desc
                                     ARRAYSIZE(szLHS)) )
            {
            case TYPE1_INSTALL_TT_AND_MPS:
                //
                //  The PS font was converted to TrueType and a matching
                //  PostScript font is ALREADY installed.
                //
                // bDeletePSEntry = TRUE;
                //
                //  fall thru....

            case TYPE1_INSTALL_TT_AND_PS:
                //
                //  The PS font was converted to TrueType and the matching
                //  PostScript font was installed.
                //

                ifType = IF_TYPE1_TT;

                //
                //  fall thru....

            case TYPE1_INSTALL_TT_ONLY:
                //
                //
                //  The PS font was converted to TrueType and the matching
                //  PostScript font was NOT installed and a matching PS
                //  font was NOT found.
                //
                //  Setup variables to finish installation of converted
                //  TrueType font file.
                //
                //  NOTE:  In this case "ifType" already equals IF_OTHER
                //

                bUpdateWinIni =
                bTrueType = TRUE;

                iReturn = CPDI_SUCCESS;

                goto FinishTTInstall;


            case TYPE1_INSTALL_PS_AND_MTT:
                //
                //  The PostScript font was installed and we found a matching
                //  TrueType font that was already installed.
                //
                //  fall thru....

            case TYPE1_INSTALL_PS_ONLY:
                //
                //  Only the PostScript font was installed.
                //

                bUpdateWinIni = FALSE;
                iReturn = CPDI_SUCCESS;

                goto done;

            case TYPE1_INSTALL_IDYES:
            case TYPE1_INSTALL_IDOK:

                bUpdateWinIni = FALSE;
                iReturn = CPDI_SUCCESS;
                goto done;

            case TYPE1_INSTALL_IDNO:
                //
                //  The font was not installed, but the User wanted to
                //  continue installation.  Continue installation with
                //  the next font.
                //
                //  The font was not installed due to an error somewhere
                //  and the User pressed OK in the MessageBox
                //
                //  OR
                //
                //  The User selected NO in the InstallPSDlg routine.
                //

                bUpdateWinIni = FALSE;
                iReturn = CPDI_FAIL;
                goto done;

            case TYPE1_INSTALL_IDCANCEL:
            default:
                iReturn = CPDI_CANCEL;
                goto done;
            }

            //
            //  On leaving this conditional many variables must be set up
            //  correctly to proceed with installation of a TrueType font.
            //
            //  szLHS         - fontname description for listbox display
            //  ifType        - itemdata to attach to TT lbox entry
            //  lpszInPath    - filename of source font
            //  bTrueType     - TRUE if Type1 file converted to TT
            //

FinishTTInstall:

            //
            //  Determine if TTF file to install is in 'fonts' dir
            //

            StringCchCopy( szFontPath, ARRAYSIZE(szFontPath), lpszInPath );


            lpCh = StrRChr( szFontPath, NULL, TEXT( '\\' ) );
            if( lpCh )
            {
                lpCh++;
                *lpCh = TEXT( '\0' );
            }

            bNoCopyFile = lstrcmpi( szFontPath, s_szSharedDir ) == 0;
        }

        //
        //  Start install progress for this font
        //

        ResetProgress( );
        Progress2( 0, szLHS );

        //
        //  If the file is compressed, then do a copy.
        //

        if( bIsCompressed( lpszInPath ) )
        {
            dwEffect = DROPEFFECT_COPY;
            bNoCopyFile = FALSE;
        }

        if( bNoCopyFile )
        {
            //
            //  If we're not copying the file, just make sure the font
            //  file path is copied to szFontPath so the font can be installed
            //  in the call to bInstallFont( ).
            //
            StringCchCopy(szFontPath, ARRAYSIZE(szFontPath), lpszInPath);
        }
        else
        {
            //
            //  Before monkeying around with the name strings, grab the source
            //  directory, including the terminating slash.  Also hold the file
            //  portion.
            //

            //
            //  Copy in name only
            //

            StringCchCopy( szInFile, ARRAYSIZE(szInFile), PathFindFileName( lpszInPath ) );

            StringCchCopy( szSourceDir, ARRAYSIZE(szSourceDir), lpszInPath );

            //
            //  Get past any path
            //

            lpCh  = StrRChr( szSourceDir, NULL, TEXT( '\\' ) );

            lpCh++;
            *lpCh = 0;

            //
            //  Let LZ tell us what the name should have been
            //

            if( ERROR_SUCCESS != IGetExpandedName( lpszInPath, szTruePath, ARRAYSIZE(szTruePath) ))
            {
                //
                //  GetExpanded failed. This usually means we can't get at
                //  the file for some reason.
                //

                iUIMsgOkCancelExclaim(hwndProgress, IDSI_FMT_BADINSTALL,
                                       IDSI_CAP_NOCREATE, szLHS );
                goto done;
            }

            //
            //  Now we're going to work on making the new file name - it's
            //  file only, and we'll tweak for uniqueness
            //

            if( lpszDestName && *lpszDestName )
            {
                StringCchCopy( szDstFile, ARRAYSIZE(szDstFile), lpszDestName );
            }
            else
            {
                //
                //  Copy in name only
                //

                StringCchCopy( szDstFile, ARRAYSIZE(szDstFile), PathFindFileName( szTruePath ) );
            }

            if( !(bUniqueOnSharedDir( szDstFile, ARRAYSIZE(szDstFile), szDstFile ) ) )
            {
                iUIMsgOkCancelExclaim(hwndProgress, IDSI_FMT_BADINSTALL,
                                       IDSI_CAP_NOCREATE, szLHS );
                goto done;
            }

            //
            //  Ready to install the file
            //

            if( iReturn = (bCPInstallFile( hwndProgress, szSourceDir, szInFile, szDstFile )
                                        ? CPDI_SUCCESS : CPDI_FAIL ) )
            {
                vPathOnSharedDir( szDstFile, szFontPath, ARRAYSIZE(szFontPath) );
            }
            else
                goto done;

            Progress2( 50, szLHS );

        }

        if( bInstallFont( hwndProgress, szFontPath, bTrueType, szLHS, &iReply ) )
        {
            iReturn = CPDI_SUCCESS;

            //
            //  Attempt to remove the source file, if the operation was
            //  a MOVE.
            //
            //  EXCEPTION: If we're doing a Type1 font installation, the name
            //  in lpszInPath buffer is the path to the matching TrueType font
            //  file created. If this is the case, do not delete it.
            //
            if( (wType != TYPE1_FONT) && (wType != TYPE1_FONT_NC) &&
                (dwEffect == DROPEFFECT_MOVE) )
            {
                //
                // SHFileOperation requires that file list be double-nul
                // terminated.
                //
                CDblNulTermList list;
                if (SUCCEEDED(list.Add(lpszInPath)))
                {
                    SHFILEOPSTRUCT sFileOp = { NULL,
                                               FO_DELETE,
                                               list,
                                               NULL,
                                               FOF_SILENT | FOF_NOCONFIRMATION,
                                               0,
                                               0
                                              };

                    SHFileOperation( &sFileOp );
                }
            }

            Progress2( 100, szLHS );
        }
        else if( !bNoCopyFile )
            vCPDeleteFromSharedDir( szDstFile );
    }

done:

    //
    //  Update the overall progress dialog
    //  Only update if user didn't cancel the operation.
    //
    if (CPDI_CANCEL != iReturn)
    {
        UpdateProgress( s_iTotal, s_iTotal - iCount,
                        (s_iTotal - iCount) * 100 / s_iTotal );
    }

    //
    //  If no more fonts coming down, properly terminate Progress
    //  dialog and reset local statics.  Also, give user time to
    //  to see this on a fast system (1 sec. delay).
    //
    if (InstallCancelled())
        iReturn = CPDI_CANCEL;

    if( s_bInit && (iCount == 0 || iReturn == CPDI_CANCEL) )
    {
        Sleep( 1000 );

        TermProgress( );
        TermPSInstall( );

        s_iTotal =  1;

        s_bInit = FALSE;
    }

    //
    // Release the installation mutex if we own it.
    //
    if ( NULL != poFontManager)
    {
        if (bOwnInstallationMutex)
            poFontManager->bReleaseInstallationMutex();

        ReleaseFontManager(&poFontManager);
    }
    return iReturn;
}


/*************************************************************************
 * FUNCTION: bCPAddFonts
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

BOOL FAR PASCAL bCPAddFonts( HWND ma )
{
    FullPathName_t  szWinDir;
    FullPathName_t  szFileTemp = { TEXT( '\0' ) };
    TCHAR           cFilter[ 80 ] = {0};
    TCHAR           szFilter[ 80 ];

    //
    //  Current directory we're using
    //  Moved s_szCurDir to file-scope so that it can be updated through
    //  FontHookProc. [brianau]
    //
    //  static FullPathName_t s_szCurDir;

    static BOOL           s_bFirst = TRUE;

    //
    //  This code is NOT REENTRANT!!!!.
    //  Make sure we don't.
    //

    if( s_pDlgAddFonts )
        return FALSE;

    //
    //  We start the current directory to be the windows directory - it will
    //  later remain as where the user last set it.
    //

    if( s_bFirst )
    {
        s_bFirst = FALSE;
        if (!GetWindowsDirectory( s_szCurDir, ARRAYSIZE( s_szCurDir ) ))
        {
            s_szCurDir[0] = 0;
        }
    }

    //
    //  Nothing added yet!
    //

    BOOL bFontsAdded = FALSE;

    //
    //  We need to set the font filter.  If TrueType is enabled, we use a
    //  filter that includes these files.  Otherwise, a simpler filter is
    //  used.  The filter has embedded nulls, which are stored in the
    //  resource file as hashes
    //

    if( GetProfileInt( szINISTrueType, szINIKEnable,1 ) )

       LoadString( g_hInst, IDS_MSG_ALLFILTER, cFilter, ARRAYSIZE( cFilter ) );

    else

       LoadString( g_hInst, IDS_MSG_NORMALFILTER, cFilter, ARRAYSIZE( cFilter ) );


    StringCchCopy( szFilter, ARRAYSIZE(szFilter), cFilter );

    vHashToNulls( szFilter );

    //
    //  Now we'll use the common open-file dialog to present the user with
    //  some choices on fonts to add
    //

    static OPENFILENAME OpenFileName;

    memset( &OpenFileName, 0, sizeof( OpenFileName ) );

    OpenFileName.lStructSize    = sizeof( OPENFILENAME );
    OpenFileName.hwndOwner      = ma;
    OpenFileName.hInstance      = g_hInst;
    OpenFileName.lpstrFilter    = szFilter;
    OpenFileName.nFilterIndex   = 1;
    OpenFileName.lpstrFile      = szFileTemp;
    OpenFileName.nMaxFile       = ARRAYSIZE( szFileTemp );
    OpenFileName.lpstrInitialDir= s_szCurDir;

    OpenFileName.Flags          = OFN_HIDEREADONLY   | OFN_ENABLEHOOK |
                                  OFN_ENABLETEMPLATE;
    OpenFileName.lpTemplateName = MAKEINTRESOURCE( ID_DLG_FONT2 );
    OpenFileName.lpfnHook       = FontHookProc;

    //
    //  This is our companion struture, which we handle independently
    //

    s_pDlgAddFonts = new AddFontsDialog;

    if(NULL == s_pDlgAddFonts)
    {
        DEBUGMSG( (DM_ERROR, TEXT( "AddFontsDialog not created." ) ) );

        // DEBUGBREAK;
        // FEATURE: Way low on memory. MessageBox?
        return FALSE;
    }

    if (!s_pDlgAddFonts->bInitialize())
    {
        DEBUGMSG( (DM_ERROR, TEXT( "AddFontsDialog initialization failed." ) ) );
        s_pDlgAddFonts->Release();
        s_pDlgAddFonts = NULL;

        return FALSE;
    }

    s_iLBSelChange = RegisterWindowMessage( LBSELCHSTRING );

//
//  Suspension of the file system notify thread is no longer required.
//  It has been superceded by the installation mutex in CFontManager.
//  See comment in header of CFontManager::iSuspendNotify() for details.
//
//    if( poFontMan )
//        poFontMan->iSuspendNotify( );

    GetOpenFileName( &OpenFileName );

//    if( poFontMan )
//        poFontMan->iResumeNotify( );

    bFontsAdded = s_pDlgAddFonts->bAdded( );

    s_pDlgAddFonts->EndThread(); // Stop the IDM_IDLE thread.
    s_pDlgAddFonts->Release();   // Decr ref count.
    s_pDlgAddFonts = NULL;       // Static ptr no longer used.

    //
    //  save the current dir so we can restore this
    //  Modified so current directory is saved in FontHookProc.
    //
    //  GetCurrentDirectory( ARRAYSIZE( s_szCurDir ), s_szCurDir );

    //
    //  set the current dir back to windows so we don't hit the floppy
    //

    if (GetWindowsDirectory( szWinDir, ARRAYSIZE( szWinDir ) ))
    {
        SetCurrentDirectory( szWinDir );
    }

    return bFontsAdded > 0;
}


/*************************************************************************
 * FUNCTION: CopyTTOutlineWithInf
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

BOOL NEAR PASCAL CopyTTOutlineWithInf( HWND hwndFontDlg,
                                       LPTSTR pszInfSection,
                                       size_t cchInfSection,
                                       LPTSTR szDesc,
                                       LPTSTR szSrc,
                                       size_t cchSrc,
                                       LPTSTR szDst,
                                       size_t cchDst)
{
    TCHAR szTemp[ PATHMAX ];
    TCHAR szDstName[ PATHMAX ];
    BOOL bInstalled = FALSE;
    LPTSTR lpTemp ;
    LPTSTR pszFiles[ 30 ];
    UINT   nFiles;
    DWORD  dwInstallFilesResult = 0;

    DEBUGMSG( (DM_TRACE1, TEXT( "CopyTTOutlineWithInf()" ) ) );
    DEBUGMSG( (DM_TRACE1, TEXT( "\tszDesc: %s" ), szDesc) );
    DEBUGMSG( (DM_TRACE1, TEXT( "\tszSrc: %s" ), szSrc) );
    DEBUGMSG( (DM_TRACE1, TEXT( "\tszDst: %s" ), szDst) );
    // DEBUGBREAK;

    //
    //  Set global window handle. used in InstallFiles to determine title of
    //  AddFile dialog.
    //

    ghwndFontDlg = hwndFontDlg; // s_pDlgAddFonts->hWnd( );

    //
    //  Get destination filename from line .
    //

    if( lpTemp = StrChr( pszInfSection, TEXT( '=' ) ) )
    {
        *lpTemp = TEXT( '\0' );

        //
        //  Got left of TEXT( '=' ).
        //

        StringCchCopy( szSrc, cchSrc, pszInfSection );

        CutOffWhite( szSrc, cchSrc );

        DEBUGMSG( (DM_TRACE1, TEXT( "szSrc after CutOffWhite %s" ), szSrc) );

        pszInfSection = lpTemp + 1;
    }
    else
    {
        //
        //  Bad format inf file.
        //

        DEBUGMSG( (DM_TRACE1, TEXT( "Bad Format inf file: %s" ), pszInfSection) );

        bInstalled = FALSE;

        goto NoMoreFiles;
    }

    //
    //  Assume that existing check has been already done in AddFonts( ).
    //

    //
    //  Right side of TEXT( '=' ) can be shirink without any space.
    //

    CutOffWhite( pszInfSection, cchInfSection );

    DEBUGMSG( (DM_TRACE1, TEXT( "pSection after CutOffWhite: %s" ), pszInfSection) );

    //
    //  Build up params for InstallFiles. Now we have pLine as x:name,y:name..
    //

    for(  nFiles = 0, lpTemp = pszInfSection; nFiles < 30; )
    {
        pszFiles[ nFiles ] = lpTemp;

        DEBUGMSG( (DM_TRACE1, TEXT( "File %d: %s" ), nFiles, lpTemp) );
        // DEBUGBREAK;

        nFiles++;

        //
        //  Null terminate each file name string
        //

        if( lpTemp = StrChr( lpTemp+1,TEXT( ',' ) ) )
        {
            *lpTemp ++ = TEXT( '\0' );
        }
        else
            //
            //  Reach end of line.
            //

            break;
    }

    if ((dwInstallFilesResult = InstallFiles(hwndFontDlg, pszFiles, nFiles,
                                             NULL, IFF_CHECKINI)) != nFiles)
    {
        goto NoMoreFiles;
    }

    //
    //  On success, return the place we installed the file.
    //
    PathCombine(szDstName, s_szSharedDir, szSrc);
    StringCchCopy( szDst, cchDst, szDstName );

    //
    //  If source file was splited into multiple files, then we build up
    //  single destination file.
    //

    if(  nFiles  )
    {
        short nDisk;

        GetDiskAndFile( pszFiles[ 0 ], &nDisk, szTemp, ARRAYSIZE( szTemp ) );

        //
        //  Even when nFiles == 1, if the a source file name (we just copied)
        //  is different from the one of destination, we must copy it to
        //  actual destination file.
        //

        if(  lstrcmpi( szSrc, szTemp )  )

        bInstalled = fnAppendSplitFiles( pszFiles, szDstName, nFiles );
    }

NoMoreFiles:

    //
    // If user aborted file installation, set return value so callers will
    // know this.  Callers look for ~01 value.
    //
    if ((DWORD)(-1) == dwInstallFilesResult)
        bInstalled = ~01;

    //
    //  If we didn't create the final dest file, make sure it is deleted.
    //

    if( !bInstalled )
    {
        vCPDeleteFromSharedDir( szDstName );
    }

    ghwndFontDlg = NULL;

    return bInstalled;
}

/*************************************************************************
 * FUNCTION: CopyTTFontWithInf
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/

BOOL NEAR PASCAL CopyTTFontWithInf( HWND hwndFontDlg,
                                    LPTSTR szProfile,
                                    LPTSTR szDesc,
                                    LPTSTR szSrc,
                                    size_t cchSrc,
                                    LPTSTR szDst,
                                    size_t cchDst)
{
    TCHAR   szSect[ MAX_FF_PROFILE_LEN+14 ];
    LPTSTR  pszInfSection = NULL;
    LPTSTR  lpch;
    BOOL    bRet = FALSE;

    StringCchCopy( szSect, ARRAYSIZE(szSect), szProfile);

    //
    //  'outline' section
    //
    lpch = szSect + lstrlen(szProfile);
    StringCchCopy(lpch, ARRAYSIZE(szSect) - (lpch - szSect), TEXT( ".outline" ) /* szTTInfOutline */);

    DEBUGMSG( (DM_TRACE1,TEXT( "CopyTTFontWithInf" ) ) );

    DEBUGMSG( (DM_TRACE1,TEXT( "\tszProfile: %s" ), szProfile ) );

    DEBUGMSG( (DM_TRACE1,TEXT( "\tszSect: %s" ), szSect ) );
    // DEBUGBREAK;

    ReadSetupInfSection(szSetupInfPath, szSect, &pszInfSection);

    if (NULL != pszInfSection)
    {
        if ((bRet = CopyTTOutlineWithInf(hwndFontDlg, pszInfSection, lstrlen(pszInfSection) + 1, szDesc, szSrc, cchSrc, szDst, cchDst)))
        {
            if (~01 == bRet)
            {
                //
                // User abort.
                //
                DEBUGMSG( (DM_ERROR, TEXT( "CopyTTFontWithInf: Return UserAbort!" ) ) );
            }
        }
        else
        {
            //
            //  Fail at installing outline font.
            //
            DEBUGMSG( (DM_ERROR, TEXT( "CopyTTFontWithInf: Error CopyTTOutlineWithInf" ) ) );
        }
        LocalFree(pszInfSection);
    }
    else
    {
        //
        //  Maybe .inf error.
        //
        DEBUGMSG( (DM_ERROR, TEXT( "CopyTTFontWithInf: Error ReadSetUpInf" ) ) );
    }

    return bRet;
}

/*************************************************************************
 * FUNCTION: bInstallOEMFile
 *
 *   LPTSTR lpszDir,      // the directory where this thing is.
 *   LPTSTR lpszDstName,  // Full path to oemsetup.inf on entry
 *   LPTSTR lpszDesc,     // Description of font.
 *   WORD   wFontType,
 *   WORD  wCount )
 *
 * PURPOSE:
 *
 * RETURNS:
 *
 *************************************************************************/
BOOL bInstallOEMFile( LPTSTR lpszDir,
                      LPTSTR lpszDstName,
                      size_t cchDstName,
                      LPTSTR lpszDesc,
                      WORD   wFontType,
                      WORD  wCount )
{
    FullPathName_t szSrcName;
    TCHAR          szTag[ 80 ];

    static FullPathName_t  szOemInfPath;

    TCHAR   szTemp[ PATHMAX ];
    HANDLE  hSection = NULL;


    DEBUGMSG( (DM_TRACE1, TEXT( "bInstallOEMFile( %s, %s )" ), lpszDstName,
                                                               lpszDesc) );
    //
    //  DEBUGBREAK;
    //  copy .inf file into fonts directory
    //
    // Remember the source directory.
    //

    StringCchCopy( szSrcName, ARRAYSIZE(szSrcName), lpszDstName );

    if(  wCount == 0 )
    {
        //
        //  Assume all of description are from same .inf when first one is.
        //

        if( !CopyNewOEMInfFile( lpszDstName, cchDstName ) )
        {
            //
            //  TODO. ui message of some sort.
            //
            return FALSE;
        }

        //
        //  lpszDestName now has the new location of the oemsetup.inf file.
        //

        StringCchCopy( szOemInfPath, ARRAYSIZE(szOemInfPath), lpszDstName );

        DEBUGMSG( (DM_TRACE1,TEXT( "szOemInfPath: %s " ), szOemInfPath ) );

        //
        //  Let InstallFiles() to prompt correct directory.
        //

        StringCchCopy( szSetupDir, ARRAYSIZE(szSetupDir), lpszDir );
    }

    //
    //  Build oemsetup.inf path..
    //

    StringCchCopy( szTemp, ARRAYSIZE(szTemp), szSetupInfPath );

    StringCchCopy( szSetupInfPath, ARRAYSIZE(szSetupInfPath), szOemInfPath );

    if( wFontType > 0xC000 )
    {
        DEBUGMSG( (DM_TRACE1,TEXT( "Can't do a WIFE font, yet" ) ) );
        return FALSE;

        //
        // In this case, bTrueType is atom for tag string of wifefont.
        //

        if( GetAtomName( wFontType, szTag, ARRAYSIZE( szTag ) - 1 ) )
        {
            //
            // There used to be some code in here that was completely disabled
            // with #if 0.  It appeared the intent of the code was to handle
            // WIFE fonts.  The code hadn't been built since at least 1995.
            // [brianau - 02/04/02]
            //
        }
        else
        {
            //
            // Bad condition..maybe mem error or something like that
            //
InfError:
            if( hSection )
               LocalFree( hSection );

            //
            //  Restore setup.inf path.
            //

            StringCchCopy( szSetupInfPath, ARRAYSIZE(szSetupInfPath), szTemp );

            DEBUGMSG( (DM_TRACE1, TEXT( "Error in OEM install" ) ) );
            // DEBUGBREAK;

            return FALSE;
        }
    }
    else if( GetAtomName( wFontType | TRUETYPE_WITH_OEMINF,
                          szTag, ARRAYSIZE( szTag ) - 1 ) )
    {
        BOOL bRet;

        //
        //  When 1 < bTrueType < C000, it also must be an atom for tag string,
        // but it lost 'which bit' when the value was set into listbox.
        // Treat this case as TRUETYPE.
        //

        StringCchCopy( szDirOfSrc, ARRAYSIZE(szDirOfSrc), lpszDir );

        DEBUGMSG( (DM_TRACE1, TEXT( "Calling CopyTTFontWithInf()." ) ) );
        // DEBUGBREAK;

        if( !(bRet = CopyTTFontWithInf( s_pDlgAddFonts->hWnd(), szTag,
                                        lpszDesc, szSrcName, ARRAYSIZE(szSrcName), lpszDstName, cchDstName ) ) )
             goto InfError;

        //
        //  Check User Abort.
        //

        if( bRet == ~01 )
            return FALSE;

        // lstrcpy( lpszDir,lpszDstName );

    }

    //
    //  Restore setup.inf path.
    //

    StringCchCopy( szSetupInfPath, ARRAYSIZE(szSetupInfPath), szTemp );


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\builder.c ===
/***
 **
 **   Module: Builder
 **
 **   Description:
 **    This is a module of the T1 to TT font converter. The module
 **    contains functions that will write the tables found in a
 **    TrueType font file.
 **
 **   Author: Michael Jansson
 **
 **   Created: 5/26/93
 **
 ***/



/**** INCLUDES */
/* General types and definitions. */
#include <string.h>     /* Prototype for memset */
#include <limits.h>

/* Special types and definitions. */
#include "types.h"
#include "metrics.h"
#include "safemem.h"
#include "encoding.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "titott.h"
#include "builder.h"
#include "fwriter.h"

#if DBG
#define STATIC
#else
#define STATIC static
#endif


/***** LOCAL TYPES */
struct GlyphKerning {
	USHORT left;
	USHORT right;
	funit delta;
};

struct GlyphList {
   long offset;            /* File offset of the sub-table for this glyph. */
   const struct encoding *code;  /* Encoding key (see the "Encoding" module. */
   funit aw;               /* Advance width. */
   funit lsb;              /* Left side bearing. */
   USHORT pts;             /* Total number of points in the glyph. */
   Point bbox[2];          /* Bounding box of the glyph. */
   USHORT conts;           /* Number of contours. */
};


/* MS cmap encoding sub-table. */
struct MSEncoding {
   USHORT segCount;
   USHORT *startCount;
   USHORT *endCount;
   USHORT *idOffsets;
   USHORT *gi;
   USHORT giCount;
   USHORT giMax;
};


struct TTHandle {
   OutputFile *file;
   Point bbox[2];
   struct GlyphList *pool;

   /* Accumulative 'maxp' entries. */
   USHORT count;
   USHORT maxcnt;
   USHORT maxpts;
   USHORT maxcontours;
   USHORT maxcomppts;
   USHORT maxcompcont;
   USHORT maxcompelements;
   USHORT maxstack;
   USHORT maxinstructions;
   USHORT maxtwilight;
};



/***** CONSTANTS */
#define SHORT_LOCA_MAX  65535
#define KERN_HORIZONTAL 0x0001
#define KERN_PAIR   0x0000
#define KERN_FORMAT0   0x0000

#define GASP_GRIDFIT    0x0001
#define GASP_DOGRAY     0x0002

#define PLT_MAC         (USHORT)1
#define PLT_MS          (USHORT)3

#define ENC_ROMAN       (USHORT)0

// for platform id = 3 cmap table, symbol font or ugl

#define ENC_SYMBOL      (USHORT)0
#define ENC_UGL         (USHORT)1

#define LAN_MS_US       (USHORT)0x0409
#define LAN_MAC_US      (USHORT)0

#define COPYRIGHT       (USHORT)0
#define FAMILY          (USHORT)1
#define SUBFAMILY       (USHORT)2
#define ID              (USHORT)3
#define FULLNAME        (USHORT)4
#define VERSION         (USHORT)5
#define PSNAME          (USHORT)6
#define NOTICE          (USHORT)7


/* Glyph constants. */
#define FLG_ONCURVE     0x01
#define FLG_SHORTX      0x02
#define FLG_SHORTY      0x04
#define FLG_REPEAT      0x08
#define FLG_SAMEX       0x10
#define FLG_SAMEY       0x20

#define ARGS_1_2_ARE_WORDS  0x0001
#define ARGS_ARE_XY_VALUES  0x0002
#define ROUND_XY_TO_GRID    0x0004
#define MORE_COMPONENTS     0x0020

#define GLYPHBUF     64          /* GlyphList's that are allocated each time */
#define MACSIZE      (USHORT)256 /* Length of the Mac encoding vector. */

/* Table constants. */
#define FIRSTCHAR    (USHORT)0x0020 /* First defined char. */
#define LASTCHAR     (USHORT)0xf002 /* Last defined char. */
#define MAXZONES     (USHORT)2      /* Number of zones in the font. */
#define MAXIDEFS     (USHORT)0      /* Number of idefs in the fpgm. */
#define MAXDEPTH     (USHORT)1      /* Number of recursions in composits. */
#define FM_READONLY  (USHORT)2      /* fsType Read Only. */
#define NO_CLASS     (USHORT)0      /* 0 = No class id for the font. */
#define OS2VERSION   (USHORT)0      /* Version of the OS/2 table. */
#define CARET_RISE   (USHORT)1      /* Vertical caret slope rise. */
#define CARET_RUN    (USHORT)0      /* Vertical caret slope run. */
#define RESERVED0    (USHORT)0
#define MAGICCOOKIE  0x5F0F3CF5L    /* Magic cookie. */
#define BASELINEY    (USHORT)0x0001 /* Baseline at y==0 */
#define LOWPPEM      (USHORT)8      /* Lowest PPEM size. */
#define ROMAN        (USHORT)2      /* Direction = left,right&neutrals.*/
#define GLYPH_FORMAT (USHORT)0      /* Current glyphs format. */
#define VERSION0     (USHORT)0      /* Version zero of a table. */
#define NUM_CMAPS    (USHORT)2      /* Number of cmap sub-tables. */
#define SEGMENT_MAP  (USHORT)4      /* MS segment mapping of cmap table. */
#define PAD0         (USHORT)0      /* Padding byte. */
#define MAX_PPEM_SIZE     (USHORT)65535  /* Maximum PPEM size in GASP table. */

/* LOCA constants */
#define SHORTOFFSETS 0
#define LONGOFFSETS  1


/* Weighted average character width. */
STATIC const long Weights[] = {
   64,
   14,
   27,
   35,
   100,
   20,
   14,
   42,
   63,
   3,
   6,
   35,
   20,
   56,
   56,
   17,
   4,
   49,
   56,
   71,
   31,
   10,
   18,
   3,
   18,
   2
};

/***** MACROS */
#define LONGVERSION(v,r)      ((((long)v)<<16L) | (long)r)


/***** STATIC FUNCTIONS */

/***
** Function: SearchRange
**
** Description:
**   Compute the search range key for the CMAP subtable
**   for Windows.
***/
STATIC USHORT SearchRange(const USHORT cnt)
{
   USHORT i;

   i = 0;
   while ((1u<<i) <= cnt) {
      i++;
   }

   return (USHORT)(1<<i);
}



/***
** Function: EntrySelector
**
** Description:
**   Compute the entry selector key for the CMAP subtable
**   for Windows.
***/
STATIC USHORT EntrySelector(const USHORT cnt)
{
   USHORT i;

   i = 0;
   while ((1u<<(i+1)) <= cnt) {
      i++;
   }

   return i;
}



/***
** Function: RangeShift
**
** Description:
**   Compute the range shift key for the CMAP subtable
**   for Windows.
***/
STATIC USHORT RangeShift(const USHORT cnt)
{
   return (USHORT)(2*cnt - SearchRange(cnt));
}



/***
 ** Function: PutGASP
 **
 ** Description:
 **   This function writes the optional 'GASP' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutGASP(OutputFile *file,
		      const USHORT treshold)
{
   long offset;

   offset = FileTell(file);

   WriteShort(VERSION0, file);
   WriteShort(3, file);

   /* First range 0 - 8 : GRIDFIT */
   WriteShort(8, file);
   WriteShort(GASP_DOGRAY, file);

   /* Second range 8 - onpix : GRIDFIT */
   WriteShort(treshold, file);
   WriteShort(GASP_GRIDFIT, file);

   /* Third range onpix - inf. : GRIDFIT | GRAYSCALE */
   WriteShort(MAX_PPEM_SIZE, file);
   WriteShort(GASP_GRIDFIT | GASP_DOGRAY, file);

   return CompleteTable(offset, TBL_GASP, file);
}


/***
** Function: cmpKern
**
** Description:
**
***/
STATIC int CDECL cmpKern(const void *a1, const void *a2)
{
   const struct GlyphKerning *k1 = a1;
   const struct GlyphKerning *k2 = a2;
   ULONG first;
   ULONG second;

   first = ((k1->left)<<16L) + k1->right;
   second = ((k2->left)<<16L) + k2->right;

   return (int)(first - second);
}


/***
 ** Function: StdEncToGlyphIndex
 **
 ** Description:
 **   This function maps an StdEncoding character code to a
 **   glyph index.
 **
 ***/
USHORT StdEncToGlyphIndex(const struct GlyphList *pool,
						  const USHORT count,
						  const USHORT code)
{
	USHORT i;

	for (i=0; i<count; i++) {
            if (LookupCharCode(pool[i].code, ENC_MSWINDOWS) == code)
                 return i;
	}

	return 0;
}


/***
 ** Function: PutKERN
 **
 ** Description:
 **   This function writes the optional 'KERN' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutKERN(OutputFile *file,
					   struct kerning *charkerns,
					   const USHORT kernsize,
					   const struct GlyphList *pool,
					   const USHORT count)
{
   struct GlyphKerning *kerns;
   long offset;
   unsigned i;
   USHORT cnt;

   if ((kerns = malloc(sizeof(struct GlyphKerning)*kernsize))==NULL)
	   return FAILURE;

   /* Translate the kerning from char codes to glyph index. */
   for (i=0, cnt=0; i<kernsize; i++) 
   {
	   if ((kerns[cnt].left  = StdEncToGlyphIndex(pool, count, charkerns[i].left))!=0 &&
		   (kerns[cnt].right = StdEncToGlyphIndex(pool, count, charkerns[i].right))!=0) 
	   {
		   kerns[cnt].delta = charkerns[i].delta;
		   cnt++;
	   }
   }
   /* Sort the kerning pairs. */
   qsort((void *)kerns, cnt, sizeof(struct GlyphKerning), cmpKern);


   offset = FileTell(file);

   WriteShort(VERSION0, file);
   WriteShort(1, file);

   /* First sub-table header. */
   WriteShort(VERSION0, file);
   WriteShort((USHORT)(2+2+2+ 2+2+2+2+ cnt*(2+2+2)), file);
   WriteShort(KERN_HORIZONTAL | KERN_PAIR | KERN_FORMAT0, file);

   /* First sub-table, format 0 */
   WriteShort(cnt, file);
   WriteShort(SearchRange(cnt), file);
   WriteShort(EntrySelector(cnt), file);
   WriteShort(RangeShift(cnt), file);
   for (i=0; i<cnt; i++) {
      WriteShort((USHORT)kerns[i].left, file);
      WriteShort((USHORT)kerns[i].right, file);
      WriteShort((USHORT)kerns[i].delta, file);
   }

   free(kerns);

   return CompleteTable(offset, TBL_KERN, file);
}


/***
 ** Function: PutCVT
 **
 ** Description:
 **   This function writes the optional 'cvt' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutCVT(OutputFile *file,
		      const short *ppgm,
		      const USHORT num)
{
   USHORT i;
   long offset;

   offset = FileTell(file);

   for (i=0; i<num; i++)
      WriteShort((USHORT)ppgm[i], file);

   return CompleteTable(offset, TBL_CVT, file);
}



/***
 ** Function: PutPREP
 **
 ** Description:
 **   This function writes the optional 'prep' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutPREP(OutputFile *file,
		       const UBYTE *prep,
		       const USHORT num)
{
   long offset;

   offset = FileTell(file);

   (void)WriteBytes(prep, num, file);

   return CompleteTable(offset, TBL_PREP, file);
}



/***
 ** Function: PutFPGM
 **
 ** Description:
 **   This function writes the optional 'fpgm' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutFPGM(OutputFile *file,
		       const UBYTE *fpgm,
		       const USHORT num)
{
   long offset;

   offset = FileTell(file);

   (void)WriteBytes(fpgm, num, file);

   return CompleteTable(offset, TBL_FPGM, file);
}



/***
 ** Function: PutPOST
 **
 ** Description:
 **   This function writes the required 'post' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutPOST(OutputFile *file,
		       struct GlyphList *pool,
		       USHORT count,
		       struct TTMetrics *ttm)
{
   const char *str;
   long offset;
   USHORT i;

   offset = FileTell(file);
   WriteLong(LONGVERSION(2, 0), file);
   WriteLong((ULONG)ttm->angle, file);
   WriteShort((USHORT)ttm->underline, file);
   WriteShort((USHORT)ttm->uthick, file);
   WriteLong((ULONG)ttm->isFixPitched, file);
   WriteLong(0L, file);
   WriteLong(0L, file);
   WriteLong(0L, file);
   WriteLong(0L, file);

   /* Write the character codes. */
   WriteShort(count, file);
   for (i=0; i<count; i++) {
      if (pool[i].code)
	 WriteShort(LookupCharCode(pool[i].code, ENC_MACCODES), file);
      else
	 WriteShort((USHORT)0, file);
   }

   /* Write the character names. */
   for (i=0; i<count; i++) {
      if (pool[i].code) {
	 str = LookupCharName(pool[i].code);
	 WriteByte((UBYTE)strlen(str), file);
	 (void)WriteBytes((UBYTE*)str, (USHORT)strlen(str), file);
      }
   }

   return CompleteTable(offset, TBL_POST, file);
}



/***
 ** Function: PutMAXP
 **
 ** Description:
 **   This function writes the required 'maxp' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutMAXP(struct TTHandle *tt,
		       const USHORT maxstorage,
		       const USHORT maxprepstack,
		       const USHORT maxfuns)
{
   long offset;

   offset = FileTell(tt->file);
   WriteLong(LONGVERSION(1, 0), tt->file);
   WriteShort(tt->count, tt->file);
   WriteShort(tt->maxpts, tt->file);
   WriteShort(tt->maxcontours, tt->file);
   WriteShort(tt->maxcomppts, tt->file);
   WriteShort(tt->maxcompcont, tt->file);
   WriteShort(MAXZONES, tt->file);
   WriteShort(tt->maxtwilight, tt->file);
   WriteShort(maxstorage, tt->file);
   WriteShort(maxfuns, tt->file);
   WriteShort(MAXIDEFS, tt->file);
   WriteShort((USHORT)MAX(tt->maxstack, maxprepstack), tt->file);
   WriteShort(tt->maxinstructions, tt->file);
   WriteShort(tt->maxcompelements, tt->file);
   WriteShort(MAXDEPTH, tt->file);
   return CompleteTable(offset, TBL_MAXP, tt->file);
}



/***
 ** Function: PutOS2
 **
 ** Description:
 **   This function writes the required 'OS/2' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutOS2(OutputFile *file,
		      const struct GlyphList *pool,
		      const USHORT count,
		      const struct TTMetrics *ttm)
{
   long offset;
   long aw;
   USHORT i;

   offset = FileTell(file);

   /* Compute some font metrics. */
   aw = 0;

   /* Do a weighted average? */
   if (ttm->Encoding==NULL) {
	   for (i=0; i<count; i++) {
		   short letter = (short)LookupCharCode(pool[i].code, ENC_MACCODES);
		   if (letter==' ') {
			   aw = aw + 166L * pool[i].aw;
		   } else if ((letter>='a' && letter <= 'z')) {
			   aw = aw + pool[i].aw * Weights[letter - 'a'];
		   }
	   }
	   aw /= 1000;
   } else {
	   for (i=0; i<count; i++) {
		   aw += pool[i].aw;
	   }
	   if (count)
		   aw = aw / count;
   }

   WriteShort(OS2VERSION, file);
   WriteShort((USHORT)aw, file);
   WriteShort(ttm->usWeightClass, file);
   WriteShort(ttm->usWidthClass, file);
   WriteShort(FM_READONLY, file);
   WriteShort((USHORT)ttm->subsize.x, file);
   WriteShort((USHORT)ttm->subsize.y, file);
   WriteShort((USHORT)ttm->suboff.x, file);
   WriteShort((USHORT)ttm->suboff.y, file);
   WriteShort((USHORT)ttm->supersize.x, file);
   WriteShort((USHORT)ttm->supersize.y, file);
   WriteShort((USHORT)ttm->superoff.x, file);
   WriteShort((USHORT)ttm->superoff.y, file);
   WriteShort((USHORT)ttm->strikesize, file);
   WriteShort((USHORT)ttm->strikeoff, file);
   WriteShort(NO_CLASS, file);

   /* Panose */
   WriteBytes(ttm->panose, (USHORT)10, file);

   /* Char range. */
   WriteLong(0L, file);
   WriteLong(0L, file);
   WriteLong(0L, file);
   WriteLong(0L, file);

   /* Vend ID. */
   WriteLong(0L, file);

   WriteShort(ttm->fsSelection, file);
   WriteShort(FIRSTCHAR, file);
   WriteShort(LASTCHAR, file);
   WriteShort((USHORT)ttm->typAscender, file);
   WriteShort((USHORT)ttm->typDescender, file);
   WriteShort((USHORT)ttm->typLinegap, file);
   WriteShort((USHORT)ttm->winAscender, file);
   WriteShort((USHORT)ttm->winDescender, file);

   return CompleteTable(offset, TBL_OS2, file);
}



/***
 ** Function: PutLOCA
 **
 ** Description:
 **   This function writes the required 'loca' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutLOCA(OutputFile *file,
		       const struct GlyphList *pool,
		       const USHORT count,
		       short *format)
{
   long offset;
   USHORT i;

   offset = FileTell(file);

   /* Check for offset size format. */
   for (i=0, (*format) = SHORTOFFSETS; i<=count &&
			 (*format)==SHORTOFFSETS; i++) {
      if (pool[i].offset/2>SHORT_LOCA_MAX)
	 (*format) = LONGOFFSETS;
   }

   if ((*format)==LONGOFFSETS)
      for (i=0; i<=count; i++)
	 WriteLong((ULONG)pool[i].offset, file);
   else
      for (i=0; i<=count; i++)
	 WriteShort((USHORT)(pool[i].offset/2), file);

   return CompleteTable(offset, TBL_LOCA, file);
}



/***
 ** Function: PutHMTX
 **
 ** Description:
 **   This function writes the required 'hmtx' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutHMTX(OutputFile *file,
		       const struct GlyphList *pool,
		       const USHORT count,
		       const funit *widths,
		       const USHORT first,
                       const USHORT last,
                       const  struct encoding *enc)

{
   long offset;
   USHORT std;
   USHORT i;
   USHORT usEnc = (USHORT) (enc? ENC_MACCODES : ENC_UNICODE);

   offset = FileTell(file);

   if (widths) {
      for (i=0; i<count; i++) {
	 if (pool[i].code) {
            std = LookupCharCode(pool[i].code, usEnc);
	 } else {
	    std = NOTDEFGLYPH;
	 }
	 if (std>=first && std<=last)
	    WriteShort((USHORT)widths[std-first], file);
	 else
	    WriteShort((USHORT)pool[i].aw, file);
	 WriteShort((USHORT)pool[i].lsb, file);
      }
   } else {
      for (i=0; i<count; i++) {
	 WriteShort((USHORT)pool[i].aw, file);
	 WriteShort((USHORT)pool[i].lsb, file);
      }
   }
   return CompleteTable(offset, TBL_HMTX, file);
}



/***
 ** Function: PutHHEA
 **
 ** Description:
 **   This function writes the required 'HHEA' table to the
 **   TT font file.
 **
 ***/
STATIC errcode PutHHEA(OutputFile *file,
		       const struct GlyphList *pool,
		       const USHORT count,
		       const Point bbox[2],
                       const funit linegap,
                       const struct TTMetrics *ttm
)
{
   funit awmin, awmax, xmax, lsb;
   long offset;
   USHORT i;

   offset = FileTell(file);

   /* Compute some font metrics. */
   awmax = SHRT_MIN;
   awmin = SHRT_MAX;
   xmax = SHRT_MIN;
   lsb = SHRT_MAX;
   for (i=0; i<count; i++) {
      funit rsb = pool[i].aw - pool[i].lsb -
		  (pool[i].bbox[1].x - pool[i].bbox[0].x);
      funit ext = pool[i].lsb +
		  (pool[i].bbox[1].x - pool[i].bbox[0].x);
      if (ext>xmax)
	 xmax = ext;
      if (rsb<awmin)
	 awmin = rsb;
      if (pool[i].aw>awmax)
	 awmax = pool[i].aw;
      if (pool[i].lsb<lsb)
	 lsb = pool[i].lsb;
   }


   WriteLong(LONGVERSION(1, 0), file);
   WriteShort((USHORT)bbox[1].y, file);
   WriteShort((USHORT)bbox[0].y, file);
   WriteShort((USHORT)linegap, file);
   WriteShort((USHORT)awmax, file);
   WriteShort((USHORT)lsb, file);
   WriteShort((USHORT)awmin, file);
   WriteShort((USHORT)xmax, file);
   WriteShort(CARET_RISE, file);
   WriteShort(CARET_RUN, file);
   WriteShort((USHORT)(ttm->FirstChar   << 8), file);
   WriteShort((USHORT)(ttm->LastChar    << 8), file);
   WriteShort((USHORT)(ttm->DefaultChar << 8), file);
   WriteShort((USHORT)(ttm->BreakChar   << 8), file);
   WriteShort((USHORT)(ttm->CharSet     << 8), file);
   WriteShort(RESERVED0, file);
   WriteShort(count, file);
   return CompleteTable(offset, TBL_HHEA, file);
}



/***
** Function: PutHEAD
**
** Description:
**   This function writes the required 'head' table to the
**   TT font file.
**
***/
STATIC errcode PutHEAD(OutputFile *file,
		       const Point bbox[2],
		       const struct TTMetrics *ttm,
		       const short loca,
		       long *csum)
{
   long offset;

   offset = FileTell(file);

   WriteLong(LONGVERSION(1, 0), file);
   WriteShort(ttm->version.ver, file);
   WriteShort(ttm->version.rev, file);
   (*csum) = (long)FileTell(file);
   WriteLong(0L, file);
   WriteLong(MAGICCOOKIE, file);
   WriteShort(BASELINEY, file);
   WriteShort((USHORT)ttm->emheight, file);
   WriteLong(ttm->created.a, file);WriteLong(ttm->created.b, file);
   WriteLong(ttm->created.a, file);WriteLong(ttm->created.b, file);
   WriteShort((USHORT)bbox[0].x, file);
   WriteShort((USHORT)bbox[0].y, file);
   WriteShort((USHORT)bbox[1].x, file);
   WriteShort((USHORT)bbox[1].y, file);
   WriteShort((USHORT)ttm->macStyle, file);
   WriteShort(LOWPPEM, file);
   WriteShort(ROMAN, file);
   WriteShort((USHORT)loca, file);
   WriteShort(GLYPH_FORMAT, file);

   return CompleteTable(offset, TBL_HEAD, file);
}



/***
** Function: WriteNameEntry
**
** Description:
**   This function writes an entry in the NAME table
**   header for one string.
**
***/
STATIC USHORT WriteNameEntry(OutputFile *file,
			     const USHORT platform,
			     const USHORT encoding,
			     const USHORT language,
			     const USHORT nameid,
			     const char *str,
			     const USHORT off)
{
   USHORT len;

   if (str) {
      len = (USHORT)strlen(str);
      switch (platform) {
	 case PLT_MS:
	    len *= 2;
	    break;
	 case PLT_MAC:
	    len *= 1;
	    break;
	 default:
	    LogError(MSG_WARNING, MSG_PLATFORM, NULL);
	    len *= 1;
	    break;
      }
      WriteShort(platform, file);
      WriteShort(encoding, file);
      WriteShort(language, file);
      WriteShort(nameid, file);
      WriteShort(len, file);
      WriteShort(off, file);
   } else {
      len = 0;
   }

   return len;
}



/***
** Function: WriteNameString
**
** Description:
**   This function write the textual data of a string
**   to the NAME table, according to the platform and
**   encoding schema.
**
***/
STATIC void WriteNameString(OutputFile *file,
			    const USHORT platform,
			    const char *str)
{
   USHORT i;

   if (str) {
      switch (platform) {
	 default:
	 case PLT_MAC:
	    (void)WriteBytes((UBYTE *)str, (USHORT)strlen(str), file);
	    break;
	 case PLT_MS:
	    for (i=0; i<strlen(str); i++)
	       WriteShort(LookupCharCode(DecodeChar(NULL,
						    (short)0,
						    ENC_STANDARD,
						    (USHORT)(UBYTE)str[i]),
					 ENC_UNICODE),
			  file);
	    break;
      }
   }
}



/***
** Function: PutNAME
**
** Description:
**   This function writes the required 'name' table to the
**   TT font file.
**
***/



STATIC errcode PutNAME(OutputFile *file, const struct TTMetrics *ttm)
{
   USHORT stroff = 0;
   USHORT count = 0;
   USHORT encId = ttm->Encoding ? ENC_SYMBOL : ENC_UGL;
   ULONG offset;
   char *id;
   char *pszStyle = NULL;

   if (ttm->usWeightClass < 500)
   {
      if (ttm->angle == 0)
      {
         pszStyle = "Regular";
      }
      else
      {
         pszStyle = "Italic";
      }
   }
   else
   {
      if (ttm->angle == 0)
      {
         pszStyle = "Bold";
      }
      else
      {
         pszStyle = "Bold Italic";
      }
   }

   /* Count the number of names. */
   if (ttm->copyright)
      count++;
   if (ttm->family)
      count++;
   if (pszStyle)
      count++;
   if (ttm->id) {
      count++;
      id = ttm->id;
   } else {
      id = ttm->name;
      count++;
   }
   if (ttm->fullname)
      count++;
   if (ttm->verstr)
      count++;
   if (ttm->name)
      count++;
   if (ttm->notice)
      count++;
   count *= 2;


   /* Write the name table. */
   offset = (ULONG)FileTell(file);
   WriteShort(VERSION0, file);
   WriteShort(count, file);
   WriteShort((USHORT)(6+count*12), file);

   /* Mac names */
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, COPYRIGHT,
		    ttm->copyright, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, FAMILY,
		    ttm->family, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, SUBFAMILY,
                    pszStyle, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, ID,
		    id, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, FULLNAME,
		    ttm->fullname, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, VERSION,
		    ttm->verstr, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, PSNAME,
		    ttm->name, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MAC, ENC_ROMAN,
		    LAN_MAC_US, NOTICE,
		    ttm->notice, stroff));

   /* MS names */
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, COPYRIGHT,
		    ttm->copyright, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, FAMILY,
		    ttm->family, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, SUBFAMILY,
                    pszStyle, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, ID,
		    id, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, FULLNAME,
		    ttm->fullname, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, VERSION,
		    ttm->verstr, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, PSNAME,
		    ttm->name, stroff));
   stroff = (USHORT)(stroff + WriteNameEntry(file, PLT_MS, encId,
		    LAN_MS_US, NOTICE,
		    ttm->notice, stroff));

   WriteNameString(file, PLT_MAC, ttm->copyright);
   WriteNameString(file, PLT_MAC, ttm->family);
   WriteNameString(file, PLT_MAC, pszStyle);
   WriteNameString(file, PLT_MAC, id);
   WriteNameString(file, PLT_MAC, ttm->fullname);
   WriteNameString(file, PLT_MAC, ttm->verstr);
   WriteNameString(file, PLT_MAC, ttm->name);
   WriteNameString(file, PLT_MAC, ttm->notice);

   WriteNameString(file, PLT_MS, ttm->copyright);
   WriteNameString(file, PLT_MS, ttm->family);
   WriteNameString(file, PLT_MS, pszStyle);
   WriteNameString(file, PLT_MS, id);
   WriteNameString(file, PLT_MS, ttm->fullname);
   WriteNameString(file, PLT_MS, ttm->verstr);
   WriteNameString(file, PLT_MS, ttm->name);
   WriteNameString(file, PLT_MS, ttm->notice);

   return CompleteTable((long)offset, TBL_NAME, file);
}



/***
** Function: BoundingBox
**
** Description:
**   Extend an already initialized rectangle (two points)
**   so that it encolses a number of coordinates.
***/
STATIC void BoundingBox(Point bbox[2],
			const Point *pts,
			const USHORT cnt)
{
   USHORT i;

   for (i=0; i<cnt; i++) {
      if (bbox[0].x > pts[i].x)
	 bbox[0].x = pts[i].x;
      if (bbox[1].x < pts[i].x)
	 bbox[1].x = pts[i].x;
      if (bbox[0].y > pts[i].y)
	 bbox[0].y = pts[i].y;
      if (bbox[1].y < pts[i].y)
	 bbox[1].y = pts[i].y;
   }
}



/***
** Function: RecordGlyph
**
** Description:
**   Record information about glyph record of the glyf table.
***/
STATIC errcode RecordGlyph(struct TTHandle *tt,
			   const struct encoding *code,
			   const Point *bbox,
			   const funit aw,
			   const USHORT pts,
			   const USHORT conts)
{
   errcode status;
   USHORT i;

   i = tt->count;

   /* Make sure that there is enough memory in the pool. */
   if (tt->count+1>=tt->maxcnt) {
      struct GlyphList *gl;

      if ((gl = Realloc(tt->pool,
			(size_t)(tt->maxcnt+GLYPHBUF)*
			sizeof(struct GlyphList)))==NULL) {
	 SetError(status=NOMEM);
	 return status;
      } else {
	 tt->maxcnt += GLYPHBUF;
	 tt->pool = gl;
      }
   }

   /* Record metrics. */
   tt->count++;
   tt->pool[i].pts = pts;
   tt->pool[i].conts = conts;
   tt->pool[i].lsb = bbox[0].x;
   tt->pool[i].aw = aw;
   tt->pool[i].bbox[0] = bbox[0];
   tt->pool[i].bbox[1] = bbox[1];
   tt->pool[i].code = code;
   tt->pool[i].offset = FileTell(tt->file) - 12L - (long)TBLDIRSIZE*NUMTBL;

   /* Update the global bounding box. */
   BoundingBox(tt->bbox, bbox, (short)2);

   /* Update maxp. */
   if (conts>tt->maxcontours)
      tt->maxcontours = conts;
   if (pts>tt->maxpts)
      tt->maxpts = pts;

   return SUCCESS;
}



/***
** Function: BuildMacCMAP
**
** Description:
**   Compute the CMAP subtable for the Mac.
***/
STATIC void BuildMacCMAP(const struct GlyphList *pool,
                         const USHORT count,
                         UBYTE *ascii2gi,
                         const struct encoding *encRoot,
                         const int encSize)
{
   const struct encoding *notdef = LookupNotDef();
   USHORT code;
   UBYTE i;

   /* Initiate the ascii to glyph-index array. Glyph 0 is the "notdef"
		character, so any unassigned character will be mapped to "notdef". */
   memset(ascii2gi, NOTDEFGLYPH, (unsigned int)MACSIZE);

   /* Build the ascii to glyph-index array. */
   if (encRoot==NULL)
   {
      for (i=2; i<MIN(255,count); i++)
      {
         if (pool[i].code!=NULL)
         {
            /* i = glyph index, Lookup..() = character code.
            Map glyph i only if it is a valid Mac character. */
            if (pool[i].code!=NULL &&
                (code = LookupCharCode(pool[i].code,ENC_MACCODES))!=NOTDEFCODE &&
				code<MACSIZE)
               ascii2gi[code] = i;
         }
      }
   }
   else
   {
      for (i=2; i<MIN(255,count); i++)
      {
         if (pool[i].code!=NULL && pool[i].code!=notdef)
         {
            const struct encoding *encGlyph;
            encGlyph = LookupFirstEnc(encRoot, encSize, pool[i].code);
            do
            {
               if ((code = LookupCharCode(encGlyph, ENC_MACCODES))!=NOTDEFCODE && code<MACSIZE)
                  ascii2gi[code] = i;
            } while (encGlyph = LookupNextEnc(encRoot, encSize, encGlyph));
         }
      }
   }

   /* Constant Mac glyph/encoding mapping for standard encoded fonts */

   if (encRoot==NULL)
   {
      /* Missing glyphs. */
      for (i=1; i<=31; i++)
              ascii2gi[i] = NOTDEFGLYPH;
      ascii2gi[127] = NOTDEFGLYPH;

      /* Null glyphs. */
      ascii2gi[0] = 1;
      ascii2gi[8] = 1;
      ascii2gi[13] = 1;
      ascii2gi[29] = 1;

      /* No countours + positive advance width. */
      ascii2gi[9] = ascii2gi[32];
      ascii2gi[13] = ascii2gi[32];
      ascii2gi[202] = ascii2gi[32];
   }
}



/***
** Function: FreeMSEncoding
**
** Description:
**   Free resourses used while computing the CMAP subtable
**   for Windows.
***/
STATIC void FreeMSEncoding(struct MSEncoding *ms)
{
   if (ms->startCount)
      Free(ms->startCount);

   if (ms->gi)
      Free(ms->gi);
}



/***
** Function: BuildMSCMAP
**
** Description:
**   Compute the CMAP subtable for Windows.
***/
STATIC errcode BuildMSCMAP(const struct GlyphList *pool,
const  USHORT           count,
struct MSEncoding      *ms,
const  struct encoding *encRoot,
const  int              encSize
)
{
   USHORT *twobyte = NULL;
   USHORT idOffset;
   USHORT code, max;
   USHORT i, j, k, big, n;

   /* Get the range of the UGL characters. */
   max = 0;
   big = 0;

   if (encRoot==NULL)
   {
      for (i=2; i<count; i++)
      {
         if (pool[i].code!=NULL)
         {
            if ((code = LookupCharCode(pool[i].code, ENC_UNICODE))!=NOTDEFCODE)
            {
               if (code<=0xff)
               {
                  if (code>max)
                     max = code;
               }
               else
               {
                  big++;
               }
            }
         }
      }
   }
   else
   /* A non-standard encoded font, i.e. a fonts with an explicit
      encoding array may reference the same glyph more than once,
           though each glyph only refers to one encoding item. We have to
           enumerate through all code point for each glyph in this case.
   */
   {
      for (i=2; i<count; i++)
      {
         if (pool[i].code!=NULL)
         {
            const struct encoding *encGlyph = LookupFirstEnc(encRoot,
                                                             encSize,pool[i].code);
            do
            {
               if ((code = LookupCharCode(encGlyph, ENC_MACCODES))!=NOTDEFCODE)
               {
                  if (code>max)
                     max = code;
               }

            } while (encGlyph = LookupNextEnc(encRoot, encSize, encGlyph));
         }
      }
   }

   max++;
   max = (USHORT)(max + big);
   if ((ms->gi = Malloc(sizeof(USHORT)*max))==NULL) {
      return NOMEM;
   }
   memset(ms->gi, NOTDEFGLYPH, max*sizeof(USHORT));

   if (big && (twobyte = Malloc(sizeof(USHORT)*big))==NULL) {
      Free(ms->gi);
      ms->gi = NULL;
      return NOMEM;
   }
	
   j = 0;
   if (encRoot==NULL)
   {
      /* Glyph zero and Glyp one are the "notdef" and the "null" glyph,
              and are not encoded here, so skip the first two glyph.
      */
      for (i=2; i<count; i++)
      {
         code = LookupCharCode(pool[i].code, ENC_UNICODE);
         if (pool[i].code && code!=NOTDEFCODE)
         {
            if (code<=0xff)
            {
               ms->gi[code] = i;
            }
            else
            {
               for (k=0; k<j; k++)
                  if (twobyte[k]>code)
                     break;
               for (n=j; n>k; n--)
               {
                  twobyte[n] = twobyte[n-1];
                  ms->gi[max-big+n] = ms->gi[max-big+n-1];
               }
               twobyte[k] = code;
               ms->gi[max-big+k] = i;
               j++;
            }
         }
      }
   }
   else
   {
      for (i=2; i<count; i++)
      {
         const struct encoding *encGlyph;

         if (pool[i].code)
         {
            encGlyph = LookupFirstEnc(encRoot, encSize, pool[i].code);
            do
            {
               if ((code = LookupCharCode(encGlyph, ENC_MACCODES))!=NOTDEFCODE)
               {
                  ms->gi[code] = i;
               }
            } while (encGlyph = LookupNextEnc(encRoot, encSize, encGlyph));
         }
      }
   }

   /* Count the segments. */
   ms->segCount=(USHORT)(2+big);
   for (i=0; i<max-big-1; i++) {
      if (ms->gi[i]!=NOTDEFGLYPH && ms->gi[i+1]==NOTDEFGLYPH) {
	 ms->segCount++;
      }
   }

   ms->startCount = Malloc(3 * (sizeof(USHORT)*ms->segCount));

   if (ms->startCount==NULL) {
      if (twobyte)
	 Free(twobyte);
      FreeMSEncoding(ms);
      return NOMEM;
   }

   ms->endCount =  (USHORT *)((char *)ms->startCount + sizeof(USHORT)*ms->segCount);
   ms->idOffsets = (USHORT *)((char *)ms->endCount +  sizeof(USHORT)*ms->segCount);

   /* i=UGL index, j=segment index, k=glyph index. */
   for (i=0, j=0, k=0; i<max-big; i++) {
      if (ms->gi[i]!=NOTDEFGLYPH) {
	 if (i==0 || (ms->gi[i-1]==NOTDEFGLYPH)) {
	    ms->startCount[j] = i;
	    ms->idOffsets[j] = (USHORT)((ms->segCount-j+k)*2);
	 }
	 if ((i==max-1-big) || (ms->gi[i+1]==NOTDEFGLYPH)) {
	    ms->endCount[j] = i;
	    j++;
	 }
	 k++;
      }
   }

   /* Segment for the double byte characters. */
   idOffset = (USHORT)((ms->segCount-j+k)*2);
   for (i=0; i<big; i++) {
      ms->startCount[j] = twobyte[i];
      ms->idOffsets[j] = idOffset;
      ms->endCount[j] = twobyte[i];
      k++;
      j++;
   }

   ms->giCount = k;
   ms->giMax = max;

   /* Sentinel segments. */
   ms->startCount[ms->segCount-1] = 0xffff;
   ms->endCount[ms->segCount-1] = 0xffff;
   ms->idOffsets[ms->segCount-1] = 0;

   if (twobyte)
      Free(twobyte);

   return SUCCESS;
}



/***
** Function: PutCMAP
**
** Description:
**   This function writes the required 'cmap' table to the
**   TT font file.
***/
STATIC errcode PutCMAP(
struct TTHandle *tt,
UBYTE *ascii2gi,
const struct encoding *enc,
const int encSize)
{
   struct MSEncoding ms;
   long end, offset;
   errcode status = SUCCESS;
   USHORT i;
   USHORT usBias = (USHORT)(enc ? 0xf000 : 0); // bias for the first glyph

   /* Build Mac encoding table. */
   BuildMacCMAP(tt->pool, tt->count, ascii2gi, enc, encSize);


   /* Build MS encoding table. */
   if ((status = BuildMSCMAP(tt->pool, tt->count, &ms, enc, encSize))!=SUCCESS)
      return status;

   offset = FileTell(tt->file);

   /* Write cmap table. */
   WriteShort(VERSION0, tt->file);
   WriteShort(NUM_CMAPS, tt->file);

   /*== CMAP table directory ==*/
   WriteShort(PLT_MAC, tt->file);
   WriteShort(ENC_ROMAN, tt->file);
   WriteLong(0L, tt->file);
   WriteShort(PLT_MS, tt->file);
   WriteShort((USHORT)(enc ? ENC_SYMBOL : ENC_UGL), tt->file);
   WriteLong(0L, tt->file);

   /* Standard apple encoding. */
   end = FileTell(tt->file);
   (void)FileSeek(tt->file, offset+8);
   WriteLong((ULONG)(end-offset), tt->file);
   (void)FileSeek(tt->file, end);
   WriteShort((USHORT)0, tt->file);
   WriteShort((USHORT)(2+2+2+MACSIZE), tt->file);
   WriteShort((USHORT)0, tt->file);
   (void)WriteBytes(ascii2gi, MACSIZE, tt->file);

   /* Long word align the subtable. */
   end = FileTell(tt->file);
   if ((end-offset)%4)
      for (i=0; (short)i<(4-((end-offset)%4)); i++)
	 WriteByte(0, tt->file);


   /* MS delta encoding. */
   end = FileTell(tt->file);
   (void)FileSeek(tt->file, offset+16);
   WriteLong((ULONG)(end-offset), tt->file);
   (void)FileSeek(tt->file, end);

   /* format */
   WriteShort(SEGMENT_MAP, tt->file);
   /* length */
   WriteShort((USHORT)(16+ms.segCount*(2+2+2+2)+ms.giCount*2), tt->file);
   /* version */
   WriteShort(VERSION0, tt->file);
   /* 2*segCount */
   WriteShort((USHORT)(ms.segCount*2), tt->file);
   /* searchRange */
   WriteShort(SearchRange(ms.segCount), tt->file);
   /* entrySelector */
   WriteShort(EntrySelector(ms.segCount), tt->file);
   /* rangeShift */
   WriteShort(RangeShift(ms.segCount), tt->file);

   /* endCount */

   for (i=0; i<ms.segCount; i++)
      WriteShort((USHORT)(ms.endCount[i] | usBias), tt->file);

   WriteShort(PAD0, tt->file);

   /* startCount */
   for (i=0; i<ms.segCount; i++)
      WriteShort((USHORT)(ms.startCount[i] | usBias), tt->file);

   /* idDelta */
   for (i=0; i<ms.segCount; i++)
      WriteShort(PAD0, tt->file);

   /* rangeOffsets */
   for (i=0; i<ms.segCount; i++)
      WriteShort(ms.idOffsets[i], tt->file);

   for (i=0; i<ms.giMax; i++)
      if (ms.gi[i]!=NOTDEFGLYPH)
	 WriteShort(ms.gi[i], tt->file);


   /* Free resources. */
   FreeMSEncoding(&ms);

   return CompleteTable(offset, TBL_CMAP, tt->file);
}




/***** FUNCTIONS */


/***
** Function: TypographicalAscender
**
** Description:
**   Compute the typographical ascender height, as ymax of
**   the letter 'b'.
***/
funit TypographicalAscender(const struct TTHandle *tt)
{
   USHORT i;
   funit height = 0;

   for (i=0; (i<tt->count) && height==0; i++) {
      if (tt->pool[i].code &&
	  !strcmp(LookupCharName(tt->pool[i].code), "b"))
	 height = tt->pool[i].bbox[1].y;
   }

   return height;
}



/***
** Function: TypographicalDescender
**
** Description:
**   Compute the typographical descender height, as ymin of
**   the letter 'g'.
***/
funit TypographicalDescender(const struct TTHandle *tt)
{
   USHORT i;
   funit height = 0;

   for (i=0; i<tt->count && height==0; i++) {
      if (tt->pool[i].code &&
	  !strcmp(LookupCharName(tt->pool[i].code), "g"))
	 height = tt->pool[i].bbox[0].y;
   }

   return height;
}



/***
** Function: WindowsBBox
**
** Description:
**   Compute the bounding box of the characters that are
**   used in Windows character set.
***/


#ifdef NOT_NEEDED_ON_NT


void WindowsBBox(const struct TTHandle *tt, Point *bbox)
{
   USHORT i;
   funit height = 0;

   bbox[0].x = bbox[0].y = SHRT_MAX;
   bbox[1].x = bbox[1].y = SHRT_MIN;
   for (i=0; i<tt->count && height==0; i++) {
      if (tt->pool[i].code && LookupCharCode(tt->pool[i].code,
					     ENC_MSWINDOWS)) {
	 BoundingBox(bbox, tt->pool[i].bbox, (USHORT)2);
      }
   }
}

#endif

/***
** Function: MacBBox
**
** Description:
**   Compute the bounding box of the characters that are
**   used in Mac character set.
**
**   This is currently set to the global bounding box
**   (tt->bbox) of all characters in the font. This will
**   ensure that accents are not sqeezed on Mac platforms.
***/
void MacBBox(const struct TTHandle *tt, Point *bbox)
{
   bbox[0] = tt->bbox[0];
   bbox[1] = tt->bbox[1];
}


void GlobalBBox(const struct TTHandle *tt, Point *bbox)
{
   bbox[0] = tt->bbox[0];
   bbox[1] = tt->bbox[1];
}







/***
** Function: InitTTOutput
**
** Description:
**   This function allocates the resources needed to
**   write a TT font file.
***/
errcode InitTTOutput(const struct TTArg *arg, struct TTHandle **tt)
{
   errcode status = SUCCESS;

   /* Allocate resources. */
   if (((*tt)=Malloc(sizeof(struct TTHandle)))==NULL) {
      SetError(status = NOMEM);
   } else {

      /* Initiate. */
      memset((*tt), '\0', sizeof(**tt));

      /* Open the file. */
      if (((*tt)->file=OpenOutputFile(arg->name))==NULL) {
	 SetError(status = BADOUTPUTFILE);
      } else {

	 /* Allocate space for glyph records. */
	 if (((*tt)->pool
	      = Malloc(sizeof(struct GlyphList)*GLYPHBUF))==NULL) {
	    SetError(status = NOMEM);
	 } else {

	    /* Initiate. */
	    (*tt)->bbox[0].x = (*tt)->bbox[0].y = SHRT_MAX;
	    (*tt)->bbox[1].x = (*tt)->bbox[1].y = SHRT_MIN;
	    (*tt)->count = 0;
	    (*tt)->maxcnt = GLYPHBUF;
	    (*tt)->maxcontours = 0;
	    (*tt)->maxpts = 0;
	    (*tt)->maxcompelements = 0;
	    (*tt)->maxtwilight = 0;

	    /* Write header. */
	    WriteTableHeader((*tt)->file);

	    /* Check error condition. */
	    if (FileError((*tt)->file))
	       status = BADOUTPUTFILE;
	 }
      }
   }

   return status;
}



/***
** Function: FreeTTMetrics
**
** Description:
**   This function free's the resources used to represent
**   TT specific metrics and auxiliary font information.
***/
void FreeTTMetrics(struct TTMetrics *ttm)
{
   if (ttm->verstr)
      Free(ttm->verstr);
   ttm->verstr = NULL;
   if (ttm->cvt)
      Free(ttm->cvt);
   ttm->cvt = NULL;
   if (ttm->widths)
      Free(ttm->widths);
   ttm->widths = NULL;
   if (ttm->prep)
      Free((UBYTE *)ttm->prep);
   ttm->prep = NULL;
}



/***
** Function: CleanUpTT
**
** Description:
**   This function free's the resources used while
**   writing a TT font file.
***/
errcode CleanUpTT(struct TTHandle *tt,
		  const struct TTArg *ttarg,
		  const errcode status)
{
   errcode rc = SUCCESS;

   if (tt) {
      if (tt->file)
		  rc = CloseOutputFile(tt->file);

      /* Nuke the output file? */
      if (status!=SUCCESS || rc!=SUCCESS)
		  RemoveFile(ttarg->name);

      if (tt->pool)
		  Free(tt->pool);
      Free(tt);
   }

   return rc;
}



/***
** Function: FreeTTGlyph
**
** Description:
**   This function will free the memory used to represent a
**   a TrueType glyph.
**
***/
void FreeTTGlyph(struct TTGlyph *glyph)
{
   Outline *path = NULL;

   /* Free the memory. */
   if (glyph) {
	   while (glyph->paths) {
		   path = glyph->paths->next;
		   Free(glyph->paths->pts);
		   Free(glyph->paths->onoff);
		   Free(glyph->paths);
		   glyph->paths = path;
	   }
	   if (glyph->hints)
		   Free(glyph->hints);
	   Free(glyph);
   }
}



/***
** Function: PutTTNotDefGlyph
**
** Description:
**   This function adds a record for a the ".notdef" glyph to the
**   'glyf' table of the TT font file.
**
***/
errcode PutTTNotDefGlyph(struct TTHandle *tt, const struct TTGlyph *glyph)
{
   struct TTGlyph ttg;
   long end = FileTell(tt->file);
   errcode status = SUCCESS;
   USHORT oldcount = tt->count;
   Outline *path;
   int conts = 0;
   int size = 0;
   int cnt = 0;


   /* Determine if there is enough room. */
   for (path=glyph->paths; path; path=path->next) {
      cnt += path->count;
      conts += 1;
   }
   size = cnt * sizeof(Point) +     /* coordinates */
	  conts * sizeof(short) +   /* end points */
	  glyph->num +              /* instructions */
	  cnt * sizeof(char) * 2;   /* flag bytes */

   ttg = *glyph;
   if (size > MAXNOTDEFSIZE) {
      ttg.num = 0;
      ttg.stack = 0;
      ttg.twilights = 0;
      ttg.hints = NULL;
      if (size - glyph->num > MAXNOTDEFSIZE) {
	 ttg.paths = NULL;
      }
   }


   /* Move back to glyph #0, i.e. the missing glyph. */
   tt->count = 0;
   (void)FileSeek(tt->file,
						tt->pool[NOTDEFGLYPH].offset+12L+(long)TBLDIRSIZE*NUMTBL);
   status = PutTTGlyph(tt, &ttg, FALSE);
   tt->count = oldcount;
   (void)FileSeek(tt->file, end);

   /* Missing outline? */
   if (ttg.paths==NULL)
      tt->pool[NOTDEFGLYPH].offset = tt->pool[NULLGLYPH].offset;

   return status;
}


/***
** Function: PutTTGlyph
**
** Description:
**   This function adds a record for a simple glyph to the
**   'glyf' table of the TT font file.
**
***/
errcode PutTTGlyph(struct TTHandle *tt, const struct TTGlyph *glyph,
						 const boolean fStdEncoding)
{
   errcode status = SUCCESS;
   UBYTE flag, prev, cnt;
   USHORT i, c, n = 0;
   Outline *path;
   Point bbox[2];
   funit x, y;


   if (glyph!=NULL) {

#ifdef DOT
      /* Replace the '.' character. */
      if (LookupCharCode(glyph->code, ENC_STANDARD)==0x2e) {
         STATIC struct TTGlyph marker;
         STATIC Outline box;
         STATIC ULONG onoff[1];
         STATIC Point pts[4];
         STATIC UBYTE xleading[] = {
	    0x00,
	    0xb9, 0, 3, 0, 0,
	    0x38,    /* SHPIX[], 4, 640 */
	 };


	 marker = *glyph;
	 glyph = &marker;
	 marker.paths = &box;
	 marker.num = sizeof(xleading);
	 marker.hints = xleading;
	 box.next = NULL;
	 box.count = 4;
	 box.onoff = &onoff[0];
	 onoff[0] = 0;
	 box.pts = pts;
	 pts[0].x = 200; pts[0].y = 1400;
	 pts[1].x = 600; pts[1].y = 1400;
	 pts[2].x = 600; pts[2].y = 1800;
	 pts[3].x = 200; pts[3].y = 1800;
      }
#endif

      /* Update maxp */
      if (glyph->num>tt->maxinstructions)
	 tt->maxinstructions = glyph->num;
      if (glyph->stack>tt->maxstack)
	 tt->maxstack = glyph->stack;
      if (glyph->twilights>tt->maxtwilight)
	 tt->maxtwilight = glyph->twilights;

      if (glyph->paths==NULL) {
	 bbox[0].x = bbox[1].x = glyph->lsb;
	 bbox[0].y = bbox[1].y = 0;

	 status=RecordGlyph(tt, glyph->code, bbox,
			    glyph->aw, (USHORT)0, (USHORT)0);
      } else {

	 /* Compute header information. */
	 bbox[0].x = bbox[0].y = SHRT_MAX;
	 bbox[1].x = bbox[1].y = SHRT_MIN;
	 for (c=0, path=glyph->paths; path; path=path->next, c++) {
	    BoundingBox(bbox, path->pts, path->count);
	    n = (USHORT)(n + path->count);
	 }

	 /* Record loca and cmap info. */
	 if ((status=RecordGlyph(tt, glyph->code, bbox,
				 glyph->aw, n, c))==SUCCESS) {

	    /* Write number of contours. */
	    WriteShort(c, tt->file);

	    /* Write bounding box. */
	    if (c) {
	       WriteShort((USHORT)bbox[0].x, tt->file);
	       WriteShort((USHORT)bbox[0].y, tt->file);
	       WriteShort((USHORT)bbox[1].x, tt->file);
	       WriteShort((USHORT)bbox[1].y, tt->file);
	    } else {
	       WriteShort(PAD0, tt->file);
	       WriteShort(PAD0, tt->file);
	       WriteShort(PAD0, tt->file);
	       WriteShort(PAD0, tt->file);
	    }

	    /* Write endPts */
	    for (c=0, path=glyph->paths; path; path=path->next) {
	       c = (USHORT)(c + path->count);
	       WriteShort((short)(c-1), tt->file);
	    }

	    /* Write instruction length. */
	    WriteShort(glyph->num, tt->file);

	    /* Write instruction. */
	    (void)WriteBytes(glyph->hints, glyph->num, tt->file);


	    /* Write the flags. */
	    x=0; y=0;
	    prev = 255;
	    cnt = 0;
	    for (path=glyph->paths; path; path=path->next) {
	       for (i=0; i<path->count; i++) {
		  flag = 0;
		  if (OnCurve(path->onoff, i))
		     flag |= FLG_ONCURVE;

		  if (path->pts[i].x==x) {
		     flag |= FLG_SAMEX;
		  } else if (ABS(path->pts[i].x - x) <= 255) {
		     flag |= FLG_SHORTX;
		     if (path->pts[i].x > x)
			flag |= FLG_SAMEX;
		  }

		  if (path->pts[i].y==y) {
		     flag |= FLG_SAMEY;
		  } else if (ABS(path->pts[i].y - y) <= 255) {
		     flag |= FLG_SHORTY;
		     if (path->pts[i].y > y)
			flag |= FLG_SAMEY;
		  }

		  x = path->pts[i].x;
		  y = path->pts[i].y;
		  if (prev!=255) {
		     if (prev!=flag) {
			if (cnt) {
			   prev |= FLG_REPEAT;
			   WriteByte(prev, tt->file);
			   WriteByte(cnt, tt->file);
			} else {
			   WriteByte(prev, tt->file);
			}
			cnt = 0;
		     } else {
			cnt ++;
		     }
		  }
		  prev = flag;
	       }
	    }
	    if (cnt) {
	       prev |= FLG_REPEAT;
	       WriteByte(prev, tt->file);
	       WriteByte(cnt, tt->file);
	    } else {
	       WriteByte(prev, tt->file);
	    }


	    /* Write the x's */
	    x = 0;
	    for (path=glyph->paths; path; path=path->next) {
	       for (i=0; i<path->count; i++) {
		  if (path->pts[i].x != x) {
		     funit dx = path->pts[i].x - x;
		     if (ABS(dx)<=255) {
			WriteByte((UBYTE)ABS(dx), tt->file);
		     } else {
			WriteShort((USHORT)dx, tt->file);
		     }
		  }
		  x = path->pts[i].x;
	       }
	    }

	    /* Write the y's */
	    y = 0;
	    for (path=glyph->paths; path; path=path->next) {
	       for (i=0; i<path->count; i++) {
		  if (path->pts[i].y != y) {
		     funit dy = path->pts[i].y - y;
		     if (ABS(dy)<=255) {
			WriteByte((UBYTE)ABS(dy), tt->file);
		     } else {
			WriteShort((USHORT)dy, tt->file);
		     }
		  }
		  y = path->pts[i].y;
	       }
	    }


	    /* Word align the glyph entry. */
	    if (FileTell(tt->file) & 1)
	       WriteByte(0, tt->file);

	    /* Poll the file status. */
	    if (FileError(tt->file))
	       status = FAILURE;
	 }
      }


      /* Check for aliases. */
		if (fStdEncoding)
		{
			if (LookupCharCode(glyph->code, ENC_UNICODE)==0x20) {
				struct TTGlyph nobreak;

				nobreak = *glyph;
				nobreak.code = LookupPSName(NULL, 0, "nbspace");
				PutTTGlyph(tt, &nobreak, FALSE);
			}
			if (LookupCharCode(glyph->code, ENC_UNICODE)==0x2d) {
				struct TTGlyph sfthyphen;

				sfthyphen = *glyph;
				sfthyphen.code = LookupPSName(NULL, 0, "sfthyphen");
				PutTTGlyph(tt, &sfthyphen, FALSE);
			}
		}
   }

   return status;
}




/***
** Function: PutTTOther
**
** Description:
**   This function writes the required TT tables to the
**   TT font file, except for the 'glyf' table which is
**   only completed (check sum is computed, etc.).
**
***/
errcode PutTTOther(struct TTHandle *tt, struct TTMetrics *ttm)
{
   long offset = TBLDIRSIZE*NUMTBL+12;
   errcode status = SUCCESS;
   UBYTE ascii2gi[MACSIZE];
   errcode err = SUCCESS;
   short locafmt = 0;
   long csum = 0;


   /*==GLYF===*/
   tt->pool[tt->count].offset = FileTell(tt->file) - offset;
   err = CompleteTable(offset, TBL_GLYF, tt->file);


   /*==CMAP===*/
   if (err==SUCCESS)
      err = PutCMAP(tt, ascii2gi, ttm->Encoding, ttm->encSize);


   /*==LOCA===*/
   if (err==SUCCESS)
      err = PutLOCA(tt->file, tt->pool, tt->count, &locafmt);


   /*==HEAD===*/
   if (err==SUCCESS)
      err = PutHEAD(tt->file, tt->bbox, ttm, locafmt, &csum);


   /*==HHEA===*/
   if (err==SUCCESS)
      err = PutHHEA(tt->file, tt->pool, tt->count,
                    tt->bbox, ttm->macLinegap, ttm);


   /*==HMTX===*/
   if (err==SUCCESS)
      err = PutHMTX(tt->file, tt->pool, tt->count,
                    ttm->widths, ttm->FirstChar, ttm->LastChar,ttm->Encoding);


   /*==OS/2===*/
   if (err==SUCCESS)
      err = PutOS2(tt->file, tt->pool, tt->count, ttm);


   /*==MAXP===*/
   if (err==SUCCESS)
      err = PutMAXP(tt, ttm->maxstorage, ttm->maxprepstack, ttm->maxfpgm);


   /*==Name===*/
   if (err==SUCCESS)
      err = PutNAME(tt->file, ttm);


   /*==POST===*/
   if (err==SUCCESS)
      err = PutPOST(tt->file, tt->pool, tt->count, ttm);

   /*==PREP===*/
   if (err==SUCCESS)
      err = PutPREP(tt->file,
		    ttm->prep, ttm->prep_size);

   /*==FPGM===*/
   if (err==SUCCESS)
      err = PutFPGM(tt->file,
		    ttm->fpgm, ttm->fpgm_size);

   /*==CVT===*/
   if (err==SUCCESS)
      err = PutCVT(tt->file, ttm->cvt, ttm->cvt_cnt);


   /*==GASP==*/
   if (err==SUCCESS)
      err = PutGASP(tt->file, ttm->onepix);


   if (ttm->kerns && (err==SUCCESS))
      err = PutKERN(tt->file, ttm->kerns, ttm->kernsize, tt->pool, tt->count);


   /*=====*/
   /* Compute check sum. */
   if (err==SUCCESS) {
      WriteChecksum(csum, tt->file);
      if (FileError(tt->file))
	 err = BADOUTPUTFILE;
   }


   if (err != SUCCESS)
      SetError(status = err);

   return status;
}




/***
** Function: PutTTComposite
**
** Description:
**
***/
errcode PutTTComposite(struct TTHandle *tt, struct TTComposite *comp)
{
   errcode status;
   Point bbox[2], pts[2];
   USHORT ai=0, bi=0, oi=0;
   USHORT n,c;

   /* Convert the encoding handles to glyph indices. */
   while (ai<tt->count && comp->aenc!=tt->pool[ai].code)
      ai++;
   while (bi<tt->count && comp->benc!=tt->pool[bi].code)
      bi++;
   if (comp->oenc) {
      while (oi<tt->count && comp->oenc!=tt->pool[oi].code)
	 oi++;
   }

   /* Update the bounding box. */
   comp->dx += tt->pool[bi].bbox[0].x - tt->pool[ai].bbox[0].x;
   bbox[0] = tt->pool[bi].bbox[0]; bbox[1] = tt->pool[bi].bbox[1];
   pts[0] = tt->pool[ai].bbox[0]; pts[1] = tt->pool[ai].bbox[1];
   pts[0].x += comp->dx; pts[1].x += comp->dx;
   pts[0].y += comp->dy; pts[1].y += comp->dy;
   BoundingBox(bbox, pts, (USHORT)2);
   bbox[0].x = tt->pool[bi].bbox[0].x; bbox[1].x = tt->pool[bi].bbox[1].x;
   if (comp->oenc)
      BoundingBox(bbox, tt->pool[oi].bbox, (USHORT)2);

   if ((status=RecordGlyph(tt, comp->cenc, bbox,
			   comp->aw, (USHORT)0, (USHORT)0))==FAILURE)
      return status;

   /* Update max composite points/contours/elements. */
   n = (USHORT)(tt->pool[bi].pts + tt->pool[ai].pts);
   c = (USHORT)(tt->pool[bi].conts + tt->pool[ai].conts);
   if (n>tt->maxcomppts)
      tt->maxcomppts = n;
   if (c>tt->maxcompcont)
      tt->maxcompcont = c;
   if (comp->oenc)
      tt->maxcompelements = 3;
   else if (tt->maxcompelements<2)
      tt->maxcompelements = 2;


   /* Write number of contours. */
   WriteShort((USHORT)-1, tt->file);

   /* Write bounding box. */
   WriteShort((USHORT)bbox[0].x, tt->file);
   WriteShort((USHORT)bbox[0].y, tt->file);
   WriteShort((USHORT)bbox[1].x, tt->file);
   WriteShort((USHORT)bbox[1].y, tt->file);

   /* Write flags. */
   WriteShort((USHORT)(MORE_COMPONENTS |
		       ARGS_ARE_XY_VALUES |
		       ROUND_XY_TO_GRID),
	      tt->file);

   /* Write base glyph index. */
   WriteShort(bi, tt->file);
   WriteByte(0, tt->file);
   WriteByte(0, tt->file);

   if (comp->oenc) {
      WriteShort((USHORT)(MORE_COMPONENTS |
			  ARGS_ARE_XY_VALUES |
			  ROUND_XY_TO_GRID),
		 tt->file);
      WriteShort(oi, tt->file);
      WriteByte(0, tt->file);
      WriteByte(0, tt->file);
   }

   WriteShort((USHORT)(ARGS_1_2_ARE_WORDS |
		       ARGS_ARE_XY_VALUES |
		       ROUND_XY_TO_GRID),
	      tt->file);
   WriteShort(ai, tt->file);
   WriteShort((USHORT)comp->dx, tt->file);
   WriteShort((USHORT)comp->dy, tt->file);

   /* Word align the glyph entry. */
   if (FileTell(tt->file) & 1)
      WriteByte(0, tt->file);

   if (FileError(tt->file))
      return FAILURE;
   return SUCCESS;
}




/***
** Function: GetPrep
**
** Description:
**   This function allocates needed space for the
**   pre-program.
**
***/
UBYTE *GetPrep(const int size)
{
   return Malloc((size_t)size);
}


/***
** Function: UsePrep
**
** Description:
**   This function records the pre-program in the
**   TTMetrics record, until an appropriate time
**   when the data can be stored in the TT file.
**
***/
void UsePrep(struct TTMetrics *ttm,
	     const UBYTE *prep,
	     const USHORT prep_size)
{
   ttm->prep = (UBYTE *)prep;
   ttm->prep_size = prep_size;
}

/***
** Function: SetFPGM
**
** Description:
**   This function records the font-program in the
**   TTMetrics record, until an appropriate time
**   when the data can be stored in the TT file.
**
***/
void SetFPGM(struct TTMetrics *ttm,
	     const UBYTE *fpgm,
	     const USHORT fpgm_size,
	     const USHORT num)
{
   ttm->fpgm = fpgm;
   ttm->fpgm_size = fpgm_size;
   ttm->maxfpgm = num;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\uimsg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// uimsg.cpp
//      Explorer Font Folder extension routines.
//    Message box and status box routines.
//    These routines are all vUIPStatusXXX and iUIMsgXXX
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//     $keywords: uimsg.cpp 1.3 22-Mar-94 1:26:04 PM$
//
//***************************************************************************
// $lgb$
// 1.0     7-Mar-94 eric Initial revision.
// 1.1     9-Mar-94 eric Added Mutex locks for GDI.
// 1.2    17-Mar-94 eric removed references to mutex.
// 1.3    22-Mar-94 eric Removed MFC toolbar code (it was already ifdef'd
//                       out)
// $lge$
//*************************************************************************** 
//
//  Copyright (C) 1992-1993 ElseWare Corporation.  All rights reserved.
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>

#include "resource.h"
#include "ui.h"
#include "dbutl.h"


//
//  Types
//

typedef TCHAR STATTEXT[ 128 ];
typedef TCHAR MSGTEXT [ 256 ];

//
//  Globals - these are shared throughout the system for
//            debugging purposes only.
//

BOOL  g_bTrace = FALSE;
BOOL  g_bDiag  = FALSE;

static BOOL  s_bIsStatClear = FALSE;
static BOOL  s_bStatPushed  = FALSE;

// static STATTEXT s_szStatTxtStack;

#define STRING_BUF   256
// static TCHAR  s_szStatTxtStack[ STRING_BUF ];
static TCHAR  s_szMemDiag[ STRING_BUF ];     // Text for memory limit
static TCHAR  s_szMemCaption[ STRING_BUF ];  // Caption for memory limit message

//
//  Although these are used but once, we load now since they're for
//  out-of-memory diagnostics, and we probably won't be able to load
//  them when needed.
//

VOID FAR PASCAL vUIMsgInit( )
{
    // s_szMemDiag.LoadString ( IDS_MSG_NSFMEM );
    // s_szMemCaption.LoadString ( IDS_MSG_CAPTION );

    LoadString( g_hInst, IDS_MSG_NSFMEM, s_szMemDiag, ARRAYSIZE( s_szMemDiag ) );

    LoadString( g_hInst, IDS_MSG_CAPTION, s_szMemCaption, ARRAYSIZE( s_szMemDiag ) );
}

/***************************************************************************
 * FUNCTION: iUIMsgBox
 *
 * PURPOSE:  Format a string and show a message box per the caller's
 *              MB_ settings.  There are several cover routines that
 *              set this up so it may be called more simply (see the header)
 *
 * RETURNS:  The function returns the result of the message box, or zero on
 *              failure (the message box function also returns zero on failure)
 ***************************************************************************/

int FAR PASCAL iUIErrMemDlg(HWND hwndParent)
{
    MessageBox( hwndParent, s_szMemDiag, s_szMemCaption,
                MB_OK | MB_ICONHAND | MB_SYSTEMMODAL | MB_SETFOREGROUND );

    return -1;
}


int FAR PASCAL iUIMsgBox( HWND hwndParent, WORD wIDStr, WORD wCAPStr, UINT uiMBFlags,
                          LPCTSTR wArg1, LPCTSTR wArg2, LPCTSTR wArg3, LPCTSTR wArg4 )
{
    // CString    cCaption;
    // CString    cMessage;

    TCHAR   cCaption[ STRING_BUF ];
    TCHAR   cMessage[ STRING_BUF ];
    MSGTEXT szMessage;
    int     iResult = 0;

    //
    //  Load the string and the message caption.    Then format the string,
    //  being careful about length, and show the (modal) message box.
    //

    if( wIDStr == IDS_MSG_NSFMEM )
        return iUIErrMemDlg(hwndParent);

    if( LoadString( g_hInst, wIDStr, cMessage, ARRAYSIZE( cMessage ) ) )
    {
        if( !LoadString( g_hInst, wCAPStr, cCaption, ARRAYSIZE( cCaption ) ) )
            cCaption[ 0 ] = 0;

        //
        //  If we have more than one string we have to format it for
        //

        LPCTSTR  args[ 4 ] = { wArg1, wArg2, wArg3, wArg4 };

        iResult = (int)FormatMessage( FORMAT_MESSAGE_FROM_STRING
                                      | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      cMessage,
                                      0,
                                      0,
                                      szMessage,
                                      ARRAYSIZE( szMessage ),
                                      (va_list *) args
                                      );
        if(  iResult )
        {
            iResult = MessageBox( hwndParent, szMessage, cCaption,
                                  MB_TASKMODAL | MB_SETFOREGROUND | uiMBFlags );

            if( iResult == -1 )
                return iUIErrMemDlg(hwndParent);
        }
    }

    return iResult;
}


int FAR PASCAL iUIMsgBoxWithCaption(HWND hwndParent, WORD wIDStr, WORD wCaption )
{ return iUIMsgBox(hwndParent, wIDStr, wCaption, MB_OKCANCEL | MB_ICONEXCLAMATION ); };


int FAR PASCAL iUIMsgOkCancelExclaim(HWND hwndParent, WORD wIDStr, WORD wIdCap, LPCTSTR wArg )
{ return iUIMsgBox(hwndParent, wIDStr, wIdCap, MB_OKCANCEL | MB_ICONEXCLAMATION, wArg );};


int FAR PASCAL iUIMsgRetryCancelExclaim(HWND hwndParent, WORD wIDStr, LPCTSTR wArg )
{ return iUIMsgBox(hwndParent, wIDStr, IDS_MSG_CAPTION, MB_RETRYCANCEL | MB_ICONEXCLAMATION, wArg );};


int FAR PASCAL iUIMsgYesNoExclaim(HWND hwndParent, WORD wIDStr, WORD wIdCap, LPCTSTR wArg )
{ return iUIMsgBox(hwndParent, wIDStr, wIdCap, MB_YESNO | MB_ICONEXCLAMATION, wArg );};


int FAR PASCAL iUIMsgYesNoExclaim(HWND hwndParent, WORD wIDStr, LPCTSTR wArg )
{ return iUIMsgBox(hwndParent, wIDStr, IDS_MSG_CAPTION, MB_YESNO | MB_ICONEXCLAMATION, wArg );};


int FAR PASCAL iUIMsgExclaim(HWND hwndParent, WORD wIDStr, LPCTSTR wArg )
{ return iUIMsgBox(hwndParent, wIDStr, IDS_MSG_CAPTION, MB_OK | MB_ICONEXCLAMATION, wArg );};


int FAR PASCAL iUIMsgBox(HWND hwndParent, WORD wIDStr, LPCTSTR wArg )
{ return iUIMsgBox(hwndParent, wIDStr, IDS_MSG_CAPTION, MB_OK | MB_ICONHAND, wArg ); };


int FAR PASCAL iUIMsgInfo(HWND hwndParent, WORD wIDStr, LPCTSTR wArg )
{ return iUIMsgBox(hwndParent, wIDStr, IDS_MSG_CAPTION, MB_OK | MB_ICONINFORMATION, wArg ); };




///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: vUIMsgBoxInvalidFont
//
// DESCRIP:  Displays a simple message box for errors encountered through
//           the following font folder functions:
//
//              IsPSFont
//              bCPValidType1Font
//              bIsValidFontFile
//              bIsTrueType
//
//           Font validation occurs in many places in the font folder.
//           This function was added to consolidate validation error reporting
//           and to ensure consistency when reporting these types of errors.
//
// ARGUMENTS:
//           pszFontFile
//              Name of font file being validated.
//
//           pszFontDesc
//              Descriptive name of font being validated.
//
//           dwType1Code
//              Code returned from one of the validation functions.
//              See IsPSFont for details.
//
//           uStyle
//              Message box style.  Defaults to MB_OKCANCEL | MB_ICONEXCLAMATION
//
///////////////////////////////////////////////////////////////////////////////
//
// Map font validation status codes to message box string resources.
//
static const struct str_id_map{
    BYTE code;          // Status portion of status code.
    DWORD idStr;        // Message format string resource id.
}StrIdMap[] = {
    { FVS_INVALID_FONTFILE,   IDS_FMT_FVS_INVFONTFILE },
    { FVS_BAD_VERSION,        IDS_FMT_FVS_BADVERSION  },
    { FVS_FILE_BUILD_ERR,     IDS_FMT_FVS_FILECREATE  },
    { FVS_FILE_EXISTS,        IDS_FMT_FVS_FILEEXISTS  },
    { FVS_FILE_OPEN_ERR,      IDS_FMT_FVS_FILEOPEN    },
    { FVS_FILE_CREATE_ERR,    IDS_FMT_FVS_FILECREATE  },
    { FVS_FILE_IO_ERR,        IDS_FMT_FVS_FILEIO      },
    { FVS_INVALID_ARG,        IDS_FMT_FVS_INTERNAL    },
    { FVS_EXCEPTION,          IDS_FMT_FVS_INTERNAL    },
    { FVS_INSUFFICIENT_BUF,   IDS_FMT_FVS_INTERNAL    },
    { FVS_MEM_ALLOC_ERR,      IDS_FMT_FVS_INTERNAL    },
    { FVS_INVALID_STATUS,     IDS_FMT_FVS_INTERNAL    }};

//
// Map font validation status codes to file name extension strings.
//
static const struct file_ext_map{
   BYTE file;        // File portion of status code.
   LPTSTR pext;      // File name extension string.
}FileExtMap[] = {
   { FVS_FILE_INF, TEXT(".INF") },
   { FVS_FILE_AFM, TEXT(".AFM") },
   { FVS_FILE_PFB, TEXT(".PFB") },
   { FVS_FILE_PFM, TEXT(".PFM") },
   { FVS_FILE_TTF, TEXT(".TTF") },
   { FVS_FILE_FOT, TEXT(".FOT") }};


int iUIMsgBoxInvalidFont(HWND hwndParent, LPCTSTR pszFontFile, LPCTSTR pszFontDesc, 
                         DWORD dwStatus, UINT uStyle)
{
    TCHAR szCannotInstall[STRING_BUF];               // Message prefix.
    TCHAR szFileName[MAX_PATH + 1];                  // Local file name copy.
    TCHAR szNulString[]  = TEXT("");                 // Output when no arg used.
    LPTSTR pszArgs[2]    = { NULL, NULL };           // Message inserts.
    LPTSTR pszFileExt    = NULL;                     // Ptr to ext part of file name.
    DWORD dwMsgId        = IDS_FMT_FVS_INTERNAL;     // Message string resource id.
    UINT cchLoaded       = 0;                        // LoadString status.
    int i                = 0;                        // General loop counter.
    const DWORD dwStatusCode = FVS_STATUS(dwStatus); // Status part of code.
    const DWORD dwStatusFile = FVS_FILE(dwStatus);   // File part of code.

    ASSERT(NULL != pszFontFile);

    //
    // Check to see if status value was properly set.
    // This check relies on status codes being initialized
    // to FVS_INVALID_STATUS.
    //
    ASSERT(dwStatusCode != FVS_INVALID_STATUS);

    //
    // We don't display a message if the status is SUCCESS.
    //
    if (dwStatusCode == FVS_SUCCESS)
    {
       ASSERT(FALSE);  // Complain to developer.
       return 0;
    }

    //
    // Format the common prefix for all messages.
    //
    if ((pszFontDesc != NULL) && (pszFontDesc[0] != TEXT('\0')))
    {
        TCHAR szFmtPrefix[STRING_BUF];

        //
        // Description string is provided and is not blank.
        // Prefix is "Unable to install the "<font desc>" font."
        //
        if ((cchLoaded = LoadString(g_hInst,
                       IDS_FMT_FVS_PREFIX,
                       szFmtPrefix,
                       ARRAYSIZE(szFmtPrefix))) > 0)
        {
            //
            // WARNING: This argument array assumes that there is only ONE
            //          replaceable argument in the string IDS_FMT_FVS_PREFIX.
            //          If this resource is modified to include more embedded
            //          values, this arg array must be extended as well.
            //
            LPCTSTR FmtMsgArgs[] = { pszFontDesc };

            cchLoaded = FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      szFmtPrefix,
                                      0,
                                      0,
                                      szCannotInstall,    
                                      ARRAYSIZE(szCannotInstall),
                                      (va_list *)FmtMsgArgs);
        }
    }
    else
    {
        //
        // Description string is not provided or is blank.
        // Prefix is "Unable to install the font."
        //
        cchLoaded = LoadString(g_hInst,
                       IDSI_CAP_NOINSTALL,
                       szCannotInstall,
                       ARRAYSIZE(szCannotInstall));
    }

    //
    // Verify prefix string is loaded and formatted.
    //
    if (0 == cchLoaded)
    {
        //
        // Resource not found/loaded.
        //
        szCannotInstall[0] = TEXT('\0');  // Make sure we're terminated.
        ASSERT(FALSE);                    // Complain during development.
    }


    StringCchCopy(szFileName, ARRAYSIZE(szFileName), pszFontFile);    // Don't want to alter source string.

    int nMapSize = ARRAYSIZE(StrIdMap);
    for (i = 0; i < nMapSize; i++)
    {
        if (StrIdMap[i].code == dwStatusCode)
        {
            dwMsgId = StrIdMap[i].idStr;
            break;
        }
    }

    pszFileExt = NULL;
    if (FVS_FILE_UNK != dwStatusFile)
    {
        nMapSize = ARRAYSIZE(FileExtMap);
        for (i = 0; i < nMapSize; i++)
        {
            if (FileExtMap[i].file == dwStatusFile)
            {
                pszFileExt = FileExtMap[i].pext;
                break;
            }
        }
    }
         
    //
    // Replace the file extension if a file type was specified in status code.
    //
    if (NULL != pszFileExt)
    {
        LPTSTR pchPeriod = StrRChr(szFileName, NULL, TEXT('.'));
        if (NULL != pchPeriod)
           StringCchCopy(pchPeriod, ARRAYSIZE(szFileName) - (pchPeriod - szFileName), pszFileExt);
    }

    //
    // Set up the required arguments for the message format strings.
    //
    pszArgs[0] = szCannotInstall;  // All msgs use this prefix.

    switch(dwMsgId)
    {
        //
        // These don't include an embedded file name.
        //
        case IDS_FMT_FVS_FILEIO:
        case IDS_FMT_FVS_INTERNAL:
           pszArgs[1] = NULL;
           break;

        //
        // By default, each message includes a file name.
        //
        default:
           pszArgs[1] = szFileName;
           break;
    }
              

    //
    // Modify very long path names so that they fit into the message box.
    // They are formatted as "c:\dir1\dir2\dir3\...\dir8\filename.ext"
    // DrawTextEx isn't drawing on anything.  Only it's formatting capabilities are
    // being used. The DT_CALCRECT flag prevents drawing.
    //
    HWND hWnd       = GetDesktopWindow();
    HDC  hDC        = GetDC(hWnd);
    LONG iBaseUnits = GetDialogBaseUnits();
    RECT rc;
    const int MAX_PATH_DISPLAY_WD = 60; // Max characters to display in path name.
    const int MAX_PATH_DISPLAY_HT =  1; // Path name is 1 character high.

    rc.left   = 0;
    rc.top    = 0;
    rc.right  = MAX_PATH_DISPLAY_WD * LOWORD(iBaseUnits);
    rc.bottom = MAX_PATH_DISPLAY_HT * HIWORD(iBaseUnits);

    DrawTextEx(hDC, szFileName, ARRAYSIZE(szFileName), &rc,
                                DT_CALCRECT | DT_PATH_ELLIPSIS | DT_MODIFYSTRING, NULL);
    ReleaseDC(hWnd, hDC);

    //
    // Display message using standard Type 1 installer msg box.
    // Note that iUIMsgBox wants 16-bit resource ID's.
    //
    return iUIMsgBox(hwndParent, (WORD)dwMsgId, IDS_MSG_CAPTION, uStyle,
                     (pszArgs[0] ? pszArgs[0] : szNulString),
                     (pszArgs[1] ? pszArgs[1] : szNulString));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\atmpfm.c ===
/*--------------------------------------------------------------------------*/
/* WINATM version only                                                      */
/*--------------------------------------------------------------------------*/
//
//      Copyright 1990, 1991 -- Adobe Systems, Inc.
//      PostScript is a trademark of Adobe Systems, Inc.
//
// NOTICE:  All information contained herein or attendant hereto is, and
// remains, the property of Adobe Systems, Inc.  Many of the intellectual
// and technical concepts contained herein are proprietary to Adobe Systems,
// Inc. and may be covered by U.S. and Foreign Patents or Patents Pending or
// are protected as trade secrets.  Any dissemination of this information or
// reproduction of this material are strictly forbidden unless prior written
// permission is obtained from Adobe Systems, Inc.
//
/*--------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <fcntl.h>
#include <ctype.h>
#include <io.h>

#include "windows.h"
#pragma pack(1)
#include "makepfm.h"
#pragma pack(4)

#include "fvscodes.h"  // FVS_xxxxxx (font validation status) codes and macros.

#ifdef WIN30
  #define LPCSTR LPSTR
#endif

typedef LPSZ GlyphName;
extern  AFM  afm;

// bodind added these

#define str_DotINF ".INF"
#define str_DotPFM ".PFM"

/*--------------------------------------------------------------------------*/
static CHAR msgbuff[128];
static HANDLE hMemArray[258];  // #_of_glyphnames + 1_glypharray + 1_kernpairs
static INT indexMemArray = 0;
static GlyphName winEnc[] =
/*  8-27-91 yh  Added some characters for Windows 3.1 */
{   /*   0 */    "",
    /*   1 */    "",
    /*   2 */    "",
    /*   3 */    "",
    /*   4 */    "",
    /*   5 */    "",
    /*   6 */    "",
    /*   7 */    "",
    /*   8 */    "",
    /*   9 */    "",
    /*  10 */    "",
    /*  11 */    "",
    /*  12 */    "",
    /*  13 */    "",
    /*  14 */    "",
    /*  15 */    "",
    /*  16 */    "",
    /*  17 */    "",
    /*  18 */    "",
    /*  19 */    "",
    /*  20 */    "",
    /*  21 */    "",
    /*  22 */    "",
    /*  23 */    "",
    /*  24 */    "",
    /*  25 */    "",
    /*  26 */    "",
    /*  27 */    "",
    /*  28 */    "",
    /*  29 */    "",
    /*  30 */    "",
    /*  31 */    "",
    /*  32 */    "space",
    /*  33 */    "exclam",
    /*  34 */    "quotedbl",
    /*  35 */    "numbersign",
    /*  36 */    "dollar",
    /*  37 */    "percent",
    /*  38 */    "ampersand",
    /*  39 */    "quotesingle",
    /*  40 */    "parenleft",
    /*  41 */    "parenright",
    /*  42 */    "asterisk",
    /*  43 */    "plus",
    /*  44 */    "comma",
    /*  45 */    "hyphen",
    /*  46 */    "period",
    /*  47 */    "slash",
    /*  48 */    "zero",
    /*  49 */    "one",
    /*  50 */    "two",
    /*  51 */    "three",
    /*  52 */    "four",
    /*  53 */    "five",
    /*  54 */    "six",
    /*  55 */    "seven",
    /*  56 */    "eight",
    /*  57 */    "nine",
    /*  58 */    "colon",
    /*  59 */    "semicolon",
    /*  60 */    "less",
    /*  61 */    "equal",
    /*  62 */    "greater",
    /*  63 */    "question",
    /*  64 */    "at",
    /*  65 */    "A",
    /*  66 */    "B",
    /*  67 */    "C",
    /*  68 */    "D",
    /*  69 */    "E",
    /*  70 */    "F",
    /*  71 */    "G",
    /*  72 */    "H",
    /*  73 */    "I",
    /*  74 */    "J",
    /*  75 */    "K",
    /*  76 */    "L",
    /*  77 */    "M",
    /*  78 */    "N",
    /*  79 */    "O",
    /*  80 */    "P",
    /*  81 */    "Q",
    /*  82 */    "R",
    /*  83 */    "S",
    /*  84 */    "T",
    /*  85 */    "U",
    /*  86 */    "V",
    /*  87 */    "W",
    /*  88 */    "X",
    /*  89 */    "Y",
    /*  90 */    "Z",
    /*  91 */    "bracketleft",
    /*  92 */    "backslash",
    /*  93 */    "bracketright",
    /*  94 */    "asciicircum",
    /*  95 */    "underscore",
    /*  96 */    "grave",
    /*  97 */    "a",
    /*  98 */    "b",
    /*  99 */    "c",
    /* 100 */    "d",
    /* 101 */    "e",
    /* 102 */    "f",
    /* 103 */    "g",
    /* 104 */    "h",
    /* 105 */    "i",
    /* 106 */    "j",
    /* 107 */    "k",
    /* 108 */    "l",
    /* 109 */    "m",
    /* 110 */    "n",
    /* 111 */    "o",
    /* 112 */    "p",
    /* 113 */    "q",
    /* 114 */    "r",
    /* 115 */    "s",
    /* 116 */    "t",
    /* 117 */    "u",
    /* 118 */    "v",
    /* 119 */    "w",
    /* 120 */    "x",
    /* 121 */    "y",
    /* 122 */    "z",
    /* 123 */    "braceleft",
    /* 124 */    "bar",
    /* 125 */    "braceright",
    /* 126 */    "asciitilde",
    /* 127 */    "",
    /* 128 */    "",
    /* 129 */    "",
    /* 130 */    "quotesinglbase",
    /* 131 */    "florin",
    /* 132 */    "quotedblbase",
    /* 133 */    "ellipsis",
    /* 134 */    "dagger",
    /* 135 */    "daggerdbl",
    /* 136 */    "circumflex",
    /* 137 */    "perthousand",
    /* 138 */    "Scaron",
    /* 139 */    "guilsinglleft",
    /* 140 */    "OE",
    /* 141 */    "",
    /* 142 */    "",
    /* 143 */    "",
    /* 144 */    "",
    /* 145 */    "quoteleft",
    /* 146 */    "quoteright",
    /* 147 */    "quotedblleft",
    /* 148 */    "quotedblright",
    /* 149 */    "bullet",
    /* 150 */    "endash",
    /* 151 */    "emdash",
    /* 152 */    "tilde",
    /* 153 */    "trademark",
    /* 154 */    "scaron",
    /* 155 */    "guilsinglright",
    /* 156 */    "oe",
    /* 157 */    "",
    /* 158 */    "",
    /* 159 */    "Ydieresis",
    /* 160 */    "space",
    /* 161 */    "exclamdown",
    /* 162 */    "cent",
    /* 163 */    "sterling",
    /* 164 */    "currency",
    /* 165 */    "yen",
    /* 166 */    "brokenbar",
    /* 167 */    "section",
    /* 168 */    "dieresis",
    /* 169 */    "copyright",
    /* 170 */    "ordfeminine",
    /* 171 */    "guillemotleft",
    /* 172 */    "logicalnot",
    /* 173 */    "minus",
    /* 174 */    "registered",
    /* 175 */    "macron",
    /* 176 */    "degree",
    /* 177 */    "plusminus",
    /* 178 */    "twosuperior",
    /* 179 */    "threesuperior",
    /* 180 */    "acute",
    /* 181 */    "mu",
    /* 182 */    "paragraph",
    /* 183 */    "periodcentered",
    /* 184 */    "cedilla",
    /* 185 */    "onesuperior",
    /* 186 */    "ordmasculine",
    /* 187 */    "guillemotright",
    /* 188 */    "onequarter",
    /* 189 */    "onehalf",
    /* 190 */    "threequarters",
    /* 191 */    "questiondown",
    /* 192 */    "Agrave",
    /* 193 */    "Aacute",
    /* 194 */    "Acircumflex",
    /* 195 */    "Atilde",
    /* 196 */    "Adieresis",
    /* 197 */    "Aring",
    /* 198 */    "AE",
    /* 199 */    "Ccedilla",
    /* 200 */    "Egrave",
    /* 201 */    "Eacute",
    /* 202 */    "Ecircumflex",
    /* 203 */    "Edieresis",
    /* 204 */    "Igrave",
    /* 205 */    "Iacute",
    /* 206 */    "Icircumflex",
    /* 207 */    "Idieresis",
    /* 208 */    "Eth",
    /* 209 */    "Ntilde",
    /* 210 */    "Ograve",
    /* 211 */    "Oacute",
    /* 212 */    "Ocircumflex",
    /* 213 */    "Otilde",
    /* 214 */    "Odieresis",
    /* 215 */    "multiply",
    /* 216 */    "Oslash",
    /* 217 */    "Ugrave",
    /* 218 */    "Uacute",
    /* 219 */    "Ucircumflex",
    /* 220 */    "Udieresis",
    /* 221 */    "Yacute",
    /* 222 */    "Thorn",
    /* 223 */    "germandbls",
    /* 224 */    "agrave",
    /* 225 */    "aacute",
    /* 226 */    "acircumflex",
    /* 227 */    "atilde",
    /* 228 */    "adieresis",
    /* 229 */    "aring",
    /* 230 */    "ae",
    /* 231 */    "ccedilla",
    /* 232 */    "egrave",
    /* 233 */    "eacute",
    /* 234 */    "ecircumflex",
    /* 235 */    "edieresis",
    /* 236 */    "igrave",
    /* 237 */    "iacute",
    /* 238 */    "icircumflex",
    /* 239 */    "idieresis",
    /* 240 */    "eth",
    /* 241 */    "ntilde",
    /* 242 */    "ograve",
    /* 243 */    "oacute",
    /* 244 */    "ocircumflex",
    /* 245 */    "otilde",
    /* 246 */    "odieresis",
    /* 247 */    "divide",
    /* 248 */    "oslash",
    /* 249 */    "ugrave",
    /* 250 */    "uacute",
    /* 251 */    "ucircumflex",
    /* 252 */    "udieresis",
    /* 253 */    "yacute",
    /* 254 */    "thorn",
    /* 255 */    "ydieresis",
                 NULL,
};

extern CHAR encfile[MAX_PATH];
extern CHAR outfile[MAX_PATH];
extern CHAR infofile[MAX_PATH];
extern INT charset;
extern INT devType;
extern BOOL forceVariablePitch;

/*--------------------------------------------------------------------------*/
BOOL GetINFFontDescription(LPSZ, LPSZ, LPSZ);
BOOL MakePfm(LPSZ, LPSZ, LPSZ);

VOID GetFilename(LPSZ, LPSZ);
INT OpenParseFile(LPSZ);
INT OpenTargetFile(LPSZ);
VOID WriteDots(VOID);
LPVOID AllocateMem(UINT);
VOID FreeAllMem(VOID);
GlyphName *SetupGlyphArray(LPSZ);

extern short _MakePfm(VOID);          /* afm.c */
extern VOID StartParse(VOID);         /* token.c */
extern BOOL GetLine(INT);
extern VOID GetWord(CHAR *, INT);
extern BOOL GetString(CHAR *, INT);
extern INT  GetToken(INT, KEY *);

/*--------------------------------------------------------------------------*/

#ifdef ADOBE_CODE_WE_DO_NOT_USE

// REVIEW: mjan - There should be a size argument for the out arguments 
//				lpszDescription and lpszPSFontName. However, the api is
//				may not be used or we may not be able to change the API.
BOOL GetINFFontDescription(
  LPSZ    lpszInf,			// in
  LPSZ    lpszDescription,	// out - Needs to be sizeof(szName)+sizeof(szBold)+sizeof(szItalic)+3 long = 171.
  LPSZ    lpszPSFontName	// out - Needs to be MAX_PATH long = 260
)
{
  INT         hfile, iToken;
  CHAR        szName[128];
  CHAR        szAngle[10];
  CHAR        szStyle[2];
  CHAR        szMods[30];
  BOOL        bAddItalic = FALSE;
  CHAR        szBold[20];
  CHAR        szItalic[20];

  static KEY infKeys[] = {
      "FontName",   TK_PSNAME,
      "MSMenuName", TK_MSMENUNAME,
      "VPStyle",    TK_VPSTYLE,
      "ItalicAngle",TK_ANGLE,
      NULL, 0
      };

  hfile = OpenParseFile( lpszInf );
  if( hfile == -1 ) return(FALSE);

  szName[0] = szStyle[0] = szMods[0] = lpszPSFontName[0] = 0;

  // bodind replaced AtmGetString by strcpy

  strcpy(szBold, "Bold");
  strcpy(szItalic, "Italic");
  //AtmGetString( RCN(STR_BOLD), szBold, sizeof(szBold) );
  //AtmGetString( RCN(STR_ITALIC), szItalic, sizeof(szItalic) );

  while( GetLine(hfile) ) {
      iToken = GetToken(hfile,infKeys);
      switch(iToken) {
          case TK_MSMENUNAME:
              GetString(szName, sizeof(szName));
              break;
          case TK_PSNAME:
              GetString(lpszPSFontName, MAX_PATH);
              break;
          case TK_ANGLE:
              GetWord(szAngle, sizeof(szAngle));
              if ( strcmp (szAngle, "0") )
                 bAddItalic = TRUE;
              break;
          case TK_VPSTYLE:
              GetString(szStyle, sizeof(szStyle));
              switch( toupper(szStyle[0]) ) {
                  case 'N': break;
                  case 'B': strcpy(szMods, szBold);    break;
                  case 'T': strcpy(szMods, szBold);
                  case 'I':
                     strcat(szMods, szItalic);
                     bAddItalic = FALSE;
                     break;
                  /* default:  break; */
                  }
              break;
          }
      }
  _lclose(hfile);

  if( !szName[0] ) return(FALSE);

  strcpy( lpszDescription, szName );
  if( szMods[0] ) {
      strcat( lpszDescription, "," );
      strcat( lpszDescription, szMods );
      if (bAddItalic)
         strcat(lpszDescription, szItalic);
      }         
  else
     {
      if (bAddItalic)
        {
        strcat (lpszDescription, "," );
        strcat (lpszDescription, szItalic);
        }
     }
  return(TRUE);
} // end of GetINFFontDescription


/*--------------------------------------------------------------------------*/
INT MakePfm(afmpath, infdir, pfmdir) /* MEF */
LPSZ afmpath, infdir, pfmdir;
{
  #define FATALERROR  2
  #define NOERROR     0

  CHAR bname[9];

  indexMemArray = 0;              /* init global */

  afm.szFile[0] = '\0';
  if (afmpath)
	strncpy(afm.szFile, afmpath, sizeof(afm.szFile)-1);
  afm.szFile[sizeof(afm.szFile)-1] = '\0';
  GetFilename(afmpath, bname);
  if( infdir[strlen(infdir)-1] == '\\' )
      sprintf(infofile, "%s%s%s", infdir, bname, str_DotINF);
  else
      sprintf(infofile, "%s\\%s%s", infdir, bname, str_DotINF);
  if( pfmdir[strlen(pfmdir)-1] == '\\' )
      sprintf(outfile,  "%s%s%s", pfmdir, bname, str_DotPFM);
  else
      sprintf(outfile,  "%s\\%s%s", pfmdir, bname, str_DotPFM);

  afm.iPtSize = 12;
  encfile[0] = EOS;
  devType = POSTSCRIPT;
  if( !strcmp(_strupr(bname), "SY______") ) charset = SYMBOL_CHARSET;
  else charset = -1;
/*
 * yh 8/16/91 -- Keep forceVariablePitch to TRUE for now to be compatible
 * with bitmaps generated by Font Foundry.  ATM and device driver will
 * report different value for PitchAndFamily for monospaced fonts.
 *
 * forceVariablePitch = FALSE;
 */

  if( !_MakePfm() ) {
      return FATALERROR;
      }
  return(NOERROR);
}

#endif // ADOBE_CODE_WE_DO_NOT_USE

/*--------------------------------------------------------------------------*/
VOID GetFilename(path, name)
LPSZ path, name;
{
	LPSZ p;
	INT i = 0;

	if (path && name)
	{
		if( (p = strrchr(path,'\\')) == NULL )
			p = strrchr(path,':');

		if (p) 
			p++;
		else
			p = path;

		for(i=0; i<8; i++) 
		{
			if( p[i]=='.' || p[i]==EOS ) 
				break;
			name[i] = p[i];
		}
	}
	if (name)
		name[i] = EOS;
}

/*----------------------------------------------------------------------------*/
INT OpenParseFile(lpszPath)
LPSZ lpszPath;
{
  OFSTRUCT    of;

  StartParse();
  return( OpenFile(lpszPath, &of, OF_READ) );
}

/*----------------------------------------------------------------------------*/
INT OpenTargetFile(lpszPath)
LPSZ lpszPath;
{
  OFSTRUCT    of;

  return( OpenFile(lpszPath, &of, OF_CREATE | OF_WRITE) );
}

LPVOID AllocateMem(size)
UINT size;
{
  HANDLE hmem;

  if( !(hmem=GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, size)) ) return(NULL);
  // May cause a leak, which is better than a crash at least.
  if (indexMemArray < sizeof(hMemArray)/sizeof(hMemArray[0])) 
	hMemArray[indexMemArray++] = hmem;
  return( GlobalLock(hmem) );
}

/*--------------------------------------------------------------------------*/
VOID FreeAllMem()
{
  INT i;

  for(i=0; i<indexMemArray; i++) {
      GlobalUnlock( hMemArray[i] );
      GlobalFree( hMemArray[i] );
      }
}

/*--------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
GlyphName *SetupGlyphArray(encFilePath)

LPSZ encFilePath;
{
  return(winEnc);
}

/*----------------------------------------------------------------------------*/



/******************************Public*Routine******************************\
*
* BOOL bGetDescFromInf(char * pszINF, DWORD cjDesc, char *pszDesc)
*
* Not same as adobe's routine, we use font name from which we weed out
* hyphens '-'
*
* History:
*  28-Apr-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL bGetDescFromInf(char * pszINF, DWORD cjDesc, char *pszDesc)
{
  INT         hfile;

  static KEY akeyInf[] = {
      "FontName",   TK_PSNAME,
      NULL, 0
      };

  hfile = OpenParseFile( pszINF );
  if( hfile == -1 ) return(FALSE);

  pszDesc[0] = 0;

  while( GetLine(hfile) )
  {
    if (GetToken(hfile,akeyInf) == TK_PSNAME)
    {
       GetString(pszDesc, cjDesc);
       break;
    }
  }
  _lclose(hfile);

  if( !pszDesc[0] ) return(FALSE);

// weed out hyphens

  for ( ; *pszDesc; pszDesc++)
  {
    if (*pszDesc == '-')
        *pszDesc = ' ';
  }

  return(TRUE);

}

/******************************Public*Routine******************************\
*
* short CreatePFM(char *pszINF, char *pszAFM, char *pszPFM);
*
* slightly modified adobe's routine
*
* History:
*  28-Apr-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
* Returns: 16-bit encoded value indicating error and type of file where
*          error occurred.  (see fvscodes.h) for definitions.
*          The following table lists the "status" portion of the codes
*          returned.
*
*           FVS_SUCCESS           
*           FVS_INVALID_FONTFILE  
*           FVS_FILE_OPEN_ERR   
*           FVS_FILE_BUILD_ERR  
*
\**************************************************************************/
short CreatePFM(char *pszINF, char *pszAFM, char *pszPFM)
{
  CHAR bname[9];

  // We need both the AFM and the INF file in order to create the PFM.
  if (pszAFM==NULL || pszINF==NULL)
	  return FVS_MAKE_CODE(FVS_INVALID_ARG, FVS_FILE_UNK);

  indexMemArray = 0;              /* init global */

  afm.szFile[0] = '\0';
	strncpy(afm.szFile, pszAFM, sizeof(afm.szFile)-1);
  afm.szFile[sizeof(afm.szFile)-1] = '\0';
  GetFilename(pszAFM, bname);

  strncpy (infofile, pszINF, sizeof(infofile)-1); 
  infofile[sizeof(infofile)-1] = '\0';
  strncpy (outfile, pszPFM, sizeof(outfile)-1); 
  outfile[sizeof(outfile)-1] = '\0';

  afm.iPtSize = 12;
  encfile[0] = EOS;
  devType = POSTSCRIPT;

// this is something that would have never come to my mind [bodind]

  if( !strcmp(_strupr(bname), "SY______") )
    charset = SYMBOL_CHARSET;
  else
    charset = -1;

/*
 * yh 8/16/91 -- Keep forceVariablePitch to TRUE for now to be compatible
 * with bitmaps generated by Font Foundry.  ATM and device driver will
 * report different value for PitchAndFamily for monospaced fonts.
 *
 * forceVariablePitch = FALSE;
 */

  return _MakePfm();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\pinstall.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// pinstal.cpp
//      Explorer Font Folder extension routines
//     Install files into \<windows>\fonts directory
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

#include "priv.h"
#include "globals.h"
#include "cpanel.h"
#include "resource.h"
#include "fontfile.h"


/*****************************************************/
/******************** locals *************************/
/*****************************************************/

static DWORD NEAR PASCAL dwGetSetFileAttr( LPTSTR lpFileName, WORD wAttr );
static int   NEAR PASCAL iMsgRecoverable( HWND hwndParent, DWORD dwVIF, PTSTR pFile );

/*****************************************************/
/******************** Defines ************************/
/*****************************************************/

#define RECOVERABLEERROR    (VIF_SRCOLD     |  VIF_DIFFLANG |  \
                             VIF_DIFFCODEPG |  VIF_DIFFTYPE)

#define UNRECOVERABLEERROR (VIF_FILEINUSE    | VIF_OUTOFSPACE   | \
                            VIF_CANNOTCREATE | VIF_OUTOFMEMORY  | \
                            VIF_CANNOTRENAME | VIF_CANNOTDELETE | \
                            VIF_CANNOTREADDST)
#define READONLY (1)

#ifndef DBCS
#define IsDBCSLeadByte(x) (FALSE)
#endif

/*****************************************************/
/******************** Functions **********************/
/*****************************************************/


int NEAR PASCAL iMsgRecoverable( HWND hwndParent, DWORD dwVIF, PTSTR pszFile )
{
    // BGK - finish this one

#define NUMFLAGS 3

    TCHAR  cszErr[ NUMFLAGS ][ 128 ] = { TEXT( "" ), TEXT( "" ), TEXT( "" ) };

    static DWORD dwFlags[ NUMFLAGS ] =
                   { VIF_SRCOLD, VIF_DIFFLANG | VIF_DIFFCODEPG, VIF_DIFFTYPE };


    for( int nTemp = 0; nTemp < NUMFLAGS; ++nTemp )
        if( dwVIF & dwFlags[ nTemp ])

            // cszErr[ nTemp ].LoadString( INSTALL5+nTemp );

            LoadString( g_hInst, INSTALL5 + nTemp, cszErr[ nTemp ], 128 );

    return iUIMsgBox( hwndParent, INSTALL8, IDS_MSG_CAPTION,
                      MB_YESNOCANCEL|MB_DEFBUTTON2|MB_ICONEXCLAMATION,
                      pszFile, cszErr[ 0 ], cszErr[ 1 ], cszErr[ 2 ]);
}


DWORD FFInstallFile( DWORD   dwFlags,
                     LPCTSTR szFromName,
                     LPCTSTR szToName,
                     LPCTSTR szFromDir,
                     LPCTSTR szToDir,
                     LPCTSTR szWinDir,
                     LPTSTR  szTmpFile,
                     UINT   *puTmpLen )
{
    FullPathName_t szFrom;
    FullPathName_t szTo;

    if (!PathCombine( szFrom, szFromDir, szFromName ) ||
        !PathCombine( szTo  , szToDir  , szToName  ))
    {
        return( VIF_BUFFTOOSMALL );
    }

    CFontFile file;
    
    if (ERROR_SUCCESS != file.Open(szFrom, 
                                   GENERIC_READ, 
                                   FILE_SHARE_READ))
    {
        return( VIF_CANNOTREADSRC );
    }

    switch(file.CopyTo(szTo))
    {
        case ERROR_SUCCESS:
            break;

        case ERROR_WRITE_FAULT:
            return( VIF_OUTOFSPACE );

        case ERROR_NOT_ENOUGH_MEMORY:
        case ERROR_LOCK_FAILED:
            return( VIF_OUTOFMEMORY );

        default:
            //
            //  Return some unknown error
            //
            return( UNRECOVERABLEERROR );
            break;
    }

    return( 0 );
}


//
//  This installs files into the system or windows directory
//
//  There is a lot of dead code here, since this is only used for installing
//  fonts now.  Oh well.
//

BOOL FAR PASCAL bCPInstallFile( HWND hwndParent, LPTSTR lpszDir, LPTSTR lpszFrom, LPTSTR lpszTo )
{
    FullPathName_t  szShareDir;
    FullPathName_t  szAttrPath;
    FILENAME        szTmpFile;
    FILENAME        szFile;
                    
    TCHAR   szClass[ 40 ];

    UINT    wClass  = ARRAYSIZE( szClass );
    UINT    wTmpLen = ARRAYSIZE( szShareDir );


    WORD    wFlags;
    UINT    wFindStatus;
    DWORD   dwInsStatus;

    BOOL    bSuccess       = FALSE;
    BOOL    bToastTempFile = FALSE;

    static    FullPathName_t s_szWinDir;

    static    BOOL  s_bFirst = TRUE;


    if( s_bFirst )
    {
        GetSystemWindowsDirectory( s_szWinDir, ARRAYSIZE( s_szWinDir ) );
        if (!lpCPBackSlashTerm  ( s_szWinDir, ARRAYSIZE(s_szWinDir)))
        {
            return FALSE; // Insufficient room to append backslash.
        }
        s_bFirst = FALSE;
    }

    StringCchCopy( e_szDirOfSrc, ARRAYSIZE(e_szDirOfSrc), lpszDir );

    vCPStripBlanks( e_szDirOfSrc, ARRAYSIZE(e_szDirOfSrc) );

    //
    //  Find the file to see if it is running or currently installed.
    //

    //
    //  Interrogate the installation system to determine where we
    //  need to put the file.  We pass in szFile - the name of the
    //  file we're going to be creating.  This has no path specified.
    //  We know where we want to put the file, and therefore don't look
    //  at the recommended destination
    //

    StringCchCopy( szFile, ARRAYSIZE(szFile), lpszTo );
    CharUpper( szFile );

    *szShareDir = 0;

    FullPathName_t szTempDir;

    GetFontsDirectory( szTempDir, ARRAYSIZE( szTempDir ) );
   
    wFindStatus = VerFindFile( VFFF_ISSHAREDFILE, szFile, NULL, szTempDir,
                                      szClass, &wClass, szShareDir, &wTmpLen );

    //
    //  Force an install in the fonts directory.
    //

    StringCchCopy( szShareDir, ARRAYSIZE(szShareDir), szTempDir );

    //
    //  If the destination file's being used by windows, we can't do much.
    //  report and bug out.
    //

    if( wFindStatus & VFF_FILEINUSE )
    {
        iUIMsgInfo( hwndParent, INSTALL1, szFile );
        goto Backout;
    }

    //
    //  If the current file is in the windows directory, be sure to delete it
    //  Or else a file installed in the system dir will not be found
    //

    if (!lpCPBackSlashTerm( szShareDir, ARRAYSIZE(szShareDir)))
    {
        goto Backout;
    }

    if( lstrcmpi( szShareDir, s_szWinDir ) == 0 )
        wFlags = 0;
    else
        wFlags = VIFF_DONTDELETEOLD;

    StringCchCopy( szFile, ARRAYSIZE(szFile), lpszFrom );

    CharUpper( szFile );

DoInstall:

    //
    //  input buffer should be empty
    //

    *szTmpFile = 0;

    wTmpLen = ARRAYSIZE( szTmpFile );

    dwInsStatus = FFInstallFile( wFlags, szFile, lpszTo, e_szDirOfSrc,
                                 szShareDir, s_szWinDir, szTmpFile,
                                 &wTmpLen );
    //
    //  Note if we created a temporary file, which we'll have to delete in
    //  the event of failure
    //

    bToastTempFile = ( dwInsStatus & VIF_TEMPFILE ) != 0;

    if( dwInsStatus & VIF_CANNOTREADSRC )
        iUIMsgInfo( hwndParent, INSTALL9 );

    //
    //  If the install failed because the file was write-protected, ask the
    //  user what to do.    A no means on to the next, a yes says reset our
    //  file attributes and try again
    //

    else if( dwInsStatus & VIF_WRITEPROT )
        switch( iUIMsgBox( hwndParent, INSTALL0, IDS_MSG_CAPTION,
                           MB_YESNOCANCEL | MB_DEFBUTTON2 | MB_ICONEXCLAMATION,
                           szFile ) )
        {
        case IDYES:
            StringCchPrintf(szAttrPath, ARRAYSIZE(szAttrPath), TEXT("%s%s"), szShareDir, szFile);

            SetFileAttributes( szAttrPath, GetFileAttributes( szAttrPath ) 
                                              & ~FILE_ATTRIBUTE_READONLY );
            goto DoInstall;
        } // switch

    //
    //  If we had a recoverable error and we're not retrying ask the user
    //  what to do.    A no means go on to the next, and a yes means reset
    //  our force flag and retry.
    //

    else if( ( dwInsStatus & RECOVERABLEERROR )
               && !(wFlags & VIFF_FORCEINSTALL ) )
        switch( iMsgRecoverable( hwndParent, dwInsStatus, szFile ) )
        {
        case IDYES:
            //
            //  Try again, forcing
            //

            wFlags |= VIFF_FORCEINSTALL;
            goto DoInstall;
        }

    //
    //  These other states all need errors reported, then bug out
    //

    else if( dwInsStatus & VIF_FILEINUSE )
        iUIMsgInfo( hwndParent, INSTALL1, szFile );

    else if( dwInsStatus & VIF_OUTOFSPACE )
        iUIMsgInfo( hwndParent, INSTALL2, szFile );

    else if( dwInsStatus & VIF_OUTOFMEMORY )
        iUIMsgInfo( hwndParent, INSTALL3, szFile );

    else if( dwInsStatus & UNRECOVERABLEERROR )
        iUIMsgInfo( hwndParent, INSTALL4, szFile );

    else if( dwInsStatus )
        iUIMsgInfo( hwndParent, INSTALL9 );

    //
    //  We've reached this point because of a good status, so we don't have
    //  to delete the temporary file.
    //

    else
    {
        bToastTempFile = FALSE;
        bSuccess = TRUE;
    }

Backout:

    if( bToastTempFile )
        vCPDeleteFromSharedDir( szTmpFile );

    bToastTempFile = FALSE;

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\putil.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// putil.cpp
//      Explorer Font Folder extension routines.
//      Control panel utility function.
//      Contains Control Panel memory allocation routines.
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//      15 Aug 95 SteveCat
//          Added memory allocation routines for Type 1 font support
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================

// C Runtime
#include <string.h>
#include <memory.h>


#include "priv.h"
#include "globals.h"

#include <lzexpand.h>

#include "cpanel.h"
#include "dbutl.h"
#include "resource.h"


//
//  local variables and constants
//

static FullPathName_t s_szSetupDir;

//
//  WIN.INI font section name
//

static TCHAR  szFonts[]  = TEXT( "fonts" );

//
//  Globally visible variables
//

FullPathName_t e_szDirOfSrc = { TEXT( '\0' ) };

FullPathName_t   s_szSharedDir;



BOOL FAR PASCAL bCPSetupFromSource( )
{
    return !lstrcmpi( e_szDirOfSrc, s_szSetupDir );
}


void FAR PASCAL vCPUpdateSourceDir( )
{
    StringCchCopy( e_szDirOfSrc, ARRAYSIZE(e_szDirOfSrc), s_szSetupDir );
}


void FAR PASCAL vCPWinIniFontChange( )
{
    PostMessage( HWND_BROADCAST, WM_WININICHANGE, NULL, (LPARAM)(LPTSTR)szFonts );
    PostMessage( HWND_BROADCAST, WM_FONTCHANGE,   NULL, 0L );
}


void FAR PASCAL vCPPanelInit( )
{
    s_wBrowseDoneMsg = RegisterWindowMessage( FILEOKSTRING );

    if( TRUE /* !s_hSetup && !s_hAutoInstall && !s_fDoUpgrade */)
    {
        TCHAR cDefDir[ PATHMAX ];

        LoadString( g_hInst, IDSI_MSG_DEFDIR, cDefDir, ARRAYSIZE( cDefDir ) );

        StringCchCopy( s_szSetupDir, ARRAYSIZE(s_szSetupDir), cDefDir );

        ::GetFontsDirectory( s_szSharedDir, ARRAYSIZE( s_szSharedDir ) );

        lpCPBackSlashTerm( s_szSharedDir, ARRAYSIZE(s_szSharedDir) );
    }

    vCPUpdateSourceDir( );
}


//
// Determine if a file is located in the fonts directory.
//
BOOL bFileIsInFontsDirectory(LPCTSTR lpszPath)
{
    TCHAR szTemp[MAX_PATH];
    BOOL bResult = FALSE;

    if (NULL != lpszPath)
    {
        //
        // Make a local copy.  String will be modified.
        //
        StringCchCopy(szTemp, ARRAYSIZE(szTemp), lpszPath);

        PathRemoveFileSpec(szTemp); // Strip to path part.
        PathAddBackslash(szTemp);   // Make sure it ends with backslash.

        bResult = (lstrcmpi(szTemp, s_szSharedDir) == 0);
    }
    return bResult;
}


VOID FAR PASCAL vCPStripBlanks( LPTSTR lpszString, size_t cchString )
{
    LPTSTR lpszPosn;

    //
    //  strip leading blanks by finding the first non blank.    If this
    //  was a change, recopy the string.  BGK - Q. Why not CharNext here?
    //

    lpszPosn = lpszString;

    while( *lpszPosn == TEXT( ' ' ) )
        lpszPosn++;

    if( lpszPosn != lpszString )
        StringCchCopy( lpszString, cchString, lpszPosn );

    //
    //  strip trailing blanks
    //

    if( ( lpszPosn = lpszString + lstrlen( lpszString ) ) != lpszString )
    {
        lpszPosn = CharPrev( lpszString, lpszPosn );

        while( *lpszPosn == TEXT( ' ' ) )
            lpszPosn = CharPrev( lpszString, lpszPosn );

        lpszPosn  = CharNext( lpszPosn );
        *lpszPosn = TEXT( '\0' );
    }
}


LPTSTR FAR PASCAL lpCPBackSlashTerm( LPTSTR lpszPath, size_t cchPath )
{
    LPTSTR lpszEnd = lpszPath + lstrlen( lpszPath );
    if ((size_t)(lpszEnd - lpszPath + 1) >= cchPath)
    {
        //
        // Not enough room to append a backslash.
        //
        return NULL;
    }

    if( !*lpszPath )
        goto appendit;

    //
    //  Get the end of the source directory
    //

    if( *CharPrev( lpszPath, lpszEnd ) != TEXT( '\\' ) )
    {
appendit:
        *lpszEnd++ = TEXT( '\\' );
        *lpszEnd   = TEXT( '\0' );
    }

    return lpszEnd;
}

HANDLE PASCAL wCPOpenFileWithShare( LPTSTR lpszFile,
                                    LPTSTR lpszPath,
                                    size_t cchPath,
                                    WORD   wFlags )
{
    HANDLE  fHandle;


    if( ( fHandle = MyOpenFile( lpszFile, lpszPath, cchPath, wFlags | OF_SHARE_DENY_NONE ) )
                  == (HANDLE) INVALID_HANDLE_VALUE )
        fHandle = MyOpenFile( lpszFile, lpszPath, cchPath, wFlags );

    return fHandle;
}

//
//  This does what is necessary to bring up a dialog box
//

int FAR PASCAL DoDialogBoxParam( int nDlg, HWND hParent, DLGPROC lpProc,
                                 DWORD dwHelpContext, LPARAM dwParam )
{
    nDlg = (int)DialogBoxParam( g_hInst, MAKEINTRESOURCE( nDlg ), hParent,
                           lpProc, dwParam );

    return( nDlg );
}


int FAR cdecl MyMessageBox (HWND hWnd, DWORD wText, DWORD wCaption, DWORD wType, ...)
{
    TCHAR   szText[ 4 * PATHMAX ], szCaption[ 2 * PATHMAX ];
    va_list parg;


    va_start( parg, wType );

    if( wText == IDS_MSG_NSFMEM /* INITS */)
        goto NoMem;

    if( !LoadString( g_hInst, wText, szCaption, ARRAYSIZE( szCaption ) ) )
        goto NoMem;

    StringCchVPrintf( szText, ARRAYSIZE(szText), szCaption, parg );

    if( !LoadString( g_hInst, wCaption, szCaption, ARRAYSIZE( szCaption ) ) )
        goto NoMem;

    wText = (DWORD) MessageBox( hWnd, szText, szCaption,
                                wType | MB_SETFOREGROUND );

    if( wText == (DWORD) -1 )
        goto NoMem;

    va_end( parg );

    return( (int) wText );


NoMem:
    va_end( parg );

    iUIErrMemDlg(hWnd);

    return( -1 );
}


//*****************************************************************
//
//   MyOpenFile()
//
//   Purpose     : To simulate the effects of OpenFile(),
//                 _lcreat and _lopen in a Uniode environment,
//                 but also to be used in non-Unicode environment
//                 as well.
//
//*****************************************************************

HANDLE MyOpenFile( LPTSTR lpszFile, TCHAR * lpszPath, size_t cchPath, DWORD fuMode )
{
    HANDLE   fh;
    DWORD    len;
    LPTSTR   lpszName;
    TCHAR    szPath[MAX_PATH];
    DWORD    accessMode  = 0;
    DWORD    shareMode   = 0;
    DWORD    createMode  = 0;
    DWORD    fileAttribs = FILE_ATTRIBUTE_NORMAL;


    if( !lpszFile )
        return( INVALID_HANDLE_VALUE );

    //
    //  fuMode of OF_EXIST is looking for the full path name if exist
    //

    if( fuMode & OF_EXIST )
    {
        len = SearchPath( NULL, lpszFile, NULL, ARRAYSIZE(szPath), szPath, &lpszName );

CopyPath:
        if( len )
        {
            if( lpszPath )
                StringCchCopy( lpszPath, cchPath, szPath );

            return( (HANDLE) 1 );
        }
        else
            return( INVALID_HANDLE_VALUE );
    }

    //
    //  fuMode of OF_PARSE is looking for the full path name by merging the
    //  current directory
    //

    if( fuMode & OF_PARSE )
    {
        len = GetFullPathName( lpszFile, ARRAYSIZE(szPath), szPath, &lpszName );
        goto CopyPath;
    }

    //
    //  set up all flags passed for create file.
    //
    //  file access flag

    if( fuMode & OF_WRITE )
        accessMode = GENERIC_WRITE;
    else if( fuMode & OF_READWRITE )
        accessMode = GENERIC_READ | GENERIC_WRITE;
    else
        accessMode = GENERIC_READ;

    //
    //  file sharing flag
    //

    if( fuMode & OF_SHARE_EXCLUSIVE )
        shareMode = 0;
    else if( fuMode & OF_SHARE_DENY_WRITE )
        shareMode = FILE_SHARE_READ;
    else if( fuMode & OF_SHARE_DENY_READ )
        shareMode = FILE_SHARE_WRITE;
    else
        shareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;

    //
    //  set file creation flag
    //

    if( fuMode & OF_CREATE )
        createMode = CREATE_ALWAYS;
    else
        createMode = OPEN_EXISTING;

    //
    //  call CreateFile();
    //

    fh = CreateFile( lpszFile, accessMode, shareMode,
                     NULL, createMode, fileAttribs, NULL );

    if( lpszPath )
        StringCchCopy( lpszPath, cchPath, lpszFile );

    return( fh );

} // end of MyOpenFile()


//*****************************************************************
//
//   MyCloseFile()
//
//   Purpose     : To simulate the effects of _lclose()
//                 in a Uniode environment.
//
//*****************************************************************

BOOL MyCloseFile( HANDLE  hFile )
{
    return( CloseHandle( hFile ) );
} // end of MyCloseFile()


//*****************************************************************
//
//   MyByteReadFile()
//
//   For Win16, will handle > 64k
//
//*****************************************************************

UINT MyByteReadFile( HANDLE  hFile, LPVOID  lpBuffer, DWORD  cbBuffer )
{
    UINT cbRead = (UINT)HFILE_ERROR;

    if (ReadFile( hFile, lpBuffer, cbBuffer, (ULONG *)&cbRead, NULL ))
        return cbRead;
    else
        return (UINT)HFILE_ERROR;
} // end of MyByteReadFile()


//*****************************************************************
//
//   MyAnsiReadFile()
//
//   Purpose     : To simulate the effects of _lread() in a Unicode
//                 environment by reading into an ANSI buffer and
//                 then converting to Unicode text.
//
//*****************************************************************

UINT MyAnsiReadFile( HANDLE  hFile,
                     UINT    uCodePage,
                     LPVOID  lpUnicode,
                     DWORD   cchUnicode)
{
    LPSTR lpAnsi  = NULL;
    UINT  cbRead  = (UINT)HFILE_ERROR;
    UINT  cbAnsi  = cchUnicode * sizeof(WCHAR);
    UINT  cchRead = 0;

    lpAnsi = (LPSTR) LocalAlloc(LPTR, cbAnsi);
    if (NULL != lpAnsi)
    {
        cbRead = MyByteReadFile( hFile, lpAnsi, cbAnsi );

        if( HFILE_ERROR != cbRead )
        {
            cchRead = MultiByteToWideChar( uCodePage,
                                           0,
                                           lpAnsi,
                                           cbRead,
                                           (LPWSTR)lpUnicode,
                                           cchUnicode);
        }
        LocalFree( lpAnsi );
    }

    return( cchRead );

} // end of MyAnsiReadFile()


//*****************************************************************
//
//   MyByteWriteFile()
//
//   For Win16, will handle > 64k
//
//*****************************************************************

UINT MyByteWriteFile( HANDLE hFile, LPVOID lpBuffer, DWORD cbBuffer )
{
    UINT cbWritten = (UINT)HFILE_ERROR;
    if (WriteFile( hFile, lpBuffer, cbBuffer, (ULONG *)&cbWritten, NULL ))
        return cbWritten;
    else
        return (UINT)HFILE_ERROR;
} // end of MyByteWriteFile()


//*****************************************************************
//
//   MyAnsiWriteFile()
//
//   Purpose     : To simulate the effects of _lwrite() in a Unicode
//                 environment by converting to ANSI buffer and
//                 writing out the ANSI text.
//
//*****************************************************************

UINT MyAnsiWriteFile( HANDLE  hFile,
                      UINT uCodePage,
                      LPVOID lpUnicode,
                      DWORD cchUnicode)
{
    LPSTR   lpAnsi    = NULL;
    UINT    cbAnsi    = 0;
    UINT    cbWritten = (UINT)HFILE_ERROR;

    //
    // Calculate byte requirement for ansi buffer.
    //
    cbAnsi = WideCharToMultiByte (uCodePage,
                                  0,
                                  (LPWSTR)lpUnicode,
                                  cchUnicode,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL);

    //
    // Allocate the ansi buffer and convert characters to ansi.
    //
    lpAnsi = (LPSTR) LocalAlloc(LPTR, cbAnsi);
    if (NULL != lpAnsi)
    {
        WideCharToMultiByte( uCodePage,
                             0,
                             (LPWSTR)lpUnicode,
                             cchUnicode,
                             lpAnsi,
                             cbAnsi,
                             NULL,
                             NULL );

        cbWritten = MyByteWriteFile( hFile, lpAnsi, cbAnsi );

        LocalFree( lpAnsi );
    }

    return( cbWritten );

} // end of MyAnsiWriteFile()


//*****************************************************************
//
//   MyFileSeek()
//
//   Purpose     : To simulate the effects of _lseek() in a Unicode
//                 environment.
//
//*****************************************************************

LONG MyFileSeek( HANDLE hFile, LONG lDistanceToMove, DWORD dwMoveMethod )
{
    return( SetFilePointer( hFile, lDistanceToMove, NULL, dwMoveMethod ) );
} // end of MyFileSeek()



/////////////////////////////////////////////////////////////////////////////
//
// AllocMem
//
//
// Routine Description:
//
//     This function will allocate local memory. It will possibly allocate
//     extra memory and fill this with debugging information for the
//     debugging version.
//
// Arguments:
//
//     cb - The amount of memory to allocate
//
// Return Value:
//
//     NON-NULL - A pointer to the allocated memory
//
//     FALSE/NULL - The operation failed. Extended error status is available
//         using GetLastError.
//
/////////////////////////////////////////////////////////////////////////////

LPVOID AllocMem( DWORD cb )
{
    LPDWORD  pMem;
    DWORD    cbNew;


    cbNew = cb + 2 * sizeof( DWORD );

    if( cbNew & 3 )
        cbNew += sizeof( DWORD ) - ( cbNew & 3 );

    pMem = (LPDWORD) LocalAlloc( LPTR, cbNew );

    if( !pMem )
        return NULL;

    // memset (pMem, 0, cbNew);     // This might go later if done in NT

    *pMem = cb;

    *(LPDWORD) ( (LPBYTE) pMem + cbNew - sizeof( DWORD ) ) = 0xdeadbeef;

    return (LPVOID)( pMem + 1 );
}


/////////////////////////////////////////////////////////////////////////////
//
// FreeMem
//
//
// Routine Description:
//
//     This function will allocate local memory. It will possibly allocate
//     extra memory and fill this with debugging information for the
//     debugging version.
//
// Arguments:
//
//     pMem - Pointer to memory to free
//     cb   - size of memory block to free
//
// Return Value:
//
//     NON-NULL - Memory successfully freed
//
//     FALSE/NULL - The operation failed. Extended error status is available
//                  using GetLastError.
//
/////////////////////////////////////////////////////////////////////////////

BOOL FreeMem( LPVOID pMem, DWORD  cb )
{
    DWORD   cbNew;
    LPDWORD pNewMem;


    if( !pMem )
        return TRUE;

    pNewMem = (LPDWORD) pMem;
    pNewMem--;


#ifdef NO_COUNT_NEEDED
    if( cb == 0 )
    {
        cb = cbNew = *pNewMem;
    }
    else
    {
        cbNew = cb + 2 * sizeof( DWORD );

        if( cbNew & 3 )
            cbNew += sizeof( DWORD ) - ( cbNew & 3 );
    }
#else

    cbNew = cb + 2 * sizeof( DWORD );

    if( cbNew & 3 )
        cbNew += sizeof( DWORD ) - ( cbNew & 3 );


#endif  // NO_COUNT_NEEDED


    if( ( *pNewMem != cb ) ||
        ( *(LPDWORD) ( (LPBYTE) pNewMem + cbNew - sizeof( DWORD ) ) != 0xdeadbeef ) )
    {
        DEBUGMSG( (DM_TRACE1, TEXT("Corrupt Memory in FontFolder : %0lx\n"), pMem ) );
    }

    return ( ( (HLOCAL) pNewMem == LocalFree( (LPVOID) pNewMem ) ) );
}


/////////////////////////////////////////////////////////////////////////////
//
// Routine Description:
//
//     These functions will allocate or reallocate enough local memory to
//     store the specified  string, and copy that string to the allocated
//     memory.  The FreeStr function frees memory that was initially
//     allocated by AllocStr.
//
// Arguments:
//
//     lpStr - Pointer to the string that needs to be allocated and stored
//
// Return Value:
//
//     NON-NULL - A pointer to the allocated memory containing the string
//
//     FALSE/NULL - The operation failed. Extended error status is available
//         using GetLastError.
//
/////////////////////////////////////////////////////////////////////////////

LPTSTR AllocStr( LPTSTR lpStr )
{
   LPTSTR lpMem;

   if( !lpStr )
      return NULL;

   const size_t cchAlloc = lstrlen(lpStr) + 1;
   if( lpMem = (LPTSTR) AllocMem( cchAlloc * sizeof( TCHAR ) ) )
      StringCchCopy( lpMem, cchAlloc, lpStr );

   return lpMem;
}


BOOL FreeStr( LPTSTR lpStr )
{
   return lpStr ? FreeMem( lpStr, ( lstrlen( lpStr ) + 1 ) * sizeof( TCHAR ) )
                : FALSE;
}


BOOL ReallocStr( LPTSTR *plpStr, LPTSTR lpStr )
{
   FreeStr( *plpStr );

   *plpStr = AllocStr( lpStr );

   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CentreWindow
//
// Purpose : Positions a window so that it is centred in its parent
//
// History:
// 12-09-91 Davidc       Created.
//
//////////////////////////////////////////////////////////////////////////////

VOID CentreWindow( HWND hwnd )
{
    RECT    rect;
    RECT    rectParent;
    HWND    hwndParent;
    LONG    dx, dy;
    LONG    dxParent, dyParent;
    LONG    Style;


    //
    //  Get window rect
    //

    GetWindowRect( hwnd, &rect );

    dx = rect.right - rect.left;
    dy = rect.bottom - rect.top;

    //
    //  Get parent rect
    //

    Style = GetWindowLong( hwnd, GWL_STYLE );

    if( (Style & WS_CHILD) == 0 )
    {
        hwndParent = GetDesktopWindow( );
    }
    else
    {
        hwndParent = GetParent( hwnd );

        if( hwndParent == NULL )
        {
            hwndParent = GetDesktopWindow( );
        }
    }

    GetWindowRect( hwndParent, &rectParent );

    dxParent = rectParent.right - rectParent.left;
    dyParent = rectParent.bottom - rectParent.top;

    //
    //  Centre the child in the parent
    //

    rect.left = ( dxParent - dx ) / 2;
    rect.top  = ( dyParent - dy ) / 3;

    //
    //  Move the child into position
    //

    SetWindowPos( hwnd, NULL, rect.left, rect.top, 0, 0,
                  SWP_NOSIZE | SWP_NOZORDER );

    SetForegroundWindow( hwnd );
}


//
// Retrieves the text from a drop-down combo box list.
// Use to prevent CB_GETTEXTLEN from overwriting the destination buffer.
//
HRESULT ComboGetText(HWND hwndCombo, int iItem, LPTSTR pszText, size_t cchText)
{
    HRESULT hr = E_INVALIDARG;
    if (0 < cchText)
    {
        hr = S_OK;
        *pszText = 0;
        
        const DWORD cchSelName = (DWORD)::SendMessage(hwndCombo, CB_GETLBTEXTLEN, iItem, 0) + 1;
        if (1 < cchSelName)
        {
            LPTSTR pszTemp = (LPTSTR)LocalAlloc(LPTR, cchSelName * sizeof(*pszTemp));
            if (NULL != pszTemp)
            {
                ::SendMessage( hwndCombo, CB_GETLBTEXT, iItem, (LPARAM)pszTemp );
                hr = StringCchCopy(pszText, cchText, pszTemp);
                LocalFree(pszTemp);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\strtab.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Class: StringTable
//
// This class implements a simple hash table for storing text strings.
// The purpose of the table is to store strings and then verify later
// if the table contains a given string.  Since there is no data associated
// with the string, the stored strings act as both key and data.  Therefore,
// there is no requirement for string retrieval.  Only existence checks
// are required.
// The structure maintains a fixed-length array of pointers, each pointing
// to a linked list structure (List).  These lists are used to handle the
// problem of hash collisions (sometimes known as "separate chaining").
//
// Note that these classes do not contain all the stuff that is usually
// considered necessary in C++ classes.  Things like copy constructors,
// assignment operator, type conversion etc are excluded. The classes
// are very specialized for the Font Folder application and these things
// would be considered "fat".  Should this hash table class be later used 
// in a situation where these things are needed, they can be added then.
//
// The public interfaces to the table are:
//
//      Initialize  - Initialize a new string table.
//      Add         - Add a new string to a table.
//      Exists      - Determine if a string exists in a table.
//      Count       - Return the number of strings in a table.
//
// Destruction of the object automatically releases all memory associated
// with the table.
//
// BrianAu - 4/11/96
///////////////////////////////////////////////////////////////////////////////
#include "priv.h"
#include "strtab.h"


//////////////////////////////////////////////////////////////////////////////
// Class "StringTable" member functions.
//////////////////////////////////////////////////////////////////////////////

//
// String table constructor.
//
StringTable::StringTable(void)
    : m_apLists(NULL),
      m_dwItemCount(0),
      m_dwHashBuckets(0),
      m_bCaseSensitive(FALSE),
      m_bAllowDuplicates(FALSE)
{

}


//
// String table destructor.
//
StringTable::~StringTable(void)
{
    Destroy();
}


//
// Destroy table structures.
// Deletes all memory associates with a string table.
//
void StringTable::Destroy(void)
{
    if (NULL != m_apLists)
    {
        for (UINT i = 0; i < m_dwHashBuckets; i++)
        {
            //
            // Delete List if one exists in this slot.
            //
            if (NULL != m_apLists[i])
                delete m_apLists[i];
        }
        //
        // Delete array of List pointers.
        //
        delete [] m_apLists;
        m_apLists = NULL;
    }

    m_bCaseSensitive   = FALSE;
    m_bAllowDuplicates = FALSE;
    m_dwItemCount      = 0;
    m_dwHashBuckets    = 0;
}


//
// Initialize a StringTable object.
// Allocates and initializes the array of List pointers.
//
HRESULT StringTable::Initialize(DWORD dwHashBuckets, BOOL bCaseSensitive,
                                BOOL bAllowDuplicates)
{
    HRESULT hr = E_OUTOFMEMORY;
    Destroy();

    m_apLists = new List* [dwHashBuckets];
    if (NULL != m_apLists)
    {
        ZeroMemory(m_apLists, dwHashBuckets * sizeof(m_apLists[0]));
        m_dwHashBuckets    = dwHashBuckets;
        m_bCaseSensitive   = bCaseSensitive;
        m_bAllowDuplicates = bAllowDuplicates;
        hr                 = S_OK;
    }
    return hr;
}


//
// Determine if a string exists in the table.
// This is a private function for use when the hash code has already
// been calculated.
//
BOOL StringTable::Exists(DWORD dwHashCode, LPCTSTR pszText)
{
    BOOL bResult  = FALSE;

    if (NULL != m_apLists)
    {
        List *pList = m_apLists[dwHashCode];

        if (NULL != pList && pList->Exists(pszText))
            bResult = TRUE;
    }
    return bResult;
}


//
// Determine if a string exists in the table.
//
BOOL StringTable::Exists(LPCTSTR pszText)
{
    LPTSTR pszTemp = (LPTSTR)pszText;
    BOOL bResult   = FALSE;

    if (!m_bCaseSensitive)
    {
        //
        // Convert to upper case if table is case-insensitive.
        // This creates a NEW string that must be deleted later.
        //
        pszTemp = CreateUpperCaseString(pszText);
    }

    if (NULL != pszTemp)
    {
        bResult = Exists(Hash(pszTemp), pszTemp);

        if (pszTemp != pszText)
            delete [] pszTemp;
    }

    return bResult;
}


//
// Duplicate a string converting it to upper case.
// The returned string must be deleted when you're done with it.
//
LPTSTR StringTable::CreateUpperCaseString(LPCTSTR pszText) const
{
    //
    // Convert to upper case if table is case-insensitive.
    //
    const size_t cchText = lstrlen(pszText) + 1;
    LPTSTR pszTemp = new TCHAR [cchText];
    if (NULL != pszTemp)
    {
        StringCchCopy(pszTemp, cchText, pszText);
        CharUpper(pszTemp);
    }
    return pszTemp;
}

    
//
// Add a string to the table.
//
BOOL StringTable::Add(LPCTSTR pszText)
{
    LPTSTR pszTemp = (LPTSTR)pszText;
    BOOL bResult   = FALSE;

    if (!m_bCaseSensitive)
    {
        //
        // Convert to upper case if table is case-insensitive.
        // This creates a NEW string that must be deleted later.
        //
        pszTemp = CreateUpperCaseString(pszText);
    }

    if (NULL != pszTemp)
    {
        DWORD dwHashCode = Hash(pszTemp);

        if (NULL != m_apLists)
        {
            List *pList = m_apLists[dwHashCode];

            if (NULL == pList)
            {
                //
                // Create a new List object for this slot if the slot is empty.
                //
                pList = new List;
                m_apLists[dwHashCode] = pList;
            }
            if (NULL != pList)
            {
                //
                // Add the new item to the List.
                //
                if (bResult = pList->Add(pszTemp, m_bAllowDuplicates))
                {
                    m_dwItemCount++;
                    bResult = TRUE;
                }
            }
        }

        //
        // Free the temp string if created for case conversion.
        //
        if (pszTemp != pszText)
            delete [] pszTemp;
    }

    return bResult;
}
    

//
// Function for calculating hash value of a string.
//
DWORD StringTable::Hash(LPCTSTR pszText) const
{
    LPCTSTR p = NULL;
    DWORD dwCode = 0;

    for (p = pszText; TEXT('\0') != *p; p++)
    {
        dwCode += *p;
    }

    return dwCode % m_dwHashBuckets;
}



#ifdef DEBUG

//
// Dump table contents to debug output.
//
void StringTable::DebugOut(void) const
{
    if (NULL != m_apLists)
    {
        TCHAR szListAddr[80];

        for (UINT i = 0; i < m_dwHashBuckets; i++)
        {
            StringCchPrintf(szListAddr, ARRAYSIZE(szListAddr), TEXT("[%08d] 0x%08X\r\n"), i, (DWORD)m_apLists[i]);
            OutputDebugString(szListAddr);
            if (NULL != m_apLists[i])
                m_apLists[i]->DebugOut();
        }
    }
}

#endif // DEBUG


//////////////////////////////////////////////////////////////////////////////
// Class "List" member functions.
//////////////////////////////////////////////////////////////////////////////

//
// Collision List constructor.
//
StringTable::List::List(void)
    : m_pHead(NULL),
      m_dwCount(0)
{
    // Do nothing.
}


//
// Collision List destructor.
//
StringTable::List::~List(void)
{
    Element *pNode = m_pHead;

    while(NULL != pNode)
    {
        //
        // Shift each node to the head and delete it.
        //
        m_pHead = m_pHead->m_pNext;
        delete pNode;
        pNode = m_pHead;
    }
}


//
// Add a text string to the List.
//
BOOL StringTable::List::Add(LPCTSTR pszText, BOOL bAllowDuplicates)
{
    BOOL bResult = FALSE;

    if (bAllowDuplicates || !Exists(pszText))
    {
        Element *pNewEle = new Element;
        if (pNewEle)
        {
            if (pNewEle->Initialize(pszText))
            {
                //
                // Insert at head of list.
                //
                pNewEle->m_pNext = m_pHead;
                m_pHead = pNewEle;
                m_dwCount++;
                bResult = TRUE;
            }
            else
            {
                delete pNewEle;
            }
        }
    }
    return bResult;
}


//
// Determine if a text string exists in the List.
//
BOOL StringTable::List::Exists(LPCTSTR pszText) const
{
    Element Key;
    Element *pNode = NULL;

    if (Key.Initialize(pszText))
    {
        pNode = m_pHead;
        while(NULL != pNode && *pNode != Key)
            pNode = pNode->m_pNext;
    }

    return (NULL != pNode);
}


#ifdef DEBUG
//
// Dump the List contents to the debug output.
//
void StringTable::List::DebugOut(void) const
{
    Element *pNode = m_pHead;
    UINT n = 0;
    TCHAR s[80];

    OutputDebugString(TEXT("List:\r\n"));
    while(NULL != pNode)
    {
        StringCchPrintf(s, ARRAYSIZE(s), TEXT("\tElement %d: "), n++);
        OutputDebugString(s);
        pNode->DebugOut();
        OutputDebugString(TEXT("\n"));
        pNode = pNode->m_pNext;
    }
}

#endif // DEBUG


//////////////////////////////////////////////////////////////////////////////
// Class "Element" member functions.
//////////////////////////////////////////////////////////////////////////////

//
// List element constructor.
//
StringTable::List::Element::Element(void)
    : m_pszText(NULL),
      m_pNext(NULL)
{
    // Do nothing.
}

//
// Delete a List element.
// Deletes the string buffer.
//
StringTable::List::Element::~Element(void)
{
    if (NULL != m_pszText)
        delete [] m_pszText;
}

//
// Initialize a new List element.
// Creates a new string buffer for the string and copies
// the string into it.
//
StringTable::List::Element::Initialize(LPCTSTR pszText)
{
    const size_t cchText = lstrlen(pszText) + 1;
    m_pszText = new TCHAR[cchText];
    if (NULL != m_pszText)
        StringCchCopy(m_pszText, cchText, pszText);

    return NULL != m_pszText;
}

//
// Determine if two elements are equal.
// If the strings are lexically equal, the elements are equal.
//
inline BOOL StringTable::List::Element::operator == (const Element& ele) const
{
    return (0 == lstrcmp(m_pszText, ele.m_pszText));
}

//
// Determine if two elements are not equal.
// If the strings are lexically not equal, the elements are not equal.
//
inline BOOL StringTable::List::Element::operator != (const Element& ele) const
{
    return !(operator == (ele));
}



#ifdef DEBUG

//
// Dump contents of List element to debug output.
//
void StringTable::List::Element::DebugOut(void) const
{
    OutputDebugString(m_pszText);
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\src\t1.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// t1.cpp
//      Explorer Font Folder extension routines
//
//
// History:
//      31 May 95 SteveCat
//          Ported to Windows NT and Unicode, cleaned up
//
//
// NOTE/BUGS
//
//  Copyright (C) 1992-1995 Microsoft Corporation
//
///////////////////////////////////////////////////////////////////////////////

//==========================================================================
//                              Include files
//==========================================================================
// C Runtime
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#include <windows.h>


// Application specific

#include "t1instal.h"

#include "priv.h"
#include "globals.h"
#include "fontcl.h"
#include "resource.h"
#include "ui.h"
#include "cpanel.h"
#include "fontman.h"


extern FullPathName_t  s_szSharedDir;

TCHAR c_szDescFormat[] = TEXT( "%s (%s)" );
TCHAR c_szPostScript[] = TEXT( "Type 1" );

TCHAR szFonts[] = TEXT( "fonts" );

TCHAR m_szMsgBuf[ PATHMAX ];

TCHAR szTTF[ ] = TEXT(".TTF");
TCHAR szFON[ ] = TEXT(".FON");
TCHAR szPFM[ ] = TEXT(".PFM");
TCHAR szPFB[ ] = TEXT(".PFB");

typedef void (__stdcall *PROGRESSPROC)( short, void *);

BOOL RegisterProgressClass( void );
VOID UnRegisterProgressClass( void );

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


//==========================================================================
//                        Local Definitions
//==========================================================================
#define GWL_PROGRESS    0
#define SET_PROGRESS    WM_USER

//  Progress Control color indices
#define PROGRESSCOLOR_FACE        0
#define PROGRESSCOLOR_ARROW       1
#define PROGRESSCOLOR_SHADOW      2
#define PROGRESSCOLOR_HIGHLIGHT   3
#define PROGRESSCOLOR_FRAME       4
#define PROGRESSCOLOR_WINDOW      5
#define PROGRESSCOLOR_BAR         6
#define PROGRESSCOLOR_TEXT        7

#define CCOLORS                   8

#define CHAR_BACKSLASH  TEXT( '\\' )
#define CHAR_COLON      TEXT( ':' )
#define CHAR_NULL       TEXT( '\0' )
#define CHAR_TRUE       TEXT( 'T' )
#define CHAR_FALSE      TEXT( 'F' )

//==========================================================================
//                       External Declarations
//==========================================================================

extern HWND  hLBoxInstalled;

//==========================================================================
//                       Local Data Declarations
//==========================================================================

BOOL bYesAll_PS = FALSE;        //  Use global state for all PS fonts
BOOL bConvertPS = TRUE;         //  Convert Type1 files to TT
BOOL bInstallPS = TRUE;         //  Install PS files
BOOL bCopyPS    = TRUE;         //  Copy PS files to Windows dir

BOOL bCancelInstall = FALSE;    // Global installation cancel

TCHAR szTrue[]  = TEXT( "T" );
TCHAR szFalse[] = TEXT( "F" );
TCHAR szHash[]  = TEXT( "#" );

BOOL bProgMsgDisplayed;         //  Used by Progress to avoid msg flicker
BOOL bProg2MsgDisplayed;        //  Used by Progress2 to avoid msg flicker

HWND hDlgProgress = NULL;

//
//  Used to determine Foreground/Backgnd colors for progress bar control
//  Global values are set at RegisterClass time
//

DWORD   rgbFG;
DWORD   rgbBG;

//  Registry location for installing PostScript printer font info

TCHAR g_szType1Key[] = TEXT( "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Type 1 Installer\\Type 1 Fonts" );

//
//  Array of default colors, matching the order of PROGRESSCOLOR_* values.
//

DWORD rgColorPro[ CCOLORS ] = {
                         COLOR_BTNFACE,             //  PROGRESSCOLOR_FACE
                         COLOR_BTNTEXT,             //  PROGRESSCOLOR_ARROW
                         COLOR_BTNSHADOW,           //  PROGRESSCOLOR_SHADOW
                         COLOR_BTNHIGHLIGHT,        //  PROGRESSCOLOR_HIGHLIGHT
                         COLOR_WINDOWFRAME,         //  PROGRESSCOLOR_FRAME
                         COLOR_WINDOW,              //  PROGRESSCOLOR_WINDOW
                         COLOR_ACTIVECAPTION,       //  PROGRESSCOLOR_BAR
                         COLOR_CAPTIONTEXT          //  PROGRESSCOLOR_TEXT
                         };

typedef struct _T1_INSTALL_OPTIONS
{
    BOOL        bMatchingTT;
    BOOL        bOnlyPSInstalled;
    LPTSTR      szDesc;
    WORD        wFontType;
} T1_INSTALL_OPTIONS, *PT1_INSTALL_OPTIONS;

//
//  Linked-list structure used for copyright Vendors
//

typedef struct _psvendor
{
    struct _psvendor *pNext;
    LPTSTR pszCopyright;            //  Copyright string
    int    iResponse;               //  User's response to YES/NO MsgBox
} PSVENDOR;

PSVENDOR *pFirstVendor = NULL;      //  ptr to linked list for PS vendors

//==========================================================================
//                      Local Function Prototypes
//==========================================================================

BOOL CheckTTInstall( LPTSTR szDesc );
INT_PTR APIENTRY InstallPSDlg( HWND hDlg, UINT nMsg, WPARAM wParam, LPARAM lParam );
void STDCALL  Progress( short PercentDone, void* UniqueValue );
LRESULT APIENTRY ProgressBarCtlProc( HWND hTest, UINT message, WPARAM wParam, LPARAM lParam );
INT_PTR APIENTRY ProgressDlg( HWND hDlg, UINT nMsg, WPARAM wParam, LPARAM lParam );
INT_PTR APIENTRY CopyrightNotifyDlgProc( HWND hDlg, UINT nMsg, WPARAM wParam, LPARAM lParam );
LONG ProgressPaint( HWND hWnd, DWORD dwProgress );


//==========================================================================
//                           Functions
//==========================================================================

/////////////////////////////////////////////////////////////////////////////
//
// StripFilespec
//
//   Remove the filespec portion from a path (including the backslash).
//
/////////////////////////////////////////////////////////////////////////////

VOID StripFilespec( LPTSTR lpszPath )
{
   LPTSTR     p;

   p = lpszPath + lstrlen( lpszPath );

   while( ( *p != CHAR_BACKSLASH )  && ( *p != CHAR_COLON )  && ( p != lpszPath ) )
      p--;

   if( *p == CHAR_COLON )
      p++;

   //
   //  Don't strip backslash from root directory entry.
   //

   if( p != lpszPath )
   {
      if( ( *p == CHAR_BACKSLASH )  && ( *( p - 1 )  == CHAR_COLON ) )
         p++;
   }

   *p = CHAR_NULL;
}


/////////////////////////////////////////////////////////////////////////////
//
// StripPath
//
//   Extract only the filespec portion from a path.
//
/////////////////////////////////////////////////////////////////////////////

VOID StripPath( LPTSTR lpszPath )
{
  LPTSTR     p;

  const size_t cchPath = lstrlen(lpszPath);

  p = lpszPath + cchPath;

  while( ( *p != CHAR_BACKSLASH )  && ( *p != CHAR_COLON )  && ( p != lpszPath ) )
      p--;

  if( p != lpszPath )
      p++;

  if( p != lpszPath )
      StringCchCopy( lpszPath, cchPath + 1, p );
}


/////////////////////////////////////////////////////////////////////////////
//
// AddVendorCopyright
//
//  Add a PostScript Vendor's Copyright and User response to "MAYBE" list.
//  This linked-list is used to keep track of a user's prior response to
//  message about converting this vendor's fonts to TrueType.  If a vendor
//  is not in the registry, we cannot automatically assume that the font
//  can be converted.  We must present the User with a message, asking them
//  to get permission from the vendor before converting the font to TrueType.
//
//  However, we do allow them to continue the installation and convert the
//  font to TrueType by selecting the YES button on the Message box.  This
//  routine keeps track of each vendor and the User's response for that
//  vendor.  This way we do not continually ask them about the same vendor
//  during installation of a large number of fonts.
//
//  (Insert item into linked list )
//
//
/////////////////////////////////////////////////////////////////////////////

BOOL AddVendorCopyright( LPTSTR pszCopyright, int iResponse )
{
    PSVENDOR *pVendor;          //  temp pointer to linked list


    //
    //  Make the new PSVENDOR node and add it to the linked list.
    //

    if( pFirstVendor )
    {
        pVendor = (PSVENDOR *) AllocMem( sizeof( PSVENDOR ) );

        if( pVendor )
        {
            pVendor->pNext = pFirstVendor;
            pFirstVendor = pVendor;
        }
        else
            return FALSE;
    }
    else        // First time thru
    {
        pFirstVendor = (PSVENDOR *) AllocMem( sizeof( PSVENDOR ) );

        if( pFirstVendor )
            pFirstVendor->pNext = NULL;
        else
            return FALSE;
    }

    //
    //  Save User response and Copyright string
    //

    pFirstVendor->iResponse = iResponse;

    pFirstVendor->pszCopyright = AllocStr( pszCopyright );

    //
    //  Return success.
    //

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
//
// CheckVendorCopyright
//
//  Check if a Vendor Copyright is already in the "MAYBE" linked-list and
//  and return User response if it is found.
//
//  Returns:
//          IDYES  - User wants to convert typeface anyway
//          IDNO   - User does not want to convert typeface
//          -1     - Entry not found
//
/////////////////////////////////////////////////////////////////////////////

int CheckVendorCopyright( LPTSTR pszCopyright )
{
    PSVENDOR *pVendor;          // temp pointer to linked list

    //
    //  Traverse the list, testing each node for matching copyright string
    //

    pVendor = pFirstVendor;

    while( pVendor )
    {
        if( !lstrcmpi( pVendor->pszCopyright, pszCopyright ) )
            return( pVendor->iResponse );

        pVendor = pVendor->pNext;
    }

    //
    //  "Did not find matching copyright" return
    //

    return( -1 );
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: CopyrightNotifyDlgProc
//
// DESCRIP:  Display the dialog informing the user about possible
//           Type1 font copyright problems.
//
// ARGS:     lParam is the address of an array of text string pointers.
//           Element 0 is the name of the font.
//           Element 1 is the name of the vendor.
//
///////////////////////////////////////////////////////////////////////////////
enum arg_nums{ARG_FONTNAME = 0, ARG_VENDORNAME};
INT_PTR APIENTRY CopyrightNotifyDlgProc( HWND hDlg, UINT nMsg, WPARAM wParam, LPARAM lParam )
{

    switch( nMsg )
    {
        case WM_INITDIALOG:
        {
            LPCTSTR *lpaszTextItems   = (LPCTSTR *)lParam;
            LPCTSTR lpszVendorName    = NULL;
            TCHAR szUnknownVendor[80] = { TEXT('\0') };

            ASSERT(NULL != lpaszTextItems);
            ASSERT(NULL != lpaszTextItems[ARG_FONTNAME]);
            ASSERT(NULL != lpaszTextItems[ARG_VENDORNAME]);

            //
            // Set font name string.
            //
            SetWindowText(GetDlgItem(hDlg, IDC_COPYRIGHT_FONTNAME),
                                           lpaszTextItems[ARG_FONTNAME]);

            //
            // Set vendor name string.  If name provided is blank, use a default
            // string of "Unknown Vendor Name" from string table.
            //
            if (TEXT('\0') == *lpaszTextItems[ARG_VENDORNAME])
            {
                UINT cchLoaded = 0;
                cchLoaded = LoadString(g_hInst, IDSI_UNKNOWN_VENDOR,
                                       szUnknownVendor, ARRAYSIZE(szUnknownVendor));

                ASSERT(cchLoaded > 0); // Complain if someone removed resource string.

                lpszVendorName = szUnknownVendor;
            }
            else
                lpszVendorName = lpaszTextItems[ARG_VENDORNAME];

            SetWindowText(GetDlgItem(hDlg, IDC_COPYRIGHT_VENDORNAME), lpszVendorName),
            CentreWindow( hDlg );
            break;
        }

    case WM_COMMAND:
        switch( LOWORD( wParam ) )
        {
            case IDYES:
            case IDNO:
                //
                // Dialog Proc must return IDYES or IDNO when a button
                // is selected.  This is the value stored in the Vendor Copyright
                // list.
                //
                EndDialog(hDlg, LOWORD(wParam));
                break;
            default:
                return FALSE;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

//
// OkToConvertType1ToTrueType
//
// This function checks the authorization for converting a Type1
// font to it's TrueType equivalent.  Authorization information is stored
// in the registry under the section ...\Type 1 Installer\Copyrights.
//
// If authorization is GRANTED, the function returns TRUE and the font may be
// converted to TrueType.
//
// If authorization is explicitly DENIED and the user has not selected
// "Yes to All" in the Type1 options dialog, a message box is displayed
// informing the user of the denial and the function returns FALSE
//
// If no authorization information is found in the registry for this vendor,
// a dialog box is displayed warning the user about possible copyright
// violations.  The user can answer Yes to convert the font anyway or No
// to skip the conversion.  This response is stored in memory on a per-vendor
// basis so that the user won't have to respond to this same question if
// a font from this vendor is encountered again.
//
BOOL OkToConvertType1ToTrueType(LPCTSTR pszFontDesc, LPCTSTR pszPFB, HWND hwndParent)
{
    char    szCopyrightA[MAX_PATH]; // For string from Type1 (ANSI) file.
    WCHAR   szCopyrightW[MAX_PATH]; // For display in UNICODE build.
    char    szPfbA[MAX_PATH];       // For arg to CheckCopyrightA (ANSI).
    LPTSTR  pszCopyright = NULL;    // Ptr to Copyright string (A or W).
    LPSTR   pszPfbA      = NULL;    // Ptr to ANSI PFB filename string.
    DWORD   dwStatus     = 0;       // Temp result variable.
    BOOL    bResult      = FALSE;   // Function return value.

    //
    //  Check convertability of this font from Type1 to TrueType.
    //
    //  Returns: SUCCESS, FAILURE, MAYBE
    //
    WideCharToMultiByte(CP_ACP, 0, pszPFB, -1, szPfbA, ARRAYSIZE(szPfbA), NULL, NULL);
    pszPfbA = szPfbA;

    dwStatus = CheckCopyrightA(pszPfbA, ARRAYSIZE(szCopyrightA), szCopyrightA);
    if (SUCCESS == dwStatus)
    {
        bResult = TRUE;
    }
    else
    {
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szCopyrightA, -1,
                                         szCopyrightW, ARRAYSIZE(szCopyrightW));
        pszCopyright = szCopyrightW;
        switch(dwStatus)
        {

            case FAILURE:

                //
                //  Put up a message box stating that this Type1 font vendor
                //  does not allow us to Convert their fonts to TT.  This will
                //  let the user know that it is not Microsoft's fault that the
                //  font is not converted to TT, but the vendor's fault.
                //
                //  NOTE:  This is only done if the User has NOT selected the
                //         YesToAll_PS install option.  Otherwise it will be very
                //         annoying to see message repeated over and over.
                //
                if (!bYesAll_PS)
                {

                    iUIMsgBox( hwndParent,
                               MYFONT + 2, IDS_MSG_CAPTION,
                               MB_OK | MB_ICONEXCLAMATION,
                               (LPTSTR)  pszCopyright,
                               (LPTSTR)  pszFontDesc );
                }
                break;

            case MAYBE:
                //
                //  Check font copyright and ask for user response if necessary
                //
                switch(CheckVendorCopyright(pszCopyright))
                {
                    case IDYES:
                        //
                        // User previously responded "Yes" for converting fonts
                        // from this vendor.  Automatic approval.
                        //
                        bResult = TRUE;
                        break;

                    case IDNO:
                        //
                        // User previously responded "No" for converting fonts
                        // from this vendor.  Automatic denial.
                        //
                        bResult = FALSE;
                        break;

                    case -1:
                    default:
                    {
                        //
                        // No previous record of having asked user about this vendor.
                        //
                        INT iResponse = IDNO;

                        //
                        // Warn user about possible copyright problems.
                        // Ask if they want to convert to TrueType anyway.
                        //
                        LPCTSTR lpszDlgTextItems[] = {pszFontDesc, pszCopyright};

                        iResponse = (INT)DialogBoxParam(g_hInst,
                                                   MAKEINTRESOURCE(DLG_COPYRIGHT_NOTIFY),
                                                   hwndParent ? hwndParent : HWND_DESKTOP,
                                                   CopyrightNotifyDlgProc,
                                                   (LPARAM)lpszDlgTextItems);
                        //
                        // Remember this response for this vendor.
                        //
                        AddVendorCopyright(pszCopyright, iResponse);

                        //
                        // Translate user response to a T/F return value.
                        //
                        bResult = (iResponse == IDYES);

                        break;
                    }
                }
                break;

            default:
                //
                //  ERROR! from routine - assume worst case
                //
                break;
        }
    }
    return bResult;
}



/////////////////////////////////////////////////////////////////////////////
//
// IsPSFont
//
//  Check validity of font file passed in and get paths to .pfm/.pfb
//  files, determine if it can be converted to TT.
//
// in:
//    lpszPfm        .pfm file name to validate
// out:
//    lpszDesc       on succes Font Name of Type1
//    lpszPfm        on succes the path to .pfm file
//    lpszPfb        on succes the path to .pfb file
//    pbCreatedPFM   on succes whether a PFM file was created or not
//                   If valid pointer on entry...
//                   *bpCreatedPFM == TRUE means check for existing PFM.
//                                    FALSE means don't check for PFM.
//    lpdwStatus     Address of caller status variable.  Use this value
//                   to determine cause of FALSE return value.
//
// NOTE: Assumes that lpszPfm and lpszPfb are of size PATHMAX & lpszDesc is
//       of size DESCMAX
//
// returns:
//    TRUE success, FALSE failure
//
// The following table lists the possible font verification status codes
// returned in *lpdwStatus along with a brief description of the cause for each.
// See fvscodes.h for numeric code value details.
//
//
//          FVS_SUCCESS
//          FVS_FILE_OPEN_ERR
//          FVS_BUILD_ERR
//          FVS_FILE_EXISTS
//          FVS_INSUFFICIENT_BUF
//          FVS_INVALID_FONTFILE
//          FVS_BAD_VERSION
//          FVS_FILE_IO_ERR
//          FVS_EXCEPTION
//
/////////////////////////////////////////////////////////////////////////////

BOOL IsPSFont( LPTSTR lpszKey,
               LPTSTR lpszDesc,         //  Optional
               size_t cchDesc,
               LPTSTR lpszPfm,          //  Optional
               size_t cchPfm,
               LPTSTR lpszPfb,          //  Optional
               size_t cchPfb,
               BOOL  *pbCreatedPFM,     //  Optional
               LPDWORD lpdwStatus )     //  May be NULL
{
    BOOL    bRet = FALSE;
    TCHAR   strbuf[ PATHMAX ] ;
    BOOL    bPFM;

    //
    //  ANSI buffers for use with ANSI only API's
    //

    char    *desc, Descbuf[ PATHMAX ] ;
    char    Keybuf[ PATHMAX ] ;
    char    *pfb, Pfbbuf[ PATHMAX ] ;
    char    *pfm, Pfmbuf[ PATHMAX ] ;
    DWORD   iDesc, iPfb, iPfm;
    DWORD   dwStatus = FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);

    //
    // Initialize status return.
    //
    if (NULL != lpdwStatus)
        *lpdwStatus = FVS_MAKE_CODE(FVS_INVALID_STATUS, FVS_FILE_UNK);


    if( lpszDesc )
        *lpszDesc = (TCHAR)  0;

    desc = Descbuf;
    iDesc = ARRAYSIZE(Descbuf);

    pfb = Pfbbuf;
    iPfb = ARRAYSIZE(Pfbbuf);

    if( lpszPfm )
    {
        pfm = Pfmbuf;
        iPfm = ARRAYSIZE(Pfmbuf);
    }
    else
    {
        pfm = NULL;
        iPfm = 0;
    }

    if( pbCreatedPFM )
    {
        bPFM = *pbCreatedPFM;  // Caller says if CheckType1WithStatusA checks for dup PFM
        *pbCreatedPFM = FALSE;
    }
    else
        bPFM = TRUE;  // By default, CheckType1WithStatusA should check for dup PFM.

    WideCharToMultiByte( CP_ACP, 0, lpszKey, -1, Keybuf, ARRAYSIZE(Keybuf), NULL, NULL );

    //
    //  The CheckType1WithStatusA routine accepts either a .INF or .PFM file name as
    //  the Keybuf( i.e. Key file )   input parameter.  If the input is a .INF
    //  file, a .PFM file will be created in the SYSTEM directory if (and
    //  only if) the .PFM file name parameter is non-NULL.  Otherwise, it
    //  will just check to see if a valid .INF, .AFM and .PFB file exist for
    //  the font.
    //
    //  The bPFM BOOL value is an output parameter that tells me if the routine
    //  created a .PFM file from the .INF/.AFM file for this font.  If the
    //  pfm input parameter is non-NULL, it will always receive the proper
    //  path for the .PFM file.
    //
    //  The bPFM flag is used to tell CheckType1WithStatusA if it should check for an
    //  existing PFM file.  If invoked as part of a drag-drop install, we
    //  don't want to do this check.  If from install dialog, do the check.
    //


    char szFontsDirA[MAX_PATH] = {0};
    SHGetSpecialFolderPathA(NULL, szFontsDirA, CSIDL_FONTS, FALSE);
    
    dwStatus = ::CheckType1WithStatusA( Keybuf, iDesc, desc, iPfm, pfm, iPfb, pfb, &bPFM, szFontsDirA );

    if( FVS_STATUS(dwStatus) == FVS_SUCCESS)
    {
        if( pbCreatedPFM )
            *pbCreatedPFM = bPFM;

        //
        //  Return Font description
        //

        if( lpszDesc )
        {
            //
            //  Convert Descbuf to UNICODE since Type1 files are ANSI
            //
            MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, Descbuf, -1, strbuf, ARRAYSIZE(strbuf) );
            vCPStripBlanks(strbuf, ARRAYSIZE(strbuf));
            StringCchPrintf(lpszDesc, cchDesc, c_szDescFormat, strbuf, c_szPostScript );
        }

        //
        //  Return PFM file name
        //

        if( lpszPfm )
        {
            //
            //  Return PFM file name - convert to UNICODE since Type1 files are ANSI
            //
            MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, Pfmbuf, -1, lpszPfm, cchPfm );
        }

        //
        //  Return PFB file name
        //

        if( lpszPfb )
        {
            //
            //  Return PFB file name - convert to UNICODE since Type1 files are ANSI
            //
            MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, Pfbbuf, -1, lpszPfb, cchPfb );
        }

        bRet = TRUE;
    }

    //
    // Return status if user wants it.
    //
    if (NULL != lpdwStatus)
       *lpdwStatus = dwStatus;

    return bRet;
}


/////////////////////////////////////////////////////////////////////////////
//
// InitPSInstall
//
//  Initialize PostScript install routine global variables.
//
/////////////////////////////////////////////////////////////////////////////

void InitPSInstall( )
{
    CFontManager *poFontManager;
    if (SUCCEEDED(GetFontManager(&poFontManager)))
    {
        //
        //  Initialize linked list variables for "MAYBE" copyright vendor list
        //
        pFirstVendor = NULL;

        //
        //  Other installation globals
        //

        bYesAll_PS = FALSE;

        //
        // If the native ATM driver is installed, we NEVER convert from Type1 to
        // TrueType.
        //
        bConvertPS = !poFontManager->Type1FontDriverInstalled();

        bInstallPS = TRUE;
        bCopyPS    = TRUE;
        ReleaseFontManager(&poFontManager);
    }        

    return;
}


/////////////////////////////////////////////////////////////////////////////
//
// TermPSInstall
//
//  Initialize PostScript install routine global variables.
//
/////////////////////////////////////////////////////////////////////////////

void TermPSInstall( )
{

    PSVENDOR *pVendor;

    //
    //  Traverse the list, freeing list memory and strings.
    //

    pVendor = pFirstVendor;

    while( pVendor )
    {
        pFirstVendor = pVendor;
        pVendor = pVendor->pNext;

        if( pFirstVendor->pszCopyright )
            FreeStr( pFirstVendor->pszCopyright );

        FreeMem( (LPVOID)  pFirstVendor, sizeof( PSVENDOR ) );
    }

    //
    //  Reset global to be safe
    //

    pFirstVendor = NULL;

    return;
}



/////////////////////////////////////////////////////////////////////////////
//
// InstallT1Font
//
//  Install PostScript Type1 font, possibly converting the Type1 font to a
//  TrueType font in the process.  Write registry entries so the PostScript
//  printer driver can find these files either in their original source
//  directory or locally in the 'shared' or system directory.
//
/////////////////////////////////////////////////////////////////////////////

int InstallT1Font( HWND   hwndParent,
                   BOOL   bCopyTTFile,          //  Copy TT file?
                   BOOL   bCopyType1Files,      //  Copy PFM/PFB to font folder?
                   BOOL   bInSharedDir,         //  Files in Shared Directory?
                   LPTSTR szKeyName,            //  IN: PFM/INF Source File name & dir
                                                //  OUT: Destination file name
                   size_t cchKeyName,
                   LPTSTR szDesc,               //  INOUT: Font description
                   size_t cchDesc)

{
    WORD   wFontType = NOT_TT_OR_T1;            //  Enumerated Font type
    int    rc, iRet;
    WORD   wMsg;
    BOOL   bCreatedPfm = FALSE;  // F = IsPSFont doesn't check for existing PFM

    TCHAR  szTemp[    PATHMAX ] ;
    TCHAR  szTemp2[   PATHMAX ] ;
    TCHAR  szPfbName[ PATHMAX ] ;
    TCHAR  szPfmName[ PATHMAX ] ;
    TCHAR  szSrcDir[  PATHMAX ] ;
    TCHAR  szDstName[ PATHMAX ] ;
    TCHAR  szTTFName[ PATHMAX ] ;
    TCHAR  *pszArg1, *pszArg2;

    T1_INSTALL_OPTIONS t1ops;

    //
    //  ASCII Buffers for use in ASCII-only api calls
    //

    char  pfb[ PATHMAX ] ;
    char  pfm[ PATHMAX ] ;
    char  ttf[ PATHMAX ] ;

    DWORD dwStatus = FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);


    //////////////////////////////////////////////////////////////////////
    //
    //  Check if font is already loaded on the system
    //
    //////////////////////////////////////////////////////////////////////

    t1ops.bOnlyPSInstalled = FALSE;
    t1ops.bMatchingTT      = FALSE;

    //
    //  Check both Type1 & Fonts registry location for prior font installation
    //

    if( CheckT1Install( szDesc, NULL, 0 ) )
    {
        //
        // "Font is already loaded"
        //
        iRet = iUIMsgOkCancelExclaim( hwndParent,
                                      MYFONT + 5,
                                      IDS_MSG_CAPTION,
                                      (LPTSTR)szDesc);
        //
        // Return without deleting the PFM file.
        // Because this font is a duplicate, the PFM
        // already existed.
        //
        goto MasterExit;
    }
    else if( CheckTTInstall( szDesc ) )
    {
        t1ops.bMatchingTT = TRUE;

        if( !bYesAll_PS )
        {
            //
            // "The TrueType version of this font is already installed."
            //

            switch( iUIMsgBox( hwndParent,
                               MYFONT + 4, IDS_MSG_CAPTION,
                               MB_YESNOCANCEL | MB_ICONEXCLAMATION,
                               (LPTSTR) szDesc ) )
            {
            case IDYES:
                break;

            case IDNO:
                iRet = TYPE1_INSTALL_IDNO;
                goto InstallPSFailure;

            case IDCANCEL:
            default:
                iRet = TYPE1_INSTALL_IDCANCEL;
                goto InstallPSFailure;
            }
        }
    }

    //
    // WARNING [brianau]
    // If we're installing from a .INF/.AFM pair, this function automatically
    // creates a new .PFM file in the fonts directory, even if the .PFM file
    // already exists.  This could cause a possible file mismatch between an
    // existing .PFB and the new .PFM.
    //
    if(::IsPSFont( szKeyName, (LPTSTR) NULL, 0, szPfmName, ARRAYSIZE(szPfmName), szPfbName, ARRAYSIZE(szPfbName),
                     &bCreatedPfm, &dwStatus ))
    {
        CFontManager *poFontManager;
        if (SUCCEEDED(GetFontManager(&poFontManager)))
        {
            wFontType = TYPE1_FONT;

            StringCchCopy(szTemp, ARRAYSIZE(szTemp), szDesc);
            RemoveDecoration(szTemp, TRUE);
            if (poFontManager->Type1FontDriverInstalled() ||
                !OkToConvertType1ToTrueType(szTemp,
                                            szPfbName,
                                            hwndParent))
            {
                wFontType = TYPE1_FONT_NC;
            }
            ReleaseFontManager(&poFontManager);
        }
    }
    else
    {
        if (iUIMsgBoxInvalidFont(hwndParent, szKeyName, szDesc, dwStatus) == IDCANCEL)
           iRet = TYPE1_INSTALL_IDCANCEL;
        else
           iRet = TYPE1_INSTALL_IDNO;
        goto InstallPSFailure;
    }

    t1ops.szDesc = szDesc;
    t1ops.wFontType = wFontType;

    //
    //  Keep a copy of source directory
    //

    StringCchCopy( szSrcDir, ARRAYSIZE(szSrcDir), szKeyName );

    StripFilespec( szSrcDir );

    lpCPBackSlashTerm( szSrcDir, ARRAYSIZE(szSrcDir) );
    //
    //  The global state of
    //
    //      bConvertPS  -  Convert Type1 files to TT
    //      bInstallPS  -  Install PS files
    //
    //  is only effective for the last time the "Install Type 1 fonts"
    //  dialog was displayed.  Check the state of these globals against
    //  what we know about the current font to determine if the dialog
    //  should be redisplayed.
    //
    //  5/31/94 [stevecat] DO NOT redisplay the dialog after "YesToAll"
    //  selected once.  Instead, display messages about 'exceptions' to
    //  their initial choices and give user the option to continue
    //  installation.
    //

    if( bYesAll_PS )
    {
        //
        //  If the PS version of this font is already installed AND the
        //  global bInstall == TRUE, then the globals are out-of-sync
        //  with this font.  Let user know and continue installation.
        //

        if( t1ops.bOnlyPSInstalled && bInstallPS )
        {
            //
            // "The Type 1 version of this font is already installed."
            //

            switch( iUIMsgBox( hwndParent,
                               MYFONT + 3, IDS_MSG_CAPTION,
                               MB_YESNOCANCEL | MB_ICONEXCLAMATION,
                               (LPTSTR) szDesc ) )
            {
            case IDYES:
                break;

            case IDNO:
                iRet = TYPE1_INSTALL_IDNO;
                goto InstallPSFailure;

            case IDCANCEL:
            default:
                iRet = TYPE1_INSTALL_IDCANCEL;
                goto InstallPSFailure;
            }
        }

        //
        //  If the matching TT font is already installed AND the global
        //  bConvertPS == TRUE, then the globals are out-of-sync with
        //  this font.  Let the user know and continue installation.
        //

        if( t1ops.bMatchingTT && bConvertPS )
        {
            //
            // "The TrueType version of this font is already installed."
            //

            switch( iUIMsgBox( hwndParent,
                               MYFONT + 4, IDS_MSG_CAPTION,
                               MB_YESNOCANCEL | MB_ICONEXCLAMATION,
                               (LPTSTR) szDesc ) )
            {
            case IDYES:
                break;

            case IDNO:
                iRet = TYPE1_INSTALL_IDNO;
                goto InstallPSFailure;

            case IDCANCEL:
            default:
                iRet = TYPE1_INSTALL_IDCANCEL;
                goto InstallPSFailure;
            }
        }
    }

    //
    // These values were originally set in the Type1 installation dialog.
    // That code was disabled in 5/97 and removed in 2/02.
    // Now that this dialog has been removed, we hard code the values.
    // [brianau 2/4/02]
    //
    bInstallPS = TRUE;             // Always install the font.
    bConvertPS = FALSE;            // Never convert Type1 to TrueType.
    bCopyPS    = bCopyType1Files;

    //
    // szDstName should already have the full source file name
    //
    //  Only convert the Type1 font to TT if:
    //
    //  a)  The user asked us to do it;
    //  b)  The font can be converted, AND;
    //  c)  There is not a matching TT font already installed
    //
    if( bConvertPS && ( wFontType != TYPE1_FONT_NC )  && !t1ops.bMatchingTT )
    {
        //////////////////////////////////////////////////////////////////
        // Convert Type1 files to TrueType
        //
        // Copy converted TT file, if necessary, to "fonts" directory
        //
        // NOTE: We are using the ConvertTypeface api to do the copying
        //       and it is an ASCII only api.
        //////////////////////////////////////////////////////////////////

        //
        //  Create destination name with .ttf
        //

        StringCchCopy( szTemp, ARRAYSIZE(szTemp), szPfmName );
        StripPath( szTemp );
        PathRenameExtension( szTemp, szTTF );

        //
        //  Build destination file pathname based on bCopyTTFile
        //

        if( bCopyTTFile || bInSharedDir )
        {
            //
            //  Copy file to local directory
            //

            StringCchCopy( szDstName, ARRAYSIZE(szDstName), s_szSharedDir );
        }
        else
        {
            //
            //  Create converted file in source directory
            //

            StringCchCopy( szDstName, ARRAYSIZE(szDstName), szSrcDir );
        }

        //
        //  Check new filename for uniqueness
        //

        if( !(bUniqueFilename( szTemp, ARRAYSIZE(szTemp), szTemp, szDstName ) ) )
        {
            iRet = iUIMsgOkCancelExclaim( hwndParent, IDSI_FMT_BADINSTALL,
                                          IDSI_CAP_NOCREATE, szDesc );
            goto InstallPSFailure;
        }

        StringCchCat( szDstName, ARRAYSIZE(szDstName), szTemp );

        //
        //  Save destination filename for return to caller
        //
        StringCchCopy( szTTFName, ARRAYSIZE(szTTFName), szDstName );

        //
        //  We will convert and copy the Type1 font in the same api
        //

        WideCharToMultiByte( CP_ACP, 0, szPfbName, -1, pfb,
                                ARRAYSIZE(pfb), NULL, NULL );

        WideCharToMultiByte( CP_ACP, 0, szPfmName, -1, pfm,
                                ARRAYSIZE(pfm), NULL, NULL );

        WideCharToMultiByte( CP_ACP, 0, szDstName, -1, ttf,
                                ARRAYSIZE(ttf), NULL, NULL );

        ResetProgress( );

        //
        //  Remove "PostScript" postfix string from description
        //

        RemoveDecoration( szDesc, TRUE );

        if( (rc = (int) ::ConvertTypefaceA( pfb, pfm, ttf,
                                            (PROGRESSPROC) Progress,
                                            (void *) szDesc ) ) < 0 )
        {
            pszArg1 = szPfmName;
            pszArg2 = szPfbName;

            switch( rc )
            {
            case ARGSTACK:
            case TTSTACK:
            case NOMEM:
                wMsg = INSTALL3;
                break;

            case NOMETRICS:
            case BADMETRICS:
            case UNSUPPORTEDFORMAT:
                //
                //  Something is wrong with the .pfm metrics file
                //

                pszArg1 = szDstName;
                pszArg2 = szPfmName;
                wMsg = MYFONT + 13;
                break;

            case BADT1HYBRID:
            case BADT1HEADER:
            case BADCHARSTRING:
            case NOCOPYRIGHT:
                //
                //  Bad .pfb input file - format, or corruption
                //

                pszArg1 = szDstName;
                pszArg2 = szPfbName;
                wMsg = MYFONT + 14;
                break;

            case BADINPUTFILE:
                //
                //  Bad input file names, or formats or file errors
                //  or file read errors
                //

                pszArg1 = szDstName;
                pszArg2 = szPfbName;
                wMsg = MYFONT + 15;
                break;

            case BADOUTPUTFILE:
                //
                //  No diskspace for copy, read-only share, etc.
                //

                pszArg1 = szDstName;
                wMsg = MYFONT + 16;
                break;

            default:
                //
                //  Cannot convert szDesc to TrueType - general failure
                //

                pszArg1 = szDstName;
                pszArg2 = szDesc;
                wMsg = MYFONT + 17;
                break;
            }

            iRet = iUIMsgBox( hwndParent, wMsg, IDS_MSG_CAPTION,
                              MB_OKCANCEL | MB_ICONEXCLAMATION,
                              pszArg1, pszArg2, szPfmName );

            goto InstallPSFailure;
        }

        //
        //  Change font description to have "TrueType" now
        //

        StringCchPrintf( szDesc, cchDesc, c_szDescFormat, szDesc, c_szTrueType );
    }

    iRet = TYPE1_INSTALL_IDNO;

    if( bInstallPS && !t1ops.bOnlyPSInstalled )
    {
        //
        //  Remove "PostScript" postfix string from description
        //

        StringCchCopy( szTemp2, ARRAYSIZE(szTemp2), szDesc );
        RemoveDecoration( szTemp2, TRUE );

        //
        //  Now reset per font install progress
        //

        ResetProgress( );
        Progress2( 0, szTemp2 );


        //
        //  Only copy the files if the User asked us to AND they are NOT
        //  already in the Shared directory.
        //

        if( bCopyPS && !bInSharedDir )
        {
            //
            //  Copy file progress
            //

            Progress2( 10, szTemp2 );

            /////////////////////////////////////////////////////////////////
            // COPY files to "fonts" directory
            /////////////////////////////////////////////////////////////////

            //
            //  For .inf/.afm file install::  Check .pfm pathname to see if
            //  it is the same as the destination file pathname we built.
            //  Make this check before we test/create a UniqueFilename.
            //

            //  Build Destination file pathname for .PFM file

            StringCchPrintf( szDstName, ARRAYSIZE(szDstName), TEXT("%s%s"), s_szSharedDir, PathFindFileName(szPfmName));

            //
            //  Check to see if the .pfm file already exists in the "fonts"
            //  directory.  If it does, then just copy the .pfb over.
            //

            if( !lstrcmpi( szPfmName, szDstName ) )
                goto CopyPfbFile;

            //
            //  Setup args for bCPInstallFile call
            //

            StripPath( szDstName );
            StripPath( szPfmName );

            if( !(bUniqueOnSharedDir( szDstName, ARRAYSIZE(szDstName), szDstName ) ) )
            {
                iRet = iUIMsgOkCancelExclaim( hwndParent, IDSI_FMT_BADINSTALL,
                                              IDSI_CAP_NOCREATE, szDesc );
                goto InstallPSFailure;
            }

            if( !bCPInstallFile( hwndParent, szSrcDir, szPfmName, szDstName ) )
                goto InstallPSFailure;

CopyPfbFile:

            //
            //  Copying pfm file was small portion of install
            //

            Progress2( 30, szTemp2 );

            //
            //  Setup and copy .PFB file
            //
            //  Setup args for bCPInstallFile call
            //

            StringCchCopy(szSrcDir, ARRAYSIZE(szSrcDir), szPfbName);  // Prepare src directory name.
            StripFilespec( szSrcDir );
            lpCPBackSlashTerm( szSrcDir, ARRAYSIZE(szSrcDir) );

            StripPath( szPfbName );
            StringCchCopy( szDstName, ARRAYSIZE(szDstName), szPfbName );

            if( !(bUniqueOnSharedDir( szDstName, ARRAYSIZE(szDstName), szDstName ) ) )
            {
                iRet = iUIMsgOkCancelExclaim( hwndParent, IDSI_FMT_BADINSTALL,
                                              IDSI_CAP_NOCREATE, szDesc );
                goto InstallPSFailure;
            }

            if( !bCPInstallFile( hwndParent, szSrcDir, szPfbName, szDstName ) )
                goto InstallPSFailure;
        }

        //
        //  Copying pfb file was large portion of install
        //

        Progress2( 85, szTemp2 );

        //
        //  Write registry entry to "install" font for use by the
        //  PostScript driver, but only after successfully copying
        //  files (if copy was necessary).
        //
        //  NOTE:  This routine will strip the path off of the filenames
        //         if they are in the Fonts dir.
        //

        iRet = WriteType1RegistryEntry( hwndParent, szDesc, szPfmName, szPfbName, bCopyPS );

        //
        // If the Type1 font driver is installed,
        // add the Type1 font resource to GDI.
        //
        {
            CFontManager *poFontManager;
            if (SUCCEEDED(GetFontManager(&poFontManager)))
            {
                if (poFontManager->Type1FontDriverInstalled())
                {
                    TCHAR szType1FontResourceName[MAX_TYPE1_FONT_RESOURCE];

                    if (BuildType1FontResourceName(szPfmName,
                                                   szPfbName,
                                                   szType1FontResourceName,
                                                   ARRAYSIZE(szType1FontResourceName)))
                    {
                        AddFontResource(szType1FontResourceName);
                    }
                }
                ReleaseFontManager(&poFontManager);
            }
        }

        //
        //  No need to add to internal font list here.  It is added in the calling
        //  code (bAddSelFonts or CPDropInstall).
        //

        //
        //  Final registry write completes install, except for listbox munging.
        //  Note that TrueType file install is handled separately.
        //

        Progress2( 100, szTemp2 );
    }

    //
    //  Determine correct return code based on installation options and
    //  current installed state of font.
    //

    if( bConvertPS && ( wFontType != TYPE1_FONT_NC ) )
    {
        //
        //  Handle the special case of when the matching TTF font is already
        //  installed.
        //

        if( t1ops.bMatchingTT )
            goto Type1InstallCheck;


        StringCchCopy( szKeyName, cchKeyName, szTTFName );

        if( t1ops.bOnlyPSInstalled )
        {
            //
            //  There is already a Lbox entry for the PS version of this font
            //  that needs to be deleted because the TT installation will
            //  add a new Lbox entry.
            //

            iRet = TYPE1_INSTALL_TT_AND_MPS;

            //
            //  Funnel all exits thru 1 point to check for Install Cancellation
            //

            goto MasterExit;
        }
        else if( bInstallPS )
        {
            iRet = ( iRet == IDOK )  ? TYPE1_INSTALL_TT_AND_PS : TYPE1_INSTALL_TT_ONLY;

            //
            //  Funnel all exits thru 1 point to check for Install Cancellation
            //

            goto MasterExit;
        }
        else
        {
            iRet = TYPE1_INSTALL_TT_ONLY;
            goto CheckPfmDeletion;
        }
    }


Type1InstallCheck:
    if( bInstallPS )
    {
        if( iRet != IDOK )
        {
            iRet = TYPE1_INSTALL_IDNO;
            goto InstallPSFailure;
        }

        if( t1ops.bMatchingTT )
        {
            iRet = TYPE1_INSTALL_PS_AND_MTT;
        }
        else
        {
            iRet = TYPE1_INSTALL_PS_ONLY;
        }
    }

    if( !bInstallPS )
        goto CheckPfmDeletion;

    //
    //  Funnel all exits thru 1 point to check for Install Cancellation
    //

    goto MasterExit;

    /////////////////////////////////////////////////////////////////////////
    //
    //  Install failure exit AND Delete extraneously created PFM file
    //
    //  NOTE:  For the installation scenario where we based installation on
    //         the .INF/.AFM file and the Type1 font was NOT installed, we
    //         need to delete the .FPM file that was created by the
    //         CheckType1WithStatusA routine in the IsPSFont routine.
    //
    /////////////////////////////////////////////////////////////////////////

InstallPSFailure:

CheckPfmDeletion:

    if( bCreatedPfm )
        DeleteFile( szPfmName );

MasterExit:

    return( InstallCancelled() ? IDCANCEL : iRet );
}


/////////////////////////////////////////////////////////////////////////////
//
// InstallPSDlg
//
//  This dialog proc manages the Install PostScript font dialog which allows
//  the user several options for the installation, including converting the
//  file to a TrueType font.
//
//  Globals munged:
//
//      bConvertPS    -   Convert Type1 files to TT
//      bInstallPS    -   Install PS files
//      bCopyPS       -   Copy PS files to Windows dir
//
/////////////////////////////////////////////////////////////////////////////

INT_PTR APIENTRY InstallPSDlg( HWND hDlg, UINT nMsg, WPARAM wParam, LPARAM lParam )
{
    TCHAR  szFormat[ PATHMAX ] ;
    TCHAR  szTemp[ PATHMAX ] ;
    TCHAR  szTemp2[ PATHMAX ] ;
    int    iButtonChecked;
    WORD   wMsg;

    static HWND hwndActive = NULL;

    T1_INSTALL_OPTIONS *pt1ops;


    switch( nMsg )
    {

    case WM_INITDIALOG:

        pt1ops = (PT1_INSTALL_OPTIONS)  lParam;

        //
        //  Remove all "PostScript" or "TrueType" postfix to font name
        //

        StringCchCopy( szTemp2, ARRAYSIZE(szTemp2), (LPTSTR) pt1ops->szDesc );

        RemoveDecoration( szTemp2, FALSE );

        {
            LPCTSTR args[] = { szTemp2 };

            LoadString( g_hInst, MYFONT + 7, szFormat, ARRAYSIZE( szFormat ) );
            FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                          FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          szFormat,
                          0,
                          0,
                          szTemp,
                          ARRAYSIZE(szTemp),
                          (va_list *)args);
        }

        SetWindowLongPtr( hDlg, GWL_PROGRESS, lParam );

        SetDlgItemText( hDlg, FONT_INSTALLMSG, szTemp );
        EnableWindow( hDlg, TRUE );

        //
        // If the native ATM driver is installed, the "Convert to TrueType" checkbox
        // is always disabled.
        //
        {
            CFontManager *poFontManager;
            if (SUCCEEDED(GetFontManager(&poFontManager)))
            {
                if (poFontManager->Type1FontDriverInstalled())
                    EnableWindow(GetDlgItem(hDlg, FONT_CONVERT_PS), FALSE);
                ReleaseFontManager(&poFontManager);
            }
        }

        if( pt1ops->bOnlyPSInstalled && pt1ops->bMatchingTT )
        {
            //
            // ERROR!  Both of these options should not be set at
            //         this point.  It means that the font is
            //         already installed.  This should have been
            //         handled before calling this dialog.
            //

            wMsg = MYFONT + 5;
InstallError:

            iUIMsgExclaim( hDlg, wMsg, pt1ops->szDesc );

            EndDialog( hDlg, IDNO );
            break;
        }

        if( (pt1ops->wFontType == TYPE1_FONT_NC )  && pt1ops->bOnlyPSInstalled )
        {
            //
            //  ERROR! This case is when I have detected only the PS
            //         version of font installed, and the font CANNOT
            //         be converted to TT for some reason.
            //

            wMsg = MYFONT + 8;
            goto InstallError;
        }

        /////////////////////////////////////////////////////////////////////
        //
        //  Setup user options depending on install state of font and
        //  convertibility to TT of T1 font and on previous user choices.
        //
        /////////////////////////////////////////////////////////////////////


        if( (pt1ops->wFontType == TYPE1_FONT )  && (!pt1ops->bMatchingTT ) )
        {
            //
            //  This one can be converted
            //

            CheckDlgButton( hDlg, FONT_CONVERT_PS, bConvertPS );
        }
        else
        {
            //
            //  Do not allow conversion to TT because, either the font
            //  type is TYPE1_FONT_NC( i.e. it cannot be converted )  OR
            //  the TT version of font is already installed.
            //

            CheckDlgButton( hDlg, FONT_CONVERT_PS, FALSE );
            EnableWindow( GetDlgItem( hDlg, FONT_CONVERT_PS ) , FALSE );
        }

        if( pt1ops->bOnlyPSInstalled )
        {
            //
            //  If the PostScript version of this font is already
            //  installed, then we gray out the options to re-install
            //  the PostScript version of font, but continue to allow
            //  the User to convert it to TT.
            //

            CheckDlgButton( hDlg, FONT_INSTALL_PS, 0 );

            EnableWindow( GetDlgItem( hDlg, FONT_INSTALL_PS ) , FALSE );

            CheckDlgButton( hDlg, FONT_COPY_PS, 0 );

            EnableWindow( GetDlgItem( hDlg, FONT_COPY_PS ) , FALSE );
        }
        else
        {
            //
            //  PostScript version of font is not installed.  Set
            //  state of "INSTALL" and "COPY" checkboxes based on
            //  global state of "INSTALL"
            //

            CheckDlgButton( hDlg, FONT_INSTALL_PS, bInstallPS );

            CheckDlgButton( hDlg, FONT_COPY_PS, bCopyPS );

            EnableWindow( GetDlgItem( hDlg, FONT_COPY_PS ) , bInstallPS );

        }

        //
        //  Save the modeless dlg window handle for reactivation
        //

        hwndActive = GetActiveWindow( );
        break;


    case WM_COMMAND:
        switch( LOWORD( wParam ) )
        {
        case FONT_INSTALL_PS:
            if( HIWORD( wParam )  != BN_CLICKED )
                break;

            //
            // Get state of "INSTALL" checkbox
            //

            iButtonChecked = IsDlgButtonChecked( hDlg, LOWORD( wParam ) );

            //
            // A disabled checkbox is same as "No Install" selection
            //

            if( iButtonChecked != 1 )
                iButtonChecked = 0;

            //
            //  Enable or disable "COPY" control based on state of
            //  "INSTALL" checkbox.  Also, initialize it.
            //

            EnableWindow( GetDlgItem( hDlg, FONT_COPY_PS ) , iButtonChecked );

            if( iButtonChecked )
                CheckDlgButton( hDlg, FONT_COPY_PS, bCopyPS );

            break;


        case IDD_HELP:
            goto DoHelp;

        case IDYES:
        case IDD_YESALL:
            bConvertPS =
            bInstallPS = FALSE;

            if( IsDlgButtonChecked( hDlg, FONT_CONVERT_PS )  == 1 )
                bConvertPS = TRUE;

            if( IsDlgButtonChecked( hDlg, FONT_INSTALL_PS )  == 1 )
                bInstallPS = TRUE;

            //
            //  This is checked twice because it could be disabled,
            //  in which case we leave the previous state alone.
            //

            if( IsDlgButtonChecked( hDlg, FONT_COPY_PS )  == 1 )
                bCopyPS = TRUE;

            if( IsDlgButtonChecked( hDlg, FONT_COPY_PS )  == 0 )
                bCopyPS = FALSE;

            //
            //  Fall thru...
            //

        case IDNO:
        case IDCANCEL:
            //
            //  Reset the active window to "Install Font Progress" modeless dlg
            //

            if( hwndActive )
            {
                SetActiveWindow( hwndActive );
                hwndActive = NULL;
            }

            EndDialog( hDlg, LOWORD( wParam ) );
            break;

        default:
            return FALSE;
        }
        break;

    default:
DoHelp:

#ifdef PS_HELP
//
// FIXFIX [stevecat] Enable help
        if( nMsg == wHelpMessage )
        {
DoHelp:
            CPHelp( hDlg );
            return TRUE;
        }
        else
#endif  //  PS_HELP

            return FALSE;
    }
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
//
// RemoveDecoration
//
//  Deletes the "(TrueType)" or "(PostScript)" postfix string from the end
//  of a font name.  Optionally it will also remove the trailing space.
//
//  NOTE:  This function modifies the string passed into the function.
//
/////////////////////////////////////////////////////////////////////////////

void RemoveDecoration( LPTSTR pszDesc, BOOL bDeleteTrailingSpace )
{
    LPTSTR lpch;

    //
    //  Remove any postfix strings like "(PostScript)" or "(TrueType)"
    //

    if( lpch = _tcschr( pszDesc, TEXT('(') ) )
    {
        //
        //  End string at <space> before "("
        //

        if( bDeleteTrailingSpace )
            lpch--;

        *lpch = CHAR_NULL;
    }

    return ;
}

/////////////////////////////////////////////////////////////////////////////
//
// CheckT1Install
//
//  Checks the Type1 fonts location in registry to see if this font is or
//  has been previously installed as a "PostScript" font.  Optionally, it
//  will return the data for the "szData" value if it finds a matching entry.
//
/////////////////////////////////////////////////////////////////////////////

BOOL CheckT1Install( LPTSTR pszDesc, LPTSTR pszData, size_t cchData )
{
    TCHAR  szTemp[ PATHMAX ] ;
    DWORD  dwSize;
    DWORD  dwType;
    HKEY   hkey;
    BOOL   bRet = FALSE;


    hkey = NULL;

    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE,        // Root key
                      g_szType1Key,              // Subkey to open
                      0L,                        // Reserved
                      KEY_READ,                  // SAM
                      &hkey )                    // return handle
            == ERROR_SUCCESS )
    {
        //
        //  Remove any postfix strings like "PostScript" or "TrueType"
        //

        StringCchCopy( szTemp, ARRAYSIZE(szTemp), pszDesc );

        RemoveDecoration( szTemp, TRUE );

        dwSize = (DWORD)(pszData ? cchData * sizeof(*pszData) : 0);

        if( RegQueryValueEx( hkey, szTemp, NULL, &dwType,
                             (LPBYTE)  pszData, &dwSize )
                ==  ERROR_SUCCESS )
        {
            bRet = ( dwType == REG_MULTI_SZ );
        }
        else
        {
            bRet = FALSE;
        }

        RegCloseKey( hkey );
    }

    return bRet;
}


/////////////////////////////////////////////////////////////////////////////
//
// AddSystemPath
//
//  Add "System" path to a naked file name, if no path currently exists
//  on the filename.  Assumes pszFile buffer is at least PATHMAX chars in
//  length.
//
/////////////////////////////////////////////////////////////////////////////

void AddSystemPath( LPTSTR pszFile, size_t cchFile )
{
    TCHAR  szPath[ PATHMAX ] ;

    //
    //  Add "system" path, if no path present on file
    //

    StringCchCopy( szPath, ARRAYSIZE(szPath), pszFile );
    StripFilespec( szPath );

    if( szPath[ 0 ]  == CHAR_NULL )
    {
        PathCombine(szPath, s_szSharedDir, pszFile);
        StringCchCopy(pszFile, cchFile, szPath);
    }

    return ;
}

/////////////////////////////////////////////////////////////////////////////
//
// ExtractT1Files
//
//  Extracts file names from a REG_MULTI_SZ (multi-string)  array that is
//  passed into this routine.  The output strings are expected to be at
//  least PATHMAX in size.  A "" (NULL string)  indicates that a filename
//  string was not present.  This should only happen for the PFB filename
//  argument.
//
/////////////////////////////////////////////////////////////////////////////

BOOL ExtractT1Files( LPTSTR pszMulti, LPTSTR pszPfmFile, size_t cchPfmFile, LPTSTR pszPfbFile, size_t cchPfbFile )
{
    LPTSTR pszPfm;
    LPTSTR pszPfb;

    if( !pszMulti )
        return FALSE;

    if( ( pszMulti[ 0 ]  != CHAR_TRUE )  && ( pszMulti[ 0 ]  != CHAR_FALSE ) )
        return FALSE;

    //
    //  .Pfm file should always be present
    //

    pszPfm = pszMulti + lstrlen( pszMulti ) + 1;

    StringCchCopy( pszPfmFile, cchPfmFile, pszPfm );

    //
    //  Add "system" path, if no path present on files
    //

    AddSystemPath( pszPfmFile, cchPfmFile );

    //
    //  Check to see if .pfb filename is present
    //

    if( pszMulti[ 0 ]  == CHAR_TRUE )
    {
        pszPfb = pszPfm + lstrlen( pszPfm )  + 1;
        StringCchCopy( pszPfbFile, cchPfbFile, pszPfb );

        //
        //  Add "system" path, if no path present on files
        //

        AddSystemPath( pszPfbFile, cchPfbFile );
    }
    else
    {
        pszPfbFile[ 0 ]  = CHAR_NULL;
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
//
// DeleteT1Install
//
//  Deletes a Type1 entry from the registry and optionally the files pointed
//  to in the data strings.
//
/////////////////////////////////////////////////////////////////////////////

BOOL DeleteT1Install( HWND hwndParent, LPTSTR pszDesc, BOOL bDeleteFiles )
{
    TCHAR  szTemp[ PATHMAX ] ;
    TCHAR  szTemp2[ T1_MAX_DATA ] ;
    TCHAR  szPfmFile[ PATHMAX ] ;
    TCHAR  szPfbFile[ PATHMAX ] ;
    TCHAR  szPath[ PATHMAX ] ;
    DWORD  dwSize;
    DWORD  dwType;
    HKEY   hkey;
    BOOL   bRet = FALSE;

    hkey = NULL;

    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE,        // Root key
                      g_szType1Key,              // Subkey to open
                      0L,                        // Reserved
                      (KEY_READ | KEY_WRITE),    // SAM
                      &hkey )                    // return handle
            == ERROR_SUCCESS )
    {
        //
        //  Remove any postfix strings like "PostScript" or "TrueType"
        //

        StringCchCopy( szTemp, ARRAYSIZE(szTemp), pszDesc );

        RemoveDecoration( szTemp, TRUE );

        if( bDeleteFiles )
        {
            dwSize = sizeof( szTemp2 );

            if( RegQueryValueEx( hkey, szTemp, NULL, &dwType,
                                 (LPBYTE )  szTemp2, &dwSize )
                    ==  ERROR_SUCCESS )
            {
                if( ExtractT1Files( szTemp2, szPfmFile, ARRAYSIZE(szPfmFile), szPfbFile, ARRAYSIZE(szPfbFile) ) )
                {
                    //
                    //  Delete the files
                    //
//                    if( DelSharedFile( hDlg, szTemp, szPfbFile, szPath, TRUE ) )
//                        DelSharedFile( hDlg, szTemp, szPfmFile, szPath, FALSE );
//
                    vCPDeleteFromSharedDir( szPfbFile );
                    vCPDeleteFromSharedDir( szPfmFile );
                }
                else
                {
                    //  ERROR! Cannot get file names from string
                    goto RemoveT1Error;
                }
            }
            else
            {
                goto RemoveT1Error;
            }
        }

        if( RegDeleteValue( hkey, szTemp )  != ERROR_SUCCESS )
        {
RemoveT1Error:

            //
            //  ERROR! Put up message box
            //

            iUIMsgOkCancelExclaim( hwndParent,
                                   MYFONT + 1,
                                   IDS_MSG_CAPTION,
                                   (LPTSTR ) szTemp );

            bRet = FALSE;
        }
        else
        {
            bRet = TRUE;
        }

        RegCloseKey( hkey );
    }

    return bRet;
}


/////////////////////////////////////////////////////////////////////////////
//
// GetT1Install
//
//  Gets a Type1 entry information from the registry into the files pointed
//  to in the data strings.
//
/////////////////////////////////////////////////////////////////////////////

BOOL GetT1Install( LPTSTR pszDesc, LPTSTR pszPfmFile, size_t cchPfmFile, LPTSTR pszPfbFile, size_t cchPfbFile )
{
    TCHAR  szTemp2[ T1_MAX_DATA ] ;
    BOOL   bRet = FALSE;


    if( CheckT1Install( pszDesc, szTemp2, ARRAYSIZE(szTemp2)) )
    {
        bRet = ExtractT1Files( szTemp2, pszPfmFile, cchPfmFile, pszPfbFile, cchPfbFile );
    }

    return bRet;
}


/////////////////////////////////////////////////////////////////////////////
//
// CheckTTInstall
//
//  Check FONTS location in registry to see if this font has already
//  been installed.
//
/////////////////////////////////////////////////////////////////////////////

BOOL CheckTTInstall( LPTSTR szDesc )
{
    TCHAR szTemp[ PATHMAX ] ;
    TCHAR szTemp2[ PATHMAX ] ;

    //
    //  Change description string to have TrueType instead of
    //  PostScript and then check if it is already installed.
    //

    StringCchCopy( szTemp, ARRAYSIZE(szTemp), szDesc );

    RemoveDecoration( szTemp, TRUE );

    StringCchPrintf( szTemp, ARRAYSIZE(szTemp), c_szDescFormat, szTemp, c_szTrueType );

    if( GetProfileString( szFonts, szTemp, szNull, szTemp2, ARRAYSIZE( szTemp2 ) ) )
        return TRUE;

    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
//
// WriteType1RegistryEntry
//
//  Create registry entry for this PostScript font by writing the path of
//  both the .PFM and .PFB files.
//
//  NOTE:  Checks global "bCopyPS" to determine if files have been copied
//         to the local shared directory.  In that case, the path info is
//         stripped from the file names passed into routine.
//
/////////////////////////////////////////////////////////////////////////////

int WriteType1RegistryEntry( HWND hwndParent,
                             LPTSTR szDesc,         // Font name description
                             LPTSTR szPfmName,      // .PFM filename
                             LPTSTR szPfbName,      // .PFB filename
                             BOOL   bInFontsDir )   // Files in fonts dir?
{
    TCHAR  szTemp[ 2*PATHMAX+6 ] ;
    TCHAR  szTemp2[ PATHMAX ] ;
    TCHAR  szClass[ PATHMAX ] ;
    DWORD  dwSize;
    DWORD  dwDisposition;
    HKEY   hkey = NULL;

    //
    //  Must have a Font description to store information in registry
    //

    if( !szDesc || !szPfmName )
        return TYPE1_INSTALL_IDNO;

    //
    //  Try to create the key if it does not exist or open existing key.
    //

    if( RegCreateKeyEx( HKEY_LOCAL_MACHINE,        // Root key
                        g_szType1Key,              // Subkey to open/create
                        0L,                        // Reserved
                        szClass,                   // Class string
                        0L,                        // Options
                        KEY_WRITE,                 // SAM
                        NULL,                      // ptr to Security struct
                        &hkey,                     // return handle
                        &dwDisposition )           // return disposition
            == ERROR_SUCCESS )
    {
        //
        //  Create REG_MULTI_SZ string to save in registry
        //
        //  X <null> [path]zzzz.pfm <null> [path]xxxxx.pfb <null><null>
        //
        //  Where X == T(rue )  if .pfb file present
        //

        StringCchCopy( szTemp, ARRAYSIZE(szTemp), szPfbName ? szTrue : szFalse );
        StringCchCat( szTemp, ARRAYSIZE(szTemp), szHash );

        if( bInFontsDir )
            StripPath( szPfmName );

        StringCchCat( szTemp, ARRAYSIZE(szTemp), szPfmName );
        StringCchCat( szTemp, ARRAYSIZE(szTemp), szHash );

        if( szPfbName )
        {
            if( bInFontsDir )
                StripPath( szPfbName );

            StringCchCat( szTemp, ARRAYSIZE(szTemp), szPfbName );
            StringCchCat( szTemp, ARRAYSIZE(szTemp), szHash );
        }

        StringCchCat( szTemp, ARRAYSIZE(szTemp), szHash );

        //
        //  Now convert string to multi-string
        //  Note that we MUST calculate dwSize BEFORE we convert the '#'
        //  characters to 0.  Otherwise, lstrlen will count only the first
        //  part of the multi-part string.
        //
        dwSize = lstrlen( szTemp ) * sizeof( TCHAR );

        vHashToNulls( szTemp );

        //
        //  Create Registry Value name to store info under by
        //  removing any postfix strings like "Type 1" or
        //  "TrueType" from Font description string.
        //

        StringCchCopy( szTemp2, ARRAYSIZE(szTemp2), szDesc );
        RemoveDecoration( szTemp2, TRUE );

        if( RegSetValueEx( hkey, szTemp2, 0L, REG_MULTI_SZ,
                            (LPBYTE) szTemp, dwSize )
                != ERROR_SUCCESS )
        {
            goto WriteRegError;
        }

        RegCloseKey( hkey );
    }
    else
    {
WriteRegError:

        //
        //  Put up a message box error stating that the USER does
        //  not have the permission necessary to install type1
        //  fonts.
        //

        if( hkey )
            RegCloseKey( hkey );

        return( iUIMsgBox( hwndParent,
                           MYFONT + 9, IDS_MSG_CAPTION,
                           MB_OKCANCEL | MB_ICONEXCLAMATION,
                           (LPTSTR) szDesc,
                           (LPTSTR) g_szType1Key ) );
    }

    return TYPE1_INSTALL_IDOK;
}


/////////////////////////////////////////////////////////////////////////////
//
// InitProgress
//
//  Create and initialize the Progress dialog.  Initial state is visible.
//
/////////////////////////////////////////////////////////////////////////////

HWND InitProgress( HWND hwnd )
{
    if( NULL == hDlgProgress )
    {
        RegisterProgressClass( );

        hDlgProgress = CreateDialog( g_hInst, MAKEINTRESOURCE( DLG_PROGRESS ) ,
                                     hwnd ? hwnd :HWND_DESKTOP,
                                     ProgressDlg );
    }

    return hDlgProgress;
}


/////////////////////////////////////////////////////////////////////////////
//
// TermProgress
//
//  Remove and cleanup after the Progress dialog.
//
/////////////////////////////////////////////////////////////////////////////

void TermProgress( )
{
    if( hDlgProgress )
    {
        DestroyWindow( hDlgProgress );
        UnRegisterProgressClass( );
    }

    hDlgProgress = NULL;

    return;
}


/////////////////////////////////////////////////////////////////////////////
//
// cpProgressYield
//
//  Allow other messages including Dialog messages for Modeless dialog to be
//  processed while we are converting Type1 files to TrueType.
//
//  Since the font conversion is done on a single thread( in order to keep it
//  synchronous with installation of all fonts )  we need to provide a mechanism
//  that will allow a user to Cancel out of the operation and also allow
//  window messages, like WM_PAINT, to be processed by other Window Procedures.
//
/////////////////////////////////////////////////////////////////////////////

VOID cpProgressYield( )
{
    MSG msg;

    while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
    {
//        if( !hDlgProgress || !IsDialogMessage( hDlgProgress, &msg ) )
        if( !IsDialogMessage( hDlgProgress, &msg ) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// UpdateProgress
//
//   Set the overall progress control in Progress Dialog, along with a
//   message describing installation progress.
//
/////////////////////////////////////////////////////////////////////////////

void UpdateProgress( int iTotalCount, int iFontInstalling, int iProgress )
{
    TCHAR szTemp[ 120 ] ;

    StringCchPrintf( szTemp, ARRAYSIZE(szTemp), m_szMsgBuf, iFontInstalling, iTotalCount );

    SetDlgItemText( hDlgProgress, ID_INSTALLMSG, szTemp );

        SendDlgItemMessage( hDlgProgress, ID_OVERALL, SET_PROGRESS,
                        (int) iProgress, 0L );

    //
    //  Process outstanding messages
    //

    cpProgressYield( );
}


/////////////////////////////////////////////////////////////////////////////
//
// ResetProgress
//
//   Clear the progress bar control and reset message to NULL
//
/////////////////////////////////////////////////////////////////////////////

void ResetProgress(  )
{
    SetDlgItemText( hDlgProgress, ID_PROGRESSMSG, szNull );

    SendDlgItemMessage( hDlgProgress, ID_BAR, SET_PROGRESS, (int) 0, 0L );

    bProgMsgDisplayed = FALSE;

    bProg2MsgDisplayed = FALSE;

    //
    //  Process outstanding messages
    //

    cpProgressYield( );
}


BOOL InstallCancelled(void)
{
    return bCancelInstall;
}


/////////////////////////////////////////////////////////////////////////////
//
// Progress
//
//   Progress function for ConvertTypefaceA - Adobe Type1 to TrueType font
//   file converter.  Put up progress in converting font and message
//   describing font being converted.
//
/////////////////////////////////////////////////////////////////////////////

void STDCALL Progress( short PercentDone, void* UniqueValue )
{
    TCHAR szTemp[ 120 ] = {0};
    TCHAR szTemp2[ 120 ] = {0};
    DWORD err = GetLastError( ); // save whatever t1instal may have set

    //
    //  UniqueValue is a pointer to the string name of the file being
    //  converted.  Only put this message up if not previously displayed.
    //

    if( !bProgMsgDisplayed )
    {
        LPCTSTR args[] = { (LPCTSTR)UniqueValue };

        LoadString( g_hInst, MYFONT + 6, szTemp2, ARRAYSIZE( szTemp2 ) );
        FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      szTemp2,
                      0,
                      0,
                      szTemp,
                      ARRAYSIZE(szTemp),
                      (va_list *)args);

        SetDlgItemText( hDlgProgress, ID_PROGRESSMSG, szTemp );

        bProgMsgDisplayed = TRUE;
    }

        SendDlgItemMessage( hDlgProgress, ID_BAR, SET_PROGRESS,
                        (int) PercentDone, 0L );

    //
    //  Process outstanding messages
    //

    cpProgressYield( );

    //
    //  reset last error to whatever t1instal set it to:
    //

    SetLastError( err );
}


/////////////////////////////////////////////////////////////////////////////
//
// Progress2
//
//   Progress function for updating progress dialog controls on a per font
//   install basis.
//
/////////////////////////////////////////////////////////////////////////////

void Progress2( int PercentDone, LPTSTR pszDesc )
{
    TCHAR szTemp[ PATHMAX ] = {0};
    TCHAR szTemp2[ 240 ] = {0};

    //
    //  szDesc is a pointer to the string name of the file being installed.
    //  Only put this message up if not previously displayed.

    if( !bProg2MsgDisplayed )
    {
        LPCTSTR args[] = { pszDesc };

        LoadString( g_hInst, MYFONT + 11, szTemp2, ARRAYSIZE( szTemp2 ) );
        FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      szTemp2,
                      0,
                      0,
                      szTemp,
                      ARRAYSIZE(szTemp),
                      (va_list *)args);

        SetDlgItemText( hDlgProgress, ID_PROGRESSMSG, szTemp );

        bProg2MsgDisplayed = TRUE;
    }

        SendDlgItemMessage( hDlgProgress, ID_BAR, SET_PROGRESS, (int) PercentDone, 0L );

    //
    //  Process outstanding messages
    //

    cpProgressYield( );
}


/////////////////////////////////////////////////////////////////////////////
//
// ProgressDlg
//
//  Display progress messages to user based on progress in converting
//  font files to TrueType
//
/////////////////////////////////////////////////////////////////////////////

INT_PTR APIENTRY ProgressDlg( HWND hDlg, UINT nMsg, WPARAM wParam, LPARAM lParam )
{

    switch( nMsg )
    {

    case WM_INITDIALOG:
        CentreWindow( hDlg );

        //
        //  Load in Progress messages
        //

        LoadString( g_hInst, MYFONT + 10, m_szMsgBuf, ARRAYSIZE( m_szMsgBuf ) );

        EnableWindow( hDlg, TRUE );
        bCancelInstall = FALSE;
        break;

    case WM_COMMAND:
        switch( LOWORD( wParam ) )
        {

        case IDOK:
        case IDCANCEL:
            bCancelInstall = ( LOWORD( wParam )  == IDCANCEL );
            //
            // Dialog is destroyed programmatically after font is installed.
            // See TermProgress( )
            //
            break;

        default:
            return FALSE;
        }
        break;

    case WM_DESTROY:
        bCancelInstall = FALSE;
        break;

    default:
        return FALSE;
    }
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
//
// ProgressBarCtlProc
//
//  Window Procedure for the Progress Bar custom control.  Handles all
//  messages like WM_PAINT just as a normal application window would.
//
/////////////////////////////////////////////////////////////////////////////

LRESULT APIENTRY ProgressBarCtlProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    DWORD dwProgress;

    dwProgress = (DWORD)GetWindowLong( hWnd, GWL_PROGRESS );

    switch( message )
    {
    case WM_CREATE:
        dwProgress = 0;

        SetWindowLong( hWnd, GWL_PROGRESS, (LONG)dwProgress );

        break;

    case SET_PROGRESS:
        SetWindowLong( hWnd, GWL_PROGRESS, (LONG) wParam );

        InvalidateRect( hWnd, NULL, FALSE );

        UpdateWindow( hWnd );

        break;


    case WM_ENABLE:
        //
        //  Force a repaint since the control will look different.
        //

        InvalidateRect( hWnd, NULL, TRUE );

        UpdateWindow( hWnd );

        break;


    case WM_PAINT:
        return ProgressPaint( hWnd, dwProgress );


    default:
        return( DefWindowProc( hWnd, message, wParam, lParam ) );

        break;
    }
    return( 0L );
}


/////////////////////////////////////////////////////////////////////////////
//
// RegisterProgressClass
//
//
/////////////////////////////////////////////////////////////////////////////

BOOL RegisterProgressClass( void )
{
    WNDCLASS wcTest;

    wcTest.lpszClassName = TEXT( "cpProgress" );
    wcTest.hInstance     = (HINSTANCE) g_hInst;
    wcTest.lpfnWndProc   = ProgressBarCtlProc;
    wcTest.hCursor       = LoadCursor( NULL, IDC_WAIT );
    wcTest.hIcon         = NULL;
    wcTest.lpszMenuName  = NULL;
    wcTest.hbrBackground = (HBRUSH) IntToPtr( rgColorPro[ PROGRESSCOLOR_WINDOW ] );
    wcTest.style         = CS_HREDRAW | CS_VREDRAW;
    wcTest.cbClsExtra    = 0;
    wcTest.cbWndExtra    = sizeof( DWORD );

    //
    //  Set Bar color to Blue and text color to white
//
// [stevecat]  Let's make these follow the window title bar color and text
//             color.  Just make the USER calls to get these colors.  This
//             will make it look better with different color schemes and the
//             Theme packs.
//
    //

//    rgbBG = RGB(   0,   0, 255 );
//    rgbFG = RGB( 255, 255, 255 );

    rgbBG = GetSysColor( rgColorPro[ PROGRESSCOLOR_BAR ] );
    rgbFG = GetSysColor( rgColorPro[ PROGRESSCOLOR_TEXT ] );

    return( RegisterClass( (LPWNDCLASS) &wcTest ) );
}


/////////////////////////////////////////////////////////////////////////////
//
// UnRegisterProgressClass
//
//
/////////////////////////////////////////////////////////////////////////////

VOID UnRegisterProgressClass( void )
{
    UnregisterClass( TEXT( "cpProgress" ), (HINSTANCE) g_hInst );
}


/////////////////////////////////////////////////////////////////////////////
//
// ProgressPaint
//
// Description:
//
//  Handles all WM_PAINT messages for the control and paints
//  the control for the progress state.
//
// Parameters:
//  hWnd            HWND Handle to the control.
//  dwProgress      DWORD Progress amount - between 1 and 100
//
// Return Value:
//  LONG            0L.
//
//
//  This is an alternate way to do the progress bar in the control.  Instead
//  of drawing a rectangle, it uses ExtTextOut to draw the opagueing rect
//  based on the percentage complete.  Clever.
//
/////////////////////////////////////////////////////////////////////////////

LONG ProgressPaint( HWND hWnd, DWORD dwProgress )
{
    PAINTSTRUCT ps;
    HDC         hDC;
    TCHAR       szTemp[ 20 ] ;
    int         dx, dy, len;
    RECT        rc1, rc2;
    SIZE        Size;


    hDC = BeginPaint( hWnd, &ps );

    GetClientRect( hWnd, &rc1 );

    FrameRect( hDC, &rc1, (HBRUSH) GetStockObject( BLACK_BRUSH ) );

    InflateRect( &rc1, -1, -1 );

    rc2 = rc1;

    dx = rc1.right;
    dy = rc1.bottom;

    if( dwProgress == 100 )
        rc1.right = rc2.left = dx;
    else
        rc1.right = rc2.left = ( dwProgress * dx / 100 ) + 1;

    //
    //  Boundary condition testing
    //

    if( rc2.left > rc2.right )
        rc2.left = rc2.right;

    len = wnsprintf( szTemp, ARRAYSIZE(szTemp), TEXT( "%3d%%" ), dwProgress );

    GetTextExtentPoint32( hDC, szTemp, len, &Size );

    SetBkColor( hDC, rgbBG );
    SetTextColor( hDC, rgbFG );

    ExtTextOut( hDC, ( dx - Size.cx ) / 2, ( dy - Size.cy ) / 2,
                ETO_OPAQUE | ETO_CLIPPED, &rc1, szTemp, len, NULL );

    SetBkColor( hDC, rgbFG );
    SetTextColor( hDC, rgbBG );

    ExtTextOut( hDC, ( dx - Size.cx ) / 2, ( dy - Size.cy ) / 2,
                ETO_OPAQUE | ETO_CLIPPED, &rc2, szTemp, len, NULL );

    EndPaint( hWnd, &ps );

    return 0L;

}

//
// Creates a resource name string suitable for calling AddFontResource for a
// Type1 font.  The resulting resource string is in the following format:
//
//      <path to pfm>|<path to pfb>
//
// Returns: TRUE  = String was created.
//          FALSE = Caller passed a NULL pointer or destination buffer is too small.
//
BOOL BuildType1FontResourceName(LPCTSTR pszPfm, LPCTSTR pszPfb, LPTSTR pszDest, DWORD cchDest)
{
    BOOL bResult = FALSE;

    if (NULL != pszDest && pszPfm != NULL && pszPfb != NULL)
    {
        *pszDest = TEXT('\0');

        if (SUCCEEDED(StringCchPrintf(pszDest, cchDest, TEXT("%s|%s"), pszPfm, pszPfb)))
        {
            bResult = TRUE;
        }
    }
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\builder.h ===
/***
 **
 **   Module: Builder
 **
 **   Description:
 **    This is a module of the T1 to TT font converter. The module
 **    contains functions that will write the tables found in a
 **    TrueType font file.
 **
 **   Author: Michael Jansson
 **
 **   Created: 5/26/93
 **
 ***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

#define PREPSIZE        1000
#define MAXNOTDEFSIZE   1024


/* Referenced types. */
struct TTArg;
struct TTHandle;


/* Argument types. */
struct TTGlyph {
   struct encoding *code;

   USHORT num;
   USHORT stack;
   USHORT twilights;
   UBYTE *hints;

   Outline *paths;

   funit aw;
   funit lsb;
};

struct TTComposite {
   struct encoding *aenc;
   struct encoding *benc;
   struct encoding *cenc;
   struct encoding *oenc;
   funit dx;
   funit dy;
   funit aw;
   funit lsb;
};

typedef struct {
   ULONG a;
   ULONG b;
} longdate;

struct TTMetrics {
   struct {
      USHORT ver;
      USHORT rev;
   } version;
   longdate created;
   char *family;
   char *copyright;
   char *name;
   char *id;
   char *notice;
   char *fullname;
   char *weight;
   char *verstr;
   f16d16 angle;
   funit underline;
   funit uthick;
   USHORT macStyle;
   USHORT usWeightClass;
   USHORT usWidthClass;
   USHORT fsSelection;

   /* True Typographical metrics. */
   funit typAscender;
   funit typDescender;
   funit typLinegap;
   Point superoff;
   Point supersize;
   Point suboff;
   Point subsize;
   funit strikeoff;
   funit strikesize;
   short isFixPitched; 

   /* Windows based metrics. */
   funit winAscender;
   funit winDescender;
   UBYTE panose[10];

   /* Mac based metrics. */
   funit macLinegap;

   funit emheight;
   USHORT FirstChar;
   USHORT LastChar;
   USHORT DefaultChar;
   USHORT BreakChar;
   USHORT CharSet;
   funit *widths;
   short *cvt;
   USHORT cvt_cnt;
   struct kerning *kerns;
   USHORT kernsize;

   /* Copy of the encoding table. */
   struct encoding *Encoding;
   USHORT encSize;

   /* Hint specific information. */
   const UBYTE *prep;      /* PreProgram. */
   USHORT prep_size;
   const UBYTE *fpgm;      /* FontProgram. */
   USHORT fpgm_size;
   USHORT maxstorage;
   USHORT maxprepstack;    /* Max stack depth in pre-program. */
   USHORT maxfpgm;         /* Max number of function in the font program. */
   USHORT onepix;          /* Treshold where stems become >= 1.0 pixles. */
};


/***
** Function: InitTTOutput
**
** Description:
**   This function allocates the resources needed to
**   write a TT font file.
***/
errcode  InitTTOutput      _ARGS((IN      struct TTArg *,
                                  OUT     struct TTHandle **));

/***
** Function: CleanUpTT
**
** Description:
**   This function free's the resources used while
**   writing a TT font file.
***/
errcode  CleanUpTT         _ARGS((INOUT   struct TTHandle *,
                                  IN      struct TTArg *,
                                  IN      errcode status));

/***
** Function: PutTTNotDefGlyph
**
** Description:
**   This function adds a record for a the ".notdef" glyph to the
**   'glyf' table of the TT font file.
**   
***/
errcode  PutTTNotDefGlyph        _ARGS((INOUT   struct TTHandle *,
                                        IN      struct TTGlyph*));


/** Function: PutTTGlyph
**
** Description:
**   This function adds a record for a simple glyph to the
**   'glyf' table of the TT font file.
**   
***/
errcode  PutTTGlyph        _ARGS((INOUT   struct TTHandle *,
                                  IN      struct TTGlyph*,
											 IN		boolean fStdEncoding));


/***
** Function: PutTTOther
**
** Description:
**   This function writes the required TT tables to the
**   TT font file, except for the 'glyf' table which is
**   only completed (check sum is computed, etc.).
**   
***/
errcode  PutTTOther        _ARGS((INOUT   struct TTHandle *,
                                  INOUT   struct TTMetrics *));

/***
** Function: FreeTTGlyph
**
** Description:
**   This function will free the memory used to represent a 
**   a TrueType glyph.
**   
***/
void     FreeTTGlyph       _ARGS((INOUT   struct TTGlyph *));


/***
** Function: PutTTComposite
**
** Description:
**   
***/
errcode  PutTTComposite    _ARGS((INOUT   struct TTHandle *,
                                  OUT     struct TTComposite *));

/***
** Function: WindowsBBox
**
** Description:
**   Compute the bounding box of the characters that are
**   used in Windows character set.
***/
void     WindowsBBox       _ARGS((IN      struct TTHandle *tt,
                                  OUT     Point *bbox));

/***
** Function: MacBBox
**
** Description:
**   Compute the bounding box of the characters that are
**   used in Mac character set.
**
**   This is currently set to the global bounding box
**   (tt->bbox) of all characters in the font. This will
**   ensure that accents are not sqeezed on Mac platforms.
***/
void     MacBBox           _ARGS((IN      struct TTHandle *tt,
                                  OUT     Point *bbox));


// the name says it

void     GlobalBBox         _ARGS((IN      struct TTHandle *tt,
                                  OUT     Point *bbox));




/***
** Function: TypographicalAscender
**
** Description:
**   Compute the typographical ascender height, as ymax of
**   the letter 'b'.
***/
funit    TypographicalDescender _ARGS((IN struct TTHandle *tt));


/***
** Function: TypographicalDescender
**
** Description:
**   Compute the typographical descender height, as ymin of
**   the letter 'g'.
***/
funit    TypographicalAscender   _ARGS((IN struct TTHandle *tt));


/***
** Function: FreeTTMetrics
**
** Description:
**   This function free's the resources used to represent
**   TT specific metrics and auxiliary font information.
***/
void     FreeTTMetrics     _ARGS((INOUT struct TTMetrics *));


/***
** Function: UsePrep
**
** Description:
**   This function records the pre-program in the
**   TTMetrics record, until an appropriate time
**   when the data can be stored in the TT file.
**   
***/
void     UsePrep           _ARGS((INOUT struct TTMetrics *,
                                  IN    UBYTE *prep,
                                  IN    USHORT size));


/***
** Function: SetFPGM
**
** Description:
**   This function records the font-program in the
**   TTMetrics record, until an appropriate time
**   when the data can be stored in the TT file.
**   
***/
void     SetFPGM           _ARGS((INOUT struct TTMetrics *,
                                  IN    UBYTE *fpgm,
                                  IN    USHORT size,
                                  IN    USHORT num));

/***
** Function: GetPrep
**
** Description:
**   This function allocates needed space for the
**   pre-program.
**   
***/
UBYTE    *GetPrep          _ARGS((IN   int size));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\errors.c ===
/***
 **
 **   Module: T1Instal
 **
 **   Description:
 **      This is a Win32 DLL specific module, that implements
 **      the error logging mechanism under Win32.
 **
 **   Author: Michael Jansson
 **   Created: 12/18/93
 **
 ***/


/***** INCLUDES */
#include <windows.h>
#include "types.h"
#include "t1local.h"
#ifdef NOMSGBOX
#include <stdio.h>
#endif



/***** CONSTANTS */
/*-none-*/



/***** GLOBALS */



/***** PROTOTYPES */
extern int __cdecl sprintf(char *, const char *, ...);


/***
 ** Function: LogError
 **
 ** Description:
 **   Add another message to the error log.
 ***/
void LogError(const long type, const long id, const char *arg)
{
   char caption[256];
   char msg[256];
   WORD etype;
   HANDLE h;
   DWORD logit;
   DWORD size;
   HKEY key;
   HMODULE hInst = ModuleInstance();

   /* Map the internal envent type to EventLog type. */
   if (type==MSG_INFO)
      etype = EVENTLOG_INFORMATION_TYPE;
   else if (type==MSG_WARNING)
      etype = EVENTLOG_WARNING_TYPE;
   else
      etype = EVENTLOG_ERROR_TYPE;

   /* Access the REG data base. */
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SUBKEY_TYPE1INSTAL, 0,
                    KEY_QUERY_VALUE, &key)==ERROR_SUCCESS) { 

      size = sizeof(logit);
      if (RegQueryValueEx(key, (LPTSTR)SUBKEY_LOGFILE, NULL, 
                          NULL, (LPVOID)&logit, &size)==ERROR_SUCCESS &&
          logit!=0) {

         h = RegisterEventSource(NULL, STR_APPNAME);
         if (h!=NULL) {
            ReportEvent(h, etype, 0, id, NULL, 1, 0, (LPSTR *)&arg, NULL);
            DeregisterEventSource(h);
         }

         if (etype==EVENTLOG_WARNING_TYPE) {
            LoadString(hInst, (UINT)id, caption, sizeof(caption));
			if (arg && (strlen(caption)+strlen(arg)<sizeof(msg)))
				sprintf(msg, caption, arg);
			else
			{
				strcpy(msg, caption); // No room for the argument.
			}
            LoadString(hInst, IDS_CAPTION, caption, sizeof(caption));
#if NOMSGBOX
            fputs("WARNING- ", stderr);
            fputs(msg, stderr);
            fputs("\n", stderr);
#else         
            MessageBox(NULL, msg, caption, INFO);
#endif
            SetLastError(0);  /* MessageBox(NULL,...) is broken */
         }
      }

      if (etype==EVENTLOG_ERROR_TYPE) {
         LoadString(hInst, (UINT)id, caption, sizeof(caption));
		 if (arg && (strlen(caption)+strlen(arg)<sizeof(msg)))
			 sprintf(msg, caption, arg);
		 else
		 {
			 strcpy(msg, caption);
		 }
         LoadString(hInst, IDS_CAPTION, caption, sizeof(caption));
#if NOMSGBOX
         fputs("ERROR  - ", stderr);
         fputs(msg, stderr);
         fputs("\n", stderr);
#else         
         MessageBox(NULL, msg, caption, INFO);
#endif
         SetLastError(0); /* MessageBox(NULL,...) is broken */
      }
      RegCloseKey(key);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\encoding.c ===
/***
 **
 **   Module: Encoding
 **
 **   Description:
 **      This is a module of the T1 to TT font converter. The module
 **      contains interface functions for the global encoding table,
 **      i.e. this is an abstract data type.
 **
 **   Author: Michael Jansson
 **
 **   Created: 6/13/93
 **
 ***/


/**** INCLUDES */
#include <string.h>
#include "types.h"
#include "encoding.h"
#include "safemem.h"



/***** LOCAL TYPES */
struct encoding {
   const char *name;            /* Postscript name of a glyph. */
   USHORT codes[ENC_MAXCODES];  /* Character codes for each encoding scheme. */
};


/***** CONSTANTS */
static const struct encoding StdEncoding[] = {
   {".notdef",       {0xffff, 0xffff, 0xffff, 0xffff}},
   {"A",             {0x0041, 0x0041, 0x0041, 0x0041}},
   {"AE",            {0x00c6, 0x00c6, 0x00e1, 174   }},
   {"Aacute",        {0x00c1, 0x00c1, 0xffff, 231   }},
   {"Abreve",        {0x0102, 0xffff, 0xffff, 0xffff}},
   {"Acircumflex",   {0x00c2, 0x00c2, 0xffff, 229   }},
   {"Adieresis",     {0x00c4, 0x00c4, 0xffff, 128   }},
   {"Agrave",        {0x00c0, 0x00c0, 0xffff, 203   }},
   {"Aogonek",       {0x0104, 0xffff, 0xffff, 0xffff}},
   {"Aring",         {0x00c5, 0x00c5, 0xffff, 129   }},
   {"Atilde",        {0x00c3, 0x00c3, 0xffff, 204   }},
   {"B",             {0x0042, 0x0042, 0x0042, 0x0042}},
   {"C",             {0x0043, 0x0043, 0x0043, 0x0043}},
   {"Cacute",        {0x0106, 0xffff, 0xffff, 0xffff}},
   {"Ccaron",        {0x010c, 0xffff, 0xffff, 0xffff}},
   {"Ccedilla",      {0x00c7, 0x00c7, 0xffff, 130   }},
   {"D",             {0x0044, 0x0044, 0x0044, 0x0044}},
   {"Dcaron",        {0x010e, 0xffff, 0xffff, 0xffff}},
   {"Delta",         {0x2206, 0xffff, 0xffff, 198   }},
   {"Dslash",        {0x0110, 0xffff, 0xffff, 0xffff}},
   {"E",             {0x0045, 0x0045, 0x0045, 0x0045}},
   {"Eacute",        {0x00c9, 0x00c9, 0xffff, 131   }},
   {"Ecaron",        {0x011a, 0xffff, 0xffff, 0xffff}},
   {"Ecircumflex",   {0x00ca, 0x00ca, 0xffff, 230   }},
   {"Edieresis",     {0x00cb, 0x00cb, 0xffff, 232   }},
   {"Egrave",        {0x00c8, 0x00c8, 0xffff, 233   }},
   {"Eogonek",       {0x0118, 0xffff, 0xffff, 0xffff}},
   {"Eth",           {0x00d0, 0x00d0, 0xffff, 0xffff}},
   {"F",             {0x0046, 0x0046, 0x0046, 0x0046}},
   {"G",             {0x0047, 0x0047, 0x0047, 0x0047}},
   {"Gamma",         {0x0393, 0xffff, 0xffff, 0xffff}},
   {"Gbreve",        {0x011e, 0xffff, 0xffff, 0xffff}},
   {"H",             {0x0048, 0x0048, 0x0048, 0x0048}},
   {"I",             {0x0049, 0x0049, 0x0049, 0x0049}},
   {"Iacute",        {0x00cd, 0x00cd, 0xffff, 234   }},
   {"Icircumflex",   {0x00ce, 0x00ce, 0xffff, 235   }},
   {"Idieresis",     {0x00cf, 0x00cf, 0xffff, 236   }},
   {"Idot",          {0x0130, 0xffff, 0xffff, 0xffff}},
   {"Igrave",        {0x00cc, 0x00cc, 0xffff, 237   }},
   {"J",             {0x004a, 0x004a, 0x004a, 0x004a}},
   {"K",             {0x004b, 0x004b, 0x004b, 0x004b}},
   {"L",             {0x004c, 0x004c, 0x004c, 0x004c}},
   {"Lacute",        {0x0139, 0xffff, 0xffff, 0xffff}},
   {"Lcaron",        {0x013d, 0xffff, 0xffff, 0xffff}},
   {"Ldot",          {0x013f, 0xffff, 0xffff, 0xffff}},
   {"Lslash",        {0x0141, 0xffff, 0x00e8, 0xffff}},
   {"M",             {0x004d, 0x004d, 0x004d, 0x004d}},
   {"N",             {0x004e, 0x004e, 0x004e, 0x004e}},
   {"Nacute",        {0x0143, 0xffff, 0xffff, 0xffff}},
   {"Ncaron",        {0x0147, 0xffff, 0xffff, 0xffff}},
   {"Ntilde",        {0x00d1, 0x00d1, 0xffff, 132   }},
   {"O",             {0x004f, 0x004f, 0x004f, 0x004f}},
   {"OE",            {0x0152, 0x008c, 0x00ea, 206   }},
   {"Oacute",        {0x00d3, 0x00d3, 0xffff, 238   }},
   {"Ocircumflex",   {0x00d4, 0x00d4, 0xffff, 239   }},
   {"Odblacute",     {0x0150, 0xffff, 0xffff, 0xffff}},
   {"Odieresis",     {0x00d6, 0x00d6, 0xffff, 133   }},
   {"Ograve",        {0x00d2, 0x00d2, 0xffff, 241   }},
   {"Oslash",        {0x00d8, 0x00d8, 0x00e9, 175   }},
   {"Otilde",        {0x00d5, 0x00d5, 0xffff, 205   }},
   {"P",             {0x0050, 0x0050, 0x0050, 0x0050}},
   {"Phi",           {0x03a6, 0xffff, 0xffff, 0xffff}},
   {"Q",             {0x0051, 0x0051, 0x0051, 0x0051}},
   {"R",             {0x0052, 0x0052, 0x0052, 0x0052}},
   {"Racute",        {0x0154, 0xffff, 0xffff, 0xffff}},
   {"Rcaron",        {0x0158, 0xffff, 0xffff, 0xffff}},
   {"S",             {0x0053, 0x0053, 0x0053, 0x0053}},
   {"Sacute",        {0x015a, 0xffff, 0xffff, 0xffff}},
   {"Scaron",        {0x0160, 0x008A, 0xffff, 0xffff}},
   {"Scedilla",      {0x015e, 0xffff, 0xffff, 0xffff}},
   {"T",             {0x0054, 0x0054, 0x0054, 0x0054}},
   {"Tcaron",        {0x0164, 0xffff, 0xffff, 0xffff}},
   {"Tcedilla",      {0x0162, 0xffff, 0xffff, 0xffff}},
   {"Theta",         {0x0398, 0xffff, 0xffff, 0xffff}},
   {"Thorn",         {0x00de, 0x00de, 0xffff, 0xffff}},
   {"U",             {0x0055, 0x0055, 0x0055, 0x0055}},
   {"Uacute",        {0x00da, 0x00da, 0xffff, 242   }},
   {"Ucircumflex",   {0x00db, 0x00db, 0xffff, 243   }},
   {"Udblacute",     {0x0170, 0xffff, 0xffff, 0xffff}},
   {"Udieresis",     {0x00dc, 0x00dc, 0xffff, 134   }},
   {"Ugrave",        {0x00d9, 0x00d9, 0xffff, 244   }},
   {"Uring",         {0x016e, 0xffff, 0xffff, 0xffff}},
   {"V",             {0x0056, 0x0056, 0x0056, 0x0056}},
   {"W",             {0x0057, 0x0057, 0x0057, 0x0057}},
   {"X",             {0x0058, 0x0058, 0x0058, 0x0058}},
   {"Y",             {0x0059, 0x0059, 0x0059, 0x0059}},
   {"Yacute",        {0x00dd, 0x00dd, 0xffff, 0xffff}},
   {"Ydieresis",     {0x0178, 0x009f, 0xffff, 217   }},
   {"Z",             {0x005a, 0x005a, 0x005a, 0x005a}},
   {"Zacute",        {0x0179, 0xffff, 0xffff, 0xffff}},
   {"Zcaron",        {0x017d, 0xffff, 0xffff, 0xffff}},
   {"Zdot",          {0x017b, 0xffff, 0xffff, 0xffff}},
   {"a",             {0x0061, 0x0061, 0x0061, 0x0061}},
   {"aacute",        {0x00e1, 0x00e1, 0xffff, 135   }},
   {"abreve",        {0x0103, 0xffff, 0xffff, 0xffff}},
   {"acircumflex",   {0x00e2, 0x00e2, 0xffff, 137   }},
   {"acute",         {0x00b4, 0x00b4, 0x00c2, 171   }},
   {"adieresis",     {0x00e4, 0x00e4, 0xffff, 138   }},
   {"ae",            {0x00e6, 0x00e6, 0x00f1, 190   }},
   {"agrave",        {0x00e0, 0x00e0, 0xffff, 136   }},
   {"alpha",         {0x03b1, 0xffff, 0xffff, 0xffff}},
   {"ampersand",     {0x0026, 0x0026, 0x0026, 0x0026}},
   {"aogonek",       {0x0105, 0xffff, 0xffff, 0xffff}},
   {"apple",         {0xf000, 0x000, 0xffff, 240   }},
   {"approxequal",   {0x2248, 0xffff, 0xffff, 197   }},
   {"aring",         {0x00e5, 0x00e5, 0xffff, 140   }},
   {"arrowboth",     {0x2194, 0xffff, 0xffff, 0xffff}},
   {"arrowdown",     {0x2193, 0xffff, 0xffff, 0xffff}},
   {"aroowleft",     {0x2190, 0xffff, 0xffff, 0xffff}},
   {"arrowright",    {0x2192, 0xffff, 0xffff, 0xffff}},
   {"arrowup",       {0x2191, 0xffff, 0xffff, 0xffff}},
   {"arrowupdn",     {0x2195, 0xffff, 0xffff, 0xffff}},
   {"arrowupdnbse",  {0x21a8, 0xffff, 0xffff, 0xffff}},
   {"asciicircum",   {0x005e, 0x005e, 0x005e, 0x005e}},
   {"asciitilde",    {0x007e, 0x007e, 0x007e, 0x007e}},
   {"asterisk",      {0x002a, 0x002a, 0x002a, 0x002a}},
   {"at",            {0x0040, 0x0040, 0x0040, 0x0040}},
   {"atilde",        {0x00e3, 0x00e3, 0xffff, 139   }},
   {"b",             {0x0062, 0x0062, 0x0062, 0x0062}},
   {"backslash",     {0x005c, 0x005c, 0x005c, 0x005c}},
   {"bar",           {0x007c, 0x007c, 0x007c, 0x007c}},
   {"block",         {0x2588, 0xffff, 0xffff, 0xffff}},
   {"braceleft",     {0x007b, 0x007b, 0x007b, 0x007b}},
   {"braceright",    {0x007d, 0x007d, 0x007d, 0x007d}},
   {"bracketleft",   {0x005b, 0x005b, 0x005b, 0x005b}},
   {"bracketright",  {0x005d, 0x005d, 0x005d, 0x005d}},
   {"breve",         {0x02d8, 0xffff, 0x00c6, 249   }},
   {"brokenbar",     {0x00a6, 0x00a6, 0xffff, 0xffff}},
   {"bullet",        {0x2022, 0x0095, 0x00b7, 165   }},
   {"c",             {0x0063, 0x0063, 0x0063, 0x0063}},
   {"cacute",        {0x0107, 0xffff, 0xffff, 0xffff}},
   {"caron",         {0x02c7, 0xffff, 0x00cf, 255   }},
   {"ccaron",        {0x010d, 0xffff, 0xffff, 0xffff}},
   {"ccedilla",      {0x00e7, 0x00e7, 0xffff, 141   }},
   {"cedilla",       {0x00b8, 0x00b8, 0x00cb, 252   }},
   {"cent",          {0x00a2, 0x00a2, 0x00a2, 162   }},
   {"circle",        {0x25cb, 0xffff, 0xffff, 0xffff}},
   {"circumflex",    {0x02c6, 0x0088, 0x00c3, 246   }},
   {"club",          {0x2663, 0xffff, 0xffff, 0xffff}},
   {"colon",         {0x003a, 0x003a, 0x003a, 0x003a}},
   {"comma",         {0x002c, 0x002c, 0x002c, 0x002c}},
   {"copyright",     {0x00a9, 0x00a9, 0xffff, 169   }},
   {"currency",      {0x00a4, 0x00a4, 0x00a8, 219   }},
   {"d",             {0x0064, 0x0064, 0x0064, 0x0064}},
   {"dagger",        {0x2020, 0x0086, 0x00b2, 160   }},
   {"daggerdbl",     {0x2021, 0x0087, 0x00b3, 224   }},
   {"dcaron",        {0x010f, 0xffff, 0xffff, 0xffff}},
   {"degree",        {0x00b0, 0x00b0, 0xffff, 161   }},
   {"delta",         {0x03b4, 0xffff, 0xffff, 0xffff}},
   {"diamond",       {0x2666, 0xffff, 0xffff, 0xffff}},
   {"dieresis",      {0x00a8, 0x00a8, 0x00c8, 172   }},
   {"divide",        {0x00f7, 0x00f7, 0xffff, 214   }},
   {"dkshade",       {0x2593, 0xffff, 0xffff, 0xffff}},
   {"dmacron",       {0x0111, 0xffff, 0xffff, 0xffff}},
   {"dnblock",       {0x2584, 0xffff, 0xffff, 0xffff}},
   {"dollar",        {0x0024, 0x0024, 0x0024, 0x0024}},
   {"dotaccent",     {0x02d9, 0xffff, 0x00c7, 250   }},
   {"dotlessi",      {0x0131, 0xffff, 0x00f5, 245   }},
   {"e",             {0x0065, 0x0065, 0x0065, 0x0065}},
   {"eacute",        {0x00e9, 0x00e9, 0xffff, 142   }},
   {"ecaron",        {0x011b, 0xffff, 0xffff, 0xffff}},
   {"ecircumflex",   {0x00ea, 0x00ea, 0xffff, 144   }},
   {"edieresis",     {0x00eb, 0x00eb, 0xffff, 145   }},
   {"egrave",        {0x00e8, 0x00e8, 0xffff, 143   }},
   {"eight",         {0x0038, 0x0038, 0x0038, 0x0038}},
   {"ellipsis",      {0x2026, 0x0085, 0x00bc, 201   }},
   {"emdash",        {0x2014, 0x0097, 0x00d0, 209   }},
   {"endash",        {0x2013, 0x0096, 0x00b1, 208   }},
   {"eogonek",       {0x0119, 0xffff, 0xffff, 0xffff}},
   {"epsilon",       {0x03b4, 0xffff, 0xffff, 0xffff}},
   {"equal",         {0x003d, 0x003d, 0x003d, 0x003d}},
   {"equivalence",   {0x2261, 0xffff, 0xffff, 0xffff}},
   {"eth",           {0x00f0, 0x00f0, 0xffff, 0xffff}},
   {"exclam",        {0x0021, 0x0021, 0x0021, 0x0021}},
   {"exclamdbl",     {0x203c, 0xffff, 0xffff, 0xffff}},
   {"exclamdown",    {0x00a1, 0x00a1, 0x00a1, 193   }},
   {"f",             {0x0066, 0x0066, 0x0066, 0x0066}},
   {"female",        {0x2640, 0xffff, 0xffff, 0xffff}},
   {"fi",            {0xf001, 0xffff, 0x00ae, 222   }},
   {"filledbox",     {0x25a0, 0xffff, 0xffff, 0xffff}},
   {"filledrect",    {0x25ac, 0xffff, 0xffff, 0xffff}},
   {"five",          {0x0035, 0x0035, 0x0035, 0x0035}},
   {"fl",            {0xf002, 0xffff, 0x00af, 223   }},
   {"florin",        {0x0192, 0x0083, 0x00a6, 196   }},
   {"four",          {0x0034, 0x0034, 0x0034, 0x0034}},
   {"fraction",      {0x2215, 0xffff, 0x00a4, 218   }},
   {"franc",         {0x20a3, 0xffff, 0xffff, 0xffff}},
   {"g",             {0x0067, 0x0067, 0x0067, 0x0067}},
   {"gbreve",        {0x011f, 0xffff, 0xffff, 0xffff}},
   {"germandbls",    {0x00df, 0x00df, 0x00fb, 167   }},
   {"grave",         {0x0060, 0x0060, 0x00c1, 0x0060}},
   {"greater",       {0x003e, 0x003e, 0x003e, 0x003e}},
   {"greaterequal",  {0x2265, 0xffff, 0xffff, 179   }},
   {"guillemotleft", {0x00ab, 0x00ab, 0x00ab, 199   }},
   {"guillemotright",{0x00bb, 0x00bb, 0x00bb, 200   }},
   {"guilsinglleft", {0x2039, 0x008b, 0x00ac, 220   }},
   {"guilsinglright",{0x203a, 0x009b, 0x00ad, 221   }},
   {"h",             {0x0068, 0x0068, 0x0068, 0x0068}},
   {"heart",         {0x2665, 0xffff, 0xffff, 0xffff}},
   {"house",         {0x2302, 0xffff, 0xffff, 0xffff}},
   {"hungarumlaut",  {0x02dd, 0xffff, 0x00cd, 0xffff}},
   {"hyphen",        {0x002d, 0x002d, 0x002d, 0x002d}},
   {"i",             {0x0069, 0x0069, 0x0069, 0x0069}},
   {"iacute",        {0x00ed, 0x00ed, 0xffff, 146   }},
   {"icircumflex",   {0x00ee, 0x00ee, 0xffff, 148   }},
   {"idieresis",     {0x00ef, 0x00ef, 0xffff, 149   }},
   {"igrave",        {0x00ec, 0x00ec, 0xffff, 147   }},
   {"infinity",      {0x221e, 0xffff, 0xffff, 176   }},
   {"integral",      {0x222b, 0xffff, 0xffff, 186   }},
   {"integralbt",    {0x2321, 0xffff, 0xffff, 0xffff}},
   {"integraltp",    {0x2320, 0xffff, 0xffff, 0xffff}},
   {"intersection",  {0x2229, 0xffff, 0xffff, 0xffff}},
   {"invbullet",     {0x25d8, 0xffff, 0xffff, 0xffff}},
   {"invcircle",     {0x25d9, 0xffff, 0xffff, 0xffff}},
   {"invsmileface",  {0x263b, 0xffff, 0xffff, 0xffff}},
   {"j",             {0x006a, 0x006a, 0x006a, 0x006a}},
   {"k",             {0x006b, 0x006b, 0x006b, 0x006b}},
   {"l",             {0x006c, 0x006c, 0x006c, 0x006c}},
   {"lacute",        {0x013a, 0xffff, 0xffff, 0xffff}},
   {"lcaron",        {0x013e, 0xffff, 0xffff, 0xffff}},
   {"ldot",          {0x0140, 0xffff, 0xffff, 0xffff}},
   {"less",          {0x003c, 0x003c, 0x003c, 0x003c}},
   {"lessequal",     {0x2264, 0xffff, 0xffff, 178   }},
   {"lfblock",       {0x258c, 0xffff, 0xffff, 0xffff}},
   {"logicalnot",    {0x00ac, 0x00ac, 0xffff, 194   }},
   {"lozenge",       {0x25ca, 0xffff, 0xffff, 215   }},
   {"lslash",        {0x0142, 0xffff, 0x00f8, 0xffff}},
   {"ltshade",       {0x2591, 0xffff, 0xffff, 0xffff}},
   {"m",             {0x006d, 0x006d, 0x006d, 0x006d}},
   {"macron",        {0x00af, 0xffff, 0x00c5, 248   }},
   {"male",          {0x2642, 0xffff, 0xffff, 0xffff}},
   {"middot",        {0x00b7, 0x00b7, 0xffff, 0xffff}},
   {"minus",         {0x2212, 0xffff, 0xffff, 0xffff}},
   {"mu",            {0x00b5, 0x00b5, 0xffff, 181   }},
   {"multiply",      {0x00d7, 0x00d7, 0xffff, 0xffff}},
   {"musicalnote",   {0x266a, 0xffff, 0xffff, 0xffff}},
   {"musicalnotedbl",{0x266b, 0xffff, 0xffff, 0xffff}},
   {"n",             {0x006e, 0x006e, 0x006e, 0x006e}},
   {"nacute",        {0x0144, 0xffff, 0xffff, 0xffff}},
   {"nbspace",       {0x00a0, 0x00a0, 0xffff, 0xffff}},
   {"ncaron",        {0x0148, 0xffff, 0xffff, 0xffff}},
   {"nine",          {0x0039, 0x0039, 0x0039, 0x0039}},
   {"notequal",      {0x2260, 0xffff, 0xffff, 173   }},
   {"nsuperior",     {0x207f, 0xffff, 0xffff, 0xffff}},
   {"ntilde",        {0x00f1, 0x00f1, 0xffff, 150   }},
   {"numbersign",    {0x0023, 0x0023, 0x0023, 0x0023}},
   {"o",             {0x006f, 0x006f, 0x006f, 0x006f}},
   {"oacute",        {0x00f3, 0x00f3, 0xffff, 151   }},
   {"ocircumflex",   {0x00f4, 0x00f4, 0xffff, 153   }},
   {"odblacute",     {0x0151, 0xffff, 0xffff, 0xffff}},
   {"odieresis",     {0x00f6, 0x00f6, 0xffff, 154   }},
   {"oe",            {0x0153, 0x009c, 0x00fa, 207   }},
   {"ogonek",        {0x02db, 0xffff, 0x00ce, 254   }},
   {"ograve",        {0x00f2, 0x00f2, 0xffff, 152   }},
   {"ohm",           {0x2126, 0xffff, 0xffff, 189   }},
   {"one",           {0x0031, 0x0031, 0x0031, 0x0031}},
   {"onehalf",       {0x00bd, 0x00bd, 0xffff, 0xffff}},
   {"onequarter",    {0x00bc, 0x00bc, 0xffff, 0xffff}},
   {"onesuperior",   {0x00b9, 0x00b9, 0xffff, 0xffff}},
   {"ordfeminine",   {0x00aa, 0x00aa, 0x00e3, 187   }},
   {"ordmasculine",  {0x00ba, 0x00ba, 0x00eb, 188   }},
   {"orthogonal",    {0x221f, 0xffff, 0xffff, 0xffff}},
   {"oslash",        {0x00f8, 0x00f8, 0x00f9, 191   }},
   {"otilde",        {0x00f5, 0x00f5, 0xffff, 155   }},
   {"overscore",     {0x00af, 0x00af, 0xffff, 0xffff}},
   {"p",             {0x0070, 0x0070, 0x0070, 0x0070}},
   {"paragraph",     {0x00b6, 0x00b6, 0x00b6, 166   }},
   {"parenleft",     {0x0028, 0x0028, 0x0028, 0x0028}},
   {"parenright",    {0x0029, 0x0029, 0x0029, 0x0029}},
   {"partialdiff",   {0x2202, 0xffff, 0xffff, 182   }},
   {"percent",       {0x0025, 0x0025, 0x0025, 0x0025}},
   {"period",        {0x002e, 0x002e, 0x002e, 0x002e}},
   {"periodcentered",{0x2219, 0xffff, 0x00b4, 225   }},
   {"perthousand",   {0x2030, 0x0089, 0x00bd, 228   }},
   {"peseta",        {0x20a7, 0xffff, 0xffff, 0xffff}},
   {"phi",           {0x03c6, 0xffff, 0xffff, 0xffff}},
   {"pi",            {0x03c0, 0xffff, 0xffff, 185   }},
   {"plus",          {0x002b, 0x002b, 0x002b, 0x002b}},
   {"plusminus",     {0x00b1, 0x00b1, 0xffff, 177   }},
   {"product",       {0x220f, 0xffff, 0xffff, 184   }},
   {"q",             {0x0071, 0x0071, 0x0071, 0x0071}},
   {"question",      {0x003f, 0x003f, 0x003f, 0x003f}},
   {"questiondown",  {0x00bf, 0x00bf, 0x00bf, 192   }},
   {"quotedbl",      {0x0022, 0x0022, 0x0022, 0x0022}},
   {"quotedblbase",  {0x201e, 0x0084, 0x00b9, 227   }},
   {"quotedblleft",  {0x201c, 0x0093, 0x00aa, 210   }},
   {"quotedblright", {0x201d, 0x0094, 0x00ba, 211   }},
   {"quoteleft",     {0x2018, 0x0091, 0x0060, 212   }},
   {"quoteright",    {0x2019, 0x0092, 0x0027, 213   }},
   {"quotesinglbase",{0x201a, 0x0082, 0x00b8, 226   }},
   {"quotesingle",   {0x0027, 0x0027, 0x00a9, 0x0027}},
   {"r",             {0x0072, 0x0072, 0x0072, 0x0072}},
   {"racute",        {0x0155, 0xffff, 0xffff, 0xffff}},
   {"radical",       {0x221a, 0xffff, 0xffff, 195   }},
   {"rcaron",        {0x0159, 0xffff, 0xffff, 0xffff}},
   {"registered",    {0x00ae, 0x00ae, 0xffff, 168   }},
   {"revlogicalnot", {0x2310, 0xffff, 0xffff, 0xffff}},
   {"ring",          {0x02da, 0xffff, 0x00ca, 251   }},
   {"rtblock",       {0x2590, 0xffff, 0xffff, 0xffff}},
   {"s",             {0x0073, 0x0073, 0x0073, 0x0073}},
   {"sacute",        {0x015b, 0xffff, 0xffff, 0xffff}},
   {"scaron",        {0x0161, 0x009a, 0xffff, 0xffff}},
   {"scedilla",      {0x015f, 0xffff, 0xffff, 0xffff}},
   {"section",       {0x00a7, 0x00a7, 0x00a7, 164   }},
   {"semicolon",     {0x003b, 0x003b, 0x003b, 0x003b}},
   {"seven",         {0x0037, 0x0037, 0x0037, 0x0037}},
   {"sfthyphen",     {0x00ad, 0x00ad, 0xffff, 0xffff}},
   {"shade",         {0x2592, 0xffff, 0xffff, 0xffff}},
   {"sigma",         {0x03c3, 0xffff, 0xffff, 0xffff}},
   {"six",           {0x0036, 0x0036, 0x0036, 0x0036}},
   {"slash",         {0x002f, 0x002f, 0x002f, 0x002f}},
   {"smileface",     {0x263a, 0xffff, 0xffff, 0xffff}},
   {"space",         {0x0020, 0x0020, 0x0020, 0x0020}},
   {"spade",         {0x2660, 0xffff, 0xffff, 0xffff}},
   {"sterling",      {0x00a3, 0x00a3, 0x00a3, 163   }},
   {"summation",     {0x2211, 0xffff, 0xffff, 183   }},
   {"sun",           {0x263c, 0xffff, 0xffff, 0xffff}},
   {"t",             {0x0074, 0x0074, 0x0074, 0x0074}},
   {"tau",           {0x03c4, 0xffff, 0xffff, 0xffff}},
   {"tcaron",        {0x0165, 0xffff, 0xffff, 0xffff}},
   {"tcedilla",      {0x0163, 0xffff, 0xffff, 0xffff}},
   {"thorn",         {0x00fe, 0x00fe, 0xffff, 0xffff}},
   {"three",         {0x0033, 0x0033, 0x0033, 0x0033}},
   {"threequarters", {0x00be, 0x00be, 0xffff, 0xffff}},
   {"threesuperior", {0x00b3, 0x00b3, 0xffff, 0xffff}},
   {"tilde",         {0x02dc, 0x0098, 0x00c4, 245   }},
   {"trademark",     {0x2122, 0x0099, 0xffff, 170   }},
   {"triagdn",       {0x25bc, 0xffff, 0xffff, 0xffff}},
   {"triagrt",       {0x25ba, 0xffff, 0xffff, 0xffff}},
   {"triagup",       {0x25b2, 0xffff, 0xffff, 0xffff}},
   {"traglf",        {0x25c4, 0xffff, 0xffff, 0xffff}},
   {"two",           {0x0032, 0x0032, 0x0032, 0x0032}},
   {"twosuperior",   {0x00b2, 0x00b2, 0xffff, 0xffff}},
   {"u",             {0x0075, 0x0075, 0x0075, 0x0075}},
   {"uacute",        {0x00fa, 0x00fa, 0xffff, 156   }},
   {"ucircumflex",   {0x00fb, 0x00fb, 0xffff, 158   }},
   {"udblacute",     {0x0171, 0xffff, 0xffff, 0xffff}},
   {"udieresis",     {0x00fc, 0x00fc, 0xffff, 159   }},
   {"ugrave",        {0x00f9, 0x00f9, 0xffff, 157   }},
   {"underscore",    {0x005f, 0x005f, 0x005f, 0x005f}},
   {"underscoredbl", {0x2017, 0xffff, 0xffff, 0xffff}},
   {"upblock",       {0x2580, 0xffff, 0xffff, 0xffff}},
   {"uring",         {0x016f, 0xffff, 0xffff, 0xffff}},
   {"v",             {0x0076, 0x0076, 0x0076, 0x0076}},
   {"w",             {0x0077, 0x0077, 0x0077, 0x0077}},
   {"x",             {0x0078, 0x0078, 0x0078, 0x0078}},
   {"y",             {0x0079, 0x0079, 0x0079, 0x0079}},
   {"yacute",        {0x00fd, 0x00fd, 0xffff, 0xffff}},
   {"ydieresis",     {0x00ff, 0x00ff, 0xffff, 216   }},
   {"yen",           {0x00a5, 0x00a5, 0x00a5, 180   }},
   {"z",             {0x007a, 0x007a, 0x007a, 0x007a}},
   {"zacute",        {0x017a, 0xffff, 0xffff, 0xffff}},
   {"zcaron",        {0x017e, 0xffff, 0xffff, 0xffff}},
   {"zdot",          {0x017c, 0xffff, 0xffff, 0xffff}},
   {"zero",          {0x0030, 0x0030, 0x0030, 0x0030}},
};


static const struct encoding SeacEncoding[] = {
   {"A",             {0xf041, 0x0041, 0x0041, 0x0041}},
   {"AE",            {0xf0c6, 0x00c6, 0x00e1, 174   }},
   {"B",             {0xf042, 0x0042, 0x0042, 0x0042}},
   {"C",             {0xf043, 0x0043, 0x0043, 0x0043}},
   {"D",             {0xf044, 0x0044, 0x0044, 0x0044}},
   {"E",             {0xf045, 0x0045, 0x0045, 0x0045}},
   {"F",             {0xf046, 0x0046, 0x0046, 0x0046}},
   {"G",             {0xf047, 0x0047, 0x0047, 0x0047}},
   {"H",             {0xf048, 0x0048, 0x0048, 0x0048}},
   {"I",             {0xf049, 0x0049, 0x0049, 0x0049}},
   {"J",             {0xf04a, 0x004a, 0x004a, 0x004a}},
   {"K",             {0xf04b, 0x004b, 0x004b, 0x004b}},
   {"L",             {0xf04c, 0x004c, 0x004c, 0x004c}},
   {"Lslash",        {0xf141, 0xffff, 0x00e8, 0xffff}},
   {"M",             {0xf04d, 0x004d, 0x004d, 0x004d}},
   {"N",             {0xf04e, 0x004e, 0x004e, 0x004e}},
   {"O",             {0xf04f, 0x004f, 0x004f, 0x004f}},
   {"OE",            {0xf152, 0x008c, 0x00ea, 206   }},
   {"Oslash",        {0xf0d8, 0x00d8, 0x00e9, 175   }},
   {"P",             {0xf050, 0x0050, 0x0050, 0x0050}},
   {"Q",             {0xf051, 0x0051, 0x0051, 0x0051}},
   {"R",             {0xf052, 0x0052, 0x0052, 0x0052}},
   {"S",             {0xf053, 0x0053, 0x0053, 0x0053}},
   {"T",             {0xf054, 0x0054, 0x0054, 0x0054}},
   {"U",             {0xf055, 0x0055, 0x0055, 0x0055}},
   {"V",             {0xf056, 0x0056, 0x0056, 0x0056}},
   {"W",             {0xf057, 0x0057, 0x0057, 0x0057}},
   {"X",             {0xf058, 0x0058, 0x0058, 0x0058}},
   {"Y",             {0xf059, 0x0059, 0x0059, 0x0059}},
   {"Z",             {0xf05a, 0x005a, 0x005a, 0x005a}},
   {"a",             {0xf061, 0x0061, 0x0061, 0x0061}},
   {"acute",         {0xf0b4, 0x00b4, 0x00c2, 171   }},
   {"ae",            {0xf0e6, 0x00e6, 0x00f1, 190   }},
   {"ampersand",     {0xf026, 0x0026, 0x0026, 0x0026}},
   {"asciicircum",   {0xf05e, 0x005e, 0x005e, 0x005e}},
   {"asciitilde",    {0xf07e, 0x007e, 0x007e, 0x007e}},
   {"asterisk",      {0xf02a, 0x002a, 0x002a, 0x002a}},
   {"at",            {0xf040, 0x0040, 0x0040, 0x0040}},
   {"b",             {0xf062, 0x0062, 0x0062, 0x0062}},
   {"backslash",     {0xf05c, 0x005c, 0x005c, 0x005c}},
   {"bar",           {0xf07c, 0x007c, 0x007c, 0x007c}},
   {"braceleft",     {0xf07b, 0x007b, 0x007b, 0x007b}},
   {"braceright",    {0xf07d, 0x007d, 0x007d, 0x007d}},
   {"bracketleft",   {0xf05b, 0x005b, 0x005b, 0x005b}},
   {"bracketright",  {0xf05d, 0x005d, 0x005d, 0x005d}},
   {"breve",         {0xf2d8, 0xffff, 0x00c6, 249   }},
   {"bullet",        {0x2022, 0x0095, 0x00b7, 165   }},
   {"c",             {0xf063, 0x0063, 0x0063, 0x0063}},
   {"caron",         {0xf2c7, 0xffff, 0x00cf, 255   }},
   {"cedilla",       {0xf0b8, 0x00b8, 0x00cb, 252   }},
   {"cent",          {0xf0a2, 0x00a2, 0x00a2, 162   }},
   {"circumflex",    {0xf2c6, 0x0088, 0x00c3, 246   }},
   {"colon",         {0xf03a, 0x003a, 0x003a, 0x003a}},
   {"comma",         {0xf02c, 0x002c, 0x002c, 0x002c}},
   {"currency",      {0xf0a4, 0x00a4, 0x00a8, 219   }},
   {"d",             {0xf064, 0x0064, 0x0064, 0x0064}},
   {"dagger",        {0x2020, 0x0086, 0x00b2, 160   }},
   {"daggerdbl",     {0x2021, 0x0087, 0x00b3, 224   }},
   {"dieresis",      {0xf0a8, 0x00a8, 0x00c8, 172   }},
   {"dollar",        {0xf024, 0x0024, 0x0024, 0x0024}},
   {"dotaccent",     {0xf2d9, 0xffff, 0x00c7, 250   }},
   {"dotlessi",      {0xf131, 0xffff, 0x00f5, 245   }},
   {"e",             {0xf065, 0x0065, 0x0065, 0x0065}},
   {"eight",         {0xf038, 0x0038, 0x0038, 0x0038}},
   {"ellipsis",      {0x2026, 0x0085, 0x00bc, 201   }},
   {"emdash",        {0x2014, 0x0097, 0x00d0, 209   }},
   {"endash",        {0x2013, 0x0096, 0x00b1, 208   }},
   {"equal",         {0xf03d, 0x003d, 0x003d, 0x003d}},
   {"exclam",        {0xf021, 0x0021, 0x0021, 0x0021}},
   {"exclamdown",    {0xf0a1, 0x00a1, 0x00a1, 193   }},
   {"f",             {0xf066, 0x0066, 0x0066, 0x0066}},
   {"fi",            {0xf001, 0xffff, 0x00ae, 222   }},
   {"five",          {0xf035, 0x0035, 0x0035, 0x0035}},
   {"fl",            {0xf002, 0xffff, 0x00af, 223   }},
   {"florin",        {0xf192, 0x0083, 0x00a6, 196   }},
   {"four",          {0xf034, 0x0034, 0x0034, 0x0034}},
   {"fraction",      {0x2215, 0xffff, 0x00a4, 218   }},
   {"g",             {0xf067, 0x0067, 0x0067, 0x0067}},
   {"germandbls",    {0xf0df, 0x00df, 0x00fb, 167   }},
   {"grave",         {0xf060, 0x0060, 0x00c1, 0x0060}},
   {"greater",       {0xf03e, 0x003e, 0x003e, 0x003e}},
   {"guillemotleft", {0xf0ab, 0x00ab, 0x00ab, 199   }},
   {"guillemotright",{0xf0bb, 0x00bb, 0x00bb, 200   }},
   {"guilsinglleft", {0x2039, 0x008b, 0x00ac, 220   }},
   {"guilsinglright",{0x203a, 0x009b, 0x00ad, 221   }},
   {"h",             {0xf068, 0x0068, 0x0068, 0x0068}},
   {"hungarumlaut",  {0xf2dd, 0xffff, 0x00cd, 0xffff}},
   {"hyphen",        {0xf02d, 0x002d, 0x002d, 0x002d}},
   {"i",             {0xf069, 0x0069, 0x0069, 0x0069}},
   {"j",             {0xf06a, 0x006a, 0x006a, 0x006a}},
   {"k",             {0xf06b, 0x006b, 0x006b, 0x006b}},
   {"l",             {0xf06c, 0x006c, 0x006c, 0x006c}},
   {"less",          {0xf03c, 0x003c, 0x003c, 0x003c}},
   {"lslash",        {0xf142, 0xffff, 0x00f8, 0xffff}},
   {"m",             {0xf06d, 0x006d, 0x006d, 0x006d}},
   {"macron",        {0xf0af, 0xffff, 0x00c5, 248   }},
   {"n",             {0xf06e, 0x006e, 0x006e, 0x006e}},
   {"nine",          {0xf039, 0x0039, 0x0039, 0x0039}},
   {"numbersign",    {0xf023, 0x0023, 0x0023, 0x0023}},
   {"o",             {0xf06f, 0x006f, 0x006f, 0x006f}},
   {"oe",            {0xf153, 0x009c, 0x00fa, 207   }},
   {"ogonek",        {0xf2db, 0xffff, 0x00ce, 254   }},
   {"one",           {0xf031, 0x0031, 0x0031, 0x0031}},
   {"ordfeminine",   {0xf0aa, 0x00aa, 0x00e3, 187   }},
   {"ordmasculine",  {0xf0ba, 0x00ba, 0x00eb, 188   }},
   {"oslash",        {0xf0f8, 0x00f8, 0x00f9, 191   }},
   {"p",             {0xf070, 0x0070, 0x0070, 0x0070}},
   {"paragraph",     {0xf0b6, 0x00b6, 0x00b6, 166   }},
   {"parenleft",     {0xf028, 0x0028, 0x0028, 0x0028}},
   {"parenright",    {0xf029, 0x0029, 0x0029, 0x0029}},
   {"percent",       {0xf025, 0x0025, 0x0025, 0x0025}},
   {"period",        {0xf02e, 0x002e, 0x002e, 0x002e}},
   {"periodcentered",{0x2219, 0xffff, 0x00b4, 225   }},
   {"perthousand",   {0x2030, 0x0089, 0x00bd, 228   }},
   {"plus",          {0xf02b, 0x002b, 0x002b, 0x002b}},
   {"q",             {0xf071, 0x0071, 0x0071, 0x0071}},
   {"question",      {0xf03f, 0x003f, 0x003f, 0x003f}},
   {"questiondown",  {0xf0bf, 0x00bf, 0x00bf, 192   }},
   {"quotedbl",      {0xf022, 0x0022, 0x0022, 0x0022}},
   {"quotedblbase",  {0x201e, 0x0084, 0x00b9, 227   }},
   {"quotedblleft",  {0x201c, 0x0093, 0x00aa, 210   }},
   {"quotedblright", {0x201d, 0x0094, 0x00ba, 211   }},
   {"quoteleft",     {0x2018, 0x0091, 0x0060, 212   }},
   {"quoteright",    {0x2019, 0x0092, 0x0027, 213   }},
   {"quotesinglbase",{0x201a, 0x0082, 0x00b8, 226   }},
   {"quotesingle",   {0xf027, 0x0027, 0x00a9, 0x0027}},
   {"r",             {0xf072, 0x0072, 0x0072, 0x0072}},
   {"ring",          {0xf2da, 0xffff, 0x00ca, 251   }},
   {"s",             {0xf073, 0x0073, 0x0073, 0x0073}},
   {"section",       {0xf0a7, 0x00a7, 0x00a7, 164   }},
   {"semicolon",     {0xf03b, 0x003b, 0x003b, 0x003b}},
   {"seven",         {0xf037, 0x0037, 0x0037, 0x0037}},
   {"six",           {0xf036, 0x0036, 0x0036, 0x0036}},
   {"slash",         {0xf02f, 0x002f, 0x002f, 0x002f}},
   {"space",         {0xf020, 0x0020, 0x0020, 0x0020}},
   {"sterling",      {0xf0a3, 0x00a3, 0x00a3, 163   }},
   {"t",             {0xf074, 0x0074, 0x0074, 0x0074}},
   {"three",         {0xf033, 0x0033, 0x0033, 0x0033}},
   {"tilde",         {0xf2dc, 0x0098, 0x00c4, 245   }},
   {"two",           {0xf032, 0x0032, 0x0032, 0x0032}},
   {"u",             {0xf075, 0x0075, 0x0075, 0x0075}},
   {"underscore",    {0xf05f, 0x005f, 0x005f, 0x005f}},
   {"v",             {0xf076, 0x0076, 0x0076, 0x0076}},
   {"w",             {0xf077, 0x0077, 0x0077, 0x0077}},
   {"x",             {0xf078, 0x0078, 0x0078, 0x0078}},
   {"y",             {0xf079, 0x0079, 0x0079, 0x0079}},
   {"yen",           {0xf0a5, 0x00a5, 0x00a5, 180   }},
   {"z",             {0xf07a, 0x007a, 0x007a, 0x007a}},
   {"zero",          {0xf030, 0x0030, 0x0030, 0x0030}},
};


/***** MACROS */
/*-none-*/


/***** STATIC FUNCTIONS */
/*-none-*/


/***** FUNCTIONS */

/***
** Function: AllocEncodingTable
**
** Description:
**   Create a new encoding ADT.
***/
struct encoding *AllocEncodingTable(const USHORT num)
{
   struct encoding *enc;
   if ((enc = Malloc(sizeof(struct encoding)*num))!=NULL)
      memset(enc, NOTDEFINIT, sizeof(struct encoding)*num);
   return enc;
}


/***
** Function: RehashEncodingTable
**
** Description:
**   Prepare an encoding ADT so that entries can be
**   located in it.
***/
void RehashEncodingTable(struct encoding *Encoding, const USHORT num)
{
   USHORT i;
   short j;
   struct encoding entry;

   for (i=1; i<num; i++) {
      j=(short)(i-1);
      entry = Encoding[i];
      while(j>=0 && strcmp(Encoding[j].name, entry.name)>0) {
         memcpy(&Encoding[j+1], &Encoding[j], sizeof(struct encoding));
         j--;
      }
      Encoding[j+1] = entry;
   }
}


/***
** Function: SetEncodingEntry
**
** Description:
**   Set the mapping from a glyph name to character
**   codes for various platforms.
***/
void SetEncodingEntry(struct encoding *Encoding,
                      const USHORT entry,
                      const char *name,
                      const USHORT num,
                      const USHORT *codes)
{
   USHORT i;

   Encoding[entry].name = name;
   for (i=0; i<num; i++) {
      Encoding[entry].codes[i] = codes[i];
   }
}


static int CDECL compare(const void *arg1, const void *arg2)
{
   return strcmp( *((const char **)arg1),
                  ((const struct encoding *)arg2)->name );
}


/***
** Function: LookupPSName
**
** Description:
**   Do a binary search for a postscript name, and return
**   a handle that can be used to look up a the character
**   code for a specific encoding schema.
**
**   If a custom encoding array is used and a glyph is not
**	 encoded by that array, though it is recognized by the
**   StandardEncoding array, then use the SeacEncoding.
**   This is needed in order to support bogus "seac" calls.
***/
struct encoding *LookupPSName(const struct encoding *Encoding,
                              USHORT size,
                              const char *name)
{
#ifndef BSEARCH
   struct encoding *result;
#else
   USHORT low, mid, high;
   short diff;

   /* Initiate. */
   low = 0;
   high = size;
#endif

   /* Use default encoding? */
   if (Encoding==NULL) {
      Encoding = StdEncoding;
      size = sizeof(StdEncoding)/sizeof(StdEncoding[0]);
   }

#ifndef BSEARCH
   result = (struct encoding *)bsearch((char *)&name,
                                       (char *)Encoding, size,
                                       sizeof(struct encoding),
                                       compare);
#else
   do {

	   mid = (low+high)>>1;
	   diff = (short)strcmp(Encoding[mid].name, name);

	   if (diff>0) {
		   high = (low+high)>>1;
	   } else if (diff<0) {
		   low = (short)((low+high+1)>>1);
	   } else if (diff==0) {
		   result =  &Encoding[mid];
	   }

   } while (low<high && result==NULL);
#endif


   if ((result==NULL) &&
	   (Encoding!=SeacEncoding) &&
	   (Encoding!=StdEncoding))
	   result = LookupPSName(SeacEncoding,
							 sizeof(SeacEncoding)/sizeof(SeacEncoding[0]),
							 name);

   return result;
}


/***
** Function: LookupCharCode
**
** Description:
**   look up a the character code for a
**   specific encoding scheme.
***/
USHORT LookupCharCode(const struct encoding *enc, const USHORT type)
{
   USHORT code = 0;

   if (enc)
      code = enc->codes[type];
   return code;
}


/***
** Function: LookupCharName
**
** Description:
**   look up a the character name for a
**   specific encoding scheme.
***/
const char *LookupCharName(const struct encoding *enc)
{
   return enc->name;
}


/***
** Function: LookupNotDef
**
** Description:
**   look up a the .notdef character
***/
const struct encoding *LookupNotDef(void)
{
   return &StdEncoding[0];
}



/***
** Function: DecodeChar
**
** Description:
**   look up an encoding record for a character code in some
**   known encoding.
***/
const struct encoding *DecodeChar(const struct encoding *Encoding,
                                  const USHORT max,
                                  const USHORT type,
                                  const USHORT code)
{
   const struct encoding *enc = &StdEncoding[0];
   USHORT i, high;

   /* Use default encoding? */
   if (Encoding==NULL) {
      Encoding = StdEncoding;
      high = sizeof(StdEncoding)/sizeof(StdEncoding[0]);
   } else {
      high = max;
   }

   for (i=0; i<high; i++) {
      if (Encoding[i].codes[type]==code) {
         enc = &Encoding[i];
         break;
      }
   }

   return enc;
}


/***
** Function: FreeEncoding
**
** Description:
**   Deallocate memory associated to the encoding array.
***/
void FreeEncoding(struct encoding *enc, const USHORT size)
{
   USHORT i;

   if (enc) {
      for (i=0; i<size; i++) {
         if (enc[i].name)
            Free((char *)enc[i].name);
      }
      Free(enc);
   }
}

/***
** Function: LookupFirstEnc
**
** Description:
**   Locate the first encoding for a given glyph.
***/
const struct encoding *LookupFirstEnc(
    const struct encoding *encRoot,
    const int              encSize,
    const struct encoding *encItem
)
{
	/* Back up to the first item with the same glyph name. */
	while (encItem>encRoot && !strcmp(encItem[-1].name, encItem[0].name))
		encItem--;

	return encItem;
}

/***
** Function: LookupNextEnc
**
** Description:
**   Locate the first encoding for a given glyph.
***/
const struct encoding *LookupNextEnc(
    const struct encoding *encRoot,
    const int              encSize,
    const struct encoding *encItem
)
{
	/* Back up to the first item with the same glyph name. */
	if (encItem<(&encRoot[encSize-1]) &&
		 !strcmp(encItem[0].name, encItem[1].name))
		return ++encItem;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\encoding.h ===
/***
 **
 **   Module: Encoding
 **
 **   Description:
 **      This is a module of the T1 to TT font converter. The module
 **      contains interface functions for the global encoding table,
 **      i.e. this is an abstract data type.
 **
 **   Author: Michael Jansson
 **
 **   Created: 6/13/93
 **
 ***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif


#define ENC_UNICODE   (USHORT)0   /* Unicode */
#define ENC_MSWINDOWS (USHORT)1   /* Microsoft Windows UGL sub-set encoding. */
#define ENC_STANDARD  (USHORT)2   /* Postscript Standard Encoding */
#define ENC_MACCODES  (USHORT)3   /* Mac encoding. */
#define ENC_MAXCODES  (USHORT)4

#define NOTDEFCODE (USHORT)0xffff /* 0xfffff is not a vaild code point so use
												 it for the .notdef character. */
#define NOTDEFINIT	0xffffffffL	 /* Used to init encoding arrays. */
#define NOTDEFGLYPH	(USHORT)0	 /* Glyph zero must be the notdef glyph. */
#define NULLGLYPH		(USHORT)1	 /* Glyph one must be the null glyph. */

/***
** Function: LookupNotDef
**
** Description:
**   look up a the .notdef character
***/
const struct encoding   *LookupNotDef        _ARGS((void));


/***
** Function: LookupPSName
**
** Description:
**   Do a binary search for a postscript name, and return
**   a handle that can be used to look up a the character
**   code for a specific encoding schema.
***/
struct encoding   *LookupPSName        _ARGS((IN      struct encoding *table,
                                              INOUT   USHORT size,
                                              IN      char *name));


/***
** Function: LookupCharName
**
** Description:
**   look up a the character name for a
**   specific encoding scheme.
***/
const char        *LookupCharName      _ARGS((IN      struct encoding *enc));


/***
** Function: LookupCharCode
**
** Description:
**   look up a the character code for a
**   specific encoding scheme.
***/
USHORT            LookupCharCode       _ARGS((IN      struct encoding *enc,
                                              IN      USHORT type));

/***
** Function: DecodeChar
**
** Description:
**   look up an encoding record for a character code in some
**   known encoding.
***/
const struct encoding   *DecodeChar    _ARGS((IN   struct encoding *table,
                                              IN      USHORT size,
                                              IN      USHORT type,
                                              IN      USHORT code));
/***
** Function: AllocEncodingTable
**
** Description:
**   Create a new encoding ADT.
***/
struct encoding   *AllocEncodingTable  _ARGS((IN      USHORT num));


/***
** Function: SetEncodingEntry
**
** Description:
**   Set the mapping from a glyph name to character
**   codes for various platforms.
***/
void              SetEncodingEntry     _ARGS((INOUT   struct encoding *, 
                                              IN      USHORT entry,
                                              IN      char *name,
                                              IN      USHORT max,
                                              IN      USHORT *codes));
/***
** Function: RehashEncodingTable
**
** Description:
**   Prepare an encoding ADT so that entries can be
**   located in it.
***/
void              RehashEncodingTable  _ARGS((INOUT   struct encoding *, 
                                              IN      USHORT num));


/***
** Function: FreeEncoding
**
** Description:
**   Deallocate memory associated to the encoding array.
***/
void              FreeEncoding         _ARGS((INOUT   struct encoding *,
                                              IN      USHORT num));

/***
** Function: LookupFirstEnc
**
** Description:
**   Locate the first encoding for a given glyph.
***/
const struct encoding *LookupFirstEnc(const struct encoding *encRoot,
												  const int encSize,
												  const struct encoding *encItem);


/***
** Function: LookupNextEnc
**
** Description:
**   Locate the first encoding for a given glyph.
***/
const struct encoding *LookupNextEnc(const struct encoding *encRoot,
												 const int encSize,
												 const struct encoding *encItem);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\charstr.h ===
/***
 **
 **   Module: CharStr
 **
 **   Description:
 **    This is a module of the T1 to TT font converter. The module
 **    contain one function that interprets the commands in a T1
 **    CharString and builds a representation of the glyph for the
 **    it.
 **
 **   Author: Michael Jansson
 **
 **   Created: 5/26/93
 **
 ***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

struct Subrs {
   USHORT len;
   UBYTE *code;
};


struct T1Glyph;
struct Composite;
struct PSState;

/***
** Function: AllocPSState
**
** Description:
**   This function allocates the workspace
**   used by the t1 parser.
***/
struct PSState *AllocPSState     _ARGS((void));


/***
** Function: InitPS
**
** Description:
**   This function initiate the workspace
**   used by the t1 parser.
***/
void           InitPS            _ARGS((INOUT   struct PSState *ps));


/***
** Function: FreePSState
**
** Description:
**   This function frees the workspace
**   used by the t1 parser.
***/
void           FreePSState       _ARGS((INOUT   struct PSState *ps));


/***
** Function: ParseCharString
**
** Description:
**   This function parses a CharString and builds a
**   of the charstring glyph.
***/
errcode        ParseCharString   _ARGS((INOUT   struct T1Glyph *glyph,
                                        INOUT   struct Composite **comp,
                                        INOUT   struct PSState *ps,
                                        IN      struct Subrs *subrs,
                                        INOUT   UBYTE *code,
                                        INOUT   USHORT len));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\fileio.h ===
/***
**
**   Module: FileIO
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      is the interface towards all low level I/O functions that are
**      are available on the current platform.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

#ifndef FASTCALL
#  ifdef MSDOS
#     define FASTCALL   __fastcall
#  else
#     define FASTCALL
#  endif
#endif

#define READONLY  0
#define READWRITE 1

struct ioFile;



/***
** Function: io_Close
**
** Description:
**   This function closes an open file.
***/
errcode           io_CloseFile   _ARGS((INOUT   struct ioFile *fp));


/***
** Function: io_ReadOneByte
**
** Description:
**   This function reads one byte from the current position in 
**   the given file. 
***/
USHORT FASTCALL   io_ReadOneByte _ARGS((INOUT   struct ioFile *fp));


/***
** Function: io_FileError
**
** Description:
**   This function returns the current error status of the file.
***/
boolean           io_FileError   _ARGS((INOUT   struct ioFile *fp));


/***
** Function: io_FileTell
**
** Description:
**   This function returns the current position in the file.
***/
long FASTCALL     io_FileTell    _ARGS((INOUT   struct ioFile *fp));


/***
** Function: io_RemoveFile
**
** Description:
**   This function removes an already closed file.
***/
void FASTCALL     io_RemoveFile  _ARGS((IN      char *name));


/***
** Function: io_OpenFile
**
** Description:
**   This function opens a file.
***/
struct ioFile     *io_OpenFile   _ARGS((IN      char *name,
                                        IN      int mode));


/***
** Function: io_FileSeek
**
** Description:
**   This function moves the current position in the file,
**   relative the beginning of the file.
***/
long FASTCALL     io_FileSeek    _ARGS((INOUT   struct ioFile *fp,
                                        INOUT   long where));


/***
** Function: io_WriteBytes
**
** Description:
**   This function writes a number of bytes, starting at the 
**   current position in the file.
***/
USHORT FASTCALL   io_WriteBytes  _ARGS((IN      UBYTE *,
                                        INOUT   USHORT, struct ioFile *));


/***
** Function: io_ReadBytes
**
** Description:
**   This function reades a number of bytes, starting at the 
**   current position in the file.
***/
USHORT FASTCALL   io_ReadBytes   _ARGS((INOUT   UBYTE *buf,
                                        INOUT   USHORT len,
                                        INOUT   struct ioFile *fp));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\charstr.c ===
/***
 **
 **   Module: CharStr
 **
 **   Description:
 **    This is a module of the T1 to TT font converter. The module
 **    contain one function that interprets the commands in a T1
 **    CharString and builds a representation of the glyph for the
 **    it.
 **
 **   Author: Michael Jansson
 **
 **   Created: 5/26/93
 **
 ***/
    

/**** INCLUDES */
/* General types and definitions. */
#include <string.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"
#include "metrics.h"
#include "encoding.h"
#include "safemem.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "charstr.h"



/***** CONSTANTS */
#define MAXSTACK  24

#define BUFMARGIN    256

/* Known OtherSubr entries. */
#define HINT_END_FLEX      0
#define HINT_START_FLEX    1
#define HINT_MID_FLEX      2
#define HINT_REPLACEMENT   3


#define PSOP_HSTEM         1
#define PSOP_VSTEM         3
#define PSOP_VMOVETO       4
#define PSOP_RLINETO       5
#define PSOP_HLINETO       6
#define PSOP_VLINETO       7
#define PSOP_RRCURVETO     8
#define PSOP_CLOSEPATH     9
#define PSOP_CALLSUBR      10
#define PSOP_RETURN        11
#define PSOP_ESCAPE        12
#  define PSOP_DOTSECTION        0
#  define PSOP_VSTEM3            1
#  define PSOP_HSTEM3            2
#  define PSOP_SEAC              6
#  define PSOP_SBW               7
#  define PSOP_DIV               12
#  define PSOP_CALLOTHERSUBR     16
#  define PSOP_POP               17
#  define PSOP_SETCURRENTPOINT   33
#define PSOP_HSBW          13
#define PSOP_ENDCHAR       14
#define PSOP_RMOVETO       21
#define PSOP_HMOVETO       22
#define PSOP_VHCURVETO     30
#define PSOP_HVCURVETO     31




/***** LOCAL TYPES */
/* Referenced types. */
typedef struct PSState {
   long stack[MAXSTACK+2];
   Point *pts;
   ULONG *onoff;
   USHORT totpts;
   USHORT numpts;
   USHORT ptr;
   short hr;
   USHORT maxpts;
   USHORT flex;
   Point flexref;
	int calls;
	long otherargs[16];
	USHORT otherptr;
} PSState;



/***** MACROS */
#define AddPoint(ps, px, py) {ps->pts[ps->numpts].x = px;\
                              ps->pts[ps->numpts].y = py;\
                              ps->numpts++;}
#define CurrXPoint(ps)        ps->pts[ps->numpts-1].x
#define CurrYPoint(ps)        ps->pts[ps->numpts-1].y
#define PrevPoint(ps, index)  ps->pts[ps->numpts-1-index]

#define PushStack(v)    ps->stack[(ps->ptr)++] = (v)
#define PopStack()      ps->stack[--(ps->ptr)]




/***** STATIC FUNCTIONS */

/***
 ** Function: AddCSpline
 **
 ** Description:
 **   Record a cubic spline.
 **
 ***/
static void AddCSpline(PSState *ps,
                       const funit x1, const funit y1,
                       const funit x2, const funit y2,
                       const funit x3, const funit y3)
{
   SetOffPoint(ps->onoff, ps->numpts);
   AddPoint(ps, x1, y1);
   SetOffPoint(ps->onoff, ps->numpts);
   AddPoint(ps, x2, y2);
   SetOnPoint(ps->onoff, ps->numpts);
   AddPoint(ps, x3, y3);
}


/***
** Function: HintReplacement
**
** Description:
**   This function limits the range of points which are
**   affected by stem hints. It may be invoked by the 
**   "dotsection" and the more general hint replacement
**   mechanism found in T1 fonts.
***/
static void HintReplacement(T1Glyph *glyph, const short hr)
{
   Stem *stem;
   Stem3 *stem3;

   /* Dead stem hints?, e.g. replaced before ever used? */
   if (hr==ENDOFPATH) {
      for (stem=glyph->hints.hstems; stem; stem=stem->next)
         if (stem->i2==ENDOFPATH)
            stem->i2 = NORANGE;
      for (stem=glyph->hints.vstems; stem; stem=stem->next)
         if (stem->i2==ENDOFPATH)
            stem->i2 = NORANGE;
      for (stem3=glyph->hints.hstems3; stem3; stem3=stem3->next) {
         if (stem3->stem1.i2==ENDOFPATH) {
            stem3->stem1.i2 = NORANGE;
            stem3->stem2.i2 = NORANGE;
            stem3->stem3.i2 = NORANGE;
         }
      }
      for (stem3=glyph->hints.vstems3; stem3; stem3=stem3->next) {
         if (stem3->stem1.i2==ENDOFPATH) {
            stem3->stem1.i2 = NORANGE;
            stem3->stem2.i2 = NORANGE;
            stem3->stem3.i2 = NORANGE;
         }
      }

   /* Set the end-point for the stem hints that are replaced. */
   } else {

      for (stem=glyph->hints.hstems; stem; stem=stem->next)
         if (stem->i2==ENDOFPATH)
            stem->i2 = hr;
      for (stem=glyph->hints.vstems; stem; stem=stem->next)
         if (stem->i2==ENDOFPATH)
            stem->i2 = hr;
      for (stem3=glyph->hints.hstems3; stem3; stem3=stem3->next) {
         if (stem3->stem1.i2==ENDOFPATH) {
            stem3->stem1.i2 = hr;
            stem3->stem2.i2 = hr;
            stem3->stem3.i2 = hr;
         }
      }
      for (stem3=glyph->hints.vstems3; stem3; stem3=stem3->next) {
         if (stem3->stem1.i2==ENDOFPATH) {
            stem3->stem1.i2 = hr;
            stem3->stem2.i2 = hr;
            stem3->stem3.i2 = hr;
         }
      }
   }
}   


/***
** Function: NewFlex
**
** Description:
**   This function records a new flex hint for
**   the current glyph.
***/
static Flex *NewFlex(const Point ref,
                     const Point midpos,
                     const Point startpos,
                     const USHORT start,
                     const USHORT mid,
                     const USHORT end,
                     const funit civ)

{
   Flex *flex = NULL;

   if ((flex = Malloc(sizeof(Flex)))!=NULL) {
      flex->civ = civ;
      flex->pos = ref;
      flex->midpos = midpos;
      flex->startpos = startpos;
      flex->start = start;
      flex->mid = mid;
      flex->end = end;
   }

   return flex;
}



/***
** Function: NewStem
**
** Description:
**   This function records a new stem hint for
**   the current glyph.
***/
static Stem *NewStem(const funit offset,
                     const funit width,
                     const short hr)
{
   Stem *stem = NULL;

   if ((stem = Malloc(sizeof(Stem)))!=NULL) {
      if (width>0) {
         stem->offset = offset;
         stem->width = width;
      } else {
         stem->offset = offset+width;
         stem->width = -width;
      }
      stem->i1 = hr;
      stem->i2 = ENDOFPATH;
   }

   return stem;
}



/***
** Function: NewStem3
**
** Description:
**   This function records a new stem3 hint for the current glyph.
***/
static Stem3 *NewStem3(const funit o1, const funit w1,
                       const funit o2, const funit w2,
                       const funit o3, const funit w3,
                       const short hr)
{
   Stem3 *stem3 = NULL;

   if ((stem3 = Malloc(sizeof(Stem3)))!=NULL) {

      stem3->stem1.offset = o1;
      stem3->stem1.width = w1;
      stem3->stem1.i1 = hr;
      stem3->stem1.i2 = ENDOFPATH;

      stem3->stem2.offset = o2;
      stem3->stem2.width = w2;
      stem3->stem2.i1 = hr;
      stem3->stem2.i2 = ENDOFPATH;

      stem3->stem3.offset = o3;
      stem3->stem3.width = w3;
      stem3->stem3.i1 = hr;
      stem3->stem3.i2 = ENDOFPATH;
   }

   return stem3;
}



/***
** Function: NewPath
**
** Description:
**   This function adds a new contour to the current glyph.
***/
static errcode NewPath(T1Glyph *glyph,
                       const Point *pts,
                       ULONG *onoff,
                       const USHORT numpts)
{
   errcode status = SUCCESS;
   Outline *path;
   Outline *prev;

   /* Skip 1,2 point paths. */
   if (numpts>2) {
      if ((path=Malloc(sizeof(Outline)))==NULL) {
         SetError(status = NOMEM);
      } else {

         path->pts=Malloc(sizeof(Point)*numpts);
         path->onoff=Malloc(ONOFFSIZE(numpts));
         if (path->pts==NULL || path->onoff==NULL) {
            if (path->pts)
               Free(path->pts);
            if (path->onoff)
               Free(path->onoff);
            Free(path);
            return NOMEM;
         }

         /* Initiate the new sub-path. */
         memcpy(path->pts, pts, sizeof(Point)*numpts);
         memcpy(path->onoff, onoff, ONOFFSIZE(numpts));
         path->count = numpts;

         /* Link it in. */
         path->next = NULL;
         if (glyph->paths==NULL) {
            glyph->paths = path;
         } else {
            for (prev = glyph->paths; prev->next; prev=prev->next);
            prev->next = path;
         }
      }
   }

   return status;
}



/***** FUNCTIONS */

/***
** Function: AllocPSState
**
** Description:
**   This function allocates the workspace
**   used by the t1 parser.
***/
struct PSState *AllocPSState(void)
{
   struct PSState *ps;

   if ((ps = Malloc(sizeof(struct PSState)))!=NULL) {
      memset(ps, '\0', sizeof(struct PSState));
   }

   return ps;      
}


/***
** Function: FreePSState
**
** Description:
**   This function frees the workspace
**   used by the t1 parser.
***/
void FreePSState(struct PSState *ps)
{
   if (ps) {
      if (ps->onoff)
         Free(ps->onoff);
      if (ps->pts)
         Free(ps->pts);
   }

   Free(ps);
}


/***
** Function: InitPS
**
** Description:
**   This function initiate the workspace
**   used by the t1 parser.
***/
void InitPS(struct PSState *ps)
{
	ps->hr = 0;
	ps->totpts = 0;
	ps->ptr = 0;
	ps->calls = 0;
}


/***
** Function: ParseCharString
**
** Description:
**   This function parses a CharString and builds a
**   of the charstring glyph.
***/
errcode ParseCharString(T1Glyph *glyph,
                        struct Composite **comp,
                        PSState *ps,
                        const struct Subrs *subrs,
                        UBYTE *code,
                        USHORT len)
{
   Composite *c;
   Stem3 *stem3;
   Stem *stem;
   Flex *flex;
   long v, w;
   funit dx1, dy1, dx2, dy2, dx3, dy3;
   funit x0, y0, x1, y1, x2, y2, x3, y3;
   funit width, offset;
   funit o1, o2, o3, w1, w2, w3;
   long v1, v2, v3, v4;
   errcode status = SUCCESS;
   long subr, args;
   funit flexciv;
   char *glyph_name = NULL;
   USHORT zero[ENC_MAXCODES];
   char msg[64];
   int i;

   /* Keep track on the number of recursive calls. */
   ps->calls++;
   if (ps->calls>100) {
      LogError(MSG_ERROR, MSG_RECURSION, NULL);
      SetError(status = BADCHARSTRING);
      return status;
   }


   while (len) {
      v = *code++; len--;

      /* Check for space for the paths. */
      if (ps->numpts+4>=ps->maxpts) {
         Point *newpts;
         ULONG *newonoff;

         if ((newpts=Realloc(ps->pts,
                             sizeof(Point)*(ps->maxpts+BUFMARGIN)))==NULL)
            return NOMEM;
         else
            ps->pts = newpts;

         if ((newonoff=Realloc(ps->onoff,
                               ONOFFSIZE(ps->maxpts+BUFMARGIN)))==NULL)
            return NOMEM;
         else
            ps->onoff = newonoff;

         ps->maxpts += BUFMARGIN;
      }

	  /* Check the operator stack size. */
	  if ((ps->ptr+1)>=MAXSTACK) {
		  SetError(status = BADCHARSTRING);
		  return status;
	  }

      /* Decode integer. */
      if (v>=32) {
         if (v<=246)
            PushStack(v-139);
         else if (v<=250) {
            w = *code++; len--;
            PushStack((v-247)*256+w+108);
         } else if (v<=254) {
            w = *code++; len--;
            PushStack(-(v-251)*256-w-108);
         } else {
            v1 = *code++; len--;
            v2 = *code++; len--;
            v3 = *code++; len--;
            v4 = *code++; len--;
            PushStack(((v1*256+v2)*256+v3)*256+v4);
         }

         /* Decode command. */
      } else {
         switch (v) {
            case PSOP_HSTEM:
               width  = (funit)PopStack();
               offset = (funit)PopStack();
               if ((stem = NewStem(offset, width, ps->hr))==NULL)
                  return NOMEM;
               stem->next = glyph->hints.hstems;
               glyph->hints.hstems = stem;
               break;
            case PSOP_VSTEM:
               width  = (funit)PopStack();
               offset = (funit)PopStack()+glyph->lsb.x;
               if ((stem = NewStem(offset, width, (ps->hr)))==NULL)
                  return NOMEM;
               stem->next = glyph->hints.vstems;
               glyph->hints.vstems = stem;
               break;
            case PSOP_VMOVETO:
               CurrYPoint(ps) += (funit)PopStack();
               break;
            case PSOP_RLINETO:
               y1 = CurrYPoint(ps) + (funit)PopStack();
               x1 = CurrXPoint(ps) + (funit)PopStack();
               SetOnPoint(ps->onoff, ps->numpts);
               AddPoint(ps, x1, y1);
               break;
            case PSOP_HLINETO:
               x1 = CurrXPoint(ps) + (funit)PopStack();
               y1 = CurrYPoint(ps);
               SetOnPoint(ps->onoff, ps->numpts);
               AddPoint(ps, x1, y1);
               break;
            case PSOP_VLINETO:
               x1 = CurrXPoint(ps);
               y1 = CurrYPoint(ps) + (funit)PopStack();
               SetOnPoint(ps->onoff, ps->numpts);
               AddPoint(ps, x1, y1);
               break;
            case PSOP_RRCURVETO:
               dy3 = (funit)PopStack();
               dx3 = (funit)PopStack();
               dy2 = (funit)PopStack();
               dx2 = (funit)PopStack();
               dy1 = (funit)PopStack();
               dx1 = (funit)PopStack();

               x0 = CurrXPoint(ps);
               y0 = CurrYPoint(ps);
               x1 = x0 + dx1;
               y1 = y0 + dy1;
               x2 = x1 + dx2;
               y2 = y1 + dy2;
               x3 = x2 + dx3;
               y3 = y2 + dy3;

               AddCSpline(ps, x1, y1, x2, y2, x3, y3);
               break;
            case PSOP_CLOSEPATH:
               /* Add the path to the glyph. */
               if ((status = NewPath(glyph, ps->pts,
                                     ps->onoff, ps->numpts))!=SUCCESS)
                  return status;

               /* Current point = last point. */
               SetOnPoint(ps->onoff, 0);
               ps->pts[0] = ps->pts[ps->numpts-1];
               ps->totpts = (USHORT)(ps->totpts + ps->numpts);
               ps->numpts = 1;
               break;
            case PSOP_CALLSUBR:
               v = PopStack();
               if ((status = ParseCharString(glyph, comp, ps,
                                             subrs, subrs[v].code,
                                             subrs[v].len))!=SUCCESS)
                  return status;
               break;
            case PSOP_RETURN:
					ps->calls--;
               return SUCCESS;
            case PSOP_ESCAPE:
               v = *code++; len--;
               switch (v) {
                  case PSOP_DOTSECTION:
                     /* End of dot section? */
                     if (ps->numpts>1) {
                        ps->hr = (short)(ps->totpts+ps->numpts-1);
                        HintReplacement(glyph, (short)(ps->hr-1));
                     }
                     break;
                  case PSOP_VSTEM3:
                     w1 = (funit)PopStack();
                     o1 = (funit)PopStack()+glyph->lsb.x;
                     w2 = (funit)PopStack();
                     o2 = (funit)PopStack()+glyph->lsb.x;
                     w3 = (funit)PopStack();
                     o3 = (funit)PopStack()+glyph->lsb.x; 
                     if (o1>o2) {
                        SWAPINT(o1, o2);
                        SWAPINT(w1, w2);
                     }
                     if (o1>o3) {
                        SWAPINT(o1, o3);
                        SWAPINT(w1, w3);
                     }
                     if (o3<o2) {
                        SWAPINT(o2, o3);
                        SWAPINT(w2, w3);
                     }
                     if ((stem3 = NewStem3(o1, w1,
                                           o2, w2,
                                           o3, w3,
                                           ps->hr))==NULL)
                        return NOMEM;
                     stem3->next = glyph->hints.vstems3;
                     glyph->hints.vstems3 = stem3;
                     break;
                  case PSOP_HSTEM3:
                     w1 = (funit)PopStack(); o1 = (funit)PopStack();
                     w2 = (funit)PopStack(); o2 = (funit)PopStack();
                     w3 = (funit)PopStack(); o3 = (funit)PopStack(); 
                     if ((stem3 = NewStem3(o1, w1,
                                           o2, w2,
                                           o3, w3,
                                           ps->hr))==NULL)
                        return NOMEM;
                     stem3->next = glyph->hints.hstems3;
                     glyph->hints.hstems3 = stem3;
                     break;
                  case PSOP_SEAC:
                     if ((c=Malloc(sizeof(Composite)))==NULL) {
                        return NOMEM;
                     }
                     c->aw = glyph->width.x;
                     c->achar = LookupCharName(DecodeChar(NULL, (USHORT)0,
                                                          ENC_STANDARD,
                                                          (USHORT)PopStack()));
                     c->bchar = LookupCharName(DecodeChar(NULL, (USHORT)0,
                                                          ENC_STANDARD,
                                                          (USHORT)PopStack()));
                     if ((c->cchar = Strdup(glyph->name))==NULL)
                        return NOMEM;
                     c->oenc = NULL;
                     c->ady = (funit)PopStack();
                     c->adx = (funit)PopStack();
                     c->asbx = (funit)PopStack();
                     c->next = *comp;
                     *comp = c;
                     if (glyph->paths==NULL)
                        return SKIP;
                     if ((glyph->name = Malloc(strlen(c->achar)+
                                               strlen(c->bchar)+2))==NULL ||
                         (c->oenc = AllocEncodingTable((USHORT)1))==NULL) {
                        if (glyph->name)
                           Free(glyph->name);
                        if (c->oenc) 
                           Free(c->oenc);
                        return NOMEM;
                     }
                     strcpy(glyph->name, c->bchar);
                     strcat(glyph->name, c->achar);
                     memset(zero, '\0', sizeof(zero[0])*ENC_MAXCODES);
                     if ((glyph_name = Strdup(glyph->name))!=NULL)
                        SetEncodingEntry(c->oenc, (USHORT)0, glyph_name,
                                         ENC_MAXCODES, zero);
                     else
                        return NOMEM;
                     break;
                  case PSOP_SBW:
                     glyph->width.y = (funit)PopStack();
                     glyph->width.x = (funit)PopStack();
                     glyph->lsb.y = (funit)PopStack();
                     glyph->lsb.x = (funit)PopStack();
                     ps->pts[0].x = glyph->lsb.x;
                     ps->pts[0].y = glyph->lsb.y;
                     ps->numpts = 1;
                     SetOnPoint(ps->onoff, 0);
                     break;
                  case PSOP_DIV:
                     /* LogError("Floating point precision lost.\n"); */       
                     y1 = (funit)PopStack();
                     x1 = (funit)PopStack();
					 if ((ps->ptr+1)>=MAXSTACK)
						 return BADCHARSTRING;
                     PushStack(((long)x1+(long)(y1>>1))/(long)y1);
                     break;
                  case PSOP_CALLOTHERSUBR:
                     subr = PopStack();
                     args = PopStack();

							/* Remember the arguments for future pop's. */
							for (i=0; i<args; i++) {
								ps->otherargs[i] = ps->stack[args-i-1];
							}
							ps->otherptr = 0;

                     switch (subr) {
                        case HINT_END_FLEX:
                           y0 = (funit)PopStack();
                           x0 = (funit)PopStack();
                           flexciv = (funit)PopStack();
                           ps->numpts--;
                           SetOffPoint(ps->onoff, ps->numpts-2);
                           SetOffPoint(ps->onoff, ps->numpts-3);
                           SetOffPoint(ps->onoff, ps->numpts-5);
                           SetOffPoint(ps->onoff, ps->numpts-6);
                           if ((flex = NewFlex(ps->flexref,
                                               PrevPoint(ps, 3),
                                               PrevPoint(ps, 6),
                                               (USHORT)(ps->totpts+
                                                        ps->numpts-7),
                                               (USHORT)(ps->totpts+
                                                        ps->numpts-4),
                                               (USHORT)(ps->totpts+
                                                        ps->numpts-1),
                                               flexciv))==NULL)
                              return NOMEM;
                           flex->next = glyph->hints.flex;
                           glyph->hints.flex = flex;
                           break;
                        case HINT_START_FLEX:
                           ps->flex = 1;
                           x0 = CurrXPoint(ps);
                           y0 = CurrYPoint(ps);
						   SetOnPoint(ps->onoff, ps->numpts);
                           AddPoint(ps, x0, y0);
                           break;
                        case HINT_MID_FLEX:
                           y0 = CurrYPoint(ps);
                           x0 = CurrXPoint(ps);
                           if (ps->flex==1) {
                              ps->flexref.x = x0;
                              ps->flexref.y = y0;
                              ps->flex=0;
                           } else {
							  SetOnPoint(ps->onoff, ps->numpts);
                              AddPoint(ps, x0, y0);
                           }
                           break;
                        case HINT_REPLACEMENT:
                           ps->hr = (short)(ps->totpts+ps->numpts-1);
                           HintReplacement(glyph, (short)(ps->hr-1));
                           (void)PopStack();
                           break;
                        default:
                           ps->ptr = (USHORT)(ps->ptr - args);
                           break;
                     }
                     break;
                        case PSOP_POP:
							if ((ps->ptr+1)>=MAXSTACK)
								return BADCHARSTRING;
							PushStack(ps->otherargs[ps->otherptr++]);
                           break;
                        case PSOP_SETCURRENTPOINT:
                           (ps->ptr) -= 2;
                           break;
                        case 15:
                           ps->ptr-=2;
                           break;
                        default:
                           LogError(MSG_ERROR, MSG_BADESC, NULL);
                           SetError(status = BADCHARSTRING);
                           return status;
               }
               break;
            case PSOP_HSBW:
               glyph->width.x = (funit)PopStack();
               glyph->width.y = 0;
               glyph->lsb.x = (funit)PopStack();
               glyph->lsb.y = 0;
               ps->pts[0].x = glyph->lsb.x;
               ps->pts[0].y = 0;
               ps->numpts = 1;
               SetOnPoint(ps->onoff, 0);
               break;
            case PSOP_ENDCHAR:
               if (ps->numpts>1) {
                  if ((status = NewPath(glyph, ps->pts,
                                        ps->onoff, ps->numpts))!=SUCCESS)
                     return status;
               }
               return SUCCESS;
            case PSOP_RMOVETO:
               CurrYPoint(ps) += (funit)PopStack();
               CurrXPoint(ps) += (funit)PopStack();
               break;
            case PSOP_HMOVETO:
               CurrXPoint(ps) += (funit)PopStack();
               break;
            case PSOP_VHCURVETO:
               dy3 = 0;
               dx3 = (funit)PopStack();
               dy2 = (funit)PopStack();
               dx2 = (funit)PopStack();
               dy1 = (funit)PopStack();
               dx1 = 0;

               x0 = CurrXPoint(ps);
               y0 = CurrYPoint(ps);
               x1 = x0 + dx1;
               y1 = y0 + dy1;
               x2 = x1 + dx2;
               y2 = y1 + dy2;
               x3 = x2 + dx3;
               y3 = y2 + dy3;

               AddCSpline(ps, x1, y1, x2, y2, x3, y3);
               break;
            case PSOP_HVCURVETO:
               dy3 = (funit)PopStack();
               dx3 = 0;
               dy2 = (funit)PopStack();
               dx2 = (funit)PopStack();
               dy1 = 0;
               dx1 = (funit)PopStack();

               x0 = CurrXPoint(ps);
               y0 = CurrYPoint(ps);
               x1 = x0 + dx1;
               y1 = y0 + dy1;
               x2 = x1 + dx2;
               y2 = y1 + dy2;
               x3 = x2 + dx3;
               y3 = y2 + dy3;

               AddCSpline(ps, x1, y1, x2, y2, x3, y3);
               break;
            case 15:
               ps->ptr -=2;
               break;

            default:
               strcpy(msg,  "'00' (00)");
               msg[1] = (char)('0' + (v/10));
               msg[2] = (char)('0' + (v%10));
               msg[6] = (char)('0' + (ps->ptr/10));
               msg[7] = (char)('0' + (ps->ptr%10));
               LogError(MSG_ERROR, MSG_BADOP, msg);
               SetError(status = BADCHARSTRING);
               return status;
         }
      }

      /* Check number of elements on the stack. */
      if (ps->ptr>MAXSTACK)
         return BADCHARSTRING;
   }

   return SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\fvscodes.h ===
#ifndef __FONT_VALIDATION_STATUS_CODES_H
#define __FONT_VALIDATION_STATUS_CODES_H

//
// Detailed status codes for function CheckInfWithStatusA().
// These codes were added after the initial creation of the T1 installer library.
// CheckInfA() returns TRUE/FALSE.  However, a FALSE return value was
// not sufficiently descriptive for a user interface to respond appropriately.
// The function CheckInfWithStatusA() was added to provide detailed status info.
// No new return points were added to T1 installer functions.  These codes merely
// replace the original TRUE/FALSE return values.
//
// These codes are also used in the font folder font validation functions.
//
// The code is designed to return information that identifies:
//    a) What happened.
//    b) What file the status applies to (if applicable).
//
//
// bit->  15                 7               0
//       +-+----------------+-----------------+
//       |S| Status Code    | File Type Code  |
//       +-+----------------+-----------------+
//        |
//        +--- Severity bit.
//
//             1 = Error.  A true error like file i/o, mem alloc etc.
//             0 = No error. But status may indicate invalid font file.
// 
//                 >>>>>>> NOTE <<<<<<<<
//
//   This file contains codes that are generated by the
//   T1 installer function CheckType1A and by related font folder functions.
//   Since both the T1 installer and the font folder must understand
//   these codes, the font folder must include this file.  I apologize for
//   this added coupling between the T1 installer and the font folder but
//   it is necessary for detailed status reporting [brianau].
//
#define FVS_FILE_UNK    0x00  // File unknown or "doesn't matter".
#define FVS_FILE_PFM    0x01  // PFM file
#define FVS_FILE_PFB    0x02  // PFB file
#define FVS_FILE_AFM    0x03  // AFM file
#define FVS_FILE_INF    0x04  // INF file
#define FVS_FILE_TTF    0x05  // TTF file
#define FVS_FILE_FOT    0x06  // FOT file

//
// Status codes.
//
#define FVS_SUCCESS                 0x00   // No problem!
#define FVS_INVALID_FONTFILE        0x01   // Invalid font file or file name.
#define FVS_BAD_VERSION             0x02   // File version not supported.
#define FVS_FILE_BUILD_ERR          0x03   // Error building a font file.
#define FVS_FILE_EXISTS             0x04   // File already exists.
#define FVS_FILE_OPEN_ERR           0x05   // Couldn't find/open existing file.

//
// These codes indicate true system errors.  Note use of high bit
// to indicate severity.
//
#define FVS_FILE_CREATE_ERR         0x80   // Couldn't create new file.
#define FVS_FILE_IO_ERR             0x81   // General file I/O error.
#define FVS_INVALID_ARG             0x82   // Invalid arg passed to function.
#define FVS_EXCEPTION               0x83   // Exception caught.
#define FVS_INSUFFICIENT_BUF        0x84   // Destination buf too small.
#define FVS_MEM_ALLOC_ERR           0x85   // Error allocating memory.
#define FVS_INVALID_STATUS          0x86   // For ensuring status was set.

//
// Macros for creating and parsing status codes.
//
#define FVS_MAKE_CODE(c,f)   ((WORD)(((BYTE)(c) << 8) | (BYTE)(f)))  // Build code
#define FVS_STATUS(c)        (((c) >> 8) & 0x00FF) // Get status part
#define FVS_FILE(c)          ((c) & 0x00FF)        // Get file part
#define FVS_ISERROR(c)       (((c) & 0x8000) != 0) // Severity bit == 1 ?

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\fwriter.h ===
/***
**
**   Module: T1Parser
**
**   Description:
**  This is a module of the T1 to TT font converter. The module
**  contains functions that is used by the Builder moduler, to
**  manage the lowlevel writing to the TT font file, as well as
**  generic check sum, table length and table offset computations.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef FWRITER_H
#define FWRITER_H

#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif


#define TBL_OS2   (USHORT)0
#define TBL_CMAP  (USHORT)1 
#define TBL_CVT   (USHORT)2 
#define TBL_FPGM  (USHORT)3 
#define TBL_GASP  (USHORT)4 
#define TBL_GLYF  (USHORT)5
#define TBL_HEAD  (USHORT)6 	      
#define TBL_HHEA  (USHORT)7 	      
#define TBL_HMTX  (USHORT)8 	      
#define TBL_KERN	(USHORT)9 
#define TBL_LOCA  (USHORT)10			 	      
#define TBL_MAXP  (USHORT)11			 	      
#define TBL_NAME  (USHORT)12			 	      
#define TBL_POST  (USHORT)13			 	      
#define TBL_PREP  (USHORT)14			 
#define NUMTBL    15L
#define TBLDIRSIZE (4L+4L+4L+4L)

/* Referenced types. */
typedef struct ioFile OutputFile;




/***
** Function: WriteTableHeader
**
** Description:
**   This function initiates a TT font file, by initiating 
**   a handle used when writing the tables and by writing
**   the leading table dictionary of the file.
***/
void        WriteTableHeader  _ARGS((INOUT   OutputFile *file));


/***
** Function: OpenOutputFile
**
** Description:
***/
OutputFile  *OpenOutputFile   _ARGS((IN      char *name));


/***
** Function: CloseOutputFile
**
** Description:
***/
errcode     CloseOutputFile   _ARGS((INOUT   OutputFile *fp));


/***
** Function: FileError
**
** Description:
***/
boolean     FileError         _ARGS((INOUT   OutputFile *fp));


/***
** Function: FileTell
**
** Description:
***/
long        FileTell          _ARGS((INOUT   OutputFile *fp));


/***
** Function: WriteLong
**
** Description:
**   This function writes a 32-bit integer in the
**   Big Endian byte order, regardless of the
**   used byte order.
***/
void        WriteLong         _ARGS((IN      ULONG val,
                                     INOUT   OutputFile *file));

/***
** Function: WriteShort
**
** Description:
**   This function writes a 16-bit integer in the
**   Big Endian byte order, regardless of the used
**   byte order.
***/
void        WriteShort        _ARGS((IN      USHORT val,

                                     INOUT   OutputFile *file));
/***
** Function: WriteByte
**
** Description:
**   This function writes an 8-bit integer in the
**   Big Endian byte order, regardless of used
**   byte order.
***/
void        WriteByte         _ARGS((IN      UBYTE val,
                                     INOUT   OutputFile *file));

/***
** Function: WriteChecksum
**
** Description:
**   This function completes the whole TT font file,
**   by computing the check sum of the whole file and writing
**   it at the designated place.
***/
void        WriteChecksum     _ARGS((IN      long offset,
                                     INOUT   OutputFile *file));

/***
** Function: FileSeek
**
** Description:
***/
long        FileSeek          _ARGS((INOUT   OutputFile *fp,

                                     IN      long where));
/***
** Function: WriteBytes
**
** Description:
***/
USHORT      WriteBytes        _ARGS((IN      UBYTE *buf,
                                     IN      USHORT len,
                                     INOUT   OutputFile *fp));
/***
** Function: CompleteTable
**
** Description:
**   This function completes a TT font file table,
**   by computing the check sum and writing it, the
**   table length and table offset to the table directory
**   of the TT font file.
**
**   Please note the dependency that this function must
**   be called right after the last byte of the contents
**   of the table have been written.
***/
errcode     CompleteTable     _ARGS((IN      long offset,
                                     IN      USHORT num,
                                     INOUT   OutputFile *file));
/***
** Function: RemoveFile
**
** Description:
**  Removes an already closed output file.
***/
void        RemoveFile        _ARGS((IN      char *name));
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\makepfm.c ===
//---------------------------------------------------------------------------
// makepfm.c
//---------------------------------------------------------------------------
// Create PFM file for Rev-3 fonts
//---------------------------------------------------------------------------
//
//      Copyright 1990, 1991 -- Adobe Systems, Inc.
//      PostScript is a trademark of Adobe Systems, Inc.
//
// NOTICE:  All information contained herein or attendant hereto is, and
// remains, the property of Adobe Systems, Inc.  Many of the intellectual
// and technical concepts contained herein are proprietary to Adobe Systems,
// Inc. and may be covered by U.S. and Foreign Patents or Patents Pending or
// are protected as trade secrets.  Any dissemination of this information or
// reproduction of this material are strictly forbidden unless prior written
// permission is obtained from Adobe Systems, Inc.
//
//---------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <ctype.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>

#include "windows.h"
#pragma pack(1)
#include "makepfm.h"
#pragma pack(4)

#include "fvscodes.h"  // FVS_xxxxxx (font validation status) codes and macros.

#ifdef WIN30
  #define LPCSTR LPSTR
#endif


#define WINATM 1
#if !WINATM
LPSZ stringtable[] = {
"MAKEPFM utility version %s released on %s.\n",
"Copyright (C) 1989-91, Adobe Systems Inc. All Rights Reserved.\n\n",
"Usage: makepfm [options] AFMfile\n",
"  -h n   - set device to PCL (n=1 for 1 byte typeface, 2 for 2 byte).\n",
"  -p n   - integral point size - only for PCL.\n",
"  -c str - PCL symbol set (9U for WinAnsi for example) - only for PCL.\n",
"  -d     - set orientation to landscape - only for PCL.\n",
"  -e str - encoding file.\n",
"  -o str - output file.\n",
"  -i str - fontinfo file.\n",
"  -l str - optional log file - defaults to \"user.log\".\n",
"  -f str - take input parameters from file instead of command line.\n",
"  -w     - display warning messages.\n",
"  -s n   - force dfCharSet to n.\n",
"Unrecognized command-line option: '%s'\n",
"Unable to open: %s\n",
"Too many track kerning data. Ignoring after %d.\n",
"Unexpected end of file - expected: %s\n",
"Expected: %s - current line: %s\n",
"Parsing character metrics - current line: %s\n",
"Parsing %s.\n",
"Missing \"MSFamily\" value\n",
"Can't create: %s\n",
"Disk is full...\n",
"Memory allocation\n",
"encoding file",
"Creating font metrics ( %s )",
"Finished.\n",
NULL
};
#endif

AFM afm = { 0 };
static ETM etm;
static PFM pfm;
static PFMEXT pfmext;
static DRIVERINFO d;

typedef LPSZ GlyphName;

/* CHAR rgbBuffer[2048]; The file buffer */
CHAR rgbBuffer[8704] = "";   /* increased to handle an additional 512 bytes of width info */
static INT cbBuffer;         /* The number of bytes in the buffer */
static INT cbMaxBuffer;		 /* Maximum size of the buffer */
static LPSZ pbBuffer;        /* Ptr to current location in buffer */
static CHAR rgbLine[160];    /* The current line of text being processed */
static LPSZ szLine;          /* Ptr to the current location in the line */
static BOOL fEOF = FALSE;
static BOOL fUnGetLine = FALSE;

/*----------------------------------------------------------------------------*/
static LPSZ notdef = "";

#define IBULLET     0x095   /* 87-1-15 sec (was 1) */
#define ISPACE      0x20
#define IWINSPACE   0xA0

static BOOL parseError;
static float sf;             /* scale factor for converting to display widths */

/* flags type of PFM to build POSTSCRIPT vs PCL */
INT devType = POSTSCRIPT;

PCLINFO pclinfo = { PORTRAIT, WINANSI_SET, epsymGENERIC8, 0, 0, 2, 0, NULL };
static SHORT fiCapHeight;
static GlyphName *glyphArray;
extern GlyphName *SetupGlyphArray(LPSZ) ;
INT charset = -1;
static BOOL forceVariablePitch = TRUE;

/* names, pointers, and handles for output, log and data files */
CHAR encfile[MAX_PATH] = "";
CHAR outfile[MAX_PATH] = "";
CHAR infofile[MAX_PATH] = "";

static INT fhIn;

#define TK_STARTKERNDATA      2
#define TK_STARTKERNPAIRS     3
#define TK_KPX                4
#define TK_ENDKERNPAIRS       5
#define TK_ENDKERNDATA        6
#define TK_FONTNAME           7
#define TK_WEIGHT             8
#define TK_ITALICANGLE        9
#define TK_ISFIXEDPITCH       10
#define TK_UNDERLINEPOSITION  11
#define TK_UNDERLINETHICKNESS 12
#define TK_FONTBBOX           13
#define TK_CAPHEIGHT          14
#define TK_XHEIGHT            15
#define TK_DESCENDER          16
#define TK_ASCENDER           17
#define TK_STARTCHARMETRICS   18
#define TK_ENDCHARMETRICS     19
#define TK_ENDFONTMETRICS     20
#define TK_STARTFONTMETRICS   21
#define TK_STARTTRACKKERN     22
#define TK_TRACKKERN          23
#define TK_ENDTRACKKERN       24

static KEY afmKeys[] = {
    "FontBBox",           TK_FONTBBOX,
    "StartFontMetrics",   TK_STARTFONTMETRICS,
    "FontName",           TK_FONTNAME,
    "Weight",             TK_WEIGHT,
    "ItalicAngle",        TK_ITALICANGLE,
    "IsFixedPitch",       TK_ISFIXEDPITCH,
    "UnderlinePosition",  TK_UNDERLINEPOSITION,
    "UnderlineThickness", TK_UNDERLINETHICKNESS,
    "CapHeight",          TK_CAPHEIGHT,
    "XHeight",            TK_XHEIGHT,
    "Descender",          TK_DESCENDER,
    "Ascender",           TK_ASCENDER,
    "StartCharMetrics",   TK_STARTCHARMETRICS,
    "EndCharMetrics",     TK_ENDCHARMETRICS,
    "StartKernData",      TK_STARTKERNDATA,
    "StartKernPairs",     TK_STARTKERNPAIRS,
    "KPX",                TK_KPX,
    "EndKernPairs",       TK_ENDKERNPAIRS,
    "EndKernData",        TK_ENDKERNDATA,
    "EndFontMetrics",     TK_ENDFONTMETRICS,
    "StartTrackKern",     TK_STARTTRACKKERN,
    "TrackKern",          TK_TRACKKERN,
    "EndTrackKern",       TK_ENDTRACKKERN,
    NULL,                 0
    };

#define CVTTOSCR(i)  (INT)(((float)(i) * sf) + 0.5)
#define DRIVERINFO_VERSION      (1)

/*----------------------------------------------------------------------------*/
VOID KxSort(KX *, KX *);
INT GetCharCode(LPSZ,  GlyphName *);
VOID ParseKernPairs(INT);
VOID ParseTrackKern(INT);
VOID ParseKernData(INT);
VOID ParseFontName(VOID);
VOID ParseMSFields(VOID);
VOID ParseCharMetrics(BOOL);
VOID ParseCharBox(BBOX *);
LPSZ ParseCharName(VOID);
INT ParseCharWidth(VOID);
INT ParseCharCode(VOID);
VOID ParseBoundingBox(BOOL);
VOID ParsePitchType(VOID);
VOID InitAfm(VOID);
short _MakePfm(VOID);
BOOL ReadFontInfo(INT);
VOID GetCharMetrics(INT, CM *);
VOID SetCharMetrics(INT, CM *);
VOID GetSmallCM(INT, CM *);
VOID SetFractionMetrics(INT, INT, INT, INT);
VOID FixCharWidths(VOID);
VOID SetAfm(VOID);
VOID SetAvgWidth(VOID);
VOID SetMaxWidth(VOID);

/*----------------------------------------------------------------------------*/
VOID ResetBuffer(VOID);
VOID PutByte(SHORT);
VOID PutRgb(LPSZ, INT);
VOID PutWord(SHORT);
VOID PutLong(long);
VOID SetDf(INT);
VOID PutString(LPSZ);
VOID PutDeviceName(LPSZ);
VOID PutFaceName(VOID);
BOOL MakeDf(BOOL, SHORT, LPSZ);
VOID PutPairKernTable(SHORT);
VOID PutTrackKernTable(SHORT);
VOID PutExtentOrWidthTable(INT);
BOOL WritePfm(LPSZ);

/*----------------------------------------------------------------------------*/
VOID SetDriverInfo(VOID);
VOID PutDriverInfo(INT);
LPSZ GetEscapeSequence(VOID);

/*----------------------------------------------------------------------------*/
VOID AfmToEtm(BOOL);
VOID PutEtm(BOOL);

/*----------------------------------------------------------------------------*/
VOID StartParse(VOID);
BOOL szIsEqual(LPSZ, LPSZ);
VOID szMove(LPSZ, LPSZ, INT);
BOOL GetBuffer(INT);
VOID UnGetLine(VOID);
BOOL GetLine(INT);
BOOL _GetLine(INT);
VOID EatWhite(VOID);
VOID GetWord(LPSZ, INT);
BOOL GetString(LPSZ, INT);
BOOL GetNumber(SHORT *);
BOOL GetFloat(float *, SHORT *);
INT MapToken(LPSZ, KEY *);
INT GetToken(INT, KEY *);

/*----------------------------------------------------------------------------*/
GlyphName *AllocateGlyphArray(INT);
VOID PutGlyphName(GlyphName *, INT, LPSZ);

/*----------------------------------------------------------------------------*/
#if DEBUG_MODE
VOID DumpAfm(VOID);
VOID DumpKernPairs(VOID);
VOID DumpKernTracks(VOID);
VOID DumpCharMetrics(VOID);
VOID DumpPfmHeader(VOID);
VOID DumpCharWidths(VOID);
VOID DumpPfmExtension(VOID);
VOID DumpDriverInfo(VOID);
VOID DumpEtm(VOID);
#endif

/*----------------------------------------------------------------------------*/
extern INT  OpenParseFile(LPSZ);                 /* main.c */
extern INT  OpenTargetFile(LPSZ);
// extern VOID cdecl PostWarning(LPCSTR,  ...);
// extern VOID cdecl PostError(LPCSTR, ...);
extern LPVOID AllocateMem(UINT);
extern VOID FreeAllMem(VOID);
extern VOID WriteDots(VOID);
extern GlyphName *SetupGlyphArray(LPSZ);
#if !WINATM
extern GlyphName *NewGlyphArray(INT);
extern LPSZ ReadLine(FILE *, LPSZ, INT);
extern LPSZ FirstTokenOnLine(FILE *, LPSZ, INT);
extern LPSZ Token(INT);
extern VOID ParseError(VOID);
#endif

/*----------------------------------------------------------------------------*/
/***************************************************************
* Name: KxSort()
* Action: Sort the pair kerning data using the quicksort algorithm.
******************************************************************/
VOID KxSort(pkx1, pkx2)
KX *pkx1;
KX *pkx2;
{
  static WORD iPivot;
  INT iKernAmount;
  KX *pkx1T;
  KX *pkx2T;

  if (pkx1>=pkx2) return;

  iPivot = pkx1->iKey;;
  iKernAmount = pkx1->iKernAmount;
  pkx1T = pkx1;
  pkx2T = pkx2;

  while (pkx1T < pkx2T)
    {
    while (pkx1T < pkx2T)
      {
      if (pkx2T->iKey < iPivot)
        {
        pkx1T->iKey = pkx2T->iKey;
        pkx1T->iKernAmount = pkx2T->iKernAmount;
        ++pkx1T;
        break;
        }
      else
        --pkx2T;
      }
    while (pkx1T < pkx2T)
      {
      if (pkx1T->iKey > iPivot)
        {
        pkx2T->iKey = pkx1T->iKey;
        pkx2T->iKernAmount = pkx1T->iKernAmount;
        --pkx2T;
        break;
        }
      else
        ++pkx1T;
      }
    }
  pkx2T->iKey = iPivot;
  pkx2T->iKernAmount = (SHORT)iKernAmount;
  ++pkx2T;
  if ((pkx1T - pkx1) < (pkx2 - pkx2T))
    {
    KxSort(pkx1, pkx1T);
    KxSort(pkx2T, pkx2);
    }
  else
    {
    KxSort(pkx2T, pkx2);
    KxSort(pkx1, pkx1T);
    }
}

/******************************************************************
* Name: GetCharCode(glyphname, glypharray)
* Action: Lookup glyphname in glypharray & return index.
********************************************************************/
INT GetCharCode(glyphname, glypharray)

LPSZ glyphname;
GlyphName *glypharray;
{
  register INT i;

  if ( STRCMP(glyphname, "") != 0 )
      for(i=0; glypharray[i]!=NULL; i++)
          if ( STRCMP(glypharray[i], glyphname) == 0 ) return(i);
  /* printf("GetCharCode: Undefined character = %s\n", glyphname); */
  return(-1);
}

/******************************************************************
* Name: ParseKernPairs()
* Action: Parse the pairwise kerning data.
********************************************************************/
VOID ParseKernPairs(pcl)
INT pcl;
{
  UINT iCh1, iCh2;
  KP *pkp;
  INT iToken;
  WORD cPairs, i;
  SHORT iKernAmount;
  CHAR szWord[80];

  GetNumber(&cPairs);
  if( cPairs == 0 )
      return;

  pkp = &afm.kp;
  pkp->cPairs = 0;
  pkp->rgPairs = (PKX) AllocateMem( (UINT) (sizeof(KX) * cPairs) );
  if( pkp->rgPairs == NULL ) {
      ; // PostError(str(MSG_PFM_BAD_MALLOC));
      parseError = TRUE;
      return;
      }

  for (i = 0; i < cPairs; ++i) {
      if( !GetLine(fhIn) ) break;
      if( GetToken(fhIn, afmKeys) != TK_KPX ) {
          UnGetLine();
          break;
          }
      GetWord(szWord, sizeof(szWord));
      iCh1 = (UINT)GetCharCode(szWord, glyphArray);
      GetWord(szWord, sizeof(szWord));
      iCh2 = (UINT)GetCharCode(szWord, glyphArray);
      GetNumber(&iKernAmount);

      /* no kern pairs for unencoded characters or miniscule kern amounts */
      if( (iCh1 == -1 || iCh2 == -1) || (pcl && CVTTOSCR(iKernAmount) == 0) )
          continue;

      pkp->rgPairs[pkp->cPairs].iKey = iCh2 << 8 | iCh1;
      pkp->rgPairs[pkp->cPairs++].iKernAmount =
                                       (pcl) ? CVTTOSCR(iKernAmount) : iKernAmount;
      }

  GetLine(fhIn);
  iToken = GetToken(fhIn, afmKeys);
  if( iToken == TK_EOF )
      ; // PostWarning(str(MSG_PFM_BAD_EOF), "EndKernPairs");
  else if( iToken != TK_ENDKERNPAIRS ) {
      ; // PostError(str(MSG_PFM_BAD_TOKEN), "EndKernPairs", rgbLine);
      parseError = TRUE;
      }
  KxSort(&afm.kp.rgPairs[0], &afm.kp.rgPairs[afm.kp.cPairs - 1]);
}

/******************************************************************
* Name: ParseTrackKern()
* Action: Parse the track kerning data.
********************************************************************/
VOID ParseTrackKern(pcl)
INT pcl;
{
  float one;
  INT i;
  KT *pkt;
  INT iToken;

  one = (float) 1;
  pkt = &afm.kt;
  GetNumber(&pkt->cTracks);
  if( pkt->cTracks > MAXTRACKS) ; // PostWarning(str(MSG_PFM_BAD_TRACK), MAXTRACKS);

  for (i = 0; i < pkt->cTracks; ++i) {
    if( !GetLine(fhIn) ) {
        ; // PostError(str(MSG_PFM_BAD_EOF), "EndTrackKern");
        parseError = TRUE;
        return;
        }
    if( GetToken(fhIn, afmKeys) != TK_TRACKKERN ) {
        ; // PostError(str(MSG_PFM_BAD_TOKEN), "EndTrackKern", rgbLine);
        parseError = TRUE;
        return;
        }
    if( i < MAXTRACKS) {
        GetNumber(&pkt->rgTracks[i].iDegree);
        GetFloat(&one, &pkt->rgTracks[i].iPtMin);
        (pcl) ? GetFloat(&sf, &pkt->rgTracks[i].iKernMin) :
                GetFloat(&one, &pkt->rgTracks[i].iKernMin);
        GetFloat(&one, &pkt->rgTracks[i].iPtMax);
        (pcl) ? GetFloat(&sf, &pkt->rgTracks[i].iKernMax) :
                GetFloat(&one, &pkt->rgTracks[i].iKernMax);
        }
    }

  GetLine(fhIn);
  iToken = GetToken(fhIn, afmKeys);
  if( iToken == TK_EOF ) {
    ; // PostError(str(MSG_PFM_BAD_EOF), "EndTrackKern");
    parseError = TRUE;
    }
  else if( iToken != TK_ENDTRACKKERN ) {
    ; // PostError(str(MSG_PFM_BAD_TOKEN), "EndTrackKern", rgbLine);
    parseError = TRUE;
    }
}

/********************************************************
* Name: ParseKernData()
* Action: Start processing the kerning data.
*************************************************************/
VOID ParseKernData(pcl)
INT pcl;
{
  INT iToken;
  do {
    if ( !GetLine(fhIn) ) {
        ; // PostError(str(MSG_PFM_BAD_EOF), "EndKernData");
        parseError = TRUE;
        }
    iToken = GetToken(fhIn, afmKeys);
    if( iToken == TK_STARTKERNPAIRS ) ParseKernPairs(pcl);
    else if( iToken == TK_STARTTRACKKERN ) ParseTrackKern(pcl);
    } while( iToken != TK_ENDKERNDATA);
}

/***********************************************************
* Name: ParseFontName()
* Action: Move the font name from the input buffer into the afm
*    structure.
**************************************************************/
VOID ParseFontName()
{
  EatWhite();
  szMove(afm.szFont, szLine, sizeof(afm.szFont));
}

/**************************************************************
* Name: ParseCharMetrics()
* Action: Parse the character metrics entry in the input file
*   and set the width and bounding box in the afm structure.
*****************************************************************/
VOID ParseCharMetrics(pcl)
BOOL pcl;
{
  SHORT cChars;
  INT i, iChar, iWidth;
  BBOX rcChar;

  if (afm.iFamily == FF_DECORATIVE)
      glyphArray = AllocateGlyphArray(255);
  else
      glyphArray = SetupGlyphArray(encfile);
  if( glyphArray == NULL ) {
      parseError = TRUE;
      return;
      }
  GetNumber(&cChars);
  for (i = 0; i < cChars; ++i) {
      if( !GetLine(fhIn) ) {
          ; // PostError(str(MSG_PFM_BAD_EOF), "EndCharMetrics");
          parseError = TRUE;
          return;
          }
      iChar = ParseCharCode();
      iWidth = ParseCharWidth();
      if( afm.iFamily == FF_DECORATIVE ) {
          if( iChar < 0 || iChar > 255 ) continue;
          PutGlyphName(glyphArray, iChar, ParseCharName());
      } else {
          iChar = GetCharCode(ParseCharName(), glyphArray);
          if( iChar == -1 ) continue;
          }
      ParseCharBox(&rcChar);
      if( parseError == TRUE ) return;

      afm.rgcm[iChar].iWidth = (pcl) ? CVTTOSCR(iWidth) : iWidth;
      afm.rgcm[iChar].rc.top = (pcl) ? CVTTOSCR(rcChar.top) : rcChar.top;
      afm.rgcm[iChar].rc.left = (pcl) ? CVTTOSCR(rcChar.left) : rcChar.left;
      afm.rgcm[iChar].rc.right = (pcl) ? CVTTOSCR(rcChar.right) : rcChar.right;
      afm.rgcm[iChar].rc.bottom = (pcl) ? CVTTOSCR(rcChar.bottom) : rcChar.bottom;
      }
  GetLine(fhIn);
  if (GetToken(fhIn, afmKeys)!=TK_ENDCHARMETRICS) {
      ; // PostError(str(MSG_PFM_BAD_TOKEN), "EndCharMetrics", rgbLine);
      parseError = TRUE;
      }
}

/***************************************************************
* Name: ParseCharBox()
* Action: Parse the character's bounding box and return its
*   dimensions in the destination rectangle.
*****************************************************************/
VOID ParseCharBox(prc)
BBOX *prc;   /* Pointer to the destination rectangle */
{
  CHAR szWord[16];

  GetWord(szWord, sizeof(szWord));
  if( szIsEqual("B", szWord) ) {
      GetNumber(&prc->left);
      GetNumber(&prc->bottom);
      GetNumber(&prc->right);
      GetNumber(&prc->top);
      }
  else {
      ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
      parseError = TRUE;
      return;
      }
  EatWhite();
  if (*szLine++ != ';') {
      ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
      parseError = TRUE;
      }
}

/*********************************************************
* Name: ParseCharName()
* Action: Parse a character's name
************************************************************/
LPSZ ParseCharName()
{
  static CHAR szWord[40];

  EatWhite();
  GetWord(szWord, sizeof(szWord));
  if (szIsEqual("N", szWord))
    GetWord(szWord, sizeof(szWord));
  else {
    ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
    parseError = TRUE;
    return(szWord);
    }
  EatWhite();
  if (*szLine++ != ';') {
    ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
    parseError = TRUE;
    }
  return(szWord);
}

/***********************************************************
* Name: ParseCharWidth()
* Action: Parse a character's width and return its numeric
*   value.
*************************************************************/
INT ParseCharWidth()
{
  SHORT iWidth = 0;
  CHAR szWord[16];


  GetWord(szWord, sizeof(szWord));
  if (szIsEqual("WX", szWord)) {
    GetNumber(&iWidth);
    if (iWidth==0) ; // PostWarning(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
    EatWhite();
    if (*szLine++ != ';') {
        ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
        parseError = TRUE;
        }
    }
  else {
    ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
    parseError = TRUE;
    }
  return(iWidth);
}

/*****************************************************************
* Name: ParseCharCode()
* Action: Parse the ascii form of a character's code point and
*   return its numeric value.
******************************************************************/
INT ParseCharCode()
{
  SHORT iChar;
  CHAR szWord[16];

  iChar = 0;
  GetWord(szWord, sizeof(szWord));
  if (szIsEqual("C", szWord)) {
    GetNumber(&iChar);
    if (iChar==0) {
        ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
        parseError = TRUE;
        return(0);
        }
    EatWhite();
    if (*szLine++ != ';') {
        ; // PostError(str(MSG_PFM_BAD_CHARMETRICS), rgbLine);
        parseError = TRUE;
        }
    }
  return(iChar);
}

/****************************************************************
* Name: ParseBounding Box()
* Action: Parse a character's bounding box and return its size in
*   the afm structure.
*******************************************************************/
VOID ParseBoundingBox(pcl)
BOOL pcl;
{
  SHORT i;

  /*  8-26-91 yh  Note that values in rcBBox are not scaled for PCL either */
  GetNumber(&i);
//  afm.rcBBox.left = (pcl) ? CVTTOSCR(i) : i;
  afm.rcBBox.left = i;
  GetNumber(&i);
//  afm.rcBBox.bottom = (pcl) ? CVTTOSCR(i) : i;
  afm.rcBBox.bottom = i;
  GetNumber(&i);
//  afm.rcBBox.right = (pcl) ? CVTTOSCR(i) : i;
  afm.rcBBox.right = i;
  GetNumber(&i);
//  afm.rcBBox.top = (pcl) ? CVTTOSCR(i) : i;
  afm.rcBBox.top = i;
}

/************************************************************
* Name: ParsePitchType()
*
* Action: Parse the pitch type and set the variable pitch
*      flag in the afm structure.
*         Always set the pitch to be variable pitch for
*         our fonts in Windows
*
**********************************************************/
VOID ParsePitchType()
{
  CHAR szWord[16];

  EatWhite();
  GetWord(szWord, sizeof(szWord));
  if( !STRCMP(_strlwr(szWord), "true" ) ) {
      afm.fWasVariablePitch = FALSE;
      afm.fVariablePitch = forceVariablePitch;
      }
//  afm.fVariablePitch = TRUE;
}

/***********************************************************
* Name: InitAfm()
* Action: Initialize the afm structure.
************************************************************/
VOID InitAfm()
{
  register int i;

  afm.iFirstChar = 0x20;
  afm.iLastChar = 0x0ff;
  afm.iAvgWidth = 0;
  afm.iMaxWidth = 0;
  afm.iItalicAngle = 0;
  afm.iFamily = 0;
  afm.ulOffset = 0;
  afm.ulThick = 0;
  afm.iAscent = 0;
  afm.iDescent = 0;
  afm.fVariablePitch = TRUE;
  afm.fWasVariablePitch = TRUE;
  afm.szFont[0] = 0;
  afm.szFace[0] = 0;
  afm.iWeight = 400;
  afm.kp.cPairs = 0;
  afm.kt.cTracks = 0;
  afm.rcBBox.left = 0;
  afm.rcBBox.bottom = 0;
  afm.rcBBox.right = 0;
  afm.rcBBox.top = 0;

  for(i=0; i<256; i++ ) {
      afm.rgcm[i].rc.left = 0;
      afm.rgcm[i].rc.bottom = 0;
      afm.rgcm[i].rc.right = 0;
      afm.rgcm[i].rc.top = 0;
      afm.rgcm[i].iWidth = 0;
      }
}

/*----------------------------------------------------------------------------
** Returns: 16-bit encoded value indicating error and type of file where
**          error occurred.  (see fvscodes.h) for definitions.
**          The following table lists the "status" portion of the codes
**          returned.
**
**           FVS_SUCCESS
**           FVS_INVALID_FONTFILE
**           FVS_FILE_OPEN_ERR
**           FVS_FILE_BUILD_ERR
*/
short _MakePfm()
{
  INT hfile;
  SHORT i;
  float ten = (float) 10;
  BOOL fPrint = FALSE, fEndOfInput = FALSE, fStartInput = FALSE;
  BOOL bRes;

  // if ( devType == PCL ) sf = ((float)afm.iPtSize / 1000.0) * (300.0 / 72.0);
  InitAfm();

  if( (hfile = OpenParseFile(infofile)) == -1 ) {
      ; // PostError(str(MSG_PFM_BAD_FOPEN), infofile);
      return(FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_INF));
      }
  if( !ReadFontInfo(hfile) ) {
      CLOSE(hfile);
      ; // PostError(str(MSG_PFM_BAD_PARSE), infofile);
      return(FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_INF));
      }
  CLOSE(hfile);

  if( (fhIn = OpenParseFile(afm.szFile)) == -1 ) {
      ; // PostError(str(MSG_PFM_BAD_FOPEN), afm.szFile);
      return(FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_AFM));
      }
  parseError = FALSE;
  while (!fEndOfInput) {
      if( !GetLine(fhIn) ) break;
      switch( GetToken(fhIn, afmKeys) ) {
          case TK_STARTFONTMETRICS:
              fStartInput = TRUE;
              break;
          case TK_STARTKERNDATA:
              ParseKernData(devType == PCL);
              break;
          case TK_FONTNAME:
              ParseFontName();
              break;
          case TK_WEIGHT:
              break;
          case TK_ITALICANGLE:
              GetFloat(&ten, &afm.iItalicAngle);
              break;
          case TK_ISFIXEDPITCH:
              ParsePitchType();
              break;
          case TK_UNDERLINEPOSITION:
              GetNumber(&i);
              afm.ulOffset = (devType==POSTSCRIPT) ? abs(i) : CVTTOSCR(abs(i));
              break;
          case TK_UNDERLINETHICKNESS:
              GetNumber(&i);
              afm.ulThick = (devType == POSTSCRIPT) ? i : CVTTOSCR(i);
              break;
          case TK_FONTBBOX:
              ParseBoundingBox(devType == PCL);
              break;
          case TK_CAPHEIGHT:
              GetNumber(&i);
              if( fiCapHeight == 0 ) fiCapHeight = i;
              break;
          case TK_XHEIGHT:
              break;
          case TK_DESCENDER:
              GetNumber(&i);
              afm.iDescent = (devType == POSTSCRIPT) ? i : CVTTOSCR(i);
              break;
          case TK_ASCENDER:
              GetNumber(&i);
              if (i < 667) i = 667;
              afm.iAscent = (devType == POSTSCRIPT) ? i : CVTTOSCR(i);
              break;
          case TK_STARTCHARMETRICS:
              if (afm.iFamily == 0) {
                  ; // PostError(str(MSG_PFM_MISSING_MSFAMILY));
                  CLOSE(fhIn);
                  return(FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_AFM));
                  }
              ParseCharMetrics(devType == PCL);
              break;
          case TK_ENDFONTMETRICS:
              fEndOfInput = TRUE;
              break;
          }
      if( parseError ) {
          CLOSE(fhIn);
          return(FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_AFM));
          }
      }
  CLOSE(fhIn);
  if( !fStartInput ) {
      ; // PostError(str(MSG_PFM_BAD_EOF), "StartFontMetrics");
      return(FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_AFM));
      }
  FixCharWidths();
  SetAfm();

#if DEBUG_MODE
  DumpAfm();
  DumpKernPairs();
  DumpKernTracks();
  DumpCharMetrics();
#endif
  bRes = MakeDf(FALSE, (SHORT)devType, outfile);
  FreeAllMem();
  return(bRes ? FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK) :
                FVS_MAKE_CODE(FVS_FILE_BUILD_ERR, FVS_FILE_PFM));
}

/*----------------------------------------------------------------------------*/
BOOL ReadFontInfo(hfile)
INT hfile;
{
  INT iToken;
  CHAR szTemp[6];
  BOOL found[LAST_FI_TOKEN+1];
  static KEY infKeys[] = {
      "MSMenuName",      TK_MSMENUNAME,
      "VPStyle",         TK_VPSTYLE,
      "Pi",              TK_PI,
      "Serif",           TK_SERIF,
      "PCLStyle",        TK_PCLSTYLE,
      "PCLStrokeWeight", TK_PCLSTROKEWEIGHT,
      "PCLTypefaceID",   TK_PCLTYPEFACEID,
      "CapHeight",       TK_INF_CAPHEIGHT,
      NULL, 0
      };

  fiCapHeight = 0;
  for(iToken=0; iToken<=LAST_FI_TOKEN; iToken++) found[iToken] = FALSE;
  while( GetLine(hfile) ) {
      iToken = GetToken(hfile,infKeys);
      found[iToken] = TRUE;
      switch(iToken) {
          case TK_MSMENUNAME:
              if( !GetString(afm.szFace, sizeof(afm.szFace)) ) return(FALSE);
              break;
          case TK_VPSTYLE:
              if( !GetString(szTemp, sizeof(szTemp)) ) return(FALSE);
              switch( toupper(szTemp[0]) ) {
                  case 'N':
                  case 'I': afm.iWeight = FW_NORMAL; break;
                  case 'B':
                  case 'T': afm.iWeight = FW_BOLD; break;
                  default:  return(FALSE); break;
                  }
              break;
          case TK_PI:
              GetWord(szTemp, sizeof(szTemp));
              if( !STRCMP(_strupr(szTemp), "TRUE") )
                  afm.iFamily = FF_DECORATIVE;
              else if( STRCMP(szTemp, "FALSE") ) return(FALSE);
              break;
          case TK_SERIF:
              GetWord(szTemp, sizeof(szTemp));
              if( !STRCMP(_strupr(szTemp), "TRUE") ) {
                  if( afm.iFamily != FF_DECORATIVE ) afm.iFamily = FF_ROMAN;
                  }
              else if( !STRCMP(szTemp, "FALSE") )  {
                  if( afm.iFamily != FF_DECORATIVE ) afm.iFamily = FF_SWISS;
                  }
              else return(FALSE);
              break;
          case TK_INF_CAPHEIGHT:
              GetNumber(&fiCapHeight);
              break;
          case TK_PCLSTYLE:
              GetNumber(&pclinfo.style);
              break;
          case TK_PCLSTROKEWEIGHT:
              GetNumber(&pclinfo.strokeWeight);
              break;
          case TK_PCLTYPEFACEID:
              GetNumber((SHORT *)&pclinfo.typeface);
              if( pclinfo.typefaceLen == 1 ) pclinfo.typeface &= 0xFF;
              break;
          }
      }
  if( found[TK_MSMENUNAME] == FALSE ||
      found[TK_VPSTYLE] == FALSE ||
      found[TK_PI] == FALSE ||
      found[TK_SERIF] == FALSE ||
      found[TK_INF_CAPHEIGHT] == FALSE ) return(FALSE);
  if ( devType == PCL )
      if( found[TK_PCLSTYLE] == FALSE ||
          found[TK_PCLSTROKEWEIGHT] == FALSE ||
          found[TK_PCLTYPEFACEID] == FALSE ) return(FALSE);
  return(TRUE);
}

#if DEBUG_MODE
/*----------------------------------------------------------------------------*/
VOID DumpAfm()
{
  printf("\nAFM HEADER\n");
  printf("afm.iFirstChar: %d\n", afm.iFirstChar);
  printf("afm.iLastChar: %d\n", afm.iLastChar);
  printf("afm.iPtSize: %d\n", afm.iPtSize);
  printf("afm.iAvgWidth: %d\n", afm.iAvgWidth);
  printf("afm.iMaxWidth: %d\n", afm.iMaxWidth);
  printf("afm.iItalicAngle: %d\n", afm.iItalicAngle);
  printf("afm.iFamily: %d\n", afm.iFamily);
  printf("afm.ulOffset: %d\n", afm.ulOffset);
  printf("afm.ulThick: %d\n", afm.ulThick);
  printf("afm.iAscent: %d\n", afm.iAscent);
  printf("afm.iDescent: %d\n", afm.iDescent);
  printf("afm.fVariablePitch: %d\n", afm.fVariablePitch);
  printf("afm.szFile: %s\n", afm.szFile);
  printf("afm.szFont: %s\n", afm.szFont);
  printf("afm.szFace: %s\n", afm.szFace);
  printf("afm.iWeight: %d\n", afm.iWeight);
  printf("afm.rcBBox - top: %d left: %d right: %d bottom: %d\n",
    afm.rcBBox.top, afm.rcBBox.left, afm.rcBBox.right, afm.rcBBox.bottom);
}
/*----------------------------------------------------------------------------*/
VOID DumpKernPairs()
{
  INT indx;

  printf("\nKERN PAIRS\n");
  printf("afm.kp.cPairs: %d\n", afm.kp.cPairs);
  for (indx = 0; indx < afm.kp.cPairs; indx++)
        printf("afm.kp.rgPairs[%d] - iKey: %u iKernAmount: %d\n", indx,
          afm.kp.rgPairs[indx].iKey, afm.kp.rgPairs[indx].iKernAmount);
}
/*----------------------------------------------------------------------------*/
VOID DumpKernTracks()
{
  INT indx;

  printf("\nKERN TRACKS\n");
  printf("afm.kt.cTracks: %d\n", afm.kt.cTracks);
  for (indx = 0; indx < afm.kt.cTracks; indx++) {
        printf("track: %d iDegree: %d iPtMin: %d iKernMin: %d iPtMax: %d iKernMax: %d\n",
          indx,
          afm.kt.rgTracks[indx].iDegree,
          afm.kt.rgTracks[indx].iPtMin,
          afm.kt.rgTracks[indx].iKernMin,
          afm.kt.rgTracks[indx].iPtMax,
          afm.kt.rgTracks[indx].iKernMax);
        }

}
/*----------------------------------------------------------------------------*/
VOID DumpCharMetrics()
{
  INT indx;

  printf("\nCHARACTER METRICS\n");
  for (indx = afm.iFirstChar; indx <= afm.iLastChar; ++indx) {
    printf("indx: %d width: %d top: %d left: %d right: %d bottom: %d\n",
          indx,
          afm.rgcm[indx].iWidth,
          afm.rgcm[indx].rc.top,
          afm.rgcm[indx].rc.left,
    afm.rgcm[indx].rc.right,
          afm.rgcm[indx].rc.bottom);
        }
}
/*----------------------------------------------------------------------------*/
#endif

/******************************************************
* Name: GetCharMetrics()
* Action: Get the character metrics for a specified character.
**********************************************************/
VOID GetCharMetrics(iChar, pcm)
INT iChar;
CM *pcm;
{
  CM *pcmSrc;

  pcmSrc = &afm.rgcm[iChar];
  pcm->iWidth = pcmSrc->iWidth;
  pcm->rc.top = pcmSrc->rc.top;
  pcm->rc.left = pcmSrc->rc.left;
  pcm->rc.bottom = pcmSrc->rc.bottom;
  pcm->rc.right = pcmSrc->rc.right;
}

/*************************************************************
* Name: SetCharMetrics()
* Action: Set the character metrics for a specified character.
***************************************************************/
VOID SetCharMetrics(iChar, pcm)
INT iChar;
CM *pcm;
{
  CM *pcmDst;

  pcmDst = &afm.rgcm[iChar];
  pcmDst->iWidth = pcm->iWidth;
  pcmDst->rc.top = pcm->rc.top;
  pcmDst->rc.left = pcm->rc.left;
  pcmDst->rc.bottom = pcm->rc.bottom;
  pcmDst->rc.right = pcm->rc.right;
}

/************************************************************
* Name: GetSmallCM()
* Action: Compute the character metrics for small sized characters
*   such as superscripts.
**************************************************************/
VOID GetSmallCM(iCh, pcm)
INT iCh;
CM *pcm;
{
  GetCharMetrics(iCh, pcm);
  pcm->iWidth = pcm->iWidth / 2;
  pcm->rc.bottom = pcm->rc.top + (pcm->rc.top - pcm->rc.bottom)/2;
  pcm->rc.right = pcm->rc.left + (pcm->rc.right - pcm->rc.left)/2;
}

/*************************************************************
* Name: SetFractionMetrics()
* Action: Set the character metrics for a fractional character
*   which must be simulated.
***************************************************************/
VOID SetFractionMetrics(iChar, iTop, iBottom, pcl)
INT iChar;        /* The character code point */
INT iTop;         /* The ascii numerator character */
INT iBottom;      /* The denominator character */
INT pcl;          /* device type */
{
  INT cxBottom;   /* The width of the denominator */
  CM cm;

#define IFRACTIONBAR  167

  /* Set denominator width to 60 percent of bottom character */
  GetCharMetrics(iBottom, &cm);
  cxBottom = (INT)((long)cm.iWidth * (long)((pcl) ? CVTTOSCR(60) : 60)
        / (long)((pcl) ? CVTTOSCR(100) : 100));

  /* Set numerator width to 40 percent of top character */
  GetCharMetrics(iTop, &cm);
  cxBottom = (INT)((long)cm.iWidth * (long)((pcl) ? CVTTOSCR(40) : 40)
        / (long)((pcl) ? CVTTOSCR(100) : 100));

  cm.iWidth = iTop + iBottom + (pcl) ? CVTTOSCR(IFRACTIONBAR) : IFRACTIONBAR;
  cm.rc.right = cm.rc.left + cm.iWidth;
  SetCharMetrics(iChar, &cm);
}

/***********************************************************************
* Name: FixCharWidths()
* Action: Fix up the character widths for those characters which
*   must be simulated in the driver.
*************************************************************************/
VOID FixCharWidths()
{
  CM cm;
  CM cmSubstitute;
  INT i;

#if 0
  if (afm.iFamily == FF_DECORATIVE) {
        GetCharMetrics(ISPACE, &cmSubstitute);
    for (i = afm.iFirstChar; i <= afm.iLastChar; ++i) {
          GetCharMetrics(i, &cm);
          if (cm.iWidth == 0) {
            SetCharMetrics(i, &cmSubstitute);
                }
          }
        return;
        }

  /* this is a text font */
  GetCharMetrics(IBULLET, &cmSubstitute);
  for (i=0x07f; i<0x091; ++i) SetCharMetrics(i, &cmSubstitute);
  for (i=0x098; i<0x0a1; ++i) SetCharMetrics(i, &cmSubstitute);
#else
  /* yh 8-27-91  Added some characters for Windows 3.1. */
  if (afm.iFamily == FF_DECORATIVE)
        GetCharMetrics(ISPACE, &cmSubstitute);
  else {                                  /* WINANSI encoding */
        GetCharMetrics(ISPACE, &cm);      /* 'space' is encoded twice */
        SetCharMetrics(IWINSPACE, &cm);
        GetCharMetrics(IBULLET, &cmSubstitute);
        }
  for (i = afm.iFirstChar; i <= afm.iLastChar; ++i) {
        GetCharMetrics(i, &cm);
        if (cm.iWidth == 0)
            SetCharMetrics(i, &cmSubstitute);
        }
#endif
}

/***************************************************************
* Name: SetAfm()
* Action: Set the character metrics in the afm to their default values.
********************************************************************/
VOID SetAfm()
{
  INT i, cx;

  afm.iFirstChar = 0x0020;
  afm.iLastChar = 0x00ff;

  if( !afm.fVariablePitch ) {
    cx = afm.rgcm[afm.iFirstChar].iWidth;
    for (i=afm.iFirstChar; i<=afm.iLastChar; ++i)
        afm.rgcm[i].iWidth = (SHORT)cx;
    }
  SetAvgWidth();
  SetMaxWidth();
}

/******************************************************************
* Name: SetAvgWidth()
* Action: This routine computes the average character width
*   from the character metrics in the afm structure.
********************************************************************/
VOID SetAvgWidth()
{
  CM *rgcm;
  INT i;
  long cx;    /* The average character width */
  long cb;    /* The number of characters */

  rgcm = afm.rgcm;

  cx = 0L;
  cb = (long) (afm.iLastChar - afm.iFirstChar + 1);
  for (i=afm.iFirstChar; i<=afm.iLastChar; ++i)
    cx += (long) rgcm[i].iWidth;
  afm.iAvgWidth = (INT) (cx / cb);
}

/*****************************************************************
* Name: SetMaxWidth()
* Action: This routine computes the maximum character width from
*   the character metrics in the afm structure.
*******************************************************************/
VOID SetMaxWidth()
{
  CM *rgcm;
  INT cx;
  INT i;

  rgcm = afm.rgcm;

  cx = 0;
  for (i=afm.iFirstChar; i<=afm.iLastChar; ++i)
    if (rgcm[i].iWidth > cx) cx = rgcm[i].iWidth;
  afm.iMaxWidth = (SHORT)cx;
}
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/******************************************************************
* Name: ResetBuffer()
* Action: This function resets the output buffer.
********************************************************************/
VOID ResetBuffer()
{
  pbBuffer = rgbBuffer;
  cbMaxBuffer = sizeof(rgbBuffer);
  cbBuffer = 0;
}

/****************************************************************
* Name: PutByte()
* Action: This function writes a byte to the output buffer.
******************************************************************/
VOID PutByte(iByte)
SHORT iByte;
{
	if ((cbBuffer+1)<cbMaxBuffer)
	{
		*pbBuffer++ = (BYTE) (iByte & 0x0ff);
		++cbBuffer;
	}
}

/****************************************************************
* Name: PutRgb()
* Action: This function writes an array of bytes to the output buffer.
******************************************************************/
VOID PutRgb(pb, cb)
LPSZ pb;
INT cb;
{
	while (--cb>=0)
		PutByte(*pb++);
}

/****************************************************************
* Name: PutWord()
* Action: This function writes a word to the output buffer.
******************************************************************/
VOID PutWord(iWord)
SHORT iWord;
{
	if ((cbBuffer+2)<cbMaxBuffer)
	{
		*pbBuffer++ = (CHAR) (iWord & 0x0ff);
		*pbBuffer++ = (CHAR) ( (iWord >> 8) & 0x0ff );
		cbBuffer += 2;
	}
}

/****************************************************************
* Name: PutLong()
* Action: This function writes a long word to the output buffer.
******************************************************************/
VOID PutLong(lWord)
long lWord;
{
  PutWord((WORD) (lWord & 0x0ffffL));
  lWord >>= 16;
  PutWord((WORD) (lWord & 0x0ffffL));
}

/**************************************************************
* Name: SetDf()
* Action: This function sets the values in the device font structure
*         from the values in the afm structure.
*****************************************************************/
static CHAR szCopyright[] = "Copyright 1988-1991 Adobe Systems Inc.";
VOID SetDf(pcl)
INT pcl;
{
//WORD minAscent;
  WORD pixHeight;
  WORD internalLeading;
  SHORT leading;
  #ifndef FF_MASKFAMILY
    #define FF_MASKFAMILY ((BYTE) 0xF0)
  #endif
  #define MAX(a,b) ((a)>(b)?(a):(b))

  pfm.iVersion = 0x0100;        /* Version 1.00 */
  szMove(pfm.szCopyright, szCopyright, sizeof(pfm.szCopyright));
  pfm.iType = (pcl) ? PCL_FONTTYPE : PS_FONTTYPE;
  pfm.iCharSet = (charset == -1) ? (BYTE) ANSI_CHARSET : (BYTE) charset;
   /* (pcl && (afm.iFamily==FF_DECORATIVE)) ? PCL_PI_CHARSET : ANSI_CHARSET );
      Windows WRITE only displays fonts with CharSet=0 in the menu */
  pfm.iDefaultChar = (BYTE) (
       ( (afm.iFamily==FF_DECORATIVE) ? ISPACE : IBULLET ) - afm.iFirstChar );
  pfm.iBreakChar = (BYTE) (ISPACE - afm.iFirstChar);

  /* for a scalable font (i.e. PostScript) default to 80 column text */
  pfm.iPoints = (pcl) ? afm.iPtSize : 10;

  /* if we ever support other bitmapped printers we will no longer be able
  to assume that the default x and y res are 300. */
  pfm.iVertRes = 300;
  pfm.iHorizRes = 300;
  pfm.iItalic = (BYTE) ((afm.iItalicAngle != 0) ? 1 : 0);
  pfm.iWeight = afm.iWeight;
  pfm.iPitchAndFamily = (BYTE) afm.iFamily;
  pfm.iFirstChar = (BYTE) afm.iFirstChar;
  pfm.iLastChar = (BYTE) afm.iLastChar;
  pfm.iAvgWidth = afm.iAvgWidth;
  pfm.iMaxWidth = afm.iMaxWidth;
  pfm.iPixWidth = (afm.fVariablePitch) ? 0 : afm.iAvgWidth;
/* pfm.iPixHeight = afm.rcBBox.top - afm.rcBBox.bottom;
 * Changed to reduce round off error.  8-26-91 yh
 */
  pixHeight = afm.rcBBox.top - afm.rcBBox.bottom;
  pfm.iPixHeight = (pcl) ? CVTTOSCR(pixHeight) : pixHeight;
/*  pfm.iInternalLeading =
 *    (pcl) ? pfm.iPixHeight - ((afm.iPtSize * 300) / 72) : 0;
 *  Changed to match ATM.  7-31-91 yh
 *  Changed to reduce round off error.  8-26-91 yh
 */
  internalLeading = max(0, pixHeight - EM);
  pfm.iInternalLeading = (pcl) ? CVTTOSCR(internalLeading) : internalLeading;

/*  pfm.iAscent = afm.rcBBox.top;
 *  Changed to fix text alignment problem.  10-08-90 yh
 */
/*  pfm.iAscent = afm.iAscent;
 *  Changed to match ATM.  7-31-91 yh
 *  Changed to reduce round off error.  8-26-91 yh
 */
  pfm.iAscent = (pcl) ?
                CVTTOSCR(EM + afm.rcBBox.bottom) + CVTTOSCR(internalLeading) :
                EM + afm.rcBBox.bottom + internalLeading;
/* Deleted to match ATM.  yh 9-13-91
 * minAscent = (pcl) ? CVTTOSCR(667) : 667;          2/3 of EM
 * if( pfm.iAscent < minAscent ) pfm.iAscent = minAscent;
 */

/*  pfm.iExternalLeading = 196; */
/*  Changed to 0 to fix a bug in PCL landscape.  Was getting huge leading. */
  /*
   * yh 8-26-91  Changed ExternalLeading for pcl to match ATM .
   */
  if (!pcl)
      /* PostScript driver ignores this field and comes up with own
       * ExternalLeading value.
       *
       * !!! HACK ALERT !!!
       *
       * ATM needs to have ExternalLeading=0.  PFMs generated with Rev. 2
       * MAKEPFM have a bug in default & break character fields.  We had
       * encoding number instead of offsets.  ATM uses following algorithm
       * to recognize the Rev. 2 PFMs:
       *     rev2pfm = pfmRec->fmExternalLeading != 0 &&
       *               etmRec->etmStrikeOutOffset == 500 &&
       *               pfmRec->fmDefaultChar >= pfmRec->fmFirstChar;
       * So, we need to make sure that either ExternalLeading stays zero or
       * StrikeOutOffset is not 500.  With current algorithm, StrikeOutOffset
       * is very likely to be less than 500.
       *     etm.iStrikeOutOffset = fiCapHeight / 2 - (afm.ulThick / 2);
       */
      pfm.iExternalLeading = 0;
  else if (!afm.fWasVariablePitch)
      pfm.iExternalLeading = 0;
  else                               /* pcl & Variable pitch */
      {
      /* Adjust external leading such that we are compatible */
      /* with the values returned by the PostScript driver.  */
      /* Who did this code??  Microsoft?  Has to be! */
      switch (pfm.iPitchAndFamily & FF_MASKFAMILY)
        {
        case FF_ROMAN:  leading = (pfm.iVertRes + 18) / 36; //2-pnt leading
                        break;
        case FF_SWISS:  if (pfm.iPoints <= 12)
                          leading = (pfm.iVertRes + 18) / 36; //2-pnt leading
                        else if (pfm.iPoints < 14)
                          leading = (pfm.iVertRes + 12) / 24; //3-pnt leading
                        else
                          leading = (pfm.iVertRes + 9) / 18; //4-pnt leading
                        break;
        default:                /* Give 19.6% of the height for leading. */
                        leading = (short) (
                                  (long) (pfm.iPixHeight-pfm.iInternalLeading)
                                  * 196L / 1000L );
                        break;
        }

      pfm.iExternalLeading = MAX(0, (SHORT)(leading - pfm.iInternalLeading));
      }

  pfm.iWidthBytes = 0;
  if (afm.fVariablePitch) pfm.iPitchAndFamily |= 1;

  pfm.iUnderline = 0;
  pfm.iStrikeOut = 0;
  pfm.oBitsPointer = 0L;
  pfm.oBitsOffset = 0L;
}

/**********************************************************
* Name: PutString()
* Action: This function writes a null terminated string
*       to the output file.
***********************************************************/
VOID PutString(sz)
LPSZ sz;
{
	INT bCh = 0;

	do    
	{
		if ((cbBuffer+1)<cbMaxBuffer)
		{
			bCh = *pbBuffer++ = *sz++;
			++cbBuffer;
		}
	} while( bCh && cbBuffer<cbMaxBuffer);
}

/***************************************************************
* Name: PutdeviceName()
* Action: This function writes the device name to the output file.
**************************************************************/
VOID PutDeviceName(szDevice)
LPSZ szDevice;
{
  pfm.oDevice = cbBuffer;
  PutString(szDevice);
}

/***************************************************************
* Name: PutFaceName()
* Action: This function writes the font's face name to the output file.
**************************************************************/
VOID PutFaceName()
{
  pfm.oFace = cbBuffer;
  PutString(afm.szFace);
}

/**************************************************************
* Name: MakeDf()
* Action: This function writes the device font info structure
*       to the output file.
* Method: This function makes two passes over the data. On the first pass
* it collects offset data as it places data in the output buffer. On the
* second pass, it first resets the output buffer and then writes the data
* to the output buffer again with the offsets computed from pass 1.
***************************************************************/
BOOL MakeDf(fPass2, devType, outfile)
BOOL fPass2;            /* TRUE if this is the second pass */
SHORT devType;  /* 1=POSTSCRIPT 2=PCL */
LPSZ outfile;
{
  BOOL result = TRUE;
  INT iMarker;

  ResetBuffer();
  SetDf(devType == PCL);

  /* put out the PFM header structure */
  PutWord(pfm.iVersion);
  PutLong(pfm.iSize);
  PutRgb(pfm.szCopyright, 60);
  PutWord(pfm.iType);
  PutWord(pfm.iPoints);
  PutWord(pfm.iVertRes);
  PutWord(pfm.iHorizRes);
  PutWord(pfm.iAscent);
  PutWord(pfm.iInternalLeading);
  PutWord(pfm.iExternalLeading);
  PutByte(pfm.iItalic);
  PutByte(pfm.iUnderline);
  PutByte(pfm.iStrikeOut);
  PutWord(pfm.iWeight);
  PutByte(pfm.iCharSet);
  PutWord(pfm.iPixWidth);
  PutWord(pfm.iPixHeight);
  PutByte(pfm.iPitchAndFamily);
  PutWord(pfm.iAvgWidth);
  PutWord(pfm.iMaxWidth);
  PutByte(pfm.iFirstChar);
  PutByte(pfm.iLastChar);
  PutByte(pfm.iDefaultChar);
  PutByte(pfm.iBreakChar);
  PutWord(pfm.iWidthBytes);
  PutLong(pfm.oDevice);
  PutLong(pfm.oFace);
  PutLong(pfm.oBitsPointer);
  PutLong(pfm.oBitsOffset);

  /* need to determine if proportional etc. */
  if (devType == PCL) PutExtentOrWidthTable(1);

  /* put out the PFM extension structure */
  iMarker = cbBuffer;
  PutWord(pfmext.oSizeFields);
  PutLong(pfmext.oExtMetricsOffset);
  PutLong(pfmext.oExtentTable);
  PutLong(pfmext.oOriginTable);
  PutLong(pfmext.oPairKernTable);
  PutLong(pfmext.oTrackKernTable);
  PutLong(pfmext.oDriverInfo);
  PutLong(pfmext.iReserved);
  pfmext.oSizeFields = cbBuffer - iMarker;
  if (devType == POSTSCRIPT) {
    /* Put the extended text metrics table */
    pfmext.oExtMetricsOffset = cbBuffer;
    PutEtm(FALSE);

    PutDeviceName("PostScript");
    PutFaceName();
    PutDriverInfo(FALSE);

    /* Put the extent table */
    PutExtentOrWidthTable(0);

    pfmext.oOriginTable = 0;
    pfmext.iReserved = 0;
    PutPairKernTable(POSTSCRIPT);
    PutTrackKernTable(POSTSCRIPT);
    }

  if (devType == PCL) {
    PutFaceName();
    PutDeviceName("PCL/HP LaserJet");

    /* Put the extended text metrics table */
    pfmext.oExtMetricsOffset = cbBuffer;
    PutEtm(TRUE);

    PutPairKernTable(PCL);
    PutTrackKernTable(PCL);

    PutDriverInfo(TRUE);
    pfmext.oOriginTable = 0;
    pfmext.iReserved = 0;
    }

  if( !fPass2 ) {
    pfm.iSize = (long)cbBuffer;
    if( !MakeDf(TRUE, devType, outfile) ) result = FALSE;
    }
  else {
    if( !WritePfm(outfile) ) result = FALSE;
#if DEBUG_MODE
    DumpPfmHeader();
    DumpCharWidths();
    DumpPfmExtension();
#endif
    }

  if (cbBuffer>=cbMaxBuffer) // Too complex font
	  result = FALSE;

  return(result);
}

/*******************************************************************
* Name: PutPairKernTable(devType)
* Action: Send the pairwise kerning table to the output file.
*********************************************************************/
VOID PutPairKernTable(devType)
SHORT devType;  /* 1=POSTSCRIPT 2=PCL */
{
  WORD i;

  if( afm.kp.cPairs > 0 ) {
      pfmext.oPairKernTable = cbBuffer;
#if DEBUG_MODE
      printf("Pair Kern Table - pairs: %d\n", afm.kp.cPairs);
#endif
      if( devType == POSTSCRIPT ) PutWord(afm.kp.cPairs);
      for (i = 0; i < afm.kp.cPairs; ++i) {
          PutWord(afm.kp.rgPairs[i].iKey);
          PutWord(afm.kp.rgPairs[i].iKernAmount);
#if DEBUG_MODE
          printf("key: %x kern amount: %d\n",
          afm.kp.rgPairs[i].iKey, afm.kp.rgPairs[i].iKernAmount);
#endif
          }
      }
  else
      pfmext.oPairKernTable = 0;
}

/******************************************************************
* Name: PutTrackKernTable(devType)
* Action: Send the track kerning table to the output file.
********************************************************************/
VOID PutTrackKernTable(devType)
SHORT devType;  /* 1=POSTSCRIPT 2=PCL */
{
  INT i;

  if (afm.kt.cTracks == 0)
    {
    pfmext.oTrackKernTable = 0;
    return;
    }

  pfmext.oTrackKernTable = cbBuffer;
  if (devType == POSTSCRIPT) PutWord(afm.kt.cTracks);
  for (i=0; i<afm.kt.cTracks; ++i)
    {
    PutWord(afm.kt.rgTracks[i].iDegree);
    PutWord(afm.kt.rgTracks[i].iPtMin);
    PutWord(afm.kt.rgTracks[i].iKernMin);
    PutWord(afm.kt.rgTracks[i].iPtMax);
    PutWord(afm.kt.rgTracks[i].iKernMax);
    }
}

/***************************************************************
* Name: PutExtentTable()
* Action: Send the character extent information to the output file.
*****************************************************************/
VOID PutExtentOrWidthTable(width)
INT width; /* 0=extent 1=width */
{
  INT i;

  /* is the typeface proportional ?? */
  if (pfm.iPitchAndFamily & 1)
    {
    pfmext.oExtentTable = (width) ? 0 : cbBuffer;
    for (i = afm.iFirstChar; i <= afm.iLastChar; i++)
      PutWord(afm.rgcm[i].iWidth);
    if (width) PutWord(0);
    }
  else
    pfmext.oExtentTable = 0;
}

/***********************************************************
* Name: WritePfm()
* Action: Flush the ouput buffer to the file.  Note that this
*         function is only called after the entire pfm structure
*         has been built in the output buffer.
*************************************************************/
BOOL WritePfm(outfile)
LPSZ outfile;
{
  INT fh;

  if( (fh = OpenTargetFile(outfile) ) == -1 ) {
      ; // PostError(str(MSG_PFM_BAD_CREATE), outfile);
      return(FALSE);
      }

  if( cbBuffer > 0  )
    if( (WORD)WRITE_BLOCK(fh, rgbBuffer, cbBuffer) != (WORD)cbBuffer ) {
        CLOSE(fh);
        ; // PostError(str(MSG_PFM_DISK_FULL));
        return(FALSE);
        }
  CLOSE(fh);
  return(TRUE);
}

#if DEBUG_MODE
/*----------------------------------------------------------------------------*/
VOID DumpPfmHeader()
{
  printf("\nDUMP PFM HEADER\n");
  printf("pfm.iVersion=%d\n",pfm.iVersion);
  printf("pfm.iSize=%ld\n",pfm.iSize);
  printf("pfm.szCopyright=%s\n",pfm.szCopyright);
  printf("pfm.iType=%d\n",pfm.iType);
  printf("pfm.iPoints=%d\n",pfm.iPoints);
  printf("pfm.iVertRes=%d\n",pfm.iVertRes);
  printf("pfm.iHorizRes=%d\n",pfm.iHorizRes);
  printf("pfm.iAscent=%d\n",pfm.iAscent);
  printf("pfm.iInternalLeading=%d\n",pfm.iInternalLeading);
  printf("pfm.iExternalLeading=%d\n",pfm.iExternalLeading);
  printf("pfm.iItalic=%d\n",pfm.iItalic);
  printf("pfm.iUnderline=%d\n",pfm.iUnderline);
  printf("pfm.iStrikeOut=%d\n",pfm.iStrikeOut);
  printf("pfm.iWeight=%d\n",pfm.iWeight);
  printf("pfm.iCharSet=%d\n",pfm.iCharSet);
  printf("pfm.iPixWidth=%d\n",pfm.iPixWidth);
  printf("pfm.iPixHeight=%d\n",pfm.iPixHeight);
  printf("pfm.iPitchAndFamily=%d\n",pfm.iPitchAndFamily);
  printf("pfm.iAvgWidth=%d\n",pfm.iAvgWidth);
  printf("pfm.iMaxWidth=%d\n",pfm.iMaxWidth);
  printf("pfm.iFirstChar=%c\n",pfm.iFirstChar);
  printf("pfm.iLastChar=%c\n",pfm.iLastChar);
  printf("pfm.iDefaultChar=%d\n",pfm.iDefaultChar);
  printf("pfm.iBreakChar=%d\n",pfm.iBreakChar);
  printf("pfm.iWidthBytes=%d\n",pfm.iWidthBytes);
  printf("pfm.oDevice=%x\n",pfm.oDevice);
  printf("pfm.oFace=%x\n",pfm.oFace);
  printf("pfm.oBitsPointer=%ld\n",pfm.oBitsPointer);
  printf("pfm.oBitsOffset=%ld\n",pfm.oBitsOffset);
}
/*----------------------------------------------------------------------------*/
VOID DumpCharWidths()
{
  INT indx;

  printf("\nCHARACTER WIDTHS\n");
  for (indx = afm.iFirstChar; indx <= afm.iLastChar; indx++)
    printf("indx: %d width: %d\n", indx, afm.rgcm[indx].iWidth);
}
/*----------------------------------------------------------------------------*/
VOID DumpPfmExtension()
{
  printf("\nDUMP PFM EXTENSION\n");
  printf("pfmext.oSizeFields=%d\n",pfmext.oSizeFields);
  printf("pfmext.oExtMetricsOffset=%x\n",pfmext.oExtMetricsOffset);
  printf("pfmext.oExtentTable=%x\n",pfmext.oExtentTable);
  printf("pfmext.oOriginTable=%x\n",pfmext.oOriginTable);
  printf("pfmext.oPairKernTable=%x\n",pfmext.oPairKernTable);
  printf("pfmext.oTrackKernTable=%x\n",pfmext.oTrackKernTable);
  printf("pfmext.oDriverInfo=%x\n",pfmext.oDriverInfo);
  printf("pfm.iReserved=%x\n",pfm.iReserved);
}
#endif
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Main purpose of these structures is to set up a translation table which
allows the driver to translate the font from the character set indicated in
the dfCharset field into the printer-specific character set. */

#define AVGSIZE  (30 * 1024)

VOID SetDriverInfo()
{
  INT i;
  long sumWidth = 0L;

  for (i = afm.iFirstChar; i <= afm.iLastChar; i++)
      sumWidth = sumWidth + (long)afm.rgcm[i].iWidth;

  d.epSize = sizeof(DRIVERINFO);
  d.epVersion = DRIVERINFO_VERSION;
  d.epMemUsage = (long) ( ((sumWidth+7L) >> 3) * (long)pfm.iPixHeight + 63L );
  d.xtbl.symbolSet = pclinfo.symbolsetNum;
  d.xtbl.offset = 0L;
  d.xtbl.len = 0;
  d.xtbl.firstchar = 0;
  d.xtbl.lastchar = 0;
  pclinfo.epEscapeSequence = GetEscapeSequence();
}
/*----------------------------------------------------------------------------*/
VOID PutDriverInfo(pcl)
INT pcl;
{
  pfmext.oDriverInfo = cbBuffer;
  if (pcl) {
    SetDriverInfo();
    PutWord(d.epSize);
    PutWord(d.epVersion);
    PutLong(d.epMemUsage);
    PutLong(d.epEscape);
    PutWord((WORD)d.xtbl.symbolSet);
    PutLong(d.xtbl.offset);
    PutWord(d.xtbl.len);
    PutByte(d.xtbl.firstchar);
    PutByte(d.xtbl.lastchar);
    d.epEscape = cbBuffer;
    PutString(pclinfo.epEscapeSequence);
  } else
    PutString(afm.szFont);
}

/*--------------------------------------------------------------------------*/
LPSZ GetEscapeSequence()
{
  static char escapeStr[80];
  char fixedPitch[2], pitch[10], height[10], *cp;
  int enc;
  float size;

  size = (float) afm.iPtSize;
  if( afm.fWasVariablePitch == TRUE ) {
      STRCPY(fixedPitch, "1");
      enc = ISPACE;
      }
  else {
      STRCPY(fixedPitch, "");
      enc = afm.iFirstChar;
      }
  sprintf(pitch, "%1.3f", 300.0 / (float)afm.rgcm[enc].iWidth);
  if( cp = strchr(pitch, '.') ) cp[3] = '\0';

  sprintf(height, "%1.2f", size);

  sprintf(escapeStr, "\x01B&l%dO\x01B(%s\x01B(s%sp%sh%sv%ds%db%uT",
          pclinfo.orientation, pclinfo.symbolsetStr,
          fixedPitch, pitch, height,
          pclinfo.style, pclinfo.strokeWeight, pclinfo.typeface);
  return(escapeStr);
}

/*----------------------------------------------------------------------------*/
#if DEBUG_MODE
VOID DumpDriverInfo()
{
  printf("\nDUMP DRIVERINFO STRUCTURE\n");
  printf("d.epSize: %d\n", d.epSize);
  printf("d.epVersion: %d\n", d.epVersion);
  printf("d.epMemUsage: %ld\n", d.epMemUsage);
  printf("d.epEscape: %ld\n", d.epEscape);
  printf("d.xtbl.symbolSet: %d\n", d.xtbl.symbolSet);
  printf("d.xtbl.offset: %ld\n", d.xtbl.offset);
  printf("d.xtbl.len: %d\n", d.xtbl.len);
  printf("d.xtbl.firstchar: %d\n", d.xtbl.firstchar);
  printf("d.xtbl.lastchar: %d\n", d.xtbl.lastchar);
  printf("d.epEscapeSequence: %s\n", d.epEscapeSequence);
}
#endif

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/* Convert from PostScript to extended text metrics */
VOID AfmToEtm(pcl)
BOOL pcl;  /* true if this is a PCL type device */
{
  etm.iSize = 52;
  /* point size in twips */
  etm.iPointSize = afm.iPtSize * 20;
  etm.iOrientation = (pcl) ? pclinfo.orientation + 1 : 0;
  etm.iMasterHeight = (pcl) ? pfm.iPixHeight : 1000;
  etm.iMinScale = (pcl) ? etm.iMasterHeight : 3;
  etm.iMaxScale = (pcl) ? etm.iMasterHeight : 1000;

  etm.iMasterUnits = (pcl) ? etm.iMasterHeight : 1000;

  /* in general need to worry a little about what happens if these various
     glyphs are not present as in a decorative font. */

  etm.iCapHeight = afm.rgcm['H'].rc.top;
  etm.iXHeight = afm.rgcm['x'].rc.top;
  etm.iLowerCaseAscent =  afm.rgcm['d'].rc.top;
  etm.iLowerCaseDescent = - afm.rgcm['p'].rc.bottom;
  etm.iSlant = (pcl) ? afm.iItalicAngle * 10 : afm.iItalicAngle;
  etm.iSuperScript = (pcl) ? 0 : -500;
  etm.iSubScript = (pcl) ? 0 : 250;
  etm.iSuperScriptSize = (pcl) ? 0 : 500;
  etm.iSubScriptSize = (pcl) ? 0 : 500;
  etm.iUnderlineOffset = (pcl) ? 0 : afm.ulOffset;
  etm.iUnderlineWidth = (pcl) ? 1 : afm.ulThick;
  etm.iDoubleUpperUnderlineOffset = (pcl) ? 0 : afm.ulOffset / 2;
  etm.iDoubleLowerUnderlineOffset = (pcl) ? 0 : afm.ulOffset;
  etm.iDoubleUpperUnderlineWidth = (pcl) ? 1 : afm.ulThick / 2;
  etm.iDoubleLowerUnderlineWidth = (pcl) ? 1 : afm.ulThick / 2;
  etm.iStrikeOutOffset = (pcl) ? 0 : fiCapHeight / 2 - (afm.ulThick / 2);
  etm.iStrikeOutWidth = (pcl) ? 1 : afm.ulThick;
  etm.nKernPairs = afm.kp.cPairs;
  etm.nKernTracks = afm.kt.cTracks;
}
/*----------------------------------------------------------------------------*/
VOID PutEtm(pcl)
BOOL pcl;  /* true if this is a PCL type device */
{
  AfmToEtm(pcl);
  PutWord(etm.iSize);
  PutWord(etm.iPointSize);
  PutWord(etm.iOrientation);
  PutWord(etm.iMasterHeight);
  PutWord(etm.iMinScale);
  PutWord(etm.iMaxScale);
  PutWord(etm.iMasterUnits);
  PutWord(etm.iCapHeight);
  PutWord(etm.iXHeight);
  PutWord(etm.iLowerCaseAscent);
  PutWord(etm.iLowerCaseDescent);
  PutWord(etm.iSlant);
  PutWord(etm.iSuperScript);
  PutWord(etm.iSubScript);
  PutWord(etm.iSuperScriptSize);
  PutWord(etm.iSubScriptSize);
  PutWord(etm.iUnderlineOffset);
  PutWord(etm.iUnderlineWidth);
  PutWord(etm.iDoubleUpperUnderlineOffset);
  PutWord(etm.iDoubleLowerUnderlineOffset);
  PutWord(etm.iDoubleUpperUnderlineWidth);
  PutWord(etm.iDoubleLowerUnderlineWidth);
  PutWord(etm.iStrikeOutOffset);
  PutWord(etm.iStrikeOutWidth);
  PutWord(etm.nKernPairs);
  PutWord(etm.nKernTracks);
#if DEBUG_MODE
  DumpEtm();
#endif
}
/*----------------------------------------------------------------------------*/
#if DEBUG_MODE
VOID DumpEtm()
{
  printf("\nDUMP ETM STRUCTURE\n");
  printf("etm.iSize: %d\n", etm.iSize);
  printf("etm.iPointSize: %d\n", etm.iPointSize);
  printf("etm.iOrientation: %d\n", etm.iOrientation);
  printf("etm.iMasterHeight: %d\n", etm.iMasterHeight);
  printf("etm.iMinScale: %d\n", etm.iMinScale);
  printf("etm.iMaxScale: %d\n", etm.iMaxScale);
  printf("etm.iMasterUnits: %d\n", etm.iMasterUnits);
  printf("etm.iCapHeight: %d\n", etm.iCapHeight);
  printf("etm.iXHeight: %d\n", etm.iXHeight);
  printf("etm.iLowerCaseAscent: %d\n", etm.iLowerCaseAscent);
  printf("etm.iLowerCaseDescent: %d\n", etm.iLowerCaseDescent);
  printf("etm.iSlant: %d\n", etm.iSlant);
  printf("etm.iSuperScript: %d\n", etm.iSuperScript);
  printf("etm.iSubScript: %d\n", etm.iSubScript);
  printf("etm.iSuperScriptSize: %d\n", etm.iSuperScriptSize);
  printf("etm.iSubScriptSize: %d\n", etm.iSubScriptSize);
  printf("etm.iUnderlineOffset: %d\n", etm.iUnderlineOffset);
  printf("etm.iUnderlineWidth: %d\n", etm.iUnderlineWidth);
  printf("etm.iDoubleUpperUnderlineOffset: %d\n",
    etm.iDoubleUpperUnderlineOffset);
  printf("etm.iDoubleLowerUnderlineOffset: %d\n",
    etm.iDoubleLowerUnderlineOffset);
  printf("etm.iDoubleUpperUnderlineWidth: %d\n",
    etm.iDoubleUpperUnderlineWidth);
  printf("etm.iDoubleLowerUnderlineWidth: %d\n",
    etm.iDoubleLowerUnderlineWidth);
  printf("etm.iStrikeOutOffset: %d\n", etm.iStrikeOutOffset);
  printf("etm.iStrikeOutWidth: %d\n", etm.iStrikeOutWidth);
  printf("etm.nKernPairs: %d\n", etm.nKernPairs);
  printf("etm.nKernTracks: %d\n", etm.nKernTracks);
}
#endif
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/
/**************************************************************
* Name: StartParse()
***************************************************************/
VOID StartParse()
{
  fEOF = FALSE;
  fUnGetLine = FALSE;
  cbBuffer = 0;
}

/**************************************************************
* Name: szIsEqual()
* Action: Compare two NULL terminated strings.
* Returns: TRUE if they are equal FALSE if they are different
***************************************************************/
BOOL szIsEqual(sz1, sz2)
LPSZ sz1;
LPSZ sz2;
{
  while (*sz1 && *sz2)
      if (*sz1++ != *sz2++) return(FALSE);
  return(*sz1 == *sz2);
}

/**************************************************************
* Name: szMove()
* Action: Copy a string.  This function will copy at most the
*   number of bytes in the destination area - 1.
***************************************************************/
VOID szMove(szDst, szSrc, cbDst)
LPSZ szDst;   /* Ptr to the destination area */
LPSZ szSrc;   /* Ptr to the source area */
INT cbDst;     /* The size of the destination area */
{
  while (*szDst++ = *szSrc++)
      if (--cbDst <= 0) {
          *(szDst-1) = 0;
          break;
          }
}

/*****************************************************************
* Name: GetBuffer()
* Action: Read a new buffer full of text from the input file.
******************************************************************/
BOOL GetBuffer(hfile)
INT hfile;
{
  cbBuffer = 0;
  if (!fEOF) {
      cbBuffer = READ_BLOCK(hfile, rgbBuffer, sizeof(rgbBuffer));
      if (cbBuffer<=0) {
          cbBuffer = 0;
          fEOF = TRUE;
          }
      }
  pbBuffer = rgbBuffer;
  return(!fEOF);
}

/*****************************************************************
* Name: UnGetLine()
* Action: This routine pushes the most recent line back into the
*   input buffer.
*******************************************************************/
VOID UnGetLine()
{
  fUnGetLine = TRUE;
  szLine = rgbLine;
}

/******************************************************************
* Name: GetLine()
* Action: This routine gets the next line of text out of the
*   input buffer.  Handles both binary & text mode.
********************************************************************/
BOOL GetLine(hfile)
INT hfile;
{
  CHAR szWord[10];

  // WriteDots();
  szLine = rgbLine;
  do {                                            /* skip comment lines */
      if( !_GetLine(hfile) ) return(FALSE);
      GetWord(szWord, sizeof(szWord));
      } while( szIsEqual("Comment", szWord) );
  szLine = rgbLine;
  return(TRUE);
}

BOOL _GetLine(hfile)
INT hfile;
{
  INT cbLine;
  CHAR bCh;

  if( fUnGetLine ) {
      szLine = rgbLine;
      fUnGetLine = FALSE;
      return(TRUE);
      }

  cbLine = 0;
  szLine = rgbLine;
  *szLine = 0;
  if( !fEOF )
  {
      while( TRUE )
      {
          if ( cbBuffer <= 0 )
              if( !GetBuffer(hfile) ) return(FALSE);
          while( --cbBuffer >= 0 )
          {
              bCh = *pbBuffer++;
              if( bCh=='\n' || ++cbLine > (sizeof(rgbLine)-1) )
              {
                  *szLine = 0;
                  szLine = rgbLine;
                  EatWhite();
                  if( *szLine != 0 ) goto DONE;
                  szLine = rgbLine;
                  cbLine = 0;
                  continue;
              }
              else if( bCh >= ' ' )
              {
                *szLine++ = bCh;
              }
          }
      }
  }
  *szLine = 0;

DONE:
  szLine = rgbLine;
  return(!fEOF);
}

/****************************************************************
* Name: EatWhite()
* Action: This routine moves the input buffer pointer forward to
*   the next non-white character.
******************************************************************/
VOID EatWhite()
{
  while (*szLine && (*szLine==' ' || *szLine=='\t'))
  ++szLine;
}

/*******************************************************************
* Name: GetWord()
* Action: This routine gets the next word delimited by white space
*   from the input buffer.
*********************************************************************/
VOID GetWord(szWord, cbWord)
LPSZ szWord;   /* Ptr to the destination area */
INT cbWord;     /* The size of the destination area */
{
  CHAR bCh;

  EatWhite();
  while (--cbWord>0) {
      switch(bCh = *szLine++) {
          case 0:
          case ' ':
          case '\t': --szLine;
                     goto DONE;
          case ';':  *szWord++ = bCh;
                     goto DONE;
          default:   *szWord++ = bCh;
                     break;
          }
      }
DONE:
  *szWord = 0;
}

/*******************************************************************
* Name: GetString()
* Action: This routine gets the next word delimited by parentheses
*   from the input buffer.
*********************************************************************/
BOOL GetString(szWord, cbWord)
LPSZ szWord;   /* Ptr to the destination area */
INT   cbWord;   /* The size of the destination area */
{
  CHAR bCh;
  BOOL result = TRUE;

  EatWhite();
  if( *szLine == '(' ) szLine++;
  else result = FALSE;
  while (--cbWord>0) {
      switch(bCh = *szLine++) {
          case 0:   result = FALSE;
                    goto DONE;
          case ')': --szLine;
                    goto DONE;
          default:  *szWord++ = bCh;
                    break;
          }
      }
DONE:
  *szWord = 0;
  return(result);
}

/************************************************************
* Name: GetNumber()
* Action: This routine parses an ASCII decimal number from the
*   input file stream and returns its value.
***************************************************************/
BOOL GetNumber(piVal)
SHORT *piVal;
{
  INT iVal;
  BOOL fNegative;

  fNegative = FALSE;

  iVal = 0;
  EatWhite();

  if (*szLine=='-') {
      fNegative = TRUE;
      ++szLine;
      }

  if (*szLine<'0' || *szLine>'9') {
      *piVal = 0;
      return(FALSE);
      }

  while (*szLine>='0' && *szLine<='9')
      iVal = iVal * 10 + (*szLine++ - '0');

  if (fNegative) iVal = - iVal;
  if (*szLine==0 || *szLine==' ' || *szLine=='\t' || *szLine==';') {
      *piVal = (SHORT)iVal;
      return(TRUE);
      }
  else {
      *piVal = 0;
      return(FALSE);
  }
}

/******************************************************************
* Name: GetFloat()
* Action: This routine parses an ASCII floating point decimal number
*   from the input file stream and returns its value scaled
*   by a specified amount.
*********************************************************************/
BOOL GetFloat(pScale, piVal)
float *pScale;     /* The amount to scale the value by */
SHORT *piVal;
{
  float scale;
  long lVal;
  long lDivisor;
  BOOL fNegative;

  scale = *pScale;
  EatWhite();
  fNegative = FALSE;
  lVal = 0L;

  if (*szLine=='-') {
      fNegative = TRUE;
      ++szLine;
      }

  if (*szLine<'0' || *szLine>'9') {
      *piVal = 0;
      return(FALSE);
      }

  while (*szLine>='0' && *szLine<='9') lVal = lVal * 10 + (*szLine++ - '0');

  lDivisor = 1L;
  if (*szLine=='.') {
      ++szLine;
      while (*szLine>='0' && *szLine<='9') {
          lVal = lVal * 10 + (*szLine++ - '0');
          lDivisor = lDivisor * 10;
          }
      }
  lVal = (lVal * (long) scale) / lDivisor;
  if (fNegative) lVal = - lVal;
  if (*szLine==0 || *szLine==' ' || *szLine=='\t' || *szLine==';') {
      *piVal = (INT) lVal;
      return(TRUE);
      }
   else {
      *piVal = 0;
      return(FALSE);
   }
}

/***************************************************************
* Name: MapToken()
* Action: This routine maps an ascii key word into an integer token.
* Returns: The token value.
******************************************************************/
INT MapToken(szWord, map)
LPSZ szWord;      /* Ptr to the ascii keyword string */
KEY *map;
{
  KEY *pkey;

  pkey = map;
  while (pkey->szKey) {
      if( szIsEqual(szWord, pkey->szKey) ) return(pkey->iValue);
      ++pkey;
      }
  return(TK_UNDEFINED);
}

/*********************************************************************
* Name: GetToken()
* Action: Get the next token from the input stream.
***********************************************************************/
INT GetToken(hfile, map)
INT hfile;
KEY *map;
{
  CHAR szWord[80];

  if (*szLine==0)
      if( !GetLine(hfile) ) return(TK_EOF);
  GetWord(szWord, sizeof(szWord));
  return(MapToken(szWord, map));
}

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
GlyphName *AllocateGlyphArray(arraymax)

INT arraymax;
{
  GlyphName *p;
  INT i;

  p = (GlyphName *) AllocateMem( (UINT) (sizeof(LPSZ) * (arraymax+2)) );
  if( p == NULL ) {
      ; // PostError(str(MSG_PFM_BAD_MALLOC));
      return(NULL);
      }
  for(i=0; i<=arraymax; i++)
      p[i] = notdef;
  p[i] = NULL;
  return(p);
}

/*--------------------------------------------------------------------------*/
VOID PutGlyphName(array, index, glyph)

GlyphName *array;
INT index;
LPSZ glyph;
{
  LPSZ p;

  if ( !STRCMP(glyph, ".notdef") )
      array[index] = notdef;
  else {
      p = (LPSZ) AllocateMem((UINT) (strlen(glyph)+1));
      if ( p == NULL ) {
          ; // PostError(str(MSG_PFM_BAD_MALLOC));
          parseError = TRUE;
          return;
      }
      STRCPY(p, glyph);
      array[index] = p;
  }
}

/*--------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\freader.h ===
/***
**
**   Module: FReader
**
**   Description:
**    This is a module of the T1 to TT font converter. The module
**    contains functions that decodes and decrypts the data of a
**    T1 font file.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif
#ifndef FASTCALL
#  ifdef MSDOS
#     define FASTCALL   __fastcall
#  else
#     define FASTCALL
#  endif
#endif

enum ftype {pfb_file, mac_file, ascii_file};

struct FRHandle;
struct FontFile;



/***
** Function: GetByte
**
** Description:
**   Pull one byte out of the T1 font file.
***/
short FASTCALL  GetByte     _ARGS((INOUT   struct FontFile *ff));


/***
** Function: Decrypt
**
** Description:
**   Decrypt a byte.
***/
UBYTE FASTCALL  Decrypt     _ARGS((INOUT   USHORT *r, IN UBYTE b));


/***
** Function: FRCleanUp
**
** Description:
**   Free the resources used when reading/decoding data from
**   a T1 font file.
***/
errcode         FRCleanUp   _ARGS((INOUT   struct FontFile *ff));


/***
** Function: FRInit
**
** Description:
**   Initite the resources needed to read/decode data from
**   a T1 font file.
***/
errcode         FRInit      _ARGS((IN      char *name,
				   IN      enum ftype,
				   OUT     struct  FontFile **));
/***
** Function: GetSeq
**
** Description:
**   Pull one sequence of bytes that are delimited by 
**   a given pair of characters, e.g. '[' and ']'.
***/
char            *GetSeq     _ARGS((INOUT   struct FontFile *ff,
				   OUT     char *buf,
				   IN      USHORT len));
/***
** Function: Get_Token
**
** Description:
**   Pull one token from the T1 font file. A token 
**   is delimited by white space and various brackets.
***/
char            *Get_Token   _ARGS((INOUT   struct FontFile *ff,
				   OUT     char *buf,
				   IN      USHORT len));
/***
** Function: GetNewLine
**
** Description:
**   Pull one whole line from the T1 font file, starting at
**   the current position.
***/
char            *GetNewLine    _ARGS((INOUT   struct FontFile *ff,
				   OUT     char *buf,
				   IN      USHORT len));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\freader.c ===
/***
**
**   Module: FReader
**
**   Description:
**    This is a module of the T1 to TT font converter. The module
**    contains functions that decodes and decrypts the data of a
**    T1 font file.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <ctype.h>
#include <string.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"
#include "safemem.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "freader.h"
#include "pfb.h"


/***** LOCAL TYPES */
struct FontFile {

   /* Low-level I/O functions. */
   errcode (FASTCALL *fclose)(struct t1file *);
   short (FASTCALL *fgetc)(struct t1file *);
   struct t1file *(*fopen)(const char *);
   boolean (FASTCALL *fstatus)(const struct t1file *);
   struct t1file *io;

   /* Font file state. */
   enum {prolog, eexec} state;
   short nextbyte;
   USHORT r;
};


/***** CONSTANTS */
static const USHORT c1 = 52845;
static const USHORT c2 = 22719;


/***** MACROS */
#define IOGetByte(f)       ((*f->fgetc)(f->io))
#define IOError(f)         ((*f->fstatus)(f->io))
#define IOOpen(f,n)        ((*f->fopen)(n))
#define IOClose(f)         ((*f->fclose)(f->io))
#define SetNextByte(ff, b) ff->nextbyte = (b)
#define NextByte(ff)       (ff->nextbyte)
#define Eexec(ff)          (boolean)(ff->state == eexec)
#define StartEexec(ff)     ff->state = eexec



/***** STATIC FUNCTIONS */
/*-none-*/



/***** FUNCTIONS */

/***
** Function: GetByte
**
** Description:
**   Pull one byte out of the T1 font file.
***/
short FASTCALL GetByte(struct FontFile *ff)
{
   short b, nb;

   b = IOGetByte(ff);

   /* Decrypt it? */
   if (Eexec(ff))
      b = (short)Decrypt(&ff->r, (UBYTE)b);

   /* Record look-a-head */
   nb = NextByte(ff);
   SetNextByte(ff, b);

   return nb;
}



/***
** Function: GetNewLine
**
** Description:
**   Pull one whole line from the T1 font file, starting at
**   the current position.
***/
char *GetNewLine(struct FontFile *ff, char *buf, const USHORT len)
{
   short i = 0;

   /* Get string. */
   while ((buf[i] = (char)GetByte(ff))!='\n' &&
          buf[i]!='\r' && ++i<((short)len-1));

   /* Skip extra characters. */
   if (buf[i]!='\n' && buf[i]!='\r')
      while (!IOError(ff) && NextByte(ff)!='\n' && NextByte(ff)!='\r')
         (void)GetByte(ff);

   /* Terminate string. */
   buf[i] = '\0';

   /* Check for the start of the eexec section. */
   if (!strcmp(buf, "eexec"))
      StartEexec(ff);

   /* Check error condition. */
   if (IOError(ff))
      return NULL;

   return buf;
}



/***
** Function: Get_Token
**
** Description:
**   Pull one token from the T1 font file. A token 
**   is delimited by white space and various brackets.
***/
char *Get_Token(struct FontFile *ff, char *buf, const USHORT len)
{
   short i = 0;
   short nb;

   /* Skip leading blanks. */
   while (isspace(NextByte(ff)))
      (void)GetByte(ff);

   /* Get string. */
   do {
      buf[i] = (char)GetByte(ff);
      nb = NextByte(ff);
   } while (++i<((short)len-1) && !isspace(nb) && nb!='{' &&
            nb!='(' && nb!='[' && nb!='/');

   /* Skip extra characters. */
   while (!IOError(ff) && !isspace(nb) && nb!='{' &&
          nb!='(' && nb!='[' && nb!='/') {
      (void)GetByte(ff);
      nb = NextByte(ff);
   }

   /* Terminate string. */
   buf[i] = '\0';

   /* Check for the start of the eexec section. */
   if (!strcmp(buf, "eexec"))
      StartEexec(ff);

   /* Check error condition. */
   if (IOError(ff))
      return NULL;

   return buf;
}



/***
** Function: GetSeq
**
** Description:
**   Pull one sequence of bytes that are delimited by 
**   a given pair of characters, e.g. '[' and ']'.
***/
char *GetSeq(struct FontFile *ff,
             char *buf,
             const USHORT len)
{
   char d1, d2;
   short i = 0;
   short inside = 0;

   /* Skip leading blanks. */
   while (NextByte(ff)!='[' &&
          NextByte(ff)!='{' &&
          NextByte(ff)!='(' &&
          !IOError(ff))
      (void)GetByte(ff);

   /* match the bracket. */
   d1 = (char)NextByte(ff);
   if (d1=='[') 
      d2 = ']';
   else if (d1=='{')
      d2 = '}';
   else if (d1=='(')
      d2 = ')';
   else
      return NULL;


   /* Get string. */ 
   (void)GetByte(ff);
   inside=1;
   do {
      buf[i] = (char)GetByte(ff);
      if (buf[i]==d1)
         inside++;
      if (buf[i]==d2)
         inside--;
   } while (inside && ++i<((short)len-1));

   /* Terminate string. */
   buf[i] = '\0';

   /* Check error condition. */
   if (IOError(ff))
      return NULL;

   return buf;
}



/***
** Function: FRInit
**
** Description:
**   Initite the resources needed to read/decode data from
**   a T1 font file.
***/
errcode FRInit(const char *name, const enum ftype type, struct FontFile **ff)
{
   errcode status = SUCCESS;
   short b;

   if (((*ff)=(struct FontFile *)Malloc(sizeof(struct FontFile)))==NULL) {
      SetError(status = NOMEM);
   } else {

      /* Initiat the handle. */
      memset((*ff), '\0', sizeof(**ff));

      /* Initiate low-level I/O. */
      switch (type) {
         case pfb_file:
            (*ff)->fgetc = PFBGetByte;
            (*ff)->fclose = PFBFreeIOBlock;
            (*ff)->fstatus = PFBFileError;
            (*ff)->fopen = PFBAllocIOBlock;
            break;
         case mac_file:
#if MACFILEFORMAT
            (*ff)->fgetc = MACGetByte;
            (*ff)->fclose = MACFreeIOBlock;
            (*ff)->fstatus = MACFileError;
            (*ff)->fopen = MACAllocIOBlock;
            break;
#endif
         case ascii_file:
#if ASCIIFILEFORMAT
            (*ff)->fgetc = ASCIIGetByte;
            (*ff)->fclose = ASCIIFreeIOBlock;
            (*ff)->fstatus = ASCIFileError;
            (*ff)->fopen = ASCIIAllocIOBlock;
            break;
#endif
         default:
            LogError(MSG_ERROR, MSG_BADFMT, NULL);
            SetError(status = BADINPUTFILE);
            break;
      }

      (*ff)->io = NULL;
      if (((*ff)->io = IOOpen((*ff),name))==NULL) {
         SetError(status = BADINPUTFILE);
      } else {
         (*ff)->state = prolog;
         (*ff)->r = 55665;

         b=GetByte(*ff);
         SetNextByte((*ff), b);
      }
   }

   return status;
}



/***
** Function: FRCleanUp
**
** Description:
**   Free the resources used when reading/decoding data from
**   a T1 font file.
***/
errcode FRCleanUp(struct FontFile *ff)
{
   errcode status = SUCCESS;

   if (ff) {
      if (ff->io)
         status = IOClose(ff);
      Free(ff);
   }

   return status;
}



/***
** Function: Decrypt
**
** Description:
**   Decrypt a byte.
***/
UBYTE FASTCALL Decrypt(USHORT *r, const UBYTE cipher)
{
   UBYTE plain;

   plain = (UBYTE)(cipher ^ (*r>>8));
   *r = (USHORT)((cipher+*r) * c1 + c2);

   return plain;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\hints.c ===
/***
**
**   Module: Hints
**
**   Description:
**      This is a module of the T1 to TT font converter. This is a
**      sub-module of the T1 to TT data translator module. It deals
**      with hints. Any part pf the T1 font that gets translated into
** TrueType instructions is done within this module.
**
**   Author: Michael Jansson
**
**   Created: 8/24/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <limits.h>
#include <string.h>

/* Special types and definitions. */
#include "titott.h"
#include "trig.h"
#include "types.h"
#include "safemem.h"
#include "metrics.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "trans.h"
#include "hints.h"
#include "ttprog.h"



/***** CONSTANTS */
#define VERSION_SELECTOR 1    /* GetInfo[] selector for version number. */
#define VERSION_1_5     33    /* Version 1.5 of Windows TrueType rasterizer. */
#define STEMSNAPARGS    6     /* Number of args of the CreateStem TTFUN. */

#ifdef SYMETRICAL_REDUCTION
#define MIN_REDUCTION   4     /* Min reduction of the diag. cntrl. */
#endif
#define REDUCTION_C1    10    /* Min reduction, second method. */

#define STACKINC        500   /* Stack increment for arg-stack + prep. */

#define TARGSIZE        100   /* Size of temporary argument stack. */
#define TTFLEXSIZE      9     /* Largest size of a flex, w/o the points. */

#define TMP_TWILIGHTS         2
#define TWILIGHTS_PER_STEM    4

#define LEFTSTEM        1
#define RIGHTSTEM       2

#define SECONDPAIR      2

#define MAXRANGE        15

#define MAXEXTR         60       /* Max num of IP buckets. */

#define UNDEF           -1

#define STDV_CVT  1
#define STDH_CVT  2
#define SNAPV_CVT(v)       (v+3)
#define SNAPH_CVT(t1m, v)  (t1m->snapv_cnt+3+v)


/* External leading hint programs. */
static const UBYTE roman_hints[] = {
   /* Magic cookie. */
   op_pushb1 + 4, 66, 3, 8, 2, 16,
   op_clear,

   op_svcta | SUBOP_Y,
   op_pushb1, 3,

   /* Push 2pnt, in sub-pels. */
   op_mppem,
   op_mps,
   op_div,
   op_pushb1, 128,
   op_mul,

   /* Push InternalLeading, in sub-pels. */
   op_pushb1+1, 2, 1,
   op_md,
   op_sub,

   /* Push MAX(2pnt - i-leading, 0) */
   op_pushb1, 0,
   op_max,

   /* Add the external leading to the Ascent height. */
   op_shpix,
};
static const UBYTE swiss_hints[] = {
   /* Magic cookie. */
   op_pushb1 + 4, 66, 3, 8, 2, 16,
   op_clear,

   op_svcta | SUBOP_Y,
   op_pushb1, 3,

   /* 0<=height<=12.5 */
   op_mps,
   op_pushw1, HIBYTE(800), LOBYTE(800),   /* 12.5 pnt */
   op_gt,
   op_if,

   /* Push 2pnt, in sub-pels. */
   op_mppem,
   op_mps,
   op_div,
   op_pushb1, 128,
   op_mul,

   op_else,

   /* 12.5 < height <= 13.5 */
   op_mps,
   op_pushw1, HIBYTE(864), LOBYTE(864),   /* 13.5 pnt */
   op_gt,
   op_if,

   /* Push 3pnt, in sub-pels. */
   op_mppem, op_pushb1, 1, op_div,
   op_mps,
   op_div,
   op_pushb1, 192,
   op_mul,

   op_else,

   /* Push 4pnt, in sub-pels. */
   op_mppem, op_pushb1, 1, op_div,
   op_mps,
   op_div,
   op_pushw1, HIBYTE(256), /* LOBYTE(256) */ 0,
   op_mul,

   op_eif,

   op_eif,

   /* Push InternalLeading, in sub-pels. */
   op_pushb1+1, 2, 1,
   op_md,
   op_sub,
   op_dup,

   /* Push MAX(?pnt - i-leading, 0) */
   op_pushb1, 0,
   op_max,

   /* Add the external leading to the Ascent height. */
   op_shpix,

};


/* Pre-program. */
static const UBYTE PrepProg[] = {
   op_pushw1, 0x01, 0xff, op_scanctrl,

   op_pushb1, 1, op_rcvt,
   op_pushb1, 128,
   op_lt,
   op_if,

   op_pushb1 + 1, 4, 0, op_scantype, op_scantype,

   op_else,

   op_pushb1 + 1, 5, 1, op_scantype, op_scantype,

   op_eif,
};


/***** LOCAL TYPES */
/* Used for associating points to stems. */
typedef struct {
   short from;
   short to; 
} Range;


/* Zone bucket - Used for grid fitting a stem that may have
been divided into several stem instructions due to hint replacement. */
typedef struct TTStem { 
   funit side1;
   funit side2;
   short rp1;
   short rp2;
   short ref;
   enum aligntype align;
   Range range[MAXRANGE];
   short cnt;
} TTStem;




/***** MACROS */

/* General macros. */
#define Trans3X     TransX
#define TransRX     TransY

#define CLOSETO(v1, v2, eps)   (ABS((v1)-(v2))<=eps)

#define CHECK_ARGSIZE(args, ta, num, asize)   /* Check argument stack. */ \
/*lint -e571 -e644 */if (((ta)+(int)(num))>(asize)) { \
   short *newarg = NULL;\
   if ((newarg = Realloc(args, sizeof(short)*(USHORT)(ta+num+STACKINC)))==NULL) { \
      Free(args); \
      LogError(MSG_ERROR, MSG_NOMEM, NULL);\
      return 0;\
   } else {\
      args = newarg;\
      asize = (short)(ta+num+STACKINC);\
/*line +e571 +e644 */   }\
}
#define CHECK_PREPSIZE(prep, tp, num, psize)   /* Check prep size. */ \
if (((tp)+(num))>(psize)) { \
   UBYTE *newprep = NULL;\
   if ((newprep = Realloc(prep, tp+num+STACKINC))==NULL) { \
      Free(prep); \
      LogError(MSG_ERROR, MSG_NOMEM, NULL);\
      return 0;\
   } else {\
      prep = newprep;\
      psize = (short)(tp+num+STACKINC);\
   }\
}



/***** STATIC FUNCTIONS */



/***
** Function: ConvertFlex
**
** Description:
**   Convert a T1 flex hint into a TrueType IP[] 
**   intruction sequence that will reduce a flex
**   that is flatter than a given height.
***/
static errcode ConvertFlex(const struct T1Metrics *t1m,
                           const Flex *flexRoot,
                           const short *ttpnts,
                           UBYTE *pgm,
                           short *pc,
                           short *args,
                           short *pcd,
                           short *marg)
{
   errcode status = SUCCESS;
   int cis, last_cis = UNDEF;
   char dir, last_dir = 0;
   short targ[TARGSIZE];
   funit height, diff;
   const Flex *flex;
   short ta = 0;
   int num = 0;


   /* Return to the glyph zone. */
   if (flexRoot) {
      pgm[(*pc)++] = op_szps;
      args[(*pcd)++] = 1;
   }

   for (flex=flexRoot; flex; flex=flex->next) {

      /* Points lost in ConvertOutline? */
      if (ttpnts[flex->start]==UNDEF ||
          ttpnts[flex->mid]==UNDEF ||
          ttpnts[flex->end]==UNDEF) {
         LogError(MSG_WARNING, MSG_FLEX, NULL);
         continue;
      }

      /* Vertical or horizontal flex? */
      if (ABS(flex->midpos.x-flex->pos.x) <
          ABS(flex->midpos.y-flex->pos.y)) {
         dir = SUBOP_Y;
         height = TransY(t1m, (funit)(flex->startpos.y - flex->pos.y));
         diff = TransY(t1m, (funit)(flex->midpos.y - flex->startpos.y));
      } else {
         dir = SUBOP_X;
         height = TransX(t1m, (funit)(flex->startpos.x - flex->pos.x));
         diff = TransX(t1m, (funit)(flex->midpos.x - flex->startpos.x));
      }

      /* Skip flex without depth. */
      if (diff==0)
         continue;

      cis = (int)((long)flex->civ * (long)GetUPEM(t1m) / 100 / ABS(diff));

      if (cis!=last_cis || dir!=last_dir ||
          (ta+TTFLEXSIZE+(ttpnts[flex->end]-ttpnts[flex->start]))>=TARGSIZE) {
         if (last_cis!=UNDEF) {
            AssembleArgs(targ, ta, pgm, pc);
            while(num--)
               pgm[(*pc)++] = op_call;
            pgm[(*pc)++] = op_eif;
            ta = 0;
         }
         pgm[(*pc)++] = (UBYTE)(op_svcta | dir);
         pgm[(*pc)++] = op_mppem;
         pgm[(*pc)++] = op_gt;
         pgm[(*pc)++] = op_if;
         args[(*pcd)++] = (short)(cis+1);
         num = 0;
      }

      status = EmitFlex(targ, &ta, height,
                        ttpnts[flex->start],
                        ttpnts[flex->mid],
                        ttpnts[flex->end]);

      last_dir = dir;
      last_cis = cis;
      num++;

      if (status!=SUCCESS) {
         SetError(status = TTSTACK);
         break;
      }
   }
   if (num) {
      AssembleArgs(targ, ta, pgm, pc);
      while(num--)
         pgm[(*pc)++] = op_call;
      pgm[(*pc)++] = op_eif;
   }

   if ((*marg)<2)
      (*marg) = 2;

   return status;
}



/***
** Function: GetSnapV
**
** Description:
**   Return the closest snap width entry.
***/
static short GetSnapV(const struct T1Metrics *t1m, const funit width)
{
   USHORT dist = SHRT_MAX;
   USHORT j = 0;
   USHORT i;

   for (i=0; i<t1m->snapv_cnt; i++) {
      if (ABS(width-t1m->stemsnapv[i])<(short)dist) {
         dist = (USHORT)ABS(width-t1m->stemsnapv[i]);
         j = i;
      }
   }

   if (dist==SHRT_MAX)
      return UNDEF;

   return (short)j;
}





/***
** Function: GetSnapH
**
** Description:
**   Return the closest snap width entry.
***/
static short GetSnapH(const struct T1Metrics *t1m, const funit width)
{
   USHORT dist = SHRT_MAX;
   USHORT j = 0;
   USHORT i;

   for (i=0; i<t1m->snaph_cnt; i++) {
      if (ABS(width-t1m->stemsnaph[i])<(short)dist) {
         dist = (USHORT)ABS(width-t1m->stemsnaph[i]);
         j = i;
      }
   }

   if (dist==SHRT_MAX)
      return UNDEF;

   return (short)j;
}




/***
** Function: PosX
**
** Description:
**   This is a call-back function used by
**   Interpolate.
***/
static funit PosX(const Point pnt)
{
   return pnt.x;
}



/***
** Function: PosY
**
** Description:
**   This is a call-back function used by
**   Interpolate.
***/
static funit PosY(const Point pnt)
{
   return pnt.y;
}



/***
** Function: InRange
**
** Description:
**   This is function determines if a point is
**   within range of a hint zone.
***/
static boolean InRange(const short pnt, const Range *range, const short cnt)
{
   short k;

   for (k=0; k<cnt; k++) {
      if ((range[k].from<=pnt) &&
          (range[k].to>=pnt || range[k].to==ENDOFPATH))
         break;
   }

   return (boolean)(k != cnt);
}


/***
** Function: BoundingStems
**
** Description:
**   Determines what stems are located to the
**   left and to the right of a point on the
**   outline, given its position.
**   
***/
static short BoundingStems(short pnt, const short max_pnt,
                           const funit pos, const TTStem *stems,
                           const short cnt,
                           short *left, short *right)
{
   funit min, max;
   short i;

   max = SHRT_MAX;
   min = 1-SHRT_MAX;
   (*right) = UNDEF;
   (*left) = UNDEF;
   do {
      for (i=0; i<cnt; i++) {
         /* Is stem to the left and defined for the point? */
         if ((stems[i].side1<=pos) &&
             (stems[i].side1>min) &&
             InRange(pnt, stems[i].range, stems[i].cnt)) {
            min = stems[i].side1;
            (*left) = (short)i;
         }

         /* Is stem to the right and defined for the point. */
         if ((stems[i].side2>=pos) &&
             (stems[i].side2<max) &&
             InRange(pnt, stems[i].range, stems[i].cnt)) {
            max = stems[i].side2;
            (*right) = (short)i;
         }
      }

   /* Advance to the next point on the outline if we did not find stems. */
   } while (((*left)==UNDEF) && ((*right)==UNDEF) && (++pnt<(short)max_pnt));

   return pnt;
}




/***
** Function: EndOfRegion
**
** Description:
**   Determine what is the closest point, after the
**   given point, for a new hint replacement.
**   
***/
static short EndOfRegion(const short pnt, const TTStem *stem)
{
   short k;

   for (k=0; k<stem->cnt; k++) {
      if ((stem->range[k].from<=pnt) &&
          (stem->range[k].to>=pnt || stem->range[k].to==ENDOFPATH))
         break;
   }

   return (short)((k==stem->cnt || stem->range[k].to==ENDOFPATH)
                  ? SHRT_MAX : stem->range[k].to);
}




/***
** Function: AddToBucket
**
** Description:
**   This function will add a point, that
**   is located between two stems, into a
**   bucket that represents an interpolation
**   zone.
***/
static short AddToBucket(Extremas *extr,
                         short xcnt,
                         const short pnt,
                         const funit left,
                         const funit right,
                         const TTStem *stems)
{
   short rp1, rp2;
   short tmp, j;

   /* Pick the reference points (which are located in the twilight zone). */
   if (left!=UNDEF)
      rp1 = stems[left].rp2;
   else
      rp1 = UNDEF;
   if (right!=UNDEF)
      rp2 = stems[right].rp1;
   else
      rp2 = UNDEF;

   /* Normalize the reference points. */
   tmp = rp1;
   rp1 = (short)MIN(rp1, rp2);
   rp2 = (short)MAX(tmp, rp2);

   /* Create/Fill IP bucket. */
   for (j=0; j<xcnt; j++) 
      if (extr[j].rp1==rp1 && extr[j].rp2==rp2 && extr[j].n<MAXPTS)
         break;
   if (j==xcnt) {
      if (xcnt<MAXEXTR) {
         extr[xcnt].rp1 = rp1;
         extr[xcnt].rp2 = rp2;
         extr[xcnt].n = 0;
         xcnt++;
      } else {
         LogError(MSG_WARNING, MSG_EXTREME1, NULL);
      }
   }

   /* Add the point to the bucket. */
   if (j<MAXEXTR && extr[j].n<MAXPTS &&
       (extr[j].pts[extr[j].n] = pnt)!=UNDEF)
      extr[j].n++;

   return xcnt;
}


/***
** Function: AddSidePntToBucket
**
** Description:
**   Same as AddToBucket, but the points are
**   known to reside exactly on the side of
**   a stem, and should be controled by one
**   reference point alone. This is only needed
**   for sheared fonts, where controling side
**   point w.r.t. two reference poins leads
**   to problems.
***/
static short AddSidePntToBucket(Extremas *extr,
                                short xcnt,
                                const short pnt,
                                const short rp)
{
   short j;

   /* Create/Fill IP bucket. */
   for (j=0; j<xcnt; j++) 
      if (extr[j].rp1==rp && extr[j].rp2==UNDEF && extr[j].n<MAXPTS)
         break;
   if (j==xcnt) {
      if (xcnt<MAXEXTR) {
         extr[xcnt].rp1 = rp;
         extr[xcnt].rp2 = UNDEF;
         extr[xcnt].n = 0;
         xcnt++;
      } else {
         LogError(MSG_WARNING, MSG_EXTREME1, NULL);
      }
   }

   /* Add the point to the bucket. */
   if (j<MAXEXTR && extr[j].n<MAXPTS &&
       (extr[j].pts[extr[j].n] = pnt)!=UNDEF)
      extr[j].n++;

   return xcnt;
}





/***
** Function: PickSides
**
** Description:
**   Select the position of the left and
**   right side boundry of a point, given
**   the stem to the left and right of the
**   current point on the outline.
***/
static void PickSides(short left, short right,
                      funit *left_side,
                      funit *right_side,
                      TTStem *stems)
{
   if (left!=right) {
      if (left!=UNDEF)
         (*left_side) = stems[left].side2;
      else
         (*left_side) = 1-SHRT_MAX/2;
      if (right!=UNDEF)
         (*right_side) = stems[right].side1;
      else
         (*right_side) = SHRT_MAX/2;
   } else {
      (*left_side) = stems[left].side1;
      (*right_side) = stems[right].side2;
   }
}   





/***
** Function: PickSequence
**
** Description:
**   Determine at what point the current
**   hint sequence is ending.
***/
static short PickSequence(short left, short right, short pnt, TTStem *stems)
{
   short left_end;
   short right_end; 
   short new_seq;

   if (left!=UNDEF && right!=UNDEF) {
      left_end = EndOfRegion(pnt, &stems[left]);
      right_end = EndOfRegion(pnt, &stems[right]);
      new_seq = (short)MIN(left_end, right_end);
   } else if (left!=UNDEF) {
      left_end = EndOfRegion(pnt, &stems[left]);
      new_seq = left_end;
   } else {
      right_end = EndOfRegion(pnt, &stems[right]);
      new_seq = right_end;
   }

   return new_seq;
}



/***
** Function: CollectPoints
**
** Description:
**   This function will go through the points
**   that are local extremas and interpolate
**   them w.r.t. the enclosing stem sides.
**   The non-extreme points are handled with
**   an IUP[] instruction when this is done.
***/
static short CollectPoints(const Outline *orgpaths,
                           const short *ttpnts,
                           TTStem *stems,
                           short cnt,
                           Extremas *extr,
                           funit (*Position)(const Point))
{
   const Outline *path;
   short xcnt = 0;
   short i,tot;
   short prev_stem;
   funit pos;
   short left, right;
   funit left_side, right_side;
   funit max, min;
   short max_pnt, min_pnt;
   short new_seq, n;
   short prev_pnt;
   funit prev_pos;
   short first;
   short pnt = UNDEF;


   tot = 0;
   for (path=orgpaths; path; path=path->next) {
      first = BoundingStems(tot,
                            (short)(tot+(short)path->count),
                            Position(path->pts[0]),
                            stems, cnt, &left, &right);
      if (first==tot+(short)path->count) {
         tot = (short)(tot + path->count);
         continue;
      }

      new_seq = PickSequence(left, right, tot, stems);
      PickSides(left, right, &left_side, &right_side, stems);
      max = 1-SHRT_MAX/2;
      min_pnt = UNDEF;
      max_pnt = UNDEF;
      min = SHRT_MAX/2;
      prev_pnt = FALSE;
      prev_pos = UNDEF;
      prev_stem = UNDEF;
      for (i = (short)(first-tot); i<(short)path->count; i++) {
         if (OnCurve(path->onoff, i)) {
            pos = Position(path->pts[i]);
            n = (short)(i+tot);

            /* Have we crossed over a stem side. */
            if ((prev_stem!=RIGHTSTEM && pos<=left_side && max_pnt!=UNDEF) ||
                (prev_stem!=LEFTSTEM && pos>=right_side && min_pnt!=UNDEF)) {

               if (prev_stem!=RIGHTSTEM && max_pnt!=UNDEF) {
                  pnt = max_pnt;
                  prev_pos = max;

               } else if (prev_stem!=LEFTSTEM && min_pnt!=UNDEF) {
                  pnt = min_pnt;
                  prev_pos = min;
               }

               xcnt = AddToBucket(extr, xcnt, ttpnts[pnt], left, right, stems);

               max = 1-SHRT_MAX/2;
               min = SHRT_MAX/2;
               max_pnt = UNDEF;
               min_pnt = UNDEF;
               prev_pnt = TRUE;
            }

            /* Crossing the side of a stem. */
            if ((pos>=right_side) || (pos<=left_side)) {
               if (pos<left_side)
                  prev_stem = RIGHTSTEM;
               else
                  prev_stem = LEFTSTEM;
            }

            /* Change left/right stem sides? */
            if ((n>new_seq) || (pos>=right_side) || (pos<=left_side)) {
               first = BoundingStems(n,
                                     (short)(path->count+tot),
                                     pos, stems, cnt,
                                     &left, &right);
               if (left==UNDEF && right==UNDEF)
                  break;

               i = (short)(i + first - n);
               new_seq = PickSequence(left, right, n, stems);
               PickSides(left, right, &left_side, &right_side, stems);
               max = 1-SHRT_MAX/2;
               min = SHRT_MAX/2;
               max_pnt = UNDEF;
               min_pnt = UNDEF;
            }

            /* Is the point on the side of the stem? */
            if (CLOSETO(pos,left_side,2) || CLOSETO(pos,right_side,2)) {
               if (!prev_pnt || !CLOSETO(prev_pos, pos, 2)) {
                  if (CLOSETO(pos, right_side, 2) ||
                      CLOSETO(pos, left_side, 2)) {
                     pnt = (short)n;
                     prev_pos = pos;

                  } else if (prev_stem!=RIGHTSTEM && max_pnt!=UNDEF) {
                     pnt = max_pnt;
                     prev_pos = max;
                     max_pnt = UNDEF;

                  } else if (prev_stem!=LEFTSTEM && min_pnt!=UNDEF) {
                     pnt = min_pnt;
                     prev_pos = min;
                     min_pnt = UNDEF;
                  }

                  xcnt = AddToBucket(extr, xcnt, ttpnts[pnt],
                                     left, right, stems);
               }

               prev_pnt = TRUE;
               prev_pos = pos;
            } else {
               prev_pnt = FALSE;

               /* New extremum candidate? */
               if (pos>max) {
                  max = pos;
                  max_pnt = (short)n;
               }
               if (pos<min) {
                  min = pos;
                  min_pnt = (short)n;
               }
            }
         }
      }


      if (left!=UNDEF || right!=UNDEF) {
         if (max_pnt!=UNDEF) {
            xcnt = AddToBucket(extr, xcnt, ttpnts[max_pnt],
                               left, right, stems);
         }
         if (min_pnt!=UNDEF && min!=max) {
            xcnt = AddToBucket(extr, xcnt, ttpnts[min_pnt],
                               left, right, stems);
         }
      }

      tot = (short)(tot + path->count);
   }


   return xcnt;
}



/***
** Function: CollectObliquePoints
**
** Description:
**   This function performs the same task as
**   the "CollectPoint" function, with the
**   exception that the outline is known to
**   be sheared. Some of the logics 
**   is changed, bacause the IUP[] instruction
**   and some IP instruction will not behave
**   the same as in a non-sheared font.
**   This differance applies only to vertical
**   stems (hints resulting in horizontal motion of
**   of points).
***/
static short CollectObliquePoints(const Outline *orgpaths,
                                  const short *ttpnts,
                                  TTStem *stems,
                                  short cnt,
                                  Extremas *extr,
                                  funit (*Position)(const Point))
{
   const Outline *path;
   short xcnt = 0;
   short i,tot;
   short prev_stem;
   funit pos;
   short left, right;
   funit left_side, right_side;
   funit max, min;
   short max_pnt, min_pnt;
   short new_seq, n;
   short first;
   short pnt = UNDEF;


   tot = 0;
   for (path=orgpaths; path; path=path->next) {
      first = BoundingStems(tot,
                            (short)(tot+path->count),
                            Position(path->pts[0]),
                            stems, cnt, &left, &right);
      if (first==tot+(short)path->count) {
         tot = (short)(tot + path->count);
         continue;
      }

      new_seq = PickSequence(left, right, tot, stems);
      PickSides(left, right, &left_side, &right_side, stems);
      max = 1-SHRT_MAX/2;
      min_pnt = UNDEF;
      max_pnt = UNDEF;
      min = SHRT_MAX/2;
      prev_stem = UNDEF;
      for (i = (short)(first-tot); i<(short)path->count; i++) {
         if (OnCurve(path->onoff, i)) {
            pos = Position(path->pts[i]);
            n = (short)(i+tot);

            /* Have we crossed over a stem side. */
            if ((prev_stem!=RIGHTSTEM && pos<=left_side && max_pnt!=UNDEF) ||
                (prev_stem!=LEFTSTEM && pos>=right_side && min_pnt!=UNDEF)) {

               if (prev_stem!=RIGHTSTEM && max_pnt!=UNDEF) {
                  pnt = max_pnt;

               } else if (prev_stem!=LEFTSTEM && min_pnt!=UNDEF) {
                  pnt = min_pnt;
               }

               max = 1-SHRT_MAX/2;
               min = SHRT_MAX/2;
               max_pnt = UNDEF;
               min_pnt = UNDEF;
            }

            /* Crossing the side of a stem. */
            if ((pos>=right_side) || (pos<=left_side)) {
               if (pos<left_side)
                  prev_stem = RIGHTSTEM;
               else
                  prev_stem = LEFTSTEM;
            }

            /* Change left/right stem sides? */
            if ((n>new_seq) || (pos>=right_side) || (pos<=left_side)) {
               first = BoundingStems(n,
                                     (short)(path->count+tot),
                                     pos, stems, cnt,
                                     &left, &right);
               if (left==UNDEF && right==UNDEF)
                  break;

               i = (short)(i + first - n);
               new_seq = PickSequence(left, right, n, stems);
               PickSides(left, right, &left_side, &right_side, stems);
               max = 1-SHRT_MAX/2;
               min = SHRT_MAX/2;
               max_pnt = UNDEF;
               min_pnt = UNDEF;
            }

            /* Is the point on the side of the stem? */
            if (CLOSETO(pos,left_side,2) || CLOSETO(pos,right_side,2)) {
               if (CLOSETO(pos, right_side, 2)) {
                  pnt = (short)n;
                  if (stems[right].side1==right_side)
                     xcnt = AddSidePntToBucket(extr, xcnt, ttpnts[pnt],
                                               stems[right].rp1);
                  else
                     xcnt = AddSidePntToBucket(extr, xcnt, ttpnts[pnt],
                                               stems[right].rp2);

               } else if (CLOSETO(pos, left_side, 2)) {
                  pnt = (short)n;
                  if (stems[left].side1==left_side)
                     xcnt = AddSidePntToBucket(extr, xcnt, ttpnts[pnt],
                                               stems[left].rp1);
                  else
                     xcnt = AddSidePntToBucket(extr, xcnt, ttpnts[pnt],
                                               stems[left].rp2);

               } else if (prev_stem!=RIGHTSTEM && max_pnt!=UNDEF) {
                  pnt = max_pnt;
                  max_pnt = UNDEF;

               } else if (prev_stem!=LEFTSTEM && min_pnt!=UNDEF) {
                  pnt = min_pnt;
                  min_pnt = UNDEF;

               }

            } else {

               /* New extremum candidate? */
               if (pos>max) {
                  max = pos;
                  max_pnt = (short)n;
               }
               if (pos<min) {
                  min = pos;
                  min_pnt = (short)n;
               }
            }
         }
      }


      if (left!=UNDEF || right!=UNDEF) {
         if (max_pnt!=UNDEF) {
         }
         if (min_pnt!=UNDEF && min!=max) {
         }
      }

      tot = (short)(tot + path->count);
   }


   return xcnt;
}



/***
** Function: AddRange
**
** Description:
**   This function adds a point range to
**   a stem bucket.
***/
static void AddRange(TTStem *stem, const short i1, const short i2)
{
   short i;

   /* Check if a prior range can be extended. */
   if (i2!=ENDOFPATH) {
      for (i=0; i<stem->cnt; i++) {
         if (stem->range[i].from == i2+1)
            break;
      }
   } else {
      i = stem->cnt;
   }

   if (i==stem->cnt) {
      if (stem->cnt<MAXRANGE) {
         stem->range[stem->cnt].from = i1;
         stem->range[stem->cnt].to = i2;
         stem->cnt++;
      } else {
         LogError(MSG_WARNING, MSG_REPLC, NULL); 
      }
   } else {
      stem->range[i].from = i1;
   }

}


/***
** Function: CreateStemBuckets
**
** Description:
**   This function will create stem buckets.
**   Several duplicated T1 stem instructions
**   may be mapped to the same bucket.
***/
static short CreateStemBuckets(Stem *stemRoot,
                               Stem3 *stem3Root,
                               TTStem **result)
{
   Stem3 *stem3, *stm3;
   Stem *stem, *stm;
   TTStem *stems = NULL;
   short i, j;
   short cnt;
   short tzpnt = TMPPNT1+1;


   /* Count the stems. */
   cnt = 0;
   (*result) = NULL;
   for (stem3=stem3Root; stem3; stem3=stem3->next) {

      /* Skip obsolete stems. */
      if (stem3->stem1.i2 == NORANGE)
         continue;

      /* Look for a duplicate. */
      for (stm3=stem3Root; stm3!=stem3; stm3=stm3->next) {
         if (stm3->stem1.offset==stem3->stem1.offset &&
             stm3->stem2.offset==stem3->stem2.offset &&
             stm3->stem3.offset==stem3->stem3.offset)
            break;
      }

      /* Count this stem if it is not a duplicate. */
      if (stm3==stem3)
         cnt = (short)(cnt + 3);
   }
   for (stem=stemRoot; stem; stem=stem->next) {

      /* Skip obsolete stems. */
      if (stem->i2 == NORANGE)
         continue;

      /* Look for a duplicate. */
      for (stm=stemRoot; stm!=stem; stm=stm->next) {
         if (stm->offset==stem->offset && stm->width==stem->width)
            break;
      }

      /* Don't count this stem if it is a duplicate. */
      if (stm==stem)
         cnt++;
   }



   /* Initiate them. */
   if (cnt) {
      if ((stems = Malloc(sizeof(TTStem)*(USHORT)cnt))==NULL) {
         errcode status;
         SetError(status=NOMEM);
         return status;
      }

      i = (short)(cnt-1);

      /* Initiate the buckets for the stem3s */
      for (stem3=stem3Root; stem3; stem3=stem3->next) {

         /* Skip obsolete stems. */
         if (stem3->stem1.i2 == NORANGE)
            continue;

         /* Skip if bucket exist for this stem already. */
         for (j=(short)(i+1); j<cnt; j++) {
            if (stems[j].side1==stem3->stem1.offset &&
                stems[j].side2==(stem3->stem1.offset+stem3->stem1.width))
               break;
         }

         if (j==cnt) { 

            /* The rightmost stem is positioned w.r.t. to the middle. */
            stems[i].side1 = stem3->stem1.offset;
            stems[i].side2 = stem3->stem1.width + stem3->stem1.offset;
            stems[i].align = at_relative2;
            stems[i].ref = (short)(i-2);
            stems[i].rp1 = tzpnt++;
            stems[i].rp2 = tzpnt++;
            stems[i].cnt = 1;
            stems[i].range[0].from = stem3->stem1.i1;
            stems[i].range[0].to = stem3->stem1.i2;
            tzpnt+=2;
            i--;

            /* The leftmost stem is positioned w.r.t. to the middle. */
            stems[i].side1 = stem3->stem3.offset;
            stems[i].side2 = stem3->stem3.width + stem3->stem3.offset;
            stems[i].align = at_relative1;
            stems[i].ref = (short)(i-1);
            stems[i].rp1 = tzpnt++;
            stems[i].rp2 = tzpnt++;
            stems[i].cnt = 1;
            stems[i].range[0].from = stem3->stem1.i1;
            stems[i].range[0].to = stem3->stem1.i2;
            tzpnt+=2;
            i--;

            /* The middle stem is centered. */
            stems[i].side1 = stem3->stem2.offset;
            stems[i].side2 = stem3->stem2.width + stem3->stem2.offset;
            stems[i].align = at_centered;
            stems[i].rp1 = tzpnt++;
            stems[i].rp2 = tzpnt++;
            stems[i].cnt = 1;
            stems[i].range[0].from = stem3->stem1.i1;
            stems[i].range[0].to = stem3->stem1.i2;
            tzpnt+=2;
            i--;
         } else {
            AddRange(&stems[j-0], stem3->stem1.i1, stem3->stem1.i2);
            AddRange(&stems[j-1], stem3->stem3.i1, stem3->stem3.i2);
            AddRange(&stems[j-2], stem3->stem2.i1, stem3->stem2.i2);
         }
      }      

      /* Initiate the buckets for the stems. */
      for (stem=stemRoot; stem; stem=stem->next) {

         /* Skip obsolete stems. */
         if (stem->i2 == NORANGE)
            continue;

         /* Skip if bucket exist for this stem already. */
         for (j=(short)(i+1); j<(short)cnt; j++) {
            if (stems[j].side1==stem->offset &&
                stems[j].side2==(stem->offset+stem->width))
               break;
         }

         /* Initiate new bucket:
         Plain vstems and hstems are centered by default. Some
         hstems may be top- or bottom-aligen at a latter point.
         Some stems may be positioned w.r.t. another vstem if
         they overlapp and the RELATIVESTEMS compiler flag is
         turned on. */
         if (j==cnt) {
            stems[i].side1 = stem->offset;
            stems[i].side2 = stem->width + stem->offset;
            stems[i].align = at_centered;
            stems[i].rp1 = tzpnt++;
            stems[i].rp2 = tzpnt++;
            stems[i].cnt = 1;
            stems[i].range[0].from = stem->i1;
            stems[i].range[0].to = stem->i2;
            tzpnt+=2;
            i--;
         } else {
            AddRange(&stems[j], stem->i1, stem->i2);
         }
      }

      /* This happens if two stems are defined for the same
      hint replacement region and the same position, which
      is an Adobe Type 1 font error (broken font). The
      converter will recover by ignoring redundant stems. */
      if (i!=-1) {
         /* LogError(MSG_STEM3); */
         for (j=0; j<=i; j++) {
            stems[j].cnt = 0;
         }
      }
   }

   (*result) = stems;

   return (short)cnt;
}


/***
** Function: ResolveRelativeStem
**
** Description:
**   This function decides if two stems should
**   be aligned side1->side1, side2->side2, 
**   side1->side2 or side2->side1.
**   Stem are positition in relation to each
**   other for two reasons: They overlapp, they
**   are aligned side by side or they are
**   members of a stem3 hint.
***/
static void ResolveRelativeStem(TTStem *ref, TTStem *cur)
{
   /* SIDE1->SIDE2 */
   if (cur->side1==ref->side2) {
      cur->ref = ref->rp2;
      cur->align = at_relative1;


      /* SIDE1->SIDE2 */
   } else if (cur->side2==ref->side1) {
      cur->ref = ref->rp1;
      cur->align = at_relative2;


      /* SIDE1->SIDE1 */
   } else if ((cur->side1>ref->side1) &&
              ((cur->side1-ref->side1+10)>=
               (cur->side2-ref->side2))) {
      cur->ref = ref->rp1;
      cur->align = at_relative1;


      /* SIDE2->SIDE2 */
   } else {
      cur->ref = ref->rp2;
      cur->align = at_relative2;
   }
}



/***
** Function: ConvertVStems
**
** Description:
**   This function translate vstem and vstem3 to TT instructions.
***/
static errcode ConvertVStems(struct T1Metrics *t1m,
                             const Hints *hints,
                             const Outline *orgpaths,
                             const short *ttpnts,
                             UBYTE *pgm,
                             short *pc_ptr,
                             short *args,
                             short *pcd_ptr,
                             USHORT *twilight_ptr)
{
   Extremas extr[MAXEXTR];
   short xcnt = 0;
   errcode status = SUCCESS;
   short pc = *pc_ptr;
   short pcd = *pcd_ptr;
   TTStem *stems = NULL;
   short i;
   short cnt;


   /* Create the buckets. */
   if ((cnt = CreateStemBuckets(hints->vstems,
                                hints->vstems3,
                                &(stems)))==NOMEM) {
      status = NOMEM;
   } else {

      /* Update Max num of twilight points. */
      if ((cnt*TWILIGHTS_PER_STEM+TMP_TWILIGHTS) > (long)(*twilight_ptr))
         (*twilight_ptr) = (USHORT)(cnt * TWILIGHTS_PER_STEM + TMP_TWILIGHTS);

      if (cnt && stems) {

#if RELATIVESTEMS
         /* Do counter- and overlappning stem control? */
         for (i=0; i<cnt; i++) {
            short j;

            if (stems[i].align==at_centered) {
               funit prox = (funit)(ABS(MAX(100,
                                            stems[i].side2 -
                                            stems[i].side1)));
               funit prox2;
               prox2 = (funit)(prox/2);
               for (j=0; j<i; j++) {
                  if (stems[j].cnt &&
                      !((stems[i].side1 - (funit)prox > stems[j].side2) ||
                        (stems[i].side2 + (funit)prox < stems[j].side1)) &&
                      (ABS(stems[i].side2-stems[i].side1-
                           (stems[j].side2-stems[j].side1)) < prox2 ||
                       (short)(stems[i].side1 > stems[j].side2) !=
                       (short)(stems[i].side2 < stems[j].side1)))
                     break;
               }
               if (i!=j) {
                  if (stems[j].side1 < stems[i].side1)
                     stems[i].align = at_relative1;
                  else
                     stems[i].align = at_relative2;
                  stems[i].ref = j;
               }
            }
         }
#endif

         /** Vertical stem hints */
         EmitVerticalStems(pgm, &pc, args, &pcd);

         /* Handle sheared fonts by settin the projection
         vector to the italic angle. The TT instructions for
         the T1 hints can handle any projection vector. */
         if (t1m->fmatrix!=DEFAULTMATRIX && GetFontMatrix(t1m)[2]!=0) {
            Point pt;

            pt.x = 0; pt.y = 1000;
            TransAllPoints(t1m, &pt, (short)1, GetFontMatrix(t1m));
            SetProjection(pgm, &pc, args, &pcd, pt.x, pt.y);
         }

         /* Convert the buckets into instructions. */
         for (i=0; i<cnt; i++) {
            if (stems[i].cnt==0)
               continue;

            /* Resolve relative stems */
            if ((stems[i].align == at_relative1 ||
                 stems[i].align == at_relative2) &&
                stems[i].ref != UNDEF)
               ResolveRelativeStem(&stems[stems[i].ref], &stems[i]);

            /* Emit the instructions. */
            status = EmitVStem(pgm, &pc, args, &pcd, t1m,
                               ABS(stems[i].side2 - stems[i].side1),
                               TransRX(t1m, stems[i].side1),
                               TransRX(t1m, stems[i].side2),
                               Trans3X(t1m, stems[i].side1),
                               Trans3X(t1m, stems[i].side2),
                               (short)MIN(stems[i].rp1, stems[i].rp2),
                               stems[i].align,
                               stems[i].ref);

            if (status!=SUCCESS)
               break;
         }

         /* Collect extremas residing within and between stem sides. */
         if (SyntheticOblique(t1m)) {
            xcnt = CollectObliquePoints(orgpaths, ttpnts,
                                        stems, cnt, extr, PosX);
         } else {
            xcnt = CollectPoints(orgpaths, ttpnts,  stems, cnt,
                                 extr, PosX);
         }

         /* Do the 3% scaling */
         ScaleDown3(extr, xcnt, pgm, &pc, args, &pcd);

         /* Switch over to GLYPHZONE */
         pgm[pc++] = op_szp2;
         args[pcd++] = 1;

         /* Interpolate the local extremas. */
         EmitIP(extr, xcnt, pgm, &pc, args, &pcd, (short)SECONDPAIR);

         /* Interpolate/Shift the rest. */
         pgm[pc++] = op_iup | SUBOP_X;


         /* Free used resources */
         if (stems)
            Free(stems);
      }
   }

   *pc_ptr = pc;
   *pcd_ptr = pcd;

   return status;
}



/***
** Function: ResolveBlueHStem3
**
** Description:
**   This function attemts to resolves a conflict between
**   a hstem3 that has one of its stems in an alignment zone,
**   if there is such a conflict.
***/
static short ResolveBlueHStem3(TTStem *stems,
                               const short cnt,
                               const short k)
{
   short ref = stems[k].ref;
   TTStem tmp;
   short i;

   /* The parent stem of a hstem3 must be first in the 'stems' array,
   i.e. the order of the stems is important.  The children stems may
   therefore have to be swaped with the parten to enforce this condition. */

   if ((stems[k].align==at_relative1 ||
        stems[k].align==at_relative2) &&
       (stems[ref].align!=at_relative1 &&
        stems[ref].align!=at_relative2 &&
        stems[ref].align!=at_side1 &&
        stems[ref].align!=at_side2)) {
      tmp = stems[k];
      stems[k] = stems[ref];
      stems[k].align = at_relative1;
      stems[k].ref = ref;
      stems[ref] = tmp;
      for (i=0; i<cnt; i++) {
         if (i!=k && i!=ref &&
             (stems[i].align==at_relative1 ||
              stems[i].align==at_relative2) &&
             stems[i].ref == ref) {
            stems[i].ref = (short)k;
            if (i<k) {
               tmp = stems[k];
               stems[k] = stems[i];
               stems[i] = tmp;
            }
            break;
         }
      }

   } else {
      ref = k;
   }

   return ref;
}



/***
** Function: ConvertHStems
**
** Description:
**   This function converts hstem and hstem3 T1 instructions.
***/
static errcode ConvertHStems(struct T1Metrics *t1m,
                             const Hints *hints,
                             const Outline *orgpaths,
                             const short *ttpnts,
                             UBYTE *pgm,
                             short *pc_ptr,
                             short *args,
                             short *pcd_ptr,
                             USHORT *twilight_ptr)
{
   Extremas extr[MAXEXTR];
   short xcnt = 0;
   errcode status = SUCCESS;
   short pc = *pc_ptr;
   short pcd = *pcd_ptr;
   TTStem *stems = NULL;
   short i, k;
   short cnt;
   short cvt;

   /* Create the stem buckets. */
   cnt = CreateStemBuckets(hints->hstems, hints->hstems3, &(stems));
   if (cnt==NOMEM)
      return NOMEM;

   /* Update Max num of twilight points. */
   if ((USHORT)(cnt*TWILIGHTS_PER_STEM+TMP_TWILIGHTS) > (*twilight_ptr))
      (*twilight_ptr) = (USHORT)(cnt * TWILIGHTS_PER_STEM + TMP_TWILIGHTS);

#if RELATIVESTEMS
   /* Do counter- and overlappning stem control? */
   for (i=0; i<cnt; i++) {
      short j;

      if (stems[i].align==at_centered) {
         funit prox = (funit)(ABS(MAX(100, stems[i].side2 - stems[i].side1)));
         funit prox2;
         prox2 = (funit)(prox/2);
         for (j=0; j<i; j++) {
            if (stems[j].cnt &&
                !((stems[i].side1 - (funit)prox > stems[j].side2) ||
                  (stems[i].side2 + (funit)prox < stems[j].side1)) &&
                (ABS(stems[i].side2-stems[i].side1-
                     (stems[j].side2-stems[j].side1)) < prox2 ||
                 (short)(stems[i].side1 > stems[j].side2) !=
                 (short)(stems[i].side2 < stems[j].side1)))
               break;
         }
         if (i!=j) {
            if (stems[j].side1 < stems[i].side1)
               stems[i].align = at_relative1;
            else
               stems[i].align = at_relative2;
            stems[i].ref = j;
         }
      }
   }
#endif

   /* Do alignment control. */
   for (i=0; i<cnt; i++) {
      if ((cvt=GetBottomPos(GetBlues(t1m),
                            GetAlignment(t1m),
                            stems[i].side1))!=UNDEF) {
         k = ResolveBlueHStem3(stems, cnt, i);
         stems[k].ref = cvt;
         stems[k].align = at_side1;
      } else if ((cvt=GetTopPos(GetBlues(t1m),
                                GetAlignment(t1m),
                                stems[i].side2))!=UNDEF) {
         k = ResolveBlueHStem3(stems, cnt, i);
         stems[k].ref = cvt;
         stems[k].align = at_side2;
      } 
   }


   if (cnt && stems) {

      /** Horizontal stem hints */
      EmitHorizontalStems(pgm, &pc, args, &pcd);

      /* Convert the buckets into instructions. */
      for (i=0; i<cnt; i++) {

         if (stems[i].cnt==0)
            continue;

         /* Resolve relative stems */
         if ((stems[i].align == at_relative1 ||
              stems[i].align == at_relative2) &&
             stems[i].ref != UNDEF)
            ResolveRelativeStem(&stems[stems[i].ref], &stems[i]);

         /* Emit the instructions. */
         status = EmitHStem(pgm, &pc, args, &pcd, t1m,
                            stems[i].side2 - stems[i].side1,
                            TransY(t1m, stems[i].side1),
                            TransY(t1m, stems[i].side2),
                            (short)MIN(stems[i].rp1, stems[i].rp2),
                            stems[i].align,
                            stems[i].ref);

         if (status!=SUCCESS)
            break;
      }


      /* Interpolate extremas residing within and between stem sides. */
      xcnt = CollectPoints(orgpaths, ttpnts, stems, cnt, extr, PosY);

      /* Switch over to GLYPHZONE */
      pgm[pc++] = op_szp2;
      args[pcd++] = 1;

      /* Interpolate the local extremas. */
      EmitIP(extr, xcnt, pgm, &pc, args, &pcd, (short)0);

      /* Interpoalte/Shift the rest. */
      pgm[pc++] = op_iup | SUBOP_Y;

      /* Free used resources */
      if (stems)
         Free(stems);
   }

   *pcd_ptr = pcd;
   *pc_ptr = pc;

   return status;
}


/***** FUNCTIONS */

/***
** Function: GetRomanHints
**
** Description:
***/
const UBYTE *GetRomanHints(int *size)
{
   (*size) = sizeof(roman_hints);

   return roman_hints;
}


/***
** Function: GetSwissHints
**
** Description:
***/
const UBYTE *GetSwissHints(int *size)
{
   (*size) = sizeof(swiss_hints);

   return swiss_hints;
}


/***
** Function: MatchingFamily
**
** Description:
**   Locate the family alignment zone that is closest to
**   a given alignment zone.
***/
short MatchingFamily(const funit pos,
                     const funit *family,
                     const USHORT fcnt)
{
   funit min_dist = SHRT_MAX;
   short k = UNDEF;
   USHORT j;

   /* Look for the closest family blue. */
   for (j=0; j<fcnt; j+=2) {
      if (ABS(family[j] - pos) < min_dist) {
         k = (short)j;
         min_dist = ABS(family[j] - pos);
      }
   }

   return k;
}




/***
** Function: ConvertHints
**
** Description:
**   This functions converts hstem, hstem3, vstem, vstem3 and flex
**   hints, as well as doing diagonal control.
***/
errcode ConvertHints(struct T1Metrics *t1m,
                     const Hints *hints,
                     const Outline *orgpaths,
                     const Outline *paths,
                     const short *ttpnts,
                     UBYTE **gpgm,
                     USHORT *num,
                     USHORT *stack,
                     USHORT *twilight)
{
   errcode status = SUCCESS;
   UBYTE *pgm = NULL;
   short *args = NULL;
   short pc = 0;
   short pcd = 0;
   short cnt = 0;
   short narg = 0;
   short marg = 0;

   /* Access resources. */
   pgm=GetCodeStack(t1m);
   args=GetArgStack(t1m);


   /* Convert the vertical stem hints. */
   if (status==SUCCESS)
      status = ConvertVStems(t1m, hints, orgpaths, ttpnts,
                             pgm, &pc, args, &pcd, twilight);
   /* Convert the horizontal stem hints. */
   if (status==SUCCESS)
      status = ConvertHStems(t1m, hints, orgpaths, ttpnts,
                             pgm, &pc, args, &pcd, twilight);

   /* Convert flex hints. */
   if (status==SUCCESS)
      status = ConvertFlex(t1m, hints->flex, ttpnts,
                           pgm, &pc, args, &pcd, &marg);

   /********************
   * Adjust diagonals 
   * Do not reduce if dominant vertical stem width is more than 
   * 2.0 pels at 11PPEm and above. This occurs when:
   * 1) StdVW > 187 
   * 2) StdVW < 100 and ForceBold = TRUE
   **/
   if ((ForceBold(t1m)==1 && GetStdVW(t1m)>100 && GetStdVW(t1m)<187) ||
       (ForceBold(t1m)==0 && GetStdVW(t1m)<187))
      narg = ReduceDiagonals(paths, pgm, &pc, args, &pcd);
   if (narg>marg)
      marg = narg;

   if (pc>PGMSIZE) {
      SetError(status = TTSTACK);
   }
   if (pcd>ARGSIZE) {
      SetError(status = ARGSTACK);
   }

   /* Allocate the gpgm */
   (*gpgm) = NULL;
   (*num) = 0;
   (*stack) = 0;
   if (status==SUCCESS) {
      if (pc) {
         if (((*gpgm) = Malloc((USHORT)(pc+pcd*3)))==NULL) {
            SetError(status = NOMEM);
         } else {
            /* Assemble the arguments for the instructions */
            cnt = 0;
            AssembleArgs(args, pcd, (*gpgm), &cnt);
            memcpy(&(*gpgm)[cnt], pgm, (USHORT)pc);
            (*num) = (USHORT)(cnt + pc);
            (*stack) = (USHORT)(pcd + marg);
         }
      }
   }


   return status;
}



/***
** Function: BuildPreProgram
**
** Description:
**   This function builds the pre-program that will compute
**   the CVT and storage entries for the TT stem hint
**   instructions to work. 
***/
USHORT BuildPreProgram(const struct T1Metrics *t1m,
                       const WeightControl *weight,
                       Blues *blues,
                       AlignmentControl *align,
                       UBYTE **glob_prep,
                       const int prepsize,
                       USHORT *maxstack)
{
   UBYTE *prep = (*glob_prep);
   short *args = NULL;
   short ta, tp = 0;
   USHORT i, j;
   long shift;
   funit stdvw, stdhw;
   short cis;
   funit std_width;
   USHORT std_tres;
   funit min_dist;
   short k;
   short argsize = ARGSIZE;
   short psize = (short)prepsize;

   /* Allocate work space. */
   if ((args=Malloc(sizeof(args[0])*(USHORT)argsize))==NULL) {
      LogError(MSG_ERROR, MSG_NOMEM, NULL);
   } else {

      /* Copy the standard pre-program. */
      memcpy(prep, PrepProg, sizeof(PrepProg));
      tp = sizeof(PrepProg);
      (*maxstack) = 0;

      /**********
      * Compute Blue values.
      */

      prep[tp++] = op_pushb1; prep[tp++] = blues->blueScale;
      prep[tp++] = op_mppem;
      prep[tp++] = op_lt;
      prep[tp++] = op_if;
      prep[tp++] = op_pushb1;
      prep[tp++] = ONEPIXEL;
      prep[tp++] = op_smd;
      prep[tp++] = op_pushb1;
      prep[tp++] = TWILIGHT;
      prep[tp++] = op_szps;
      prep[tp++] = op_svcta | SUBOP_Y;
      prep[tp++] = op_rtg;


      /***********************/
      /*** ABOVE BlueScale ***/
      /***********************/

      /* Align the top zones. */
      for (i=0; i<blues->blue_cnt/2; i++) { 
         min_dist = SHRT_MAX;
         k = UNDEF;

         /*** Copy the FamilyBlue entries to the BlueValues if */
         /*** below the Family cut in size.         */
         if (blues->fblue_cnt>0) {

            /* Do the cut in on FamilyBlue/BlueValue. */
            k = MatchingFamily(blues->bluevalues[i*2],
                               blues->familyblues,
                               blues->fblue_cnt);
            min_dist = ABS(blues->bluevalues[i*2] - blues->familyblues[k]);

            /* Always FamilyBlue? */
            if (min_dist) { 
               cis = (short)(GetUPEM(t1m) / TransY(t1m, min_dist));
               tp = (short)FamilyCutIn(prep, (USHORT)tp, cis);
            }

            /* Allocate a cvt if this family has not been used before. */
            if (blues->family_cvt[k/2]==UNDEF_CVT) {
               blues->family_cvt[k/2] = align->cvt;
               align->cvt += 2;
            }

            ta = 2;
            CHECK_ARGSIZE(args, ta, align->top[i].cnt, argsize);
            for (j=0; j<align->top[i].cnt; j++) {
               args[ta++] = (short)align->top[i].pos[j].cvt;
            }
            CHECK_PREPSIZE(prep, tp, 2*ta+10, psize);
            tp = (short)CopyFamilyBlue(prep, tp, args, ta);
            if ((ta+2)>(int)(*maxstack))
               (*maxstack) = (USHORT)(ta+2);

            /* Set up the zone. */
            tp = (short)SetZone(prep, (USHORT)tp,
            (short)(blues->family_cvt[k/2]));

            if (min_dist>0)
               prep[tp++] = op_else;
         }


         /*** Set up the zone. */
         CHECK_PREPSIZE(prep, tp, STACKINC, psize);
         tp = (short)SetZone(prep, (USHORT)tp,
              (short)(align->top[i].blue_cvt));
         if (k!=UNDEF && min_dist) {
            prep[tp++] = op_eif;
         }


         /*** Round and enforce overshoot. */
         ta = 2;
         CHECK_ARGSIZE(args, ta, align->top[i].cnt, argsize);
         for (j=0; j<align->top[i].cnt; j++) {
            if ((align->top[i].pos[j].y -
                 blues->bluevalues[i*2])*F8D8 > blues->blueShift) {
               args[ta++] = (short)align->top[i].pos[j].cvt;
            }
         } 
         if (ta>2) {
            CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
            tp = (short)AlignOvershoot(prep, tp, args, ta);
            if (ta>(short)(*maxstack))
               (*maxstack) = (USHORT)ta;
         }

         ta = 2;
         CHECK_ARGSIZE(args, ta, align->top[i].cnt, argsize);
         for (j=0; j<align->top[i].cnt; j++) {
            if ((align->top[i].pos[j].y -
                 blues->bluevalues[i*2])*F8D8 <= blues->blueShift) {
               args[ta++] = (short)align->top[i].pos[j].cvt;
            }
         } 
         if (ta>2) {
            CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
            tp = (short)AlignFlat(prep, tp, args, ta);
            if (ta>(short)(*maxstack))
               (*maxstack) = (USHORT)(ta+2);
         }
      }



      /* Align the bottom zones. */
      for (i=0; i<blues->oblue_cnt/2; i++) { 
         min_dist = SHRT_MAX;
         k = UNDEF;

         /*** Copy the FamilyBlue entries to the BlueValues if */
         /*** below the Family cut in size.         */
         if (blues->foblue_cnt>0) {

            /* Do the cut in on FamilyBlue/BlueValue. */
            k = MatchingFamily(blues->otherblues[i*2],
                               blues->familyotherblues,
                               blues->foblue_cnt);
            min_dist = ABS(blues->otherblues[i*2] -
                           blues->familyotherblues[k]);

            /* Always FamilyBlue? */
            if (min_dist) { 
               cis = (short)(GetUPEM(t1m) / TransY(t1m, min_dist));
               tp = (short)FamilyCutIn(prep, (USHORT)tp, cis);
            }

            /* Allocate a cvt if this family has not been used before. */
            if (blues->familyother_cvt[k/2]==UNDEF_CVT) {
               blues->familyother_cvt[k/2] = align->cvt++;
            }

            ta = 2;
            CHECK_ARGSIZE(args, ta, align->bottom[i].cnt, argsize);
            for (j=0; j<align->bottom[i].cnt; j++) {
               args[ta++] = (short)align->bottom[i].pos[j].cvt;
            }
            CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
            tp = (short)CopyFamilyBlue(prep, tp, args, ta);
            if (ta>(short)(*maxstack))
               (*maxstack) = (USHORT)ta;


            /* Set up the zone. */
            tp = (short)SetZone(prep, (USHORT)tp,
            (short)blues->familyother_cvt[k/2]);

            if (min_dist>0)
               prep[tp++] = op_else;
         }


         /*** Set up the zone. */
         tp = (short)SetZone(prep, (USHORT)tp,
              (short)align->bottom[i].blue_cvt);
         if (k!=UNDEF && min_dist) {
            prep[tp++] = op_eif;
         }


         /*** Round and enforce overshoot. */
         ta = 2;
         CHECK_ARGSIZE(args, ta, align->bottom[i].cnt, argsize);
         for (j=0; j<align->bottom[i].cnt; j++) {
            if ((align->bottom[i].pos[j].y -
                 blues->otherblues[i*2+1])*F8D8 > blues->blueShift) {
               args[ta++] = (short)align->bottom[i].pos[j].cvt;
            }
         } 
         if (ta>2) {
            CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
            tp = (short)AlignOvershoot(prep, tp, args, ta);
            if (ta>(short)(*maxstack))
               (*maxstack) = (USHORT)ta;
         }

         ta = 2;
         CHECK_ARGSIZE(args, ta, align->bottom[i].cnt, argsize);
         for (j=0; j<align->bottom[i].cnt; j++) {
            if ((align->bottom[i].pos[j].y -
                 blues->otherblues[i*2+1])*F8D8 <= blues->blueShift) {
               args[ta++] = (short)align->bottom[i].pos[j].cvt;
            }
         } 
         if (ta>2) {
            CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
            tp = (short)AlignFlat(prep, tp, args, ta);
            if (ta>(short)(*maxstack))
               (*maxstack) = (USHORT)(ta+2);
         }
      }




      /***********************/
      /*** BELOW BlueScale ***/
      /***********************/
      prep[tp++] = op_else;

      /*** Align the top zones. */

      for (i=0; i<blues->blue_cnt/2; i++) { 

         /* Initiate */
         min_dist = SHRT_MAX;
         k = UNDEF;

         /* switch between blues and family blues. */
         if (blues->fblue_cnt) {

            /* Look for the closest family blue. */
            k = MatchingFamily(blues->bluevalues[i*2],
                               blues->familyblues,
                               blues->fblue_cnt);
            min_dist = ABS(blues->bluevalues[i*2] - blues->familyblues[k]);

            /* Copy/Round the family overshoot position to the zone. */
            if (min_dist) {
               cis = (short)(GetUPEM(t1m) / TransY(t1m, (funit)min_dist));
               tp = (short)FamilyCutIn(prep, (USHORT)tp, cis);
               ta = 2;
               CHECK_ARGSIZE(args, ta, align->top[i].cnt*2, argsize);
               for (j=0; j<align->top[i].cnt; j++) {
                  args[ta++] = (short)(blues->family_cvt[k/2] + 1);
                  args[ta++] = (short)(align->top[i].pos[j].cvt);
               }
               CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
               tp = (short)CopyZone(prep, tp, args, ta);
               if (ta>(short)(*maxstack))
                  (*maxstack) = (USHORT)(ta+2);


               prep[tp++] = op_else;
            }
         }

         /* Copy/Round the blue overshoot position to the zone position. */
         ta = 2;
         CHECK_ARGSIZE(args, ta, align->top[i].cnt*2, argsize);
         for (j=0; j<align->top[i].cnt; j++) {
            args[ta++] = (short)(align->top[i].blue_cvt + 1);
            args[ta++] = (short)(align->top[i].pos[j].cvt);
         }
         CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
         tp = (short)CopyZone(prep, tp, args, ta);
         if (ta>(short)(*maxstack))
            (*maxstack) = (USHORT)ta;

         if (k!=UNDEF && min_dist>0)
            prep[tp++] = op_eif;
      }


      /*** Align the bottom zones. */
      for (i=0; i<blues->oblue_cnt/2; i++) { 

         /* Initiate. */
         min_dist = SHRT_MAX;
         k = UNDEF;

         /* switch between blues and family blues. */
         if (blues->foblue_cnt) {

            /* Look for the closest family blue. */
            k = MatchingFamily(blues->otherblues[i*2],
                               blues->familyotherblues,
                               blues->foblue_cnt);
            min_dist = ABS(blues->otherblues[i*2] -
                           blues->familyotherblues[k]);

            /* Copy/Round the family overshoot position to the zone. */
            if (min_dist) {
               cis = (short)(GetUPEM(t1m) / TransY(t1m, (funit)min_dist));
               tp = (short)FamilyCutIn(prep, (USHORT)tp, cis);
               ta = 2;
               CHECK_ARGSIZE(args, ta, align->bottom[i].cnt*2, argsize);
               for (j=0; j<align->bottom[i].cnt; j++) {
                  args[ta++] = (short)(blues->familyother_cvt[k/2]);
                  args[ta++] = (short)(align->bottom[i].pos[j].cvt);
               }
               CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
               tp = (short)CopyZone(prep, tp, args, ta);
               if (ta>(short)(*maxstack))
                  (*maxstack) = (USHORT)ta;

               prep[tp++] = op_else;
            }
         }

         /* Copy/Round the blue overshoot position to the zone position. */
         ta = 2;
         CHECK_ARGSIZE(args, ta, align->bottom[i].cnt*2, argsize);
         for (j=0; j<align->bottom[i].cnt; j++) {
            args[ta++] = (short)(align->bottom[i].blue_cvt);
            args[ta++] = (short)(align->bottom[i].pos[j].cvt);
         }
         CHECK_PREPSIZE(prep, tp, ta*2+4, psize);
         tp = (short)CopyZone(prep, tp, args, ta);
         if (ta>(short)(*maxstack))
            (*maxstack) = (USHORT)ta;

         if (k!=UNDEF && min_dist>0)
            prep[tp++] = op_eif;
      }


      /* EIF[] MMPEM<BlueScale */
      prep[tp++] = op_eif;


      prep[tp++] = op_pushb1;
      prep[tp++] = 64;
      prep[tp++] = op_smd;


      /**************************************/
      /***      STEM WEIGHT CONTROL       ***/
      /**************************************/

      /****** ForceBold ***/
      if (ForceBold(t1m)) {
         prep[tp++] = op_pushb1+2;
         prep[tp++] = STDV_CVT;
         prep[tp++] = ONEPIXEL*3/4;
         prep[tp++] = STDV_CVT;
         prep[tp++] = op_rcvt;
         prep[tp++] = op_max;
         prep[tp++] = op_wcvtp;
      }


      /******
      * Compute width of horizontal stems. 
      */
      prep[tp++] = op_rtdg;
      prep[tp++] = op_svcta | SUBOP_Y;
      if ((std_width = GetStdHW(t1m))==0)
         std_width = GetDefStdHW(t1m);
      std_width = TransY(t1m, std_width);
      std_tres = (USHORT)(GetUPEM(t1m) * 2 / std_width);
      ta = 0;
      CHECK_ARGSIZE(args, ta, STEMSNAPARGS*weight->cnt_hw, argsize);
      for (i=0; i<weight->cnt_hw; i++) { 
         funit width = TransY(t1m, weight->hwidths[i].width);
         short snap = GetSnapH(t1m, weight->hwidths[i].width);
         USHORT storage = weight->hwidths[i].storage;
         USHORT snap_ci, std_ci;
         short snap_cvt;

         std_ci = CutInSize(width, std_width, std_tres, GetUPEM(t1m));
         if (snap!=UNDEF) {
            snap_ci = CutInSize(width, TransY(t1m, t1m->stemsnaph[snap]),
                                std_tres, GetUPEM(t1m));
            snap_cvt = (short)SNAPH_CVT(t1m, snap);
            ta = (short)SnapStemArgs(args, (USHORT)ta,
                 width, STDH_CVT, (USHORT)snap_cvt,
                 std_ci, snap_ci, storage);
         } else {
            ta = (short)StdStemArgs(args, (USHORT)ta, width, STDH_CVT,
                std_ci, storage);
         }
      } 
      if (ta+2>(short)(*maxstack))   /* Args + loopcnt + fun_num */
         (*maxstack) = (USHORT)(ta+2);
      CHECK_PREPSIZE(prep, tp, ta*2+2, psize);
      AssembleArgs(args, ta, prep, &tp);
      if (t1m->snaph_cnt)
         tp = (short)CreateSnapStems(prep, (USHORT)tp, (short)weight->cnt_hw);
      else
         tp = (short)CreateStdStems(prep, (USHORT)tp,  (short)weight->cnt_hw);


      /******
      * Compute width of vertical stems. 
      */
      prep[tp++] = op_svcta | SUBOP_X;
      if ((std_width = GetStdVW(t1m))==0)
         std_width = GetDefStdVW(t1m);
      std_width = TransX(t1m, std_width);
      std_tres = (USHORT)(GetUPEM(t1m) * 2 / std_width);
      ta = 0;
      CHECK_ARGSIZE(args, ta, STEMSNAPARGS*weight->cnt_vw, argsize);
      for (i=0; i<weight->cnt_vw; i++) { 
         funit width = TransX(t1m, weight->vwidths[i].width);
         short storage = (short)weight->vwidths[i].storage;
         short snap = GetSnapV(t1m, weight->vwidths[i].width);
         USHORT snap_ci, std_ci;
         short snap_cvt;

         std_ci = CutInSize(width, std_width, std_tres, GetUPEM(t1m));
         if (snap!=UNDEF) {
            snap_ci = CutInSize(width, TransX(t1m, t1m->stemsnapv[snap]),
                                std_tres, GetUPEM(t1m));
            snap_cvt = (short)SNAPV_CVT(snap);
            ta = (short)SnapStemArgs(args, (USHORT)ta,
                              width, STDV_CVT, (USHORT)snap_cvt,
                              std_ci, snap_ci, (USHORT)storage);
         } else {
            ta = (short)StdStemArgs(args, (USHORT)ta, width,
                STDV_CVT, std_ci, (USHORT)storage);
         }
      } 
      if (ta+2>(short)(*maxstack))
         (*maxstack) = (USHORT)(ta+2);
      CHECK_PREPSIZE(prep, tp, ta*2+2, psize);
      AssembleArgs(args, ta, prep, &tp);
      if (t1m->snapv_cnt)
         tp = (short)CreateSnapStems(prep, (USHORT)tp, (short)weight->cnt_vw);
      else
         tp = (short)CreateStdStems(prep, (USHORT)tp, (short)weight->cnt_vw);



      prep[tp++] = op_rtg;


      /******
      * Compute diagonal control parameters.
      */
      CHECK_PREPSIZE(prep, tp, STACKINC, psize);
      if ((stdvw = GetStdVW(t1m))==0)
         stdvw = GetDefStdVW(t1m);
      if ((stdhw = GetStdHW(t1m))==0)
         stdhw = GetDefStdHW(t1m);
      if (stdvw && stdhw) {
         cis = (short)(MAX((GetUPEM(t1m) + GetUPEM(t1m)/2) / std_width, 1));
#ifdef SYMETRICAL_REDUCTION
         shift = (long)GetUPEM(t1m);
#else
         shift = (long)GetUPEM(t1m)*(long)MIN(stdvw,stdhw)/
                 (long)MAX(stdvw, stdhw)/2L+(long)GetUPEM(t1m)/2L;
#endif
      } else if (stdvw || stdhw) {
         cis = (short)(1548 / MAX(stdvw, stdhw) + 1);
         shift = (long)GetUPEM(t1m)/2;
      } else {
         cis = 41;
         shift = GetUPEM(t1m)/4;
      }

      prep[tp++] = op_pushb1; prep[tp++] = STORAGE_DIAG;
      prep[tp++] = op_pushb1; prep[tp++] = STDV_CVT;
      prep[tp++] = op_rcvt;
      prep[tp++] = op_pushb1; prep[tp++] = (UBYTE)48;
      prep[tp++] = op_lt;
      prep[tp++] = op_if;

#ifdef SYMETRICAL_REDUCTION
      /* Compute the reduction. */
      shift = (short)(shift/(long)cis/4);
      prep[tp++] = op_npushw;
      prep[tp++] = 2;
      prep[tp++] = (UBYTE)TMPCVT;
      prep[tp++] = 0;
      prep[tp++] = HIBYTE(shift);
      prep[tp++] = LOBYTE(shift);
      prep[tp++] = op_wcvtf;
      prep[tp++] = op_pushb1; prep[tp++] = (UBYTE)TMPCVT;
      prep[tp++] = op_rcvt;
      prep[tp++] = op_pushb1; prep[tp++] = MIN_REDUCTION;
      prep[tp++] = op_add;
#else
      /* Compute the reduction. */
      shift = (short)(shift/(long)cis/2);
      prep[tp++] = op_npushw;
      prep[tp++] = 2;
      prep[tp++] = (UBYTE)TMPCVT;
      prep[tp++] = 0;
      prep[tp++] = HIBYTE(shift);
      prep[tp++] = LOBYTE(shift);
      prep[tp++] = op_wcvtf;
      prep[tp++] = op_pushb1; prep[tp++] = (UBYTE)TMPCVT;
      prep[tp++] = op_rcvt;
      prep[tp++] = op_pushb1; prep[tp++] = REDUCTION_C1;
      prep[tp++] = op_max;
#endif

      prep[tp++] = op_else;
      prep[tp++] = op_pushb1; prep[tp++] = 0;
      prep[tp++] = op_eif;

      prep[tp++] = op_pushb1 + 1;
      prep[tp++] = VERSION_1_5;
      prep[tp++] = VERSION_SELECTOR;
      prep[tp++] = op_getinfo;
      prep[tp++] = op_gt;
      prep[tp++] = op_if;
      prep[tp++] = op_pushb1;
      prep[tp++] = 8;
      prep[tp++] = op_mul;
      prep[tp++] = op_eif;

      prep[tp++] = op_ws;

      Free(args);
   } 

   (*glob_prep) = prep;                             
   return (USHORT)tp;
}




/***
** Function: GetFontProg
**
** Description:
**   Return the font program.
***/
const UBYTE *GetFontProg(void)
{
   return tt_GetFontProg();
}


/***
** Function: GetFontProgSize
**
** Description:
**   Return the size of the font program.
***/
const USHORT GetFontProgSize(void)
{
   return tt_GetFontProgSize();
}


/***
** Function: GetNumFuns
**
** Description:
**   Return the number of functions defined in
**   the font program.
***/
const USHORT GetNumFuns(void)
{
   return tt_GetNumFuns();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\hints.h ===
/***
**
**   Module: Hints
**
**   Description:
**      This is a module of the T1 to TT font converter. This is a
**      sub-module of the T1 to TT data translator module. It deals
**      with hints. Any part pf the T1 font that gets translated into
** TrueType instructions is done within this module.
**
**   Author: Michael Jansson
**
**   Created: 8/24/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif



/***
** Function: ConvertHints
**
** Description:
**   This functions converts hstem, hstem3, vstem, vstem3 and flex
**   hints, as well as doing diagonal control.
***/
errcode        ConvertHints      _ARGS((INOUT   struct T1Metrics *t1m,
                                        IN      Hints *hints,
                                        IN      Outline *orgpaths,
                                        IN      Outline *paths,
                                        IN      short *sideboard,
                                        OUT     UBYTE **gpgm,
                                        OUT     USHORT *num,
                                        OUT     USHORT *stack,
                                        OUT     USHORT *twilight));

/***
** Function: BuildPreProgram
**
** Description:
**   This function builds the pre-program that will compute
**   the CVT and storage entries for the TT stem hint
**   instructions to work. 
***/
USHORT         BuildPreProgram   _ARGS((IN      struct T1Metrics *t1m,
                                        IN      WeightControl *weight,
                                        INOUT   Blues *blues,
                                        INOUT   AlignmentControl *align,
                                        INOUT   UBYTE **prep,
                                        IN      int prepsize,
                                        OUT     USHORT *maxprepstack));
/***
** Function: MatchingFamily
**
** Description:
**   Locate the family alignment zone that is closest to
**   a given alignment zone.
***/
short          MatchingFamily    _ARGS((IN      funit pos,
                                        IN      funit *family,
                                        IN      USHORT fcnt));
/***
** Function: GetRomanHints
**
** Description:
***/
const UBYTE    *GetRomanHints    _ARGS((OUT     int *size));


/***
** Function: GetSwissHints
**
** Description:
***/
const UBYTE    *GetSwissHints    _ARGS((OUT     int *size));


/***
** Function: GetFontProg
**
** Description:
**   Return the font program.
***/
const UBYTE    *GetFontProg      _ARGS((void));


/***
** Function: GetFontProgSize
**
** Description:
**   Return the size of the font program.
***/
const USHORT   GetFontProgSize   _ARGS((void));


/***
** Function: GetNumFuns
**
** Description:
**   Return the number of functions defined in
**   the font program.
***/
const USHORT   GetNumFuns        _ARGS((void));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\fwriter.c ===
/***
**
**   Module: T1Parser
**
**   Description:
**  This is a module of the T1 to TT font converter. The module
**  contains functions that is used by the Builder moduler, to
**  manage the lowlevel writing to the TT font file, as well as
**  generic check sum, table length and table offset computations.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
/*-none-*/

/* Special types and definitions. */
#include "types.h"

/* Module dependent types and prototypes. */
#include "fileio.h"
#include "fwriter.h"



/***** LOCAL TYPES */
/*-none-*/



/***** CONSTANTS */
static const char *dir[] = {
   "OS/2",
   "cmap",
   "cvt ",
   "fpgm",
   "gasp",
   "glyf",
   "head",
   "hhea",
   "hmtx",
   "kern",
   "loca",
   "maxp",
   "name",
   "post",
   "prep",
};

#define MAGIC_CHECKSUM  0xB1B0AFBA


/***** MACROS */
/*-none-*/



/***** STATIC FUNCTIONS */
/***
** Function: SumCheckSum
**
** Description:
**   This function computes the check sum of
**   a section of the output file.
***/
static ULONG SumCheckSum(OutputFile *file, long length)
{
   ULONG sum = 0;
   UBYTE tbl[32];


   /* Unwrap the loop a bit. */
   while (length>16) {
      (void)io_ReadBytes(tbl, (USHORT)16, file);
      sum += MkLong(tbl[0],  tbl[1],  tbl[2],  tbl[3]);
      sum += MkLong(tbl[4],  tbl[5],  tbl[6],  tbl[7]);
      sum += MkLong(tbl[8],  tbl[9],  tbl[10], tbl[11]);
      sum += MkLong(tbl[12], tbl[13], tbl[14], tbl[15]);
      length -= 16;
   }

   /* Do the sentinel DWORDS. */
   while (length>0) {
      (void)io_ReadBytes(tbl, (USHORT)4, file);
      sum += MkLong(tbl[0], tbl[1], tbl[2], tbl[3]);
      length -= 4;
   }

   return sum;
}



/***** FUNCTIONS */


/***
** Function: WriteLong
**
** Description:
**   This function writes a 32-bit integer in the
**   Big Endian byte order, regardless of the
**   used byte order.
***/
void WriteLong(const ULONG val, OutputFile *file)
{
   UBYTE bytes[4];

   bytes[0] = (UBYTE)((val>>24)&0xff);
   bytes[1] = (UBYTE)((val>>16)&0xff);
   bytes[2] = (UBYTE)((val>>8)&0xff);
   bytes[3] = (UBYTE)((val)&0xff);
   (void)WriteBytes(bytes, (USHORT)4, file);
}



/***
** Function: WriteShort
**
** Description:
**   This function writes a 16-bit integer in the
**   Big Endian byte order, regardless of the used
**   byte order.
***/
void WriteShort(const USHORT val, OutputFile *file)
{
   UBYTE bytes[2];

   bytes[0] = (UBYTE)((val>>8)&0xff); 
   bytes[1] = (UBYTE)((val)&0xff);
   (void)WriteBytes(bytes, (USHORT)2, file);
}



/***
** Function: WriteByte
**
** Description:
**   This function writes an 8-bit integer in the
**   Big Endian byte order, regardless of used
**   byte order.
***/
void WriteByte(const UBYTE byte, OutputFile *file)
{
   (void)WriteBytes(&byte, (USHORT)1, file);
}




/***
** Function: CompleteTable
**
** Description:
**   This function completes a TT font file table,
**   by computing the check sum and writing it, the
**   table length and table offset to the table directory
**   of the TT font file.
**
**   Please note the dependency that this function must
**   be called right after the last byte of the contents
**   of the table have been written.
***/
errcode CompleteTable(const long offset,
                      const USHORT num,
                      OutputFile *file)
{
   long end;
   long length;
   ULONG sum = 0;
   long curr;
   short i;

   /* Determine the end of the table. */
   end = FileTell(file);

   /* Write pad bytes. */
   length = end - offset;
   if (length%4)
      for (i=0; i<(4-(long)(length%4)); i++)
         WriteByte(0, file);

   /* Record end of file position. */
   curr = io_FileTell(file);

   /* Compute the check sum */
   (void)io_FileSeek(file, offset);
   sum = SumCheckSum(file, end - offset);

   /* Write table directory entry */
   (void)io_FileSeek(file, (ULONG)(12L + TBLDIRSIZE*num + 4L));
   WriteLong(sum, file);
   WriteLong((ULONG)offset, file);
   WriteLong((ULONG)length, file);

   /* Go to end of file. */
   (void)io_FileSeek(file, curr);

   return FileError(file);
}



/***
** Function: WriteChecksum
**
** Description:
**   This function completes the whole TT font file,
**   by computing the check sum of the whole file and writing
**   it at the designated place.
***/
void WriteChecksum(const long offset, OutputFile *file)
{
   long end;
   ULONG sum = 0;

   end = io_FileTell(file);
   (void)io_FileSeek(file, 0L);
   sum = SumCheckSum(file, end);
   sum = MAGIC_CHECKSUM - sum;
   (void)io_FileSeek(file, offset);
   WriteLong(sum, file);
}




/***
** Function: WriteTableHeader
**
** Description:
**   This function initiates a TT font file, by initiating 
**   a handle used when writing the tables and by writing
**   the leading table dictionary of the file.
***/
void WriteTableHeader(OutputFile *file)
{
   USHORT segcount;
   USHORT i;


   /* Count the segcount */ /*lint -e650 */
   for (segcount=0; (1UL<<(segcount+1)) <= NUMTBL; segcount++)
      continue; /*lint +e650*/

   /* Write the offset table. */
   WriteLong(0x00010000L, file);
   WriteShort((USHORT)NUMTBL, file);
   WriteShort((USHORT)((1<<segcount)*16), file);
   WriteShort(segcount, file);
   WriteShort((USHORT)(NUMTBL*16-(1<<segcount)*16), file);

   /* Write the table directory entries. */
   for (i=0; i<NUMTBL; i++) {
      (void)WriteBytes((UBYTE*)&(dir[i][0]), (USHORT)4, file);
      WriteLong(0L, file);
      WriteLong(0L, file);
      WriteLong(0L, file);
   }
}



/***
** Function: OpenOutputFile
**
** Description:
***/
OutputFile *OpenOutputFile(const  char *name)
{
   return io_OpenFile(name, READWRITE);
}



/***
** Function: CloseOutputFile
**
** Description:
***/
errcode CloseOutputFile(OutputFile *fp)
{
   return io_CloseFile(fp);
}


/***
** Function: WriteBytes
**
** Description:
***/
USHORT WriteBytes(const UBYTE *buf,
                  const USHORT len,
                  OutputFile *fp)
{
   return io_WriteBytes(buf, len, fp);
}



/***
** Function: FileError
**
** Description:
***/
boolean FileError(OutputFile *fp)
{
   return io_FileError(fp);
}



/***
** Function: FileTell
**
** Description:
***/
long FileTell(OutputFile *fp)
{
   return io_FileTell(fp);
}



/***
** Function: FileSeek
**
** Description:
***/
long FileSeek(OutputFile *fp,
              const long where)
{
   return io_FileSeek(fp, where);
}


/***
** Function: RemoveFile
**
** Description:
**  Removes an already closed output file.
***/
void RemoveFile(const char *name)
{
   io_RemoveFile(name);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\metrics.h ===
#ifndef METRICS_H
#define METRICS_H



#define ONOFFSIZE(n)	((((n+7)/8)+sizeof(long)-1)/sizeof(long)*sizeof(long))
#define OnCurve(arr, n)  !((arr[(USHORT)(n)>>5]) & (ULONG)(1UL<<((USHORT)(n) % 32UL)))
#define SetOffPoint(arr, n)  arr[(unsigned)(n)/sizeof(arr[0])/8] |= \
                              1UL<<((unsigned)(n) % (sizeof(arr[0])*8))
#define SetOnPoint(arr, n)   arr[(unsigned)(n)/sizeof(arr[0])/8] &= \
                              ~(1UL<<((unsigned)(n) % (sizeof(arr[0])*8UL)))

#define USEMETRICS      0
#define DEFAULTMETRICS  1
#define F8D8            256
#define MAXSNAP         (USHORT)12
#define MAXBLUE         (USHORT)20
#define UNDEF_CVT			0
#define ENDOFPATH			-1
#define NORANGE			-2
#define ARGSIZE                 2000
#define PGMSIZE			3000
#define DEFAULTMATRIX	NULL
#define F16D16BASE		(1L<<19L)
#define F16D16HALF		(1L<<18L)
#define F16D16PPM			524




typedef int funit;
typedef struct {
	funit x;
	funit y;
} Point;

typedef struct Outline {
	struct Outline *next;	 /* Next path of the glyph. */
	USHORT count;		 /* Number of 'pts', 'onoff' and 'map'. */
	Point *pts;		 /* X/Y coordinates. */
	ULONG *onoff;		 /* On/Off curve point bit flags. */
} Outline;

typedef struct StemS {
        struct StemS *next;
        funit offset;
        funit width;
        short i1;
        short i2;
} Stem;

typedef struct Stem3S {
        struct Stem3S *next;
        Stem stem1;
        Stem stem2;
        Stem stem3;
} Stem3;

typedef struct FlexS {
   struct FlexS *next;
   funit civ;
   Point pos;
   Point midpos;
   Point startpos;
   USHORT start;
   USHORT mid;
   USHORT end;
} Flex;

typedef struct {
        Stem *vstems;
        Stem *hstems;
        Stem3 *vstems3;
        Stem3 *hstems3;
   Flex *flex;
} Hints;
        
        
typedef struct Composite {
   struct Composite *next;
   funit asbx;
   funit aw;
   funit adx;
   funit ady;
   const char *achar;
   const char *bchar;
   char *cchar;
   struct encoding *oenc;
} Composite;
   

typedef struct T1Glyph {
   char *name;

   Point lsb;
   Point width;

   Outline *paths;

   Hints hints;

} T1Glyph;
   

typedef struct StemWidth {
   funit width;
   USHORT storage;
} StemWidth;


typedef struct WeightControl {
   StemWidth *vwidths;
   USHORT cnt_vw;
   USHORT max_vw;
   StemWidth *hwidths;
   USHORT cnt_hw;
   USHORT max_hw;
   USHORT storage;
} WeightControl;

struct CVTPos {
   funit y;
   USHORT cvt;
};

typedef struct StemPos {
   struct CVTPos *pos;
   USHORT cnt;
   USHORT blue_cvt;
} StemPos;

typedef struct AlignmentControl {
   StemPos top[MAXBLUE/2];
   StemPos bottom[MAXBLUE/2];
   USHORT cvt;
} AlignmentControl;   

typedef struct Blues {
   funit bluevalues[MAXBLUE];
   USHORT blue_cnt;
   funit otherblues[MAXBLUE];
   USHORT oblue_cnt;
   funit familyblues[MAXBLUE];
   USHORT family_cvt[MAXBLUE/2];
   USHORT fblue_cnt;
   funit familyotherblues[MAXBLUE];
   USHORT familyother_cvt[MAXBLUE/2];
   USHORT foblue_cnt;
   short blueShift;      /*  /BlueShift * F8D8 */
   UBYTE blueFuzz;
   UBYTE blueScale;      /* /BlueScale * 1000 */
   AlignmentControl align;
} Blues;

struct kerning {
	UBYTE left;
	UBYTE right;
	funit delta;
};


struct T1Metrics {
   char *date;
   char *copyright;
   char *name;
   char *id;
   char *notice;
   char *fullname;
   char *weight;
   char *family;
   struct {
      USHORT ver;
      USHORT rev;
   } version;
   f16d16 angle;
   funit avgCharWidth;
   funit underline;
   funit uthick;
   funit stdhw;
   funit stdvw;
   funit defstdhw;
   funit defstdvw;
   funit stemsnaph[MAXSNAP];
   USHORT snaph_cnt;
   funit stemsnapv[MAXSNAP];
   USHORT snapv_cnt;
   UBYTE forcebold;
   UBYTE pitchfam;
   USHORT fixedPitch;
   USHORT flags;
   USHORT tmweight;
   funit ascent;
   funit descent;
   funit intLeading;
   funit extLeading;
   funit superoff;
   funit supersize;
   funit suboff;
   funit subsize;
   funit strikeoff;
   funit strikesize;
   UBYTE firstChar;
   UBYTE lastChar;
   UBYTE DefaultChar;
   UBYTE BreakChar;
   UBYTE CharSet;
   funit *widths;       /* Advance widths. */
   struct kerning *kerns;
   USHORT kernsize;
   WeightControl stems;
   Blues blues;
   funit upem;
   f16d16 *fmatrix;
   UBYTE pgm[PGMSIZE];
   short args[ARGSIZE];
   struct encoding *encoding;
   USHORT encSize;


   Composite *seac;
   Composite *used_seac;
};   



/****** MACROS */
#define GetUPEM(t1m)             (t1m->upem)
#define GetFontMatrix(t1m)       (t1m->fmatrix)
#define GetStdVW(t1m)            (t1m->stdvw)
#define GetStdHW(t1m)            (t1m->stdhw)
#define GetDefStdVW(t1m)         (t1m->defstdvw)
#define GetDefStdHW(t1m)         (t1m->defstdhw)
#define SetDefStdVW(t1m, width)  t1m->defstdvw = width
#define SetDefStdHW(t1m, width)  t1m->defstdhw = width
#define GetCodeStack(t1m)        t1m->pgm
#define GetArgStack(t1m)         t1m->args
#define GetWeight(t1m)           &(t1m->stems)
#define ForceBold(t1m)           t1m->forcebold
#define GetAlignment(t1m)        &(t1m->blues.align)
#define GetBlues(t1m)            &(t1m->blues)
#define CurrentEncoding(t1m)     t1m->encoding
#define EncodingSize(t1m)        t1m->encSize
#define Composites(t1m)          t1m->seac
#define SyntheticOblique(t1m)    (t1m->fmatrix && t1m->fmatrix[2])
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\makepfm.h ===
// *------------------------------------------------------------------------*
// * makepfm.h
// *------------------------------------------------------------------------*
//
//      Copyright 1990, 1991 -- Adobe Systems, Inc.
//      PostScript is a trademark of Adobe Systems, Inc.
//
// NOTICE:  All information contained herein or attendant hereto is, and
// remains, the property of Adobe Systems, Inc.  Many of the intellectual
// and technical concepts contained herein are proprietary to Adobe Systems,
// Inc. and may be covered by U.S. and Foreign Patents or Patents Pending or
// are protected as trade secrets.  Any dissemination of this information or
// reproduction of this material are strictly forbidden unless prior written
// permission is obtained from Adobe Systems, Inc.
//
//---------------------------------------------------------------------------


typedef char *LPSZ;

#define OPEN        FileOpen
#define CLOSE       _lclose
#define READ_BLOCK  _lread
#define WRITE_BLOCK _lwrite
#define STRCPY      lstrcpy
#define STRCAT      lstrcat
#define STRCMP      lstrcmp



/*--------------------------------------------------------------------------*/
#define DEBUG_MODE      0  

typedef struct {      /* A lookup table for converting strings to tokens */
  char *szKey;        /* Ptr to the string */
  int iValue;         /* The corresponding token value */
} KEY;

#define TK_UNDEFINED       0    /* tokens for ReadFontInfo */
#define TK_EOF             1
#define TK_MSMENUNAME      2
#define TK_VPSTYLE         3
#define TK_PI              4
#define TK_SERIF           5
#define TK_PCLSTYLE        6
#define TK_PCLSTROKEWEIGHT 7
#define TK_PCLTYPEFACEID   8
#define TK_INF_CAPHEIGHT   9
#define LAST_FI_TOKEN      9
#define TK_ANGLE           10   // added for ATM ( GetINFFontDescription )
#define TK_PSNAME          11   // added for ATM ( GetINFFontDescription )

/*----------------------------------------------------------------------------*/
/* EM describes the basic character cell dimension (in Adobe units) */
#define EM 1000

/*----------------------------------------------------------------------------*/
#define ANSI_CHARSET   0
#define SYMBOL_CHARSET 2
#define OEM_CHARSET    255
#define PCL_PI_CHARSET 181

#define PS_FONTTYPE    0x0081
#define PCL_FONTTYPE   0x0080

#define FW_NORMAL      400
#define FW_BOLD        700

/* GDI font families. */
#define WIN30
#ifdef WIN30
#define FF_DONTCARE   (0<<4) /* Don't care or don't know. */
#define FF_ROMAN      (1<<4) /* Variable stroke width, serifed. Times Roman, Century Schoolbook, etc. */
#define FF_SWISS      (2<<4) /* Variable stroke width, sans-serifed. Helvetica, Swiss, etc. */
#define FF_MODERN     (3<<4) /* Const stroke width, serifed or sans-serifed. Pica, Elite, Courier, etc. */
#define FF_SCRIPT     (4<<4) /* Cursive, etc. */
#define FF_DECORATIVE (5<<4) /* Old English, etc. */
#endif

typedef struct
{
  SHORT left;
  SHORT bottom;
  SHORT right;
  SHORT top;
} BBOX;

typedef struct {
  SHORT capHeight;
  SHORT xHeight;
  SHORT loAscent;        /* Lower-case ascent */
  SHORT loDescent;       /* Lower-case descent */
  SHORT ulOffset;        /* The underline offset */
  SHORT ulThick;         /* The underline thickness */
  SHORT iSlant;          /* The italic angle */
  BBOX  rcBounds;      /* The font bounding box */
} EMM;

typedef struct {
  char szFont[32];     /* The PostScript font name */
  char szFace[32];     /* The face name of the font */
  BOOL fEnumerate;     /* TRUE if the font should be enumerated */
  BOOL fItalic;        /* TRUE if this is an italic font */
  BOOL fSymbol;        /* TRUE if the font is decorative */
  SHORT iFamily;       /* The fonts family */
  WORD  iWeight;       /* TRUE if this is a bold font */
  SHORT iFirstChar;    /* The first character in the font */
  SHORT iLastChar;     /* The last character in the font */
  SHORT rgWidths[256]; /* Character widths from 0x020 to 0x0ff */
} FONT;

extern void PutByte(SHORT);
extern void PutWord(SHORT);
extern void PutLong(long);

typedef struct
{
  WORD iKey;
  SHORT iKernAmount;
} KX, *PKX;

typedef struct
{
  WORD cPairs;           /* The number of kerning pairs */
  PKX rgPairs;
} KP;

/* The info for a single kern track */
typedef struct
{
  SHORT iDegree;         /* The degree of kerning */
  SHORT iPtMin;          /* The minimum point size */
  SHORT iKernMin;        /* The minimum kern amount */
  SHORT iPtMax;          /* The maximum point size */
  SHORT iKernMax;        /* The maximum kern amount */
} TRACK;

#define MAXTRACKS 16
/* The track kerning table for a font */
typedef struct
{
  SHORT cTracks;              /* The number of kern tracks */
  TRACK rgTracks[MAXTRACKS];  /* The kern track information */
} KT;

/* Character metrics */
typedef struct
{
  BBOX rc;
  SHORT iWidth;
} CM;

typedef struct
{
  WORD  iPtSize;
  SHORT iFirstChar;
  SHORT iLastChar;
  SHORT iAvgWidth;
  SHORT iMaxWidth;
  SHORT iItalicAngle;
  SHORT iFamily;
  SHORT ulOffset;
  SHORT ulThick;
  SHORT iAscent;
  SHORT iDescent;
  BOOL fVariablePitch;
  BOOL fWasVariablePitch;
  char szFile[MAX_PATH + 4]; // +1 for nul term, +3 for alignment.
  char szFont[80];
  char szFace[80];
  SHORT iWeight;
  KP kp;
  KT kt;
  BBOX rcBBox;
  CM rgcm[256];        /* The character metrics */
} AFM;

/*----------------------------------------------------------------------------*/

typedef struct
{
  SHORT iSize;
  SHORT iPointSize;
  SHORT iOrientation;
  SHORT iMasterHeight;
  SHORT iMinScale;
  SHORT iMaxScale;
  SHORT iMasterUnits;
  SHORT iCapHeight;
  SHORT iXHeight;
  SHORT iLowerCaseAscent;
  SHORT iLowerCaseDescent;
  SHORT iSlant;
  SHORT iSuperScript;
  SHORT iSubScript;
  SHORT iSuperScriptSize;
  SHORT iSubScriptSize;
  SHORT iUnderlineOffset;
  SHORT iUnderlineWidth;
  SHORT iDoubleUpperUnderlineOffset;
  SHORT iDoubleLowerUnderlineOffset;
  SHORT iDoubleUpperUnderlineWidth;
  SHORT iDoubleLowerUnderlineWidth;
  SHORT iStrikeOutOffset;
  SHORT iStrikeOutWidth;
  WORD nKernPairs;
  WORD nKernTracks;
} ETM;

/*----------------------------------------------------------------------------*/

typedef struct
{
  WORD iVersion;
  DWORD iSize;
  CHAR szCopyright[60];
  WORD iType;
  WORD iPoints;
  WORD iVertRes;
  WORD iHorizRes;
  WORD iAscent;
  WORD iInternalLeading;
  WORD iExternalLeading;
  BYTE iItalic;
  BYTE iUnderline;
  BYTE iStrikeOut;
  WORD iWeight;
  BYTE iCharSet;
  WORD iPixWidth;
  WORD iPixHeight;
  BYTE iPitchAndFamily;
  WORD iAvgWidth;
  WORD iMaxWidth;
  BYTE iFirstChar;
  BYTE iLastChar;
  BYTE iDefaultChar;
  BYTE iBreakChar;
  WORD iWidthBytes;
  DWORD oDevice;
  DWORD oFace;
  DWORD oBitsPointer;
  DWORD oBitsOffset;
} PFM;

typedef struct
{
  WORD oSizeFields;
  DWORD oExtMetricsOffset;
  DWORD oExtentTable;
  DWORD oOriginTable;
  DWORD oPairKernTable;
  DWORD oTrackKernTable;
  DWORD oDriverInfo;
  DWORD iReserved;
} PFMEXT;

/*----------------------------------------------------------------------------*/

typedef enum    {
        epsymUserDefined,
        epsymRoman8,
        epsymKana8,
        epsymMath8,
        epsymUSASCII,
        epsymLineDraw,
        epsymMathSymbols,
        epsymUSLegal,
        epsymRomanExt,
        epsymISO_DenNor,
        epsymISO_UK,
        epsymISO_France,
        epsymISO_German,
        epsymISO_Italy,
        epsymISO_SwedFin,
        epsymISO_Spain,
        epsymGENERIC7,
        epsymGENERIC8,
        epsymECMA94
} SYMBOLSET;

typedef struct
        {
        SYMBOLSET symbolSet;            /* kind of translation table */
        DWORD offset;                           /* location of user-defined table */
        WORD len;                                       /* length (in bytes) of table */
        BYTE firstchar, lastchar;       /* table ranges from firstchar to lastchar */
        } TRANSTABLE;

typedef struct
        {
        WORD epSize;                            /* size of this data structure */
        WORD epVersion;                         /* number indicating version of struct */
        DWORD epMemUsage;                       /* amt of memory font takes up in printer */
        DWORD epEscape;                         /* pointer to escape that selects the font */
        TRANSTABLE xtbl;                        /* character set translation info */
        } DRIVERINFO;

/*----------------------------------------------------------------------------*/

#define POSTSCRIPT  (1)
#define PCL         (2)

/*----------------------------------------------------------------------------*/

typedef enum    { PORTRAIT, LANDSCAPE } ORIENTATION;

#define ASCII_SET   ("0U")
#define ROMAN8_SET  ("8U")
#define WINANSI_SET ("9U")
#define PI_SET      ("15U")

typedef struct
{
  ORIENTATION orientation;
  char symbolsetStr[4];
  SYMBOLSET symbolsetNum;
  SHORT style;
  SHORT strokeWeight;
  SHORT typefaceLen;
  WORD typeface;
  char *epEscapeSequence;       /* escape sequence that selects the font */
} PCLINFO;

/*--------------------------------------------------------------------------*/
#define EOS        '\0'

/*--------------------------------------------------------------------------*/

#define BUFFLEN 80
#define MANDATORY       1
#define CookedReadMode  "r"
#define FATALEXIT  (2)



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\mreader.h ===
/***
**
**   Module: MReader
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      will extract information from a T1 font metrics file, by parsing
**      the data/commands found in PFM and AFM files.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif



/***
** Function: ReadFontMetrics
**
** Description:
**  Read a font metrics file that associated to a type 1 font.
***/
errcode   ReadFontMetrics   _ARGS((IN   char *metrics,
                                   OUT  struct T1Metrics *t1m));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\mreader.c ===
/***
**
**   Module: MReader
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      will extract information from a T1 font metrics file, by parsing
**      the data/commands found in PFM and AFM files.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <string.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"

/* Module dependent types and prototypes. */
#include "pfm.h"



/***** CONSTANTS */
/*-none-*/



/***** LOCAL TYPES */
enum MType {t1_afm, t1_pfm, t1_unknown};



/***** MACROS */
/*-none-*/


/***** STATIC FUNCTIONS */

/***
** Function: MetricsType
**
** Description:
**   This function determines the type of the
**   metrics file that is associated to the 
**   main Adobe Type 1 outline file. 
***/
static enum MType MetricsType(const char *metrics)
{
   enum MType type;

   if (metrics==NULL || strlen(metrics)<5)
      type = t1_unknown;
   else if (!_strnicmp(&metrics[strlen(metrics)-3], "AFM", 3))
      type = t1_afm;
   else if (!_strnicmp(&metrics[strlen(metrics)-3], "PFM", 3))
      type = t1_pfm;
   else
      type = t1_unknown;

   return type;
}

/***** FUNCTIONS */

/***
** Function: ReadFontMetrics
**
** Description:
**  Read a font metrics file that associated to a type 1 font.
***/
errcode ReadFontMetrics(const char *metrics, struct T1Metrics *t1m)
{
   errcode status = SUCCESS;

   switch(MetricsType(metrics)) {
      case t1_pfm:
         status = ReadPFMMetrics(metrics, t1m);
         break;
      case t1_afm:
         /* status = ReadAFMMetrics(metrics, t1m); */
         break;
      case t1_unknown:
      default:
         status = BADMETRICS;
         break;
   }

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\pfb.c ===
/***
**
**   Module: PFB
**
**   Description:
**        This is a module of the T1 to TT font converter. The module
**        contains functions that manages the "printer binary file" file
**        format (Adobe Type 1 for MS-Windows).
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <ctype.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"
#include "safemem.h"

/* Module dependent types and prototypes. */
#include "fileio.h"



/***** LOCAL TYPES */
struct t1file {
   struct ioFile *file;
   enum blocktype {none=0, ascii, encoded} type;
   long size;
   long curr;
};



/***** CONSTANTS */
/*-none-*/



/***** MACROS */
#define HEXDIGIT(c)  (((c)>='a') ? ((c) - 'a' + 10) : ((c) - '0')) 
#define HEX(c1,c2)   (HEXDIGIT(c1)*16+HEXDIGIT(c2))



/***** STATIC FUNCTIONS */
/*-none-*/



/***** FUNCTIONS */

/***
** Function: PFBAllocIOBlock
**
** Description:
**   Initiate an I/O stream for a PFB font file.
***/
struct t1file *PFBAllocIOBlock(const char *name)
{
   struct t1file *pfb;

   if ((pfb=Malloc(sizeof(struct t1file)))!=NULL) {

      if ((pfb->file = io_OpenFile(name, READONLY))==NULL) {
         Free(pfb);
         pfb = NULL;
      } else {
         pfb->type = none;
         pfb->size = 0;
         pfb->curr = 0;
      }
   }

   return pfb;
}


/***
** Function: PFBFreeIOBlock
**
** Description:
**   Free an I/O stream for a PFB font file.
***/
errcode FASTCALL PFBFreeIOBlock(struct t1file *pfb)
{
   errcode status = SUCCESS;

   status = io_CloseFile(pfb->file);
   Free(pfb);

   return status;
}


/***
** Function: PFBFileError
**
** Description:
**   Check if an I/O stream is ok.
***/
boolean FASTCALL PFBFileError(const struct t1file *pfb)
{
   return io_FileError(pfb->file);
}


/***
** Function: PFBGetByte
**
** Description:
**   Pull one byte from the opened PFB font file.
**   Please note that this function does not check
**   if it succeedes it reading a byte or not. It is
**   up to the calling module to manage the  error
**   checkes by using the FileError() function when
**   appropriate.
**
***/
short FASTCALL PFBGetByte(struct t1file *pfb)
{
   short b, c1, c2;

   /* Enter a new PFB block? */
   if (pfb->curr>=pfb->size) {
      UBYTE type[2];
      UBYTE size[4];

      type[0]=(UBYTE)io_ReadOneByte(pfb->file);
      type[1]=(UBYTE)io_ReadOneByte(pfb->file);

      size[0]=(UBYTE)io_ReadOneByte(pfb->file);
      size[1]=(UBYTE)io_ReadOneByte(pfb->file);
      size[2]=(UBYTE)io_ReadOneByte(pfb->file);
      size[3]=(UBYTE)io_ReadOneByte(pfb->file);

      pfb->curr = 0;
      pfb->size = (long)MkLong(size[3], size[2], size[1], size[0]);
      pfb->type = ((type[0]==0x80 && (type[1]==0x01 ||
                                      type[1]==0x02)) ? ascii : encoded);
   }


   /* Read a byte. */
   switch (pfb->type) {
      case ascii:
         b = (short)io_ReadOneByte(pfb->file);
         pfb->curr++;
         break;
      case encoded:
         c1 = (short)tolower(io_ReadOneByte(pfb->file));
         c2 = (short)tolower(io_ReadOneByte(pfb->file));
         b = (short)HEX(c1, c2);
         pfb->curr += 2;
         break;
      case none:
      default:
         b = (short)-1;
         break;
   }

   return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\pfm.c ===
/***
**
**   Module: PFM
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      will extract information from a T1 font metrics file, by parsing
**      the data/commands found in a PFM file.
**
**      Please note that all data stored in a PFM file is represented
**      in the little-endian order.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <string.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"
#include "safemem.h"
#include "metrics.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "fileio.h"



/***** CONSTANTS */
/*-none-*/


/***** LOCAL TYPES */
/*-none-*/


/***** MACROS */
/*-none-*/


/***** STATIC FUNCTIONS */

/***
** Function: GetNextWord
**
** Description:
**   This function pulls two bytes from a file
**   and convert them into a 16-bit integer.
***/
static short GetNextWord(struct ioFile *file)
{
   short iWord;

   iWord = (short)io_ReadOneByte(file);
   iWord |= (short)(io_ReadOneByte(file) * 256);

   return(iWord);
}


/***
** Function: GetLong
**
** Description:
**   This function pulls four bytes from a file
**   and convert them into a 32-bit integer.
***/
static long GetLong(struct ioFile *file)
{
   short low;
   short high;


   low = GetNextWord(file);
   high = GetNextWord(file);

   return (long)((long)low+((long)high * 65535L));
}



/***
** Function: ReadString
**
** Description:
**   This function pulls a null terminated
**   string from the file.
***/
static void ReadString(UBYTE *dst, int size, struct ioFile *file)
{
   int i;

   i=0;
   while (io_FileError(file)==SUCCESS && i<size) {
      dst[i] = (UBYTE)io_ReadOneByte(file);
      if (dst[i]=='\0')
         break;
      i++;
   }
   if (i==size)
	   dst[i-1] = '\0';
}






/***** FUNCTIONS */

/***
** Function: ReadPFMMetrics
**
** Description:
**   This function parses a Printer Font Metrics
**   (*.pfm) file. 
***/
errcode ReadPFMMetrics(const char *metrics, struct T1Metrics *t1m)
{
   errcode status = SUCCESS;
   struct ioFile *file;
   UBYTE buf[256];
   long kernoffset;
   long widthoffset;
   long etmoffset;
   long faceoffset;
   short ver;
   short i;

   if (metrics==NULL || (file = io_OpenFile(metrics, READONLY))==NULL) {
      status = NOMETRICS;
   } else {

      (void)io_ReadOneByte(file);     /* Skip the revision number. */
      ver = (short)io_ReadOneByte(file);

      if (ver>3) {
         SetError(status=UNSUPPORTEDFORMAT);
      } else {

         (void)GetLong(file);        /* dfSize */

         /* Get Copyright */
         if (t1m->copyright)
            Free(t1m->copyright);
         if ((t1m->copyright = Malloc(60))==NULL) {
            SetError(status=NOMEM);
         } else {
            (void)io_ReadBytes((UBYTE *)t1m->copyright, (USHORT)60, file);

            (void)GetNextWord(file);                      /* dfType */
            (void)GetNextWord(file);                      /* dfPoints */
            (void)GetNextWord(file);                      /* dfVertRes */
            (void)GetNextWord(file);                      /* dfHorizRes */
            t1m->ascent = GetNextWord(file);              /* dfAscent */
            t1m->intLeading = GetNextWord(file);          /* dfInternalLeading */
            t1m->extLeading = GetNextWord(file);          /* dfExternalLeading */
            (void)io_ReadOneByte(file);               /* dfItalic */
            (void)io_ReadOneByte(file);               /* dfUnderline */
            (void)io_ReadOneByte(file);               /* dfStrikeOut */
            t1m->tmweight = (USHORT)GetNextWord(file);    /* dfWeight */
            t1m->CharSet = (UBYTE)io_ReadOneByte(file);   /* dfCharSet */
            (void)GetNextWord(file);                      /* dfPixWidth */
            (void)GetNextWord(file);                      /* dfPixHeight */
            t1m->pitchfam = (UBYTE)io_ReadOneByte(file);/* dfPitchAndFamily */
            t1m->avgCharWidth = GetNextWord(file);        /* dfAvgWidth */
            (void)GetNextWord(file);                      /* dfMaxWidth */
            t1m->firstChar = (UBYTE)io_ReadOneByte(file);   /* dfFirstChar */
            t1m->lastChar = (UBYTE)io_ReadOneByte(file);    /* dfLastChar */
            t1m->DefaultChar = (UBYTE)io_ReadOneByte(file); /* dfDefaultChar */
            t1m->BreakChar   = (UBYTE)io_ReadOneByte(file); /* dfBreakChar */
            (void)GetNextWord(file);                      /* dfWidthBytes */
            (void)GetLong(file);                      /* dfDevice */
	    faceoffset = GetLong(file);             /* dfFace */
            (void)GetLong(file);                      /* dfBitsPointer */
            (void)GetLong(file);                      /* dfBitsOffset */
            (void)GetNextWord(file);                      /* dfSizeFields */
            etmoffset = GetLong(file);                /* dfExtMetricsOffset */
            widthoffset = GetLong(file);              /* dfExtentTable */
            (void)GetLong(file);                      /* dfOriginTable */
            kernoffset = GetLong(file);               /* dfPairKernTable */
            (void)GetLong(file);                      /* dfTrackKernTable */
	    (void)GetLong(file);                      /* dfDriverInfo */
            (void)GetLong(file);                      /* dfReserved */

            if (io_FileError(file)!=SUCCESS) {
               SetError(status = BADMETRICS);
            }

            /* Get extended type metrics */
            (void)io_FileSeek(file, etmoffset);

            (void)GetNextWord(file);             /* etmSize */
            (void)GetNextWord(file);             /* etmPointSize */
            (void)GetNextWord(file);             /* etmOrientation */
            (void)GetNextWord(file);             /* etmMasterHeight */
            (void)GetNextWord(file);             /* etmMinScale */
            (void)GetNextWord(file);             /* etmMaxScale */
            (void)GetNextWord(file);             /* etmMasterUnits */
            (void)GetNextWord(file);             /* etmCapHeight */
            (void)GetNextWord(file);             /* etmXHeight */
            (void)GetNextWord(file);             /* etmLowerCaseAscent */
            t1m->descent = GetNextWord(file);    /* etmLowerCaseDecent */
            (void)GetNextWord(file);             /* etmSlant */
            t1m->superoff = GetNextWord(file);   /* etmSuperScript */
            t1m->suboff = GetNextWord(file);     /* etmSubScript */
            t1m->supersize = GetNextWord(file);  /* etmSuperScriptSize */
            t1m->subsize = GetNextWord(file);    /* etmSubScriptSize */
            (void)GetNextWord(file);             /* etmUnderlineOffset */
            (void)GetNextWord(file);             /* etmUnderlineWidth */
            (void)GetNextWord(file);             /* etmDoubleUpperUnderlineOffset*/
            (void)GetNextWord(file);             /* etmDoubleLowerUnderlineOffset*/
            (void)GetNextWord(file);             /* etmDoubleUpperUnderlineWidth */
            (void)GetNextWord(file);             /* etmDoubleLowerUnderlineWidth */
            t1m->strikeoff = GetNextWord(file);  /* etmStrikeOutOffset */
            t1m->strikesize = GetNextWord(file); /* etmStrikeOutWidth */
            (void)GetNextWord(file);             /* etmNKernPairs */
            (void)GetNextWord(file);             /* etmNKernTracks */

            /* Get the advance width for the characters. */
            if ((t1m->widths = Malloc(sizeof(funit)*
                                      (t1m->lastChar -
                                       t1m->firstChar + 1)))==NULL) {
               SetError(status=NOMEM);
            } else {
               (void)io_FileSeek(file, widthoffset);
               for (i=0; i<=t1m->lastChar-t1m->firstChar; i++)
                  t1m->widths[i] = GetNextWord(file);

               if (io_FileError(file)!=SUCCESS) {
                  SetError(status = BADMETRICS);
               }
            }

            /* Get the face name. */
            if ((status==SUCCESS) && faceoffset) {
               (void)io_FileSeek(file, faceoffset);
               if (t1m->family)
                  Free(t1m->family);
               ReadString(buf, sizeof(buf), file);
               if (io_FileError(file)) {
                  SetError(status = BADMETRICS);
               } else {
                  if ((t1m->family = Strdup((char*)buf))==NULL) {
                     SetError(status=NOMEM);
                  }
               }
            }

            /* Get the pair-kerning the typeface. */
            if ((status==SUCCESS) && kernoffset) {
               (void)io_FileSeek(file, kernoffset);
               t1m->kernsize = (USHORT)GetNextWord(file);
               if (io_FileError(file)!=SUCCESS) {
                  SetError(status = BADMETRICS);
               } else {
                  if ((t1m->kerns = Malloc(sizeof(struct kerning)*
                                            t1m->kernsize))==NULL) {
                     SetError(status=NOMEM);
                  } else {
                     for (i=0; i<(int)t1m->kernsize; i++) {
                        t1m->kerns[i].left = (UBYTE)io_ReadOneByte(file);
                        t1m->kerns[i].right = (UBYTE)io_ReadOneByte(file);
                        t1m->kerns[i].delta = GetNextWord(file);
                     }

                     if (io_FileError(file)!=SUCCESS) {
                        SetError(status = BADMETRICS);
                     }
                  }
               }
            }
         }
      }

      if (io_CloseFile(file)!=SUCCESS)
         status = BADMETRICS;
   }

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\safemem.h ===
/* Prototypes for "safe" (but slow) malloc/free routines to be used
 * in development of Large model Windows applications.
 *
 * lenoxb  5/28/93
 */

#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif



/***********
 ** Debug version of memory management functions.
 **
 */

#if TRACEMEM

void* SafeMalloc        _ARGS((INOUT   size_t,
                               INOUT   char *,
                               INOUT   short));
void* SafeReAlloc       _ARGS((INOUT   void*,
                               INOUT   size_t,
                               INOUT   char *,
                               INOUT   short));
void  SafeFree          _ARGS((INOUT   void*));
void  SafeListMemLeak   _ARGS((INOUT   void));
char* SafeStrdup        _ARGS((IN      char*,
                               INOUT   char *,
                               INOUT   short));

#define Malloc(size)          SafeMalloc(size, __FILE__, __LINE__)
#define Realloc(ptr, size)    SafeReAlloc(ptr, size, __FILE__, __LINE__)
#define Free(ptr)             SafeFree(ptr)
#define Strdup(ptr)           SafeStrdup(ptr, __FILE__, __LINE__)
#define ListMemLeak           SafeListMemLeak




#else
/***********
 ** Run-time version of memory management functions.
 **
 */


/*#include <stddef.h>*/
#include <stdlib.h>

#define Malloc(size)       malloc(size)
#define Realloc(ptr,size)  realloc(ptr, (size_t)(size))
#define Free               free
#define Strdup             _strdup
#define ListMemLeak()      ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\pfm.h ===
/***
**
**   Module: PFM
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      will extract information from a T1 font metrics file, by parsing
**      the data/commands found in a PFM file.
**
**      Please note the all data stored in a PFM file is represented
**      in the little-endian order.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

struct T1Metrics;


/***
** Function: ReadPFMMetrics
**
** Description:
**   This function parses a Printer Font Metrics
**   (*.pfm) file. 
***/
errcode  ReadPFMMetrics    _ARGS((IN      char *metrics,
                                  OUT     struct T1Metrics *t1m));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\pfb.h ===
/***
**
**   Module: PFB
**
**   Description:
**        This is a module of the T1 to TT font converter. The module
**        contains functions that manages the "printer binary file" file
**        format (Adobe Type 1 for MS-Windows).
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif
#ifndef FASTCALL
#  ifdef MSDOS
#     define FASTCALL   __fastcall
#  else
#     define FASCALL
#  endif
#endif

struct t1file;

/***
** Function: PFBAllocIOBlock
**
** Description:
**   Initiate an I/O stream for a PFB font file.
***/
struct t1file     *PFBAllocIOBlock  _ARGS((IN      char *name));


/***
** Function: PFBFreeIOBlock
**
** Description:
**   Free an I/O stream for a PFB font file.
***/
errcode FASTCALL  PFBFreeIOBlock    _ARGS((INOUT   struct t1file *io));


/***
** Function: PFBFileError
**
** Description:
**   Check if an I/O stream is ok.
***/
boolean FASTCALL  PFBFileError      _ARGS((IN      struct t1file *io));

/***
** Function: PFBGetByte
**
** Description:
**   Pull one byte from the opened PFB font file.
**   Please note that this function does not check
**   if it succeedes it reading a byte or not. It is
**   up to the calling module to manage the  error
**   checkes by using the FileError() function when
**   appropriate.
**
***/
short FASTCALL    PFBGetByte        _ARGS((INOUT   struct t1file *io));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\t1instal.h ===
#if defined(__cplusplus)
extern "C" {
#endif

#include "fvscodes.h"  // FVS_xxxxxx (font validation status) codes and macros.

#define MAXERRORS          -14
#define NOCOPYRIGHT        -13
#define ARGSTACK           -12
#define TTSTACK            -11
#define NOMETRICS          -10
#define UNSUPPORTEDFORMAT  -9
#define BADMETRICS         -8
#define BADT1HYBRID        -7
#define BADCHARSTRING      -6
#define BADINPUTFILE       -5
#define BADOUTPUTFILE      -4
#define BADT1HEADER        -3
#define NOMEM              -2
#define FAILURE            -1
#define SUCCESS            0
#define DONE               1
#define SKIP               2

#define MAYBE              2

#ifdef _MSC_VER
#define STDCALL  __stdcall
#else
#define STDCALL
#endif

#ifndef UNICODE
#  define ConvertTypeface  ConvertTypefaceA
#  define IsType1          IsType1A
#endif

short STDCALL ConvertTypefaceA   (char *szPfb,
                                  char *szPfm,
                                  char *szTtf,
                                  void (STDCALL *Proc)(short,void*),
                                  void *arg);

BOOL STDCALL CheckType1A (char *pszKeyFile,
                           DWORD cjDesc,
                           char *pszDesc,
                           DWORD cjPFM,
                           char *pszPFM,
                           DWORD cjPFB,
                           char *pszPFB,
                           BOOL *pbCreatedPFM,
                           char *pszFontPath
                           );

short STDCALL CheckCopyrightA    (char *szPFB,
                                  DWORD wSize,
                                  char *szVendor);


//
// Function CheckType1WithStatusA performs the same operation as
// CheckType1A except that it returns an encoded status value
// rather than merely TRUE/FALSE.  See fvscodes.h for a description
// of the "Font Validation Status" encodings.
// Since the original CheckType1A interface is exported from T1INSTAL.DLL
// by name, it was left unchanged so that existing applications that
// might use it don't break.
//
short STDCALL CheckType1WithStatusA (char *pszKeyFile,
                                     DWORD cjDesc,
                                     char *pszDesc,
                                     DWORD cjPFM,
                                     char *pszPFM,
                                     DWORD cjPFB,
                                     char *pszPFB,
                                     BOOL *pbCreatedPFM,
                                     char *pszFontPath
                                     );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\t1instal.c ===
/***
 **
 **   Module: T1Instal
 **
 **   Description:
 **      This is the Win32 DLL (t1instal.dll) interface to the
 **      font converter. All window specific code is located in
 **      this module and the error hadler module (errors.c).
 **
 **   Author: Michael Jansson
 **   Created: 12/18/93
 **
 ***/

/***** INCLUDES */

#include "windows.h"

#include <string.h>
#include <time.h>
#include <limits.h>
#include <ctype.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#undef IN

#include "titott.h"
#include "types.h"
#include "t1local.h"
#include "t1instal.h"
#include "fileio.h"
#include "safemem.h"
#include "t1msg.h"

#undef UNICODE


/* The CopyrightCheck/MAYBEOK case always succeeds for now. */
#define MAYBEOK   SUCCESS


/***** LOCAL TYPES */
struct callFrame {
   const void (STDCALL *Progress)(short, void*);
   void *arg;
   int last;
   int done;
};


static short lastCP = FALSE;
static char lastVendor[256] = "Unknown.";

/***** CONSTANTS */
#define MIN_PROGRESS    3
#define DELIMITERS      " ,"
#define COPYSIGN        169
#define TRUE            1
#define FALSE           0
#define DFFACE          139
#define DFDRIVERINFO    101

#define VERSTR "Converter: Windows Type 1 Installer V1.0d.\n" \
               "Font: V"

const char version[] = "\n$VER: 1.0d\n";

#ifndef NOANSIWINMAC
const char *winmac[] = {
   "A",
   "AE",
   "Aacute",
   "Acircumflex",
   "Adieresis",
   "Agrave",
   "Aring",
   "Atilde",
   "B",
   "C",
   "Cacute",
   "Ccaron",
   "Ccedilla",
   "D",
   "Delta",
   "E",
   "Eacute",
   "Ecircumflex",
   "Edieresis",
   "Egrave",
   "Eth",
   "F",
   "G",
   "Gbreve",
   "H",
   "I",
   "Iacute",
   "Icircumflex",
   "Idieresis",
   "Idot",
   "Igrave",
   "J",
   "K",
   "L",
   "Lslash",
   "M",
   "N",
   "Ntilde",
   "O",
   "OE",
   "Oacute",
   "Ocircumflex",
   "Odieresis",
   "Ograve",
   "Oslash",
   "Otilde",
   "P",
   "Q",
   "R",
   "S",
   "Scaron",
   "Scedilla",
   "T",
   "Thorn",
   "U",
   "Uacute",
   "Ucircumflex",
   "Udieresis",
   "Ugrave",
   "V",
   "W",
   "X",
   "Y",
   "Yacute",
   "Ydieresis",
   "Z",
   "a",
   "aacute",
   "acircumflex",
   "acute",
   "adieresis",
   "ae",
   "agrave",
   "ampersand",
   "approxequal",
   "aring",
   "asciicircum",
   "asciitilde",
   "asterisk",
   "at",
   "atilde",
   "b",
   "backslash",
   "bar",
   "braceleft",
   "braceright",
   "bracketleft",
   "bracketright",
   "breve",
   "brokenbar",
   "bullet",
   "c",
   "cacute",
   "caron",
   "ccaron",
   "ccedilla",
   "cedilla",
   "cent",
   "circumflex",
   "colon",
   "comma",
   "copyright",
   "currency",
   "d",
   "dagger",
   "daggerdbl",
   "degree",
   "dieresis",
   "divide",
   "dmacron",
   "dollar",
   "dotaccent",
   "dotlessi",
   "e",
   "eacute",
   "ecircumflex",
   "edieresis",
   "egrave",
   "eight",
   "ellipsis",
   "emdash",
   "endash",
   "equal",
   "eth",
   "exclam",
   "exclamdown",
   "f",
   "fi",
   "five",
   "fl",
   "florin",
   "four",
   "fraction",
   "franc",
   "g",
   "gbreve",
   "germandbls",
   "grave",
   "greater",
   "greaterequal",
   "guillemotleft",
   "guillemotright",
   "guilsinglleft",
   "guilsinglright",
   "h",
   "hungerumlaut",
   "hyphen",
   "i",
   "iacute",
   "icircumflex",
   "idieresis",
   "igrave",
   "infinity",
   "integral",
   "j",
   "k",
   "l",
   "less",
   "lessequal",
   "logicalnot",
   "lozenge",
   "lslash",
   "m",
   "macron",
   "middot",
   "minus",
   "mu",
   "multiply",
   "n",
   "nbspace",
   "nine",
   "notequal",
   "ntilde",
   "numbersign",
   "o",
   "oacute",
   "ocircumflex",
   "odieresis",
   "oe",
   "ogonek",
   "ograve",
   "ohm",
   "one",
   "onehalf",
   "onequarter",
   "onesuperior",
   "ordfeminine",
   "ordmasculine",
   "oslash",
   "otilde",
   "overscore",
   "p",
   "paragraph",
   "parenleft",
   "parenright",
   "partialdiff",
   "percent",
   "period",
   "periodcentered",
   "perthousand",
   "pi",
   "plus",
   "plusminus",
   "product",
   "q",
   "question",
   "questiondown",
   "quotedbl",
   "quotedblbase",
   "quotedblleft",
   "quotedblright",
   "quoteleft",
   "quoteright",
   "quotesinglbase",
   "quotesingle",
   "r",
   "radical",
   "registered",
   "ring",
   "s",
   "scaron",
   "scedilla",
   "section",
   "semicolon",
   "seven",
   "sfthyphen",
   "six",
   "slash",
   "space",
   "sterling",
   "summation",
   "t",
   "thorn",
   "three",
   "threequarters",
   "threesuperior",
   "tilde",
   "trademark",
   "two",
   "twosuperior",
   "u",
   "uacute",
   "ucircumflex",
   "udieresis",
   "ugrave",
   "underscore",
   "v",
   "w",
   "x",
   "y",
   "yacute",
   "ydieresis",
   "yen",
   "z",
   "zero"
};

#define GLYPHFILTER  &win
const struct GlyphFilter win = {
   sizeof(winmac) / sizeof(winmac[0]),
   winmac
};

#else
#define GLYPHFILTER (struct GlyphFilter *)0
#endif /* NOANSIWINMAC */


/***** MACROS */

#define ReadLittleEndianDword(file,dw)  {          \
        dw  = (DWORD)io_ReadOneByte(file) ;        \
        dw |= (DWORD)io_ReadOneByte(file) << 8;    \
        dw |= (DWORD)io_ReadOneByte(file) << 16;   \
        dw |= (DWORD)io_ReadOneByte(file) << 24;   \
        }
				
#ifndef try
#define try __try
#define except __except
#endif


/***** GLOBALS */
HMODULE ModuleInstance(
    void
    )
{
    static HMODULE hInst = NULL;
    if (NULL == hInst)
        hInst = GetModuleHandle(TEXT("fontext.dll"));
    return hInst;
}


/***** STATIC FUNCTIONS */


/***
** Function: Decrypt
**
** Description:
**   Decrypt a byte.
***/
static DWORD CSum(char *str)
{
   DWORD sum = 0;

   while (*str)
      sum += *str++;

   return sum;
}


/***
** Function: Decrypt
**
** Description:
**   Decrypt a byte.
***/
static char *Encrypt(char *str, char *out, unsigned long cbOut)
{
   const USHORT c1 = 52845;
   const USHORT c2 = 22719;
   UBYTE cipher;
   USHORT r = 8366;
   int i;
   
   for (i=0; i<(int)strlen(str) && i<(int)cbOut; i++) {
      cipher = (UBYTE)(str[i] ^ (r>>8));
      r = (USHORT)((cipher + r) * c1 + c2);
      out[i] = (char)((cipher & 0x3f) + ' ');

      /* Unmap 'bad' characters, that the Registry DB doesn't like. */
      if (out[i]=='=' || out[i]==' ' || out[i]=='@' || out[i]=='"')
         out[i] = 'M';
   }
   out[i] = '\0';

   return out;
}


static char *stristr(char *src, char *word)
{
	size_t len = strlen(word);
	char *tmp = src;

	while (*src) {
		if (!_strnicmp(src, word, len))
			break;
		src++;
	}

	return src;
}


/***
 ** Function: GetCompany
 **
 ** Description:
 **   Extract the company name out of a copyright string.
 ***/
char *GetCompany(char *buf)
{
   char *company = NULL;
   int done = FALSE;
   UBYTE *token;
   UBYTE *tmp1;
   UBYTE *tmp2;
   UBYTE *tmp3;
   UBYTE *tmp4;
   int i;

   token = buf;

   while (token && !done) {

	   /* Locate the start of the copyright string. */
	   tmp1 = stristr(token, "copyright");
	   tmp2 = stristr(token, "(c)");
	   tmp3 = stristr(token, " c ");
	   if ((tmp4 = strchr(token, COPYSIGN))==NULL)
		   tmp4 = &token[strlen(token)];
	   if (*tmp1==0 && *tmp2==0 && *tmp3==0 && *tmp4==0) {
		   token = NULL;
		   break;
	   } else if (tmp1<tmp2 && tmp1<tmp3 && tmp1<tmp4)
		   token = tmp1;
	   else if (tmp2<tmp3 && tmp2<tmp4)
		   token = tmp2;
	   else if (tmp3<tmp4)
		   token = tmp3;
	   else
		   token = tmp4;

      /* Skip the leading copyright strings/character. */
      if (token[0]==COPYSIGN && token[1]!='\0') {
         token += 2;
      } else if (!_strnicmp(token, "copyright", strlen("copyright"))) {
		  token += strlen("copyright");
	  } else {
		  token += strlen("(c)");
	  }

	  /* Skip blanks. */
	  while(*token && isspace(*token) || *token==',')
		  token++;

	  /* Another copyright word? */
	  if (!_strnicmp((char*)token, "(c)", strlen("(c)")) ||
		  !_strnicmp((char*)token, "copyright", strlen("copyright")) ||
		  token[0]==COPYSIGN)
		  continue;

      /* Skip the years. */
	  company = token;
      if (isdigit(token[0])) {
         while (isdigit(*company) || isspace(*company) ||
				ispunct(*company) || (*company)=='-')
            company++;

         if (*company=='\0')
            break;

         /* Skip strings like "by", up to the beginning of a name that */
         /* starts with an upper case letter. */         
         while (*company && (company[0]<'A' || company[0]>'Z'))
            company++;

         done = TRUE;
      } else {
         continue;
      }
   } 


   /* Did we find it? */
   if (company) {
      while (*company && isspace(*company))
         company++; 


      if (*company=='\0') {
         company=NULL;
      } else {

         /* Terminate the company name. */
         if ((token = (UBYTE*)strchr(company, '.'))!=NULL) {

            /* Period as an initial delimiter, e.g. James, A. B. ?*/
            if (token[-1]>='A' && token[-1]<='Z') {
               if (strchr((char*)&token[1], '.'))
                  token = (UBYTE*)strchr((char*)&token[1], '.');

               /* Check for "James A. Bently, " */
               else if (strchr((char*)&token[1], ',')) {
                  token = (UBYTE*)strchr((char*)&token[1], ',');
                  token[0] = '.';
               }
            }
			token[1] = '\0';
         } else {
			 /* Name ending with a ';'? */
			 if ((token = (UBYTE*)strrchr(company, ';'))) {
				 *token = '\0';
			 }
		 }

		 /* Truncate some common strings. */
		 tmp1 = stristr(company, "all rights reserved");
		 *tmp1 = '\0';

		 /* Remove trailing punctuation character. */
		 for (i=(int)strlen(company)-1; i>0 &&
				(ispunct(company[i]) || isspace(company[i])); i--) {
			 company[i] = 0;
		 }
      }
   }      
              

   return company;
}




/**** FUNCTIONS */

/***
 ** Function: ConvertAnyway
 **
 ** Description:
 **   Ask the user if it is ok to convert. 
 ***/
static errcode ConvertAnyway(const char *vendor, const char *facename)
{
   char tmp[256];
   char msg[1024];
   errcode answer;
   HMODULE hInst = ModuleInstance();

   if (vendor==NULL || strlen(vendor)==0) {
      LoadString(hInst, IDS_RECOGNIZE1, tmp, sizeof(tmp));
      StringCchPrintfA(msg, sizeof(msg), tmp, facename);
   } else {
      LoadString(hInst, IDS_RECOGNIZE2, tmp, sizeof(tmp));
      StringCchPrintfA(msg, sizeof(msg), tmp, facename, vendor);
   }      
   LoadString(hInst, IDS_MAINMSG, tmp, sizeof(tmp));
   StringCchCatA(msg, sizeof(msg), tmp);
   LoadString(hInst, IDS_CAPTION, tmp, sizeof(tmp));
   answer = (errcode)MessageBox(NULL, msg, tmp, QUERY);
   SetLastError(0);

   return answer;
}



/***
 ** Function: CheckCopyright
 **
 ** Description:
 **   This is the callback function that verifies that
 **   the converted font is copyrighted by a company who
 **   has agreed to having their fonts converted by
 **   this software. These companies are registered in the
 **   registry data base.
 ***/


static errcode CheckCopyright(const char *facename,
                              const char *copyright,
                              const char *notice)
{
#ifdef NOCOPYRIGHTS
   return SKIP;
#else
   HKEY key;
   char tmp[256];
   char *company = NULL;
   char buf[1024];
   int done = FALSE;
   short result = FAILURE;
   

   /* Access the REG data base. */
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SUBKEY_TYPE1COPYRIGHTS, 0,
                    KEY_QUERY_VALUE, &key)==ERROR_SUCCESS) { 


      /* Look for the company name in the /notice string. */
      if (notice && notice[0]) {
         strncpy(buf, notice, sizeof(buf));
		 buf[sizeof(buf)-1] = '\0';
         company = GetCompany(buf);
      }

      /* Look in the /copyright string if the company name was not found. */
      if (company==NULL && copyright && copyright[0]) {
         strncpy(buf, copyright, sizeof(buf));
		 buf[sizeof(buf)-1] = '\0';
         company = GetCompany(buf);
      }


#ifdef SHOWCOPYRIGHTS
      LogError(MSG_INFO, MSG_Copyright, company);
      Encrypt(company, tmp, sizeof(tmp)-1);
      sprintf(&tmp[strlen(tmp)], "(%d)\n", CSum(tmp));
      LogError(MSG_INFO, MSG_Encoding, tmp);
#else

      /* Did not find a company name? */
      if (company==NULL &&
          ((notice==NULL || notice[0]=='\0'||
            strstr(notice, "Copyright")==NULL) &&
           (copyright==NULL || copyright[0]=='\0' ||
            strstr(copyright, "Copyright")==NULL))) {

         /* No known copyright. */
         LogError(MSG_WARNING, MSG_NOCOPYRIGHT, NULL);
         result = MAYBEOK;

      /* Strange copyright format? */
      } else if (company==NULL || company[0]=='\0') {
         if (notice && notice[0])
            LogError(MSG_WARNING, MSG_BADFORMAT, notice);
         else
            LogError(MSG_WARNING, MSG_BADFORMAT, copyright);

         result = MAYBEOK;

      /* Found copyright! */
      } else {
         DWORD size;
         DWORD csum;

         size = 4;
         if (RegQueryValueEx(key, Encrypt(company, tmp, sizeof(tmp)-1), NULL, NULL,
                             (LPBYTE)&csum, &size)==ERROR_SUCCESS) {
            
            /* A positive match -> ok to convert. */
            if (CSum(tmp)==csum) {
               LogError(MSG_INFO, MSG_COPYRIGHT, company);
               result = SUCCESS;
            } else {
               LogError(MSG_ERROR, MSG_BADCOPYRIGHT, company);
               result = SKIP;
            }
         } else {
            LogError(MSG_WARNING, MSG_BADCOPYRIGHT, company);
            result = MAYBEOK;
         }
      }               
#endif

      RegCloseKey(key);

      /* Give the user the final word. */
      if (result==FAILURE) {
         if (ConvertAnyway(company, facename)==TRUE)
            result = SUCCESS;
      }


   /* No copyright key in the registry? */
   } else {
      LogError(MSG_ERROR, MSG_NODB, NULL);
      result = FAILURE;
   }   


   return result;
#endif
}



/***
 ** Function: NTCheckCopyright
 **
 ** Description:
 **   This is the callback function that verifies that
 **   the converted font is copyrighted by a company who
 **   has agreed to having their fonts converted by
 **   this software. These companies are registered in the
 **   registry data base.
 ***/
static errcode NTCheckCopyright(const char *facename,
                                const char *copyright,
                                const char *notice)
{
   HKEY key;
   char tmp[256];
   char *company = NULL;
   char buf[1024];
   int done = FALSE;
   short result = FAILURE;
   

   /* Access the REG data base. */
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SUBKEY_TYPE1COPYRIGHTS, 0,
                    KEY_QUERY_VALUE, &key)==ERROR_SUCCESS) { 


      /* Look for the company name in the /notice string. */
      if (notice && notice[0]) {
         strncpy(buf, notice, sizeof(buf));
		 buf[sizeof(buf)-1] = '\0';
         company = GetCompany(buf);
      }

      /* Look in the /copyright string if the company name was not found. */
      if (company==NULL && copyright && copyright[0]) {
         strncpy(buf, copyright, sizeof(buf));
		 buf[sizeof(buf)-1] = '\0';
         company = GetCompany(buf);
      }

      /* Did not find a company name? */
      if (company==NULL &&
          ((notice==NULL || notice[0]=='\0'||
            strstr(notice, "Copyright")==NULL) &&
           (copyright==NULL || copyright[0]=='\0' ||
            strstr(copyright, "Copyright")==NULL))) {

         /* No known copyright. */
         result = MAYBE;

      /* Strange copyright format? */
      } else if (company==NULL || company[0]=='\0') {
         result = MAYBE;

      /* Found copyright! */
      } else {
         DWORD size;
         DWORD csum;

         /* remember for future use. */
         strncpy(lastVendor, company, 256);
         lastVendor[MIN(255, strlen(company))] = '\0';

         size = 4;
         if (RegQueryValueEx(key, Encrypt(company, tmp, sizeof(tmp)-1), NULL, NULL,
                             (LPBYTE)&csum, &size)==ERROR_SUCCESS) {
            
            /* A positive match -> ok to convert. */
            if (CSum(tmp)==csum) {
               result = SUCCESS;
            } else {
               result = FAILURE;
            }
         } else {
            result = MAYBE;
         }
      }               

      RegCloseKey(key);


   /* No copyright key in the registry? */
   } else {
      result = FAILURE;
   }   


   lastCP = result;

   return FAILURE;
}


/***
 ** Function: _Progress
 **
 ** Description:
 **   This is the internal progress callback function that 
 **   computes an percentage-done number, based on the
 **   number of converted glyphs.
 ***/
static void _Progress(short type, void *generic, void *arg)
{
   struct callFrame *f = arg;

   /* Processing glyphs or wrapping up? */
   if (type==0 || type==1) 
      f->done++;
   else
      f->done = MIN(sizeof(winmac)/sizeof(winmac[0]), f->done+10);
   
   if ((f->done-f->last)>MIN_PROGRESS) {
      f->Progress((short)(f->done*100/(sizeof(winmac)/sizeof(winmac[0]))),
                  f->arg);
      f->last = f->done;
   }
   
   UNREFERENCED_PARAMETER(type);
   UNREFERENCED_PARAMETER(generic);
   SetLastError(0L);
}
            
static BOOL ReadStringFromOffset(struct ioFile *file,
                                 const DWORD dwOffset, 
                                 char *pszString,
                                 int cLen,
                                 BOOL bStrip)
{
    BOOL result = TRUE;
    DWORD offset;

    /* Get offset to string. */
    io_FileSeek(file, dwOffset);

    /* Read the offset. */

    ReadLittleEndianDword(file, offset);

    /*  Get the string. */
    (void)io_FileSeek(file, offset);
    if (io_FileError(file) != SUCCESS) {
        result = FALSE;
    } else {
        int i;

        i=0;
        while (io_FileError(file)==SUCCESS && i<cLen) {
            pszString[i] = (UBYTE)io_ReadOneByte(file);
            if (pszString[i]=='\0')
                break;

            /* Replace all dashes with spaces. */
            if (bStrip && pszString[i]=='-')
                pszString[i]=' ';
            i++;
        }
		/* If it was truncated, we need to NULL terminate it */
		if (i==cLen && cLen>0)
			pszString[cLen-1] = '\0';
    }

    return result;
}
                                 



/**** FUNCTIONS */

/***
 ** Function: ConvertTypeFaceA
 **
 ** Description:
 **   Convert a T1 font into a TT font file. This is the
 **   simplified interface used by the Win32 DLL, with the
 **   ANSI interface.
 ***/
short STDCALL ConvertTypefaceAInternal(const char *type1,
                               const char *metrics,
                               const char *truetype,
                               const void (STDCALL *Progress)(short, void*),
                               void *arg)
{                        
   struct callFrame f;
   struct callProgress p;
   struct T1Arg t1Arg;
   struct TTArg ttArg;
   short status;


   /* Check parameters. */
   if (type1==NULL || metrics==NULL)
      return FAILURE;

   /* Set up arguments to ConvertTypefaceA() */
   t1Arg.filter = GLYPHFILTER;
   t1Arg.upem = (short)2048;
   t1Arg.name = (char *)type1;
   t1Arg.metrics = (char *)metrics;
   ttArg.precision = (short)50;
   ttArg.name = (char *)truetype;
   ttArg.tag = VERSTR;

   /* Use progress gauge */
   if (Progress) {
      LogError(MSG_INFO, MSG_STARTING, type1);

      f.Progress = Progress;
      f.done = 0;
      f.last = 0;
      f.arg = arg;
      p.arg = &f;
      p.cb = _Progress;
      status = ConvertT1toTT(&ttArg, &t1Arg, CheckCopyright, &p);
      Progress(100, arg);
   } else {
      status = ConvertT1toTT(&ttArg, &t1Arg, CheckCopyright, NULL);
   }

   
   return status;
}



short STDCALL ConvertTypefaceA(char *type1,
                               char *metrics,
                               char *truetype,
                               void (STDCALL *Progress)(short, void*),
                               void *arg)
{

    short bRet;

    try
    {
        bRet = ConvertTypefaceAInternal(type1,
                                        metrics,
                                        truetype,
                                        Progress,
                                        arg);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
    #if 0
        ASSERTGDI(
            GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR,
            "ttfd!ttfdSemLoadFontFile, strange exception code\n"
            );
    #endif

        bRet = BADINPUTFILE;

    }

    return bRet;
}


short STDCALL FindPfb (
    char *pszPFM,
    char *achPFB,
	DWORD cbPFB
);


/***
** Function: CheckPfmA
**
** Description:
**   This function determines if there is a pfm/pfb pair of
**   files that makes up an Adobe Type 1 font, and determins
**   the descriptive face name of it.
**
** Returns: 16-bit encoded value indicating error and type of file where
**          error occurred.  (see fvscodes.h) for definitions.
**          The following table lists the "status" portion of the codes
**          returned.
**
**           FVS_SUCCESS           
**           FVS_INVALID_FONTFILE  
**           FVS_FILE_OPEN_ERR   
**           FVS_INVALID_ARG
**           FVS_FILE_IO_ERR
**           FVS_BAD_VERSION
***/

short STDCALL CheckPfmA(
    char  *pszPFM,
    DWORD  cjDesc,
    char  *pszDesc,
    DWORD  cjPFB,
    char  *pszPFB
)
{
   struct ioFile *file;
   char szDriver[MAX_PATH];
   short result = FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);
   short ver;

   char achPFB[MAX_PATH];

   char  *psz_PFB;
   DWORD  cjPFB1;

   if (pszPFB)
   {
       psz_PFB = pszPFB;
       cjPFB1 = cjPFB;
   }
   else
   {
       psz_PFB = (char *)achPFB;
       cjPFB1 = MAX_PATH;
   }

   /* Check parameter. */
   if (pszPFM==NULL || ((strlen(pszPFM)+3) >= cjPFB1))
      return FVS_MAKE_CODE(FVS_INVALID_ARG, FVS_FILE_UNK);

   // check if pfb file exists and find the path to it:

    result = FindPfb(pszPFM, psz_PFB, cjPFB1);
    if (FVS_STATUS(result) != FVS_SUCCESS)
        return result;

   /****
    * Locate the pszDescriptive name of the font.
    */

   if ((file = io_OpenFile(pszPFM, READONLY))==NULL)
      return FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_PFM);

   (void)io_ReadOneByte(file);     /* Skip the revision number. */
   ver = (short)io_ReadOneByte(file);

   if (ver > 3) {
      /*  ERROR - unsupported format */
      result = FVS_MAKE_CODE(FVS_BAD_VERSION, FVS_FILE_PFM);
   } else {

      /* Read the driver name. */
      if (!ReadStringFromOffset(file, DFDRIVERINFO, szDriver, 
                                    sizeof(szDriver), FALSE))
      {
          result = FVS_MAKE_CODE(FVS_FILE_IO_ERR, FVS_FILE_PFM);
      }
      /* Is it "PostScript" ? */
      else if (_stricmp(szDriver, "PostScript"))
      {
          result = FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_PFM);
      }
      /* Only get description if asked to do so. */
      else if (pszDesc && !ReadStringFromOffset(file, DFFACE, pszDesc, cjDesc, TRUE))
      {
          result = FVS_MAKE_CODE(FVS_FILE_IO_ERR, FVS_FILE_PFM);
      }
   }

   (void)io_CloseFile(file);

   return result;
}



/***
** Function: CheckCopyrightsA
**
** Description:
**   This function verifies that it is ok to convert the font. This is
**   done by faking an installation.
***/
short STDCALL CheckCopyrightAInternal(char *szPFB,
                              DWORD wSize,
                              char *szVendor)
{
   struct T1Arg t1Arg;
   struct TTArg ttArg;
   
   /* Set up arguments to ConvertTypefaceA() */
   t1Arg.metrics = NULL;
   t1Arg.upem = (short)2048;
   t1Arg.filter = GLYPHFILTER;
   t1Arg.name = szPFB;
   ttArg.precision = (short)200;
   ttArg.tag = NULL;
   ttArg.name = "NIL:";
   lastCP = FAILURE;
   strcpy(lastVendor, "");
   (void)ConvertT1toTT(&ttArg, &t1Arg, NTCheckCopyright, NULL);
   if (szVendor && wSize)
   {
	   strncpy(szVendor, lastVendor, wSize);
	   szVendor[MIN(wSize-1, strlen(lastVendor))] = '\0';
   }
   return lastCP;
}


short STDCALL CheckCopyrightA(char *szPFB,
                              DWORD wSize,
                              char *szVendor)
{
    short iRet;

    try
    {
        iRet = CheckCopyrightAInternal(szPFB,wSize,szVendor);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        iRet = BADINPUTFILE;
    }
    return iRet;

}






/******************************Public*Routine******************************\
*
* short STDCALL CheckInfA (
*
* If pfm and inf files are in the same directory only pfm is recognized
* and inf file is ignored.
*
* History:
*  27-Apr-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
* Returns: 16-bit encoded value indicating error and type of file where
*          error occurred.  (see fvscodes.h) for definitions.
*          The following table lists the "status" portion of the codes
*          returned.
*
*           FVS_SUCCESS           
*           FVS_INVALID_FONTFILE  
*           FVS_FILE_OPEN_ERR   
*           FVS_FILE_BUILD_ERR  
*           FVS_FILE_EXISTS
*           FVS_INSUFFICIENT_BUF
*
\**************************************************************************/


short CreatePFM(char *pszINF, char *pszAFM, char *pszPFM);
BOOL bGetDescFromInf(char * pszINF, DWORD cjDesc, char *pszDesc);

BOOL bFileExists(char *pszFile)
{
    HFILE hf;

    if ((hf = _lopen(pszFile, OF_READ)) != -1)
    {
        _lclose(hf);
        return TRUE;
    }

    return FALSE;
}

short STDCALL CheckInfA (
    char *pszINF,
    DWORD cjDesc,
    char *pszDesc,
    DWORD cjPFM,
    char *pszPFM,
    DWORD cjPFB,
    char *pszPFB,
    BOOL *pbCreatedPFM,
    char *pszFontPath
)
{
    char achPFM[MAX_PATH];
    char achPFB[MAX_PATH];
    char achAFM[MAX_PATH];

    DWORD  cjKey;
    char *pszParent = NULL; // points to the where parent dir of the inf file is
    char *pszBare = NULL; // "bare" .inf name, initialization essential
    short result = FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);
    BOOL bAfmExists = FALSE;
    BOOL bPfbExists = FALSE;

    //
    // This is a real hack use of pbCreatedPFM.
    // It's the best solution with the time we have.
    //
    BOOL bCheckForExistingPFM = *pbCreatedPFM;

    *pbCreatedPFM = FALSE;

// example:
// if pszINF -> "c:\psfonts\fontinfo\foo_____.inf"
// then pszParent -> "fontinfo\foo_____.inf"

    cjKey = (DWORD)strlen(pszINF) + 1;

    if (cjKey < 5)          // 5 = strlen(".pfm") + 1;
        return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_INF);

	// Need to check that it is not too long.
	// Below we do a "strcpy(achAFM, "..\\afm\\")", so need to have space
	// for 7 extra bytes in our buffers.
    if (cjKey > (sizeof(achPFM)-7))
        return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_INF);

// check if a pfm file exists in the SAME directory.
// Use the buffer on the stack to produce the path for the pfm file:

    strcpy(achPFM, pszINF);
    strcpy(&achPFM[cjKey - 5],".PFM");

// try to open pfm file to check if it exists:

    if (bCheckForExistingPFM && bFileExists(achPFM))
    {
    // we found the pfm file, therefore we do not report this .inf file.

        return FVS_MAKE_CODE(FVS_FILE_EXISTS, FVS_FILE_PFM);
    }

// pfm file is NOT found, go on to check if .afm and .pfb files exists:
// We will first check if .afm and .pfb files exists in the same dir as .inf

    strcpy(achAFM, pszINF);
    strcpy(&achAFM[cjKey - 5],".AFM");

    strcpy(achPFB, pszINF);
    strcpy(&achPFB[cjKey - 5],".PFB");

    bAfmExists = bFileExists(achAFM);
    bPfbExists = bFileExists(achPFB);

    if (!bAfmExists || !bPfbExists)
    {
    // we did not find the .afm and .pfb files in the same dir as .inf
    // we will check two more directories for the .afm and .pfb files
    // 1) the parent directory of the .inf file for .pfb file
    // 2) the afm subdirectory of the .inf parent directory for .afm file
    //
    // This is meant to handle the standard configuration of files produced
    // on user's hard drive by unlocking fonts from Adobe's CD or from a
    // previous installation of atm manager on this machine.
    // This configuration is as follows:
    // c:\psfonts\           *.pfb files are here
    // c:\psfonts\afm        *.afm files are here
    // c:\psfonts\fontinfo   *.inf files are here
    // c:\psfonts\pfm        *.pfm files that are created on the fly
    //                         are PUT here by atm.
    // We will instead put the files in windows\system dir where all other
    // fonts are, it may not be possible to write pmf files on the media
    // from where we are installing fonts

        pszBare = &pszINF[cjKey - 5];
        for ( ; pszBare > pszINF; pszBare--)
        {
            if ((*pszBare == '\\') || (*pszBare == ':'))
            {
                pszBare++; // found it
                break;
            }
        }

    // check if full path to .inf file was passed in or a bare
    // name itself was passed in to look for .inf file in the current dir

        if ((pszBare > pszINF) && (pszBare[-1] == '\\'))
        {
        // skip '\\' and search backwards for another '\\':

            for (pszParent = &pszBare[-2]; pszParent > pszINF; pszParent--)
            {
                if ((*pszParent == '\\') || (*pszParent == ':'))
                {
                    pszParent++; // found it
                    break;
                }
            }

        // create .pfb file name in the .inf parent directory:

            strcpy(&achPFB[pszParent - pszINF], pszBare);
            strcpy(&achPFB[strlen(achPFB) - 4], ".PFB");

        // create .afm file name in the afm subdirectory of the .inf
        // parent directory:

            strcpy(&achAFM[pszParent - pszINF], "afm\\");
            strcpy(&achAFM[pszParent - pszINF + 4], pszBare);
            strcpy(&achAFM[strlen(achAFM) - 4], ".AFM");

        }
        else if (pszBare == pszINF)
        {
        // bare name was passed in, to check for the inf file in the "." dir:

            strcpy(achPFB, "..\\");
            strcpy(&achPFB[3], pszBare);   // 3 == strlen("..\\")
            strcpy(&achPFB[strlen(achPFB) - 4], ".PFB");

            strcpy(achAFM, "..\\afm\\");
            strcpy(&achAFM[7], pszBare);   // 7 == strlen("..\\afm\\")
            strcpy(&achAFM[strlen(achAFM) - 4], ".AFM");
        }
        else
        {
            return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_UNK);
        }

   // check again if we can find the files, if not fail.

       if (!bAfmExists && !bFileExists(achAFM))
          return FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_AFM);
       if (!bPfbExists && !bFileExists(achPFB))
          return FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_PFB);
    }

// now we have paths to .inf .afm and .pfb files. Now let us see
// what the caller wants from us:

    if (pszDesc)
    {
    // we need to return description string in the buffer supplied

        if (!bGetDescFromInf(pszINF, (DWORD)cjDesc, pszDesc))
            return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_INF);
    }

// copy pfb file path out if requested

    if (pszPFB)
    {
        if ((strlen(achPFB) + 1) < cjPFB)
            strcpy(pszPFB,achPFB);
        else
            return FVS_MAKE_CODE(FVS_INSUFFICIENT_BUF, FVS_FILE_UNK); 
    }

// the caller wants a pfm file created from inf,afm files
// For now and probably for ever we will put this file in
// the %windir%\system, or %windir%\fonts for the secure system.

    if (pszPFM && pszFontPath && *pszFontPath)
    {
        char *pszAppendHere;  // append "bare" name here

    // copy the first directory of the font path into the buffer provided
    // It is expected that this routine will get something like
    // "c:\foo" pointing to font path

        strncpy(achPFM,pszFontPath,sizeof(achPFM));
		achPFM[sizeof(achPFM)-1] = '\0';
        pszAppendHere = &achPFM[strlen(pszFontPath) - 1];

        if (*pszAppendHere != '\\')
        {
             pszAppendHere++;
            *pszAppendHere = '\\';
        }
        pszAppendHere++;

		// Check buffer bounds
		if (pszAppendHere >= &achPFM[sizeof(achPFM)-1])
			return FVS_MAKE_CODE(FVS_INSUFFICIENT_BUF, FVS_FILE_UNK); 

    // find bare name of the .inf file if we do not have already:

        if (!pszBare)
        {
            pszBare = &pszINF[cjKey - 5];
            for ( ; pszBare > pszINF; pszBare--)
            {
                if ((*pszBare == '\\') || (*pszBare == ':'))
                {
                    pszBare++; // found it
                    break;
                }
            }
        }

    // append Bare name to the %windir%system\ path
		// Check buffer bounds
		if ((pszAppendHere+strlen(pszBare)) >= &achPFM[sizeof(achPFM)-1])
			return FVS_MAKE_CODE(FVS_INSUFFICIENT_BUF, FVS_FILE_UNK); 
		
        strcpy(pszAppendHere, pszBare);

    // finally change .inf extension to .pfm extension

        strcpy(&pszAppendHere[strlen(pszAppendHere) - 4], ".PFM");

    // copy out:

        strncpy(pszPFM, achPFM, cjPFM);
		pszPFM[cjPFM-1] = '\0';
        
        result = CreatePFM(pszINF, achAFM, pszPFM);
        *pbCreatedPFM = (FVS_STATUS(result) == FVS_SUCCESS);

        if (!(*pbCreatedPFM))
            return result;
    }

    return FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);
}


/******************************Public*Routine******************************\
*
* short STDCALL CheckType1AInternal
*
* Effects: See if we are going to report this as a valid type 1 font
*
* Warnings:
*
* History:
*  29-Apr-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
* Returns: 16-bit encoded value indicating error and type of file where
*          error occurred.  (see fvscodes.h) for definitions.
*          The following table lists the "status" portion of the codes
*          returned.
*
*           FVS_SUCCESS           
*           FVS_INVALID_FONTFILE  
*           FVS_FILE_OPEN_ERR   
*           FVS_FILE_BUILD_ERR
*           FVS_INVALID_ARG
*           FVS_FILE_IO_ERR
*           FVS_BAD_VERSION
*           FVS_FILE_EXISTS
*           FVS_INSUFFICIENT_BUF
*
\**************************************************************************/


short STDCALL CheckType1AInternal (
    char *pszKeyFile,
    DWORD cjDesc,
    char *pszDesc,
    DWORD cjPFM,
    char *pszPFM,
    DWORD cjPFB,
    char *pszPFB,
    BOOL *pbCreatedPFM,
    char *pszFontPath

)
{
    DWORD  cjKey;

	// Validate indata
	if (pszKeyFile==NULL || pbCreatedPFM==NULL)
		return FVS_MAKE_CODE(FVS_INVALID_ARG, FVS_FILE_UNK);


    *pbCreatedPFM = FALSE; // initialization is essential.

    cjKey = (DWORD)strlen(pszKeyFile) + 1;

    if (cjKey < 5)          // 5 = strlen(".pfm") + 1;
        return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_UNK);

    if (!_strcmpi(&pszKeyFile[cjKey - 5], ".PFM"))
    {
    // copy out pfm string when asked to do so:

        if (pszPFM && (cjKey < cjPFM))
        {
            if (cjKey < cjPFM)
                strcpy(pszPFM, pszKeyFile);
            else
                return FVS_MAKE_CODE(FVS_INSUFFICIENT_BUF, FVS_FILE_UNK);
        }

        return CheckPfmA(
                   pszKeyFile,
                   cjDesc,
                   pszDesc,
                   cjPFB,
                   pszPFB
                   );
    }
    else if (!_strcmpi(&pszKeyFile[cjKey - 5], ".INF"))
    {
        return CheckInfA (
                   pszKeyFile,
                   cjDesc,
                   pszDesc,
                   cjPFM,
                   pszPFM,
                   cjPFB,
                   pszPFB,
                   pbCreatedPFM,
                   pszFontPath
                   );
    }
    else
    {
    // this font is not our friend

        return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_UNK);
    }
}


/******************************Public*Routine******************************\
*
* CheckType1WithStatusA, try / except wrapper
*
* Effects:
*
* Warnings:
*
* History:
*  14-Jun-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
* Returns: 16-bit encoded value indicating error and type of file where
*          error occurred.  (see fvscodes.h) for definitions.
*          The following table lists the "status" portion of the codes
*          returned.
*
*           FVS_SUCCESS           
*           FVS_INVALID_FONTFILE  
*           FVS_FILE_OPEN_ERR   
*           FVS_FILE_BUILD_ERR
*           FVS_INVALID_ARG
*           FVS_FILE_IO_ERR
*           FVS_BAD_VERSION
*           FVS_FILE_EXISTS
*           FVS_INSUFFICIENT_BUF
*           FVS_EXCEPTION
*         
\**************************************************************************/

short STDCALL CheckType1WithStatusA (
    char *pszKeyFile,
    DWORD cjDesc,
    char *pszDesc,
    DWORD cjPFM,
    char *pszPFM,
    DWORD cjPFB,
    char *pszPFB,
    BOOL *pbCreatedPFM,
    char *pszFontPath
)
{
    short status;
    try
    {
        status = CheckType1AInternal (
                   pszKeyFile,
                   cjDesc,
                   pszDesc,
                   cjPFM,
                   pszPFM,
                   cjPFB,
                   pszPFB,
                   pbCreatedPFM,
                   pszFontPath);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = FVS_MAKE_CODE(FVS_EXCEPTION, FVS_FILE_UNK);
    }

    return status;
}

/******************************Public*Routine******************************\
*
* CheckType1A, try / except wrapper
*
* Effects:
*
* Warnings:
*
* History:
*  14-Jun-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL STDCALL CheckType1A (
    char *pszKeyFile,
    DWORD cjDesc,
    char *pszDesc,
    DWORD cjPFM,
    char *pszPFM,
    DWORD cjPFB,
    char *pszPFB,
    BOOL *pbCreatedPFM,
    char *pszFontPath
)
{
    short status = CheckType1WithStatusA(pszKeyFile,
                                         cjDesc,
                                         pszDesc,
                                         cjPFM,
                                         pszPFM,
                                         cjPFB,
                                         pszPFB,
                                         pbCreatedPFM,
                                         pszFontPath);

    return (FVS_STATUS(status) == FVS_SUCCESS);
}


/******************************Public*Routine******************************\
*
* FindPfb, given pfm file, see if pfb file exists in the same dir or in the
* parent directory of the pfm file
*
* History:
*  14-Jun-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
* Returns: 16-bit encoded value indicating error and type of file where
*          error occurred.  (see fvscodes.h) for definitions.
*          The following table lists the "status" portion of the codes
*          returned.
*
*           FVS_SUCCESS           
*           FVS_INVALID_FONTFILE  
*           FVS_FILE_OPEN_ERR   
*
\**************************************************************************/


short STDCALL FindPfb (
    char *pszPFM,
    char *achPFB,
	DWORD cbPFB
)
{
    DWORD  cjKey;
    char *pszParent = NULL; // points to the where parent dir of the inf file is
    char *pszBare = NULL;   // "bare" .inf name, initialization essential

// example:
// if pszPFM -> "c:\psfonts\pfm\foo_____.pfm"
// then pszParent -> "pfm\foo_____.pfm"

    cjKey = (DWORD)strlen(pszPFM) + 1;

    if (cjKey < 5 || cjKey > cbPFB-3)   // 5 = strlen(".pfm") + 1; 3 = strlen("..\\") below 
        return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_PFM);

// go on to check if .pfb file exists:
// We will first check .pfb file exists in the same dir as .pfm

    strcpy(achPFB, pszPFM);
    strcpy(&achPFB[cjKey - 5],".PFB");

    if (!bFileExists(achPFB))
    {
    // we did not find the .pfb file in the same dir as .pfm
    // Now check the parent directory of the .pfm file

        pszBare = &pszPFM[cjKey - 5];
        for ( ; pszBare > pszPFM; pszBare--)
        {
            if ((*pszBare == '\\') || (*pszBare == ':'))
            {
                pszBare++; // found it
                break;
            }
        }

    // check if full path to .pfm was passed in or a bare
    // name itself was passed in to look for .pfm file in the current dir

        if ((pszBare > pszPFM) && (pszBare[-1] == '\\'))
        {
        // skip '\\' and search backwards for another '\\':

            for (pszParent = &pszBare[-2]; pszParent > pszPFM; pszParent--)
            {
                if ((*pszParent == '\\') || (*pszParent == ':'))
                {
                    pszParent++; // found it
                    break;
                }
            }

        // create .pfb file name in the .pfm parent directory:

            strcpy(&achPFB[pszParent - pszPFM], pszBare);
            strcpy(&achPFB[strlen(achPFB) - 4], ".PFB");

        }
        else if (pszBare == pszPFM)
        {
        // bare name was passed in, to check for the inf file in the "." dir:

            strcpy(achPFB, "..\\");
            strcpy(&achPFB[3], pszBare);   // 3 == strlen("..\\")
            strcpy(&achPFB[strlen(achPFB) - 4], ".PFB");
        }
        else
        {
            return FVS_MAKE_CODE(FVS_INVALID_FONTFILE, FVS_FILE_PFM); // We should never get here.
        }

   // check again if we can find the file, if not fail.

       if (!bFileExists(achPFB))
       {
           return FVS_MAKE_CODE(FVS_FILE_OPEN_ERR, FVS_FILE_PFB);
       }
    }

// now we have paths to .pfb file in the buffer provided by the caller.

    return FVS_MAKE_CODE(FVS_SUCCESS, FVS_FILE_UNK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\t1local.h ===
#define STR_APPNAME              "Type 1 Installer"
#define SUBKEY_TYPE1INSTAL       "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Type 1 Installer"
#define SUBKEY_TYPE1COPYRIGHTS   SUBKEY_TYPE1INSTAL "\\Copyrights"
#define SUBKEY_LOGFILE           "Log events"   



#define IDS_CAPTION	1
#define IDS_RECOGNIZE1  2
#define IDS_RECOGNIZE2  3
#define IDS_MAINMSG     4


#define ALERT				MB_OK | MB_DEFBUTTON1 | MB_ICONSTOP
#define INFO				MB_OK | MB_DEFBUTTON1 | MB_ICONEXCLAMATION
#define QUERY				MB_OKCANCEL | MB_DEFBUTTON2 | MB_ICONEXCLAMATION

HMODULE ModuleInstance(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\titott.c ===
/***
 **
 **   Module: TItoTT
 **
 **   Description:
 **      This is the main module of the Postscript Type I to TrueType
 **      font converter.
 **
 **   Author: Michael Jansson
 **   Created: 5/26/93
 **
 ***/


/***** INCLUDES */
#include <string.h>
#include "types.h"
#include "safemem.h"
#include "metrics.h"
#include "titott.h"
#include "t1parser.h"
#include "builder.h"
#include "trans.h"


/***** LOCAL TYPES */
/*-none-*/


/***** CONSTANTS */
#define NOTDEFNAME  ".notdef"

static const struct TTGlyph null = {
   NULL,
   0, 0, 0, NULL,
   NULL,
   0, 0
};
static Point mpo3[] = {
   {1150, 10}, {1150, 30}, {1160, 30}, {1170, 20}, {1180, 30}, {1190, 30}, 
   {1190, 10}, {1180, 10}, {1180, 20}, {1170, 10}, {1160, 20}, {1160, 10}
};
static Point mpo2[] = {
   {60, 40}, {60, 1560}, {1160, 1560}, {1160, 40}
};
static Point mpo1[] = {
   {20, 0}, {1200, 0}, {1200, 1600}, {20, 1600}
};
static ULONG onoff[1] = {0L};
static Outline p1 = {
   NULL,
   sizeof(mpo3)/sizeof(mpo3[0]),
   &mpo3[0],
   &onoff[0]
};
static Outline p2 = {
   &p1,
   sizeof(mpo2)/sizeof(mpo2[0]),
   &mpo2[0],
   &onoff[0]
};
static Outline missingPath = {
   &p2,
   sizeof(mpo1)/sizeof(mpo1[0]),
   &mpo1[0],
   &onoff[0]
};

static struct TTGlyph missing = {
   NULL,
   MAXNOTDEFSIZE, 0, 0, NULL,
   &missingPath,
   1500, 0
};


/***** MACROS */
/*-none-*/


/***** GLOBALS */
/*-none-*/


/***** STATIC FUNCTIONS */
/*-none-*/


/**** FUNCTIONS */

/***
 ** Function: ConvertT1toTT
 **
 ** Description:
 **   Convert a T1 font into a TT font file.
 ***/
errcode ConvertT1toTT(const struct TTArg *ttArg,
                      const struct T1Arg *t1Arg,
                      const short (*check)(const char *copyright,
                                           const char *notice,
                                           const char *facename),
                      struct callProgress *cp)
{
   /* Resources */
   struct T1Handle  *t1 = NULL;
   struct TTHandle  *tt = NULL;
   struct T1Metrics *t1m = NULL;

   /* Temporary variables. */
   struct T1Glyph  glyph;
   struct TTGlyph *ttglyph;
   struct Composite *comp;
   struct TTComposite ttcomp;
   struct TTMetrics ttm;
   boolean fStdEncoding;
   boolean done;
   errcode status;

   /* Initiate variables. */
   ttglyph = NULL;
   memset(&glyph, '\0', sizeof(glyph));
   memset(&ttm, '\0', sizeof(ttm));

   /* Inititate input and output */
   if ((status = InitT1Input(t1Arg, &t1, &t1m, check))==SUCCESS &&
       (status = InitTTOutput(ttArg, &tt))==SUCCESS) {
     
      done = FALSE;

      fStdEncoding = (CurrentEncoding(t1m)==NULL);

      /* Create the missing and the null glyph. */
      if ((missing.hints = Malloc(MAXNOTDEFSIZE))==NULL) {
         status = NOMEM;
         done = TRUE;
      } else {
         memset(missing.hints, 0x22, MAXNOTDEFSIZE);
         (void)PutTTGlyph(tt, &missing, fStdEncoding);
         (void)PutTTGlyph(tt, &null, fStdEncoding);
         Free(missing.hints);
      }

      /* Convert the simple glyphs. */
      while(!done) {
         status = GetT1Glyph(t1, &glyph, t1Arg->filter);
         if (status == SUCCESS) {
            if ((status = ConvertGlyph(t1m,
                                       &glyph,
                                       &ttglyph,
                                       (int)ttArg->precision))!=SUCCESS ||
                (status = PutTTGlyph(tt, ttglyph, fStdEncoding))!=SUCCESS) {
               done = TRUE;
            } else {

               FreeTTGlyph(ttglyph);
               ttglyph=NULL;
               if (cp)
                  cp->cb((short)0, &glyph, cp->arg);
            }
         } else if (status<=FAILURE || status==DONE) {
            done = TRUE;
         } else {
            /* Handle the missing glyph ".notdef" */
            if (!strcmp(glyph.name, NOTDEFNAME)) {
               if ((status = ConvertGlyph(t1m,
                                          &glyph,
                                          &ttglyph,
                                          (int)ttArg->precision))!=SUCCESS ||
                   (status = PutTTNotDefGlyph(tt, ttglyph))!=SUCCESS) {
                  done = TRUE;
               } else {
                  FreeTTGlyph(ttglyph);
                  ttglyph=NULL;
                  if (cp)
                     cp->cb((short)0, &glyph, cp->arg);
               }
            }
         }
         FreeT1Glyph(&glyph);
      }
      
      if (status==DONE) {

         /* Convert the composite glyphs. */
         while ((comp = GetT1Composite(t1))!=NULL) {

            /* Check if the base glyph is converted */
            if ((status = GetT1BaseGlyph(t1, comp, &glyph))==SUCCESS) {
               if ((status = ConvertGlyph(t1m,
                                          &glyph,
                                          &ttglyph,
                                          (int)ttArg->precision))!=SUCCESS ||
                   (status = PutTTGlyph(tt, ttglyph, fStdEncoding))!=SUCCESS) {
                  break;
               }
               FreeTTGlyph(ttglyph);
               ttglyph=NULL;
               if (cp)
                  cp->cb((short)0, &glyph, cp->arg);
            } else if (status<=FAILURE)
               break;
            FreeT1Glyph(&glyph);

            /* Check if the base accent is converted */
            if ((status = GetT1AccentGlyph(t1, comp, &glyph))==SUCCESS) {
               if ((status = ConvertGlyph(t1m,
                                          &glyph,
                                          &ttglyph,
                                          (int)ttArg->precision))!=SUCCESS ||
                   (status = PutTTGlyph(tt, ttglyph, fStdEncoding))!=SUCCESS) {
                  break;
               }
               FreeTTGlyph(ttglyph);
               ttglyph=NULL;
               if (cp)
                  cp->cb((short)0, &glyph, cp->arg);
            } else if (status<=FAILURE)
               break;
            FreeT1Glyph(&glyph);


            /* Convert and store accented glyph. */
            if (status>=SUCCESS && 
                ((status = ConvertComposite(t1m, comp, &ttcomp))!=SUCCESS ||
                 (status = PutTTComposite(tt, &ttcomp))!=SUCCESS)) {
               break;
            }
            if (cp)
               cp->cb((short)1, &comp, cp->arg);
         }

         /* Flush out un-used work space. */
         FlushWorkspace(t1);

         /* Convert the metrics. */
         if (status==SUCCESS || status==DONE || status==SKIP) {
            if ((status = ReadOtherMetrics(t1m,
                                           t1Arg->metrics))==SUCCESS &&
                (status = ConvertMetrics(tt, t1m, &ttm,
                                         ttArg->tag))==SUCCESS) {
               if (cp)
                  cp->cb((short)2, NULL, cp->arg);
               status = PutTTOther(tt, &ttm);
            }
         }
      }
   }                               

   /* More progress. */
   if (cp)
      cp->cb((short)3, NULL, cp->arg);

   FreeTTMetrics(&ttm);
   FreeTTGlyph(ttglyph);
   FreeT1Glyph(&glyph);
   if (CleanUpTT(tt, ttArg, status)!=SUCCESS && status==SUCCESS)
      status = BADINPUTFILE;
   if (CleanUpT1(t1)!=SUCCESS && status==SUCCESS)
      status = BADINPUTFILE;

   /* All done! */
   if (cp)
      cp->cb((short)4, NULL, cp->arg);


   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\titott.h ===
/***
 **
 **   Module: TItoTT
 **
 **   Description:
 **      This is the internal interface for the Adobe Type 1 to
 **      TrueType font converter.
 **
 **   Author: Michael Jansson
 **   Created: 5/26/93
 **
 ***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

#define MAXERRORS          -14
#define NOCOPYRIGHT        -13
#define ARGSTACK           -12
#define TTSTACK            -11
#define NOMETRICS          -10
#define UNSUPPORTEDFORMAT  -9
#define BADMETRICS         -8
#define BADT1HYBRID        -7
#define BADCHARSTRING      -6
#define BADINPUTFILE       -5
#define BADOUTPUTFILE      -4
#define BADT1HEADER        -3
#define NOMEM              -2
#define FAILURE            -1
#define SUCCESS            0
#define DONE               1
#define SKIP               2

struct GlyphFilter {
   const unsigned short num;
   const char **name;
};

struct T1Arg {
   const char *name;
   const char *metrics;
   const struct GlyphFilter *filter;
   int upem;
};

struct TTArg {
   char *name;
   char *tag;
   short precision;
};

struct callProgress {
   const void (*cb)(short, void *, void *);
   void *arg;
};
   

/***
 ** Function: ConvertT1toTT
 **
 ** Description:
 **   Convert a T1 font into a TT font file.
 ***/
short ConvertT1toTT _ARGS((IN struct TTArg *ttArg,
                           IN struct T1Arg *t1Arg,
                           IN short (*check)(IN char *facename,
                                             IN char *copyright,
                                             IN char *notice),
                           INOUT struct callProgress *cp));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\testt1.c ===
#include <stdio.h>
#include <stdlib.h>
#include "t1instal.h"

#define DEFAULT_STR  (void*)"Converting with pfb: "
#define PFM_STR      (void*)"Converting with pfb+pfm: "
#define FULL_STR     (void*)"Converting with pfb+pfm+ttf: "

#ifdef _MSC_VER
#  define CDECL  __cdecl
#else
#  define CDECL
#endif


#ifdef PROGRESS
const void STDCALL PrintProgress(short percent, void *arg)
{
   char *str = arg;
   
   printf("\r%s%d%%  ", str, percent);
}
#else
#define PrintProgress 0L
#endif

void CDECL main(int argc, char **argv)
{
   short res;
   char buf[128];

   if (argc==2)
      res = ConvertTypeface(argv[1], 0L, 0L,
                            PrintProgress, DEFAULT_STR);
   else if (argc==3) {
      if (IsType1(argv[2], sizeof(buf), buf)) {
         printf("Converting typeface: %s\n", buf);
         res = ConvertTypeface(argv[1], argv[2], 0L,
                               PrintProgress, PFM_STR);
      } else {
         printf("Not a valid Adobe Type 1 typeface.\n");
      }
         
   } else if (argc==4) {
      if (IsType1(argv[2], sizeof(buf), buf)) {
         printf("Converting typeface: %s\n", buf);
         res = ConvertTypeface(argv[1], argv[2], argv[3],
                               PrintProgress, PFM_STR);
      } else {
         printf("Not a valid Adobe Type 1 typeface.\n");
      }
   }

   if (res!=SUCCESS)
      puts("\nConversion failed!");

   exit((int)res);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\t1parser.c ===
/***
**
**   Module: T1Parser
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      will extract information from a T1 font file, by parsing
**      the data/commands found in PFB, PFM and AFM files.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <string.h>
#include "types.h"

/* Special types and definitions. */
#include "safemem.h"
#include "encoding.h"
#include "metrics.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "titott.h"
#include "t1parser.h"
#include "charstr.h"
#include "freader.h"
#include "mreader.h"


/***** CONSTANTS */
#define ONE       (USHORT)1
#define BUFLEN    (USHORT)512

#define PS_ANGLE              "/ItalicAngle"
#define PS_ARRAY              "array"
#define PS_BEGIN              "begin"
#define PS_BLUEFUZZ           "/BlueFuzz"
#define PS_BLUESCALE          "/BlueScale"
#define PS_BLUESHIFT          "/BlueShift"
#define PS_BLUEVALUES         "/BlueValues"
#define PS_CHARSTRINGS        "/CharStrings"
#define PS_COPYRIGHT          "/Copyright"
#define PS_DATE               "%%CreationDate:"
#define PS_DUP                "dup"
#define PS_ENCODING           "/Encoding"
#define PS_END                "end"
#define PS_FAMILY             "/FamilyName"
#define PS_FAMILYBLUES        "/FamilyBlues"
#define PS_FAMILYOTHERBLUES   "/FamilyOtherBlues"
#define PS_FONTMATRIX         "/FontMatrix"
#define PS_FORCEBOLD          "/ForceBold"
#define PS_FULLNAME           "/FullName"
#define PS_HYBRID             "hires"
#define PS_ISFIXED            "/isFixedPitch"
#define PS_LENIV              "/lenIV"
#define PS_NAME               "/FontName"
#define PS_NOACCESS           "noaccess"
#define PS_NOTICE             "/Notice"
#define PS_OTHERBLUES         "/OtherBlues"
#define PS_SNAPH              "/StemSnapH"
#define PS_SNAPV              "/StemSnapV"
#define PS_STDENCODING        "StandardEncoding"
#define PS_STDVW              "/StdVW"
#define PS_STDHW              "/StdHW"
#define PS_SUBRS              "/Subrs"
#define PS_UNDERLINE          "/UnderlinePosition"
#define PS_UTHICK             "/UnderlineThickness"
#define PS_ID                 "/UniqueID"
#define PS_VERSION            "/version"
#define PS_WEIGHT             "/Weight"



/***** LOCAL TYPES */

struct T1Handle {
   struct FontFile *ff;

   struct PSState *ps;

   struct Subrs stdenc[256];

   USHORT numsubrs;
   struct Subrs *subrs;
   USHORT leniv;
   struct T1Metrics t1m;
};


/***** MACROS */
/*-none-*/


/***** PROTOTYPES */
/*-none-*/

/***** STATIC FUNCTIONS */


/***
** Function: StrToFix
**
** Description:
**   This is a "strtod" function, that converts from
**   ascii to fixpoint numbers.
***/
static long StrToFix(char *str, char **out, const long base)
{
   char *fstr;
   long num = 0, frac = 0, exp = 0;

   if (out)
      (*out) = str;

   /* Skip white space. */
   while (*str && (*str==' ' || *str=='\t'))
      str++;

   /* A number? */
   if (*str && ((*str>='0' && *str<='9') || *str=='-') || *str=='.') {

      num = atoi(str)*base;

      /* Fraction? */
      fstr = strchr(str, '.');
      if (fstr!=NULL && (strchr(str, ' ')==NULL || fstr<strchr(str, ' '))) {

         do {
            fstr++;
         } while (*fstr>='0' && *fstr<='9');

         /* Exponent? */
         if (*fstr=='E')
            exp = atoi(fstr+1);
         else
            exp = 0;

         fstr--;
         while (*fstr!='.') {
            frac += ((*fstr)-'0')*base;
            frac /= 10;
            fstr--;
         }
         if (num<0)
            num -= frac;
         else
            num += frac;

         /* Handle exponent. */
         if (exp>0) {
            do {
               num *= 10;
            } while (--exp);
         } else if (exp<0) {
            do {
               num /= 10;
            } while (++exp);
         }
      }

      /* Skip digits. */
      while (*str && ((*str>='0' && *str<='9') ||
                      *str=='.' || *str=='-' || *str=='E'))
         str++;

      if (out)
         (*out) = str;
   }

   return num;
}



/***
** Function: FreeT1Composite
**
** Description:
**   This function frees the memory used to represent
**   a composite acented T1 glyph.
***/
static void FreeT1Composite(Composite *comp)
{
   if (comp) {
      if (comp->cchar)
         Free(comp->cchar);
      Free(comp);
   }
}


/***
** Function: UseGlyph
**
** Description:
**   This function determines whether a glyph should be
**   converted or not, based on the name of the glyph
**   and a specification of the desired glyphs.
***/
static int CDECL compare(const void *arg1, const void *arg2)
{
	return strcmp( *((const char **)arg1), *((const char **)arg2) );
}
static boolean UseGlyph(const struct GlyphFilter *filter,
                        Composite *comp,
                        const char *name)
{
   boolean found = FALSE;
   char **result;

   /* Check if the glyph is explicitly specified. */
   if (filter) {

      result = (char **)bsearch((char *)&name,
                                (char *)filter->name, filter->num,
                                sizeof(char *),
                                compare);


      found = (boolean)(result!=NULL);

      /* Check if the glyph is specified indirectly through an accented */
      /* composite glyph. */
      if (!found) {
         Composite *c;

         for (c=comp; c &&
                strcmp(name, c->achar) &&
                strcmp(name, c->bchar); c = c->next);
         found = (boolean)(c!=NULL);
      }
   } else {
      found = TRUE;
   }

   return found;
}



/***
** Function: ReadFontMatrix
**
** Description:
**   Read the command sequence "/FontMatrix[%d %d %d %d]" and
**   record the transformation matrix in the T1 handle.
***/
static errcode ReadFontMatrix(struct T1Handle *t1,
                              char *str,
                              const USHORT len)
{
   errcode status=SUCCESS;
   f16d16 fmatrix[6];
   USHORT i;

   if (GetSeq(t1->ff, str, len)) {
      for (i=0; i<6; i++)
         fmatrix[i] = StrToFix(str, &str, F16D16BASE);

      /* Check if we have the default matrix. */ /*lint -e771 */
      if (fmatrix[2]!=0 ||
          fmatrix[4]!=0 ||
          fmatrix[1]!=0 ||
          fmatrix[5]!=0 ||
          fmatrix[0]!=F16D16PPM ||
          fmatrix[3]!=F16D16PPM ||
          t1->t1m.upem!=2048) {  /*lint +e771 */ /* fmatrix[] IS initialized */

          if ((t1->t1m.fmatrix = Malloc(sizeof(f16d16)*6))==NULL) {
              SetError(status = NOMEM);
          } else {
            t1->t1m.fmatrix[0] = fmatrix[0];
            t1->t1m.fmatrix[1] = fmatrix[1];
            t1->t1m.fmatrix[2] = fmatrix[2];
            t1->t1m.fmatrix[3] = fmatrix[3];
            t1->t1m.fmatrix[4] = fmatrix[4];
            t1->t1m.fmatrix[5] = fmatrix[5];
         }
      } else {
         t1->t1m.fmatrix = NULL;
      }
   } else {
      SetError(status = BADINPUTFILE);
   }

   return status;
}


/***
** Function: ReadEncodingArray
**
** Description:
**   Read the command sequence "/Encoding %d array ..." and
**   build an encoding table, or read "/Encoding StdEncoding def"
**   and used the standard encoding table.
***/
static errcode ReadEncodingArray(struct T1Handle *t1,
                                 char *str,
                                 const USHORT len)
{
   errcode status = SUCCESS;
   USHORT codes[ENC_MAXCODES];
   char *glyph_name = NULL;
   USHORT i, index;

   if (Get_Token(t1->ff, str, len)==NULL) {
      SetError(status = BADINPUTFILE);
   } else {
      if (strcmp(str, PS_STDENCODING) &&
          ((t1->t1m.encSize=(USHORT)atoi(str))!=0)) {
         if ((t1->t1m.encoding = AllocEncodingTable(t1->t1m.encSize))==NULL) {
            SetError(status = NOMEM);
         } else {

            /* Skip leading proc. */
            while (Get_Token(t1->ff, str, len) && strcmp(str, PS_DUP));

            /* Read the encoding entries: "<n> <str> put <comment>\n dup" */
            for (i=0; i<t1->t1m.encSize; i++) {

               /* Get character code. */
               (void)Get_Token(t1->ff, str, len);
               if (str[0]=='8' && str[1]=='#') {   /* Octal? */
                  index = (USHORT)atoi(&str[2]);
                  index = (USHORT)((index/10)*8 + (index%8));
               } else {
                  index = (USHORT)atoi(str);
               }

               /* Get character name. */
               (void)Get_Token(t1->ff, str, len);

               codes[ENC_MSWINDOWS] = index;
               codes[ENC_UNICODE] = index;

               if (index<256) {
                  codes[ENC_STANDARD] = index;
                  codes[ENC_MACCODES] = index;
               } else {
                  codes[ENC_STANDARD] = NOTDEFCODE;
                  codes[ENC_MACCODES] = NOTDEFCODE;
               }
               if ((glyph_name = Strdup(&str[1]))!=NULL)
                  SetEncodingEntry(t1->t1m.encoding, i,
                                   glyph_name,
                                   ENC_MAXCODES,
                                   codes);
               else {
                  status = NOMEM;
                  break;
               }
               
               (void)Get_Token(t1->ff, str, len);   /* Pop "dup" */
               (void)Get_Token(t1->ff, str, len);   /* Pop "put" or comment. */
               if (str[0]=='%') {
                  (void)GetNewLine(t1->ff, str, len);
                  (void)Get_Token(t1->ff, str, len);   /* Pop "put". */
               }

               if (strcmp(str, PS_DUP))
                  break;
            }
            t1->t1m.encSize = (USHORT)(i+1);

            /* Rehash the table. */
            RehashEncodingTable(t1->t1m.encoding, t1->t1m.encSize);
         }
      }
   }

   return status;
}


/***
** Function: ReadArray
**
** Description:
**   Read an array.
***/
static errcode ReadArray(struct T1Handle *t1,
                         char *str,
                         const USHORT len,
                         funit *array,
                         USHORT maxarr,
                         USHORT *cnt)
{
   errcode status;
   char *nxt;

   if (GetSeq(t1->ff, str, len)) {
      (*cnt)=0;
      do {
         array[(*cnt)] = (funit)(((StrToFix(str, &nxt, 4L)+8002)>>2) - 2000);
         if (nxt==str)
            break;
         str = nxt;
      } while (++(*cnt)<maxarr);
      status=SUCCESS;
   } else {
      SetError(status = BADINPUTFILE);
   }

   return status;
}



/***
** Function: ReadFontSubrs
**
** Description:
**   Read the command sequence "/Subrs %d array dup %d %d RD %x ND ...",
**   decode and decrypt the subroutines and store them in the T1
**   handle.
***/
static errcode ReadFontSubrs(struct T1Handle *t1,
                             char *str, const USHORT len)
{
   errcode status = SUCCESS;
   USHORT index,i,j;
   USHORT count = 0;
   USHORT r;
   short b;

   /* Get the number of subroutines. */
   if (Get_Token(t1->ff, str, len)==NULL) {
      SetError(status = BADINPUTFILE);
   } else {
      count = (USHORT)atoi(str);

      /* Get the "array" keyword". */
      if ((Get_Token(t1->ff, str, len)==NULL) || strcmp(str, PS_ARRAY)) {
         SetError(status = BADINPUTFILE);
      } else {
         if ((t1->subrs = Malloc((USHORT)sizeof(struct Subrs)*count))==NULL) {
            SetError(status = NOMEM);
         } else {
            memset(t1->subrs, '\0', sizeof(struct Subrs)*count);
            t1->numsubrs = count;
            for (i=0; i<count; i++) {

               if (Get_Token(t1->ff, str, len)==NULL) {  /* Get "dup" */
                  SetError(status = BADINPUTFILE);
                  break;
               }
               if (strcmp(str, PS_DUP)) {
                  SetError(status = BADT1HEADER);
                  break;
               }

               if (Get_Token(t1->ff, str, len)==NULL) { /* Get Subr index. */
                  SetError(status=BADINPUTFILE);
                  break;
               }
               index = (USHORT)atoi(str);
               if (t1->subrs[index].code) {
                  LogError(MSG_WARNING, MSG_DBLIDX, NULL);
                  Free(t1->subrs[index].code);
               }

               if (Get_Token(t1->ff, str, len)==NULL) { /* Get length. */
                  SetError(status=BADINPUTFILE);
                  break;
               }
               t1->subrs[index].len = (USHORT)(atoi(str) - t1->leniv);
               if ((t1->subrs[index].code
                    = Malloc(t1->subrs[index].len))==NULL) {
                  SetError(status = NOMEM);
                  break;
               }

               if (Get_Token(t1->ff, str, len)==NULL) { /* Get RD + space */
                  SetError(status=BADINPUTFILE);
                  break;
               }
               /* Skip space. */
               (void)GetByte(t1->ff);

               /* Skip lenIV */
               r = 4330;
               for (j=0; j<t1->leniv; j++) {
                  b=GetByte(t1->ff);
                  (void)Decrypt(&r, (UBYTE)b);
               }
               if (status!=SUCCESS)
                  break;

               /* Get code. */
               for (j=0; j<t1->subrs[index].len; j++) {
                  b=GetByte(t1->ff);
                  t1->subrs[index].code[j] = Decrypt(&r, (UBYTE)b);
               }
               if (status!=SUCCESS)
                  break;

               if (Get_Token(t1->ff, str, len)==NULL) { /* Get ND */
                  SetError(status=BADINPUTFILE);
                  break;
               }
               /* Check for non-ATM compatible equivalent to 'ND' */
               if (!strcmp(str, PS_NOACCESS)) {
                  (void)Get_Token(t1->ff, str, len);
               }

            }
         }
      }
   }

   return status;
}





/***** FUNCTIONS */


/***
** Function: FlushWorkspace
**
** Description:
**   Free the resources allocated for the T1 handle.
***/
void FlushWorkspace(struct T1Handle *t1)
{
   USHORT i;

   /* Free /Subrs */
   if (t1->subrs) {
      for (i=0; i<t1->numsubrs; i++) {
         Free(t1->subrs[i].code);
      }
      Free(t1->subrs);
   }
   t1->subrs = NULL;
}   


/***
** Function: CleanUpT1
**
** Description:
**   Free the resources allocated for the T1 handle.
***/
errcode CleanUpT1(struct T1Handle *t1)
{
   errcode status = SUCCESS;
   AlignmentControl *align;
   Composite *next;
   Blues *blues;
   USHORT i;

   if (t1) {

      /* Free the PSState */
      if (t1->ps)
         FreePSState(t1->ps);

      /* Free /Subrs */
      if (t1->subrs) {
         for (i=0; i<t1->numsubrs; i++) {
            Free(t1->subrs[i].code);
         }
         Free(t1->subrs);
      }

      /* Clean up font file reader. */
      status = FRCleanUp(t1->ff);

      /* Clean up font matrix. */
      if (t1->t1m.fmatrix)
         Free(t1->t1m.fmatrix);

      /* Clean up seac. */
      while (t1->t1m.used_seac) {
         next = t1->t1m.used_seac->next;
         FreeT1Composite(t1->t1m.used_seac);
         t1->t1m.used_seac = next;
      }
      while (t1->t1m.seac) {
         next = t1->t1m.seac->next;
         FreeT1Composite(t1->t1m.seac);
         t1->t1m.seac = next;
      }

      /* Clean up stdenc. */
      for (i=0; i<256; i++) {
         if (t1->stdenc[i].code) {
            Free(t1->stdenc[i].code);
            t1->stdenc[i].code = NULL;
            t1->stdenc[i].len = 0;
         }
      }

      /* Clean up encoding table. */
      if (t1->t1m.encoding)
         FreeEncoding(t1->t1m.encoding, t1->t1m.encSize);

      /* Free strings */
      if (t1->t1m.date)
         Free(t1->t1m.date);
      if (t1->t1m.copyright)
         Free(t1->t1m.copyright);
      if (t1->t1m.name)
         Free(t1->t1m.name);
      if (t1->t1m.id)
         Free(t1->t1m.id);
      if (t1->t1m.notice)
         Free(t1->t1m.notice);
      if (t1->t1m.fullname)
         Free(t1->t1m.fullname);
      if (t1->t1m.weight)
         Free(t1->t1m.weight);
      if (t1->t1m.family)
         Free(t1->t1m.family);
      if (t1->t1m.widths)
         Free(t1->t1m.widths);
                if (t1->t1m.kerns)
                        Free(t1->t1m.kerns);
      if (t1->t1m.stems.vwidths)
         Free(t1->t1m.stems.vwidths);
      if (t1->t1m.stems.hwidths)
         Free(t1->t1m.stems.hwidths);
      blues = &(t1->t1m.blues);
      align = &(t1->t1m.blues.align);
      for (i=0; i<blues->blue_cnt/2; i++) {
         Free(align->top[i].pos);
      }
      for (i=0; i<blues->oblue_cnt/2; i++) {
         Free(align->bottom[i].pos);
      }

      /* Free handle. */
      Free(t1);
   }

   return status;
}



/***
** Function: InitT1Input
**
** Description:
**   Allocate and initiate a handle for a T1 font file, including
**   extracting data from the font prolog that is needed to
**   read the glyphs, such as /FontMatrix, /Subrs and /lenIV.
***/
errcode InitT1Input(const struct T1Arg *arg,
                    struct T1Handle **t1ref,
                    struct T1Metrics **t1mref,
                    const short (*check)(const char *,
                                         const char *,
                                         const char *))
{
   errcode status = SUCCESS;
   struct T1Handle *t1;
   struct PSState *ps;
   Blues *blues;
   boolean hybrid = FALSE;
   struct T1Metrics *t1m = NULL;
   char str[BUFLEN];
   USHORT i;

   /* Allocate the handle. */
   if (((*t1ref)=Malloc((USHORT)sizeof(struct T1Handle)))==NULL ||
       (ps = AllocPSState())==NULL) {
      if ((*t1ref)) {
         Free((*t1ref));
         *t1ref = NULL;
      }
      SetError(status = NOMEM);
   } else {

      /* Initiate the T1 record. */
      t1 = (*t1ref);
      t1m = &t1->t1m;
      (*t1mref) = t1m;
      blues = GetBlues(t1m);
      memset(t1, '\0', sizeof(*t1));
      t1->ps = ps;
      t1->leniv = 4;
      t1m->upem = arg->upem;
      t1m->defstdhw = 70;
      t1m->defstdvw = 80;

      blues->blueScale = 39;   /* Should really be 39.625 */
      blues->blueFuzz = 1;
      blues->blueShift = 7 * F8D8;
      blues->align.cvt = 3;
      t1m->stems.storage = 15;

      /* Initiate font file reader. */
      if ((status=FRInit(arg->name, pfb_file, &t1->ff))==SUCCESS) {

         /* Read /FontMatrix and /Subrs. */
         while (status==SUCCESS) {
            if (Get_Token(t1->ff, str, BUFLEN)==NULL) {
               SetError(status=BADINPUTFILE);

               /**** /ForceBold true def ****/
            } else if (!strcmp(str, PS_FORCEBOLD)) {
               if (Get_Token(t1->ff, str, BUFLEN)) {
                  if (!strcmp(str, "true") || !strcmp(str, "True"))
                     t1m->forcebold = TRUE;
                  else
                     t1m->forcebold = FALSE;
                  status = SUCCESS;
               } else {
                  status = BADINPUTFILE;
               }

               /**** /BlueFuzz 1 def ****/
            } else if (!strcmp(str, PS_BLUEFUZZ)) {
               if (Get_Token(t1->ff, str, BUFLEN)) {
                  blues->blueFuzz = (UBYTE)atoi(str);
                  status = SUCCESS;
               } else {
                  status = BADINPUTFILE;
               }

               /**** /BlueScale 0.043625 def ****/
            } else if (!strcmp(str, PS_BLUESCALE)) {
               if (Get_Token(t1->ff, str, BUFLEN)) {
                  str[5] = '\0';
                  blues->blueScale = (UBYTE)atoi(&str[2]);
                  status = SUCCESS;
               } else {
                  status = BADINPUTFILE;
               }

               /**** /BlueShift 7 def ****/
            } else if (!strcmp(str, PS_BLUESHIFT)) {
               if (Get_Token(t1->ff, str, BUFLEN)) {
                  blues->blueShift = (short)StrToFix(str, NULL, (long)F8D8);
                  status = SUCCESS;
               } else {
                  status = BADINPUTFILE;
               }

               /**** /Encoding StandardEncodind def ****/
            } else if (!strcmp(str, PS_ENCODING)) {
               status = ReadEncodingArray(t1, str, BUFLEN);

               /**** /StdVW [118] def ****/
            } else if (!strcmp(str, PS_STDVW)) {
               USHORT dummy;
               status = ReadArray(t1, str, BUFLEN,
                                  &t1m->stdvw, ONE, &dummy);


               /**** /StdHW [118] def ****/
            } else if (!strcmp(str, PS_STDHW)) {
               USHORT dummy;
               status = ReadArray(t1, str, BUFLEN,
                                  &t1m->stdhw, ONE, &dummy);

               /**** /StemSnapV [118 120] def ****/
            } else if (!strcmp(str, PS_SNAPV)) {
               status = ReadArray(t1, str, BUFLEN,
                                  &t1m->stemsnapv[0],
                                  MAXSNAP, &t1m->snapv_cnt);

               /* Add space for the snap enties in the CV table. */
               if (status==SUCCESS)
                  blues->align.cvt = (USHORT)(blues->align.cvt +
                                             t1m->snapv_cnt);

               /**** /StemSnapH [118 120] def ****/
            } else if (!strcmp(str, PS_SNAPH)) {
               status = ReadArray(t1, str, BUFLEN,
                                  &t1m->stemsnaph[0],
                                  MAXSNAP, &t1m->snaph_cnt);

               /* Add space for the snap enties in the CV table. */
               if (status==SUCCESS)
                  blues->align.cvt = (USHORT)(blues->align.cvt +
                                              t1m->snaph_cnt);

               /**** /BlueValues [-15 0] def ****/
            } else if (!strcmp(str, PS_BLUEVALUES)) {
               status = ReadArray(t1, str, BUFLEN,
                                  &(blues->bluevalues[0]),
                                  MAXBLUE, &(blues->blue_cnt));
               if (blues->blue_cnt%2)
                  SetError(status = BADINPUTFILE);

               /**** /OtherBlues [-15 0] def ****/
            } else if (!strcmp(str, PS_OTHERBLUES)) {
               status = ReadArray(t1, str, BUFLEN,
                                  &(blues->otherblues[0]),
                                  MAXBLUE, &(blues->oblue_cnt));
               if (blues->oblue_cnt%2)
                  SetError(status = BADINPUTFILE);

               /**** /FamilyBlues [-15 0] def ****/
            } else if (!strcmp(str, PS_FAMILYBLUES)) {
               status = ReadArray(t1, str, BUFLEN,
                                  &(blues->familyblues[0]),
                                  MAXBLUE, &(blues->fblue_cnt));

               /**** /FamilyOtherBlues [-15 0] def ****/
            } else if (!strcmp(str, PS_FAMILYOTHERBLUES)) {
               status = ReadArray(t1, str, BUFLEN,
                                  &(blues->familyotherblues[0]),
                                  MAXBLUE, &(blues->foblue_cnt));

               /**** /CharString ... */
            } else if (!strcmp(str, PS_CHARSTRINGS)) {
               break;

               /**** /FontMatrix [0 0.001 0 0.001 0] def ****/
            } else if (GetFontMatrix(t1m)==NULL &&
                       !strcmp(str, PS_FONTMATRIX)) {
               status = ReadFontMatrix(t1, str, BUFLEN);
            } else if (!strcmp(str, PS_SUBRS)) {
               /* Discard prior lores /Subrs. */
               FlushWorkspace(t1);

               /* Read new subrs. */
               status = ReadFontSubrs(t1,str, BUFLEN);

               /**** /lenIV 4 def ****/
            } else if (!strcmp(str, PS_LENIV)) {
               if (Get_Token(t1->ff, str, BUFLEN)) {
                  t1->leniv = (USHORT)atoi(str);
                  status = SUCCESS;
               } else {
                  status = BADINPUTFILE;
               }
            } else if (t1m->date==NULL && !strcmp(str, PS_DATE)) {
               if ((GetNewLine(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->date=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->copyright==NULL &&
                       !strcmp(str, PS_COPYRIGHT)) {
               if ((GetSeq(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->copyright=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->name==NULL && !strcmp(str, PS_NAME)) {
               if ((Get_Token(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->name=Strdup(&str[1]))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->id==NULL && !strcmp(str, PS_ID)) {
               if ((Get_Token(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->id=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->version.ver==0 && !strcmp(str, PS_VERSION)) {
               if ((GetSeq(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else {
                  t1m->version.ver = (USHORT)atoi(str);
                  if (strchr(str, '.'))
                     t1m->version.rev = (USHORT)atoi(strchr(str, '.')+1);
                  else
                     t1m->version.rev = 0;
               }
            } else if (t1m->notice==NULL && !strcmp(str, PS_NOTICE)) {
               if ((GetSeq(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->notice=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->fullname==NULL && !strcmp(str, PS_FULLNAME)) {
               if ((GetSeq(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->fullname=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->family==NULL && !strcmp(str, PS_FAMILY)) {
               if ((GetSeq(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->family=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->weight==NULL && !strcmp(str, PS_WEIGHT)) {
               if ((GetSeq(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else if ((t1m->weight=Strdup(str))==NULL) {
                  SetError(status = NOMEM);
               }
            } else if (t1m->angle==0 && !strcmp(str, PS_ANGLE)) {
               if ((Get_Token(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else 
                  t1m->angle = StrToFix(str, NULL, F16D16BASE);
            } else if (t1m->underline==0 && !strcmp(str, PS_UNDERLINE)) {
               if ((Get_Token(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else
                  t1m->underline = (funit)StrToFix(str, NULL, 1L);
            } else if (t1m->uthick==0 && !strcmp(str, PS_UTHICK)) {
               if ((Get_Token(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else
                  t1m->uthick = (funit)StrToFix(str, NULL, 1L);
            } else if (!strcmp(str, PS_ISFIXED)) {
               if ((Get_Token(t1->ff, str, BUFLEN))==NULL) {
                  SetError(status = BADINPUTFILE);
               } else
                  if (!strcmp(str, "true") ||
                      !strcmp(str, "True") ||
                      !strcmp(str, "TRUE"))
                     t1m->fixedPitch = TRUE;
            } else if (!strcmp(str, PS_HYBRID)) {
               hybrid = TRUE;
            }
         }

         /* Change the baseline zone into an OtherBlues[] zone. */
         if (blues->blue_cnt) {
            blues->otherblues[blues->oblue_cnt++] = blues->bluevalues[0];
            blues->otherblues[blues->oblue_cnt++] = blues->bluevalues[1];
            for (i=2; i<blues->blue_cnt; i++)
               blues->bluevalues[i-2] = blues->bluevalues[i];
            blues->blue_cnt -= 2;
         }
         if (blues->fblue_cnt) {
            blues->familyotherblues[blues->foblue_cnt++]
                  = blues->familyblues[0];
            blues->familyotherblues[blues->foblue_cnt++]
                  = blues->familyblues[1];
            for (i=2; i<blues->fblue_cnt; i++)
               blues->familyblues[i-2] = blues->familyblues[i];
            blues->fblue_cnt -= 2;
         }

         /* Allocate the space for the blue buckets. */
         for (i=0; i<blues->blue_cnt; i+=2) {
            USHORT size = (USHORT)((ABS(blues->bluevalues[i+1] -
                                        blues->bluevalues[i]) +
                                    1 + 2*blues->blueFuzz)*
                                   (USHORT)sizeof(struct CVTPos));
            if ((blues->align.top[i/2].pos = Malloc(size))==NULL) {
               SetError(status = NOMEM);
               break;
            }

            /* Make sure that first value is larger than second value. */
            if (blues->bluevalues[i] > blues->bluevalues[i+1]) {
               LogError(MSG_WARNING, MSG_INVBLUES, NULL);
               SWAPINT(blues->bluevalues[i], blues->bluevalues[i+1]);
            }
         }
         for (i=0; i<blues->oblue_cnt; i+=2) {
            USHORT size = (USHORT)((ABS(blues->otherblues[i+1] -
                                        blues->otherblues[i]) +
                                    1 + 2*blues->blueFuzz)*
                                   (USHORT)sizeof(struct CVTPos));
            if ((blues->align.bottom[i/2].pos = Malloc(size))==NULL) {
               SetError(status = NOMEM);
               break;
            }

            /* Make sure that first value is larger than second value. */
            if (blues->otherblues[i] > blues->otherblues[i+1]) {
               LogError(MSG_WARNING, MSG_INVBLUES, NULL);
               SWAPINT(blues->otherblues[i], blues->otherblues[i+1]);
            }
         }


         /* Advance to the first glyph. */
         if (status==SUCCESS) {
            while (Get_Token(t1->ff, str, BUFLEN) &&
                   strcmp(str, PS_BEGIN));

            if (strcmp(str, PS_BEGIN)) {
               SetError(status = BADT1HEADER);
            }

            /* Skip lores chars if hybrid font. */
            if (status==SUCCESS && hybrid) {
               USHORT count;

               /* Skip Charstring dictionary. */
               do {
                  /* Glyph name, or end. */
                  if (Get_Token(t1->ff, str, BUFLEN)==NULL) {
                     SetError(status = BADINPUTFILE);
                     break;
                  }
                  if (!strcmp(str, PS_END))
                     break;

                  /* Charstring length. */
                  if (Get_Token(t1->ff, str, BUFLEN)==NULL) {
                     SetError(status = BADINPUTFILE);
                     break;
                  }
                  count = (USHORT)(atoi(str)+1);

                  /* Delimiter. */
                  if (Get_Token(t1->ff, str, BUFLEN)==NULL) {
                     SetError(status = BADINPUTFILE);
                     break;
                  }

                  /* Charstring */
                  for (i=0; i<count; i++)
                     (void)GetByte(t1->ff);

                  /* Delimiter */
                  if (Get_Token(t1->ff, str, BUFLEN)==NULL) {
                     SetError(status = BADINPUTFILE);
                     break;
                  }
               } while (status==SUCCESS);

               /* Skip to the beginning of next charstring. */
               while (Get_Token(t1->ff, str, BUFLEN) &&
                      strcmp(str, PS_BEGIN));

               if (strcmp(str, PS_BEGIN)) {
                  SetError(status = BADT1HYBRID);
               }
            }
         }
      }
   }

   if ((status==SUCCESS) && t1m && check(t1m->name,
                                         t1m->copyright,
                                         t1m->notice)!=SUCCESS)
      status = NOCOPYRIGHT;

   return status;
}



/***
** Function: GetT1Glyph
**
** Description:
**   The current file position of the T1 font file must be
**   at the begining of an entry in the /CharStrings dictionary.
**   The function will decode the font commands, parse them, and
**   finally build a representation of the glyph.
***/
errcode GetT1Glyph(struct T1Handle *t1,
                   struct T1Glyph *glyph,
                   const struct GlyphFilter *filter)
{
   errcode status = SUCCESS;
   /* struct encoding *enc; */
   char  str[BUFLEN];
   UBYTE *code;
   USHORT len;
   USHORT i;
   USHORT r = 4330;   
   short b;

   /* Get glyph name or end. */
   if (Get_Token(t1->ff, str, BUFLEN)==NULL) {
      SetError(status = BADINPUTFILE);
   } else if (!strcmp(str, PS_END)) {
      status = DONE;
   } else if (str[0]!='/') {
      SetError(status = BADCHARSTRING);
   } else {
      if ((glyph->name = Strdup(&str[1]))==NULL) {
         SetError(status = NOMEM);
      }
	  else if (Get_Token(t1->ff, str, BUFLEN)==NULL || 
		  (len = (USHORT)atoi(str))==0) /* Get length of charstring. */
	  {
			SetError(status = BADINPUTFILE);
	  }
	  else {
         /* Get RD + space */
         (void)Get_Token(t1->ff, str, BUFLEN);         (void)GetByte(t1->ff);

         /* Get commands. */
         if (len<BUFLEN)
            code = (UBYTE *)str;
         else
            if ((code = Malloc(len*sizeof(UBYTE)))==NULL) {
               SetError(status = NOMEM);
            }

         if (code) {
            for (i=0; i<len; i++) {
               b = GetByte(t1->ff);
               code[i] = (UBYTE)Decrypt(&r, (UBYTE)b);
            }

            /* Parse commands. */
            if (status==SUCCESS) {
               if (t1->t1m.encoding!=NULL ||
                   UseGlyph(filter, t1->t1m.seac, glyph->name)) {
                  InitPS(t1->ps);
                  status = ParseCharString(glyph,
                                           &t1->t1m.seac,
                                           t1->ps,
                                           t1->subrs,
                                           &code[t1->leniv],
                                           (USHORT)(len-t1->leniv));

                  /* Skip normal conversion for the ".notdef" glyph. */
                  if (!strcmp(glyph->name, ".notdef"))
                     status = SKIP;

               } else {
                  status = SKIP;

               /***

               Two approaches are implemented for the management of
               composite glyphs:

               1) It is up to the client to specify a GlyphFilter such
               that all 'seac' characters has their dependent base and
               accent character in the filter as well.

               2) The converter manages a list of the dependent characters,
               which are converted when found.

               Approach 2) will typically cause the converter to use more
               memory than what is available in the small memory model,
               which is why the default is to disabled it.

               ***/


#if 0

                  /* Record StandardEncoding glyphs, for 'seac' */
                  if ((enc = LookupPSName(t1->t1m.encoding,
                                          t1->t1m.encSize,
                                          glyph->name)) &&
                      (i = LookupCharCode(enc, ENC_STANDARD))!=0) {
                     if ((t1->stdenc[i].code
                          = Malloc(len-t1->leniv))==NULL) {
                        SetError(status = NOMEM);
                     } else {
                        memcpy(t1->stdenc[i].code,
                               &code[t1->leniv],
                               sizeof(UBYTE) * (len - t1->leniv));
                        t1->stdenc[i].len = len - t1->leniv;
                     }
                  }
#endif
               }

               if (code!=(UBYTE *)str)
                  Free(code);

               /* Get ND */
               (void)Get_Token(t1->ff, str, BUFLEN);
            }
         }
      }
   }


   return status;
}



/***
** Function: FreeT1Glyph
**
** Description:
**   This function frees the memory used to represent
**   a glyph that has been translated.
***/
void FreeT1Glyph(T1Glyph *glyph)
{
   Flex *flex;
   Stem *stem;
   Stem3 *stem3;


   if (glyph->name)
      Free(glyph->name);
   while (glyph->hints.vstems) {
      stem = glyph->hints.vstems->next;
      Free(glyph->hints.vstems);
      glyph->hints.vstems = stem;
   }
   while (glyph->hints.hstems) {
      stem = glyph->hints.hstems->next;
      Free(glyph->hints.hstems);
      glyph->hints.hstems = stem;
   }
   while (glyph->hints.vstems3) {
      stem3 = glyph->hints.vstems3->next;
      Free(glyph->hints.vstems3);
      glyph->hints.vstems3 = stem3;
   }
   while (glyph->hints.hstems3) {
      stem3 = glyph->hints.hstems3->next;
      Free(glyph->hints.hstems3);
      glyph->hints.hstems3 = stem3;
   }
   while (glyph->hints.flex) {
      flex = glyph->hints.flex->next;
      Free(glyph->hints.flex);
      glyph->hints.flex = flex;
   }
   while (glyph->paths) {
      Outline *path = glyph->paths;
      glyph->paths = path->next;
      if (path->count) {
         Free(path->onoff);
         Free(path->pts);
      }
      Free(path);
   }
   memset((void *)glyph, '\0', sizeof(T1Glyph));
}



/***
** Function: GetT1Composite
**
** Description:
**   This function unlinks the first composite glyph
**   from the list of recorded composite glyphs, which
**   is returned to the caller.
***/
struct Composite  *GetT1Composite(struct T1Handle *t1)
{
   struct Composite *comp;

   comp = t1->t1m.seac;
   if (comp) {
      t1->t1m.seac = comp->next;
      comp->next = t1->t1m.used_seac;
      t1->t1m.used_seac = comp;
   }

   return comp;
}



/***
** Function: GetT1BaseGlyph
**
** Description:
**   This function parses the charstring code associated to the
**   base character of a composite character, if that glyph
**   is not already converted.
***/
errcode GetT1BaseGlyph(struct T1Handle *t1,
                       const struct Composite *comp,
                       struct T1Glyph *glyph)
{
   struct encoding *enc;
   struct Subrs *subr;
   errcode status = SUCCESS;

   if ((enc = LookupPSName(t1->t1m.encoding,
                           t1->t1m.encSize,
                           comp->bchar))==NULL) {
       LogError(MSG_WARNING, MSG_BADENC, comp->bchar);
       return SKIP;
   }

   subr = &t1->stdenc[LookupCharCode(enc, ENC_STANDARD)];

   if (subr->len==0) {
      status = SKIP; /* Missing or already done. */
   } else {
      InitPS(t1->ps);
      if ((glyph->name = Strdup((char*)comp->achar))==NULL) {
         SetError(status = NOMEM);
      } else {
         status = ParseCharString(glyph,
                                  &t1->t1m.seac,
                                  t1->ps,
                                  t1->subrs,
                                  subr->code,
                                  subr->len);
      }
      Free(subr->code);
      subr->code = NULL;
      subr->len = 0;
   }
   return status;
}



/***
** Function: GetT1AccentGlyph
**
** Description:
**   This function parses the charstring code associated to the
**   accent character of a composite character, if that glyph
**   is not already converted.
***/
errcode GetT1AccentGlyph(struct T1Handle *t1,
                         const struct Composite *comp,
                         struct T1Glyph *glyph)
{
   struct encoding *enc;
   struct Subrs *subr;
   errcode status = SUCCESS;

   if ((enc = LookupPSName(t1->t1m.encoding,
                           t1->t1m.encSize,
                           comp->achar))==NULL) {
       LogError(MSG_WARNING, MSG_BADENC, comp->achar);
       return SKIP;
   }

   subr = &t1->stdenc[LookupCharCode(enc, ENC_STANDARD)];

   if (subr->len==0) {
      status = SKIP; /* Missing or already done. */
   } else {
      InitPS(t1->ps);
      if ((glyph->name = Strdup((char *)comp->achar))==NULL) {
         SetError(status = NOMEM);
      } else {
         status = ParseCharString(glyph,
                                  &t1->t1m.seac,
                                  t1->ps,
                                  t1->subrs,
                                  subr->code,
                                  subr->len);
      }
      Free(subr->code);
      subr->code = NULL;
      subr->len = 0;
   }
   return status;
}



/***
** Function: ReadOtherMetrics
**
** Description:
**   Return font level information about the T1 font (mostly
**   metrics).
***/
errcode ReadOtherMetrics(struct T1Metrics *t1m,
                         const char *metrics)
{
   errcode status = SUCCESS;

   if ((status = ReadFontMetrics(metrics, t1m))==NOMETRICS) {
      t1m->flags = DEFAULTMETRICS;
      status = SUCCESS;
   } else {
      t1m->flags = USEMETRICS;
   }

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\t1parser.h ===
/***
**
**   Module: T1Parser
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      will extract information from a T1 font file, by parsing
**      the data/commands found in PFB, PFM and AFM files.
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif



struct T1Arg;
struct T1Info;
struct T1Glyph;
struct T1Handle;
struct T1Metrics;
struct Composite;
struct GlyphFilter;



/***
** Function: InitT1Input
**
** Description:
**   Allocate and initiate a handle for a T1 font file, including
**   extracting data from the font prolog that is needed to
**   read the glyphs, such as /FontMatrix, /Subrs and /lenIV.
***/
errcode           InitT1Input       _ARGS((IN      struct T1Arg *,
                                           OUT     struct T1Handle **,
                                           OUT     struct T1Metrics **,
                                           IN      short (*cb)(IN char *,
                                                               IN char *,
                                                               IN char *)));
/***
** Function: CleanUpT1
**
** Description:
**   Free the resources allocated for the T1 handle.
***/
errcode           CleanUpT1         _ARGS((INOUT   struct T1Handle *));


/***
** Function: ReadOtherMetrics
**
** Description:
**   Return font level information about the T1 font (mostly
**   metrics).
***/
errcode           ReadOtherMetrics  _ARGS((INOUT   struct T1Metrics *,
                                           IN      char *metrics));

/***
** Function: GetT1Glyph
**
** Description:
**   The current file position of the T1 font file must be
**   at the begining of an entry in the /CharStrings dictionary.
**   The function will decode the font commands, parse them, and
**   finally build a representation of the glyph.
***/
errcode           GetT1Glyph        _ARGS((INOUT   struct T1Handle *,
                                           OUT     struct T1Glyph *,
                                           IN      struct GlyphFilter *));
/***
** Function: FreeT1Glyph
**
** Description:
**   This function frees the memory used to represent
**   a glyph that has been translated.
***/
void              FreeT1Glyph       _ARGS((INOUT   struct T1Glyph *));


/***
** Function: GetT1Composite
**
** Description:
**   This function unlinks the first composite glyph
**   from the list of recorded composite glyphs, which
**   is returned to the caller.
***/
struct Composite  *GetT1Composite   _ARGS((INOUT   struct T1Handle *));


/***
** Function: GetT1AccentGlyph
**
** Description:
**   This function parses the charstring code associated to the
**   accent character of a composite character, if that glyph
**   is not already converted.
***/
errcode           GetT1AccentGlyph  _ARGS((INOUT   struct T1Handle *,
                                           IN      struct Composite *,
                                           OUT     struct T1Glyph *));
/***
** Function: GetT1BaseGlyph
**
** Description:
**   This function parses the charstring code associated to the
**   base character of a composite character, if that glyph
**   is not already converted.
***/
errcode           GetT1BaseGlyph    _ARGS((INOUT   struct T1Handle *,
                                           IN      struct Composite *,
                                           OUT     struct T1Glyph *));
/***
** Function: FlushWorkspace
**
** Description:
**   Free the resources allocated for the T1 handle.
***/
void              FlushWorkspace    _ARGS((INOUT   struct T1Handle *t1));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\trans.c ===
/***
**
**   Module: Trans
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      contains functions that will convert T1 specific data into
**      corresponding TT data, such as hints and font metrics.
**
**   Author: Michael Jansson
**
**   Created: 5/28/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <string.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"
#include "safemem.h"
#include "trig.h"
#include "metrics.h"
#include "encoding.h"
#include "builder.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
#include "trans.h"
#include "hints.h"


/***** CONSTANTS */

/* PitchAndFamily pitch values (low 4 bits) */
#define DEFAULT_PITCH       0x00
#define FIXED_PITCH         0x01
#define VARIABLE_PITCH      0x02

/* PitchAndFamily family values (high 4 bits) */
#define FF_DONTCARE         0x00
#define FF_ROMAN            0x10
#define FF_SWISS            0x20
#define FF_MODERN           0x30
#define FF_SCRIPT           0x40
#define FF_DECORATIVE       0x50

#define SWISS_LEADING       0x21
#define ROMAN_LEADING       0x11

#define NOCARE_PANOSE   0
#define NO_PANOSE       1
#define COVE_PANOSE     2
#define TEXT_PANOSE     2
#define DECORATIVE_PANOSE 4
#define SCRIPT_PANOSE   3
#define SANS_PANOSE     11
#define FIXED_PANOSE    9



#define BUFMARG      64
#define CLIMIT    8
#define CLIMIT2      4

#define SUBDIVIDE 0
#define CONVERT      1

#define FW_THIN         100
#define FW_EXTRALIGHT   200
#define FW_LIGHT  300
#define FW_NORMAL 400
#define FW_MEDIUM 500
#define FW_SEMIBOLD     600
#define FW_BOLD         700
#define FW_BLACK  900

#define FWIDTH_ULTRA_CONDENSED   1
#define FWIDTH_EXTRA_CONDENSED   2
#define FWIDTH_CONDENSED         3
#define FWIDTH_SEMI_CONDENSED    4
#define FWIDTH_NORMAL            5
#define FWIDTH_SEMI_EXPANDED     6
#define FWIDTH_EXPANDED          7
#define FWIDTH_EXTRA_EXPANDED    8
#define FWIDTH_ULTRA_EXPANDED    9

#define MAC_ITALIC   0x01
#define MAC_BOLD  0x02

#define FS_ITALIC 0x01
#define FS_BOLD      0x20
#define FS_NORMAL 0x40

#define CVTSIZE     5


/***** LOCAL TYPES */
/* None */


/***** MACROS */
#define ATMSCALE(v)  (((v)*31)/32)
#define IP(v,x1,x2,x1p,x2p)   /*lint -e776 */(short)((long)(v-x1)*(long)(x2p-x1p)/(long)(x2-x1)+(long)x1p)/*lint +e776*/

#define ADDCVT(val)   ttm->cvt[ttm->cvt_cnt++] = (short)(val)

#define SGN(v)   ((v)>0 ? 1 : -1)
#define DIR(v,w)  (char)((ABS((v)-(w))<16) ? 0 : SGN((w) - (v)))


/***** PROTOTYPES */
static USHORT SplitSpline(Point *pts, ULONG *onoff,
                          int i, USHORT length,
                          const funit x0, const funit y0,
                          const funit x1, const funit y1, 
                          const funit x2, const funit y2, 
                          const funit x3, const funit y3,
                          const int delta);


/***** STATIC FUNCTIONS */

/***
** Function: LookupComposite
**
** Description:
**   
***/
static struct encoding *LookupComposite(struct Composite *comp, char *name)
{
   while (comp) {
      if (comp->oenc && !strcmp(LookupCharName(comp->oenc), name))
         return comp->oenc;
      comp=comp->next;
   }

   return NULL;
}



/***
** Function: norm
**
** Description:
**   Normalize an angle so that it falls within the
**   range ~[-pi, pi]
***/
static int norm(int a)
{
   if (a>PI)
      a -= 2*PI;
   if (a<-PI)
      a += 2*PI;

   return ABS(a)/16;
}


/***
** Function: CompareCurves
**
** Description:
**   Make a estimate of the error between a cubic
**   and a quadric curve, given four control points,
**   and suggest an action (sub-division or convertion).
***/
static boolean FASTCALL CompareCurves(const funit x0, const funit y0,
                                      const funit x1, const funit y1, 
                                      const funit x2, const funit y2, 
                                      const funit x3, const funit y3,
                                      const funit nx, const funit ny,
                                      const int delta)
{
   int a, b;



   if ((ABS(ny-y0)>CLIMIT || ABS(nx-x0)>CLIMIT) &&
       (ABS(ny-y3)>CLIMIT || ABS(nx-x3)>CLIMIT)) {

      if (y0!=y1 || x0!=x1)
         a = norm(Atan2(ny-y0, nx-x0) - Atan2(y1-y0, x1-x0))
             * (ABS(ny-y0) + ABS(nx-x0));
      else if (y0!=y2 || x2!=x0)
         a = norm(Atan2(ny-y0, nx-x0) - Atan2(y2-y0, x2-x0))
             * (ABS(ny-y0) + ABS(nx-x0));
      else
         a = 0;

      if (a>=delta)
         return SUBDIVIDE;



      if (y2!=y3 || x2!=x3)
         b = norm(Atan2(y3-ny, x3-nx) - Atan2(y3-y2, x3-x2))
             * (ABS(ny-y0) + ABS(nx-x0));
      else if (y1!=y3 || x1!=x3)
         b = norm(Atan2(y3-ny, x3-nx) - Atan2(y3-y1, x3-x1))
             * (ABS(ny-y0) + ABS(nx-x0));
      else
         b = 0;


      if (b>=delta)    /* angle too big. */
         return SUBDIVIDE;
   }

   return CONVERT;
}



/***
** Function: ConvertSpline
**
** Description:
**   This function adds a spline to the current contour, by first
**   converting it from a cubic to a quadric spline.
***/
static USHORT ConvertSpline(Point *pts, ULONG *onoff,
                            USHORT length, int i,
                            const funit x0, const funit y0,
                            const funit x1, const funit y1, 
                            const funit x2, const funit y2, 
                            const funit x3, const funit y3,
                            const int delta)
{
   funit nx, ny;
   int oi = i;
   USHORT n = 0;

   ny = (funit)(((-y0+y1+y2+((y1+y2)<<1)-y3 + 4002)/4) - (short)1000);
   nx = (funit)(((-x0+x1+x2+((x1+x2)<<1)-x3 + 4002)/4) - (short)1000);
   if (CompareCurves(x0, y0,
                     x1, y1,
                     x2, y2,
                     x3, y3,
                     nx, ny, delta)==SUBDIVIDE) {
      n = SplitSpline(pts, onoff, i, length,
                      x0, y0, x1, y1, x2, y2, x3, y3, delta);
   } else /* CONVERT */ {
      if (i>1 && !OnCurve(onoff, i-2) &&
          (short)(pts[i-1].x >= pts[i-2].x) != (short)(pts[i-1].x >= nx) &&
          (short)(pts[i-1].y >= pts[i-2].y) != (short)(pts[i-1].y >= ny) &&
          (short)(pts[i-1].x >  pts[i-2].x) != (short)(pts[i-1].x > nx) &&
          (short)(pts[i-1].y >  pts[i-2].y) != (short)(pts[i-1].y > ny) &&
          ABS(pts[i-1].x - (nx+pts[i-2].x)/2)<CLIMIT2 && 
          ABS(pts[i-1].y - (ny+pts[i-2].y)/2)<CLIMIT2) {
      }
      SetOffPoint(onoff, i);
      pts[i].y = ny;
      pts[i].x = nx;
      i++;
      SetOnPoint(onoff, i);
      pts[i].y = y3;
      pts[i].x = x3;
      i++;

      n = (USHORT)(i-oi);
   }

   return n;
}



/***
** Function: SplitSpline
**
** Description:
**   This function converts a cubic spline by first
**   creating two new cubic splines, using de Casteljau's
**   algorithm, and then adding the two new splines to the
**   current path.
***/
static USHORT SplitSpline(Point *pts, ULONG *onoff,
                          int i, USHORT length,
                          const funit x0, const funit y0,
                          const funit x1, const funit y1, 
                          const funit x2, const funit y2, 
                          const funit x3, const funit y3,
                          const int delta)
{
   funit xt, yt;
   funit nx1, ny1;
   funit nx2, ny2;
   funit nx3, ny3;
   funit nx4, ny4;
   funit nx5, ny5;
   USHORT cnt;

   xt = (funit)(((x1+x2+8001)/2)-4000);
   yt = (funit)(((y1+y2+8001)/2)-4000);
   nx1 = (funit)(((x0+x1+8001)/2)-4000);
   ny1 = (funit)(((y0+y1+8001)/2)-4000);
   nx2 = (funit)(((nx1+xt+8001)/2)-4000);
   ny2 = (funit)(((ny1+yt+8001)/2)-4000);
   nx5 = (funit)(((x2+x3+8001)/2)-4000);
   ny5 = (funit)(((y2+y3+8001)/2)-4000);
   nx4 = (funit)(((nx5+xt+8001)/2)-4000);
   ny4 = (funit)(((ny5+yt+8001)/2)-4000);
   nx3 = (funit)(((nx2+nx4+8001)/2)-4000);
   ny3 = (funit)(((ny2+ny4+8001)/2)-4000);

   cnt = ConvertSpline(pts, onoff, length, i,
                       x0, y0,
                       (funit)nx1, (funit)ny1,
                       (funit)nx2, (funit)ny2,
                       (funit)nx3, (funit)ny3,
                       delta);
   cnt = (USHORT)(cnt + ConvertSpline(pts, onoff, length, i+cnt,
                                      (funit)nx3, (funit)ny3,
                                      (funit)nx4, (funit)ny4,
                                      (funit)nx5, (funit)ny5,
                                      x3, y3,
                                      delta));

   return cnt;
}




/***
** Function: FreeOutline
**
** Description:
**   This function frees the memory allocated for one 
**   contour.
**   
***/
static void FreeOutline(Outline *path)
{
   Outline *tmp;

   while (path) {
      tmp = path;
      path=path->next;
      Free(tmp->pts);
      Free(tmp->onoff);
      Free(tmp);
   }
}



/***
** Function: ConvertOutline
**
** Description:
**   This function converts an outline by replacing the
**   cubic splines with quadric splines, and by scaling the
**   coordinates to the desired em-height.
**   
***/
static errcode ConvertOutline(const struct T1Metrics *t1m,
                              Outline *src, Outline **dst,
                              const int delta,
                              short *sideboard)
{
   errcode status = SUCCESS;
   f16d16 *fmatrix;
   Outline *path;
   ULONG *onoff = NULL;
   Point *pts = NULL;
   USHORT count;
   USHORT i,j,n;
   USHORT tot = 0;
   USHORT t1tot = 0;


   /* Get the T1 font transformation matrix. */
   fmatrix = GetFontMatrix(t1m);

   while (src) {

      /* Skip paths with less than three points. */
      if (src->count<3) {
         t1tot = (USHORT)(t1tot + src->count);
         src = src->next;
         continue;
      }

      /* Allocate the needed resources */
      count = (USHORT)((src->count+BUFMARG)&~0x0f);
      path = Malloc(sizeof(Outline));
      pts = Malloc(count*sizeof(Point));
      onoff = Malloc(ONOFFSIZE(count));
      if (path==NULL || pts==NULL || onoff==NULL) {
         if (path)
            Free(path);
         if (pts)
            Free(pts);
         if (onoff)
            Free(onoff);
         FreeOutline((*dst));
         (*dst) = NULL;
         SetError(status = NOMEM);
         break;
      }
      memset(onoff, '\0', ONOFFSIZE(count));

      /* Convert the splines. */ /*lint -e771 */
      i=0;
      j=0;
      while (i<src->count) {
         char prev = DIR(src->pts[(i-2+src->count)%src->count].y,
                         src->pts[(i-1+src->count)%src->count].y);
         char this = DIR(src->pts[(i-1+src->count)%src->count].y,
                         src->pts[i].y);

         /* Double the local extremas so that diag-cntrl will work. */
         if (prev && this && prev!=this)
            pts[j++] = src->pts[(i-1+src->count)%src->count];

         if (OnCurve(src->onoff, i)) {
            pts[j++] = src->pts[i++];
         } else {
            /* pts[j] = pts[j-1]; j++; */
            n = ConvertSpline(pts, onoff, count, (int)j,
                              src->pts[i-1].x, src->pts[i-1].y,
                              src->pts[i-0].x, src->pts[i-0].y,
                              src->pts[i+1].x, src->pts[i+1].y,
                              src->pts[i+2].x, src->pts[i+2].y,
                              delta);

            /* Enforce horizontal and vertical tangents. */
            if (OnCurve(onoff, j-1)) {
               if (src->pts[i-1].x==src->pts[i-0].x)
                  pts[j].x = (funit)((pts[j].x + pts[j-1].x)/2);
               if (src->pts[i-1].y==src->pts[i-0].y)
                  pts[j].y = (funit)((pts[j].y + pts[j-1].y)/2);
            }
            if (src->pts[i+1].x==src->pts[i+2].x)
               pts[j+n-2].x = (funit)((pts[j+n-1].x + pts[j+n-2].x)/2);
            if (src->pts[i+1].y==src->pts[i+2].y)
               pts[j+n-2].y = (funit)((pts[j+n-2].y + pts[j+n-1].y)/2);

            j = (USHORT)(j + n);
            i += 3;
         }

         /* Both a line and a curve end with an on-curve point. */
         sideboard[t1tot+i-1] = (short)(j-1+tot);

         /* Extend the pts/onoff arrays. */
         if (j+BUFMARG/2>=count) {
            Point *newpts = NULL;
            ULONG *newonoff = NULL;

            count += BUFMARG;
            newpts = Realloc(pts, count*sizeof(Point));
            newonoff = Realloc(onoff, ONOFFSIZE(count));
            if (newpts==NULL || newonoff==NULL) {
               if (newonoff)
                  Free(newonoff);
               if (newpts)
                  Free(newpts);
               /*lint -e644 */
               if (onoff)
                  Free(onoff);
               if (pts)
                  Free(pts);
               /*lint +e644 */
               FreeOutline((*dst));
               (*dst) = NULL;
               SetError(status=NOMEM);
               break;
            }
            pts = newpts;
            onoff = newonoff;
         }
      }

      if (status!=SUCCESS)
         break;

      /* Scale the points. */
      TransAllPoints(t1m, pts, j, fmatrix);

      t1tot = (USHORT)(t1tot + src->count);
      src = src->next;

      (*dst) = path;
      path->next = NULL;
      path->pts = pts;
      path->onoff = onoff;
      path->count = (USHORT)j;  /*lint +e771 */
      dst = &(path->next);

      tot = (USHORT)(tot + j);
   }

   return status;
}

#ifdef MSDOS
#pragma auto_inline(off)
#endif
static long Mul2(long a, long b, long c, long d)
{
   return a*b+c*d;
}
#ifdef MSDOS
#pragma auto_inline(on)
#endif


/***** FUNCTIONS */

/***
** Function: TransAllPoints
**
** Description:
**   Translate a coordinate according to a transformation matrix.
***/
void FASTCALL TransAllPoints(const struct T1Metrics *t1m,
                             Point *pts,
                             const USHORT cnt,
                             const f16d16 *fmatrix)
{
   if (fmatrix==NULL) {
      register Point *p;
      register int i;

      i = cnt;
      p = pts;
      while (i--) {
         p->x = (funit)((p->x<<1)+(((p->x<<1)+
                                    p->x+(p->x/16)+
                                    8224)/64) - 128);
         p++;
      }
      i = cnt;
      p = pts;
      while (i--) {
         p->y = (funit)((p->y<<1)+(((p->y<<1)+
                                    p->y+
                                    (p->y/16)+
                                    8224)/64) - 128);
         p++;
      }

   } else {
      Point *p;
      int i;
      long u,v;

      i = cnt;
      p = pts;
      while (i--) {
         v = (GetUPEM(t1m) * (Mul2(fmatrix[0], (long)p->x,
                                   fmatrix[2], (long)p->y) +
                              fmatrix[4]) + F16D16HALF) / 524288L;
         u = (GetUPEM(t1m) * (Mul2(fmatrix[1], (long)p->x,
                                   fmatrix[3], (long)p->y) +
                              fmatrix[5]) + F16D16HALF) / 524288L;
         p->x = (funit)v;
         p->y = (funit)u;
         p++;
      }
   }
}



/***
** Function: TransX
**
** Description:
**   Translate a horizontal coordinate according to a transformation matrix.
***/
funit FASTCALL TransX(const struct T1Metrics *t1m, const funit x)
{
   f16d16 *fmatrix = GetFontMatrix(t1m);
   funit pos;

   if (fmatrix) {
      pos = (funit)((GetUPEM(t1m)* ATMSCALE(fmatrix[0] * x) +
                     F16D16HALF) / F16D16BASE);
   } else {
      pos = (funit)(((int)x<<1)-((((int)x+((int)x/64)+8224)/64) - 128));
   }

   return pos;
}


/***
** Function: TransY
**
** Description:
**   Translate a vertical coordinate according to a transformation matrix.
***/
funit FASTCALL TransY(const struct T1Metrics *t1m, const funit y)
{
   f16d16 *fmatrix = GetFontMatrix(t1m);
   funit pos;

   if (fmatrix) {
      pos = (funit)((GetUPEM(t1m)*fmatrix[3] * y +
                     F16D16HALF) / F16D16BASE);
   } else {
      pos = (funit)(((int)y<<1)+((((int)y<<1)+
                                  (int)y+
                                  ((int)y/16)+
                                  8224)/64) - 128);
   }

   return pos;
}


/***
** Function: ConvertGlyph
**
** Description:
**   This function convertes the data associated to a T1 font glyph
**   into the corresponding data used in a TT font glyph.
***/
errcode FASTCALL ConvertGlyph(struct T1Metrics *t1m,
                              const struct T1Glyph *t1glyph,
                              struct TTGlyph **ttglyph,
                              const int delta)
{
   errcode status = SUCCESS;
   struct encoding *code;

   if ((code = LookupPSName(CurrentEncoding(t1m),
                            EncodingSize(t1m),
                            t1glyph->name))==NULL &&
       (code = LookupComposite(Composites(t1m), t1glyph->name))==NULL &&
       strcmp(t1glyph->name, ".notdef")) {
      LogError(MSG_INFO, MSG_BADENC, t1glyph->name);
      status = SUCCESS;
   } else {

      if (((*ttglyph) = Malloc(sizeof(struct TTGlyph)))==NULL) {
         SetError(status = NOMEM);
      } else {
         short *sideboard = NULL;
         Outline *path;
         USHORT tot;

         memset((*ttglyph), '\0', sizeof(struct TTGlyph));
         if (t1glyph->width.y!=0) {
            LogError(MSG_WARNING, MSG_BADAW, NULL);
         }
         (*ttglyph)->aw = TransY(t1m, t1glyph->width.x);
         (*ttglyph)->lsb = TransY(t1m, t1glyph->lsb.x);
         (*ttglyph)->code = code;
         (*ttglyph)->num = 0;
         (*ttglyph)->twilights = 0;

         /* Initiate the side board. */
         for (path=t1glyph->paths, tot=0; path; path=path->next)
            tot = (USHORT)(tot + path->count);
         if (tot && (sideboard = Malloc((unsigned)tot*sizeof(short)))==NULL) {
            SetError(status=NOMEM);
         } else if ((status = ConvertOutline(t1m, t1glyph->paths,
                                             &((*ttglyph)->paths),
                                             delta,
                                             sideboard))==SUCCESS)
            status = ConvertHints(t1m,
                                  &t1glyph->hints,
                                  t1glyph->paths,
                                  (*ttglyph)->paths,
                                  sideboard,
                                  &(*ttglyph)->hints,
                                  &(*ttglyph)->num,
                                  &(*ttglyph)->stack,
                                  &(*ttglyph)->twilights);

         if (sideboard)
            Free(sideboard);


         /* Pick default std widths. */
         if (t1glyph->name[0]=='l' && t1glyph->name[1]=='\0') {
            if (GetStdVW(t1m)==0 && t1glyph->hints.vstems)
               SetDefStdVW(t1m, t1glyph->hints.vstems->width);
         }
         if (t1glyph->name[0]=='z' && t1glyph->name[1]=='\0') {
            if (GetStdHW(t1m)==0) {
               if (t1glyph->hints.hstems && t1glyph->hints.hstems->width)
                  SetDefStdHW(t1m, t1glyph->hints.hstems->width);
               else if (t1glyph->hints.vstems && t1glyph->hints.vstems->width)
                  SetDefStdHW(t1m, t1glyph->hints.vstems->width);
            }
         }
      }
   } 

   return status;
}


/***
** Function: ConvertComposite
**
** Description:
**   This function convertes the data associated to a T1 font seac glyph
**   into the corresponding data used in a TT font composite glyph.
**
***/
errcode FASTCALL ConvertComposite(struct T1Metrics *t1m,
                                  const struct Composite *comp,
                                  struct TTComposite *ttcomp)
{
   Point pt;

   pt.x = comp->adx;
   pt.y = comp->ady;
   TransAllPoints(t1m, &pt, 1, GetFontMatrix(t1m));
   ttcomp->dx = pt.x + (pt.x - TransX(t1m, comp->adx));
   ttcomp->dy = pt.y;
   ttcomp->aw = TransY(t1m, comp->aw);
   ttcomp->lsb = TransY(t1m, comp->asbx);
   ttcomp->aenc = LookupPSName(CurrentEncoding(t1m),
                               EncodingSize(t1m), comp->achar);
   ttcomp->benc = LookupPSName(CurrentEncoding(t1m),
                               EncodingSize(t1m), comp->bchar);
   if ((ttcomp->cenc = LookupPSName(CurrentEncoding(t1m),
                                    EncodingSize(t1m), comp->cchar))==NULL) {
      LogError(MSG_INFO, MSG_BADENC, comp->cchar);
   }
   ttcomp->oenc = comp->oenc;

   if (ttcomp->aenc && ttcomp->benc)
      return SUCCESS;
   return SKIP;
}





/***
** Function: ConvertMetrics
**
** Description:
**
***/
errcode FASTCALL ConvertMetrics(const struct TTHandle *tt,
                                struct T1Metrics *t1m,
                                struct TTMetrics *ttm,
                                const char *tag)
{
   const AlignmentControl *align;
   const Blues *blues;
   USHORT prep_size;
   UBYTE *prep = NULL;
   errcode status = SUCCESS;
   Point bbox[2];
   funit em;
   funit PostAsc;
   USHORT i, j;


   ttm->Encoding = CurrentEncoding(t1m);
   ttm->encSize = EncodingSize(t1m);
   ttm->version.ver = t1m->version.ver;
   ttm->version.rev = t1m->version.rev;

   if ((ttm->verstr = Malloc(strlen(tag)+4+1+4+1))==NULL) {
      SetError(status = NOMEM);
   } else {
      strcpy(ttm->verstr, tag);
      (void)_itoa((int)ttm->version.ver, &ttm->verstr[strlen(ttm->verstr)], 4);
      strcat(ttm->verstr, ".");
      (void)_itoa((int)ttm->version.rev, &ttm->verstr[strlen(ttm->verstr)], 4);
      ttm->created.a = 0;
      ttm->created.b = 0;
      ttm->family = t1m->family;
      ttm->copyright = t1m->copyright;
      ttm->name = t1m->name;
      ttm->id = t1m->id;
      ttm->notice = t1m->notice;
      ttm->fullname = t1m->fullname;
      ttm->weight = t1m->weight;
      ttm->angle = t1m->angle;
      ttm->underline = TransY(t1m, t1m->underline);
      ttm->uthick = TransY(t1m, t1m->uthick);
      ttm->usWidthClass = (USHORT)(strstr(t1m->fullname, "Ultra-condensed")
                                   ? FWIDTH_ULTRA_CONDENSED :
         ((strstr(t1m->fullname, "Extra-condensed") ? FWIDTH_EXTRA_CONDENSED :
            ((strstr(t1m->fullname, "Condensed") ? FWIDTH_CONDENSED :
               ((strstr(t1m->fullname, "Semi-condensed") ? FWIDTH_SEMI_CONDENSED :
                  ((strstr(t1m->fullname, "Semi-expanded")
                    ? FWIDTH_SEMI_EXPANDED :
                     ((strstr(t1m->fullname, "Expanded")
                       ? FWIDTH_EXPANDED :
                        ((strstr(t1m->fullname, "Extra-expanded")
                          ? FWIDTH_EXTRA_EXPANDED :
                           ((strstr(t1m->fullname, "Ultra-expanded")
                             ? FWIDTH_ULTRA_EXPANDED :
                              FWIDTH_NORMAL)))))))))))))));


      /* Window based metrics. */

      // ps driver does not compute asc and desc based on the
      // windows charset. So, we will not do it either. We will
      // also use the all glyhs supported in the font.
      // Ps driver acutally trusts the values found in .pfm file.
      // These values, according to afm->pfm converter code, are computed
      // over all glyphs. However, some vendors ship buggy pfm's with
      // zero ascenders or negative descenders. If we took these values
      // literally, as ps driver does, the true type driver would
      // shave off portions of glyphs and the conversion would appear broken.
      // Pcl printing and screen output would be totally broken.
      // Turns out that for these buggy fonts ATM on win31 also
      // corrects the value from .pfm files for screen and pcl printer.
      // [bodind]


      // total bbox: [bodind], replaced WindowsBBox function:

      GlobalBBox(tt, bbox);

      ttm->winAscender = ABS(bbox[1].y);
      ttm->winDescender = ABS(bbox[0].y);


      ttm->panose[0] = NOCARE_PANOSE;
      ttm->panose[1] = NOCARE_PANOSE;
      ttm->panose[2] = NOCARE_PANOSE;
      ttm->panose[3] = NOCARE_PANOSE;
      ttm->panose[4] = NOCARE_PANOSE;
      ttm->panose[5] = NOCARE_PANOSE;
      ttm->panose[6] = NOCARE_PANOSE;
      ttm->panose[6] = NOCARE_PANOSE;
      ttm->panose[7] = NOCARE_PANOSE;
      ttm->panose[8] = NOCARE_PANOSE;
      ttm->panose[9] = NOCARE_PANOSE;
      /* Fixed pitch fonts are not given a panose by ATM. */
      if (!(t1m->fixedPitch)) {
         switch (t1m->pitchfam & 0xf0) {
            case FF_DECORATIVE:
               ttm->panose[0] = (UBYTE)DECORATIVE_PANOSE;
               ttm->panose[1] = (UBYTE)NO_PANOSE;
               break;
            case FF_ROMAN:
               ttm->panose[0] = (UBYTE)TEXT_PANOSE;
               ttm->panose[1] = (UBYTE)COVE_PANOSE;
               break;
            case FF_SWISS:
               ttm->panose[0] = (UBYTE)TEXT_PANOSE;
               ttm->panose[1] = (UBYTE)SANS_PANOSE;
               break;
            case FF_SCRIPT:
               ttm->panose[0] = (UBYTE)SCRIPT_PANOSE;
               ttm->panose[1] = (UBYTE)SANS_PANOSE;
               break;
            case FF_MODERN:
               ttm->panose[0] = (UBYTE)TEXT_PANOSE;
               ttm->panose[1] = (UBYTE)SANS_PANOSE;
               break;
         }
      } 
      ttm->isFixPitched = t1m->fixedPitch;
      ttm->panose[2] = (UBYTE)((t1m->tmweight - 500) * 12 / 900 + 6);

      /* Mac based metrics. */
      MacBBox(tt, bbox);
      ttm->macLinegap = TransY(t1m, (funit)(t1m->extLeading +
                                            (ttm->winAscender +
                                             ttm->winDescender) -
                                            (bbox[1].y-bbox[0].y)));

      /* Typographical metrics. */
      ttm->emheight = GetUPEM(t1m);
      if (t1m->flags==DEFAULTMETRICS) {
         ttm->usWeightClass = (USHORT)(strstr(t1m->fullname, "Thin") ? FW_THIN :
            ((strstr(t1m->fullname, "light") ? FW_EXTRALIGHT :
               ((strstr(t1m->fullname, "Light") ? FW_LIGHT :
                  ((strstr(t1m->fullname, "Medium") ? FW_MEDIUM :
                     ((strstr(t1m->fullname, "emi-bold") ? FW_SEMIBOLD :
                        ((strstr(t1m->fullname, "Bold") ? FW_BOLD :
                           ((strstr(t1m->fullname, "Black") ? FW_BLACK :
                              FW_NORMAL)))))))))))));
         ttm->macStyle = (USHORT)(((ttm->usWeightClass>FW_MEDIUM)?MAC_BOLD : 0) |
                         ((ttm->angle != 0) ? MAC_ITALIC : 0));
         ttm->fsSelection = (USHORT)(((ttm->angle != 0) ? FS_ITALIC : 0) |
                            ((ttm->usWeightClass > FW_MEDIUM) ? FS_BOLD : 0) |
                            ((ttm->usWeightClass==FW_NORMAL)
                                     ? FS_NORMAL : 0));
         ttm->typAscender = TypographicalAscender(tt);
         ttm->typDescender = TypographicalDescender(tt);
         em = ttm->typAscender - ttm->typDescender;
         ttm->superoff.y = (funit)(em / 2);
         ttm->superoff.x = 0;
         ttm->supersize.y = (funit)(em * 2 / 3);
         ttm->supersize.x = (funit)(em * 3 / 4);
         ttm->suboff.y = (funit)(em / 5);
         ttm->suboff.x = 0;
         ttm->subsize.y = (funit)(em * 2 / 3);
         ttm->subsize.x = (funit)(em * 3 / 4);
         ttm->strikeoff = (funit)(ttm->typAscender / 2);
         ttm->strikesize = (funit)(ttm->typAscender / 10);
      } else {
         ttm->usWeightClass = t1m->tmweight;
         ttm->macStyle = (USHORT)(((t1m->tmweight>FW_MEDIUM)?MAC_BOLD : 0) |
                         ((ttm->angle != 0) ? MAC_ITALIC : 0));
         ttm->fsSelection = (USHORT)(((ttm->angle != 0) ? FS_ITALIC : 0) |
                            ((ttm->usWeightClass > FW_MEDIUM) ? FS_BOLD : 0) |
                            ((ttm->usWeightClass==FW_NORMAL)
                                     ? FS_NORMAL : 0));
         ttm->typAscender = TransY(t1m, (funit)(t1m->ascent -
                                                t1m->intLeading));
         ttm->typDescender = (funit)(-TransY(t1m, t1m->descent)-1);
         ttm->typLinegap = TransY(t1m, (funit)(t1m->intLeading +
                                               t1m->extLeading));
         ttm->superoff.y = ABS(TransY(t1m, t1m->superoff));
         ttm->superoff.x = 0;
         ttm->supersize.y = TransY(t1m, t1m->supersize);
         ttm->supersize.x = (funit)(TransY(t1m, t1m->supersize) * 3 / 4);
         ttm->suboff.y = ABS(TransY(t1m, t1m->suboff));
         ttm->suboff.x = 0;
         ttm->subsize.y = TransY(t1m, t1m->subsize);
         ttm->subsize.x = (funit)(TransY(t1m, t1m->subsize) * 3 / 4);
         ttm->strikeoff = ABS(TransY(t1m, t1m->strikeoff));
         ttm->strikesize = TransY(t1m, t1m->strikesize);

         // Adjust usWinAscent so that internal leading matches up.
         // For fonts that do not have buggy pfm files, this adjustment
         // will do nothing, for those for which intLeading is
         // incorrectly set to zero, taking max means that the tops will not
         // be chopped off in the converted font. ttfd shaves off anything
         // that extends beyond ascender or descender. For fonts with buggy
         // pfm's, tt conversions may have bogus internal leadings, but this
         // is better than having glyph bottoms or tops shaved off. [bodind]

         PostAsc = ttm->emheight + TransY(t1m, t1m->intLeading) - ttm->winDescender;

         if (PostAsc > ttm->winAscender)
            ttm->winAscender  = PostAsc;
      }

      /* Gray-scale threshold. */
      if (GetStdVW(t1m)!=0 || GetDefStdVW(t1m)!=0) {
         ttm->onepix = (USHORT)(1 + GetUPEM(t1m)*3/2 /
                                TransY(t1m, ((GetStdVW(t1m) ?
                                              GetStdVW(t1m) :
                                              GetDefStdVW(t1m)))));
      }

      // needed in producing the correct ifimetrics for tt conversion

      ttm->DefaultChar = t1m->DefaultChar;
      ttm->BreakChar   = t1m->BreakChar;
      ttm->CharSet     = t1m->CharSet;  // essential for correct font mapping

      /* Character widths. */
      if (t1m->flags!=DEFAULTMETRICS) {
         ttm->FirstChar   = t1m->firstChar;
         ttm->LastChar    = t1m->lastChar;
         if ((ttm->widths = Malloc(sizeof(funit)*
                                   (t1m->lastChar-t1m->firstChar+1)))==NULL) {
            SetError(status = NOMEM);
         } else {
            for (i=0; i<=(unsigned)(t1m->lastChar-t1m->firstChar); i++) {
               ttm->widths[i] = TransY(t1m, t1m->widths[i]);
            }
         }
      }

      /* Pair kerning. */
      if (t1m->flags!=DEFAULTMETRICS &&
          t1m->kerns!=NULL) {
         if ((ttm->kerns = Malloc(sizeof(struct kerning)*
                                  t1m->kernsize))==NULL) {
            SetError(status = NOMEM);
         } else {
            for (i=0; i<t1m->kernsize; i++) {
               ttm->kerns[i].left = t1m->kerns[i].left;
               ttm->kerns[i].right = t1m->kerns[i].right;
               ttm->kerns[i].delta = TransY(t1m, t1m->kerns[i].delta);
            }
            ttm->kernsize = t1m->kernsize;
         }
      }

      /* Pre program. */
      if ((prep = GetPrep(PREPSIZE))!=NULL &&
          (prep_size = BuildPreProgram(t1m,
                                       GetWeight(t1m),
                                       GetBlues(t1m),
                                       GetAlignment(t1m),
                                       &prep, PREPSIZE,
                                       &(ttm->maxprepstack)))>0) {

         /* Store the pre-program. */
         UsePrep(ttm, prep, prep_size);
      }

      /* CVT entries. */
      blues = GetBlues(t1m);
      if (status!=NOMEM &&
          (ttm->cvt = Malloc(blues->align.cvt * CVTSIZE)) == NULL) {
         SetError(status = NOMEM);
      } else {
         ADDCVT(0);  /* TMPCVT */
         ADDCVT((GetStdVW(t1m)==0) ?
                TransX(t1m, GetDefStdVW(t1m))/2 :
            TransX(t1m, GetStdVW(t1m))/2);
         ADDCVT((GetStdHW(t1m)==0) ?
                TransY(t1m, GetDefStdHW(t1m))/2 :
            TransY(t1m, GetStdHW(t1m))/2);
         for (i=0; i<t1m->snapv_cnt; i++)
            ADDCVT(TransY(t1m, t1m->stemsnapv[i])/2);
         for (i=0; i<t1m->snaph_cnt; i++)
            ADDCVT(TransY(t1m, t1m->stemsnaph[i])/2);

         /* Align the top zones. */
         align = GetAlignment(t1m);
         for (i=0; i<blues->blue_cnt/2; i++) {
            /* Skip empty zones. */
            if (align->top[i].cnt==0)
               continue;
            
            ttm->cvt[align->top[i].blue_cvt]
                  = (short)TransY(t1m, blues->bluevalues[i*2]);
            ttm->cvt[align->top[i].blue_cvt+1]
                  = (short)TransY(t1m, blues->bluevalues[i*2+1]);
            for (j=0; j<align->top[i].cnt; j++) {
               funit pos;
               int k;

               /* Get the closest family. */
               k = MatchingFamily(blues->bluevalues[i*2],
                                  blues->familyblues,
                                  blues->fblue_cnt);

               /* Compute the position in the zone w.r.t. the family blues. */
               if (blues->bluevalues[i*2] != blues->bluevalues[i*2+1])
                  pos = IP(align->top[i].pos[j].y,
                           blues->bluevalues[i*2],
                           blues->bluevalues[i*2+1],
                           blues->familyblues[k],
                           blues->familyblues[k+1]);
               else
                  pos = blues->familyblues[k];

               ttm->cvt[align->top[i].pos[j].cvt]
                     = (short)TransY(t1m, align->top[i].pos[j].y);
               ttm->cvt[align->top[i].pos[j].cvt+1]
                     = (short)TransY(t1m, pos);
            }
         }

         /* Align the bottom zones. */
         for (i=0; i<blues->oblue_cnt/2; i++) {
            /* Skip empty zones. */
            if (align->bottom[i].cnt==0)
               continue;
            
            ttm->cvt[align->bottom[i].blue_cvt]
                  = (short)TransY(t1m, blues->otherblues[i*2+1]);
            for (j=0; j<align->bottom[i].cnt; j++) {
               funit pos;
               int k;

               /* Get the closest family. */
               k = MatchingFamily(blues->otherblues[i*2],
                                  blues->familyotherblues,
                                  blues->foblue_cnt);

               /* Compute the position in the zone w.r.t. the family blues. */
               if (blues->otherblues[i*2] != blues->otherblues[i*2+1])
                  pos = IP(align->bottom[i].pos[j].y,
                           blues->otherblues[i*2],
                           blues->otherblues[i*2+1],
                           blues->familyotherblues[k],
                           blues->familyotherblues[k+1]);
               else
                  pos = blues->familyotherblues[k];

               ttm->cvt[align->bottom[i].pos[j].cvt]
                     = (short)TransY(t1m, align->bottom[i].pos[j].y);
               ttm->cvt[align->bottom[i].pos[j].cvt+1]
                     = (short)TransY(t1m, pos);
            }
         }

         /* Add the family zones. */
         for (i=0; i<blues->fblue_cnt/2; i++) {
            if (blues->family_cvt[i]!=UNDEF_CVT) {
               ttm->cvt[blues->family_cvt[i]]
                     = (short)TransY(t1m, blues->familyblues[i*2]);
               ttm->cvt[blues->family_cvt[i]+1]
                     = (short)TransY(t1m, blues->familyblues[i*2+1]);
            }
         }

         /* Add the family other zones. */
         for (i=0; i<blues->foblue_cnt/2; i++) {
            if (blues->familyother_cvt[i]!=UNDEF_CVT) {
               ttm->cvt[blues->familyother_cvt[i]]
                     = (short)TransY(t1m, blues->familyotherblues[i*2+1]);
            }
         }

         ttm->cvt_cnt = blues->align.cvt;
         ttm->maxstorage = t1m->stems.storage;

         /* Store the font-program. */
         SetFPGM(ttm, GetFontProg(), GetFontProgSize(), GetNumFuns());
      }
   }

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\version.h ===
/* All version strings and release dates are located in this file. */

char vFoundry[] = "3.20";
char dFoundry[] = "09/15/92";

char vMakebit[] = "3.20";
char dMakebit[] = "09/15/92";  /* bc14 with newptr bug fixed in cscan.c*/

char vMakeabf[] = "3.20";
char dMakeabf[] = "09/15/92";

char vMakeljf[] = "3.20";
char dMakeljf[] = "09/15/92";

char vMakepfm[] = "3.20";
char dMakepfm[] = "09/15/92";

char vMakevfm[] = "3.20";
char dMakevfm[] = "09/15/92";

char vMakewp5[] = "3.20";
char dMakewp5[] = "09/15/92";

char vMakeword[] = "3.20";
char dMakeword[] = "09/15/92";

char vMakefon[] = "3.20";
char dMakefon[] = "09/15/92";

char vMakepfon[] = "3.20";
char dMakepfon[] = "10/02/89";

char vUpdatwin[] = "3.20";
char dUpdatwin[] = "09/15/92";

char vCheckcnf[] = "3.20";
char dCheckcnf[] = "09/15/92";



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\trig.h ===
/***
 **
 **   Module: Trig
 **
 **   Description:
 **    This is a module of the T1 to TT font converter. The module
 **    contains a look-up table for computing atan2() faster, and
 **    with less precision than that of the c run-time library.
 **
 **   Author: Michael Jansson
 **
 **   Created: 5/26/93
 **
 ***/



#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif
#ifndef FASTCALL
#  ifdef MSDOS
#     define FASTCALL   __fastcall
#  else
#     define FASTCALL
#  endif
#endif

#define PI    1024
#define PI2   512
#define PI4   256



/***
** Function: Atan2
**
** Description:
**   Compute atan2()
***/
int FASTCALL Atan2   _ARGS((IN int dy, IN int dx));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\trans.h ===
/***
**
**   Module: Trans
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      contains functions that will convert T1 specific data into
**      corresponding TT data, such as hints and font metrics.
**
**   Author: Michael Jansson
**
**   Created: 5/28/93
**
***/



#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif
#ifndef FASTCALL
#  ifdef MSDOS
#     define FASTCALL   __fastcall
#  else
#     define FASTCALL
#  endif
#endif


struct TTMetrics;
struct T1Metrics;
struct TTHandle;
struct T1Glyph;
struct TTGlyph;
struct TTComposite;
struct Composite;


/***
** Function: ConvertComposite
**
** Description:
**   This function convertes the data associated to a T1 font seac glyph
**   into the corresponding data used in a TT font composite glyph.
**
***/
errcode FASTCALL  ConvertComposite  _ARGS((INOUT   struct T1Metrics *,
                                           IN      struct Composite *,
                                           OUT     struct TTComposite *));
/***
** Function: ConvertGlyph
**
** Description:
**   This function convertes the data associated to a T1 font glyph
**   into the corresponding data used in a TT font glyph.
***/
errcode FASTCALL  ConvertGlyph      _ARGS((INOUT   struct T1Metrics *,
                                           IN      struct T1Glyph *,
                                           OUT     struct TTGlyph **,
                                           IN      int));
/***
** Function: ConvertMetrics
**
** Description:
**
***/
errcode FASTCALL  ConvertMetrics    _ARGS((IN      struct TTHandle *,
                                           INOUT   struct T1Metrics *,
                                           OUT     struct TTMetrics *,
                                           IN      char *tag));

/***
** Function: TransX
**
** Description:
**   Translate a horizontal coordinate according to a transformation matrix.
***/
funit FASTCALL    TransX            _ARGS((IN      struct T1Metrics *t1,
                                           IN      funit x));

/***
** Function: TransY
**
** Description:
**   Translate a vertical coordinate according to a transformation matrix.
***/
funit FASTCALL    TransY            _ARGS((IN      struct T1Metrics *t1,
                                           IN      funit y));

/***
** Function: TransAllPoints
**
** Description:
**   Translate a coordinate according to a transformation matrix.
***/
void  FASTCALL    TransAllPoints    _ARGS((IN      struct T1Metrics *t1,
                                           INOUT   Point *pts,
                                           IN      USHORT cnt,
                                           IN      f16d16 *fmatrix));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\types.h ===
#ifndef TYPES_H
#define TYPES_H


/***********/
/* Macros. */
#define MAX(v,w)  ((v)>=(w) ? (v) : (w))
#define MIN(v,w)  ((v)<(w) ? (v) : (w))
#define ABS(v)	  (((v)>=0) ? (v) : -(v))
#define SWAPINT(a,b)   {(a)^=(b); (b)^=(a); (a)^=(b);}
#define MkLong(c1,c2,c3,c4)	 (((ULONG)(c1)<<24L) + ((ULONG)(c2)<<16L) + \
				 ((ULONG)(c3)<<8L) + ((ULONG)(c4)))



/**************/
/* Constants. */
#define TRUE   1
#define FALSE  0



/**********/
/* Types. */
typedef short errcode;
typedef unsigned char UBYTE;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef unsigned char boolean;
typedef long f16d16;


/* Microsoft C specific stuff. */
#ifndef CDECL
#ifdef _MSC_VER
#  define CDECL  __cdecl
#else
#  define CDECL
#endif
#endif


/*** Error handling. */
void LogError(const long type, const long id, const char *arg);

#if _DEBUG
#ifdef MSDOS
int _cdecl sprintf(char *, const char *, ...);
#else
int sprintf(char *, const char *, ...);
#endif
#define SetError(c)  {char tmp[64];  (void)sprintf(tmp,\
	"Error %d at %s, line %d.\n", c, __FILE__, __LINE__); LogError(MSG_ERROR, MSG_DB, tmp);}
#else
#define SetError(c)  {c;}
#endif

/* Message types */
#define MSG_INFO     0L
#define MSG_WARNING  1L
#define MSG_ERROR    2L

	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\trig.c ===
/***
 **
 **   Module: Trig
 **
 **   Description:
 **    This is a module of the T1 to TT font converter. The module
 **    contains a look-up table for computing atan2() faster, and
 **    with less precision than that of the c run-time library.
 **
 **   Author: Michael Jansson
 **
 **   Created: 5/26/93
 **
 ***/



#include "types.h"
#include "metrics.h"
#include "trig.h"

static const unsigned char atan_tbl[] = {
   0,
   2, 5, 7, 10, 12, 15, 17, 20, 22, 25, 27, 30, 32, 35, 38, 40, 
   43, 45, 48, 50, 53, 55, 57, 60, 62, 65, 67, 70, 72, 75, 77, 79, 
   82, 84, 87, 89, 91, 94, 96, 98, 101, 103, 105, 107, 110, 112, 114, 116, 
   119, 121, 123, 125, 127, 130, 132, 134, 136, 138, 140, 142, 144, 147, 149, 151, 
   153, 155, 157, 159, 161, 163, 165, 167, 168, 170, 172, 174, 176, 178, 180, 182, 
   183, 185, 187, 189, 191, 192, 194, 196, 198, 199, 201, 203, 204, 206, 208, 209, 
   211, 212, 214, 216, 217, 219, 220, 222, 223, 225, 226, 228, 229, 231, 232, 234, 
   235, 237, 238, 239, 241, 242, 244, 245, 246, 248, 249, 250, 252, 253, 254, 255
};


/***
** Function: Atan2
**
** Description:
**   Compute atan2()
***/
int FASTCALL Atan2(const funit dy, const funit dx)
{
   funit du, dv;
   int a = 0;

   /* Normalize the sign. */
   if (ABS(dx)>ABS(dy)) {
      du = ABS(dx);
      dv = ABS(dy);

      if (du==0) {
         a = PI4;
      } else {

         /* Normalize for the size of the table. */
         while (dv>256) {
            dv = (dv+1)>>1;
            du = (du+1)>>1;
         }
         dv = ((dv<<7)+(du>>1))/du;

         /* Lookup the angle. */
         if (dv==1) 
            a = (int)((long)PI4 * (long)ABS(dx) / (long)ABS(dy));
         if (du!=dv)
            a = (int)atan_tbl[dv];
      }

   } else {
      du = ABS(dy);
      dv = ABS(dx);

      if (du==0) {
         a = PI4;
      } else {

         /* Normalize for the size of the table. */
         while (dv>256) {
            dv = (dv+1)>>1;
            du = (du+1)>>1;
         }
         dv = ((dv<<7)+(du>>1))/du;

         /* Lookup the angle. */
         if (dv==1) 
            a = (int)((long)PI4 * (long)ABS(dy) / (long)ABS(dx));
         if (du!=dv)
            a = PI2 - (int)atan_tbl[dv];
      }
   }


   /* pick the right quadrant. */
   if (dx>0) {
      if (dy>0) {
         /* NOOP */
      } else {
         a = -a;
      }
   } else {
      if (dy>0) {
         a = PI - a;
      } else {
         a = a - PI;
      }
   }

   return a;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\winio.c ===
/***
**
**   Module: FileIO
**
**   Description:
**      This is a module of the T1 to TT font converter. The module
**      is the interface towards all low level I/O functions that are
**      are available on the current platform.
**      This version of the module is written specifically for Win32,
**      and is based on "memory mapped files".
**
**   Author: Michael Jansson
**
**   Created: 5/26/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <windows.h>

#undef IN

/* Special types and definitions. */
#include "t1instal.h"
#include "types.h"
#include "safemem.h"
#include "fileio.h"

/* Module dependent types and prototypes. */
/*-none-*/


/***** LOCAL TYPES */
struct ioFile {
   HANDLE file;
   HANDLE mapping;
   LPVOID data;
   UBYTE  *ptr;
   UBYTE  *max;
   DWORD  length;
   boolean output;
};


/***** CONSTANTS */
#define FILESIZE     65535L
#define BUFSIZE      8L * 1024L
#define BADSET_ERROR 0xffffffff

/***** MACROS */
#ifndef FASTCALL
#  ifdef MSDOS
#     define FASTCALL   __fastcall
#  else
#     define FASTCALL
#  endif
#endif
#define TRY if (1)
#define EXCEPT(v) else



/***** STATIC FUNCTIONS */
/*-none-*/




/***** FUNCTIONS */

struct ioFile *io_OpenFile(const char *name, const int mode)
{
   DWORD access;
   DWORD create;
   DWORD attr;
   DWORD prot;
   DWORD lowsize;
   DWORD mapaccess;
   SECURITY_ATTRIBUTES sa;
   struct ioFile *file;

   if ((file = Malloc(sizeof(struct ioFile)))!=NULL) {
      file->file = NULL;
      file->mapping = NULL;
      file->data = NULL;
      file->ptr = NULL;
      file->length = 0;

      if (mode == READONLY) {
         access = GENERIC_READ;
         create = OPEN_EXISTING;
         attr = FILE_ATTRIBUTE_NORMAL /*FILE_FLAG_SEQUENTIAL_SCAN*/;
         prot = PAGE_READONLY;
         lowsize = 0;
         mapaccess = FILE_MAP_READ;
         file->output = FALSE;
      } else {
         access = GENERIC_READ | GENERIC_WRITE;
         create = CREATE_ALWAYS;
         attr = FILE_ATTRIBUTE_NORMAL;
         prot = PAGE_READWRITE;
         lowsize = FILESIZE;
         mapaccess = FILE_MAP_ALL_ACCESS;
         file->output = TRUE;
      }
      sa.nLength = sizeof(sa);
      sa.lpSecurityDescriptor = NULL;
      sa.bInheritHandle = FALSE;
      if ((file->file = CreateFile(name, access, 0, &sa, create,
                                   attr, NULL))==INVALID_HANDLE_VALUE) {
         (void)io_CloseFile(file);
         SetLastError(0);
         file = NULL;
      } else {
         if ((file->mapping = CreateFileMapping(file->file, NULL,
                                                prot, 0, lowsize,
                                                NULL))==INVALID_HANDLE_VALUE) {
            (void)io_CloseFile(file);
            file = NULL;
         } else {
            if ((file->data = MapViewOfFile(file->mapping,
                                            mapaccess, 0, 0, 0))==NULL) {
               (void)io_CloseFile(file);
               file = NULL;
            } else {
               file->ptr = (UBYTE *)file->data;
               file->max = file->ptr;
               file->max = file->max + GetFileSize(file->file, NULL);
            }
         }
      }
   }

   return file;
}

errcode io_CloseFile(struct ioFile *file)
{
   errcode status = SUCCESS;

   if (file==NULL || file->data==NULL || file->file==0)
      status = FAILURE;


   if (file) {
      if ((DWORD)(file->ptr - (UBYTE *)file->data)>file->length)
         file->length = (long)(file->ptr - (UBYTE *)file->data);

      if (file->data){
         UnmapViewOfFile(file->data);
         file->data = NULL;
      }

      if (file->mapping) {
         CloseHandle(file->mapping);
         file->mapping = NULL;
      }

      if (file->file) {
         if (file->output) {
            if (SetFilePointer(file->file,
                               file->length,
                               0,
                               FILE_BEGIN)==BADSET_ERROR)
               status = FAILURE;
            else if (SetEndOfFile(file->file)==FALSE)
               status = FAILURE;

         }

         CloseHandle(file->file);
         file->file = NULL;
      }

      Free(file);
   }

   return status;
}


USHORT FASTCALL io_ReadOneByte(struct ioFile *file)
{
   USHORT byte;

   if (file->ptr<=file->max) {
      byte = (USHORT)*(file->ptr++);
   } else {
      SetLastError(ERROR_READ_FAULT);
      byte = ERROR_READ_FAULT;
   }

   return byte;
}

USHORT FASTCALL io_WriteBytes(const UBYTE *buf,
                              USHORT len,
                              struct ioFile *file)
{
   if ((file->ptr+len)<=file->max) {
      memcpy(file->ptr, buf, len);
      file->ptr = file->ptr + len;
   } else if (file->data) {
      long pos = io_FileTell(file);
      long size = MAX(GetFileSize(file->file, NULL),
                      MAX(file->length, (ULONG)(file->ptr -
                                                (UBYTE *)file->data)));

      /* Get rid of the old file mapping. */
      UnmapViewOfFile(file->data);
      file->data = NULL;
      CloseHandle(file->mapping);
      file->mapping = NULL;

      /* Get a new file mapping. */
      if ((file->mapping = CreateFileMapping(file->file, NULL,
                                               PAGE_READWRITE, 0,
                                               size + BUFSIZE,
                                               NULL))==INVALID_HANDLE_VALUE) {
         SetLastError(ERROR_WRITE_FAULT);
         file->ptr = file->max;
         len = 0;
      } else if ((file->data = MapViewOfFile(file->mapping,
                                             FILE_MAP_ALL_ACCESS,
                                             0, 0, 0))==NULL) {
         SetLastError(ERROR_WRITE_FAULT);
         file->ptr = file->max;
         len = 0;
      } else {
         file->ptr = (UBYTE *)file->data;
         file->max = (UBYTE *)file->data;
         file->max = file->max + size + BUFSIZE;
         io_FileSeek(file, pos);
         io_WriteBytes(buf, len, file);
      }
   }

   return len;
}

USHORT FASTCALL io_ReadBytes(UBYTE *buf, USHORT len, struct ioFile *file)
{
   if ((file->ptr+len)<=file->max) {
      memcpy(buf, file->ptr, len);
      file->ptr = file->ptr + len;
   } else {
      SetLastError(ERROR_READ_FAULT);
      len = 0;
   }

   return len;
}

boolean io_FileError(struct ioFile *file)
{
   return (boolean)GetLastError();
}


long FASTCALL io_FileTell(struct ioFile *file)
{
   return (long)(file->ptr - (UBYTE *)file->data);
}


long FASTCALL io_FileSeek(struct ioFile *file, long where)
{
   DWORD oldpos = (DWORD)(file->ptr - (UBYTE *)file->data);

   /* Keep track of the length of the file. */
   if (oldpos>file->length)
      file->length = oldpos;

   /* Fail if file is not mapped, or if we are jumping out of bounds. */
   if (file->data && (where>=0) &&
       ((UBYTE *)file->data+where) <= file->max) {
      file->ptr = (UBYTE *)file->data;
      file->ptr = file->ptr + where;
   } else {
      SetLastError(ERROR_SEEK);
   }

   return (long)oldpos;
}


/***
** Function: FileSeek
**
** Description:
***/
void FASTCALL io_RemoveFile(const char *name)
{
   DeleteFile(name);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\ttprog.h ===
/**
**   Description:
**      This is a module of the T1 to TT font converter. This is a
**      sub-module of Hint module. This modules deals with the 
**      the font program fo the font.
**
**   Author: Michael Jansson
**
**   Created: 8/24/93
**
***/


#ifndef _ARGS
#  define IN  const
#  define OUT
#  define INOUT
#  define _ARGS(arg) arg
#endif

#define HIBYTE(v)	(UBYTE)((USHORT)(v)>>8)
#define LOBYTE(v)	(UBYTE)((USHORT)(v)&0xff)

#define TWILIGHT  0
#define GLYPHZONE 1

#define TMPCVT 0L
#define TMPPNT 0L
#define TMPPNT1 1L

#define STORAGE_DIAG 3

#define ONEPIXEL    64L

#define INFINITY	   (USHORT)SHRT_MAX


#define MAXPTS 10         /* Max num of pts on a stem hint side. */


/* IP bucket - Used for collecting points that should be
interpolated within the zones defined by the stem hints. */
typedef struct Extremas {
   short rp1;
   short rp2;
   short n;
   short pts[MAXPTS];
} Extremas;



enum aligntype  {
   at_side1,
   at_side2,
   at_relative1,
   at_relative2,
   at_centered
};



/***
**
**   Description:
**      This file contains op-codes for a sub-set of the
**      TrueType instruction set.
**
**   Author: Michael Jansson
**
**   Created: 10/14/93
**
***/


/* TrueType sub-op codes. */
#define SUBOP_Y         0x00
#define SUBOP_X         0x01

#define SUBOP_R         0x01

#define SUBOP_MOVE      0x10
#define SUBOP_MINDIST   0x08
#define SUBOP_ROUND     0x04
#define SUBOP_GRAY      0x00

#define SUBOP_mMRGR  SUBOP_MINDIST | SUBOP_ROUND | SUBOP_GRAY
#define SUBOP_MmRGR  SUBOP_MOVE | SUBOP_ROUND | SUBOP_GRAY


/* TrueType op codes. */
enum {        
   op_mps = 0x4c,
   op_spvtl = 0x07,
   op_roll = 0x8a,
   op_gteq = 0x53,
   op_cindex =  0x25,
   op_rtdg = 0x3d,
   op_clear = 0x22,
   op_szp0 = 0x13,
   op_szp1 = 0x14,
   op_szp2 = 0x15,
   op_szps = 0x16,
   op_loopcall = 0x2a,
   op_shz = 0x36,
   op_smd = 0x1a,
   op_rutg = 0x7c,
   op_rdtg = 0x7d,
   op_pop = 0x21,
   op_abs = 0x64,
   op_scvtci = 0x1d,
   op_rs = 0x43,
   op_spvfs = 0x0a,
   op_shp = 0x33,
   op_roff = 0x7a,
   op_md = 0x49,
   op_ssw = 0x1f,
   op_mul = 0x63,
   op_odd = 0x56,
   op_gc = 0x46,
   op_dup = 0x20,
   op_min = 0x8c,
   op_max = 0x8b,
   op_neg = 0x65,
   op_sfvtl = 0x08,
   op_spvtca =  0x06,
   op_swap = 0x23,
   op_mdrp = 0xc0,
   op_mdap = 0x2e,
   op_miap = 0x3e,
   op_mirp = 0xe0,
   op_alignrp = 0x3c,
   op_iup = 0x30,
   op_svcta = 0x00,
   op_sloop = 0x17,
   op_npushb = 0x40,
   op_npushw = 0x41,
   op_mppem = 0x4b,
   op_lt = 0x50,
   op_gt = 0x52,
   op_if = 0x58,
   op_scfs = 0x48,
   op_else = 0x1b,
   op_wcvtf = 0x70,
   op_wcvtp = 0x44,
   op_pushw1 = 0xb8,
   op_pushb1 = 0xb0,
   op_eif = 0x59,
   op_shpix = 0x38,
   op_srp0 = 0x10,
   op_srp1 = 0x11,
   op_srp2 = 0x12,
   op_ip = 0x39,
   op_rcvt = 0x45,
   op_round = 0x68,
   op_rtg = 0x18,
   op_rthg = 0x19,
   op_add = 0x60,
   op_div = 0x62,
   op_scanctrl = 0x85,
   op_ws = 0x42,
   op_sswci = 0x1e,
   op_scantype = 0x8d,
   op_sub = 0x61,
   op_fdef = 0x2c,
   op_endf = 0x2d,
   op_call = 0x2b,
   op_getinfo = 0x88
};



/***
** Function: GetTopPos
**
** Description:
**   This function allocates a cvt entry for the 
**   top side of a horizontal stem;
***/
short	       GetTopPos	    _ARGS((IN	   Blues *blues,
					   INOUT   AlignmentControl *align,
					   IN	   funit pos));
/***
** Function: GetBottomPos
**
** Description:
**   This function allocates a cvt entry for the 
**   top side of a horizontal stem;
***/
short	       GetBottomPos	    _ARGS((IN	   Blues *blues,
					   INOUT   AlignmentControl *align,
					   IN	   funit pos));
/***
** Function: CutInSize
**
** Description:
**   This function computes the cut in size
**   of a stem, given a master width and the
**   width of the stem. This is done with the
**   StdVW==2.0 pixel treshold and the thinn
**   and wide cut in values.
***/
USHORT	       CutInSize	    _ARGS((IN	   funit width,
					   IN	   funit master,
					   IN	   USHORT tresh,
					   IN	   funit upem));

/***
** Function: SnapStemArgs
**
** Description:
**   
***/
USHORT	       SnapStemArgs	    _ARGS((OUT	   short *args,
					   INOUT   USHORT ta,
					   IN	   funit width,
					   IN	   USHORT std_cvt,
					   IN	   USHORT snap_cvt,
					   IN	   USHORT std_ci,
					   IN	   USHORT snap_ci,
					   IN	   USHORT storage));
/***
** Function: StdStemArgs
**
** Description:
**   
***/
USHORT	       StdStemArgs	    _ARGS((OUT	   short *args,
					   INOUT   USHORT ta,
					   IN	   funit width,
					   IN	   USHORT std_cvt,
					   IN	   USHORT std_ci,
					   IN	   USHORT storage));
/***
** Function: CreateStdStems
**
** Description:
**   
***/
USHORT	       CreateStdStems	    _ARGS((INOUT   UBYTE *prep,
					   INOUT   USHORT tp,
					   IN	   short cnt));
/***
** Function: CreateSnapStems
**
** Description:
**   
***/
USHORT	       CreateSnapStems	    _ARGS((INOUT   UBYTE *prep,
					   INOUT   USHORT tp,
					   IN	   short cnt));
/***
** Function: tt_GetFontProg
**
** Description:
**   This function returns the static font
**   font program.
***/
const UBYTE    *tt_GetFontProg	    _ARGS((void));


/***
** Function: tt_GetNumFuns
**
** Description:
**   This function returns the number of functions
**   defined in the static font program.
***/
USHORT	       tt_GetNumFuns	    _ARGS((void));


/***
** Function: tt_GetFontProgSize
**
** Description:
**   This function returns the size of the
**   static font program.
***/
USHORT	       tt_GetFontProgSize   _ARGS((void));


/***
** Function: SetZone
**
** Description:
**   This function initiate an alignment zone
**   by creating an appropriate point in the
**   twilight zone.
***/
USHORT	       SetZone		    _ARGS((INOUT   UBYTE *prep,
					   INOUT   USHORT tp,
					   IN	   short cvt));
/***
** Function: CopyZone
**
** Description:
**   This function copies a cvt entry, representing an
**   alignment zone, to the cvt used for a particular hstem.
***/
USHORT	       CopyZone		    _ARGS((INOUT   UBYTE *prep,
					   INOUT   short tp,
					   INOUT   short *args,
					   IN	   short ta));
/***
** Function: CopyFamilyBlue
**
** Description:
**   This function copies a cvt entry, representing a
**   family blue zone, to the cvt used for a particular hstem.
***/
USHORT	       CopyFamilyBlue	    _ARGS((INOUT   UBYTE *prep,
					   INOUT   short tp,
					   INOUT   short *args,
					   IN	   short ta));
/***
** Function: AlignFlat
**
** Description:
**   This function creates a cvt entry for
**   a particular hstem.
***/
USHORT	       AlignFlat	    _ARGS((INOUT   UBYTE *prep,
					   INOUT   short tp,
					   INOUT   short *args,
					   IN	   short ta));
/***
** Function: AlignOvershoot
**
** Description:
**   This function creates a cvt entry for
**   a particular hstem.
***/
USHORT	       AlignOvershoot	    _ARGS((INOUT   UBYTE *prep,
					   INOUT   short tp,
					   INOUT   short *args,
					   IN	   short ta));
/***
** Function: EmitFlex
**
** Description:
**   Convert a T1 flex hint into a TrueType IP[] 
**   intruction sequence that will reduce a flex
**   that is flatter than a given height.
***/
errcode	       EmitFlex		    _ARGS((INOUT   short *args,
					   INOUT   short *pcd,
					   IN	   funit height,
					   IN	   short start,
					   IN	   short mid,
					   IN	   short last));
/***
** Function: ReduceDiagonals
**
** Description:
**   This function generates the TT instructions
**   that will shrink the outline, in order to
**   control the width of diagonals. This implementation
**   can probably be improved.
***/
short	       ReduceDiagonals	    _ARGS((IN	   Outline *paths,
					   INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd));
/***
** Function: ScaleDown3
**
** Description:
**   This function generates the TT instructions
**   that will scale down points 3%.
***/
void	       ScaleDown3	    _ARGS((IN	   Extremas *extr,
					   IN	   short xcnt, 
					   INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd));
/***
** Function: EmitIP
**
** Description:
**   This function generates the TT instructions
**   that will interpolate points that are either
**   within or between stem sides.
***/
void	       EmitIP		    _ARGS((IN	   Extremas *extr,
					   IN	   short xcnt, 
					   INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd,
					   IN	   short scale3offset));
/***
** Function: EmitVerticalStem
**
** Description:
**   This function generates the code that
**   will initiate the graphics state of the
**   TrueType interpreter for the grid fitting
**   of vertical stems.
***/
void	       EmitVerticalStems    _ARGS((INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd));
/***
** Function: EmitHorizontalStem
**
** Description:
**   This function generates the code that
**   will initiate the graphics state of the
**   TrueType interpreter for the grid fitting
**   of vertical stems.
***/
void	       EmitHorizontalStems  _ARGS((INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd));
/***
** Function: EmitVStem
**
** Description:
**   This function generates the code that
**   will create and grid fit points in the
**   twilight zone, corresponding to a vstem.
***/
errcode	       EmitVStem	    _ARGS((INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd,
					   INOUT   struct T1Metrics *t1m,
					   IN	   funit width,
					   IN      funit real_side1,
					   IN      funit real_side2,
					   IN      funit side1,
					   IN      funit side2,
					   IN      short rp,
					   IN      enum aligntype align,
					   IN      short ref));
/***
** Function: EmitHStem
**
** Description:
**   This function generates the code that
**   will create and grid fit points in the
**   twilight zone, corresponding to a hstem.
***/
errcode	       EmitHStem	    _ARGS((INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd,
					   INOUT   struct T1Metrics *t1m,
					   IN	   funit width,
					   IN      funit side1,
					   IN      funit side2,
					   IN      short rp,
					   IN      enum aligntype align,
					   IN      short ref));
/***
** Function: FamilyCutIn
**
** Description:
**   This function generates a branch in the
**   pre-program. 
***/
USHORT	       FamilyCutIn	    _ARGS((INOUT   UBYTE *pgm,
					   INOUT   USHORT tp,
					   IN	   short cis));
/***
** Function: SetProjection
**
** Description:
**   This function generates the TrueType code that
**   changes the projection vector in oblique typefaces.
***/
void	       SetProjection	    _ARGS((INOUT   UBYTE *pgm,
					   INOUT   short *pc,
					   INOUT   short *args,
					   INOUT   short *pcd,
					   IN	   funit x,
					   IN	   funit y));
/***
** Function: AssembleArgs
**
** Description:
**   This function takes a sequence of arguments and
**   assembles them into a sequence of PUSHB1[], PUSHW1[],
**   NPUSHB[] and NPUSHW[] instructions.
***/
void           AssembleArgs         _ARGS((INOUT   short *args,
                                           IN      short pcd,
                                           OUT     UBYTE *is,
                                           INOUT   short *cnt));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontext\t1instal\ttprog.c ===
/***
**
**   Module: ttprog
**
**   Description:
**      This is a module of the T1 to TT font converter. This is a
**      sub-module of Hint module. This modules deals with the 
**      the font program fo the font.
**
**   Author: Michael Jansson
**
**   Created: 8/24/93
**
***/


/**** INCLUDES */
/* General types and definitions. */
#include <limits.h>

/* Special types and definitions. */
#include "titott.h"
#include "types.h"
#include "safemem.h"
#include "metrics.h"
#include "t1msg.h"

/* Module dependent types and prototypes. */
/*#include "hints.h"*/
#include "ttprog.h"



/***** MACROS */
/*-none-*/



/***** CONSTANTS */
#define MAXIP			100

#define CURVEPHASE      6

#define MAXTHINPNTS     512

#define UNDEF        -1

#define SMALL_LOWER     21L
#define SMALL_UPPER     50L
#define LARGE_LOWER     21L
#define LARGE_UPPER     21L

#define BUFSIZE         20

#define TTFUN_SET_ZONE           1 
#define TTFUN_COPY_ZONE          2 
#define TTFUN_STEM_SNAP_WIDTH    3 
#define TTFUN_STEM_STD_WIDTH     4 
#define TTFUN_SHIFT_BLUE_ZONE    5 
#define TTFUN_ALIGN_BLUE_ZONE    6 
#define TTFUN_COPY_FAMILY        7 
#define TTFUN_WRITE_STEM         8 
#define TTFUN_VERTICAL           9 
#define TTFUN_HORIZONTAL         10
#define TTFUN_VCENTER            11
#define TTFUN_HCENTER            12
#define TTFUN_RELATIVE1V         13
#define TTFUN_RELATIVE2V         14
#define TTFUN_RELATIVE1H         15
#define TTFUN_RELATIVE2H         16
#define TTFUN_SIDE1              17    
#define TTFUN_SIDE2              18
#define TTFUN_FLEX               19
#define TTFUN_SCALE3             20
#define TTFUN_SHIFT1             21
#define TTFUN_SHIFT2             22
#define TTFUN_IP1                23  
#define TTFUN_IP2                24
#define TTFUN_IPN                25
#define TTFUN_SHP1               26  
#define TTFUN_SHP2               27
#define TTFUN_SHPN               28
#define TTFUN_RANGE              29
#define TTFUN_OBLIQUE            30
#define TTFUN_NUM                31    /* 1..30 */


#define FDEF(name)            op_pushb1, name, op_fdef,
#define ENDF                  op_endf,
#define CALL(name)            op_pushb1, name, op_call
#define WCVT(name)            op_pushb1, name, op_swap, op_wcvtf
#define PUSH1(v)              op_pushb1, (v)
#define PUSH2(v1, v2)         op_pushb1+1, (v1), (v2)
#define PUSH3(v1, v2, v3)     op_pushb1+2, (v1), (v2), (v3)
#define PUSH4(v1, v2, v3, v4) op_pushb1+3, (v1), (v2), (v3), (v4)
#define PUSH5(v1,v2,v3,v4,v5) op_pushb1+4, (v1), (v2), (v3), (v4), (v5)


static const UBYTE FontProg[] = {


   
/******* SET ZONE FUNCTION
 *
 * Args: flat_pos
 *
 */
FDEF(TTFUN_SET_ZONE)
   PUSH1(TMPPNT),
   op_swap,
   op_miap,
   PUSH1(TMPPNT),
   op_mdap | SUBOP_R,
ENDF




/******* COPY ZONE FUNCTION
 *
 * Args: from_cvt, to_cvt
 *
 */
FDEF(TTFUN_COPY_ZONE)
   op_rcvt,
   op_round,
   op_wcvtp,
ENDF





/******* STEM SNAP WIDTH FUNCTION
 *
 * Args: std_ci, std_cvt, snap_ci, snap_cvt, width, storage
 *
 */
FDEF(TTFUN_STEM_SNAP_WIDTH)
   op_mppem,
   op_gteq,
   op_if,

      /* Use std */
      op_rcvt,
      op_round,
      PUSH1(ONEPIXEL/2),
      op_max,
      op_swap, op_pop, op_swap, op_pop, op_swap, op_pop,
      CALL(TTFUN_WRITE_STEM),
      
   op_else,
      op_pop,
      op_mppem,
      op_gteq,
      op_if,
   
         /* Use snap */
         op_rcvt,
         op_round,
         PUSH1(ONEPIXEL/2),
         op_max,
    op_swap,
         op_pop, 
         CALL(TTFUN_WRITE_STEM),
         
      /* Use real width. */
      op_else,
         op_pop,
         WCVT(TMPCVT),
         PUSH1(TMPCVT),
         op_rcvt,
         op_round,
         PUSH1(ONEPIXEL/2),
         op_max,
         CALL(TTFUN_WRITE_STEM),
      op_eif,
   
   op_eif,
ENDF



   

/******* STEM STD WIDTH FUNCTION
 *
 * Args: std_ci, std_cvt, width, storage
 *
 */
FDEF(TTFUN_STEM_STD_WIDTH)
   op_mppem,
   op_gteq,
   op_if,
   
      /* Use std */
      op_rcvt,
      op_round,
      PUSH1(ONEPIXEL/2),
      op_max,
      op_swap,
      op_pop,
      CALL(TTFUN_WRITE_STEM),
      
   /* Use real width. */
   op_else,
      op_pop,
      WCVT(TMPCVT),
      PUSH1(TMPCVT),
      op_rcvt,
      op_round,
      PUSH1(ONEPIXEL/2),
      op_max,
      CALL(TTFUN_WRITE_STEM),
   op_eif,
   
ENDF





/******* SHIFT BLUE ZONE FUNCTION
 *
 * Args: cvt
 *
 */
FDEF(TTFUN_SHIFT_BLUE_ZONE)
   PUSH5(TMPPNT1, TMPPNT1, TMPPNT, TMPPNT1, 5),
   op_cindex,
   op_miap,
   op_srp0,
   op_mdrp | SUBOP_mMRGR,
   op_gc,
   op_wcvtp,
ENDF





/******* ALIGN BLUE ZONE FUNCTION
 *
 * Args: cvt
 *
 */
FDEF(TTFUN_ALIGN_BLUE_ZONE)
   PUSH5(TMPPNT1, TMPPNT1, TMPPNT, TMPPNT1, 5),
   op_cindex,
   op_miap,
   op_srp0,
   op_mdrp | SUBOP_ROUND,
   op_gc,
   op_wcvtp,
ENDF





/******* COPY FAMILY FUNCTION
 *
 * Args: base_cvt
 *
 */
FDEF(TTFUN_COPY_FAMILY)
   op_dup,
   PUSH1(1),
   op_add,
   op_rcvt,
   op_wcvtp,
ENDF





/******* WRITE STEM FUNCTION
 *
 * Args: width, storage
 *
 */
FDEF(TTFUN_WRITE_STEM)
   op_dup,    /* -| width, width, storage */
   op_dup,    /* -| width, width, width, storage */
   op_add,    /* -| 2*width, width, storage, */
   op_odd,    /* -| odd/even, width, storage */
   PUSH2(1, 4),     /* -| 4, 1, odd/even, width, storage */
   op_cindex,     /* -| storage, 1, odd/even, width, storage */
   op_add,
   op_swap,   /* -| odd/even, storage+1, width, storage */
   op_ws,
   op_ws,
ENDF





/******* VERTICAL FUNCTION
 *
 * Args: -*none*-
 *
 */
FDEF(TTFUN_VERTICAL)
   op_svcta | SUBOP_X,
   PUSH1(TWILIGHT),
   op_szps,
ENDF





/******* HORIZONTAL FUNCTION
 *
 * Args: -*none*-
 *
 */
FDEF(TTFUN_HORIZONTAL)
   PUSH1(TWILIGHT),
   op_svcta,
   op_szps,
ENDF





/******* CENTER VSTEM FUNCTION
 *
 * Args: p1, p2, p3, p4, c, tz1, width
 *
 */
FDEF(TTFUN_VCENTER)

   /* Set rounding state for the center. */
   PUSH2(1, 8),
   op_cindex,
   op_add,
   op_rs,
   op_if,
       op_rthg,
   op_else,
       op_rtg,
   op_eif,

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 6),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 6),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 2, 5),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 3, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,


   /* Move/round center. */
   WCVT(TMPCVT),     /* c */
   PUSH2(TMPPNT, TMPCVT),
   op_miap| SUBOP_R,
   op_rtg,

   /* Align all points to the center. */
   op_dup, op_dup, PUSH1(1), op_add,
   op_alignrp, op_alignrp,   /* tz1, tz1+1 */


   /* Compute the width. */
   op_swap,
   op_rs,
   PUSH1(CURVEPHASE),
   op_sub,
   op_swap,


   /* -| tz1, width */
   op_dup,
   op_dup,
   op_dup,
   op_srp0,
   PUSH1(4), op_cindex,
   op_neg,     /* -| (-width/2), tz1, tz1, tz1, width */
   op_shpix,      
   PUSH1(2),
   op_add,
   op_alignrp,    /* -| tz1+2, tz1, width */


   /* Do the other side. */
   /* -| tz1, width */
   PUSH1(1),
   op_add,
   op_dup,
   op_dup,     /* -| tz1+1, tz1+1, tz1+1, width */
   op_srp0,
   op_roll,    /* -| width, tz1+1, tz1+1 */
   op_shpix,      
   PUSH1(2),
   op_add,
   op_alignrp,    /* -| tz1+3 */

   /* Done. */
ENDF






/******* CENTER HSTEM FUNCTION
 *
 * Args: p1, p2, c, tz1, width
 *
 */
FDEF(TTFUN_HCENTER)

   /* Set,rounding state for the center. */
   PUSH2(1, 6),
   op_cindex,
   op_add,
   op_rs,
   op_if,
       op_rthg,
   op_else,
       op_rtg,
   op_eif,

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 4),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,


   /* Move/round center. */
   WCVT(TMPCVT),  /* c */
   PUSH2(TMPPNT, TMPCVT),
   op_miap| SUBOP_R,
   op_rtg,

   /* Align all points to the center. */
   op_dup, op_dup, PUSH1(1), op_add,
   op_alignrp, op_alignrp,   /* tz1, tz1+1 */


   /* Compute the width. */
   op_swap,
   op_rs,
   PUSH1(CURVEPHASE),
   op_sub,
   op_swap,


   /* -| tz1, width */
   op_dup,
   PUSH1(3), op_cindex,
   op_neg,     /* -| -width, tz1, tz1, width */
   op_shpix,      

   /* Do the other side. */
   /* -| tz1, width */
   PUSH1(1),
   op_add,
   op_swap,    /* -| width, tz1+1 */
   op_shpix,      

   /* Done. */
ENDF





/******* RELATIVE1V STEM FUNCTION
 *
 * Args: p1, p2, p3, p4, ref, tz1, width
 *
 */
FDEF(TTFUN_RELATIVE1V)

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 6),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 6),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 2, 5),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 3, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   /* Move/round side. */
   op_srp0,
   op_dup,
   op_mdrp | SUBOP_MmRGR,

   /* Align points on the left side. */
   op_dup, PUSH1(1), op_add, op_dup, op_dup, op_dup,
   PUSH1(1), op_add,  /* -| tz1+2, tz1+1, tz1+1, tz+1, tz, width */
   op_alignrp,
   op_alignrp,

   /* Align right side */
   op_srp0,    /* -| tz1+1, tz1, width */
   op_roll,
   op_rs,
   op_dup,
   op_add,     /* -| width*2, tz1+1, tz1 */
   op_shpix,
   PUSH1(3),
   op_add,
   op_alignrp,    /* -| tz1+3 */

ENDF





/******* RELATIVE2V STEM FUNCTION
 *
 * Args: p1, p2, p3, p4, ref, tz1, width
 *
 */
FDEF(TTFUN_RELATIVE2V)

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 6),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 6),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 2, 5),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 3, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,


   /* Move/round side. */
   op_srp0,
   op_dup,
   PUSH1(1), op_add,
   op_mdrp | SUBOP_MmRGR,

   /* Align points on the left side. */
   op_dup, op_dup, op_dup, op_dup,
   PUSH1(3), op_add,  /* -| tz1+3, tz1, tz1, tz1, tz1, width */
   op_alignrp,
   op_alignrp,


   /* Align left side */
   op_srp0,    /* -| tz1, tz1, width */
   op_roll,
   op_rs,
   op_dup,
   op_add,
   op_neg,
   op_shpix,      /* -| -2*width, tz1, tz1 */
   PUSH1(2), op_add,
   op_alignrp,    /* -| tz1+2 */

ENDF





/******* RELATIVE1H STEM FUNCTION
 *
 * Args: p1, p2, ref, tz1, width
 *
 */
FDEF(TTFUN_RELATIVE1H)

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 4),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   /* Move/round side. */
   op_srp0,
   op_dup,
   op_mdrp | SUBOP_MmRGR,


   /* Align all point to the lower side. */
   PUSH1(1), op_add, op_dup,
   op_alignrp,

   /* Align right side */
   op_swap,
   op_rs,
   op_dup,
   op_add,
   op_shpix,

ENDF





/******* RELATIVE2H STEM FUNCTION
 *
 * Args: p1, p2, ref, tz1, width
 *
 */
FDEF(TTFUN_RELATIVE2H)

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 4),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,


   /* Move/round side. */
   op_srp0,
   op_dup,
   PUSH1(1), op_add,
   op_mdrp | SUBOP_MmRGR,

   /* Align all points to the center. */
   op_dup, op_alignrp,

   /* Align left side */
   op_swap,
   op_rs,
   op_dup,
   op_add,
   op_neg,
   op_shpix,

ENDF





/******* SIDE1 STEM FUNCTION
 *
 * Args: p1, p2, zone, tz1, width
 *
 */
FDEF(TTFUN_SIDE1)

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 4),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,

   /* Move/round side. */
   PUSH2(TMPPNT, TMPPNT),
   op_srp0, op_swap, op_miap | SUBOP_R,

   /* Align all points to the side. */
   op_dup, PUSH1(1), op_add, op_dup, op_roll,
   op_alignrp, op_alignrp,

   /* Align first side */
   op_swap,
   op_rs,
   op_dup,
   op_add,
   PUSH1(CURVEPHASE),
   op_sub,
   op_shpix,

ENDF





/******* SIDE2 STEM FUNCTION
 *
 * Args:  p1, p2, zone, tz1, width
 *
 */
FDEF(TTFUN_SIDE2)

   /* Create the stem in the twilight zone. */
   WCVT(TMPCVT),
   PUSH2(TMPCVT, 4),
   op_cindex,
   op_swap,
   op_miap,

   WCVT(TMPCVT),
   PUSH3(TMPCVT, 1, 4),
   op_cindex,
   op_add,
   op_swap,
   op_miap,


   /* Move/round side. */
   PUSH2(TMPPNT, TMPPNT),
   op_srp0, op_swap, op_miap | SUBOP_R,

   /* Align all points to the side. */
   op_dup, op_dup, PUSH1(1), op_add, 
   op_alignrp, op_alignrp,

   /* Align second side */
   op_swap,
   op_rs,
   op_dup,
   op_add,
   PUSH1(CURVEPHASE),
   op_sub,
   op_neg,
   op_shpix,

ENDF


    


/******* FLEX FUNCTION
 *
 * Args on the stack: pnt_start, pnt_mid, ref_pos, pnt_mid,
 *       pnt_start, pnt_mid, cnt, p1, p2, ....
 *
 */
FDEF(TTFUN_FLEX)
   op_srp0,
   op_alignrp,
   op_wcvtf,
   op_rcvt,
   op_shpix,
   op_srp1,
   op_srp2,
   op_sloop,
   op_ip,
ENDF





/******* SCALE3 FUNCTION
 *
 * Args: cnt, p1, p2, ... 
 *
 */
FDEF(TTFUN_SCALE3)
   PUSH4(GLYPHZONE, TMPPNT1, TMPPNT, TMPPNT1),
   op_pushw1, HIBYTE(-31), LOBYTE(-31),
   PUSH3(TMPPNT, 0, TMPPNT1),
   op_pushw1, HIBYTE(1000), LOBYTE(1000),
   op_scfs,
   op_scfs,
   op_shpix,
   op_srp1,
   op_srp2,
   op_szp2,
   op_sloop,
   op_ip,
ENDF





/******* SHIFT1 FUNCTION
 *
 * Args: cnt reduction p1 p2 ...
 *
 */
FDEF(TTFUN_SHIFT1)
   op_sloop,
   op_rs,
   op_neg,
   op_shpix,
ENDF




   
/******* SHIFT2 FUNCTION
 *
 * Args: cnt reduction p1 p2 ...
 *
 */
FDEF(TTFUN_SHIFT2)
   op_sloop,
   op_rs,
   op_shpix,
ENDF





/******* IP1 FUNCTION
 *
 * Args: rp1, rp2, p1
 *
 */
FDEF(TTFUN_IP1)
   op_srp1,
   op_srp2,
   op_ip,
ENDF





/******* IP2 FUNCTION
 *
 * Args: rp1, rp2, p1, p2
 *
 */
FDEF(TTFUN_IP2)
   op_srp1,
   op_srp2,
   op_ip,
   op_ip,
ENDF





/******* IPN FUNCTION
 *
 * Args: rp1, rp2, cnt, p1, p2
 *
 */
FDEF(TTFUN_IPN)
   op_srp1,
   op_srp2,
   op_sloop,
   op_ip,
ENDF





/******* SHP1 FUNCTION
 *
 * Args: rp, p
 *
 */
FDEF(TTFUN_SHP1)
   op_srp1,
   op_shp,
ENDF





/******* SHP2 FUNCTION
 *
 * Args: rp, p1, p2
 *
 */
FDEF(TTFUN_SHP2)
   op_srp1,
   op_shp,
   op_shp,
ENDF


    

    
/******* SHPN FUNCTION
 *
 * Args: rp, cnt, p1, p2
 *
 */
FDEF(TTFUN_SHPN)
   op_srp1,
   op_sloop,
   op_shp,
ENDF





/******* RANGE FUNCTION
 *
 * Args: p
 *
 */
FDEF(TTFUN_RANGE)
   op_dup,
   PUSH1(1),
   op_add,
ENDF




/******* RANGE FUNCTION
 *
 * Args: pos_x, pos_y,
 *
 */
FDEF(TTFUN_OBLIQUE)
   op_svcta | SUBOP_Y,
   PUSH1(TMPPNT1),
   op_swap,
   op_scfs,
   PUSH2(TMPPNT, 0),
   op_scfs,
   op_svcta | SUBOP_X,
   PUSH1(TMPPNT1),
   op_swap,
   op_scfs,
   PUSH2(TMPPNT, 0),
   op_scfs,
   PUSH2(TMPPNT, TMPPNT1),
   op_spvtl,
ENDF

};


/***** LOCAL TYPES */


/***** STATIC FUNCTIONS */

/***
** Function: GetVStemWidth
**
** Description:
**   This function allocates a storage entry for the 
**   width of a vertical stem;
***/
static short GetVStemWidth(WeightControl *weight, const funit width)
{
   StemWidth *newwidths = NULL;
   short entry = 0;
   USHORT j;

   if (weight->cnt_vw >= weight->max_vw) {
      newwidths = Realloc(weight->vwidths,
                          sizeof(StemWidth)*(weight->max_vw+BUFSIZE));
      if (newwidths == NULL) {
         entry = NOMEM;
      } else {
         weight->vwidths = newwidths;
         weight->max_vw += BUFSIZE;
      }
   }

   if (entry != NOMEM) {
      for (j=0; j<weight->cnt_vw; j++) {
         if (weight->vwidths[j].width==width) {
            entry = (short)weight->vwidths[j].storage;
            break;
         }
      }

      if (j==weight->cnt_vw) {
         weight->vwidths[weight->cnt_vw].storage = weight->storage;
         weight->vwidths[weight->cnt_vw].width = width;
         entry = (short)weight->storage;
         weight->storage += 2;
         weight->cnt_vw++;
      }
   }

   return entry;
}


/***
** Function: GetHStemWidth
**
** Description:
**   This function allocates a storage entry for the 
**   width of a vertical stem;
***/
static short GetHStemWidth(WeightControl *weight, const funit width)
{
   StemWidth *newwidths = NULL;
   short entry = 0;
   USHORT j;

   if (weight->cnt_hw >= weight->max_hw) {
      newwidths = Realloc(weight->hwidths,
                          sizeof(StemWidth)*(weight->max_hw+BUFSIZE));
      if (newwidths == NULL) {
         entry = NOMEM;
      } else {
         weight->hwidths = newwidths;
         weight->max_hw += BUFSIZE;
      }
   }

   if (entry != NOMEM) {
      for (j=0; j<weight->cnt_hw; j++) {
         if (weight->hwidths[j].width==width) {
            entry = (short)weight->hwidths[j].storage;
            break;
         }
      }

      if (j==weight->cnt_hw) {
         weight->hwidths[weight->cnt_hw].storage = weight->storage;
         weight->hwidths[weight->cnt_hw].width = width;
         entry = (short)weight->storage;
         weight->storage += 2;
         weight->cnt_hw++;
      }
   }

   return entry;
}




/***** GLOBAL FUNCTIONS */

/***
** Function: SetZone
**
** Description:
**   This function initiate an alignment zone
**   by creating an appropriate point in the
**   twilight zone.
***/
USHORT SetZone(UBYTE *prep, USHORT tp, const short cvt)
{
   /* Set up the zone. */
   if (cvt>255) {
      prep[tp++] = op_pushw1;
      prep[tp++] = HIBYTE(cvt);
      prep[tp++] = LOBYTE(cvt);
      prep[tp++] = op_pushb1;
      prep[tp++] = TTFUN_SET_ZONE;
   } else {
      prep[tp++] = op_pushb1 + 1;
      prep[tp++] = (UBYTE)cvt;
      prep[tp++] = TTFUN_SET_ZONE;
   }
   prep[tp++] = op_call;

   return tp;
}



/***
** Function: CopyZone
**
** Description:
**   This function copies a cvt entry, representing an
**   alignment zone, to the cvt used for a particular hstem.
***/
USHORT CopyZone(UBYTE *prep, short tp, short *args, const short ta)
{
   args[0] = TTFUN_COPY_ZONE;
   args[1] = (short)((ta-2)/2);
   AssembleArgs(args, ta, prep, &tp);
   prep[tp++] = op_loopcall;

   return (USHORT)tp;
}



/***
** Function: CopyFamilyBlue
**
** Description:
**   This function copies a cvt entry, representing a
**   family blue zone, to the cvt used for a particular hstem.
***/
USHORT CopyFamilyBlue(UBYTE *prep, short tp, short *args, const short ta)
{
   args[0] = TTFUN_COPY_FAMILY;
   args[1] = (short)(ta-2);
   AssembleArgs(args, ta, prep, &tp);
   prep[tp++] = op_loopcall;

   return (USHORT)tp;
}



/***
** Function: AlignFlat
**
** Description:
**   This function creates a cvt entry for
**   a particular hstem.
***/
USHORT AlignFlat(UBYTE *prep, short tp, short *args, const short ta)
{
   args[0] = TTFUN_ALIGN_BLUE_ZONE;
   args[1] = (short)(ta-2);
   AssembleArgs(args, ta, prep, &tp);
   prep[tp++] = op_loopcall;

   return (USHORT)tp;
}



/***
** Function: AlignOvershoot
**
** Description:
**   This function creates a cvt entry for
**   a particular hstem.
***/
USHORT AlignOvershoot(UBYTE *prep, short tp, short *args, const short ta)
{
   args[0] = TTFUN_SHIFT_BLUE_ZONE;
   args[1] = (short)(ta-2);
   AssembleArgs(args, ta, prep, &tp);
   prep[tp++] = op_loopcall;

   return (USHORT)tp;
}


/***
** Function: GetTopPos
**
** Description:
**   This function allocates a cvt entry for the 
**   top side of a horizontal stem;
***/
short GetTopPos(const Blues *blues,
                AlignmentControl *align,
                const funit pos)
{
   short entry = UNDEF;
   const funit *bluevals;
   short fuzz;
   USHORT i, j;

   bluevals = &(blues->bluevalues[0]);
   fuzz = blues->blueFuzz;

   /* Check if it is within a zone. */
   for (i=0; i<blues->blue_cnt; i+=2) {
      if (((bluevals[i]-fuzz)<=pos) && ((bluevals[i+1]+fuzz)>=pos))
         break;
   }

   /* Record the position? */
   if (i!=blues->blue_cnt) {
      i /= 2;

      /* Is the position already mapped to a cvt entry? */
      for (j=0; j<align->top[i].cnt; j++) {
         if (align->top[i].pos[j].y==pos) {
            entry = (short)align->top[i].pos[j].cvt;
            break;
         }
      }

      if (j==align->top[i].cnt) {

         /* Allocate the BlueZone cvt's */
         if (align->top[i].cnt==0) {
            align->top[i].blue_cvt = align->cvt;
            align->cvt +=2;
         }

         align->top[i].pos[align->top[i].cnt].cvt = align->cvt;
         align->top[i].pos[align->top[i].cnt].y = pos;
         entry = (short)align->cvt;
         align->cvt+=2;
         align->top[i].cnt++;
      }
   }

   return entry;
}


/***
** Function: GetBottomPos
**
** Description:
**   This function allocates a cvt entry for the 
**   top side of a horizontal stem;
***/
short GetBottomPos(const Blues *blues,
                   AlignmentControl *align,
                   const funit pos)
{
   short entry = UNDEF;
   const funit *bluevals;
   short fuzz;
   USHORT i, j;

   bluevals = &(blues->otherblues[0]);
   fuzz = blues->blueFuzz;

   /* Check if it is within a zone. */
   for (i=0; i<blues->oblue_cnt; i+=2) {
      if (((bluevals[i]-fuzz)<=pos) && ((bluevals[i+1]+fuzz)>=pos))
         break;
   }


   /* Record the position? */
   if (i!=blues->oblue_cnt) {
      i /= 2;

      /* Is the position already mapped to a cvt entry? */
      for (j=0; j<align->bottom[i].cnt; j++) {
         if (align->bottom[i].pos[j].y==pos) {
            entry = (short)align->bottom[i].pos[j].cvt;
            break;
         }
      }

      if (j==align->bottom[i].cnt) {

         /* Allocate the BlueZone and FamilyBlue cvt's */
         if (align->bottom[i].cnt==0) {
            align->bottom[i].blue_cvt = align->cvt++;
         }

         align->bottom[i].pos[align->bottom[i].cnt].cvt = align->cvt;
         align->bottom[i].pos[align->bottom[i].cnt].y = pos;
         entry = (short)align->cvt;
         align->cvt+=2;
         align->bottom[i].cnt++;
      }
   }

   return entry;
}


/***
** Function: CutInSize
**
** Description:
**   This function computes the cut in size
**   of a stem, given a master width and the
**   width of the stem. This is done with the
**   StdVW==2.0 pixel treshold and the thinn
**   and wide cut in values.
***/
USHORT CutInSize(const funit width,
                 const funit master,
                 const USHORT tresh,
                 const funit upem)
{
   USHORT cis, ci1, ci2;

   /*lint -e776 */
   if (width > master) {
      ci1 = (USHORT)((long)upem * SMALL_UPPER / ONEPIXEL /
                     (long)(width - master));
      ci2 = (USHORT)((long)upem * LARGE_UPPER / ONEPIXEL /
                     (long)(width - master));
   } else if (width < master) {
      ci1 = (USHORT)((long)upem * SMALL_LOWER / ONEPIXEL /
                     (long)(master - width));
      ci2 = (USHORT)((long)upem * LARGE_LOWER / ONEPIXEL /
                     (long)(master - width));
   } else {
      ci1 = INFINITY;  
      ci2 = INFINITY;
   }
   /*lint +e776 */

   if (ci1 < tresh) {
      cis = ci1;
   } else if (ci2 < tresh) {
      cis = tresh;
   } else {
      cis = ci2;
   }

   return cis;
}


/***
** Function: SnapStemArgs
**
** Description:
**   
***/
USHORT SnapStemArgs(short *args, USHORT ta,
                    const funit width,
                    const USHORT std_cvt,
                    const USHORT snap_cvt,
                    const USHORT std_ci,
                    const USHORT snap_ci,
                    const USHORT storage)
{
   args[ta++] = (short)std_ci;
   args[ta++] = (short)std_cvt;
   args[ta++] = (short)snap_ci;
   args[ta++] = (short)snap_cvt;
   args[ta++] = (short)(width/2);
   args[ta++] = (short)storage;

   return ta;
}



/***
** Function: StdStemArgs
**
** Description:
**   
***/
USHORT StdStemArgs(short *args, USHORT ta,
                   const funit width,
                   const USHORT std_cvt,
                   const USHORT std_ci,
                   const USHORT storage)
{
   args[ta++] = (short)std_ci;
   args[ta++] = (short)std_cvt;
   args[ta++] = (short)(width/2);
   args[ta++] = (short)storage;

   return ta;
}



/***
** Function: CreateStdStems
**
** Description:
**   
***/
USHORT CreateStdStems(UBYTE *prep, USHORT tp, const short cnt)
{
   if (cnt>255) {
      prep[tp++] = op_pushw1;
      prep[tp++] = HIBYTE(cnt);
      prep[tp++] = LOBYTE(cnt);
      prep[tp++] = op_pushb1;
      prep[tp++] = TTFUN_STEM_STD_WIDTH;
   } else {
      prep[tp++] = op_pushb1 + 1;
      prep[tp++] = (UBYTE)cnt;
      prep[tp++] = TTFUN_STEM_STD_WIDTH;
   }

   prep[tp++] = op_loopcall;

   return tp;
}



/***
** Function: CreateSnapStems
**
** Description:
**   
***/
USHORT CreateSnapStems(UBYTE *prep, USHORT tp, const short cnt)
{
   if (cnt>255) {
      prep[tp++] = op_pushw1;
      prep[tp++] = HIBYTE(cnt);
      prep[tp++] = LOBYTE(cnt);
      prep[tp++] = op_pushb1;
      prep[tp++] = TTFUN_STEM_SNAP_WIDTH;
   } else {
      prep[tp++] = op_pushb1 + 1;
      prep[tp++] = (UBYTE)cnt;
      prep[tp++] = TTFUN_STEM_SNAP_WIDTH;
   }

   prep[tp++] = op_loopcall;

   return tp;
}




/***
** Function: tt_GetFontProg
**
** Description:
**   This function returns the static font
**   font program.
***/
const UBYTE *tt_GetFontProg(void)
{
   return FontProg;
}




/***
** Function: tt_GetFontProgSize
**
** Description:
**   This function returns the size of the
**   static font program.
***/
USHORT tt_GetFontProgSize(void)
{
   return (USHORT)sizeof(FontProg);
}




/***
** Function: tt_GetNumFuns
**
** Description:
**   This function returns the number of functions
**   defined in the static font program.
***/
USHORT tt_GetNumFuns(void)
{
   return (USHORT)TTFUN_NUM;
}



/***
** Function: EmitFlex
**
** Description:
**   Convert a T1 flex hint into a TrueType IP[] 
**   intruction sequence that will reduce a flex
**   that is flatter than a given height.
***/
errcode EmitFlex(short *args,
                 short *pcd,
                 const funit height,
                 const short start,
                 const short mid,
                 const short last)
{
   errcode status = SUCCESS;
   int i;

   /* Enough space for the instructions? */
   args[(*pcd)++] = TTFUN_FLEX;
   args[(*pcd)++] = start;
   args[(*pcd)++] = mid;
   args[(*pcd)++] = (short)height;
   args[(*pcd)++] = TMPCVT;
   args[(*pcd)++] = TMPCVT;
   args[(*pcd)++] = mid;
   args[(*pcd)++] = start;
   args[(*pcd)++] = mid;

   /* Push the flex points onto the stack. */
   args[(*pcd)++] = (short)(last-start-2);
   for (i=start+(short)1; i<last; i++)
      if (i!=mid)
         args[(*pcd)++] = (short)i;

   return status;
}




/***
** Function: ReduceDiagonals
**
** Description:
**   This function generates the TT instructions
**   that will shrink the outline, in order to
**   control the width of diagonals. This implementation
**   can probably be improved.
***/
short ReduceDiagonals(const Outline *paths,
                      UBYTE *pgm, short *pc,
                      short *args,  short *pcd)
{
   short cw[MAXTHINPNTS];
   short ccw[MAXTHINPNTS];
   short targ[MAXTHINPNTS];
   const Outline *path;
   Point *pts;
   short i,j;
   short cwi = 0, ccwi = 0;
   short prev;
   short n,m;
   short prev_cw, prev_ccw;
   short ta;



   /* Collect points on left and right side that are diagonals. */
   i = 0;
   for (path = paths; path && ccwi<MAXTHINPNTS && cwi<MAXTHINPNTS;
   path=path->next) {

      pts = &path->pts[0];
      prev_cw = FALSE;
      prev_ccw = FALSE;

      /* Are the first and last point coinciding? */
      if (pts[path->count-1].x!=pts[0].x ||
          pts[path->count-1].y!=pts[0].y)
         prev = (short)(path->count-(short)1);
      else
         prev = (short)(path->count-(short)2);

      /* Special case the first point. */
      if (!OnCurve(path->onoff, prev) ||
          (pts[0].x != pts[prev].x &&
           ABS(pts[0].x - pts[prev].x) < ABS(pts[0].y - pts[prev].y)*8)) {
         if (pts[0].y>pts[prev].y+20) {
            if (pts[prev].y<=pts[prev-1].y)
               cw[cwi++] = (short)(i+(short)path->count-1);
            cw[cwi++] = i;
            prev_cw = TRUE;
            prev_ccw = FALSE;
         } else if (pts[0].y<pts[prev].y-20) {
            if (pts[prev].y>=pts[prev-1].y)
               ccw[ccwi++] = (short)(i+(short)path->count-1); 
            ccw[ccwi++] = i;
            prev_cw = FALSE;
            prev_ccw = TRUE;
         }
      }


      for (j=1; j<(short)path->count &&
             ccwi<MAXTHINPNTS && cwi<MAXTHINPNTS; j++) {
         i++;
         if (!OnCurve(path->onoff, j-1) ||
             (pts[j].x != pts[j-1].x &&
              ABS(pts[j].x - pts[j-1].x) < ABS(pts[j].y - pts[j-1].y)*8)) {
            if (pts[j].y>pts[j-1].y+20) {
               if (!prev_cw)
                  cw[cwi++] = (short)(i-1);
               cw[cwi++] = i;
               prev_cw = TRUE; 
               prev_ccw = FALSE;
            } else if (pts[j].y<pts[j-1].y-20) {
               if (!prev_ccw)
                  ccw[ccwi++] = (short)(i-1);
               ccw[ccwi++] = i;
               prev_cw = FALSE;
               prev_ccw = TRUE;
            } else {
               prev_cw = FALSE;
               prev_ccw = FALSE;
            }
         } else {
            prev_cw = FALSE;
            prev_ccw = FALSE;
         }
      }
      i++;
   }


   /* Did we get all points? */
   if (ccwi>=MAXTHINPNTS || cwi>=MAXTHINPNTS) {
      LogError(MSG_WARNING, MSG_DIAG, NULL);
   }


   /* Any points to shift? */
   if (cwi || ccwi) {
      args[(*pcd)++] = STORAGE_DIAG;
      pgm[(*pc)++] = op_rs;
      pgm[(*pc)++] = op_if;
      pgm[(*pc)++] = op_svcta + SUBOP_X;

      /* Switch over to GLYPHZONE */
      pgm[(*pc)++] = op_szp2;
      args[(*pcd)++] = 1;


      ta = 3;

      /* Disable "cw[m] may not have been initialized".*/ /*lint -e644 */
      for (n=0; n<cwi; n=m) {
         for (m=(short)(n+1); m<cwi && cw[m]==cw[m-1]+1; m++); /*lint +e644 */
         if (m-n<=4) {
            for (i=n; i<m; i++)
               targ[ta++] = cw[i];
         } else {
            targ[0] = TTFUN_RANGE;
            targ[1] = (short)(m-n-1);
            targ[2] = cw[n];
            AssembleArgs(targ, ta, pgm, pc);
            pgm[(*pc)++] = op_loopcall;
            ta = 3;
         }
      }
      targ[0] = TTFUN_SHIFT1;
      targ[1] = cwi;
      targ[2] = STORAGE_DIAG;
      AssembleArgs(targ, ta, pgm, pc);
      pgm[(*pc)++] = op_call;


      /************ Shift back the left side of the glyph. */

      ta = 3;

      /* Disable "ccw[m] may not have been initialized".*/ /*lint -e644 */
      for (n=0; n<ccwi; n=m) {
         for (m=(short)(n+1); m<ccwi && ccw[m]==ccw[m-1]+1; m++); /*lint +e644 */
         if (m-n<=4) {
            for (i=n; i<m; i++)
               targ[ta++] = ccw[i];
         } else {
            targ[0] = TTFUN_RANGE;
            targ[1] = (short)(m-n-1);
            targ[2] = ccw[n];
            AssembleArgs(targ, ta, pgm, pc);
            pgm[(*pc)++] = op_loopcall;
            ta = 3;
         }
      }
      targ[0] = TTFUN_SHIFT2;
      targ[1] = ccwi;
      targ[2] = STORAGE_DIAG;
      AssembleArgs(targ, ta, pgm, pc);
      pgm[(*pc)++] = op_call;


#ifdef SYMETRICAL_REDUCTION

      /* The amount that the outline is shrunk is computed once at
      each size, in the pre-program. The outline is shrunk
      symetrically by the amount: 1/16 + (12 Funits)*size/UPEm.

      This approach yields more symmetrical results than shrinking
      the outline horizontally alone (see separate papers on the topic). */


      /* Same thing for the height... */
      i = 0;
      cwi = 0;
      ccwi = 0;
      for (path = paths; path && ccwi<MAXTHINPNTS && cwi<MAXTHINPNTS;
      path=path->next) {

         pts = &path->pts[0];

         /* Are the first and last point coinciding? */
         if (pts[path->count-1].y!=pts[0].y ||
             pts[path->count-1].x!=pts[0].x)
            prev = path->count-1;
         else
            prev = path->count-2;

         if (!OnCurve(path->onoff, prev) ||
             (pts[0].y != pts[prev].y &&
              ABS(pts[0].y - pts[prev].y) < ABS(pts[0].x - pts[prev].x)*8)) {
            if (pts[0].x>pts[prev].x+20) {
               if (pts[prev].x<=pts[prev-1].x)
                  cw[cwi++] = i+path->count-1;
               cw[cwi++] = i;
            } else if (pts[0].x<pts[prev].x-20) {
               if (pts[prev].x>=pts[prev-1].x)
                  ccw[ccwi++] = i+path->count-1; 
               ccw[ccwi++] = i;
            }
         }


         for (j=1; j<path->count && ccwi<MAXTHINPNTS && cwi<MAXTHINPNTS; j++) {
            i++;
            if (!OnCurve(path->onoff, j-1) ||
                (pts[j].y != pts[j-1].y &&
                 ABS(pts[j].y - pts[j-1].y) < ABS(pts[j].x - pts[j-1].x)*8)) {
               if (pts[j].x>pts[j-1].x+20) {
                  if (!cwi || cw[cwi-1]!=i-1)
                     cw[cwi++] = i-1;
                  cw[cwi++] = i;
               } else if (pts[j].x<pts[j-1].x-20) {
                  if (!ccwi || ccw[ccwi-1]!=i-1)
                     ccw[ccwi++] = i-1;
                  ccw[ccwi++] = i;
               }
            }
         }
         i++;
      }


      if (ccwi>=MAXTHINPNTS || cwi>=MAXTHINPNTS) {
         LogError(MSG_WARNING, MSG_DIAG, NULL);
      }


      /* Any points to shift? */
      if (cwi || ccwi) {
         pgm[(*pc)++] = op_svcta + SUBOP_Y;


         for (n=0; n<cwi; n=m) {
            for (m=n+1; m<cwi && cw[m]==cw[m-1]+1; m++);
            pgm[(*pc)++] = op_pushb1 + 2;
            pgm[(*pc)++] = cw[n];
            pgm[(*pc)++] = (UBYTE)(m-n-1);
            pgm[(*pc)++] = TTFUN_RANGE;
            pgm[(*pc)++] = op_loopcall;
         }
         pgm[(*pc)++] = op_pushb1+2;
         pgm[(*pc)++] = STORAGE_DIAG;
         pgm[(*pc)++] = cwi;
         pgm[(*pc)++] = TTFUN_SHIFT2;
         pgm[(*pc)++] = op_call;



         /************ Shift back the left side of the glyph. */


         for (n=0; n<ccwi; n=m) {
            for (m=n+1; m<ccwi && ccw[m]==ccw[m-1]+1; m++);
            pgm[(*pc)++] = op_pushb1 + 2;
            pgm[(*pc)++] = (UBYTE)ccw[n];
            pgm[(*pc)++] = (UBYTE)(m-n-1);
            pgm[(*pc)++] = TTFUN_RANGE;
            pgm[(*pc)++] = op_loopcall;
         }
         pgm[(*pc)++] = op_pushb1+2;
         pgm[(*pc)++] = STORAGE_DIAG;
         pgm[(*pc)++] = (UBYTE)ccwi;
         pgm[(*pc)++] = TTFUN_SHIFT1;
         pgm[(*pc)++] = op_call;
      }
#endif

      pgm[(*pc)++] = op_eif;
   }

   /* Args + num of args + function number. */
   return (short)(MAX(cwi, ccwi)+2); 
}




/***
** Function: ScaleDown3
**
** Description:
**   This function generates the TT instructions
**   that will scale down points 3%.
***/
void ScaleDown3(const Extremas *extr, const short xcnt, 
                UBYTE *pgm, short *pc,
                short *args, short *pcd)
{
   short i,j,offset, opc, opcd;

   /* Remember the state of the stacks. */
   opc = (*pc);
   opcd = (*pcd);

   args[(*pcd)++] = TTFUN_SCALE3;

   offset = (*pcd)++;
   args[offset] = 0;
   for (i=0; i<xcnt; i++) {
      if ((extr[i].rp1==UNDEF || extr[i].rp2==UNDEF)) {
         for (j=0; j<extr[i].n; j++) {
            args[(*pcd)++] = extr[i].pts[j];
         }
         args[offset] = (short)(args[offset] + extr[i].n);
      }
   }
   if (args[offset]>0) {
      pgm[(*pc)++] = op_call;
   } else {
      /* Back track. */
      (*pc) = opc;
      (*pcd) = opcd;
   }
}


/***
** Function: EmitIP
**
** Description:
**   This function generates the TT instructions
**   that will interpolate points that are either
**   within or between stem sides.
***/
void EmitIP(const Extremas *extr, const short xcnt, 
            UBYTE *pgm, short *pc,
            short *args, short *pcd,
            const short scale3offset)
{
   short i,j,num;
   short ones[MAXIP], twoes[MAXIP], nths[MAXIP];
   short cnt1, cnt2, cntn;


   /*lint -e530 -e644 */
   /* Shift extrems. */
   cnt1 = 0; cnt2 = 0; cntn = 0; num = 0;
   for (i=0; i<xcnt; i++) {
      short rp;

      /* Skip interpolations. */
      if (extr[i].rp1!=UNDEF && extr[i].rp2!=UNDEF)
         continue;

      /* Set the reference points. */
      if (extr[i].rp1!=UNDEF) {
         rp = (short)(extr[i].rp1+scale3offset);
      }  else {
         rp = (short)(extr[i].rp2+scale3offset);
      }

      if (extr[i].n==1) {
         if ((cnt1+2)>=MAXIP) {
            pgm[(*pc)++] = op_loopcall;
            args[(*pcd)++] = TTFUN_SHP1;
            args[(*pcd)++] = (short)(cnt1/2);
            for (j=0; j<cnt1; j++)
               args[(*pcd)++] = (short)ones[j];
            cnt1 = 0;
         }
         ones[cnt1++] = rp;
         ones[cnt1++] = extr[i].pts[0];
      } else if (extr[i].n==2) {
         if ((cnt2+3)>=MAXIP) {
            pgm[(*pc)++] = op_loopcall;
            args[(*pcd)++] = TTFUN_SHP2;
            args[(*pcd)++] = (short)(cnt2/3);
            for (j=0; j<cnt2; j++)
               args[(*pcd)++] = (short)twoes[j];
            cnt2 = 0;
         }
         twoes[cnt2++] = rp;
         twoes[cnt2++] = extr[i].pts[0];
         twoes[cnt2++] = extr[i].pts[1];
      } else {
         if ((cntn+2+extr[i].n)>=MAXIP) {
            pgm[(*pc)++] = op_loopcall;
            args[(*pcd)++] = TTFUN_SHPN;
            args[(*pcd)++] = num;
            for (j=0; j<cntn; j++)
               args[(*pcd)++] = (short)nths[j];
            cntn = 0;
            num = 0;
         }
         nths[cntn++] = rp;
         nths[cntn++] = extr[i].n;
         for (j=0; j<extr[i].n; j++) {
            nths[cntn++] = extr[i].pts[j];
         }
         num++;
      }
   }

   if (cnt1) {
      if (cnt1>2) {
         pgm[(*pc)++] = op_loopcall;
         args[(*pcd)++] = TTFUN_SHP1;
         args[(*pcd)++] = (short)(cnt1/2);
      } else {
         pgm[(*pc)++] = op_call;
         args[(*pcd)++] = TTFUN_SHP1;
      }
      for (i=0; i<cnt1; i++)
         args[(*pcd)++] = ones[i];
   }
   if (cnt2) {
      if (cnt2>3) {
         pgm[(*pc)++] = op_loopcall;
         args[(*pcd)++] = TTFUN_SHP2;
         args[(*pcd)++] = (short)(cnt2/3);
      } else {
         pgm[(*pc)++] = op_call;
         args[(*pcd)++] = TTFUN_SHP2;
      }
      for (i=0; i<cnt2; i++)
         args[(*pcd)++] = twoes[i];
   }
   if (cntn) {
      if (num>1) {
         pgm[(*pc)++] = op_loopcall;
         args[(*pcd)++] = TTFUN_SHPN;
         args[(*pcd)++] = num;
      } else {
         pgm[(*pc)++] = op_call;
         args[(*pcd)++] = TTFUN_SHPN;
      }
      for (i=0; i<cntn; i++)
         args[(*pcd)++] = (short)nths[i];
   }


   /* Interpolate the extrems. */
   cnt1 = 0; cnt2 = 0; cntn = 0; num = 0;
   for (i=0; i<xcnt; i++) {

      /* Skip interpolations. */
      if (extr[i].rp1==UNDEF || extr[i].rp2==UNDEF)
         continue;

      if (extr[i].n==1) {
         if ((cnt1+3)>=MAXIP) {
            pgm[(*pc)++] = op_loopcall;
            args[(*pcd)++] = TTFUN_IP1;
            args[(*pcd)++] = (short)(cnt1/2);
            for (j=0; j<cnt1; j++)
               args[(*pcd)++] = (short)ones[j];
            cnt1 = 0;
         }
         ones[cnt1++] = extr[i].rp1;
         ones[cnt1++] = extr[i].rp2;
         ones[cnt1++] = extr[i].pts[0];
      } else if (extr[i].n==2) {
         if ((cnt2+4)>=MAXIP) {
            pgm[(*pc)++] = op_loopcall;
            args[(*pcd)++] = TTFUN_IP2;
            args[(*pcd)++] = (short)(cnt2/3);
            for (j=0; j<cnt2; j++)
               args[(*pcd)++] = (short)twoes[j];
            cnt2 = 0;
         }
         twoes[cnt2++] = extr[i].rp1;
         twoes[cnt2++] = extr[i].rp2;
         twoes[cnt2++] = extr[i].pts[0];
         twoes[cnt2++] = extr[i].pts[1];
      } else {
         if ((cntn+3+extr[i].n)>=MAXIP) {
            pgm[(*pc)++] = op_loopcall;
            args[(*pcd)++] = TTFUN_IPN;
            args[(*pcd)++] = num;
            for (j=0; j<cntn; j++)
               args[(*pcd)++] = (short)nths[j];
            cntn = 0;
            num = 0;
         }
         nths[cntn++] = extr[i].rp1;
         nths[cntn++] = extr[i].rp2;
         nths[cntn++] = extr[i].n;
         for (j=0; j<extr[i].n; j++) {
            nths[cntn++] = extr[i].pts[j];
         }
         num++;
      }
   }

   if (cnt1) {
      if (cnt1>3) {
         pgm[(*pc)++] = op_loopcall;
         args[(*pcd)++] = TTFUN_IP1;
         args[(*pcd)++] = (short)(cnt1/3);
      } else {
         pgm[(*pc)++] = op_call;
         args[(*pcd)++] = TTFUN_IP1;
      }
      for (i=0; i<cnt1; i++)
         args[(*pcd)++] = (short)ones[i];
   }
   if (cnt2) {
      if (cnt2>4) {
         pgm[(*pc)++] = op_loopcall;
         args[(*pcd)++] = TTFUN_IP2;
         args[(*pcd)++] = (short)(cnt2/4);
      } else {
         pgm[(*pc)++] = op_call;
         args[(*pcd)++] = TTFUN_IP2;
      }
      for (i=0; i<cnt2; i++)
         args[(*pcd)++] = (short)twoes[i];
   }
   if (cntn) {
      if (num>1) {
         pgm[(*pc)++] = op_loopcall;
         args[(*pcd)++] = TTFUN_IPN;
         args[(*pcd)++] = num;
      } else {
         pgm[(*pc)++] = op_call;
         args[(*pcd)++] = TTFUN_IPN;
      }
      for (i=0; i<cntn; i++)
         args[(*pcd)++] = (short)nths[i];
   }
   /*lint +e530 +e644 */
}




/***
** Function: EmitVerticalStem
**
** Description:
**   This function generates the code that
**   will initiate the graphics state of the
**   TrueType interpreter for the grid fitting
**   of vertical stems.
***/
void EmitVerticalStems(UBYTE *pgm, short *pc, short *args, short *pcd)
{
   pgm[(*pc)++] = op_call;
   args[(*pcd)++] = TTFUN_VERTICAL;
}





/***
** Function: EmitHorizontalStem
**
** Description:
**   This function generates the code that
**   will initiate the graphics state of the
**   TrueType interpreter for the grid fitting
**   of vertical stems.
***/
void EmitHorizontalStems(UBYTE *pgm, short *pc, short *args, short *pcd)
{
   pgm[(*pc)++] = op_call;
   args[(*pcd)++] = TTFUN_HORIZONTAL;
}





/***
** Function: EmitVStem
**
** Description:
**   This function generates the code that
**   will create and grid fit points in the
**   twilight zone, corresponding to a vstem.
***/
errcode EmitVStem(UBYTE *pgm, short *pc,
                  short *args, short *pcd,
                  struct T1Metrics *t1m,
                  const funit width,
                  const funit real_side1,
                  const funit real_side2,
                  const funit side1,
                  const funit side2,
                  const short rp,
                  const enum aligntype align,
                  const short ref)
{
                     errcode status = SUCCESS;
                     short w_storage;

                     if ((w_storage = GetVStemWidth(GetWeight(t1m), width))==NOMEM) {
                        SetError(status = NOMEM);
                     } else {

                        pgm[(*pc)++] = op_call;
                        switch (align) {
                           case at_centered:
                              args[(*pcd)++] = TTFUN_VCENTER;
                              args[(*pcd)++] = (short)real_side1;
                              args[(*pcd)++] = (short)real_side2;
                              args[(*pcd)++] = (short)side1;
                              args[(*pcd)++] = (short)side2;
                              args[(*pcd)++] = (short)((side1+side2)/2);
                              args[(*pcd)++] = rp;
                              args[(*pcd)++] = w_storage;
                              break;

                           case at_relative1:
                              args[(*pcd)++] = TTFUN_RELATIVE1V;
                              args[(*pcd)++] = (short)real_side1;
                              args[(*pcd)++] = (short)real_side2;
                              args[(*pcd)++] = (short)side1;
                              args[(*pcd)++] = (short)side2;
                              args[(*pcd)++] = ref;
                              args[(*pcd)++] = rp;
                              args[(*pcd)++] = w_storage;
                              break;

                           case at_relative2:
                              args[(*pcd)++] = TTFUN_RELATIVE2V;
                              args[(*pcd)++] = (short)real_side1;
                              args[(*pcd)++] = (short)real_side2;
                              args[(*pcd)++] = (short)side1;
                              args[(*pcd)++] = (short)side2;
                              args[(*pcd)++] = ref;
                              args[(*pcd)++] = rp;
                              args[(*pcd)++] = w_storage;
                              break;

                           case at_side1:
                           case at_side2:
                              LogError(MSG_WARNING, MSG_ALIGN, NULL);
                              break;
                        }
                     }

                     return status;
} 




/***
** Function: EmitHStem
**
** Description:
**   This function generates the code that
**   will create and grid fit points in the
**   twilight zone, corresponding to a hstem.
***/
errcode EmitHStem(UBYTE *pgm, short *pc,
                  short *args, short *pcd,
                  struct T1Metrics *t1m,
                  const funit width,
                  const funit side1,
                  const funit side2,
                  const short rp,
                  const enum aligntype align,
                  const short ref)
{
   errcode status = SUCCESS;
   short w_storage;

   if ((w_storage = GetHStemWidth(GetWeight(t1m), width))==NOMEM) {
      SetError(status = NOMEM);
   } else {

      pgm[(*pc)++] = op_call;
      switch (align) {

         case at_side1:
            args[(*pcd)++] = TTFUN_SIDE1;
            args[(*pcd)++] = (short)side1;
            args[(*pcd)++] = (short)side2;
            args[(*pcd)++] = ref;
            args[(*pcd)++] = rp;
            args[(*pcd)++] = w_storage;
            break;

         case at_side2:
            args[(*pcd)++] = TTFUN_SIDE2;
            args[(*pcd)++] = (short)side1;
            args[(*pcd)++] = (short)side2;
            args[(*pcd)++] = ref;
            args[(*pcd)++] = rp;
            args[(*pcd)++] = w_storage;
            break;

         case at_relative1:
            args[(*pcd)++] = TTFUN_RELATIVE1H;
            args[(*pcd)++] = (short)side1;
            args[(*pcd)++] = (short)side2;
            args[(*pcd)++] = ref;
            args[(*pcd)++] = rp;
            args[(*pcd)++] = w_storage;
            break;

         case at_relative2:
            args[(*pcd)++] = TTFUN_RELATIVE2H;
            args[(*pcd)++] = (short)side1;
            args[(*pcd)++] = (short)side2;
            args[(*pcd)++] = ref;
            args[(*pcd)++] = rp;
            args[(*pcd)++] = w_storage;
            break;

         case at_centered:
         default:
            args[(*pcd)++] = TTFUN_HCENTER;
            args[(*pcd)++] = (short)side1;
            args[(*pcd)++] = (short)side2;
            args[(*pcd)++] = (short)((side1+side2)/2);
            args[(*pcd)++] = rp;
            args[(*pcd)++] = w_storage;
            break;
      }
   }

   return status;
}






/***
** Function: FamilyCutIn
**
** Description:
**   This function generates a branch in the
**   pre-program. 
***/
USHORT FamilyCutIn(UBYTE *prep,
                   USHORT tp,
                   const short cis)
{
   prep[tp++] = op_mppem;
   if (cis<256) {
      prep[tp++] = op_pushb1; prep[tp++] = (UBYTE)cis;
   } else {
      prep[tp++] = op_pushw1;
      prep[tp++] = HIBYTE(cis);
      prep[tp++] = LOBYTE(cis);
   }
   prep[tp++] = op_lt;
   prep[tp++] = op_if;

   return tp;
}




/***
** Function: SetProjection
**
** Description:
**   This function generates the TrueType code that
**   changes the projection vector in oblique typefaces.
***/
void SetProjection(UBYTE *pgm, short *pc,
                   short *args, short *pcd,
                   const funit x, const funit y)
{
   pgm[(*pc)++] = op_call;
   args[(*pcd)++] = TTFUN_OBLIQUE;
   args[(*pcd)++] = (short)y;
   args[(*pcd)++] = (short)x;
}


/***
** Function: AssembleArgs
**
** Description:
**   This function takes a sequence of arguments and
**   assembles them into a sequence of PUSHB1[], PUSHW1[],
**   NPUSHB[] and NPUSHW[] instructions.
***/
void AssembleArgs(short *args, const short pcd, UBYTE *is, short *cnt)
{
   short bytes;
   short i,j;


   if ((args[pcd-1] <= UCHAR_MAX && args[pcd-1]>=0)) {
      bytes = 1;
   } else {
      bytes = 0;
   }

   for (i=0, j=0; j<pcd; i++) {

      /* Pack a sequence of bytes? */
      if (bytes) {
         if ((i-j)>=255 || i==pcd ||
             (args[pcd-i-1]>UCHAR_MAX || args[pcd-i-1]<0)) {
            bytes = 0;
            if ((i-j)<=8) {
               is[(*cnt)++] = (UBYTE)(op_pushb1 + (i-j) - 1);
            } else {
               is[(*cnt)++] = op_npushb;
               is[(*cnt)++] = (UBYTE)(i-j);
            }
            while (j<i)
               is[(*cnt)++] = (UBYTE)args[pcd-1-j++];
         }

         /* Pack a sequence of words? */
      } else {
         if ((i-j)>=255 || i==pcd || 
             (args[pcd-i-1]<=UCHAR_MAX && args[pcd-i-1]>=0)) {
            bytes = 1;
            if ((i-j)<=8) {
               is[(*cnt)++] = (UBYTE)(op_pushw1 + (i-j) - 1);
            } else {
               is[(*cnt)++] = op_npushw;
               is[(*cnt)++] = (UBYTE)(i-j);
            }
            while (j<i) {
               is[(*cnt)++] = HIBYTE(args[pcd-j-1]);
               is[(*cnt)++] = LOBYTE(args[pcd-j-1]);
               j++;
            }
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontview\fontdefs.h ===
typedef enum {
    FFT_TRUETYPE,       // FFT_TRUETYPE *Must* be the first one in the list
    FFT_BITMAP,
    FFT_PRINTER,
    FFT_ATM,
    FFT_OTF,
    FFT_BAD_FILE        // FFT_BAD_FILE *Must* be the last one in the list
} FFTYPE;

typedef enum {
    DTP_UNUSED = 0,
    DTP_NORMALDRAW,
    DTP_SHRINKDRAW,
    DTP_SHRINKTEXT,
    DTP_WRAPDRAW,
    DTP_TEXTOUT
} DTYPE;

typedef struct {
    DTYPE   dtyp;
    int     cptsSize;
    BOOL    fLineUnder;
    LPTSTR  pszText;
    int     cchText;
} TXTLN;

typedef TXTLN *PTXTLN;

#define CLINES_DISPLAY  20      // max of 20 lines in sample text

typedef struct {
    LOGFONT     lfTestFont;
    TXTLN    atlDsp[CLINES_DISPLAY];
} DISPTEXT;

typedef DISPTEXT *PDISPTEXT;

typedef struct {
    int x;
    int y;
    int cx;
    int cy;
    int id;
    HWND hwnd;
    int idText;
    LPTSTR pszText;
} BTNREC;

#define FMB_TTL_ERROR   ((DWORD)-1)
#define C_PTS_PER_INCH  72          // 72 points per inch
#define CB_ONE_K        1024

#define CY_MIN_WINSIZE  300
#define CX_MIN_WINSIZE  300


#define CPTS_COPYRIGHT_SIZE 10
#define CPTS_INFO_SIZE      12
#define CPTS_SAMPLE_ALPHA   16
#define CPTS_TITLE_SIZE     30


#define ROUND_UP_DIV( x, y )    ( ((x) + (y-1)) / y )
#define OTM_STRING( lpOTM, field )   ((LPTSTR)((LPBYTE)lpOTM + (DWORD)(lpOTM->field)))
#define ABS( i )    ((i) < 0 ? -(i) : (i))
#define ARRAYSIZE(a)    (sizeof(a) / sizeof(a[0]))
#define INDEX_TYPEFACENAME   1


typedef BOOL (* PFNFONTPARSER)( HANDLE hfile, PTXTLN ptxlFontInfo );


extern HANDLE hInst;
extern HWND ghwndFrame;
extern HWND ghwndView;
extern TCHAR gszFontPath[2*MAX_PATH];


extern TCHAR gszDots[];
#define FmtFree( s )    if(NULL == (s) || (s) == gszDots) { /* do nothing */ } else LocalFree( s )

/***************************************************************************\
*
* Prototypes
*
\***************************************************************************/
//
// In FONTVIEW.C
//
BOOL InitApplication(HANDLE hInstance, HICON hIcon);
BOOL InitInstance( HANDLE  hInstance, int nCmdShow, LPTSTR  pszTitle);
void InitGlobals();
LRESULT FAR PASCAL ViewWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT FAR PASCAL FrameWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL DoCommand( HWND hWnd, WPARAM wParam, LPARAM lParam );
BOOL ParseCommand( LPTSTR lpstrCmdLine, LPTSTR pszFontPath, size_t cchFontPath, BOOL *pfPrint );
FFTYPE LoadFontFile( LPTSTR pszFontPath, PDISPTEXT pdtSmpl, HICON *phIcon );
WORD GetGDILangID();
//
//  In FMTTOOLS.C
//
int FmtMessageBox( HWND hwnd, DWORD dwTitleID, LPTSTR pszTitleStr,
    UINT fuStyle, BOOL fSound, DWORD dwTextID, ... );
LPTSTR FmtSprintf( DWORD id, ... );
PVOID AllocMem( DWORD cb );
#define FreeMem( pb )   LocalFree(pb)


#ifdef FV_DEBUG
extern void Dprintf( LPTSTR pszFmt, ... );
#   define  DBTX( s )   TEXT( s ) TEXT("\n")
#   define  DPRINT(p)   Dprintf p
#else
#   define  DPRINT(p)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontview\fvrc.h ===
#define IDS_FONTFACE    100

#define IDB_DONE        200
#define IDB_PRINT       201
#define IDB_PREV_FONT   202
#define IDB_NEXT_FONT   203

#define IDK_UP          300
#define IDK_DOWN        301
#define IDK_PGUP        302
#define IDK_PGDWN       303
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontview\fontview.c ===
/****************************************************************************\
*
*     PROGRAM: fontview.c
*
*     PURPOSE: Loads and displays fonts from the given filename
*
*     COMMENTS:
*
*     HISTORY:
*       02-Oct-1995 JonPa       Created It
*
\****************************************************************************/

#include <windows.h>                /* required for all Windows applications */
#include <commdlg.h>
#include <shellapi.h>
#include <shlwapi.h> 
#include <strsafe.h>
#include <wingdip.h>                /* prototype for GetFontRsourceInfo     */
#include <objbase.h>
#include "fontdefs.h"               /* specific to this program             */
#include "fvmsg.h"
#include "fvrc.h"
#include "ttdefs.h"



HANDLE hInst;                       /* current instance                     */
HWND ghwndView = NULL;
HWND ghwndFrame = NULL;
BOOL    gfPrint = FALSE;
TCHAR   gszFontPath[2 * MAX_PATH];
LPTSTR  gpszSampleText;
LPTSTR  gpszSampleAlph[3];
FFTYPE  gfftFontType;
LOGFONT glfFont;
DISPTEXT gdtDisplay;
HBRUSH  ghbr3DFace;
HBRUSH  ghbr3DShadow;


int gyScroll = 0;              // Vertical scroll offset in pels
int gcyLine = 0;

int gcxMinWinSize = CX_MIN_WINSIZE;
int gcyMinWinSize = CY_MIN_WINSIZE;

BOOL gbIsDBCS = FALSE;    // Indicates whether system default langID is DBCS
int  gNumOfFonts = 0;     // number of fonts in the file.
int  gIndexOfFonts = 0;   // current index of the fonts.
LPLOGFONT glpLogFonts;    // get global data by GetFontResourceInfo()

int apts[] = { 12, 18, 24, 36, 48, 60, 72 };
#define C_POINTS_LIST  (sizeof(apts) / sizeof(apts[0]))

#define CPTS_BTN_AREA   28
int gcyBtnArea = CPTS_BTN_AREA;
BTNREC gabtCmdBtns[] = {
    {   6,  6, 36, 16, IDB_DONE,      NULL, MSG_DONE,      NULL },
    {  -6,  6, 36, 16, IDB_PRINT,     NULL, MSG_PRINT,     NULL },
    {  68,  6, 20, 16, IDB_PREV_FONT, NULL, MSG_PREV_FONT, NULL }, // DBCS only.
    { -68,  6, 20, 16, IDB_NEXT_FONT, NULL, MSG_NEXT_FONT, NULL }  // DBCS only.
};

#define C_DBCSBUTTONS  2  // Prev & Next font are DBCS specific.
//
// This may be recalculated in WinMain to adjust for a DBCS locale.
//
int C_BUTTONS = (sizeof(gabtCmdBtns) / sizeof(gabtCmdBtns[0]));


#if DBG
void DDPrint( LPTSTR sz, DWORD dw ) {
    TCHAR szBuff[246];
    StringCchPrintf( szBuff, ARRAYSIZE(szBuff), sz, dw );

    OutputDebugString( szBuff );
}

#   define DDPRINT( s, d )  DDPrint( s, d )
#else
#   define DDPRINT( s, d )
#endif


#define IsZeroFSig( fs )  ( (fs)->fsUsb[0] == 0 && (fs)->fsUsb[1] == 0 && (fs)->fsUsb[2] == 0 && \
                                (fs)->fsUsb[3] == 0 && (fs)->fsCsb[0] == 0 && (fs)->fsCsb[1] == 0 )

BOOL NativeCodePageSupported(LPLOGFONT lplf) {
    BOOL fRet = FALSE;
    HDC hdc = CreateCompatibleDC(NULL);
    if (hdc)
    {
        HFONT hf, hfOld;
        FONTSIGNATURE fsig;
        CHARSETINFO  csi;

        DDPRINT( TEXT("System default code page: %d\n"), GetACP() );

        TranslateCharsetInfo( (LPDWORD)IntToPtr(GetACP()), &csi, TCI_SRCCODEPAGE );

        hf = CreateFontIndirect( lplf );

        hfOld = SelectObject( hdc, hf );

        GetTextCharsetInfo( hdc, &fsig, 0 );

        SelectObject( hdc, hfOld );

        DeleteObject(hf);

        if (IsZeroFSig( &fsig ) ) {
            // Font does not support GetTextCharsetInfo(), just go off of the lfCharSet value

            DDPRINT( TEXT("Font does not support GetTextCharsetInfo... \nTesting %d (font cs) against"), lplf->lfCharSet );
            DDPRINT( TEXT("%d (sys charset)\n"), csi.ciCharset );

            fRet = (lplf->lfCharSet == csi.ciCharset);

        } else {
            DDPRINT( TEXT("GTCI() worked...\nChecking font charset bits %08x"),  fsig.fsCsb[0] );
            DDPRINT( TEXT(" %08x against"),  fsig.fsCsb[1] );
            DDPRINT( TEXT(" system charset bits %08x "), csi.fs.fsCsb[0] );
            DDPRINT( TEXT("  %08x\n"), csi.fs.fsCsb[1] );

            fRet = ((csi.fs.fsCsb[0] &  fsig.fsCsb[0]) || (csi.fs.fsCsb[1] &  fsig.fsCsb[1]));
        }

        DeleteDC(hdc);
    }

    return fRet;
}

/****************************************************************************
*
*     FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)
*
*     PURPOSE: calls initialization function, processes message loop
*
*
\****************************************************************************/
int APIENTRY WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpstrCmdLine,
    int nCmdShow
    )
{
    int i, iCpts;
    MSG msg;
    HACCEL  hAccel;
    HICON hIcon;
    USHORT wLanguageId;
    BOOL bCoInitialized = FALSE;

    //
    // Initialize the gbIsDBCS flag based on the current default language.
    //
    wLanguageId = LANGIDFROMLCID(GetThreadLocale());

    gbIsDBCS    = (LANG_JAPANESE == PRIMARYLANGID(wLanguageId)) ||
                  (LANG_KOREAN   == PRIMARYLANGID(wLanguageId)) ||
                  (LANG_CHINESE  == PRIMARYLANGID(wLanguageId));

    //
    // In a DBCS locale, exclude the Prev-Next font buttons.
    //
    if (!gbIsDBCS)
         C_BUTTONS -= C_DBCSBUTTONS;
    //
    // Need to initialize COM so that SHGetFileInfo will load the IExtractIcon handler
    // implemented in fontext.dll.
    //
    if (SUCCEEDED(CoInitialize(NULL)))
        bCoInitialized = TRUE;

    /*
     * Parse the Command Line
     *
     *  Use GetCommandLine() here (instead of lpstrCmdLine) so the
     *  command string will be in Unicode on NT
     */
    FillMemory( &gdtDisplay, sizeof(gdtDisplay), 0 );

    if (!ParseCommand( GetCommandLine(), gszFontPath, ARRAYSIZE(gszFontPath), &gfPrint ) ||
        (gfftFontType = LoadFontFile( gszFontPath, &gdtDisplay, &hIcon )) == FFT_BAD_FILE) {

        // Bad font file, inform user, and exit

        FmtMessageBox( NULL, MSG_APP_TITLE, NULL, MB_OK | MB_ICONSTOP,
                FALSE, MSG_BADFILENAME, gszFontPath );

        if (bCoInitialized)
            CoUninitialize();

        ExitProcess(1);
    }

    /*
     * Now finish initializing the display structure
     */
    gpszSampleAlph[0] = FmtSprintf(MSG_SAMPLEALPH_0);
    gpszSampleAlph[1] = FmtSprintf(MSG_SAMPLEALPH_1);
    gpszSampleAlph[2] = FmtSprintf(MSG_SAMPLEALPH_2);

    // find next line on display
    for( i = 0; i < CLINES_DISPLAY; i++ ) {
        if (gdtDisplay.atlDsp[i].dtyp == DTP_UNUSED)
            break;
    }

    // fill in sample alphabet
    gdtDisplay.atlDsp[i].pszText = gpszSampleAlph[0];
    gdtDisplay.atlDsp[i].cchText = lstrlen(gpszSampleAlph[0]);
    gdtDisplay.atlDsp[i].dtyp    = DTP_SHRINKTEXT;
    gdtDisplay.atlDsp[i].cptsSize = CPTS_SAMPLE_ALPHA;

    i++;
    gdtDisplay.atlDsp[i] = gdtDisplay.atlDsp[i-1];
    gdtDisplay.atlDsp[i].pszText = gpszSampleAlph[1];
    gdtDisplay.atlDsp[i].cchText = lstrlen(gpszSampleAlph[1]);

    i++;
    gdtDisplay.atlDsp[i] = gdtDisplay.atlDsp[i-1];
    gdtDisplay.atlDsp[i].pszText = gpszSampleAlph[2];
    gdtDisplay.atlDsp[i].cchText = lstrlen(gpszSampleAlph[2]);
    gdtDisplay.atlDsp[i].fLineUnder = TRUE;


    // now fill in sample Sentences
    iCpts = 0;

    if (gbIsDBCS)
    {
        //
        // Determine with string to use: the default or the language
        // specific.
        //
        switch (gdtDisplay.lfTestFont.lfCharSet) {
            case SYMBOL_CHARSET:
            case ANSI_CHARSET:
            case DEFAULT_CHARSET:
            case OEM_CHARSET:
                gpszSampleText = FmtSprintf(MSG_SAMPLETEXT);
                break;

            default:
                gpszSampleText = FmtSprintf(MSG_SAMPLETEXT_ALT);
                break;
        }
    }
    else
    {
        if(NativeCodePageSupported(&(gdtDisplay.lfTestFont))) {
            //
            // Native code page is supported, select that codepage
            // and print the localized string.
            //
            CHARSETINFO csi;

            TranslateCharsetInfo( (LPDWORD)IntToPtr(GetACP()), &csi, TCI_SRCCODEPAGE );

            gdtDisplay.lfTestFont.lfCharSet = (BYTE)csi.ciCharset;

            gpszSampleText =  FmtSprintf(MSG_SAMPLETEXT);

        } else {
            //
            // Font does not support the local code page.  Print
            // a random string up instead using the font's default charset.
            //
            gpszSampleText =  FmtSprintf(MSG_ALTSAMPLE);
        }
    }

    for( i += 1; i < CLINES_DISPLAY && iCpts < C_POINTS_LIST; i++ ) {
        if (gdtDisplay.atlDsp[i].dtyp == DTP_UNUSED) {
            gdtDisplay.atlDsp[i].pszText = gpszSampleText;
            gdtDisplay.atlDsp[i].cchText = lstrlen(gpszSampleText);
            gdtDisplay.atlDsp[i].dtyp    = DTP_TEXTOUT;
            gdtDisplay.atlDsp[i].cptsSize = apts[iCpts++];
        }
    }

    /*
     * Init the title font LOGFONT, and other variables
     */
    InitGlobals();

    if (!hPrevInstance) {
        if (!InitApplication(hInstance, hIcon)) {
            msg.wParam = FALSE;
            goto ExitProg;
        }
    }

    /* Perform initializations that apply to a specific instance */

    if (!InitInstance(hInstance, nCmdShow, gdtDisplay.atlDsp[0].pszText)) {
        msg.wParam = FALSE;
        goto ExitProg;
    }

    /* Acquire and dispatch messages until a WM_QUIT message is received. */
    hAccel = LoadAccelerators(hInstance, TEXT("fviewAccel"));

    while (GetMessage(&msg, NULL, 0L, 0L)) {
        if (!TranslateAccelerator(ghwndView, hAccel, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

ExitProg:
    for ( i = 0; i < C_BUTTONS; i++ )
        FmtFree( gabtCmdBtns[i].pszText );

    if (gbIsDBCS && glpLogFonts)
        FreeMem(glpLogFonts);

    RemoveFontResource( gszFontPath );

    if (bCoInitialized)
        CoUninitialize();

    return (int)(msg.wParam);
}


/****************************************************************************
*
*     FUNCTION: InitApplication(HANDLE)
*
*     PURPOSE: Initializes window data and registers window class
*
*     COMMENTS:
*
*         This function is called at initialization time only if no other
*         instances of the application are running.  This function performs
*         initialization tasks that can be done once for any number of running
*         instances.
*
*         In this case, we initialize a window class by filling out a data
*         structure of type WNDCLASS and calling the Windows RegisterClass()
*         function.  Since all instances of this application use the same window
*         class, we only need to do this when the first instance is initialized.
*
*
\****************************************************************************/

BOOL InitApplication(HANDLE hInstance, HICON hIcon)       /* current instance             */
{
    WNDCLASS  wc;
    BOOL fRet = FALSE;

    /* Fill in window class structure with parameters that describe the       */
    /* main window.                                                           */

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = FrameWndProc;

    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;           /* Application that owns the class.   */
    wc.hIcon = hIcon ? hIcon : LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = ghbr3DFace;
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("FontViewWClass");

    /* Register the window class and return success/failure code. */

    if (RegisterClass(&wc)) {
        /* Fill in window class structure with parameters that describe the       */
        /* main window.                                                           */

        wc.style = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc = ViewWndProc;

        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = hInstance;           /* Application that owns the class.   */
        wc.hIcon = NULL;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = GetStockObject(WHITE_BRUSH);
        wc.lpszMenuName =  NULL;
        wc.lpszClassName = TEXT("FontDisplayClass");

        fRet = RegisterClass(&wc);
    }

    return fRet;
}


/****************************************************************************
*
*     FUNCTION:  InitInstance(HANDLE, int)
*
*     PURPOSE:  Saves instance handle and creates main window
*
*     COMMENTS:
*
*         This function is called at initialization time for every instance of
*         this application.  This function performs initialization tasks that
*         cannot be shared by multiple instances.
*
*         In this case, we save the instance handle in a static variable and
*         create and display the main program window.
*
\****************************************************************************/

BOOL InitInstance( HANDLE  hInstance, int nCmdShow, LPTSTR  pszTitle)
{

    /* Save the instance handle in static variable, which will be used in  */
    /* many subsequence calls from this application to Windows.            */

    hInst = hInstance;

    /* Create a main window for this application instance.  */

    ghwndFrame = CreateWindow( TEXT("FontViewWClass"), pszTitle,
            WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_CLIPCHILDREN,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL );

    /* If window could not be created, return "failure" */

    if (!ghwndFrame)
        return (FALSE);

    return (TRUE);               /* Returns the value from PostQuitMessage */

}

/****************************************************************************
*
*     FUNCTION: InitLogFont
*
\****************************************************************************/
void InitGlobals( void ) {
    TCHAR szMsShellDlg2[LF_FACESIZE];
    INT cyDPI,i, cxFiller, cxMaxTxt, cxTxt, cxMax;
    HDC hdc;
    HFONT hfOld;
    RECT rc;

    FillMemory( &glfFont, sizeof(glfFont), 0 );

    glfFont.lfCharSet         = DEFAULT_CHARSET;
    glfFont.lfOutPrecision    = OUT_DEFAULT_PRECIS;
    glfFont.lfClipPrecision   = CLIP_DEFAULT_PRECIS;
    glfFont.lfQuality         = DEFAULT_QUALITY;
    glfFont.lfPitchAndFamily  = DEFAULT_PITCH | FF_DONTCARE;

    if (LoadString(hInst, IDS_FONTFACE, szMsShellDlg2, ARRAYSIZE(szMsShellDlg2)))
        StringCchCopy(glfFont.lfFaceName, ARRAYSIZE(glfFont.lfFaceName), szMsShellDlg2);
    else
        StringCchCopy(glfFont.lfFaceName, ARRAYSIZE(glfFont.lfFaceName), TEXT("MS Shell Dlg2"));

    hdc = CreateCompatibleDC(NULL);
    cyDPI = GetDeviceCaps(hdc, LOGPIXELSY );

    hfOld = SelectObject( hdc, GetStockObject(DEFAULT_GUI_FONT));

    // Find out size of padding around text
    SetRect(&rc, 0, 0, 0, 0 );
    DrawText(hdc, TEXT("####"), -1, &rc, DT_CALCRECT | DT_CENTER);
    cxFiller = rc.right - rc.left;

    gcyBtnArea = MulDiv( gcyBtnArea, cyDPI, C_PTS_PER_INCH );
    cxMax = cxMaxTxt = 0;
    for( i = 0; i < C_BUTTONS; i++ ) {
        gabtCmdBtns[i].x  = MulDiv( gabtCmdBtns[i].x,  cyDPI, C_PTS_PER_INCH );
        gabtCmdBtns[i].y  = MulDiv( gabtCmdBtns[i].y,  cyDPI, C_PTS_PER_INCH );
        gabtCmdBtns[i].cx = MulDiv( gabtCmdBtns[i].cx, cyDPI, C_PTS_PER_INCH );
        gabtCmdBtns[i].cy = MulDiv( gabtCmdBtns[i].cy, cyDPI, C_PTS_PER_INCH );

        if (gabtCmdBtns[i].cx > cxMax)
            cxMax = gabtCmdBtns[i].cx;

        gabtCmdBtns[i].pszText = FmtSprintf( gabtCmdBtns[i].idText );
        SetRect(&rc, 0, 0, 0, 0 );
        DrawText(hdc, gabtCmdBtns[i].pszText, -1, &rc, DT_CALCRECT | DT_CENTER);

        cxTxt = rc.right - rc.left + cxFiller;

        if (cxMaxTxt < cxTxt) {
            cxMaxTxt = cxTxt;
        }
    }

    //
    // Make sure buttons are big enough for text! (So localizer's won't have
    // to change code.
    //
    if (cxMax < cxMaxTxt) {
        for( i = 0; i < C_BUTTONS; i++ ) {
            gabtCmdBtns[i].cx = gabtCmdBtns[i].cx * cxMaxTxt / cxMax;
        }
    }

    //
    // Make sure buttons don't overlap
    //
    i = C_BUTTONS - 1;
    cxMax = gabtCmdBtns[0].x + gabtCmdBtns[0].cx + gabtCmdBtns[0].x + gabtCmdBtns[i].cx + (-gabtCmdBtns[i].x) +
            (2 * GetSystemMetrics(SM_CXSIZEFRAME));

    if (cxMax > gcxMinWinSize)
        gcxMinWinSize = cxMax;

    SelectObject(hdc, hfOld);
    DeleteDC(hdc);

    gcyLine = MulDiv( CPTS_INFO_SIZE, cyDPI, C_PTS_PER_INCH );

    ghbr3DFace   = GetSysColorBrush(COLOR_3DFACE);
    ghbr3DShadow = GetSysColorBrush(COLOR_3DSHADOW);
}

/****************************************************************************
*
*     FUNCTION: SkipWhiteSpace
*
\****************************************************************************/
LPTSTR SkipWhiteSpace( LPTSTR psz ) {

    while( *psz == TEXT(' ') || *psz == TEXT('\t') || *psz == TEXT('\n') ) {
        psz = CharNext( psz );
    }

    return psz;
}


/****************************************************************************
*
*     FUNCTION: CloneString
*
\****************************************************************************/
LPTSTR CloneString(LPTSTR psz) {
    int cch;
    LPTSTR pszRet;
    cch = (lstrlen( psz ) + 1);

    pszRet = AllocMem(cch * sizeof(TCHAR));
    StringCchCopy( pszRet, cch, psz );
    return pszRet;
}


/****************************************************************************
*
*     FUNCTION: GetFileSizeFromName(pszFontPath)
*
\****************************************************************************/
DWORD GetFileSizeFromName( LPCTSTR pszPath ) {
    HANDLE hfile;
    DWORD cb = 0;

    hfile = CreateFile( pszPath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL );
    if (hfile != INVALID_HANDLE_VALUE) {
        cb = GetFileSize( hfile, NULL );
        CloseHandle(hfile);
    }

    return cb;
}




HRESULT FindPfb (LPCTSTR pszPFM, LPTSTR pszPFB, size_t cchPFB);
HRESULT BuildType1FontSpec(LPCTSTR pszPFM, LPTSTR pszSpec, size_t cchSpec);


/****************************************************************************
*
*     FUNCTION: ParseCommand
*
\****************************************************************************/


BOOL ParseCommand( LPTSTR lpstrCmdLine, LPTSTR pszFontPath, size_t cchFontPath, BOOL *pfPrint ) {
    LPTSTR psz;
    BOOL fInQuote = FALSE;
    TCHAR szPfmPfb[(2 * MAX_PATH) + 1];  // +1 for possible '|' delimiter.

    //
    // Skip program name
    //
    for( psz = SkipWhiteSpace(lpstrCmdLine);
            *psz != TEXT('\0') && (fInQuote || *psz != TEXT(' ')); psz = CharNext(psz) ) {

        if (*psz == TEXT('\"')) {
            fInQuote = !fInQuote;
        }
    }

    if (*psz == TEXT('\0')) {
        *pszFontPath = TEXT('\0');
        return FALSE;
    }

    psz = SkipWhiteSpace(psz);

    //
    // Check for "/p"
    //
    if (psz[0] == TEXT('/') && (psz[1] == TEXT('p') || psz[1] == TEXT('P'))) {
        *pfPrint = TRUE;
        psz += 2;           // DBCS OK since we already verified that the
                            // chars were '/' and 'p', they can't be lead bytes
    } else
        *pfPrint = FALSE;

    psz = SkipWhiteSpace(psz);

    //
    // If the string ends in ".PFM"...
    //
    if (0 == lstrcmpi(PathFindExtension(psz), TEXT(".PFM")))
    {
        if (SUCCEEDED(BuildType1FontSpec(psz, szPfmPfb, ARRAYSIZE(szPfmPfb))))
        {
            psz = szPfmPfb;
        }
    }
    StringCchCopy( pszFontPath, cchFontPath, psz );
    return *psz != TEXT('\0');
}


/****************************************************************************
*
*     FUNCTION: GetGDILangID
*
*   REVIEW!  I believe this is how GDI determines the LangID, verify on
*   international builds.
*
\****************************************************************************/
WORD   GetGDILangID() {
    return (WORD)GetSystemDefaultLangID();
}



void ConvertTTStrToWinZStr( LPWSTR pwsz, LPVOID pvTTS, int cbMW ) {
    int i, cch;
    LPMWORD lpmw = pvTTS;

    cch = cbMW / sizeof(MWORD);

    for( i = 0; i < cch; i++ ) {
        *pwsz++ = MWORD2INT(*lpmw);
        lpmw++;
    }

    *pwsz = L'\0';
}


VOID ConvertDBCSTTStrToWinZStr( LPTSTR pwsz, LPCSTR pvTTS, ULONG cbMW ) {
    BYTE Name[256];
    WORD wordChar;
    BYTE *ansiName = Name;
    WORD *srcString = (WORD *)pvTTS;
    int length = 0;
    int cb = cbMW;

    for(;cb;cb-=2) {
        wordChar = *srcString;
        if(wordChar & 0x00FF) {
            *ansiName++ = (CHAR)((wordChar & 0x00FF));
            *ansiName++ = (CHAR)((wordChar & 0xFF00) >> 8);
            length += 2;
        } else {
            *ansiName++ = (CHAR)((wordChar & 0xFF00) >> 8);
            length++;
        }
        srcString++;
    }

    ansiName[length] = '\0';

    MultiByteToWideChar(CP_ACP,0,Name,length,pwsz,cbMW);
}

/****************************************************************************
*
*     FUNCTION: FindNameString
*
*   helper function for GetAlignedTTName
*
\****************************************************************************/
LPTSTR FindNameString(PBYTE pbTTData, int cNameRec, int idName, WORD wLangID)
{
    PTTNAMETBL ptnt;
    PTTNAMEREC ptnr;
    LPTSTR     psz;
    int        i;

    ptnt = (PTTNAMETBL)pbTTData;

    for( i = 0; i < cNameRec; i++ ) {
        LPVOID pvTTStr;

        ptnr = &(ptnt->anrNames[i]);
        if (MWORD2INT(ptnr->mwidPlatform) != TTID_PLATFORM_MS ||
            MWORD2INT(ptnr->mwidName) != idName               ||
            MWORD2INT(ptnr->mwidLang) != wLangID) {
            continue;
        }

        pvTTStr = (LPVOID)(pbTTData + MWORD2INT(ptnt->mwoffStrings)
                                    + MWORD2INT(ptnr->mwoffString));

        psz = AllocMem((MWORD2INT(ptnr->mwcbString) + sizeof(TEXT('\0'))) * 2);

        if ((MWORD2INT(ptnr->mwidEncoding) == TTID_MS_GB) ||
            (MWORD2INT(ptnr->mwidEncoding) == TTID_MS_WANSUNG) ||
            (MWORD2INT(ptnr->mwidEncoding) == TTID_MS_BIG5)) {
            ConvertDBCSTTStrToWinZStr( psz, pvTTStr, MWORD2INT(ptnr->mwcbString) );
        } else {
            ConvertTTStrToWinZStr( psz, pvTTStr, MWORD2INT(ptnr->mwcbString) );
        }

        return psz;
    }

    return NULL;
}



/****************************************************************************
*
*     FUNCTION: GetAlignedTTName
*
*   NOTE: This function returns an allocated string that must be freed
*   after use.
*
*   This function allocs a buffer to recopy the string into incase we are
*   running on a RISC machine with NT.  Since the string will be UNICODE
*   (ie. each char is a WORD), those strings must be aligned on WORD
*   boundaries.  Unfortunatly, TrueType files do not neccesarily align
*   the embedded unicode strings.  Furthur more, on NT we can not simply
*   return a pointer to the data stored in the input buffer, since the
*   'Unicode' strings stored in the TTF file are stored in Motorola (big
*   endian) format, and we need the unicode chars in Intel (little endian)
*   format. Last but not least, we need the returned string to be null terminated
*   so we need to either alloc the buffer for that case anyway.
*
\****************************************************************************/
LPTSTR GetAlignedTTName( PBYTE pbTTData, int idName ) {
    PTTNAMEREC ptnr;
    PTTNAMETBL ptnt;
    int cNameRec,i;
    LPTSTR psz;
    BOOL bFirstRetry;
    WORD wLangID = GetGDILangID();
    LCID lcid = GetThreadLocale();

    ptnt = (PTTNAMETBL)pbTTData;
    cNameRec = MWORD2INT(ptnt->mwcNameRec);

    //
    // Look For Microsoft Platform ID's
    //
    if (gbIsDBCS)
    {
        if ((psz = FindNameString(pbTTData, cNameRec, idName, wLangID)) != NULL) {
            return psz;
        }
        //
        // If we didn't find it, try English if we haven't already.
        //
        if ( wLangID != 0x0409 ) {
            if ((psz = FindNameString(pbTTData, cNameRec, idName, 0x0409)) != NULL) {
                return psz;
            }
        }
    }
    else
    {
        bFirstRetry = TRUE;

retry_lang:

        for( i = 0; i < cNameRec; i++ ) {
            LPVOID pvTTStr;
            ptnr = &(ptnt->anrNames[i]);
            if (MWORD2INT(ptnr->mwidPlatform) != TTID_PLATFORM_MS ||
                MWORD2INT(ptnr->mwidName) != idName               ||
                MWORD2INT(ptnr->mwidLang) != wLangID) {
                continue;
            }

            pvTTStr = (LPVOID)(pbTTData + MWORD2INT(ptnt->mwoffStrings) + MWORD2INT(ptnr->mwoffString));
            psz = AllocMem(MWORD2INT(ptnr->mwcbString) + sizeof(TEXT('\0')));

            ConvertTTStrToWinZStr( psz, pvTTStr, MWORD2INT(ptnr->mwcbString) );
            return psz;
        }

        //
        // Give 0x409 a try if there is no specified MAC language.
        //
        if (bFirstRetry && wLangID != 0x0409) {
            bFirstRetry = FALSE;
            wLangID     = 0x0409;
            goto retry_lang;
        }
    }

    //
    // Didn't find MS Platform, try Macintosh
    //
    for( i = 0; i < cNameRec; i++ ) {
        int cch;
        LPSTR pszMacStr;

        ptnr = &(ptnt->anrNames[i]);
        if (MWORD2INT(ptnr->mwidPlatform) != TTID_PLATFORM_MAC ||
            MWORD2INT(ptnr->mwidName) != idName                ||
            MWORD2INT(ptnr->mwidLang) != wLangID) {
            continue;
        }

        pszMacStr = (LPVOID)(pbTTData + MWORD2INT(ptnt->mwoffStrings) + MWORD2INT(ptnr->mwoffString));

        cch = MultiByteToWideChar(CP_MACCP, 0, pszMacStr, MWORD2INT(ptnr->mwcbString), NULL, 0);
        if (cch == 0)
            continue;

        cch += 1; // for null
        psz = AllocMem(cch * sizeof(TCHAR));
        if (psz == NULL)
            continue;

        cch = MultiByteToWideChar(CP_MACCP, 0, pszMacStr, MWORD2INT(ptnr->mwcbString), psz, cch);
        if (cch == 0) {
            FreeMem(psz);
            continue;
        }

        return psz;
    }

    //
    // Didn't find MS Platform nor Macintosh
    // 1. Try change Thread Locale to data Locale
    // 2. MultiByteToWideChar with Thread code page CP_THREAD_ACP
    //
    for( i = 0; i < cNameRec; i++ ) {
        int cch;
        LPSTR pszStr;

        ptnr = &(ptnt->anrNames[i]);
        if (MWORD2INT(ptnr->mwidName) != idName ||
            MWORD2INT(ptnr->mwidLang) == 0) {
            continue;
        }

        if (LANGIDFROMLCID(lcid) != MWORD2INT(ptnr->mwidLang)) {
            lcid = MAKELCID(MWORD2INT(ptnr->mwidLang), SORT_DEFAULT);
            if (!SetThreadLocale(lcid)) {
                break;
            }
        }

        pszStr = (LPVOID)(pbTTData + MWORD2INT(ptnt->mwoffStrings) + MWORD2INT(ptnr->mwoffString));

        cch = MultiByteToWideChar(CP_THREAD_ACP, 0, pszStr, MWORD2INT(ptnr->mwcbString), NULL, 0);
        if (cch == 0)
            continue;

        cch += 1; // for null
        psz = AllocMem(cch * sizeof(TCHAR));
        if (psz == NULL)
            continue;

        cch = MultiByteToWideChar(CP_THREAD_ACP, 0, pszStr, MWORD2INT(ptnr->mwcbString), psz, cch);
        if (cch == 0) {
            FreeMem(psz);
            continue;
        }

        return psz;
    }

    return NULL;
}


/****************************************************************************
*
*     FUNCTION: LoadFontFile
*
\****************************************************************************/
FFTYPE LoadFontFile( LPTSTR pszFontPath, PDISPTEXT pdtSmpl, HICON *phIcon ) {
    int cFonts;
    FFTYPE fft = FFT_BAD_FILE;
    SHFILEINFO sfi;
    LPTSTR pszAdobe;
    TCHAR szFPBuf[MAX_PATH];

    cFonts = AddFontResource( pszFontPath );

    if (gbIsDBCS)
    {
        //
        // save cFonts value to global variable.
        //
        gNumOfFonts = cFonts;
    }

    if (cFonts != 0) {
        LPLOGFONT lplf;
        DWORD cb;
        DWORD cbCFF = 0, cbMMSD = 0, cbDSIG = 0; // for OpenType
        BYTE *pbDSIG = NULL; // for OpenType
        BOOL  fIsTT;

        cb = sizeof(LOGFONT) * cFonts;

        if (gbIsDBCS)
        {
            //
            // save lplf to global variable.
            //
            glpLogFonts = lplf = AllocMem(cb);
        }
        else
        {
            lplf = AllocMem(cb);
        }

        // ?? Should this be GetFontResourceInfo (doesn't matter; but why force W)
        if (GetFontResourceInfoW( (LPTSTR)pszFontPath, &cb, lplf, GFRI_LOGFONTS )) {
            HDC hdc;
            HFONT hf, hfOld;
            LOGFONT lf;
            int nIndex;
            int cLoopReps = 1;

            BOOL fIsTrueTypeFont;
            DWORD dwSize = sizeof(BOOL);

            if(GetFontResourceInfoW((LPTSTR) pszFontPath, &dwSize, &fIsTrueTypeFont, GFRI_ISTRUETYPE)) {
                // If there is a raster & true type font on the system at the same time, 
                // and the height/width requested is supported by both fonts, the 
                // the font methods (which take the LOGFONT struct, *lplf) will select
                // the raster font (by design).  THis causes a problem when the user wants
                // to view the true type font; so, an extra check needs to be done to see if
                // the font requested is a true type, and if so then specify in the LOGFONT
                // struct to only show the true type font
                if(fIsTrueTypeFont) {
                    lplf->lfOutPrecision = OUT_TT_ONLY_PRECIS;
                }
            }

            //
            // This DBCS-aware code was originally placed within #ifdef DBCS
            // preprocessor statements.  For single-binary, these had to be
            // replaced with runtime checks.  The original code did some funky
            // things to execute a loop in DBCS builds but only a single iteration
            // in non-DBCS builds.  To do this, the "for" statement and it's
            // closing brace were placed in #ifdef DBCS like this:
            //
            // #ifdef DBCS
            //     for (nIndex = 0; nIndex < cFonts; nIndex++)
            //     {
            //          //
            //          // Other DBCS-specific code.
            //          //
            // #endif
            //          //
            //          // Code for both DBCS and non-DBCS systems
            //          // executes only once.
            //          //
            // #ifdef DBCS
            //     }
            // #endif
            //
            // While effective in a multi-binary configuration, this doesn't
            // translate well to a single-binary build.
            // To preserve the original logic without having to do major
            // reconstruction, I've replaced the loop sentinel variable with
            // "cLoopReps".  In non-DBCS locales, it is set to 1.  In DBCS
            // locales, it is assigned the value in "cFonts".
            //
            // [BrianAu 5/4/97]
            //

          if (gbIsDBCS)
              cLoopReps = cFonts;

          for (nIndex = 0; nIndex < cLoopReps; nIndex++) {
            if (gbIsDBCS)
            {
                lf = *(lplf + nIndex);

                //
                // Skip vertical font
                //
                if (lf.lfFaceName[0] == TEXT('@')) {
                    gNumOfFonts = (cFonts == 2) ? gNumOfFonts-1 : gNumOfFonts;
                    continue;
                }

                hf = CreateFontIndirect(&lf);
            }
            else
            {
                hf = CreateFontIndirect(lplf);
            }

            hdc = CreateCompatibleDC(NULL);

            if (hdc)
            {
                hfOld = SelectObject(hdc, hf);

                // Only otf fonts will have CFF table, tag is ' FFC'.

                cbCFF = GetFontData(hdc,' FFC', 0, NULL, 0);
                cbDSIG = GetFontData(hdc,'GISD', 0, NULL, 0);

                if (cbDSIG != GDI_ERROR)
                {
                    if ((pbDSIG = AllocMem(cbDSIG)) == NULL)
                    {
                        // Can't determine what's in the DSIG table.
                        // Continue as though the DSIG table does not exist.
                        cbDSIG = 0;
                    }
                    else
                    {
                        if (GetFontData (hdc, 'GISD', 0, pbDSIG, cbDSIG) == GDI_ERROR)
                        {
                            // Continue as though the DSIG table does not exist
                            cbDSIG = 0;
                        }
                        FreeMem(pbDSIG);
                    }
                }


                if (cbCFF == GDI_ERROR)
                    cbCFF = 0;

                if (cbDSIG == GDI_ERROR)
                    cbDSIG = 0;

                if (cbCFF || cbDSIG)
                {
                    fft = FFT_OTF;
                    if (cbCFF)
                    {
                        cbMMSD = GetFontData(hdc,'DSMM', 0, NULL, 0);
                        if (cbMMSD == GDI_ERROR)
                            cbMMSD = 0;
                    }
                }

                cb = GetFontData(hdc, TT_TBL_NAME, 0, NULL, 0);

                if (fft != FFT_OTF)
                {
                    fIsTT = (cb != 0 && cb != GDI_ERROR);
                    fft = fIsTT ? FFT_TRUETYPE : FFT_BITMAP;
                }

                if ((fft == FFT_TRUETYPE) || (fft == FFT_OTF)) {
                    int i;
                    LPBYTE lpTTData;
                    LPTSTR pszTmp;

                    lpTTData = AllocMem(cb);
                    GetFontData(hdc, TT_TBL_NAME, 0, lpTTData, cb);

                    i = 0;

                    //
                    // Title String
                    //
                    pdtSmpl->atlDsp[i].dtyp = DTP_SHRINKDRAW;
                    pdtSmpl->atlDsp[i].cptsSize = CPTS_TITLE_SIZE;
                    pdtSmpl->atlDsp[i].fLineUnder = TRUE;

                    pszTmp = GetAlignedTTName( lpTTData, TTID_NAME_FULLFONTNM );
                    if (pszTmp != NULL) {
                        if (gbIsDBCS)
                        {
                            //
                            // TTC Support.
                            //
                            if (nIndex == 0) {
                                pdtSmpl->atlDsp[i].pszText = CloneString(pszTmp);
                            } else {
                                pdtSmpl->atlDsp[i].pszText = FmtSprintf(MSG_TTC_CONCAT,
                                                                        pdtSmpl->atlDsp[i].pszText,
                                                                        pszTmp);
                            }

                            if (nIndex + 1 == cFonts) {
                                //
                                // If last this is last font, append "(True Type)"
                                //
                            pdtSmpl->atlDsp[i].pszText = FmtSprintf((fft == FFT_TRUETYPE) ? MSG_PTRUETYPEP : MSG_POPENTYPEP,
                                                                    pdtSmpl->atlDsp[i].pszText);
                            }
                            pdtSmpl->atlDsp[i].cchText = lstrlen(pdtSmpl->atlDsp[i].pszText);
                            FreeMem(pszTmp);
                        }
                        else
                        {
                            pdtSmpl->atlDsp[i].pszText = FmtSprintf((fft == FFT_TRUETYPE) ? MSG_PTRUETYPEP : MSG_POPENTYPEP, pszTmp);
                            pdtSmpl->atlDsp[i].cchText = lstrlen(pdtSmpl->atlDsp[i].pszText);
                            FreeMem(pszTmp);
                        }
                    } else {
                        if (gbIsDBCS)
                        {
                            //
                            // TTC support
                            //
                            if (nIndex == 0) {
                                pdtSmpl->atlDsp[i].pszText = CloneString(lf.lfFaceName);
                            } else {
                                pdtSmpl->atlDsp[i].pszText = FmtSprintf(MSG_TTC_CONCAT,
                                                                        pdtSmpl->atlDsp[i].pszText,
                                                                        lf.lfFaceName);
                            }

                            if (nIndex + 1 == cFonts) {
                                //
                                // If last this is last font, append "(True Type)"
                                //
                                pdtSmpl->atlDsp[i].pszText = FmtSprintf((fft == FFT_TRUETYPE) ? MSG_PTRUETYPEP : MSG_POPENTYPEP,
                                                                        pdtSmpl->atlDsp[i].pszText);
                            }
                            pdtSmpl->atlDsp[i].cchText = lstrlen(pdtSmpl->atlDsp[i].pszText);
                        }
                        else
                        {
                            pdtSmpl->atlDsp[i].pszText = CloneString(lplf->lfFaceName);
                            pdtSmpl->atlDsp[i].cchText = lstrlen(pdtSmpl->atlDsp[0].pszText);
                        }
                    }
                    i++;
                    pdtSmpl->atlDsp[i] = pdtSmpl->atlDsp[i-1];

                    //// insert an extra line to provide better description of the font

                    if (fft == FFT_OTF)
                    {
                        LPTSTR pszTemp = NULL;
                        WCHAR awcTmp[256];
                        awcTmp[0] = 0; // zero init

                        pdtSmpl->atlDsp[i].dtyp = DTP_NORMALDRAW;
                        pdtSmpl->atlDsp[i].cptsSize = CPTS_INFO_SIZE;
                        pdtSmpl->atlDsp[i].fLineUnder = FALSE;

                        pdtSmpl->atlDsp[i].pszText = FmtSprintf(
                                          MSG_POTF,
                                          awcTmp);

                        if (cbDSIG)
                        {
                            pszTemp = pdtSmpl->atlDsp[i].pszText;

                            pdtSmpl->atlDsp[i].pszText = FmtSprintf(
                                          MSG_PDSIG,
                                          pdtSmpl->atlDsp[i].pszText);

                            FmtFree(pszTemp);
                        }

                        pszTemp = pdtSmpl->atlDsp[i].pszText;
                        pdtSmpl->atlDsp[i].pszText = FmtSprintf(
                                      cbCFF ? MSG_PPSGLYPHS : MSG_PTTGLYPHS,
                                      pdtSmpl->atlDsp[i].pszText);
                        FmtFree(pszTemp);

                        pszTemp = pdtSmpl->atlDsp[i].pszText;
                        pdtSmpl->atlDsp[i].pszText = FmtSprintf(
                                      MSG_PINSTRUCTIONS,
                                      pdtSmpl->atlDsp[i].pszText);
                        FmtFree(pszTemp);

                        if (cbCFF)
                        {
                            pszTemp = pdtSmpl->atlDsp[i].pszText;
                            pdtSmpl->atlDsp[i].pszText = FmtSprintf(
                                          cbMMSD ? MSG_PMULTIPLEMASTER : MSG_PSINGLEMASTER,
                                          pdtSmpl->atlDsp[i].pszText);
                            FmtFree(pszTemp);
                        }

                        pdtSmpl->atlDsp[i].cchText = lstrlen(pdtSmpl->atlDsp[i].pszText);

                        i++;
                        pdtSmpl->atlDsp[i] = pdtSmpl->atlDsp[i-1];
                    }

                    //
                    // Typeface Name:
                    //
                    pdtSmpl->atlDsp[i].cptsSize = CPTS_INFO_SIZE;
                    pdtSmpl->atlDsp[i].dtyp = DTP_NORMALDRAW;
                    pdtSmpl->atlDsp[i].fLineUnder = FALSE;
                    pszTmp = GetAlignedTTName( lpTTData, TTID_NAME_FONTFAMILY );
                    if (pszTmp != NULL) {
                        pdtSmpl->atlDsp[i].pszText = FmtSprintf(MSG_TYPEFACENAME, pszTmp);
                        pdtSmpl->atlDsp[i].cchText = lstrlen(pdtSmpl->atlDsp[i].pszText);
                        FreeMem(pszTmp);
                        i++;
                        pdtSmpl->atlDsp[i] = pdtSmpl->atlDsp[i-1];
                    }

                    //
                    // File size:
                    //
                    pdtSmpl->atlDsp[i].pszText = FmtSprintf(MSG_FILESIZE,
                            ROUND_UP_DIV(GetFileSizeFromName(pszFontPath), CB_ONE_K));
                    pdtSmpl->atlDsp[i].cchText = lstrlen(pdtSmpl->atlDsp[i].pszText);

                    //
                    // Version:
                    //
                    pszTmp = GetAlignedTTName( lpTTData, TTID_NAME_VERSIONSTR );
                    if (pszTmp != NULL) {
                        i++;
                        pdtSmpl->atlDsp[i] = pdtSmpl->atlDsp[i-1];
                        pdtSmpl->atlDsp[i].pszText = FmtSprintf(MSG_VERSION, pszTmp);
                        pdtSmpl->atlDsp[i].cchText = lstrlen(pdtSmpl->atlDsp[i].pszText);
                        FreeMem( pszTmp );
                    }

                    //
                    // Copyright string
                    //
                    pszTmp = GetAlignedTTName( lpTTData, TTID_NAME_COPYRIGHT );
                    if (pszTmp != NULL) {
                        i++;
                        pdtSmpl->atlDsp[i] = pdtSmpl->atlDsp[i-1];
                        pdtSmpl->atlDsp[i].cptsSize = CPTS_COPYRIGHT_SIZE;
                        pdtSmpl->atlDsp[i].dtyp = DTP_WRAPDRAW;
                        pdtSmpl->atlDsp[i].pszText = FmtSprintf(MSG_COPYRIGHT, pszTmp);
                        pdtSmpl->atlDsp[i].cchText = lstrlen(pdtSmpl->atlDsp[i].pszText);
                        FreeMem( pszTmp );
                    }

                    pdtSmpl->atlDsp[i].fLineUnder = TRUE;

                    if (gbIsDBCS)
                    {
                        //
                        // TTC Support.
                        //
                        FreeMem(lpTTData);
                    }
                } else {

                    // Title String (Non TrueType case)

                    pdtSmpl->atlDsp[0].dtyp = DTP_SHRINKDRAW;
                    pdtSmpl->atlDsp[0].cptsSize = CPTS_TITLE_SIZE;
                    pdtSmpl->atlDsp[0].fLineUnder = TRUE;
                    pdtSmpl->atlDsp[0].pszText = CloneString(lplf->lfFaceName);
                    pdtSmpl->atlDsp[0].cchText = lstrlen(pdtSmpl->atlDsp[0].pszText);

                    // Use Default quality, so we can see GDI scaling of Bitmap Fonts
                    lplf->lfQuality = DEFAULT_QUALITY;
                    lplf->lfWidth = 0;
                }

                // If LPK is loaded then GetFontResourceInfo(GFRI_LOGFONTS) may return ANSI_CHARSET for some DBCS fonts.
                // Get the native char set.
                if (gbIsDBCS & NativeCodePageSupported(lplf)) {
                        //
                        // Native code page is supported, set that codepage
                        //
                        CHARSETINFO csi;
        
                        TranslateCharsetInfo( (LPDWORD)IntToPtr(GetACP()), &csi, TCI_SRCCODEPAGE );
        
                        lplf->lfCharSet = (BYTE)csi.ciCharset;
                }

                SelectObject(hdc, hfOld);
                DeleteDC(hdc);
            } // if (hdc)
            
            if (hf)
            {
                DeleteObject(hf);
            }

          } // for
            pdtSmpl->lfTestFont = *lplf;
        }

        if (!gbIsDBCS)
        {
            FreeMem(lplf);
        }
    }


    //
    // MAJOR HACK!
    //
    // Since ATM-Type1 fonts are split between two files, (*.PFM and *.PFB) we have done a hack
    // earlier in the code to find the missing filename and concatinate them together in
    // the form "FOO.PFM|FOO.PFB", so we can then call AddFontResource() with only one string.
    //
    // Since SHGetFileInfo does not understand this hacked filename format, we must split ATM-Type1
    // names appart here and then reconcat them after we call the shell api.
    //
    pszAdobe = pszFontPath;

    while( *pszAdobe && *pszAdobe != TEXT('|') )
        pszAdobe = CharNext(pszAdobe);

    if ( *pszAdobe ) {

        *pszAdobe = TEXT('\0');

        pdtSmpl->atlDsp[0].pszText = FmtSprintf(MSG_PTYPE1, pdtSmpl->atlDsp[0].pszText);
        pdtSmpl->atlDsp[0].cchText = lstrlen(pdtSmpl->atlDsp[0].pszText);

    } else {
        pszAdobe = NULL;
    }
    // end of HACK


    //
    // Get the associated icon for this font file type
    //
    if ( fft != FFT_BAD_FILE && SHGetFileInfo( pszFontPath, 0, &sfi, sizeof(sfi), SHGFI_ICON )) {
        *phIcon = sfi.hIcon;
    } else
        *phIcon = NULL;

    //
    // HACK - restore the '|' we nuked above
    //
    if ( pszAdobe != NULL ) {
        *pszAdobe = TEXT('|');
    }
    // end of HACK

    return fft;
}


/****************************************************************************
*
*     FUNCTION: DrawFontSample
*
* Parameters:
*
*   lprcPage    Size of the page in pels.  A page is either a printed
*               sheet (on a printer) or the Window.
*
*   cyOffset    Offset into the virtual sample text.  Used to "scroll" the
*               window up and down.  Positive number means start further
*               down in the virtual sample text as the top line in the
*               lprcPage.
*
*   lprcPaint   Rectangle to draw.  It is in the same coord space as
*               lprcPage.  Used to optimize window repaints, and to
*               support banding to printers.
*
*
\****************************************************************************/
int DrawFontSample( HDC hdc, LPRECT lprcPage, int cyOffset, LPRECT lprcPaint, BOOL fReallyDraw ) {
    int cyDPI;
    HFONT hfOld, hfText, hfDesk;
    LOGFONT lfTmp;
    int yBaseline = -cyOffset;
    int taOld,i;
    TCHAR szNumber[10];
    int cyShkTxt = -1, cptsShkTxt = -1;
    SIZE sz;
    int cxPage;

    DPRINT((DBTX("PAINTING")));

    cyDPI = GetDeviceCaps(hdc, LOGPIXELSY );
    taOld = SetTextAlign(hdc, TA_BASELINE);

    glfFont.lfHeight = MulDiv( -CPTS_COPYRIGHT_SIZE, cyDPI, C_PTS_PER_INCH );
    hfDesk = CreateFontIndirect(&glfFont);

    // Get hfOld for later
    hfOld = SelectObject(hdc, hfDesk);


    if (gbIsDBCS)
    {
        //
        // if two or more fonts exist, set correct typeface name
        //
        if (gNumOfFonts > 1 && gfftFontType == FFT_TRUETYPE) {
            gdtDisplay.atlDsp[INDEX_TYPEFACENAME].pszText =
                                FmtSprintf(MSG_TYPEFACENAME, gdtDisplay.lfTestFont.lfFaceName);
            gdtDisplay.atlDsp[INDEX_TYPEFACENAME].cchText =
                                lstrlen(gdtDisplay.atlDsp[INDEX_TYPEFACENAME].pszText);
        }
    }

    //
    // Find the longest shrinktext line so we can make sure they will fit
    // on the screen
    //
    cxPage = lprcPage->right - lprcPage->left;
    for( i = 0; i < CLINES_DISPLAY && gdtDisplay.atlDsp[i].dtyp != DTP_UNUSED; i++ ) {
        PTXTLN ptlCurrent = &(gdtDisplay.atlDsp[i]);

        if (ptlCurrent->dtyp == DTP_SHRINKTEXT) {
            lfTmp = gdtDisplay.lfTestFont;

            if (cptsShkTxt == -1)
                cptsShkTxt = ptlCurrent->cptsSize;

            cyShkTxt = MulDiv( -cptsShkTxt, cyDPI, C_PTS_PER_INCH );

            lfTmp.lfHeight = cyShkTxt;

            hfText = CreateFontIndirect( &lfTmp );
            SelectObject(hdc, hfText);

            GetTextExtentPoint32(hdc, ptlCurrent->pszText, ptlCurrent->cchText, &sz );

            SelectObject(hdc, hfOld);
            DeleteObject(hfText);

            // Make sure shrink lines are not too long
            if (sz.cx > cxPage) {

                DPRINT((DBTX(">>>Old lfH:%d sz.cx:%d cxPage:%d"), lfTmp.lfHeight, sz.cx, cxPage));

                cptsShkTxt = cptsShkTxt * cxPage / sz.cx;
                cyShkTxt = MulDiv( -cptsShkTxt, cyDPI, C_PTS_PER_INCH );

                DPRINT((DBTX(">>>New lfH:%d"),lfTmp.lfHeight));
            }
        }
    }


    //
    // Paint the screen/page
    //
    for( i = 0; i < CLINES_DISPLAY && gdtDisplay.atlDsp[i].dtyp != DTP_UNUSED; i++ ) {
        TEXTMETRIC tm;
        PTXTLN ptlCurrent = &(gdtDisplay.atlDsp[i]);

        // Create and select the font for this line

        if (ptlCurrent->dtyp == DTP_TEXTOUT || ptlCurrent->dtyp == DTP_SHRINKTEXT )
            lfTmp = gdtDisplay.lfTestFont;
        else
            lfTmp = glfFont;

        if (ptlCurrent->dtyp == DTP_SHRINKTEXT) {
            DPRINT((DBTX("PAINT:Creating ShrinkText Font:%s height:%d"), lfTmp.lfFaceName, lfTmp.lfHeight ));
            lfTmp.lfHeight = cyShkTxt;
        }
        else
            lfTmp.lfHeight = MulDiv( -ptlCurrent->cptsSize, cyDPI, C_PTS_PER_INCH );

        hfText = CreateFontIndirect( &lfTmp );
        SelectObject(hdc, hfText);


        // Get size characteristics for this line in the selected font
        if (ptlCurrent->dtyp == DTP_SHRINKDRAW) {

            GetTextExtentPoint32(hdc, ptlCurrent->pszText, ptlCurrent->cchText, &sz );

            // Make sure shrink lines are not too long
            if (sz.cx > cxPage) {

                SelectObject(hdc, hfOld);
                DeleteObject(hfText);

                DPRINT((DBTX("===Old lfH:%d sz.cx:%d cxPage:%d"), lfTmp.lfHeight, sz.cx, cxPage));

                lfTmp.lfHeight = MulDiv( -ptlCurrent->cptsSize * cxPage / sz.cx, cyDPI, C_PTS_PER_INCH );

                DPRINT((DBTX("===New lfH:%d"),lfTmp.lfHeight));

                hfText = CreateFontIndirect( &lfTmp );
                SelectObject(hdc, hfText);
            }
        }



        GetTextMetrics(hdc, &tm);

        yBaseline += (tm.tmAscent + tm.tmExternalLeading);
        DPRINT((DBTX("tmH:%d tmA:%d tmD:%d tmIL:%d tmEL:%d"), tm.tmHeight, tm.tmAscent, tm.tmDescent, tm.tmInternalLeading, tm.tmExternalLeading));

        // Draw the text
        switch(ptlCurrent->dtyp) {
            case DTP_NORMALDRAW:
            case DTP_SHRINKDRAW:
            case DTP_SHRINKTEXT:
                if (fReallyDraw) {
                    ExtTextOut(hdc, lprcPage->left, yBaseline, ETO_CLIPPED, lprcPaint,
                            ptlCurrent->pszText, ptlCurrent->cchText, NULL);
                }

                //
                // Bob says "This looks nice!" (Adding a little extra white space before the underline)
                //
                if (ptlCurrent->fLineUnder)
                    yBaseline += tm.tmDescent;

                break;

            case DTP_WRAPDRAW: {
                RECT rc;
                int cy;

                yBaseline += tm.tmDescent;
                SetRect(&rc, lprcPage->left, yBaseline - tm.tmHeight, lprcPage->right, yBaseline );

                DPRINT((DBTX("**** Org RC:(%d, %d, %d, %d)  tmH:%d"), rc.left, rc.top, rc.right, rc.bottom, tm.tmHeight));
                cy = DrawText(hdc, ptlCurrent->pszText, ptlCurrent->cchText, &rc,
                        DT_NOPREFIX | DT_WORDBREAK | DT_CALCRECT);


                DPRINT((DBTX("**** Cmp RC:(%d, %d, %d, %d)  cy:%d"), rc.left, rc.top, rc.right, rc.bottom, cy));
                if( cy > tm.tmHeight )
                    yBaseline = rc.bottom = rc.top + cy;

                if (fReallyDraw) {
                    SetTextAlign(hdc, taOld);
                    DrawText(hdc, ptlCurrent->pszText, ptlCurrent->cchText, &rc, DT_NOPREFIX | DT_WORDBREAK);
                    SetTextAlign(hdc, TA_BASELINE);
                }
                break;
            }

            case DTP_TEXTOUT:
                if (fReallyDraw) {
                    SIZE szNum;
                    int cchNum;
                    SelectObject(hdc, hfDesk );
                    StringCchPrintf( szNumber, ARRAYSIZE(szNumber), TEXT("%d"), ptlCurrent->cptsSize );
                    cchNum = lstrlen(szNumber);
                    ExtTextOut(hdc, lprcPage->left, yBaseline, ETO_CLIPPED, lprcPaint, szNumber, cchNum, NULL);


                    GetTextExtentPoint32(hdc, szNumber, cchNum, &szNum);

                    SelectObject(hdc, hfText);
                    ExtTextOut(hdc, lprcPage->left + szNum.cx * 2, yBaseline, ETO_CLIPPED, lprcPaint,
                            ptlCurrent->pszText, ptlCurrent->cchText, NULL);
                }
                break;
        }

        yBaseline += tm.tmDescent;

        if (fReallyDraw && ptlCurrent->fLineUnder) {
            MoveToEx( hdc, lprcPage->left, yBaseline, NULL);
            LineTo( hdc, lprcPage->right, yBaseline );

            // Leave space for the line we just drew
            yBaseline += 1;
        }

        SelectObject( hdc, hfOld );
        DeleteObject( hfText );
    }

    SelectObject(hdc, hfOld);
    SetTextAlign(hdc, taOld);
    DeleteObject(hfDesk);

    return yBaseline;
}

/****************************************************************************
*
*     FUNCTION: PaintSampleWindow
*
\****************************************************************************/
void PaintSampleWindow( HWND hwnd, HDC hdc, PAINTSTRUCT *pps ) {
    RECT rcClient;

    GetClientRect(hwnd, &rcClient);

    DrawFontSample( hdc, &rcClient, gyScroll, &(pps->rcPaint), TRUE );

}


/****************************************************************************
*
*     FUNCTION: FrameWndProc(HWND, unsigned, WORD, LONG)
*
*     PURPOSE:  Processes messages
*
*     MESSAGES:
*
*         WM_COMMAND    - application menu (About dialog box)
*         WM_DESTROY    - destroy window
*
*     COMMENTS:
*
*         To process the IDM_ABOUT message, call MakeProcInstance() to get the
*         current instance address of the About() function.  Then call Dialog
*         box which will create the box according to the information in your
*         fontview.rc file and turn control over to the About() function.  When
*         it returns, free the intance address.
*
\****************************************************************************/

LRESULT APIENTRY FrameWndProc(
        HWND hwnd,                /* window handle                   */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* additional information          */
        LPARAM lParam)            /* additional information          */
{
    static SIZE szWindow = {0, 0};

    switch (message) {

        case WM_PAINT: {
            HDC hdc;
            RECT rc;
            PAINTSTRUCT ps;
            int x;

            hdc = BeginPaint(hwnd, &ps);

            // get the window rect
            GetClientRect(hwnd, &rc);

            // extend only down by gcyBtnArea
            rc.bottom = rc.top + gcyBtnArea;

            // Fill rect with button face color (handled by class background brush)
            // FillRect(hdc, &rc, ghbr3DFace);

            // Fill small rect at bottom with edge color
            rc.top = rc.bottom - 2;
            FillRect(hdc, &rc, ghbr3DShadow);

            ReleaseDC(hwnd, hdc);

            EndPaint(hwnd, &ps);
            break;
        }

        case WM_CREATE: {
            HDC hdc;
            RECT rc;
            int i;

            GetClientRect(hwnd, &rc);
            szWindow.cx = rc.right - rc.left;
            szWindow.cy = rc.bottom - rc.top;

            for( i = 0; i < C_BUTTONS; i++ ) {
                int x = gabtCmdBtns[i].x;
                HWND hwndBtn;

                if (gbIsDBCS)
                {
                    DWORD dwStyle = 0;

                    //
                    // If font is not TrueType font or not TTC font,
                    // AND button id is previous/next,
                    // then just continue.
                    //
                    if ((gfftFontType != FFT_TRUETYPE ||
                         gNumOfFonts <= 1) &&
                        (gabtCmdBtns[i].id == IDB_PREV_FONT ||
                         gabtCmdBtns[i].id == IDB_NEXT_FONT)) {
                            continue;
                    }
                    //
                    // Set x potision for each button.
                    //
                    switch (gabtCmdBtns[i].id) {
                        case IDB_PREV_FONT:
                            x = szWindow.cx / 2 - gabtCmdBtns[i].cx - 5;
                            dwStyle = WS_DISABLED;  // initially disabled.
                            break;
                        case IDB_NEXT_FONT:
                            x = szWindow.cx / 2 + 5;
                            break;
                        default:
                            if (x < 0)
                                x = szWindow.cx + x - gabtCmdBtns[i].cx;
                    }
                    gabtCmdBtns[i].hwnd = hwndBtn = CreateWindow( TEXT("button"),
                            gabtCmdBtns[i].pszText,
                            BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE | dwStyle,
                            x, gabtCmdBtns[i].y,
                            gabtCmdBtns[i].cx, gabtCmdBtns[i].cy,
                            hwnd, (HMENU)IntToPtr(gabtCmdBtns[i].id),
                            hInst, NULL);
                }
                else
                {
                    if (x < 0)
                        x = szWindow.cx + x - gabtCmdBtns[i].cx;

                    gabtCmdBtns[i].hwnd = hwndBtn = CreateWindow( TEXT("button"),
                            gabtCmdBtns[i].pszText, BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE,
                            x, gabtCmdBtns[i].y,
                            gabtCmdBtns[i].cx, gabtCmdBtns[i].cy,
                            hwnd, (HMENU)IntToPtr(gabtCmdBtns[i].id),
                            hInst, NULL);

                }
                if (hwndBtn != NULL) {
                    SendMessage(hwndBtn,
                                WM_SETFONT,
                                (WPARAM)GetStockObject(DEFAULT_GUI_FONT),
                                MAKELPARAM(TRUE, 0));
                }
            }

            ghwndView = CreateWindow( TEXT("FontDisplayClass"), NULL, WS_CHILD | WS_VSCROLL | WS_VISIBLE,
                    0, gcyBtnArea, szWindow.cx, szWindow.cy - gcyBtnArea, hwnd, 0, hInst, NULL );

            break;
        }

        case WM_GETMINMAXINFO: {
            LPMINMAXINFO lpmmi = (LPMINMAXINFO) lParam;

            lpmmi->ptMinTrackSize.x = gcxMinWinSize;
            lpmmi->ptMinTrackSize.y = gcyMinWinSize;

            break;
        }

        case WM_SIZE: {
            int cxNew, cyNew;
            HDC hdc;
            RECT rc;
            SCROLLINFO sci;

            cxNew = LOWORD(lParam);
            cyNew = HIWORD(lParam);

            if (cyNew != szWindow.cy || cxNew != szWindow.cx) {
                int i;

                if (gbIsDBCS)
                {
                    for( i = 0; i < C_BUTTONS; i++ ) {
                        int x = gabtCmdBtns[i].x;

                        //
                        // If font is not TrueType font or not TTC font,
                        // AND button id is previous/next,
                        // then just continue.
                        //
                        if ((gfftFontType != FFT_TRUETYPE ||
                             gNumOfFonts <= 1) &&
                            (gabtCmdBtns[i].id == IDB_PREV_FONT ||
                             gabtCmdBtns[i].id == IDB_NEXT_FONT)) {
                                continue;
                        }
                        //
                        // Set x potision for each button.
                        //
                        switch (gabtCmdBtns[i].id) {
                            case IDB_PREV_FONT:
                                SetWindowPos(gabtCmdBtns[i].hwnd,
                                             NULL,
                                             cxNew / 2 - gabtCmdBtns[i].cx - 5,
                                             gabtCmdBtns[i].y,
                                             0,
                                             0,
                                             SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );
                                break;
                            case IDB_NEXT_FONT:
                                SetWindowPos(gabtCmdBtns[i].hwnd,
                                             NULL,
                                             cxNew /2 + 5,
                                             gabtCmdBtns[i].y,
                                             0,
                                             0,
                                             SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );
                                break;
                            default:
                                if (x < 0) {
                                    SetWindowPos(gabtCmdBtns[i].hwnd,
                                                 NULL,
                                                 cxNew + x - gabtCmdBtns[i].cx,
                                                 gabtCmdBtns[i].y,
                                                 0,
                                                 0,
                                                 SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );
                                }
                        }
                    }
                }
                else // !DBCS
                {
                    for( i = 0; i < C_BUTTONS; i++ ) {
                        int x = gabtCmdBtns[i].x;

                        if (x < 0) {
                            SetWindowPos(gabtCmdBtns[i].hwnd, NULL, cxNew + x - gabtCmdBtns[i].cx, gabtCmdBtns[i].y, 0, 0,
                                    SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );
                        }
                    }
                } // DBCS

                szWindow.cx = cxNew;
                szWindow.cy = cyNew;

                SetWindowPos(ghwndView, NULL, 0, gcyBtnArea, szWindow.cx, szWindow.cy - gcyBtnArea,
                        SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE );

            }
            break;
        }

        case WM_COMMAND:           /* message: command from application menu */
            if (LOWORD(wParam) != IDB_DONE)
                return SendMessage(ghwndView, message, wParam, lParam);

            PostMessage(ghwndFrame, WM_CLOSE, 0, 0);
            break;

        case WM_DESTROY: {
            int i;

            DestroyWindow(ghwndView);
            for( i = 0; i < C_BUTTONS; i++ ) {
                DestroyWindow(gabtCmdBtns[i].hwnd);
            }

            PostQuitMessage(0);
            break;
        }

        default:                          /* Passes it on if unproccessed    */
            return (DefWindowProc(hwnd, message, wParam, lParam));
    }
    return (0L);
}

/****************************************************************************
*
*     FUNCTION: ViewWndProc(HWND, unsigned, WORD, LONG)
*
*     PURPOSE:  Processes messages
*
*     MESSAGES:
*
*         WM_COMMAND    - application menu (About dialog box)
*         WM_DESTROY    - destroy window
*
*     COMMENTS:
*
*         To process the IDM_ABOUT message, call MakeProcInstance() to get the
*         current instance address of the About() function.  Then call Dialog
*         box which will create the box according to the information in your
*         fontview.rc file and turn control over to the About() function.  When
*         it returns, free the intance address.
*
\****************************************************************************/

LRESULT APIENTRY ViewWndProc(
        HWND hwnd,                /* window handle                   */
        UINT message,             /* type of message                 */
        WPARAM wParam,            /* additional information          */
        LPARAM lParam)            /* additional information          */
{
    static SIZE szWindow = {0, 0};
    static int  cyVirtPage = 0;

    switch (message) {

        case WM_CREATE: {
            HDC hdc;
            RECT rc;
            SCROLLINFO sci;
            int i;

            GetClientRect(hwnd, &rc);
            szWindow.cx = rc.right - rc.left;
            szWindow.cy = rc.bottom - rc.top;

            hdc = CreateCompatibleDC(NULL);
            cyVirtPage = DrawFontSample(hdc, &rc, 0, NULL, FALSE);
            DeleteDC(hdc);


            gyScroll = 0;

            sci.cbSize = sizeof(sci);
            sci.fMask = SIF_ALL | SIF_DISABLENOSCROLL;
            sci.nMin = 0;
            sci.nMax = cyVirtPage;
            sci.nPage = szWindow.cy;
            sci.nPos = gyScroll;

            SetScrollInfo(hwnd, SB_VERT, &sci, TRUE );

            if (gfPrint)
                PostMessage(hwnd, WM_COMMAND, IDB_PRINT, 0);
            break;
        }

        case WM_SIZE: {
            int cxNew, cyNew;
            HDC hdc;
            RECT rc;
            SCROLLINFO sci;

            cxNew = LOWORD(lParam);
            cyNew = HIWORD(lParam);

            if (cyNew != szWindow.cy || cxNew != szWindow.cx) {
                int i;

                szWindow.cx = cxNew;
                szWindow.cy = cyNew;

                hdc = CreateCompatibleDC(NULL);
                SetRect(&rc, 0, 0, szWindow.cx, szWindow.cy);
                cyVirtPage = DrawFontSample(hdc, &rc, 0, NULL, FALSE);
                DeleteDC(hdc);

                if (cyVirtPage <= cyNew) {
                    // Disable the scrollbar
                    gyScroll = 0;
                }

                if (cyVirtPage > szWindow.cy && gyScroll > cyVirtPage - szWindow.cy)
                    gyScroll = cyVirtPage - szWindow.cy;

                sci.cbSize = sizeof(sci);
                sci.fMask = SIF_ALL | SIF_DISABLENOSCROLL;
                sci.nMin = 0;
                sci.nMax = cyVirtPage;
                sci.nPage = cyNew;
                sci.nPos = gyScroll;

                SetScrollInfo(hwnd, SB_VERT, &sci, TRUE );
            }
            break;
        }

        case WM_VSCROLL: {
            int iCode = (int)LOWORD(wParam);
            int yPos = (int)HIWORD(wParam);
            int yNewScroll = gyScroll;

            switch( iCode ) {

            case SB_THUMBPOSITION:
            case SB_THUMBTRACK:
                if (yPos != yNewScroll)
                    yNewScroll = yPos;
                break;

            case SB_LINEUP:
                yNewScroll -= gcyLine;
                break;

            case SB_PAGEUP:
                yNewScroll -= szWindow.cy;
                break;

            case SB_LINEDOWN:
                yNewScroll += gcyLine;
                break;

            case SB_PAGEDOWN:
                yNewScroll += szWindow.cy;
                break;

            case SB_TOP:
                yNewScroll = 0;
                break;

            case SB_BOTTOM:
                yNewScroll = cyVirtPage;
                break;
            }

            if (yNewScroll < 0)
                yNewScroll = 0;

            if (yNewScroll > cyVirtPage - szWindow.cy)
                yNewScroll = cyVirtPage - szWindow.cy;

            if (yNewScroll < 0)
                yNewScroll = 0;

            if (gyScroll != yNewScroll) {
                SCROLLINFO sci;
                int dyScroll;

                dyScroll = gyScroll - yNewScroll;

                if (ABS(dyScroll) < szWindow.cy) {
                    ScrollWindowEx(hwnd, 0, dyScroll, NULL, NULL, NULL, NULL, SW_ERASE | SW_INVALIDATE);
                } else
                    InvalidateRect(hwnd, NULL, TRUE);

                gyScroll = yNewScroll;

                sci.cbSize = sizeof(sci);
                sci.fMask = SIF_ALL | SIF_DISABLENOSCROLL;
                sci.nMin = 0;
                sci.nMax = cyVirtPage;
                sci.nPage = szWindow.cy;
                sci.nPos = gyScroll;

                SetScrollInfo(hwnd, SB_VERT, &sci, TRUE );
            }

            break;
        }


        case WM_COMMAND:           /* message: command from application menu */
            if( !DoCommand( hwnd, wParam, lParam ) )
                return (DefWindowProc(hwnd, message, wParam, lParam));
            break;

        case WM_PAINT: {
            HDC hdc;
            PAINTSTRUCT ps;

            hdc = BeginPaint( hwnd, &ps );
            PaintSampleWindow( hwnd, hdc, &ps );
            EndPaint( hwnd, &ps );
            break;
        }

        default:                          /* Passes it on if unproccessed    */
            return (DefWindowProc(hwnd, message, wParam, lParam));
    }
    return (0L);
}

/*********************************************\
*
* PRINT DLGS
*
*
\*********************************************/
HDC PromptForPrinter(HWND hwnd, HINSTANCE hInst, int *pcCopies ) {
    PRINTDLG pd;

    FillMemory(&pd, sizeof(pd), 0);

    pd.lStructSize = sizeof(pd);
    pd.hwndOwner = hwnd;
    pd.Flags = PD_RETURNDC | PD_NOSELECTION;
    pd.nCopies = 1;
    pd.hInstance = hInst;

    if (PrintDlg(&pd)) {
        *pcCopies = pd.nCopies;
        return pd.hDC;
    } else
        return NULL;
}

/****************************************************************************\
*
*     FUNCTION: PrintSampleWindow(hwnd)
*
*       Prompts for a printer and then draws the sample text to the printer
*
\****************************************************************************/
void PrintSampleWindow(HWND hwnd) {
    HDC hdc;
    DOCINFO di;
    int cxDPI, cyDPI, iPage, cCopies;
    RECT rcPage;
    HCURSOR hcur;

    hdc = PromptForPrinter(hwnd, hInst, &cCopies);
    if (hdc == NULL)
        return;

    hcur = SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));

    cyDPI = GetDeviceCaps(hdc, LOGPIXELSY );
    cxDPI = GetDeviceCaps(hdc, LOGPIXELSX );

    /*
     * Set a one inch margine around the page
     */
    SetRect(&rcPage, 0, 0, GetDeviceCaps(hdc, HORZRES), GetDeviceCaps(hdc, VERTRES));

    rcPage.left    += cxDPI;
    rcPage.right   -= cxDPI;


    di.cbSize = sizeof(di);
    di.lpszDocName = gdtDisplay.atlDsp[0].pszText;
    di.lpszOutput = NULL;
    di.lpszDatatype = NULL;
    di.fwType = 0;

    StartDoc(hdc, &di);

    for( iPage = 0; iPage < cCopies; iPage++ ) {
        StartPage(hdc);

        DrawFontSample( hdc, &rcPage, -cyDPI, &rcPage, TRUE );

        EndPage(hdc);
    }

    EndDoc(hdc);

    DeleteDC(hdc);

    SetCursor(hcur);
}


/****************************************************************************\
*
*     FUNCTION: EnableCommandButtons(id, bEnable)
*
*       Enable/disable command button.
*
\****************************************************************************/
BOOL EnableCommandButton(int id, BOOL bEnable)
{
    int  i;
    HWND hwnd = NULL;

    for( i = 0; i < C_BUTTONS; i++ ) {
        if (gabtCmdBtns[i].id == id) {
            hwnd = gabtCmdBtns[i].hwnd;
            break;
        }
    }
    return (hwnd == NULL) ? FALSE: EnableWindow(hwnd, bEnable);
}


/****************************************************************************\
*
*     FUNCTION: ViewNextFont(iInc)
*
*       Show the previous/next font.
*
\****************************************************************************/
void ViewNextFont(int iInc)
{
    int index = gIndexOfFonts + iInc;

    while (1) {
        if ( index < 0 || index >= gNumOfFonts ) {
            //
            // if out of range, then return.
            //
            MessageBeep(MB_OK);
            return;
        }
        else if ((*(glpLogFonts + index)).lfFaceName[0] == TEXT('@')) {
            //
            // if the font is vertical font, skip this font and
            // try next/previous font.
            //
            index += iInc;
        }
        else {
            break;
        }
    }

    //
    // Enable/Disable Prev/Next buttons.
    //
    if (index == 0) {
        // first font
        EnableCommandButton(IDB_PREV_FONT, FALSE);
        EnableCommandButton(IDB_NEXT_FONT, TRUE);
    }
    else if (index == gNumOfFonts - 1) {
        // last font
        EnableCommandButton(IDB_PREV_FONT, TRUE);
        EnableCommandButton(IDB_NEXT_FONT, FALSE);
    }
    else {
        // other
        EnableCommandButton(IDB_PREV_FONT, TRUE);
        EnableCommandButton(IDB_NEXT_FONT, TRUE);
    }

    //
    // Show the new font.
    //
    gIndexOfFonts = index;
    gdtDisplay.lfTestFont = *(glpLogFonts + index);
    InvalidateRect(ghwndView, NULL, TRUE);
}


/****************************************************************************\
*
*     FUNCTION: DoCommand(HWND, unsigned, WORD, LONG)
*
*     PURPOSE:  Processes messages for "About" dialog box
*
*     MESSAGES:
*
*         WM_INITDIALOG - initialize dialog box
*         WM_COMMAND    - Input received
*
*     COMMENTS:
*
*         No initialization is needed for this particular dialog box, but TRUE
*         must be returned to Windows.
*
*         Wait for user to click on "Ok" button, then close the dialog box.
*
\****************************************************************************/
BOOL DoCommand( HWND hWnd, WPARAM wParam, LPARAM lParam )
{

    switch(LOWORD(wParam)){
        case IDB_PRINT: {
            PrintSampleWindow(hWnd);
            break;
        }

        case IDB_DONE: {
            PostMessage(ghwndFrame, WM_CLOSE, 0, 0);
            break;
        }

        case IDK_UP: {
            SendMessage(hWnd, WM_VSCROLL, SB_LINEUP, (LPARAM)NULL );
            break;
        }

        case IDK_DOWN: {
            SendMessage(hWnd, WM_VSCROLL, SB_LINEDOWN, (LPARAM)NULL );
            break;
        }

        case IDK_PGUP: {
            SendMessage(hWnd, WM_VSCROLL, SB_PAGEUP, (LPARAM)NULL );
            break;
        }

        case IDK_PGDWN: {
            SendMessage(hWnd, WM_VSCROLL, SB_PAGEDOWN, (LPARAM)NULL );
            break;
        }

        case IDB_PREV_FONT: {
            ViewNextFont(-1);
            break;
        }

        case IDB_NEXT_FONT: {
            ViewNextFont(1);
            break;
        }

        default: {
            return FALSE;
        }
    }

    return TRUE;
}



BOOL bFileExists(TCHAR*pszFile)
{
    HANDLE  hf;

    if ((hf = CreateFile(pszFile,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL)) != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hf);
        return TRUE;
    }

    return FALSE;
}


/******************************Public*Routine******************************\
*
* FindPfb, given pfm file, see if pfb file exists in the same dir or in the
* parent directory of the pfm file
*
* Given:  c:\foo\bar\font.pfm
* Check:  c:\foo\bar\font.pfb
*         c:\foo\font.pfb
*
* Given:  font.pfm
* Check:  font.pfb
*         ..\font.pfb
*
* History:
*  14-Jun-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
*
*  28-Feb-2002 -by- Brian Aust [BrianAu]
* Replaced all of Bodin's character manipulations with calls to 
* shlwapi path functions and strsafe helpers.
*
* Returns:
*     S_OK    - PFB file found.  Full path to PFB written to pszPFB buffer.
*     S_FALSE - PFB file not found.
*     Other   - Error HRESULT.
*
\**************************************************************************/

HRESULT FindPfb (LPCTSTR pszPFM, LPTSTR pszPFB, size_t cchPFB)
{
    TCHAR szPath[MAX_PATH];  // Working 'scratch' buffer.
    HRESULT hr;
    
    if (0 != lstrcmpi(PathFindExtension(pszPFM), TEXT(".PFM")))
    {
        //
        // Caller didn't provide a PFM file path.
        //
        return E_INVALIDARG;
    }

    //
    // Copy input path to our scratch buffer so we can modify it.
    //
    hr = StringCchCopy(szPath, ARRAYSIZE(szPath), pszPFM);
    if (SUCCEEDED(hr))
    {
        //
        // Does a PFB file exist in the same directory as the PFM file?
        //
        PathRenameExtension(szPath, TEXT(".PFB"));
        if (bFileExists(szPath))
        {
            hr = S_OK;  // Found a match!
        }
        else
        {
            LPCTSTR pszFileName = PathFindFileName(pszPFM);
            //
            // PFB doesn't exist in same directory.  
            // Try the parent directory.
            // Remove the file name so we have only a directory path.
            //
            if (!PathRemoveFileSpec(szPath))
            {
                //
                // This shouldn't happen.  We've already tested earlier
                // for content in the path string.  
                //
                hr = E_FAIL;
            }
            else
            {
                if (0 == szPath[0])
                {
                    //
                    // Removing the file spec left us with an empty string.
                    // That means a bare "font.pfm" name was passed in. 
                    // Build a relative path to the parent directory.
                    //
                    hr = StringCchPrintf(szPath, ARRAYSIZE(szPath), TEXT("..\\%s"), pszFileName);
                }
                else
                {
                    //
                    // Remove the containing directory so we have a path
                    // to the parent directory.
                    //
                    if (PathRemoveFileSpec(szPath))
                    {
                        //
                        // We're now at the parent directory.
                        // Build a full file path here.
                        //
                        if (PathAppend(szPath, pszFileName))
                        {
                            hr = S_OK;  // We have a path to test.
                        }
                        else
                        {
                            hr = E_FAIL;
                        }
                    }
                    else
                    {
                        //
                        // No parent directory exists in the path.  That 
                        // means, the PFM file is in the root of the path.
                        // We've already tested for a PFB in the same
                        // directory so our search is over.  No match.
                        //
                        hr = S_FALSE;
                    }
                }
            }
            if (S_OK == hr)
            {
                //
                // We have a valid path to search.  Replace the extension
                // with .PFB and see if the file exists.
                //
                PathRenameExtension(szPath, TEXT(".PFB"));
                if (!bFileExists(szPath))
                {
                    hr = S_FALSE;  // No match.
                }
            }
        }
        if (S_OK == hr)
        {
            //
            // Found matching PFB file.  Return the path to the caller.
            //
            hr = StringCchCopy(pszPFB, cchPFB, szPath);
        }
    }
    return hr;
}

//
// Given the path for a PFM file, try to locate a matching
// PFB file.  If one is found, the two paths are concatenated together
// and returned with a '|' character as a delimiter.  If a PFB file is 
// not found, the path to the PFM file is returned unaltered.
//
HRESULT BuildType1FontSpec(LPCTSTR pszPFM, LPTSTR pszSpec, size_t cchSpec)
{
    TCHAR szPFB[MAX_PATH];
    HRESULT hr = FindPfb(pszPFM, szPFB, ARRAYSIZE(szPFB));
    if (S_OK == hr)
    {
        //
        // PFB file found.  Build the concatenated PFM|PFB path string.
        //
        hr = StringCchPrintf(pszSpec, cchSpec, TEXT("%s|%s"), pszPFM, szPFB);
    }
    else if (S_FALSE == hr)
    {
        //
        // No PFB found.  Return the original PFM file path.
        //
        hr = StringCchCopy(pszSpec, cchSpec, pszPFM);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontview\fmttools.c ===
#include <windows.h>
#include <fontdefs.h>
#include <fvmsg.h>

TCHAR gpszUnknownError[MAX_PATH] = TEXT("Error");
TCHAR gszDots[] = TEXT("...");
/***************************************************************************\
*
*     FUNCTION: FmtMessageBox( HWND hwnd, DWORD dwTitleID, UINT fuStyle,
*                   BOOL fSound, DWORD dwTextID, ... );
*
*     PURPOSE:  Formats messages with FormatMessage and then displays them
*               in a message box
*
*
*
*
* History:
* 22-Apr-1993 JonPa         Created it.
\***************************************************************************/
int FmtMessageBox( HWND hwnd, DWORD dwTitleID, LPTSTR pszTitleStr,
    UINT fuStyle, BOOL fSound, DWORD dwTextID, ... ) {
    LPTSTR pszMsg;
    LPTSTR pszTitle;
    int idRet;

    va_list marker;

    va_start( marker, dwTextID );

    if(!FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK, hInst,
            dwTextID, 0, (LPTSTR)&pszMsg, 1, &marker))
        pszMsg = gpszUnknownError;

    va_end( marker );

    GetLastError();

    if (dwTitleID != FMB_TTL_ERROR ||
            !FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK |
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
                hInst, dwTitleID, 0, (LPTSTR)&pszTitle, 1, (va_list *)&pszTitleStr)) {
        pszTitle = NULL;
    }

    GetLastError();

    if (fSound) {
        MessageBeep( fuStyle & (MB_ICONASTERISK | MB_ICONEXCLAMATION |
                MB_ICONHAND | MB_ICONQUESTION | MB_OK) );
    }

    if (hwnd == NULL)
        hwnd = GetDesktopWindow();

    idRet = MessageBox(hwnd, pszMsg, pszTitle, fuStyle);

    if (pszTitle != NULL)
        FmtFree( pszTitle );

    if (pszMsg != gpszUnknownError)
        FmtFree( pszMsg );

    return idRet;
}

/***************************************************************************\
*
*     FUNCTION: FmtSprintf( DWORD id, ... );
*
*     PURPOSE:  sprintf but it gets the pattern string from the message rc.
*
* History:
* 03-May-1993 JonPa         Created it.
\***************************************************************************/
LPTSTR FmtSprintf( DWORD id, ... ) {
    LPTSTR pszMsg;
    va_list marker;

    va_start( marker, id );

    if(!FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK, hInst,
            id, 0, (LPTSTR)&pszMsg, 1, &marker)) {
        GetLastError();
        pszMsg = gszDots;
    }
    va_end( marker );

    return pszMsg;
}

/***************************************************************************\
*
*     FUNCTION: PVOID AllocMem( DWORD cb );
*
*     PURPOSE:  allocates memory, checking for errors
*
*   Do not call this function until after LoadFontFile() has been called
*   since this function will try and remove the font.
*
* History:
*   22-Apr-1993 JonPa   Wrote it.
\***************************************************************************/
PVOID AllocMem( DWORD cb ) {
    PVOID pv = (PVOID)LocalAlloc(LPTR, cb);

    if (pv == NULL) {
        FmtMessageBox( ghwndFrame, FMB_TTL_ERROR, NULL, MB_OK | MB_ICONSTOP,
                TRUE, MSG_OUTOFMEM );
        RemoveFontResource( gszFontPath );
        ExitProcess(2);
    }

    return pv;
}

#ifdef FV_DEBUG
/***************************************************************************\
*
*     FUNCTION: FmtSprintf( DWORD id, ... );
*
*     PURPOSE:  sprintf but it gets the pattern string from the message rc.
*
* History:
* 03-May-1993 JonPa         Created it.
\***************************************************************************/
void Dprintf( LPTSTR pszFmt, ... ) {
    TCHAR szBuffer[256];
    va_list marker;

    va_start( marker, pszFmt );

    StringCchVPrintf( szBuffer, ARRAYSIZE(szBuffer), pszFmt, marker );
    OutputDebugString(szBuffer);

    va_end( marker );

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\ole2map\elsepan.c ===
/***************************************************************************
 * ELSEPAN.C - ElseWare PANOSE(tm) 1.0 Font Mapper routines.
 *
 * $keywords: elsepan.c 1.5 19-Jul-93 11:15:09 AM$
 *
 * Copyright (C) 1991-93 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/
#define ELSE_MAPPER_CORE
#include <windows.h>
#include "elsepan.h"

/* Sanity check: this is the poor man's way to make sure the mapstate
 * we get is valid. We init this value during startup and check it upon
 * entry to every API routine.
 *
 * Note it is a good idea to modify SANITY_VALUE every time you make a
 * significant change to the software just in case the mapper ends up
 * in an environment where there may be multiple copies of it running,
 * or if client software tries to save the mapstate (which is a no-no: it
 * should use the API to get and set the exposed mapstate variables).
 */

#ifndef NOELSEWEIGHTS

#define SANITY_VALUE           0xD0CACA12L

#else

#define SANITY_VALUE           0xD0CACA13L

#endif

#define M_SANE(lpMapState) \
   (((lpMapState) != NULL) && ((lpMapState)->ulSanity == SANITY_VALUE))

#define M_lpjOFFS(lpDB, lOffs) (((EW_LPBYTE)(lpDB)) + (lOffs))

LOCAL EW_LPPIND_MEM EW_NEAR EW_PASCAL s_lpPANGetIndRec
   ELSEARGS (( EW_LPPDICT_MEM lpPDB, EW_LPBYTE EW_FAR *lplpPanWant,
      EW_LPBYTE EW_FAR *lplpPanThis ));

LOCAL EW_BOOL EW_NEAR EW_PASCAL s_bPANGetPenaltyC0
   ELSEARGS (( EW_LPPIND_MEM lpPanIndRec, EW_LPPTBL_C0_MEM lpPC0,
      EW_LPUSHORT lpunMatch, EW_USHORT unTblSize, EW_USHORT unAttrA,
      EW_USHORT unAttrB ));

LOCAL EW_USHORT EW_NEAR EW_PASCAL s_unPANGetPenaltyC1
   ELSEARGS (( EW_USHORT unAttrA, EW_USHORT unAttrB ));

LOCAL EW_BOOL EW_NEAR EW_PASCAL s_bPANGetPenaltyC2
   ELSEARGS (( EW_LPPIND_MEM lpPanIndRec, EW_LPBYTE lpPTbl,
      EW_LPUSHORT lpunMatch, EW_USHORT unTblSize,
      EW_USHORT unAttrA, EW_USHORT unAttrB ));

LOCAL EW_USHORT EW_NEAR EW_PASCAL s_unPANGetPenaltyC4
   ELSEARGS (( EW_LPPTBL_C4_MEM lpPC4, EW_USHORT unAttrA,
      EW_USHORT unAttrB ));

LOCAL EW_LPBYTE EW_NEAR EW_PASCAL s_lpPANGetWeights
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_LPPDICT_MEM lpPDB,
      EW_LPPIND_MEM lpPanIndRec ));

LOCAL EW_BOOL EW_NEAR EW_PASCAL s_bPANMatchDigits
   ELSEARGS (( EW_LPPDICT_MEM lpPDB, EW_LPUSHORT lpunMatchTotal,
      EW_LPPIND_MEM lpPanIndRec, EW_LPPTBL_MEM lpPTblRec, EW_USHORT unWt,
      EW_USHORT unAttrA, EW_USHORT unAttrB ));



/***************************************************************************
 * FUNCTION: nPANMapInit
 *
 * PURPOSE:  Initialize the font mapper.  Fill in the default settings.
 *
 * RETURNS:  Return the size of the map-state struct if successful, or
 *           the negative size if the passed in struct was too small.
 *           The function returns zero if it failed to initialize.
 ***************************************************************************/
EW_SHORT EW_FAR EW_PASCAL nPANMapInit( EW_LPMAPSTATE lpMapState,
                                       EW_USHORT unSizeMapState)
{
    EW_USHORT i;
    EW_LPPDICT_MEM lpPDB;
    EW_LPBYTE lpPanDef;
    EW_LPBYTE lpjWtA;
    EW_LPBYTE lpjWtB;
    
    //
    //  Simple version check: make sure we got the right size struct.
    //

    if( unSizeMapState < sizeof( EW_MAPSTATE ) )
    {
        if( unSizeMapState >= sizeof( EW_ULONG ) )
        {
            lpMapState->ulSanity = 0L;
        }
        return( -(EW_SHORT) sizeof( EW_MAPSTATE ) );
    }

    lpMapState->ulSanity = 0L;
    
    //
    //  Attempt to allocate the penalty database. We keep the handle
    //  until the mapper is disabled.
    //

    if( !( lpMapState->ulhPan1Data = M_lAllocPAN1DATA( ) ) )
    {
        goto errout0;
    }

    //
    //  Make sure the penalty database is the right version and
    //  in the right byte ordering.
    //

    if( !( lpPDB = M_lLockPAN1DATA( lpMapState->ulhPan1Data ) ) )
    {
        goto errout1;
    }

    if( ( lpPDB->unVersion != PANOSE_PENALTY_VERS ) ||
         ( lpPDB->unByteOrder != PTBL_BYTE_ORDER ) )
    {
        goto errout2;
    }

    M_bUnlockPAN1DATA( lpMapState->ulhPan1Data );
    
    //
    //  Fill in defaults.
    //

    lpMapState->unThreshold = ELSEDEFTHRESHOLD;
    lpMapState->unRelaxThresholdCount = 0;
    lpMapState->bUseDef = TRUE;
    
    //
    //  Initial default font is the PANOSE number for Courier.
    //

    lpPanDef = lpMapState->ajPanDef;

    lpPanDef[PAN_IND_FAMILY]     = FAMILY_LATTEXT;
    lpPanDef[PAN_IND_SERIF]      = SERIF_THIN;
    lpPanDef[PAN_IND_WEIGHT]     = WEIGHT_THIN;
    lpPanDef[PAN_IND_PROPORTION] = PROPORTION_MONOSPACE;
    lpPanDef[PAN_IND_CONTRAST]   = CONTRAST_NONE;
    lpPanDef[PAN_IND_STROKE]     = STROKE_GRADVERT;
    lpPanDef[PAN_IND_ARMSTYLE]   = ARM_STRAIGHTSGLSERIF;
    lpPanDef[PAN_IND_LTRFORM]    = LTRFORM_NORMCONTACT;
    lpPanDef[PAN_IND_MIDLINE]    = MIDLINE_STDSERIFED;
    lpPanDef[PAN_IND_XHEIGHT]    = XHEIGHT_CONSTLARGE;


#ifndef NOELSEWEIGHTS
    //
    //  Initialize the custom weights array.
    //

    for( i = 0, lpjWtA = lpMapState->ajWtRefA,
          lpjWtB = lpMapState->ajWtRefB;
          i < MAX_CUSTOM_WEIGHTS;
          ++i, *lpjWtA++ = PANOSE_ANY, *lpjWtB++ = PANOSE_ANY)
       ;

#endif
    
    //
    //  This value is checked by all other functions, in an attempt
    //  to safeguard against a mapstate that we didn't initialize.
    //

    lpMapState->ulSanity = SANITY_VALUE;
    
    //
    //  Normal return.
    //

    return( sizeof( EW_MAPSTATE ) );
    
errout2:
    M_bUnlockPAN1DATA(lpMapState->ulhPan1Data);

errout1:
    M_bFreePAN1DATA(lpMapState->ulhPan1Data);

errout0:
    return( 0 );
}


/***************************************************************************
 * FUNCTION: bPANMapClose
 *
 * PURPOSE:  Free the penalty database and close the font mapper. Also
 *           clear the sanity value so we will not service any more calls
 *           on this mapstate.
 *
 * RETURNS:  The function returns TRUE if the penalty database is
 *           successfully freed.
 ***************************************************************************/

EW_BOOL EW_FAR EW_PASCAL bPANMapClose( EW_LPMAPSTATE lpMapState )
{
    if( M_SANE( lpMapState ) )
    {
       lpMapState->ulSanity = 0L;

       return( M_bFreePAN1DATA( lpMapState->ulhPan1Data ) );
    }

    return( FALSE );
}


#ifndef NOELSEPICKFONTS

/***************************************************************************
 * FUNCTION: nPANGetMapDefault
 *
 * PURPOSE:  Fill in the passed-in PANOSE number structure with the
 *           default font.
 *
 * RETURNS:  Return 0 if the default number was not copied (passed-in
 *           structure too small), or NUM_PAN_DIGITS if it was.
 ***************************************************************************/

EW_SHORT EW_FAR EW_PASCAL nPANGetMapDefault( EW_LPMAPSTATE lpMapState,
                                             EW_LPBYTE lpPanDef,
                                             EW_USHORT unSizePanDef)
{
    //
    //  Sanity checks.
    //
    
    if( !M_SANE( lpMapState ) || ( unSizePanDef < SIZE_PAN1_NUM ) )
    {
        return( 0 );
    }

    //
    //  Copy the number.
    //

    M_ELSEMEMCPY( lpPanDef, lpMapState->ajPanDef, SIZE_PAN1_NUM );
    
    return( NUM_PAN_DIGITS );
}


/***************************************************************************
 * FUNCTION: nPANSetMapDefault
 *
 * PURPOSE:  Make the passed-in PANOSE number the new default font.  There
 *           is no sanity checking on the number.
 *
 * RETURNS:  Return 0 if the default number was not copied (passed-in
 *           structure too small), or NUM_PAN_DIGITS if it was.
 ***************************************************************************/

EW_SHORT EW_FAR EW_PASCAL nPANSetMapDefault( EW_LPMAPSTATE lpMapState,
                                             EW_LPBYTE lpPanDef,
                                             EW_USHORT unSizePanDef)
{
    //
    //  Sanity checks.
    //
    
    if( !M_SANE( lpMapState ) || ( unSizePanDef < SIZE_PAN1_NUM ) )
    {
       return( 0 );
    }
    
    //
    //  Copy the number.
    //
    
    M_ELSEMEMCPY( lpMapState->ajPanDef, lpPanDef, SIZE_PAN1_NUM );
    
    return( NUM_PAN_DIGITS );
}


/***************************************************************************
 * FUNCTION: bPANEnableMapDefault
 *
 * PURPOSE:  Enable/disable usage of the default font.
 *
 * RETURNS:  Return the previous usage state, or FALSE in the event of
 *           an error.
 ***************************************************************************/

EW_BOOL EW_FAR EW_PASCAL bPANEnableMapDefault( EW_LPMAPSTATE lpMapState,
                                               EW_BOOL bEnable)
{
    if( M_SANE( lpMapState ) )
    {
        EW_BOOL bPrev = lpMapState->bUseDef;

        lpMapState->bUseDef = bEnable;

        return( bPrev );
    }
    else
    {
        return( FALSE );
    }
}


/***************************************************************************
 * FUNCTION: bPANIsDefaultEnabled
 *
 * PURPOSE:  This function gets the state of using the default font.
 *
 * RETURNS:  Return TRUE if usage of the default font is enabled, and
 *           FALSE if it is not or an error occurred.
 ***************************************************************************/

EW_BOOL EW_FAR EW_PASCAL bPANIsDefaultEnabled( EW_LPMAPSTATE lpMapState )
{
    return( M_SANE( lpMapState ) && lpMapState->bUseDef );
}

#endif /* ifndef NOELSEPICKFONTS */


#ifndef NOELSETHRESHOLD

/***************************************************************************
 * FUNCTION: unPANGetMapThreshold
 *
 * PURPOSE:  This function gets the state of using threshold checking
 *           in the mapper.
 *
 * RETURNS:  Return the match threshold, or zero if an error occurred.
 ***************************************************************************/

EW_USHORT EW_FAR EW_PASCAL unPANGetMapThreshold( EW_LPMAPSTATE lpMapState )
{
    return( M_SANE( lpMapState ) ? lpMapState->unThreshold : 0 );
}


/***************************************************************************
 * FUNCTION: bPANSetMapThreshold
 *
 * PURPOSE:  Change the match threshold.
 *
 * RETURNS:  Return TRUE if the threshold is changed, FALSE if it is
 *           equal to the match error value and therefore rejected, or
 *           an error occurred.
 ***************************************************************************/

EW_BOOL EW_FAR EW_PASCAL bPANSetMapThreshold( EW_LPMAPSTATE lpMapState,
                                              EW_USHORT unThreshold)
{
    //
    //  Cannot set a threshold equal to the error value.
    //
    
    if( !M_SANE( lpMapState ) || ( unThreshold == PAN_MATCH_ERROR ) )
    {
       return( FALSE );
    }
    
    //
    //  Set new threshold.
    //
    
    lpMapState->unThreshold = unThreshold;
    
    return( TRUE );
}


/***************************************************************************
 * FUNCTION: bPANIsThresholdRelaxed
 *
 * PURPOSE:  This function gets the state of using the threshold in
 *           mapping.
 *
 * RETURNS:  Return TRUE if the match threshold is relaxed, or FALSE if
 *           it is not or an error occurred.
 ***************************************************************************/

EW_BOOL EW_FAR EW_PASCAL bPANIsThresholdRelaxed( EW_LPMAPSTATE lpMapState )
{
    return( M_SANE( lpMapState ) &&( lpMapState->unRelaxThresholdCount > 0 ) );
}


/***************************************************************************
 * FUNCTION: vPANRelaxThreshold
 *
 * PURPOSE:  Temporarily relax the threshold variable so every font
 *           except the erroneous ones will return a match value.
 *
 * RETURNS:  Nothing.
 ***************************************************************************/

EW_VOID EW_FAR EW_PASCAL vPANRelaxThreshold( EW_LPMAPSTATE lpMapState )
{
    if( M_SANE( lpMapState ) )
    {
       ++lpMapState->unRelaxThresholdCount;
    }
}


/***************************************************************************
 * FUNCTION: bPANRestoreThreshold
 *
 * PURPOSE:  Restore mapping within a threshold.
 *
 * RETURNS:  Return TRUE if the threshold is back in effect or an error
 *           occurred, FALSE if someone else has relaxed it too so it
 *           still is relaxed. We return TRUE on error in the event someone
 *           rights a 'for' loop restoring until TRUE is returned.
 ***************************************************************************/

EW_BOOL EW_FAR EW_PASCAL bPANRestoreThreshold( EW_LPMAPSTATE lpMapState )
{
    if( M_SANE( lpMapState ) &&( lpMapState->unRelaxThresholdCount > 0 ) )
    {
       return( --lpMapState->unRelaxThresholdCount == 0 );
    }
    else
    {
       return( TRUE );
    }
}

#endif /* ifndef NOELSETHRESHOLD */


#ifndef NOELSEWEIGHTS

/***************************************************************************
 * FUNCTION: bPANGetMapWeights
 *
 * PURPOSE:  Retrieve the mapper weight values for the passed-in family
 *           digits pair. The variable *lpbIsCustom is set if custom
 *           mapper weights have been set by the caller.
 *
 *           The weights array is an array of 10 bytes corresponding to
 *           the 10 PANOSE digits. The first weight is ignored (and usually
 *           set to zero) because we never actually assess a weighted
 *           penalty on the family digit. We include it so the index
 *           constants may be used to access the values in the weights
 *           array.
 *
 * RETURNS:  Return TRUE if mapper weights were retrieved/available (it is
 *           legal for the caller to pass in NULL for lpjWts), or FALSE
 *           if none exist.
 ***************************************************************************/

EW_BOOL EW_FAR EW_PASCAL bPANGetMapWeights( EW_LPMAPSTATE lpMapState,
                                            EW_BYTE jFamilyA,
                                            EW_BYTE jFamilyB,
                                            EW_LPBYTE lpjWts,
                                            EW_LPBOOL lpbIsCustom)
{
    EW_USHORT      i;
    EW_BOOL        bFound = FALSE;
    EW_LPPDICT_MEM lpPDB;
    EW_LPPIND_MEM  lpPanIndRec;
    EW_LPBYTE      lpjWtA;
    EW_LPBYTE      lpjWtB;
    

    //
    //  Sanity test on the family digits.
    //

    if( !M_SANE( lpMapState ) ||
         ( jFamilyA <= PANOSE_NOFIT ) ||( jFamilyA > MAX_PAN1_FAMILY ) ||
         ( jFamilyB <= PANOSE_NOFIT ) ||( jFamilyB > MAX_PAN1_FAMILY ) )
    {
        return( FALSE );
    }

    //
    //  Search for custom weights.
    //

    for( i = 0, lpjWtA = lpMapState->ajWtRefA, lpjWtB = lpMapState->ajWtRefB;
          !bFound && ( i < MAX_CUSTOM_WEIGHTS ) && *lpjWtA;
          ++i, ++lpjWtA, ++lpjWtB)
    {
        //
        //  If custom weights are found then set *lpbIsCustom to
        //  TRUE, copy the weights, and return success.
        //
        
        if( ( (*lpjWtA == jFamilyA ) &&( *lpjWtB == jFamilyB ) ) ||
             ( (*lpjWtA == jFamilyB ) &&( *lpjWtB == jFamilyA ) ) )
        {
            if( lpjWts )
            {
                M_ELSEMEMCPY( lpjWts,
                              &lpMapState->ajCustomWt[SIZE_PAN1_NUM * i],
                              SIZE_PAN1_NUM );
            }

            if( lpbIsCustom )
            {
                *lpbIsCustom = TRUE;
            }

            bFound = TRUE;
        }
    }

    //
    //  No custom weights available. Search the penalty database
    //  for default weights.
    //

    if( !bFound && ( lpPDB = M_lLockPAN1DATA( lpMapState->ulhPan1Data ) ) )
    {
        for( i = 0, lpPanIndRec = lpPDB->pind;
             !bFound && ( i < lpPDB->unNumDicts );
             ++i, ++lpPanIndRec )
        {
            if( ( (lpPanIndRec->jFamilyA == jFamilyA ) &&
                (  lpPanIndRec->jFamilyB == jFamilyB ) ) ||
                ( (lpPanIndRec->jFamilyA == jFamilyB ) &&
                (  lpPanIndRec->jFamilyB == jFamilyA ) ) )
            {
                if( lpPanIndRec->unOffsWts )
                {
                    if( lpjWts )
                    {
                        M_ELSEMEMCPY( lpjWts,
                                      M_lpjOFFS( lpPDB, lpPanIndRec->unOffsWts ),
                                      SIZE_PAN1_NUM );
                    }

                    if( lpbIsCustom )
                    {
                        *lpbIsCustom = FALSE;
                    }

                    bFound = TRUE;
                }
            }
        }

        M_bUnlockPAN1DATA( lpMapState->ulhPan1Data );
    }

    //
    //  Return the result of the search.
    //

    return( bFound );
}


/***************************************************************************
 * FUNCTION: bPANSetMapWeights
 *
 * PURPOSE:  Set the mapper weight values for the passed-in family
 *           digits pair.
 *
 *           The weights array is an array of 10 bytes corresponding to
 *           the 10 PANOSE digits. The first weight is ignored (and usually
 *           set to zero) because we never actually assess a weighted
 *           penalty on the family digit. We include it so the index
 *           constants may be used to access the values in the weights
 *           array.
 *
 * RETURNS:  Return TRUE if mapper weights were set, or FALSE if this
 *           family pair is not supported by the mapper or there is no
 *           more room for custom mapper weights.
 ***************************************************************************/

EW_BOOL EW_FAR EW_PASCAL bPANSetMapWeights( EW_LPMAPSTATE lpMapState,
                                            EW_BYTE jFamilyA,
                                            EW_BYTE jFamilyB,
                                            EW_LPBYTE lpjWts )
{
    EW_USHORT      i;
    EW_BOOL        bFound;
    EW_LPPDICT_MEM lpPDB;
    EW_LPPIND_MEM  lpPanIndRec;
    EW_LPBYTE      lpjWtA;
    EW_LPBYTE      lpjWtB;
    EW_LPBYTE      lpjWtFam;
    

    //
    //  Sanity test on the family digits.
    //

    if( !M_SANE( lpMapState ) || !lpjWts ||
         ( jFamilyA <= PANOSE_NOFIT ) ||( jFamilyA > MAX_PAN1_FAMILY ) ||
         ( jFamilyB <= PANOSE_NOFIT ) ||( jFamilyB > MAX_PAN1_FAMILY ) )
    {
        return( FALSE );
    }

    //
    //  First make sure this family pair exists in the penalty
    //  database (it does not make sense to store penalties for
    //  a family pair we'll never map against).
    //

    if( lpPDB = M_lLockPAN1DATA( lpMapState->ulhPan1Data ) )
    {
        for( i = 0, bFound = FALSE, lpPanIndRec = lpPDB->pind;
             i < lpPDB->unNumDicts; ++i, ++lpPanIndRec)
        {
            if( ( (lpPanIndRec->jFamilyA == jFamilyA ) &&
                (  lpPanIndRec->jFamilyB == jFamilyB ) ) ||
                ( (lpPanIndRec->jFamilyA == jFamilyB ) &&
                (  lpPanIndRec->jFamilyB == jFamilyA ) ) )
            {
                bFound = TRUE;
                break;
            }
        }

        M_bUnlockPAN1DATA( lpMapState->ulhPan1Data );

        if( !bFound )
        {
            return( FALSE );
        }
    }
    else
    {
        return( FALSE );
    }

    //
    //  Search for an existing entry.
    //

    for( i = 0, lpjWtA = lpMapState->ajWtRefA, lpjWtB = lpMapState->ajWtRefB;
         ( i < MAX_CUSTOM_WEIGHTS ) && *lpjWtA;
          ++i, ++lpjWtA, ++lpjWtB)
    {
        if( ( (*lpjWtA == jFamilyA ) &&( *lpjWtB == jFamilyB ) ) ||
            ( (*lpjWtA == jFamilyB ) &&( *lpjWtB == jFamilyA ) ) )
        {
            break;
        }
    }

    //
    //  Abort if the weights were not found and there are no free slots.
    //

    if( i >= MAX_CUSTOM_WEIGHTS )
    {
        return( FALSE );
    }

    //
    //  We either found the previous weights or have a free slot,
    //  in both cases copy the passed-in weights. For aesthetics,
    //  preserve zero for the family weight( it is not used ).
    //

    *lpjWtA = jFamilyA;
    *lpjWtB = jFamilyB;

    M_ELSEMEMCPY( lpjWtFam = &lpMapState->ajCustomWt[SIZE_PAN1_NUM * i],
                  lpjWts, SIZE_PAN1_NUM);

    *lpjWtFam = 0;
    
    //
    //  Return success.
    //

    return( TRUE );
}


/***************************************************************************
 * FUNCTION: bPANClearMapWeights
 *
 * PURPOSE:  Locate the custom mapper weights for the passed-in family
 *           digit pair and clear them, thus causing the mapper to revert
 *           back to using the default weights.
 *
 * RETURNS:  Return TRUE if custom mapper weights were located and cleared,
 *           FALSE if there are no custom weights for the passed-in family
 *           digit pair.
 ***************************************************************************/

EW_BOOL EW_FAR EW_PASCAL bPANClearMapWeights( EW_LPMAPSTATE lpMapState,
                                              EW_BYTE jFamilyA,
                                              EW_BYTE jFamilyB )
{
    EW_USHORT i;
    EW_USHORT j;
    EW_LPBYTE lpjWtA;
    EW_LPBYTE lpjWtB;
    

    //
    //  Sanity test on the family digits.
    //

    if( !M_SANE( lpMapState ) ||
         ( jFamilyA <= PANOSE_NOFIT ) ||( jFamilyA > MAX_PAN1_FAMILY ) ||
         ( jFamilyB <= PANOSE_NOFIT ) ||( jFamilyB > MAX_PAN1_FAMILY ) )
    {
        return( FALSE );
    }

    //
    //  Search for custom weights.
    //

    for( i = 0, lpjWtA = lpMapState->ajWtRefA, lpjWtB = lpMapState->ajWtRefB;
         ( i < MAX_CUSTOM_WEIGHTS ) && *lpjWtA;
          ++i, ++lpjWtA, ++lpjWtB)
    {
        //
        //  If custom weights are found then overwrite them by
        //  shifting other weights forward in the array.
        //

        if( ( (*lpjWtA == jFamilyA ) &&( *lpjWtB == jFamilyB ) ) ||
            ( (*lpjWtA == jFamilyB ) &&( *lpjWtB == jFamilyA ) ) )
        {
            for( j = i + 1, ++lpjWtA, ++lpjWtB;
                 ( j < MAX_CUSTOM_WEIGHTS ) && *lpjWtA;
                  ++j, ++lpjWtA, ++lpjWtB)
            {
                lpjWtA[-1] = *lpjWtA;
                lpjWtB[-1] = *lpjWtB;
            }

            lpjWtA[-1] = PANOSE_ANY;
            lpjWtB[-1] = PANOSE_ANY;

            if( i < ( j - 1 ) )
            {
                M_ELSEMEMCPY( &lpMapState->ajCustomWt[SIZE_PAN1_NUM * i],
                              &lpMapState->ajCustomWt[SIZE_PAN1_NUM * (i + 1)],
                              ( SIZE_PAN1_NUM * (j - i - 1 ) ) );
            }

            return( TRUE );
        }
    }

    //
    //  Custom weights matching this family digit pair were not
    //  found, return failure.
    //

    return( FALSE );
}


#endif /* ifndef NOELSEWEIGHTS */


/***************************************************************************
 * FUNCTION: unPANMatchFonts
 *
 * PURPOSE:  Match two PANOSE numbers.
 *
 * RETURNS:  Return a match value if the fonts are successfully compared
 *           and are within range of the threshold, otherwise return
 *           PAN_MATCH_ERROR if there is an error or the fonts are out
 *           of range.
 ***************************************************************************/

EW_USHORT EW_FAR EW_PASCAL unPANMatchFonts( EW_LPMAPSTATE lpMapState,
                                            EW_LPBYTE lpPanWant,
                                            EW_ULONG ulSizeWant,
                                            EW_LPBYTE lpPanThis,
                                            EW_ULONG ulSizeThis,
                                            EW_BYTE jMapToFamily )
{
    EW_USHORT unMatch = PAN_MATCH_ERROR;
    EW_USHORT unThreshold;
    EW_USHORT i;
    EW_USHORT j;
    EW_LPPDICT_MEM lpPDB;
    EW_LPPIND_MEM lpPanIndRec;
    EW_LPPTBL_MEM lpPTblRec;
    EW_LPBYTE lpjWts;
    EW_LPATOB_MEM lpAtoBHead;
    EW_LPATOB_ITEM_MEM lpAtoB;


    //
    //  Sanity check on the PANOSE numbers. Both numbers must be
    //  valid PANOSE 1.0 numbers, and the 'this'( compared-to )
    //  number must match the map-to family.
    //

    if( !M_SANE( lpMapState ) ||
         ( ulSizeWant != SIZE_PAN1_NUM ) || ( ulSizeThis != SIZE_PAN1_NUM ) ||
         ( lpPanWant[PAN_IND_FAMILY] <= PANOSE_NOFIT )   ||
         ( lpPanWant[PAN_IND_FAMILY] > MAX_PAN1_FAMILY ) ||
         ( lpPanThis[PAN_IND_FAMILY] <= PANOSE_NOFIT )   ||
         ( lpPanThis[PAN_IND_FAMILY] > MAX_PAN1_FAMILY ) ||
         ( lpPanThis[PAN_IND_FAMILY] != jMapToFamily ) )
    {
        goto backout0;
    }

    //
    //  Lock the penalty database.
    //

    if( !(lpPDB = M_lLockPAN1DATA( lpMapState->ulhPan1Data ) ) )
    {
        goto backout0;
    }

    //
    //  Locate the index entry that points to the dictionary containing
    //  the penalty tables for this PANOSE number.
    //  This routine may flip what lpPanWant and lpPanThis point to so
    //  we can guarantee the 'FamilyA' from the penalty tables is always
    //  associated with lpPanWant and 'FamilyB' is associated with
    //  lpPanThis.
    // 
    //  Optimization for unsupported families: If we do not support this
    //  family, but the numbers are identical, then return an 'exact match'
    //  value of zero. Otherwise return the usual match error value.
    //

    if( !(lpPanIndRec = s_lpPANGetIndRec(lpPDB, &lpPanWant, &lpPanThis ) ) )
    {
        for( i = 0; ( i < NUM_PAN_DIGITS ) && ( *lpPanWant == *lpPanThis ) &&
             ( *lpPanWant != PANOSE_NOFIT );
              ++i, ++lpPanWant, ++lpPanThis)
           ;
        
        if( i >= NUM_PAN_DIGITS )
        {
            unMatch = 0;
        }

        goto backout1;
    }

    //
    //  Get the array of mapper weights -- this could be a custom array
    //  supplied by the user, or the default array from the penalty
    //  database.
    //

    if( !( lpjWts = s_lpPANGetWeights( lpMapState, lpPDB, lpPanIndRec ) ) )
    {
        goto backout1;
    }

    //
    //  If we are NOT supposed to do threshold testing then just set
    //  it to the maximum integer.
    //

    if( lpMapState->unRelaxThresholdCount > 0 )
    {
        unThreshold = ELSEMAXSHORT;
    }
    else
    {
        unThreshold = lpMapState->unThreshold;
    }

    //
    //  Index the penalty table array.
    //

    lpPTblRec = (EW_LPPTBL_MEM) M_lpjOFFS( lpPDB, lpPanIndRec->unOffsPTbl );
    
    //
    //  There are two flavors of walking the digits:
    // 
    //  1. For cross-family matching, we walk an array of indices mapping
    //     digits from one family to the digits of another.
    //  2. For normal( same family ) matching, we directly walk the digits.
    // 
    //  Test for an a-to-b array( cross-family matching ).
    //

    if( lpPanIndRec->unOffsAtoB )
    {
        //
        //  This is a cross-family mapping, get the a-to-b array head.
        //
        
        lpAtoBHead = (EW_LPATOB_MEM) M_lpjOFFS( lpPDB, lpPanIndRec->unOffsAtoB );
        
        //
        //  Walk the a-to-b array.
        //
        
        for( i = unMatch = 0, j = lpAtoBHead->unNumAtoB,
              lpAtoB = lpAtoBHead->AtoBItem;
              i < j;
              ++i, ++lpPTblRec, ++lpjWts, ++lpAtoB)
        {
            //
            //  Compare the two digits. Abort if the test fails or the
            //  accumulated match value is greater than the threshold.
            //

            if( !s_bPANMatchDigits( lpPDB, &unMatch, lpPanIndRec,
                  lpPTblRec, *lpjWts, lpPanWant[lpAtoB->jAttrA],
                  lpPanThis[lpAtoB->jAttrB]) ||
                 ( unMatch > unThreshold ) )
            {
                unMatch = PAN_MATCH_ERROR;
                goto backout1;
            }
        }
    }
    else
    {
        //
        //  Normal match: comparing PANOSE numbers from the same
        //  families. Walk the digits accumulating the match result.
        //
        
        for( i = unMatch = 0, ++lpPanWant, ++lpPanThis;
              i <( NUM_PAN_DIGITS - 1 );
              ++i, ++lpPTblRec, ++lpjWts, ++lpPanWant, ++lpPanThis )
        {
            //
            //  Compare the two digits. Abort if the test fails or the
            //  accumulated match value is greater than the threshold.
            //

            if( !s_bPANMatchDigits( lpPDB, &unMatch, lpPanIndRec,
                  lpPTblRec, *lpjWts, *lpPanWant, *lpPanThis) ||
                 ( unMatch > unThreshold ) )
            {
                unMatch = PAN_MATCH_ERROR;
                goto backout1;
            }
        }
    }

    //
    //  Return the match value. If it was out of range or an error
    //  occurred, then it will equal PAN_MATCH_ERROR.
    //

backout1:
    M_bUnlockPAN1DATA( lpMapState->ulhPan1Data );

backout0:
    return( unMatch );
}


#ifndef NOELSEPICKFONTS


/***************************************************************************
 * FUNCTION: unPANPickFonts
 *
 * PURPOSE:  Walk an array of fonts ordering them by the closest to the
 *           requested font.  If no font is within range of the threshold
 *           then look for the closest to the default font.  If still
 *           no font is found then just pick the first font in the list.
 *
 *           Implementation note: This proc assumes PANOSE 1.0 numbers.
 *           A future version of this proc will accept intermixed PANOSE
 *           1.0 and 2.0 numbers, and will call a callback routine to
 *           supply each record, instead of presuming it can walk an
 *           array of fixed-length records.
 *
 * RETURNS:  Return the number of fonts found to match the requested
 *           font, or zero if unNumInds == 0 or an error ocurred.
 *
 *           If no close match was found but the default font is enabled,
 *           then one is returned and *lpMatchValues == PAN_MATCH_ERROR.
 *
 *           If no suitable match was found and the default font is
 *           disabled, then zero is returned.
 ***************************************************************************/
EW_USHORT EW_FAR EW_PASCAL unPANPickFonts( EW_LPMAPSTATE lpMapState,
                                           EW_LPUSHORT lpIndsBest,
                                           EW_LPUSHORT lpMatchValues,
                                           EW_LPBYTE lpPanWant,
                                           EW_USHORT unNumInds,
                                           EW_LPBYTE lpPanFirst,
                                           EW_USHORT unNumAvail,
                                           EW_SHORT nRecSize,
                                           EW_BYTE jMapToFamily )
{
    EW_USHORT i;
    EW_USHORT j;
    EW_USHORT k;
    EW_USHORT unNumFound = 0;
    EW_USHORT unMatchValue;
    EW_USHORT unSavedThreshold;
    EW_LPUSHORT lpMatches;
    EW_LPUSHORT lpInds;
    EW_LPBYTE lpPanThis;
    
    //
    //  Sanity check.
    //

    if( !M_SANE( lpMapState ) || ( unNumInds == 0 ) || ( unNumAvail == 0 ) ||
         ( (nRecSize < 0 ) &&( nRecSize > -(EW_SHORT )SIZE_PAN1_NUM) ) ||
         ( (nRecSize > 0 ) &&( nRecSize < (EW_SHORT )SIZE_PAN1_NUM) ) )
    {
        return( 0 );
    }

    //
    //  This routine implements a 'quit early' algorithm by modifying
    //  the threshold to the worst acceptable value in the list (once
    //  the list is full). This has the effect of causing matchfonts
    //  to abort & return PAN_MATCH_ERROR whenever a penalty exceeds
    //  the threshold.
    //

    unSavedThreshold = lpMapState->unThreshold;
    
    //
    //  Walk the PANOSE numbers ordering them from best to worst
    //  match.  Walk the array with a byte pointer, advancing by
    //  the passed-in record size.
    //

    for( i = 0, lpPanThis = lpPanFirst; i < unNumAvail;
         ++i, lpPanThis += nRecSize)
    {
        //
        //  Get the match value.
        //

        if( ( unMatchValue = unPANMatchFonts( lpMapState,
              lpPanWant, SIZE_PAN1_NUM, lpPanThis, SIZE_PAN1_NUM,
              jMapToFamily ) ) != PAN_MATCH_ERROR )
        {
            //
            //  Find the slot in the array where this match value
            //  should reside.
            // 

            for( j = 0, lpMatches = lpMatchValues;
                ( j < unNumFound ) &&( *lpMatches < unMatchValue );
                ++j, ++lpMatches)
               ;
            
            //
            //  If this match value is better than one of the matches
            //  already in the array, then insert it.  Notice that
            //  until the array is full everything goes in it.  After
            //  that, we shuffle less close matches off the end.
            //

            if( j < unNumInds )
            {
                if( unNumFound < unNumInds )
                {
                   ++unNumFound;
                }

                for( lpInds = &lpIndsBest[k = unNumFound - 1],
                     lpMatches = &lpMatchValues[k];
                     k > j;
                     lpInds[0] = lpInds[-1], lpMatches[0] = lpMatches[-1],
                     --k, --lpInds, --lpMatches)
                    ;

                *lpInds = i;
                *lpMatches = unMatchValue;
                
                //
                //  If the list is full, then set the threshold equal
                //  to the last match value in the list. The matchfonts
                //  routine will abort & return PAN_MATCH_ERROR on any
                //  match greater than this value.
                // 
                //  Also, if the last value in the list is zero (exact
                //  match), then exit the loop because the list will
                //  not change.
                //

                if( unNumFound == unNumInds )
                {
                    if( (k = lpMatchValues[unNumFound - 1] ) == 0)
                    {
                        break;
                    }

                    lpMapState->unThreshold = k;
                }
            }
        }
    }

    //
    //  If no acceptable match was found, then attempt to find a match
    //  for the default font.  We temporarily step off the threshold
    //  so we will definitely find something.  At this point, we do
    //  not care if the default is not within the threshold, we just
    //  want to find it.
    //

    if( !unNumFound && lpMapState->bUseDef )
    {
        lpMapState->unThreshold = ELSEMAXSHORT;
    
        for( i = 0, lpPanThis = lpPanFirst; i < unNumAvail;
             ++i, lpPanThis += nRecSize)
        {
            if( ( unMatchValue = unPANMatchFonts( lpMapState,
                lpMapState->ajPanDef, SIZE_PAN1_NUM, lpPanThis, SIZE_PAN1_NUM,
                lpMapState->ajPanDef[PAN_IND_FAMILY] ) ) != PAN_MATCH_ERROR )
            {
                if( unNumFound == 0 )
                {
                    *lpIndsBest = i;
                    lpMapState->unThreshold = *lpMatchValues = unMatchValue;
                    ++unNumFound;
                }
                else if( unMatchValue < *lpMatchValues )
                {
                    *lpIndsBest = i;
                    lpMapState->unThreshold = *lpMatchValues = unMatchValue;
                }
            }
        }

        //
        //  We flag this match with the error so the caller can
        // determine that the default font was substituted.
        // 

        if( unNumFound > 0 )
        {
            *lpMatchValues = PAN_MATCH_ERROR;
        }
    }

    //
    //  Restore the threshold.
    // 

    lpMapState->unThreshold = unSavedThreshold;
    
    //
    //  If still no match is found then just pick the first font.
    //

    if( !unNumFound )
    {
        *lpIndsBest = 0;
        *lpMatchValues = PAN_MATCH_ERROR;
        ++unNumFound;
    }

    //
    //  Return the number of fonts found.  It will be zero if we
    //  encountered an error or couldn't find a suitable match.
    //

    return( unNumFound );
}


#endif /* ifndef NOELSEPICKFONTS */


/***************************************************************************
 * FUNCTION: vPANMakeDummy
 *
 * PURPOSE:  Build a dummy PANOSE number with all attributes set to
 *           PANOSE_NOFIT.
 *
 * RETURNS:  Nothing.
 ***************************************************************************/

EW_VOID EW_FAR EW_PASCAL vPANMakeDummy( EW_LPBYTE lpPanThis,
                                        EW_USHORT unSize )
{
    EW_USHORT i;
    EW_USHORT j;
    
    unSize /= sizeof( EW_BYTE );
    
    for( i = j = 0; (i < NUM_PAN_DIGITS ) &&( j < unSize );
       ++i, j += sizeof( EW_BYTE ), *lpPanThis++ = PANOSE_NOFIT)
       ;
}


/***************************************************************************/
/************************** LOCAL SERVICE ROUTINES *************************/
/***************************************************************************/


/***************************************************************************
 * FUNCTION: s_lpPANGetIndRec
 *
 * PURPOSE:  Search the header of the database looking for a dictionary
 *           of penalty tables designed for this family pair.
 *
 *           There is a similar search for the index rec in the routine
 *           bPANGetMapWeights. If you make a change here, also check in
 *           that routine.
 *
 * RETURNS:  Return the pointer to the index record if a match is found,
 *           or NULL if one is not.
 ***************************************************************************/

LOCAL EW_LPPIND_MEM EW_NEAR EW_PASCAL s_lpPANGetIndRec(
                                               EW_LPPDICT_MEM lpPDB,
                                               EW_LPBYTE EW_FAR *lplpPanWant,
                                               EW_LPBYTE EW_FAR *lplpPanThis )
{
    EW_USHORT i;
    EW_BYTE jFamilyA =( *lplpPanWant )[PAN_IND_FAMILY];
    EW_BYTE jFamilyB =( *lplpPanThis )[PAN_IND_FAMILY];
    EW_LPBYTE lpPanSwitch;
    EW_LPPIND_MEM lpPanIndRec;


    //
    //  Walk the index array in the penalty database looking for
    //  a matching family pair.
    //

    for( i = 0, lpPanIndRec = lpPDB->pind; i < lpPDB->unNumDicts;
          ++i, ++lpPanIndRec)
    {
        if( ( lpPanIndRec->jFamilyA == jFamilyA ) &&
            ( lpPanIndRec->jFamilyB == jFamilyB ) )
        {
            //
            //  Straight match. Return the index.
            //

            return( lpPanIndRec );
        
        }
        else if( ( lpPanIndRec->jFamilyA == jFamilyB ) &&
                 ( lpPanIndRec->jFamilyB == jFamilyA ) )
        {
            //
            //  There is a match but the families are swapped. Swap
            //  the PANOSE numbers to match the order in the penalty
            //  database in the event it contains tables that are
            //  order-dependent (this can happen with cross-family
            //  mapping, C0-style/uncompressed/non-symmetric tables).
            //

            lpPanSwitch = *lplpPanWant;

            *lplpPanWant = *lplpPanThis;
            *lplpPanThis = lpPanSwitch;

            return( lpPanIndRec );
        }
    }

    //
    //  No match found, return an error.
    // 

    return( NULL );
}


/***************************************************************************
 * FUNCTION: s_bPANGetPenaltyC0
 *
 * PURPOSE:  Compute the penalty between two PANOSE digits using 'C0'
 *           compression, where the entire table is provided (except
 *           the any and no-fit rows and columns).
 *
 * RETURNS:  Return TRUE if the computed index is within range, and
 *           *lpunMatch is filled in with the penalty value, FALSE if
 *           it is out of range.
 ***************************************************************************/

LOCAL EW_BOOL EW_NEAR EW_PASCAL s_bPANGetPenaltyC0( EW_LPPIND_MEM lpPanIndRec,
                                                    EW_LPPTBL_C0_MEM lpPC0,
                                                    EW_LPUSHORT lpunMatch,
                                                    EW_USHORT unTblSize,
                                                    EW_USHORT unAttrA,
                                                    EW_USHORT unAttrB )
{
    EW_USHORT unInd;


    //
    //  Make sure each value is within range.  Notice this may
    //  be a non-square table.
    //

    if( ( unAttrA > lpPC0->jARangeLast ) ||( unAttrB > lpPC0->jBRangeLast ) )
    {
        *lpunMatch = lpPanIndRec->jDefNoFitPenalty;

        return( FALSE );
    }

    //
    //  Compute the table index.
    //

    if( ( unInd = ( (unAttrA - 2 ) *(lpPC0->jBRangeLast - 1 ) )
                        + unAttrB - 2) >= unTblSize )
    {
        *lpunMatch = lpPanIndRec->jDefNoFitPenalty;

        return( FALSE );
    }

    //
    //  Get the penalty.
    //

    *lpunMatch = lpPC0->jPenalties[unInd];

    return( TRUE );
}


/***************************************************************************
 * FUNCTION: s_unPANGetPenaltyC1
 *
 * PURPOSE:  Compute the penalty between two PANOSE digits using 'C1'
 *           compression, which is a perfectly symmetrical table around
 *           the diagonal.  Two digits on the diagonal are an exact match.
 *           A difference of 1 yields a penalty of 1, a difference of 2
 *           yields a penalty of 2, and so on.
 *
 *           It is assumed the caller handled any, no-fit, and exact
 *           matches.
 *
 * RETURNS:  Return the penalty from the table, the function cannot fail.
 ***************************************************************************/
LOCAL EW_USHORT EW_NEAR EW_PASCAL s_unPANGetPenaltyC1( EW_USHORT unAttrA,
                                                       EW_USHORT unAttrB )
{
    EW_SHORT nDiff;
    

    //
    //  Compute the penalty, which is simply the absolute value
    //  of the difference between the two numbers.
    //

    if( ( nDiff = (EW_SHORT) unAttrA - (EW_SHORT) unAttrB ) < 0 )
    {
        nDiff = -nDiff;
    }

    return( nDiff );
}


/***************************************************************************
 * FUNCTION: s_bPANGetPenaltyC2
 *
 * PURPOSE:  Compute the penalty between two PANOSE digits using 'C2'
 *           compression, which is a table symmetrical about the
 *           diagonal, but not a smooth range from low to high, so the
 *           lower left corner of the table is provided.  The unAttrA
 *           digit references the row and unAttrB references the column.
 *
 *           It is assumed the caller handled any, no-fit, and exact
 *           matches.
 *
 * RETURNS:  Return TRUE if the computed index is within range, and
 *           *lpunMatch is filled in with the penalty value, FALSE if
 *           it is out of range.
 ***************************************************************************/

LOCAL EW_BOOL EW_NEAR EW_PASCAL s_bPANGetPenaltyC2( EW_LPPIND_MEM lpPanIndRec,
                                                    EW_LPBYTE lpPTbl,
                                                    EW_LPUSHORT lpunMatch,
                                                    EW_USHORT unTblSize,
                                                    EW_USHORT unAttrA,
                                                    EW_USHORT unAttrB )
{
    EW_USHORT unSwap;
    EW_SHORT nInd;


    //
    //  The formula we use assumes the lower left half of the
    //  penalty table, which means row > column.  The table is
    //  symmetric about the diagonal, so if row < column we can
    //  just switch their values.
    // 

    if( unAttrA < unAttrB )
    {
       unSwap = unAttrA;
       unAttrA = unAttrB;
       unAttrB = unSwap;
    }

    //
    //  The table is missing the any, no-fit, and exact match
    //  penalties as those are handled separately.  Since the
    //  table is triangular shaped, we use the additive series
    //  to compute the row:
    // 
    //    n + ... + 3 + 2 + 1 == 1/2 * n *( n + 1 )
    // 
    //  Substituting n for row - 3, the first possible row, and
    //  adding the column offset, we get the following formula:
    // 
    //   ( 1/2 * (row - 3 ) *( row - 2 ) ) +( col - 2 )
    // 
    //  We know that row >= 3 and col >= 2 as we catch the other
    //  cases above.
    // 

    if( ( nInd = M_ELSEMULDIV( unAttrA - 3, unAttrA - 2, 2 ) +
         (EW_SHORT) unAttrB - 2) >= (EW_SHORT) unTblSize )
    {
        *lpunMatch = lpPanIndRec->jDefNoFitPenalty;

        return( FALSE );
    }

    *lpunMatch = lpPTbl[nInd];

    return( TRUE );
}


/***************************************************************************
 * FUNCTION: s_unPANGetPenaltyC4
 *
 * PURPOSE:  Compute the penalty between two PANOSE digits using 'C4'
 *           compression, which is almost identical to  'C1' compression
 *           except a start and increment value are supplied.
 *
 *           It is assumed the caller handled any, no-fit, and exact
 *           matches.
 *
 * RETURNS:  Return the penalty from the table, the function cannot fail.
 ***************************************************************************/

LOCAL EW_USHORT EW_NEAR EW_PASCAL s_unPANGetPenaltyC4( EW_LPPTBL_C4_MEM lpPC4,
                                                       EW_USHORT unAttrA,
                                                       EW_USHORT unAttrB )
{
    EW_SHORT nDiff;
    

    //
    //  First compute the absolute value of the difference
    //  between the two numbers.
    // 

    if( (nDiff = (EW_SHORT )unAttrA -( EW_SHORT )unAttrB) < 0)
    {
       nDiff = -nDiff;
    }

    //
    //  Then scale by the increment and start values.
    // 

    if( nDiff > 0 )
    {
       nDiff = ( ( nDiff - 1 ) *(EW_SHORT) lpPC4->jIncrement ) +
                (EW_SHORT) lpPC4->jStart;
    }

    return( nDiff );
}


/***************************************************************************
 * FUNCTION: s_lpPANGetWeights
 *
 * PURPOSE:  Check the mapstate record for a set of user-supplied custom
 *           weights. If none are present, then use the default weights
 *           from the mapping table.
 *
 * RETURNS:  Return the pointer to the array of weight values.
 ***************************************************************************/

LOCAL EW_LPBYTE EW_NEAR EW_PASCAL s_lpPANGetWeights( EW_LPMAPSTATE lpMapState,
                                                     EW_LPPDICT_MEM lpPDB,
                                                     EW_LPPIND_MEM lpPanIndRec )
{
    EW_USHORT i;
    EW_LPBYTE lpjWtA;
    EW_LPBYTE lpjWtB;
    EW_BYTE jFamilyA = lpPanIndRec->jFamilyA;
    EW_BYTE jFamilyB = lpPanIndRec->jFamilyB;
    
#ifndef NOELSEWEIGHTS
    //
    //  Search for custom weights.
    // 

    for( i = 0, lpjWtA = lpMapState->ajWtRefA, lpjWtB = lpMapState->ajWtRefB;
         ( i < MAX_CUSTOM_WEIGHTS ) && *lpjWtA;
          ++i, ++lpjWtA, ++lpjWtB )
    {
        //
        //  If custom weights are found then return a pointer into
        //  the mapstate struct. We store a weight value for the family
        //  digit but do not use it. The pointer points to the first
        //  digit after the family digit.
        // 

        if( ( (*lpjWtA == jFamilyA ) &&( *lpjWtB == jFamilyB ) ) ||
            ( (*lpjWtA == jFamilyB ) &&( *lpjWtB == jFamilyA ) ) )
        {
            return( &lpMapState->ajCustomWt[ ( SIZE_PAN1_NUM * i ) + 1] );
        }
    }
#endif

    //
    //  If no custom weights were found then return the default
    //  weight from the penalty database.
    // 

    if( lpPanIndRec->unOffsWts )
    {
       return( M_lpjOFFS(lpPDB, lpPanIndRec->unOffsWts + 1 ) );
    }
    else
    {
       return( NULL );
    }
}


/***************************************************************************
 * FUNCTION: s_bPANMatchDigits
 *
 * PURPOSE:  Compute the match value between two PANOSE digits and add
 *           it to the passed in match total.
 *
 * RETURNS:  Return TRUE if the match value is computed and added to
 *           *lpunMatchTotal.  If an error occurs, return FALSE and
 *           set *lpunMatchTotal to the value PAN_MATCH_ERROR.
 ***************************************************************************/

LOCAL EW_BOOL EW_NEAR EW_PASCAL s_bPANMatchDigits( EW_LPPDICT_MEM lpPDB,
                                                   EW_LPUSHORT lpunMatchTotal,
                                                   EW_LPPIND_MEM lpPanIndRec,
                                                   EW_LPPTBL_MEM lpPTblRec,
                                                   EW_USHORT unWt,
                                                   EW_USHORT unAttrA,
                                                   EW_USHORT unAttrB )
{
    EW_USHORT unLast = lpPTblRec->jRangeLast;
    EW_USHORT unMatch;
    

    //
    //  First make sure the digit values are not out of range.
    // 

    if( (unAttrA > unLast ) ||( unAttrB > unLast ) )
    {
       goto errout;
    }

    //
    //  Special case no-fit, any, or exact matches.
    // 

    if( ( unAttrA == PANOSE_NOFIT ) || ( unAttrB == PANOSE_NOFIT ) )
    {
        if( lpPTblRec->jCompress != PAN_COMPRESS_C3 )
        {
           *lpunMatchTotal += lpPanIndRec->jDefNoFitPenalty * unWt;
           return( TRUE );
        }
    }
    else if( ( unAttrA == PANOSE_ANY ) || ( unAttrB == PANOSE_ANY ) )
    {
        *lpunMatchTotal += lpPanIndRec->jDefAnyPenalty * unWt;
        return( TRUE );
    }
    else if( (unAttrA == unAttrB ) &&
            ( lpPTblRec->jCompress != PAN_COMPRESS_C0 ) )
    {
        *lpunMatchTotal += lpPanIndRec->jDefMatchPenalty * unWt;
        return( TRUE );
    }

    //
    //  Compute the penalty depending on the kind of compression
    //  used for the table.
    // 

    switch( lpPTblRec->jCompress )
    {
    
        case PAN_COMPRESS_C0:
            if( !lpPTblRec->unOffsTbl || !lpPTblRec->unTblSize
                || !s_bPANGetPenaltyC0( lpPanIndRec,
                  (EW_LPPTBL_C0_MEM) M_lpjOFFS( lpPDB, lpPTblRec->unOffsTbl ),
                  &unMatch, lpPTblRec->unTblSize, unAttrA, unAttrB ) )
            {
                goto errout;
            }
            
            *lpunMatchTotal += unMatch * unWt;
            break;
        
        case PAN_COMPRESS_C1:
            *lpunMatchTotal += s_unPANGetPenaltyC1( unAttrA, unAttrB ) * unWt;
            break;
        
        case PAN_COMPRESS_C2:
            if( !lpPTblRec->unOffsTbl || !lpPTblRec->unTblSize ||
                !s_bPANGetPenaltyC2( lpPanIndRec,
                  M_lpjOFFS( lpPDB, lpPTblRec->unOffsTbl ), &unMatch,
                  lpPTblRec->unTblSize, unAttrA, unAttrB ) )
            {
                goto errout;
            }
            
            *lpunMatchTotal += unMatch * unWt;
            break;
        
        case PAN_COMPRESS_C3:
            if( !lpPTblRec->unOffsTbl || !lpPTblRec->unTblSize )
            {
                goto errout;
            }
            
            if( ( unAttrA == PANOSE_NOFIT ) || ( unAttrB == PANOSE_NOFIT ) )
            {
                unMatch = *M_lpjOFFS( lpPDB, lpPTblRec->unOffsTbl );
            }
            else if( !s_bPANGetPenaltyC2( lpPanIndRec,
                     M_lpjOFFS( lpPDB, lpPTblRec->unOffsTbl + 1 ), &unMatch,
                                (EW_USHORT) ( lpPTblRec->unTblSize - 1 ),
                                unAttrA, unAttrB ) )
            {
                goto errout;
            }
            
            *lpunMatchTotal += unMatch * unWt;
            break;
        
        case PAN_COMPRESS_C4:
            if( !lpPTblRec->unOffsTbl || !lpPTblRec->unTblSize )
            {
                goto errout;
            }
            
            *lpunMatchTotal += s_unPANGetPenaltyC4(
                (EW_LPPTBL_C4_MEM) M_lpjOFFS( lpPDB, lpPTblRec->unOffsTbl ),
                unAttrA, unAttrB) * unWt;
            break;
    }

    //
    //  Match computed, successful return.
    // 

    return( TRUE );
    
    //
    //  An error occurred, return FALSE.
    // 

errout:

    *lpunMatchTotal = PAN_MATCH_ERROR;

    return( FALSE );
}

/***************************************************************************
 * Revision log:
 *
 * 31-Jan-93  msd PANOSE 1.0 mapper: 10-digit PANOSE.
 *  2-Feb-93  msd Removed huge pointer stuff.
 *  3-Feb-93  msd Removed ctrl-z at EOF.  Added 'unused' pragmas.
 *  3-Feb-93  msd Fixed bug caused by vcs check-in.
 * 14-Feb-93  msd Removed extra restore-threshold call in pickfonts.
 * 15-Feb-93  msd For extra security, bumped the sanity value from
 *                word to a long.
 ***************************************************************************/
/*
 * $lgb$
 * 1.0    17-Feb-93    msd New module created because of vcs problems.
 * 1.1    17-Feb-93    msd Small doc change.
 * 1.2    18-Feb-93    msd Added penalty table byte-ordering check, and C4 ptbl compression( new version of ptbl ). Modified internal routines so 'unused' pragmas are not necessary. Use EW_FAR.
 * 1.3    23-Feb-93    msd On close session, kill the sanity value so subsequent mapper calls will fail.
 * 1.4    25-Feb-93    msd Modified the default font search logic in pickfonts -- search by the default font's family, not by the requested family. Also use M_ELSEMEMCPY() in a few more places.
 * 1.5    19-Jul-93    msd Added compilation flags to selectively disable mapper routines.
 * $lge$
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\fontview\ttdefs.h ===
typedef struct {
    BYTE    bMSB;
    BYTE    bLSB;
} MWORD;

typedef MWORD *LPMWORD;

#define MWORD2INT(mw)  ((mw).bMSB * 256 + (mw).bLSB)

typedef struct {
    MWORD   mwidPlatform;
    MWORD   mwidEncoding;
    MWORD   mwidLang;
    MWORD   mwidName;
    MWORD   mwcbString;
    MWORD   mwoffString;
} TTNAMEREC;

typedef TTNAMEREC *PTTNAMEREC;

typedef struct {
    MWORD   mwiFmtSel;
    MWORD   mwcNameRec;
    MWORD   mwoffStrings;
    TTNAMEREC   anrNames[1];
} TTNAMETBL;

typedef TTNAMETBL *PTTNAMETBL;


#define     TT_TBL_NAME         0x656D616E      // 'name'

#define     TTID_PLATFORM_MAC   1
#define     TTID_PLATFORM_MS    3

#define     TTID_MS_UNDEFINED   0
#define     TTID_MS_UNICODE     1
#define     TTID_MS_SHIFTJIS    2
#define     TTID_MS_GB          3
#define     TTID_MS_BIG5        4
#define     TTID_MS_WANSUNG     5

#define     TTID_NAME_COPYRIGHT  0
#define     TTID_NAME_FONTFAMILY 1
#define     TTID_NAME_FONTSUBFAM 2
#define     TTID_NAME_UNIQFONTID 3
#define     TTID_NAME_FULLFONTNM 4
#define     TTID_NAME_VERSIONSTR 5
#define     TTID_NAME_PSFONTNAME 6
#define     TTID_NAME_TRADEMARK  7
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\ole2map\elsetype.h ===
/***************************************************************************
 * ELSETYPE.H - Public ElseWare include file.
 *
 * $keywords: elsetype.h 1.13  5-Oct-93 5:46:20 PM$
 *
 * Used to design public interfaces to mapper, mai, TMR, 318 etc.)
 *
 * Most ElseWare types contain an "EW_" to avoid confusion with other host
 * defined types.  All source files must include this file.  This file
 * should be included **AFTER** other standard environment headers such
 * as windows.h, c include files.
 *
 * Other include files:
 *
 *    ELSEPRIV.H     Used to contain other useful info that need not be
 *                   in public interfaces.
 *
 *    <proj>.h       Public interface to a project, e.g. TMR.H
 *
 *    <proj>PRIV.H   Private interfaces for a project, e.g. TMRPRIV.H
 *
 *    <comp>.H       Component interfaces within a project, e.g. DM.H
 *
 *    <comp>PRIV.H   Component private interfaces.
 *
 * Copyright (C) 1992-93 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/

#ifndef __ELSETYPE_H__
#define __ELSETYPE_H__

/***************************************************************************
 * Keyword definitions.
 ***************************************************************************/


#if defined(__STDC__) || defined(WIN32)

/* Standard C, i.e. ANSI C
 */

#ifdef EW_FAR
#undef EW_FAR
#endif
#define EW_FAR

#ifdef EW_NEAR
#undef EW_NEAR
#endif
#define EW_NEAR

#ifdef EW_HUGE
#undef EW_HUGE
#endif
#define EW_HUGE

#ifdef EW_PASCAL
#undef EW_PASCAL
#endif
#ifdef WIN32
#define EW_PASCAL __stdcall
#else
#define EW_PASCAL
#endif /* WIN32 */

#ifdef EW_CDECL
#undef EW_CDECL
#endif
#define EW_CDECL

#else /* __STDC__ */

#ifndef EW_FAR
#define EW_FAR       __far
#endif

#ifndef EW_NEAR
#define EW_NEAR      __near
#endif

#ifndef EW_HUGE
#define EW_HUGE      __huge
#endif

#ifndef EW_PASCAL
#define EW_PASCAL    __pascal
#endif

#ifndef EW_CDECL
#define EW_CDECL     __cdecl
#endif

#endif /* __STDC__ */

#ifndef EXPORT
#define EXPORT       __export
#endif

#ifndef EW_VOID
#define EW_VOID      void
#endif

#ifndef GLOBAL
#define GLOBAL       extern
#endif

#ifndef LOCAL
#define LOCAL        static
#endif

#ifndef NULL
#define NULL         0L
#endif

#ifndef EW_NULL
#define EW_NULL      0L
#endif

#ifndef MAXLONG
#define MAXLONG      (0x7FFFFFFF)
#endif

#ifndef TRUE
#define TRUE         1
#endif

#ifndef FALSE
#define FALSE        0
#endif

#ifndef MAX
#define MAX(a, b) ( ((a) > (b)) ? (a) : (b) )
#endif

#ifndef MIN
#define MIN(a, b) ( ((a) < (b)) ? (a) : (b) )
#endif

#ifdef _NATIVE_IS_MOTOROLA /* native byte order matches Motorola 68000 */
   #ifndef SWAPL
      #define SWAPL(a)        (a)
   #endif
   #ifndef SWAPW
      #define SWAPW(a)        (a)
   #endif
   #ifndef SWAPWINC
      #define SWAPWINC(a)     (*(a)++)
   #endif
#else
 /* Portable code to extract a short or a long from a 2- or 4-byte buffer */
 /* which was encoded using Motorola 68000 (TrueType "native") byte order. */
   #define FS_2BYTE(p)  ( ((unsigned short)((p)[0]) << 8) |  (p)[1])
   #define FS_4BYTE(p)  ( FS_2BYTE((p)+2) | ( (FS_2BYTE(p)+0L) << 16) )

   #ifndef SWAPW
      #define SWAPW(a)        ((short) FS_2BYTE( (unsigned char EW_FAR*)(&(a)) ))
   #endif

   #ifndef SWAPL
      #define SWAPL(a)        ((long) FS_4BYTE( (unsigned char EW_FAR*)(&(a)) ))
   #endif

   #ifndef SWAPWINC
      #define SWAPWINC(a)     SWAPW(*(a)); a++  /* Do NOT parenthesize! */
   #endif


#endif

#ifndef FLIPW
   #define FLIPW(a)           ((short) FS_2BYTE( (unsigned char EW_FAR*)(&(a)) ))
#endif

#ifndef FLIPL
   #define FLIPL(a)           ((long) FS_4BYTE( (unsigned char EW_FAR*)(&(a)) ))
#endif

#ifndef ASW
   #define ASW(a,b)        (a = SWAPW((b)))
#endif

#ifndef ASL
   #define ASL(a,b)        (a = SWAPL((b)))
#endif

#ifndef ASWT
   extern short __nASWT;
   #define ASWT(a,b)       {__nASWT = (b); a = SWAPW(__nASWT);}
#endif

#ifndef ASLT
   extern long __lASLT;
   #define ASLT(a,b)       {__lASLT = (b); a = SWAPL(__lASLT);}
#endif


/***************************************************************************
 * ElseWare specific types.  These are unlikely to cause conflict.
 ***************************************************************************/

typedef int             EW_RC, EW_FAR* EW_LPRC;

/***************************************************************************
 * Common types.  Prepend with an "EW_" to avoid conflict.
 *
 * m means MOTOROLA order for multiple byte types
 *
 * Note that the types in, WORD, DWORD have been avoided.
 ***************************************************************************/

typedef EW_VOID                        EW_FAR* EW_LPVOID;    /*  v, lpv    */

typedef signed short     EW_SHORT,     EW_FAR* EW_LPSHORT;   /*  n,  lpn   */
typedef signed short     EW_mSHORT,    EW_FAR* EW_LPmSHORT;  /* mn,  lpmn  */

typedef unsigned short   EW_USHORT,    EW_FAR* EW_LPUSHORT;  /*  un, lpun  */
typedef unsigned short   EW_mUSHORT,   EW_FAR* EW_LPmUSHORT; /* mun, lpmun */

typedef signed long      EW_LONG,      EW_FAR* EW_LPLONG;    /*  l,  lpl   */
typedef signed long      EW_mLONG,     EW_FAR* EW_LPmLONG;   /* ul,  lpul  */

typedef unsigned long    EW_ULONG,     EW_FAR* EW_LPULONG;   /*  ul, lpul  */
typedef unsigned long    EW_mULONG,    EW_FAR* EW_LPmULONG;  /* mul, lpmul */

typedef signed char      EW_CHAR,      EW_FAR* EW_LPCHAR;    /* c,   lpc   */
typedef signed char                    EW_FAR* EW_LPSTR;     /*      lpsz  */
typedef unsigned char    EW_BYTE,      EW_FAR* EW_LPBYTE;    /* j,   lpj   */
typedef signed short     EW_BOOL,      EW_FAR* EW_LPBOOL;    /* b,   lpb   */

typedef signed short                  EW_HUGE* EW_HPSHORT;   /*      hpn   */
typedef signed short                  EW_HUGE* EW_HPmSHORT;  /*      hpmn  */
typedef unsigned short                EW_HUGE* EW_HPUSHORT;  /*      hpun  */
typedef unsigned short                EW_HUGE* EW_HPmUSHORT; /*      hpmun */
typedef signed long                   EW_HUGE* EW_HPLONG;    /*      hpl   */
typedef signed long                   EW_HUGE* EW_HPmLONG;   /*      hpml  */
typedef unsigned long                 EW_HUGE* EW_HPULONG;   /*      hpul  */
typedef unsigned long                 EW_HUGE* EW_HPmULONG;  /*      hpmul */
typedef signed char                   EW_HUGE* EW_HPCHAR;    /*      hpc   */
typedef signed char                   EW_HUGE* EW_HPSTR;     /*      hpsz  */
typedef unsigned char                 EW_HUGE* EW_HPBYTE;    /*      hpj   */

/*
 * other hungarian:
 *    sz    for zero terminated strings
 *    sp    for pascal strings
 *    a...  for arrays, except for arrays of char which are strings
 */

#ifdef __EW_TT_TYPES__
/*
 * Note: these typedefs do not follow the convention of all CAPS
 *       so that they more closely match the format used in the
 *       TrueType Spec 1.0.
 */
typedef unsigned long    EW_Fixed,     EW_FAR* EW_LPFixed;    /*  fi,  lpnfi  */
typedef unsigned long    EW_mFixed,    EW_FAR* EW_LPmFixed;   /* mfi,  lpmfi  */
typedef signed short     EW_FWord,     EW_FAR* EW_LPFWord;    /*  fw,  lpfw   */
typedef signed short     EW_mFWord,    EW_FAR* EW_LPmFWord;   /* mfw,  lpmfw  */
typedef unsigned short   EW_UFWord,    EW_FAR* EW_LPUFWord;   /* ufw,  lpufw  */
typedef unsigned short   EW_mUFWord,   EW_FAR* EW_LPmUFword;  /* mufw, lpmufw */

typedef signed short     EW_F2DOT14,   EW_FAR* EW_LPF2DOT14;  /* f2,   lpf2   */
typedef signed short     EW_mF2DOT14,  EW_FAR* EW_LPmF2DOT14; /* mf2,  lpmf2  */
typedef signed long      EW_F26DOT6,   EW_FAR* EW_LPF26DOT6;  /* f26,  lpf26  */
typedef signed long      EW_mF26DOT6,  EW_FAR* EW_LPmF26DOT6; /* mf26, lpmf26 */
typedef signed short     EW_F10DOT6,   EW_FAR* EW_LPF10DOT6;  /* f10,  lpf10  */
typedef signed short     EW_mF10DOT6,  EW_FAR* EW_LPmF10DOT6; /* mf10, lpmf10 */

typedef                  EW_Fixed      EW_HUGE* EW_HPFixed;   /*  fi,  lpnfi  */
typedef                  EW_mFixed     EW_HUGE* EW_HPmFixed;  /* mfi,  lpmfi  */
typedef                  EW_FWord      EW_HUGE* EW_HPFWord;   /*  fw,  lpfw   */
typedef                  EW_mFWord     EW_HUGE* EW_HPmFWord;  /* mfw,  lpmfw  */
typedef                  EW_UFWord     EW_HUGE* EW_HPUFWord;  /* ufw,  lpufw  */
typedef                  EW_mUFWord    EW_HUGE* EW_HPmUFword; /* mufw, lpmufw */

typedef                  EW_F2DOT14    EW_HUGE* EW_HPF2DOT14;  /* f2,   lpf2   */
typedef                  EW_mF2DOT14   EW_HUGE* EW_HPmF2DOT14; /* mf2,  lpmf2  */
typedef                  EW_F26DOT6    EW_HUGE* EW_HPF26DOT6;  /* f26,  lpf26  */
typedef                  EW_mF26DOT6   EW_HUGE* EW_HPmF26DOT6; /* mf26, lpmf26 */
typedef                  EW_F10DOT6    EW_HUGE* EW_HPF10DOT6;  /* f10,  lpf10  */
typedef                  EW_mF10DOT6   EW_HUGE* EW_HPmF10DOT6; /* mf10, lpmf10 */
#endif /* __EW_TT_TYPES__ */



typedef EW_LPBYTE (EW_NEAR EW_PASCAL *EW_NEAROPPTR)();
typedef EW_LPBYTE (EW_FAR  EW_PASCAL *EW_FAROPPTR )();
typedef EW_RC     (EW_FAR            *EW_FARFUNC)();
typedef EW_LPBYTE (EW_FAR            *EW_LPPTR);

/***************************************************************************
 * EW_PANOSE
 ***************************************************************************/

typedef struct tagEW_PANOSE
{
    EW_BYTE    jFamilyType;
    EW_BYTE    jSerifStyle;
    EW_BYTE    jWeight;
    EW_BYTE    jProportion;
    EW_BYTE    jContrast;
    EW_BYTE    jStrokeVariation;
    EW_BYTE    jArmStyle;
    EW_BYTE    jLetterform;
    EW_BYTE    jMidline;
    EW_BYTE    jXHeight;
} EW_PANOSE, EW_FAR* EW_LPPANOSE;


/***************************************************************************
 * EW_lseWare specific macros and constants.
 ***************************************************************************/


#endif /* __ELSETYPE_H__ */

/***************************************************************************
 * Revision log:
 ***************************************************************************/
/*
 * $lgb$
 * 1.0    22-Dec-92    cdm This is the official version.
 * 1.1    22-Dec-92    cdm Added LPBOOL.
 * 1.2    24-Dec-92    cdm Draft 2.
 * 1.3     6-Jan-93    cdm Fixed typo in EW_BOOL decl.
 * 1.4    27-Jan-93    emr Added EW_LPVOID
 * 1.5    30-Jan-93    msd Added EW_LPSTR.
 * 1.6    10-Feb-93    msd Added EW_ prefix to FAR, NEAR, HUGE, PASCAL, and CDECL.
 * 1.7    18-Feb-93    msd Bumped copyright notice.
 * 1.8    26-Feb-93    msd Added EW_PANOSE struct.
 * 1.9    21-Apr-93    emr Added EW_LPPTR. It's used by 318 and Pecos.
 * 1.10   21-Apr-93    emr Fixed MIN() macro.
 * 1.11   30-Apr-93    emr Some of the types in the TrueType section where being multiply defined. This was an error  on the Think C Macintosh compiler.
 * 1.12   19-Jul-93    pmh Latest engine5 elsetype.h.
 * 1.13    5-Oct-93   paul signed vars; FLIP macros
 * $lge$
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\ole2map\elsepan.h ===
/***************************************************************************
 * ELSEPAN.H - Base definitions for ElseWare PANOSE(tm) 1.0 Font Mapper.
 *
 * $keywords: elsepan.h 1.10 19-Jul-93 11:11:34 AM$
 *
 * Copyright (C) 1991-93 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/

#ifndef __ELSEPAN_H__
#define __ELSEPAN_H__

/***************************************************************************
 * ELSEUSER
 *
 * Rather than modify elsepan.h, put flags and additions in elseuser.h, or
 * disable inclusion of elseuser.h by placing "#define NOELSEUSER" ahead of
 * the #include for elsepan.h.
 ***************************************************************************/
#ifdef NOELSEUSER
#define __ELSEUSER_H__
#endif
#ifndef __ELSEUSER_H__
#include "elseuser.h"
#endif

/***************************************************************************
 * ELSETYPE
 *
 * Basic ElseWare types.
 ***************************************************************************/
#ifndef __ELSETYPE_H__
#include "elsetype.h"
#endif

/***************************************************************************
 * C++ SUPPORT
 *
 * If we are compiling with a C++ compiler, make these C-callable functions.
 ***************************************************************************/
#ifdef __cplusplus
extern "C" {
#endif

/***************************************************************************
 * COMPILER FLAG OVERRIDES
 *
 * If we are compiling one of the core ElseWare Font Mapper source files,
 * then override some flags.
 ***************************************************************************/
#ifdef ELSE_MAPPER_CORE
#undef NOELSEPANCONST
#define ELSEPENALTYDB
#endif

/***************************************************************************
 * PANOSE 1.0 PENALTIES DATABASE
 *
 * By default, this is declared as a static data object that stores
 * all the penalty tables in a variable called 's_panDB.' This is in
 * PAN1PTBL.H, which is generated by a stand-alone program in PAN1PTBL.C.
 *
 * Two sets of macros 'allocate' and 'lock' the database, which really
 * just return the pointer to the statically defined 's_panDB.'
 *
 * To override, the user should '#define NOELSEPANDATA' in ELSEUSER.H
 * and provide replacements for the allocate and lock routines. The file
 * PAN1PTBL.H should be used to generate the user-provided penalty database.
 ***************************************************************************/
#ifdef ELSE_MAPPER_CORE
#ifdef NOELSEPANDATA
#define __PAN1PTBL_H__
#endif
#ifndef __PAN1PTBL_H__
#include "pan1ptbl.h"
#define M_lAllocPAN1DATA() (1L)              /* returns data handle     */
#define M_bFreePAN1DATA(hData) (TRUE)        /* returns TRUE/FALSE      */
#define M_lLockPAN1DATA(hData) ((EW_LPPDICT_MEM)s_panDB) /* returns ptr */
#define M_bUnlockPAN1DATA(hData) (TRUE)      /* returns TRUE/FALSE      */
#endif
#endif

/***************************************************************************
 * COMPILATION FLAGS
 *
 * These flags control various aspects of compiling the font mapper.  You
 * turn these flags on by #defining them in elseuser.h.
 ***************************************************************************/

/* ELSEARGS macro
 *
 * Disable argument lists on prototypes by #defining NOELSEARGS.
 */
#ifdef ELSEARGS
#undef ELSEARGS
#endif
#ifndef NOELSEARGS
#define ELSEARGS(args) args
#else
#define ELSEARGS(args) ()
#endif

/* PAN_MATCH_ERROR
 *
 * This constant marks an error.
 */
#ifndef PAN_MATCH_ERROR
#define PAN_MATCH_ERROR 0xFFFF
#endif

/* ELSEMAXSHORT
 *
 * Maximum legal value for a SHORT.
 */
#ifndef ELSEMAXSHORT
#define ELSEMAXSHORT 0x7FFF
#endif

/* ELSEDEFTHRESHOLD
 *
 * Default value for the mapper threshold.
 */
#ifndef ELSEDEFTHRESHOLD
#define ELSEDEFTHRESHOLD 30
#endif

/* M_ELSELMUL
 *
 * a * b long math operation.
 */
#ifndef M_ELSELMUL
#define M_ELSELMUL(a, b) ((long)((long)(a) * (long)(b)))
#endif

/* M_ELSELDIV
 *
 * a / b long math operation.
 */
#ifndef M_ELSELDIV
#define M_ELSELDIV(a, b) ((long)((long)(a) / (long)(b)))
#endif

/* M_ELSEMULDIV
 *
 * (a * b) / c math operation.
 */
#ifndef M_ELSEMULDIV
#define M_ELSEMULDIV(a, b, c) \
   ((int)(M_ELSELDIV((M_ELSELMUL((a), (b)) + M_ELSELDIV((c), 2)), (c))))
#endif

/* M_ELSEMEMCPY
 *
 * memcpy(dst, src, len) operation.
 *
 * Defined in elsepan.c. Override it by defining a macro
 * for M_ELSEMEMCPY(dst, src, len).
 */

/***************************************************************************
 * PANOSE CONSTANTS
 *
 * These constants represent the individual values of the PANOSE digits.
 ***************************************************************************/
#define PANOSE_ANY             0
#define PANOSE_NOFIT           1
#define NUM_PAN_DIGITS         10
#define MAX_PAN1_FAMILY        127
#define MAX_PAN1_DIGIT         31
#define MAX_CUSTOM_WEIGHTS     8
#define SIZE_PAN1_NUM          (sizeof(EW_BYTE) * NUM_PAN_DIGITS)

#ifndef NOELSEPANCONST

/* Latin Text PANOSE values.
 */
#define FAMILY_LATTEXT             2
#define FAMILY_LATSCRIPT           3
#define FAMILY_LATDECORATIVE       4
#define FAMILY_LATPICTORIAL        5
#define FAMILY_KANJI3TEXTANDSCRIPT 6
#define FAMILY_KANJI3DECORATIVE    7
#define FAMILY_KANJI3SYMBOLS       8
#define FAMILY__LAST               8

#define SERIF_COVE             2
#define SERIF_OBTUSECOVE       3
#define SERIF_SQUARECOVE       4
#define SERIF_OBTSQUARECOVE    5
#define SERIF_SQUARE           6
#define SERIF_THIN             7
#define SERIF_BONE             8
#define SERIF_EXAGGERATED      9
#define SERIF_TRIANGLE         10
#define SERIF_NORMALSANS       11
#define SERIF_OBTUSESANS       12
#define SERIF_PERPSANS         13
#define SERIF_FLARED           14
#define SERIF_ROUNDED          15
#define SERIF__LAST            15

#define WEIGHT_VERYLIGHT       2
#define WEIGHT_LIGHT           3
#define WEIGHT_THIN            4
#define WEIGHT_BOOK            5
#define WEIGHT_MEDIUM          6
#define WEIGHT_DEMI            7
#define WEIGHT_BOLD            8
#define WEIGHT_HEAVY           9
#define WEIGHT_BLACK           10
#define WEIGHT_NORD            11
#define WEIGHT__LAST           11

#define PROPORTION_OLDSTYLE    2
#define PROPORTION_MODERN      3
#define PROPORTION_EVENWIDTH   4
#define PROPORTION_EXPANDED    5
#define PROPORTION_CONDENSED   6
#define PROPORTION_VERYEXP     7
#define PROPORTION_VERYCOND    8
#define PROPORTION_MONOSPACE   9
#define PROPORTION__LAST       9

#define CONTRAST_NONE          2
#define CONTRAST_VERYLOW       3
#define CONTRAST_LOW           4
#define CONTRAST_MEDIUMLOW     5
#define CONTRAST_MEDIUM        6
#define CONTRAST_MEDIUMHIGH    7
#define CONTRAST_HIGH          8
#define CONTRAST_VERYHIGH      9
#define CONTRAST__LAST         9

#define STROKE_NOVARIATION     2
#define STROKE_GRADDIAG        3
#define STROKE_GRADTRANS       4
#define STROKE_GRADVERT        5
#define STROKE_GRADHORZ        6
#define STROKE_RAPIDVERT       7
#define STROKE_RAPIDHORZ       8
#define STROKE_INSTANTVERT     9
#define STROKE__LAST           9

#define ARM_STRAIGHTHORZ       2
#define ARM_STRAIGHTWEDGE      3
#define ARM_STRAIGHTVERT       4
#define ARM_STRAIGHTSGLSERIF   5
#define ARM_STRAIGHTDBLSERIF   6
#define ARM_NONSTRTHORZ        7
#define ARM_NONSTRTWEDGE       8
#define ARM_NONSTRTVERT        9
#define ARM_NONSTRTSGLSERIF    10
#define ARM_NONSTRTDBLSERIF    11
#define ARM__LAST              11

#define LTRFORM_NORMCONTACT    2
#define LTRFORM_NORMWEIGHTED   3
#define LTRFORM_NORMBOXED      4
#define LTRFORM_NORMFLATTENED  5
#define LTRFORM_NORMROUNDED    6
#define LTRFORM_NORMOFFCENTER  7
#define LTRFORM_NORMSQUARE     8
#define LTRFORM_OBLQCONTACT    9
#define LTRFORM_OBLQWEIGHTED   10
#define LTRFORM_OBLQBOXED      11
#define LTRFORM_OBLQFLATTENED  12
#define LTRFORM_OBLQROUNDED    13
#define LTRFORM_OBLQOFFCENTER  14
#define LTRFORM_OBLQSQUARE     15
#define LTRFORM__LAST          15

#define MIDLINE_STDTRIMMED     2
#define MIDLINE_STDPOINTED     3
#define MIDLINE_STDSERIFED     4
#define MIDLINE_HIGHTRIMMED    5
#define MIDLINE_HIGHPOINTED    6
#define MIDLINE_HIGHSERIFED    7
#define MIDLINE_CONSTTRIMMED   8
#define MIDLINE_CONSTPOINTED   9
#define MIDLINE_CONSTSERIFED   10
#define MIDLINE_LOWTRIMMED     11
#define MIDLINE_LOWPOINTED     12
#define MIDLINE_LOWSERIFED     13
#define MIDLINE__LAST          13

#define XHEIGHT_CONSTSMALL     2
#define XHEIGHT_CONSTSTD       3
#define XHEIGHT_CONSTLARGE     4
#define XHEIGHT_DUCKSMALL      5
#define XHEIGHT_DUCKSTD        6
#define XHEIGHT_DUCKLARGE      7
#define XHEIGHT__LAST          7

/* Latin Script PANOSE values.
 */
#ifndef NOELSEPANSCRIPT

#define STOOL_FLATNIB          2
#define STOOL_PRESSUREPT       3
#define STOOL_ENGRAVED         4
#define STOOL_BALL             5
#define STOOL_BRUSH            6
#define STOOL_ROUGH            7
#define STOOL_FELTPEN          8
#define STOOL_WILDBRUSH        9
#define STOOL__LAST            9

#define STOP_ROMDISCONNECT     2
#define STOP_ROMTRAIL          3
#define STOP_ROMCONNNECT       4
#define STOP_CURDISCONNECT     5
#define STOP_CURTRAIL          6
#define STOP_CURCONNECT        7
#define STOP_BLACKDISCONNECT   8
#define STOP_BLACKTRAIL        9
#define STOP_BLACKCONNECT      10
#define STOP__LAST             10

#define SFORM_UPNOWRAP         2
#define SFORM_UPSOMEWRAP       3
#define SFORM_UPMOREWRAP       4
#define SFORM_UPEXCESSWRAP     5
#define SFORM_OBNOWRAP         6
#define SFORM_OBSOMEWRAP       7
#define SFORM_OBMOREWRAP       8
#define SFORM_OBEXCESSWRAP     9
#define SFORM_EXNOWRAP         10
#define SFORM_EXSOMEWRAP       11
#define SFORM_EXMOREWRAP       12
#define SFORM_EXEXCESSWRAP     13
#define SFORM__LAST            13

#define SFINIAL_NONENOLOOP     2
#define SFINIAL_NONECLOSELOOP  3
#define SFINIAL_NONEOPENLOOP   4
#define SFINIAL_SHARPNOLOOP    5
#define SFINIAL_SHARPCLOSELOOP 6
#define SFINIAL_SHARPOPENLOOP  7
#define SFINIAL_TAPERNOLOOP    8
#define SFINIAL_TAPERCLOSELOOP 9
#define SFINIAL_TAPEROPENLOOP  10
#define SFINIAL_ROUNDNOLOOP    11
#define SFINIAL_ROUNDCLOSELOOP 12
#define SFINIAL_ROUNDOPENLOOP  13
#define SFINIAL__LAST          13

#define SXASCENT_VERYLOWDIF    2
#define SXASCENT_LOWDIF        3
#define SXASCENT_MEDIUMDIF     4
#define SXASCENT_HIGHDIF       5
#define SXASCENT_VERYHIGHDIF   6
#define SXASCENT__LAST         6

#endif  /* ifndef NOELSEPANSCRIPT */

/* Kanji PANOSE values.
 */
#ifndef NOELSEPANKANJI

#define KSTROKE_TRADBRUSH      2
#define KSTROKE_VIGBRUSH       3
#define KSTROKE_DRYBRUSH       4
#define KSTROKE_FLATNIBPEN     5
#define KSTROKE_SQUARE         6
#define KSTROKE_OBTSQUARE      7
#define KSTROKE_ROUND          8
#define KSTROKE_TAPERED        9
#define KSTROKE_MECHBRUSH      10
#define KSTROKE_STACCATO       11
#define KSTROKE_VOLATE         12
#define KSTROKE__LAST          12

#define KCELL_NORMNOSLANT      2
#define KCELL_NORMSLANTED      3
#define KCELL_WIDENOSLANT      4
#define KCELL_WIDESLANTED      5
#define KCELL_TALLNOSLANT      6
#define KCELL_TALLSLANTED      7
#define KCELL_XTRAWIDENOSLANT  8
#define KCELL_XTRAWIDESLANTED  9
#define KCELL_XTRATALLNOSLANT  10
#define KCELL_XTRATALLSLANTED  11
#define KCELL__LAST            11

#define KSSTROKE_ZOT           2
#define KSSTROKE_LONGZOT       3
#define KSSTROKE_FATZOT        4
#define KSSTROKE_HOOKEDZOT     5
#define KSSTROKE_SHORTRECT     6
#define KSSTROKE_LONGRECT      7
#define KSSTROKE_TAPEREDRECT   8
#define KSSTROKE_SPIKE         9
#define KSSTROKE_ROUNDED       10
#define KSSTROKE_EXAGGERATED   11
#define KSSTROKE_ROUGH         12
#define KSSTROKE__LAST         12

#define KTOP_STDNOSQUARE       2
#define KTOP_MODNOSQUARE       3
#define KTOP_STRONGNOSQUARE    4
#define KTOP_WILDNOSQUARE      5
#define KTOP_STDSQUARE         6
#define KTOP_MODSQUARE         7
#define KTOP_STRONGSQUARE      8
#define KTOP_WILDSQUARE        9
#define KTOP__LAST             9

#define KSTYLESIM_FULL         2
#define KSTYLESIM_COMPLEMENT   3
#define KSTYLESIM_SIMILAR      4
#define KSTYLESIM_DIFFERENT    5
#define KSTYLESIM_DISPARATE    6
#define KSTYLESIM__LAST        6

#define KSTROKEVAR_FULL        2
#define KSTROKEVAR_MODERATE    3
#define KSTROKEVAR_LOW         4
#define KSTROKEVAR_NONE        5
#define KSTROKEVAR__LAST       5

#endif  /* ifndef NOELSEPANKANJI */
#endif  /* ifndef NOELSEPANCONST */

/***************************************************************************
 * LATIN TEXT PANOSE INDICES
 *
 * Indices into an array containing the standard 10-digit PANOSE number.
 ***************************************************************************/
#define PAN_IND_FAMILY         0
#define PAN_IND_SERIF          1
#define PAN_IND_WEIGHT         2
#define PAN_IND_PROPORTION     3
#define PAN_IND_CONTRAST       4
#define PAN_IND_STROKE         5
#define PAN_IND_ARMSTYLE       6
#define PAN_IND_LTRFORM        7
#define PAN_IND_MIDLINE        8
#define PAN_IND_XHEIGHT        9
#define PAN_IND__LAST          9

/***************************************************************************
 * LATIN SCRIPT PANOSE INDICES
 *
 * Indices into an array containing the Latin Script 10-digit PANOSE number.
 ***************************************************************************/
#ifndef NOELSEPANSCRIPT
/* define PAN_IND_FAMILY       0 */
#define SPAN_IND_STOOL         1
#define SPAN_IND_WEIGHT        2
#define SPAN_IND_MONOSPC       3
#define SPAN_IND_ASPECT        4
#define SPAN_IND_CONTRAST      5
#define SPAN_IND_STOP          6
#define SPAN_IND_SFORM         7
#define SPAN_IND_SFINIAL       8
#define SPAN_IND_SXASCENT      9
#define SPAN_IND__LAST         9 
#endif  /* ifndef NOELSEPANSCRIPT */

/***************************************************************************
 * KANJI PANOSE INDICES
 *
 * Indices into an array containing the Kanji 10-digit PANOSE number.
 ***************************************************************************/
#ifndef NOELSEPANKANJI
/* define PAN_IND_FAMILY       0 */
#define KPAN_IND_KSTROKE       1
#define KPAN_IND_WEIGHT        2
#define KPAN_IND_KCELL         3
#define KPAN_IND_MONOSPC       4
#define KPAN_IND_CONTRAST      5
#define KPAN_IND_KSSTROKE      6
#define KPAN_IND_KTOP          7
#define KPAN_IND_KSTYLESIM     8
#define KPAN_IND_KSTROKEVAR    9
#define KPAN_IND__LAST         9
#endif  /* ifndef NOELSEPANKANJI */

/***************************************************************************
 * KANJI-TO-LATIN WEIGHT INDICES
 *
 * Indices into the weights array for the Kanji-to-Latin cross-class
 * penalty database.
 ***************************************************************************/
#ifndef NOELSEPANKANJI
/* define PAN_IND_FAMILY       0 */
#define PAN_IND_WT_KLSTROKETOSERIF 1
#define PAN_IND_WT_KLWEIGHT        2
#define PAN_IND_WT_KLCELLTOPROP    3
#define PAN_IND_WT_KLCELLTOLTRFORM 4
#define PAN_IND_WT_KLMONOTOPROP    5
#define PAN_IND_WT_KLCONTRAST      6
#define PAN_IND_WT_KLTOPTOLTRFORM  7
#endif  /* ifndef NOELSEPANKANJI */

/***************************************************************************
 * PANOSE_PENALTY_VERS
 *
 * Database format version number.
 *
 * 0x0100 - Original implementation.
 * 0x0101 - Modified the compression formats in which the tables are stored,
 *          and added a flat table format (zero compression).
 * 0x0110 - PANOSE version 1.0 penalties, previous versions were
 *          "Expanded PANOSE" penalties. Added C3 compression.
 * 0x0111 - Added byte ordering check, and C4 compression. Also the penalty
 *          table builder will make identical ptbls point to the same data
 *          to further compress the database.
 ***************************************************************************/
#define PANOSE_PENALTY_VERS    0x0111

/***************************************************************************
 * PANOSE PENALTY TABLE data structures
 *
 * The following structures are fused together into one big block.  See
 * the sample code in PAN1PTBL.C (provided with the ElseWare Font Mapper
 * source code) for an example of how to build this structure.
 ***************************************************************************/
#ifdef ELSEPENALTYDB

#define PAN_COMPRESS_C0        0
#define PAN_COMPRESS_C1        1
#define PAN_COMPRESS_C2        2
#define PAN_COMPRESS_C3        3
#define PAN_COMPRESS_C4        4
#define PAN_COMPRESS__LAST     4

/* Byte ordering test: the unByteOrder field of the header is
 * tested to make sure it matches this value -- if the bytes
 * are swapped, the test will fail.
 */
#define PTBL_BYTE_ORDER        0x1234

/* C0 compression == full table provided.  The first two bytes
 * of the table contain its dimensions.  When the need exists
 * to specify the whole table it is usually because it is a
 * non-square, non-symmetrical table.
 */
typedef struct _tagEW_PTBL_C0_MEM {
   EW_BYTE jARangeLast;        /* highest possible A value (table width) */
   EW_BYTE jBRangeLast;        /* highest possible B value (table depth) */
   EW_BYTE jReserved;          /* reserved, should be zero */
   EW_BYTE jPenalties[1];      /* penalty table */
} EW_PTBL_C0_MEM, EW_FAR *EW_LPPTBL_C0_MEM;

/* C1 compression == smooth penalty range symetrical about the
 * diagonal where closest to diagonal == 1 and each increment
 * away from the diagonal == increment penalty by one.  NO table
 * is provided, and the any, no-fit, and match penalties take
 * on the defaults listed in the index entry for the dictionary.
 * The variables ulOffsTbl and unTblSize in the range record
 * should be zero.
 */

/* C2 penalties symmetrical around the diagonal but without
 * a smooth range, lower left half specified.  There is no special
 * record needed: it is an array of bytes where any, no-fit, and
 * match penalties are taken from the header.
 */

/* C3 penalties are identical to C2 except the very first byte
 * is the no-fit penalty value: any and match penalties are taken
 * from the header.
 */

/* C4 penalties are similar to C1: symmetric around the diagonal,
 * increasing in uniform increments the further from the diagonal.
 * The difference is it doesn't start at 1 and/or doesn't increment
 * by 1. The start and increment values are provided.
 */
typedef struct _tagEW_PTBL_C4_MEM {
   EW_BYTE jStart;             /* lowest value in table */
   EW_BYTE jIncrement;         /* increment away from the diagonal */
} EW_PTBL_C4_MEM, EW_FAR *EW_LPPTBL_C4_MEM;

/* Penalty table record, which describes the format of the penalty
 * table and contains its offset and size.  There is an array of
 * 9 of these at the offset unOffsPTbl stored in the index record
 * (there is no penalty table for the family digit). In the case of
 * cross-family mapping, there are unNumAtoB records (instead of 9).
 */
typedef struct _tagEW_PTBL_MEM {
   EW_BYTE jRangeLast;         /* highest possible PANOSE digit value */
   EW_BYTE jCompress;          /* type of compression */
   EW_USHORT unOffsTbl;        /* byte offset to penalty table */
   EW_USHORT unTblSize;        /* # bytes in penalty table */
} EW_PTBL_MEM, EW_FAR *EW_LPPTBL_MEM;

/* The A to B array maps PANOSE digits from one classification to
 * those in another (this happens when the two Family digits are
 * not equal).
 */
typedef struct _tagEW_ATOB_ITEM_MEM {
   EW_BYTE jAttrA;             /* PANOSE number index from family A */
   EW_BYTE jAttrB;             /* related PANOSE number ind from family B */
} EW_ATOB_ITEM_MEM, EW_FAR *EW_LPATOB_ITEM_MEM;

typedef struct _tagEW_ATOB_MEM {
   EW_USHORT unNumAtoB;        /* count of array items */
   EW_ATOB_ITEM_MEM AtoBItem[1]; /* remapping array (variable length) */
} EW_ATOB_MEM, EW_FAR *EW_LPATOB_MEM;

/* Mapper weights are stored in an array of 10 1-byte values.
 * We include a weight for the family digit even though it is
 * ignored by the mapper (it is included so the weights array
 * is parrallel to the PANOSE digits array, allowing the same
 * constants to be used to access both arrays). In cross-family
 * mappings there are still 10 weights, and the unused ones are
 * set to zero.
 */

/* Penalty index record.  Each record contains information for a
 * penalty database, which contains all the penalty tables for one
 * given family pair.
 */
typedef struct _tagEW_PIND_MEM {
   EW_BYTE jFamilyA;           /* family pair for which penalties apply */
   EW_BYTE jFamilyB;           /* ditto */
   EW_BYTE jDefAnyPenalty;     /* default penalty value for 'any' match */
   EW_BYTE jDefNoFitPenalty;   /* default penalty value for 'no fit' match */
   EW_BYTE jDefMatchPenalty;   /* default penalty value for exact match */
   EW_BYTE jReserved;          /* to keep the record word-aligned */
   EW_USHORT unOffsWts;        /* byte offs to mapper weights */
   EW_USHORT unOffsAtoB;       /* byte offs to array relates family A to B */
   EW_USHORT unOffsPTbl;       /* byte offs to penalty tables */
} EW_PIND_MEM, EW_FAR *EW_LPPIND_MEM;

/* Penalty dictionary header.  This is the header to the entire
 * structure.  Its last item is a variable length array of index
 * records.  Each index record points to a penalty database.
 */
typedef struct _tagEW_PDICT_MEM {
   EW_USHORT unVersion;        /* version # of this structure */
   EW_USHORT unByteOrder;      /* byte ordering flag */
   EW_USHORT unNumDicts;       /* number of entries in PANOSE_PINDEX array */
   EW_USHORT unSizeDB;         /* count in bytes of the whole database */
   EW_PIND_MEM pind[1];        /* array of EW_PIND recs (variable len) */
} EW_PDICT_MEM, EW_FAR *EW_LPPDICT_MEM;

#endif  /* ifdef ELSEPENALTYDB */

/***************************************************************************
 * MAP STATE structure
 *
 * This data structure stores the state variables used by the mapper.
 * It is passed into almost all the mapper routines.
 ***************************************************************************/
typedef struct _tagEW_MAPSTATE {
   EW_ULONG ulSanity;
   EW_USHORT unThreshold;
   EW_USHORT unRelaxThresholdCount;
   EW_ULONG ulhPan1Data;
   EW_BOOL bUseDef;
   EW_BYTE ajPanDef[NUM_PAN_DIGITS];
#ifndef NOELSEWEIGHTS
   EW_BYTE ajWtRefA[MAX_CUSTOM_WEIGHTS];
   EW_BYTE ajWtRefB[MAX_CUSTOM_WEIGHTS];
   EW_BYTE ajCustomWt[SIZE_PAN1_NUM * MAX_CUSTOM_WEIGHTS];
#endif
} EW_MAPSTATE, EW_FAR *EW_LPMAPSTATE;

/***************************************************************************
 * ELSEPAN.C: Core PANOSE 1.0 font mapping routines.
 ***************************************************************************/

GLOBAL EW_SHORT EW_FAR EW_PASCAL nPANMapInit
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_USHORT unSizeMapState ));

GLOBAL EW_BOOL EW_FAR EW_PASCAL bPANMapClose
   ELSEARGS (( EW_LPMAPSTATE lpMapState ));

GLOBAL EW_USHORT EW_FAR EW_PASCAL unPANMatchFonts
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_LPBYTE lpPanWant,
      EW_ULONG ulSizeWant, EW_LPBYTE lpPanThis, EW_ULONG ulSizeThis,
      EW_BYTE jMapToFamily ));

GLOBAL EW_VOID EW_FAR EW_PASCAL vPANMakeDummy
   ELSEARGS (( EW_LPBYTE lpPanThis, EW_USHORT unSize ));


#ifndef NOELSEPICKFONTS

GLOBAL EW_SHORT EW_FAR EW_PASCAL nPANGetMapDefault
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_LPBYTE lpPanDef,
      EW_USHORT unSizePanDef ));

GLOBAL EW_SHORT EW_FAR EW_PASCAL nPANSetMapDefault
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_LPBYTE lpPanDef,
      EW_USHORT unSizePanDef ));

GLOBAL EW_BOOL EW_FAR EW_PASCAL bPANEnableMapDefault
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_BOOL bEnable ));

GLOBAL EW_BOOL EW_FAR EW_PASCAL bPANIsDefaultEnabled
   ELSEARGS (( EW_LPMAPSTATE lpMapState ));

GLOBAL EW_USHORT EW_FAR EW_PASCAL unPANPickFonts
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_LPUSHORT lpIndsBest,
      EW_LPUSHORT lpMatchValues, EW_LPBYTE lpPanWant,
      EW_USHORT unNumInds, EW_LPBYTE lpPanFirst, EW_USHORT unNumAvail,
      EW_SHORT nRecSize, EW_BYTE jMapToFamily ));

#endif /* ifndef NOELSEPICKFONTS */


#ifndef NOELSETHRESHOLD

GLOBAL EW_USHORT EW_FAR EW_PASCAL unPANGetMapThreshold
   ELSEARGS (( EW_LPMAPSTATE lpMapState ));

GLOBAL EW_BOOL EW_FAR EW_PASCAL bPANSetMapThreshold
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_USHORT unThreshold ));

GLOBAL EW_BOOL EW_FAR EW_PASCAL bPANIsThresholdRelaxed
   ELSEARGS (( EW_LPMAPSTATE lpMapState ));

GLOBAL EW_VOID EW_FAR EW_PASCAL vPANRelaxThreshold
   ELSEARGS (( EW_LPMAPSTATE lpMapState ));

GLOBAL EW_BOOL EW_FAR EW_PASCAL bPANRestoreThreshold
   ELSEARGS (( EW_LPMAPSTATE lpMapState ));

#endif /* ifndef NOELSETHRESHOLD */


#ifndef NOELSEWEIGHTS

GLOBAL EW_BOOL EW_FAR EW_PASCAL bPANGetMapWeights
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_BYTE jFamilyA,
      EW_BYTE jFamilyB, EW_LPBYTE lpjWts, EW_LPBOOL lpbIsCustom ));

GLOBAL EW_BOOL EW_FAR EW_PASCAL bPANSetMapWeights
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_BYTE jFamilyA,
      EW_BYTE jFamilyB, EW_LPBYTE lpjWts ));

GLOBAL EW_BOOL EW_FAR EW_PASCAL bPANClearMapWeights
   ELSEARGS (( EW_LPMAPSTATE lpMapState, EW_BYTE jFamilyA,
      EW_BYTE jFamilyB ));

#endif /* ifndef NOELSEWEIGHTS */


#ifdef __cplusplus
}
#endif

#endif /* ifndef __ELSEPAN_H__ */

/***************************************************************************
 * Revision log:
 ***************************************************************************/
/*
 * $lgb$
 * 1.0    31-Jan-93    msd PANOSE 1.0 mapper: 10-digit PANOSE.
 * 1.1     2-Feb-93    msd Removed huge pointer stuff.
 * 1.2     2-Feb-93    msd 
 * 1.3     3-Feb-93    msd Removed ctrl-Z at EOF.
 * 1.4     3-Feb-93    msd Fixed bug caused by vcs check-in.
 * 1.5     6-Feb-93    msd Word-aligned C0 penalty header.
 * 1.6    15-Feb-93    msd For extra security, bumped the sanity value from word to a long.
 * 1.7    18-Feb-93    msd Added support for C++ compilers.
 * 1.8    18-Feb-93    msd Added penalty table byte-ordering check, and C4 ptbl compression (new version of ptbl). Use EW_FAR.
 * 1.9    27-Apr-93    msd Added MAX_PAN1_DIGIT.
 * 1.10   19-Jul-93    msd Added compilation flags to selectively disable mapper routines.
 * $lge$
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\ole2map\pan1ptbl.h ===
/***************************************************************************
 * PAN1PTBL.H - ElseWare PANOSE(tm) default penalty tables.
 *
 * This file was generated by PAN1PTBL.EXE.
 *
 * This file contains the penalty tables for the PANOSE 1.0 font
 * mapper. It was generated from the file PAN1PTBL.TXT.
 *
 * Penalty database structure version 1.11.
 *
 * File created Mon Sep 26 10:13:46 1994.
 *
 * Copyright (C) 1992-93 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/

#ifndef __PAN1PTBL_H__
#define __PAN1PTBL_H__

/***************************************************************************
 * PENALTY DATABASE
 *
 * Below is the default penalty database for the PANOSE font
 * mapper.  It is in the MEMORY format.
 *
 * Look at PAN1PTBL.C to see how this is created.
 ***************************************************************************/
EW_BYTE s_panDB[] = {
   0x11, 0x01, 0x34, 0x12, 0x06, 0x00, 0x46, 0x09, 0x02, 0x02,
   0x00, 0x0a, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x5a, 0x00,
   0x06, 0x06, 0x00, 0x0a, 0x00, 0x00, 0x29, 0x02, 0x00, 0x00,
   0x33, 0x02, 0x06, 0x02, 0x00, 0x0a, 0x00, 0x00, 0x27, 0x03,
   0x31, 0x03, 0x41, 0x03, 0x03, 0x03, 0x00, 0x0a, 0x00, 0x00,
   0x70, 0x05, 0x00, 0x00, 0x7a, 0x05, 0x04, 0x04, 0x00, 0x0a,
   0x00, 0x00, 0xc8, 0x06, 0x00, 0x00, 0xd2, 0x06, 0x05, 0x05,
   0x00, 0x0a, 0x00, 0x00, 0x8b, 0x08, 0x00, 0x00, 0x95, 0x08,
   0x00, 0x07, 0x08, 0x09, 0x05, 0x02, 0x02, 0x06, 0x02, 0x01,
   0x0f, 0x02, 0x90, 0x00, 0x5b, 0x00, 0x0b, 0x02, 0xeb, 0x00,
   0x2d, 0x00, 0x09, 0x02, 0x18, 0x01, 0x1c, 0x00, 0x09, 0x01,
   0x00, 0x00, 0x00, 0x00, 0x09, 0x02, 0x34, 0x01, 0x1c, 0x00,
   0x0b, 0x02, 0x50, 0x01, 0x2d, 0x00, 0x0f, 0x02, 0x7d, 0x01,
   0x5b, 0x00, 0x0d, 0x02, 0xd8, 0x01, 0x42, 0x00, 0x07, 0x02,
   0x1a, 0x02, 0x0f, 0x00, 0x01, 0x03, 0x04, 0x04, 0x03, 0x01,
   0x06, 0x06, 0x02, 0x03, 0x05, 0x05, 0x03, 0x03, 0x02, 0x07,
   0x07, 0x05, 0x05, 0x06, 0x06, 0x07, 0x07, 0x06, 0x06, 0x07,
   0x08, 0x02, 0x03, 0x03, 0x05, 0x05, 0x06, 0x05, 0x05, 0x04,
   0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 0x09, 0x09, 0x09, 0x09,
   0x09, 0x09, 0x09, 0x09, 0x08, 0x09, 0x09, 0x09, 0x01, 0x09,
   0x09, 0x09, 0x09, 0x09, 0x08, 0x09, 0x09, 0x09, 0x02, 0x01,
   0x06, 0x06, 0x07, 0x07, 0x08, 0x07, 0x09, 0x09, 0x06, 0x04,
   0x04, 0x05, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
   0x0a, 0x07, 0x07, 0x07, 0x08, 0x01, 0x02, 0x01, 0x03, 0x02,
   0x01, 0x04, 0x03, 0x02, 0x01, 0x06, 0x05, 0x04, 0x03, 0x02,
   0x07, 0x06, 0x05, 0x04, 0x03, 0x01, 0x08, 0x07, 0x06, 0x05,
   0x04, 0x02, 0x01, 0x09, 0x08, 0x07, 0x06, 0x05, 0x03, 0x02,
   0x01, 0x0a, 0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x02, 0x01,
   0x02, 0x03, 0x02, 0x06, 0x06, 0x04, 0x05, 0x05, 0x05, 0x08,
   0x08, 0x08, 0x07, 0x03, 0x08, 0x07, 0x07, 0x08, 0x0a, 0x03,
   0x0c, 0x0c, 0x0c, 0x0a, 0x0c, 0x0a, 0x0c, 0x0c, 0x03, 0x04,
   0x02, 0x05, 0x03, 0x01, 0x08, 0x09, 0x09, 0x09, 0x07, 0x04,
   0x04, 0x03, 0x07, 0x08, 0x09, 0x09, 0x09, 0x02, 0x08, 0x09,
   0x08, 0x06, 0x06, 0x08, 0x06, 0x0a, 0x02, 0x04, 0x02, 0x06,
   0x06, 0x06, 0x06, 0x06, 0x06, 0x02, 0x07, 0x08, 0x08, 0x08,
   0x08, 0x08, 0x07, 0x08, 0x08, 0x08, 0x02, 0x08, 0x08, 0x07,
   0x08, 0x08, 0x04, 0x02, 0x09, 0x09, 0x09, 0x05, 0x06, 0x08,
   0x08, 0x08, 0x09, 0x09, 0x09, 0x06, 0x05, 0x08, 0x08, 0x08,
   0x03, 0x02, 0x02, 0x02, 0x03, 0x02, 0x02, 0x03, 0x03, 0x03,
   0x02, 0x05, 0x05, 0x05, 0x06, 0x07, 0x06, 0x06, 0x04, 0x04,
   0x04, 0x06, 0x08, 0x0a, 0x0a, 0x0b, 0x0c, 0x0c, 0x0e, 0x0a,
   0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0e, 0x02, 0x0a, 0x09, 0x08,
   0x09, 0x0a, 0x0b, 0x0d, 0x02, 0x02, 0x0b, 0x09, 0x09, 0x08,
   0x09, 0x0a, 0x0c, 0x03, 0x02, 0x02, 0x0b, 0x0a, 0x0a, 0x09,
   0x08, 0x09, 0x0c, 0x03, 0x03, 0x03, 0x02, 0x0d, 0x0c, 0x0c,
   0x0b, 0x0c, 0x08, 0x0c, 0x05, 0x05, 0x05, 0x06, 0x07, 0x0e,
   0x0e, 0x0c, 0x0a, 0x09, 0x0a, 0x08, 0x06, 0x06, 0x04, 0x04,
   0x04, 0x06, 0x02, 0x04, 0x04, 0x06, 0x05, 0x06, 0x06, 0x04,
   0x06, 0x02, 0x06, 0x06, 0x05, 0x04, 0x04, 0x05, 0x05, 0x05,
   0x03, 0x05, 0x06, 0x05, 0x05, 0x05, 0x04, 0x03, 0x07, 0x03,
   0x05, 0x05, 0x04, 0x05, 0x06, 0x05, 0x02, 0x04, 0x06, 0x07,
   0x07, 0x07, 0x08, 0x08, 0x04, 0x03, 0x03, 0x06, 0x06, 0x07,
   0x08, 0x07, 0x08, 0x06, 0x03, 0x04, 0x04, 0x06, 0x07, 0x06,
   0x08, 0x08, 0x07, 0x05, 0x05, 0x02, 0x03, 0x04, 0x02, 0x04,
   0x02, 0x08, 0x06, 0x0c, 0x0a, 0x08, 0x0a, 0x02, 0x0c, 0x0a,
   0x08, 0x04, 0x02, 0x00, 0x09, 0x08, 0x05, 0x07, 0x05, 0x04,
   0x04, 0x05, 0x04, 0x0c, 0x02, 0x69, 0x02, 0x37, 0x00, 0x0b,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x03, 0xa0, 0x02, 0x2e,
   0x00, 0x03, 0x02, 0xce, 0x02, 0x01, 0x00, 0x09, 0x01, 0x00,
   0x00, 0x00, 0x00, 0x0c, 0x02, 0xcf, 0x02, 0x37, 0x00, 0x09,
   0x03, 0x06, 0x03, 0x1d, 0x00, 0x06, 0x04, 0x23, 0x03, 0x02,
   0x00, 0x05, 0x04, 0x25, 0x03, 0x02, 0x00, 0x03, 0x04, 0x04,
   0x07, 0x07, 0x06, 0x08, 0x08, 0x08, 0x04, 0x08, 0x08, 0x08,
   0x05, 0x03, 0x06, 0x06, 0x06, 0x06, 0x05, 0x04, 0x05, 0x05,
   0x05, 0x03, 0x06, 0x05, 0x04, 0x02, 0x03, 0x04, 0x03, 0x08,
   0x07, 0x05, 0x04, 0x04, 0x02, 0x03, 0x04, 0x08, 0x07, 0x08,
   0x06, 0x03, 0x05, 0x04, 0x04, 0x05, 0x08, 0x07, 0x08, 0x08,
   0x05, 0x02, 0x14, 0x04, 0x01, 0x05, 0x05, 0x01, 0x04, 0x01,
   0x05, 0x02, 0x06, 0x05, 0x01, 0x06, 0x02, 0x04, 0x02, 0x06,
   0x01, 0x05, 0x03, 0x07, 0x06, 0x02, 0x05, 0x01, 0x07, 0x03,
   0x04, 0x02, 0x06, 0x03, 0x07, 0x01, 0x05, 0x04, 0x08, 0x06,
   0x02, 0x07, 0x03, 0x05, 0x01, 0x08, 0x04, 0x04, 0x08, 0x02,
   0x03, 0x01, 0x05, 0x04, 0x04, 0x08, 0x07, 0x06, 0x08, 0x08,
   0x07, 0x08, 0x07, 0x02, 0x08, 0x06, 0x07, 0x06, 0x04, 0x03,
   0x07, 0x06, 0x07, 0x04, 0x07, 0x06, 0x04, 0x04, 0x04, 0x04,
   0x06, 0x05, 0x06, 0x07, 0x08, 0x07, 0x07, 0x06, 0x03, 0x08,
   0x08, 0x06, 0x04, 0x07, 0x09, 0x09, 0x08, 0x06, 0x09, 0x09,
   0x08, 0x06, 0x08, 0x05, 0x14, 0x02, 0x04, 0x02, 0x06, 0x04,
   0x02, 0x03, 0x05, 0x07, 0x09, 0x05, 0x03, 0x05, 0x07, 0x02,
   0x07, 0x05, 0x03, 0x05, 0x04, 0x02, 0x09, 0x07, 0x05, 0x03,
   0x06, 0x04, 0x02, 0x02, 0x02, 0x03, 0x03, 0x00, 0x09, 0x08,
   0x06, 0x04, 0x04, 0x05, 0x04, 0x00, 0x00, 0x07, 0x00, 0x01,
   0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x07, 0x04, 0x03, 0x05,
   0x04, 0x07, 0x07, 0x0f, 0x00, 0x6b, 0x03, 0x9d, 0x00, 0x0b,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x08, 0x04, 0x53,
   0x00, 0x0f, 0x00, 0x5b, 0x04, 0x8f, 0x00, 0x09, 0x00, 0xea,
   0x04, 0x13, 0x00, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0f,
   0x00, 0xfd, 0x04, 0x73, 0x00, 0x0c, 0x0f, 0x00, 0x02, 0x02,
   0x03, 0x03, 0x05, 0x04, 0x06, 0x04, 0x05, 0x07, 0x07, 0x07,
   0x03, 0x07, 0x03, 0x03, 0x04, 0x04, 0x06, 0x05, 0x07, 0x03,
   0x06, 0x08, 0x08, 0x08, 0x06, 0x08, 0x04, 0x04, 0x05, 0x05,
   0x08, 0x07, 0x08, 0x04, 0x07, 0x08, 0x07, 0x07, 0x08, 0x09,
   0x03, 0x03, 0x04, 0x04, 0x04, 0x03, 0x08, 0x05, 0x05, 0x07,
   0x07, 0x07, 0x05, 0x07, 0x05, 0x06, 0x04, 0x05, 0x02, 0x04,
   0x06, 0x07, 0x04, 0x02, 0x03, 0x03, 0x04, 0x06, 0x06, 0x05,
   0x05, 0x04, 0x03, 0x05, 0x07, 0x08, 0x04, 0x03, 0x02, 0x02,
   0x04, 0x06, 0x07, 0x07, 0x08, 0x08, 0x05, 0x07, 0x05, 0x07,
   0x07, 0x04, 0x05, 0x05, 0x07, 0x02, 0x08, 0x08, 0x08, 0x08,
   0x06, 0x06, 0x08, 0x06, 0x03, 0x04, 0x05, 0x05, 0x06, 0x05,
   0x01, 0x01, 0x02, 0x02, 0x04, 0x05, 0x07, 0x04, 0x04, 0x07,
   0x07, 0x07, 0x04, 0x07, 0x04, 0x04, 0x04, 0x04, 0x07, 0x07,
   0x08, 0x03, 0x04, 0x08, 0x08, 0x08, 0x07, 0x08, 0x08, 0x08,
   0x08, 0x08, 0x09, 0x08, 0x09, 0x03, 0x07, 0x09, 0x09, 0x09,
   0x09, 0x09, 0x0b, 0x09, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
   0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x02,
   0x00, 0x01, 0x01, 0x01, 0x00, 0x02, 0x01, 0x03, 0x01, 0x01,
   0x01, 0x01, 0x00, 0x02, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01,
   0x02, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x00,
   0x03, 0x01, 0x01, 0x02, 0x02, 0x02, 0x01, 0x03, 0x00, 0x04,
   0x02, 0x02, 0x02, 0x02, 0x01, 0x03, 0x00, 0x04, 0x02, 0x02,
   0x02, 0x02, 0x03, 0x01, 0x04, 0x00, 0x02, 0x02, 0x02, 0x02,
   0x03, 0x01, 0x04, 0x00, 0x02, 0x0b, 0x0f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05,
   0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
   0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
   0x05, 0x05, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
   0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
   0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05,
   0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
   0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x09,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07,
   0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x09, 0x0f, 0x00,
   0x03, 0x02, 0x04, 0x05, 0x06, 0x03, 0x07, 0x03, 0x02, 0x04,
   0x05, 0x06, 0x03, 0x07, 0x03, 0x02, 0x04, 0x05, 0x06, 0x03,
   0x07, 0x03, 0x02, 0x04, 0x05, 0x06, 0x03, 0x07, 0x03, 0x02,
   0x04, 0x05, 0x06, 0x03, 0x07, 0x03, 0x02, 0x04, 0x05, 0x06,
   0x03, 0x07, 0x03, 0x02, 0x04, 0x05, 0x06, 0x03, 0x07, 0x03,
   0x02, 0x04, 0x05, 0x06, 0x03, 0x07, 0x06, 0x05, 0x04, 0x03,
   0x02, 0x06, 0x04, 0x06, 0x05, 0x04, 0x03, 0x02, 0x06, 0x04,
   0x06, 0x05, 0x04, 0x03, 0x02, 0x06, 0x04, 0x06, 0x05, 0x04,
   0x03, 0x02, 0x06, 0x04, 0x06, 0x05, 0x04, 0x03, 0x02, 0x06,
   0x04, 0x06, 0x05, 0x04, 0x03, 0x02, 0x06, 0x04, 0x06, 0x05,
   0x04, 0x03, 0x02, 0x06, 0x04, 0x06, 0x05, 0x04, 0x03, 0x02,
   0x06, 0x04, 0x00, 0x05, 0x04, 0x06, 0x03, 0x04, 0x03, 0x02,
   0x01, 0x01, 0x09, 0x02, 0xb0, 0x05, 0x1c, 0x00, 0x0b, 0x01,
   0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0xcc, 0x05, 0x43, 0x00,
   0x07, 0x02, 0x0f, 0x06, 0x0f, 0x00, 0x09, 0x04, 0x1e, 0x06,
   0x02, 0x00, 0x0a, 0x02, 0x20, 0x06, 0x24, 0x00, 0x0d, 0x02,
   0x44, 0x06, 0x42, 0x00, 0x0d, 0x02, 0x86, 0x06, 0x42, 0x00,
   0x06, 0x04, 0x23, 0x03, 0x02, 0x00, 0x03, 0x02, 0x02, 0x05,
   0x05, 0x04, 0x07, 0x07, 0x08, 0x04, 0x07, 0x08, 0x09, 0x07,
   0x03, 0x06, 0x06, 0x08, 0x05, 0x04, 0x05, 0x08, 0x09, 0x09,
   0x07, 0x03, 0x03, 0x05, 0x09, 0x09, 0x00, 0x00, 0x09, 0x14,
   0x14, 0x14, 0x14, 0x14, 0x09, 0x09, 0x00, 0x14, 0x14, 0x14,
   0x14, 0x14, 0x00, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
   0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
   0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
   0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
   0x14, 0x14, 0x14, 0x09, 0x00, 0x14, 0x14, 0x14, 0x14, 0x14,
   0x00, 0x02, 0x03, 0x02, 0x04, 0x03, 0x02, 0x05, 0x04, 0x03,
   0x02, 0x09, 0x08, 0x07, 0x08, 0x09, 0x02, 0x01, 0x02, 0x04,
   0x02, 0x04, 0x06, 0x08, 0x06, 0x04, 0x06, 0x02, 0x08, 0x06,
   0x04, 0x04, 0x02, 0x03, 0x05, 0x07, 0x05, 0x07, 0x09, 0x05,
   0x03, 0x05, 0x07, 0x05, 0x07, 0x02, 0x07, 0x05, 0x03, 0x09,
   0x07, 0x05, 0x04, 0x02, 0x03, 0x05, 0x03, 0x07, 0x05, 0x03,
   0x02, 0x04, 0x06, 0x08, 0x04, 0x02, 0x04, 0x06, 0x03, 0x06,
   0x04, 0x02, 0x04, 0x05, 0x03, 0x08, 0x06, 0x04, 0x02, 0x07,
   0x05, 0x03, 0x03, 0x05, 0x07, 0x09, 0x02, 0x04, 0x06, 0x08,
   0x05, 0x03, 0x05, 0x07, 0x04, 0x02, 0x04, 0x06, 0x03, 0x07,
   0x05, 0x03, 0x05, 0x06, 0x04, 0x02, 0x04, 0x05, 0x03, 0x09,
   0x07, 0x06, 0x03, 0x08, 0x06, 0x04, 0x02, 0x07, 0x05, 0x06,
   0x02, 0x04, 0x02, 0x03, 0x05, 0x07, 0x05, 0x03, 0x05, 0x02,
   0x07, 0x05, 0x03, 0x04, 0x02, 0x03, 0x05, 0x07, 0x03, 0x05,
   0x07, 0x05, 0x03, 0x05, 0x05, 0x03, 0x05, 0x02, 0x07, 0x05,
   0x03, 0x07, 0x05, 0x03, 0x04, 0x02, 0x03, 0x05, 0x07, 0x03,
   0x05, 0x07, 0x03, 0x05, 0x07, 0x05, 0x03, 0x05, 0x05, 0x03,
   0x05, 0x05, 0x03, 0x05, 0x02, 0x07, 0x05, 0x03, 0x07, 0x05,
   0x03, 0x07, 0x05, 0x03, 0x04, 0x02, 0x00, 0x05, 0x04, 0x04,
   0x03, 0x04, 0x04, 0x02, 0x02, 0x01, 0x0c, 0x02, 0x08, 0x07,
   0x37, 0x00, 0x0b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x09, 0x02,
   0x3f, 0x07, 0x1c, 0x00, 0x0d, 0x02, 0x5b, 0x07, 0x42, 0x00,
   0x10, 0x02, 0x9d, 0x07, 0x69, 0x00, 0x07, 0x02, 0x06, 0x08,
   0x0f, 0x00, 0x08, 0x02, 0x15, 0x08, 0x15, 0x00, 0x0f, 0x02,
   0x2a, 0x08, 0x5b, 0x00, 0x05, 0x02, 0x85, 0x08, 0x06, 0x00,
   0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x08, 0x08, 0x08, 0x06,
   0x08, 0x08, 0x08, 0x08, 0x06, 0x08, 0x08, 0x06, 0x08, 0x06,
   0x04, 0x08, 0x08, 0x08, 0x08, 0x04, 0x06, 0x06, 0x06, 0x08,
   0x08, 0x08, 0x04, 0x04, 0x06, 0x06, 0x08, 0x08, 0x08, 0x08,
   0x08, 0x06, 0x06, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
   0x08, 0x08, 0x08, 0x08, 0x06, 0x02, 0x03, 0x02, 0x04, 0x03,
   0x02, 0x05, 0x04, 0x03, 0x02, 0x06, 0x05, 0x04, 0x03, 0x02,
   0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x09, 0x09, 0x08, 0x07,
   0x08, 0x09, 0x09, 0x02, 0x03, 0x02, 0x04, 0x03, 0x02, 0x05,
   0x04, 0x03, 0x02, 0x06, 0x05, 0x04, 0x03, 0x02, 0x07, 0x06,
   0x05, 0x04, 0x03, 0x02, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03,
   0x02, 0x04, 0x03, 0x03, 0x04, 0x05, 0x06, 0x08, 0x09, 0x06,
   0x06, 0x06, 0x06, 0x04, 0x05, 0x07, 0x08, 0x03, 0x08, 0x08,
   0x08, 0x08, 0x07, 0x05, 0x06, 0x07, 0x06, 0x03, 0x09, 0x09,
   0x09, 0x09, 0x09, 0x08, 0x08, 0x08, 0x09, 0x09, 0x08, 0x01,
   0x04, 0x04, 0x05, 0x05, 0x01, 0x06, 0x06, 0x02, 0x02, 0x05,
   0x05, 0x03, 0x03, 0x03, 0x07, 0x07, 0x04, 0x04, 0x06, 0x06,
   0x07, 0x07, 0x06, 0x06, 0x07, 0x07, 0x02, 0x03, 0x03, 0x05,
   0x05, 0x06, 0x05, 0x04, 0x04, 0x08, 0x08, 0x08, 0x08, 0x08,
   0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x07,
   0x08, 0x08, 0x08, 0x01, 0x08, 0x08, 0x08, 0x08, 0x08, 0x07,
   0x08, 0x08, 0x08, 0x02, 0x01, 0x04, 0x04, 0x07, 0x07, 0x08,
   0x06, 0x07, 0x07, 0x04, 0x04, 0x04, 0x04, 0x09, 0x09, 0x09,
   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x06, 0x06, 0x06, 0x07,
   0x06, 0x05, 0x06, 0x06, 0x04, 0x05, 0x07, 0x05, 0x06, 0x09,
   0x08, 0x07, 0x06, 0x08, 0x06, 0x07, 0x04, 0x08, 0x05, 0x03,
   0x08, 0x05, 0x04, 0x04, 0x09, 0x07, 0x05, 0x03, 0x03, 0x03,
   0x04, 0x02, 0x05, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x06,
   0x06, 0x05, 0x07, 0x02, 0x08, 0x08, 0x08, 0x05, 0x06, 0x05,
   0x02, 0x03, 0x03, 0x03, 0x05, 0x04, 0x04, 0x04, 0x04, 0x05,
   0x03, 0x04, 0x03, 0x04, 0x03, 0x05, 0x04, 0x03, 0x04, 0x04,
   0x04, 0x06, 0x06, 0x06, 0x07, 0x06, 0x06, 0x05, 0x07, 0x07,
   0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x09, 0x09, 0x08, 0x09,
   0x08, 0x08, 0x08, 0x08, 0x08, 0x05, 0x04, 0x05, 0x03, 0x06,
   0x05, 0x06, 0x05, 0x07, 0x08, 0x06, 0x08, 0x06, 0x06, 0x07,
   0x07, 0x07, 0x05, 0x07, 0x09, 0x08, 0x07, 0x08, 0x07, 0x07,
   0x08, 0x08, 0x08, 0x04, 0x07, 0x09, 0x09, 0x04, 0x03, 0x06,
   0x08, 0x06, 0x08, 0x04, 0x04, 0x03, 0x07, 0x08, 0x07, 0x03,
   0x04, 0x02, 0x07, 0x06, 0x05, 0x04, 0x03, 0x00, 0x05, 0x00,
   0x04, 0x00, 0x04, 0x01, 0x01, 0x01, 0x01, 0x0c, 0x02, 0xcb,
   0x08, 0x37, 0x00, 0x0b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03,
   0x02, 0x02, 0x09, 0x01, 0x00, 0x07, 0x02, 0x0f, 0x06, 0x0f,
   0x00, 0x09, 0x00, 0x03, 0x09, 0x43, 0x00, 0x09, 0x00, 0x03,
   0x09, 0x43, 0x00, 0x09, 0x00, 0x03, 0x09, 0x43, 0x00, 0x09,
   0x00, 0x03, 0x09, 0x43, 0x00, 0x09, 0x00, 0x03, 0x09, 0x43,
   0x00, 0x09, 0x09, 0x04, 0x09, 0x09, 0x04, 0x09, 0x09, 0x09,
   0x04, 0x09, 0x09, 0x09, 0x09, 0x04, 0x09, 0x09, 0x09, 0x09,
   0x09, 0x04, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x09,
   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x09, 0x09, 0x09,
   0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x09, 0x09, 0x09, 0x09,
   0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x09, 0x09, 0x09, 0x00,
   0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x00,
   0x03, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0a, 0x03, 0x00, 0x03,
   0x09, 0x09, 0x09, 0x09, 0x0a, 0x09, 0x03, 0x00, 0x03, 0x09,
   0x09, 0x09, 0x0a, 0x09, 0x09, 0x03, 0x00, 0x03, 0x09, 0x09,
   0x0a, 0x09, 0x09, 0x09, 0x03, 0x00, 0x03, 0x09, 0x0a, 0x09,
   0x09, 0x09, 0x09, 0x03, 0x00, 0x03, 0x0a, 0x09, 0x09, 0x09,
   0x09, 0x09, 0x03, 0x00
};

#endif /* ifndef __PAN1PTBL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\ole2map\panmap.h ===
/***************************************************************************
 * PANMAP.H - Base definitions for ElseWare PANOSE(tm) 1.0 Font Mapper.
 *            OLE 2.0 Implementation
 *
 *
 * Copyright (C) 1991-94 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/

#ifndef __PANOLE2_H__
#define __PANOLE2_H__


/* A Global Unique Identifier and an Interface ID for the PANOSE mapper.
 */
DEFINE_GUID(CLSID_PANOSEMapper, 0xBD84B381L, 0x8CA2, 0x1069, 0xAB, 0x1D, 0x08,
        0x00, 0x09, 0x48, 0xF5, 0x34);
DEFINE_GUID(IID_IPANOSEMapper, 0xBD84B382L, 0x8CA2, 0x1069, 0xAB, 0x1D, 0x08,
        0x00, 0x09, 0x48, 0xF5, 0x34);




DECLARE_INTERFACE_( IPANOSEMapper, IUnknown)
{
   /* IUnknown 
    */
   STDMETHOD(QueryInterface) (THIS_
                           REFIID riid,
                           LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef) (THIS) PURE;
   STDMETHOD_(ULONG,Release) (THIS) PURE;

   /* The PANOSE Mapper interface.
    */
   STDMETHOD_(USHORT, unPANMatchFonts) ( THIS_
         LPBYTE lpPanWant,
         ULONG ulSizeWant, LPBYTE lpPanThis, ULONG ulSizeThis,
         BYTE jMapToFamily) PURE;


   STDMETHOD_(VOID, vPANMakeDummy)( THIS_
         LPBYTE lpPanThis, USHORT unSize ) PURE;

   STDMETHOD_(SHORT, nPANGetMapDefault)( THIS_
         LPBYTE lpPanDef,
         USHORT unSizePanDef ) PURE;

   STDMETHOD_(SHORT, nPANSetMapDefault) (THIS_
         LPBYTE lpPanDef,
         USHORT unSizePanDef ) PURE;

   STDMETHOD_(BOOL, bPANEnableMapDefault) (THIS_
         BOOL bEnable )  PURE;

   STDMETHOD_(BOOL, bPANIsDefaultEnabled) (THIS)  PURE;

   STDMETHOD_(USHORT, unPANPickFonts) (THIS_
         USHORT FAR *lpIndsBest,
         USHORT FAR *lpMatchValues, LPBYTE lpPanWant,
         USHORT unNumInds, LPBYTE lpPanFirst, USHORT unNumAvail,
         SHORT nRecSize, BYTE jMapToFamily ) PURE ;

   STDMETHOD_(USHORT, unPANGetMapThreshold) (THIS) PURE;

   STDMETHOD_(BOOL, bPANSetMapThreshold) (THIS_
         USHORT unThreshold ) PURE;

   STDMETHOD_(BOOL, bPANIsThresholdRelaxed) (THIS) PURE;

   STDMETHOD_(VOID, vPANRelaxThreshold) (THIS) PURE;

   STDMETHOD_(BOOL, bPANRestoreThreshold) (THIS) PURE;

   STDMETHOD_(BOOL, bPANGetMapWeights) (THIS_
         BYTE jFamilyA,
         BYTE jFamilyB, LPBYTE lpjWts, LPBOOL lpbIsCustom ) PURE;

   STDMETHOD_(BOOL, bPANSetMapWeights) (THIS_
         BYTE jFamilyA,
         BYTE jFamilyB, LPBYTE lpjWts ) PURE;

   STDMETHOD_(BOOL, bPANClearMapWeights) (THIS_
         BYTE jFamilyA,
         BYTE jFamilyB ) PURE;
};
typedef IPANOSEMapper FAR * LPPANOSEMAPPER;

#endif   // __PANOLE2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\ole2map\elseuser.h ===
/***************************************************************************
 * ELSEUSER.H - Supplemental header file with compiler flags for the
 *              ElseWare PANOSE(tm) font mapper.
 *
 * $keywords: elseuser.h 1.8 19-Jul-93 11:11:47 AM$
 *
 * Copyright (C) 1991-93 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/

#ifndef __ELSEUSER_H__
#define __ELSEUSER_H__

/* Compiler flags.
 *
 * NOELSEARGS      - Suppress argument list in procedure prototypes.
 * NOELSEPANCONST  - Suppress list of PANOSE constants.
 * NOELSEPANDATA   - Suppress penalty db, see details below.
 * NOELSEPANSCRIPT - Suppress constants for Latin Script.
 * NOELSEPANKANJI  - Suppress PANOSE constants for Kanji.
 * NOELSEPICKFONTS - Excludes unPANPickFonts(), and default routines.
 * NOELSETHRESHOLD - Excludes threshold routines.
 * NOELSEWEIGHTS   - Exclude mapper custom weight controls.
 * ELSEPENALTYDB   - Include constants and structures for penalty tables.
 *
 * PAN_MATCH_ERROR <val> - Match result indicating no match, should equal
 *                         the max allowable unsigned value for EW_USHORT.
 *
 * ELSEMAXSHORT <val>    - The maximum allowable positive signed value for
 *                         EW_SHORT (should be less than PAN_MATCH_ERROR).
 *
 * ELSEDEFTHRESHOLD <val> - Default mapper threshold value (30 if not
 *                          specified). Set equal to ELSEMAXSHORT to
 *                          entirely disable threshold checking.
 */

/* Macros.
 *
 * Override these macros with system-dependant equivalents to improve
 * the performance of the mapper.
 *
 * M_ELSELMUL(a,b)     - Long multiply a * b.
 * M_ELSELDIV(a,b)     - Long divide a / b.
 * M_ELSEMULDIV(a,b,c) - Long multiply & divide, a * b / c, rounded.
 * M_ELSEMEMCPY(dst,src,len) - memcpy(dst,src,len).
 */

/* NOELSEPANDATA: Penalty database override
 *
 * The default behavior of the mapper is to declare a static data
 * structure containing the penalty database. The structure is
 * defined in the file PAN1PTBL.H, which is included in ELSEPAN.C.
 * The file is generated by the program PAN1PTBL, which reads the
 * file PAN1PTBL.TXT.
 *
 * To override this behavior, define NOELSEPANDATA and provide
 * replacements for the following macros:
 *
 * M_lAllocPAN1DATA()       - Allocate database, return 4-byte handle.
 * M_lLockPAN1DATA(hData)   - Lock penalty database.
 * M_bUnlockPAN1DATA(hData) - Unlock penalty database.
 * M_bFreePAN1DATA(hData)   - Free penalty database.
 *
 * The PAN1PTBL program can be used to create a binary file containing
 * the memory picture of the structure (type the program name at the
 * command line to recieve a usage statement).
 */

#define NOELSEPANKANJI

/* overrides for Windows */
#define M_ELSEMULDIV(a, b, c) MulDiv((a), (b), (c))

#include <memory.h>
#define M_ELSEMEMCPY(dst, src, len) CopyMemory((dst), (src), (len))

#endif /* ifndef __ELSEUSER_H__ */

/***************************************************************************
 * Revision log:
 ***************************************************************************/
/*
 * $lgb$
 * 1.0    21-Jan-93    msd New file taken from project MAI.
 * 1.1    31-Jan-93    msd Replaced Expanded PANOSE (1.1) mapper with 10-digit (1.0) mapper.
 * 1.2     1-Feb-93    msd Remove _huge reference.
 * 1.3     2-Feb-93    msd Removed huge pointer stuff.
 * 1.4     3-Feb-93    msd Removed ctrl-Z at EOF.
 * 1.5     3-Feb-93    msd Fixed bug caused by vcs check-in.
 * 1.6    16-Mar-93    msd Enable PANOSE constants.
 * 1.7    27-Apr-93    msd Enabled script constants.
 * 1.8    19-Jul-93    msd Added compilation flags to selectively disable mapper routines.
 * $lge$
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\fontfldr\ole2map\panmap.cpp ===
/***************************************************************************
 * PANMAP.CPP - Implementaion for ElseWare PANOSE(tm) 1.0 Font Mapper.
 *             OLE 2.0 Implementation
 *
 *
 * Copyright (C) 1991-94 ElseWare Corporation.  All rights reserved.
 ***************************************************************************/
#define _INC_OLE
#define CONST_VTABLE
#include <windows.h>
#include <ole2.h>

// #pragma data_seg(".text")
#define INITGUID
#include <initguid.h>
#include <cguid.h>
#include "elsepan.h"
#include "panmap.h"
#undef INITGUID
// #pragma data_seg()


ULONG g_ulRefThisDll = 0;
ULONG g_ulLock = 0;         //
ULONG g_ulObjs = 0;         // Number of objects

typedef void (FAR PASCAL *LPFNDESTROYED)(void);

////////////////////////////////////////////////////////////////////////////
//
//  Overloaded allocation operators.
//
//  Needed by NT since we don't yet link to real C++ runtimes
//
////////////////////////////////////////////////////////////////////////////

static inline void * __cdecl operator new(
    size_t size)
{
    return ((void *)LocalAlloc(LPTR, size));
}

static inline void __cdecl operator delete(
    void *ptr)
{
    LocalFree(ptr);
}

extern "C" inline __cdecl _purecall(void)
{
    return (0);
}




/**********************************************************************
 */
class CPanoseMapper : public IPANOSEMapper {
public:
   CPanoseMapper(LPUNKNOWN pUnk);
   ~CPanoseMapper(void);


   BOOL  bInit(void);

   /* IUnknown
    */
   STDMETHODIMP         QueryInterface ( REFIID riid, LPVOID FAR* ppvObj);
   STDMETHODIMP_(ULONG) AddRef( void );
   STDMETHODIMP_(ULONG) Release( void ) ;

   /* The PANOSE Mapper interface.
    */
   STDMETHODIMP_(USHORT) unPANMatchFonts(
         LPBYTE lpPanWant,
         ULONG ulSizeWant, EW_LPBYTE lpPanThis, ULONG ulSizeThis,
         BYTE jMapToFamily);


   STDMETHODIMP_(EW_VOID) vPANMakeDummy(
         LPBYTE lpPanThis, USHORT unSize ) ;

   STDMETHODIMP_(SHORT) nPANGetMapDefault(
         LPBYTE lpPanDef,
         USHORT unSizePanDef ) ;

   STDMETHODIMP_(SHORT) nPANSetMapDefault(
         LPBYTE lpPanDef,
         USHORT unSizePanDef ) ;

   STDMETHODIMP_(BOOL) bPANEnableMapDefault (
         BOOL bEnable )  ;

   STDMETHODIMP_(BOOL) bPANIsDefaultEnabled(  )  ;

   STDMETHODIMP_(USHORT) unPANPickFonts (
         USHORT FAR *lpIndsBest,
         USHORT FAR *lpMatchValues, LPBYTE lpPanWant,
         USHORT unNumInds, LPBYTE lpPanFirst, USHORT unNumAvail,
         SHORT nRecSize, BYTE jMapToFamily )  ;

   STDMETHODIMP_(USHORT) unPANGetMapThreshold(  ) ;

   STDMETHODIMP_(BOOL) bPANSetMapThreshold (
         USHORT unThreshold ) ;

   STDMETHODIMP_(BOOL) bPANIsThresholdRelaxed(  ) ;

   STDMETHODIMP_(VOID) vPANRelaxThreshold(  ) ;

   STDMETHODIMP_(BOOL) bPANRestoreThreshold(  ) ;

   STDMETHODIMP_(BOOL) bPANGetMapWeights (
         BYTE jFamilyA,
         BYTE jFamilyB, LPBYTE lpjWts, LPBOOL lpbIsCustom ) ;

   STDMETHODIMP_(BOOL) bPANSetMapWeights (
         BYTE jFamilyA,
         BYTE jFamilyB, LPBYTE lpjWts ) ;

   STDMETHODIMP_(BOOL) bPANClearMapWeights (
         BYTE jFamilyA,
         BYTE jFamilyB ) ;


private:
   LPUNKNOWN      m_pUnkOuter;   //Controlling unknown
   EW_MAPSTATE    m_MapState;    // Used for Core Mapper.

};

/**********************************************************************
 */
class CWrapper : public IUnknown {
public:
   CWrapper(LPUNKNOWN pUnk, LPFNDESTROYED pfn);
   ~CWrapper(void);

   BOOL bInit(void);

   /* IUnknown
    */
   STDMETHODIMP         QueryInterface ( REFIID riid, LPVOID FAR* ppvObj);
   STDMETHODIMP_(ULONG) AddRef( void );
   STDMETHODIMP_(ULONG) Release( void ) ;

private:
   ULONG          m_ulRef;       //Object reference count
   LPUNKNOWN      m_pUnkOuter;   //Controlling unknown
   LPFNDESTROYED  m_pfnDestroy;  // Function to call when destroyed.

   CPanoseMapper * m_pPM;        // the actual PAN mapper.
};

/**********************************************************************
 */
class CImpIClassFactory : public IClassFactory
{
public:
   CImpIClassFactory()
      { m_ulRef = 0; g_ulRefThisDll++;}
   ~CImpIClassFactory() { g_ulRefThisDll--; }

   // *** IUnknown methods ***
   STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
   STDMETHODIMP_(ULONG) AddRef(void);
   STDMETHODIMP_(ULONG) Release(void);

   // *** IClassFactory methods ***
   STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              LPVOID FAR* ppvObject);
   STDMETHODIMP LockServer(BOOL fLock);

private:
   int m_ulRef;
};


// ******************************************************************
// LibMain
// extern "C" BOOL APIENTRY DllMain(HINSTANCE hDll, DWORD dwReason, LPVOID lpReserved)
STDAPI_(BOOL) DllMain(HINSTANCE hDll, DWORD dwReason, LPVOID lpReserved)
{
   switch(dwReason)
   {
      case DLL_PROCESS_ATTACH:
         break;

      case DLL_PROCESS_DETACH:
         break;

      case DLL_THREAD_ATTACH:
         break;

      case DLL_THREAD_DETACH:
         break;

      default:
         break;

   } // switch

   return(TRUE);
}

// ******************************************************************
// DllCanUnloadNow
STDAPI DllCanUnloadNow()
{
   HRESULT retval;

   retval = ResultFromScode((g_ulRefThisDll == 0) &&( g_ulLock == 0 )
            &&( g_ulObjs = 0 )
            ? S_OK : S_FALSE);
   return(retval);
}

//*******************************************************************
// Object destruction notification proc.
void FAR PASCAL vObjectDestroyed(void)
{
   g_ulObjs--;
}

// ******************************************************************
// DllGetClassObject
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid,
        LPVOID FAR* ppvObj)
{
   if(!(rclsid == CLSID_PANOSEMapper))
      return(ResultFromScode(E_FAIL));

   if(!(riid == IID_IUnknown) && !(riid == IID_IClassFactory))
      return(ResultFromScode(E_NOINTERFACE));

   *ppvObj = (LPVOID) new CImpIClassFactory;

   if(!*ppvObj)
      return(ResultFromScode(E_OUTOFMEMORY));


  ( (LPUNKNOWN )*ppvObj)->AddRef();

   return NOERROR;
}


// ***********************************************************************
// ***********************************************************************
// CImpIClassFactory member functions

// *** IUnknown methods ***
STDMETHODIMP CImpIClassFactory::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
   *ppvObj = NULL;

   // Any interface on this object is the object pointer
   if((riid == IID_IUnknown) ||( riid == IID_IClassFactory ))
      *ppvObj =( LPVOID ) this;

   if(*ppvObj) {
     ( (LPUNKNOWN )*ppvObj)->AddRef();
      return NOERROR;
   }

   return(ResultFromScode(E_NOINTERFACE));
}


STDMETHODIMP_(ULONG) CImpIClassFactory::AddRef(void)
{
   return(++m_ulRef);
}


STDMETHODIMP_(ULONG) CImpIClassFactory::Release(void)
{
   ULONG retval;
   retval = --m_ulRef;
   if(!retval) delete this;
   return(retval);
}


// *** IClassFactory methods ***
STDMETHODIMP CImpIClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
        REFIID riid, LPVOID FAR* ppvObj)
{
   HRESULT retval;
   CWrapper * pPM;

   *ppvObj=NULL;
   retval = ResultFromScode(E_OUTOFMEMORY);

   // If we have a controlling unknown, it must ask for IUnknown
   //
   if(pUnkOuter && riid != IID_IUnknown)
      return( E_NOINTERFACE );

   pPM = new CWrapper(pUnkOuter, vObjectDestroyed);

   // Increment the object count if we were successful.
   //
   if(!pPM)
      return(retval);
   g_ulObjs++;

   // Initialize the Panose Mapper. It will destroy itself if initialization
   // fails.
   //
   if(pPM->bInit())
      retval = pPM->QueryInterface(riid, ppvObj);

   return(retval);
}


STDMETHODIMP CImpIClassFactory::LockServer(BOOL fLock)
{
   if(fLock)
      g_ulLock++;
   else
      g_ulLock--;
   return(NOERROR);
}

// ***********************************************************************
// ***********************************************************************
// CWrapper member functions
CWrapper::CWrapper( LPUNKNOWN pUnk, LPFNDESTROYED pfn )
   :  m_pUnkOuter(pUnk),
      m_pfnDestroy(pfn),
      m_ulRef(0) ,
      m_pPM(0)
{

}

CWrapper::~CWrapper(void)
{
   // Clean up the mapper.
   //
   if( m_pPM )
      delete m_pPM;

   // Notify of destruction.
   //
   if( NULL != m_pfnDestroy )
     ( *m_pfnDestroy )();
}


BOOL  CWrapper::bInit(void)
{
   BOOL bRet = FALSE;
   LPUNKNOWN   pUnk = this;

   if( m_pUnkOuter )
      pUnk = m_pUnkOuter;

   m_pPM = new CPanoseMapper(pUnk);

   if(m_pPM) {
      bRet = m_pPM->bInit();
      if(  !bRet  )
         m_pPM = NULL;
   }

   if( !bRet )
      delete this;

   return bRet;
}

STDMETHODIMP CWrapper::QueryInterface(  REFIID riid, LPVOID FAR* ppvObj )
{
   *ppvObj=NULL;

   /*
    * The only calls for IUnknown are either in a nonaggregated
    * case or when created in an aggregation, so in either case
    * always return our IUnknown for IID_IUnknown.
    */
   if( riid == IID_IUnknown )
      *ppvObj=(LPVOID)this;

   /*
    * Return
    */
   if( riid == IID_IPANOSEMapper )
      *ppvObj=(LPVOID)m_pPM;

   //AddRef any interface we'll return.
   if( NULL!=*ppvObj )  {
     ( (LPUNKNOWN )*ppvObj)->AddRef();
      return NOERROR;
   }

   return ResultFromScode(E_NOINTERFACE);

}

STDMETHODIMP_(ULONG) CWrapper::AddRef( void )
{
   m_ulRef++;

    return m_ulRef;
}

STDMETHODIMP_(ULONG) CWrapper::Release( void )
{
   ULONG ulRet = --m_ulRef;
   if(( ULONG )0 == ulRet )
      delete this;

   return ulRet;
}

// ***********************************************************************
// ***********************************************************************
// CPanoseMapper member functions

CPanoseMapper::CPanoseMapper( LPUNKNOWN pUnk )
   :  m_pUnkOuter(pUnk)
{

}

CPanoseMapper::~CPanoseMapper(void)
{
   // Clean up the mapper.
   //
   ::bPANMapClose( &m_MapState );

}


BOOL  CPanoseMapper::bInit(void)
{
   // Initialize the MapState struct
   //
   BOOL bOK =( ::nPANMapInit(&m_MapState, sizeof(m_MapState )) > 0);

   // If init fails, then this is not valid. Delete it.
   //
   if( ! bOK )
      delete this;

   return bOK;
}


/* IUnknown
   */
STDMETHODIMP CPanoseMapper::QueryInterface(  REFIID riid, LPVOID FAR* ppvObj )
{
   return m_pUnkOuter->QueryInterface(riid, ppvObj);

}

STDMETHODIMP_(ULONG) CPanoseMapper::AddRef( void )
{
   return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CPanoseMapper::Release( void )
{
   return m_pUnkOuter->Release();
}

/* The PANOSE Mapper interface.
   */
STDMETHODIMP_(USHORT) CPanoseMapper::unPANMatchFonts(
      LPBYTE lpPanWant,
      ULONG ulSizeWant, LPBYTE lpPanThis, ULONG ulSizeThis,
      BYTE jMapToFamily)
{
   return ::unPANMatchFonts(
         &m_MapState,
         lpPanWant,
         ulSizeWant,
         lpPanThis,
         ulSizeThis,
         jMapToFamily);
}


STDMETHODIMP_(VOID) CPanoseMapper::vPANMakeDummy(
      LPBYTE lpPanThis, USHORT unSize )
{
   ::vPANMakeDummy( lpPanThis, unSize );
}

STDMETHODIMP_(SHORT) CPanoseMapper::nPANGetMapDefault(
      LPBYTE lpPanDef,
      USHORT unSizePanDef )
{
   return ::nPANGetMapDefault( &m_MapState, lpPanDef, unSizePanDef );
}


STDMETHODIMP_(SHORT) CPanoseMapper::nPANSetMapDefault(
      LPBYTE lpPanDef,
      USHORT unSizePanDef )
{
   return ::nPANSetMapDefault( &m_MapState, lpPanDef, unSizePanDef );
}


STDMETHODIMP_(BOOL) CPanoseMapper::bPANEnableMapDefault (
      BOOL bEnable )
{
   return ::bPANEnableMapDefault( &m_MapState, (EW_BOOL)bEnable  );
}


STDMETHODIMP_(BOOL) CPanoseMapper::bPANIsDefaultEnabled(  )
{
   return ::bPANIsDefaultEnabled(  &m_MapState  );
}


STDMETHODIMP_(USHORT) CPanoseMapper::unPANPickFonts (
      USHORT FAR * lpIndsBest,
      USHORT FAR * lpMatchValues, LPBYTE lpPanWant,
      USHORT unNumInds, LPBYTE lpPanFirst, USHORT unNumAvail,
      SHORT nRecSize, BYTE jMapToFamily )
{
   return ::unPANPickFonts (
         &m_MapState,
         lpIndsBest,
         lpMatchValues,
         lpPanWant,
         unNumInds,
         lpPanFirst,
         unNumAvail,
         nRecSize,
         jMapToFamily );
}


STDMETHODIMP_(USHORT) CPanoseMapper::unPANGetMapThreshold(  )
{
   return ::unPANGetMapThreshold( &m_MapState  );
}


STDMETHODIMP_(BOOL) CPanoseMapper::bPANSetMapThreshold (
      USHORT unThreshold )
{
   return ::bPANSetMapThreshold( &m_MapState, unThreshold  );
}


STDMETHODIMP_(BOOL) CPanoseMapper::bPANIsThresholdRelaxed(  )
{
   return ::bPANIsThresholdRelaxed( &m_MapState  );
}


STDMETHODIMP_(VOID) CPanoseMapper::vPANRelaxThreshold(  )
{
   ::vPANRelaxThreshold( &m_MapState  );
}


STDMETHODIMP_(BOOL) CPanoseMapper::bPANRestoreThreshold(  )
{
   return ::bPANRestoreThreshold( &m_MapState  );
}


STDMETHODIMP_(BOOL) CPanoseMapper::bPANGetMapWeights (
      BYTE jFamilyA,
      BYTE jFamilyB, LPBYTE lpjWts, LPBOOL lpbIsCustom )
{
   *lpbIsCustom =( BOOL )0;
   return ::bPANGetMapWeights (&m_MapState, jFamilyA,
               jFamilyB, lpjWts,( EW_LPBOOL )lpbIsCustom );
}


STDMETHODIMP_(BOOL) CPanoseMapper::bPANSetMapWeights (
      BYTE jFamilyA,
      BYTE jFamilyB, LPBYTE lpjWts )
{
   return ::bPANSetMapWeights (
      &m_MapState, jFamilyA,
      jFamilyB, lpjWts );
}


STDMETHODIMP_(BOOL) CPanoseMapper::bPANClearMapWeights (
      BYTE jFamilyA,
      BYTE jFamilyB )
{
   return ::bPANClearMapWeights( &m_MapState, jFamilyA, jFamilyB  );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\card.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/


/****************************************************************************

card.cpp

Nov 91, JimH

Methods for card objects

****************************************************************************/

#include "hearts.h"

#include <stdlib.h>                 // for labs() prototype

#include "card.h"

// Declare (and initialize) static members

HINSTANCE card::hCardsDLL;
INITPROC card::lpcdtInit;
DRAWPROC card::lpcdtDraw;
FARPROC  card::lpcdtTerm;
CBitmap  card::m_bmFgnd;
CBitmap  card::m_bmBgnd2;
CDC      card::m_MemB;
CDC      card::m_MemB2;
CRgn     card::m_Rgn1;
CRgn     card::m_Rgn2;
CRgn     card::m_Rgn;
DWORD    card::dwPixel[12];

BOOL     card::bConstructed;
int      card::dxCrd;
int      card::dyCrd;
CBitmap  card::m_bmBgnd;

int      card::count    = 0;
int      card::stepsize = 15;       // bigger stepsize -> faster glide

/****************************************************************************

card::card

If this is the first card being constructed, links to cards.dll are
set up, along with the bitmaps and regions required for glide()

****************************************************************************/

card::card(int n) : id(n), state(NORMAL)
{
    loc.x = 0;
    loc.y = 0;
    if (count == 0)
    {
        bConstructed = FALSE;

        hCardsDLL = LoadLibrary(TEXT("CARDS.DLL"));
        if (hCardsDLL < (HINSTANCE)HINSTANCE_ERROR)
            return;

        lpcdtInit = (INITPROC) GetProcAddress(hCardsDLL, "cdtInit");
        lpcdtDraw = (DRAWPROC) GetProcAddress(hCardsDLL, "cdtDraw");
        lpcdtTerm =  (FARPROC) GetProcAddress(hCardsDLL, "cdtTerm");

        BOOL bResult = FALSE;
        if(lpcdtInit)
        {
            bResult = (*lpcdtInit)(&dxCrd, &dyCrd);
        }
        if (!bResult)
            return;

        bConstructed = TRUE;

        CDC ic;
        ic.CreateIC(TEXT("DISPLAY"), NULL, NULL, NULL);

        if (!m_bmBgnd.CreateCompatibleBitmap(&ic, dxCrd, dyCrd) ||
            !m_bmFgnd.CreateCompatibleBitmap(&ic, dxCrd, dyCrd) ||
            !m_bmBgnd2.CreateCompatibleBitmap(&ic, dxCrd, dyCrd))
                bConstructed = FALSE;

        ic.DeleteDC();

        if (!m_Rgn1.CreateRectRgn(1, 1, 2, 2) ||        // dummy sizes
            !m_Rgn2.CreateRectRgn(1, 1, 2, 2) ||
            !m_Rgn.CreateRectRgn(1, 1, 2, 2))
                bConstructed = FALSE;
    }
    count++;
}


/****************************************************************************

card::~card

If this is the last card being destroyed, cards.dll is freed and the
bitmaps and regions created for glide() are deleted.

****************************************************************************/
card::~card()
{
    count--;
    if (count == 0)
    {
        (*lpcdtTerm)();
        FreeLibrary(hCardsDLL);
        m_bmBgnd.DeleteObject();
        m_bmFgnd.DeleteObject();
        m_bmBgnd2.DeleteObject();
        m_Rgn.DeleteObject();
        m_Rgn1.DeleteObject();
        m_Rgn2.DeleteObject();
    }
}


/****************************************************************************

card::Draw

wrapper for cards.cdtDraw()
EMPTY cards are not passed through

****************************************************************************/

BOOL card::Draw(CDC &dc, int x, int y, int mode, BOOL bUpdateLoc)
{
    if (bUpdateLoc)
    {
        loc.x = x;              // update current location
        loc.y = y;
    }

    if (id == EMPTY)
        return FALSE;

    return (*lpcdtDraw)(dc.m_hDC, x, y,
        mode == FACEDOWN ? CARDBACK : id, mode, 255);
}


/****************************************************************************

card::CleanDraw

Same as Draw except corners are cleaned up before bitmap is blted.
It's slower than normal draw, but there won't be a white flash in the
corners.

****************************************************************************/

BOOL card::CleanDraw(CDC &dc)
{
    if (id == EMPTY)
        return FALSE;

    SaveCorners(dc, loc.x, loc.y);
    CDC memDC;
    memDC.CreateCompatibleDC(&dc);
    CBitmap bitmap;
    if (!bitmap.CreateCompatibleBitmap(&dc, dxCrd, dyCrd))
        return FALSE;

    CBitmap *oldbitmap = memDC.SelectObject(&bitmap);
    BOOL bResult = (*lpcdtDraw)(memDC.m_hDC, 0, 0, id, FACEUP, 0);
    if (!bResult)
        return FALSE;

    RestoreCorners(memDC, 0, 0);
    dc.BitBlt(loc.x, loc.y, dxCrd, dyCrd, &memDC, 0, 0, SRCCOPY);

    memDC.SelectObject(oldbitmap);
    bitmap.DeleteObject();

    return TRUE;
}


/****************************************************************************

card::PopDraw

Version of Draw intended for local humans.  Selected cards are popped up.

****************************************************************************/

BOOL card::PopDraw(CDC &dc)
{
    if (id == EMPTY)
        return FALSE;

    int y = loc.y;
    if (state == SELECTED)
        y -= POPSPACING;

    return (*lpcdtDraw)(dc.m_hDC, loc.x, y, id, FACEUP, 0);
}


/****************************************************************************

card::Draw

This routine glides a card from its current position to the specified
end position.

NOTE: before Glide() is called, the client must load card::m_bmBgnd with
a bitmap of what should be displayed as being underneath the original
card location.  card::m_bmBgnd is created when the first card is
constructed, and destroyed when the last card is destructed.  Note also
that card::m_bmBgnd must NOT be selected in any DC when Glide() is called.

****************************************************************************/

VOID card::Glide(CDC &dc, int xEnd, int yEnd)
{
    int     x1, y1, x2, y2;             // each step is x1,y1 to x2,y2

    if (!m_MemB.CreateCompatibleDC(&dc) ||  // memory DCs
        !m_MemB2.CreateCompatibleDC(&dc))
            return;

    m_MemB2.SelectObject(&m_bmBgnd2);
    m_MemB.SelectObject(&m_bmFgnd);

    // draw card into fgnd bitmap
    (*lpcdtDraw)(m_MemB.m_hDC, 0, 0, id, FACEUP, 0);

    m_MemB.SelectObject(&m_bmBgnd);     // associate memDCs with bitmaps
    SaveCorners(dc, loc.x, loc.y);
    RestoreCorners(m_MemB, 0, 0);

    long dx = xEnd - loc.x;
    long dy = yEnd - loc.y;
    int  distance = IntSqrt(dx*dx + dy*dy); // int approx. of dist. to travel

    int  steps = distance / stepsize;   // determine # of intermediate steps

    // Ensure that GlideStep gets called an even number of times so
    // the background bitmap will get set properly for multi-glide moves

    if ((steps % 2) == 1)
        steps++;

    x1 = loc.x;
    y1 = loc.y;
    for (int i = 1; i < steps; i++)
    {
        x2 = loc.x + (int) (((long)i * dx) / (long)steps);
        y2 = loc.y + (int) (((long)i * dy) / (long)steps);
        GlideStep(dc, x1, y1, x2, y2);
        x1 = x2;
        y1 = y2;
    }

    // do last step manually so it lands exactly on xEnd, yEnd

    GlideStep(dc, x1, y1, xEnd, yEnd);

    // reset clip region for entire screen

    m_Rgn.SetRectRgn(0, 0, 30000, 30000);   // really big region
    dc.SelectObject(&m_Rgn);

    loc.x = xEnd;
    loc.y = yEnd;

    m_MemB.DeleteDC();        // clean up memory DCs
    m_MemB2.DeleteDC();
}


/******************************************************************************

GlideStep

This routine gets called once for each step in the glide animation.  On
input, it needs the screen under the source in m_MemB, and the card to be
moved in m_bmFgnd.  It calculates the screen under the destination itself
and blts it into m_MemB2.  At the end of the animation, it moves m_MemB2 into
m_MemB so it can be called again immediately with new coordinates.

******************************************************************************/

VOID card::GlideStep(CDC &dc, int x1, int y1, int x2, int y2)
{
    m_Rgn1.SetRectRgn(x1, y1, x1+dxCrd, y1+dyCrd);
    m_Rgn2.SetRectRgn(x2, y2, x2+dxCrd, y2+dyCrd);

    /* create background of new location by combing screen background
       plus overlap from old background */

    m_MemB2.BitBlt(0, 0, dxCrd, dyCrd, &dc, x2, y2, SRCCOPY);
    m_MemB2.BitBlt(x1-x2, y1-y2, dxCrd, dyCrd, &m_MemB, 0, 0, SRCCOPY);
    SaveCorners(m_MemB2, 0, 0);

    /* Draw old background and then draw card  */

    m_Rgn.CombineRgn(&m_Rgn1, &m_Rgn2, RGN_DIFF); // part of hRgn1 not in hRgn2
    dc.SelectObject(&m_Rgn);
    dc.BitBlt(x1, y1, dxCrd, dyCrd, &m_MemB, 0, 0, SRCCOPY);
    dc.SelectObject(&m_Rgn2);
    CBitmap *oldbitmap = m_MemB.SelectObject(&m_bmFgnd);    // temp
    RestoreCorners(m_MemB, 0, 0);
    dc.BitBlt(x2, y2, dxCrd, dyCrd, &m_MemB, 0, 0, SRCCOPY);
    m_MemB.SelectObject(oldbitmap);                         // restore

    /* copy new background to old background, or rather, accomplish the
       same effect by swapping the associated memory device contexts. */

    HDC temp = m_MemB.Detach();         // detach the hDC from the CDC
    m_MemB.Attach(m_MemB2.Detach());    // move the hDC from B2 to B
    m_MemB2.Attach(temp);               // finish the swap
}


/******************************************************************************

IntSqrt

Newton's method to find a quick close-enough square root without pulling
in the floating point libraries.

f(x)  = x*x - square = 0
f'(x) = 2x

******************************************************************************/

int card::IntSqrt(long square)
{
    long lastguess = square;
    long guess = min(square / 2L, 1024L);

    while (labs(guess-lastguess) > 3L)       // 3 is close enough
    {
        lastguess = guess;
        guess -= ((guess * guess) - square) / (2L * guess);
    }

    return (int) guess;
}


/******************************************************************************

SaveCorners
RestoreCorners

based on similar routines in cards.dll

******************************************************************************/

VOID card::SaveCorners(CDC &dc, int x, int y)
{
    // Upper Left
    dwPixel[0] = dc.GetPixel(x, y);
    dwPixel[1] = dc.GetPixel(x+1, y);
    dwPixel[2] = dc.GetPixel(x, y+1);

    // Upper Right
    x += dxCrd -1;
    dwPixel[3] = dc.GetPixel(x, y);
    dwPixel[4] = dc.GetPixel(x-1, y);
    dwPixel[5] = dc.GetPixel(x, y+1);

    // Lower Right
    y += dyCrd-1;
    dwPixel[6] = dc.GetPixel(x, y);
    dwPixel[7] = dc.GetPixel(x, y-1);
    dwPixel[8] = dc.GetPixel(x-1, y);

    // Lower Left
    x -= dxCrd-1;
    dwPixel[9] = dc.GetPixel(x, y);
    dwPixel[10] = dc.GetPixel(x+1, y);
    dwPixel[11] = dc.GetPixel(x, y-1);
}

VOID card::RestoreCorners(CDC &dc, int x, int y)
{
    // Upper Left
    dc.SetPixel(x, y, dwPixel[0]);
    dc.SetPixel(x+1, y, dwPixel[1]);
    dc.SetPixel(x, y+1, dwPixel[2]);

    // Upper Right
    x += dxCrd-1;
    dc.SetPixel(x, y, dwPixel[3]);
    dc.SetPixel(x-1, y, dwPixel[4]);
    dc.SetPixel(x, y+1, dwPixel[5]);

    // Lower Right
    y += dyCrd-1;
    dc.SetPixel(x, y, dwPixel[6]);
    dc.SetPixel(x, y-1, dwPixel[7]);
    dc.SetPixel(x-1, y, dwPixel[8]);

    // Lower Left
    x -= dxCrd-1;
    dc.SetPixel(x, y, dwPixel[9]);
    dc.SetPixel(x+1, y, dwPixel[10]);
    dc.SetPixel(x, y-1, dwPixel[11]);
}


/******************************************************************************

GetRect()

sets and returns a rect that covers the card

******************************************************************************/

CRect &card::GetRect(CRect &rect)
{
    rect.SetRect(loc.x, loc.y, loc.x+dxCrd, loc.y+dyCrd);
    return(rect);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\comp2.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

comp2.cpp

Aug 92, JimH
May 93, JimH    chico port

Logic for computer player to select cards to play when not holding
the lead, and initializing data tables is here.

****************************************************************************/

#include "hearts.h"

#include "main.h"
#include "resource.h"

#include "debug.h"      // undef _DEBUG instead to remove messages

/****************************************************************************

computer::SelectCardToPlay

computer player chooses a card to play.

****************************************************************************/

void computer::SelectCardToPlay(handinfotype &h, BOOL bCheating)
{
    TRACE1("<%d> ", id);

    Setup(h);                       // calculate values of private vars

    SLOT s;
    if (bFirst)                     // am I leading?
        s = SelectLeadCard(h);
    else
        s = SelectNonLeadCard(h);

    ASSERT(s >= 0);
    ASSERT(s < MAXSLOT);
    ASSERT(cd[s].IsValid());

    SetMode(WAITING);
    cd[s].Play();                                   // mark card as played
    h.cardplayed[id] = &(cd[s]);                    // update handinfo

    // inform other players

    ::move.playerid = id;
    ::move.cardid = cd[s].ID();
    ::move.playerled = h.playerled;
    ::move.turn = h.turn;

    // inform gamemeister

    ::pMainWnd->PostMessage(WM_COMMAND, IDM_REF);
    TRACE0("\n");
}


/****************************************************************************

computer::SelectNonLeadCard

This is where cards to play are selected when the computer player is
not leading.

****************************************************************************/

SLOT computer::SelectNonLeadCard(handinfotype &h)
{
    BOOL bFirstTrick = (cardled != NULL) && (cardled->ID() == TWOCLUBS);

    // If we have at least one card of the led suit...

    if (sHighCard[nSuitLed] != EMPTY)
    {
        TRACE0("can follow suit. ");

        // If there's only one card of this suit, return it.

        if (sHighCard[nSuitLed] == sLowCard[nSuitLed])
        {
            TRACE0("must ");
            PLAY(sHighCard[nSuitLed]);
            return sHighCard[nSuitLed];
        }

        // if it's the first trick, play the high club

        if (bFirstTrick)
        {
            TRACE0("might as well ");
            PLAY(sHighCard[nSuitLed]);
            return sHighCard[nSuitLed];
        }

        // If I am the last player in this trick, and I've won the hand anyway,
        // return highest legal card (unless it's the queen of spades.)

        if (bLast && (nLowVal[nSuitLed] > currentval))
        {
            TRACE0("must win trick. ");
            if (sHighCard[nSuitLed] != sBlackLady)
            {
                PLAY(sHighCard[nSuitLed]);
                return sHighCard[nSuitLed];
            }
            else
            {
                TRACE0("avoid queen. ");
                PLAY(sLowCard[nSuitLed]);
                return sLowCard[nSuitLed];
            }
        }

        // If I am the last player and I CAN win the trick....

        if (bLast && (nHighVal[nSuitLed] > currentval))
        {
            TRACE0("can win. ");

            // Don't grab the trick if there aren't enough low cards
            // left in hand.  The lead may be hard to lose!

            if (nLowestVal < 7)                     // i.e., card val < 8
            {
                if ((nPoints == 0) && (sHighCard[nSuitLed] != sBlackLady))
                {
                    TRACE0("go for it. ");
                    PLAY(sHighCard[nSuitLed]);
                    return sHighCard[nSuitLed];
                }

                // Take a few hearts if it means losing a high spade.

                if ((!h.bQSPlayed) && nSuitLed == SPADES && nPoints < 4)
                {
                    if (nHighVal[SPADES] > QUEEN)
                    {
                        TRACE0("sacrifice hearts to lose high spade. ");
                        PLAY(sHighCard[SPADES]);
                        return sHighCard[SPADES];
                    }
                }
                TRACE0("decline. ");
            }
            else
            {
                TRACE0("no low cards. ");
            }
        }

        // Otherwise, try to find the highest safe card to play...

        SLOT safe = SafeCard(h);
        if (safe != EMPTY)
        {
            // if someone other than me is potentially shooting,
            // hold back high cards.

            if (h.bShootingRisk && h.bHumanShooter && (h.nMoonShooter != id))
            {
                TRACE0("2nd ");
                SLOT s2 = CardBelow(safe);
                if (s2 != EMPTY)
                    safe = s2;
            }

            TRACE0("highest safe card. ");
            PLAY(safe);
            return safe;
        }

        // And if that fails, just play the lowest card.

        TRACE0("no safe card, choose lowest. ");
        if (sLowCard[nSuitLed] != sBlackLady)
        {
            PLAY(sLowCard[nSuitLed]);
            return sLowCard[nSuitLed];
        }
        else
        {
            TRACE0("try to avoid queen. ");
            PLAY(sHighCard[nSuitLed]);
            return sHighCard[nSuitLed];
        }
    }

    TRACE0("can't follow suit. ");

    // At this point, there are no cards of the led suit.  The first
    // priority is to try to sluff off the queen of spades.

    if (!bFirstTrick || !::pMainWnd->IsFirstBloodEnforced())
    {
        if (sBlackLady != EMPTY)
        {
            TRACE0("gotcha! Queen of Spades. ");
            return sBlackLady;
        }
    }

    //  The next priority is to dump high spades (if queen not yet played).

    if ((!h.bQSPlayed) && (nHighVal[SPADES] > QUEEN))
    {
        TRACE0("lose high spade. ");
        PLAY(sHighCard[SPADES]);
        return sHighCard[SPADES];
    }

    // The next priority is to find the most vulnerable suit

    int mvsuit = BestSuitToDump(!bFirstTrick);

    // There is an unusual situation which must be checked for explicitly.
    // It's possible BestSuitToDump may return SPADES, and the high card
    // is the queen.  This would still be illegal if it was first round.

    if (bFirstTrick && ::pMainWnd->IsFirstBloodEnforced() && mvsuit == SPADES)
    {
        SLOT s = sHighCard[mvsuit];
        if (cd[s].ID() == BLACKLADY)
        {
            if (sHighCard[DIAMONDS] != EMPTY)       // we know there's no clubs
                mvsuit = DIAMONDS;
            else if (sLowCard[SPADES] != sHighCard[SPADES])
            {
                TRACE0("dump low spade.  ");
                return sLowCard[SPADES];
            }
            else
                mvsuit = HEARTS;
        }
    }


    // if someone other than me is potentially shooting, hold back high cards

    if (h.bShootingRisk && h.bHumanShooter && (h.nMoonShooter != id) &&
                                (sHighCard[mvsuit] != sLowCard[mvsuit]))
    {
        SLOT s = sHighCard[mvsuit];
        SLOT s2 = CardBelow(s);
        if (s2 != EMPTY)
            s = s2;

#ifdef _DEBUG
        TRACE1("hold high %c. ", suitid[mvsuit]);
#endif
        PLAY(s);
        return s;
    }

#ifdef _DEBUG
    TRACE1("dump %c. ", suitid[mvsuit]);
#endif
    PLAY(sHighCard[mvsuit]);
    return sHighCard[mvsuit];
}


/****************************************************************************

computer::SafeCard

Returns highest safe card or EMPTY if no safe card found.

****************************************************************************/

SLOT computer::SafeCard(handinfotype &h)
{
    // Special check.  If Ace of Spades is current trick winner, play the
    // Queen of Spades rather than the King, even though the King is higher.

    if ((sBlackLady!=EMPTY) && (nSuitLed==SPADES) && (currentval==(KING+1)))
        return sBlackLady;

    // Look for highest card of same suit that won't win trick.

    SLOT sSafe = EMPTY;             // highest safe slot
    int  nSafeVal = -1;             // value of highest safe card

    for (SLOT s = 0; s < MAXSLOT; s++)
    {
        if (cd[s].IsValid())
        {
            if (cd[s].Suit() == nSuitLed)
            {
                int v = cd[s].Value2();

                // If card is safe (v < currentval) and card is highest
                // safe card found so far (v > nSaveVal)...

                if ((v < currentval) && (v > nSafeVal))
                {
                    sSafe = s;
                    nSafeVal = v;
                }
            }
        }
    }

    return sSafe;
}


/****************************************************************************

computer::Setup

Set up reference tables for high and low cards in each suit, etc.

****************************************************************************/

void computer::Setup(handinfotype &h)
{
    cardled   = h.cardplayed[h.playerled];
    if (cardled)
    {
        nSuitLed  = cardled->Suit();
        nValueLed = cardled->Value2();
    }
    else
    {
        nSuitLed  = EMPTY;
        nValueLed = EMPTY;
    }

    nPoints   = 0;                      // points in hand already

    // Initialize Tables

    for (int suit = 0; suit < MAXSUIT; suit++)  // highs and lows by suit
    {
        sHighCard[suit] = EMPTY;
        sLowCard[suit]  = EMPTY;
        nHighVal[suit]  = ACE - 1;          // lower than any real card
        nLowVal[suit]   = KING + 2;         // higher than any real card
    }

    sHighestCard = EMPTY;                   // highs and lows regardless of suit
    sLowestCard = EMPTY;
    nHighestVal = ACE - 1;
    nLowestVal = KING + 2;

    // Determine currentval (the value of the winning card so far) and nPoints.

    currentval = nValueLed;
    for (int i = 0; i < MAXPLAYER; i++)
    {
        card *c = h.cardplayed[i];
        if (c->IsValid())
        {
            // First, determine if there are any point cards in play.

            if (c->Suit() == HEARTS)
                nPoints++;

            if (c->ID() == BLACKLADY)
                nPoints += 13;

            // Then, find the highest card (on table) of the led suit.

            if (c->Suit() == nSuitLed)
            {
                int v = c->Value2();

                if (v > currentval)
                    currentval = v;
            }
        }
    }

    // Calculate if we're leading or completing this trick.

    bFirst = (h.playerled == id);
    bLast  = (((h.playerled + (MAXPLAYER-1)) % MAXPLAYER) == id);

    // Special check for the Queen of Spades

    sBlackLady = EMPTY;     // assume we don't have it

    // Collect information on high and low cards in each suit.

    for (SLOT s = 0; s < MAXSLOT; s++)
    {
        if (cd[s].IsValid())
        {
            int suit = cd[s].Suit();
            int v = cd[s].Value2();

            if (cd[s].ID() == BLACKLADY)
                sBlackLady = s;

            if (v < nLowVal[suit])
            {
                nLowVal[suit] = v;
                sLowCard[suit] = s;
            }

            if (v < nLowestVal)
            {
                nLowestVal = v;
                sLowestCard = s;
            }

            if (v > nHighVal[suit])
            {
                nHighVal[suit] = v;
                sHighCard[suit] = s;
            }

            if (v > nHighestVal)
            {
                nHighestVal = v;
                sHighestCard = s;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\computer.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

computer.cpp

keithmo

****************************************************************************/

#include "hearts.h"

#include "main.h"
#include "resource.h"


//
//  Static members.
//

//
//  This array is used to prioritize the search for cards
//  to pass.  This basically maps the irritating A-K ordering
//  used by CARDS.DLL into a more appropriate 2-A ordering.
//

int computer :: _VectorPriority[13] =
	{
	    VECTOR_ACE,
	    VECTOR_KING,
	    VECTOR_QUEEN,
	    VECTOR_JACK,
	    VECTOR_10,
	    VECTOR_9,
	    VECTOR_8,
	    VECTOR_7,
	    VECTOR_6,
	    VECTOR_5,
	    VECTOR_4,
	    VECTOR_3,
	    VECTOR_2
	};

//
//  This array is used to prioritize the card suits.
//

int computer :: _SuitPriority[4] =
    {
	INDEX_HEARTS,
	INDEX_SPADES,
	INDEX_DIAMONDS,
	INDEX_CLUBS
    };


/****************************************************************************

computer constructor

****************************************************************************/
computer :: computer(int n) : player(n, n)
{
    CString newname;
    TCHAR    buf[MAXNAMELENGTH+1];

    *buf = '\0';
    RegEntry    Reg(szRegPath);
    Reg.GetString(regvalPName[n-1], buf, sizeof(buf));
    newname = buf;

    if (newname.IsEmpty())
        newname.LoadString(IDS_P1NAME + n - 1);

    CClientDC dc(::pMainWnd);
    SetName(newname, dc);
    
}   // computer :: computer


/****************************************************************************

Keith:  Make sure you Select(TRUE) cards you select, and
        SetMode(DONE_SELECTING) before you return.

****************************************************************************/
void computer :: SelectCardsToPass()
{
    //
    //  This will hold the total number of cards that
    //  have been passed.
    //
    
    int cPassed = 0;
    int i;
    int nSuit;
    
    //
    //  First we must build our database.
    //

    ComputeVectors();

    //
    //  Priority 1:  Lose the Queen, King, and Ace of Spades.
    //

    PassCardsInVector( QuerySpadesVector() & QKA_CARDS,
		       INDEX_SPADES,
		       &cPassed );

    //
    //  Priority 2:  Lose the Jack, Queen, King, and Ace of Hearts.
    //

    PassCardsInVector( QueryHeartsVector() & JQKA_CARDS,
		       INDEX_HEARTS,
		       &cPassed );

    //
    //  Priority 3:  Pass any high cards not accompanied by two or
    //		     more low cards.
    //

    for( i = 0 ; ( i < 4 ) && ( cPassed < 3 ) ; i++ )
    {
	nSuit = _SuitPriority[i];

	if( nSuit == INDEX_SPADES )
	{
	    continue;
	}
	
	if( CountBits( _CardVectors[nSuit] & LOW_CARDS ) < 2 )
	{
	    PassCardsInVector( _CardVectors[nSuit] & HIGH_CARDS,
			       nSuit,
			       &cPassed );
	}
    }

    //
    //  Priority 4:  If we have the opportunity to "short suit" our
    //  hand, do it.
    //

    for( i = 0 ; ( i < 4 ) && ( cPassed < 3 ) ; i++ )
    {
	nSuit = _SuitPriority[i];
	
	if( CountBits( _CardVectors[nSuit] ) <= ( 3 - cPassed ) )
	{
	    PassCardsInVector( _CardVectors[nSuit],
			       nSuit,
			       &cPassed );
	}
    }

    //
    //  Priority 5:  Hell, I don't know.  Just find some cards to pass.
    //

    for( i = 0 ; ( i < 4 ) && ( cPassed < 3 ) ; i++ )
    {
	nSuit = _SuitPriority[i];
	
	PassCardsInVector( _CardVectors[nSuit],
			   nSuit,
			   &cPassed );
    }
    
    SetMode( DONE_SELECTING );
    
}   // computer :: SelectCardsToPass


/****************************************************************************

    ComputeVectors

    This method sets the _CardVectors[] array to reflect the current set
    of cards held by the computer.
    
****************************************************************************/
void computer :: ComputeVectors( void )
{
    //
    //  First, clear out the current vectors.
    //

    _CardVectors[0] = 0;
    _CardVectors[1] = 0;
    _CardVectors[2] = 0;
    _CardVectors[3] = 0;

    //
    //  Now, scan the currently held cards, updating the vectors.
    //
    
    for( int i = 0 ; i < 13 ; i++ )
    {
	if( cd[i].IsInHand() )
	{
	    AddCard( cd[i].ID() );
	}
    }

}   // computer :: ComputeVectors


/****************************************************************************

    PassCardsInVector
    
****************************************************************************/
void computer :: PassCardsInVector( int nVector, int nSuit, int * pcPassed )
{
    int tmpVector;
    
    //
    //  Don't even try if the vector is already empty or we've already
    //  passed three cards.
    //

    if( ( nVector == 0 ) || ( *pcPassed >= 3 ) )
	return;

    //
    //  Scan the cards in our hand.  Pass all of those whose suit
    //  matches nSuit & are in nVector.  Prioritize the search
    //  via the _VectorPriority array.
    //

    for( int m = 0 ; ( m < 13 ) && ( *pcPassed < 3 ) ; m++ )
    {
	tmpVector = nVector & _VectorPriority[m];

	if( tmpVector == 0 )
	    continue;

	for( int i = 0 ; i < 13 ; i++ )
	{
	    if( cd[i].Suit() != nSuit )
		continue;
	    
	    if( ( tmpVector & CardToVector( cd[i].ID() ) ) == 0 )
		continue;
	
	    //
	    //  We found a card.  Mark it as selected.
	    //
	    
	    cd[i].Select( TRUE );

	    //
	    //  Remove the card from our local vector.  Also
	    //  remove it from the card database and update the
	    //  number of passed cards.
	    //
	    
	    nVector &= ~CardToVector( cd[i].ID() );
	    RemoveCard( cd[i].ID() );
	    (*pcPassed)++;

	    //
	    //  Since there's always *exactly* one bit set in
	    //  tmpVector, and we've found the card for that
	    //  bit, we can exit this inner loop.
	    //

	    break;
	}
    
	//
	//  If the vector has become empty, we can terminate the
	//  outer loop.
	//

	if( nVector == 0 )
	    break;
    }
    
}   // computer :: PassCardsInVector


/****************************************************************************

    CountBits
    
****************************************************************************/
int computer :: CountBits( int x ) const
{
    x = ( ( x >> 1 ) & 0x5555 ) + ( x & 0x5555 );
    x = ( ( x >> 2 ) & 0x3333 ) + ( x & 0x3333 );
    x = ( ( x >> 4 ) & 0x0f0f ) + ( x & 0x0f0f );
    x = ( ( x >> 8 ) & 0x00ff ) + ( x & 0x00ff );

    return x;
    
}   // computer :: CountBits
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\card.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/


/****************************************************************************

card.h

Feb 92, JimH

Header file for class card

****************************************************************************/

#ifndef	CARD_INC
#define	CARD_INC

// typedefs for pointers to functions in cards.dll
// cdtTerm() can use standard FARPROC

typedef BOOL (FAR PASCAL *DRAWPROC)(HDC, int, int, int, int, DWORD);
typedef BOOL (FAR PASCAL *INITPROC)(int FAR *, int FAR *);

const   int     EMPTY       = -1;
const   int     FACEUP      = 0;
const   int     FACEDOWN    = 1;
const   int     HILITE      = 2;
const   int     CARDBACK    = 54;
const   int     ACE         = 0;
const   int     QUEEN       = 11;
const   int     KING        = 12;

const   int     TWOCLUBS    = 4;
const   int     BLACKLADY   = 47;
const   int     CLUBS       = 0;
const   int     DIAMONDS    = 1;
const   int     HEARTS      = 2;
const   int     SPADES      = 3;

const   int     POPSPACING  = 20;       // selected cards pop up this high

const   int     MAXSUIT     = 4;

enum    statetype { NORMAL, SELECTED, PLAYED, HIDDEN };

class card {

    private:
        int     id;                         // 0 to 51
        POINT   loc;                        // current top-left corner loc.
        statetype state;                    // selected or hidden?

        static  int         count;          // number of card instances
        static  int         stepsize;       // size of glide() steps
        static  HINSTANCE   hCardsDLL;      // handle to cards.dll
        static  INITPROC    lpcdtInit;      // ptr to cards.cdtInit()
        static  DRAWPROC    lpcdtDraw;      // ptr to cards.cdtDraw()
        static  FARPROC     lpcdtTerm;      // ptr to cards.cdtTerm()
        static  CBitmap     m_bmFgnd;       // animation card
        static  CBitmap     m_bmBgnd2;      // background dest bitmap
        static  CDC         m_MemB, m_MemB2; // memory DCs for bkgnd bitmaps
        static  CRgn        m_Rgn1, m_Rgn2; // hRgn1 is source, hRgn2 is dest
        static  CRgn        m_Rgn;          // combined region
        static  DWORD       dwPixel[12];    // corner pixels for save/restore

        VOID GlideStep(CDC &dc, int x1, int y1, int x2, int y2);
        VOID SaveCorners(CDC &dc, int x, int y);
        VOID RestoreCorners(CDC &dc, int x, int y);
        int  IntSqrt(long square);

    public:
        static  BOOL        bConstructed;
        static  int         dxCrd, dyCrd;   // size of card bitmap
        static  CBitmap     m_bmBgnd;       // what's under card to glide

        card(int n = EMPTY);
        ~card();

        int ID()    { ASSERT(this != NULL); return id; }
        int Suit()  { ASSERT(this != NULL); return (id % MAXSUIT); }
        int Value() { ASSERT(this != NULL); return (id / MAXSUIT); }
        int Value2() { int v = Value(); return ((v == ACE) ? (KING + 1) : v); }
        VOID Select(BOOL b) { state = (b ? SELECTED : NORMAL); }
        BOOL IsEmpty() { ASSERT(this != NULL); return (id == EMPTY); }
        BOOL IsSelected() { ASSERT(this != NULL); return (state == SELECTED); }
        BOOL IsPlayed() { ASSERT(this != NULL); return (state == PLAYED); }
        BOOL IsHeart() { return (Suit() == HEARTS); }
        BOOL IsValid() { return ((this != NULL) && (id != EMPTY)); }

        VOID SetID(int n) { id = n; }
        VOID SetLoc(int x, int y) { loc.x = x; loc.y = y; }
        int  SetStepSize(int s) { int old = stepsize; stepsize = s; return old;}
        int  GetX(void) { return loc.x; }
        int  GetY(void) { return loc.y; }

        BOOL Draw(CDC &dc, int x, int y,
                  int mode = FACEUP, BOOL bUpdateLoc = TRUE);
        BOOL Draw(CDC &dc) { return Draw(dc, loc.x, loc.y, FACEUP); }
        BOOL Draw(CDC &dc, int mode) { return Draw(dc, loc.x, loc.y, mode); }
        BOOL PopDraw(CDC &dc);      // draw with selections popped
        BOOL CleanDraw(CDC &dc);    // draw with clean corners

        VOID Glide(CDC &dc, int xEnd, int yEnd);
        CRect &GetRect(CRect& rect);
        VOID Remove() { state = HIDDEN; id = EMPTY; }
        VOID Play() { state = PLAYED; }
        BOOL IsNormal() { return (state == NORMAL); }
        BOOL IsInHand() { return ((state == NORMAL) || (state == SELECTED)); }
};

#endif  // conditional include
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\debug.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

//  Aug 92, JimH

#if defined(_DEBUG)

extern TCHAR suitid[];
extern TCHAR cardid[];

#define  PLAY(s)   { int v = cd[s].Value2() + 1;\
                     if (v < 11) { TRACE1("play %d", v); } else\
                     { TRACE1("play %c", cardid[v-11]); } \
                     TRACE1("%c. ", suitid[cd[s].Suit()]); }

#define  CDNAME(c) { int v = c->Value2() + 1;\
                     if (v < 11) { TRACE("%d", v); } else\
                     { TRACE("%c", cardid[v-11]); } \
                     TRACE("%c ", suitid[c->Suit()]); }

#define  DUMP()      Dump(afxDump)

#else
#define PLAY(s)
#define CDNAME(c)
#define DUMP()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\dlg.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

dlg.h

Aug 92, JimH

Dialog classes are declared here.

CScoreDlg       shows current score sheet

CQuoteDlg       quote dialog

CWelcomeDlg     welcome to hearts, do you want to be GameMeister?

COptionsDlg     set options

****************************************************************************/

#ifndef	DLG_INC
#define	DLG_INC

const int   MAXHANDS = 12;      // can display this many in score sheet
const int   MAXPLAYER = 4;
const int   UNKNOWN = -1;       // third BOOL value

class CScoreDlg : public CModalDialog
{
    public:
        CScoreDlg(CWnd *pParent);
        CScoreDlg(CWnd *pParent, int s[MAXPLAYER], int id);
        BOOL    IsGameOver()        { return bGameOver; }
        void    ResetScore()        { nHandsPlayed = 0; bGameOver = FALSE; }
        void    SetText();

    private:
        CStatic *text[MAXPLAYER];
        int     m_myid;

        static  int  score[MAXPLAYER][MAXHANDS+1];
        static  int  nHandsPlayed;
        static  BOOL bGameOver;

        virtual BOOL OnInitDialog();
        afx_msg void OnPaint();

        DECLARE_MESSAGE_MAP()
};

class CQuoteDlg : public CModalDialog
{
    public:
        CQuoteDlg(CWnd *pParent);
        afx_msg void OnPaint();

        DECLARE_MESSAGE_MAP()
};

class CWelcomeDlg : public CModalDialog
{
    public:
        CWelcomeDlg(CWnd *pParent);
        virtual BOOL OnInitDialog();
        virtual void OnOK();
        CString GetMyName()         { return m_myname; }
        BOOL    IsGameMeister()     { return m_bGameMeister; }

        afx_msg void OnHelp();

    private:
        CString m_myname;
        BOOL    m_bGameMeister;

        DECLARE_MESSAGE_MAP()
};

class COptionsDlg : public CModalDialog
{
    public:
        COptionsDlg(CWnd *pParent);
        virtual BOOL OnInitDialog();
        virtual void OnOK();

    private:
        BOOL    IsAutoStart(BOOL bToggle = FALSE);

        BOOL    m_bInitialState;
        BYTE    m_buffer[200];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\dlg.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

dlg.cpp

Aug 92, JimH
May 93, JimH    chico port

Dialog classes are defined here.

CScoreDlg       shows current score sheet

CQuoteDlg       quote dialog

CWelcomeDlg     welcome to Hearts, wanna be gamemeister?

COptionsDlg     set options

CLocateDlg      locate dealer

****************************************************************************/

#include "hearts.h"

#include "resource.h"
#include "main.h"
#include "debug.h"
#include "helpnum.h"
#include "stdlib.h"


typedef int (CALLBACK* FPROC)();            // a FARPROC that returns int


// declare statics

int  CScoreDlg::nHandsPlayed = 0;
int  CScoreDlg::score[MAXPLAYER][MAXHANDS+1];
BOOL CScoreDlg::bGameOver = FALSE;

BEGIN_MESSAGE_MAP( CScoreDlg, CModalDialog )
    ON_WM_PAINT()
END_MESSAGE_MAP()


/****************************************************************************

CScoreDlg constructors

The first constructor takes only one argument, the pointer to the class
of the parent window.  It is used to display the current score at
arbitrary points in the game, ie when the user requests it.

The second also updates the static score array with new information.

****************************************************************************/

CScoreDlg::CScoreDlg(CWnd *pParent) : CModalDialog(DLG_SCORE, pParent),
                                      m_myid(-1)
{

}

CScoreDlg::CScoreDlg(CWnd *pParent, int s[MAXPLAYER], int id) :
            CModalDialog(DLG_SCORE, pParent), m_myid(id)
{
    if (nHandsPlayed == MAXHANDS)
    {
        for (int hand = 1; hand < MAXHANDS; hand++)
            for (int player = 0; player < MAXPLAYER; player++)
                score[player][hand-1] = score[player][hand];

        nHandsPlayed--;
    }

    // add latest scores to list

    for (int player = 0; player < MAXPLAYER; player++)
        score[player][nHandsPlayed] = s[player];

    nHandsPlayed++;
}


/****************************************************************************

CScoreDlg::OnInitDialog

****************************************************************************/

BOOL CScoreDlg::OnInitDialog()
{
    RECT rcDlg, rcMain;

    GetParent()->GetClientRect(&rcMain);
    GetParent()->ClientToScreen(&rcMain);
    rcMain.bottom -= ::nStatusHeight;
    GetWindowRect(&rcDlg);

    int dxDlg = rcDlg.right - rcDlg.left;
    int dxMain = rcMain.right - rcMain.left;
    int x = rcMain.left + ((dxMain - dxDlg) / 2);

    int dyDlg = rcDlg.bottom - rcDlg.top;
    int dyMain = rcMain.bottom - rcMain.top;
    int y = rcMain.top + ((dyMain - dyDlg) / 2);

    SetWindowPos(NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
    SetText();          // set title bar text
    return TRUE;
}


/****************************************************************************

CScoreDlg::SetText  -- set title bar text

****************************************************************************/

void CScoreDlg::SetText()
{
    CString s, s2;

    s.LoadString(IDS_SCORESHEET);

    if (nHandsPlayed != 0)
    {
        int place = 0;
        for (int i = 1; i < MAXPLAYER; i++)
            if (score[i][nHandsPlayed-1] < score[0][nHandsPlayed-1])
                place++;

        s2.LoadString(IDS_PLACE1 + place);
        s += " -- ";
        s += s2;
    }

    SetWindowText(s);
}


/****************************************************************************

CScoreDlg::OnPaint

The score text is not drawn with text controls because the strikeout
text is needed for some parts of the score.  Instead, the paint message
is hooked here.

****************************************************************************/

void CScoreDlg::OnPaint()
{
    BYTE charset = 0;
    int	fontsize = 0; 
    CString fontname, charsetstr, fontsizestr;
    fontname.LoadString(IDS_FONTFACE);
    charsetstr.LoadString(IDS_CHARSET);
    fontsizestr.LoadString(IDS_FONTSIZE);
    charset = (BYTE)_ttoi((const TCHAR *)charsetstr);
    fontsize = _ttoi((const TCHAR *)fontsizestr);

    // Nobody has best score if game hasn't started yet

    int nBestScore = (nHandsPlayed == 0 ? 0 : 30000);
    int nWorstScore = 0;

    if (nHandsPlayed > 0)
    {
        for (int pos = 0; pos < MAXPLAYER; pos++)
        {
            if (score[pos][nHandsPlayed-1] < nBestScore)
            {
                nBestScore = score[pos][nHandsPlayed-1];
            }
            if (score[pos][nHandsPlayed-1] > nWorstScore)
            {
                nWorstScore = score[pos][nHandsPlayed-1];
            }
        }
    }

    // If the game is over, display appropriate text in title bar

    if (nWorstScore >= 100)
    {
        CString title;

        if (score[0][nHandsPlayed-1] == nBestScore)
            title.LoadString(IDS_GAMEOVERWIN);
        else
            title.LoadString(IDS_GAMEOVER);

        SetWindowText(title);
        bGameOver = TRUE;
    }

    CPaintDC dc(this);
    CRect rect;
    GetClientRect(&rect);

    // Divide the dialog up into columns for displaying scores

    rect.right -= 5;                // 5 pixels on left, overlap on right
    int nWidth = rect.right / 5;
    rect.bottom -= 10;              // 5 pixels on top and bottom
    int nHeight = rect.bottom;
    CString text, s;
    dc.SetBkMode(TRANSPARENT);

    // If game is over, change the appearance of the dialog so people
    // notice it.  The section below adds the icon under the OK button.

    if (bGameOver)
    {
        HICON    hIcon = ::LoadIcon(AfxGetInstanceHandle(),
                              MAKEINTRESOURCE(AFX_IDI_STD_FRAME));

        int x = (nWidth * 4) + ((nWidth - 32) / 2);
        int y = 75;

        dc.DrawIcon(x, y, hIcon);
        // CRect   rectIcon(x-10, y-10, x+32+10, y+32+10);
        // FrameRect(rectIcon);
    }

    // create Helv 8 bold font, and Helv 8 bold strikeout font

    CFont   font, strikefont;
    font.CreateFont(fontsize, 0, 0, 0, 700, 0, 0, 0, charset, 0, 0, 0, 0, fontname);
    strikefont.CreateFont(fontsize, 0, 0, 0, 700, 0, 0, 1, charset, 0, 0, 0, 0, fontname);
    CFont *oldfont = dc.SelectObject(&font);

    for (int pos = 0; pos < MAXPLAYER; pos++)
    {
        int red = 127;      // ega needed special processing here

        if (nHandsPlayed > 0)
            if (score[pos][nHandsPlayed-1] == nBestScore)
                dc.SetTextColor(bGameOver ? RGB(red, 0, 0) : RGB(0, 0, 255));

        text = ((CMainWindow *)::pMainWnd)->GetPlayerName(pos);

        // The line below allows overlapping of names at top of score dlg.
        // To disallow overlapping, use:
        // rect.SetRect(5 + (nWidth*pos), 5, 5 + (nWidth*(pos+1)), nHeight);

        rect.SetRect((nWidth*pos) - 5, 5, 15 + (nWidth*(pos+1)), nHeight);
        int nTextHeight = dc.DrawText(text, -1, &rect, DT_CENTER | DT_NOPREFIX);
        rect.top += nTextHeight;

        dc.SelectObject(&strikefont);
        text.Empty();
        for (int hand = 0; hand < (nHandsPlayed - 1); hand++)
        {
            wsprintf(s.GetBuffer(20), TEXT("%d\r\n"), score[pos][hand]);
            s.ReleaseBuffer();
            text += s;
        }
        dc.DrawText(text, -1, &rect, DT_CENTER);
        rect.top += (nTextHeight * (nHandsPlayed - 1));

        dc.SelectObject(&font);
        if (nHandsPlayed > 0)
        {
            wsprintf(text.GetBuffer(20), TEXT("%d"), score[pos][nHandsPlayed-1]);
            text.ReleaseBuffer();
        }
        dc.DrawText(text, -1, &rect, DT_CENTER);
        dc.SetTextColor(0);
    }

    dc.SelectObject(oldfont);
}


/****************************************************************************

CQuoteDlg

****************************************************************************/

BEGIN_MESSAGE_MAP( CQuoteDlg, CModalDialog )
    ON_WM_PAINT()
END_MESSAGE_MAP()

/****************************************************************************

CQuoteDlg constructor

****************************************************************************/

CQuoteDlg::CQuoteDlg(CWnd *pParent) : CModalDialog(DLG_QUOTE, pParent)
{

}


/****************************************************************************

CQuoteDlg::OnPaint

This used to draw an icon and a 3d frame.  Now it just draws the icon.

****************************************************************************/

void CQuoteDlg::OnPaint()
{
    CPaintDC dc(this);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
    HICON    hIcon = ::LoadIcon(AfxGetInstanceHandle(),
                          MAKEINTRESOURCE(AFX_IDI_STD_FRAME));

    int x = 24;
    int y = 24;
    dc.DrawIcon(x, y, hIcon);
    // CRect rectIcon(x-10, y-10, x+32+10, y+32+10);
    // FrameRect(rectIcon);
}


/****************************************************************************

CWelcomeDlg

****************************************************************************/

BEGIN_MESSAGE_MAP( CWelcomeDlg, CModalDialog )
    ON_BN_CLICKED(IDC_WELCOMEHELP,  OnHelp)
END_MESSAGE_MAP()

/****************************************************************************

CWelcomeDlg constructor

****************************************************************************/

CWelcomeDlg::CWelcomeDlg(CWnd *pParent) : CModalDialog(DLG_WELCOME, pParent),
        m_bGameMeister(FALSE)
{
    RegEntry    Reg(szRegPath);
    TCHAR *pm_myname = m_myname.GetBuffer(MAXNAMELENGTH+1);
    Reg.GetString(regvalName, pm_myname, MAXNAMELENGTH+1);
    m_myname.ReleaseBuffer();
}


/****************************************************************************

CWelcomeDlg::OnInitDialog()

Restore settings from .ini file

****************************************************************************/

BOOL CWelcomeDlg::OnInitDialog()
{
    CEdit *editname = (CEdit *)GetDlgItem(IDC_YOURNAME);
    editname->SetWindowText(m_myname);
    editname->LimitText(MAXNAMELENGTH);

    return TRUE;
}


/****************************************************************************

CWelcomeDlg::OnOK()

Don't allow empty name.  Store data in .ini file.

****************************************************************************/

void CWelcomeDlg::OnOK()
{
    GetDlgItemText(IDC_YOURNAME, m_myname.GetBuffer(MAXNAMELENGTH+1),
                  MAXNAMELENGTH+1);
    m_myname.ReleaseBuffer();

    if (m_myname.IsEmpty())
    {
        ((CEdit *)GetDlgItem(IDC_YOURNAME))->SetFocus();
        return;
    }

    m_bGameMeister = TRUE;

    RegEntry    Reg(szRegPath);

    Reg.SetValue(regvalRole, m_bGameMeister ? 1 : 0L);
    Reg.SetValue(regvalName, m_myname);

//    ::WinHelp(m_hWnd, szHelpFileName, HELP_QUIT, 0);

    EndDialog(IDOK);
}


/****************************************************************************

CWelcomeDlg::OnHelp()

****************************************************************************/

void CWelcomeDlg::OnHelp()
{
//    ::WinHelp(m_hWnd, szHelpFileName, HELP_CONTEXT, IDH_START_HOW_HRTS);
}


/****************************************************************************

COptionsDlg constructor

****************************************************************************/

COptionsDlg::COptionsDlg(CWnd *pParent) : CModalDialog(DLG_OPTIONS, pParent)
{

}


/****************************************************************************

COptionsDlg::OnInitDialog

Set dialog controls to current values

****************************************************************************/

BOOL COptionsDlg::OnInitDialog()
{
    RegEntry    Reg(szRegPath);

    // Set animation speed radio button

    DWORD dwSpeed = Reg.GetNumber(regvalSpeed, IDC_NORMAL);

    ((CButton *)GetDlgItem((int)dwSpeed))->SetCheck(TRUE);

    // Set current computer player names.  If they are not specified in
    // the .ini file, get defaults from the resource file.

    CEdit   *pName[3];
    CString sName[3];

    for (int i = 0; i < 3; i++)
    {
        pName[i] = (CEdit *)GetDlgItem(IDC_NAME1 + i);
        pName[i]->LimitText(MAXNAMELENGTH);
        TCHAR *p = sName[i].GetBuffer(MAXNAMELENGTH + 1);
        Reg.GetString(regvalPName[i], p, MAXNAMELENGTH+1);
        sName[i].ReleaseBuffer();

        if (sName[i].IsEmpty())
            sName[i].LoadString(IDS_P1NAME + i);

        pName[i]->SetWindowText(p);
    }

    // get current autostart state

    m_bInitialState = IsAutoStart();
//    ((CButton *)GetDlgItem(IDC_AUTO))->SetCheck(m_bInitialState);

    return TRUE;
}


/****************************************************************************

COptionsDlg::OnOK

save contol settings

****************************************************************************/

void COptionsDlg::OnOK()
{
    RegEntry    Reg(szRegPath);

    // save animation speed setting

    DWORD dwSpeed;
    int   nStepSize;

    if (((CButton *)GetDlgItem(IDC_FAST))->GetCheck())
    {
        dwSpeed = IDC_FAST;
        nStepSize = 60;
    }
    else if (((CButton *)GetDlgItem(IDC_SLOW))->GetCheck())
    {
        dwSpeed = IDC_SLOW;
        nStepSize = 5;
    }
    else
    {
        dwSpeed = IDC_NORMAL;
        nStepSize = 15;
    }

    card c;
    c.SetStepSize(nStepSize);
    Reg.SetValue(regvalSpeed, dwSpeed);

    // save computer player names

    for (int i = 0; i < 3; i++)
    {
        CString sDefault, sEdit;
        sDefault.LoadString(IDS_P1NAME + i);

        GetDlgItemText(IDC_NAME1 + i, sEdit.GetBuffer(MAXNAMELENGTH+1),
                      MAXNAMELENGTH+1);
        sEdit.ReleaseBuffer();

        if (sDefault == sEdit)
            Reg.DeleteValue(regvalPName[i]);
        else
            Reg.SetValue(regvalPName[i], sEdit);
    }

    // save autostart state

//    BOOL bState = ((CButton *)GetDlgItem(IDC_AUTO))->GetCheck();

//    if (bState != m_bInitialState)
//        IsAutoStart(TRUE);              // toggle state

    EndDialog(IDOK);
}


/****************************************************************************

COptionsDlg::IsAutoStart

returns autostart state, and optionally toggles it.  The bToggle
parameter is FALSE by default.

If bToggle is TRUE, this function returns the NEW state.

****************************************************************************/

BOOL COptionsDlg::IsAutoStart(BOOL bToggle)
{
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\computer.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/


/****************************************************************************

    computer.h

    This file contains the class declarations and manifest constants
    necessary for implementing the 'computer' object.

    FILE HISTORY:

	KeithMo	    01-Mar-1992	    Created from JimH's PLAYER.H.

****************************************************************************/

#include "card.h"
#include "player.h"

#ifndef	_COMPUTER_H_
#define	_COMPUTER_H_


//
//  These constants are used for indexing the _CardVectors array.
//
//  Note that this ordering *must* match the ordering used for the
//  card ID values!!
//

#define INDEX_CLUBS		0
#define INDEX_DIAMONDS		1
#define INDEX_HEARTS		2
#define INDEX_SPADES            3

//
//  These constants represent the values returned from the
//  CardToVector() function.
//
//  Note that this ordering *must* match the ordering used for the
//  card ID values!!
//

#define VECTOR_ACE		0x0001
#define VECTOR_2       		0x0002
#define VECTOR_3       		0x0004
#define VECTOR_4       		0x0008
#define VECTOR_5       		0x0010
#define VECTOR_6       		0x0020
#define VECTOR_7       		0x0040
#define VECTOR_8       		0x0080
#define VECTOR_9		0x0100
#define VECTOR_10		0x0200
#define VECTOR_JACK		0x0400
#define VECTOR_QUEEN		0x0800
#define VECTOR_KING		0x1000

//
//  These constants define various combinations of cards.
//

#define LOW_CARDS		(VECTOR_2 | VECTOR_3 | VECTOR_4 | VECTOR_5 \
				 | VECTOR_6 | VECTOR_7)
				 
#define HIGH_CARDS		(VECTOR_8 | VECTOR_9 | VECTOR_10 \
				 | VECTOR_JACK | VECTOR_QUEEN | VECTOR_KING \
				 | VECTOR_ACE)

#define QKA_CARDS		(VECTOR_QUEEN | VECTOR_KING | VECTOR_ACE)

#define JQKA_CARDS		(VECTOR_JACK | VECTOR_QUEEN | VECTOR_KING \
				 | VECTOR_ACE)


/****************************************************************************

    computer

****************************************************************************/
class computer : public player
{
private:
    static int _VectorPriority[13];
    static int _SuitPriority[4];
    
    int _CardVectors[4];

    int CardToSuit( int nCard ) const
        { return nCard % 4; }

    int CardToValue( int nCard ) const
        { return nCard / 4; }

    int CardToVector( int nCard ) const
        { return 1 << CardToValue( nCard ); }

    int CountBits( int x ) const;

    void AddCard( int nCard )
        { _CardVectors[CardToSuit(nCard)] |= CardToVector(nCard); }

    void RemoveCard( int nCard )
        { _CardVectors[CardToSuit(nCard)] &= ~CardToVector(nCard); }

    BOOL TestCard( int nCard ) const
        { return (_CardVectors[CardToSuit(nCard)] & CardToVector(nCard)) != 0; }

    int QueryClubsVector( void ) const
	{ return _CardVectors[INDEX_CLUBS]; }

    int QueryDiamondsVector( void ) const
	{ return _CardVectors[INDEX_DIAMONDS]; }

    int QueryHeartsVector( void ) const
	{ return _CardVectors[INDEX_HEARTS]; }

    int QuerySpadesVector( void ) const
	{ return _CardVectors[INDEX_SPADES]; }

    void ComputeVectors( void );

    void PassCardsInVector( int nVector, int nSuit, int * pcPassed );

    // comp2.cpp helper functions and data

    int  BestSuitToDump(BOOL bIncludeHearts = TRUE);
    int  BestSuitToLose(BOOL bIncludeHearts = TRUE);
    SLOT CardBelow(SLOT s);
    int  CardsAbove(SLOT s);
    int  CardsAboveLow(int suit);
    int  CardsBelowLow(int suit);
    SLOT MidSlot(int suit);
    SLOT SafeCard(handinfotype &h);
    SLOT SelectLeadCard(handinfotype &h);
    SLOT SelectNonLeadCard(handinfotype &h);
    void Setup(handinfotype &h);
    int  SureLossSuit(BOOL bIncludeHearts);
	
    BOOL    bFirst;                 // am I leading?
    BOOL    bLast;                  // am I last?
    card    *cardled;
    int     nSuitLed;
    int     nValueLed;
    int     currentval;             // current winning value
    int     nPoints;                // points currently in hand

    SLOT    sBlackLady;             // non-EMPTY if in hand

    SLOT    sHighCard[MAXSUIT];     // highest and lowest cards by suit
    int     nHighVal[MAXSUIT];
    SLOT    sLowCard[MAXSUIT];
    int     nLowVal[MAXSUIT];

    SLOT    sHighestCard;           // highest and lowest regardless of suit
    int     nHighestVal;
    SLOT    sLowestCard;
    int     nLowestVal;

    int     nAvailable[MAXSUIT][KING+2];    // cards unaccounted for this hand

public:
    computer(int n);
    virtual void NotifyEndHand(handinfotype &h);
    virtual void NotifyNewRound(void);
    virtual void SelectCardsToPass(void);
    virtual void SelectCardToPlay(handinfotype &h, BOOL bCheating);
    virtual void UpdateStatus(void) { }
    virtual void UpdateStatus(int stringid) { status = stringid; }
    virtual void UpdateStatus(const TCHAR *string) { }
    
};  // class computer


#endif	// _COMPUTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\helpnum.h ===
#define IDH_START_HOW_HRTS      2001
#define IDH_LOCATE              2002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\hearts.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

hearts.cpp

Main file for Microsoft Hearts Network.

Aug 92, JimH
May 93, JimH    chico port

****************************************************************************/

#include "hearts.h"
#include "debug.h"

extern "C" void _setargv() { }      // reduces size of C runtimes
extern "C" void _setenvp() { }

TCHAR   suitid[] = TEXT("CDHS");
TCHAR   cardid[] = TEXT("JQKA");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\human.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

human.cpp

Aug 92, JimH
May 93, JimH    chico port

local_human and remote_human member functions

****************************************************************************/

#include "hearts.h"

#include "main.h"                       // friendly access
#include "resource.h"
#include "debug.h"

#include <stdio.h>
#include <stdlib.h>                     // abs() prototype

static  CRect   rectCard;               // used in timer callback


// declare static members

BOOL    local_human::bTimerOn;
CString local_human::m_StatusText;


/****************************************************************************

human constructor -- abstract class

****************************************************************************/

human::human(int n, int pos) : player(n, pos)
{

}


/****************************************************************************

local_human::local_human()

This is the constructor that initializes player::hWnd and player::hInst.
It also creates the stretch bitmap that covers a card plus its popped
height extension.

****************************************************************************/

local_human::local_human(int n) : human(n, 0)
{
    m_pStatusWnd = new CStatusBarCtrl();
    m_StatusText.LoadString(IDS_INTRO);

    CClientDC dc(::pMainWnd);

    m_pStatusWnd->Create(WS_CHILD|WS_VISIBLE|CCS_BOTTOM, CRect(), ::pMainWnd, 0);
    m_pStatusWnd->SetSimple();
    UpdateStatus();

    bTimerOn = FALSE;

    if (!m_bmStretchCard.CreateCompatibleBitmap(&dc, card::dxCrd,
                        card::dyCrd + POPSPACING))
    {
        ::pMainWnd->FatalError(IDS_MEMORY);
        return;
    }
}


/****************************************************************************

local_human destructor

****************************************************************************/

local_human::~local_human()
{
    m_bmStretchCard.DeleteObject();
    delete m_pStatusWnd;
    m_pStatusWnd = NULL;
}


/****************************************************************************

local_human::Draw()

This virtual function draws selected cards in the popped up position.
ALL is not used for slot in this variant.

****************************************************************************/

void local_human::Draw(CDC &dc, BOOL bCheating, SLOT slot)
{
    DisplayName(dc);
    SLOT start = (slot == ALL ? 0 : slot);
    SLOT stop  = (slot == ALL ? MAXSLOT : slot+1);

    SLOT playedslot = EMPTY;            // must draw cards in play last for EGA

    for (SLOT s = start; s < stop; s++)
    {
        if (cd[s].IsPlayed())
            playedslot = s;
        else
            cd[s].PopDraw(dc);          // pop up selected cards
    }

    if (playedslot != EMPTY)
        cd[playedslot].Draw(dc);
}


/****************************************************************************

local_human::PopCard()

handles mouse button selection of card to pass

****************************************************************************/

void local_human::PopCard(CBrush &brush, int x, int y)
{
    SLOT s = XYToCard(x, y);
    if (s == EMPTY)
        return;

    // count selected cards

    int c = 0;
    for (int i = 0; i < MAXSLOT; i++)
        if (cd[i].IsSelected())
            c++;

    if (cd[s].IsSelected() && (c == 3))
    {
        ::pMainWnd->PostMessage(WM_COMMAND, IDM_HIDEBUTTON);
    }
    else if (!cd[s].IsSelected())
    {
        if (c == 3)                 // only allow three selections
            return;
        else if (c == 2)
            ::pMainWnd->PostMessage(WM_COMMAND, IDM_SHOWBUTTON);
    }

    // toggle selection

    BOOL bSelected = cd[s].IsSelected();
    cd[s].Select(!bSelected);

    CClientDC dc(::pMainWnd);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
    CDC memDC;
    memDC.CreateCompatibleDC(&dc);
    memDC.SelectObject(&m_bmStretchCard);
    memDC.SelectObject(&brush);
    memDC.PatBlt(0, 0, card::dxCrd, card::dyCrd + POPSPACING, PATCOPY);

    for (i = 0; i < MAXSLOT; i++)
    {
        if (abs(i - s) <= (card::dxCrd / HORZSPACING))
        {
            cd[i].Draw(memDC,                                   // cdc
                       (i - s) * HORZSPACING,                   // x
                       cd[i].IsSelected() ? 0 : POPSPACING,     // y
                       FACEUP,                                  // mode
                       FALSE);                                  // update loc?
        }
    }

    dc.BitBlt(loc.x + (HORZSPACING * s), loc.y - POPSPACING,
           card::dxCrd, card::dyCrd + POPSPACING,
           &memDC, 0, 0, SRCCOPY);
}


/****************************************************************************

local_human::PlayCard()

handles mouse button selection of card to play
and ensures move is legal.

PlayCard starts a timer that calls StartTimer() which calls TimerBadMove().
Think of it as one long function with a timer delay half way through.

****************************************************************************/

BOOL local_human::PlayCard(int x, int y, handinfotype &h, BOOL bCheating,
                            BOOL bFlash)
{
    SLOT s = XYToCard(x, y);
    if (s == EMPTY)
        return FALSE;

    card *cardled    = h.cardplayed[h.playerled];
    BOOL bFirstTrick = (cardled != NULL && cardled->ID() == TWOCLUBS);

    /* check if selected card is valid */

    if (h.playerled == id)              // if local human is leading...
    {
        if (cd[s].ID() != TWOCLUBS)
        {
            for (int i = 0; i < MAXSLOT; i++)   // is there a two of clubs?
            {
                if ((i != s) && (cd[i].ID() == TWOCLUBS))
                {
                    UpdateStatus(IDS_LEAD2C);
                    if (bFlash)
                        StartTimer(cd[s]);

                    return FALSE;
                }
            }
        }
        if ((cd[s].Suit() == HEARTS) && (!h.bHeartsBroken))   // if hearts led
        {
            for (int i = 0; i < MAXSLOT; i++)   // are there any non-hearts?
            {
                if ((!cd[i].IsEmpty()) && (cd[i].Suit() != HEARTS))
                {
                    UpdateStatus(IDS_LEADHEARTS);
                    if (bFlash)
                        StartTimer(cd[s]);

                    return FALSE;
                }
            }
        }
    }

    // if not following suit

    else if (cardled != NULL && (cd[s].Suit() != cardled->Suit()))
    {
        // make sure we're following suit if possible

        for (int i = 0; i < MAXSLOT; i++)
        {
            if ((!cd[i].IsEmpty()) && (cd[i].Suit()==cardled->Suit()))
            {
                CString s1, s2;
                s1.LoadString(IDS_BADMOVE);
                s2.LoadString(IDS_SUIT0+cardled->Suit());
                TCHAR string[80];
                wsprintf(string, s1, s2);

                if (bFlash)
                {
                    UpdateStatus(string);
                    StartTimer(cd[s]);
                }

                return FALSE;
            }
        }

        // make sure we're not trying to break the First Blood rule

        if (bFirstTrick && ::pMainWnd->IsFirstBloodEnforced())
        {
            BOOL bPointCard =
                         (cd[s].Suit() == HEARTS || cd[s].ID() == BLACKLADY);

            BOOL bOthersAvailable = FALSE;

            for (int i = 0; i < MAXSLOT; i++)
                if ((!cd[i].IsEmpty()) && (cd[i].Suit() != HEARTS))
                    if (cd[i].ID() != BLACKLADY)
                        bOthersAvailable = TRUE;

            if (bPointCard && bOthersAvailable)
            {
                UpdateStatus(IDS_BADBLOOD);
                if (bFlash)
                    StartTimer(cd[s]);

                return FALSE;
            }
        }
    }

    SetMode(WAITING);
    cd[s].Play();
    h.cardplayed[id] = &(cd[s]);

    ::move.playerid = id;
    ::move.cardid = cd[s].ID();
    ::move.playerled = h.playerled;
    ::move.turn = h.turn;

    ::pMainWnd->OnRef();

    return TRUE;
}

void local_human::StartTimer(card &c)
{
    CClientDC dc(::pMainWnd);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
    c.Draw(dc, HILITE);           // flash
    c.GetRect(rectCard);

    if (::pMainWnd->SetTimer(1, 250, TimerBadMove))
    {
        bTimerOn = TRUE;
    }
    else
    {
        bTimerOn = FALSE;
        ::pMainWnd->InvalidateRect(&rectCard, FALSE);
    }
}

// MFC2 changes same as SetTimer in main2.cpp

#if defined (MFC1)

UINT FAR PASCAL EXPORT
        TimerBadMove(HWND hWnd, UINT nMsg, int nIDEvent, DWORD dwTime)
{
    ::KillTimer(hWnd, 1);
    local_human::bTimerOn = FALSE;
    ::InvalidateRect(hWnd, &rectCard, FALSE);
    return 0;
}

#else

void FAR PASCAL EXPORT
        TimerBadMove(HWND hWnd, UINT nMsg, UINT_PTR nIDEvent, DWORD dwTime)
{
    ::KillTimer(hWnd, 1);
    local_human::bTimerOn = FALSE;
#ifdef USE_MIRRORING
    CRect rect;
	int  i;
	DWORD ProcessDefaultLayout;
	if (GetProcessDefaultLayout(&ProcessDefaultLayout))
		if (ProcessDefaultLayout == LAYOUT_RTL)
		{
    	GetClientRect(hWnd, &rect);
		rectCard.left = abs(rect.right - rect.left) - rectCard.left;
		rectCard.right = abs(rect.right - rect.left) - rectCard.right;
		i = rectCard.left;
		rectCard.left = rectCard.right;
		rectCard.right = i;
		}
#endif

    ::InvalidateRect(hWnd, &rectCard, FALSE);

}

#endif


/****************************************************************************

local_human::XYToCard()

returns a card slot number (or EMPTY) given a mouse location

****************************************************************************/

int local_human::XYToCard(int x, int y)
{
    // check that we are in the right general area on the screen

    if (y < (loc.y - POPSPACING))
        return EMPTY;

    if (y > (loc.y + card::dyCrd))
        return EMPTY;

    if (x < loc.x)
        return EMPTY;

    if (x > (loc.x + (12 * HORZSPACING) + card::dxCrd))
        return EMPTY;

    // Take first stab at card selected.

    SLOT s = (x - loc.x) / HORZSPACING;
    if (s > 12)
        s = 12;

    // If the click is ABOVE the top of the normal card location,
    // check to see if this is a selected card.

    if (y < loc.y)
    {
        // If the card is bSelected, then we have it.  If not, it could
        // be overhanging other cards.

        if (!cd[s].IsSelected())
        {
            for (;;)
            {
                if (s == 0)
                    return EMPTY;
                s--;

                // if this card doesn't extend as far as x, give up

                if ((loc.x + (s * HORZSPACING) + card::dxCrd) < x)
                    return EMPTY;

                // if this card is selected, we've got it

                if (cd[s].IsSelected())
                    break;
            }
        }
    }

    // a similar check is used to make sure we pick a card not yet played

    if (!cd[s].IsInHand())
    {
        for (;;)
        {
            if (s == 0)
                return EMPTY;
            s--;

            // if this card doesn't extend as far as x, give up

            if ((loc.x + (s * HORZSPACING) + card::dxCrd) < x)
                return EMPTY;

            // if this card is selected, we've got it

            if (cd[s].IsInHand())
                break;
        }
    }

    return s;
}


/****************************************************************************

local_human::SelectCardsToPass()

This virtual function allows mouse clicks to mean select a card to play.

****************************************************************************/

void local_human::SelectCardsToPass()
{
    SetMode(SELECTING);
}


/****************************************************************************

local_human::SelectCardToPlay

Computer versions of this virtual function actually do the card selection.
This local_human version marks the player as ready to select a card to
play with the mouse, and updates the status to reflect this.

****************************************************************************/

void local_human::SelectCardToPlay(handinfotype &h, BOOL bCheating)
{
    SetMode(PLAYING);
    UpdateStatus(IDS_GO);
}


/****************************************************************************

local_human::UpdateStatus

The status bar can be updated either by manually filling m_StatusText
or by passing a string resource id.

****************************************************************************/

void local_human::UpdateStatus(void)
{
    m_pStatusWnd->SetText(m_StatusText, 255, 0);
}

void local_human::UpdateStatus(int stringid)
{
    status = stringid;
    m_StatusText.LoadString(stringid);
    UpdateStatus();
}

void local_human::UpdateStatus(const TCHAR *string)
{
    m_StatusText = string;
    UpdateStatus();
}


/****************************************************************************

local_human::ReceiveSelectedCards

The parameter c[] is an array of three cards being passed from another
player.

****************************************************************************/

void local_human::ReceiveSelectedCards(int c[])
{
    for (int i = 0, j = 0; j < 3; i++)
    {
        if (cd[i].IsSelected())
            cd[i].SetID(c[j++]);

        ASSERT(i < MAXSLOT);
    }

    SetMode(ACCEPTING);
    UpdateStatus(IDS_ACCEPT);
}


/****************************************************************************

local_human::WaitMessage()

Makes and shows the "Waiting for %s to move..." message

****************************************************************************/

void local_human::WaitMessage(const TCHAR *name)
{
    TCHAR buf[100];
    CString s;

    s.LoadString(IDS_WAIT);
    wsprintf(buf, s, name);
    UpdateStatus(buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\hearts.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

hearts.h

Aug 92, JimH
May 93, JimH    chico port

declaration of theApp class

****************************************************************************/


#ifndef	HEARTS_INC
#define	HEARTS_INC

#ifndef STRICT
#define STRICT
#endif

//#include <windows.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcmn.h>			// MFC support for Windows Common Controls

#include <shellapi.h>
//#include <shell.h>

#include <afxwin.h>

#include <htmlhelp.h>

class CTheApp : public CWinApp
{
    public:
        BOOL InitInstance();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\lead.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

lead.cpp

Aug 92, JimH
May 93, JimH    chico port

Logic to select lead card is here

****************************************************************************/

#include "hearts.h"

#include "main.h"
#include "resource.h"

#include "debug.h"      // undef _DEBUG instead to remove messages

/****************************************************************************

computer::SelectLeadCard

****************************************************************************/

SLOT computer::SelectLeadCard(handinfotype &h)
{
    SLOT    s;

    TRACE0("leading. ");

    // count cards left and check for two of clubs

    SLOT s2Clubs = EMPTY;
    int cTricksLeft = 0;
    for (s = 0; s < MAXSLOT; s++)
    {
        if (cd[s].IsValid())
        {
            cTricksLeft++;
            if (cd[s].ID() == TWOCLUBS)
                s2Clubs = s;
        }
    }

    if (s2Clubs != EMPTY)
    {
        TRACE0("lead 2 of clubs. ");
        return s2Clubs;
    }

    // If the Queen of Spades has not yet been played, try to force it out.
    // See if we are "spade safe" -- i.e., if we have no spades that are
    // queen or higher.  If we are safe, lead the lowest spade.

    if (!h.bQSPlayed)       // this is only interesting if queen not yet played
    {
        BOOL bHaveSpades = (sLowCard[SPADES] != EMPTY);
        BOOL bSpadeSafe = (nHighVal[SPADES] < QUEEN);

        if (bHaveSpades && bSpadeSafe)
        {
            TRACE0("try to force out spades, ");
            PLAY(sLowCard[SPADES]);
            return sLowCard[SPADES];
        }
    }

    // Now we just want to lead the lowest card of the best suit

    int suit = SureLossSuit(h.bHeartsBroken);

    if (suit == EMPTY)
        suit = BestSuitToLose(h.bHeartsBroken);

    // Be brave early on and lead a card near the midpoint of the suit
    // (if the queen of spades has been played already.)
    // Later on, just lead the lowest card of that suit.

    if (cTricksLeft > 8 && suit != HEARTS && h.bQSPlayed)
    {
        TRACE0("try midslot. ");
        s = MidSlot(suit);
    }
    else
    {
        s = sLowCard[suit];
    }

    PLAY(s);
    return s;
}


/****************************************************************************

computer::NotifyNewRound

Each player gets this call immediately after cards are passed.
It is a chance to initialize tables, etc.

****************************************************************************/

void computer::NotifyNewRound()
{
    // assume all cards are available

    for (int suit = 0; suit < MAXSUIT; suit++)
        for (int i = 0; i < (KING+2); i++)
            nAvailable[suit][i] = TRUE;

    // mark cards in hand as unavailable

    for (SLOT s = 0; s < MAXSLOT; s++)
        nAvailable[cd[s].Suit()][cd[s].Value2()] = FALSE;
}



/****************************************************************************

computer::NotifyEndHand

Each player gets this call immediately after the hand is completed.
The computer player here looks through the handplayed and marks
those cards are no longer available.

****************************************************************************/

void computer::NotifyEndHand(handinfotype &h)
{
    for (int i = 0; i < 4; i++)
        nAvailable[h.cardplayed[i]->Suit()][h.cardplayed[i]->Value2()] = FALSE;
}


/****************************************************************************

computer::CardsAboveLow(int suit)

Returns number of available (not yet played) cards that can beat the
low card held for the given suit.

****************************************************************************/

int computer::CardsAboveLow(int suit)
{
    int     count = 0;

    for (int i = nLowVal[suit]+1; i < (KING+2); i++)
        if (nAvailable[suit][i])
        {
            int j = i+1;                   // zero offset
            count++;
        }

    return count;
}


/****************************************************************************

computer::CardsBelowLow(int suit)

Returns number of available (not yet played) cards that are less than the
low card held for the given suit.

****************************************************************************/

int computer::CardsBelowLow(int suit)
{
    int     count = 0;

    for (int i = ACE+1; i < nLowVal[suit]; i++)
        if (nAvailable[suit][i])
        {
            int j = i+1;                   // zero offset
            count++;
        }

    return count;
}


/****************************************************************************

computer::BestSuitToLose

Returns the suit with the most CardsAboveLow()
bIncludeHearts defaults to TRUE.  Use FALSE if hearts not
yet broken and you're looking for a card to lead.

****************************************************************************/

int computer::BestSuitToLose(BOOL bIncludeHearts)
{
    int     best = -1;
    int     bestsuit = EMPTY;

    for (int suit = 0; suit < MAXSUIT; suit++)
    {
        if (sLowCard[suit] != EMPTY)        // if we have a card of this suit
        {
            if (suit != HEARTS || bIncludeHearts)
            {
                int count = CardsAboveLow(suit);
#ifdef _DEBUG
                TRACE2("%c=%d ", suitid[suit], count);
#endif
                if (count == best)      // if they're the same, pick lower card
                {
                    if (nLowVal[suit] < nLowVal[bestsuit])
                    {
                        bestsuit = suit;
                        best = count;
                    }
                }
                else if (count > best)
                {
                    bestsuit = suit;
                    best = count;
                }
            }
        }
    }

    if (bestsuit == EMPTY)          // only if all we have are unbroken hearts
        return HEARTS;
    else
        return bestsuit;
}


/****************************************************************************

computer::BestSuitToDump

Returns the suit with the most CardsBelowLow()
This is the most-vulnerable suit.
bIncludeHearts defaults to TRUE.

****************************************************************************/

int computer::BestSuitToDump(BOOL bIncludeHearts)
{
    int     best = -1;
    int     bestsuit = EMPTY;

    for (int suit = 0; suit < MAXSUIT; suit++)
    {
        if (sLowCard[suit] != EMPTY)        // if we have a card of this suit
        {
            if (suit != HEARTS || bIncludeHearts)
            {
                int count = CardsBelowLow(suit);
#ifdef _DEBUG
                TRACE2("%c=%d ", suitid[suit], count);
#endif
                if (count == best)      // if they're the same, pick lower card
                {
                    if (nLowVal[suit] > nLowVal[bestsuit])
                    {
                        bestsuit = suit;
                        best = count;
                    }
                }
                else if (count > best)
                {
                    bestsuit = suit;
                    best = count;
                }
            }
        }
    }

    if (bestsuit == EMPTY)          // only if all we have are unbroken hearts
        return HEARTS;
    else
        return bestsuit;
}


/****************************************************************************

computer::MidSlot

Instead of choosing the high or low card from a given suit, this function
can be used to pick something in the middle, where middle is defined as
the card with about the same number of available cards above and below it.

****************************************************************************/

SLOT computer::MidSlot(int suit)
{
    SLOT midslot = sLowCard[suit];
    int maxtricks = CardsAbove(sLowCard[suit]);
    int tricks = maxtricks;

    for (SLOT s = 0; s < MAXSLOT; s++)
    {
        if ((cd[s].IsValid()) && (cd[s].Suit()==suit) && (s!=sLowCard[suit]))
        {
            int above = CardsAbove(s);
            if ((above < tricks) && (above > (maxtricks / 2)))
            {
                midslot = s;
                tricks = above;
            }
        }
    }
    return midslot;
}


/****************************************************************************

computer::CardsAbove

Similar to CardsAboveLow except that it finds number of cards in the same
suit available from an arbitrary card.

****************************************************************************/

int computer::CardsAbove(SLOT s)
{
    int     suit = cd[s].Suit();
    int     count = 0;

    for (int i = cd[s].Value2()+1; i < (KING+2); i++)
        if (nAvailable[suit][i])
            count++;

    return count;
}


/****************************************************************************

computer::CardBelow

returns the slot of the next highest card of the same suit, or EMPTY

****************************************************************************/

SLOT computer::CardBelow(SLOT slot)
{
    SLOT sBelow = EMPTY;
    int  suit  = cd[slot].Suit();
    int  value = cd[slot].Value2();
    int  best  = -1;

    for (SLOT s = 0; s < MAXSLOT; s++)
    {
        if ((cd[s].IsValid()) && (cd[s].Suit()==suit) && (cd[s].Value2()<value))
        {
            if (cd[s].Value2() > best)
            {
                best = cd[s].Value2();
                sBelow = s;
            }
        }
    }

    return sBelow;
}


/****************************************************************************

computer::SureLossSuit

Returns a suit that can be led which guarantees a loss of
lead, or EMPTY if none is found.

****************************************************************************/

int computer::SureLossSuit(BOOL bIncludeHearts)
{
    for (int suit = (MAXSUIT-1); suit >= 0; --suit)
    {
        if (sLowCard[suit] != EMPTY)        // if we have a card of this suit
        {
            if (suit != HEARTS || bIncludeHearts)
            {
                if (CardsAboveLow(suit) > 0 && CardsBelowLow(suit) == 0)
                {
                    TRACE0("can lose this trick. ");
                    return suit;
                }
            }
        }
    }

    return EMPTY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\main.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

main.h

CMainWindow object
This class encompasses most of what is interesting in the main window of
Hearts.

Aug 92, JimH

****************************************************************************/

#ifndef STRICT
#define STRICT
#endif

#include "regentry.h"

#include "player.h"
#include "computer.h"
#include "dlg.h"

#ifndef	MAIN_INC
#define	MAIN_INC


// non-translateable strings

extern  const TCHAR szRegPath[];
extern  const TCHAR regvalSound[];
extern  const TCHAR regvalName[];
extern  const TCHAR regvalRole[];
extern  const TCHAR regvalSpeed[];
extern  const TCHAR *regvalPName[3];

extern  const TCHAR szHelpFileName[];

const   int     WINWIDTH    = 540;
const   int     WINHEIGHT   = 480;

const   int     LEFT        = 0;        // passdir
const   int     RIGHT       = 1;
const   int     ACROSS      = 2;
const   int     NOPASS      = 3;

const   int     OFF         = 0;        // used in PlaySound

const   int     MAXNAMELENGTH   = 14;

enum    roletype { GAMEMEISTER, PLAYER };


typedef struct {                        // sent out after each move
    int     playerid;
    int     cardid;
    int     playerled;
    int     turn;
} MOVE;


#if defined (MFC1)
UINT FAR PASCAL EXPORT TimerDispatch(HWND, UINT, int, DWORD);
#else
void FAR PASCAL EXPORT TimerDispatch(HWND, UINT, UINT, DWORD);
#endif


class CMainWindow : public CFrameWnd
{
    friend  player::player(int n, int pos);
    friend  void player::GlideToCentre(SLOT s, BOOL bFaceup);

#if defined(MFC1)
    friend  UINT FAR PASCAL EXPORT TimerDispatch(HWND, UINT, int, DWORD);
#else
    friend  void FAR PASCAL EXPORT TimerDispatch(HWND, UINT, UINT_PTR, DWORD);
#endif

    public:
        CMainWindow(LPTSTR lpCmdLine);
        void     FatalError(int errorno = -1);
        int      GetGameNumber()            { return m_gamenumber; }
        COLORREF GetBkColor()               { return m_bkgndcolor; }
        CString  GetPlayerName(int num)     { return p[num]->GetName(); }
        modetype GetPlayerMode(int num)     { return p[num]->GetMode(); }
        int      GetMyId()                  { return m_myid; }
        int      Id2Pos(int id)             { return ((id - m_myid + 4) % 4); }
        BOOL     IsFirstBloodEnforced()     { return bEnforceFirstBlood; }
        void     PlayerQuit(int id);
        int      Pos2Id(int pos)            { return ((pos + m_myid) % 4); }
        void     SetGameNumber(int num)     { m_gamenumber = num; }

        afx_msg void OnAbout();
        afx_msg void OnBossKey()            { ShowWindow(SW_MINIMIZE); }
        afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
        afx_msg void OnCheat();
        afx_msg void OnClose();
        afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
        afx_msg BOOL OnEraseBkgnd(CDC *);
        afx_msg void OnExit()               { bConstructed = FALSE; OnClose(); }
        afx_msg void OnHelp()
                        { ::HtmlHelp(::GetDesktopWindow(), szHelpFileName, HH_DISPLAY_TOPIC, 0); }
/*
        afx_msg void OnHelpOnHelp()
                        { ::WinHelp(m_hWnd, NULL, HELP_HELPONHELP, 0); }
*/
        afx_msg void OnHideButton()         { m_Button.EnableWindow(FALSE); }
/*
        afx_msg void OnSearch()
                      { ::WinHelp(m_hWnd, szHelpFileName, HELP_PARTIALKEY,
                                                        (DWORD_PTR)(LPSTR)""); }
*/
        afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
        afx_msg void OnNewGame();
        afx_msg void OnOptions();
        afx_msg void OnPaint();
        afx_msg void OnPass();
        afx_msg void OnQuote();
        afx_msg void OnRef();
        afx_msg void OnShowButton() { m_Button.EnableWindow();
                                      m_Button.SetFocus(); }
        afx_msg void OnScore();
        afx_msg void OnSound();
        afx_msg void OnWelcome();
        afx_msg LRESULT OnPrintClient(WPARAM wParam, LPARAM lParam);

    private:
        int      CountClients();
        void     DoSort();
        void     DispatchCards();
        void     EndHand();
        void     FirstMove();
        void     GameOver();
        BOOL     HandlePassing();
        void     ResetHandInfo(int playernumber);
        void     Shuffle();
        BOOL     SoundInit();
        BOOL     HeartsPlaySound(int id);

        CButton  m_Button;
        int      m_StatusHeight;
        CScoreDlg *m_pScoreDlg;

        BOOL     bAutostarted;
        BOOL     bCheating;
        BOOL     bConstructed;
        BOOL     bEnforceFirstBlood;
        BOOL     bHasSound;
        BOOL     bSoundOn;
        BOOL     bTimerOn;
        int      m_gamenumber;
        LPTSTR    m_lpCmdLine;
        player   *p[MAXPLAYER];
        int      m_myid;
        int      passdir;
        int      m_FatalErrno;

        COLORREF        m_bkgndcolor;
        handinfotype    handinfo;
        roletype        role;

        int      tricksleft;
        int      trickwinner;

        static   CBrush m_BgndBrush;
        static   CRect  m_TableRect;

        DECLARE_MESSAGE_MAP()
};

// global variables

extern  CMainWindow *pMainWnd;

extern  MOVE    move;
extern  int     nStatusHeight;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\main.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

main.cpp

Aug 92, JimH
May 93, JimH    chico port

Main window callback functions
Other CMainWindow member functions are in main2.cpp and welcome.cpp

****************************************************************************/

#include "hearts.h"
#include "main.h"
#include "resource.h"
#include "debug.h"
#include <regstr.h>



// declare static memberes

CBrush  CMainWindow::m_BgndBrush;
CRect   CMainWindow::m_TableRect;

// declare globals

CMainWindow *pMainWnd;

MOVE    move;               // describes move for DDE transaction
int     nStatusHeight;      // height of status window

// Do not translate these registry strings

const TCHAR szRegPath[]     = REGSTR_PATH_WINDOWSAPPLETS TEXT("\\Hearts");
const TCHAR regvalSound[]   = TEXT("sound");
const TCHAR regvalName[]    = TEXT("name");
const TCHAR regvalRole[]    = TEXT("gamemeister");
const TCHAR regvalSpeed[]   = TEXT("speed");
const TCHAR *regvalPName[3]  = { TEXT("p1name"), TEXT("p2name"), TEXT("p3name") };

const TCHAR szHelpFileName[]  = TEXT("mshearts.chm");

CTheApp theApp;                     // start Hearts and run it!

/****************************************************************************

CTheApp::InitInstance

****************************************************************************/

BOOL CTheApp::InitInstance()
{

    m_pMainWnd = new CMainWindow(m_lpCmdLine);
    m_pMainWnd->ShowWindow(SW_SHOW);        // instead of m_nCmdShow
    m_pMainWnd->UpdateWindow();

    // Start the app off by posting Welcome dialog.

    m_pMainWnd->PostMessage(WM_COMMAND, IDM_WELCOME);

    return TRUE;
}


BEGIN_MESSAGE_MAP( CMainWindow, CFrameWnd )
    ON_COMMAND(IDM_ABOUT,       OnAbout)
    ON_COMMAND(IDM_BOSSKEY,     OnBossKey)
    ON_COMMAND(IDM_CHEAT,       OnCheat)
    ON_COMMAND(IDM_EXIT,        OnExit)
    ON_COMMAND(IDM_HELP,        OnHelp)
//    ON_COMMAND(IDM_HELPONHELP,  OnHelpOnHelp)
    ON_COMMAND(IDM_HIDEBUTTON,  OnHideButton)
//    ON_COMMAND(IDM_SEARCH,      OnSearch)
    ON_COMMAND(IDM_NEWGAME,     OnNewGame)
    ON_COMMAND(IDM_OPTIONS,     OnOptions)
    ON_COMMAND(IDM_QUOTE,       OnQuote)
    ON_COMMAND(IDM_REF,         OnRef)
    ON_COMMAND(IDM_SHOWBUTTON,  OnShowButton)
    ON_COMMAND(IDM_SCORE,       OnScore)
    ON_COMMAND(IDM_SOUND,       OnSound)
    ON_COMMAND(IDM_WELCOME,     OnWelcome)

    ON_BN_CLICKED(IDM_BUTTON,   OnPass)

    ON_WM_CHAR()
    ON_MESSAGE(WM_PRINTCLIENT, OnPrintClient)
    ON_WM_CLOSE()
    ON_WM_CREATE()
    ON_WM_ERASEBKGND()
    ON_WM_LBUTTONDOWN()
    ON_WM_PAINT()
END_MESSAGE_MAP()


/****************************************************************************

CMainWindow constructor

creates green background brush, and main hearts window

****************************************************************************/

CMainWindow::CMainWindow(LPTSTR lpCmdLine) :
    m_lpCmdLine(lpCmdLine), passdir(LEFT), bCheating(FALSE), bSoundOn(FALSE),
    bTimerOn(FALSE), bConstructed(TRUE), m_FatalErrno(0),
    bEnforceFirstBlood(TRUE)
{
#if !defined (MFC1)
    m_bAutoMenuEnable = FALSE;      // MFC 1.0 compatibility, required for MFC2
#endif
	

    for (int i = 0; i < MAXPLAYER; i++)
        p[i] = NULL;

    ResetHandInfo(-1);              // set handinfo struct to default values

    // Check for monochrome

    CDC ic;
    ic.CreateIC(TEXT("DISPLAY"), NULL, NULL, NULL);

    if (ic.GetDeviceCaps(NUMCOLORS) == 2)       // if monochrome
        m_bkgndcolor = RGB(255, 255, 255);      // white background for mono
    else
        m_bkgndcolor = RGB(0, 127, 0);

    ic.DeleteDC();

    m_BgndBrush.CreateSolidBrush(m_bkgndcolor); // destroyed in OnClose()
    LoadAccelTable( TEXT("HeartsAccel") );

    RECT rc;
    SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, 0);

    CRect rect;
    int dy = min(WINHEIGHT, (rc.bottom - rc.top));

    int x, y;
    if (GetSystemMetrics(SM_CYSCREEN) <= 480)   // VGA
    {
        x = (((rc.right - rc.left) - WINWIDTH) / 2) + rc.left;  // centered
        y = rc.top;
    }
    else
    {
        x = CW_USEDEFAULT;
        y = CW_USEDEFAULT;
    }

    rect.SetRect(x, y, x+WINWIDTH, y+dy);

    CString sAppname;
    sAppname.LoadString(IDS_APPNAME);


    Create( NULL,                                       // default class
            sAppname,                                   // window title
            WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU |
            WS_MINIMIZEBOX | WS_CLIPCHILDREN,           // window style
            rect,                                       // size
            NULL,                                       // parent
            TEXT("HeartsMenu"));                              // menu
}


/****************************************************************************

CMainWindow::OnAbout

displays about box

****************************************************************************/

//extern "C" int WINAPI ShellAbout(HWND, LPCSTR, LPCSTR, HICON);

void CMainWindow::OnAbout()
{
    HICON hIcon = ::LoadIcon(AfxGetInstanceHandle(),
                          MAKEINTRESOURCE(AFX_IDI_STD_FRAME));

    CString s;
    s.LoadString(IDS_NETWORK);
    ShellAbout(m_hWnd, s, NULL, hIcon);
}


/****************************************************************************

CMainWindow::OnQuote

displays quote box and plays quote.

****************************************************************************/

void CMainWindow::OnQuote()
{
    CQuoteDlg quote(this);
    // HeartsPlaySound(SND_QUOTE);
    quote.DoModal();
    HeartsPlaySound(OFF);
}


/****************************************************************************

CMainWindow::OnChar, looks space, plays first legal move, or pushes button

****************************************************************************/

void CMainWindow::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    // We know the cast below is legal because position 0 is always
    // the local human.

    local_human *p0 = (local_human *)p[0];

    int mode = p0->GetMode();

    if ((nChar != (UINT)' ') || (p0->IsTimerOn()))
        return;

    if (mode != PLAYING)
        return;

    p0->SetMode(WAITING);

    POINT loc;

    for (SLOT s = 0; s < MAXSLOT; s++)
    {
        if (p0->GetCardLoc(s, loc))
        {
            if (p0->PlayCard(loc.x, loc.y, handinfo, bCheating, FALSE))
            {
                return;
            }
        }
    }

    p0->SetMode(PLAYING);
}


/****************************************************************************

CMainWindow::OnCheat -- toggles bCheating used to show all cards face up.

****************************************************************************/

void CMainWindow::OnCheat()
{
    RegEntry    Reg(szRegPath);
    const TCHAR val[] = TEXT("ZB");
    TCHAR        buf[20];

    Reg.GetString(val, buf, sizeof(buf));
    if (buf[0] != TEXT('4') || buf[1] != TEXT('2'))
        return;

    bCheating = !bCheating;
    InvalidateRect(NULL, TRUE);     // redraw main hearts window

    CMenu *pMenu = GetMenu();
    pMenu->CheckMenuItem(IDM_CHEAT, bCheating ? MF_CHECKED : MF_UNCHECKED);
}


/****************************************************************************

CMainWindow::OnClose -- cleans up background brush, deletes players, etc.

****************************************************************************/

void CMainWindow::OnClose()
{
    m_BgndBrush.DeleteObject();

    for (int i = 0; i < 4; i++)
    {
        if (p[i])
        {
            delete p[i];
            p[i] = NULL;
        }
    }


    ::HtmlHelp(::GetDesktopWindow(), szHelpFileName, HH_CLOSE_ALL, 0);

    {
        RegEntry Reg(szRegPath);
        Reg.FlushKey();
    }

    DestroyWindow();
}


/****************************************************************************

CMainWindow::OnCreate -- creates pass button child window & player objects.
                         also initializes some of the data members

****************************************************************************/

int CMainWindow::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    ::pMainWnd = this;

    if (!bConstructed)
    {
        FatalError(IDS_MEMORY);
        return -1;
    }

    // Check for existence of cards.dll

    SetErrorMode(SEM_NOOPENFILEERRORBOX);
    HINSTANCE hCardsDLL = LoadLibrary(TEXT("CARDS.DLL"));
    if (hCardsDLL < (HINSTANCE)HINSTANCE_ERROR)
    {
        FatalError(IDS_CARDSDLL);
        bConstructed = FALSE;
        return -1;
    }
    ::FreeLibrary(hCardsDLL);

    CClientDC dc(this);
    TEXTMETRIC  tm;

    ::srand((unsigned) ::time(NULL));       // set rand() seed

    dc.GetTextMetrics(&tm);
    int nTextHeight = tm.tmHeight + tm.tmExternalLeading;
    m_StatusHeight = nTextHeight + 11;
    GetClientRect(m_TableRect);

    m_TableRect.bottom -= m_StatusHeight;

    bConstructed = TRUE;

    // Player 0 is constructed as the gamemeister.  This
    // initializes lots of good stuff which is used later.
    // If player 0 doesn't happen to be a real gamemeister,
    // this gets fixed up in OnWelcome().

    p[0] = new local_human(0);      // display status bar

    if (p[0] == NULL)
    {
        bConstructed = FALSE;
        return -1;
    }

    // Construct pushbutton

    int cxChar = tm.tmAveCharWidth;
    int cyChar = tm.tmHeight + tm.tmExternalLeading;
    int nWidth = (60 * cxChar) / 4;
    int nHeight = (14 * cyChar) / 8;
    int x = (m_TableRect.right / 2) - (nWidth / 2);
    int y = m_TableRect.bottom - card::dyCrd - (2 * POPSPACING) - nHeight;
    CRect rect;
    rect.SetRect(x, y, x+nWidth, y+nHeight);

    if (!m_Button.Create(TEXT(""), WS_CHILD | BS_PUSHBUTTON, rect, this, IDM_BUTTON))
    {
        bConstructed = FALSE;
        return -1;
    }

    // check for sound capability

    RegEntry    Reg(szRegPath);

    bHasSound = SoundInit();
    if (bHasSound)
    {
        if (Reg.GetNumber(regvalSound, FALSE))
        {
            CMenu *pMenu = GetMenu();
            pMenu->CheckMenuItem(IDM_SOUND, MF_CHECKED);
            bSoundOn = TRUE;
        }
    }
    else
    {
        CMenu *pMenu = GetMenu();
        pMenu->EnableMenuItem(IDM_SOUND, MF_GRAYED);
    }

    card c;
    int  nStepSize;
    DWORD dwSpeed = Reg.GetNumber(regvalSpeed, IDC_NORMAL);

    if (dwSpeed == IDC_FAST)
        nStepSize = 60;
    else if (dwSpeed == IDC_SLOW)
        nStepSize = 5;
    else
        nStepSize = 15;

    c.SetStepSize(nStepSize);

    return (bConstructed ? 0 : -1);
}


/****************************************************************************

CMainWindow::OnEraseBkgnd -- required to draw background green

****************************************************************************/

BOOL CMainWindow::OnEraseBkgnd(CDC *pDC)
{
    if (!m_BgndBrush.m_hObject)         // if background brush is not valid
        return FALSE;

    m_BgndBrush.UnrealizeObject();
    CBrush *pOldBrush = pDC->SelectObject(&m_BgndBrush);
    pDC->PatBlt(0, 0, WINWIDTH, WINHEIGHT, PATCOPY);
    pDC->SelectObject(pOldBrush);
    return FALSE;
}



/****************************************************************************

CMainWindow::OnLButtonDown

Handles human selecting card to play or pass.

****************************************************************************/

void CMainWindow::OnLButtonDown(UINT nFlags, CPoint point)
{
    // We know the cast below is legal because position 0 is always
    // the local human.

#ifdef USE_MIRRORING
    CRect rect;
	DWORD ProcessDefaultLayout;
	if (GetProcessDefaultLayout(&ProcessDefaultLayout))
		if (ProcessDefaultLayout == LAYOUT_RTL)
		{
    	GetClientRect(&rect);
		point.x = rect.right - rect.left - point.x;
		}
#endif

    local_human *p0 = (local_human *)p[0];

    if (p0->IsTimerOn())    // ignore mouse clicks if timer running
        return;

    modetype mode = p0->GetMode();

    if (mode == SELECTING)
    {
        p0->PopCard(m_BgndBrush, point.x, point.y);
        return;
    }
    else if (mode != PLAYING)
        return;

    p0->SetMode(WAITING);
    if (p0->PlayCard(point.x, point.y, handinfo, bCheating))    // valid card?
        return;

    // move wasn't legal, so back to PLAYING mode

    p0->SetMode(PLAYING);
}


/****************************************************************************

CMainWindow::OnNewGame

****************************************************************************/

void CMainWindow::OnNewGame()
{
    passdir = LEFT;                 // each new game must start with LEFT

    bAutostarted = FALSE;           // means dealer has agreed to play at least

    CMenu *pMenu = GetMenu();
    pMenu->EnableMenuItem(IDM_NEWGAME, MF_GRAYED);

    if (role == GAMEMEISTER)
    {

        BOOL    bNewPlayers = FALSE;

        for (int i = 1; i < MAXPLAYER; i++)
        {
            if (!p[i])
            {
                bNewPlayers = TRUE;
                p[i] = new computer(i);
                if (!p[i])
                {
                    bConstructed = FALSE;
                    return;
                }
            }
        }

        m_gamenumber = ::rand();
    }

    ResetHandInfo(-1);

    ::srand(m_gamenumber);

    {
        CScoreDlg score(this);
        score.ResetScore();
    }                           // destruct score

    TRACE1("\n\ngame number is %d\n\n", m_gamenumber);
    DUMP();
    TRACE0("\n\n");

    Shuffle();
}


/****************************************************************************

CMainWindow::OnOptions -- user requests options dialog from menu

****************************************************************************/

void CMainWindow::OnOptions()
{
    COptionsDlg optionsdlg(this);
    optionsdlg.DoModal();
}


/****************************************************************************

CMainWindow::OnPaint

****************************************************************************/

void CMainWindow::OnPaint()
{
    CPaintDC dc( this );
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif

    // players must be painted in order starting with playerled so that
    // cards in centre overlap correctly

    if (bConstructed)
    {
        int start = Id2Pos(handinfo.playerled % 4);

        // check that someone has started

        if (start >= 0)
        {
            for (int i = start; i < (MAXPLAYER+start); i++)
            {
                int pos = i % 4;
                if (p[pos])
                {
                    if (p[pos]->GetMode() == SCORING)
                    {
                        p[pos]->DisplayHeartsWon(dc);
                    }
                    else
                    {
                        p[pos]->Draw(dc, bCheating);
                        p[pos]->MarkSelectedCards(dc);
                    }
                }
            }
        }
    }
}


/****************************************************************************

CMainWindow::OnPass

This function handles the local human pressing the button either to
pass selected cards or to accept cards passed.

****************************************************************************/

void CMainWindow::OnPass()
{
    if (p[0]->GetMode() == ACCEPTING)       // OK (accepting passed cards)
    {
        m_Button.ShowWindow(SW_HIDE);
        m_Button.SetWindowText(TEXT(""));
        p[0]->SetMode(WAITING);             // local human pushed the button

        CRect rect;
        p[0]->GetCoverRect(rect);

        for (SLOT s = 0; s < MAXSLOT; s++)
            p[0]->Select(s, FALSE);

        InvalidateRect(&rect, TRUE);
        UpdateWindow();

        FirstMove();

        return;
    }

    m_Button.EnableWindow(FALSE);
    p[0]->SetMode(DONE_SELECTING);

    BOOL bReady = TRUE;

    for (int i = 1; i < MAXPLAYER; i++)
        if (p[i]->GetMode() != DONE_SELECTING)
            bReady = FALSE;

    if (!bReady)
        p[0]->UpdateStatus(IDS_PASSWAIT);

    if (bReady)
        HandlePassing();
}


/****************************************************************************

CMainWindow::OnRef

After a human or a computer plays a card, they must
PostMessage(WM_COMMAND, IDM_REF)
which causes this routine (the referee) to be called.

Ref does the following:
    - updates handinfo data struct
    - calls HeartsPlaySound() if appropriate
    - determines if the hand is over or, if not, whose turn is next

****************************************************************************/

void CMainWindow::OnRef()
{
    card *c = handinfo.cardplayed[handinfo.turn];

    if (!handinfo.bHeartsBroken)
    {
        if (c->Suit() == HEARTS)
        {
            handinfo.bHeartsBroken = TRUE;
            HeartsPlaySound(SND_BREAK);
        }
    }

    if (c->ID() == BLACKLADY)
    {
        handinfo.bQSPlayed = TRUE;
        HeartsPlaySound(SND_QUEEN);
    }

/* ------------------------------------------------
#if defined(_DEBUG)
    TRACE("[%d] ", m_myid);
    TRACE("h.turn %d, ", handinfo.turn);
    TRACE("led %d, ", handinfo.playerled);
    for (int i = 0; i < 4; i++)
    {
        if (handinfo.cardplayed[i])
            { CDNAME(handinfo.cardplayed[i]); }
        else
            { TRACE("-- "); }
    }
    TRACE("\n",);
#endif
------------------------------------------------ */

    int pos = Id2Pos(handinfo.turn);
    SLOT slot = p[pos]->GetSlot(handinfo.cardplayed[handinfo.turn]->ID());

#if defined(_DEBUG)
    if (p[pos]->IsHuman())
        ((human *)p[pos])->DebugMove(slot);
#endif

    p[pos]->GlideToCentre(slot, pos==0 ? TRUE : bCheating);

    handinfo.turn++;
    handinfo.turn %= 4;

    int newpos = Id2Pos(handinfo.turn);

    if (handinfo.turn == handinfo.playerled)
    {
        EndHand();
    }
    else
    {
        p[newpos]->SelectCardToPlay(handinfo, bCheating);

        if (newpos != 0)
            ((local_human *)p[0])->WaitMessage(p[newpos]->GetName());
    }
}


/****************************************************************************

CMainWindow::OnScore -- user requests score dialog from menu

****************************************************************************/

void CMainWindow::OnScore()
{
    CScoreDlg scoredlg(this);       // this constructor does not add new info
    scoredlg.DoModal();
}


/****************************************************************************

CMainWindow::DoSort

****************************************************************************/

void CMainWindow::DoSort()
{
    for (int i = 0; i < (bCheating ? MAXPLAYER : 1); i++)
    {
        CRect   rect;
        int     id;             // card in play for this player

        if (handinfo.cardplayed[i] == NULL)
            id = EMPTY;
        else
            id = handinfo.cardplayed[i]->ID();

        p[i]->Sort();

        if (id != EMPTY)    // if this player has a card in play, restore it
        {
            for (SLOT s = 0; s < MAXSLOT; s++)
            {
                if (p[i]->GetID(s) == id)
                {
                    handinfo.cardplayed[i] = p[i]->Card(s);
                    break;
                }
            }
        }

        p[i]->GetCoverRect(rect);
        InvalidateRect(&rect, TRUE);
    }
}


/****************************************************************************

CMainWindow::OnSound()

request sound on or off from menu.

****************************************************************************/

void CMainWindow::OnSound()
{
    RegEntry    Reg(szRegPath);

    bSoundOn = !bSoundOn;

    CMenu *pMenu = GetMenu();
    pMenu->CheckMenuItem(IDM_SOUND, bSoundOn ? MF_CHECKED : MF_UNCHECKED);

    if (bSoundOn)
        Reg.SetValue(regvalSound, 1);
    else
        Reg.DeleteValue(regvalSound);
}


/****************************************************************************

CMainWindow::OnPrintClient()

Draw background into the specified HDC.  This is used when drawing
the "Pass" button in the Luna style.

****************************************************************************/

LRESULT CMainWindow::OnPrintClient(WPARAM wParam, LPARAM lParam)
{
    CDC dc;
    CRect rect;

    dc.Attach((HDC)wParam);
    GetClientRect(&rect);
    dc.FillRect(&rect, &m_BgndBrush);
    dc.Detach();
   
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\main2.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

main2.cpp

Aug 92, JimH
May 93, JimH    chico port

Additional member functions for CMainWindow are here.

****************************************************************************/

#include "hearts.h"

#include "main.h"
#include "resource.h"
#include "debug.h"


/****************************************************************************

CMainWindow::Shuffle -- user requests shuffle from menu

****************************************************************************/

void CMainWindow::Shuffle()
{
    static  int offset[MAXPLAYER] = { 1, 3, 2, 0 };     // passdir order

    // fill temp array with consecutive values

    int temp[52];                   // array of card values
    for (int i = 0; i < 52; i++)
        temp[i] = i;

    //  Sort cards

    int nLeft = 52;
    for (i = 0; i < 52; i++)
    {
        int j = ::rand() % nLeft;
        int id = i/13;
        int pos = Id2Pos(id);               // convert id to position
        p[pos]->SetID(i%13, temp[j]);
        p[pos]->Select(i%13, FALSE);
        temp[j] = temp[--nLeft];
    }

    // display PASS button

    if (passdir != NOPASS)
    {
        CString text;
        text.LoadString(IDS_PASSLEFT + passdir);
        m_Button.SetWindowText(text);
        m_Button.EnableWindow(FALSE);
        m_Button.ShowWindow(SW_SHOW);
    }

    // set card locs and ask players to select cards to pass

    for (i = 0; i < MAXPLAYER; i++)
    {
        p[i]->ResetLoc();

        if (passdir != NOPASS)
            p[i]->SelectCardsToPass();
    }

    // Make sure everyone gets appropriate little white dots

    //  Paint main window.  This is done manually instead of just
    //  invalidating the rectangle so that the cards are drawn in
    //  order as if they are dealt, instead of a player at a time.

    CClientDC   dc(this);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
    CRect       rect;
    GetClientRect(rect);
    dc.FillRect(&rect, &m_BgndBrush);

    for (SLOT s = 0; s < MAXSLOT; s++)
        for (i = 0; i < MAXPLAYER; i++)
            p[i]->Draw(dc, bCheating, s);

    for (i = 0; i < MAXPLAYER; i++)
    {
        if (passdir == NOPASS)
            p[i]->NotifyNewRound();
        else
        {
            p[i]->MarkSelectedCards(dc);
            CString sSelect;
            sSelect.LoadString(IDS_SELECT);
            CString sName;
            int passto = (i + offset[passdir]) % 4;
            sName = p[passto]->GetName();
            TCHAR string[100];
            wsprintf(string, sSelect, sName);
            p[i]->UpdateStatus(string);
        }
    }

    DoSort();
}


/****************************************************************************

CMainWindow::HandlePassing()

This function first checks to make sure each player is DONE_SELECTING,
and then transfers the cards from hand to hand.

This function is called by the gamemeister when he presses the pass
button, or when notification arrives that a remote human has selected
cards to pass.

It returns FALSE if cards were not passed (because a remote human was
still selecting) and TRUE if cards were successfully passed.

****************************************************************************/

BOOL CMainWindow::HandlePassing()
{
    int     passto[MAXPLAYER];
    int     temp[MAXPLAYER][3];

    static  int offset[MAXPLAYER] = { 1, 3, 2, 0 };

    for (int pos = 0; pos < MAXPLAYER; pos++)
        if (p[pos]->GetMode() != DONE_SELECTING)
            return FALSE;

    for (pos = 0; pos < MAXPLAYER; pos++)
    {
        passto[pos] = ((pos + offset[passdir]) % 4);
        p[pos]->ReturnSelectedCards(temp[pos]);
    }

    for (pos = 0; pos < MAXPLAYER; pos++)
        p[passto[pos]]->ReceiveSelectedCards(temp[pos]);

    for (pos = 0; pos < MAXPLAYER; pos++)
        if (bCheating || (pos == 0))
            p[pos]->Sort();

    tricksleft = MAXSLOT;

    passdir++;
    if (passdir > NOPASS)
        passdir = LEFT;

    for (pos = 0; pos < MAXPLAYER; pos++)
        p[pos]->NotifyNewRound();           // notify players cards are passed

    CString s;
    s.LoadString(IDS_OK);
    m_Button.SetWindowText(s);
    OnShowButton();

    for (pos = 0; pos < MAXPLAYER; pos++)
    {
        CRect   rect;

        if (pos == 0 || bCheating)
            p[pos]->GetCoverRect(rect);
        else
            p[pos]->GetMarkingRect(rect);

        InvalidateRect(&rect, TRUE);
    }

    UpdateWindow();
    return TRUE;
}


/****************************************************************************

CMainWindow::FirstMove

resets cardswon[] and tells owner of two of clubs to start hand

****************************************************************************/

void CMainWindow::FirstMove()
{
    for (int pos = 0; pos < MAXPLAYER; pos++)
    {
        p[pos]->SetMode(WAITING);
        p[pos]->ResetCardsWon();
    }

    for (pos = 0; pos < MAXPLAYER; pos++)
    {
        for (SLOT s = 0; s < MAXSLOT; s++)
        {
            if (p[pos]->GetID(s) == TWOCLUBS)
            {
                int id = Pos2Id(pos);
                ResetHandInfo(id);
                handinfo.bHeartsBroken = FALSE;
                handinfo.bQSPlayed = FALSE;
                handinfo.bShootingRisk = TRUE;
                handinfo.nMoonShooter = EMPTY;
                handinfo.bHumanShooter = FALSE;
                p[pos]->SelectCardToPlay(handinfo, bCheating);

                if (pos != 0)
                    ((local_human *)p[0])->WaitMessage(p[pos]->GetName());

                return;
            }
        }
    }
}


/****************************************************************************

CMainWindow::EndHand
TimerDispatch
CMainWindow::DispatchCards

The Ref calls this routine at the end of each hand.  It is logically
a single routine, but is broken up so that there is a delay before the
cards are zipped off the screen.

EndHand() calculates who won the hand (trick) and starts a timer.

TimerDispatch() receives the time message and calls DispatchCards().

DispatchCards()

****************************************************************************/

void CMainWindow::EndHand()
{
    /* determine suit led */

    int  playerled = handinfo.playerled;
    card *cardled  = handinfo.cardplayed[playerled];
    int  suitled   = cardled->Suit();
    int  value     = cardled->Value2();

    trickwinner = playerled;               //  by default

    //  Let players update tables, etc.

    for (int i = 0; i < 4; i++)
        p[i]->NotifyEndHand(handinfo);

    // check if anyone else played a higher card of the same suit

    for (i = playerled; i < (playerled+4); i++)
    {
        int j = i % 4;
        card *c = handinfo.cardplayed[j];
        if (c->Suit() == suitled)
        {
            int v = c->Value2();

            if (v > value)
            {
                value = v;
                trickwinner = j;
            }
        }
    }

    TRACE0("\n");

    // Update moonshoot portion of handinfo

    if (handinfo.bShootingRisk)
    {
        BOOL bPoints = FALSE;               // point cards this hand?

        for (i = 0; i < 4; i++)
        {
            card *c = handinfo.cardplayed[i];
            if ((c->Suit() == HEARTS) || (c->ID() == BLACKLADY))
                bPoints = TRUE;
        }

        if (bPoints)
        {
            if (handinfo.nMoonShooter == EMPTY)
            {
                handinfo.nMoonShooter = trickwinner;  // first points this round
                handinfo.bHumanShooter = p[trickwinner]->IsHuman();
                TRACE2("First points to p[%d] (%s)\n", trickwinner,
                    handinfo.bHumanShooter ? TEXT("human") : TEXT("computer"));
            }

            else if (handinfo.nMoonShooter != trickwinner)   // new point earner
            {
                handinfo.bShootingRisk = FALSE;
                TRACE0("Moon shot risk over\n");
            }
        }
    }

    // Start a timer so there is a delay between when the last card of
    // the trick is played, and when the cards are whisked off toward
    // the trick winner (dispatched.)  If the timer fails, just call
    // DispatchCards() directly.  The timer id is m_myid instead of a
    // constant so there's no conflict if you run multiple instances on
    // a single machine using local DDE, which is useful for testing.

    if (SetTimer(m_myid, 1000, TimerDispatch))
        bTimerOn = TRUE;
    else
    {
        bTimerOn = FALSE;
        DispatchCards();
    }
}


// for MFC1, this would return UINT and 3rd parameter would be int
// for MFC2, this would return VOID and 3rd parameter would be UINT

#if defined (MFC1)

inline UINT FAR PASCAL EXPORT
    TimerDispatch(HWND hWnd, UINT nMsg, int nIDEvent, DWORD dwTime)
{
    ::pMainWnd->DispatchCards();  // sneak back into a CMainWindow member func.
    return 0;
}

#else

inline VOID FAR PASCAL EXPORT
    TimerDispatch(HWND hWnd, UINT nMsg, UINT_PTR nIDEvent, DWORD dwTime)
{
    ::pMainWnd->DispatchCards();  // sneak back into a CMainWindow member func.
}

#endif



void CMainWindow::DispatchCards()
{
    KillTimer(m_myid);

    bTimerOn = FALSE;
    int score[MAXPLAYER];

    int poswinner = Id2Pos(trickwinner);

    // Determine who led so cards can be removed in reverse order.

    int  playerled = handinfo.playerled;
    card *cardled  = handinfo.cardplayed[playerled];

    // build up background bitmap for Glide()

    for (int i = (playerled + 3); i >= playerled; i--)
    {
        CDC *memdc = new CDC;
        CClientDC dc(this);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
        memdc->CreateCompatibleDC(&dc);
        memdc->SelectObject(&card::m_bmBgnd);
        memdc->SelectObject(&m_BgndBrush);
        memdc->PatBlt(0, 0, card::dxCrd, card::dyCrd, PATCOPY);
        card *c = handinfo.cardplayed[i % 4];

        // If cards overlap, there is some extra work to do because the cards
        // still in player 0's or 2's hands may overlap cards that have been
        // played, so they have to get blted in first.

        if (TRUE)  // bugbug should be able to check for overlap here
        {
            for (int pos = 0; pos < MAXPLAYER; pos += 2)
            {
                int mode = ((pos == 0 || bCheating) ? FACEUP : FACEDOWN);

                for (SLOT s = 0; s < MAXSLOT; s++)
                {
                    card *c2 = p[pos]->Card(s);
                    int x = c2->GetX() - c->GetX();
                    int y = c2->GetY() - c->GetY();
                    if (!c2->IsPlayed())
                        c2->Draw(*memdc, x, y, mode, FALSE);
                }
            }
        }

        // Everyone needs to check for overlap of played cards.

        for (int j = playerled; j < i; j++)
        {
            card *c2 = handinfo.cardplayed[j % 4];
            int x = c2->GetX() - c->GetX();
            int y = c2->GetY() - c->GetY();
            c2->Draw(*memdc, x, y, FACEUP, FALSE);
        }

        delete memdc;

        p[poswinner]->WinCard(dc, c);
        c->Remove();
    }

    ResetHandInfo(trickwinner);

    // If there are more tricks left before we need to reshuffle,
    // ask the winner of this trick to start next hand, and we're done.

    if (--tricksleft)
    {
        p[poswinner]->SelectCardToPlay(handinfo, bCheating);

        if (poswinner != 0)
            ((local_human *)p[0])->WaitMessage(p[poswinner]->GetName());

        return;
    }

    // Make sure sound buffer is freed up.

    HeartsPlaySound(OFF);

    // Display hearts (and queen of spades) next to whoever "won" them.

    int nMoonShot = EMPTY;                  // assume nobody shot moon
    for (i = 0; i < MAXPLAYER; i++)
    {
        BOOL bMoonShot;
        score[i] = p[i]->EvaluateScore(bMoonShot);
        if (bMoonShot)
            nMoonShot = i;                  // scores need to be adjusted

        CClientDC dc(this);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
        p[i]->DisplayHeartsWon(dc);
        p[i]->SetMode(SCORING);
    }

    // adjust scores if someone collected all hearts AND queen of spades

    if (nMoonShot != EMPTY)
    {
        for (i = 0; i < MAXPLAYER; i++)
        {
            if (i == nMoonShot)
                score[i] -= 26;
            else
                score[i] += 26;

            p[i]->SetScore(score[i]);       // adjust player score manually
        }
    }

    // Show score

    p[0]->UpdateStatus(IDS_SCORE);
    p[0]->SetMode(SCORING);
    CScoreDlg scoredlg(this, score, m_myid);    // update scores in scoredlg

    player *pold = p[0];

    scoredlg.DoModal();                         // display scores

    // If there has been a request to shut down while the score dialog
    // is displayed, m_FatalErrno will be non-zero.

    if (m_FatalErrno != 0)
    {
        p[0]->SetMode(PLAYING);         // something other than SCORING...
        FatalError(m_FatalErrno);       // so FatalError will accept it.
        return;
    }

    // It's possible for another player to have quit the game while
    // the score dialog was showing, so check that we're still
    // alive and well.

    if (p[0] != pold)
        return;

    // replace quit remote humans with computer players

    for (i = 1; i < MAXPLAYER; i++)
    {
        if (p[i]->HasQuit())
        {
            CString name = p[i]->GetName();
            int scoreLocal = p[i]->GetScore();
            delete p[i];
            p[i] = new computer(i);             // check for failure
            CClientDC dc(this);
            p[i]->SetName(name, dc);
            p[i]->SetScore(scoreLocal);
        }
    }

    p[0]->SetMode(passdir == NOPASS ? DONE_SELECTING : SELECTING);

    if (scoredlg.IsGameOver())
    {
        GameOver();
        return;
    }

    Shuffle();

    // If there is no passing for upcoming round, we must make the changes
    // that HandlePassing() would normally do to start the next round.

    if (passdir == NOPASS)
    {
        for (i = 0; i < MAXPLAYER; i++)         // everyone's DONE_SELECTING
            p[i]->SetMode(DONE_SELECTING);

        passdir = LEFT;                         // NEXT hand passes left
        tricksleft = MAXSLOT;                   // reset # of hands
        FirstMove();                            // start next trick
    }

}


/****************************************************************************

CMainWindow::ResetHandInfo

Note that handinfo.bHeartsBroken is not reset here -- it applies to
the entire hand and is set only in FirstMove()

Same with handinfo.bQSPlayed and moonshoot variables.

****************************************************************************/

void CMainWindow::ResetHandInfo(int playernumber)
{
    handinfo.playerled = playernumber;
    handinfo.turn      = playernumber;
    for (int i = 0; i < MAXPLAYER; i++)
        handinfo.cardplayed[i] = NULL;
}


/****************************************************************************

CMainWindow::CountClients()

Count of number of clients active (including computer players)
Only the GameMeister calls this, so potential clients are pos 1 to 3.

****************************************************************************/

int CMainWindow::CountClients()
{
    ASSERT(role == GAMEMEISTER);

    int cb = 0;

    for (int pos = 1; pos < MAXPLAYER; pos++)
        if (p[pos])
            cb++;

    return cb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\player.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

player.h

Aug 92, JimH
May 93, JimH    chico port

Header file for class player

hierarchy:              player
                      /       \
                 computer     human
                             /     \
                   local_human     remote_human

note: player and human are abstract classes.

    pos == 0 implies local human
    id  == 0 implies gamemeister

Relative to any human player, positions (pos) are arranged like this:

        2
      1   3
        0

If the human is the gamemeister, these are also the id's.

****************************************************************************/

#include "card.h"
#include "debug.h"

#ifndef	PLAYER_INC
#define	PLAYER_INC

const int   HORZSPACING = 15;
const int   VERTSPACING = 15;
const int   IDGE        = 3;        // EDGE was defined as something else
const int   MAXCARDSWON = 14;

typedef     int     SLOT;

enum modetype { STARTING,
                SELECTING,
                DONE_SELECTING,
                WAITING,
                ACCEPTING,
                PLAYING,
                SCORING
              };

const int   MAXSLOT     = 13;

const int   ALL         = -1;

struct handinfotype {
    int     playerled;              // id of player led
    int     turn;                   // whose turn?  (0 to 3)
    card    *cardplayed[4];         // cards in play for each player
    BOOL    bHeartsBroken;          // hearts broken in this hand?
    BOOL    bQSPlayed;              // Queen of Spades played yet?
    BOOL    bShootingRisk;          // someone trying to shoot the moon?
    int     nMoonShooter;           // id of potential shooter
    BOOL    bHumanShooter;          // is nMoonShooter a human player?
};

/* timer callback */

#if defined (MFC1)
UINT FAR PASCAL EXPORT TimerBadMove(HWND hWnd, UINT nMsg, int nIDEvent, DWORD dwTime);
#else
void FAR PASCAL EXPORT TimerBadMove(HWND hWnd, UINT nMsg, UINT nIDEvent, DWORD dwTime);
#endif

class CMainWindow;

class player {

    private:
        CString     name;
        CFont       font;

    protected:
        int         id;                     // position relative to gamemeister
        int         position;               // position relative to you
        int         score;
        card        cd[MAXSLOT];
        POINT       loc;                    // location of cd[0]
        int         dx, dy;                 // offset for rest of cards
        POINT       playloc;                // played cards glided to here
        POINT       homeloc;                // won cards glided to here
        POINT       dotloc;                 // location of cd[0] "selected" dot
        POINT       nameloc;                // location of name
        modetype    mode;
        int         status;

        int         cardswon[MAXCARDSWON];
        int         numcardswon;

    public:
        player(int n, int pos);
        virtual ~player() { }               // required for ~local_human

        card    *Card(int s) { return &(cd[s]); }
        void    DisplayHeartsWon(CDC &dc);
        void    DisplayName(CDC &dc);
        int     EvaluateScore(BOOL &bMoonShot);
        BOOL    GetCardLoc(SLOT s, POINT& loc);
        SLOT    GetSlot(int id);
        CRect   &GetCoverRect(CRect& rect);
        int     GetID(SLOT slot) { return cd[slot].ID(); }
        CRect   &GetMarkingRect(CRect& rect);
        modetype GetMode() { return mode; }
        CString GetName() { return name; }
        int     GetScore() { return score; }
        void    GlideToCentre(SLOT s, BOOL bFaceup);
        void    MarkCardPlayed(SLOT s)      { cd[s].Play(); }
        void    ResetCardsWon(void);
        void    ResetLoc(void);
        void    ReturnSelectedCards(int c[]);
        void    Select(SLOT slot, BOOL bSelect)
                            { cd[slot].Select(bSelect); }
        void    SetID(SLOT slot, int id) { cd[slot].SetID(id); }
        void    SetMode(modetype m) { mode = m; }
        void    SetName(CString& newname, CDC& dc);
        void    SetScore(int s)     { score = s; }
        void    SetStatus(int s)    { status = s; }
        void    Sort(void);
        void    WinCard(CDC &dc, card *c);

        virtual void Draw(CDC &dc, BOOL bCheating = FALSE, SLOT slot = ALL);
        virtual BOOL IsHuman()      { return FALSE; }
        virtual void MarkSelectedCards(CDC &dc);
        virtual void NotifyEndHand(handinfotype &h) = 0;
        virtual void NotifyNewRound(void) = 0;

        virtual void ReceiveSelectedCards(int c[]);
        virtual void SelectCardsToPass(void) = 0;
        virtual void SelectCardToPlay(handinfotype &h, BOOL bCheating) = 0;

        virtual void UpdateStatus(void) = 0;
        virtual void UpdateStatus(int stringid) = 0;
        virtual void UpdateStatus(const TCHAR *string) = 0;

        virtual void Quit()     { }
        virtual BOOL HasQuit()  { return FALSE; }
};

class human : public player {

    private:

    protected:
        human(int n, int pos);

    public:
        virtual BOOL IsHuman()  { return TRUE; }

#if defined(_DEBUG)
        void    DebugMove(SLOT slot) { \
              TRACE1("<%d> human decides to ", id); PLAY(slot); TRACE0("\n"); }
#endif

};

class local_human : public human {

#if defined (MFC1)
    friend UINT FAR PASCAL EXPORT TimerBadMove(HWND, UINT, int, DWORD);
#else
    friend void FAR PASCAL EXPORT TimerBadMove(HWND, UINT, UINT_PTR, DWORD);
#endif

    protected:
        CBitmap m_bmStretchCard;                // bitmap for card + pop length
        CStatusBarCtrl *m_pStatusWnd;

        int     XYToCard(int x, int y);
        void    StartTimer(card &c);

        static  BOOL    bTimerOn;
        static  CString m_StatusText;

    public:
        local_human(int n);
        ~local_human();

        BOOL IsTimerOn() { return bTimerOn; }
        BOOL PlayCard(int x, int y, handinfotype &h, BOOL bCheating,
                        BOOL bFlash = TRUE);
        void PopCard(CBrush &brush, int x, int y);
        void SetPlayerId(int n)         { id = n; }
        void WaitMessage(const TCHAR *name);

        virtual void Draw(CDC &dc, BOOL bCheating = FALSE, SLOT slot = ALL);
        virtual void MarkSelectedCards(CDC &dc) { return; }
        virtual void NotifyEndHand(handinfotype &h) { return; }
        virtual void NotifyNewRound(void) { return; }
        virtual void ReceiveSelectedCards(int c[]);
        virtual void SelectCardsToPass(void);
        virtual void SelectCardToPlay(handinfotype &h, BOOL bCheating);
        virtual void UpdateStatus(void);
        virtual void UpdateStatus(int stringid);
        virtual void UpdateStatus(const TCHAR *string);
};

#endif	// PLAYER_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\player.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

player.cpp

Aug 92, JimH
May 93, JimH    chico port

Methods for player objects

****************************************************************************/

#include "hearts.h"

#include "main.h"                           // friendly access
#include "resource.h"
#include "debug.h"

#include <stdlib.h>                         // qsort() prototype
#include <stdio.h>


extern "C" {                                // compare routine for qsort()
int __cdecl CompareCards(card *c1, card *c2);
}


/****************************************************************************

player::player

****************************************************************************/

player::player(int n, int pos) : id(n), position(pos)
{
    // Set up font
    BYTE charset = 0;
    int	fontsize = 0; 
    CString fontname, charsetstr, fontsizestr;
    fontname.LoadString(IDS_FONTFACE);
    charsetstr.LoadString(IDS_CHARSET);
    fontsizestr.LoadString(IDS_FONTSIZE);
    charset = (BYTE)_ttoi(charsetstr);
    fontsize = _ttoi(fontsizestr);
    font.CreateFont(fontsize, 0, 0, 0, 700, 0, 0, 0, charset, 0, 0, 0, 0, fontname);

    CRect   rect = CMainWindow::m_TableRect;

    POINT centre;
    const int offset = 30;          // offset from centre for playloc

    mode = STARTING;

    centre.x = (rect.right / 2) - (card::dxCrd / 2);
    centre.y = (rect.bottom / 2) - (card::dyCrd / 2);
    playloc = centre;
    score = 0;

    CClientDC dc(::pMainWnd);
    TEXTMETRIC  tm;
    dc.GetTextMetrics(&tm);
    int nTextHeight = tm.tmHeight + tm.tmExternalLeading;

    switch (position) {
        case 0:
            loc.x = (rect.right - (12 * HORZSPACING + card::dxCrd)) / 2;
            loc.y = rect.bottom - card::dyCrd - IDGE;
            dx = HORZSPACING;
            dy = 0;
            playloc.x -= 5;
            playloc.y += offset;
            dotloc.x = loc.x + (HORZSPACING / 2);
            dotloc.y = loc.y - IDGE;
            homeloc.x = playloc.x;
            homeloc.y = rect.bottom + card::dyCrd;
            nameloc.x = loc.x + card::dxCrd + IDGE;
            nameloc.y = rect.bottom - nTextHeight - IDGE;
            break;

        case 1:
            loc.x = 3 * IDGE;
            loc.y = (rect.bottom - (12 * VERTSPACING + card::dyCrd)) / 2;
            dx = 0;
            dy = VERTSPACING;
            playloc.x -= offset;
            playloc.y -= 5;
            dotloc.x = loc.x + card::dxCrd + IDGE;
            dotloc.y = loc.y + (VERTSPACING / 2);
            homeloc.x = -card::dxCrd;
            homeloc.y = playloc.y;
            nameloc.x = loc.x + 2;
            nameloc.y = loc.y - nTextHeight;
            break;

        case 2:
            loc.x = ((rect.right - (12 * HORZSPACING + card::dxCrd)) / 2)
                    + (12 * HORZSPACING);
            loc.y = IDGE;
            dx = -HORZSPACING;
            dy = 0;
            playloc.x += 5;
            playloc.y -= offset;
            dotloc.x = loc.x + card::dxCrd - (HORZSPACING / 2);
            dotloc.y = loc.y + card::dyCrd + IDGE;
            homeloc.x = playloc.x;
            homeloc.y = -card::dyCrd;
            nameloc.x = ((rect.right - (12 * HORZSPACING + card::dxCrd)) / 2)
                        + (12 * HORZSPACING) + card::dxCrd + IDGE;
            nameloc.y = IDGE;
            break;

        case 3:
            loc.x = rect.right - (card::dxCrd + (3 * IDGE));
            loc.y = ((rect.bottom - (12 * VERTSPACING + card::dyCrd)) / 2)
                   + (12 * VERTSPACING);
            dx = 0;
            dy = -VERTSPACING;
            playloc.x += offset;
            playloc.y += 5;
            dotloc.x = loc.x - IDGE;
            dotloc.y = loc.y + card::dyCrd - (VERTSPACING / 2);
            homeloc.x = rect.right;
            homeloc.y = playloc.y;
            nameloc.x = ((rect.right - (12 * HORZSPACING + card::dxCrd)) / 2)
                         - IDGE - 2;
            nameloc.y = ((rect.bottom - (12 * VERTSPACING + card::dyCrd)) / 2)
                   + (12 * VERTSPACING) + card::dyCrd;
            break;
    }

    ResetLoc();
}


/****************************************************************************

player::ResetLoc

This routine puts cards in locations based on their slot number.
It is used to initialize their x,y locs, or after cards have been sorted.

****************************************************************************/

void player::ResetLoc()
{
    int x = loc.x;
    int y = loc.y;

    for (SLOT s = 0; s < MAXSLOT; s++)
    {
        if (cd[s].IsInHand())
            cd[s].SetLoc(x, y);
        x += dx;
        y += dy;
    }
}


/****************************************************************************

player::Sort

****************************************************************************/

void player::Sort()
{
    qsort( (void *)cd,
	   MAXSLOT,
	   sizeof(card),
	   (int (__cdecl *)(const void *, const void *))CompareCards );

    ResetLoc();
}


/****************************************************************************

CompareCards

This is the compare function for player::Sort.

Aces are high, cards not in hand sort high, and order of suits is
clubs, diamonds, spades, hearts (alternating colours)

****************************************************************************/

int __cdecl CompareCards(card *c1, card *c2)
{
    int v1 = c1->Value2();
    int v2 = c2->Value2();
    int s1 = c1->Suit();
    int s2 = c2->Suit();

    if (!(c1->IsInHand()))
        v1 = EMPTY;

    if (!(c2->IsInHand()))
        v2 = EMPTY;

    if (v1 == EMPTY || v2 == EMPTY)
    {
        if (v1 == v2)                   // they're both EMPTY
            return 0;
        else if (v1 == EMPTY)
            return 1;
        else
            return -1;
    }

    if (s1 != s2)                           // different suits?
    {
        if (s1 == HEARTS && s2 == SPADES)   // these two suits reversed
            return 1;
        else if (s1 == SPADES && s2 == HEARTS)
            return -1;
        else
            return (s1 - s2);
    }

    return (v1 - v2);
}


/****************************************************************************

player::GetSlot

converts a card id to a slot number

****************************************************************************/

SLOT player::GetSlot(int id)
{
    SLOT s = EMPTY;

    for (int num = 0; num < MAXSLOT; num++)
    {
        if (GetID(num) == id)
        {
            s = num;
            break;
        }
    }

    ASSERT(s != EMPTY);
    return s;
}


/****************************************************************************

player::GetCardLoc

Loc gets location of upper-left corner of specified card slot.
Returns true if slot s is valid.

****************************************************************************/

BOOL player::GetCardLoc(SLOT s, POINT& loc)
{
    if (!cd[s].IsValid())
        return FALSE;

    loc.x = cd[s].GetX();
    loc.y = cd[s].GetY();

    return TRUE;
}


/****************************************************************************

player::GetCoverRect

returns a rect that covers all cards in hand

****************************************************************************/

CRect &player::GetCoverRect(CRect& rect)
{
    rect.left  = (dx < 0 ? loc.x + 12 * dx : loc.x);
    rect.right = rect.left + (dx != 0 ?
                      card::dxCrd + 12 * abs(dx) : card::dxCrd);
    rect.top   = (dy < 0 ? loc.y + 12 * dy : loc.y);
    rect.bottom = rect.top + (dy != 0 ?
                      card::dyCrd + 12 * abs(dy) : card::dyCrd);

    // expand rect to include selection indicators

    if (position == 0)
        rect.top -= POPSPACING;
    else if (position == 1)
        rect.right += 2 * IDGE;
    else if (position == 2)
        rect.bottom += 2 * IDGE;
    else
        rect.left -= 2 * IDGE;

    return rect;
}


/****************************************************************************

rect::GetMarkingRect

returns a rect that covers all selection marking dots

****************************************************************************/

CRect &player::GetMarkingRect(CRect& rect)
{
    rect.left   = (dx < 0 ? dotloc.x + (12 * dx) : dotloc.x);
    rect.right  = (dx < 0 ? dotloc.x + 2 : dotloc.x + (12 * dx) + 2);
    rect.top    = (dy < 0 ? dotloc.y + (12 * dy) : dotloc.y);
    rect.bottom = (dy < 0 ? dotloc.y + 2 : dotloc.y + (12 * dy) + 2);

    return rect;
}


/****************************************************************************

player::Draw

Draws all the cards belonging to this player.  bCheating defaults to
FALSE, and SLOT defaults to ALL.

****************************************************************************/

void player::Draw(CDC &dc, BOOL bCheating, SLOT slot)
{
    DisplayName(dc);
    SLOT start = (slot == ALL ? 0 : slot);
    SLOT stop  = (slot == ALL ? MAXSLOT : slot+1);

    SLOT playedslot = EMPTY;            // must draw cards in play last for EGA

    for (SLOT s = start; s < stop; s++)
    {
        if (cd[s].IsPlayed())
            playedslot = s;             // save and draw later
        else if (bCheating)
            cd[s].Draw(dc);
        else
            cd[s].Draw(dc, FACEDOWN);
    }

    if (playedslot != EMPTY)
        cd[playedslot].Draw(dc);
}

void player::DisplayName(CDC &dc)
{
    CFont *oldfont = dc.SelectObject(&font);
    dc.SetBkColor(::pMainWnd->GetBkColor());
    dc.TextOut(nameloc.x, nameloc.y, name, name.GetLength());
    dc.SelectObject(oldfont);
}

void player::SetName(CString& newname, CDC& dc)
{
    static RECT rect;               // client rect of main window
    static BOOL bFirst = TRUE;      // first time through this routine?

    if (bFirst)
        ::pMainWnd->GetClientRect(&rect);

    if (rect.right > 100)           // app started non-iconic
        bFirst = FALSE;

    name = newname;
    CFont *oldfont = dc.SelectObject(&font);
    if (position == 0)
    {
        CSize size = dc.GetTextExtent(name, name.GetLength());
        nameloc.x = ((rect.right - (12 * HORZSPACING + card::dxCrd)) / 2)
                        - IDGE - size.cx;
    }
    else if (position == 3)
    {
        CSize size = dc.GetTextExtent(name, name.GetLength());
        nameloc.x = rect.right - size.cx - (3*IDGE) - 2;
    }
    dc.SelectObject(oldfont);
}

/****************************************************************************

player::ReturnSelectedCards
player::ReceiveSelectedCards

When cards are passed from player to player, the first function is used
to return the selected cards.  The second is used to pass another player's
selections in.

****************************************************************************/

void player::ReturnSelectedCards(int c[])
{
    c[0] = EMPTY;               // default
    c[1] = EMPTY;
    c[2] = EMPTY;

    if (mode == STARTING || mode == SELECTING)
        return;

    for (int i = 0, j = 0; j < 3; i++)
    {
        if (cd[i].IsSelected())
            c[j++] = cd[i].ID();

        if (i >= MAXSLOT)
            { ASSERT(i < MAXSLOT); }
    }
}

void player::ReceiveSelectedCards(int c[])
{
    for (int i = 0, j = 0; j < 3; i++)
    {
        if (cd[i].IsSelected())
        {
            cd[i].SetID(c[j++]);
            cd[i].Select(FALSE);
        }
        ASSERT(i < MAXSLOT);
    }

    SetMode(WAITING);
}


/****************************************************************************

player::MarkSelectedCards

This virtual function puts white dots beside selected cards for all
non-local_human players.

****************************************************************************/

void player::MarkSelectedCards(CDC &dc)
{
    COLORREF color = RGB(255, 255, 255);

    for (int s = 0; s < MAXSLOT; s++)
    {
        if (cd[s].IsSelected())
        {
            int x = dotloc.x + (s * dx);
            int y = dotloc.y + (s * dy);
            dc.SetPixel(x, y, color);
            dc.SetPixel(x+1, y, color);
            dc.SetPixel(x, y+1, color);
            dc.SetPixel(x+1, y+1, color);
        }
    }
}


/****************************************************************************

player::GlideToCentre

This function takes a selected card and glides it to its play location.
The other normal cards (cards still in hand) are each checked to see if
the card is to be moved.  If so, their image is drawn into the background
bitmap.

****************************************************************************/

void player::GlideToCentre(SLOT s, BOOL bFaceup)
{
    CRect rectCard, rectSrc, rectDummy;

    CClientDC dc(::pMainWnd);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif

    CDC *memdc = new CDC;
    memdc->CreateCompatibleDC(&dc);

    memdc->SelectObject(&card::m_bmBgnd);
    memdc->SelectObject(&CMainWindow::m_BgndBrush);
    memdc->PatBlt(0, 0, card::dxCrd, card::dyCrd, PATCOPY);

    cd[s].GetRect(rectCard);

    for (SLOT i = 0; i < MAXSLOT; i++)
    {
        if (cd[i].IsNormal() && (i != s))
        {
            cd[i].GetRect(rectSrc);
            if (IntersectRect(&rectDummy, &rectSrc, &rectCard))
            {
                cd[i].Draw(*memdc,                      // CDC
                           rectSrc.left-rectCard.left,  // x
                           rectSrc.top-rectCard.top,    // y
                           bFaceup ? FACEUP : FACEDOWN, // mode
                           FALSE);                      // don't update loc
            }
        }
    }
    delete memdc;               // must delete before Glide() called

    cd[s].CleanDraw(dc);
    cd[s].Glide(dc, playloc.x, playloc.y);          // glide to play location
    cd[s].Play();                                   // mark card as played

    SetMode(WAITING);
}


/****************************************************************************

player::ResetCardsWon

cardswon[] keeps track of point cards won this hand.  This function
clears this data for a new hand.

****************************************************************************/

void player::ResetCardsWon()
{
    for (int i = 0; i < MAXCARDSWON; i++)
        cardswon[i] = EMPTY;

    numcardswon = 0;
}


/****************************************************************************

player::WinCard

Cards won in tricks are passed in.  If they are point cards (hearts
or queen on spades) the id is saved in cardswon[].

****************************************************************************/

void player::WinCard(CDC &dc, card *c)
{
    if ((c->IsHeart()) || (c->ID() == BLACKLADY))
        cardswon[numcardswon++] = c->ID();

    RegEntry Reg(szRegPath);
    DWORD    dwSpeed = Reg.GetNumber(regvalSpeed, IDC_NORMAL);

    int oldstep = c->SetStepSize(dwSpeed == IDC_SLOW ? 5 : 30);
    c->Glide(dc, homeloc.x, homeloc.y);
    c->SetStepSize(oldstep);
}


/****************************************************************************

player::EvaluateScore

Points stored in cardswon[] are added to players total score.

****************************************************************************/

int player::EvaluateScore(BOOL &bMoonShot)
{
    for (int i = 0; i < MAXCARDSWON; i++)
    {
        if (cardswon[i] == BLACKLADY)
            score += 13;
        else if (cardswon[i] != EMPTY)
            score++;
    }

    if (cardswon[MAXCARDSWON-1] != EMPTY)   // if player got ALL point cards
        bMoonShot = TRUE;
    else
        bMoonShot = FALSE;

    return score;
}


/****************************************************************************

player::DisplayHeartsWon

****************************************************************************/

void player::DisplayHeartsWon(CDC &dc)
{
    card    c;
    int     x = loc.x;
    int     y = loc.y;

    x += ((MAXCARDSWON - numcardswon) / 2) * dx;
    y += ((MAXCARDSWON - numcardswon) / 2) * dy;

    for (int i = 0; i < numcardswon; i++)
    {
        c.SetID(cardswon[i]);
        c.SetLoc(x, y);
        c.Draw(dc);
        x += dx;
        y += dy;
    }

    DisplayName(dc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\regentry.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991-1994                    **/
/***************************************************************************/


/****************************************************************************

regentry.h

Mar. 94     JimH

Wrapper for registry access


Construct a RegEntry object by specifying the subkey (under
HKEY_CURRENT_USER by default, but can be overridden.)

All member functions are inline so there is minimal overhead.

All member functions (except the destructor) set an internal
error state which can be retrieved with GetError().
Zero indicates no error.

RegEntry works only with strings and DWORDS which are both set
using the overloaded function SetValue()

    SetValue("valuename", "string");
    SetValue("valuename", 42);
    
Values are retrieved with GetString() and GetNumber().  GetNumber()
allows you to specificy a default if the valuename doesn't exist.

DeleteValue() removes the valuename and value pair.

****************************************************************************/

#ifndef REGENTRY_INC
#define REGENTRY_INC

#ifndef STRICT
#define STRICT
#endif

#ifndef ERROR_SUCCESS
#define ERROR_SUCCESS   0
#endif

#include <windows.h>

class RegEntry
{
    public:
        RegEntry(const TCHAR *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
        ~RegEntry()         { if (_bConstructed) RegCloseKey(_hkey); }
        
        long    GetError()  { return _error; }
        long    SetValue(const TCHAR *pszValue, const TCHAR *string);
        long    SetValue(const TCHAR *pszValue, long dwNumber);
        TCHAR * GetString(const TCHAR *pszValue, TCHAR *string, DWORD length);
        long    GetNumber(const TCHAR *pszValue, long dwDefault = 0);
        long    DeleteValue(const TCHAR *pszValue);
        long    FlushKey()  { if (_bConstructed) return RegFlushKey(_hkey);
                              else return NULL; }

    private:
        HKEY    _hkey;
        long    _error;
        long    _bConstructed;

};

inline RegEntry::RegEntry(const TCHAR *pszSubKey, HKEY hkey)
{
    _error = RegCreateKey(hkey, pszSubKey, &_hkey);
    _bConstructed = (_error == ERROR_SUCCESS);
}


inline long RegEntry::SetValue(const TCHAR *pszValue, const TCHAR *string)
{
    if (_bConstructed)
        _error = RegSetValueEx(_hkey, pszValue, 0, REG_SZ,
                    (BYTE *)string, sizeof(TCHAR) * (lstrlen(string)+1));

    return _error;
}

inline long RegEntry::SetValue(const TCHAR *pszValue, long dwNumber)
{
    if (_bConstructed)
        _error = RegSetValueEx(_hkey, pszValue, 0, REG_BINARY,
                    (BYTE *)&dwNumber, sizeof(dwNumber));

    return _error;
}

inline TCHAR *RegEntry::GetString(const TCHAR *pszValue, TCHAR *string, DWORD length)
{
    DWORD    dwType = REG_SZ;
    
    if (!_bConstructed)
        return NULL;

    _error = RegQueryValueEx(_hkey, pszValue, 0, &dwType, (LPBYTE)string,
                &length);

    if (_error)
        *string = '\0';

    return string;
}

inline long RegEntry::GetNumber(const TCHAR *pszValue, long dwDefault)
{
    DWORD    dwType = REG_BINARY;
    long    dwNumber;
    DWORD    dwSize = sizeof(dwNumber);

    if (!_bConstructed)
        return 0;

    _error = RegQueryValueEx(_hkey, pszValue, 0, &dwType, (LPBYTE)&dwNumber,
                &dwSize);
    
    if (_error)
        dwNumber = dwDefault;
    
    return dwNumber;
}

inline long RegEntry::DeleteValue(const TCHAR *pszValue)
{
    if (_bConstructed)
        _error = RegDeleteValue(_hkey, pszValue);
    
    return _error;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\sound.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

sound.cpp

Aug 92, JimH
May 93, JimH    chico port

SoundInit() just verifies that a wave driver is loaded.
HeartsPlaySound() plays the sound given a resource id.

****************************************************************************/


#include "hearts.h"
#include <mmsystem.h>

#include "main.h"
#include "resource.h"
#include "debug.h"


/****************************************************************************

SoundInit()

returns TRUE if sound is enabled.

****************************************************************************/

BOOL CMainWindow::SoundInit()
{
    return (::waveOutGetNumDevs() > 0);
}


/****************************************************************************

CMainWindow::HeartsPlaySound(id)

Plays the specified sound from the resource file.

The static variable hRes is used as a flag to know if memory has been
allocated and locked for the sound.  If hRes is non-zero, a sound is
still playing, or at least the memory for the sound has not been unlocked
and freed.  The application must call HeartsPlaySound(NULL, 0) to free this
memory before exiting.  (The game destructor does this.  It also
happens at the end of each hand.)

****************************************************************************/

BOOL CMainWindow::HeartsPlaySound(int id)
{
    static  HRSRC  hRes = 0;

    if (!bHasSound)                 // check for sound capability
        return TRUE;

    if (id == OFF)                  // request to turn off sound
    {
        if (hRes == 0)              // hRes != 0 if a sound has been played...
            return TRUE;            // and not freed.

        sndPlaySound(NULL, 0);      // make sure sound is stopped
        UnlockResource(hRes);
        FreeResource(hRes);
        hRes = 0;
        return TRUE;
    }

    if (!bSoundOn)                  // has user toggled sound off?
        return TRUE;

    // User has requested a sound.  Check if previous sound was freed.

    if (hRes != 0)
        HeartsPlaySound(OFF);

    BOOL bReturn;

    HINSTANCE hInst = AfxGetInstanceHandle();
    HRSRC  hResInfo = FindResource(hInst, MAKEINTRESOURCE(id), TEXT("WAVE"));
    if (!hResInfo)
        return FALSE;

    hRes = (HRSRC) ::LoadResource(hInst, hResInfo);
    if (!hRes)
        return FALSE;

    LPTSTR lpRes = (LPTSTR) ::LockResource(hRes);
    if (lpRes)
        bReturn = ::sndPlaySound(lpRes, SND_MEMORY | SND_ASYNC | SND_NODEFAULT);
    else
        bReturn = FALSE;

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\reversi\rev.c ===
#include <windows.h>
#include <port1632.h>
#include <process.h>
#include <stdlib.h>
#include "reversi.h"

VOID NEAR PASCAL paintmove(BYTE b[BoardSize], INT move, INT friendly,
        INT enemy);
BOOL NEAR PASCAL msgcheck(VOID);

extern INT     moves[61];
extern INT     BestMove[max_depth+2];
extern HWND    hWin;
extern HDC     hDisp;
extern INT     depth;
extern INT     direc[];


/*       Indexes for computing scores and whether or not a player has       */
/*       any pieces on the board.  Very order dependant.                    */

BYTE PieceFlags[] = {   0x00 ,      /* Ignore sides */
                        0x00 ,      /* Ignore blanks */
                        0x01 ,      /* Human has a piece */
                        0x02 ,      /* Computer has a piece */
                    };

                    
INT Scores[] = { 0, 0 };
INT humanScore = 0;
INT compScroe = 0;

 

BYTE FinalComp[] = {0, 0, -1, 1 };   /* Table for compute # computer pieces */

BYTE FinalHuman[] = {0, 0, 1, -1};   /* Table for compute # human pieces    */

/*
 *       The scoring tables are used to evaluate the board
 *       position.  The corners of the board change value
 *       according to whether a given square is occupied or
 *       not.  This can be done dynamically, saving ~ 1K
 *       worth of data space but costing an as of yet
 *       undetermined performance hit.
 */

#define B11     11    /* Offsets to particular squares */
#define B18     18 
#define B81     81 
#define B88     88 

#define maskb11     0x08    /* Masks used for indexing into Scoring tables. */
#define maskb18     0x04
#define maskb81     0x02
#define maskb88     0x01


INT NEAR PASCAL finalscore(
BYTE b[],
BYTE friendly,
BYTE enemy)
{
    INT i;
    INT count=0;

    for (i=11 ; i<=88 ; i++) {
        if (b[i] == friendly) count++;
        else if (b[i] == enemy) count--;
    }
    if (count > 0)
        return(win +  count);
    else if (count < 0)
        return(loss + count);
    else
        return(0);
}



INT NEAR PASCAL legalcheck(
BYTE b[],
INT move,
BYTE friendly,
BYTE enemy)
{
   INT sq,d;
   INT *p;

   if (b[move] == empty) {
      p=direc;
      while ((d = *p++) != 0) {
          sq=move;
          if (b[sq += d] == enemy) {
             while(b[sq += d] == enemy)
                ;
             if (b[sq] == friendly) return(1);
          }
      }
   }
   return(0);
}


VOID NEAR PASCAL makemove(
BYTE b[],
INT move,
BYTE friendly,
BYTE enemy)
{
   INT sq,d;
   INT *p;

   if (move != PASS) {
      p=direc;
      while ((d = *p++) != 0) {
          sq=move;
          if (b[sq += d] == enemy) {
             while(b[sq += d] == enemy)
                ;
             if (b[sq] == friendly)
                while(b[sq -= d] == enemy)
                   b[sq]=friendly;
          }
      }
      b[move]=friendly;
   }
}


/*

   calculate the value of board

*/
INT NEAR PASCAL score(
BYTE b[],
BYTE friendly,
BYTE enemy)
{
    INT *pvalue;
    BYTE *pb;
    INT fpoints=0;
    INT epoints=0;
    INT ecount=0;
    BYTE bv;
    INT v,b11,b18,b81,b88;

    static INT value[79] = {     99, -8,  8,  6,  6,  8, -8, 99,000,
                                000, -8,-24, -4, -3, -3, -4,-24, -8,000,
                                000,  8, -4,  7,  4,  4,  7, -4,  8,000,
                                000,  6, -3,  4,  0,  0,  4, -3,  6,000,
                                000,  6, -3,  4,  0,  0,  4, -3,  6,000,
                                000,  8, -4,  7,  4,  4,  7, -4,  8,000,
                                000, -8,-24, -4, -3, -3, -4,-24, -8,000,
                                000, 99, -8,  8,  6,  6,  8, -8, 99,infin};

    static INT value2[79]= {     99, -8,  8,  6,  6,  8, -8, 99,000,
                                000, -8,-24,  0,  1,  1,  0,-24, -8,000,
                                000,  8,  0,  7,  4,  4,  7,  0,  8,000,
                                000,  6,  1,  4,  1,  1,  4,  1,  6,000,
                                000,  6,  1,  4,  1,  1,  4,  1,  6,000,
                                000,  8,  0,  7,  4,  4,  7,  0,  8,000,
                                000, -8,-24,  0,  1,  1,  1,-24, -8,000,
                                000, 99, -8,  8,  6,  6,  8, -8, 99,infin};

    pb = &b[11];
    b11 = *pb;
    b18 = b[18];
    b81 = b[81];
    b88 = b[88];

    if ((b11 != empty) || (b18 != empty) || (b81 != empty) || (b88 != empty)) {
        pvalue = value2;

        if (b11 == empty) {
                value2[12-11] = -8;  value2[21-11] = -8;  value2[22-11] = -24;
        } else {
                value2[12-11] = 12;  value2[21-11] = 12;  value2[22-11] = 8;
        }

        if (b18 == empty) {
                value2[17-11] = -8;  value2[28-11] = -8;  value2[27-11] = -24;
        } else {
                value2[17-11] = 12;  value2[28-11] = 12;  value2[27-11] = 8;
        }

        if (b81 == empty) {
                value2[82-11] = -8;  value2[71-11] = -8;  value2[72-11] = -24;
        } else {
                value2[82-11] = 12;  value2[71-11] = 12;  value2[72-11] = 8;
        }

        if (b88 == empty) {
                value2[87-11] = -8;  value2[78-11] = -8;  value2[77-11] = -24;
        } else {
                value2[87-11] = 12;  value2[78-11] = 12;  value2[77-11] = 8;
        }
    } else {
        pvalue = value;
    }

    while((v=*pvalue++) != infin) {
       bv = *pb++;
       if (bv == friendly)
           fpoints += v;
       else if (bv == enemy) {
                   epoints += v;
           ecount++;
       }

    }
    if (!ecount)          /* any enemy pieces on the board? */
       return(win);       /* if not, we just won!                 */
    else
       return(fpoints-epoints);
}



INT NEAR PASCAL minmax(
BYTE b[max_depth + 2][100],
INT move,
BYTE friendly,
BYTE enemy,
INT ply,
INT vmin,
INT vmax)
{
    BYTE *pCurrent, *pPrevious, *pSource, *pDest;
    INT *pMoves;
    INT *pBestMove;
    INT i;
    INT sq, value, cur_move;

    pPrevious = &b[ply][0];
    pCurrent =  &b[ply+1][0];

    pSource = &b[ply][11];
    pDest =   &b[ply+1][11];
    for (i=11 ; i<=88 ; i++) *pDest++=*pSource++;

    pBestMove = &BestMove[ply];
    if (move == PASS) {
        if (ply == depth) {
            pMoves = moves;
            while((sq = *pMoves++) != 0) {
                if (legalcheck(pCurrent,sq,enemy,friendly))
                    return(score(pCurrent,friendly,enemy));
            }
            return(finalscore(pCurrent,friendly,enemy));
        }
    }
    else {
        if (ply == 0) {
	    hDisp = GetDC(hWin);
            paintmove(pCurrent,move,friendly,enemy);
            ReleaseDC(hWin, hDisp);
        }
        else {
            makemove(pCurrent,move,friendly,enemy);
            if (ply == depth) return(score(pCurrent,friendly,enemy));
        }
    }
    pMoves = moves;
    cur_move = PASS;
    *pBestMove = PASS;
    while((sq = *pMoves++) != 0) {
        if (legalcheck(pCurrent,sq,enemy,friendly)) {
           cur_move = sq;
           value = minmax(b,cur_move,enemy,friendly,ply+1,-vmax,-vmin);
           if (value > vmin) {
              vmin = value;
              *pBestMove = cur_move;
              if (value >= vmax) goto cutoff;   /* alpha-beta cutoff */
           }
        }
    }
    if (cur_move == PASS) {
       if (move == PASS)        /* two passes in a row mean game is over */
          return(finalscore(pCurrent,friendly,enemy));
       else {
          value = minmax(b,PASS,enemy,friendly,ply+1,-vmax,-vmin);
          if (value > vmin) vmin = value;
       }
    }
cutoff:
    return(-vmin);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\reversi\reversi.h ===
#define BoardSize           100 
#define edge                0
#define empty               1
#define human               2
#define computer            3
#define infin               32767
#define win                 32000
#define loss                (-32000)
#define max_depth           6

#define PASS                20
#define NEW                 25
#define BSkill              40
#define EASY                41
#define MEDIUM              42
#define HARD                44
#define VHARD               46
#define HINT                50
#define EXIT                52


/* Menu ID's */

#define MN_HELP_INDEX       30
#define MN_HELP_KEYBOARD    31
#define MN_HELP_COMMANDS    32
#define MN_HELP_PLAYING     33
#define MN_HELP_RULES       34
#define MN_HELP_USINGHELP   35
#define MN_HELP_ABOUT       36
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\assert.h ===
#define ASSERTFAILED   999
#define EXIT           2
#define FILE           200
#define GAMENO         203
#define LINE           201
#define OK             1
#define SOLVERSION     202
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\welcome.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/

/****************************************************************************

welcome.cpp

Aug 92, JimH
May 93, JimH    chico port

more CMainWindow member functions


CTheApp::InitInstance() posts a IDM_WELCOME message as soon as it has
constructed and shown the main window.  This file includes that message's
handler (OnWelcome) and some support routines.

****************************************************************************/

#include "hearts.h"

#include "main.h"
#include "resource.h"
#include "debug.h"

/****************************************************************************

CMainWindow::OnWelcome()

Pop up the Welcome dialog.

****************************************************************************/

void CMainWindow::OnWelcome()
{
    // bugbug -- what should "hearts" string really be?

    BOOL    bCmdLine     = (*m_lpCmdLine != '\0');

    bAutostarted = (lstrcmpi(m_lpCmdLine, TEXT("hearts")) == 0);

    if (bAutostarted)
        HeartsPlaySound(SND_QUEEN);       // tell new dealer someone wants to play

    CWelcomeDlg welcome(this);

    if (!bAutostarted && !bCmdLine)
    {
        if (IDCANCEL == welcome.DoModal())  // display Welcome dialog
        {
            PostMessage(WM_CLOSE);
            return;
        }
    }

    if (bAutostarted || welcome.IsGameMeister())    // if Gamemeister
    {
        CClientDC   dc(this);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif
        role = GAMEMEISTER;
        m_myid = 0;
        p[0]->SetStatus(IDS_GMWAIT);

        CString name = welcome.GetMyName();

        if (name.IsEmpty())
            name.LoadString(IDS_DEALER);

        p[0]->SetName(name, dc);
        p[0]->DisplayName(dc);

        PostMessage(WM_COMMAND, IDM_NEWGAME);

        return;
    }
}



/****************************************************************************

CMainWindow::FatalError()

A static BOOL prevents this function from being called reentrantly.  One is
enough, and more than one leaves things in bad states.  The parameter is
the IDS_X constant that identifies the string to display.

There is also a check that we don't try to shut down while the score dialog
is displayed.  This avoids some nasty debug traps when the score dialog
doesn't shut down properly.  The same problems can happen if, say, a dealer
quits when a client is looking at the quote.  Oh well.

****************************************************************************/

void CMainWindow::FatalError(int errorno)
{
    if (p[0]->GetMode() == SCORING)
    {
        m_FatalErrno = errorno;
        return;
    }

    static BOOL bClosing = FALSE;

    if (bClosing)
        return;

    bClosing = TRUE;

    if (errno != -1)                        // if not default
    {
        CString s1, s2;
        s1.LoadString(errno);
        s2.LoadString(IDS_APPNAME);

        if (bSoundOn)
            MessageBeep(MB_ICONSTOP);

        MessageBox(s1, s2, MB_ICONSTOP);    // potential reentrancy problem
    }

    PostMessage(WM_CLOSE);
}


/****************************************************************************

CMainWindow::GameOver

****************************************************************************/

void CMainWindow::GameOver()
{
    CClientDC   dc(this);
#ifdef USE_MIRRORING
	SetLayout(dc.m_hDC, 0);
	SetLayout(dc.m_hAttribDC, 0);
#endif

    InvalidateRect(NULL, TRUE);
    p[0]->SetMode(STARTING);
    p[0]->SetScore(0);

    for (int i = 1; i < MAXPLAYER; i++)
    {
        delete p[i];
        p[i] = NULL;
    }

    if (role == GAMEMEISTER)
    {
        p[0]->SetStatus(IDS_GMWAIT);

        p[0]->DisplayName(dc);
        CMenu *pMenu = GetMenu();
        pMenu->EnableMenuItem(IDM_NEWGAME, MF_ENABLED);

        PostMessage(WM_COMMAND, IDM_NEWGAME);

        return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\mshearts\resource.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991, 1992                   **/
/***************************************************************************/


#define IDM_ABOUT       101
#define IDM_NEWGAME     102
#define IDM_EXIT        103
#define IDM_HELP        106
#define IDM_SEARCH      110
#define IDM_HELPONHELP  112
#define IDM_BOSSKEY     114
#define IDM_BUTTON      115
#define IDM_SHOWBUTTON  116
#define IDM_HIDEBUTTON  117
#define IDM_STATUS      118
#define IDM_REPAINTMSG  119
#define IDM_ALLPASSED   120
#define IDM_CHEAT       121
#define IDM_MENU        122
#define IDM_REF         123
#define IDM_SOUND       124
#define IDM_SCORE       125
#define IDM_WELCOME     126
#define IDM_QUOTE       127
#define IDM_OPTIONS     128

#define IDC_YOURNAME    201
#define IDC_JOIN        202
#define IDC_MEISTER     203
#define IDC_SERVERNAME  204
#define IDC_WELCOMEHELP 205
#define IDC_BLOOD       208
#define IDC_SCORE       209
#define IDC_PLAYER1     210
#define IDC_PLAYER2     211
#define IDC_PLAYER3     212
#define IDC_OPHELP      213
#define IDC_GROUP       214
#define IDC_SLOW        215
#define IDC_NORMAL      216
#define IDC_FAST        217
#define IDC_NAME1       218
#define IDC_NAME2       219
#define IDC_NAME3       220
#define IDC_AUTO        221
#define IDC_AUTOGROUP   222
#define IDC_BROWSE      223
#define IDC_LOCATEHELP  224

#define IDS_MEMORY      301
#define IDS_APPNAME     AFX_IDS_APP_TITLE
#define IDS_P1NAME      303             // P1, P2, & P3NAME must be consecutive
#define IDS_P2NAME      304
#define IDS_P3NAME      305
#define IDS_INTRO       306
#define IDS_SELECT      307
#define IDS_CONNECTING  308
#define IDS_PASSWAIT    309
#define IDS_WAIT        310
#define IDS_GO          311
#define IDS_BADMOVE     312
#define IDS_LEADHEARTS  313
#define IDS_LEAD2C      314
#define IDS_ACCEPT      315
#define IDS_OK          316
#define IDS_SCORE       317
#define IDS_SCORESHEET  318
#define IDS_PLACE1      319
#define IDS_PLACE2      320
#define IDS_PLACE3      321
#define IDS_PLACE4      322

#define IDS_DISCONNECT  323
#define IDS_NOSERVER    324
#define IDS_SERVERFAIL  325
#define IDS_CARDSDLL    326
#define IDS_VERSION     327
#define IDS_PWAIT       328
#define IDS_GMWAIT      329
#define IDS_BUSY        330
#define IDS_TIMEOUT     331
#define IDS_UNKNOWNERR  332
#define IDS_GAMEOVER    333
#define IDS_GAMEOVERWIN 334
#define IDS_NETWORK     335
#define IDS_NOTREADY    336
#define IDS_AGAIN       337
#define IDS_BADBLOOD    338
#define IDS_UNKNOWN     339
#define IDS_DEALER      340

#define IDS_CREDITS     399

#define IDS_SUIT0       401             // these MUST be consecutive values!
#define IDS_SUIT1       402
#define IDS_SUIT2       403
#define IDS_SUIT3       404

#define IDS_PASSLEFT    405             // these MUST be consecutive values!
#define IDS_PASSRIGHT   406
#define IDS_PASSACROSS  407

#define IDS_FONTFACE 	410
#define IDS_CHARSET     411
#define IDS_FONTSIZE    412
#define IDS_STARTMENUNAME 413
#define IDS_INFOTIP     414

#define SND_BREAK       401
#define SND_QUEEN       402
#define SND_QUOTE       403

#define DLG_QUOTE       501
#define DLG_SCORE       502
#define DLG_WELCOME     503
#define DLG_OPTIONS     505
#define DLG_LOCATE      506
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\cdt.h ===
#define CLOADMAX	5

/* Command ids */
#define IDACLUBS	 1
#define ID2CLUBS	 2
#define ID3CLUBS	 3
#define ID4CLUBS	 4
#define ID5CLUBS	 5
#define ID6CLUBS	 6
#define ID7CLUBS	 7
#define ID8CLUBS	 8
#define ID9CLUBS	 9
#define IDTCLUBS	 10
#define IDJCLUBS	 11
#define IDQCLUBS	 12
#define IDKCLUBS	 13

#define IDADIAMONDS	 14
#define ID2DIAMONDS	 15
#define ID3DIAMONDS	 16
#define ID4DIAMONDS	 17
#define ID5DIAMONDS	 18
#define ID6DIAMONDS	 19
#define ID7DIAMONDS	 20
#define ID8DIAMONDS	 21
#define ID9DIAMONDS	 22
#define IDTDIAMONDS	 23
#define IDJDIAMONDS	 24
#define IDQDIAMONDS	 25
#define IDKDIAMONDS	 26

#define IDAHEARTS	 27
#define ID2HEARTS	 28
#define ID3HEARTS	 29
#define ID4HEARTS	 30
#define ID5HEARTS	 31
#define ID6HEARTS	 32
#define ID7HEARTS	 33
#define ID8HEARTS	 34
#define ID9HEARTS	 35
#define IDTHEARTS	 36
#define IDJHEARTS	 37
#define IDQHEARTS	 38
#define IDKHEARTS	 39

#define IDASPADES	 40
#define ID2SPADES	 41
#define ID3SPADES	 42
#define ID4SPADES	 43
#define ID5SPADES	 44
#define ID6SPADES	 45
#define ID7SPADES	 46
#define ID8SPADES	 47
#define ID9SPADES	 48
#define IDTSPADES	 49
#define IDJSPADES	 50
#define IDQSPADES	 51
#define IDKSPADES	 52

#define IDGHOST	53

#define IDFACEDOWN1 	54
#define IDFACEDOWN2 	55
#define IDFACEDOWN3 	56
#define IDFACEDOWN4 	57
#define IDFACEDOWN5 	58
#define IDFACEDOWN6 	59
#define IDFACEDOWN7 	60
#define IDFACEDOWN8 	61
#define IDFACEDOWN9 	62
#define IDFACEDOWN10 	63
#define IDFACEDOWN11 	64
#define IDFACEDOWN12	   65

#define IDFACEDOWNFIRST IDFACEDOWN1
#define IDFACEDOWNLAST IDFACEDOWN12

#define IDX 67
#define IDO 68
#define IDMAX IDDECK



/* internal ID's for animation */

#define IDASLIME1 678
#define IDASLIME2 679

#define IDAKASTL1 680

#define IDAFLIPE1 681
#define IDAFLIPE2 682


#define IDABROBOT1 683
#define IDABROBOT2 684


/* Red non-face card frame */
#define IDFRAME 999


#define FACEUP		0
#define FACEDOWN	1   /* for compatibility with old apps, use IDFACEDOWNFIRST..IDFACEDOWNLAST */
#define HILITE		2
#define GHOST		3
#define REMOVE		4
#define INVISIBLEGHOST 5
#define DECKX		6
#define DECKO		7
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\reversi\reversi.c ===
/****************************************************************************/
/*                                                                          */
/*  Windows Reversi -                                                       */
/*                                                                          */
/*      Originally written by Chris Peters                                  */
/*                                                                          */
/****************************************************************************/

#include "windows.h"
#include <port1632.h>
#include <process.h>
#include <stdlib.h>
#include "reversi.h"

/* Exported procedures called from other modules */
LRESULT APIENTRY ReversiWndProc(HWND, UINT, WPARAM, LPARAM);
VOID APIENTRY InverseMessage(HWND, UINT, UINT_PTR, DWORD);
INT_PTR APIENTRY AboutDlgProc(HWND, UINT, WPARAM, LPARAM);

PSTR    pDisplayMessage;
HBRUSH  hbrBlack;
HBRUSH  hbrPat;
HBRUSH  hbrWhite;
HBRUSH  hbrRed;
HBRUSH  hbrGreen;
HBRUSH  hbrBlue;
HBRUSH  hbrHuman;
HBRUSH  hbrComputer;


HANDLE  hInst;
HANDLE  curIllegal;
HANDLE  curLegal;
HANDLE  curThink;
HANDLE  curBlank;
BOOL    fThinking = FALSE;
BOOL    fCheated = FALSE;
INT     direc[9] = {9, 10, 11, 1, -1, -9, -10, -11, 0};
WORD     prevCheck;
BYTE    board[max_depth+2][BoardSize];
INT     fPass;
INT     flashtimes;
INT     count;
INT     MessageOn;
INT     charheight;
INT     charwidth;
INT     xscr;
CHAR    strBuf[80];
BOOL    bMouseDownInReversi = FALSE;
INT     xExt;
INT     yExt;
INT     Bx;
INT     By;
INT     ASPECT;
INT     COLOR;
INT     TXMIN;
INT     TYMIN = 45;
INT     dimension;
BOOL    ffirstmove;

CHAR    szReversi[20];
CHAR    szReversiPractice[40];
CHAR    szPass[30];
CHAR    szMustPass[30];
CHAR    szTie[30];
CHAR    szLoss[30];
CHAR    szWon[30];
CHAR    szWonPost[30];
CHAR    szLossPost[30];
CHAR    szAbout[20];
CHAR    szIllegal[70];
CHAR    szNoPass[70];
CHAR    szHelpFile[15];

HANDLE  hAccel;

POINT   MousePos;

INT     depth;
INT     BestMove[max_depth+2];
HDC     hDisp;
HWND    hWin;
INT     moves[61] = {11,18,81,88, 13,31,16,61,
                     38,83,68,86, 14,41,15,51,
                     48,84,58,85, 33,36,63,66,
                     34,35,43,46, 53,56,64,65,
                     24,25,42,47, 52,57,74,75,
                     23,26,32,37, 62,67,73,76,
                     12,17,21,28, 71,78,82,87,
                     22,27,72,77,
              0};


INT NEAR PASCAL minmax(BYTE b[max_depth + 2][100], INT move, INT friendly,
    INT enemy, INT ply, INT vmin, INT vmax);
VOID NEAR PASCAL makemove(BYTE b[], INT move, INT friendly, INT enemy);
INT NEAR PASCAL legalcheck(BYTE b[], INT move, INT friendly, INT enemy);


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  UpdateCursor() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* To use UpdateCursor,  set the global var MousePos.x and MousePos.y and make
 * the call.  The cursor will appear at the new position
 */

VOID NEAR PASCAL UpdateCursor(
HWND    hwnd)
{
  POINT curpoint;

  curpoint.x = MousePos.x;
  curpoint.y = MousePos.y;
  ClientToScreen(hwnd, (LPPOINT)&curpoint);
  SetCursorPos(curpoint.x, curpoint.y);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  checkdepth() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL checkdepth(
HWND hWindow,
WORD  d)
{
  HMENU hMenu;

  hMenu = GetMenu(hWindow);
  CheckMenuItem(hMenu, prevCheck, MF_UNCHECKED);
  CheckMenuItem(hMenu, d, MF_CHECKED);
  prevCheck = d;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  clearboard() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL clearboard(
BYTE b[max_depth+2][BoardSize])
{
  register INT  i,j;
  INT           k;

  for (i=0; i<=max_depth ; i++)
      for (j=0 ; j<=99 ; j++)
          b[i][j] = edge;

    for (i=0 ; i<=max_depth ; i++)
      {
        for (j=11 ; j<=81 ; j=j+10)
            for (k=j ; k<j+8 ; k++)
                b[i][k] = empty;

        b[i][45]=computer;
        b[i][54]=computer;
        b[i][44]=human;
        b[i][55]=human;
      }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevCreate() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Called on WM_CREATE messages. */

VOID NEAR PASCAL RevCreate(
register HWND   hWindow)

{
  register HDC  hDC;
  TEXTMETRIC    charsize;           /* characteristics of the characters */

  MessageOn   = FALSE;
  hDC = GetDC(hWindow);
  GetTextMetrics(hDC, (LPTEXTMETRIC)&charsize);

  charheight = charsize.tmHeight;
  charwidth = charsize.tmAveCharWidth;

  ReleaseDC(hWindow, hDC);

  if (COLOR == TRUE)
    {
      hbrComputer = hbrBlue;
      hbrHuman = hbrRed;
    }
  else
    {
      hbrComputer = hbrBlack;
      hbrHuman = hbrWhite;
    }

  TXMIN = 45 * ASPECT;

  clearboard(board);

  /* Okay to pass on first move */
  fPass = PASS;
  depth = 1;
  prevCheck = EASY;
  ffirstmove = TRUE;
  checkdepth(hWindow, prevCheck);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  printboard() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL printboard(
BYTE b[max_depth+2][BoardSize])

{
  register INT  i,j;
  INT sq;

  for (i=0; i < 8; i++)
    {
      for (j=0; j < 8; j++)
        {
          if ((sq = (INT)b[0][i*10+j+11]) != empty)
            {
              if (sq == computer)
                  SelectObject(hDisp, hbrComputer);
              else
                  SelectObject(hDisp, hbrHuman);

              Ellipse(hDisp,
                      Bx+2*ASPECT+i*xExt,
                      By+2+j*yExt,
                      Bx+2*ASPECT + i*xExt + xExt-4*ASPECT,
                      By+2+j*yExt + yExt-4);
            }
        }
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ClearMessageTop() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL ClearMessageTop(
HDC     hDC)

{
  if (MessageOn == TRUE)
    {
      flashtimes = count + 1;
      SelectObject(hDC, (COLOR) ? hbrGreen : hbrWhite);
      PatBlt(hDC, 0, 0, xscr, charheight, PATCOPY);
      MessageOn = FALSE;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ShowMessageTop() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL ShowMessageTop(
HDC     hDC,
PSTR    string)

{
  INT   dx;

  pDisplayMessage = string;
  ClearMessageTop(hDC);
  SelectObject(hDC, hbrWhite);
  PatBlt(hDC, 0, 0, xscr, charheight, PATCOPY);
  SetBkMode(hDC, TRANSPARENT);
  MGetTextExtent(hDC, (LPSTR)string, lstrlen(string), &dx, NULL);
  TextOut(hDC, (INT)(xscr - dx)/2, 0, (LPSTR)string, lstrlen(string));
  MessageOn = TRUE;
  SetBkMode(hDC, OPAQUE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  drawboard() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL drawboard(
BYTE b[max_depth+2][BoardSize])
{
  register INT  i;
  INT           lcx,lcy;
  register INT  xdimension;
  INT           xLineExt,yLineExt;

  yLineExt = 8 * yExt;
  xLineExt = 8 * xExt;
  xdimension = dimension * ASPECT;

  SelectObject(hDisp, hbrBlack);
  PatBlt(hDisp, Bx+2*xdimension, By+2*dimension, xLineExt, yLineExt, PATCOPY);
  MUnrealizeObject(hbrPat);
  SelectObject(hDisp, hbrPat);
  PatBlt(hDisp, Bx, By, xLineExt, yLineExt, PATCOPY);

  SelectObject(hDisp, hbrBlack);
  for (i=Bx; i <= Bx + xLineExt; i += xExt)
      PatBlt(hDisp, i, By, ASPECT, yLineExt, PATCOPY);

  for (i=By; i <= By + yLineExt; i += yExt)
      PatBlt(hDisp, Bx, i, xLineExt, 1, PATCOPY);

  lcx = Bx+xLineExt;
  lcy = By+yLineExt;

  MUnrealizeObject(hbrPat);
  SelectObject(hDisp, hbrPat);

  for (i=1; i < xdimension; ++i)
      PatBlt(hDisp, lcx+i, By+i/ASPECT, 1, yLineExt, PATCOPY);

  /* Fill in bottom edge of puzzle. */
  for (i=1; i < dimension; ++i)
      PatBlt(hDisp, Bx+i*ASPECT, lcy+i, xLineExt, 1, PATCOPY);

  SelectObject(hDisp, hbrBlack);

  MMoveTo(hDisp, lcx, By);
  LineTo(hDisp, lcx+xdimension, By+dimension);
  LineTo(hDisp, lcx+xdimension, lcy+dimension);
  LineTo(hDisp, Bx+xdimension, lcy+dimension);
  LineTo(hDisp, Bx, lcy);
  MMoveTo(hDisp, lcx+xdimension, lcy+dimension);
  LineTo(hDisp, lcx, lcy);

  printboard(b);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevPaint() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Called on WM_PAINT messages. */

VOID NEAR PASCAL RevPaint(
HWND    hWindow,
HDC     hDC)

{
  register INT  Tx, Ty;
  INT           xLineExt, yLineExt;
  RECT          lpSize;

  /* Since it is easy to resize we'll do it on every repaint */
  hDisp = hDC;
  hWin  = hWindow;
  SetBkMode(hDisp, OPAQUE);
  GetClientRect(hWindow, (LPRECT)&lpSize);
  xscr = Tx = lpSize.right - lpSize.left;
  Ty = lpSize.bottom - lpSize.top;

  /* Dont go below minimum size */
  if (Tx < Ty*ASPECT)
    {
      if (Tx < TXMIN)
          Tx = TXMIN;
      xExt = Tx / (9 + 1);
      yExt = xExt / ASPECT;
    }
  else
    {
      if (Ty < TYMIN)
          Ty = TYMIN;
      yExt = Ty / (9 + 1);
      xExt = yExt * ASPECT;
    }
  yLineExt = 8 * yExt;
  xLineExt = 8 * xExt;
  dimension = yLineExt/30;

  Bx = (Tx > xLineExt) ? (Tx - xLineExt) / 2 : 0;
  By = (Ty > yLineExt) ? (Ty - yLineExt) / 2 : 0;

  drawboard(board);

  if (MessageOn)
    {
      ShowMessageTop(hDisp, pDisplayMessage);
      PatBlt(hDC, 0, 0, xscr, charheight, DSTINVERT);
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FlashMessageTop() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL FlashMessageTop(
HWND    hWindow)
{
  flashtimes = 0;
  count = 4;
  SetTimer(hWindow, 666, 200, InverseMessage);    /* Timer ID is 666 */
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevMessage() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL RevMessage(
HWND            hWindow,
HDC             hDC,
register CHAR   *pS,
INT             n,
CHAR            *pchPostStr)
{
  register CHAR *pch;

  pch = strBuf;
  while (*pS)
      *pch++ = *pS++;

  if (n)
    {
      if (n / 10)
          *pch++ = (CHAR)(n / 10 + '0');
      *pch++ = (CHAR)(n % 10 + '0');
    }

  if (pchPostStr)
    {
      while (*pchPostStr)
          *pch++ = *pchPostStr++;
    }
  *pch = TEXT('\0');

  ShowMessageTop(hDC, strBuf);
  FlashMessageTop(hWindow);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  flashsqr() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL flashsqr(
register HDC    hDC,
INT             x1,
INT             y1,
INT             Ex,
INT             Ey,
INT             color,
BOOL            fBlankSquare,
INT             n)

{
  register INT  i;

  if (fBlankSquare)
      SelectObject(hDC, GetStockObject(NULL_PEN));

  SetCursor(curBlank);

  for (i=0; i < n; ++i)
    {
      if (color == 1)
          color = 2;
      else
          color = 1;

      if (color == 1)
          SelectObject(hDC,hbrComputer);
      else
          SelectObject(hDC, hbrHuman);

      SetBkMode(hDC, OPAQUE);
      Ellipse(hDC, x1, y1, x1+Ex, y1+Ey);
    }

  if (fBlankSquare)
    {
      MUnrealizeObject(hbrPat);
      SelectObject(hDC, hbrPat);
      Ellipse(hDC, x1, y1, x1+Ex, y1+Ey);
    }
  else
      SetCursor(curThink);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevMouseMove() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL RevMouseMove(
POINT   point)

{
  INT     move;
  INT     Si, Sj;
  INT     yLineExt = 8 * yExt;
  INT     xLineExt = 8 * xExt;
  HANDLE  cur;

  MousePos.x = point.x;
  MousePos.y = point.y;

  if(xExt ==0 || yExt == 0)
      return;

  cur = curIllegal;

  if ((point.x > Bx) && (point.x < (Bx+xLineExt)) && (point.y > By) && (point.y < (By+yLineExt)))
    {
      Si = (point.x - Bx) / xExt;
      Sj = (point.y - By) / yExt;
      move = Si * 10 + Sj + 11;
      if (legalcheck(board[0], move, human, computer))
          cur = curLegal;
    }
  SetCursor(cur);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ShowBestMove() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL ShowBestMove(
HWND hwnd)

{
  HDC           hdc;
  INT           sq;
  register INT  x, y;
  INT           *pMoves;
  BOOL          bDone;

  if (fPass == PASS && !ffirstmove)
      return;

  if (!fCheated)
      SetWindowText(hwnd, (LPSTR)szReversiPractice);

  fCheated = TRUE;
  SetCursor(curThink);
  fThinking = TRUE;

  if (ffirstmove)
    {
      /* HACK: Hardcode the first move hint. */
      x = 4;
      y = 2;
    }
  else
    {
      if (depth == 1)
        {
          bDone = FALSE;
          pMoves = moves;
          sq = *pMoves;
          while (!bDone)
            {
              sq = *pMoves;
              if (legalcheck(board[0], sq, human, computer))
                  bDone = TRUE;
              else
                  pMoves++;
            }
          y = (sq - 11) % 10;
          x = (sq - 11) / 10;
        }
      else
        {
          minmax(board, BestMove[0],  computer, human, 1, -infin, infin);
          y = (BestMove[1] - 11) % 10;
          x = (BestMove[1] - 11) / 10;
        }
    }

  MousePos.x = (x * xExt) + Bx + xExt/2;
  MousePos.y = (y * yExt) + By + yExt/2;

  UpdateCursor(hwnd);

  hdc = GetDC(hwnd);

  x = x * xExt + Bx + 2 * ASPECT;
  y = y * yExt + By + 2;

  flashsqr(hdc, x, y, xExt - 4 * ASPECT, yExt - 4, computer, TRUE, 3);

  fThinking = FALSE;

  ReleaseDC(hwnd, hdc);

  RevMouseMove(MousePos);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  gameover() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Find a human reply to the computers move.
 * As a side effect set flag fPass if the human
 * has a legal move.
 */

VOID NEAR PASCAL gameover(
register HWND   hWindow,
HDC             hDC,
BYTE            b[max_depth + 2][BoardSize],
INT             r)

{
  register INT  i;
  INT           cc;
  INT           hc;
  INT           sq;
  INT           reply2;
  INT           *pMoves;

  pMoves = moves;
  fPass = PASS;
  reply2 = PASS;
  while ((sq = *pMoves++) != 0)
    {
      if (legalcheck(b[0], sq, human, computer))
          fPass = sq;
      else if (legalcheck(b[0], sq, computer, human))
          reply2 = sq;
    }

  if (fPass == PASS)
    {
      if ((r == PASS) || (reply2 == PASS))
        {
          hc = 0;
          cc = 0;
          for (i=11; i <= 88; i++)
            {
              if (b[0][i] == human)
                  hc++;
              else if (b[0][i] == computer)
                  cc++;
            }

          if (hc > cc)
              RevMessage(hWindow, hDC, szWon, hc-cc, szWonPost);
          else if (hc < cc)
              RevMessage(hWindow, hDC, szLoss, cc-hc, szLossPost);
          else
              RevMessage(hWindow, hDC, szTie, 0, NULL);
        }
      else
        {
          RevMessage(hWindow, hDC, szMustPass, 0, NULL);
        }
    }
  else if (r == PASS)
    {
      RevMessage(hWindow, hDC, szPass, 0, NULL);
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  paintmove() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Make a move and show the results. */

VOID NEAR PASCAL paintmove(
BYTE    b[BoardSize],
INT     move,
BYTE    friendly,
BYTE    enemy)
{
  INT           d;
  INT           sq;
  INT           *p;
  register INT  i,j;
  INT           color;

  if (move != PASS)
    {
      if (friendly == computer)
        {
          SelectObject(hDisp, hbrComputer);
          color = 1;
        }
      else
        {
          SelectObject(hDisp, hbrHuman);
          color = 2;
        }

      i = ((move - 11) / 10) * xExt + Bx + 2 * ASPECT;
      j = ((move - 11) % 10) * yExt + By + 2;
      Ellipse(hDisp, i, j, i + xExt - 4 * ASPECT, j + yExt - 4);
      flashsqr(hDisp, i, j, xExt - 4 * ASPECT, yExt - 4, color, FALSE, 4);

      p = direc;
      while ((d = *p++) != 0)
        {
          sq=move;
          if (b[sq += d] == enemy)
           {
             while(b[sq += d] == enemy)
                ;
             if (b[sq] == (BYTE)friendly)
               {
                 while(b[sq -= d] == enemy)
                   {
                     board[0][sq] = b[sq] = friendly;
                     i = ((sq - 11)/10)*xExt+Bx+2*ASPECT;
                     j = ((sq - 11)%10)*yExt+By+2;
                     Ellipse(hDisp, i, j, i + xExt-4*ASPECT, j + yExt-4);
                   }
               }
           }
        }
      b[move]=friendly;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevMenu() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Called on WM_COMMAND messages. */

VOID NEAR PASCAL RevMenu(
register HWND   hWindow,
INT             idval)

{
  HDC           hDC;
  register INT  cmd;

  if (fThinking)
      return;

  hWin = hWindow;

  switch (idval)
    {
      case EXIT:
          PostMessage(hWindow, WM_CLOSE, 0, 0L);
          break;

      case MN_HELP_ABOUT:
          DialogBox(hInst, MAKEINTRESOURCE(3), hWindow, AboutDlgProc);
          break;

      case MN_HELP_INDEX:
          //TEMPFIX WinHelp(hWindow, (LPSTR)szHelpFile, HELP_INDEX, 0L);
          break;

      case MN_HELP_USINGHELP:
          //TEMPFIX WinHelp(hWindow, (LPSTR)NULL, HELP_HELPONHELP, 0L);
          break;

      case MN_HELP_KEYBOARD:
          cmd = 0x1e;
          goto HelpCommon;

      case MN_HELP_COMMANDS:
          cmd = 0x20;
          goto HelpCommon;

      case MN_HELP_PLAYING:
          cmd = 0x21;
          goto HelpCommon;

      case MN_HELP_RULES:
          cmd = 0x22;
HelpCommon:
          //TEMPFIX WinHelp(hWindow, (LPSTR)szHelpFile, HELP_CONTEXT, (DWORD)cmd);
          break;

      case HINT:
          ShowBestMove(hWindow);
          return;
          break;

      case NEW:
          SetWindowText(hWindow , (LPSTR)szReversi);
          ffirstmove = TRUE;
          hDisp = hDC = GetDC(hWindow);
          fCheated = FALSE;
          SetBkMode(hDisp, OPAQUE);
          ClearMessageTop(hDC);
          fPass = PASS;
          clearboard(board);
          drawboard(board);
          ReleaseDC(hWindow, hDC);
          hDisp = 0;
          break;

      case EASY:
          depth = 1;                      /* MUST BE AT LEAST 1.  */
          checkdepth(hWindow, EASY);      /* KEEP HANDS OFF!      */
          break;

      case MEDIUM:
          depth = 2;
          checkdepth(hWindow, MEDIUM);
          break;

      case HARD:
          depth = 4;
          checkdepth(hWindow, HARD);
          break;

      case VHARD:
          depth = 6;
          checkdepth(hWindow, VHARD);
          break;

      case PASS:
          if (fPass == PASS)
            {
              hDisp = hDC = GetDC(hWindow);
              SetBkMode(hDisp, OPAQUE);
              fThinking = TRUE;
              ClearMessageTop(hDC);
              SetCursor(curThink);
              ReleaseDC(hWindow, hDC);
              hDisp = 0;
              minmax(board, PASS, human, computer, 0, -infin, infin);
              hDisp = hDC = GetDC(hWindow);
              paintmove(board[0], BestMove[0], (BYTE)computer, (BYTE)human);
              gameover(hWindow, hDC, board, BestMove[0]);
              SetCursor(curIllegal);
              fThinking = FALSE;
              ReleaseDC(hWindow, hDC);
              hDisp = 0;
            }
          else
              MessageBox(hWindow, (LPSTR)szNoPass, (LPSTR)szReversi, MB_OK | MB_ICONASTERISK);
          break;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  msgcheck() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Called by ASM routine to allow other tasks to run. */

BOOL NEAR PASCAL msgcheck()
{
  MSG msg;

  if (PeekMessage((LPMSG)&msg, NULL, 0, 0, TRUE))
    {
      if (msg.message == WM_QUIT)
        exit(0);

      if (TranslateAccelerator(msg.hwnd, hAccel, (LPMSG)&msg) == 0)
        {
          TranslateMessage((LPMSG)&msg);
          DispatchMessage((LPMSG)&msg);
        }

      return(TRUE);
    }
  return(FALSE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevInit() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL NEAR PASCAL RevInit(
HANDLE hInstance)

{
  register PWNDCLASS    pRevClass;
  HANDLE                hbmdel;
  HDC                   hdc;
  static INT rgpat[] = { 170, 85, 170, 85, 170, 85, 170, 85 };

  hbrWhite = GetStockObject(WHITE_BRUSH);
  hbrBlack = GetStockObject(BLACK_BRUSH);
  hbmdel   = CreateBitmap(8, 8, 1, 1, (LPSTR)rgpat);
  hbrPat   = CreatePatternBrush(hbmdel);

  if (!hbrPat)
      return(FALSE);
  if (hbmdel)
      DeleteObject(hbmdel);
  ffirstmove = TRUE;
  hdc = GetDC((HWND)NULL);

  COLOR = GetDeviceCaps(hdc, NUMCOLORS) > 2;

  if (GetDeviceCaps(hdc, VERTRES) == 200)
      ASPECT = 2;
  else
      ASPECT = 1;
  ReleaseDC((HWND)NULL, hdc);

  hbrRed        = (HBRUSH)CreateSolidBrush(RGB(0xFF,0,0));
  hbrGreen      = (HBRUSH)CreateSolidBrush(RGB(0,0xFF,0));
  hbrBlue       = (HBRUSH)CreateSolidBrush(RGB(0,0,0xFF));

  if (!hbrRed || !hbrGreen || !hbrBlue)
      return(FALSE);

  LoadString(hInstance, 3,  (LPSTR)szReversi, 20);
  LoadString(hInstance, 4,  (LPSTR)szReversiPractice, 40);
  LoadString(hInstance, 5,  (LPSTR)szPass, 30);
  LoadString(hInstance, 6,  (LPSTR)szMustPass, 30);
  LoadString(hInstance, 7,  (LPSTR)szTie, 30);
  LoadString(hInstance, 8,  (LPSTR)szLoss, 30);
  LoadString(hInstance, 9,  (LPSTR)szWon, 30);
  LoadString(hInstance, 10, (LPSTR)szAbout, 20);
  LoadString(hInstance, 11, (LPSTR)szLossPost, 30);
  LoadString(hInstance, 12, (LPSTR)szWonPost, 30);
  LoadString(hInstance, 13, (LPSTR)szIllegal, 70);
  LoadString(hInstance, 14, (LPSTR)szNoPass, 70);
  LoadString(hInstance, 15, (LPSTR)szHelpFile, 15);

  hAccel = LoadAccelerators(hInstance, (LPSTR)"MAINACC");
  pRevClass = (PWNDCLASS)((CHAR *)LocalAlloc(LMEM_ZEROINIT, sizeof(WNDCLASS)));
  if (!pRevClass)
      return(FALSE);

  curLegal   = LoadCursor(NULL, IDC_CROSS);
  curIllegal = LoadCursor(NULL, IDC_ARROW);
  curThink   = LoadCursor(NULL, IDC_WAIT);
  curBlank   = LoadCursor(hInstance, MAKEINTRESOURCE(1));
  if (!curLegal || !curIllegal || !curThink || !curBlank)
      return(FALSE);
  pRevClass->hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(3));

  pRevClass->lpszClassName = (LPSTR)"Reversi";
  pRevClass->hbrBackground = ((COLOR) ? hbrGreen : hbrWhite);
  pRevClass->lpfnWndProc   = ReversiWndProc;
  pRevClass->lpszMenuName  = MAKEINTRESOURCE(1);
  pRevClass->hInstance    = hInstance;
  pRevClass->style         = CS_VREDRAW | CS_HREDRAW | CS_BYTEALIGNCLIENT;

  if (!RegisterClass((LPWNDCLASS)pRevClass))
    {
      LocalFree((HANDLE)pRevClass);
      return(FALSE);
    }
  LocalFree((HANDLE)pRevClass);

  return(TRUE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevMouseClick() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL RevMouseClick(
HWND  hWnd,
POINT point)
{
  INT     move;
  INT     Si, Sj;
  INT     yLineExt = 8 * yExt;
  INT     xLineExt = 8 * xExt;
  HDC     hDC;

  MousePos.x = point.x;
  MousePos.y = point.y;

  if (xExt == 0 || yExt == 0)
      return;

  if ((point.x > Bx) && (point.x < (Bx+xLineExt)) && (point.y > By) && (point.y < (By+yLineExt)))
    {
      Si = (point.x - Bx) / xExt;
      Sj = (point.y - By) / yExt;
      move = Si * 10 + Sj + 11;
      if (legalcheck(board[0], move, human, computer))
        {
          board[0][move] = human;
          ffirstmove = FALSE;
          fThinking = TRUE;
          SetCursor(curThink);

          hDisp = hDC = GetDC(hWnd);
          ClearMessageTop(hDC);

          minmax(board, move, human, computer, 0, -infin, infin);
          makemove(board[0], move, human, computer);

          hDisp = hDC;

          paintmove(board[0], BestMove[0], computer, human);
          gameover(hWnd, hDC, board, BestMove[0]);

          ReleaseDC(hWnd, hDC);
          hDisp = 0;

          SetCursor(curIllegal);
          fThinking = FALSE;
        }
      else
          MessageBox(hWnd, (LPSTR)szIllegal, (LPSTR)szReversi, MB_OK | MB_ICONASTERISK);
   }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Next() -                                                                */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL Next(
register INT *px,
register INT *py)

{
  (*px)++;
  if (*px > 7)
    {
      *px = 0;
      (*py)++;
      if (*py > 7)
          *py = 0;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Previous() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL Previous(
register INT *px,
register INT *py)
{
  (*px)--;
  if (*px < 0)
    {
      *px = 7;
      (*py)--;
      if (*py < 0)
          *py = 7;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ShowNextMove() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL ShowNextMove(
HWND    hwnd,
BOOL    fforward)
{
  INT       x, y;
  INT       potentialmove;
  BOOL      done;

  /* What out for infinite loops. */
  if (fPass == PASS && !ffirstmove)
      return;

  x = (MousePos.x - Bx) / xExt;
  y = (MousePos.y - By) / yExt;

  done = FALSE;
  while (!done)
    {
      do
        {
          if (fforward)
              Next(&x, &y);
          else
              Previous(&x, &y);
        }
      while ((board[0][potentialmove = (x * 10 + y + 11)]) != empty);

      fThinking = TRUE;
      if (legalcheck(board[0], potentialmove, human, computer))
          done = TRUE;

      fThinking = FALSE;
    }

  MousePos.x = x * xExt + Bx + xExt / 2;
  MousePos.y = y * yExt + By + yExt / 2;

  UpdateCursor(hwnd);
  RevMouseMove(MousePos);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RevChar() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID NEAR PASCAL RevChar(
HWND            hwnd,
register WORD   code)
{
  INT   a;
  POINT curpoint;

  curpoint.x = curpoint.y = 1;
  switch (code)
    {
      case 0x27:
          MousePos.x += xExt;
          break;

      case 0x28:
          MousePos.y += yExt;
          break;

      case 0x25:
          curpoint.x = (MousePos.x - Bx)/xExt;
          MousePos.x -= xExt;
          break;

      case 0x26:
          curpoint.y = (MousePos.y - By)/yExt;
          MousePos.y -= yExt;
          break;

      case 0x24:
          curpoint.y = (MousePos.y - By)/yExt;
          curpoint.x = (MousePos.x - Bx)/xExt;
          MousePos.y -= yExt;
          MousePos.x -= xExt;
          break;

      case 0x21:
          curpoint.y = (MousePos.y - By)/yExt;
          MousePos.y -= yExt;
          MousePos.x += xExt;
          break;

      case 0x23:
          curpoint.x = (MousePos.x - Bx)/xExt;
          MousePos.y += yExt;
          MousePos.x -= xExt;
          break;

      case 0x22:
          MousePos.y += yExt;
          MousePos.x += xExt;
          break;

      case 0x0020:
      case 0x000D:
          if (!fThinking)
              RevMouseClick(hwnd, MousePos);
          return;

      case 0x0009:
          if (fThinking)
              break;
          if (GetKeyState(VK_SHIFT) < 0)
              ShowNextMove(hwnd, FALSE);    /* look backwards */
          else
              ShowNextMove(hwnd, TRUE);     /* look forwards */
          return;

      default:
          return;
    }

  if (((a = ((MousePos.x - Bx) / xExt)) >7) || a <= 0)
      MousePos.x = Bx + xExt / 2;             /* wrap around horizontally */

  if (a > 8 || (curpoint.x == 0 && a == 0))
      MousePos.x = (7*xExt) + Bx + xExt / 2 ;

  if ( ((a = ((MousePos.y - By) / yExt)) >7) || a <= 0)
      MousePos.y = By + yExt / 2;

  if ( a > 8 || (curpoint.y == 0 && a == 0))
      MousePos.y = (7*yExt) + By + yExt / 2;

  MousePos.x = ((MousePos.x - Bx) / xExt) * xExt + Bx + xExt / 2;
  MousePos.y = ((MousePos.y - By) / yExt) * yExt + By + yExt / 2;
  UpdateCursor(hwnd);
  RevMouseMove(MousePos);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  InverseMessage() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID APIENTRY InverseMessage(
register HWND   hWindow,
UINT            message,
UINT_PTR        wParam,
DWORD           lParam)
{
  HDC   hDC;

  message;
  wParam;
  lParam;

  if (flashtimes <= count)
    {
      hDC = GetDC(hWindow);
      PatBlt(hDC, 0, 0, xscr, charheight, DSTINVERT);
      flashtimes++;
      ReleaseDC(hWindow, hDC);
    }
  else
      KillTimer(hWindow, 666);

  return;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ReversiWndProc() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

LRESULT APIENTRY ReversiWndProc(
HWND            hWnd,
register UINT   message,
WPARAM          wParam,
LPARAM          lParam)
{
  HMENU         hm;
  PAINTSTRUCT   ps;
  POINT         curpoint;

  switch (message)
    {
      case WM_COMMAND:
          RevMenu(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
          break;

      case WM_INITMENU:                 /* disable the menu if thinking */
          hm = GetMenu(hWnd);
          if (fThinking)
            {
              EnableMenuItem(hm, 0, MF_DISABLED | MF_BYPOSITION);
              EnableMenuItem(hm, 1, MF_DISABLED | MF_BYPOSITION);
            }
          else
            {
              EnableMenuItem(hm, 0, MF_ENABLED | MF_BYPOSITION);
              EnableMenuItem(hm, 1, MF_ENABLED | MF_BYPOSITION);
            }
          break;

      case WM_CREATE:
          RevCreate(hWnd);
          hWin = hWnd;
          break;

      case WM_CLOSE:
          if (hDisp)
              ReleaseDC(hWnd, hDisp);
          return(DefWindowProc(hWnd, message, wParam, lParam));

      case WM_DESTROY:
          if (MGetModuleUsage(hInst) == 1)
            {
              DeleteObject(hbrGreen);
              DeleteObject(hbrPat);
              DeleteObject(hbrRed);
              DeleteObject(hbrBlue);
            }

          /* In case WinHelp keys off hWindow, we need to do the HELP_QUIT
           * here instead of when there is just one instance of help...
           */
          //TEMPFIX WinHelp(hWnd, (LPSTR)szHelpFile, HELP_QUIT, 0L);

          PostQuitMessage(0);
          break;

      case WM_KEYDOWN:
          if (IsIconic(hWnd))
              return 0L;
          RevChar(hWnd, (WORD)wParam);
          break;

      case WM_ACTIVATE:
          if (!GetSystemMetrics(SM_MOUSEPRESENT))
            {
              if (GET_WM_ACTIVATE_STATE(wParam, lParam))
                {
                  if (GET_WM_ACTIVATE_HWND(wParam, lParam) != hWnd)
                    {
                      curpoint.x = MousePos.x;
                      curpoint.y = MousePos.y;
                      ClientToScreen(hWnd, (LPPOINT)&curpoint);
                      SetCursorPos(curpoint.x, curpoint.y);
                      RevMouseMove(MousePos);
                      ShowCursor(GET_WM_ACTIVATE_STATE(wParam, lParam));
                    }
                }
              else
                  ShowCursor((BOOL) wParam);
            }
          if (wParam && (!HIWORD(lParam)))
              SetFocus(hWnd);
          break;

      case WM_PAINT:
          BeginPaint(hWnd, (LPPAINTSTRUCT)&ps);
          RevPaint(hWnd, ps.hdc);
          EndPaint(hWnd, (LPPAINTSTRUCT)&ps);
          break;

      case WM_MOUSEMOVE:
		  {
		  POINT pt;

		  LONG2POINT(lParam, pt);		/* convert LONG lParam to POINT structure*/
          if (!fThinking)
#ifdef ORGCODE		
              RevMouseMove(MAKEPOINT(lParam));
#else
              RevMouseMove(pt);
#endif
          else
              SetCursor(curThink);
          break;
		  }
      case WM_LBUTTONDOWN:
          SetCapture(hWnd);
          bMouseDownInReversi = TRUE;
          break;

      case WM_LBUTTONUP:
		  {
		  POINT pt;

		  LONG2POINT(lParam, pt);		/* convert LONG lParam to POINT structure*/

          ReleaseCapture();
          if (!fThinking && bMouseDownInReversi)
#ifdef ORGCODE
              RevMouseClick(hWnd, MAKEMPOINT(lParam));
#else
              RevMouseClick(hWnd, pt);
#endif
          bMouseDownInReversi = FALSE;
          break;
		  }
      case WM_TIMER:
          /* This should never be called. */
          break;

      case WM_VSCROLL:
      case WM_HSCROLL:
              break;

      default:
          return(DefWindowProc(hWnd, message, wParam, lParam));
          break;
      }
  return(0L);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AboutDlgProc()                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR APIENTRY AboutDlgProc(
HWND          hDlg,
UINT          message,
WPARAM        wParam,
LPARAM        lParam)

{
  if (message == WM_COMMAND)
    {
      EndDialog(hDlg, TRUE);
      return(TRUE);
    }
  if (message == WM_INITDIALOG)
      return(TRUE);
  else
      return(FALSE);
  UNREFERENCED_PARAMETER(wParam);	
  UNREFERENCED_PARAMETER(lParam);	
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  WinMain() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

MMain(hInstance, hPrev, lpszCmdLine, cmdShow) /* { */
  HWND hWnd;
  MSG   msg;

  _argc;
  _argv;

  hInst = hInstance;
  if (!hPrev)
    {
      if (!RevInit(hInstance))
          return(FALSE);
    }
  else
    {
      if (fThinking)
          return FALSE;
#ifdef WIN16
      GetInstanceData(hPrev, (PSTR)&hbrBlack,           sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrPat,             sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrWhite,           sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrRed,             sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrBlue,            sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrGreen,           sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrComputer,        sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&hbrHuman,           sizeof(HBRUSH));
      GetInstanceData(hPrev, (PSTR)&curIllegal,         sizeof(HCURSOR));
      GetInstanceData(hPrev, (PSTR)&curLegal,           sizeof(HCURSOR));
      GetInstanceData(hPrev, (PSTR)&curThink,           sizeof(HCURSOR));
      GetInstanceData(hPrev, (PSTR)&curBlank,           sizeof(HCURSOR));
      GetInstanceData(hPrev, (PSTR)&prevCheck,          sizeof(prevCheck));
      GetInstanceData(hPrev, (PSTR)&depth,              sizeof(depth));
      GetInstanceData(hPrev, (PSTR)direc,               sizeof(direc));
      GetInstanceData(hPrev, (PSTR)moves,               sizeof(moves));
      GetInstanceData(hPrev, (PSTR)szReversi,           20);
      GetInstanceData(hPrev, (PSTR)szReversiPractice,   40);
      GetInstanceData(hPrev, (PSTR)szPass,              10);
      GetInstanceData(hPrev, (PSTR)szMustPass,          20);
      GetInstanceData(hPrev, (PSTR)szTie,               15);
      GetInstanceData(hPrev, (PSTR)szLoss,              15);
      GetInstanceData(hPrev, (PSTR)szWon,               15);
      GetInstanceData(hPrev, (PSTR)szAbout,             20);
      GetInstanceData(hPrev, (PSTR)&COLOR,              sizeof(INT));
      GetInstanceData(hPrev, (PSTR)&ASPECT,             sizeof(INT));
      GetInstanceData(hPrev, (PSTR)&hAccel,             2);
      GetInstanceData(hPrev, (PSTR)szIllegal,           70);
      GetInstanceData(hPrev, (PSTR)szNoPass,            70);
      GetInstanceData(hPrev, (PSTR)szHelpFile,          15);
#endif /* WIN16 */
    }

  TYMIN = 45;
  fThinking = FALSE;

  hWnd = CreateWindow((LPSTR) "Reversi",
                fCheated ? (LPSTR)szReversiPractice : (LPSTR)szReversi,
                WS_TILEDWINDOW,
                CW_USEDEFAULT,
                0,
                (GetSystemMetrics(SM_CXSCREEN) >> 1),
                (GetSystemMetrics(SM_CYSCREEN) * 4 / 5),
                (HANDLE)NULL,
                (HANDLE)NULL,
                (HANDLE)hInstance,
                NULL);

  if (!hWnd)
      return(FALSE);

  ShowWindow(hWnd, cmdShow);
  UpdateWindow(hWnd);

  /* Messaging Loop. */
  while (GetMessage((LPMSG)&msg, NULL, 0, 0))
    {
      if (!TranslateAccelerator(msg.hwnd, hAccel, (LPMSG)&msg))
        {
          TranslateMessage((LPMSG)&msg);
          DispatchMessage((LPMSG)&msg);
        }
    }
  return(0);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\back.h ===
typedef BITMAPINFOHEADER BMP;

#define DyBmp(bmp) ((int) bmp.biHeight)
#define DxBmp(bmp) ((int) bmp.biWidth)
#define CplnBmp(bmp) 1
#define OfsBits(bgnd) (bgnd.dwOfsBits)
#define CbLine(bgnd) (bgnd.cbLine)

typedef BITMAPFILEHEADER BMPHDR;

typedef struct _bgnd
{
	PT ptOrg;
	OFSTRUCT of;
	BMP bm;
	/* must folow a bm  */
	BYTE rgRGB[64];  /* bug: wont work with >16 color bmps  */
	INT cbLine;
	LONG dwOfsBits;
	BOOL fUseBitmap;
	DY dyBand;
	INT ibndMac;
	HANDLE *rghbnd;
} BGND;


/* PUBLIC routines */

BOOL FInitBgnd(TCHAR *szFile);
BOOL FDestroyBgnd();
BOOL FGetBgndFile(TCHAR *sz);
VOID DrawBgnd(X xLeft, Y yTop, X xRight, Y yBot);
VOID SetBgndOrg();



/* Macros */

extern BGND bgnd;

#define FUseBitmapBgnd() (bgnd.fUseBitmap)


#define BFT_BITMAP 0x4d42   /* 'BM' */
#define ISDIB(bft) ((bft) == BFT_BITMAP)
#define WIDTHBYTES(i)   ((i+31)/32*4)      /* ULONG aligned ! */
WORD DibNumColors(VOID FAR * pv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\back.c ===
#include "sol.h"
VSZASSERT


/* flags for _lseek */
#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

#define cbBand 8192

BGND bgnd;


BOOL _FValidBm(BMP *pbm)
{
    return((pbm->biBitCount == 1 || pbm->biBitCount == 4)
        && pbm->biPlanes == 1 && pbm->biSize == sizeof(BMP));
}




BOOL FInitBgnd(TCHAR *szFile)
{
    INT fh;
    BOOL fResult;
    LONG lcbBm;
    LONG dwBmSize;

    fResult = fFalse;
    bgnd.fUseBitmap = fFalse;
    if((fh = OpenFile(szFile, &bgnd.of, OF_CANCEL|OF_READ)) == -1)
        return fFalse;

    if(!FReadDibBitmapInfo(fh, &bgnd.bm))    
        goto ReturnClose;
    bgnd.dwOfsBits = M_llseek( fh, 0L, SEEK_CUR);

    if(!_FValidBm(&bgnd.bm))
        goto ReturnClose;

        
    /* BUG: check if bitmap is ok */
    bgnd.cbLine = (((INT) bgnd.bm.biWidth * bgnd.bm.biBitCount+31)/32)*4;
    lcbBm = (LONG) bgnd.cbLine * DyBmp(bgnd.bm);
    bgnd.ibndMac = (INT) ((lcbBm+cbBand-1) / cbBand);
    if((bgnd.rghbnd = PAlloc(bgnd.ibndMac*sizeof(HANDLE))) == NULL)
        goto ReturnClose;
    bgnd.dyBand = (INT) ((LONG) DyBmp(bgnd.bm) * cbBand / lcbBm);
    bgnd.fUseBitmap = fTrue;
    SetBgndOrg();
    fResult = fTrue;
ReturnClose:
    M_lclose(fh);
    return fResult;
}




BOOL FDestroyBgnd()
{
    INT ibnd;
    HANDLE *phbnd;

    if(bgnd.fUseBitmap)
    {
        for(ibnd = 0; ibnd < bgnd.ibndMac; ibnd++)
        {
            if(*(phbnd = &bgnd.rghbnd[ibnd]) != NULL)
            {
                GlobalFree(*phbnd);
                *phbnd = NULL;
            }
        }
        FreeP(bgnd.rghbnd);
    }
    return fTrue;
}



BOOL FGetBgndFile(TCHAR *sz)
{
    if(bgnd.fUseBitmap)
        PszCopy(bgnd.of.szPathName, sz);
    else
        sz[0] = TEXT('\000');
    return fTrue;
}




BOOL _FLoadBand(INT ibnd, Y y)
{
    HANDLE hbnd;
    BYTE[     ]*FAR[     ]**lpb;
    INT ipln;
    INT fh;
    LONG lcbpln;
    HANDLE *phbnd;
    DY dy;

    phbnd = &bgnd.rghbnd[ibnd];

    if(*phbnd != NULL)
        GlobalFree(*phbnd);
    hbnd = GlobalAlloc(GMEM_MOVEABLE|GMEM_DISCARDABLE, (LONG) cbBand);
    lpb = GlobalLock(hbnd);
    if(lpb == NULL)
        return fFalse;
    fh = OpenFile("", &bgnd.of, OF_REOPEN|OF_READ );

    lcbpln = 0L;
    dy = WMin(bgnd.dyBand, DyBmp(bgnd.bm)-y);
    for(ipln = 0; ipln < CplnBmp(bgnd.bm); ipln++)
    {
        M_llseek( fh, (LONG)OfsBits(bgnd)+ipln*lcbpln+(y)*CbLine(bgnd), 0);
        M_lread( fh, (LPSTR) lpb+ipln*CbLine(bgnd)*bgnd.dyBand, dy * CbLine(bgnd));
    }

    GlobalUnlock(hbnd);
    *phbnd = hbnd;
    M_lclose(fh);
    return fTrue;
}




Y _YDrawBand(HDC hdcMem, HBITMAP hbm, X xLeft, Y yTop, X xRight, Y yBot)
{
    HBITMAP hbmSav;
    HANDLE hbnd;
    BYTE[     ]*FAR[     ]**lpb;
    Y y;
    INT ibnd;

    /* round yTop to nearest band */
    y = ((yTop-bgnd.ptOrg.y)/bgnd.dyBand)*bgnd.dyBand;
    
    ibnd = y/bgnd.dyBand;
    if(ibnd < 0)
        return bgnd.ptOrg.y;
    if(ibnd >= bgnd.ibndMac)
        return yBot+1;
    ibnd = bgnd.ibndMac-ibnd-1;
     Assert(ibnd >= 0);
    Assert(ibnd < bgnd.ibndMac);
    while((hbnd = bgnd.rghbnd[ibnd]) == NULL ||
        (lpb = (BYTE[     ]*FAR[     ]**) GlobalLock(hbnd)) == NULL)
    {
        if(!_FLoadBand(ibnd, y))
            /* KLUDGE:, should back out gracefully */
            return yBot;
    }
        
    Assert(lpb != NULL);
    SetDIBitsToDevice(hdcCur, xLeft-xOrgCur, yTop-yOrgCur, 
        WMin(xRight-xLeft, DyBmp(bgnd.bm)-xLeft+bgnd.ptOrg.x), 
        WMin(WMin(bgnd.dyBand, yBot-yTop), DyBmp(bgnd.bm)-yTop+bgnd.ptOrg.y),
        0,    0,
        y-bgnd.ptOrg.y,
        bgnd.dyBand,
        
//        xLeft-bgnd.ptOrg.x, yTop-y-bgnd.ptOrg.y, 
//        0,
//        WMin(WMin(bgnd.dyBand, yBot-yTop), DyBmp(bgnd.bm)-yTop+bgnd.ptOrg.y),
        lpb,
        (BITMAPINFO FAR *)&bgnd.bm,
        DIB_RGB_COLORS);
    
    GlobalUnlock(hbnd);
    return y+bgnd.dyBand+bgnd.ptOrg.y;
}


VOID DrawBgnd(X xLeft, Y yTop, X xRight, Y yBot)
{
    INT dy;
    Y y;
    HDC hdcMem;
    HBITMAP hbm;
    HBRUSH hbr;

    if(bgnd.fUseBitmap)
    {

        for(y = yTop; y <= yBot; )
        {
            y = _YDrawBand(hdcMem, hbm, xLeft, y, xRight, yBot);
        }
        ExcludeClipRect(hdcCur, bgnd.ptOrg.x-xOrgCur, bgnd.ptOrg.y-yOrgCur, bgnd.ptOrg.x+DxBmp(bgnd.bm)-xOrgCur, bgnd.ptOrg.y+DyBmp(bgnd.bm)-yOrgCur);
    }

    MSetBrushOrg(hdcCur, xOrgCur, yOrgCur);
    MUnrealizeObject( hbrTable );
    hbr = SelectObject(hdcCur, hbrTable);
    Assert(xRight >= xLeft);
    Assert(yBot >= yTop);
    PatBlt(hdcCur, xLeft-xOrgCur, yTop-yOrgCur, xRight-xLeft, yBot-yTop, PATCOPY);
    SelectObject(hdcCur, hbr);

    if(bgnd.fUseBitmap)
        SelectClipRgn(hdcCur, NULL);
}



VOID SetBgndOrg()    
{
    bgnd.ptOrg.x = (rcClient.xRight - DxBmp(bgnd.bm))/2;
    bgnd.ptOrg.y = (rcClient.yBot -  DyBmp(bgnd.bm))/2;
}




/*
 *  ReadDibBitmapInfo()
 *
 *  Will read a file in DIB format and return a global HANDLE to it's
 *  BITMAPINFO.  This function will work with both "old" and "new"
 *  bitmap formats, but will allways return a "new" BITMAPINFO
 *
 */
BOOL FReadDibBitmapInfo(INT fh, BITMAPINFO *pbi)
{
    DWORD     off;
    HANDLE    hbi = NULL;
    INT       size;
    INT       i;
    WORD      nNumColors;

    RGBQUAD FAR       *pRgb;
    BITMAPINFOHEADER   bi;
    BITMAPCOREHEADER   bc;
    LPBITMAPINFOHEADER lpbi;
    BITMAPFILEHEADER   bf;

    if (fh == -1)
        return NULL;

    off = M_llseek( fh, 0L, SEEK_CUR);

    if (sizeof(bf) != M_lread( fh, (LPSTR)&bf, sizeof(bf)) )
        return fFalse;

    /*
     *  do we have a RC HEADER?
     */
    if (!ISDIB(bf.bfType))
    {
        bf.bfOffBits = 0L;
        M_llseek( fh, off, SEEK_SET );
    }

    if (sizeof(bi) != M_lread( fh, (LPSTR)&bi, sizeof(bi)) )
        return fFalse;

    nNumColors = DibNumColors(&bi);

    /*
     *  what type of bitmap info is this?
     */
    switch (size = (INT)bi.biSize)
    {
        case sizeof(BITMAPINFOHEADER):
            break;

        case sizeof(BITMAPCOREHEADER):
            bc = *(BITMAPCOREHEADER*)&bi;
            bi.biSize               = sizeof(BITMAPINFOHEADER);
            bi.biWidth              = (DWORD)bc.bcWidth;
            bi.biHeight             = (DWORD)bc.bcHeight;
            bi.biPlanes             =  (WORD)bc.bcPlanes;
            bi.biBitCount           =  (WORD)bc.bcBitCount;
               bi.biStyle               	= 0;
            bi.biSizeImage          = 0;
            bi.biXPelsPerMeter      = 0;
            bi.biYPelsPerMeter      = 0;
            bi.biClrUsed            = nNumColors;
            bi.biClrImportant       = nNumColors;

            M_llseek(fh, (LONG)sizeof(BITMAPCOREHEADER)-sizeof(BITMAPINFOHEADER), SEEK_CUR);

            break;

        default:
            return fFalse;       /* not a DIB */
    }

    /*
     *    fill in some default values!
     */
    if (bi.biSizeImage == 0)
    {
        bi.biSizeImage = WIDTHBYTES((DWORD)bi.biWidth * bi.biBitCount)
             * bi.biHeight;
    }

    if (bi.biXPelsPerMeter == 0)
    {
        bi.biXPelsPerMeter = 0;     // ??????????????
    }

    if (bi.biYPelsPerMeter == 0)
    {
        bi.biYPelsPerMeter = 0;     // ??????????????
    }

    if (bi.biClrUsed == 0)
    {
        bi.biClrUsed = DibNumColors(&bi);
    }


    lpbi = (VOID FAR *)pbi;
    *lpbi = bi;

    pRgb = (RGBQUAD FAR *)((LPSTR)lpbi + bi.biSize);

    if (nNumColors)
    {
        if (size == sizeof(BITMAPCOREHEADER))
        {
            /*
             * convert a old color table (3 byte entries) to a new
             * color table (4 byte entries)
             */
            M_lread( fh, (LPSTR)pRgb, nNumColors * sizeof(RGBTRIPLE) );

            for (i=nNumColors-1; i>=0; i--)
            {
                RGBQUAD rgb;

                rgb.rgbRed      = ((RGBTRIPLE FAR *)pRgb)[i].rgbtRed;
                rgb.rgbBlue     = ((RGBTRIPLE FAR *)pRgb)[i].rgbtBlue;
                rgb.rgbGreen    = ((RGBTRIPLE FAR *)pRgb)[i].rgbtGreen;
                rgb.rgbReserved = (BYTE)0;

                pRgb[i] = rgb;  // BUG, this is wrong!!!!
            }
        }
        else
        {
            M_lread(fh, (LPSTR)pRgb, nNumColors * sizeof(RGBQUAD));
        }
        }

    if (bf.bfOffBits != 0L)
        M_llseek( fh, off + bf.bfOffBits, SEEK_SET );

    return fTrue;
}







/*  How Many colors does this DIB have?
 *  this will work on both PM and Windows bitmap info structures.
 */
WORD DibNumColors(VOID FAR * pv)
{
    INT bits;

    /*
     *  with the new format headers, the size of the palette is in biClrUsed
     *  else is dependent on bits per pixel
     */
    if (((LPBITMAPINFOHEADER)pv)->biSize != sizeof(BITMAPCOREHEADER))
    {
        if (((LPBITMAPINFOHEADER)pv)->biClrUsed != 0)
            return (WORD)((LPBITMAPINFOHEADER)pv)->biClrUsed;

        bits = ((LPBITMAPINFOHEADER)pv)->biBitCount;
    }
    else
    {
        bits = ((LPBITMAPCOREHEADER)pv)->bcBitCount;
    }

    switch (bits)
    {
        case 1:
            return 2;
        case 4:
            return 16;
        case 8:
            Assert(fFalse);  // NYI
            return 256;
        default:
            return 0;
    }

    
}





#ifdef LATER

HDC HdcCreateImage(HDC hdcApp, INT idbMask, INT idbImage, LONG rgb, DX *pdx, DY *pdy)
{
    HDC hdcMem, hdcMem1;
    HBITMAP hbmT, hbmTT, hbmMask;
    HBRUSH hbr;
    BITMAP bm;

    hdcMem = CreateCompatibleDC(hdcApp);
    hbmMask = LoadBitmap(hinstApp, MAKEINTRESOURCE(idbMask));
    GetObject(hbmMask, sizeof(BITMAP), (LPSTR) &bm);

    /* enlarge the size of hdc */
    hbmT = SelectObject(hdcMem, CreateCompatibleBitmap(hdcApp, bm.bmWidth, bm.bmHeight));
    hbr = SelectObject(hdcMem, hbrTable);
    PatBlt(hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, PATCOPY);
    SelectObject(hdcMem, hbr);

    hdcMem1 = CreateCompatibleDC(hdcApp);
    hbmTT = SelectObject(hdcMem1, hbmMask);
    BitBlt(hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem1, 0, 0, SRCAND);
    /* load image and delete hbmMask */
    DeleteObject(SelectObject(hdcMem1, LoadBitmap(hinstApp, MAKEINTRESOURCE(idbImage))));
    /* load brush to color image */
    hbr = SelectObject(hdcMem, CreateSolidBrush(rgb));

#define ropDPSao 0x00EA02E9   /* (Source & Pattern) | Dest */
    BitBlt(hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem1, 0, 0, ropDPSao);
    DeleteObject(SelectObject(hdcMem, hbr));
    DeleteObject(SelectObject(hdcMem1, hbmTT));
    DeleteDC(hdcMem1);
    *pdx = bm.bmWidth;
    *pdy = bm.bmHeight;
    return hdcMem;
}

Marquee(RC *prc)
{
    HDC hdc;
    HDC hdcObj;
    X x;
    Y y;
    DX dxObj;
    DY dyObj;
    DX dx;
    DY dy;
    INT dobjX, dobjY;  /* # of objects per dir */
    INT iobj;
    INT iSlice, iSlice1;

    hdc = GetDC(hwndApp);
    hdcObj = HdcCreateImage(hdc, idbBlackBear, idbWhiteBear, RGB(255, 0, 0), &dxObj, &dyObj);
    dobjX = (prc->xRight-prc->xLeft)/dxObj;
    dobjY = (prc->yBot-prc->yTop)/dyObj;
    dx = dxObj*2;
    dy = 0;
    y = prc->yTop-dyObj;
    x = prc->xLeft-dxObj+iSlice%dxObj;
    for(iobj = 0; iobj < 2*dobjX+2*dobjY; iobj++)
        {
        BitBlt(hdc, x, y, dxObj, dyObj, hdcObj, 0, 0, SRCCOPY);
        if(dy == 0)
            {
            if(x > prc->xRight+dxObj)
                {
                dy = dyObj*2;
                dx = 0;
                }    
            else if(x < prc->xLeft-dxObj)
                {
                dy = -dyObj*2;
                dx = 0;
                }
            }
        else if(dx == 0)
            {
            if(y > prc->yBot+dyObj)
                {
                dx = -dxObj*2;
                dy = 0;
                }
            }
        x+=dx;
        y+=dy;
        }
    for(iSlice = 0; iSlice < 5; iSlice++)
        {
        for(iSlice1 = 0; iSlice1 < dxObj; iSlice1++)
            {
            BitBlt(hdc, prc->xLeft-dxObj+iSlice1+1, prc->yTop-dyObj, prc->xRight-prc->xLeft+dxObj, dyObj,
                     hdc, prc->xLeft-dxObj+iSlice1, prc->yTop-dyObj, SRCCOPY);
            BitBlt(hdc, prc->xRight+dxObj, prc->yTop-dyObj+iSlice1+1, dxObj, prc->yBot-prc->yTop+dyObj,
                     hdc, prc->xRight+dxObj, prc->yTop-dyObj+iSlice1, SRCCOPY);
            }
        }


    DeleteDC(hdcObj);
    ReleaseDC(hwndApp, hdc);
    return fTrue;
}











Animation()
{
    INT iX, iY, ihdc;
    DX dx;
    DY dy;
    HDC hdc;
    HDC rghdc[3];

    RC rc;


    rc.xLeft = 100; rc.xRight = 300;
    rc.yTop = 100; rc.yBot = 200;
    Marquee(&rc);
    return fTrue;

}


#endif /* LATER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\cards.c ===
#include "sol.h"
#ifndef DLL
VSZASSERT
#else
#ifdef DEBUG
#undef Assert
#define Assert(f) { if (!(f)) { ExitWindows(0L); } }
#endif
#endif


#define COOLCARD


#ifdef COOLCARD
void SaveCorners(HDC hdc, LONG FAR *rgRGB, INT x, INT y, INT dx, INT dy);
void RestoreCorners(HDC hdc, LONG FAR *rgRGB, INT x, INT y, INT dx, INT dy);
#endif

VOID APIENTRY cdtTerm(VOID);
VOID MyDeleteHbm(HBITMAP hbm);
static HBITMAP HbmFromCd(INT, HDC);
static BOOL FLoadBack(INT);


// we removed the older card decks that required Animation. The new
// card deck doesn't involve any animation.


#ifdef UNUSEDCODE

typedef struct
        {
        INT id;
        DX  dx;
        DY       dy;
        } SPR;

#define isprMax 4

typedef struct
        {
        INT cdBase;
        DX dxspr;
        DY dyspr;
        INT isprMac;
        SPR rgspr[isprMax];
        } ANI;

#define ianiMax 4
static ANI rgani[ianiMax] =
        { IDFACEDOWN12, 32, 22, 4,
                {IDASLIME1, 32, 32,
                 IDASLIME2, 32, 32,
                 IDASLIME1, 32, 32,
                 IDFACEDOWN12, 32, 32
                },
          IDFACEDOWN10, 36, 12, 2,
                {IDAKASTL1, 42, 12,
                 IDFACEDOWN10, 42, 12,
                 0, 0, 0,
                 0, 0, 0
                },
          IDFACEDOWN11, 14, 12, 4,
                {
                IDAFLIPE1, 47, 1,
                IDAFLIPE2, 47, 1,
                IDAFLIPE1, 47, 1,
                IDFACEDOWN11, 47, 1
                },
          IDFACEDOWN3, 24, 7, 4,
                {
                IDABROBOT1, 24, 40,
                IDABROBOT2, 24, 40,
                IDABROBOT1, 24, 40,
                IDFACEDOWN3, 24, 40
                }
        /* remember to inc ianiMax */
        };

#endif

static HBITMAP  hbmCard[52] =
        {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
         NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
         NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
         NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};

static HBITMAP hbmGhost = NULL;
static HBITMAP hbmBack = NULL;
static HBITMAP hbmDeckX = NULL;
static HBITMAP hbmDeckO = NULL;
static INT idback = 0;
static INT dxCard, dyCard;
static INT cInits = 0;


#ifdef DLL
HANDLE hinstApp;
#else
extern HANDLE  hinstApp;
#endif

BOOL APIENTRY cdtInit(INT FAR *pdxCard, INT FAR *pdyCard)
/*
 * Parameters:
 *      pdxCard, pdyCard
 *                      Far pointers to ints where card size will be placed
 *
 * Returns:
 *      True when successful, False when it can't find one of the standard
 *      bitmaps.
 */
        {

        BITMAP bmCard;
        HDC hdc = NULL;
        HBITMAP hbmDstBitmap;
        HANDLE hDstOld;
        HANDLE hSrcOld;
        HDC hdcDstMemory;
        HDC hdcSrcMemory;

#ifdef DLL
        if (cInits++ != 0)
                {
                *pdxCard = dxCard;
                *pdyCard = dyCard;
                return fTrue;
                }
#endif

        hbmGhost = LoadBitmap( hinstApp, MAKEINTRESOURCE(IDGHOST));
        hbmDeckX = LoadBitmap( hinstApp, MAKEINTRESOURCE(IDX));
        hbmDeckO = LoadBitmap( hinstApp, MAKEINTRESOURCE(IDO));
        if(hbmGhost == NULL || hbmDeckX == NULL || hbmDeckO == NULL) {
                goto Fail;
        }

        GetObject( hbmGhost, sizeof( BITMAP), (LPSTR)&bmCard);
        dxCard = *pdxCard = bmCard.bmWidth;
        dyCard = *pdyCard = bmCard.bmHeight;

        //
        // Create two compatible memory DCs for bitmap conversion.
        //

        hdc = GetDC(NULL);
        hdcSrcMemory = CreateCompatibleDC(hdc);
        hdcDstMemory = CreateCompatibleDC(hdc);
        if ((hdcSrcMemory == NULL) || (hdcDstMemory == NULL)) {
            goto Fail;
        }

        //
        // Create a compatible bitmap for the conversion of the Ghost
        // bitmap, blt the loaded bitmap to the compatible bitmap, and
        // delete the original bitmap.
        //

        hbmDstBitmap = CreateCompatibleBitmap(hdc, dxCard, dyCard);
        if (hbmDstBitmap == NULL) {
            goto Fail;
        }

        hSrcOld = SelectObject(hdcSrcMemory, hbmGhost);
        hDstOld = SelectObject(hdcDstMemory, hbmDstBitmap);
        BitBlt(hdcDstMemory, 0, 0, dxCard, dyCard, hdcSrcMemory, 0, 0, SRCCOPY);
        SelectObject(hdcSrcMemory, hSrcOld);
        SelectObject(hdcDstMemory, hDstOld);
        DeleteObject(hbmGhost);
        hbmGhost = hbmDstBitmap;

        //
        // Create a compatible bitmap for the conversion of the DeckX
        // bitmap, blt the loaded bitmap to the compatible bitmap, and
        // delete the original bitmap.
        //

        hbmDstBitmap = CreateCompatibleBitmap(hdc, dxCard, dyCard);
        if (hbmDstBitmap == NULL) {
            goto Fail;
        }

        hSrcOld = SelectObject(hdcSrcMemory, hbmDeckX);
        hDstOld = SelectObject(hdcDstMemory, hbmDstBitmap);
        BitBlt(hdcDstMemory, 0, 0, dxCard, dyCard, hdcSrcMemory, 0, 0, SRCCOPY);
        SelectObject(hdcSrcMemory, hSrcOld);
        SelectObject(hdcDstMemory, hDstOld);
        DeleteObject(hbmDeckX);
        hbmDeckX = hbmDstBitmap;

        //
        // Create a compatible bitmap for the conversion of the DeckO
        // bitmap, blt the loaded bitmap to the compatible bitmap, and
        // delete the original bitmap.
        //

        hbmDstBitmap = CreateCompatibleBitmap(hdc, dxCard, dyCard);
        if (hbmDstBitmap == NULL) {
        }

        hSrcOld = SelectObject(hdcSrcMemory, hbmDeckO);
        hDstOld = SelectObject(hdcDstMemory, hbmDstBitmap);
        BitBlt(hdcDstMemory, 0, 0, dxCard, dyCard, hdcSrcMemory, 0, 0, SRCCOPY);
        SelectObject(hdcSrcMemory, hSrcOld);
        SelectObject(hdcDstMemory, hDstOld);
        DeleteObject(hbmDeckO);
        hbmDeckO = hbmDstBitmap;

        //
        // Delete the compatible DCs.
        //

        DeleteDC(hdcDstMemory);
        DeleteDC(hdcSrcMemory);
        ReleaseDC(NULL, hdc);
        return fTrue;

Fail:
        if (hdc != NULL) {
            ReleaseDC(NULL, hdc);
        }

        cdtTerm();
        return fFalse;
        }




BOOL APIENTRY cdtDrawExt(HDC hdc, INT x, INT y, INT dx, INT dy, INT cd, INT mode, DWORD rgbBgnd)
/*
 * Parameters:
 *      hdc     HDC to window to draw cards on
 *      x, y    Where you'd like them
 * dx,dy card extents
 *      cd              Card to be drawn
 *      mode    Way you want it drawn
 *
 * Returns:
 *      True if card successfully drawn, False otherwise
 */
{

        HBITMAP  hbmSav;
        HDC      hdcMemory;
        DWORD    dwRop;
        HBRUSH   hbr;
#ifdef COOLCARD
        LONG     rgRGB[12];
#endif

        Assert(hdc != NULL);
                switch (mode)
                        {
                default:
                        Assert(fFalse);
                        break;
                case FACEUP:
                        hbmSav = HbmFromCd(cd, hdc);
                        dwRop = SRCCOPY;
                        break;
                case FACEDOWN:
                        if(!FLoadBack(cd))
                                return fFalse;
                        hbmSav = hbmBack;
                        dwRop = SRCCOPY;
                        break;
                case REMOVE:
                case GHOST:
                        hbr = CreateSolidBrush( rgbBgnd);
                        if(hbr == NULL)
                                return fFalse;

                        MUnrealizeObject( hbr);
                        if((hbr = SelectObject( hdc, hbr)) != NULL)
                                {
                        PatBlt(hdc, x, y, dx, dy, PATCOPY);
                                hbr = SelectObject( hdc, hbr);
                                }
                        DeleteObject( hbr);
                        if(mode == REMOVE)
                                return fTrue;
                        Assert(mode == GHOST);
                        /* default: fall thru */

                case INVISIBLEGHOST:
                        hbmSav = hbmGhost;
                        dwRop = SRCAND;
                        break;

                case DECKX:
                        hbmSav = hbmDeckX;
                        dwRop = SRCCOPY;
                        break;
                case DECKO:
                        hbmSav = hbmDeckO;
                        dwRop = SRCCOPY;
                        break;

                case HILITE:
                        hbmSav = HbmFromCd(cd, hdc);
                        dwRop = NOTSRCCOPY;
                        break;
                        }
        if (hbmSav == NULL)
                return fFalse;
        else
                {
        hdcMemory = CreateCompatibleDC( hdc);
                if(hdcMemory == NULL)
                        return fFalse;

                if((hbmSav = SelectObject( hdcMemory, hbmSav)) != NULL)
                        {
#ifdef COOLCARD
                        if( !fKlondWinner )
							SaveCorners(hdc, rgRGB, x, y, dx, dy);
#endif
                        if(dx != dxCard || dy != dyCard)
                                StretchBlt(hdc, x, y, dx, dy, hdcMemory, 0, 0, dxCard, dyCard, dwRop);
                        else
                                BitBlt( hdc, x, y, dxCard, dyCard, hdcMemory, 0, 0, dwRop);

                SelectObject( hdcMemory, hbmSav);
                        /* draw the border for the red cards */
                        if(mode == FACEUP)
                                {
                                INT icd;

                                icd = RaFromCd(cd) % 13 + SuFromCd(cd) * 13+1;
                                if((icd >= IDADIAMONDS && icd <= IDTDIAMONDS) ||
                                        (icd >= IDAHEARTS && icd <= IDTHEARTS))
                                        {
                                        PatBlt(hdc, x+2, y, dx-4, 1, BLACKNESS);  /* top */
                                        PatBlt(hdc, x+dx-1, y+2, 1, dy-4, BLACKNESS); /* right */
                                        PatBlt(hdc, x+2, y+dy-1, dx-4, 1, BLACKNESS); /* bottom */
                                        PatBlt(hdc, x, y+2, 1, dy-4, BLACKNESS); /* left */
                                        SetPixel(hdc, x+1, y+1, 0L); /* top left */
                                        SetPixel(hdc, x+dx-2, y+1, 0L); /*  top right */
                                        SetPixel(hdc, x+dx-2, y+dy-2, 0L); /* bot right */
                                        SetPixel(hdc, x+1, y+dy-2, 0L); /* bot left */
                                        }
                                }
#ifdef COOLCARD
                        if( !fKlondWinner )
							RestoreCorners(hdc, rgRGB, x, y, dx, dy);
#endif
                        }
        DeleteDC( hdcMemory);
                return fTrue;
                }
        }






BOOL APIENTRY cdtDraw(HDC hdc, INT x, INT y, INT cd, INT mode, DWORD rgbBgnd)
/*
 * Parameters:
 *      hdc             HDC to window to draw cards on
 *      x, y    Where you'd like them
 *      cd              Card to be drawn
 *      mode    Way you want it drawn
 *
 * Returns:
 *      True if card successfully drawn, False otherwise
 */
        {

        return cdtDrawExt(hdc, x, y, dxCard, dyCard, cd, mode, rgbBgnd);
        }


#ifdef COOLCARD

void SaveCorners(HDC hdc, LONG FAR *rgRGB, INT x, INT y, INT dx, INT dy)
        {
        if(dx != dxCard || dy != dyCard)
                return;

        /* Upper Left */
        rgRGB[0] = GetPixel(hdc, x, y);
        rgRGB[1] = GetPixel(hdc, x+1, y);
        rgRGB[2] = GetPixel(hdc, x, y+1);

        /* Upper Right */
        x += dx -1;
        rgRGB[3] = GetPixel(hdc, x, y);
        rgRGB[4] = GetPixel(hdc, x-1, y);
        rgRGB[5] = GetPixel(hdc, x, y+1);

        /* Lower Right */
        y += dy-1;
        rgRGB[6] = GetPixel(hdc, x, y);
        rgRGB[7] = GetPixel(hdc, x, y-1);
        rgRGB[8] = GetPixel(hdc, x-1, y);

        /* Lower Left */
        x -= dx-1;
        rgRGB[9] = GetPixel(hdc, x, y);
        rgRGB[10] = GetPixel(hdc, x+1, y);
        rgRGB[11] = GetPixel(hdc, x, y-1);

        }



void RestoreCorners(HDC hdc, LONG FAR *rgRGB, INT x, INT y, INT dx, INT dy)
        {
        if(dx != dxCard || dy != dyCard)
                return;

        /* Upper Left */
        SetPixel(hdc, x, y, rgRGB[0]);
        SetPixel(hdc, x+1, y, rgRGB[1]);
        SetPixel(hdc, x, y+1, rgRGB[2]);

        /* Upper Right */
        x += dx-1;
        SetPixel(hdc, x, y, rgRGB[3]);
        SetPixel(hdc, x-1, y, rgRGB[4]);
        SetPixel(hdc, x, y+1, rgRGB[5]);

        /* Lower Right */
        y += dy-1;
        SetPixel(hdc, x, y, rgRGB[6]);
        SetPixel(hdc, x, y-1, rgRGB[7]);
        SetPixel(hdc, x-1, y, rgRGB[8]);

        /* Lower Left */
        x -= dx-1;
        SetPixel(hdc, x, y, rgRGB[9]);
        SetPixel(hdc, x+1, y, rgRGB[10]);
        SetPixel(hdc, x, y-1, rgRGB[11]);
        }
#endif






BOOL APIENTRY cdtAnimate(HDC hdc, INT cd, INT x, INT y, INT ispr)
        {
        INT iani;
        ANI *pani;
        SPR *pspr;
        HBITMAP hbm;
        HDC hdcMem;
        X xSrc;
        Y ySrc;

        if(ispr < 0)
                return fFalse;
        Assert(hdc != NULL);
        for(iani = 0; iani < ianiMax; iani++)
                {
                if(cd == rgani[iani].cdBase)
                        {
                        pani = &rgani[iani];
                        if(ispr < pani->isprMac)
                                {
                                pspr = &pani->rgspr[ispr];
                                Assert(pspr->id != 0);
                                if(pspr->id == cd)
                                        {
                                        xSrc = pspr->dx;
                                        ySrc = pspr->dy;
                                        }
                                else
                                        xSrc = ySrc = 0;

                                hbm = LoadBitmap(hinstApp, MAKEINTRESOURCE(pspr->id));
                                if(hbm == NULL)
                                        return fFalse;

                        hdcMem = CreateCompatibleDC(hdc);
                                if(hdcMem == NULL)
                                        {
                                        DeleteObject(hbm);
                                        return fFalse;
                                        }

                                if((hbm = SelectObject(hdcMem, hbm)) != NULL)
                                        {
                                        BitBlt(hdc, x+pspr->dx, y+pspr->dy, pani->dxspr, pani->dyspr,
                                                hdcMem, xSrc, ySrc, SRCCOPY);
                                        DeleteObject(SelectObject(hdcMem, hbm));
                                        }
                                DeleteDC(hdcMem);
                                return fTrue;
                                }
                        }
                }
        return fFalse;
        }



/* loads global bitmap hbmBack */
BOOL FLoadBack(INT idbackNew)
        {

        Assert(FInRange(idbackNew, IDFACEDOWNFIRST, IDFACEDOWNLAST));

        if(idback != idbackNew)
                {
                MyDeleteHbm(hbmBack);
                if((hbmBack = LoadBitmap(hinstApp, MAKEINTRESOURCE(idbackNew))) != NULL)
                        idback = idbackNew;
                else
                        idback = 0;
                }
        return idback != 0;
        }



static HBITMAP HbmFromCd(INT cd, HDC hdc)

{

    INT icd;
    HBITMAP hbmDstBitmap;
    HANDLE hDstOld;
    HANDLE hSrcOld;
    HDC hdcDstMemory;
    HDC hdcSrcMemory;

    if (hbmCard[cd] == NULL) {
        icd = RaFromCd(cd) % 13 + SuFromCd(cd) * 13;
        if ((hbmCard[cd] = LoadBitmap(hinstApp,MAKEINTRESOURCE(icd+1))) == NULL) {
            return NULL;
        }

        //
        // Create two compatible memory DCs for bitmap conversion.
        //

        hdcSrcMemory = CreateCompatibleDC(hdc);
        hdcDstMemory = CreateCompatibleDC(hdc);
        if ((hdcSrcMemory == NULL) || (hdcDstMemory == NULL)) {
            goto Finish;
        }

        //
        // Create a compatible bitmap for the conversion of the card
        // bitmap, blt the loaded bitmap to the compatible bitmap, and
        // delete the original bitmap.
        //

        hbmDstBitmap = CreateCompatibleBitmap(hdc, dxCard, dyCard);
        if (hbmDstBitmap == NULL) {
            goto Finish;
        }

        hSrcOld = SelectObject(hdcSrcMemory, hbmCard[cd]);
        hDstOld = SelectObject(hdcDstMemory, hbmDstBitmap);
        BitBlt(hdcDstMemory, 0, 0, dxCard, dyCard, hdcSrcMemory, 0, 0, SRCCOPY);
        SelectObject(hdcSrcMemory, hSrcOld);
        SelectObject(hdcDstMemory, hDstOld);
        DeleteObject(hbmCard[cd]);
        hbmCard[cd] = hbmDstBitmap;

        //
        // Delete the compatible DCs.
        //

        DeleteDC(hdcDstMemory);
        DeleteDC(hdcSrcMemory);
    }

Finish:
    return hbmCard[cd];
}


VOID MyDeleteHbm(HBITMAP hbm)
        {
        if(hbm != NULL)
                DeleteObject(hbm);
        }

VOID APIENTRY cdtTerm()
/*
 * Free up space if it's time to do so.
 *
 * Parameters:
 *      none
 *
 * Returns:
 *      nothing
 */
        {
        INT     i;
#ifdef DLL
        if (--cInits > 0) return;
#endif

        for (i = 0; i < 52; i++) {
            MyDeleteHbm(hbmCard[i]);
            hbmCard[i] = NULL;
        }

        MyDeleteHbm(hbmGhost);
        MyDeleteHbm(hbmBack);
        MyDeleteHbm(hbmDeckX);
        MyDeleteHbm(hbmDeckO);
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\col.c ===
#include "sol.h"
VSZASSERT

BOOL fMegaDiscardHack = fFalse;   /* See klond.c's DiscardMove  */


MOVE move = {0};	   /* move data, pointed to by current pcol->pmove  */



COLCLS *PcolclsCreate(INT tcls, INT (FAR *lpfnColProc)(),
							DX dxUp, DY dyUp, DX dxDn, DY dyDn,
							INT dcrdUp, INT dcrdDn)
{
	COLCLS *pcolcls;

	if((pcolcls = PAlloc(sizeof(COLCLS)))==NULL)
		return NULL;

	Assert(lpfnColProc != NULL);
	pcolcls->tcls = tcls;
	pcolcls->lpfnColProc = lpfnColProc;
	pcolcls->ccolDep = 0;
	pcolcls->dxUp = dxUp;
	pcolcls->dyUp = dyUp;
	pcolcls->dxDn = dxDn;
	pcolcls->dyDn = dyDn;
	pcolcls->dcrdUp = dcrdUp;
	pcolcls->dcrdDn = dcrdDn;
	return pcolcls;
}


COL *PcolCreate(COLCLS *pcolcls, X xLeft, Y yTop, X xRight, Y yBot, INT icrdMax)
{
	COL *pcol;


	if((pcol = PAlloc(sizeof(COL) + (icrdMax-1)*sizeof(CRD)))==NULL)
		return NULL;
	
	if( (pcol->pcolcls = pcolcls) != NULL )
		pcol->lpfnColProc = pcolcls->lpfnColProc;
	
	pcol->rc.xLeft = xLeft;
	pcol->rc.yTop = yTop;
	pcol->rc.xRight = xRight;
	pcol->rc.yBot = yBot;
	pcol->icrdMax = icrdMax;
	pcol->icrdMac = 0;
	pcol->pmove = NULL;
	if(pcol->pcolcls != NULL)
		pcol->pcolcls->ccolDep++;
	return pcol;
}


#ifdef DEBUG
INT SendColMsg(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2)
{
	INT imdbg;
	INT wResult;

	Assert(pcol != NULL);
	imdbg = ILogMsg(pcol, msgc, wp1, wp2, fFalse);

	wResult = (*(pcol->lpfnColProc))(pcol, msgc, wp1, wp2);
	LogMsgResult(imdbg, wResult);
	return wResult;
}
#endif


VOID DrawBackExcl(COL *pcol, PT *ppt)
{
	COLCLS *pcolcls;

	pcolcls = pcol->pcolcls;

	if(pcolcls->dxUp != 0 || pcolcls->dxDn != 0)
		DrawBackground(ppt->x+dxCrd, pcol->rc.yTop, pcol->rc.xRight, pcol->rc.yBot);
	if(pcolcls->dyUp != 0 || pcolcls->dyDn != 0)
		DrawBackground(pcol->rc.xLeft, ppt->y+dyCrd, pcol->rc.xRight, pcol->rc.yBot);
}



BOOL DefFreeCol(COL *pcol)
{
	COLCLS *pcolcls;

	if((pcolcls = pcol->pcolcls) != NULL)
		{
		pcolcls = pcol->pcolcls;
		Assert(pcolcls->ccolDep > 0);
		if(--pcolcls->ccolDep == 0)
			{
			FreeP(pcol->pcolcls);
			}
		}
	FreeP(pcol);
	return fTrue;
}


	
INT DefHit(COL *pcol, PT *ppt, INT icrdMin)
{
	INT icrd;
	CRD *pcrd;
	HDC hdc, hdcCurSav;
	PT ptCrd;
	RC rc;
	INT OldusehdcCur;

	if(!PtInRect((LPRECT)&pcol->rc, *(POINT *)ppt) || pcol->icrdMac == 0)
		return icrdNil;
	for(icrd = pcol->icrdMac-1; icrd >= icrdMin && (pcrd = &pcol->rgcrd[icrd])->fUp; icrd--)
		{
	 	if(FPtInCrd(pcrd, *ppt))
			{
			move.ccrdSel = pcol->icrdMac-icrd;
			/* save where mouse hit card */
			ptCrd = pcol->rgcrd[icrd].pt;
			move.delHit.dx = ptCrd.x - ppt->x;
			move.delHit.dy = ptCrd.y - ppt->y;

			if(fOutlineDrag)
				goto Return;

			hdc = GetDC(hwndApp);
			if(hdc == NULL)

				{
// No longer referenced label.
//
//OOM0:
				OOM();
				return icrdNil;
				}
				
			move.hdcScreen = hdc;
			move.dyCol = dyCrd+(move.ccrdSel-1)*pcol->pcolcls->dyUp;

			rc.xRight = (rc.xLeft = ptCrd.x) + dxCrd;
			rc.yTop = ptCrd.y;
			rc.yBot = rc.yTop+move.dyCol;

			/* optimization:  if column already drawn and visible on screen */
			/* then blt it to col image right here. */
			if(FRectAllVisible(hdc, &rc))
				{
				BitBlt(move.hdcCol, 0, 0, dxCrd, move.dyCol, hdc, ptCrd.x, ptCrd.y, SRCCOPY);	
				}
			else
				{
				OldusehdcCur = usehdcCur;
				usehdcCur = 1;
				hdcCurSav = HdcSet(move.hdcCol, ptCrd.x, ptCrd.y);
				DrawBackground(ptCrd.x, ptCrd.y, pcol->rc.xRight, pcol->rc.yBot);
				SendColMsg(pcol, msgcRender, icrd, pcol->icrdMac);
				HdcSet(hdcCurSav, 0, 0);
				usehdcCur = OldusehdcCur;
				}
				
			OldusehdcCur = usehdcCur;
			usehdcCur = 1;
			hdcCurSav = HdcSet(move.hdcScreenSave, ptCrd.x, ptCrd.y);
			DrawBackground(ptCrd.x, ptCrd.y, pcol->rc.xRight, pcol->rc.yBot);
			SendColMsg(pcol, msgcRender, icrd-1, WMax(0, icrd));
			HdcSet(hdcCurSav, 0, 0);
			usehdcCur = OldusehdcCur;

Return:
			pcol->pmove = &move;
			move.icrdSel = icrd;
			return icrd;				
			}
		}
	return icrdNil;
}



BOOL DefMouseUp(COL *pcol, PT *pptPrev, BOOL fRender)
{
	MOVE *pmove;
	VOID DrawOutline();

	if(fRender)
		SendColMsg(pcol, msgcZip, 0, 0);

	if(fOutlineDrag)
		{
		if(pptPrev->x != ptNil.x)
			SendColMsg(pcol, msgcDrawOutline, (INT_PTR) pptPrev, (INT_PTR) &ptNil);
		return fTrue;
		}

	pmove = pcol->pmove;
	if (pcol->pmove == NULL)
		return fTrue;

	if(pmove->fHdc)
		{
		if(pptPrev->x != ptNil.x)	
			{
			BitBlt(pmove->hdcScreen, pptPrev->x+pmove->delHit.dx, pptPrev->y+pmove->delHit.dy,
				dxCrd, pmove->dyCol, pmove->hdcScreenSave, 0, 0, SRCCOPY);
			}

		if(fRender)
			{
			SendColMsg(pcol, msgcRender, pmove->icrdSel-1, icrdToEnd);
			}

		ReleaseDC(hwndApp, pmove->hdcScreen);
		pmove->hdcScreen = NULL;
			
		}
	return fTrue;
}



/* Removes cards from pcol and puts them into pcolTemp */
/* ccrdSel and icrdSel must be set in pcol->pmove */
BOOL DefRemove(COL *pcol, COL *pcolTemp)
{
    INT icrdSel;
    INT ccrdSel;
    INT ccrdShiftDown;     /* amount left over in pcol */

    Assert(pcol->pmove != NULL);
    if (pcol->pmove == NULL)
	return fTrue;

    icrdSel = pcol->pmove->icrdSel;
    ccrdSel = pcol->pmove->ccrdSel;
    Assert(ccrdSel <= pcolTemp->icrdMax);
    /* save the cards to remove in pcolTemp */
    bltb(&pcol->rgcrd[icrdSel], &pcolTemp->rgcrd[0], sizeof(CRD) * ccrdSel);
    pcolTemp->icrdMac = ccrdSel;

    /* remove the cards from pcol */
    Assert(icrdSel+ccrdSel <= pcol->icrdMax);
    ccrdShiftDown = pcol->icrdMac - (icrdSel+ccrdSel);

    /* copy down any left over above the deleted cards */
    if (ccrdShiftDown > 0)
    {
        bltb(&pcol->rgcrd[icrdSel+ccrdSel], &pcol->rgcrd[icrdSel],
                sizeof(CRD) * ccrdShiftDown);
    }
    pcol->icrdMac -= ccrdSel;     /* no longer have this many cards */
/*  pcol->pmove = NULL;  Done in DefEndSel.. */
    return fTrue;
}

/* insert cards from pcolTemp into pcol at icrd */

BOOL DefInsert(COL *pcol, COL *pcolTemp, INT icrd)
{
	INT icrdT;

	icrdT = icrd == icrdToEnd ? pcol->icrdMac : icrd;

	Assert(icrdT <= pcol->icrdMac);
	Assert(pcol->icrdMac+pcolTemp->icrdMac <= pcol->icrdMax);
	/* is it the hard case of inserting in the middle of a col? */
	/* if so, expand pcol->rgcrd */
	if(icrd != icrdToEnd)
		bltb(&pcol->rgcrd[icrdT], &pcol->rgcrd[icrdT+pcolTemp->icrdMac],
			sizeof(CRD) * pcolTemp->icrdMac);
	else
		icrd = pcol->icrdMac;

	/* Insert the cards from pcolTemp to pcol */
	bltb(&pcolTemp->rgcrd[0], &pcol->rgcrd[icrdT], sizeof(CRD) * pcolTemp->icrdMac);

	pcol->icrdMac += pcolTemp->icrdMac;
	pcolTemp->icrdMac = 0;
	return fTrue;
}


BOOL DefMove(COL *pcolDest, COL *pcolSrc, INT icrd)
{
	INT icrdMacDestSav, icrdSelSav;
	COL *pcolTemp;
	BOOL fResult;
	BOOL fZip;

	fZip = icrd & bitFZip;
	icrd &= icrdMask;
	Assert(pcolSrc->pmove != NULL);
	if (pcolSrc->pmove == NULL)
		return fTrue;

	icrdSelSav = WMax(pcolSrc->pmove->icrdSel-1, 0);
	icrdMacDestSav = (icrd == icrdToEnd) ? pcolDest->icrdMac : icrd;
	if((pcolTemp = PcolCreate(NULL, 0, 0, 0, 0, pcolSrc->pmove->ccrdSel)) == NULL)
		return fFalse;

	fResult = SendColMsg(pcolSrc, msgcRemove, (INT_PTR)pcolTemp, 0) &&
		SendColMsg(pcolDest, msgcInsert, (INT_PTR) pcolTemp, icrd) &&
		SendColMsg(pcolDest, msgcComputeCrdPos, icrdMacDestSav, fFalse) &&
		(!fZip || SendColMsg(pcolSrc, msgcZip, 0, 0)) &&
		(!fOutlineDrag || SendColMsg(pcolSrc, msgcRender, icrdSelSav, icrdToEnd)) &&
		SendColMsg(pcolDest, msgcRender, icrdMacDestSav, icrdToEnd) &&
	  	SendColMsg(pcolSrc, msgcEndSel, fFalse, 0);
	FreeP(pcolTemp);
	return fResult;
}



BOOL DefCopy(COL *pcolDest, COL *pcolSrc, BOOL fAll)
{
	Assert(pcolSrc->icrdMac <= pcolDest->icrdMax);
	if(fAll)
		bltb(pcolSrc, pcolDest, sizeof(COL)+(pcolSrc->icrdMac-1)*sizeof(CRD));
	else
		{
		bltb(pcolSrc->rgcrd, pcolDest->rgcrd, pcolSrc->icrdMac*sizeof(CRD));
		pcolDest->icrdMac = pcolSrc->icrdMac;
		}
	return(SendColMsg(pcolDest, msgcRender, 0, icrdToEnd));
}




BOOL DefRender(COL *pcol, INT icrdFirst, INT icrdLast)
{
	INT icrd;
	INT icrdMac;
	CRD *pcrd, *pcrdPrev;
	COLCLS *pcolcls;

	icrdFirst = WMax(icrdFirst, 0);
	Assert(icrdLast >= 0);
	if(!FGetHdc())
		return fFalse;
	if(pcol->icrdMac == 0 || icrdLast == 0)
		{
		DrawBackground(pcol->rc.xLeft, pcol->rc.yTop, pcol->rc.xRight, pcol->rc.yBot);
		if(icrdLast == 0)
			goto EraseExtra;
		}
	else
		{
		Assert(icrdToEnd >= 0);
		Assert(icrdToEnd > pcol->icrdMac);
		Assert(icrdLast == icrdToEnd || icrdLast <= pcol->icrdMac);
		icrdMac = WMin(pcol->icrdMac, icrdLast);

		for(icrd = icrdFirst; icrd < icrdMac; icrd++)
			{
			pcrd = &pcol->rgcrd[icrd];
			if(icrd == icrdFirst ||
					pcrd->pt.x != pcrdPrev->pt.x || pcrd->pt.y != pcrdPrev->pt.y ||
					pcrd->fUp)
				DrawCard(pcrd);
			pcrdPrev = pcrd;
			}
EraseExtra:
		/* hack to make dealing quicker  */
		if(pgmCur->fDealt || pcol->pcolcls->tcls == tclsDeck)
			{
			pcolcls = pcol->pcolcls;
			pcrd = &pcol->rgcrd[icrdLast == 0 ? 0 : icrdMac-1];
			DrawBackExcl(pcol, &pcrd->pt);
			}
		}

	ReleaseHdc();
	return fTrue;
}


BOOL DefPaint(COL *pcol, PAINTSTRUCT *ppaint)
{
	INT icrd;

	if(ppaint == NULL)
		icrd = 0;
	else
		{
		if(!FRectIsect(&pcol->rc, (RC *)&ppaint->rcPaint))
			return fFalse;

		if(pcol->icrdMac == 0)
			icrd = 0;
		else
			{
			for(icrd = 0; icrd < pcol->icrdMac ;icrd++)
				if(FCrdRectIsect(&pcol->rgcrd[icrd], (RC *)&ppaint->rcPaint))
					break;
			if(icrd == pcol->icrdMac)
				return fFalse;
			}
		}

	return SendColMsg(pcol, msgcRender, icrd, icrdToEnd);
}


/* New super cool dragging, does five blts, but no clippin' */

BOOL DefDrawOutline(COL *pcol, PT *ppt, PT *pptPrev)
{
	HDC hdc, hdcT;
	HBITMAP hbmT;
	MOVE *pmove;
	PT pt, ptPrev;
	DEL del;
	COLCLS *pcolcls;

	Assert(pcol->pmove != NULL);
	pmove = pcol->pmove;
	if (pcol->pmove == NULL)
		return fTrue;

	OffsetPt(ppt, &pmove->delHit, &pt);
	if(pptPrev->x != ptNil.x)	
		OffsetPt(pptPrev, &pmove->delHit, &ptPrev);

	if(fOutlineDrag)
		{
		pcolcls = pcol->pcolcls;
		DrawOutline(&pt, pmove->ccrdSel, 0, pcolcls->dyUp);
		if(pptPrev->x != ptNil.x)
			{
			DrawOutline(&ptPrev, pmove->ccrdSel, 0, pcolcls->dyUp);
			}
		return fTrue;
		}
	
	hdc = pmove->hdcScreen;
	Assert(hdc != NULL);

	hdcT = pmove->hdcT;
	Assert(hdcT != NULL);

	hbmT = pmove->hbmT;
	Assert(hbmT != NULL);

	/* screen to save hdc */
	BitBlt(hdcT, 0, 0, dxCrd, pmove->dyCol, hdc, pt.x, pt.y, SRCCOPY);
	/* if not the first time */
	if(pptPrev->x != ptNil.x)
		{
		del.dx = pptPrev->x - ppt->x;
		del.dy = pptPrev->y - ppt->y;
		/* save old screen to save hdc */
		BitBlt(hdcT, del.dx, del.dy, dxCrd, pmove->dyCol, pmove->hdcScreenSave, 0, 0, SRCCOPY);
		BitBlt(pmove->hdcScreenSave, -del.dx, -del.dy, dxCrd, pmove->dyCol,  pmove->hdcCol, 0, 0, SRCCOPY);
		}

	BitBlt(hdc, pt.x, pt.y, dxCrd, pmove->dyCol, pmove->hdcCol, 0, 0, SRCCOPY);
	
	if(pptPrev->x != ptNil.x)
		{
		BitBlt(hdc, ptPrev.x, ptPrev.y, dxCrd, pmove->dyCol, pmove->hdcScreenSave, 0, 0, SRCCOPY);
		}

	/* swap pmove->hdcT and pmove->hdcScreenSave */
	hdcT = pmove->hdcScreenSave;
	pmove->hdcScreenSave = pmove->hdcT;
	pmove->hdcT = hdcT;

	/* swap pmove->hbmT and pmove->hbmScreenSaveOld */
	hbmT = pmove->hbmScreenSaveOld;
	pmove->hbmScreenSaveOld = pmove->hbmT;
	pmove->hbmT = hbmT;

	return fTrue;
}





BOOL DefComputeCrdPos(COL *pcol, INT icrdFirst, BOOL fAssumeDown)
{
	INT icrd;
	CRD *pcrd;
	COLCLS *pcolcls;
	PT pt;

	Assert(icrdFirst >= 0);
	if(icrdFirst == 0)
		{
		pt.x = pcol->rc.xLeft;
		pt.y = pcol->rc.yTop;
		}
	else
		{
		Assert(icrdFirst < pcol->icrdMac);
		pt = pcol->rgcrd[--icrdFirst].pt;
		/* Used by discard, because discard piles are handled differently  */
		if(fMegaDiscardHack)
			icrdFirst++;
		}

	pcolcls = pcol->pcolcls;
	for(icrd = icrdFirst; icrd < pcol->icrdMac; icrd++)
		{
		pcrd = &pcol->rgcrd[icrd];
		pcrd->pt = pt;
		if(pcrd->fUp && !fAssumeDown)
			{
		  	if(icrd % pcolcls->dcrdUp == pcolcls->dcrdUp-1)
				{
				pt.x += pcolcls->dxUp;
				pt.y += pcolcls->dyUp;
				}
			}
		else if(icrd % pcolcls->dcrdDn == pcolcls->dcrdDn-1)
			{
			pt.x += pcolcls->dxDn;
			pt.y += pcolcls->dyDn;
			}
		}
	return fTrue;
}


VOID InvertCardPt(PT *ppt)
{
	RC rc;

	rc.xRight = (rc.xLeft = ppt->x) + dxCrd;
	rc.yBot = (rc.yTop = ppt->y) + dyCrd;
	
	InvertRc(&rc);
}



INT DefValidMovePt(COL *pcolDest, COL *pcolSrc, PT *ppt)
{
	RC rc;

	Assert(pcolSrc->pmove != NULL);	
	if (pcolSrc->pmove == NULL)
		return fTrue;

	Assert((X *)&(((RC *)(0))->xLeft) == (X *)&(((PT *)(0))->x));
	Assert((Y *)&(((RC *)(0))->yTop) == (Y *)&(((PT *)(0))->y));

	OffsetPt(ppt, &pcolSrc->pmove->delHit, (PT *)&rc);
	rc.xRight = rc.xLeft+dxCrd;
	rc.yBot = rc.yTop+dyCrd;
	if(pcolDest->icrdMac == 0)
		{
		if(!FRectIsect(&rc, &pcolDest->rc))
			return icrdNil;
		}
	else if(!(FCrdRectIsect(&pcolDest->rgcrd[pcolDest->icrdMac-1], &rc)))
		return icrdNil;

	return SendColMsg(pcolDest, msgcValidMove, (INT_PTR) pcolSrc, 0) ? pcolDest->icrdMac : icrdNil;
}	



BOOL DefSel(COL *pcol, INT icrdFirst, INT ccrd)
{
#ifdef DEBUG
	INT icol;

	for(icol = 0; icol < pgmCur->icolMac; icol++)
		Assert(pgmCur->rgpcol[icol]->pmove == NULL);
#endif

	move.delHit.dx = move.delHit.dy = 0;
	if(icrdFirst == icrdEnd)
		{
		if(pcol->icrdMac > 0)
			{
			move.icrdSel = pcol->icrdMac-1;
			move.ccrdSel = 1;
			goto Return;
			}
		else
			return icrdNil;
		}
	if(ccrd == ccrdToEnd)
		ccrd = pcol->icrdMac-icrdFirst;
	Assert(icrdFirst < pcol->icrdMac);
	Assert(icrdFirst+ccrd <= pcol->icrdMac);
	move.icrdSel = icrdFirst;
	move.ccrdSel = ccrd;
Return:	
	pcol->pmove = &move;
	return move.icrdSel;
}



BOOL DefEndSel(COL *pcol, BOOL fReleaseDC)
{
	pcol->pmove = NULL;
	return fTrue;
}


BOOL DefFlip(COL *pcol, BOOL fUp)
{
	INT icrd;
	MOVE *pmove;
	INT icrdMac;
	
	Assert(pcol->pmove != NULL);
	if (pcol->pmove == NULL)
		return fTrue;

	pmove = pcol->pmove;

	icrdMac = pmove->icrdSel+pmove->ccrdSel;
	for(icrd = pmove->icrdSel; icrd < icrdMac; icrd++)
		pcol->rgcrd[icrd].fUp = (short)fUp;
	return fTrue;
}


BOOL DefInvert(COL *pcol)
{
	INT icrdSel, ccrdSel;
	INT icrd, icrdMid;

	Assert(pcol->pmove != NULL);
	if (pcol->pmove == NULL)
		return fTrue;

	icrdSel = pcol->pmove->icrdSel;
	ccrdSel = pcol->pmove->ccrdSel;

	icrdMid = icrdSel+ccrdSel/2;
	for(icrd = icrdSel; icrd < icrdMid; icrd++)
		SwapCards(&pcol->rgcrd[icrd], &pcol->rgcrd[2*icrdSel+ccrdSel-1-icrd]);

	return fTrue;
}


BOOL DefDragInvert(COL *pcol)
{

	if(fOutlineDrag)
		{
		if(!FGetHdc())
			return fFalse;
		Assert((X *)&((RC *)(0))->xLeft == (X *)&((PT *)(0))->x);
		Assert((Y *)&((RC *)(0))->yTop == (Y *)&((PT *)(0))->y);
		InvertCardPt(pcol->icrdMac > 0 ? &pcol->rgcrd[pcol->icrdMac-1].pt : (PT *)&pcol->rc);
		ReleaseHdc();
		}
	return fTrue;
}

INT DefNumCards(COL *pcol, BOOL fUpOnly)
{
	INT icrd;

	if(fUpOnly)
		{
		for(icrd = pcol->icrdMac-1; icrd >= 0 && pcol->rgcrd[icrd].fUp; icrd--)
			;
		Assert(pcol->icrdMac-1-icrd >= 0);
		return pcol->icrdMac-1-icrd;
		}
	else
		return pcol->icrdMac;
}



BOOL DefGetPtInCrd(COL *pcol, INT icrd, PT *ppt)
{
	PT *pptT;
	if(icrd == 0)
		pptT = (PT *)&pcol->rc;
	else
		{
		pptT = &pcol->rgcrd[icrd].pt;
		Assert(icrd < pcol->icrdMac);
		}
	ppt->x = pptT->x+dxCrd/2;
	ppt->y = pptT->y;
	return fTrue;
}





BOOL DefShuffle(COL *pcol)
{
	INT iSwitch;
	CRD crdT;
	INT icrd;
	CRD *pcrdS;
//	INT cdecl rand();

#define iSwitchMax 5

	for(iSwitch = 0; iSwitch < iSwitchMax; iSwitch++)
		{
		for(icrd = 0; icrd < pcol->icrdMac; icrd++)
			{
			pcrdS = &pcol->rgcrd[rand() % pcol->icrdMac];
			crdT = pcol->rgcrd[icrd];
			pcol->rgcrd[icrd] = *pcrdS;
			*pcrdS = crdT;
			}
		}
	return fTrue;
}

#define izipMax 35

VOID APIENTRY DdaProc(INT x, INT y, LPARAM lpextra)
{
	COL *pcol;
	PT pt;

	pcol = (COL *)lpextra;
	if (pcol->pmove == NULL)
		return;

	if(pcol->pmove->izip++ < izipMax)
		return;
	pcol->pmove->izip = 0;
	pt.x = x;
	pt.y = y;
	SendColMsg(pcol, msgcDrawOutline, (INT_PTR) &pt, (INT_PTR) &pgmCur->ptMousePrev);
	pgmCur->ptMousePrev = pt;
}


INT DefZip(COL *pcol)
{
	PT ptDest;
	MOVE *pmove;

	/* When outline-dragging is checked, that starting point can be ptNil and
	 * in this case we draw a line starting from (7FFF, 7FFF) and this
	 * causes the temporary hang! So, avoid the LineDDA() call when the
	 * prev point is ptNil;
	 * Fix for Bug #8182 --SANKAR-- 01-23-90
	 */
	if(pgmCur->ptMousePrev.x == ptNil.x)
	    return(fTrue);

	pmove = pcol->pmove;
	if (pcol->pmove == NULL)
		return fTrue;

	/* Don't use OffsetPt here, it's sense is wrong */
	ptDest = pcol->rgcrd[pmove->icrdSel].pt;
	ptDest.x -= pmove->delHit.dx;
	ptDest.y -= pmove->delHit.dy;

	pmove->izip = 0;
	LineDDA(pgmCur->ptMousePrev.x, pgmCur->ptMousePrev.y, ptDest.x, ptDest.y, DdaProc, (LPARAM) pcol );
	return fTrue;
}


INT DefColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2)
{	
	switch(msgc)
		{
	case msgcInit:
		return fTrue;

	case msgcEnd:
		return DefFreeCol(pcol);

	case msgcClearCol:
		pcol->pmove = NULL;
		pcol->icrdMac = 0;
		/* more? */
		return fTrue;

	case msgcHit:	/* wp1 = ppt, return icrdHit/icrdNil */
		return DefHit(pcol, (PT *)wp1, (INT)wp2);

	case msgcMouseUp:
		return DefMouseUp(pcol, (PT *) wp1, (INT)wp2);

	case msgcDblClk:
		return fFalse;

	case msgcSel:  /* wp1 = icrdSel, icrdEnd if last card, wp2 = ccrdSel, ccrdToEnd if all to end */
		return DefSel(pcol, (INT)wp1, (INT)wp2);

	case msgcEndSel:
		return DefEndSel(pcol, (BOOL)wp1);

	case msgcNumCards:
		return DefNumCards(pcol, (BOOL)wp1);

	case msgcFlip: /* wp1 = fUp */
		return DefFlip(pcol, (BOOL)wp1);

	case msgcInvert:
		return DefInvert(pcol);

	case msgcRemove: 	/* wp1 = pcolTemp, return fTrue/fFalse */
		return DefRemove(pcol, (COL *) wp1);

	case msgcInsert:	/* wp1 = pcolTemp, */
							/* wp2 = icrd to insert after, icrdToEnd if at end*/
		return DefInsert(pcol, (COL *)wp1, (INT)wp2);

	case msgcMove:	 	/* wp1 = pcolSrc, wp2 = icrd, (icrdToEnd = to endcrd) */
			 				/* return fTrue/fFalse */
		return DefMove(pcol, (COL *) wp1, (INT)wp2);

	case msgcCopy:  /* wp1 = pcolSrc, wp2 = fAll (if true then copy all of col struct)*/
		return DefCopy(pcol, (COL *) wp1, (BOOL)wp2);

	case msgcValidMove: /* wp1 = pcolSrc, wp2 = icrd, (icrdToEnd = to endcrd) */
		/* this must be supplied by game */
		return fFalse;

	case msgcValidMovePt:
		return DefValidMovePt(pcol, (COL *) wp1, (PT *)wp2);

	case msgcRender:	/* wp1 = icrdFirst, return fTrue/fFalse*/
		return DefRender(pcol, (INT)wp1, (INT)wp2);
	
	case msgcPaint:	/* wp1 = ppaint, if NULL then paint all */
		return DefPaint(pcol, (PAINTSTRUCT *) wp1);

	case msgcDrawOutline: /* wp1 = ppt , wp2 = pptPrev*/
		return DefDrawOutline(pcol, (PT *) wp1, (PT *) wp2);

	case msgcComputeCrdPos: /* wp1 = icrdFirst */
		return DefComputeCrdPos(pcol, (INT)wp1, (BOOL)wp2);

	case msgcDragInvert:
		return DefDragInvert(pcol);

	case msgcGetPtInCrd:
		return DefGetPtInCrd(pcol, (INT)wp1, (PT *)wp2);

	case msgcValidKbdColSel:
		return fTrue;

	case msgcValidKbdCrdSel:
		return fTrue;

	case msgcShuffle:
		return DefShuffle(pcol);


	case msgcAnimate:
		return fFalse;

	case msgcZip:
		return DefZip(pcol);
		}

	Assert(fFalse);
    return fFalse;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\debug.c ===
#include "sol.h"
#include <io.h>
#include <string.h>
#include "assert.h"
VSZASSERT

#ifdef DEBUG

MDBG rgmdbg[imdbgMax];
WORD lvl = 0;
INT imdbgCur = 0;


VOID InitDebug()
{
    INT imdbg;
    MDBG *pmdbg;

    for(imdbg = 0; imdbg < imdbgMax; imdbg++)
    {
        pmdbg = &rgmdbg[imdbg];
        pmdbg->pgmcol = NULL;
        pmdbg->lvl = 0;
        pmdbg->msg = 0xcccc;
        pmdbg->wp1 = 0xcccc;
        pmdbg->wp2 = 0xcccc;
        pmdbg->wResult = 0xcccc;
    }

    imdbgCur = 0;
    lvl = 0;
}



WORD ILogMsg(VOID *pgmcol, INT msg, WPARAM wp1, LPARAM wp2, BOOL fGm)
{
    MDBG *pmdbg;
    WORD imdbgRet;

    Assert(FInRange(imdbgCur, 0, imdbgMax-1));
    pmdbg = &rgmdbg[imdbgCur];

    Assert(fGm == 0 || fGm == 1);
    pmdbg->pgmcol = pgmcol;
    pmdbg->msg = msg + (fGm << 15);
    pmdbg->wp1 = wp1;
    pmdbg->wp2 = wp2;
    pmdbg->wResult = 0xcccc;
    pmdbg->lvl = lvl;
    lvl++;
    imdbgRet = imdbgCur++;
    imdbgCur %= imdbgMax;
    Assert(FInRange(imdbgCur, 0, imdbgMax-1));
    return imdbgRet;
}



VOID LogMsgResult(INT imdbg, LRESULT wResult)
{
    lvl--;

    Assert(FInRange(imdbg, 0, imdbgMax-1));
    rgmdbg[imdbg].wResult = wResult;
}

VOID WriteCrlf(INT fh)
{
    _write(fh, TEXT("\x0d\n"), sizeof(TCHAR) * 2);
}


VOID WriteSz(INT fh, TCHAR *sz)
{
    _write(fh, sz, lstrlen(sz));
    WriteCrlf(fh);
}

VOID WriteIField(INT fh, TCHAR *szField, INT_PTR ifld)
{
    TCHAR szBuf[128];
    INT cch;

    _write(fh, szField, lstrlen(szField));
    _write(fh, TEXT(" = "), sizeof(TCHAR) *3);
    cch = CchDecodeInt(szBuf, ifld);
    _write(fh, szBuf, cch);
    WriteCrlf(fh);
}




VOID DumpCol(INT fh, COL *pcol)
{
    INT icrd;
    MOVE *pmove;

    WriteCrlf(fh);
    WriteIField(fh, TEXT(">>> *pcol"), (INT_PTR) pcol);
    WriteIField(fh, TEXT("pcolcls->tcls"), pcol->pcolcls->tcls);
    WriteIField(fh, TEXT("icrdMac"), pcol->icrdMac);
    WriteIField(fh, TEXT("pmove"), (INT_PTR) pcol->pmove);
    if(pcol->pmove != NULL)
    {
        pmove = pcol->pmove;
        WriteIField(fh, TEXT("pmove->icrdSel"), pmove->icrdSel);
        WriteIField(fh, TEXT("pmove->ccrdSel"), pmove->ccrdSel);
        WriteIField(fh, TEXT("pmove->delHit.x"), pmove->delHit.dx);
        WriteIField(fh, TEXT("pmove->delHit.y"), pmove->delHit.dy);
        WriteIField(fh, TEXT("pmove->fHdc"), pmove->fHdc);
        WriteIField(fh, TEXT("pmove->dyCol"), pmove->dyCol);
        WriteIField(fh, TEXT("pmove->hdcScreen"), (INT_PTR)pmove->hdcScreen);

        WriteIField(fh, TEXT("pmove->hdcCol"), (INT_PTR)pmove->hdcCol);
        WriteIField(fh, TEXT("pmove->hbmColOld"), (INT_PTR)pmove->hbmColOld);

        WriteIField(fh, TEXT("pmove->hdcScreenSave"), (INT_PTR)pmove->hdcScreenSave);
        WriteIField(fh, TEXT("pmove->hbmScreenSaveOld"), (INT_PTR)pmove->hbmScreenSaveOld);

        WriteIField(fh, TEXT("pmove->hdcT"), (INT_PTR)pmove->hdcT);
        WriteIField(fh, TEXT("pmove->hbmT"), (INT_PTR)pmove->hbmT);
    }
    for(icrd = 0; icrd < pcol->icrdMac; icrd++)
    {
        WriteIField(fh, TEXT("\t-card "), icrd);
        WriteIField(fh, TEXT("\t    cd"), pcol->rgcrd[icrd].cd);
        WriteIField(fh, TEXT("\t   fUp"), pcol->rgcrd[icrd].fUp);
        WriteIField(fh, TEXT("\t  pt.x"), pcol->rgcrd[icrd].pt.x);
        WriteIField(fh, TEXT("\t  pt.y"), pcol->rgcrd[icrd].pt.y);
    }
}


VOID DumpGm(INT fh, GM *pgm)
{
    INT icol;

    WriteIField(fh, TEXT("pgm"), (INT_PTR) pgm);
    WriteIField(fh, TEXT("udr.fAvail"), pgm->udr.fAvail);
    WriteIField(fh, TEXT("udr.sco"), pgm->udr.sco);
    WriteIField(fh, TEXT("udr.icol1"), pgm->udr.icol1);
    WriteIField(fh, TEXT("udr.icol2"), pgm->udr.icol2);
    WriteIField(fh, TEXT("udr.rgpcol[1]"), (INT_PTR) pgm->udr.rgpcol[1]);
    WriteIField(fh, TEXT("udr.rgpcol[2]"), (INT_PTR) pgm->udr.rgpcol[2]);
    WriteIField(fh, TEXT("fDealt"), pgm->fDealt);
    WriteIField(fh, TEXT("fWon"), pgm->fWon);
    WriteIField(fh, TEXT("fInput"), pgm->fInput);
    WriteIField(fh, TEXT("sco"), pgm->sco);
    WriteIField(fh, TEXT("iqsecScore"), pgm->iqsecScore);
    WriteIField(fh, TEXT("dqsecScore"), pgm->dqsecScore);
    WriteIField(fh, TEXT("ccrdDeal"), pgm->ccrdDeal);
    WriteIField(fh, TEXT("irep"), pgm->irep);
    WriteIField(fh, TEXT("ptMousePrev->x"), pgm->ptMousePrev.x);
    WriteIField(fh, TEXT("ptMousePrev->y"), pgm->ptMousePrev.y);
    WriteIField(fh, TEXT("fButtonDown"), pgm->fButtonDown);
    WriteIField(fh, TEXT("icolKbd"), pgm->icolKbd);
    WriteIField(fh, TEXT("icrdKbd"), pgm->icrdKbd);
    WriteIField(fh, TEXT("icolSel"), pgm->icolSel);
    WriteIField(fh, TEXT("icolHilight"), pgm->icolHilight);
    WriteIField(fh, TEXT("icolMac"), pgm->icolMac);
    WriteIField(fh, TEXT("icolMax"), pgm->icolMax);
    for(icol = 0; icol < pgm->icolMac; icol++)
        DumpCol(fh, pgm->rgpcol[icol]);
}

TCHAR *PchDecodeWp(TCHAR *pch, INT_PTR wp)
{
    INT icol;

    if(pgmCur == NULL)
            return pch;
    if((GM *) wp == pgmCur)
            return PszCopy(TEXT("(pgmCur)"), pch);

    for(icol = 0; icol < pgmCur->icolMac; icol++)
    {
        if((struct _col *) wp == pgmCur->rgpcol[icol])
        {
            pch = PszCopy(TEXT("(col "), pch);
            pch += CchDecodeInt(pch, icol);
            *pch++ = TEXT(')');
            break;
        }
    }
    return pch;
}


VOID DumpRgmdbg(TCHAR *szFile, INT li)
{
    OFSTRUCT of;
    INT fh;
    INT imdbg;
    USHORT lvl;
    MDBG *pmdbg;
    TCHAR szBuf[128];
    TCHAR *pch;


    if((fh = (OpenFile("sol.dbg", &of, OF_CREATE|OF_WRITE))) == -1)
            return;

    WriteSz(fh, TEXT("Assertion Failure"));
    WriteIField(fh, szFile, li);
    WriteSz(fh, szVer);
    WriteIField(fh, TEXT("Game #"), igmCur);
    WriteCrlf(fh);



    /* write game and col structs */
    if(pgmCur != NULL)
            DumpGm(fh, pgmCur);

    imdbg = imdbgCur;
    do
    {
        Assert(FInRange(imdbgCur, 0, imdbgMax-1));
        pmdbg = &rgmdbg[imdbg];
        Assert(pmdbg->lvl < 60);
        for(lvl = 0; lvl < pmdbg->lvl; lvl++)
                _write(fh, TEXT("\t"), 1);
        pch = PchDecodeWp(szBuf, (INT_PTR) pmdbg->pgmcol);
        pmdbg->msg &= 0x7fff;
        *pch++ = TEXT(' ');
        pch += CchDecodeInt(pch, pmdbg->msg);
        *pch++ = TEXT(',');
        *pch++ = TEXT(' ');
        pch += CchDecodeInt(pch, pmdbg->wp1);
        pch = PchDecodeWp(pch, pmdbg->wp1);
        *pch++ = TEXT(',');
        *pch++ = TEXT(' ');
        pch += CchDecodeInt(pch, pmdbg->wp2);
        pch = PchDecodeWp(pch, pmdbg->wp2);
        *pch++ = TEXT(' ');
        *pch++ = TEXT('-');
        *pch++ = TEXT('>');
        *pch++ = TEXT(' ');
        pch += CchDecodeInt(pch, pmdbg->wResult);
        _write(fh, szBuf, (int)(pch-szBuf));
        WriteCrlf(fh);

        imdbg--;
        if(imdbg < 0)
            imdbg = imdbgMax-1;
        Assert(FInRange(imdbg, 0, imdbgMax-1));
    } while(imdbg != imdbgCur);

    _close(fh);
}





/* Puts msg on bottom of screen.  Useful because I don't have a debug console now */
VOID DisplayMsg(TCHAR *sz, INT msgc, INT wp1, INT wp2)
{

    INT y;
    INT x;
    HDC hdc;
    INT cch;
    TCHAR szInt[20];
    TEXTMETRIC tm;

    if(fScreenShots)
        return;

    x = 0;

    hdc = GetDC(hwndApp);
    GetTextMetrics(hdc, (LPTEXTMETRIC)&tm);
    y = 0;/*        dyScreen - tm.tmHeight; */

    TextOut(hdc, x, y, TEXT("                         "), 24);
    TextOut(hdc, x, y, sz, cch = lstrlen(sz));
    x += (cch+1) * tm.tmMaxCharWidth;

    cch = CchDecodeInt(szInt, msgc);
    TextOut(hdc, x, y, szInt, cch);
    x += (cch+1) * tm.tmAveCharWidth;

    cch = CchDecodeInt(szInt, wp1);
    TextOut(hdc, x, y, szInt, cch);
    x += (cch+1) * tm.tmAveCharWidth;

    cch = CchDecodeInt(szInt, wp2);
    TextOut(hdc, x, y, szInt, cch);
    x += (cch+1) * tm.tmAveCharWidth;

    ReleaseDC(hwndApp, hdc);
}

VOID PrintCardMacs(GM *pgm)
{
    INT icol;
    TCHAR sz[20];
    INT cch;
    HDC hdc;

    hdc = GetDC(hwndApp);
    for(icol = 0; icol < pgm->icolMac; icol++)
    {
        cch = CchDecodeInt(sz, pgm->rgpcol[icol]->icrdMac);
        TextOut(hdc, 30 * icol, 10, sz, cch);
    }
    ReleaseDC(hwndApp, hdc);
}



INT_PTR APIENTRY GameNo(HWND hdlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL fTranslated;
    INT igmNext;

    if (iMessage == WM_COMMAND)
    {
        if( GET_WM_COMMAND_ID( wParam, lParam ) == IDOK )
        {
            igmNext = GetDlgItemInt(hdlg, ideGameNoEdit, &fTranslated, fFalse);
            if(fTranslated && igmNext >= 0)
                igmCur = igmNext;
            else
            {
                Error(TEXT("Invalid game number"));
                return fFalse;
            }
        }
        if(wParam == IDOK || wParam == IDCANCEL)
            EndDialog(hdlg, wParam == IDOK);
        return fTrue;
    }
    else if (iMessage == WM_INITDIALOG)
    {
        SetDlgItemInt(hdlg, ideGameNoEdit, igmCur, fFalse);
        return fTrue;
    }
    else
        return fFalse;
}



BOOL FSetGameNo()
{
    BOOL fResult;

    if(fResult = (BOOL)DialogBox(hinstApp,
                                 MAKEINTRESOURCE(iddGameNo),
                                 hwndApp,
                                 GameNo))

        srand(igmCur);
    return fResult;
}






BOOL FValidCol(COL *pcol)
{
    INT icol;

    if(pcol == NULL)
        return fFalse;

    for(icol = 0; icol < pgmCur->icolMax; icol++)
    {
        if(pcol == pgmCur->rgpcol[icol])
        {
            if(pcol->pcolcls == NULL)
                return fFalse;
            if(pcol->icrdMac > pcol->icrdMax)
                return fFalse;

            return fTrue;
        }
    }
    return fFalse;
}


TCHAR *vszFile;
INT vli;

TCHAR vszLi[32];

INT_PTR APIENTRY AssertDlgProc(HANDLE hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{

    switch(wm)
    {
        case WM_INITDIALOG:
            SetWindowText(GetDlgItem(hdlg, FILE), vszFile);
            CchDecodeInt(vszLi, vli);
            SetWindowText(GetDlgItem(hdlg, LINE), vszLi);
            CchDecodeInt(vszLi, igmCur);
            SetWindowText(GetDlgItem(hdlg, GAMENO), vszLi);
         /* SetWindowText(GetDlgItem(hdlg, SOLVERSION), szVer); */
            break;
        case WM_COMMAND:
            switch( GET_WM_COMMAND_ID( wParam, lParam ))
            {
                default:
                    return fFalse;
                case IDOK:
                    EndDialog(hdlg, 0);
                    break;
                case EXIT:
                    EndDialog(hdlg, 1);
                    break;
             }
            break;

        default:
                return fFalse;
    }

    return fTrue;
}


VOID AssertFailed(TCHAR *szFile, INT li)
{
    INT f;

    vszFile = szFile;
    vli = li;

    f = (INT)DialogBox(hinstApp,
                       MAKEINTRESOURCE(ASSERTFAILED),
                       hwndApp,
                       AssertDlgProc);


    DumpRgmdbg(szFile, li);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\crd.h ===
#include "cdt.h"


typedef INT CD;

/* CaRD struct, this is what a card be */
typedef struct _crd
	{
	WORD cd  : 15;		/* card # (1..52) */
	WORD fUp : 1;		/* is this card up/down */
	PT pt;					/* upper-left corner of card */
	} CRD;




/* WARNING: Order of su's is assumed */
#define suClub 0
#define suDiamond 1
#define suHeart 2
#define suSpade 3
#define suMax 4
#define suFirst suClub

#define raAce 0
#define raDeuce 1
#define raTres 2
#define raFour 3
#define raFive 4
#define raSix 5
#define raSeven 6
#define raEight 7
#define raNine 8
#define raTen 9
#define raJack 10
#define raQueen 11
#define raKing 12
#define raMax 13
#define raNil 15
#define raFirst raAce

typedef INT RA;
typedef INT SU;

#define cdNil 0x3c


#define cIDFACEDOWN (IDFACEDOWNLAST-IDFACEDOWNFIRST+1)

#define SuFromCd(cd) ((cd)&0x03)
#define RaFromCd(cd) ((cd)>>2)
#define Cd(ra, su) (((ra)<<2)|(su))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\debug.h ===
#include <stdlib.h>

typedef struct
	{
	VOID *pgmcol;
	WORD lvl;
	INT msg;
	WPARAM wp1;
	LPARAM wp2;
	LRESULT wResult;
	} MDBG;



#define imdbgMax 500

VOID PrintCardMacs( GM * );
BOOL FSetGameNo( VOID );
VOID InitDebug( VOID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\col.h ===
/* COLumn CLaSs struct */
typedef struct _colcls
{
    INT tcls;                   /* class type  */
    INT (FAR *lpfnColProc)();
    INT ccolDep;                /* # of dependent columns */
    DX  dxUp;                   /* up card offsets */
    DY  dyUp;
    DX  dxDn;                   /* down card offsets */
    DY  dyDn;
    INT dcrdUp;                 /* up # of cards between ofsetting */
    INT dcrdDn;                 /* down # of cards between ofsetting */
} COLCLS;


/* MOVE struct, only set up while dragging */
typedef struct _move
{
    INT     icrdSel;          /* current card sel */
    INT     ccrdSel;          /* # of cards selected */
    DEL     delHit;           /* negative of offset from card where mouse hit */
    BOOL    fHdc;             /* TRUE if hdc's are allocated */
    DY      dyCol;            /* height of col (BUG: can only drag vert cols) */
    HDC     hdcScreen;

    HDC     hdcCol;           /*  the column */
    HBITMAP hbmColOld;        /* original hbm in hdcCol */

    HDC     hdcScreenSave;    /* save buffer for screen */
    HBITMAP hbmScreenSaveOld; /* original hbm in hdcScreenSave */
    
    HDC     hdcT;
    HBITMAP hbmT;
    INT     izip;
} MOVE;




/* COL struct, this is what a column o' cards is */
typedef struct _col
{
    COLCLS *pcolcls;          /* class of this instance */
    INT (FAR *lpfnColProc)(); /* duplicate of fn in colcls struct (for efficiency) */
    RC rc;                    /* bounding rectangle of this col */
    MOVE *pmove;              /* move info, only valid while draggin */
    INT icrdMac;                
    INT icrdMax;
    CRD rgcrd[1];
} COL;

/* SCOre */
typedef INT SCO;

// Constants - earlier they were generated in the col.msg file.

#define icolNil             -1
#define msgcNil             0		  
#define msgcInit            1		  
#define msgcEnd             2		  
#define msgcClearCol        3	   
#define msgcNumCards        4     
#define msgcHit             5		  
#define msgcSel             6		  
#define msgcEndSel          7	  
#define msgcFlip            8		  
#define msgcInvert          9	  
#define msgcMouseUp         10	  
#define msgcDblClk          11	  
#define msgcRemove          12	  
#define msgcInsert          13	  
#define msgcMove            14		  
#define msgcCopy            15		  
#define msgcValidMove       16  
#define msgcValidMovePt     17  
#define msgcRender          18	  
#define msgcPaint           19		  
#define msgcDrawOutline     20  
#define msgcComputeCrdPos   21
#define msgcDragInvert      22  
#define msgcGetPtInCrd      23  
#define msgcValidKbdColSel  24
#define msgcValidKbdCrdSel  25
#define msgcShuffle         26
#define msgcAnimate         27
#define msgcZip             28



#ifdef DEBUG
INT SendColMsg(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2);
#else
#define SendColMsg(pcol, msgc, wp1, wp2) \
    (*((pcol)->lpfnColProc))((pcol), (msgc), (wp1), (wp2))    
#endif
INT DefColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2);
VOID OOM( VOID );
VOID DrawOutline( PT *, INT, DX, DY );

/*---------------------------------------------------------------------------
     --------------------> Message explanations <---------------------

    // WARNING: probably totally out-o-date

msgcNil:
    Nil Message, not used 
    wp1:         N/A
    wp2:        N/A
    returns:    TRUE

msgcInit:
    Sent when a column in created.  (currently not used)
    wp1:        N/A
    wp2:       N/A
    returns    TRUE

msgcEnd:
    Sent when a column is destroyed.  Frees pcol
    wp1:        N/A
    wp2:       N/A
    returns     TRUE
    
msgcClearCol:
    Sent to clear a column of it's cards
    wp1:        N/A
    wp2:       N/A
    returns     TRUE

msgcHit:
    Checks if a card is hit by the mouse.  pcol->delHit is set to the
    point where the mouse hit the card relative to the upper right
    corner of the card.  Sets pcol->icrdSel and pcol->ccrdSel
    wp1:        ppt
    wp2:        N/A
    returns: icrd if hit, icrdNil if no hit.  May return icrdEmpty if hit
                an empty column

msgcSel:
    Selects cards in the column for future moves.  Sets pcol->icrdSel and
    pcol->ccrdSel;
    wp1:        icrdFirst, first card to select; icrdEnd selects last card
    wp2:        ccrdSel, # of cards to select; ccrdToEnd selects to end of col
    returns:    TRUE/FALSE

msgcFlip:
    Flips cards to fUp
    wp1:        fUp, TRUE if to flip cards up, FALSE to flip down
    wp2:        N/A
    returns:    TRUE/FALSE

msgcInvert:
    Inverts order of cards selected in pcol
    Often used for dealing to discard.
    wp1:        N/A
    wp2:        N/A
    returns: TRUE/FALSE

msgcRemove:
    Removes cards from pcol and places them in pcolTemp (wp1)
    pcolTemp must be larger than the number of cards selected
    wp1:        pcolTemp, must be of class tcls == tclsTemp
    wp2:        N/A
    returns:    TRUE/FALSE

msgcInsert:
    Inserts all cards from pcolSrc into pcol at icrdInsAfter (wp2)  
    pcol must be large enough to accomodate the cards.
    wp1:        pcolTemp, must be of class tcls == tclsTemp
    wp2:        icrdInsAfter, card to insert after.  icrdToEnd if append to end of col
    returns:    TRUE/FALSE

msgcMove:
    Combines msgcRemove, msgcInsert, and rendering.
    Moves cards from pcolSrc into pcolDest at icrdInsAfter.  Computes new
    card positions and sends render messages to both columns
    wp1:        pcolSrc
    wp2:        icrdInsAfter, card to insert after. may be '|'ed with flags:
                    icrdInvert : Inverts order of cards
    returns:    TRUE/FALSE

msgcCopy:
    Copies pcolSrc into pcol.  pcol must be large enough
    wp1:        pcolSrc
    wp2:        fAll,  If true then entire structure is copied, else just the cards
    returns:    TRUE/FALSE

msgcValidMove:  ***** MUST BE SUPPLIED BY GAME, NO DEFAULT ACTION ******
    Determines if a move is valid.
    wp1:        pcolSrc
    wp2:        N/A
    returns:    TRUE/FALSE


msgcValidMovePt:
    Determines if a card being dragged over a column is a valid move.
    Sends msgcValidMove if card overlaps
    wp1:        pcolSrc
    wp2:        pptMouse
    returns:    icrdHit/icrdNil

msgcRender
    Renders the column starting at icrdFirst
    wp1:        icrdFirst
    wp2:        N/A
    return:    TRUE/FALSE

msgcPaint:
    Renders column if it intersects the paint update rect
    wp1:        ppaint, if NULL then renders entire column
    wp2:        N/A
    returns: TRUE/FALSE


msgcDrawOutline:
    Draws outline of cards when being dragged by mouse
    wp1:        pptMouse
    wp2:        N/A
    returns: TRUE/FALSE

msgcComputeCrdPos:
    Computes position of cards based on colcls.{dxcrdUp|dxcrdDn|dycrdUp|dycrdDn}
    wp1:        icrdFirst, first card to compute
    wp2:        N/A
    returns:    TRUE

msgcDragInvert:
    Inverts the topmost card in the pile
    wp1:        N/A
    wp2:        N/A
    returns: TRUE/FALSE

-----------------------------------------------------------------------------*/




#define icrdNil       0x1fff
#define icrdEmpty     0x1ffe

#define icrdToEnd     0x1ffd
#define ccrdToEnd     -2

#define icrdEnd       0x1ffc


/* special flags |'d with icrd for msgcMove */
#define bitFZip       0x2000
#define icrdMask      0x1fff
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\game.c ===
#include "sol.h"
VSZASSERT




VOID FreeGm(GM *pgm)
{
    INT icol;
    COL *pcol;

    if(pgm != NULL)
    {
        for(icol = pgm->icolMac-1; icol >= 0; icol--)
            if((pcol = pgm->rgpcol[icol]) != NULL)
                SendColMsg(pcol, msgcEnd, 0, 0);
        if(pgm == pgmCur)
            pgmCur = NULL;
        FreeUndo(&pgm->udr);
        FreeP(pgm);
    }
}


BOOL FCreateDCBM(HDC hdc, HDC *phdc, HBITMAP *phbmOld, DY dyCol)
{
    HDC hdcT;
    HBITMAP hbm;

    if((hdcT = CreateCompatibleDC(hdc)) == NULL)
        return fFalse;

    if((hbm = CreateCompatibleBitmap(hdc, dxCrd, dyCol)) == NULL)
    {
        Error:
        DeleteDC(hdcT);
        return fFalse;
    }

    if((*phbmOld = SelectObject(hdcT, hbm)) == NULL)
    {
        /* Delete the bitmap */
        DeleteObject(hbm);
        goto Error;
    }
    *phdc = hdcT;

    return fTrue;
}


BOOL FSetDrag(BOOL fOutline)
    {
    HDC hdc;

    fOutlineDrag = fOutline;

    if(fOutline && move.fHdc)
    {
        Assert(move.hdcScreenSave);
        Assert(move.hdcCol);
        Assert(move.hbmScreenSaveOld);
        Assert(move.hbmColOld);
        Assert(move.hdcT);

        DeleteObject(SelectObject(move.hdcCol, move.hbmColOld));
        DeleteDC(move.hdcCol);

        DeleteObject(SelectObject(move.hdcScreenSave, move.hbmScreenSaveOld));
        DeleteDC(move.hdcScreenSave);

        DeleteObject(SelectObject(move.hdcT, move.hbmT));
        DeleteDC(move.hdcT);
        move.fHdc = fFalse;
    }


    if(!fOutline && !move.fHdc)
    {
        hdc = GetDC(hwndApp);
        if(hdc == NULL)
        {
            OOM:
            ErrorIds(idsNoFullDrag);
            fOutlineDrag = fFalse;
            move.fHdc = fFalse;
            return fFalse;
        }

        move.hdcScreen = NULL;

        if(!FCreateDCBM(hdc, &move.hdcScreenSave, &move.hbmScreenSaveOld, pgmCur->dyDragMax))
        {
            ReleaseDC(hwndApp,hdc);
            goto OOM;
        }

        if(!FCreateDCBM(hdc, &move.hdcT, &move.hbmT, pgmCur->dyDragMax))
        {
            OOM1:

            ReleaseDC(hwndApp,hdc);
            DeleteObject(SelectObject(move.hdcScreenSave, move.hbmScreenSaveOld));
            DeleteDC(move.hdcScreenSave);
            goto OOM;
        }

        if(!FCreateDCBM(hdc, &move.hdcCol, &move.hbmColOld, pgmCur->dyDragMax))
        {
            DeleteObject(SelectObject(move.hdcT, move.hbmT));
            DeleteDC(move.hdcT);
            goto OOM1;
        }

        move.fHdc = fTrue;
        ReleaseDC(hwndApp, hdc);
    }
    return fTrue;
}




BOOL FInitGm()
{
    BOOL FInitKlondGm();

    return FInitKlondGm();
}


#ifdef DEBUG
LRESULT SendGmMsg(GM *pgm, INT msgg, WPARAM wp1, LPARAM wp2)
{
    INT imdbg;
    LRESULT wResult;

    Assert(pgm != NULL);
    imdbg = ILogMsg(pgm, msgg, wp1, wp2, fTrue);

    wResult =(*(pgm->lpfnGmProc))(pgm, msgg, wp1, wp2);
    LogMsgResult(imdbg, wResult);
    return wResult;
}

#endif


BOOL DefGmInit(GM *pgm, BOOL fResetScore)
{

    pgm->fDealt = fFalse;
    if(fResetScore)
        pgm->sco = 0;
    pgm->iqsecScore = 0;
    pgm->irep = 0;
    pgm->icolHilight = pgm->icolSel = icolNil;
    pgm->icolKbd = 0;
    pgm->icrdKbd = 0;
    pgm->fInput = fFalse;
    pgm->fWon = fFalse;
    pgm->ccrdDeal = ccrdDeal;
    return fTrue;
}



BOOL DefGmMouseDown(GM *pgm, PT *ppt, INT icolFirst)
{
    INT icol;

    /* sel already in effect */
    if(FSelOfGm(pgm))
        return fFalse;
    if(!pgm->fDealt)
        return fFalse;
    pgm->fInput = fTrue;
    pgm->fButtonDown = fTrue;
    for(icol = icolFirst; icol < pgm->icolMac; icol++)
    {
        if(SendColMsg(pgm->rgpcol[icol], msgcHit, (INT_PTR) ppt, 0) != icrdNil)
        {
            pgm->icolSel = icol;
            pgm->ptMousePrev = ptNil;

            /* KLUDGE:  in col render, we redraw the column after a selection
               is made.  if the mouse isn't moved, no image of the selected
               card shows up.
            */
            if(!fOutlineDrag)
            {
                /* SendGmMsg(pgm, msggMouseMove, (INT_PTR) ppt, 0); */
                pgm->ptMousePrev = *ppt;
            }
            return fTrue;
        }
    }
    return fFalse;
}

BOOL DefGmMouseUp(GM *pgm, PT *pptBogus, BOOL fNoMove)
{
    COL *pcolSel, *pcolHilight;
    BOOL fResult = fFalse;

    pgm->fButtonDown = fFalse;
    if(FSelOfGm(pgm))
    {
        pcolSel = pgm->rgpcol[pgm->icolSel];
        if(FHilightOfGm(pgm))
        {
            pcolHilight = pgm->rgpcol[pgm->icolHilight];
            SendGmMsg(pgm, msggSaveUndo, pgm->icolHilight, pgm->icolSel);
            SendColMsg(pcolHilight, msgcDragInvert, 0, 0);
            if(fNoMove)
            {
                SendColMsg(pcolSel, msgcMouseUp, (INT_PTR) &pgm->ptMousePrev, fTrue);
                fResult = fTrue;
                goto Return;
            }
            SendColMsg(pcolSel, msgcMouseUp, (INT_PTR) &pgm->ptMousePrev, fFalse);
            fResult = SendColMsg(pcolHilight, msgcMove, (INT_PTR) pcolSel, icrdToEnd) &&
                SendGmMsg(pgm, msggScore, (INT_PTR) pcolHilight, (INT_PTR) pcolSel);
            pgm->icolHilight = icolNil;
            if(SendGmMsg(pgm, msggIsWinner, 0, 0))
                SendGmMsg(pgm, msggWinner, 0, 0);
        }
        else
            SendColMsg(pcolSel, msgcMouseUp, (INT_PTR) &pgm->ptMousePrev, fTrue);

        Return:
        SendColMsg(pcolSel, msgcEndSel, fFalse, 0);
        }
    pgm->icolSel = icolNil;
    return fResult;
}



BOOL DefGmMouseDblClk(GM *pgm, PT * ppt)
{
    INT icol;

    for(icol = 0; icol < pgm->icolMac; icol++)
        if(SendColMsg(pgm->rgpcol[icol], msgcDblClk, (INT_PTR) ppt, icol))
            return fTrue;
    return fFalse;
}



// This routine moves all the "playable" cards
// to the four suit stacks.
// It's invoked when the user right-clicks or
// presses Ctrl-A.


BOOL DefGmMouseRightClk(GM *pgm, PT * ppt)
{
    INT icol;
    CRD *pcrd;
    INT icolDest;
    COL *pcolDest;
    BOOL fResult;
    COL *pcol;
    INT  iContinue;

    fResult = fFalse;

    // Keep doing this as long as in every iteration
    // we move one card to the suit stack.
    do
    {
        iContinue = 0;
        for(icol = 0; icol < pgm->icolMac; icol++)
        {
            // We don't want to move cards from one suit stack
            // to another.
            if (icol >= icolFoundFirst && icol < icolFoundFirst+ccolFound)
                continue;

            // Now the column we have is one of the 7 columns
            // or the deck.
            pcol = pgm->rgpcol[icol];

            // If this column contains cards and the top one faces up
            if(pcol->icrdMac > 0 && (pcrd=&pcol->rgcrd[pcol->icrdMac-1])->fUp)
            {
                if(pcol->pmove == NULL)
                    SendColMsg(pcol, msgcSel, icrdEnd, ccrdToEnd);
                Assert(pcol->pmove != NULL);

                // Check if it can be moved to any of the suit stacks.
                for(icolDest = icolFoundFirst; icolDest < icolFoundFirst+ccolFound; icolDest++)
                {
                    pcolDest = pgmCur->rgpcol[icolDest];
                    if(SendColMsg(pcolDest, msgcValidMove, (INT_PTR)pcol, 0))
                    {
                        SendGmMsg(pgmCur, msggSaveUndo, icolDest, icol);
                        fResult = SendColMsg(pcolDest, msgcMove, (INT_PTR) pcol, icrdToEnd) &&
                        (fOutlineDrag || SendColMsg(pcol, msgcRender, pcol->icrdMac-1, icrdToEnd)) &&
                            SendGmMsg(pgmCur, msggScore, (INT_PTR) pcolDest, (INT_PTR) pcol);

                        iContinue ++;

                        if(SendGmMsg(pgmCur, msggIsWinner, 0, 0))
                            SendGmMsg(pgmCur, msggWinner, 0, 0);
                        break;
                    }
                }
            }

            SendColMsg(pcol, msgcEndSel, fFalse, 0);
        }
    } while (iContinue > 0);

    return fResult;
}





BOOL DefGmMouseMove(GM *pgm, PT *ppt)
{
    COL *pcol;
    INT icol;

    if(FSelOfGm(pgm))
    {
        Assert(pgm->icolSel < pgm->icolMac);
        /* draw new outline */
        pcol = pgm->rgpcol[pgm->icolSel];
        SendColMsg(pcol, msgcDrawOutline, (INT_PTR) ppt, (INT_PTR) &pgm->ptMousePrev);
        pgm->ptMousePrev = *ppt;
        for(icol = 0; icol < pgm->icolMac; icol++)
            if(SendColMsg(pgm->rgpcol[icol], msgcValidMovePt, (INT_PTR)pgm->rgpcol[pgm->icolSel], (INT_PTR) ppt) != icrdNil)
            {
                 if(icol != pgm->icolHilight)
                 {
                    if(FHilightOfGm(pgm))
                        SendColMsg(pgm->rgpcol[pgm->icolHilight], msgcDragInvert, 0, 0);
                     pgm->icolHilight = icol;
                     return SendColMsg(pgm->rgpcol[icol], msgcDragInvert, 0, 0);
                 }
                 else
                     return fTrue;
            }
        /* nothing to hilight */
        if(FHilightOfGm(pgm))
        {
            SendColMsg(pgm->rgpcol[pgm->icolHilight], msgcDragInvert, 0, 0);
            pgm->icolHilight = icolNil;
            return fTrue;
        }
    }
    return fFalse;
}


BOOL DefGmPaint(GM *pgm, PAINTSTRUCT *ppaint)
{
    INT icol;
    HDC hdc;

    hdc = HdcSet(ppaint->hdc, 0, 0);

    if(!pgm->fDealt)
        goto Return;
    for(icol = 0; icol < pgm->icolMac; icol++)
        SendColMsg(pgm->rgpcol[icol], msgcPaint, (INT_PTR) ppaint, 0);
Return:
    HdcSet(hdc, 0, 0);
    return fTrue;
}


BOOL DefGmUndo(GM *pgm)
{
    UDR *pudr;

    Assert(!FSelOfGm(pgm));
    pudr = &pgm->udr;
    if(!pudr->fAvail)
        return fFalse;
    Assert(pudr->icol1 != icolNil);
    Assert(pudr->icol2 != icolNil);

    Assert(pudr->icol1 < pgm->icolMax);
    Assert(pudr->icol2 < pgm->icolMax);

    pgm->sco  = pudr->sco;
    pgm->irep = pudr->irep;

    SendGmMsg(pgm, msggChangeScore, 0, 0);


    SendColMsg(pgm->rgpcol[pudr->icol1], msgcCopy, (INT_PTR) pudr->rgpcol[0], fTrue);
    SendColMsg(pgm->rgpcol[pudr->icol2], msgcCopy, (INT_PTR) pudr->rgpcol[1], fTrue);
    /* end any selectons if we had 'em */
    SendColMsg(pgm->rgpcol[pudr->icol1], msgcEndSel, 0, 0);
    SendColMsg(pgm->rgpcol[pudr->icol2], msgcEndSel, 0, 0);

    SendGmMsg(pgm, msggKillUndo, 0, 0);
    return fTrue;
}



/* in future: may want to alloc columns */
BOOL DefGmSaveUndo(GM *pgm, INT icol1, INT icol2)
{
    Assert(icol1 != icolNil);
    Assert(icol2 != icolNil);
    Assert(icol1 < pgm->icolMac);
    Assert(icol2 < pgm->icolMac);
    Assert(icol1 != icol2);

    /* should use msgcCopy, but undo colcls's may not be set correctly */
    bltb(pgm->rgpcol[icol1], pgm->udr.rgpcol[0], sizeof(COL)+(pgm->rgpcol[icol1]->icrdMac-1)*sizeof(CRD));
    bltb(pgm->rgpcol[icol2], pgm->udr.rgpcol[1], sizeof(COL)+(pgm->rgpcol[icol2]->icrdMac-1)*sizeof(CRD));
    pgm->udr.icol1  = icol1;
    pgm->udr.icol2  = icol2;
    pgm->udr.fAvail = fTrue;
    pgm->udr.sco    = pgm->sco;
    pgm->udr.irep   = pgm->irep;

    if(pgm->udr.fEndDeck)
    {
        pgm->udr.fEndDeck = FALSE;
        pgm->udr.irep--;
    }

    return fTrue;
}



#ifdef DEBUG
VOID DisplayKbdSel(GM *pgm)
{
    HDC hdc;
    TCHAR sz[20];
    INT cch;

    hdc = GetDC(hwndApp);
    PszCopy(TEXT("      "), sz);
    cch = CchDecodeInt(sz, pgm->icolKbd);
    TextOut(hdc, 0, 10, sz, 5);
    PszCopy(TEXT("      "), sz);
    cch = CchDecodeInt(sz, pgm->icrdKbd);
    TextOut(hdc, 0, 20, sz, 5);
    PszCopy(TEXT("      "), sz);
    cch = CchDecodeInt(sz, pgm->icolSel);
    TextOut(hdc, 0, 30, sz, 5);
    ReleaseDC(hwndApp, hdc);
}
#endif



VOID NewKbdColAbs(GM *pgm, INT icol)
{
    Assert(icol >= 0);
    Assert(icol < pgm->icolMac);

    if(!SendColMsg(pgm->rgpcol[icol], msgcValidKbdColSel, FSelOfGm(pgm), 0))
        /* beep? */
        return;

    pgm->icolKbd = icol;
    pgm->icrdKbd = SendColMsg(pgm->rgpcol[pgm->icolKbd], msgcNumCards, fFalse, 0)-1;
    if(pgm->icrdKbd < 0)
        pgm->icrdKbd = 0;
}


VOID NewKbdCol(GM *pgm, INT dcol, BOOL fNextGroup)
{
    INT icolNew;

    icolNew = pgm->icolKbd;
    if(icolNew == icolNil)
        icolNew = 0;
    if(dcol != 0)
    {
        do
        {
            icolNew += dcol;
            if(icolNew < 0)
                icolNew = pgm->icolMac-1;
            else if(icolNew >= pgm->icolMac)
                icolNew = 0;

            /* only one col class and looped through all col's */
            if(icolNew == pgm->icolKbd)
                break;
        }
        while (!SendColMsg(pgm->rgpcol[icolNew], msgcValidKbdColSel, FSelOfGm(pgm), 0) ||
                (fNextGroup &&
                    pgm->rgpcol[icolNew]->pcolcls->tcls ==
                       pgm->rgpcol[pgm->icolKbd]->pcolcls->tcls));

    }

    NewKbdColAbs(pgm, icolNew);
}




VOID NewKbdCrd(GM *pgm, INT dcrd)
{
    INT icrdUpMac, icrdMac;
    INT icrdKbdNew;

    icrdUpMac = SendColMsg(pgm->rgpcol[pgm->icolKbd], msgcNumCards, fTrue, 0);
    icrdMac = SendColMsg(pgm->rgpcol[pgm->icolKbd], msgcNumCards, fFalse, 0);

    if(icrdMac == 0)
        icrdKbdNew = 0;
    else
    {
        if(icrdUpMac == 0)
            icrdKbdNew = icrdMac-1;
        else
            icrdKbdNew = PegRange(pgm->icrdKbd+dcrd, icrdMac-icrdUpMac, icrdMac-1);
    }
    if(SendColMsg(pgm->rgpcol[pgm->icolKbd], msgcValidKbdCrdSel, icrdKbdNew, 0))
        pgm->icrdKbd = icrdKbdNew;
}





BOOL DefGmKeyHit(GM *pgm, INT vk)
{
    PT pt, ptCurs;
    COLCLS *pcolcls;

    /* cancel any mouse selections */

    switch(vk)
    {
    case VK_SPACE:
    case VK_RETURN:
        if(!FSelOfGm(pgm))
            {
            /* begin a selection */
            NewKbdCrd(pgm, 0);  /* !!! */
            SendColMsg(pgm->rgpcol[pgm->icolKbd], msgcGetPtInCrd, pgm->icrdKbd, (INT_PTR) &pt);
            if(!SendGmMsg(pgm, msggMouseDown, (INT_PTR) &pt, 0))
                return fFalse;
            NewKbdCol(pgm, 0, fFalse);
            goto Display;
            }
        else
            {
            /* possibly make a move */
            SendGmMsg(pgm, msggMouseUp, 0, fFalse);
            NewKbdCol(pgm, 0, fFalse);
            return fTrue;
            }

    case VK_ESCAPE:
        SendGmMsg(pgm, msggMouseUp, 0, fTrue);
        return fTrue;

    case VK_A:
        if (GetKeyState(VK_CONTROL) < 0)
            SendGmMsg(pgm, msggMouseRightClk, 0, fTrue);
        return fTrue;

    case VK_LEFT:
        /* Should these be VK_CONTROL??? */
        NewKbdCol(pgm, -1, GetKeyState(VK_SHIFT) < 0);
        goto Display;

    case VK_RIGHT:
        NewKbdCol(pgm, 1, GetKeyState(VK_SHIFT) < 0);
        goto Display;

    case VK_UP:
        NewKbdCrd(pgm, -1);
        goto Display;

    case VK_DOWN:
        NewKbdCrd(pgm, 1);
        goto Display;

    case VK_HOME:
        NewKbdColAbs(pgm, 0);
        goto Display;

    case VK_END:
        NewKbdColAbs(pgm, pgm->icolMac-1);
        goto Display;

    case VK_TAB:
        NewKbdCol(pgm, GetKeyState(VK_SHIFT) < 0 ? -1 : 1, fTrue);
Display:
        SendColMsg(pgm->rgpcol[pgm->icolKbd], msgcGetPtInCrd, pgm->icrdKbd, (INT_PTR) &pt);
        ptCurs = pt;
        ClientToScreen(hwndApp, (LPPOINT) &ptCurs);
        if(FSelOfGm(pgm))
        {
            if(SendColMsg(pgm->rgpcol[pgm->icolKbd], msgcNumCards, fFalse, 0) > 0)
            {
                pcolcls = pgm->rgpcol[pgm->icolKbd]->pcolcls;
                ptCurs.y += pcolcls->dyUp;
                /* dxUp ? */
            }
        }

        /* SetCursorPos will cause WM_MOUSEMOVE to be sent */
        SetCursorPos(ptCurs.x, ptCurs.y);
        return fTrue;
    }
    return fFalse;
}



BOOL DefGmChangeScore(GM *pgm, INT cs, INT sco)
{

    if(smd == smdNone)
        return fTrue;
    switch(cs)
        {
    default:
        return fTrue;
    case csAbs:
        pgm->sco = sco;
        break;
    case csDel:
        pgm->sco += sco;
        break;
    case csDelPos:
        pgm->sco = WMax(pgm->sco+sco, 0);
        break;
        }
    StatUpdate();

    return fTrue;
}


BOOL DefGmWinner(GM *pgm)
{
    pgm->fWon = fFalse;
    if(FYesNoAlert(idsDealAgain))
        PostMessage(hwndApp, WM_COMMAND, idsInitiate, 0L);
    return fTrue;
}


INT DefGmProc(GM *pgm, INT msgg, WPARAM wp1, LPARAM wp2)
{

    switch(msgg)
    {
    case msggInit:
        return DefGmInit(pgm, (BOOL)wp1);
    case msggEnd:
        FreeGm(pgm);
        break;

    case msggKeyHit:
        return DefGmKeyHit(pgm, (INT)wp1);

    case msggMouseRightClk:
        return DefGmMouseRightClk(pgm, (PT *)wp1);

    case msggMouseDown: /* wp1 == ppt, wp2 = icolFirst (normally 0) */
        return DefGmMouseDown(pgm, (PT *)wp1, (INT)wp2);

    case msggMouseUp:
        return DefGmMouseUp(pgm, (PT *)wp1, (BOOL)wp2);

    case msggMouseMove:
        return DefGmMouseMove(pgm, (PT *)wp1);

    case msggMouseDblClk:
        return DefGmMouseDblClk(pgm, (PT *)wp1);

    case msggPaint:
        return DefGmPaint(pgm, (PAINTSTRUCT *)wp1);

    case msggDeal:
        Assert(fFalse);
        break;

    case msggUndo:
        return DefGmUndo(pgm);

    case msggSaveUndo:

        return DefGmSaveUndo(pgm, (INT)wp1, (INT)wp2);

    case msggKillUndo:
        /* in future may want to free columns */
        pgm->udr.fAvail = fFalse;
        break;
    case msggIsWinner:
        return fFalse;
    case msggWinner:
        return DefGmWinner(pgm);
    case msggForceWin:
        NYI();
        break;
    case msggTimer:
        return fFalse;
    case msggScore:
        return fTrue;
    case msggChangeScore:
        return DefGmChangeScore(pgm, (INT)wp1, (INT)wp2);

    }

    return fFalse;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\game.h ===
/* game stuff */

/* GaMe struct  */
typedef struct _gm
{
	LRESULT (FAR *lpfnGmProc)(GM, INT, WPARAM, LPARAM); /* our illustrious gameproc  */
	UDR  udr;          /* undo record  */
	BOOL fDealt;       /* TRUE if cards have been dealt  */
	BOOL fInput;       /* TRUE if input has been recieved after dealing */
	BOOL fWon;         /* TRUE if game is won (and in win sequence)  */
	INT  sco;          /* da sco  */
	INT  iqsecScore;   /* # of quarter seconds since first input  */
	INT  dqsecScore;   /* # of quarter seconds betweeen decrementing score  */
	INT  ccrdDeal;     /* # of cards to deal from deck  */
	INT  irep;         /* # of times thru the deck */
	PT   ptMousePrev;  /* cache of previous mouse position */
	BOOL fButtonDown;  /* TRUE if mouse button down or kbd sel */
	INT  icolKbd;      /* Current cursor position via kbd */
	INT  icrdKbd;					
	INT  icolSel;      /* Current selection  */
	INT  icolHilight;  /* Column currently hilighted (while draggin)  */
	DY	 dyDragMax;    /* maximum height of column (for dragging)  */
	INT  icolMac;
	INT  icolMax;
	COL  *rgpcol[1];
} GM;


// Constants - earlier they were generated in the game.msg file.

#define icolNil             -1
#define msggInit            0		
#define msggEnd             1		
#define msggKeyHit          2	
#define msggMouseDown       3
#define msggMouseUp         4	
#define msggMouseMove       5
#define msggMouseDblClk     6
#define msggPaint           7		
#define msggDeal            8		
#define msggUndo            9		
#define msggSaveUndo        10	
#define msggKillUndo        11	
#define msggIsWinner        12	
#define msggWinner          13	
#define msggScore           14		
#define msggChangeScore     15
#define msggDrawStatus      16
#define msggTimer           17
#define msggForceWin        18	
#define msggMouseRightClk   19


#define ID_ICON_MAIN        500

HICON   hIconMain;              // the main freecell icon.
HICON   hImageMain;             // the main freecell image.

/* Score MoDe  */
typedef INT SMD;
#define smdStandard   ideScoreStandard
#define smdVegas      ideScoreVegas
#define smdNone       ideScoreNone


#define FSelOfGm(pgm)      ((pgm)->icolSel != icolNil)
#define FHilightOfGm(pgm)  ((pgm)->icolHilight != icolNil)



BOOL FInitKlondGm( VOID );
VOID FreeGm(GM *pgm);

#ifdef DEBUG
LRESULT SendGmMsg(GM *pgm, INT msgg, WPARAM wp1, LPARAM wp2);
#else
#define SendGmMsg(pgm, msgg, wp1, wp2) \
	(*((pgm)->lpfnGmProc))((pgm), (msgg), (wp1), (wp2))
#endif	
INT DefGmProc(GM *pgm, INT msgg, WPARAM wp1, LPARAM wp2);


/* standard change score notification codes */
/* instance specific codes should be positive  */
#define csNil     -1  /* no score change  */
#define csAbs     -2  /* change score to an absolute #  */
#define csDel     -3  /* change score by an absolute #  */
#define csDelPos  -4  /* change score by an absolute #, but don't let it get negative */


// define the virtual key constant for key a
#define  VK_A     (INT) 'A'
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\klond.h ===
/* Klondike info */

/* Col classes  */
#define tclsDeck 1
#define tclsDiscard 2
#define tclsFound 3
#define tclsTab 4


/* indexes of columns */
#define icolDeck 			0
#define icolDiscard 		1
#define icolFoundFirst	2
#define ccolFound 		4
#define icolTabFirst	   6
#define ccolTab			7


/* BUG! this should be placed in a game descriptor table */
#define icrdDeckMax 52
#define icrdDiscardMax (icrdDeckMax-(1+2+3+4+5+6+7))
#define icrdFoundMax 13
#define icrdTabMax 19





/* Change Score notification codes */
/* WARNING: order is assumed by mpscdsco* in klond.c */
#define csKlondTime			0		/* decrement score with time */
#define csKlondDeckFlip		1		/* deck gone thru 1 or 3 times  */
#define csKlondFound		2		/* new card on foundation */
#define csKlondTab			3		/* card from Deck to tab */
#define csKlondTabFlip		4		/* exposure of new foundation card */
#define csKlondFoundTab		5		/* card from foundation to tab (- pts) */
#define csKlondDeal			6		/* cost of a deal */
#define csKlondWin			7		/* win bonus */

#define csKlondMax csKlondWin+1

VOID OOM( VOID );
VOID DrawCardExt( PT *, INT, INT );
BOOL APIENTRY cdtAnimate( HDC, INT, INT, INT, INT );
VOID NewKbdColAbs( GM *, INT );
BOOL FValidCol( COL * );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\klond.c ===
#include "sol.h"
VSZASSERT


/* Klondike init stuff */
LRESULT KlondGmProc(GM *pgm, INT msgg, WPARAM wp1, LPARAM wp2);
LRESULT DeckColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2);
LRESULT DiscardColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2);
LRESULT TabColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2);
LRESULT FoundColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2);



// Imported from Win3.1
BOOL FInitKlondGm()
{
    COLCLS *pcolcls;
    GM *pgm;
    DX dxCrdOffUp;
    DX dyCrdOffUp;
    DX dyCrdOffDn;
    int icol;
    int icrdMax;

    /* KLUDGE to get klondike going */
    FreeGm(pgmCur);

    if((pgm = pgmCur = PAlloc(sizeof(GM)+(13-1)*sizeof(COL *))) == NULL)
        return fFalse;

    pgm->lpfnGmProc = KlondGmProc;
    SendGmMsg(pgm, msggInit, fTrue, 0);
    pgm->icolMax = 13;
    pgm->dqsecScore = 10*4;

    if(!FInitUndo(&pgm->udr))
        goto OOM;

    /* Initialize all the column types but don't position yet */
    for(icol = 0; icol < pgm->icolMax; icol++)
    {
        switch(icol)
        {
        case icolDeck:
            pcolcls = PcolclsCreate(tclsDeck, (COLCLSCREATEFUNC)DeckColProc,
                            0, 0, 2, 1, 1, 10);
            icrdMax = icrdDeckMax;
            break;

        case icolDiscard:
            dxCrdOffUp = dxCrd / 5;
            pcolcls = PcolclsCreate(tclsDiscard, (COLCLSCREATEFUNC)DiscardColProc,
                            dxCrdOffUp, 1, 2, 1, 1, 10);
            icrdMax = icrdDiscardMax;
            break;

        case icolFoundFirst:
            pcolcls = PcolclsCreate(tclsFound, (COLCLSCREATEFUNC)FoundColProc,
                            2, 1, 0, 0, 4, 1);
            Assert(icol - 1 == icolDiscard);
            icrdMax = icrdFoundMax;
            break;

        case icolTabFirst:
            Assert(fHalfCards == 1 || fHalfCards == 0);
            dyCrdOffUp = dyCrd * 4 / 25 - fHalfCards;
            dyCrdOffDn = dyCrd / 25;
            pgm->dyDragMax = dyCrd + 12 * dyCrdOffUp;
            pcolcls = PcolclsCreate(tclsTab, (COLCLSCREATEFUNC)TabColProc,
                        0, dyCrdOffUp, 0, dyCrdOffDn, 1, 1);
            icrdMax = icrdTabMax;
            break;
        }

        if(pcolcls == NULL)
        {
OOM:
            OOM();
            FreeGm(pgmCur);
            Assert(pgmCur == NULL);
            return fFalse;
        }

        if((pgm->rgpcol[icol] = PcolCreate(pcolcls, 0, 0, 0, 0, icrdMax))
            == NULL)
        {
            FreeP(pcolcls);
            goto OOM;
        }
        pgm->icolMac++;
    }

    /* Return without positioning the cards.  This will be done at
     *  WM_SIZE message time.
     */
    return TRUE;
}


/*  PositionCols
 *      Positions the card columns.  Note that this has been revised to
 *      allow card positioning at times other than at the start of the
 *      game.
 */

BOOL PositionCols(void)
{
    DX dxMarg;
    DY dyMarg;
    DX dx;
    X xLeft;
    X xRight;
    Y yTop;
    Y yBot;
    int icol;
    DY dyCrdOffUp;
    DY dyCrdOffDn;
    COL *pcol;
    GM *pgm;
    WORD i;

    /* The game we're using is always the current one */
    pgm = pgmCur;

    /* Before doing the column classes, replace all card X coordinates with
     *  offsets from the column class.
     */
    for (icol = 0 ; icol < 13 ; ++icol)
    {
        /* Get a pointer to this COL structure */
        pcol = pgm->rgpcol[icol];

        /* Loop through all the cards in this column */
        for (i = 0 ; i < pcol->icrdMax ; ++i)
            pcol->rgcrd[i].pt.x -= pcol->rc.xLeft;
    }

    /* Set the card margins.  Note that xCardMargin is computed in SOL.C
     *  at the time the original window is created and is changed on
     *  WM_SIZE messages.
     */
    dxMarg = xCardMargin;
    dyMarg = MulDiv(dyCrd, 5, 100);

    /* Loop through all column types */
    for(icol = 0 ; icol < 13 ; icol++)
    {
        switch(icol)
        {
        case icolDeck:
            xLeft = dxMarg;
            yTop = dyMarg;
            xRight = xLeft + dxCrd + icrdDeckMax / 10 * 2;
            yBot = yTop + dyCrd + icrdDeckMax / 10;
            dx = 0;
            break;

        case icolDiscard:
            xLeft += dxMarg + dxCrd;
            xRight = xLeft + 7 * dxCrd / 5 + icrdDiscardMax / 10 * 2;
            break;

        case icolFoundFirst:
            xLeft = 4 * dxMarg + 3 * dxCrd;
            xRight = xLeft + dxCrd + icrdFoundMax / 4 * 2;
            dx = dxMarg + dxCrd;
            break;

        case icolTabFirst:
            dyCrdOffUp = dyCrd * 4 / 25 - fHalfCards;
            dyCrdOffDn = dyCrd / 25;
            xLeft = dxMarg;
            xRight = xLeft + dxCrd;
            yTop = yBot + 1;
            yBot = yTop + 12 * dyCrdOffUp + dyCrd + 6 * dyCrdOffDn;
            break;
        }

        /* Set this information into the structure */
        pcol = pgm->rgpcol[icol];
        pcol->rc.xLeft = xLeft;
        pcol->rc.yTop = yTop;
        pcol->rc.xRight = xRight;
        pcol->rc.yBot = yBot;

        /* Prepare for the next loop */
        xLeft += dx;
        xRight += dx;
    }

    /* Now that the column offsets are correct, move the cards back */
    for (icol = 0 ; icol < 13 ; ++icol)
    {
        /* Get a pointer to this COL structure */
        pcol = pgm->rgpcol[icol];

        /* Loop through all the cards in this column */
        for (i = 0 ; i < pcol->icrdMax ; ++i)
            pcol->rgcrd[i].pt.x += pcol->rc.xLeft;
    }

    return TRUE;
}




/* TABLEAU col Proc stuff */


BOOL FTabValidMove(COL *pcolDest, COL *pcolSrc)
{
    RA raSrc, raDest;
    SU suSrc, suDest;
    INT icrdSel;
    CD cd;

    Assert(pcolSrc->pmove != NULL);
    icrdSel = pcolSrc->pmove->icrdSel;

    Assert(icrdSel < pcolSrc->icrdMac);
    Assert(pcolSrc->icrdMac > 0);
    cd = pcolSrc->rgcrd[icrdSel].cd;
    raSrc = RaFromCd(cd);
    suSrc = SuFromCd(cd);
    if(raSrc == raKing)
        return (pcolDest->icrdMac == 0);
    if(pcolDest->icrdMac == 0)
        return fFalse;
    if(!pcolDest->rgcrd[pcolDest->icrdMac-1].fUp)
        return fFalse;
    cd = pcolDest->rgcrd[pcolDest->icrdMac-1].cd;
    raDest = RaFromCd(cd);
    suDest = SuFromCd(cd);
    /* invalid moves */
    Assert((suClub ^ suSpade) == 0x03);
    Assert((suHeart ^ suDiamond) == 0x03);
    /* valid moves */
    Assert((suClub ^ suDiamond) < 0x03);
    Assert((suClub ^ suHeart) < 0x03);
    Assert((suSpade ^ suDiamond) < 0x03);
    Assert((suSpade ^ suHeart) < 0x03);

    return (((suSrc ^ suDest) < 0x03) && suSrc != suDest && raSrc+1 == raDest);
}


INT TabHit(COL *pcol, PT *ppt, INT icrdMin)
{
    CRD *pcrd;

    if(pcol->icrdMac > 0 && !(pcrd=&pcol->rgcrd[pcol->icrdMac-1])->fUp && FPtInCrd(pcrd, *ppt))
    {
        SendGmMsg(pgmCur, msggKillUndo, 0, 0);
        SendColMsg(pcol, msgcSel, icrdEnd, 1);
        SendColMsg(pcol, msgcFlip, fTrue, 0);
        SendColMsg(pcol, msgcComputeCrdPos, pcol->icrdMac-1, fFalse);
        SendColMsg(pcol, msgcRender, pcol->icrdMac-1, icrdToEnd);
        SendGmMsg(pgmCur, msggChangeScore, csKlondTabFlip, 0);
        SendColMsg(pcol, msgcEndSel, fFalse, 0);
        /* should I return this? */
        return icrdNil;
    }
    return DefColProc(pcol, msgcHit, (INT_PTR) ppt, icrdMin);
}


BOOL TabDiscardDblClk(COL *pcol, PT *ppt, INT icol)
{
    CRD *pcrd;
    INT icolDest;
    COL *pcolDest;
    BOOL fResult;

    fResult = fFalse;
    if(pcol->icrdMac > 0 && (pcrd=&pcol->rgcrd[pcol->icrdMac-1])->fUp && FPtInCrd(pcrd, *ppt))
    {
        if(pcol->pmove == NULL)
            SendColMsg(pcol, msgcSel, icrdEnd, ccrdToEnd);
        Assert(pcol->pmove != NULL);
        for(icolDest = icolFoundFirst; icolDest < icolFoundFirst+ccolFound; icolDest++)
        {
            pcolDest = pgmCur->rgpcol[icolDest];
            if(SendColMsg(pcolDest, msgcValidMove, (INT_PTR)pcol, 0))
            {
                SendGmMsg(pgmCur, msggSaveUndo, icolDest, icol);
                fResult = SendColMsg(pcolDest, msgcMove, (INT_PTR) pcol, icrdToEnd) &&
                    (fOutlineDrag || SendColMsg(pcol, msgcRender, pcol->icrdMac-1, icrdToEnd)) &&
                    SendGmMsg(pgmCur, msggScore, (INT_PTR) pcolDest, (INT_PTR) pcol);
                if(SendGmMsg(pgmCur, msggIsWinner, 0, 0))
                    SendGmMsg(pgmCur, msggWinner, 0, 0);
                goto Return;
            }
        }
        SendColMsg(pcol, msgcEndSel, fFalse, 0);
    }

Return:
    return fResult;
}



LRESULT TabColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2)
{

    switch(msgc)
    {
        case msgcHit:
        /* should this go in DefProc? */
            return TabHit(pcol, (PT *)wp1, (INT)wp2);

        case msgcDblClk:
            return TabDiscardDblClk(pcol, (PT *)wp1, (INT)wp2);

        case msgcValidMove:
            return FTabValidMove(pcol, (COL *) wp1);
    }
    return DefColProc(pcol, msgc, wp1, wp2);
}



BOOL FFoundRender(COL *pcol, INT icrdFirst, INT icrdLast)
{
#define dxFoundDn 2
#define dyFoundDn 1

    if(pcol->icrdMac == 0 || icrdLast == 0)
        {
        if(!FGetHdc())
            return fFalse;
        DrawCardExt((PT *)(&pcol->rc.xLeft), 0, GHOST);
        DrawBackExcl(pcol, (PT *) &pcol->rc);
        ReleaseHdc();
        return fTrue;
        }
    else
        return DefColProc(pcol, msgcRender, icrdFirst, icrdLast);
}





BOOL FFoundValidMove(COL *pcolDest, COL *pcolSrc)
{
    RA raSrc;
    SU suSrc;
    INT icrdSel;

    Assert(pcolSrc->pmove != NULL);
    icrdSel = pcolSrc->pmove->icrdSel;
    Assert(icrdSel < pcolSrc->icrdMac);
    Assert(pcolSrc->icrdMac > 0);
    if(pcolSrc->pmove->ccrdSel != 1)
        return fFalse;
    raSrc = RaFromCd(pcolSrc->rgcrd[icrdSel].cd);
    suSrc = SuFromCd(pcolSrc->rgcrd[icrdSel].cd);
    if(pcolDest->icrdMac == 0)
        return(raSrc == raAce);
    return (raSrc == RaFromCd(pcolDest->rgcrd[pcolDest->icrdMac-1].cd)+1 &&
                 suSrc == SuFromCd(pcolDest->rgcrd[pcolDest->icrdMac-1].cd));

}



/* Foundation stuff */
LRESULT FoundColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2)
{
        switch(msgc)
        {
        case msgcValidMove:
            return FFoundValidMove(pcol, (COL *) wp1);

        case msgcRender:
            return FFoundRender(pcol, (INT)wp1, (INT)wp2);
        }
    return DefColProc(pcol, msgc, wp1, wp2);
}




/* DeckStuff */


BOOL DeckInit(COL *pcol)
{
    CRD *pcrd;
    INT icrd;

    Assert(pcol->icrdMax == icrdDeckMax);
    for(icrd = 0; icrd < icrdDeckMax; icrd++)
        {
        pcrd = &pcol->rgcrd[icrd];
        pcrd->cd = (unsigned short)icrd;
        pcrd->pt = *(PT *)&pcol->rc;
        pcrd->fUp = fFalse;
        }
    pcol->icrdMac = icrdDeckMax;
    SendColMsg(pcol, msgcShuffle, 0, 0);
    SendColMsg(pcol, msgcComputeCrdPos, 0, fFalse);
    return fTrue;
}







INT DeckHit(COL *pcol, PT *ppt, INT icrdMin)
{
    RC rc;
    INT ccrd;

    if(pcol->icrdMac == 0)
    {
        CrdRcFromPt((PT *) &pcol->rc, &rc);
        if(PtInRect((LPRECT) &rc, *(POINT *)ppt))
            return icrdEmpty;
        else
            return icrdNil;
    }
    else
        if(!FPtInCrd(&pcol->rgcrd[pcol->icrdMac-1], *ppt))
            return icrdNil;

    ccrd = ((GetKeyState(VK_SHIFT) & GetKeyState(VK_CONTROL) & GetKeyState(VK_MENU)) < 0) ? 1 : pgmCur->ccrdDeal;

    move.icrdSel = WMax(pcol->icrdMac-ccrd, 0);
    move.ccrdSel = pcol->icrdMac - move.icrdSel;
    Assert(pcol->pmove == NULL);
    pcol->pmove = &move;
    return move.icrdSel;
}


BOOL FDeckRender(COL *pcol, INT icrdFirst, INT icrdLast)
{
    INT mode;
    BOOL f;
    PT pt;

    /* to avoid redrawing the deck multiple times during dealing */
    if(!pgmCur->fDealt && pcol->icrdMac%10 != 9)
        return fTrue;
    if(!FGetHdc())
        return fFalse;
    if(pcol->icrdMac == 0)
        {
        mode = (smd == smdVegas && pgmCur->irep == ccrdDeal-1) ? DECKX : DECKO;
        DrawCardExt((PT *) &pcol->rc, 0, mode);
        DrawBackExcl(pcol, (PT *) &pcol->rc);
        f = fTrue;
        }
    else
        {
        f = DefColProc(pcol, msgcRender, icrdFirst, icrdLast);
        if((icrdLast == pcol->icrdMac || icrdLast == icrdToEnd) && !fHalfCards)
            {
            pt.x = pcol->rgcrd[pcol->icrdMac-1].pt.x+dxCrd-1;
            pt.y = pcol->rgcrd[pcol->icrdMac-1].pt.y+dyCrd-1;
            SetPixel(hdcCur, pt.x-xOrgCur, pt.y-yOrgCur, rgbTable);
            SetPixel(hdcCur, pt.x-1-xOrgCur, pt.y-yOrgCur, rgbTable);
            SetPixel(hdcCur, pt.x-xOrgCur, pt.y-1-yOrgCur, rgbTable);
            }
        }
    ReleaseHdc();
    return f;
}


VOID DrawAnimate(INT cd, PT *ppt, INT iani)
{

    if(!FGetHdc())
        return;
    cdtAnimate(hdcCur, cd, ppt->x, ppt->y, iani);
    ReleaseHdc();
}


BOOL DeckAnimate(COL *pcol, INT iqsec)
{
    INT iani;
    PT pt;

// we removed the older card decks that required Animation. The new
// card deck doesn't involve any animation.

#ifdef UNUSEDCODE

    if(pcol->icrdMac > 0 && !fHalfCards)
        {
        pt = pcol->rgcrd[pcol->icrdMac-1].pt;
        switch(modeFaceDown)
            {
        case IDFACEDOWN3:
            DrawAnimate(IDFACEDOWN3, &pt, iqsec % 4);
            break;
        case IDFACEDOWN10:  /* krazy kastle  */
            DrawAnimate(IDFACEDOWN10, &pt, iqsec % 2);
            break;

        case IDFACEDOWN11:  /* sanflipe */
            if((iani = (iqsec+4) % (50*4)) < 4)
                DrawAnimate(IDFACEDOWN11, &pt, iani);
            else
                /* if a menu overlapps an ani while it is ani'ing, leaves deck
                 bitmap in inconsistent state...  */
                if(iani % 6 == 0)
                    DrawAnimate(IDFACEDOWN11, &pt, 3);
            break;
        case IDFACEDOWN12:  /* SLIME  */
            if((iani = (iqsec+4) % (15*4)) < 4)
                DrawAnimate(IDFACEDOWN12, &pt, iani);
            else
                /* if a menu overlapps an ani while it is ani'ing, leaves deck
                 bitmap in inconsistent state... */
                if(iani % 6 == 0)
                    DrawAnimate(IDFACEDOWN12, &pt, 3);
            break;
            }
        }

#endif

    return fTrue;
}





LRESULT DeckColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2)
{

    switch(msgc)
        {
    case msgcInit:
        return DeckInit(pcol);
    case msgcValidMove:
    case msgcDrawOutline:
        return fFalse;
    case msgcValidMovePt:
        return icrdNil;
    case msgcHit:                    									
        return DeckHit(pcol, (PT *) wp1, (INT)wp2);
    case msgcRender:
        return FDeckRender(pcol, (INT) wp1, (INT) wp2);
    case msgcValidKbdColSel:
        return !wp1;
    case msgcValidKbdCrdSel:
        return pcol->icrdMac == 0 || wp1 == (WPARAM) pcol->icrdMac-1;
    case msgcAnimate:
        return DeckAnimate(pcol, (INT)wp1);
        }
    return DefColProc(pcol, msgc, wp1, wp2);
}


BOOL DiscardRemove(COL *pcol, COL *pcolDest, LPARAM wp2)
{
        return DefColProc(pcol, msgcRemove, (INT_PTR) pcolDest, wp2);
}


BOOL DiscardMove(COL *pcolDest, COL *pcolSrc, INT icrd)
{
    BOOL fResult;

    SendColMsg(pcolDest, msgcComputeCrdPos, WMax(0, pcolDest->icrdMac-3), fTrue);

    /* YUCK: Default ComputeCrdPos doesn't quite work for discard because
        up cards are handled specially for Discard piles.  To keep
        code size down we have this global hack variable which DefComputeCrdPos
        uses.
    */
    fMegaDiscardHack = fTrue;
    fResult = DefColProc(pcolDest, msgcMove, (INT_PTR) pcolSrc, icrd);
    fMegaDiscardHack = fFalse;
    return fResult;
}



INT DiscardHit(COL *pcol, PT *ppt, INT icrdMin)
{
    return DefColProc(pcol, msgcHit, (INT_PTR) ppt, WMax(0, pcol->icrdMac-1));
}


BOOL DiscardRender(COL *pcol, INT icrdFirst, INT icrdLast)
{
    PT pt;
    INT icrd;
    COLCLS *pcolcls;

    if(DefColProc(pcol, msgcRender, icrdFirst, icrdLast))
        {
        if(FGetHdc())
            {
            pcolcls = pcol->pcolcls;
            for(icrd = pcol->icrdMac-1; icrd >= 0 && icrd >= pcol->icrdMac-2; icrd--)
                {
                pt = pcol->rgcrd[icrd].pt;
                /* 3 is a kludge value here */
                DrawBackground(pt.x+dxCrd-pcolcls->dxUp, pt.y-pcolcls->dyUp*3,
                        			pt.x+dxCrd, pt.y);
                }
            ReleaseHdc();
            }
        return fTrue;
        }
    return fFalse;
}



/* Discard Stuff */
LRESULT DiscardColProc(COL *pcol, INT msgc, WPARAM wp1, LPARAM wp2)
{
    switch(msgc)
        {
    case msgcDblClk:
        return TabDiscardDblClk(pcol, (PT *)wp1, (INT)wp2);
    case msgcHit:
        return DiscardHit(pcol, (PT *)wp1, (INT)wp2);
    case msgcMove:
        return DiscardMove(pcol, (COL *) wp1, (INT)wp2);
    case msgcRemove:
        return DiscardRemove(pcol, (COL *) wp1, wp2);
    case msgcValidMovePt:
        return icrdNil;
    case msgcValidKbdColSel:
        return !wp1;
    case msgcRender:
        return DiscardRender(pcol, (INT)wp1, (INT)wp2);
    case msgcValidKbdCrdSel:
        return pcol->icrdMac == 0 || wp1 == (WPARAM) pcol->icrdMac-1;
        }

    return DefColProc(pcol, msgc, wp1, wp2);
}




/* GAME stuff */

BOOL KlondDeal(GM *pgm, BOOL fZeroScore)
{
    INT icrdSel;
    INT icol;
    INT irw;
    COL *pcolDeck;
    VOID StatString();

    if(!FGetHdc())
        {
        OOM();
        return fFalse;
        }

    EraseScreen();
    for(icol = 0; icol < pgm->icolMac; icol++)
        SendColMsg(pgm->rgpcol[icol], msgcClearCol, 0, 0);

    pcolDeck = pgm->rgpcol[icolDeck];
    SendColMsg(pcolDeck, msgcInit, 0, 0);

    SendGmMsg(pgm, msggKillUndo, 0, 0);
    SendGmMsg(pgm, msggInit, !(smd == smdVegas && fKeepScore) || fZeroScore, 0);

    StatString(idsNil);
    pgm->fDealt = fTrue;
    SendGmMsg(pgm, msggChangeScore, csKlondDeal, 0);
    SendColMsg(pcolDeck, msgcRender, 0, icrdToEnd);
    pgm->fDealt = fFalse;
    for(icol = icolFoundFirst; icol < icolFoundFirst+ccolFound; icol++)
        SendColMsg(pgm->rgpcol[icol], msgcRender, 0, icrdToEnd);

// BabakJ: What the %@!&$* is this?! irw is always less than irw + ccolTab!!!
//         Note: ccolTab if #ifdef'ed as 7
//    for(irw = 0; irw < irw+ccolTab; irw++)

    for(irw = 0; irw < ccolTab; irw++)
        for(icol = irw; icol < ccolTab; icol++)
            {
            icrdSel = SendColMsg(pcolDeck, msgcSel, icrdEnd, 0);
            if(icol == irw)
                SendColMsg(pcolDeck, msgcFlip, fTrue, 0);
            SendColMsg(pgm->rgpcol[icol+icolTabFirst], msgcMove, (INT_PTR) pcolDeck, icrdToEnd);
            SendColMsg(pcolDeck, msgcRender, icrdSel-1, icrdToEnd);
            }
    NewKbdColAbs(pgm, 0);
    pgm->fDealt = fTrue;
    ReleaseHdc();
    return fTrue;
}




BOOL KlondMouseDown(GM *pgm, PT *ppt)
{
    INT icrdSel;
    INT icrd;
    COL *pcolDeck, *pcolDiscard;

    /* Kbd sel already in effect */
    if(FSelOfGm(pgm) || !pgm->fDealt)
        return fFalse;
    /* place the next cards on discard pile */
    if((icrd = SendColMsg(pgm->rgpcol[icolDeck], msgcHit, (INT_PTR) ppt, 0)) != icrdNil)
        {
        pgm->fInput = fTrue;
        pcolDeck = pgm->rgpcol[icolDeck];
        pcolDiscard = pgm->rgpcol[icolDiscard];
        if(icrd == icrdEmpty)
            {
            /* repeat */
            if(SendColMsg(pcolDiscard, msgcNumCards, 0, 0) == 0)
                {
                /* both deck and discard are empty */
                Assert(pcolDeck->pmove == NULL);
                return fFalse;
                }
            if(smd == smdVegas && pgm->irep == ccrdDeal-1)
                return fFalse;

            pgm->irep++;
            pgm->udr.fEndDeck = TRUE;

            return SendGmMsg(pgm, msggSaveUndo, icolDiscard, icolDeck) &&
                SendColMsg(pcolDiscard, msgcSel, 0, ccrdToEnd) != icrdNil &&
                SendColMsg(pcolDiscard, msgcFlip, fFalse, 0) &&
                SendColMsg(pcolDiscard, msgcInvert, 0, 0) &&
                SendGmMsg(pgm, msggScore, (INT_PTR) pcolDeck, (INT_PTR) pcolDiscard) &&
                SendColMsg(pcolDeck, msgcMove, (INT_PTR) pcolDiscard, icrdToEnd) &&
                SendColMsg(pcolDiscard, msgcRender, 0, icrdToEnd);
            }
        else
            {
            icrdSel = pcolDeck->pmove->icrdSel-1;
            /* deal next cards to discard */
            return SendGmMsg(pgm, msggSaveUndo, icolDiscard, icolDeck) &&
                SendColMsg(pcolDeck, msgcFlip, fTrue, 0) &&
                SendColMsg(pcolDeck, msgcInvert, 0, 0) &&
                SendColMsg(pcolDiscard, msgcMove, (INT_PTR)pcolDeck, icrdToEnd) &&
                SendColMsg(pcolDeck, msgcRender, icrdSel, icrdToEnd);
            }
        }
    return DefGmProc(pgm, msggMouseDown, (INT_PTR) ppt, icolDiscard);
}


BOOL KlondIsWinner(GM *pgm)
{
    INT icol;

    for(icol = icolFoundFirst; icol < icolFoundFirst+ccolFound; icol++)
        if(pgm->rgpcol[icol]->icrdMac != icrdFoundMax)
            return fFalse;
    return fTrue;
}


BOOL FAbort()
{
    MSG msg;

    if (MsgWaitForMultipleObjects(0, NULL, FALSE, 5, QS_ALLINPUT) != WAIT_OBJECT_0)
        return FALSE;

    if(PeekMessage(&msg, hwndApp, 0, 0, PM_NOREMOVE))
        {
        switch(msg.message)
            {
        case WM_LBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_KEYDOWN:
        case WM_SYSKEYDOWN:
        case WM_MENUSELECT:
        case WM_NCLBUTTONDOWN:
        case WM_NCMBUTTONDOWN:
        case WM_NCRBUTTONDOWN:
            return fTrue;
            }

        PeekMessage(&msg, hwndApp, 0, 0, PM_REMOVE);
        TranslateMessage((LPMSG)&msg);
        DispatchMessage((LPMSG)&msg);
        }
    return fFalse;
}



// Hack for making winning animation faster:
// At cascading time we have: KlondWinner -> DrawCardPt ->cdtDrawExt
// so we set a flag so cdtDrawExt knows it is cascading and does not need
// to round up corners.
BOOL fKlondWinner = FALSE;

BOOL KlondWinner(GM *pgm)
{
    INT icol;
    INT icrd;
    CRD *pcrd;
    PT pt;
    PT ptV;
    INT dxp;
    INT dyp;
    RC rcT;
    INT dsco;
    TCHAR *pch;
    TCHAR szBonus[84];
    VOID StatString();
    UINT cchUsed, cchTmp;

    fKlondWinner = TRUE;

    dsco = (INT)SendGmMsg(pgmCur, msggChangeScore, csKlondWin, 0);
    pgm->udr.fAvail = fFalse;
    pgm->fDealt = fFalse;
    pgm->fWon = fTrue;

    if(smd == smdStandard)
    {
        cchUsed = CchString(szBonus, idsBonus, ARRAYSIZE(szBonus));
        pch =    &szBonus[cchUsed];

        cchTmp = CchDecodeInt(pch, dsco);
        pch += cchTmp;
        cchUsed += cchTmp;

        *pch++ = TEXT(' ');
        cchUsed++;

        *pch++ = TEXT(' ');
        cchUsed++;
    }
    else
    {
        pch = szBonus;
        cchUsed = 0;
    }
    if (cchUsed < ARRAYSIZE(szBonus))
    {
        CchString(pch, idsEndWinner, ARRAYSIZE(szBonus) - cchUsed);
    }

    StatStringSz(szBonus);
    if(!FGetHdc())
        goto ByeNoRel;
    Assert(xOrgCur == 0);
    Assert(yOrgCur == 0);
    GetClientRect(hwndApp, (RECT *)&rcT);
    dxp = rcT.xRight;
    dyp = rcT.yBot - dyCrd;

    for(icrd = icrdFoundMax-1; icrd >= 0; icrd--)
    {
        for(icol = icolFoundFirst; icol < icolFoundFirst+ccolFound; icol++)
        {
            ptV.x = rand() % 110 - 65;  /* favor up and to left */
            if(abs(ptV.x) < 15)  /* kludge so doesn't bounce forever */
                ptV.x = -20;
            ptV.y = rand() % 110 - 75;
            pt = (pcrd = &pgm->rgpcol[icol]->rgcrd[icrd])->pt;

            while(pt.x > -dxCrd && pt.x < dxp)
            {
                DrawCardPt(pcrd, &pt);
                pt.x += ptV.x/10;
                pt.y += ptV.y/10;
                ptV.y+= 3;
                if(pt.y > dyp && ptV.y > 0)
                    ptV.y = -(ptV.y*8)/10;
                if(FAbort())
                    goto ByeBye;
            }

       }
    }


ByeBye:
    ReleaseHdc();
ByeNoRel:
    StatString(idsNil);
    EraseScreen();

    fKlondWinner = FALSE;

    return DefGmProc(pgm, msggWinner, 0, 0);
}

BOOL KlondForceWin(GM *pgm)
{
    INT icol;
    CRD *pcrd;
    COL *pcol;
    RA ra;
    SU su;

    for(icol = 0; icol < pgm->icolMac; icol++)
        SendColMsg(pgm->rgpcol[icol], msgcClearCol, 0, 0);
    for(su = suFirst, icol = icolFoundFirst; icol < icolFoundFirst+ccolFound; icol++, su++)
    {
        Assert(raFirst == 0);
        for(ra = raFirst; ra < raMax; ra++)
        {
            pcol = pgm->rgpcol[icol];
            pcrd = &pcol->rgcrd[ra];
            pcrd->cd = Cd(ra, su);
            pcrd->pt.x = pcol->rc.xLeft;
            pcrd->pt.y = pcol->rc.yTop;
            pcrd->fUp = fTrue;
        }
        pgm->rgpcol[icol]->icrdMac = icrdFoundMax;
    }
    Assert(SendGmMsg(pgm, msggIsWinner, 0, 0));
    return (BOOL)SendGmMsg(pgm, msggWinner, 0, 0);
}


/* Note: assumes is called once a second */
/* if pcolDest == pcolSrc == NULL, then is a timer msg */
BOOL KlondScore(GM *pgm, COL *pcolDest, COL *pcolSrc)
{
    INT cs;
    INT tclsSrc, tclsDest;


    if(smd == smdNone)
        return fTrue;
    cs = csNil;

    Assert(FValidCol(pcolSrc));
    Assert(FValidCol(pcolDest));


    tclsSrc = pcolSrc->pcolcls->tcls;
    tclsDest = pcolDest->pcolcls->tcls;

    switch(tclsDest)
        {
    default:
        return fTrue;
    case tclsDeck:
        if(tclsSrc == tclsDiscard)
            cs = csKlondDeckFlip;
        break;
    case tclsFound:
        switch(tclsSrc)
            {
        default:
            return fTrue;
        case tclsDiscard:
        case tclsTab:
            cs = csKlondFound;
            break;
            }
        break;
    case tclsTab:
        switch(tclsSrc)
            {
        default:
            return fTrue;
        case tclsDiscard:
            cs = csKlondTab;
            break;
        case tclsFound:
            cs = csKlondFoundTab;
            break;
            }
        break;
         }

    SendGmMsg(pgm, msggChangeScore, cs, 0);
    return fTrue;
}

INT mpcsdscoStd[] = { -2, -20, 10, 5, 5, -15,   0,  0};
INT mpcsdscoVegas[] = {0,   0,  5, 0, 0,  -5, -52,  0};


BOOL KlondChangeScore(GM *pgm, INT cs, INT sco)
{
    INT dsco;
    INT csNew;
    INT *pmpcsdsco;
    INT ret;

    if(cs < 0)
        return DefGmProc(pgm, msggChangeScore, cs, sco);
    Assert(FInRange(cs, 0, csKlondMax-1));
    switch(smd)
    {
        default:
            Assert(smd == smdNone);
            return fTrue;
        case smdVegas:
            pmpcsdsco = mpcsdscoVegas;
            break;

        case smdStandard:
            pmpcsdsco = mpcsdscoStd;
            if(cs == csKlondWin && fTimedGame)
            {
    #ifdef DEBUG
                pgm->iqsecScore = WMax(120, pgm->iqsecScore);
    #endif
                /* check if timer set properly */
                if(pgm->iqsecScore >= 120)
                    dsco = (20000/(pgm->iqsecScore>>2))*(350/10);
                else
                    dsco = 0;
                goto DoScore;
            }
            if(cs == csKlondDeckFlip)
            {
                if(ccrdDeal == 1 && pgm->irep >= 1)
                {
                    dsco = -100;
                    goto DoScore;
                }
                else if(ccrdDeal == 3 && pgm->irep > 3)
                    break;
                else
                    return fTrue;
            }
            break;
    }

    dsco = pmpcsdsco[cs];
DoScore:
    csNew = smd == smdVegas ? csDel : csDelPos;
    ret = DefGmProc(pgm, msggChangeScore, csNew, dsco);
    if(cs == csKlondWin)
        return dsco;
    else
        return ret;
}



BOOL KlondTimer(GM *pgm, INT wp1, INT wp2)
{

    if(fTimedGame && pgm->fDealt && pgm->fInput && !fIconic)
    {
        pgm->iqsecScore = WMin(pgm->iqsecScore+1, 0x7ffe);
        if(pgm->icolSel == icolNil)
            SendColMsg(pgm->rgpcol[icolDeck], msgcAnimate, pgm->iqsecScore, 0);
        if(pgm->dqsecScore != 0 && (pgm->iqsecScore)%pgm->dqsecScore == 0)
        {
            SendGmMsg(pgm, msggChangeScore, csKlondTime, 0);
        }
        else
        {
            /* update status bar once as second */
            if(~(pgm->iqsecScore & 0x03))
                StatUpdate();
            return fTrue;
        }
   }
   return fFalse;
}

BOOL KlondDrawStatus(GM *pgm, RC *prc)
{
    TCHAR *pch;
    TCHAR sz[80];
    RC rc;
    LONG rgb;
    BOOL fNegSco;
    SIZE   iSize;
    extern INT iCurrency;
    extern TCHAR szCurrency[];
    HFONT  hFontOld = NULL;
    HFONT  hStatusFont = NULL;


    // store the old font and replace the status font by MS Shell Dlg
    // as it supports FE characters as well as euro characters.

    hStatusFont = CreateFont(-MulDiv(9, GetDeviceCaps(hdcCur, LOGPIXELSY), 72), 0, 0, 0, FW_BOLD, 0, 0, 0, 
                             DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, 
                             DEFAULT_PITCH, TEXT("MS Shell Dlg")); 

    if (hStatusFont && hdcCur)
        hFontOld = SelectObject(hdcCur, hStatusFont);

    pch = sz;
    if(fTimedGame)
    {
        pch += CchString(pch, idsTime, ARRAYSIZE(sz));
        pch += CchDecodeInt(pch, (pgm->iqsecScore>>2));
    }
#ifdef DEBUG
    if(!fScreenShots)
    {
        *pch++ = TEXT(' ');
        pch = PszCopy(TEXT("Game # "), pch);
        pch += CchDecodeInt(pch, igmCur);
    }
#endif
    if(pch != sz)
    {
        DrawText(hdcCur, sz, (INT)(pch-sz), (LPRECT) prc, DT_RIGHT|DT_NOCLIP|DT_SINGLELINE);
    }

    if(smd != smdNone)
    {
        rc = *prc;
        GetTextExtentPoint32(hdcCur, sz, (INT)(pch-sz), &iSize);
        rc.xRight -= iSize.cx;
        pch = sz;
        if(fNegSco = pgm->sco < 0)
            *pch++ = TEXT('-');
        if(smd == smdVegas)
        {
            if(!(iCurrency&1))
            {
                pch = PszCopy(szCurrency, pch);
                if(iCurrency == 2)
                    *pch++ = TEXT(' ');
            }
        }
        pch += CchDecodeInt(pch, fNegSco ? -pgm->sco : pgm->sco);
        if(smd == smdVegas)
        {
            if(iCurrency&1)
            {
                if(iCurrency == 3)
                    *pch++ = TEXT(' ');
                pch = PszCopy(szCurrency, pch);
            }
        }
        *pch++ = TEXT(' ');
        rgb = SetTextColor(hdcCur, (!fBW && fNegSco) ? RGB(0xff, 0, 0) : RGB(0, 0, 0));
        DrawText(hdcCur, sz, (INT)(pch-sz), (LPRECT) &rc, DT_RIGHT|DT_NOCLIP|DT_SINGLELINE);
        SetTextColor(hdcCur, rgb);

        GetTextExtentPoint32(hdcCur, sz, (INT)(pch-sz), &iSize);
        rc.xRight -= iSize.cx;
        pch = PszCopy(szScore, sz);
        DrawText(hdcCur, sz, (INT)(pch-sz), (LPRECT) &rc, DT_RIGHT|DT_NOCLIP|DT_SINGLELINE);
        GetTextExtentPoint32(hdcCur, sz, (INT)(pch-sz), &iSize);
        rc.xRight -= iSize.cx;
        rc.xLeft = rc.xRight - 4 * dxChar;
        PatBlt(hdcCur, rc.xLeft, rc.yTop, rc.xRight-rc.xLeft, rc.yBot-rc.yTop, PATCOPY);
        }


    // restore the font
    if (hFontOld)
        SelectObject(hdcCur, hFontOld);

    // close the created font handle
    if (hStatusFont)
        DeleteObject(hStatusFont);

    return fTrue;
}




LRESULT KlondGmProc(GM *pgm, INT msgg, WPARAM wp1, LPARAM wp2)
{
    switch(msgg)
        {
    case msggMouseDblClk:
        if(DefGmProc(pgm, msggMouseDblClk, wp1, wp2))
            return fTrue;
        /* fall thru so works for deck double clicks */
    case msggMouseDown:
        return KlondMouseDown(pgm, (PT *)wp1);

    case msggDeal:
        return KlondDeal(pgm, (BOOL)wp1);

    case msggIsWinner:
        return KlondIsWinner(pgm);

    case msggWinner:
        return KlondWinner(pgm);

    case msggForceWin:
        return KlondForceWin(pgm);

    case msggScore:
        return KlondScore(pgm, (COL *) wp1, (COL *)wp2);

    case msggChangeScore:
        return KlondChangeScore(pgm, (INT)wp1, (INT)wp2);

    case msggTimer:
        return KlondTimer(pgm, (INT)wp1, (INT)wp2);


    case msggDrawStatus:
        return KlondDrawStatus(pgm, (RC *) wp1);
        }
    return DefGmProc(pgm, msgg, wp1, wp2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\soldraw.h ===
/* CarDDRaw structure  */
typedef struct _cddr
{
	HDC hdc;
	INT x;
	INT y;
	INT cd;
	INT mode;
	DWORD rgbBgnd;
} CDDR;



#define drwInit 		1
#define drwDrawCard 	2
#define drwClose 		3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\sol.h ===
//#ifdef WIN

/* BabakJ: The stuff in this ifdef is hack for using \\popcorn env */
//#define NOCOMM
/* #define _NTDEF_  to get NT defs, i.e. WORD unsigned short, not int */

#include <windows.h>
#include <port1632.h>


// Babakj: Set DEBUG based on DBG (1 or 0) to do FREE or CHECKED builds of Solitaire
#if DBG
#define DEBUG
#endif


/* #include <winkrnl.h>   To define OFSTRUCT */
/* OpenFile() Structure */
//typedef struct tagOFSTRUCT
//  {
//    BYTE        cBytes;
//    BYTE        fFixedDisk;
//    WORD        nErrCode;
//    BYTE        reserved[4];
//    BYTE        szPathName[128];
//  } OFSTRUCT;
//typedef OFSTRUCT            *POFSTRUCT;
//typedef OFSTRUCT NEAR       *NPOFSTRUCT;
//typedef OFSTRUCT FAR        *LPOFSTRUCT;
//#define OF_CREATE           0x1000
//#define OF_WRITE            0x0001
/* End if stuff taken from Winkrnl.h */
//#endif

#include <stdlib.h>
#include <time.h>
#include "std.h"
#include "crd.h"
#include "col.h"
#include "undo.h"
#include "solid.h"
#include "game.h"
#include "soldraw.h"
#include "back.h"
#include "stat.h"
#include "klond.h"
#include "debug.h"


// key in the registry to store the solitaire settings.
#define SOLKEYNAME TEXT("Software\\Microsoft\\Solitaire")


VOID ChangeBack( INT );
VOID WriteIniFlags( INT );
BOOL FYesNoAlert( INT );
VOID DoOptions( VOID );
VOID DoBacks( VOID );
VOID NewGame( BOOL, BOOL );
BOOL APIENTRY cdtDraw( HDC, INT, INT, INT, INT, DWORD );
BOOL APIENTRY cdtDrawExt(HDC, INT, INT, INT, INT, INT, INT, DWORD);
BOOL FCreateStat( VOID );
BOOL FSetDrag( BOOL );
BOOL FInitGm( VOID );
BOOL APIENTRY cdtInit( INT FAR *, INT FAR * );
typedef INT (*COLCLSCREATEFUNC)();
COLCLS *PcolclsCreate(INT tcls, COLCLSCREATEFUNC lpfnColProc,
							DX dxUp, DY dyUp, DX dxDn, DY dyDn,
							INT dcrdUp, INT dcrdDn);
COL *PcolCreate(COLCLS *pcolcls, X xLeft, Y yTop, X xRight, Y yBot, INT icrdMax);
VOID SwapCards(CRD *pcrd1, CRD *pcrd2);
BOOL FCrdRectIsect(CRD *pcrd, RC *prc);
BOOL FRectIsect(RC *prc1, RC *prc2);
BOOL FPtInCrd(CRD *pcrd, PT pt);

VOID DrawCard(CRD *pcrd);
VOID DrawCardPt(CRD *pcrd, PT *ppt);
VOID DrawBackground(X xLeft, Y yTop, X xRight, Y yBot);
VOID DrawBackExcl(COL *pcol, PT *ppt);
VOID EraseScreen(VOID);
VOID OOM( VOID );

HDC HdcSet(HDC hdc, X xOrg, Y yOrg);
extern X xOrgCur;
extern Y yOrgCur;


#define AssertHdcCur() Assert(hdcCur != NULL)


BOOL FGetHdc( VOID );
VOID ReleaseHdc( VOID );

typedef union
	{
	struct _ini
		{
		BOOL fStatusBar : 1;
		BOOL fTimedGame : 1;
		BOOL fOutlineDrag : 1;
		BOOL fDrawThree : 1;
		unsigned fSMD: 2;
		BOOL fKeepScore : 1;
		BOOL unused:8;
		} grbit;
	DWORD w;
	} INI;


/* WriteIniFlags flags */

#define wifOpts   0x01
#define wifBitmap 0x02
#define wifBack   0x04

#define wifAll wifOpts|wifBitmap|wifBack




/* externals    */
/* sol.c        */
extern TCHAR   szAppName[]; // name of this application (solitaire)
extern TCHAR   szScore[];   // title 'score:' for internationalization
extern HWND   hwndApp;      // handle to main window of app
extern HANDLE hinstApp;     // handle to instance of app
extern BOOL   fBW;          // true if on monochrome video (not NT!)
extern HBRUSH hbrTable;     // handle to brush of table top
extern LONG   rgbTable;     // RGB value of table top
extern INT    modeFaceDown; // back of cards bmp id
extern BOOL   fIconic;      // true if app is iconic
extern INT    dyChar;       // tmHeight for textout
extern INT    dxChar;       // tmMaxCharWidth for textout
extern GM*    pgmCur;       // current game
extern DEL    delCrd;
extern DEL    delScreen;
extern PT     ptNil;        // no previous pt (nil)

#define dxCrd delCrd.dx
#define dyCrd delCrd.dy
#define dxScreen delScreen.dx
#define dyScreen delScreen.dy

extern RC     rcClient;     // client rectangle after resize
extern INT    igmCur;       // the current game #, srand seeded with this
#ifdef DEBUG
extern BOOL   fScreenShots;  // ???
#endif
extern HDC    hdcCur;       // current HDC to draw on (!)
extern INT    usehdcCur;    // hdcCur use count
extern X      xOrgCur;
extern Y      yOrgCur;

extern TCHAR   szOOM[50];   // "out of memory" error message

extern BOOL   fStatusBar;   // true if we are to show status
extern BOOL   fTimedGame;   // true if we are to time game
extern BOOL   fKeepScore;   // true if keeping score (vegas only)
extern SMD    smd;          // Score MoDe (std, vegas, none)
extern INT    ccrdDeal;
extern BOOL   fOutlineDrag;

extern BOOL   fHalfCards;
extern int    xCardMargin;


/* stat.c         */
extern HWND  hwndStat;      // hwnd of status window

/* col.c          */
extern BOOL  fMegaDiscardHack;  // true if called from DiscardMove
extern MOVE  move;              // move data

/* klond.c        */
BOOL PositionCols(void);
extern BOOL fKlondWinner;       // true if we needn't round card corners


#ifdef DEBUG
WORD ILogMsg( VOID *, INT, WPARAM, LPARAM, BOOL );
VOID LogMsgResult( INT, LRESULT );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\marq.c ===
#include "sol.h"
#include <htmlhelp.h>
VSZASSERT

#define dxBord 3
#define dyBord 3

INT_PTR APIENTRY OptionsDlgProc(HANDLE hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    BOOL fNewGame;
    static INT ccrdDealNew;
    static SMD smdNew;

    BOOL FDestroyStat();

    // Used for context sensitive help.
    static DWORD aIds[] = {
        ideDrawOne,       IDH_OPTIONS_DRAW,
        ideDrawThree,     IDH_OPTIONS_DRAW,
        ideScoreStandard, IDH_OPTIONS_SCORING,
        ideScoreVegas,    IDH_OPTIONS_SCORING,
        ideScoreNone,     IDH_OPTIONS_SCORING,
        ideTimedGame,     IDH_OPTIONS_TIMED_GAME,
        ideStatusBar,     IDH_OPTIONS_STATUS_BAR,
        ideOutlineDrag,   IDH_OPTIONS_OUTLINE_DRAGGING,
        ideKeepScore,     IDH_OPTIONS_CUMULATIVE_SCORE,
        ideScore,         IDH_OPTIONS_CUMULATIVE_SCORE,
        0,0 };

    switch(wm)
    {
        default:
            return fFalse;

        case WM_INITDIALOG:
            CheckRadioButton(hdlg, ideScoreStandard, ideScoreNone, smdNew = smd);
            ccrdDealNew = ccrdDeal;
            CheckRadioButton(hdlg, ideDrawOne, ideDrawThree, ccrdDeal == 1 ? ideDrawOne : ideDrawThree);
            CheckDlgButton(hdlg, ideStatusBar, (WORD)fStatusBar);
            CheckDlgButton(hdlg, ideTimedGame, (WORD)fTimedGame);
            CheckDlgButton(hdlg, ideOutlineDrag, (WORD)fOutlineDrag);
            CheckDlgButton(hdlg, ideKeepScore, (WORD)fKeepScore);
            EnableWindow(GetDlgItem(hdlg, ideKeepScore), smd == smdVegas);
            EnableWindow(GetDlgItem(hdlg, ideScore), smd == smdVegas);
            break;
        case WM_COMMAND:
            switch( GET_WM_COMMAND_ID( wParam, lParam) )
            {
                default:
                    return fFalse;
                case ideDrawOne:
                case ideDrawThree:
                    ccrdDealNew = GET_WM_COMMAND_ID( wParam, lParam) == ideDrawOne ? 1 : 3;
                    CheckRadioButton(hdlg, ideDrawOne, ideDrawThree, GET_WM_COMMAND_ID( wParam, lParam));
                    break;
                case ideScoreStandard:
                case ideScoreVegas:
                case ideScoreNone:
                    smdNew = GET_WM_COMMAND_ID( wParam, lParam );
                    CheckRadioButton(hdlg, ideScoreStandard, ideScoreNone, GET_WM_COMMAND_ID( wParam, lParam ));
                    EnableWindow(GetDlgItem(hdlg, ideKeepScore), smdNew == smdVegas);
                    EnableWindow(GetDlgItem(hdlg, ideScore), smdNew == smdVegas);
                    break;
                case IDOK:
                    fNewGame = fFalse;
                    if(IsDlgButtonChecked(hdlg, ideStatusBar) != (WORD)fStatusBar)
                    {
                        if(fStatusBar ^= 1)
                            FCreateStat();
                        else
                            FDestroyStat();
                    }
                    if(ccrdDealNew != ccrdDeal)
                    {
                        ccrdDeal = ccrdDealNew;
                        FInitGm();
                        PositionCols();
                        fNewGame = fTrue;
                    }
                    if(IsDlgButtonChecked(hdlg, ideTimedGame) != (WORD)fTimedGame)
                    {
                        fTimedGame ^= 1;
                        fNewGame = fTrue;
                    }
                    if(smd != smdNew)
                    {
                        smd = smdNew;
                        fNewGame = fTrue;
                    }
                    if(IsDlgButtonChecked(hdlg, ideOutlineDrag) != (WORD)fOutlineDrag)
                    {
                        FSetDrag(fOutlineDrag^1);
                    }

                    fKeepScore = IsDlgButtonChecked(hdlg, ideKeepScore);

                    WriteIniFlags(wifOpts|wifBitmap);
                    /* fall thru */
            case IDCANCEL:
                    EndDialog(hdlg, GET_WM_COMMAND_ID( wParam, lParam ) == IDOK && fNewGame);
                    break;
            }
            break;

        // context sensitive help.
         case WM_HELP: 
            WinHelp(((LPHELPINFO) lParam)->hItemHandle, TEXT("sol.hlp"), 
            HELP_WM_HELP, (ULONG_PTR) aIds);         
            break;  

        case WM_CONTEXTMENU: 
            WinHelp((HWND) wParam, TEXT("sol.hlp"), HELP_CONTEXTMENU, 
            (ULONG_PTR) aIds);         
            break;   
    }
    return fTrue;
}



VOID DoOptions()
{
    BOOL fNewGame;

    if(fNewGame = (BOOL)DialogBox(hinstApp,
                                  MAKEINTRESOURCE(iddOptions),
                                  hwndApp,
                                  OptionsDlgProc))

            NewGame(fTrue, fTrue);
}



BOOL FDrawFocus(HDC hdc, RC *prc, BOOL fFocus)
{
    HBRUSH hbr;
    RC rc;
    hbr = CreateSolidBrush(GetSysColor(fFocus ? COLOR_HIGHLIGHT : COLOR_3DFACE));
    if(hbr == NULL)
            return fFalse;
    rc = *prc;
    FrameRect(hdc, (LPRECT) &rc, hbr);
    InflateRect((LPRECT) &rc, -1, -1);
    FrameRect(hdc, (LPRECT) &rc, hbr);
    DeleteObject(hbr);
    return fTrue;
}




INT_PTR APIENTRY BackDlgProc(HANDLE hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    static INT modeNew;
    MEASUREITEMSTRUCT FAR *lpmi;
    DRAWITEMSTRUCT FAR *lpdi;
    RC rc, rcCrd;
    HDC hdc;

    // Used for context sensitive help.
    static DWORD aIds[] = {
        IDFACEDOWN1,       IDH_SELECT_CARD_BACK,
        IDFACEDOWN2,       IDH_SELECT_CARD_BACK,
        IDFACEDOWN3,       IDH_SELECT_CARD_BACK,
        IDFACEDOWN4,       IDH_SELECT_CARD_BACK,
        IDFACEDOWN5,       IDH_SELECT_CARD_BACK,
        IDFACEDOWN6,       IDH_SELECT_CARD_BACK,
        IDFACEDOWN7,       IDH_SELECT_CARD_BACK,
        IDFACEDOWN8,       IDH_SELECT_CARD_BACK,
        IDFACEDOWN9,       IDH_SELECT_CARD_BACK,
        IDFACEDOWN10,      IDH_SELECT_CARD_BACK,
        IDFACEDOWN11,      IDH_SELECT_CARD_BACK,
        IDFACEDOWN12,      IDH_SELECT_CARD_BACK,
        0,0 };

    switch(wm)
    {
        case WM_INITDIALOG:
            modeNew = modeFaceDown;
            SetFocus(GetDlgItem(hdlg, modeFaceDown));
            return fFalse;

        case WM_COMMAND:
            if( GET_WM_COMMAND_CMD( wParam, lParam )==BN_CLICKED )
                if( GET_WM_COMMAND_ID( wParam, lParam ) >= IDFACEDOWNFIRST && GET_WM_COMMAND_ID( wParam, lParam ) <= IDFACEDOWN12) {
                modeNew = (INT) wParam;
            break;
            }
            if( GET_WM_COMMAND_CMD( wParam, lParam )==BN_DOUBLECLICKED )
                if( GET_WM_COMMAND_ID( wParam, lParam ) >= IDFACEDOWNFIRST && GET_WM_COMMAND_ID( wParam, lParam ) <= IDFACEDOWN12 )
// BabakJ: On Win32, we are destroying wNotifyCode, but is not used later!
                wParam=IDOK;
            // slimy fall through hack of doom (no dupe code or goto)
            switch( GET_WM_COMMAND_ID( wParam, lParam )) {
                case IDOK:
                    ChangeBack(modeNew);
                    WriteIniFlags(wifBack);
                    // fall thru

                case IDCANCEL:
                    EndDialog(hdlg, 0);
                    break;
            }
            break;

    case WM_MEASUREITEM:
            lpmi = (MEASUREITEMSTRUCT FAR *)lParam;
            lpmi->CtlType = ODT_BUTTON;
            lpmi->itemWidth = 32;
            lpmi->itemHeight = 54;
            break;
    case WM_DRAWITEM:
            lpdi = (DRAWITEMSTRUCT FAR *)lParam;

            CopyRect((LPRECT) &rc, &lpdi->rcItem);
            rcCrd = rc;
            InflateRect((LPRECT) &rcCrd, -dxBord, -dyBord);
            hdc = lpdi->hDC;

            if (lpdi->itemAction == ODA_DRAWENTIRE)
            {
                cdtDrawExt(hdc, rcCrd.xLeft, rcCrd.yTop,
                        rcCrd.xRight-rcCrd.xLeft, rcCrd.yBot-rcCrd.yTop,
                        lpdi->CtlID, FACEDOWN, 0L);
                FDrawFocus(hdc, &rc, lpdi->itemState & ODS_FOCUS);
                break;
            }
            if (lpdi->itemAction == ODA_SELECT)
                InvertRect(hdc, (LPRECT)&rcCrd);

            if (lpdi->itemAction == ODA_FOCUS) {
                // Set the new mode when we get focus
                if (lpdi->itemState & ODS_FOCUS)
                    modeNew = lpdi->CtlID;
                FDrawFocus(hdc, &rc, lpdi->itemState & ODS_FOCUS);
            }

            break;

           // context sensitive help.
         case WM_HELP: 
            WinHelp(((LPHELPINFO) lParam)->hItemHandle, TEXT("sol.hlp"), 
            HELP_WM_HELP, (ULONG_PTR) aIds);         
            break;  

        case WM_CONTEXTMENU: 
            WinHelp((HWND) wParam, TEXT("sol.hlp"), HELP_CONTEXTMENU, 
            (ULONG_PTR) aIds);         
            break;   
 

    default:
            return fFalse;
            }
    return fTrue;
}


LRESULT APIENTRY BackPushProc(HWND hwnd, INT wm, WPARAM wParam, LPARAM lParam)
{
    return 0L;
}

VOID DoBacks()
{

    DialogBox(hinstApp,
              MAKEINTRESOURCE(iddBacks),
              hwndApp,
              BackDlgProc);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\sol.c ===
#include "sol.h"
#include <shellapi.h>  // To pick up ShellAbout()
#include <htmlhelp.h>
#include <commctrl.h>   // for fusion classes.

VSZASSERT


#define rgbGreen RGB(0x00,0x80,0x00)
#define rgbWhite RGB(0xff,0xff,0xff)

PT   ptNil = {0x7fff, 0x7fff};
TCHAR szAppName[10];      // name of this app: 'solitaire'
TCHAR szScore[50];        // 'score:' for internationalization

/* Instance info */
static HANDLE  hAccel; // accelerators handle

HWND    hwndApp;       // window handle to this app
HANDLE  hinstApp;      // instance handle to this app
BOOL    fBW=FALSE;     // true if on true monochrome video! (never true on NT)
HBRUSH  hbrTable;      // brush for background of table top
LONG    rgbTable;      // RGB value of table top

BOOL fIconic = fFalse; // true if app is 'iconic'

INT  dyChar;           // tmHeight of font in hdc
INT  dxChar;           // tmMaxCharWidth of font in hdc


#define modeNil -1
INT modeFaceDown = modeNil;  // back of cards ID


GM *pgmCur = NULL;           // current game

/* card extent info */
DEL delCrd;
DEL delScreen;

RC rcClient;                 // client rectangle

INT igmCur;   /* the current game #, srand seeded with this */
#ifdef DEBUG
BOOL fScreenShots = fFalse;
#endif

/* window messages for external app drawing */
static UINT wmCardDraw;


HDC hdcCur = NULL;   // current hdc to draw on
INT usehdcCur = 0;   // hdcCur use count
X xOrgCur = 0;
Y yOrgCur = 0;

static TCHAR szClass[] = TEXT("Solitaire");

TCHAR szOOM[50];

// BUG: some of these should go in gm struct
//
BOOL fStatusBar   = fTrue;
BOOL fTimedGame   = fTrue;
BOOL fKeepScore   = fFalse;
SMD  smd          = smdStandard;  /* Score MoDe */
INT  ccrdDeal     = 3;
BOOL fOutlineDrag = fFalse;

BOOL fHalfCards = fFalse;


INT  xCardMargin;
#define MIN_MARGIN  (dxCrd / 8 + 3)


/********************  Internal Functions ****************/
BOOL FSolInit( HANDLE, HANDLE, LPTSTR, INT );
VOID GetIniFlags( BOOL * );
VOID APIENTRY cdtTerm( VOID );
VOID DoHelp( INT );

LRESULT APIENTRY SolWndProc(HWND, UINT, WPARAM, LPARAM);

// International stuff
//
INT  iCurrency;
TCHAR szCurrency[5];


/******************************************************************************
 * WINMAIN/ENTRY POINT
 *   This is the main entry-point for the application.  It uses the porting
 *   macro MMain() since it was ported from 16bit Windows.
 *
 *   The accelerator-table was added from demo-purposes.
 *
 *
 *****************************************************************************/
MMain( hinst, hinstPrev, lpstrCmdLine, sw )

    MSG msg;
    LPTSTR  lpszCmdLine = GetCommandLine();


    // Initialize the application.
    //
    if (!FSolInit(hinst, hinstPrev, lpszCmdLine, sw))
            return(0);


    // Message-Polling loop.
    //
    msg.wParam = 1;
    while (GetMessage((LPMSG)&msg, NULL, 0, 0))
    {
        if( !TranslateAccelerator( hwndApp, hAccel, &msg ))
        {
            TranslateMessage((LPMSG)&msg);
            DispatchMessage((LPMSG)&msg);
        }
    }

    return ((int)(msg.wParam ? 1 : 0));

    // Eliminate unreferenced-variable warnings from
    // porting macro.
    //
    (void)_argv;
    (void)_argc;
}


/******************************************************************************
 *      FSolInit
 *
 *      Main program initialization.
 *
 *      Arguments:
 *              hinst - instance of this task
 *              hinstPrev - previous instance, or NULL if this is the
 *                      first instance
 *              lpszCmdLine - command line argument string
 *              sw - show window command
 *
 *      Returns:
 *              fFalse on failure.
 *
 *****************************************************************************/
BOOL FSolInit(HANDLE hinst, HANDLE hinstPrev, LPTSTR lpszCmdLine, INT sw)
{
    WNDCLASSEX cls;
    HDC        hdc;
    TEXTMETRIC tm;
    HANDLE     hcrsArrow;
    BOOL       fStartIconic;
    TCHAR FAR  *lpch;
    BOOL       fOutline;
    TCHAR      szT[20];
    RECT       rect;
    INITCOMMONCONTROLSEX icc;   // common control registration.
    WORD APIENTRY TimerProc(HWND, UINT, UINT_PTR, DWORD);

    hinstApp = hinst;

    /* create stock objects */

    CchString(szOOM, idsOOM, ARRAYSIZE(szOOM));
    if(!cdtInit((INT FAR *)&dxCrd, (INT FAR *)&dyCrd))
    {
        goto OOMError;
    }
    hcrsArrow = LoadCursor(NULL, IDC_ARROW);
    hdc = GetDC(NULL);
    if(hdc == NULL)
    {
        OOMError:
        OOM();
        return fFalse;
    }

    GetTextMetrics(hdc, (LPTEXTMETRIC)&tm);
    dyChar = tm.tmHeight;
    dxChar = tm.tmMaxCharWidth;
    if (GetDeviceCaps(hdc, NUMCOLORS) == 2)
        fBW = fTrue;

/* BUG:  if HORZRES not big enough, have to call cdtDrawExt & shrink dxCrd */
/* BUG:  Need to check VERTRES and divide dxCrd by 2 (esp w/ lores ega) */
    dxScreen = GetDeviceCaps(hdc, HORZRES);
    dyScreen = GetDeviceCaps(hdc, VERTRES);
    if(fHalfCards = dyScreen < 300)
        dyCrd /= 2;
    ReleaseDC(NULL, hdc);
    rgbTable = fBW ? rgbWhite : rgbGreen;
    hbrTable = CreateSolidBrush(rgbTable);

    srand((WORD) time(NULL));

    /* load strings */
    CchString(szAppName, idsAppName, ARRAYSIZE(szAppName));
    CchString(szScore, idsScore, ARRAYSIZE(szScore));

    CchString(szT, idsCardDraw, ARRAYSIZE(szT));
    wmCardDraw = RegisterWindowMessage(szT);

    /* scan cmd line to see if should come up iconic */
    /* this may be unnecessary with win3.0 (function may be provided to */
    /* do it automatically */

    fStartIconic = fFalse;
    for(lpch = lpszCmdLine; *lpch != TEXT('\000'); lpch++)
    {
        if(*lpch == TEXT('/') && *(lpch+1) == TEXT('I'))
        {
            fStartIconic = fTrue;
            break;
        }
    }


    // Register the common controls.
    icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icc.dwICC  = ICC_ANIMATE_CLASS | ICC_BAR_CLASSES | ICC_COOL_CLASSES | ICC_HOTKEY_CLASS | ICC_LISTVIEW_CLASSES | 
                 ICC_PAGESCROLLER_CLASS | ICC_PROGRESS_CLASS | ICC_TAB_CLASSES | ICC_UPDOWN_CLASS | ICC_USEREX_CLASSES;
    InitCommonControlsEx(&icc);

    /* Load the solitaire icon */

    hIconMain = LoadIcon(hinstApp, MAKEINTRESOURCE(ID_ICON_MAIN));

    /* Load the solitaire icon image */

    hImageMain = LoadImage(hinstApp, MAKEINTRESOURCE(ID_ICON_MAIN),
                         IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);


    /* register window classes */

    if (hinstPrev == NULL)
    {
        ZeroMemory( &cls, sizeof(cls) );
        cls.cbSize= sizeof(cls);
        cls.style = CS_BYTEALIGNWINDOW | CS_DBLCLKS,
        cls.lpfnWndProc = SolWndProc;
        cls.hInstance = hinstApp;
        cls.hIcon =  hIconMain;
        cls.hIconSm= hImageMain;
        cls.hCursor = hcrsArrow;
        cls.hbrBackground = hbrTable;
        cls.lpszMenuName = MAKEINTRESOURCE(idmSol);
        cls.lpszClassName = (LPTSTR)szClass;
        if (!RegisterClassEx(&cls))
        {
            goto OOMError;
        }
     }

	/* Determine the proper starting size for the window */

	/* Card margin is just a little bigger than 1/8 of a card */
	xCardMargin = MIN_MARGIN;
	
	/* We need 7 card widths and 8 margins */
	rect.right = dxCrd * 7 + 8 * xCardMargin;

	/* Compute the window size we need for a client area this big */
	rect.bottom = dyCrd * 4;
	rect.left = rect.top = 0;
	AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, TRUE);
	rect.right -= rect.left;
	rect.bottom -= rect.top;

	/* Make sure it's not too big */
	if (rect.bottom > dyScreen)
	    rect.bottom = dyScreen;

    /* create our windows */
    if (!
    (hwndApp = CreateWindow( (LPTSTR)szClass, (LPTSTR)szAppName,
                    fStartIconic ? WS_OVERLAPPEDWINDOW | WS_MINIMIZE | WS_CLIPCHILDREN:
                    WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                    CW_USEDEFAULT, 0,
			rect.right, rect.bottom,
                        (HWND)NULL, (HMENU)NULL, hinstApp, (LPTSTR)NULL)))
        {
        goto OOMError;
        }

    GetIniFlags(&fOutline);


    if(SetTimer(hwndApp, 666, 250, TimerProc) == 0)
    {
        goto OOMError;
    }

    FInitGm();
    FSetDrag(fOutline);

    ShowWindow(hwndApp, sw);
    UpdateWindow(hwndApp);

    hAccel = LoadAccelerators( hinst, TEXT("HiddenAccel") );

    FRegisterStat(hinstPrev == NULL);
    if(fStatusBar)
        FCreateStat();

    Assert(pgmCur != NULL);
    if(sw != SW_SHOWMINNOACTIVE && sw != SW_MINIMIZE)
        PostMessage(hwndApp, WM_COMMAND, idsInitiate, 0L);

    return(fTrue);
}



VOID DoPaint(HWND hwnd)
{
    PAINTSTRUCT paint;

    BeginPaint(hwnd, (LPPAINTSTRUCT) &paint);
    if(pgmCur)
        SendGmMsg(pgmCur, msggPaint, (INT_PTR) &paint, 0);
    EndPaint(hwnd, (LPPAINTSTRUCT) &paint);
}


/*      SolWndProc
 *
 *      Window procedure for main Sol window.
 *
 *      Arguments:
 *              hwnd - window handle receiving the message - should
 *                      be hwndSol
 *              wm - window message
 *              wParam, lParam - more info as required by wm
 *
 *      Returns:
 *              depends on the message
 */
LRESULT APIENTRY SolWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    HMENU hmenu;
    PT pt;
    INT msgg;
    VOID NewGame();
    VOID StatString();

    switch (wm)
    {
        default:
            if(wm == wmCardDraw)
            {
                switch(wParam)
                {
                    case drwInit:
                        return MAKELONG(dxCrd, dyCrd);

                    case drwDrawCard:
                        #define lpcddr ((CDDR FAR *)lParam)
                        return cdtDraw(lpcddr->hdc, lpcddr->x, lpcddr->y, lpcddr->cd, lpcddr->mode, lpcddr->rgbBgnd);
                        #undef lpcddr

                    case drwClose:
                        PostMessage(hwndApp, WM_SYSCOMMAND, SC_CLOSE, 0L);
                        return fTrue;
                }
            }
            break;

    case WM_HELP:
        DoHelp( idsHelpIndex );
        break;

    case WM_DESTROY:
        KillTimer(hwndApp, 666);
        SendGmMsg(pgmCur, msggEnd, 0, 0);
        FSetDrag(fTrue);    /* Free up screen bitmaps if we made em */
        cdtTerm();
        DeleteObject(hbrTable);
        PostQuitMessage(0);
        break;

    case WM_ACTIVATE:
        if( GET_WM_ACTIVATE_STATE(wParam, lParam) &&
		   !GET_WM_ACTIVATE_FMINIMIZED(wParam, lParam) )
            DoPaint(hwnd);
        break;

    case WM_KILLFOCUS:
        if(pgmCur->fButtonDown)
            SendGmMsg(pgmCur, msggMouseUp, 0, fTrue);
        /* Fall through. */
    case WM_SETFOCUS:
        ShowCursor(wm == WM_SETFOCUS);
        break;


    case WM_SIZE:
    {
	    int nNewMargin;
	    int nMinMargin;

	    fIconic = IsIconic(hwnd);
	    GetClientRect(hwnd, (LPRECT) &rcClient);

	    /* Compute the new margin size if any and if necessary, redraw */
	    nNewMargin = ((short)lParam - 7 * (short)dxCrd) / 8;
	    nMinMargin = MIN_MARGIN;
	    if (nNewMargin < nMinMargin && xCardMargin != nMinMargin)
		nNewMargin = nMinMargin;
	    if (nNewMargin >= nMinMargin)
	    {
            xCardMargin = nNewMargin;
            PositionCols();
            InvalidateRect(hwnd, NULL, TRUE);
	    }

	    /* Code always falls through here */
    }


    case WM_MOVE:
        StatMove();
        break;


    case WM_MENUSELECT:
	    // Don't send in garbage if not a menu item
	    if( GET_WM_MENUSELECT_FLAGS( wParam, lParam ) & MF_POPUP     ||
		    GET_WM_MENUSELECT_FLAGS( wParam, lParam ) & MF_SYSMENU   ||
		    GET_WM_MENUSELECT_FLAGS( wParam, lParam ) & MF_SEPARATOR ) {

		    StatString(idsNil);
		}
		else {
		    StatString( GET_WM_MENUSELECT_CMD( wParam, lParam ));
		}
        break;

    case WM_KEYDOWN:
        Assert(pgmCur);
        SendGmMsg(pgmCur, msggKeyHit, wParam, 0);
        break;

    case WM_LBUTTONDOWN:
        /*              ProfStart(); */
        SetCapture(hwnd);
        if(pgmCur->fButtonDown)
            break;
        msgg = msggMouseDown;
        goto DoMouse;

    case WM_LBUTTONDBLCLK:
        msgg = msggMouseDblClk;
        if(pgmCur->fButtonDown)
            break;
        goto DoMouse;

    case WM_RBUTTONDOWN:
        // If the left mousebutton is down, ignore the right click.
        if (GetCapture())
            break;
        msgg = msggMouseRightClk;
        goto DoMouse;

    case WM_LBUTTONUP:
        /*              ProfStop(); */
        ReleaseCapture();
        msgg = msggMouseUp;
        if(!pgmCur->fButtonDown)
            break;
        goto DoMouse;

    case WM_MOUSEMOVE:
        msgg = msggMouseMove;
        if(!pgmCur->fButtonDown)
            break;
DoMouse:
            Assert(pgmCur != NULL);
            LONG2POINT( lParam, pt );
            Assert(pgmCur);
            SendGmMsg(pgmCur, msgg, (INT_PTR) &pt, 0);
            break;


    case WM_COMMAND:
        switch( GET_WM_COMMAND_ID( wParam, lParam ))
        {
            /* Game menu */
            case idsInitiate:
                NewGame(fTrue, fFalse);
                break;
            case idsUndo:
                Assert(pgmCur);
                SendGmMsg(pgmCur, msggUndo, 0, 0);
                break;
            case idsBacks:
                DoBacks();
                break;
            case idsOptions:
                DoOptions();
                break;
            case idsExit:
                PostMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                break;
            /* Help Menu */
            case (WORD)idsHelpIndex:
            case (WORD)idsHelpSearch:
            case (WORD)idsHelpUsing:
                DoHelp( (INT)(SHORT)GET_WM_COMMAND_ID( wParam, lParam ));
                break;
            case idsAbout:
            {
                TCHAR szExtraInfo[100];
                CchString(szExtraInfo, idsExtraInfo, ARRAYSIZE(szExtraInfo));
#ifndef _GAMBIT_
                ShellAbout(hwnd, szAppName, szExtraInfo, hIconMain);
#endif
                break;
            }
            case idsForceWin:
                SendGmMsg(pgmCur, msggForceWin, 0, 0);
                break;
#ifdef DEBUG
            case idsGameNo:
                if(FSetGameNo())
                    NewGame(fFalse, fFalse);
                break;

            case idsCardMacs:
                PrintCardMacs(pgmCur);
                break;
            case idsAssertFail:
                Assert(fFalse);
                break;
            case idsMarquee:
                break;

            case idsScreenShots:
                fScreenShots ^= 1;
                CheckMenuItem(GetMenu(hwnd), idsScreenShots, fScreenShots ? MF_CHECKED|MF_BYCOMMAND : MF_UNCHECKED|MF_BYCOMMAND);
                InvalidateRect(hwndStat, NULL, fTrue);
                if(fScreenShots)
                    InvalidateRect(hwnd, NULL, fTrue);
                break;
#endif
            default:
                break;
            }
            break;

    case WM_INITMENU:
            hmenu = GetMenu(hwnd);
            Assert(pgmCur);
            EnableMenuItem(hmenu, idsUndo,
                    pgmCur->udr.fAvail && !FSelOfGm(pgmCur) ? MF_ENABLED : MF_DISABLED|MF_GRAYED);
            EnableMenuItem(hmenu, idsInitiate, FSelOfGm(pgmCur) ? MF_DISABLED|MF_GRAYED : MF_ENABLED);
            EnableMenuItem(hmenu, idsBacks,    FSelOfGm(pgmCur) ? MF_DISABLED|MF_GRAYED : MF_ENABLED);
            EnableMenuItem(hmenu, idsAbout,    FSelOfGm(pgmCur) ? MF_DISABLED|MF_GRAYED : MF_ENABLED);
            break;

    case WM_PAINT:
        if(!fIconic)
        {
            DoPaint(hwnd);
            return(0L);
        }
        break;    
    }

    return(DefWindowProc(hwnd, wm, wParam, lParam));
}



HDC HdcSet(HDC hdc, X xOrg, Y yOrg)
{
    HDC hdcT = hdcCur;
    hdcCur = hdc;
    xOrgCur = xOrg;
    yOrgCur = yOrg;
    return hdcT;
}



BOOL FGetHdc()
{
    HDC hdc;

    Assert(hwndApp);
    if(hdcCur != NULL)
    {
        usehdcCur++;
        return fTrue;
    }

    hdc = GetDC(hwndApp);
    if(hdc == NULL)
        return fFalse;
    HdcSet(hdc, 0, 0);
    usehdcCur = 1;
    return fTrue;
}


VOID ReleaseHdc()
{
    if(hdcCur == NULL)
        return;
    if(--usehdcCur == 0)
    {
        ReleaseDC(hwndApp, hdcCur);
        hdcCur = NULL;
    }
}


WORD APIENTRY TimerProc(HWND hwnd, UINT wm, UINT_PTR id, DWORD dwTime)
{

    if(pgmCur != NULL)
		SendGmMsg(pgmCur, msggTimer, 0, 0);
    return fTrue;
}





VOID ChangeBack(INT mode)
{

    if(mode == modeFaceDown)
        return;
    modeFaceDown = mode;
    InvalidateRect(hwndApp, NULL, fTrue);
}


VOID NewGame(BOOL fNewSeed, BOOL fZeroScore)
{

#ifdef DEBUG
    InitDebug();
#endif
    if(fNewSeed)
    {
        static INT lastrnd= -1;     // previous rand() value
        INT rnd1;                   // trial rand() value
        INT Param;

        // It was reported that games never changed.
        // We could not repro it so see if it happens
        // and output a message to the debugger.
        //

        Param= (INT) time(NULL);
        srand( igmCur = ((WORD) Param) & 0x7fff);

#ifdef DEBUG
        rnd1= rand();

        if( lastrnd == rnd1 )
        {
            TCHAR szText[100];
            wsprintf(szText,TEXT("Games repeat: time= %d  GetLastError= %d\n"),
                     Param, GetLastError());
            OutputDebugString(szText);
        }

        lastrnd= rnd1;
#endif

    }

#ifdef DEBUG
    SendGmMsg(pgmCur, msggChangeScore, 0, 0);
#endif
    SendGmMsg(pgmCur, msggDeal, fZeroScore, 0);
}



INT_PTR APIENTRY About(HWND hdlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
    if (iMessage == WM_COMMAND)
    {
        EndDialog(hdlg,fTrue);
        return fTrue;
    }
    else if (iMessage == WM_INITDIALOG)
        return fTrue;
    else
        return fFalse;
}


VOID DoHelp(INT idContext)
{
    CHAR sz[100];
    HWND hwndResult;

    LoadStringA(hinstApp, (WORD)idsHelpFile, (LPSTR)sz, 100);

#ifndef _GAMBIT_
    switch(idContext)
    {
        case idsHelpUsing:
            hwndResult = HtmlHelpA(GetDesktopWindow(), "NTHelp.chm", HH_DISPLAY_TOPIC, 0);
            break;
        case idsHelpIndex:
            hwndResult = HtmlHelpA(GetDesktopWindow(), sz, HH_DISPLAY_TOPIC, 0);
            break;
        case idsHelpSearch:
            hwndResult = HtmlHelpA(GetDesktopWindow(), sz, HH_DISPLAY_INDEX, 0);
            break;
    }
    if(!hwndResult)
        ErrorIds(idsNoHelp);
#endif
}


VOID GetIniFlags(BOOL *pfOutline)
{
    INI    ini;
    INT    mode;
    TCHAR  szDefCurrency[5];
    INT    iDefCurrency;


    ini.w = 0;
    ini.grbit.fStatusBar = fStatusBar;
    ini.grbit.fTimedGame = fTimedGame;
    ini.grbit.fOutlineDrag = fOutlineDrag;
    ini.grbit.fDrawThree = ccrdDeal == 3;
    ini.grbit.fKeepScore = fKeepScore;
    ini.grbit.fSMD = 0;

    ini.w = GetIniInt(idsAppName, idsOpts, ini.w);

    fStatusBar = ini.grbit.fStatusBar ? 1 : 0;
    fTimedGame = ini.grbit.fTimedGame ? 1 : 0;
    *pfOutline = ini.grbit.fOutlineDrag ? 1 : 0;
    ccrdDeal = ini.grbit.fDrawThree ? 3 : 1;
    fKeepScore = ini.grbit.fKeepScore ? 1 : 0;
    switch(ini.grbit.fSMD)
    {
        default:
            smd = smdStandard;
            break;
        case 1:
            smd = smdVegas;
            break;
        case 2:
            smd = smdNone;
            break;
    }

    mode = GetIniInt(idsAppName, idsBack, rand() % cIDFACEDOWN) + IDFACEDOWNFIRST-1;
    ChangeBack(PegRange(mode, IDFACEDOWNFIRST, IDFACEDOWN12));

    // get the default user currency.
    if (GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SCURRENCY, szDefCurrency, sizeof(szDefCurrency)/sizeof(TCHAR)) == 0)
        lstrcpy(szDefCurrency, TEXT("$"));

    if (GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_ICURRENCY, (LPTSTR) &iDefCurrency, sizeof(iDefCurrency)) == 0)
        iDefCurrency = 0;

    iCurrency = GetIniInt(idsIntl, idsiCurrency, iDefCurrency);
    FGetIniString(idsIntl, idssCurrency, szCurrency, szDefCurrency, sizeof(szCurrency));



}


VOID WriteIniFlags(INT wif)
{
    INI ini;

    if(wif & wifOpts)
    {
        ini.w = 0;
        ini.grbit.fStatusBar = fStatusBar;
        ini.grbit.fTimedGame = fTimedGame;
        ini.grbit.fOutlineDrag = fOutlineDrag;
        ini.grbit.fDrawThree = ccrdDeal == 3;
        ini.grbit.fKeepScore = fKeepScore;
        switch(smd)
        {
            default:
                Assert(fFalse);
                break;
            case smdStandard:
                ini.grbit.fSMD = 0;
                break;
            case smdVegas:
                ini.grbit.fSMD = 1;
                break;
            case smdNone:
                ini.grbit.fSMD = 2;
                break;
        }

        FWriteIniInt(idsAppName, idsOpts, ini.w);
    }
    if(wif & wifBack)
            FWriteIniInt(idsAppName, idsBack, modeFaceDown-IDFACEDOWNFIRST+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\undo.c ===
#include "sol.h"
VSZASSERT



BOOL FInitUndo(UDR *pudr)
{
    INT icol;

    pudr->fAvail = fFalse;

    for(icol = 0; icol < 2; icol++)
         if((pudr->rgpcol[icol] = PcolCreate(NULL, 0, 0, 0, 0, icrdUndoMax)) == NULL)
        {
            if(icol != 0)
                FreeP(pudr->rgpcol[0]);
            return fFalse;
        }
    return fTrue;
}
    

VOID FreeUndo(UDR *pudr)
{
    INT icol;

    for(icol = 0; icol < 2; icol++)
        FreeP(pudr->rgpcol[icol]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\stat.h ===
/* PUBLICs */
BOOL FRegisterStat(BOOL fFirstInst);
BOOL FDestroyStat( VOID );
VOID StatRender( VOID );
VOID StatUpdate( VOID );
VOID StatMove( VOID );
VOID StatString(INT ids);
VOID StatStringSz(TCHAR *sz);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\solid.h ===
#define szVer TEXT("Version 3.0")


/* ------ Strings ------ */
#define idsNil          0x1fff
#define idsAppName		100
#define idsScore		101
#define idsTime		    102
#define idsCardDraw		103
#define idsDealAgain	104
#define idsHelpFile		105
#define idsEndWinner	106
#define idsBonus		107
#define idsExtraInfo	108
	

/* ini strings */
#define idsBack		    200
#define idsOpts		    201
#define idsBitmap		202
/* DON'T internationalize iCurrency, sCurrency and intl */
#define idsiCurrency	203
#define idssCurrency	204
#define idsIntl		    205

/* error strings */
#define idsOOM		    300
#define idsNoHelp		301
#define idsNoBitmap		302
#define idsNoFullDrag	303

/* status line strings */
#define idsInitiate		1000
#define idsUndo		    1001
#define idsBacks		1002
#define idsOptions		1003
#define idsExit		    1004

/* Debug               */
#define idsGameNo		1005
#define idsCardMacs		1006
#define idsAssertFail	1007
#define idsMarquee		1008
#define idsScreenShots	1009
#define idsForceWin		1010


/* Help menu */
/* BabakJ: Win3.1 help merge */
#define idsHelpIndex		-30
#define idsHelpSearch		-29
#define idsHelpUsing		-28
#define idsAbout		2000

/* INTERNATIONAL: Ignore the stuff below */

#define idmSol		        1

/* ------ Dialog Boxes ----- */
#define iddAbout		    100
#define iddBacks		    101
#define iddGameNo		    102
#define iddOptions		    103

#define ideGameNoEdit		200

/* Options */
#define ideDrawOne		    300
#define ideDrawThree		301
#define ideScoreStandard	302
#define ideScoreVegas		303
#define ideScoreNone		304
#define ideTimedGame		305
#define ideStatusBar		306
#define ideOutlineDrag		307
#define ideKeepScore		308
#define ideBitmap		    309
#define ideScore		    310


#define idsStatLast         idsAbout


// CS help for the two dialogs in Solitaire--Deck and Options //

//Deck (Card Back)
#define IDH_SELECT_CARD_BACK            100

//Options//
#define IDH_OPTIONS_DRAW                101
#define IDH_OPTIONS_SCORING             102
#define IDH_OPTIONS_TIMED_GAME          103
#define IDH_OPTIONS_STATUS_BAR          104
#define IDH_OPTIONS_OUTLINE_DRAGGING    105
#define IDH_OPTIONS_CUMULATIVE_SCORE    106
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\std.h ===
#include <memory.h>


typedef INT X;
typedef INT Y;
typedef INT DX;
typedef INT DY;


#define fTrue  1
#define fFalse 0

/* PoinT structure */
typedef struct _pt
{
    X x;
    Y y;
} PT;



/* DEL structure */
typedef struct _del
{
    DX dx;
    DY dy;
} DEL;


/* ReCt structure  */
typedef struct _rc
{
    X xLeft;
    Y yTop;
    X xRight;
    Y yBot;
} RC;


#ifdef DEBUG
#define VSZASSERT static TCHAR *vszAssert = TEXT(__FILE__);
#define Assert(f) { if (!(f)) { AssertFailed(vszAssert, __LINE__); } }
#define SideAssert(f) { if (!(f)) { AssertFailed(vszAssert, __LINE__); } }
#else
#define Assert(f)
#define SideAssert(f) (f)
#define VSZASSERT
#endif

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

VOID *PAlloc(INT cb);
VOID FreeP( VOID * );

TCHAR *PszCopy(TCHAR *pszFrom, TCHAR *rgchTo);
INT CchDecodeInt(TCHAR *rgch, INT_PTR w);
VOID Error(TCHAR *sz);
VOID ErrorIds(INT ids);
INT WMin(INT w1, INT w2);
INT WMax(INT w1, INT w2);
// INT WParseLpch(TCHAR[ 	]*FAR[ 	]***plpch);
BOOL FInRange(INT w, INT wFirst, INT wLast);
INT PegRange(INT w, INT wFirst, INT wLast);
VOID NYI( VOID );
INT CchString(TCHAR *sz, INT ids, UINT cchBuf);
VOID InvertRc(RC *prc);
VOID OffsetPt(PT *ppt, DEL *pdel, PT *pptDest);
BOOL FRectAllVisible(HDC hdc, RC *prc);

// Removed so it will build on NT...<chriswil>
//
// INT APIENTRY MulDiv( INT, INT, INT );


#ifdef DEBUG
VOID AssertFailed(TCHAR *szFile, INT li);
#endif

#define bltb(pb1, pb2, cb) memcpy(pb2, pb1, cb)


extern HWND hwndApp;
extern HANDLE hinstApp;



BOOL FWriteIniString(INT idsTopic, INT idsItem, TCHAR *szValue);
BOOL FWriteIniInt(INT idsTopic, INT idsItem, DWORD w);
BOOL FGetIniString(INT idsTopic, INT idsItem, TCHAR *sz, TCHAR *szDefault, INT cchMax);
DWORD GetIniInt(INT idsTopic, INT idsItem, DWORD wDefault);



VOID CrdRcFromPt(PT *ppt, RC *prc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\stat.c ===
#include "sol.h"
VSZASSERT

#define dyStatMarg 1
#define dxStatMarg 4

static TCHAR szStatClass[] = TEXT("Stat");    // class name

HWND hwndStat = NULL;      // window to status area
static INT dyStat;         // height of status window


BOOL FRegisterStat(BOOL fFirstInst)
{
    WNDCLASS cls;
    LRESULT APIENTRY StatWndProc(HWND, UINT, WPARAM, LPARAM );

    /* ?? can I use static class? */
    if(fFirstInst)
    {
        cls.style = 0,
        cls.lpfnWndProc = StatWndProc;
        cls.cbClsExtra = cls.cbWndExtra = 0;
        cls.hInstance = hinstApp;
        cls.hIcon = NULL;
        cls.hCursor = LoadCursor(NULL, IDC_ARROW);
        cls.hbrBackground = GetStockObject(WHITE_BRUSH);
        cls.lpszMenuName = NULL;
        cls.lpszClassName = (LPTSTR)szStatClass;
        if (!RegisterClass((LPWNDCLASS)&cls))
            return(fFalse);
    }
    return fTrue;
}


BOOL FCreateStat()
{
    RC rc;

    dyStat = dyChar+2*dyStatMarg;
    GetClientRect(hwndApp, (LPRECT) &rc);
    hwndStat = CreateWindow((LPTSTR) szStatClass, TEXT(""),
                WS_BORDER|WS_CHILD|CS_HREDRAW|CS_VREDRAW,
                rc.xLeft-1, rc.yBot-dyStat+1, rc.xRight-rc.xLeft+2, dyStat, hwndApp,
                NULL, hinstApp, NULL);


    ShowWindow(hwndStat, SW_SHOWNOACTIVATE);
    UpdateWindow(hwndStat);
    return fTrue;
}



BOOL FDestroyStat()
{
    if(hwndStat)
    {
        DestroyWindow(hwndStat);
        hwndStat = NULL;
    }
    return fTrue;
}


LRESULT APIENTRY StatWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT paint;
    HDC hdc;
    VOID StatRender();

    switch(wm)
    {
        case WM_PAINT:
            BeginPaint(hwnd, (LPPAINTSTRUCT) &paint);
            hdc = HdcSet(paint.hdc, 0, 0);
            StatRender();
            HdcSet(hdc, 0, 0);
            EndPaint(hwnd, (LPPAINTSTRUCT) &paint);
            return(0L);
    }

    return(DefWindowProc(hwnd, wm, wParam, lParam));
}


VOID StatRender()
{
    RC rc;

    if(pgmCur != NULL && hwndStat != NULL)
    {
        GetClientRect(hwndStat, (LPRECT) &rc);
        rc.xRight -= dxStatMarg;
        SendGmMsg(pgmCur, msggDrawStatus, (INT_PTR) &rc, 0);
    }
}


VOID StatUpdate()
{
    HDC hdc;
    HDC hdcSav;

    if(hwndStat == NULL)
        return;
    if((hdc = GetDC(hwndStat)) != NULL)
    {
        hdcSav = HdcSet(hdc, 0, 0);
        StatRender();
        HdcSet(hdcSav, 0, 0);
        ReleaseDC(hwndStat, hdc);
    }
}


VOID StatMove()
{
    RC rc;

    if(hwndStat != NULL)
    {
        GetClientRect(hwndApp, (LPRECT) &rc);
        MoveWindow(hwndStat, rc.xLeft-1, rc.yBot-dyStat+1, rc.xRight-rc.xLeft+2, dyStat, fTrue);
        InvalidateRect(hwndStat, NULL, fTrue);
    }
}


VOID StatStringSz(TCHAR *sz)
{
    HDC hdc, hdcSav;
    RC rc;
    HFONT  hFontOld = NULL;
    HFONT  hStatusFont = NULL;

    if(hwndStat == NULL)
            return;
    hdc = GetDC(hwndStat);
    if(hdc == NULL)
            return;

    // store the old font and replace the status font by MS Shell Dlg
    // as it supports FE characters as well as euro characters.

    hStatusFont = CreateFont(-MulDiv(9, GetDeviceCaps(hdc, LOGPIXELSY), 72), 0, 0, 0, FW_BOLD, 0, 0, 0, 
                             DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, 
                             DEFAULT_PITCH, TEXT("MS Shell Dlg")); 

    if (hStatusFont)
        hFontOld = SelectObject(hdc, hStatusFont);


    hdcSav =        HdcSet(hdc, 0, 0);
    GetClientRect(hwndStat, (LPRECT) &rc);
    PatBlt(hdcCur, rc.xLeft, rc.yTop, rc.xRight-rc.xLeft, rc.yBot-rc.yTop, PATCOPY);
    TextOut(hdcCur, dxStatMarg, 0, sz, lstrlen(sz));
    StatRender();

    // restore the font
    if (hFontOld)
        SelectObject(hdcCur, hFontOld);

    // close the created font handle
    if (hStatusFont)
        DeleteObject(hStatusFont);

    HdcSet(hdcSav, 0, 0);
    ReleaseDC(hwndStat, hdc);
}


VOID StatString(INT ids)
{
    TCHAR sz[60];

    if(ids != idsNil)
        CchString(sz, ids, ARRAYSIZE(sz));
    else
        sz[0] = TEXT('\000');

    StatStringSz(sz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\undo.h ===
/* UnDo Record  */
typedef struct _udr
{
	BOOL fAvail;
    BOOL fEndDeck;
	INT sco;
	INT icol1, icol2;
    INT irep;
	COL *rgpcol[2];
} UDR;


BOOL FInitUndo(UDR *pudr);
VOID FreeUndo(UDR *pudr);



#define icrdUndoMax 52
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\games\sol\util.c ===
#include "sol.h"
VSZASSERT




VOID *PAlloc(INT cb)
{
    TCHAR *p;

    // KLUDGE: solve overwriting memory by allocating more
    #define MEMORYPAD 200
    p = (TCHAR *)LocalAlloc(LPTR, cb+MEMORYPAD);
    Assert(p != NULL);
    return (VOID *)p;
}


VOID FreeP(VOID *p)
{
    LocalFree((HANDLE) p);
}



VOID InvertRc(RC *prc)
{
    Assert(xOrgCur == 0);
    Assert(yOrgCur == 0);
    AssertHdcCur();

    InvertRect(hdcCur, (LPRECT) prc);
}


VOID DrawCard(CRD *pcrd)
{
    AssertHdcCur();
    cdtDrawExt( hdcCur,
                pcrd->pt.x-xOrgCur,
                pcrd->pt.y-yOrgCur,
                dxCrd,
                dyCrd,
                pcrd->fUp ? pcrd->cd : modeFaceDown,
                pcrd->fUp ? FACEUP : FACEDOWN,
                rgbTable);
}


VOID DrawOutline(PT *ppt, INT ccrd, DX dx, DY dy)
{
    Y y;
    PT pt;
    INT rop2;
    if(!FGetHdc())
        return;

    pt = *ppt;

    rop2 = SetROP2(hdcCur, R2_NOT);
    MMoveTo(hdcCur, pt.x, pt.y);
    LineTo(hdcCur, pt.x+dxCrd, pt.y);
    LineTo(hdcCur, pt.x+dxCrd, y = pt.y+dyCrd+(ccrd-1) * dy);
    LineTo(hdcCur, pt.x, y);
    LineTo(hdcCur, pt.x, pt.y);
    y = pt.y;
    while(--ccrd)
    {
        y += dy;
        MMoveTo(hdcCur, pt.x, y);
        LineTo(hdcCur, pt.x+dxCrd, y);
    }
    SetROP2(hdcCur, rop2);
    ReleaseHdc();
}

VOID DrawCardPt(CRD *pcrd, PT *ppt)
{
    DWORD dwModeExt=0;     // turn on sign bit if moving fast
                           // cdtDrawExt must support this!

    if( fKlondWinner )
    {
        dwModeExt= MINLONG;
    }

    AssertHdcCur();
    cdtDrawExt(hdcCur,
               ppt->x-xOrgCur,
               ppt->y-yOrgCur,
               dxCrd,
               dyCrd,
               pcrd->fUp ? pcrd->cd : modeFaceDown,
               (pcrd->fUp ? FACEUP : FACEDOWN ) | dwModeExt,
               rgbTable);
}

VOID DrawCardExt(PT *ppt, INT cd, INT mode)
{
    VOID DrawBackground();

    AssertHdcCur();

    cdtDrawExt( hdcCur,
                ppt->x-xOrgCur,
                ppt->y-yOrgCur,
                dxCrd,
                dyCrd,
                cd,
                mode,
                rgbTable);
}


VOID DrawBackground(X xLeft, Y yTop, X xRight, Y yBot)
{
    HBRUSH hbr;


    AssertHdcCur();
    MSetBrushOrg(hdcCur, xOrgCur, yOrgCur);
    MUnrealizeObject(hbrTable);
    if((hbr = SelectObject(hdcCur, hbrTable)) != NULL)
    {
        Assert(xRight >= xLeft);
        Assert(yBot >= yTop);
        PatBlt( hdcCur,
                xLeft-xOrgCur,
                yTop-yOrgCur,
                xRight-xLeft,
                yBot-yTop,
                PATCOPY);
        SelectObject(hdcCur, hbr);
    }
}


VOID EraseScreen(VOID)
{
    RC rc;
    HDC HdcSet();

    if(!FGetHdc())
        return;
    GetClientRect(hwndApp, (LPRECT) &rc);
    DrawBackground(rc.xLeft, rc.yTop, rc.xRight, rc.yBot);
    ReleaseHdc();
}





BOOL FPtInCrd(CRD *pcrd, PT pt)
{

    return(pt.x >= pcrd->pt.x && pt.x < pcrd->pt.x+dxCrd &&
             pt.y >= pcrd->pt.y && pt.y < pcrd->pt.y+dyCrd);
}




BOOL FRectIsect(RC *prc1, RC *prc2)
{
    RC rcDummy;

    return(IntersectRect((LPRECT) &rcDummy, (LPRECT) prc1, (LPRECT) prc2));
}


VOID CrdRcFromPt(PT *ppt, RC *prc)
{
    prc->xRight = (prc->xLeft = ppt->x) + dxCrd;
    prc->yBot = (prc->yTop = ppt->y) + dyCrd;
}


BOOL FCrdRectIsect(CRD *pcrd, RC *prc)
{
    RC rcDummy;
    RC rcCrd;

    CrdRcFromPt(&pcrd->pt, &rcCrd);
    return(IntersectRect((LPRECT) &rcDummy, (LPRECT) &rcCrd, (LPRECT) prc));
}

/* BUG: only considers upper left and lower right corners */
/* this is ok for my purposes now, but beware... */
BOOL FRectAllVisible(HDC hdc, RC *prc)
{
    return PtVisible(hdc, prc->xLeft, prc->yTop) && PtVisible(hdc, prc->xRight, prc->yBot);
}


VOID OffsetPt(PT *ppt, DEL *pdel, PT *pptDest)
{
    pptDest->x = ppt->x + pdel->dx;
    pptDest->y = ppt->y + pdel->dy;
}


VOID SwapCards(CRD *pcrd1, CRD *pcrd2)
{
    CRD crdT;

    crdT = *pcrd1;
    *pcrd1 = *pcrd2;
    *pcrd2 = crdT;
}





TCHAR *PszCopy(TCHAR *pszFrom, TCHAR *rgchTo)
{
    while (*rgchTo++ = *pszFrom++)
        ;
    return(rgchTo-1);
}



INT CchDecodeInt(TCHAR *rgch, INT_PTR w)
{
    INT fNeg;
    TCHAR *pch, *pchT;
    TCHAR rgchT[20];

    if (fNeg = w<0)
        w = -w;

    pchT = rgchT;
    do
    {
        *pchT++ = (TCHAR)(TEXT('0') + (TCHAR) (w % 10));
        w /= 10;
    }
    while (w);
    pch = rgch;
    if (fNeg)
        *pch++ = TEXT('-');
    do
        *pch++ = *--pchT;
    while (pchT > rgchT);
    *pch = TEXT('\000');
    return((INT)(pch - rgch));
}

VOID Error(TCHAR *sz)
{

    MessageBox(hwndApp, (LPTSTR)sz, (LPTSTR)szAppName, MB_OK|MB_ICONEXCLAMATION);
}

/* returns fTrue if yes is clicked  */
BOOL FYesNoAlert( INT ids )
{
    TCHAR sz[128];
    INT id;

    CchString(sz, ids, ARRAYSIZE(sz));
    id = MessageBox(hwndApp, sz, szAppName, MB_YESNO|MB_ICONEXCLAMATION);
    return id == IDYES || id == IDOK;
}


VOID ErrorIds(INT ids)
{
    TCHAR sz[128];

    CchString(sz, ids, ARRAYSIZE(sz));
    Error(sz);
}

INT WMin(INT w1, INT w2)
{
    return(w1 < w2 ? w1 : w2);
}


INT WMax(INT w1, INT w2)
{
    return(w1 > w2 ? w1 : w2);
}


BOOL FInRange(INT w, INT wFirst, INT wLast)
{
    Assert(wFirst <= wLast);
    return(w >= wFirst && w <= wLast);
}


INT PegRange(INT w, INT wFirst, INT wLast)
{
    Assert(wFirst <= wLast);
    if(w < wFirst)
        return wFirst;
    else if(w > wLast)
        return wLast;
    else
        return w;
}


VOID OOM()
{
    Error(szOOM);
}

VOID NYI()
{
    Error(TEXT("Not Yet Implemented"));
}

INT CchString(TCHAR *sz, INT ids, UINT cchBuf)
{
    return LoadString(hinstApp, (WORD)ids, (LPTSTR)sz, cchBuf);
}



BOOL FWriteIniString(INT idsTopic, INT idsItem, TCHAR *szValue)
{
    TCHAR szItem[32];
    HKEY  hKey;          // key to our registry root
    LONG  lStatus;       // status from RegCreateKey
    INT   iLen;
    BOOL  fRet = FALSE;

    // create the key
    lStatus = RegCreateKeyEx(HKEY_CURRENT_USER, SOLKEYNAME, 0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL);
    if(lStatus != ERROR_SUCCESS)
    {
        return FALSE;         // just return quietly
    }

    CchString(szItem, idsItem, ARRAYSIZE(szItem));
    iLen = (lstrlen(szValue)+1) * sizeof(TCHAR);

    // write the key and value to the registry
    if (RegSetValueEx(hKey, szItem, 0, REG_SZ, (BYTE*)szValue, iLen) == ERROR_SUCCESS)    
        fRet = TRUE;
    else
        fRet = FALSE;

    RegCloseKey(hKey);
    return fRet;
}

BOOL FWriteIniInt(INT idsTopic, INT idsItem, DWORD w)
{
    TCHAR szItem[32];
    HKEY  hKey;          // key to our registry root
    LONG  lStatus;       // status from RegCreateKey
    BOOL  fRet = FALSE;

    // create the key
    lStatus = RegCreateKeyEx(HKEY_CURRENT_USER, SOLKEYNAME, 0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL);
    if(lStatus != ERROR_SUCCESS)
    {
        return FALSE;         // just return quietly
    }

    CchString(szItem, idsItem, ARRAYSIZE(szItem));

    // write the key and value to the registry
    if (RegSetValueEx(hKey, szItem, 0, REG_DWORD, (BYTE*) &w, sizeof(DWORD)) == ERROR_SUCCESS)
       fRet = TRUE;
    else
        fRet = FALSE;

    RegCloseKey(hKey);
    return fRet;

}


BOOL FGetIniString(INT idsTopic, INT idsItem, TCHAR *sz, TCHAR *szDefault, INT cchMax)
{
    TCHAR szItem[32];
    HKEY  hKey;          // key to our registry root
    LONG  lStatus;
    DWORD dwType;

    // open the key 
    lStatus = RegCreateKeyEx(HKEY_CURRENT_USER, SOLKEYNAME, 0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL);
    if(lStatus != ERROR_SUCCESS)
    {
        CopyMemory(sz, szDefault, min(cchMax, lstrlen(szDefault)+1));
        return TRUE;
    }

    CchString(szItem, idsItem, ARRAYSIZE(szItem));

    if(hKey)
    {
        lStatus= RegQueryValueEx(hKey, szItem, NULL, &dwType, (BYTE*) szDefault, &cchMax);
        RegCloseKey(hKey);

        if(lStatus != ERROR_SUCCESS || dwType != REG_SZ)
        {
            CopyMemory(sz, szDefault, min(cchMax, lstrlen(szDefault)+1));
        }
    }

    return TRUE;
}


DWORD GetIniInt(INT idsTopic, INT idsItem, DWORD wDefault)
{
    TCHAR szItem[32];
    HKEY  hKey;          // key to our registry root
    LONG  lStatus;
    DWORD dwResult = wDefault;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = 0;

    lStatus = RegCreateKeyEx(HKEY_CURRENT_USER, SOLKEYNAME, 0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL);
    if(lStatus != ERROR_SUCCESS)
    {
        return wDefault;
    }

    CchString(szItem, idsItem, ARRAYSIZE(szItem));

    if(hKey)
    {
        lStatus = RegQueryValueEx(hKey, szItem, NULL, &dwType, (BYTE*) &dwResult, &dwSize);
        RegCloseKey(hKey);

        if(lStatus != ERROR_SUCCESS || dwType != REG_DWORD)
        {
            dwResult = wDefault;
        }
    }

    return(dwResult);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\debug\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991-1994, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//              30-Sep-93   KyleP       DEVL obsolete
//               7-Oct-94   BruceFo     Ripped out all kernel, non-FLAT,
//                                      DLL-specific, non-Win32 functionality.
//                                      Now it's basically "print to the
//                                      debugger" code.
//
//----------------------------------------------------------------------------

#if DBG == 1

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"
#include <strsafe.h>

#ifndef ARRAYLEN
#define ARRAYLEN(a) (sizeof(a) / sizeof((a)[0]))
#endif

//////////////////////////////////////////////////////////////////////////////

unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;

//////////////////////////////////////////////////////////////////////////////

static int _cdecl w4dprintf(const char *format, ...);
static int _cdecl w4vdprintf(const char *format, va_list arglist);

//////////////////////////////////////////////////////////////////////////////

static CRITICAL_SECTION s_csMessageBuf;
static char g_szMessageBuf[500];		// this is the message buffer

static int _cdecl w4dprintf(const char *format, ...)
{
	int ret;

    va_list va;
    va_start(va, format);
	ret = w4vdprintf(format, va);
    va_end(va);

	return ret;
}


static int _cdecl w4vdprintf(const char *format, va_list arglist)
{
	int ret = 0;

	EnterCriticalSection(&s_csMessageBuf);
	if (SUCCEEDED(StringCchPrintfA(g_szMessageBuf, ARRAYLEN(g_szMessageBuf), format, arglist)))
	{
	    ret = lstrlenA(g_szMessageBuf);
	}
	OutputDebugStringA(g_szMessageBuf);
	LeaveCriticalSection(&s_csMessageBuf);
	return ret;
}

//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl
_asdprintf(
    char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   Win4AssertEx, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//----------------------------------------------------------------------------

EXPORTIMP void APINOT
Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
    if (Win4AssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

		_asdprintf("%s File: %s Line: %u, thread id %d\n",
            szMessage, szFile, iLine, tid);
    }

    if (Win4AssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (Win4AssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}


//+------------------------------------------------------------
// Function:    SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4InfoLevel;
    Win4InfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoMask(
    unsigned long ulNewMask)
{
    unsigned long ul;

    ul = Win4InfoMask;
    Win4InfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    SetWin4AssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4AssertLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4AssertLevel;
    Win4AssertLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

EXPORTIMP int APINOT
PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile)
{
    int id;
    static char szAssertCaption[128];
    static char szModuleName[128];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char * pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    StringCchPrintfA(szAssertCaption, ARRAYLEN(szAssertCaption), "Process: %s File: %s line %u, thread id %d.%d",
        pszModuleName, szFile, iLine, pid, tid);

    id = MessageBoxA(NULL,
                     szMsg,
                     szAssertCaption,
                     MB_SETFOREGROUND
						| MB_DEFAULT_DESKTOP_ONLY
						| MB_TASKMODAL
						| MB_ICONEXCLAMATION
						| MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (0 == id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBoxA(NULL,
                             szMsg,
                             szAssertCaption,
                             MB_SETFOREGROUND
								| MB_SERVICE_NOTIFICATION
								| MB_TASKMODAL
								| MB_ICONEXCLAMATION
								| MB_OKCANCEL);
        }
    }

    return id;
}


//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

static CRITICAL_SECTION s_csDebugPrint;

EXPORTIMP void APINOT
vdprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
		EnterCriticalSection(&s_csDebugPrint);

        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((Win4InfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4dprintf("%d.%03d> %s: ", pid, tid, pszComp);
            }
            w4vdprintf(ppszfmt, pargs);
        }

        if (Win4InfoLevel & DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                printf("%d.%03d> %s: ", pid, tid, pszComp);
            }
            vprintf(ppszfmt, pargs);
        }

		LeaveCriticalSection(&s_csDebugPrint);
    }
}

void APINOT InitializeDebugging(void)
{
	InitializeCriticalSection(&s_csMessageBuf);
	InitializeCriticalSection(&s_csDebugPrint);
}

void APINOT UninitializeDebugging(void)
{
    DeleteCriticalSection(&s_csMessageBuf);
    DeleteCriticalSection(&s_csDebugPrint);
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\inc\uconvert.h ===
/***************************************************************
*
*  UCONVERT - Unicode File conversion
*
*
*  Author: Asmus Freytag
*
*  Copyright (C) 1991, Microsoft Corporation
*-----------------------------------------------------
* header file for Uconvert */

#ifdef UNICODE

#define BUFFER_TOO_SMALL                0x0005

#define ISUNICODE_ASCII16               0x0001
#define ISUNICODE_REVERSE_ASCII16       0x0010
#define ISUNICODE_STATISTICS            0x0002
#define ISUNICODE_REVERSE_STATISTICS    0x0020
#define ISUNICODE_CONTROLS              0x0004
#define ISUNICODE_REVERSE_CONTROLS      0x0040

#define ISUNICODE_SIGNATURE             0x0008
#define ISUNICODE_REVERSE_SIGNATURE     0x0080

#define ISUNICODE_ILLEGAL_CHARS         0x0100
#define ISUNICODE_ODD_LENGTH            0x0200

#define ISUNICODE_NULL_BYTES            0x1000

#define ISUNICODE_UNICODE_MASK          0x000F
#define ISUNICODE_REVERSE_MASK          0x00F0
#define ISUNICODE_NOT_UNICODE_MASK      0x0F00
#define ISUNICODE_NOT_ASCII_MASK        0xF000

#define UNICODE_FFFF              0xFFFF
#define REVERSE_BYTE_ORDER_MARK   0xFFFE
#define BYTE_ORDER_MARK           0xFEFF

#define PARAGRAPH_SEPARATOR       0x2029
#define LINE_SEPARATOR            0x2028


#define UNICODE_TAB               0x0009
#define UNICODE_LF                0x000A
#define UNICODE_CR                0x000D
#define UNICODE_SPACE             0x0020
#define UNICODE_CJK_SPACE         0x3000

#define UNICODE_R_TAB             0x0900
#define UNICODE_R_LF              0x0A00
#define UNICODE_R_CR              0x0D00
#define UNICODE_R_SPACE           0x2000
#define UNICODE_R_CJK_SPACE       0x0030  /* Ambiguous - same as ASCII '0' */

#define ASCII_CRLF                0x0A0D


BOOL IsUnicode  (LPTSTR lpBuff, int iSize, LPINT lpiResult);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\debug\debug.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       debug.h
//
//  Contents:   Debugging macros. Stolen from old Cairo debnot.h with the
//				following history...
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              22-Oct-91   SatoNa      Added SHLSTRICT
//              29-Apr-92   BartoszM    Moved from win4p.h
//               3-Jun-92   BruceFo     Added SMUISTRICT
//              17-Dec-92   AlexT       Moved UN..._PARM out of DEVL==1
//              30-Sep-93   KyleP       DEVL obsolete
//              18-Jun-94   AlexT       Make Assert a better statement
//				 7-Oct-94   BruceFo		Stole and ripped out everything except
//                                      debug prints and asserts.
//
//
//  NOTE: you must call the InitializeDebugging() API before calling any other
//  APIs!
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

#include <stdarg.h>

//----------------------------------------------------------------------------
//  Parameter Macros
//
//  To avoid compiler warnings for unimplemented functions, use
//  UNIMPLEMENTED_PARM(x) for each unreferenced parameter.  This will
//  later be defined to nul to reveal functions that we forgot to implement.
//
//  For functions which will never use a parameter, use
//  UNREFERENCED_PARM(x).
//

#define UNIMPLEMENTED_PARM(x)   (x)

#define UNREFERENCED_PARM(x)    (x)


#if DBG == 1

//
// DEBUG -- DEBUG -- DEBUG -- DEBUG -- DEBUG
//

//
// Debug print functions.
//

#ifdef __cplusplus
extern "C" {
# define EXTRNC "C"
#else
# define EXTRNC
#endif

#ifndef EXPORTDEF
 #define EXPORTDEF
#endif
#ifndef EXPORTIMP
 #define EXPORTIMP
#endif
#ifndef EXPORTED
 #define EXPORTED  _cdecl
#endif
#ifndef APINOT
#ifdef _X86_
 #define APINOT    _stdcall
#else
 #define APINOT    _cdecl
#endif
#endif


// vdprintf should only be called from xxDebugOut()

   EXPORTDEF void          APINOT
   vdprintf(
       unsigned long ulCompMask,
       char const *pszComp,
       char const *ppszfmt,
       va_list  ArgList);

   EXPORTDEF void          APINOT
   Win4AssertEx(
       char const *pszFile,
       int iLine,
       char const *pszMsg);

   EXPORTDEF int           APINOT
   PopUpError(
       char const *pszMsg,
       int iLine,
       char const *pszFile);

   EXPORTDEF unsigned long APINOT
   SetWin4InfoLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4InfoMask(
       unsigned long ulNewMask);

   EXPORTDEF unsigned long APINOT
   SetWin4AssertLevel(
       unsigned long ulNewLevel);

   EXPORTDEF void APINOT
   InitializeDebugging(
	   void);

   EXPORTDEF void APINOT
   UninitializeDebugging(
	   void);

#ifdef __cplusplus
}
#endif // __cplusplus

# define Win4Assert(x)  \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))

# define Win4Verify(x) Win4Assert(x)


//
// Debug print macros
//

# define DEB_ERROR               0x00000001      // exported error paths
# define DEB_WARN                0x00000002      // exported warnings
# define DEB_TRACE               0x00000004      // exported trace messages

# define DEB_DBGOUT              0x00000010      // Output to debugger
# define DEB_STDOUT              0x00000020      // Output to stdout

# define DEB_IERROR              0x00000100      // internal error paths
# define DEB_IWARN               0x00000200      // internal warnings
# define DEB_ITRACE              0x00000400      // internal trace messages

# define DEB_USER1               0x00010000      // User defined
# define DEB_USER2               0x00020000      // User defined
# define DEB_USER3               0x00040000      // User defined
# define DEB_USER4               0x00080000      // User defined
# define DEB_USER5               0x00100000      // User defined
# define DEB_USER6               0x00200000      // User defined
# define DEB_USER7               0x00400000      // User defined
# define DEB_USER8               0x00800000      // User defined
# define DEB_USER9               0x01000000      // User defined
# define DEB_USER10              0x02000000      // User defined
# define DEB_USER11              0x04000000      // User defined
# define DEB_USER12              0x08000000      // User defined
# define DEB_USER13              0x10000000      // User defined
# define DEB_USER14              0x20000000      // User defined
# define DEB_USER15              0x40000000      // User defined

# define DEB_NOCOMPNAME          0x80000000      // suppress component name

# define DEB_FORCE               0x7fffffff      // force message

# define ASSRT_MESSAGE           0x00000001      // Output a message
# define ASSRT_BREAK             0x00000002      // Int 3 on assertion
# define ASSRT_POPUP             0x00000004      // And popup message


//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------

# ifndef DEF_INFOLEVEL
#  define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
# endif


# define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = DEF_INFOLEVEL;\
        extern EXTRNC char* comp##InfoLevelString = #comp;


# ifdef __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }     \
    \
    class comp##CDbgTrace\
    {\
    private:\
        unsigned long _ulFlags;\
        char const * const _pszName;\
    public:\
        comp##CDbgTrace(unsigned long ulFlags, char const * const pszName);\
        ~comp##CDbgTrace();\
    };\
    \
    inline comp##CDbgTrace::comp##CDbgTrace(\
            unsigned long ulFlags,\
            char const * const pszName)\
    : _ulFlags(ulFlags), _pszName(pszName)\
    {\
        comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
    }\
    \
    inline comp##CDbgTrace::~comp##CDbgTrace()\
    {\
        comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
    }

# else  // ! __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }

# endif // ! __cplusplus

#else  // DBG == 0

//
// NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG
//

# define Win4Assert(x)  NULL
# define Win4Verify(x)  (x)

# define DECLARE_DEBUG(comp)
# define DECLARE_INFOLEVEL(comp)

#endif // DBG == 0

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\inc\uniconv.h ===
/****************************************************************************/
/*                                                                          */
/*  UNICONV.H -                                                             */
/*                                                                          */
/*       My special Unicode workaround file                                 */
/*                                                                          */
/*       Created by      :       Diane K. Oh                                */
/*       On Date         :       June 11, 1992                              */
/*                                                                          */
/*       File was created to Unicode enable special function calls of       */
/*       WIN32 Shell applications.                                          */
/*                                                                          */
/****************************************************************************/

#include <string.h>
#include <tchar.h>
#ifdef UNICODE
#include <wchar.h>
#else
#include <ctype.h>
#endif


/*--------------------------------------------------------------------------*/
/*  Macros                                                                  */
/*--------------------------------------------------------------------------*/

#define CharSizeOf(x)   (sizeof(x) / sizeof(*x))
#define ByteCountOf(x)  ((x) * sizeof(TCHAR))

/*--------------------------------------------------------------------------*/
/*  Constants                                                               */
/*--------------------------------------------------------------------------*/

#define   UNICODE_FONT_NAME        TEXT("Lucida Sans Unicode")
#define   UNICODE_FIXED_FONT_NAME  TEXT("Lucida Console")

/*--------------------------------------------------------------------------*/
/*  Function Templates                                                      */
/*--------------------------------------------------------------------------*/

INT      MyAtoi          (LPTSTR string);
LONG     MyAtol          (LPTSTR  string);
LPTSTR   MyItoa          (INT value, LPTSTR string, INT radix);
LPTSTR   MyUltoa         (unsigned long value, LPTSTR string, INT radix);
VOID     MySplitpath     (LPTSTR path, LPTSTR drive, LPTSTR dir,
                          LPTSTR fname, LPTSTR ext);

LPTSTR   SkipProgramName (LPTSTR lpCmdLine);


HANDLE   MyOpenFile      (LPTSTR lpszFile, TCHAR * lpszPath, DWORD fuMode);
BOOL     MyCloseFile     (HANDLE hFile);
BOOL     MyAnsiReadFile  (HANDLE hFile, UINT uCodePage, LPVOID lpBuffer, DWORD nChars);
BOOL     MyByteReadFile  (HANDLE hFile, LPVOID lpBuffer, DWORD nBytes);
BOOL     MyAnsiWriteFile (HANDLE hFile, UINT uCodePage, LPVOID lpBuffer, DWORD nChars);
BOOL     MyByteWriteFile (HANDLE hFile, LPVOID lpBuffer, DWORD nBytes);
LONG     MyFileSeek      (HANDLE hFile, LONG lDistanceToMove, DWORD dwMoveMethod);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\netobjs\dllmain.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       dllmain.cxx
//
//  Contents:   DLL initialization entrypoint and global variables
//
//  History:    4-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//--------------------------------------------------------------------------
// Globals used elsewhere

UINT        g_NonOLEDLLRefs = 0;
HINSTANCE   g_hInstance = NULL;

//--------------------------------------------------------------------------
// Debugging

DECLARE_INFOLEVEL(NetObjectsUI)

//--------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Win32 DLL initialization function
//
//  Arguments:  [hInstance] - Handle to this dll
//              [dwReason]  - Reason this function was called.  Can be
//                            Process/Thread Attach/Detach.
//
//  Returns:    BOOL    - TRUE if no error.  FALSE otherwise
//
//  History:    4-Apr-95 BruceFo  Created
//
//---------------------------------------------------------------------------

extern "C"
BOOL
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
    {
#if DBG == 1
        InitializeDebugging();
//         NetObjectsUIInfoLevel = DEB_ERROR | DEB_TRACE;
        NetObjectsUIInfoLevel = DEB_ERROR;
        SetWin4AssertLevel(ASSRT_BREAK | ASSRT_MESSAGE);
#endif // DBG == 1

        appDebugOut((DEB_TRACE, "ntlanui2.dll: DllMain enter\n"));

        // Disable thread notification from OS
        DisableThreadLibraryCalls(hInstance);
        g_hInstance = hInstance;
        InitCommonControls();
        break;
    }

    case DLL_PROCESS_DETACH:
        appDebugOut((DEB_TRACE, "ntlanui2.dll: DllMain leave\n"));
#if DBG == 1
        UninitializeDebugging();
#endif // DBG == 1
        break;
    }

    return TRUE;
}

extern HRESULT PropDummyFunction();
HRESULT Linkage()
{
    return PropDummyFunction();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\netobjs\ext.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ext.cxx
//
//  Contents:   Shell extension handler for network objects
//
//  Classes:    CNetObj
//
//  History:    26-Sep-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <pages.hxx>

#define DONT_WANT_SHELLDEBUG
#include <shlobjp.h>

#include "resource.h"
#include "ext.hxx"
#include "util.hxx"

//--------------------------------------------------------------------------
//
// Shell DLL communication
//

typedef
UINT
(WINAPI *SHELLGETNETRESOURCE)(
    HNRES hnres,
    UINT iItem,
    LPNETRESOURCE pnresOut,
    UINT cbMax
    );

HINSTANCE g_hShellLibrary = NULL;
SHELLGETNETRESOURCE g_pFuncGNR = NULL;
UINT g_cfNetResource = 0;

BOOL LoadShellDllEntries(VOID);

//--------------------------------------------------------------------------


/*
 * Helper functions used to communicate with shell32.dll
 */

BOOL LoadShellDllEntries(VOID)
{
    if (g_hShellLibrary)
    {
        return TRUE;
    }

    g_hShellLibrary = LoadLibrary(TEXT("shell32.dll"));
    if (NULL == g_hShellLibrary)
    {
        return FALSE;
    }

    g_pFuncGNR = (SHELLGETNETRESOURCE)GetProcAddress(g_hShellLibrary, (LPSTR)IntToPtr(SHGetNetResourceORD));
    if (NULL == g_pFuncGNR)
    {
        return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CNetObj::CNetObj
//
//  Synopsis:   Constructor
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

CNetObj::CNetObj(
    VOID
    )
    :
    _uRefs(0),
    _pDataObject(NULL),
    _hkeyProgID(NULL)
{
    INIT_SIG(CNetObj);

    AddRef(); // give it the correct initial reference count. add to the DLL reference count
}


//+-------------------------------------------------------------------------
//
//  Member:     CNetObj::~CNetObj
//
//  Synopsis:   Destructor
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

CNetObj::~CNetObj()
{
    CHECK_SIG(CNetObj);

    if (_pDataObject)
    {
        _pDataObject->Release();
    }

    if (_hkeyProgID)
    {
        LONG l = RegCloseKey(_hkeyProgID);
        if (l != ERROR_SUCCESS)
        {
            appDebugOut((DEB_ERROR, "CNetObj::destructor. Error closing registry key, 0x%08lx\n", l));
        }
        _hkeyProgID = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CNetObj::Initialize
//
//  Derivation: IShellExtInit
//
//  Synopsis:   Initialize the shell extension. Stashes away the argument data.
//
//  History:    4-Apr-95    BruceFo  Created
//
//  Notes:      This method can be called more than once.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CNetObj::Initialize(
    LPCITEMIDLIST   pidlFolder,
    LPDATAOBJECT    pDataObject,
    HKEY            hkeyProgID
    )
{
    CHECK_SIG(CNetObj);

    CNetObj::~CNetObj();

    if (!LoadShellDllEntries())
    {
        return E_FAIL;
    }

    // Duplicate the pDataObject pointer
    _pDataObject = pDataObject;
    if (pDataObject)
    {
        pDataObject->AddRef();
    }

    // Duplicate the handle
    if (hkeyProgID)
    {
        LONG l = RegOpenKeyEx(hkeyProgID, NULL, 0L, MAXIMUM_ALLOWED, &_hkeyProgID);
        if (l != ERROR_SUCCESS)
        {
            appDebugOut((DEB_ERROR, "CNetObj::Initialize. Error duplicating registry key, 0x%08lx\n", l));
        }
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CNetObj::AddPages
//
//  Derivation: IShellPropSheetExt
//
//  Synopsis:   (from shlobj.h)
//              "The explorer calls this member function when it finds a
//              registered property sheet extension for a particular type
//              of object. For each additional page, the extension creates
//              a page object by calling CreatePropertySheetPage API and
//              calls lpfnAddPage.
//
//  Arguments:  lpfnAddPage -- Specifies the callback function.
//              lParam -- Specifies the opaque handle to be passed to the
//                        callback function.
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

STDMETHODIMP
CNetObj::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM               lParam
    )
{
    CHECK_SIG(CNetObj);

    //
    // Call IDataObject::GetData asking for a g_cfNetResource (i.e., HNRES).
    //
    STGMEDIUM medium;
    FORMATETC fmte =
    {
        g_cfNetResource
            ? g_cfNetResource
            : (g_cfNetResource = RegisterClipboardFormat(CFSTR_NETRESOURCES)),
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };
    appAssert(NULL != _pDataObject);
    HRESULT hr = _pDataObject->GetData(&fmte, &medium);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
    {
        return hr;
    }

    ///////////////// Now I have a 'medium' to release

    hr = S_OK;

    HNRES hnres = medium.hGlobal;

    // Get number of selected items
    if (NULL != g_pFuncGNR)
    {
        UINT cItems = (*g_pFuncGNR)(hnres, (UINT)-1, NULL, 0);
        if (cItems > 0)
        {
            // Retrieve NETRESOURCE object from clipboard
            LPNETRESOURCE pNetRes = (LPNETRESOURCE)_bufNetResource;
            UINT ret = (*g_pFuncGNR)(hnres, 0, pNetRes, MAX_ONE_RESOURCE); // Get first item
            if (ret == 0)
            {
                // bad hnres?
                appDebugOut((DEB_TRACE, "CNetObj::AddPages. SHGetNetResource returned 0\n"));
                // NOTE: this is really error
            }
            else if (ret > MAX_ONE_RESOURCE)
            {
                // FEATURE: Resize the buf and try again
                appDebugOut((DEB_TRACE, "CNetObj::AddPages. buffer too small, needs to be %d\n", ret));
            }
            else
            {
                LPTSTR pszTemplate = NULL;

                if (RESOURCEDISPLAYTYPE_NETWORK == pNetRes->dwDisplayType)
                {
                    pszTemplate = MAKEINTRESOURCE(IDD_NETWORK_SUMMARYINFO);
                }
                else if (RESOURCEDISPLAYTYPE_DOMAIN == pNetRes->dwDisplayType)
                {
                    pszTemplate = MAKEINTRESOURCE(IDD_WRKGRP_SUMMARYINFO);
                }
                else if (RESOURCEDISPLAYTYPE_SERVER == pNetRes->dwDisplayType)
                {
                    pszTemplate = MAKEINTRESOURCE(IDD_SERVER_SUMMARYINFO);
                }
                else if (RESOURCEDISPLAYTYPE_SHARE == pNetRes->dwDisplayType)
                {
                    pszTemplate = MAKEINTRESOURCE(IDD_SHARE_SUMMARYINFO);
                }
                else
                {
                    appDebugOut((DEB_TRACE, "CNetObj::AddPages. Unknown net resource type!\n"));
                }

                //
                //  Create a property sheet page object from a dialog box.
                //

                if (NULL != pszTemplate)
                {
                    FillAndAddPage(
                            lpfnAddPage,
                            lParam,
                            CPage::DlgProcPage,
                            pszTemplate);
                }
            }
        }
        else
        {
            appDebugOut((DEB_TRACE, "CNetObj::AddPages. NO net resources!\n"));
            // NOTE: this is really error
        }
    }
    else
    {
        appDebugOut((DEB_TRACE, "CNetObj::AddPages. No SHGetNetResource function!\n"));
        // NOTE: this is really error
    }

    ReleaseStgMedium(&medium);
    return hr;
}

BOOL
CNetObj::FillAndAddPage(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam,
    DLGPROC pfnDlg,
    LPTSTR pszTemplate
    )
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    psp.dwSize      = sizeof(psp);  // no extra data.
    psp.dwFlags     = PSP_USEREFPARENT;
    psp.hInstance   = g_hInstance;
    psp.pszTemplate = pszTemplate;
    psp.hIcon       = NULL;
    psp.pszTitle    = NULL;
    psp.pfnDlgProc  = pfnDlg;
    psp.pfnCallback = NULL;
    psp.pcRefParent = &g_NonOLEDLLRefs;

    //
    // We need to backlink ourselves because we are using member variable
    // of this class.
    //
    psp.lParam      = (LPARAM)this;
    this->AddRef();

    hpage = CreatePropertySheetPage(&psp);
    if (NULL != hpage)
    {
        if (!lpfnAddPage(hpage, lParam))
        {
            DestroyPropertySheetPage(hpage);
        }
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CNetObj::ReplacePages
//
//  Derivation: IShellPropSheetExt
//
//  Synopsis:   (From shlobj.h)
//              "The explorer never calls this member of property sheet
//              extensions. The explorer calls this member of control panel
//              extensions, so that they can replace some of default control
//              panel pages (such as a page of mouse control panel)."
//
//  Arguments:  uPageID -- Specifies the page to be replaced.
//              lpfnReplace -- Specifies the callback function.
//              lParam -- Specifies the opaque handle to be passed to the
//                        callback function.
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

STDMETHODIMP
CNetObj::ReplacePage(
    UINT                 uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM               lParam
    )
{
    CHECK_SIG(CNetObj);

    appAssert(!"CNetObj::ReplacePage called, not implemented");
    return E_NOTIMPL;
}


// dummy function to export to get linking to work
HRESULT PropDummyFunction()
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\netobjs\guids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       guids.h
//
//  Contents:   Guids local to this directory
//
//  History:    26-Sep-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#ifndef __GUIDS_H__
#define __GUIDS_H__

DEFINE_GUID(CLSID_CNetObj, 0x59be4990, 0xf85c, 0x11ce, 0xaf, 0xf7, 0x00, 0xaa, 0x00, 0x3c, 0xa9, 0xf6);

#endif // __GUIDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\netobjs\makefile.inc ===
app.rc: $(SDK_INC_PATH)\windows.h \
        $(SDK_INC_PATH)\common.ver \
        $(SDK_INC_PATH)\ntverp.h \
        resource.h \
        $(O)\messages.h \
        $(O)\messages.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\netobjs\helpids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       helpids.h
//
//  Contents:   Help context identifiers
//
//  History:    13-Sep-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#define IDH_NET_NETWORK                    100
#define IDH_NET_SERVER                     101
#define IDH_NET_COMMENT                    102
#define IDH_NET_WORKGROUP_OR_DOMAIN_NAME   103
#define IDH_NET_TYPE                       104
#define IDH_NET_SHARE                      105

#define IDH_NET_WORKGROUP_OR_DOMAIN_NAME_2 IDH_NET_WORKGROUP_OR_DOMAIN_NAME
#define IDH_NET_WRKGRP_TYPE                IDH_NET_NETWORK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\netobjs\ole.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       ole.cxx
//
//  Contents:   Class factory, etc, for all OLE objects
//
//  History:    25-Sep-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <initguid.h>
#include "guids.h"

#include "ole.hxx"
#include "ext.hxx"

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

ULONG g_ulcInstancesNetObj = 0;

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CNetObj::QueryInterface(
    IN REFIID riid,
    OUT LPVOID* ppvObj
    )
{
    appDebugOut((DEB_ITRACE, "CNetObj::QueryInterface..."));

    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IUnknown\n"));
        pUnkTemp = (IUnknown*)(IShellExtInit*) this;    // doesn't matter which
    }
    else
    if (IsEqualIID(IID_IShellExtInit, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IShellExtInit\n"));
        pUnkTemp = (IShellExtInit*) this;
    }
    else
    if (IsEqualIID(IID_IShellPropSheetExt, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IShellPropSheetExt\n"));
        pUnkTemp = (IShellPropSheetExt*) this;
    }
    else
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "unknown interface\n"));
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;

    return hr;
}

STDMETHODIMP_(ULONG)
CNetObj::AddRef(
    VOID
    )
{
    ULONG cInst = InterlockedIncrement((LONG*)&g_ulcInstancesNetObj);
    ULONG cRef = InterlockedIncrement((LONG*)&_uRefs);

    appDebugOut((DEB_ITRACE, "CNetObj::AddRef, local: %d, DLL: %d\n", cRef, cInst));

    return cRef;
}

STDMETHODIMP_(ULONG)
CNetObj::Release(
    VOID
    )
{
    appAssert( 0 != g_ulcInstancesNetObj );
    InterlockedDecrement((LONG*)&g_ulcInstancesNetObj);

    appAssert( 0 != _uRefs );
    ULONG cRef = InterlockedDecrement((LONG*)&_uRefs);

    appDebugOut((DEB_ITRACE,
        "CNetObj::Release, local: %d, DLL: %d\n",
        cRef,
        g_ulcInstancesNetObj));

    if (0 == cRef)
    {
        delete this;
    }

    return cRef;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CNetObjCF::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    appDebugOut((DEB_ITRACE, "CNetObjCF::QueryInterface..."));

    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IUnknown\n"));
        pUnkTemp = (IUnknown*) this;
    }
    else if (IsEqualIID(IID_IClassFactory, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IClassFactory\n"));
        pUnkTemp = (IClassFactory*) this;
    }
    else
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "unknown interface\n"));
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;

    return hr;
}


STDMETHODIMP_(ULONG)
CNetObjCF::AddRef()
{
    ULONG cInst = InterlockedIncrement((LONG*)&g_ulcInstancesNetObj);
    appDebugOut((DEB_ITRACE, "CNetObjCF::AddRef, DLL: %d\n", cInst));
    return cInst;
}

STDMETHODIMP_(ULONG)
CNetObjCF::Release()
{
    appAssert( 0 != g_ulcInstancesNetObj );
    ULONG cRef = InterlockedDecrement((LONG*)&g_ulcInstancesNetObj);

    appDebugOut((DEB_ITRACE,
        "CNetObjCF::Release, DLL: %d\n",
        cRef));

    return cRef;
}

STDMETHODIMP
CNetObjCF::CreateInstance(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj)
{
    appDebugOut((DEB_ITRACE, "CNetObjCF::CreateInstance\n"));

    if (pUnkOuter != NULL)
    {
        // don't support aggregation
        return E_NOTIMPL;
    }

    CNetObj* pNetObj = new CNetObj();
    if (NULL == pNetObj)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pNetObj->QueryInterface(riid, ppvObj);
    pNetObj->Release();

    if (FAILED(hr))
    {
        hr = E_NOINTERFACE; // FEATURE: Whats the error code?
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP
CNetObjCF::LockServer(BOOL fLock)
{
    //
    // FEATURE: Whats supposed to happen here?
    //
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

STDAPI
DllCanUnloadNow(
    VOID
    )
{
    if (0 == g_ulcInstancesNetObj
        && 0 == g_NonOLEDLLRefs
        )
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

CNetObjCF cfNetObj;

STDAPI
DllGetClassObject(
    REFCLSID cid,
    REFIID iid,
    LPVOID* ppvObj
    )
{
    appDebugOut((DEB_TRACE, "DllGetClassObject\n"));

    HRESULT hr = E_NOINTERFACE;

    if (IsEqualCLSID(cid, CLSID_CNetObj))
    {
        hr = cfNetObj.QueryInterface(iid, ppvObj);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\netobjs\pages.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       pages.cxx
//
//  Contents:   property pages for provider, domain/workgroup, server, share
//
//  History:    26-Sep-95        BruceFo     Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "helpids.h"
#include "ext.hxx"
#include "pages.hxx"
#include "util.hxx"

////////////////////////////////////////////////////////////////////////////

//
//  This is the minimum version number necessary to
//  actually display a version number.  If we get a
//  machine with a major version number less that this
//  value, we don't display the version number.
//

#define MIN_DISPLAY_VER  2

////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Method:     CPage::DlgProcPage, static public
//
//  Synopsis:   Dialog Procedure for all CPage
//
//--------------------------------------------------------------------------

INT_PTR CALLBACK
CPage::DlgProcPage(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CPage* pThis = NULL;

    if (msg==WM_INITDIALOG)
    {
        PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
        pThis = new CPage(hwnd, psp->lParam);
        if (NULL != pThis)
        {
            if (FAILED(pThis->InitInstance()))
            {
                delete pThis;
                pThis = NULL;
            }
        }

        SetWindowLongPtr(hwnd,GWLP_USERDATA,(LPARAM)pThis);
    }
    else
    {
        pThis = (CPage*) GetWindowLongPtr(hwnd,GWLP_USERDATA);
    }

    if (pThis != NULL)
    {
        return pThis->_PageProc(hwnd,msg,wParam,lParam);
    }
    else
    {
        return FALSE;
    }
}


//+--------------------------------------------------------------------------
//
//  Method:     CPage::CPage, public
//
//  Synopsis:   Constructor
//
//---------------------------------------------------------------------------

CPage::CPage(
    IN HWND hwndPage,
    IN LPARAM lParam
    )
    :
    _hwndPage(hwndPage),
    _pNetObj( (CNetObj*)lParam )
{
    INIT_SIG(CPage);
}


//+--------------------------------------------------------------------------
//
//  Method:     CPage::~CPage, public
//
//  Synopsis:   Destructor
//
//---------------------------------------------------------------------------

CPage::~CPage()
{
    CHECK_SIG(CPage);
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::InitInstance, public
//
//  Synopsis:   Part II of the constuctor process
//
//  Notes:      We don't want to handle any errors in constuctor, so this
//              method is necessary for the second phase error detection.
//
//--------------------------------------------------------------------------

HRESULT
CPage::InitInstance(
    VOID
    )
{
    CHECK_SIG(CPage);
    appDebugOut((DEB_ITRACE, "CPage::InitInstance\n"));

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::_PageProc, private
//
//  Synopsis:   Dialog Procedure for this object
//
//--------------------------------------------------------------------------

INT_PTR
CPage::_PageProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CHECK_SIG(CPage);

    static DWORD aHelpIds[] =
    {
        IDC_NETWORK,        IDH_NET_NETWORK,
        IDC_NETWORK_ICON,   IDH_NET_NETWORK,
        IDC_SERVER,         IDH_NET_SERVER,
        IDC_SERVER_ICON,    IDH_NET_SERVER,
        IDC_SERVER_TEXT,    IDH_NET_SERVER,
        IDC_COMMENT,        IDH_NET_COMMENT,
        IDC_COMMENT_TEXT,   IDH_NET_COMMENT,
        IDC_WORKGROUP_OR_DOMAIN,   IDH_NET_WORKGROUP_OR_DOMAIN_NAME,
        IDC_WORKGROUP_OR_DOMAIN_NAME,   IDH_NET_WORKGROUP_OR_DOMAIN_NAME,
        IDC_WORKGROUP_OR_DOMAIN_NAME_2_ICON, IDH_NET_WORKGROUP_OR_DOMAIN_NAME_2,
        IDC_WORKGROUP_OR_DOMAIN_NAME_2, IDH_NET_WORKGROUP_OR_DOMAIN_NAME_2,
        IDC_TYPE,           IDH_NET_TYPE,
        IDC_TYPE_TEXT,      IDH_NET_TYPE,
        IDC_SHARE,          IDH_NET_SHARE,
        IDC_SHARE_ICON,     IDH_NET_SHARE,
        IDC_WRKGRP_TYPE,    IDH_NET_WRKGRP_TYPE,
        IDC_WRKGRP_TYPE_TEXT,   IDH_NET_WRKGRP_TYPE,
        0,0
    };

    switch (msg)
    {
    case WM_INITDIALOG:
        return _OnInitDialog(hwnd, (HWND)wParam, lParam);

    case WM_NOTIFY:
        return _OnNotify(hwnd, (int)wParam, (LPNMHDR)lParam);

    case WM_HELP:
    {
        LPHELPINFO lphi = (LPHELPINFO)lParam;

        if (lphi->iContextType == HELPINFO_WINDOW)  // a control
        {
            WCHAR szHelp[50];
            LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
            WinHelp(
                (HWND)lphi->hItemHandle,
                szHelp,
                HELP_WM_HELP,
                (DWORD_PTR)aHelpIds);
        }
        break;
    }

    case WM_CONTEXTMENU:
    {
        WCHAR szHelp[50];
        LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
        WinHelp(
            (HWND)wParam,
            szHelp,
            HELP_CONTEXTMENU,
            (DWORD_PTR)aHelpIds);
        break;
    }

    case WM_DESTROY:
        if (NULL != _pNetObj)
        {
            _pNetObj->Release();
        }
        return TRUE;

    case WM_NCDESTROY:
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)NULL);
        delete this;    // do this LAST!
        return TRUE;

    } // end switch (msg)

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::_OnInitDialog, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CPage::_OnInitDialog(
    IN HWND hwnd,
    IN HWND hwndFocus,
    IN LPARAM lInitParam
    )
{
    CHECK_SIG(CPage);
    appDebugOut((DEB_ITRACE, "_OnInitDialog\n"));

    appAssert(NULL != _pNetObj);
    LPNETRESOURCE pnr = (LPNETRESOURCE)_pNetObj->_bufNetResource;
    appAssert(NULL != pnr);

    if (RESOURCEDISPLAYTYPE_NETWORK == pnr->dwDisplayType)
    {
        return _OnInitNetwork(hwnd, pnr);
    }
    else if (RESOURCEDISPLAYTYPE_DOMAIN == pnr->dwDisplayType)
    {
        return _OnInitDomain(hwnd, pnr);
    }
    else if (RESOURCEDISPLAYTYPE_SERVER == pnr->dwDisplayType)
    {
        return _OnInitServerOrShare(hwnd, pnr, TRUE);
    }
    else if (RESOURCEDISPLAYTYPE_SHARE == pnr->dwDisplayType)
    {
        return _OnInitServerOrShare(hwnd, pnr, FALSE);
    }
    else
    {
        appAssert(!"CNetObj::AddPages. Unknown net resource type!\n");
        return TRUE;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::_OnInitNetwork, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CPage::_OnInitNetwork(
    IN HWND hwnd,
    IN LPNETRESOURCE pnr
    )
{
    CHECK_SIG(CPage);
    appAssert(NULL != pnr);

    SetDlgItemText(hwnd, IDC_NETWORK, pnr->lpProvider);
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::_OnInitDomain, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CPage::_OnInitDomain(
    IN HWND hwnd,
    LPNETRESOURCE pnr
    )
{
    CHECK_SIG(CPage);
    appAssert(NULL != pnr);

    SetDlgItemText(hwnd, IDC_WORKGROUP_OR_DOMAIN_NAME_2, pnr->lpRemoteName);
    SetDlgItemText(hwnd, IDC_WRKGRP_TYPE,              pnr->lpProvider);
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CPage::_OnInitServerOrShare, private
//
//  Synopsis:   WM_INITDIALOG handler for Server and Share objects
//
//--------------------------------------------------------------------------

BOOL
CPage::_OnInitServerOrShare(
    IN HWND hwnd,
    IN LPNETRESOURCE pnr,
    IN BOOL fServer         // TRUE == server, FALSE == share
    )
{
    CHECK_SIG(CPage);
    appAssert(NULL != pnr);

    CWaitCursor wait;

    NET_API_STATUS err;
    LPTSTR pszRealServerName = pnr->lpRemoteName;
    appAssert(NULL != pszRealServerName);

    // Figure out server name without UNC prefix
    if (pszRealServerName[0] == TEXT('\\') && pszRealServerName[1] == TEXT('\\'))
    {
        pszRealServerName += 2;
    }

    if (!fServer)
    {
        // Get share name
        LPTSTR pszShareName = wcschr(pszRealServerName, TEXT('\\'));
        appAssert(NULL != pszShareName);
        *pszShareName++ = TEXT('\0');    // NOTE: NULL-terminating server name
        SetDlgItemText(hwnd, IDC_SHARE, pszShareName);
    }

    SetDlgItemText(hwnd, IDC_SERVER, pszRealServerName);

    // Get server information
    PSERVER_INFO_101 pServerInfo = NULL;
    err = NetServerGetInfo(pnr->lpRemoteName, 101, (LPBYTE*)&pServerInfo);
    if (NERR_Success != err)
    {
        MyErrorDialog(hwnd, MessageFromError(err), pszRealServerName);
        return TRUE;
    }

    // NOTE: I now have a pServerInfo to delete

    appAssert(NULL != pServerInfo);

    if (fServer)
    {
        if (NULL != pServerInfo->sv101_comment)
        {
            SetDlgItemText(hwnd, IDC_COMMENT, pServerInfo->sv101_comment);
        }
    }

    _SetServerType(hwnd, IDC_TYPE, pServerInfo);

    DWORD svtype = pServerInfo->sv101_type; // save type for later use
    NetApiBufferFree(pServerInfo);          // get rid of it so we don't have to worry about it

    UINT idLogonType = IDS_LOGON_WORKGROUP;
    if (svtype & SV_TYPE_NT)
    {
        // It's an NT server. See if it is in a workgroup or a domain.
        LPWSTR pszDomainName;
        BOOL bIsWorkgroupName;
        err = MyNetpGetDomainNameEx(pnr->lpRemoteName, &pszDomainName, &bIsWorkgroupName);
        if (err != NERR_Success)
        {
            MyErrorDialog(hwnd, MessageFromError(err), pszRealServerName);
            return TRUE;
        }
        SetDlgItemText(hwnd, IDC_WORKGROUP_OR_DOMAIN_NAME, pszDomainName);
        NetApiBufferFree(pszDomainName);

        if (!bIsWorkgroupName)
        {
            idLogonType = IDS_LOGON_DOMAIN;
        }
    }
    else
    {
        // It's not an NT server, so assume it's a workgroup.
        PWKSTA_INFO_100 pWorkstationInfo = NULL;
        err = NetWkstaGetInfo(pnr->lpRemoteName, 100, (LPBYTE*)&pWorkstationInfo);
        if (NERR_Success != err)
        {
            MyErrorDialog(hwnd, MessageFromError(err), pszRealServerName);
            return TRUE;
        }

        appAssert(NULL != pWorkstationInfo);

        if (NULL != pWorkstationInfo->wki100_langroup)
        {
            SetDlgItemText(hwnd, IDC_WORKGROUP_OR_DOMAIN_NAME, pWorkstationInfo->wki100_langroup);
        }
        NetApiBufferFree(pWorkstationInfo);
    }

    WCHAR szLogonType[80];
    LoadString(g_hInstance, idLogonType, szLogonType, ARRAYLEN(szLogonType));
    SetDlgItemText(hwnd, IDC_WORKGROUP_OR_DOMAIN, szLogonType);

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::_OnNotify, private
//
//  Synopsis:   WM_NOTIFY handler
//
//--------------------------------------------------------------------------

BOOL
CPage::_OnNotify(
    IN HWND hwnd,
    IN int idCtrl,
    IN LPNMHDR phdr
    )
{
    CHECK_SIG(CPage);

    switch (phdr->code)
    {
    case PSN_APPLY:
    case PSN_RESET:         // cancel
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, FALSE); // go away
        return TRUE;

    case PSN_KILLACTIVE:    // change to another page
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
        return FALSE;

    case PSN_SETACTIVE:
    case PSN_QUERYCANCEL:
        return FALSE;

    } // end switch (phdr->code)

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPage::_SetServerType, private
//
//  Synopsis:   Sets a server type control
//
//--------------------------------------------------------------------------

VOID
CPage::_SetServerType(
    HWND hwnd,
    int idControl,
    PSERVER_INFO_101 pinfo
    )
{
    //
    //  Determine the server's type (NT, LM, etc) and role.
    //

    DWORD type = pinfo->sv101_type;

    UINT verMajor = pinfo->sv101_version_major & MAJOR_VERSION_MASK;
    UINT verMinor = pinfo->sv101_version_minor;

    UINT idType = IDS_SERVER_TYPE_LANMAN;
    if (type & SV_TYPE_NT)
    {
        if (verMajor <= 4)
            idType = IDS_SERVER_TYPE_WINNT;
        else if (verMajor == 5 && verMinor == 0)
            idType = IDS_SERVER_TYPE_WIN2K;
        else
            idType = IDS_SERVER_TYPE_POSTWIN2K;
    }
    else
    if (type & SV_TYPE_WINDOWS)
    {
        idType = IDS_SERVER_TYPE_WINDOWS95;
    }
    else
    if (type & SV_TYPE_WFW)
    {
        idType = IDS_SERVER_TYPE_WFW;
    }

    UINT idRole = IDS_ROLE_PROFESSIONAL;
    if (type & SV_TYPE_DOMAIN_CTRL)
    {
        idRole = IDS_ROLE_PRIMARY;
    }
    else
    if (type & SV_TYPE_DOMAIN_BAKCTRL)
    {
        idRole = IDS_ROLE_BACKUP;
    }
    else
    if (type & SV_TYPE_SERVER_NT)
    {
        idRole = IDS_ROLE_SERVER;
    }
    else
    if (verMajor <= 4)
    {
        idRole = IDS_ROLE_WKSTA;
    }

    HRESULT msgFormat = MSG_TYPE_FORMAT;
    if (   verMajor < MIN_DISPLAY_VER
        || (type & SV_TYPE_WINDOWS)
        || (verMajor >= 5)
       )
    {
         msgFormat = MSG_TYPE_FORMAT_UNKNOWN;
    }

    WCHAR szType[80];
    LoadString(g_hInstance, idType, szType, ARRAYLEN(szType));

    WCHAR szRole[80];
    LoadString(g_hInstance, idRole, szRole, ARRAYLEN(szRole));

    DWORD_PTR aInserts[4];
    aInserts[0] = (DWORD_PTR)szType;
    aInserts[1] = verMajor;
    aInserts[2] = verMinor;
    aInserts[3] = (DWORD_PTR)szRole;

    WCHAR szBuffer[256];
    DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE
                                | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                             g_hInstance,
                             msgFormat,
                             LANG_USER_DEFAULT,
                             szBuffer,
                             ARRAYLEN(szBuffer),
                             (va_list*)aInserts);
    if (0 == dwReturn)   // couldn't find message
    {
        appDebugOut((DEB_IERROR,
            "FormatMessage failed, 0x%08lx\n",
            GetLastError()));

        szBuffer[0] = TEXT('\0');
    }

    SetDlgItemText(hwnd, idControl, szBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\netobjs\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by app.rc
//
#define IDS_APP_MSG_NOT_FOUND           101
#define IDS_NET_MSG_NOT_FOUND           102
#define IDS_NO_NET_MSG                  103
#define IDS_MSGTITLE                    104
#define IDS_HELPFILENAME                112
#define IDI_SERVER                      113
#define IDI_WORKGROUP                   114
#define IDI_SHARE                       115
#define IDD_NETWORK_SUMMARYINFO         116
#define IDI_NETWORK                     117
#define IDS_ROLE_PRIMARY                118
#define IDS_ROLE_BACKUP                 119
#define IDS_ROLE_WKSTA                  120
#define IDS_ROLE_SERVER                 122
#define IDC_WORKGROUP_OR_DOMAIN         123
#define IDC_WORKGROUP_OR_DOMAIN_NAME    124
#define IDS_SERVER_TYPE_WINNT           125
#define IDS_SERVER_TYPE_LANMAN          126
#define IDS_SERVER_TYPE_WFW             127
#define IDS_SERVER_TYPE_WINDOWS95       128
#define IDS_LOGON_DOMAIN                129
#define IDS_LOGON_WORKGROUP             130
#define IDC_WORKGROUP_OR_DOMAIN_NAME_2  131
#define IDS_ROLE_PROFESSIONAL           132
#define IDS_SERVER_TYPE_WIN2K           133
#define IDS_SERVER_TYPE_POSTWIN2K       134
#define IDD_SERVER_SUMMARYINFO          1017
#define IDC_COMMENT                     1019
#define IDD_SHARE_SUMMARYINFO           1026
#define IDC_SHARE                       1027
#define IDC_SERVER                      1028
#define IDC_TYPE                        1029
#define IDC_WRKGRP_TYPE                 1030
#define IDD_WRKGRP_SUMMARYINFO          1031
#define IDC_NETWORK                     1034
#define IDC_NETWORK_ICON                1035
#define IDC_SERVER_ICON                 1036
#define IDC_COMMENT_TEXT                1037
#define IDC_TYPE_TEXT                   1038
#define IDC_SHARE_ICON                  1039
#define IDC_SERVER_TEXT                 1040
#define IDC_WORKGROUP_OR_DOMAIN_NAME_2_ICON 1041
#define IDC_WRKGRP_TYPE_TEXT            1042

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1043
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\netobjs\util.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       util.cxx
//
//  Contents:   Misc helper functions
//
//  History:    5-Apr-95    BruceFo Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "util.hxx"

#include <strsafe.h>
//////////////////////////////////////////////////////////////////////////////

#define NETMSG_DLL TEXT("netmsg.dll")

//////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Function:   MyFormatMessageText
//
//  Synopsis:   Given a resource IDs, load strings from given instance
//              and format the string into a buffer
//
//  History:    11-Aug-93 WilliamW   Created.
//
//--------------------------------------------------------------------------
VOID
MyFormatMessageText(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    IN va_list * parglist
    )
{
    //
    // get message from system or app msg file.
    //

    DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE,
                             g_hInstance,
                             dwMsgId,
                             LANG_USER_DEFAULT,
                             pszBuffer,
                             dwBufferSize,
                             parglist);

    if (0 == dwReturn)   // couldn't find message
    {
        appDebugOut((DEB_IERROR,
            "FormatMessage failed, 0x%08lx\n",
            GetLastError()));

        WCHAR szText[200];
        LoadString(g_hInstance, IDS_APP_MSG_NOT_FOUND, szText, ARRAYLEN(szText));
        StringCchPrintf(pszBuffer, dwBufferSize, szText, dwMsgId);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   MyCommonDialog
//
//  Synopsis:   Common popup dialog routine - stole from diskadm directory
//
//--------------------------------------------------------------------------
DWORD
MyCommonDialog(
    IN HWND    hwnd,
    IN HRESULT dwMsgCode,
    IN PWSTR   pszCaption,
    IN DWORD   dwFlags,
    IN va_list arglist
    )
{
    WCHAR szMsgBuf[500];

    MyFormatMessageText(dwMsgCode, szMsgBuf, ARRAYLEN(szMsgBuf), &arglist);
    return MessageBox(hwnd, szMsgBuf, pszCaption, dwFlags);
}



//+-------------------------------------------------------------------------
//
//  Function:   MyErrorDialog
//
//  Synopsis:   This routine retreives a message from the app or system
//              message file and displays it in a message box.
//
//  Note:       Stole from diskadm directory
//
//--------------------------------------------------------------------------
VOID
MyErrorDialog(
    IN HWND hwnd,
    IN HRESULT dwErrorCode,
    ...
    )
{
    WCHAR szCaption[100];
    va_list arglist;

    va_start(arglist, dwErrorCode);

    LoadString(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));
    MyCommonDialog(hwnd, dwErrorCode, szCaption, MB_ICONSTOP | MB_OK, arglist);

    va_end(arglist);
}



//+-------------------------------------------------------------------------
//
//  Function:   MessageFromError
//
//  Synopsis:   MessageFromError returns a message ID which is more or
//              less appropriate to a return code from a remoted
//              NetServerGetInfo.
//
//  History:    26-Sep-95   BruceFo     Stolen from Win95
//
//--------------------------------------------------------------------------

HRESULT
MessageFromError(
    NET_API_STATUS err
    )
{
    switch (err)
    {
        case ERROR_ACCESS_DENIED:
        case ERROR_NETWORK_ACCESS_DENIED:
            return MSG_ACCESSDENIED;
        case ERROR_BAD_NETPATH:
            return MSG_SERVERNOTFOUND;
        default:
            return MSG_CANTREMOTE;
    }

    return 0;
}


//----------------------------------------------------------------------------

CWaitCursor::CWaitCursor(UINT idResCursor)
{
    _hcurWait = _hcurOld = NULL;

    if (0 != idResCursor)
    {
        _hcurWait = LoadCursor(g_hInstance, MAKEINTRESOURCE(idResCursor));
        _hcurOld = SetCursor(_hcurWait);
    }
    else
    {
        _hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    }
}

CWaitCursor::~CWaitCursor()
{
    ::SetCursor( _hcurOld );
    if (_hcurWait)
    {
        ::DestroyCursor( _hcurWait );
    }
}

//----------------------------------------------------------------------------

NET_API_STATUS
MyNetpGetDomainNameEx (
    IN  LPWSTR MachineName,
    OUT LPWSTR* DomainNamePtr, // alloc and set ptr (free with NetApiBufferFree)
    OUT PBOOL IsWorkgroupName
    )

/*++

Routine Description:

    Returns the name of the domain or workgroup this machine belongs to.
    Stolen from netlib and hacked to remote it.

Arguments:

    MachineName - The machine in question

    DomainNamePtr - The name of the domain or workgroup

    IsWorkgroupName - Returns TRUE if the name is a workgroup name.
        Returns FALSE if the name is a domain name.

Return Value:

   NERR_Success - Success.
   NERR_CfgCompNotFound - There was an error determining the domain name

--*/
{
    NET_API_STATUS status;
    NTSTATUS ntstatus;
    LSA_HANDLE PolicyHandle;
    PPOLICY_ACCOUNT_DOMAIN_INFO PrimaryDomainInfo;
    OBJECT_ATTRIBUTES ObjAttributes;
    UNICODE_STRING unicodeMachineName;

    //
    // Check for caller's errors.
    //
    if (DomainNamePtr == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Open a handle to the machine's security policy.  Initialize the
    // objects attributes structure first.
    //
    InitializeObjectAttributes(
        &ObjAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    if (STATUS_NAME_TOO_LONG == RtlInitUnicodeStringEx(&unicodeMachineName, MachineName))
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    ntstatus = LsaOpenPolicy(
                   &unicodeMachineName,
                   &ObjAttributes,
                   POLICY_VIEW_LOCAL_INFORMATION,
                   &PolicyHandle
                   );

    if (! NT_SUCCESS(ntstatus))
    {
        appDebugOut((DEB_ERROR,
            "NetpGetDomainName: LsaOpenPolicy returned 0x%08lx\n",
            ntstatus));
        return NERR_CfgCompNotFound;
    }

    //
    // Get the name of the primary domain from LSA
    //
    ntstatus = LsaQueryInformationPolicy(
                   PolicyHandle,
                   PolicyPrimaryDomainInformation,
                   (PVOID *) &PrimaryDomainInfo
                   );

    if (! NT_SUCCESS(ntstatus))
    {
        appDebugOut((DEB_ERROR,
            "NetpGetDomainName: LsaQueryInformationPolicy failed 0x%08lx\n",
            ntstatus));
        (void) LsaClose(PolicyHandle);
        return NERR_CfgCompNotFound;
    }

    (void) LsaClose(PolicyHandle);

    status = NetApiBufferAllocate(
                      PrimaryDomainInfo->DomainName.Length + sizeof(WCHAR),
                      (LPVOID*)DomainNamePtr);
    if (status != NERR_Success)
    {
        (void) LsaFreeMemory((PVOID) PrimaryDomainInfo);
        return status;
    }

    ZeroMemory(
        *DomainNamePtr,
        PrimaryDomainInfo->DomainName.Length + sizeof(WCHAR)
        );

    CopyMemory(
        *DomainNamePtr,
        PrimaryDomainInfo->DomainName.Buffer,
        PrimaryDomainInfo->DomainName.Length
        );

    *IsWorkgroupName = (PrimaryDomainInfo->DomainSid == NULL);

    (void) LsaFreeMemory((PVOID) PrimaryDomainInfo);

    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\ntshrui\copyhook.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       copyhook.cxx
//
//  Contents:   CShareCopyHook implementation
//
//  History:    21-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "copyhook.hxx"
#include "cache.hxx"
#include "shrinfo.hxx"
#include "util.hxx"


//+-------------------------------------------------------------------------
//
//  Member:     CShareCopyHook::CShareCopyHook
//
//  Synopsis:   Constructor
//
//  History:    21-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

CShareCopyHook::CShareCopyHook(
    VOID
    )
    :
    _uRefs(0)
{
    INIT_SIG(CShareCopyHook);

    AddRef(); // give it the correct initial reference count. add to the DLL reference count
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCopyHook::~CShareCopyHook
//
//  Synopsis:   Destructor
//
//  History:    21-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

CShareCopyHook::~CShareCopyHook()
{
    CHECK_SIG(CShareCopyHook);
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCopyHook::CopyCallback
//
//  Derivation: ICopyHook
//
//  Synopsis:   Called when the shell is copying an object
//
//  History:    21-Apr-95 BruceFo  Created
//
// FEATURE: instead of deleting a share on a directory move, how about
// moving the share?
//
//--------------------------------------------------------------------------

STDMETHODIMP_(UINT)
CShareCopyHook::CopyCallback(
    HWND hwnd,
    UINT wFunc,
    UINT fFlags,
    LPCWSTR pszSrcFile,
    DWORD dwSrcAttribs,
    LPCWSTR pszDestFile,
    DWORD dwDestAttribs
    )
{
    appDebugOut((DEB_TRACE,
        "CShareCopyHook::CopyCallback. %ws -> %ws\n",
        pszSrcFile, pszDestFile));

    UINT idMsg;

    if (!(dwSrcAttribs & FILE_ATTRIBUTE_DIRECTORY))
    {
       return IDYES;  //We're only worried about directories
    }

    if (!g_fSharingEnabled)
    {
        return IDYES;
    }

    switch (wFunc)
    {
        case FO_DELETE:
            idMsg = MSG_RMDIRCONFIRM;
            break;

        case FO_RENAME:
        case FO_MOVE:
            idMsg = MSG_MVDIRCONFIRM;
            break;

        default:
            return IDYES;
    }

    BOOL fChange = FALSE;
    UINT wnErr = IDYES;    /* by default, shell should go ahead and do it */
    CShareInfo* pWarnList = NULL;
    HRESULT hr = g_ShareCache.ConstructParentWarnList(pszSrcFile, &pWarnList);
    if (SUCCEEDED(hr))
    {
        if (NULL != pWarnList)
        {
            for (CShareInfo* p = (CShareInfo*) pWarnList->Next();
                 p != pWarnList;
                 p = (CShareInfo*) p->Next())
            {
                wnErr = WarnDelShare(hwnd, idMsg, p->GetNetname(), p->GetPath());
                if (wnErr != IDYES)
                {
                    // IDYES: obviously, continue
                    break;
                }

                fChange = TRUE;
            }

            // get rid of the temporary list
            DeleteShareInfoList(pWarnList, TRUE);

            if (fChange)
            {
                g_ShareCache.Refresh();
            }
        }
    }
    return wnErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\ntshrui\dlgbase.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dlgbase.cxx
//
//  Contents:   CDialog base class
//
//  History:    19-Oct-94 BruceFo Created.
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "dlgbase.hxx"

//+-------------------------------------------------------------------------
//
//  Method:     CDialog::_WinDlgProc, static private
//
//  Synopsis:   Windows Dialog Procedure
//
//--------------------------------------------------------------------------

INT_PTR CALLBACK
CDialog::_WinDlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CDialog *pPropPage = NULL;

    if (msg==WM_INITDIALOG)
    {
       SetWindowLongPtr(hwnd,GWLP_USERDATA,lParam);
    }

    pPropPage = (CDialog*) GetWindowLongPtr(hwnd,GWLP_USERDATA);

    if (pPropPage != NULL)
    {
        return pPropPage->DlgProc(hwnd,msg,wParam,lParam);
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\ntshrui\cache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       cache.cxx
//
//  Contents:   Functions to manage a cache of shares
//
//  History:    11-Apr-95    BruceFo  Created
//              21-Aug-95    BruceFo  Created CShareCache class to clean up
//                                      resource usage of resources protected
//                                      by critical section.
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "critsec.hxx"
#include "cache.hxx"
#include "dllmain.hxx"
#include "shrinfo.hxx"
#include "strhash.hxx"
#include "util.hxx"

//////////////////////////////////////////////////////////////////////////////

#if DBG == 1
VOID
DumpNetEnum(
    IN LPVOID pBufShares,
    IN ULONG entriesRead
    );
#endif // DBG == 1

//////////////////////////////////////////////////////////////////////////////

CShareCache g_ShareCache;   // the main share cache

//////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::CShareCache
//
//  Synopsis:   Constructor.
//
//  History:    21-Aug-95    BruceFo  Created
//
//--------------------------------------------------------------------------

CShareCache::CShareCache(
    VOID
    )
    :
    m_cShares(0),
    m_pBufShares(NULL),
    m_pHash(NULL)
{
    InitializeCriticalSection(&m_csBuf);
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::~CShareCache
//
//  Synopsis:   Destructor
//
//  History:    21-Aug-95    BruceFo  Created
//
//--------------------------------------------------------------------------

CShareCache::~CShareCache()
{
    Delete();
    DeleteCriticalSection(&m_csBuf);
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::Delete
//
//  Synopsis:   Gets rid of cached memory.
//
//  History:    21-Aug-95    BruceFo  Created
//
//--------------------------------------------------------------------------

VOID
CShareCache::Delete(
    VOID
    )
{
    CTakeCriticalSection t(&m_csBuf);
    if (NULL != m_pBufShares)
    {
        NetApiBufferFree(m_pBufShares);
    }
    m_pBufShares = NULL;
    delete m_pHash;
    m_pHash = NULL;
    m_cShares = 0;
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::IsPathShared
//
//  Synopsis:   See ::IsPathShared.
//
//  History:    21-Aug-95    BruceFo  Created
//
//--------------------------------------------------------------------------

BOOL
CShareCache::IsPathShared(
    LPCTSTR lpPath,
    BOOL fRefresh
    )
{
    BOOL bOldSharingEnabled = g_fSharingEnabled;
    BOOL bRet = FALSE;

    {
        // scope the critical section taking

        CTakeCriticalSection t(&m_csBuf);

        // For plug and play: if the server service starts
        // or stops, we get a refresh call.  If sharing is not currently
        // enabled but a refresh is request, see if sharing has just become
        // available.

        if (fRefresh)
        {
            appDebugOut((DEB_TRACE, "Forced cache refresh!\n"));

            RefreshNoCritSec();
        }

        if (CacheOK())
        {
            appAssert(NULL != m_pHash);
            bRet = m_pHash->IsMember(lpPath);
        }
        else
        {
            // the server doesn't seem to be running...
            bRet = FALSE;
        }
    }

    if (bOldSharingEnabled != g_fSharingEnabled)
    {
        // The server either came up or went down, and we refreshed based on
        // that fact. Force the shell/explorer to redraw *all* views.

        appDebugOut((DEB_TRACE, "Forcing the shell to redraw *all* views!\n"));

        SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);
    }

    return bRet;
}



//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::Refresh
//
//  Synopsis:   Refreshes the cache of shares
//
//  History:    21-Aug-95    BruceFo  Created
//
//  Note:       Sets g_fSharingEnabled
//
//--------------------------------------------------------------------------

VOID
CShareCache::Refresh(
    VOID
    )
{
    CTakeCriticalSection t(&m_csBuf);
    RefreshNoCritSec();
}

// in:
//      pShare		  share to inspect
//      bIncludeHidden -> admin shares (X$, ADMIN$) will not be skipped
//                        otherwise they are included

BOOL ShouldSkipShare(SHARE_INFO_502* pShare, BOOL bIncludeHidden)
{
    // needs to have an associated path
    // needs to be STYPE_DISK (to skip IPC$)
    // STYPE_SPECIAL indicates hidden admin share 
    
    return (pShare->shi502_path == NULL) ||
           (pShare->shi502_path[0] == 0) ||
           ((pShare->shi502_type & ~STYPE_SPECIAL) != STYPE_DISKTREE) ||
           (bIncludeHidden ? FALSE : (pShare->shi502_type & STYPE_SPECIAL));
}



//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::RefreshNoCritSec
//
//  Synopsis:   Refreshes the cache of shares: the critical section must
//              already taken!
//
//  History:    18-Aug-95    BruceFo  Created
//
//  Note:       Sets g_fSharingEnabled
//
//--------------------------------------------------------------------------

VOID
CShareCache::RefreshNoCritSec(
    VOID
    )
{
    Delete();

    DWORD entriesRead, totalEntries;
    DWORD err = ::NetShareEnum(
                        NULL,   // local computer
                        502,
                        &m_pBufShares,
                        0xffffffff,     // no buffer limit; get them all!
                        &entriesRead,
                        &totalEntries,
                        NULL);  // no resume handle 'cause we're getting all
    if (err != NERR_Success)
    {
        appDebugOut((DEB_ERROR,
            "Error enumerating shares: 0x%08lx\n",
            err));

        m_pBufShares = NULL;    // just in case NetShareEnum munged it
        // NTRAID#NTBUG9-585661-2002/03/19 JonN redundant call to Delete()
        Delete();
    }
    else
    {
        // NTRAID#NTBUG9-585715-2002/03/19 JonN It is entirely possible to not read
        //   read all of the shares if there are many of them.  Ideally we should
        //   keep reading (is resume handle supported?), but for now the assertion
        //   can simply be removed.
        appAssert(entriesRead == totalEntries);
        m_cShares = entriesRead;
    }

    // ISSUE-2002/03/19-JonN We consider "no shares" to be the same as
    //   "sharing disabled".  Creating/deleting the first share will
    //   generate SHCNE_ASSOCCHANGED.  The problem is unlikely since
    //   there is usually a $ share.
    if (m_cShares > 0)
    {
        //
        // Now, create a hash table and put all the shares into it (strings are
        // cached; don't copy any data)
        //

        m_pHash = new CStrHashTable(m_cShares * 2 - 1);
        if ((NULL == m_pHash) || FAILED(m_pHash->QueryError()))
        {
            // out of memory; delete everything
            Delete();
        }
        else
        {
            SHARE_INFO_502* pShareBase = (SHARE_INFO_502 *)m_pBufShares;

            for (UINT iShare = 0; iShare < m_cShares; iShare++)
            {
                SHARE_INFO_502* pShare = &pShareBase[iShare];

                if (ShouldSkipShare(pShare, FALSE)) // don't include hidden
                    continue;

                HRESULT hr = m_pHash->Insert(pShare->shi502_path);
                if (FAILED(hr))
                {
                    // out of memory; delete everything
                    Delete();
                    break;
                }
            }
        }

#if DBG == 1
        if (NULL != m_pHash)
        {
            // if everything hasn't been deleted because of a memory problem...
            m_pHash->Print();
        }
#endif // DBG == 1

    }

    g_fSharingEnabled = CacheOK();
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::IsShareNameUsed
//
//  Synopsis:   Returns TRUE if the share name in question is already used
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

BOOL
CShareCache::IsShareNameUsed(
    IN PWSTR pszShareName
    )
{
    CTakeCriticalSection t(&m_csBuf);

    if (!CacheOK())
    {
        return FALSE;
    }

    SHARE_INFO_502* pShareBase = (SHARE_INFO_502 *)m_pBufShares;

    for (UINT iShare = 0; iShare < m_cShares; iShare++)
    {
        SHARE_INFO_502* pShare = &pShareBase[iShare];
        // 585678-2002/03/19 JonN check for NULL
        if ( NULL != pShare->shi502_netname
          && 0 == _wcsicmp(pszShareName, pShare->shi502_netname))
        {
            return TRUE;
        }
    }

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::IsExistingShare
//
//  Synopsis:   Finds out if a share name is already in use with a different
//              path.
//
//  Arguments:  [pszShareName] - name of share being replaced
//              [pszPath] - path to compare against
//              [pszOldPath] - If not null, filled with path of the share,
//                             if found
//
//  Returns:    Returns TRUE if found and the paths are different,
//              FALSE otherwise
//
//  History:    4-May-95   BruceFo     Stolen
//
//  ISSUE-2002/04/12-JonN should combine this function with previous function
//
//--------------------------------------------------------------------------

BOOL
CShareCache::IsExistingShare(
    IN PCWSTR pszShareName,
    IN PCWSTR pszPath,
    OUT PWSTR pszOldPath,
    IN INT cchOldPathBuf // 585682-2002/04/12-JonN
    )
{
    appAssert(NULL != pszShareName);

    CTakeCriticalSection t(&m_csBuf);

    if (!CacheOK())
    {
        return FALSE;
    }

    SHARE_INFO_502* pShareBase = (SHARE_INFO_502 *)m_pBufShares;

    for (UINT iShare = 0; iShare < m_cShares; iShare++)
    {
        SHARE_INFO_502* pShare = &pShareBase[iShare];
        if ( NULL != pShare->shi502_netname
          && 0 == _wcsicmp(pszShareName, pShare->shi502_netname))
        {
            if (pszOldPath != NULL)
            {
                // 585682-2002/03/19 JonN
                wcsncpy(pszOldPath, pShare->shi502_path, cchOldPathBuf);
                pszOldPath[cchOldPathBuf-1] = L'\0';
            }

            return TRUE;
        }
    }

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::ConstructList
//
//  Synopsis:   Construct a list of shares for a particular path
//
//  Arguments:
//
//  Returns:    hresult
//
//  History:    21-Aug-95   BruceFo     Created
//
//--------------------------------------------------------------------------

HRESULT
CShareCache::ConstructList(
    IN PCWSTR          pszPath,
    IN OUT CShareInfo* pShareList,
    OUT ULONG*         pcShares
    )
{
    CTakeCriticalSection t(&m_csBuf);

    SHARE_INFO_502* pShareBase = (SHARE_INFO_502 *)m_pBufShares;

    HRESULT hr;
    ULONG cShares = 0;

    for (UINT iShare = 0; iShare < m_cShares; iShare++)
    {
        SHARE_INFO_502* pShare = &pShareBase[iShare];

        // NTRAID#NTBUG9-585678-2002/03/19 JonN check for NULL
        if (0 == _wcsicmp(pszPath, pShare->shi502_path))
        {
            if (ShouldSkipShare(pShare, TRUE))  // include hidden
                continue;
            //
            // We found one!
            //

            appDebugOut((DEB_ITRACE,
                "ConstructList: adding %ws\n",
                pShare->shi502_netname));

            CShareInfo* pNewInfo = new CShareInfo();
            if (NULL == pNewInfo)
            {
                // ISSUE-2002/04/17-JonN We should delete the partial list
                return E_OUTOFMEMORY;
            }

            hr = pNewInfo->InitInstance();
            if (FAILED(hr))
            {
                // ISSUE-2002/04/17-JonN We should delete the partial list
                delete pNewInfo;
                return hr;
            }

            // We can't point into the data protected by a critical section,
            // so we must copy it.
            hr = pNewInfo->Copy(pShare);
            if (FAILED(hr))
            {
                // ISSUE-2002/04/17-JonN We should delete the partial list
                delete pNewInfo;
                return hr;
            }

            // 585723-2002/03/19 JonN
            // This could happen due to API failure.  This used to cause us
            //   to fail out of the loop.  Instead, we now just fail through
            //   and let the caching display be wrong.
            NET_API_STATUS    ret = pNewInfo->ReadCacheFlags ();
            appAssert( NERR_Success == ret );
            /*
            if ( NERR_Success != ret )
            {
                // ISSUE-2002/04/17-JonN We should delete the partial list
                delete pNewInfo;
                return HRESULT_FROM_WIN32 (ret);
            }
            */

            pNewInfo->InsertBefore(pShareList); // add to end of list

            ++cShares;
        }
    }

    *pcShares = cShares;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::ConstructParentWarnList
//
//  Synopsis:   Construct a new list of shares that are children or descendants
//              of the path passed in.
//
//  Arguments:  [pszPath] - the prefix path to check for
//              [ppShareList] - new share list, if success. Caller must delete
//                  it using 'delete' on each element. This list is
//                  doubly-linked with a dummy head node. NOTE: As an
//                  optimization, this is set to NULL if there is no share.
//                  This avoids allocating and deleting memory unless there
//                  is something to warn the user about.
//
//  Returns:    hresult
//
//  History:    21-Aug-95   BruceFo     Created
//
//--------------------------------------------------------------------------

HRESULT
CShareCache::ConstructParentWarnList(
    IN PCWSTR        pszPath,
    OUT CShareInfo** ppShareList
    )
{
    CTakeCriticalSection t(&m_csBuf);

    HRESULT hr = S_OK;
    CShareInfo* pShareList = NULL;
    SHARE_INFO_502* pShareBase = (SHARE_INFO_502 *)m_pBufShares;
    INT cchPath = wcslen(pszPath);

    for (UINT iShare = 0; iShare < m_cShares; iShare++)
    {
        SHARE_INFO_502* pShare = &pShareBase[iShare];

        PWSTR pszSharePath = pShare->shi502_path;
        INT cchSharePath = wcslen(pszSharePath);

        if (cchSharePath >= cchPath)
        {
            // WARNING - the following won't work with LFN/shortname differences

            // PERF: we're doing a prefix match of the current directory
            // name on the set of share names. This could be expensive with
            // a linear search!

            if (0 == _wcsnicmp(pszSharePath, pszPath, cchPath)
                && (    *(pszSharePath + cchPath) == TEXT('\\')
                     || *(pszSharePath + cchPath) == TEXT('\0')
                   )
               )
            {
                appDebugOut((DEB_TRACE,
                    "ConstructParentWarnList, share %ws, file %ws. Found a prefix!\n",
                    pszSharePath, pszPath));

                if (NULL == pShareList)
                {
                    // do the lazy dummy head node creation if this is the
                    // first prefix match

                    pShareList = new CShareInfo();  // dummy head node
                    if (NULL == pShareList)
                    {
                        return E_OUTOFMEMORY;
                    }
                }

                CShareInfo* pNewInfo = new CShareInfo();
                if (NULL == pNewInfo)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    hr = pNewInfo->InitInstance();
                    if (SUCCEEDED(hr))
                    {
                        // We can't point into the data protected by a
                        // critical section, so we must copy it.
                        hr = pNewInfo->Copy(pShare);
                        if ( SUCCEEDED (hr) )
                        {
                            // NTRAID#NTBUG9-603727-2002/04/15 JonN
                            // There is no point in calling ReadCacheFlags,
                            //   since the caller won't use that field.
                            //   It matters because the API could fail
                            //   and cause ConstructParentWarnList to fail.
                            // NTRAID#NTBUG9-589996-2002/04/15 JonN
                            //   fixed memory leak.
                            NET_API_STATUS    ret = pNewInfo->ReadCacheFlags ();
                            appAssert( NERR_Success == ret );
                            /*
                            if ( NERR_Success != ret )
                            {
                                delete pNewInfo;
                                return HRESULT_FROM_WIN32 (ret);
                            }
                            */
                        }
                    }
                }

                if (FAILED(hr))
                {
                    delete pNewInfo;
                    DeleteShareInfoList(pShareList, TRUE);

                    return hr;
                }

                pNewInfo->InsertBefore(pShareList); // add to end of list
            }
        }
    }

    *ppShareList = pShareList;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CShareCache::CacheOK
//
//  Synopsis:   Returns TRUE if the cache contains valid data.
//
//  History:    24-Sep-95    BruceFo  Created
//
//  Note:       The critical section must be held when calling this function
//
//--------------------------------------------------------------------------

BOOL
CShareCache::CacheOK(
    VOID
    )
{
    // either both are valid or both are invalid
    appAssert(
        ((NULL != m_pHash) && (NULL != m_pBufShares)) ||
        ((NULL == m_pHash) && (NULL == m_pBufShares))
        );

    return (NULL != m_pHash);
}


#if DBG == 1

//+-------------------------------------------------------------------------
//
//  Function:   DumpNetEnum
//
//  Synopsis:   Dumps an array of SHARE_INFO_502 structures.
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

VOID
DumpNetEnum(
    IN LPVOID pBufShares,
    IN ULONG entriesRead
    )
{
    SHARE_INFO_502* pBase = (SHARE_INFO_502*) pBufShares;

    appDebugOut((DEB_TRACE,
        "DumpNetEnum: %d entries\n",
        entriesRead));

    for (ULONG i = 0; i < entriesRead; i++)
    {
        SHARE_INFO_502* p = &(pBase[i]);

        appDebugOut((DEB_TRACE | DEB_NOCOMPNAME,
"\t Share name: %ws\n"
"\t       Type: %d (0x%08lx)\n"
"\t    Comment: %ws\n"
"\tPermissions: %d (0x%08lx)\n"
"\t   Max uses: %d\n"
"\t       Path: %ws\n"
"\t   Password: %ws\n"
"\t   Reserved: %d\n"
"\t   Security? %ws\n"
"\n"
,
p->shi502_netname,
p->shi502_type, p->shi502_type,
p->shi502_remark,
p->shi502_permissions, p->shi502_permissions,
p->shi502_max_uses,
p->shi502_path,
(NULL == p->shi502_passwd) ? L"none" : p->shi502_passwd,
p->shi502_reserved,
(NULL == p->shi502_security_descriptor) ? L"No" : L"Yes"
));

    }
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\ntshrui\dlgnew.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dlgnew.cxx
//
//  Contents:   "New Share" dialog
//
//  History:    21-Feb-95 BruceFo Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "helpids.h"
#include "cache.hxx"
#include "dlgnew.hxx"
#include "acl.hxx"
#include "util.hxx"
#include "shrinfo.hxx"

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Member:     CDlgNewShare::SizeWndProc, public
//
//  Synopsis:   "allow" edit window subclass proc to disallow non-numeric
//              characters.
//
//  History:    5-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

// NTRAID#NTBUG9-585729-2002/03/19 JonN Wouldn't it be easier to just use ES_NUMBER?
LRESULT CALLBACK
CDlgNewShare::SizeWndProc(
    IN HWND hwnd,
    IN UINT wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (wMsg)
    {
    case WM_CHAR:
    {
        WCHAR chCharCode = (WCHAR)wParam;
        if (   (chCharCode == TEXT('\t'))
            || (chCharCode == TEXT('\b'))
            || (chCharCode == TEXT('\n'))
            )
        {
            break;
        }

        if (chCharCode < TEXT('0') || chCharCode > TEXT('9'))
        {
            // bad key: ignore it
            MessageBeep(0xffffffff);    // let user know it's an illegal char
            return FALSE;
        }

        break;
    }
    } // end of switch

    CDlgNewShare* pThis = (CDlgNewShare*)GetWindowLongPtr(GetParent(hwnd),GWLP_USERDATA);
    // 585755-2002/03/21 handle NULL in pThis and pThis->_pfnAllowProc
    if (NULL == pThis || NULL == pThis->_pfnAllowProc)
    {
        appAssert(FALSE);
        return FALSE;
    }
    return CallWindowProc(pThis->_pfnAllowProc, hwnd, wMsg, wParam, lParam);
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::CDlgNewShare, private
//
//  Synopsis:   constructor
//
//--------------------------------------------------------------------------

CDlgNewShare::CDlgNewShare(
    IN HWND hwndParent
    )
    :
    CDialog(hwndParent, MAKEINTRESOURCE(IDD_NEW_SHARE)),
    // 2002/03/21-JonN: initialize m_pInfoList, m_pShareInfo, m_pReplaceList
    m_pInfoList(NULL),
    m_pShareInfo(NULL),
    m_pReplaceList(NULL),
    _bShareNameChanged(FALSE),
    _bCommentChanged(FALSE),
    _wMaxUsers(DEFAULT_MAX_USERS),
    _fSecDescModified(FALSE),
    _pStoredSecDesc(NULL),
    _pfnAllowProc(NULL)
{
    INIT_SIG(CDlgNewShare);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::~CDlgNewShare, private
//
//  Synopsis:   destructor
//
//  m_pInfoList, m_pShareInfo, and m_pReplaceList belong to the caller
//
//--------------------------------------------------------------------------
CDlgNewShare::~CDlgNewShare()
{
    CHECK_SIG(CDlgNewShare);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::DlgProc, private
//
//  Synopsis:   Dialog Procedure for this object
//
//--------------------------------------------------------------------------
INT_PTR
CDlgNewShare::DlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CHECK_SIG(CDlgNewShare);

    static DWORD aHelpIds[] =
    {
        IDOK,                       HC_OK,
        IDCANCEL,                   HC_CANCEL,
        IDC_SHARE_SHARENAME,        HC_SHARE_SHARENAME,
        IDC_SHARE_SHARENAME_TEXT,   HC_SHARE_SHARENAME,
        IDC_SHARE_COMMENT,          HC_SHARE_COMMENT,
        IDC_SHARE_COMMENT_TEXT,     HC_SHARE_COMMENT,
        IDC_SHARE_MAXIMUM,          HC_SHARE_MAXIMUM,
        IDC_SHARE_ALLOW,            HC_SHARE_ALLOW,
        IDC_SHARE_ALLOW_VALUE,      HC_SHARE_ALLOW_VALUE,
        IDC_SHARE_ALLOW_SPIN,       -1L, // 257807 by request of JillZ
        IDC_SHARE_PERMISSIONS,      HC_SHARE_PERMISSIONS,
        IDC_SHARE_LIMIT,            HC_SHARE_LIMIT,
        0,0
    };

    switch (msg)
    {
    case WM_INITDIALOG:
        return _OnInitDialog(hwnd);

    case WM_COMMAND:
        return _OnCommand(hwnd, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);

    case WM_VSCROLL:
        // The up/down control changed the edit control: select it again
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
        return TRUE;

    case WM_HELP:
    {
        LPHELPINFO lphi = (LPHELPINFO)lParam;

        if (lphi->iContextType == HELPINFO_WINDOW)  // a control
        {
            WCHAR szHelp[50];
            LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
            WinHelp(
                (HWND)lphi->hItemHandle,
                szHelp,
                HELP_WM_HELP,
                (DWORD_PTR)aHelpIds);
        }
        break;
    }

    case WM_CONTEXTMENU:
    {
        WCHAR szHelp[50];
        LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
        WinHelp(
            (HWND)wParam,
            szHelp,
            HELP_CONTEXTMENU,
            (DWORD_PTR)aHelpIds);
        break;
    }

    case WM_DESTROY:
    {
        // restore original subclass to window.
        appAssert(NULL != GetDlgItem(hwnd,IDC_SHARE_ALLOW_VALUE));
        SetWindowLongPtr(GetDlgItem(hwnd,IDC_SHARE_ALLOW_VALUE), GWLP_WNDPROC, (LONG_PTR)_pfnAllowProc);
        return FALSE;
    }

    } // end of switch

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::_OnInitDialog, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CDlgNewShare::_OnInitDialog(
    IN HWND hwnd
    )
{
    CHECK_SIG(CDlgNewShare);

    // Subclass allow edit control to disallow non-positive numbers
    _pfnAllowProc = (WNDPROC)SetWindowLongPtr(
                                    GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE),
                                    GWLP_WNDPROC,
                                    (LONG_PTR)&SizeWndProc);

    // use LanMan API constants to set maximum share name & comment lengths
    SendDlgItemMessage(hwnd, IDC_SHARE_SHARENAME, EM_LIMITTEXT, NNLEN, 0L);
    SendDlgItemMessage(hwnd, IDC_SHARE_COMMENT,   EM_LIMITTEXT, MAXCOMMENTSZ, 0L);

    CheckRadioButton(
            hwnd,
            IDC_SHARE_MAXIMUM,
            IDC_SHARE_ALLOW,
            IDC_SHARE_MAXIMUM);

    SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");

    // set the spin control range: 1 <--> large number
    SendDlgItemMessage(
            hwnd,
            IDC_SHARE_ALLOW_SPIN,
            UDM_SETRANGE,
            0,
            MAKELONG(g_uiMaxUsers, 1));

    SetFocus(GetDlgItem(hwnd, IDC_SHARE_SHARENAME));

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDlgNewShare::_OnCommand, private
//
//  Synopsis:   WM_COMMAND handler
//
//  History:    21-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

BOOL
CDlgNewShare::_OnCommand(
    IN HWND hwnd,
    IN WORD wNotifyCode,
    IN WORD wID,
    IN HWND hwndCtl
    )
{
    CHECK_SIG(CDlgNewShare);

    switch (wID)
    {

//
// Notifications
//

    case IDC_SHARE_MAXIMUM:
        if (BN_CLICKED == wNotifyCode)
        {
            // Take away WS_TABSTOP from the "allow users" edit control
            HWND hwndEdit = GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE);
            SetWindowLong(hwndEdit, GWL_STYLE, GetWindowLong(hwndEdit, GWL_STYLE) & ~WS_TABSTOP);

            _CacheMaxUses(hwnd);
            SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");
        }
        return TRUE;

    case IDC_SHARE_ALLOW:
        if (BN_CLICKED == wNotifyCode)
        {
            // Give WS_TABSTOP to the "allow users" edit control
            HWND hwndEdit = GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE);
            SetWindowLong(hwndEdit, GWL_STYLE, GetWindowLong(hwndEdit, GWL_STYLE) | WS_TABSTOP);

            // let the spin control set the edit control
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
        }
        return TRUE;

    case IDC_SHARE_ALLOW_VALUE:
    {
        if (EN_SETFOCUS == wNotifyCode)
        {
            if (1 != IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
            {
                CheckRadioButton(
                    hwnd,
                    IDC_SHARE_MAXIMUM,
                    IDC_SHARE_ALLOW,
                    IDC_SHARE_ALLOW);
            }

            // let the spin control set the edit control
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
        }
        if (EN_KILLFOCUS == wNotifyCode)
        {
            _CacheMaxUses(hwnd);
        }

        return TRUE;
    }

    case IDC_SHARE_ALLOW_SPIN:
        if (UDN_DELTAPOS == wNotifyCode)
        {
            if (1 != IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
            {
                CheckRadioButton(
                    hwnd,
                    IDC_SHARE_MAXIMUM,
                    IDC_SHARE_ALLOW,
                    IDC_SHARE_ALLOW);
            }
        }
        return TRUE;

    case IDC_SHARE_SHARENAME:
    {
        if (wNotifyCode == EN_CHANGE)
        {
            _bShareNameChanged = TRUE;
        }
        return TRUE;
    }

    case IDC_SHARE_COMMENT:
    {
        if (wNotifyCode == EN_CHANGE)
        {
            _bCommentChanged = TRUE;
        }
        return TRUE;
    }


//
// Commands
//

    case IDOK:
        return _OnOK(hwnd);

    case IDCANCEL:
        EndDialog(hwnd, FALSE);
        return TRUE;

    case IDC_SHARE_PERMISSIONS:
        return _OnPermissions(hwnd);

    } // end of switch (wID)

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::_OnOK, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------

BOOL
CDlgNewShare::_OnOK(
    IN HWND hwnd
    )
{
    CHECK_SIG(CDlgNewShare);

    HRESULT hr;

    // Validate the share

    WCHAR szShareName[NNLEN + 1]; 
    ZeroMemory( szShareName, sizeof(szShareName) ); // 2002/03/21-JonN initialize

    if (0 == GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName)))
    {
        MyErrorDialog(hwnd, IERR_BlankShareName);
        SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
        return TRUE;
    }

	TrimLeadingAndTrailingSpaces(szShareName);

    HRESULT uTemp;
    if (!IsValidShareName(szShareName, &uTemp))
    {
        MyErrorDialog(hwnd, uTemp);
        SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
        return TRUE;
    }

    // Trying to create a reserved share?
    if (0 == _wcsicmp(g_szIpcShare, szShareName))
    {
        MyErrorDialog(hwnd, IERR_SpecialShare);
        SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
        return TRUE;
    }

    if (0 == _wcsicmp(g_szAdminShare, szShareName))
    {
        // We will let the admin create the admin$ share if they create
        // it in the directory specified by GetWindowsDirectory().
        WCHAR szWindowsDir[MAX_PATH];
        UINT err = GetWindowsDirectory(szWindowsDir, ARRAYLEN(szWindowsDir));
        if (err == 0)
        {
            // oh well, give them this error
            MyErrorDialog(hwnd, IERR_SpecialShare);
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            return FALSE;
        }

        if (0 != _wcsicmp(m_pShareInfo->GetPath(), szWindowsDir))
        {
            MyErrorDialog(hwnd, IERR_SpecialShare);
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            return FALSE;
        }

        // otherwise, it is the right directory. Let them create it.
    }

    // Check to see that the same share doesn't already exist. We don't allow
    // the user to create a share with the same name as a marked-for-delete
    // share, because it's easier!
    for (CShareInfo* p = (CShareInfo*) m_pInfoList->Next();
         p != m_pInfoList;
         p = (CShareInfo*) p->Next())
    {
        if (0 == _wcsicmp(p->GetNetname(), szShareName))
        {
            MyErrorDialog(hwnd, IERR_AlreadyExists, szShareName);
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            return TRUE;
        }
    }

    /* removed JonN 10/5/98
    // Check for downlevel accessibility
    // we should really get rid of this at some point -- JonN 7/18/97
    ULONG nType;
    if (NERR_Success != NetpPathType(NULL, szShareName, &nType, INPT_FLAGS_OLDPATHS))
    {
        DWORD id = MyConfirmationDialog(
                        hwnd,
                        IERR_InaccessibleByDos,
                        MB_YESNO | MB_ICONEXCLAMATION,
                        szShareName);
        if (id == IDNO)
        {
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            return TRUE;
        }
    }
    */

    WCHAR szOldPath[PATHLEN + 1];

    if (g_ShareCache.IsExistingShare(szShareName, m_pShareInfo->GetPath(),
                szOldPath, ARRAYLEN(szOldPath))) // 585682-2002/04/12-JonN
    {
        DWORD id = ConfirmReplaceShare(hwnd, szShareName, szOldPath, m_pShareInfo->GetPath());
        if (id != IDYES)
        {
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            return TRUE;
        }

        // User said to replace the old share. We need to add
        // a "delete" record for the old share.

        CShareInfo* pOldInfo = new CShareInfo();
        if (NULL == pOldInfo)
        {
            return FALSE;
        }

        hr = pOldInfo->InitInstance();
        CHECK_HRESULT(hr);
        if (FAILED(hr))
        {
            delete pOldInfo;
            return FALSE;
        }

        hr = pOldInfo->SetNetname(szShareName);
        CHECK_HRESULT(hr);
        if (FAILED(hr))
        {
            delete pOldInfo;
            return FALSE;
        }

        hr = pOldInfo->SetPath(szOldPath);
        CHECK_HRESULT(hr);
        if (FAILED(hr))
        {
            delete pOldInfo;
            return FALSE;
        }

        // NTRAID#NTBUG9-603727-2002/04/15 JonN
        // This could happen due to API failure.
        //   I don't see any good reason to call ReadCacheFlags,
        //   since we're just going to delete the share anyhow.
        NET_API_STATUS    ret = pOldInfo->ReadCacheFlags ();
        appAssert( NERR_Success == ret );
        /*
        if ( NERR_Success != ret )
        {
            delete pOldInfo;
            return HRESULT_FROM_WIN32 (ret);
        }
        */

        pOldInfo->SetDirtyFlag(SHARE_FLAG_REMOVE);
        pOldInfo->InsertBefore(m_pReplaceList); // add to end of replace list
    }

    // Everything OK, save away the data

    if (_bShareNameChanged)
    {
        hr = m_pShareInfo->SetNetname(szShareName);
        CHECK_HRESULT(hr);
    }

    if (_bCommentChanged)
    {
        WCHAR szComment[MAXCOMMENTSZ + 1];
        ZeroMemory( szComment, sizeof(szComment) ); // 2002/03/21-JonN initialize
        GetDlgItemText(hwnd, IDC_SHARE_COMMENT, szComment, ARRAYLEN(szComment));
        hr = m_pShareInfo->SetRemark(szComment);
        CHECK_HRESULT(hr);
    }

    if (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_MAXIMUM))
    {
        hr = m_pShareInfo->SetMaxUses(SHI_USES_UNLIMITED);
        CHECK_HRESULT(hr);
    }
    else if (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
    {
        _CacheMaxUses(hwnd);
        hr = m_pShareInfo->SetMaxUses(_wMaxUsers);
        CHECK_HRESULT(hr);
    }

    EndDialog(hwnd, TRUE);
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::_OnPermissions, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------
BOOL
CDlgNewShare::_OnPermissions(
    IN HWND hwnd
    )
{
    CHECK_SIG(CDlgNewShare);

    WCHAR szShareName[NNLEN + 1];
    ZeroMemory( szShareName, sizeof(szShareName) ); // 2002/03/21-JonN initialize
    GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName));
    // don't trim spaces, this might be an existing share with spaces in its name

    PSECURITY_DESCRIPTOR pNewSecDesc = NULL;
    PSECURITY_DESCRIPTOR pSecDesc = m_pShareInfo->GetSecurityDescriptor();
    // 2002/03/21-JonN handle these cases
    if (!pSecDesc || !IsValidSecurityDescriptor(pSecDesc))
    {
        appAssert(FALSE);
        return FALSE;
    }

    BOOL bSecDescChanged = FALSE; // 2002/03/21-JonN initialize
    LONG err = EditShareAcl(
                        hwnd,
                        NULL,
                        szShareName,
                        pSecDesc,
                        &bSecDescChanged,
                        &pNewSecDesc);

    if (bSecDescChanged)
    {
        _fSecDescModified = TRUE;

        appAssert(IsValidSecurityDescriptor(pNewSecDesc));
        m_pShareInfo->TransferSecurityDescriptor(pNewSecDesc);
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::_CacheMaxUses, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------
VOID
CDlgNewShare::_CacheMaxUses(
    IN HWND hwnd
    )
{
    DWORD dwRet = (DWORD)SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_GETPOS, 0, 0);
    if (HIWORD(dwRet) != 0)
    {
        _wMaxUsers = DEFAULT_MAX_USERS;

        // Reset the edit control to the new value
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
    }
    else
    {
        _wMaxUsers = LOWORD(dwRet);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\ntshrui\helpids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       helpids.h
//
//  Contents:   Help context identifiers
//
//  History:    13-Sep-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#define HC_OK                       1
#define HC_CANCEL                   2
#define HC_SHARE_SHARENAME          3
#define HC_SHARE_COMMENT            4
#define HC_SHARE_MAXIMUM            5
#define HC_SHARE_ALLOW              6
#define HC_SHARE_ALLOW_VALUE        7
#define HC_SHARE_PERMISSIONS        8
#define HC_SHARE_NOTSHARED          9
#define HC_SHARE_SHAREDAS           10
#define HC_SHARE_SHARENAME_COMBO    11
#define HC_SHARE_REMOVE             12
#define HC_SHARE_NEWSHARE           13
#define HC_SHARE_LIMIT              14
#define IDH_SHARE_CACHING_BTN       1019
#define IDH_SHARE2_ShareOnNet       10001
#define IDH_SHARE2_ReadOnly         10002
#define IDH_SHARE2_ShareName        10003
#define IDH_SHARE2_MakePrivate      10004

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// The following are help ids for the ACL editor

// stolen from \nt\private\net\ui\common\h\uihelp.h
#define HC_UI_BASE              7000
#define HC_UI_SHELL_BASE        (HC_UI_BASE+10000)

// stolen from \nt\private\net\ui\shellui\h\helpnums.h
#define HC_NTSHAREPERMS              11 // Main share perm dialog
// The following four have to be consecutive
#define HC_SHAREADDUSER              12 // Share perm add dlg
#define HC_SHAREADDUSER_LOCALGROUP   13 // Share perm add->Members
#define HC_SHAREADDUSER_GLOBALGROUP  14 // Share perm add->Members
#define HC_SHAREADDUSER_FINDUSER     15 // Share perm add->FindUser
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\ntshrui\api.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       api.cxx
//
//  Contents:   Exported APIs from this DLL
//
//  History:    5-Oct-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "dllmain.hxx"
#include "shrpage.hxx"
#include "shrinfo.hxx"
#include "cache.hxx"
#include "util.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   IsPathSharedW
//
//  Synopsis:   IsPathShared is used by the shell to determine whether to
//              put a "shared folder / hand" icon next to a directory.
//              Different from Windows 95, we don't allow sharing remote
//              directories (e.g., \\brucefo4\c$\foo\bar style paths).
//
//  Arguments:  [lpcszPath] - path to look for
//              [bRefresh]  - TRUE if cache should be refreshed
//
//  Returns:    TRUE if the path is shared, FALSE otherwise
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

STDAPI_(BOOL)
IsPathSharedW(
    LPCWSTR lpcszPath,
    BOOL bRefresh
    )
{
    InterlockedIncrement((long*)&g_NonOLEDLLRefs);

    appDebugOut((DEB_TRACE,"IsPathSharedW(%ws, %d)\n", lpcszPath, bRefresh));

    OneTimeInit();
    BOOL bSuccess = g_ShareCache.IsPathShared(lpcszPath, bRefresh);

    appDebugOut((DEB_TRACE,
        "IsPathShared(%ws, %ws) = %ws\n",
        lpcszPath,
        bRefresh ? L"refresh" : L"no refresh",
        bSuccess ? L"yes" : L"no"));

    appAssert( 0 != g_NonOLEDLLRefs );
    InterlockedDecrement((long*)&g_NonOLEDLLRefs);
    return bSuccess;
}


//+-------------------------------------------------------------------------
//
//  Function:   IsPathSharedA
//
//  Synopsis:   See IsPathSharedW
//
//  Arguments:  See IsPathSharedW
//
//  Returns:    See IsPathSharedW
//
//  History:    1-Mar-96    BruceFo  Created
//              27-Feb-02   JeffreyS Stubbed out
//
//--------------------------------------------------------------------------

STDAPI_(BOOL)
IsPathSharedA(
    LPCSTR /*lpcszPath*/,
    BOOL /*bRefresh*/
    )
{
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   SharingDialog
//
//  Synopsis:   This API brings up the "Sharing" dialog. This entrypoint is
//              only used by the FAX team, as far as I know. Note that the
//              paths passed in are ANSI---that's because that's what they
//              were in Win95 when the API was defined.
//
//              This API, on NT, only works locally. It does not do remote
//              sharing, as Win95 does. Thus, the pszComputerName parameter
//              is ignored.
//
//  Arguments:  hwndParent      -- parent window
//              pszComputerName -- a computer name. This is ignored!
//              pszPath         -- the path to share.
//
//  Returns:    TRUE if everything went OK, FALSE otherwise
//
//  History:    5-Oct-95    BruceFo  Created
//
//--------------------------------------------------------------------------

STDAPI_(BOOL)
SharingDialogW(
    HWND    hwndParent,
    LPCWSTR pszComputerName,
    LPCWSTR pszPath
    )
{
    InterlockedIncrement((long*)&g_NonOLEDLLRefs);
    appDebugOut((DEB_TRACE,"SharingDialogW(%ws)\n", pszPath));

    BOOL bReturn = FALSE;

    // Parameter validation
    if (NULL != pszComputerName)
    {
        appDebugOut((DEB_TRACE,
            "SharingDialog() API called with a computer name which will be ignored\n"));
    }

    if (NULL != pszPath)
    {
        // Make sure the DLL is initialized.
        OneTimeInit(TRUE);

        CSharingPropertyPage* pPage = new CSharingPropertyPage(TRUE);
        if (NULL != pPage)
        {
            HRESULT hr = pPage->InitInstance(pszPath);
            if (SUCCEEDED(hr))
            {
                PROPSHEETPAGE psp;

                psp.dwSize      = sizeof(psp);    // no extra data.
                psp.dwFlags     = PSP_USEREFPARENT | PSP_USECALLBACK;
                psp.hInstance   = g_hInstance;
                psp.pszTemplate = MAKEINTRESOURCE(IDD_SHARE_PROPERTIES);
                psp.hIcon       = NULL;
                psp.pszTitle    = NULL;
                psp.pfnDlgProc  = CSharingPropertyPage::DlgProcPage;
                psp.lParam      = (LPARAM)pPage;  // transfer ownership
                psp.pfnCallback = CSharingPropertyPage::PageCallback;
                psp.pcRefParent = &g_NonOLEDLLRefs;

                INT_PTR ret = DialogBoxParam(
                                g_hInstance,
                                MAKEINTRESOURCE(IDD_SHARE_PROPERTIES),
                                hwndParent,
                                CSharingPropertyPage::DlgProcPage,
                                (LPARAM)&psp);
                if (-1 != ret)
                {
                    bReturn = TRUE;
                }
            }

            pPage->Release();
        }
    }

    appAssert( 0 != g_NonOLEDLLRefs );
    InterlockedDecrement((long*)&g_NonOLEDLLRefs);
    return bReturn;
}

//+-------------------------------------------------------------------------
//
//  Function:   SharingDialogA
//
//  Synopsis:   see SharingDialogW
//
//  Arguments:  see SharingDialogW
//
//  Returns:    see SharingDialogW
//
//  History:    1-Mar-96    BruceFo  Created
//              27-Feb-02   JeffreyS Stubbed out
//
//--------------------------------------------------------------------------

STDAPI_(BOOL)
SharingDialogA(
    HWND   /*hwndParent*/,
    LPCSTR /*pszComputerName*/,
    LPCSTR /*pszPath*/
    )
{
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}


DWORD
CopyShareNameToBuffer(
    IN     CShareInfo* p,
    IN OUT LPWSTR lpszNameBuf,
    IN     DWORD cchNameBufLen
    )
{
    appAssert(NULL != lpszNameBuf);
    appAssert(0 != cchNameBufLen);

    WCHAR szLocalComputer[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD nSize = ARRAYLEN(szLocalComputer);
    if (!GetComputerName(szLocalComputer, &nSize))
    {
        return GetLastError();
    }

    DWORD computerLen = lstrlenW(szLocalComputer);
    DWORD shareLen    = lstrlenW(p->GetNetname());

    /* Two slashes + server name + slash + share name + null terminator. */
    if (2 + computerLen + 1 + shareLen + 1 > cchNameBufLen)
    {
        return ERROR_MORE_DATA;
    }

    /* Return network resource name as UNC path. */

    lpszNameBuf[0] = L'\\';
    lpszNameBuf[1] = L'\\';
    lpszNameBuf += 2;
    cchNameBufLen -= 2;

    lstrcpynW(lpszNameBuf, szLocalComputer, cchNameBufLen);
    lpszNameBuf += computerLen;
    cchNameBufLen -= computerLen;
    
    *lpszNameBuf++ = L'\\';
    cchNameBufLen--;

    lstrcpynW(lpszNameBuf, p->GetNetname(), cchNameBufLen);

    return ERROR_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetNetResourceFromLocalPathW
//
//  Synopsis:   Used by shell link tracking code.
//
//  Arguments:  [lpcszPath]      Path we're concerned about.
//              [lpszNameBuf]    If path is shared, UNC path to share goes here.
//              [cchNameBufLen] length of lpszNameBuf buffer in characters
//              [pdwNetType]     net type of local server, e.g., WNNC_NET_LANMAN
//
//  Returns:    TRUE if path is shared and net resource information
//              returned, else FALSE.
//
//  Notes:      *lpszNameBuf and *pwNetType are only valid if TRUE is returned.
//
//  Example:    If c:\documents is shared as MyDocs on machine Scratch, then
//              calling GetNetResourceFromLocalPath(c:\documents, ...) will
//              set lpszNameBuf to \\Scratch\MyDocs.
//
//  History:    3-Mar-96    BruceFo  Created from Win95 sources
//
//--------------------------------------------------------------------------

STDAPI_(BOOL)
GetNetResourceFromLocalPathW(
    IN     LPCWSTR lpcszPath,
    IN OUT LPWSTR lpszNameBuf,
    IN     DWORD cchNameBufLen,
    OUT    PDWORD pdwNetType
    )
{
    InterlockedIncrement((long*)&g_NonOLEDLLRefs);
    appDebugOut((DEB_TRACE,"GetNetResourceFromLocalPathW(%ws)\n", lpcszPath));

    // do some parameter validation
    if (NULL == lpcszPath || NULL == lpszNameBuf || NULL == pdwNetType || 0 == cchNameBufLen)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        appAssert( 0 != g_NonOLEDLLRefs );
        InterlockedDecrement((long*)&g_NonOLEDLLRefs);
        return FALSE;
    }

    OneTimeInit();

    // Parameters seem OK (pointers might still point to bad memory);
    // do the work.

    CShareInfo* pShareList = new CShareInfo();  // dummy head node
    if (NULL == pShareList)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        appAssert( 0 != g_NonOLEDLLRefs );
        InterlockedDecrement((long*)&g_NonOLEDLLRefs);
        return FALSE;   // out of memory
    }

    BOOL bReturn = FALSE;
    DWORD dwLastError;
    DWORD cShares;
    HRESULT hr = g_ShareCache.ConstructList(lpcszPath, pShareList, &cShares);
    if (SUCCEEDED(hr))
    {
        // Now, we have a list of (possibly zero) shares. The user is asking for
        // one of them. Give them the first normal, non-special share. If there
        // doesn't exist a non-special share, then give them a special share.

        if (cShares > 0)
        {
            BOOL bFoundOne = FALSE;
            CShareInfo* p;

            for (p = (CShareInfo*) pShareList->Next();
                 p != pShareList;
                 p = (CShareInfo*) p->Next())
            {
                if (p->GetType() == STYPE_DISKTREE)
                {
                    // found a share for this one.
                    bFoundOne = TRUE;
                    break;
                }
            }

            if (!bFoundOne)
            {
                for (p = (CShareInfo*) pShareList->Next();
                     p != pShareList;
                     p = (CShareInfo*) p->Next())
                {
                    if (p->GetType() == (STYPE_SPECIAL | STYPE_DISKTREE))
                    {
                        bFoundOne = TRUE;
                        break;
                    }
                }
            }

            if (bFoundOne)
            {
                dwLastError = CopyShareNameToBuffer(p, lpszNameBuf, cchNameBufLen);
                if (ERROR_SUCCESS == dwLastError)
                {
                    bReturn = TRUE;
                    *pdwNetType = WNNC_NET_LANMAN; // we only support LanMan
                }
            }
            else
            {
                // nothing found!
                dwLastError = ERROR_BAD_NET_NAME;
            }
        }
        else
        {
            dwLastError = ERROR_BAD_NET_NAME;
        }
    }
    else
    {
        dwLastError = ERROR_OUTOFMEMORY;
    }

    DeleteShareInfoList(pShareList, TRUE);

    if (!bReturn)
    {
        SetLastError(dwLastError);
    }

    appAssert( 0 != g_NonOLEDLLRefs );
    InterlockedDecrement((long*)&g_NonOLEDLLRefs);
    return bReturn;
}


STDAPI_(BOOL)
GetNetResourceFromLocalPathA(
    IN     LPCSTR /*lpcszPath*/,
    IN OUT LPSTR  /*lpszNameBuf*/,
    IN     DWORD  /*cchNameBufLen*/,
    OUT    PDWORD /*pdwNetType*/
    )
{
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetLocalPathFromNetResourceW
//
//  Synopsis:   Used by shell link tracking code.
//
//  Arguments:  [lpcszName]     A UNC path we're concerned about.
//              [dwNetType]     net type of local server, e.g., WNNC_NET_LANMAN
//              [lpszLocalPathBuf]   Buffer to place local path of UNC path
//              [cchLocalPathBufLen] length of lpszLocalPathBuf buffer in
//                                   characters
//              [pbIsLocal]     Set to TRUE if lpcszName points to a local
//                              resource.
//
//  Returns:
//
//  Notes:      *lpszLocalPathBuf and *pbIsLocal are only valid if
//              TRUE is returned.
//
//  Example:    If c:\documents is shared as MyDocs on machine Scratch, then
//              calling GetLocalPathFromNetResource(\\Scratch\MyDocs, ...) will
//              set lpszLocalPathBuf to c:\documents.
//
//  History:    3-Mar-96    BruceFo  Created from Win95 sources
//
//--------------------------------------------------------------------------

STDAPI_(BOOL)
GetLocalPathFromNetResourceW(
    IN     LPCWSTR lpcszName,
    IN     DWORD dwNetType,
    IN OUT LPWSTR lpszLocalPathBuf,
    IN     DWORD cchLocalPathBufLen,
    OUT    PBOOL pbIsLocal
    )
{
    InterlockedIncrement((long*)&g_NonOLEDLLRefs);
    appDebugOut((DEB_TRACE,"GetLocalPathFromNetResourceW(%ws)\n", lpcszName));
    OneTimeInit();

    BOOL bReturn = FALSE;
    DWORD dwLastError;

    *pbIsLocal = FALSE;

    if (g_fSharingEnabled)
    {
        if (0 != dwNetType && HIWORD(dwNetType) == HIWORD(WNNC_NET_LANMAN))
        {
            /* Is the network resource name a UNC path on this machine? */

            WCHAR szLocalComputer[MAX_COMPUTERNAME_LENGTH + 1];
            DWORD nSize = ARRAYLEN(szLocalComputer);
            if (!GetComputerName(szLocalComputer, &nSize))
            {
                dwLastError = GetLastError();
            }
            else
            {
                dwLastError = ERROR_BAD_NET_NAME;

                DWORD dwLocalComputerLen = lstrlenW(szLocalComputer);
                if (   lpcszName[0] == L'\\'
                    && lpcszName[1] == L'\\'
                    && (0 == _wcsnicmp(lpcszName + 2, szLocalComputer, dwLocalComputerLen))
                    )
                {
                    LPCWSTR lpcszSep = &(lpcszName[2 + dwLocalComputerLen]);
                    if (*lpcszSep == L'\\')
                    {
                        *pbIsLocal = TRUE;

                        WCHAR szLocalPath[MAX_PATH];
                        if (g_ShareCache.IsExistingShare(lpcszSep + 1, NULL, szLocalPath, ARRAYLEN(szLocalPath)))
                        {
                            if (wcslen(szLocalPath) < cchLocalPathBufLen)
                            {
                                lstrcpynW(lpszLocalPathBuf, szLocalPath, cchLocalPathBufLen);
                                dwLastError = ERROR_SUCCESS;
                                bReturn = TRUE;
                            }
                            else
                            {
                                dwLastError = ERROR_MORE_DATA;
                            }
                        }
                    }
                }
            }
        }
        else
        {
            dwLastError = ERROR_BAD_PROVIDER;
        }
    }
    else
    {
        appDebugOut((DEB_TRACE,"GetLocalPathFromNetResourceW: sharing not enabled\n"));
        dwLastError = ERROR_BAD_NET_NAME;
    }

    if (!bReturn)
    {
        SetLastError(dwLastError);
    }

    appAssert( 0 != g_NonOLEDLLRefs );
    InterlockedDecrement((long*)&g_NonOLEDLLRefs);
    return bReturn;
}


STDAPI_(BOOL)
GetLocalPathFromNetResourceA(
    IN     LPCSTR /*lpcszName*/,
    IN     DWORD  /*dwNetType*/,
    IN OUT LPSTR  /*lpszLocalPathBuf*/,
    IN     DWORD  /*cchLocalPathBufLen*/,
    OUT    PBOOL  /*pbIsLocal*/
    )
{
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}

STDAPI CanShareFolderW(LPCWSTR pszPath)
{
    InterlockedIncrement((long*)&g_NonOLEDLLRefs);
    appDebugOut((DEB_TRACE,"CanShareFolderW(%s)\n", pszPath));
    OneTimeInit();

    HRESULT hr = S_FALSE;

    if (g_fSharingEnabled || IsSimpleUI())
    {
        if ( (pszPath[0] >= L'A' && pszPath[0] <= L'Z') && pszPath[1] == L':')
        {
            WCHAR szRoot[4];

            szRoot[0] = pszPath[0];
            szRoot[1] = TEXT(':');
            szRoot[2] = TEXT('\\');
            szRoot[3] = 0;

            UINT uType = GetDriveType(szRoot);

            switch (uType)
            {
                case DRIVE_UNKNOWN:
                case DRIVE_NO_ROOT_DIR:
                case DRIVE_REMOTE:
                    hr = S_FALSE;
                    break;
        
                case DRIVE_FIXED:
                case DRIVE_REMOVABLE:
                    {
                        WCHAR szDesktopIni[MAX_PATH];
                        if (PathCombine(szDesktopIni, pszPath, TEXT("desktop.ini")))
                        {
                            hr = GetPrivateProfileInt(TEXT(".ShellClassInfo"), TEXT("Sharing"), TRUE, szDesktopIni) ? S_OK : S_FALSE;
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
                        }
                    }
                    break;

                default:
                   hr = S_OK;
                   break;
            }

            //
            // NTRAID#NTBUG9-353119-2001/04/10-jeffreys
            //
            // We need to call PathIsDirectory to prevent the "Share this
            // folder" task from appearing in the webview pane of CAB and
            // ZIP folders. (NTBUG9 #319149 and 319153)
            //
            // However, PathIsDirectory fails with ERROR_NOT_READY on an
            // empty CD or removable drive, which is a case we want to allow
            // or the Sharing page will not show. (NTBUG9 #353119)
            //
            if (S_OK == hr && !PathIsDirectory(pszPath))
            {
                hr = S_FALSE;

                if (GetLastError() == ERROR_NOT_READY &&
                    (DRIVE_CDROM == uType || DRIVE_REMOVABLE == uType) &&
                    PathIsRootW(pszPath))
                {
                    // Ok to share an empty CD or removable drive
                    hr = S_OK;
                }
            }
        }
    }

    appAssert( 0 != g_NonOLEDLLRefs );
    InterlockedDecrement((long*)&g_NonOLEDLLRefs);

    return hr;
}

STDAPI ShowShareFolderUIW(HWND hwndParent, LPCWSTR pszPath)
{
    InterlockedIncrement((long*)&g_NonOLEDLLRefs);
    appDebugOut((DEB_TRACE,"ShowShareFolderUIW(%s)\n", pszPath));

    TCHAR szShare[50];
    LoadString(g_hInstance, IDS_MSGTITLE, szShare, ARRAYLEN(szShare));
    SHObjectProperties(hwndParent, SHOP_FILEPATH, pszPath, szShare);

    appAssert( 0 != g_NonOLEDLLRefs );
    InterlockedDecrement((long*)&g_NonOLEDLLRefs);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\ntshrui\dllmain.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       dllmain.hxx
//
//  Contents:   DLL initialization entrypoint and global variables
//
//  History:    4-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "critsec.hxx"
#include "cache.hxx"
#include "strhash.hxx"
#include "dllmain.hxx"
#include "util.hxx"

//--------------------------------------------------------------------------
// Globals used elsewhere

UINT        g_NonOLEDLLRefs = 0;
HINSTANCE   g_hInstance = NULL;
BOOL        g_fSharingEnabled = FALSE;   // until proven otherwise
UINT        g_uiMaxUsers = 0;   // max number of users based on product type

WCHAR       g_szAdminShare[] = L"ADMIN$";
WCHAR       g_szIpcShare[]   = L"IPC$";

//--------------------------------------------------------------------------
// Globals used only in this file

CRITICAL_SECTION    g_csOneTimeInit;
BOOL                g_fOneTimeInitDone = FALSE;

// Note: the total wait time is:
//    min( (the wait hint / WAIT_FRACTION), MAX_WAIT_PERIOD ) * MAX_WAIT_COUNT
// In the case of the server, with a 30 second hint, about 2 minutes, 30 sec.

#define WAIT_FRACTION   4       // the fraction of the hint to wait
#define MAX_WAIT_COUNT  20      // the maximum number of wait failures to tolerate before quiting
#define MAX_WAIT_PERIOD 15000L  // 15 seconds

#define WAIT_TO_BEGIN_GRANULARITY   4000    // 4 seconds
#define MAX_WAIT_TO_BEGIN           90000L  // 90 seconds: time to wait before giving up that it will ever start

//--------------------------------------------------------------------------
// Debugging

#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "Sharing"
#define SZ_MODULE           "Sharing"
#define DECLARE_DEBUG       1
#include <debug.h>

//--------------------------------------------------------------------------

VOID
InitializeShareCache(
    VOID
    );

DWORD WINAPI
WaitForServerThread(
    IN LPVOID ThreadParameter
    );

BOOL
CheckServiceController(
    VOID
    );

BOOL
ServerConfiguredToStart(
    SC_HANDLE hScManager
    );

BOOL
WaitForServerToBeginStarting(
    SC_HANDLE hService,
    LPSERVICE_STATUS pServiceStatus // so we don't need to re-query on successful return
    );

//--------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Win32 DLL initialization function
//
//  Arguments:  [hInstance] - Handle to this dll
//              [dwReason]  - Reason this function was called.  Can be
//                            Process/Thread Attach/Detach.
//
//  Returns:    BOOL    - TRUE if no error.  FALSE otherwise
//
//  History:    4-Apr-95 BruceFo  Created
//
//---------------------------------------------------------------------------

extern "C"
BOOL
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID /*lpReserved*/
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
    {
        appDebugOut((DEB_TRACE, "ntshrui.dll: DllMain enter\n"));

        // Disable thread notification from OS
        DisableThreadLibraryCalls(hInstance);
        CcshellGetDebugFlags();
        g_hInstance = hInstance;
        // Be specific about where to get your manifest from - it's in the dll, at the
        // default resource ID for the shell, which is 123.
        SHFusionInitializeFromModuleID(hInstance, SHFUSION_DEFAULT_RESOURCE_ID);
        InitCommonControls();   // get up/down control
        InitializeCriticalSection(&g_csOneTimeInit);
        break;
    }

    case DLL_PROCESS_DETACH:
        appDebugOut((DEB_TRACE, "ntshrui.dll: DllMain leave\n"));
        SHFusionUninitialize();
        DeleteCriticalSection(&g_csOneTimeInit);
        break;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   OneTimeInit
//
//  Synopsis:   Initialization code: check if SMB server is running
//
//  History:    21-Apr-95 BruceFo  Created
//
//  Returns:
//  Note:       We don't want to do this in the DLL initialization code, so
//              we call it for every entrypoint, namely DllGetClassObject,
//              DllCanUnloadNow, and IsPathShared.
//
//--------------------------------------------------------------------------

VOID
OneTimeInit(
    IN BOOL bDialog // TRUE if for dialog API
    )
{
    // quick check; no critical section
    if (g_fOneTimeInitDone)
    {
        return;
    }

    {
        CTakeCriticalSection t(&g_csOneTimeInit);   // scope it

        // Since there wasn't a critical section on the above check, multiple
        // threads might have fallen through to the critical section taking,
        // and wait. After the one-time initialization is complete, the
        // first thread sets g_fOneTimeInitDone to TRUE and leaves the
        // critical section. At this point, the other threads will wake up
        // here. Do the check again, and return if another thread did the
        // initialization.

        if (g_fOneTimeInitDone)
        {
            return;
        }

        // Now, do the actual initialization

        if (!bDialog)
        {
            // First, determine if the server is running. If not, see if
            // we should wait for it. If we wait and it still isn't
            // started, then give up.

            InitializeShareCache();
        }
        // if it is a dialog call, then we don't load up the cache because
        // that's the first thing the dialog code does.

        // Determine the maximum number of users
        g_uiMaxUsers = IsOS(OS_ANYSERVER) ? MAX_USERS_ON_SERVER : MAX_USERS_ON_WORKSTATION;

        g_fOneTimeInitDone = TRUE;  // set this *last*
    }
}


VOID
InitializeShareCache(
    VOID
    )

/*++

Routine Description:

    This routine initializes the share cache. It determines if the LanMan
    server is running. If it is, great.
    If it isn't, determine if it is starting. If so, wait for a while. After
    a while, if it still hasn't started, then give up and assume it's hung.
    If the server isn't starting, then determine if the configuration says it
    is going to start (set to autostart). If so, wait to see if it ever goes
    into the "start pending" state. Give up after a reasonable period. If it
    does go into this state, then wait for it to finish starting, as described
    before.

    Both LanMan and Service Controller APIs are used in this endeavor.

Arguments:

    None

Return Value:

    Returns TRUE if the server service has been started; otherwise
    returns FALSE.  Any API errors return FALSE, and hence assume
    the server isn't started or won't start.

--*/

{
    appDebugOut((DEB_TRACE, "InitializeShareCache: enter\n"));

    g_ShareCache.Refresh(); // sets g_fSharingEnabled
    if (g_fSharingEnabled)
    {
        // well, we've got a cache so no need to start up a thread and wait
        // for the server to start
        return;
    }

    // The server isn't currently started. Create a thread that waits for it
    // to start, and if it does, refreshes the shell.

    DWORD threadId;
    HANDLE hThread = CreateThread(
                            NULL,
                            0,
                            WaitForServerThread,
                            NULL,
                            0,
                            &threadId);
    if (NULL == hThread)
    {
        appDebugOut((DEB_ERROR, "Error creating thread\n"));
    }
    else
    {
        CloseHandle(hThread); // No reason to keep handle around
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   WaitForServerThread
//
//  Synopsis:   Thread procedure for the thread that waits for the server
//              to start.
//
//  History:    25-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

DWORD WINAPI
WaitForServerThread(
    IN LPVOID /*ThreadParameter*/
    )
{
    appDebugOut((DEB_TRACE, "Created thread to wait for server to start\n"));

    if (CheckServiceController())
    {
        // the server has started

        appDebugOut((DEB_TRACE, "The server finally started, after waiting in a thread. Refresh all!\n"));

        g_ShareCache.Refresh(); // sets g_fSharingEnabled
    }

    return 0;
}


//+-------------------------------------------------------------------------
//
//  Function:   CheckServiceController
//
//  Synopsis:   Returns TRUE if the server starts, based on consulting the
//              service controller and waiting for the server to start.
//
//  History:    25-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

BOOL
CheckServiceController(
    VOID
    )
{
    // See if it is currently starting.

    SC_HANDLE hScManager;
    SC_HANDLE hService;
    SERVICE_STATUS serviceStatus;

    hScManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hScManager == NULL)
    {
        appDebugOut((DEB_ERROR,
                "CheckServiceController: OpenSCManager failed: 0x%08lx\n",
                GetLastError()));

        return FALSE;
    }

    appDebugOut((DEB_TRACE, "CheckServiceController: opening server service\n"));

    hService = OpenService(hScManager, SERVICE_SERVER, SERVICE_QUERY_STATUS);
    if (hService == NULL)
    {
        appDebugOut((DEB_ERROR,
                "CheckServiceController: OpenService failed: 0x%08lx\n",
                GetLastError()));

        CloseServiceHandle(hScManager);
        return FALSE;
    }

    // Now we've got a handle to the server service. See if it's started.

    appDebugOut((DEB_TRACE, "CheckServiceController: querying server service\n"));

    if (!QueryServiceStatus(hService, &serviceStatus))
    {
        appDebugOut((DEB_ERROR,
                "CheckServiceController: QueryServiceStatus failed: 0x%08lx\n",
                GetLastError()));

        CloseServiceHandle(hScManager);
        CloseServiceHandle(hService);
        return FALSE;
    }

    if (serviceStatus.dwCurrentState == SERVICE_RUNNING)
    {
        appDebugOut((DEB_TRACE, "CheckServiceController: Server is running!\n"));

        // we've off to the races!

        CloseServiceHandle(hScManager);
        CloseServiceHandle(hService);
        return TRUE;
    }

    if (serviceStatus.dwCurrentState != SERVICE_START_PENDING)
    {
        appDebugOut((DEB_TRACE, "CheckServiceController: Server is not running nor is it starting! State = %d\n", serviceStatus.dwCurrentState));

        // The server is not in the process of starting. Go check its
        // configuration and see if it is even configured to start.

        if (!ServerConfiguredToStart(hScManager))
        {
            // the service is not in the process of starting, nor is it
            // configured to start, so we give up.

            CloseServiceHandle(hScManager);
            CloseServiceHandle(hService);
            return FALSE;
        }

        if (!WaitForServerToBeginStarting(hService, &serviceStatus))
        {
            // The server is configured to start, but we already waited for
            // it to commence starting, and it never did. So give up on
            // it.

            CloseServiceHandle(hScManager);
            CloseServiceHandle(hService);
            return FALSE;
        }

        // the server is configured to start, we waited for it to commence
        // its startup sequence, and it actually did commence starting!
    }

    // In this case, the service is trying to start. Wait until it either
    // starts or we think it's hung.

    appDebugOut((DEB_TRACE, "CheckServiceController: Server is starting\n"));

    //
    // record the current check point. The service should "periodically
    // increment" this if it is making progress.
    //

    DWORD lastCheckPoint = serviceStatus.dwCheckPoint;
    DWORD waitCount = 0;

    while (serviceStatus.dwCurrentState == SERVICE_START_PENDING)
    {
        if (lastCheckPoint == serviceStatus.dwCheckPoint)
        {
            ++waitCount;
            if (waitCount > MAX_WAIT_COUNT)
            {
                appDebugOut((DEB_TRACE,
                    "CheckServiceController: Server service is HUNG\n"));

                CloseServiceHandle(hScManager);
                CloseServiceHandle(hService);
                return FALSE;
            }
        }
        else
        {
            waitCount = 0;
            lastCheckPoint = serviceStatus.dwCheckPoint;
        }

        // Ideally, we would wait the wait hint and be done with it. However,
        // We don't want to be waiting if the service gives us an overly
        // generous wait hint and finishes while we're still waiting. So,
        // wait a fraction of the wait hint. The exact fraction is
        // 1/WAIT_FRACTION. The effect is that we wait no more than
        // MAX_WAIT_COUNT / WAIT_FRACTION times the wait hint before
        // giving up. We make sure we wait at least 1 second between checks.
        // Finally, cap the wait hint in case it is far to large, possibly
        // in error.

        DWORD dwWait = serviceStatus.dwWaitHint / WAIT_FRACTION;
        dwWait = (dwWait > MAX_WAIT_PERIOD) ? MAX_WAIT_PERIOD : dwWait;
        dwWait = (dwWait < 1000) ? 1000 : dwWait; // at least 1 second

        appDebugOut((DEB_TRACE,
            "CheckServiceController: sleeping. hint = %d, actually waiting %d\n",
            serviceStatus.dwWaitHint, dwWait));

        Sleep(dwWait);

        if (!QueryServiceStatus(hService, &serviceStatus))
        {
            appDebugOut((DEB_ERROR,
                    "CheckServiceController: QueryServiceStatus failed: 0x%08lx\n",
                    GetLastError()));

            CloseServiceHandle(hScManager);
            CloseServiceHandle(hService);
            return FALSE;
        }
    }

    CloseServiceHandle(hScManager);
    CloseServiceHandle(hService);

    if (serviceStatus.dwCurrentState == SERVICE_RUNNING)
    {
        appDebugOut((DEB_TRACE, "CheckServiceController: service finally started\n"));

        // This magic line refreshes *all* the explorer windows. Unfortunately,
        // it causes a share cache refresh for each one as well...
        SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);

        return TRUE;    // Finally! It's running!
    }
    else
    {
        appDebugOut((DEB_TRACE, "CheckServiceController: service never started\n"));
        return FALSE;
    }
}


BOOL
ServerConfiguredToStart(
    SC_HANDLE hScManager
    )
{
    // We re-open the service because we want a different type of permission

    SC_HANDLE hService = OpenService(hScManager, SERVICE_SERVER, SERVICE_QUERY_CONFIG);
    if (hService == NULL)
    {
        appDebugOut((DEB_ERROR,
                "ServerConfiguredToStart: OpenService failed: 0x%08lx\n",
                GetLastError()));

        return FALSE;
    }

    BOOL b;
    DWORD cbBytesNeeded;
    BYTE buffer[1024];  // a large buffer...
    LPQUERY_SERVICE_CONFIG lpqscServConfig = (LPQUERY_SERVICE_CONFIG)buffer;
    b = QueryServiceConfig(
                    hService,
                    lpqscServConfig,
                    sizeof(buffer),
                    &cbBytesNeeded);
    if (!b)
    {
        appDebugOut((DEB_ERROR,
                "ServerConfiguredToStart: QueryServiceConfig failed: 0x%08lx\n",
                GetLastError()));

        return FALSE;
    }

    b = (lpqscServConfig->dwStartType == SERVICE_AUTO_START);
    CloseServiceHandle(hService);

    appDebugOut((DEB_TRACE,
        "ServerConfiguredToStart: configured to start? %s\n",
        b ? "yes" : "no"));

    return b;
}


BOOL
WaitForServerToBeginStarting(
    SC_HANDLE hService,
    LPSERVICE_STATUS pServiceStatus // so we don't need to re-query on successful return
    )
{
    // Here's the algorithm:
    //      wait WAIT_TO_BEGIN_GRANULARITY milliseconds
    //      query status
    //      if the service is running then return TRUE
    //      if we've waited MAX_WAIT_TO_BEGIN ms, return FALSE
    //      go back and wait again...

    DWORD dwWaitedMilliseconds;

    for (dwWaitedMilliseconds = 0;
         dwWaitedMilliseconds < MAX_WAIT_TO_BEGIN;
         dwWaitedMilliseconds += WAIT_TO_BEGIN_GRANULARITY)
    {
        appDebugOut((DEB_TRACE,
            "WaitForServerToBeginStarting: sleeping\n"));

        Sleep(WAIT_TO_BEGIN_GRANULARITY);

        if (!QueryServiceStatus(hService, pServiceStatus))
        {
            appDebugOut((DEB_ERROR,
                    "WaitForServerToBeginStarting: QueryServiceStatus failed: 0x%08lx\n",
                    GetLastError()));

            return FALSE;
        }

        if (   pServiceStatus->dwCurrentState == SERVICE_RUNNING
            || pServiceStatus->dwCurrentState == SERVICE_START_PENDING
            )
        {
            appDebugOut((DEB_TRACE,
                "WaitForServerToBeginStarting: server commenced startup\n"));

            return TRUE;
        }
    }

    appDebugOut((DEB_TRACE,
        "WaitForServerToBeginStarting: waited %d milliseconds for server to commence startup, then gave up\n",
         MAX_WAIT_TO_BEGIN));

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\ntshrui\makefile.inc ===
app.rc: $(SDK_INC_PATH)\windows.h \
        $(SDK_INC_PATH)\common.ver \
        $(SDK_INC_PATH)\ntverp.h \
        shell_ntshrui.manifest \
        resource.h \
        $(O)\messages.h \
        $(O)\messages.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\ntshrui\permpage.cxx ===
// PermPage.cxx : Implementation ACL Editor classes
// jonn 7/10/97 copied from \nt\private\admin\snapin\filemgmt\permpage.cpp

#include "headers.hxx"
#pragma hdrstop

#include "acl.hxx"
#include "resource.h"   // IDS_SHAREPERM_*
#include "util.hxx"     // CopySecurityDescriptor

// need IID_ISecurityInformation
#define INITGUID
#include <initguid.h>
#include <aclui.h>

//
// I define my own implementation of ISecurityInformation
//

class CSecurityInformation : public ISecurityInformation
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo ) = 0;
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault ) = 0;
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor ) = 0;
    STDMETHOD(GetAccessRights) (const GUID* pguidObjectType,
                                DWORD dwFlags,
                                PSI_ACCESS *ppAccess,
                                ULONG *pcAccesses,
                                ULONG *piDefaultAccess );
    STDMETHOD(MapGeneric) (const GUID *pguidObjectType,
                           UCHAR *pAceFlags,
                           ACCESS_MASK *pMask);
    STDMETHOD(GetInheritTypes) (PSI_INHERIT_TYPE *ppInheritTypes,
                                ULONG *pcInheritTypes );
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage );

    CSecurityInformation() : _cRef(1) {}

private:
    LONG _cRef;
};

class CShareSecurityInformation : public CSecurityInformation
{
private:
    LPCWSTR m_strMachineName;
    LPCWSTR m_strShareName;
    WCHAR  m_szTitle[200];
public:
    CShareSecurityInformation(LPCWSTR pszMachineName, LPCWSTR pszShareName)
        : m_strMachineName(pszMachineName), m_strShareName(pszShareName)
    {
        LoadString( g_hInstance, IDS_PERMPAGE_TITLE, m_szTitle, ARRAYLEN(m_szTitle) );
    }
    LPCWSTR QueryMachineName()
    {
        return m_strMachineName;
    }
    LPCWSTR QueryShareName()
    {
        return m_strShareName;
    }

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo );
};

class CSMBSecurityInformation : public CShareSecurityInformation
{
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault );
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor );
public:
    PSECURITY_DESCRIPTOR m_pInitialDescriptor;
    PSECURITY_DESCRIPTOR* m_ppCurrentDescriptor;
    CSMBSecurityInformation(LPCWSTR pszMachineName, LPCWSTR pszShareName, PSECURITY_DESCRIPTOR pSDOriginal, PSECURITY_DESCRIPTOR *ppSDResult);
    ~CSMBSecurityInformation();
};


// IUnknown implementation

STDMETHODIMP CSecurityInformation::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CSecurityInformation, ISecurityInformation),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CSecurityInformation::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CSecurityInformation::Release()
{
    appAssert(0 != _cRef);
    ULONG cRef = InterlockedDecrement(&_cRef);
    if (0 == cRef)
    {
        delete this;
    }
    return cRef;
}

// ISecurityInformation interface implementation

SI_ACCESS siShareAccesses[] =
{
  { &GUID_NULL, 
    FILE_ALL_ACCESS, 
    MAKEINTRESOURCE(IDS_SHAREPERM_ALL), 
    SI_ACCESS_GENERAL },
  { &GUID_NULL, 
    FILE_GENERIC_READ | FILE_EXECUTE | FILE_GENERIC_WRITE | DELETE, 
    MAKEINTRESOURCE(IDS_SHAREPERM_MODIFY), 
    SI_ACCESS_GENERAL },
  { &GUID_NULL, 
    FILE_GENERIC_READ | FILE_EXECUTE, 
    MAKEINTRESOURCE(IDS_SHAREPERM_READ), 
    SI_ACCESS_GENERAL }
};
#define iShareDefAccess      2   // FILE_GEN_READ

STDMETHODIMP CSecurityInformation::GetAccessRights (
                            const GUID* /*pguidObjectType*/,
                            DWORD /*dwFlags*/,
                            PSI_ACCESS *ppAccess,
                            ULONG *pcAccesses,
                            ULONG *piDefaultAccess )
{
    appAssert(ppAccess != NULL);
    appAssert(pcAccesses != NULL);
    appAssert(piDefaultAccess != NULL);

    *ppAccess = siShareAccesses;
    *pcAccesses = ARRAYLEN(siShareAccesses);
    *piDefaultAccess = iShareDefAccess;

    return S_OK;
}

// This is consistent with the NETUI code
GENERIC_MAPPING ShareMap =
{
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};

STDMETHODIMP CSecurityInformation::MapGeneric (
                       const GUID* /*pguidObjectType*/,
                       UCHAR* /*pAceFlags*/,
                       ACCESS_MASK *pMask)
{
    appAssert(pMask != NULL);

    MapGenericMask(pMask, &ShareMap);

    return S_OK;
}

STDMETHODIMP CSecurityInformation::GetInheritTypes (
                            PSI_INHERIT_TYPE* /*ppInheritTypes*/,
                            ULONG* /*pcInheritTypes*/ )
{
    appAssert(FALSE);
    return E_NOTIMPL;
}

STDMETHODIMP CSecurityInformation::PropertySheetPageCallback(HWND /*hwnd*/, UINT /*uMsg*/, SI_PAGE_TYPE /*uPage*/)
{
    return S_OK;
}

/*
JeffreyS 1/24/97:
If you don't set the SI_RESET flag in
ISecurityInformation::GetObjectInformation, then fDefault should never be TRUE
so you can ignore it.  Returning E_NOTIMPL in this case is OK too.

If you want the user to be able to reset the ACL to some default state
(defined by you) then turn on SI_RESET and return your default ACL
when fDefault is TRUE.  This happens if/when the user pushes a button
that is only visible when SI_RESET is on.
*/
STDMETHODIMP CShareSecurityInformation::GetObjectInformation (
    PSI_OBJECT_INFO pObjectInfo )
{
    if (NULL == pObjectInfo)
        return E_POINTER;

    pObjectInfo->dwFlags = SI_EDIT_PERMS | SI_NO_ACL_PROTECT | SI_PAGE_TITLE;
    pObjectInfo->hInstance = g_hInstance;
    pObjectInfo->pszServerName = (LPWSTR)QueryMachineName();
    pObjectInfo->pszObjectName = (LPWSTR)QueryShareName();

    // page title added JonN 3/8/99 per 115196
    pObjectInfo->pszPageTitle = m_szTitle;

    return S_OK;
}

CSMBSecurityInformation::CSMBSecurityInformation(
    LPCWSTR pszMachineName, LPCWSTR pszShareName,
    PSECURITY_DESCRIPTOR pSDOriginal, PSECURITY_DESCRIPTOR *ppSDResult
)
: CShareSecurityInformation(pszMachineName, pszShareName)
, m_pInitialDescriptor( pSDOriginal )
, m_ppCurrentDescriptor( ppSDResult )
{
}

CSMBSecurityInformation::~CSMBSecurityInformation()
{
}

STDMETHODIMP CSMBSecurityInformation::GetSecurity (
                        SECURITY_INFORMATION RequestedInformation,
                        PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                        BOOL fDefault )
{
    HRESULT hr = S_OK;

    if (NULL == ppSecurityDescriptor)
        return E_POINTER;

    *ppSecurityDescriptor = NULL;

    if (0 == RequestedInformation )
        return E_INVALIDARG;

    if (fDefault)
        return E_NOTIMPL;

    appAssert( NULL != m_ppCurrentDescriptor );
    if (NULL != *m_ppCurrentDescriptor)
    {
        hr = CopySecurityDescriptor(*m_ppCurrentDescriptor, ppSecurityDescriptor);
    }
    else if (NULL != m_pInitialDescriptor)
    {
        hr = CopySecurityDescriptor(m_pInitialDescriptor, ppSecurityDescriptor);
    }
    else
    {
        // Ok to return NULL for "no security".  Aclui will interpret
        // this as "Everyone: Full Control".
    }
    return hr;
}

STDMETHODIMP CSMBSecurityInformation::SetSecurity (
                        SECURITY_INFORMATION /*SecurityInformation*/,
                        PSECURITY_DESCRIPTOR pSecurityDescriptor )
{
    PSECURITY_DESCRIPTOR psdTemp;
    HRESULT hr = CopySecurityDescriptor(pSecurityDescriptor, &psdTemp);
    if (SUCCEEDED(hr))
    {
        appAssert( NULL != m_ppCurrentDescriptor );
        ::LocalFree(*m_ppCurrentDescriptor);
        *m_ppCurrentDescriptor = psdTemp;
    }
    return hr;
}

HMODULE g_hlibACLUI = NULL;
typedef BOOL (*EDIT_SECURITY_PROC) ( HWND, LPSECURITYINFO );
EDIT_SECURITY_PROC g_pfnEditSecurityProc;

LONG
EditShareAcl(
    IN HWND                      hwndParent,
    IN LPCWSTR                   pszServerName,
    IN LPCWSTR                   pszShareName,
    IN PSECURITY_DESCRIPTOR      pSecDesc,
    OUT BOOL*                    pfSecDescModified,
    OUT PSECURITY_DESCRIPTOR*    ppSecDesc
    )
{
    appAssert( ppSecDesc != NULL );
    *ppSecDesc = NULL;

    if (NULL == g_hlibACLUI)
    {
        g_hlibACLUI = ::LoadLibrary(L"ACLUI.DLL");
        if (NULL == g_hlibACLUI)
        {
            appAssert(FALSE); // ACLUI.DLL isn't installed?
            return 0;
        }
    }

    if (NULL == g_pfnEditSecurityProc)
    {
        g_pfnEditSecurityProc = reinterpret_cast<EDIT_SECURITY_PROC>(::GetProcAddress(g_hlibACLUI,"EditSecurity"));
        if (NULL == g_pfnEditSecurityProc)
        {
            appAssert(FALSE); // ACLUI.DLL is invalid?
            return 0;
        }
    }

    CSMBSecurityInformation* psecinfo = new CSMBSecurityInformation(pszServerName, pszShareName, pSecDesc, ppSecDesc);
    if (NULL == psecinfo)
        return 0;

    (g_pfnEditSecurityProc)(hwndParent,psecinfo);

    if (NULL != pfSecDescModified)
        *pfSecDescModified = (NULL != *ppSecDesc);

    psecinfo->Release();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\ntshrui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by app.rc
//
#define IDS_APP_MSG_NOT_FOUND           100
#define IDS_NET_MSG_NOT_FOUND           101
#define IDS_NO_NET_MSG                  102
#define IDS_MSGTITLE                    103
#define IDS_SHARING                     104
#define IDS_MENUHELP                    105
#define IDS_ACLEDIT_PERM_GEN_NO_ACCESS  106
#define IDS_ACLEDIT_PERM_GEN_READ       107
#define IDS_ACLEDIT_PERM_GEN_MODIFY     108
#define IDS_ACLEDIT_PERM_GEN_ALL        109
#define IDS_ACLEDIT_TITLE               110
#define IDS_HELPFILENAME                111
#define IDS_SHAREPERM_READ              112
#define IDS_SHAREPERM_MODIFY            113
#define IDS_SHAREPERM_ALL               114
#define IDS_CSCUI_HELPFILENAME          115
#define IDI_ICON_SHARE                  116
#define IDS_PERMPAGE_TITLE              117
#define IDS_PRIVATE_CONFIRM_DELSHARE    118
#define IDS_PRIVATE_CREATE_PASSWORD     119
#define IDS_SIMPLE_SHARE_HELPFILE       120
#define IDS_SHARE_HELP_SHARING_AND_SECURITY_PER 121
#define IDI_SECURITY                    122
#define IDI_NETWORK                     123
#define IDI_SMALL_EXCL                  124
#define IDS_SHARE_HELP_SHARING_AND_SECURITY_WKS 125
#define IDS_PERM_PROGRESS_TITLE         126
#define IDI_INFO                        127
#define IDD_SHARE_PROPERTIES            1000
#define IDC_SHARE_SHARENAME             1001
#define IDC_SHARE_COMMENT               1002
#define IDC_SHARE_SHARENAME_TEXT        1003
#define IDC_SHARE_COMMENT_TEXT          1004
#define IDC_SHARE_LIMIT                 1005
#define IDC_SHARE_MAXIMUM               1006
#define IDC_SHARE_ALLOW                 1007
#define IDC_SHARE_PERMISSIONS           1008
#define IDC_SHARE_ALLOW_SPIN            1010
#define IDC_SHARE_ALLOW_VALUE           1011
#define IDC_SHARE_REMOVE                1012
#define IDC_SHARE_NOTSHARED             1013
#define IDC_SHARE_SHAREDAS              1014
#define IDC_SHARE_SHARENAME_COMBO       1015
#define IDC_SHARE_NEWSHARE              1017
#define IDD_NEW_SHARE                   1018
#define IDC_SHARE_CACHING               1019
#define IDC_SHARE_CACHING_TEXT          1020
#define IDC_SHARE_ICON                  1021
#define IDC_SHARE_TOPTEXT               1022
#define IDD_SIMPLE_SHARE_PROPERTIES     1025
#define IDC_SIMPLE_SHARE_SECURITY_STATIC 1036
#define IDC_SIMPLE_SHARE_NETWORKING_STATIC 1037
#define IDC_LNK_SHARE_PARENT_PROTECTED  1038
#define IDC_LNK_SHARE_NETWORK_WIZARD    1039
#define IDC_LNK_SHARE_HELP_ON_SECURITY  1040
#define IDC_LNK_SHARE_HELP_SHARING_AND_SECURITY 1041
#define IDC_I_SHARE_INFORMATION         1043
#define IDC_LNK_SHARE_OPEN_SHARED_DOCS  1044
#define IDC_LNK_SHARE_DRIVE_BLOCADE     1045
#define IDC_GB_SECURITY                 1046
#define IDC_GB_NETWORK_SHARING          1047
#define IDC_S_SHARE_SYSTEM_FOLDER       1049
#define IDC_LNK_SHARE_SECURITY_OVERRIDE 1050
#define IDD_SIMPLE_SHARE_ENABLE_WARNING 1051
#define IDC_RB_ENABLE_FILE_SHARING      1052
#define IDC_RB_RUN_THE_WIZARD           1053
#define IDC_ICON_INFO                   1054

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1055
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\ntshrui\ole.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       ole.cxx
//
//  Contents:   Class factory, etc, for all OLE objects:
//              CShare and CShareCopyHook
//
//  History:    6-Apr-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "ole.hxx"
#include "copyhook.hxx"
#include "share.hxx"
#include "dllmain.hxx"

// {f81e9010-6ea4-11ce-a7ff-00aa003ca9f6}
const CLSID CLSID_CShare = {0xf81e9010, 0x6ea4, 0x11ce, 0xa7, 0xff, 0x00, 0xaa, 0x00, 0x3c, 0xa9, 0xf6 };
// {40dd6e20-7c17-11ce-a804-00aa003ca9f6}
const CLSID CLSID_CShareCopyHook = {0x40dd6e20, 0x7c17, 0x11ce, 0xa8, 0x04, 0x00, 0xaa, 0x00, 0x3c, 0xa9, 0xf6};


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

ULONG g_ulcInstancesShare = 0;
ULONG g_ulcInstancesShareCopyHook = 0;

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CShare::QueryInterface(
    IN REFIID riid,
    OUT LPVOID* ppvObj
    )
{
    appDebugOut((DEB_ITRACE, "CShare::QueryInterface..."));

    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IUnknown\n"));
        pUnkTemp = (IUnknown*)(IShellExtInit*) this;    // doesn't matter which
    }
    else
    if (IsEqualIID(IID_IShellExtInit, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IShellExtInit\n"));
        pUnkTemp = (IShellExtInit*) this;
    }
    else
    if (IsEqualIID(IID_IShellPropSheetExt, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IShellPropSheetExt\n"));
        pUnkTemp = (IShellPropSheetExt*) this;
    }
    else
    if (IsEqualIID(IID_IContextMenu, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IContextMenu\n"));
        pUnkTemp = (IContextMenu*) this;
    }
    else
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "unknown interface\n"));
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;

    return hr;
}

STDMETHODIMP_(ULONG)
CShare::AddRef(
    VOID
    )
{
    ULONG cInst = InterlockedIncrement((LONG*)&g_ulcInstancesShare);
    ULONG cRef = InterlockedIncrement((LONG*)&_uRefs);

    appDebugOut((DEB_ITRACE, "CShare::AddRef, local: %d, DLL: %d\n", cRef, cInst ));

    return cRef;
}

STDMETHODIMP_(ULONG)
CShare::Release(
    VOID
    )
{
    appAssert( 0 != g_ulcInstancesShare );
    InterlockedDecrement((LONG*)&g_ulcInstancesShare);

    appAssert( 0 != _uRefs );
    ULONG cRef = InterlockedDecrement((LONG*)&_uRefs);

    appDebugOut((DEB_ITRACE,
        "CShare::Release, local: %d, DLL: %d\n",
        cRef,
        g_ulcInstancesShare));

    if (0 == cRef)
    {
        delete this;
    }

    return cRef;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CShareCF::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    appDebugOut((DEB_ITRACE, "CShareCF::QueryInterface..."));

    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IUnknown\n"));
        pUnkTemp = (IUnknown*) this;
    }
    else if (IsEqualIID(IID_IClassFactory, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IClassFactory\n"));
        pUnkTemp = (IClassFactory*) this;
    }
    else
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "unknown interface\n"));
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;

    return hr;
}


STDMETHODIMP_(ULONG)
CShareCF::AddRef()
{
    ULONG cInst = InterlockedIncrement((LONG*)&g_ulcInstancesShare);
    appDebugOut((DEB_ITRACE, "CShareCF::AddRef, DLL: %d\n", cInst ));
    return cInst;
}

STDMETHODIMP_(ULONG)
CShareCF::Release()
{
    appAssert( 0 != g_ulcInstancesShare );
    InterlockedDecrement((LONG*)&g_ulcInstancesShare);

    appDebugOut((DEB_ITRACE,
        "CShareCF::Release, DLL: %d\n",
        g_ulcInstancesShare));

    return g_ulcInstancesShare;
}

STDMETHODIMP
CShareCF::CreateInstance(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj)
{
    appDebugOut((DEB_ITRACE, "CShareCF::CreateInstance\n"));

    if (pUnkOuter != NULL)
    {
        // don't support aggregation
        return E_NOTIMPL;
    }

    CShare* pShare = new CShare();
    if (NULL == pShare)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pShare->QueryInterface(riid, ppvObj);
    pShare->Release();

    return hr;
}

STDMETHODIMP
CShareCF::LockServer(BOOL fLock)
{
    //
    // FEATURE: Whats supposed to happen here?
    //
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CShareCopyHook::QueryInterface(
    IN REFIID riid,
    OUT LPVOID* ppvObj
    )
{
    appDebugOut((DEB_ITRACE, "CShareCopyHook::QueryInterface..."));

    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IUnknown\n"));
        pUnkTemp = (IUnknown*) this;
    }
    else
    if (IsEqualIID(IID_IShellCopyHook, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "ICopyHook\n"));
        pUnkTemp = (ICopyHook*) this;
    }
    else
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "unknown interface\n"));
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;

    return hr;
}

STDMETHODIMP_(ULONG)
CShareCopyHook::AddRef(
    VOID
    )
{
    ULONG cInst = InterlockedIncrement((LONG*)&g_ulcInstancesShare);
    ULONG cRef = InterlockedIncrement((LONG*)&_uRefs);

    appDebugOut((DEB_ITRACE, "CShareCopyHook::AddRef, local: %d, DLL: %d\n", cRef, cInst ));

    return cRef;
}

STDMETHODIMP_(ULONG)
CShareCopyHook::Release(
    VOID
    )
{
    appAssert( 0 != g_ulcInstancesShare );
    InterlockedDecrement((LONG*)&g_ulcInstancesShare);

    appAssert( 0 != _uRefs );
    ULONG cRef = InterlockedDecrement((LONG*)&_uRefs);

    appDebugOut((DEB_ITRACE,
        "CShareCopyHook::Release, local: %d, DLL: %d\n",
        cRef,
        g_ulcInstancesShare));

    if (0 == cRef)
    {
        delete this;
    }

    return cRef;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CShareCopyHookCF::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    appDebugOut((DEB_ITRACE, "CShareCopyHookCF::QueryInterface..."));

    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IUnknown\n"));
        pUnkTemp = (IUnknown*) this;
    }
    else if (IsEqualIID(IID_IClassFactory, riid))
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "IClassFactory\n"));
        pUnkTemp = (IClassFactory*) this;
    }
    else
    {
        appDebugOut((DEB_ITRACE | DEB_NOCOMPNAME, "unknown interface\n"));
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;

    return hr;
}


STDMETHODIMP_(ULONG)
CShareCopyHookCF::AddRef()
{
    return InterlockedIncrement((LONG*)&g_ulcInstancesShareCopyHook);
}

STDMETHODIMP_(ULONG)
CShareCopyHookCF::Release()
{
    appAssert( 0 != g_ulcInstancesShareCopyHook );
    InterlockedDecrement((LONG*)&g_ulcInstancesShareCopyHook);
    return g_ulcInstancesShareCopyHook;
}

STDMETHODIMP
CShareCopyHookCF::CreateInstance(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj)
{
    appDebugOut((DEB_ITRACE, "CShareCopyHookCF::CreateInstance\n"));

    if (pUnkOuter != NULL)
    {
        // don't support aggregation
        return E_NOTIMPL;
    }

    CShareCopyHook* pShareCopyHook = new CShareCopyHook();
    if (NULL == pShareCopyHook)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pShareCopyHook->QueryInterface(riid, ppvObj);
    pShareCopyHook->Release();

    if (FAILED(hr))
    {
        hr = E_NOINTERFACE; // FEATURE: Whats the error code?
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP
CShareCopyHookCF::LockServer(BOOL fLock)
{
    //
    // FEATURE: Whats supposed to happen here?
    //
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

STDAPI
DllCanUnloadNow(
    VOID
    )
{
    OneTimeInit();

    if (0 == g_ulcInstancesShare
        && 0 == g_ulcInstancesShareCopyHook
        && 0 == g_NonOLEDLLRefs)
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

CShareCF cfShare;
CShareCopyHookCF cfShareCopyHook;

STDAPI
DllGetClassObject(
    REFCLSID cid,
    REFIID iid,
    LPVOID* ppvObj
    )
{
    OneTimeInit();

    appDebugOut((DEB_TRACE, "DllGetClassObject\n"));

    HRESULT hr = E_NOINTERFACE;

    if (IsEqualCLSID(cid, CLSID_CShare))
    {
        hr = cfShare.QueryInterface(iid, ppvObj);
    }
    else if (IsEqualCLSID(cid, CLSID_CShareCopyHook))
    {
        hr = cfShareCopyHook.QueryInterface(iid, ppvObj);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\ntshrui\shrinfo.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       shrinfo.cxx
//
//  Contents:   Lanman SHARE_INFO_502 encapsulation
//
//  History:    21-Feb-95   BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "shrinfo.hxx"
#include "util.hxx"



CShareInfo::CShareInfo(
    VOID
    )
    :
    m_bOwn(TRUE),
    m_flags(0),
    m_pInfo(NULL),
    m_dwCacheFlags (0),
    m_bCachingSupported (true)
{
    INIT_SIG(CShareInfo);
    Close();    // doubly-linked list
}

CShareInfo::CShareInfo(
    IN SHARE_INFO_502* pInfo
    )
    :
    m_bOwn(FALSE),
    m_flags(0),
    m_pInfo(pInfo),
    m_dwCacheFlags (0),
    m_bCachingSupported (true)
{
    INIT_SIG(CShareInfo);
    Close();    // doubly-linked list
}

HRESULT
CShareInfo::InitInstance(
    VOID
    )
{
    CHECK_SIG(CShareInfo);

    if (m_bOwn)
    {
        appAssert(m_pInfo == NULL);

        m_pInfo = new SHARE_INFO_502;
        if (NULL == m_pInfo)
        {
            return E_OUTOFMEMORY;
        }

        m_pInfo->shi502_netname       = NULL;
        m_pInfo->shi502_type          = STYPE_DISKTREE;
        m_pInfo->shi502_remark        = NULL;

        // JonN-543153-2002/04/02
        m_pInfo->shi502_permissions   = ACCESS_READ | ACCESS_EXEC;
        // m_pInfo->shi502_permissions   = ACCESS_ALL;

        m_pInfo->shi502_max_uses      = SHI_USES_UNLIMITED;
        m_pInfo->shi502_path          = NULL;
        m_pInfo->shi502_passwd        = NULL;
        m_pInfo->shi502_reserved      = 0;

        if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
                c_szReadonlyShareSD,
                SDDL_REVISION_1,
                &m_pInfo->shi502_security_descriptor,
                NULL))
        {
            // If we continued here and the user clicked Apply, the share
            // would be wide open (no security).
            return E_ACCESSDENIED;
        }

    }

    return S_OK;
}

CShareInfo::~CShareInfo()
{
    CHECK_SIG(CShareInfo);

    if (m_bOwn)
    {
        if (NULL != m_pInfo)    // must check; InitInstance might have failed
        {
            delete[] m_pInfo->shi502_netname;
            delete[] m_pInfo->shi502_remark;
            delete[] m_pInfo->shi502_path;
            delete[] m_pInfo->shi502_passwd;
            if (NULL != m_pInfo->shi502_security_descriptor)
            {
                ::LocalFree(m_pInfo->shi502_security_descriptor);
                m_pInfo->shi502_security_descriptor = NULL;
            }
            delete m_pInfo;
        }
    }
}

NET_API_STATUS
CShareInfo::Commit(
    IN PWSTR pszMachine
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);
    if (NULL == m_pInfo)
        return E_POINTER; // 2002/03/21-JonN handle this case

    if (m_flags == 0)
    {
        // nothing changed
        appDebugOut((DEB_ITRACE, "CShareInfo::Commit: nothing (%ws)\n", m_pInfo->shi502_netname));
        return NERR_Success;
    }

// #if DBG == 1
//     Dump(L"Commit");
// #endif // DBG == 1

    NET_API_STATUS ret = NERR_Success; // JonN 05/30/00 PREFIX 114205

    // Note: we store a path, even for admin$. However, the NetShare* APIs
    // don't like seeing a path for admin$, so we temporarily strip it here
    // if necessary, before calling any APIs.

    LPWSTR pszPathTmp = m_pInfo->shi502_path;
    if (0 == _wcsicmp(g_szAdminShare, m_pInfo->shi502_netname))
    {
        m_pInfo->shi502_path = NULL;
    }

    if (SHARE_FLAG_ADDED == m_flags)
    {
        appDebugOut((DEB_TRACE, "CShareInfo::Commit: add (%ws)\n", m_pInfo->shi502_netname));
        ret = NetShareAdd(pszMachine, 502, (LPBYTE)m_pInfo, NULL);
        if ( NERR_Success == ret )
            ret = WriteCacheFlags ();
    }
    else if (SHARE_FLAG_REMOVE == m_flags)
    {
        appDebugOut((DEB_TRACE, "CShareInfo::Commit: remove (%ws)\n", m_pInfo->shi502_netname));
        ret = NetShareDel(pszMachine, m_pInfo->shi502_netname, 0);
        if (NERR_NetNameNotFound == ret)
        {
            // Share didn't exist, but we are removing. No problem.
            ret = NERR_Success;
        }
    }
    else if (SHARE_FLAG_MODIFY == m_flags)
    {
        appDebugOut((DEB_TRACE, "CShareInfo::Commit: modify (%ws)\n", m_pInfo->shi502_netname));
        DWORD parm_err;
        ret = NetShareSetInfo(pszMachine, m_pInfo->shi502_netname, 502, (LPBYTE)m_pInfo, &parm_err);
        if ( NERR_Success == ret )
            ret = WriteCacheFlags ();
    }


    // Restore the original, in case of admin$
    m_pInfo->shi502_path = pszPathTmp;

    // Must refresh the cache of shares after all commits
    if (ret != NERR_Success)
    {
        appDebugOut((DEB_TRACE, "CShareInfo::Commit: err = %d\n", ret));
    }

    return ret;
}

SHARE_INFO_502*
CShareInfo::GetShareInfo(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    return m_pInfo;
}

PWSTR
CShareInfo::GetNetname(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);
    
    if ( m_pInfo )
        return m_pInfo->shi502_netname;
    else
        return 0;
}

DWORD
CShareInfo::GetType(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    if ( m_pInfo )
        return m_pInfo->shi502_type;
    else
        return 0;
}

PWSTR
CShareInfo::GetRemark(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    if ( m_pInfo )
        return m_pInfo->shi502_remark;
    else
        return 0;
}

DWORD
CShareInfo::GetMaxUses(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    if ( m_pInfo )
        return m_pInfo->shi502_max_uses;
    else
        return 0;
}

PWSTR
CShareInfo::GetPath(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    if ( m_pInfo )
        return m_pInfo->shi502_path;
    else
        return 0;
}

PSECURITY_DESCRIPTOR
CShareInfo::GetSecurityDescriptor(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(NULL != m_pInfo);

    if ( m_pInfo )
        return m_pInfo->shi502_security_descriptor;
    else
        return 0;
}

HRESULT
CShareInfo::SetNetname(
    IN PWSTR pszNetname
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);
    appAssert(pszNetname && wcslen(pszNetname) <= NNLEN);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetNetname() = '%ws'\n",
        pszNetname));

    delete[] m_pInfo->shi502_netname;
    m_pInfo->shi502_netname = NewDup(pszNetname);

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

HRESULT
CShareInfo::SetType(
    IN DWORD dwType
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (dwType != m_pInfo->shi502_type)
    {
        // only take ownership and set the data if it's changed!

        if (!TakeOwn())
        {
            return E_OUTOFMEMORY;
        }

        appDebugOut((DEB_ITRACE,
            "CShareInfo::SetType(%ws) = %d\n",
            m_pInfo->shi502_netname,
            dwType));

        m_pInfo->shi502_type = dwType;

        if (m_flags != SHARE_FLAG_ADDED)
        {
            m_flags = SHARE_FLAG_MODIFY;
        }
    }

    return S_OK;
}

HRESULT
CShareInfo::SetRemark(
    IN PWSTR pszRemark
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetRemark(%ws) = '%ws'\n",
        m_pInfo->shi502_netname,
        pszRemark));

    delete[] m_pInfo->shi502_remark;
    m_pInfo->shi502_remark = NewDup(pszRemark);

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

HRESULT
CShareInfo::SetMaxUses(
    IN DWORD dwMaxUses
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (dwMaxUses != m_pInfo->shi502_max_uses)
    {
        // only take ownership and set the data if it's changed!

        if (!TakeOwn())
        {
            return E_OUTOFMEMORY;
        }

        appDebugOut((DEB_ITRACE,
            "CShareInfo::SetMaxUses(%ws) = %d\n",
            m_pInfo->shi502_netname,
            dwMaxUses));

        m_pInfo->shi502_max_uses = dwMaxUses;

        if (m_flags != SHARE_FLAG_ADDED)
        {
            m_flags = SHARE_FLAG_MODIFY;
        }
    }

    return S_OK;
}

HRESULT
CShareInfo::SetPath(
    IN PWSTR pszPath
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetPath(%ws) = '%ws'\n",
        m_pInfo->shi502_netname,
        pszPath));

    delete[] m_pInfo->shi502_path;
    if (pszPath[0] == TEXT('\0'))
    {
        m_pInfo->shi502_path = NULL;    // so IPC$ and ADMIN$ work
    }
    else
    {
        m_pInfo->shi502_path = NewDup(pszPath);
    }

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

HRESULT
CShareInfo::SetSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecDesc
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::SetSecurityDescriptor(%ws) = ...\n",
        m_pInfo->shi502_netname));

    PSECURITY_DESCRIPTOR pSDNew;
    HRESULT hr = CopySecurityDescriptor(pSecDesc, &pSDNew);
    if (SUCCEEDED(hr))
    {
        if (NULL != m_pInfo->shi502_security_descriptor)
            ::LocalFree(m_pInfo->shi502_security_descriptor);
        m_pInfo->shi502_security_descriptor = pSDNew;

        if (m_flags != SHARE_FLAG_ADDED)
        {
            m_flags = SHARE_FLAG_MODIFY;
        }
    }

    return hr;
}


// security descriptors alloced via ::LocalAlloc
HRESULT
CShareInfo::TransferSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecDesc
    )
{
    CHECK_SIG(CShareInfo);
    appAssert(m_flags != SHARE_FLAG_REMOVE);

    if (!TakeOwn())
    {
        return E_OUTOFMEMORY;
    }

    appDebugOut((DEB_ITRACE,
        "CShareInfo::TransferSecurityDescriptor(%ws) = ...\n",
        m_pInfo->shi502_netname));

    if (NULL != m_pInfo->shi502_security_descriptor)
        ::LocalFree(m_pInfo->shi502_security_descriptor);
    m_pInfo->shi502_security_descriptor = pSecDesc;

    if (m_flags != SHARE_FLAG_ADDED)
    {
        m_flags = SHARE_FLAG_MODIFY;
    }

    return S_OK;
}

ULONG
CShareInfo::GetFlag(
    VOID
    )
{
    CHECK_SIG(CShareInfo);

    return m_flags;
}

VOID
CShareInfo::SetDirtyFlag(
    ULONG flag
    )
{
    CHECK_SIG(CShareInfo);

    m_flags = flag;
}

HRESULT
CShareInfo::Copy(
    IN SHARE_INFO_502* pInfo
    )
{
    CHECK_SIG(CShareInfo);

    // get a valid SHARE_INFO_502 structure...

    if (m_bOwn)
    {
        // delete what's already there

        appAssert(NULL != m_pInfo);

        delete[] m_pInfo->shi502_netname;
        delete[] m_pInfo->shi502_remark;
        delete[] m_pInfo->shi502_path;
        delete[] m_pInfo->shi502_passwd;
        if (NULL != m_pInfo->shi502_security_descriptor)
        {
            ::LocalFree(m_pInfo->shi502_security_descriptor);
            m_pInfo->shi502_security_descriptor = NULL;
        }
    }
    else
    {
        m_pInfo = new SHARE_INFO_502;
        if (NULL == m_pInfo)
        {
            return E_OUTOFMEMORY;
        }
    }

    appAssert(NULL != m_pInfo);

    m_bOwn = TRUE;

    m_pInfo->shi502_netname       = NULL;
    m_pInfo->shi502_type          = pInfo->shi502_type;
    m_pInfo->shi502_remark        = NULL;
    m_pInfo->shi502_permissions   = pInfo->shi502_permissions;
    m_pInfo->shi502_max_uses      = pInfo->shi502_max_uses;
    m_pInfo->shi502_path          = NULL;
    m_pInfo->shi502_passwd        = NULL;
    m_pInfo->shi502_reserved      = pInfo->shi502_reserved;
    m_pInfo->shi502_security_descriptor = NULL;

    if (NULL != pInfo->shi502_netname)
    {
        m_pInfo->shi502_netname = NewDup(pInfo->shi502_netname);
    }
    if (NULL != pInfo->shi502_remark)
    {
        m_pInfo->shi502_remark = NewDup(pInfo->shi502_remark);
    }
    if (NULL != pInfo->shi502_path)
    {
        m_pInfo->shi502_path = NewDup(pInfo->shi502_path);
    }
    if (NULL != pInfo->shi502_passwd)
    {
        m_pInfo->shi502_passwd = NewDup(pInfo->shi502_passwd);
    }

    if (NULL != pInfo->shi502_security_descriptor)
    {
        CopySecurityDescriptor(pInfo->shi502_security_descriptor, &m_pInfo->shi502_security_descriptor);
    }

    return S_OK;
}

BOOL
CShareInfo::TakeOwn(
    VOID
    )
{
    CHECK_SIG(CShareInfo);

    if (m_pInfo == NULL)
        return FALSE;

    if (m_bOwn)
    {
        return TRUE;    // already own the memory
    }

    SHARE_INFO_502* pInfo = new SHARE_INFO_502;
    if (NULL == pInfo)
    {
        return FALSE;
    }

    pInfo->shi502_type          = m_pInfo->shi502_type;
    pInfo->shi502_permissions   = m_pInfo->shi502_permissions;
    pInfo->shi502_max_uses      = m_pInfo->shi502_max_uses;
    pInfo->shi502_reserved      = 0;

    pInfo->shi502_netname = NULL;
    if (NULL != m_pInfo->shi502_netname)
    {
        pInfo->shi502_netname = NewDup(m_pInfo->shi502_netname);
    }

    pInfo->shi502_remark  = NULL;
    if (NULL != m_pInfo->shi502_remark)
    {
        pInfo->shi502_remark = NewDup(m_pInfo->shi502_remark);
    }

    pInfo->shi502_path    = NULL;
    if (NULL != m_pInfo->shi502_path)
    {
        pInfo->shi502_path = NewDup(m_pInfo->shi502_path);
    }

    pInfo->shi502_passwd  = NULL;
    if (NULL != m_pInfo->shi502_passwd)
    {
        pInfo->shi502_passwd = NewDup(m_pInfo->shi502_passwd);
    }

    pInfo->shi502_security_descriptor = NULL;
    if (NULL != m_pInfo->shi502_security_descriptor)
    {
        CopySecurityDescriptor(m_pInfo->shi502_security_descriptor, &pInfo->shi502_security_descriptor);
    }

    m_pInfo = pInfo;
    m_bOwn = TRUE;

#if DBG == 1
    Dump(L"After TakeOwn");
#endif // DBG == 1

    return TRUE;
}


VOID
DeleteShareInfoList(
    IN CShareInfo* pShareInfoList,
    IN BOOL fDeleteDummyHeadNode
    )
{
    if (NULL == pShareInfoList)
    {
        // allow "deletion" of NULL list
        return;
    }

    for (CShareInfo* p = (CShareInfo*) pShareInfoList->Next();
         p != pShareInfoList;
         )
    {
        CShareInfo* pNext = (CShareInfo*)p->Next();
        delete p;
        p = pNext;
    }

    if (fDeleteDummyHeadNode)
    {
        delete pShareInfoList;
    }
    else
    {
        pShareInfoList->Close();    // reset pointers
    }
}


#if DBG == 1

VOID
CShareInfo::Dump(
    IN PWSTR pszCaption
    )
{
    CHECK_SIG(CShareInfo);

    appDebugOut((DEB_TRACE,
        "CShareInfo::Dump, %ws\n",
        pszCaption));

    appDebugOut((DEB_TRACE | DEB_NOCOMPNAME,
"\t       This: 0x%08lx\n"
"\t       Info: 0x%08lx\n"
"\tOwn memory?: %ws\n"
"\t      Flags: %ws\n"
"\t Share name: %ws\n"
"\t       Type: %d\n"
"\t    Comment: %ws\n"
"\tPermissions: %d\n"
"\t   Max uses: %d\n"
"\t       Path: %ws\n"
"\t   Password: %ws\n"
"\t   Reserved: %d\n"
"\t   Security? %ws\n"
,
this,
m_pInfo,
m_bOwn ? L"yes" : L"no",
(m_flags == 0)
    ? L"none"
    : (m_flags == SHARE_FLAG_ADDED)
        ? L"added"
        : (m_flags == SHARE_FLAG_REMOVE)
            ? L"remove"
            : (m_flags == SHARE_FLAG_MODIFY)
                ? L"modify"
                : L"UNKNOWN!",
(NULL == m_pInfo->shi502_netname) ? L"none" : m_pInfo->shi502_netname,
m_pInfo->shi502_type,
(NULL == m_pInfo->shi502_remark) ? L"none" : m_pInfo->shi502_remark,
m_pInfo->shi502_permissions,
m_pInfo->shi502_max_uses,
(NULL == m_pInfo->shi502_path) ? L"none" : m_pInfo->shi502_path,
(NULL == m_pInfo->shi502_passwd) ? L"none" : m_pInfo->shi502_passwd,
m_pInfo->shi502_reserved,
(NULL == m_pInfo->shi502_security_descriptor) ? L"No" : L"Yes"
));

}

#endif // DBG == 1

DWORD 
CShareInfo::GetCacheFlags(
    VOID
    ) const
{
    CHECK_SIG(CShareInfo);

    return m_dwCacheFlags;
}

void 
CShareInfo::SetCacheFlags(
    DWORD dwFlags
    )
{
    CHECK_SIG(CShareInfo);

    m_dwCacheFlags = dwFlags;
    if ( SHARE_FLAG_ADDED != m_flags )
        m_flags = SHARE_FLAG_MODIFY;
}

//
// These methods cover the separate API to determine whether IntelliMirror
// caching is enabled.  By default (FPNW and SFM) they are disabled.
//
// We read this data at level 501 in order to determine whether the target
// server is NT4.  NetShareGetInfo[1005] actually succeeds on an NT4 server,
// whereas NetShareGetInfo[501] fails with ERROR_INVALID_LEVEL.  We want this
// to fail so that we can disable the checkbox where the underlying
// functionality is not supported.
//
// CODEWORK: If this becomes remotable, we'll need to do a better job of 
//            handling the error case when this method fails.
//
NET_API_STATUS 
CShareInfo::ReadCacheFlags(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    NET_API_STATUS retval = NERR_Success;

    m_dwCacheFlags = 0;
		
    if ( m_bCachingSupported ) // If we've already determined that caching is 
                               // not supported, don't call this again
    {
        SHARE_INFO_501* pshi501 = NULL;
        PWSTR           pwszNetName = GetNetname ();

        if ( pwszNetName && *pwszNetName )
        {
            retval = ::NetShareGetInfo(
                    L"",            // machine name
                    pwszNetName,    // share name
                    501,
                    (LPBYTE*)&pshi501);
            if (NERR_Success == retval)
            {
                if ( pshi501 )
                {
                    m_dwCacheFlags = pshi501->shi501_flags;
                    ::NetApiBufferFree (pshi501);
                }
            }
            else if ( ERROR_INVALID_LEVEL == retval )
            {
                // This share is probably on an NT 4.0 machine and does not 
                // support caching
                m_bCachingSupported = false;
                retval = NERR_Success;
            }
            else if ( NERR_Success != retval )
                m_bCachingSupported = false;
        }
    }
    return retval;
}

NET_API_STATUS 
CShareInfo::WriteCacheFlags(
    VOID
    )
{
    CHECK_SIG(CShareInfo);
    NET_API_STATUS retval = NERR_Success;

    if ( m_bCachingSupported ) // If we've already determined that caching is 
						       // not supported, don't call this again
    {
        SHARE_INFO_1005 shi1005;
        ZeroMemory( &shi1005, sizeof(shi1005) );
        shi1005.shi1005_flags = m_dwCacheFlags;
        DWORD dwDummy = 0;
        retval = ::NetShareSetInfo(
                L"",            // machine name
                GetNetname (),    // share name
                1005,
                (LPBYTE)&shi1005,
                &dwDummy);
        if ( ERROR_INVALID_LEVEL == retval )
        {
            // This share is probably on an NT 4.0 machine and does not support 
            // caching
            m_bCachingSupported = false;
            retval = NERR_Success;
        }
        else if ( NERR_Success != retval )
            m_bCachingSupported = false;
    }

	return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\dlgbase.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dlgbase.cxx
//
//  Contents:   CDialog base class
//
//  History:    19-Oct-94 BruceFo Created.
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "dlgbase.hxx"

//+-------------------------------------------------------------------------
//
//  Method:     CDialog::_WinDlgProc, static private
//
//  Synopsis:   Windows Dialog Procedure
//
//--------------------------------------------------------------------------

INT_PTR CALLBACK
CDialog::_WinDlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CDialog *pPropPage = NULL;

    if (msg==WM_INITDIALOG)
    {
       SetWindowLongPtr(hwnd,GWLP_USERDATA,lParam);
    }

    pPropPage = (CDialog*) GetWindowLongPtr(hwnd,GWLP_USERDATA);

    if (pPropPage != NULL)
    {
        return pPropPage->DlgProc(hwnd,msg,wParam,lParam);
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\ntshrui\permpage.h ===
// PermPage.h : Declaration of the standard permissions page class

#ifndef __PERMPAGE_H_INCLUDED__
#define __PERMPAGE_H_INCLUDED__

#include "aclui.h"

class CSecurityInformation : public ISecurityInformation, public CComObjectRoot
{
    DECLARE_NOT_AGGREGATABLE(CSecurityInformation)
    BEGIN_COM_MAP(CSecurityInformation)
        COM_INTERFACE_ENTRY(ISecurityInformation)
    END_COM_MAP()

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo ) = 0;
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault ) = 0;
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor ) = 0;
    STDMETHOD(GetAccessRights) (const GUID* pguidObjectType,
                                DWORD dwFlags,
                                PSI_ACCESS *ppAccess,
                                ULONG *pcAccesses,
                                ULONG *piDefaultAccess );
    STDMETHOD(MapGeneric) (const GUID *pguidObjectType,
                           UCHAR *pAceFlags,
                           ACCESS_MASK *pMask);
    STDMETHOD(GetInheritTypes) (PSI_INHERIT_TYPE *ppInheritTypes,
                                ULONG *pcInheritTypes );
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage );

protected:
	HRESULT NewDefaultDescriptor(
		PSECURITY_DESCRIPTOR* ppsd,
		SECURITY_INFORMATION RequestedInformation
		);

	// this will throw a memory exception where appropriate
	HRESULT MakeSelfRelativeCopy(
		PSECURITY_DESCRIPTOR  psdOriginal,
		PSECURITY_DESCRIPTOR* ppsdNew );
};

class CShareSecurityInformation : public CSecurityInformation
{
private:
	LPWSTR m_strMachineName;
	LPWSTR m_strShareName;
public:
	void SetMachineName( LPWSTR pszMachineName )
	{
		m_strMachineName = pszMachineName;
	}
	void SetShareName( LPWSTR pszShareName )
	{
		m_strShareName = pszShareName;
	}
	// note: these should be LPCTSTR but are left this way for convenience
	LPWSTR QueryMachineName()
	{
		return m_strMachineName;
	}
	LPWSTR QueryShareName()
	{
		return m_strShareName;
	}

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo );
};

class CSMBSecurityInformation : public CShareSecurityInformation
{
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault );
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor );
public:
	// SHARE_INFO_502* m_pvolumeinfo;
	PSECURITY_DESCRIPTOR m_pInitialDescriptor;
	PSECURITY_DESCRIPTOR* m_ppCurrentDescriptor;
	CSMBSecurityInformation();
	~CSMBSecurityInformation();
};


#endif // ~__PERMPAGE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\ntshrui\share.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       share.cxx
//
//  Contents:   Shell extension handler for sharing
//
//  Classes:    CShare
//
//  History:    4-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "shrpage.hxx"
#include "shrpage2.hxx"

#include "share.hxx"
#include "acl.hxx"
#include "util.hxx"
#include "resource.h"

//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//
//  Member:     CShare::CShare
//
//  Synopsis:   Constructor
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

CShare::CShare(VOID) :
    _uRefs(0),
    _fPathChecked(FALSE),
    _fMultipleSharesSelected (FALSE)
{
    INIT_SIG(CShare);
    AddRef(); // give it the correct initial reference count. add to the DLL reference count
    _szPath[0] = 0;
}


//+-------------------------------------------------------------------------
//
//  Member:     CShare::~CShare
//
//  Synopsis:   Destructor
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

CShare::~CShare()
{
    CHECK_SIG(CShare);
}

//
//  Retrieve a PIDL from the HIDA.
//
STDAPI_(LPITEMIDLIST) 
IDA_FullIDList(
      CIDA * pidaIn
    , UINT idxIn
    )
{
    LPITEMIDLIST pidl = NULL;
    LPCITEMIDLIST pidlParent = IDA_GetIDListPtr( pidaIn, (UINT) -1 );
    if ( NULL != pidlParent )
    {
        LPCITEMIDLIST pidlRel = IDA_GetIDListPtr( pidaIn, idxIn );
        if ( NULL != pidlRel )
        {
            pidl = ILCombine( pidlParent, pidlRel );
        }
    }

    return pidl;
}

//+-------------------------------------------------------------------------
//
//  Member:     CShare::Initialize
//
//  Derivation: IShellExtInit
//
//  Synopsis:   Initialize the shell extension. Stashes away the argument data.
//
//  History:    4-Apr-95    BruceFo  Created
//
//  Notes:      This method can be called more than once.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CShare::Initialize(
    LPCITEMIDLIST   /*pidlFolder*/,
    LPDATAOBJECT    pDataObject,
    HKEY            /*hkeyProgID*/
    )
{
    CHECK_SIG(CShare);

    HRESULT hr = E_FAIL;

    if (pDataObject && _szPath[0] == 0)
    {
        STGMEDIUM medium;
        FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        hr = pDataObject->GetData(&fmte, &medium);
        if (SUCCEEDED(hr))
        {
            // Get the count of shares that have been selected.  Display the page only
            // if 1 share is selected but not for multiple shares.
            UINT nCntFiles = ::DragQueryFile((HDROP) medium.hGlobal, (UINT)-1, _szPath, ARRAYLEN (_szPath));
            if ( nCntFiles > 1 )
            {
                _fMultipleSharesSelected = TRUE;
            }

            DragQueryFile((HDROP)medium.hGlobal, 0, _szPath, ARRAYLEN(_szPath));
            ReleaseStgMedium(&medium);

            hr = S_OK;
        }
    }

    if (FAILED(hr) && _szPath[0] == 0 )
    {
        STGMEDIUM med;
        LPIDA pida = DataObj_GetHIDA(pDataObject, &med);
        if (pida)
        {
            if (pida->cidl > 1)
            {
                _fMultipleSharesSelected = TRUE;
            }

            //  Only grab the first guy.
            LPITEMIDLIST pidl = IDA_FullIDList( pida, 0 );
            if ( NULL != pidl )
            {
                LPCITEMIDLIST pidlParent = IDA_GetIDListPtr( pida, (UINT) -1 );
                if (NULL != pidlParent)
                {
                    IShellFolder * psf;
                    LPCITEMIDLIST pidlLast;

                    hr = SHBindToParent(pidl, IID_IShellFolder, (void**)&psf, &pidlLast);
                    if (SUCCEEDED(hr))
                    {
                        hr = DisplayNameOf(psf, pidlLast, SHGDN_NORMAL | SHGDN_FORPARSING, _szPath, ARRAYLEN(_szPath));

                        psf->Release();
                    }
                }
                ILFree(pidl);
            }

            HIDA_ReleaseStgMedium(pida, &med);
        }
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CShare::AddPages
//
//  Derivation: IShellPropSheetExt
//
//  Synopsis:   (from shlobj.h)
//              "The explorer calls this member function when it finds a
//              registered property sheet extension for a particular type
//              of object. For each additional page, the extension creates
//              a page object by calling CreatePropertySheetPage API and
//              calls lpfnAddPage.
//
//  Arguments:  lpfnAddPage -- Specifies the callback function.
//              lParam -- Specifies the opaque handle to be passed to the
//                        callback function.
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

STDMETHODIMP
CShare::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM               lParam
    )
{
    CHECK_SIG(CShare);

    if (!_fMultipleSharesSelected && _OKToShare())
    {
        //
        //  Create a property sheet page object from a dialog box.
        //

        BOOL bSimpleUI = IsSimpleUI();

        CShareBase* pPage = NULL;
        if (bSimpleUI)
        {
            pPage = new CSimpleSharingPage();
        }
        else
        {
            pPage = new CSharingPropertyPage(FALSE);
        }

        if (NULL != pPage)
        {
            appAssert(_szPath[0]);

            HRESULT hr = pPage->InitInstance(_szPath);
            if (SUCCEEDED(hr))
            {
                PROPSHEETPAGE psp;

                psp.dwSize      = sizeof(psp);    // no extra data.
                psp.dwFlags     = PSP_USEREFPARENT | PSP_USECALLBACK;
                psp.hInstance   = g_hInstance;
                psp.pszTemplate = bSimpleUI ? MAKEINTRESOURCE(IDD_SIMPLE_SHARE_PROPERTIES) : MAKEINTRESOURCE(IDD_SHARE_PROPERTIES);
                psp.hIcon       = NULL;
                psp.pszTitle    = NULL;
                psp.pfnDlgProc  = CShareBase::DlgProcPage;
                psp.lParam      = (LPARAM)pPage;  // transfer ownership
                psp.pfnCallback = CShareBase::PageCallback;
                psp.pcRefParent = &g_NonOLEDLLRefs;

                // This AddRef's pPage.  See CShareBase::PageCallback.
                HPROPSHEETPAGE hpage = CreatePropertySheetPage(&psp);
                if (NULL != hpage)
                {
                    BOOL fAdded = (*lpfnAddPage)(hpage, lParam);
                    if (!fAdded)
                    {
                        // This Release's pPage.
                        DestroyPropertySheetPage(hpage);
                    }
                    // else the property sheet has a reference to pPage.
                }
            }

            // Release initial ref. This frees pPage is anything failed above.
            pPage->Release();
        }
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CShare::ReplacePages
//
//  Derivation: IShellPropSheetExt
//
//  Synopsis:   (From shlobj.h)
//              "The explorer never calls this member of property sheet
//              extensions. The explorer calls this member of control panel
//              extensions, so that they can replace some of default control
//              panel pages (such as a page of mouse control panel)."
//
//  Arguments:  uPageID -- Specifies the page to be replaced.
//              lpfnReplace -- Specifies the callback function.
//              lParam -- Specifies the opaque handle to be passed to the
//                        callback function.
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

STDMETHODIMP
CShare::ReplacePage(
    UINT                 /*uPageID*/,
    LPFNADDPROPSHEETPAGE /*lpfnReplaceWith*/,
    LPARAM               /*lParam*/
    )
{
    CHECK_SIG(CShare);

    appAssert(!"CShare::ReplacePage called, not implemented");
    return E_NOTIMPL;
}



//+-------------------------------------------------------------------------
//
//  Member:     CShare::QueryContextMenu
//
//  Derivation: IContextMenu
//
//  Synopsis:   Called when shell wants to add context menu items.
//
//  History:    4-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

STDMETHODIMP
CShare::QueryContextMenu(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT /*idCmdLast*/,
    UINT uFlags
    )
{
    CHECK_SIG(CShare);

    if ((hmenu == NULL) || (uFlags & (CMF_DEFAULTONLY | CMF_VERBSONLY)))
    {
        return S_OK;
    }

    int  cNumberAdded = 0;
    UINT idCmd        = idCmdFirst;

    // 159891 remove context menu if multiple shares selected
    if (!_fMultipleSharesSelected && _OKToShare())
    {
        appAssert(_szPath[0]);

        WCHAR szShareMenuItem[50];
        LoadString(g_hInstance, IDS_SHARING, szShareMenuItem, ARRAYLEN(szShareMenuItem));

        if (InsertMenu(hmenu, indexMenu, MF_STRING | MF_BYPOSITION, idCmd++, szShareMenuItem))
        {
            cNumberAdded++;
            InsertMenu(hmenu, indexMenu, MF_SEPARATOR | MF_BYPOSITION, 0, NULL);
        }
    }
    return ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, (USHORT)cNumberAdded));
}



//+-------------------------------------------------------------------------
//
//  Member:     CShare::InvokeCommand
//
//  Derivation: IContextMenu
//
//  Synopsis:   Called when the shell wants to invoke a context menu item.
//
//  History:    4-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

STDMETHODIMP
CShare::InvokeCommand(
    LPCMINVOKECOMMANDINFO pici
    )
{
    CHECK_SIG(CShare);

    HRESULT hr = E_INVALIDARG;  // assume error.

    if (0 == HIWORD(pici->lpVerb))
    {
        appAssert(_szPath[0]);
        hr = ShowShareFolderUIW(pici->hwnd, _szPath);
    }
    else
    {
        // FEATURE: compare the strings if not a MAKEINTRESOURCE?
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CShare::GetCommandString
//
//  Derivation: IContextMenu
//
//  Synopsis:   Called when the shell wants to get a help string or the
//              menu string.
//
//  History:    4-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

STDMETHODIMP
CShare::GetCommandString(
    UINT_PTR    /*idCmd*/,
    UINT        uType,
    UINT*       /*pwReserved*/,
    LPSTR       pszName,
    UINT        cchMax
    )
{
    CHECK_SIG(CShare);

    if (uType == GCS_HELPTEXT)
    {
        LoadStringW(g_hInstance, IDS_MENUHELP, (LPWSTR)pszName, cchMax);
        return NOERROR;
    }
    else
    {
        LoadStringW(g_hInstance, IDS_SHARING, (LPWSTR)pszName, cchMax);
        return NOERROR;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CShare::_OKToShare
//
//  Synopsis:   Determine if it is ok to share the current object. It stashes
//              away the current path by querying the cached IDataObject.
//
//  History:    4-Apr-95    BruceFo  Created
//
//--------------------------------------------------------------------------

BOOL
CShare::_OKToShare(VOID)
{
    CHECK_SIG(CShare);

    if (!_fPathChecked)
    {
        _fPathChecked = TRUE;
        _fOkToSharePath = (S_OK == CanShareFolderW(_szPath));
    }

    return _fOkToSharePath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\ntshrui\shrpage.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       shrpage.cxx
//
//  Contents:   "Sharing" shell property page extension
//
//  History:    6-Apr-95        BruceFo     Created
//              12-Jul-00       JonN        fixed 140878, MSG_MULTIDEL debounce
//              06-Oct-00       jeffreys    Split CShareBase out of CSharingPropertyPage
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "helpids.h"
#include "dlgnew.hxx"
#include "cache.hxx"
#include "share.hxx"
#include "acl.hxx"
#include "shrinfo.hxx"
#include "shrpage.hxx"
#include "util.hxx"



void _MyShow( HWND hwndParent, INT idControl, BOOL fShow )
{
    HWND hwndChild = GetDlgItem( hwndParent, idControl );
    appAssert( NULL != hwndChild );
    ShowWindow( hwndChild, (fShow) ? SW_SHOW : SW_HIDE );
    EnableWindow( hwndChild, fShow );
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CShareBase::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CShareBase, IOleWindow),                   // IID_IOleWindow
        { 0 }
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CShareBase::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShareBase::Release()
{
    appAssert( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CShareBase::GetWindow(HWND *phwnd)
{
    *phwnd = _GetFrameWindow();
    return S_OK;
}

STDMETHODIMP CShareBase::ContextSensitiveHelp(BOOL /*fEnterMode*/)
{
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::PageCallback, static public
//
//  Synopsis:
//
//--------------------------------------------------------------------------

UINT CALLBACK
CShareBase::PageCallback(
    IN HWND /*hwnd*/,
    IN UINT uMsg,
    IN LPPROPSHEETPAGE ppsp
    )
{
    CShareBase* pThis = (CShareBase*)ppsp->lParam;

    switch (uMsg)
    {
    case PSPCB_CREATE:
        return 1;       // allow creation

    case PSPCB_RELEASE:
        appAssert(NULL != pThis);
        pThis->Release();
        break;

    case PSPCB_ADDREF:
        appAssert(NULL != pThis);
        pThis->AddRef();
        break;

    default:
        appDebugOut((DEB_ERROR, "CShareBase::PageCallback, unknown page callback message %d\n", uMsg));
        break;
    } // end switch

    return 0;
}

//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::DlgProcPage, static public
//
//  Synopsis:   Dialog Procedure for all sharing dialogs/pages
//
//--------------------------------------------------------------------------

INT_PTR CALLBACK
CShareBase::DlgProcPage(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CShareBase* pThis = NULL;

    if (msg==WM_INITDIALOG)
    {
        PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
        pThis = (CShareBase*)psp->lParam;
        SetWindowLongPtr(hwnd,GWLP_USERDATA,(LPARAM)pThis);
    }
    else
    {
        pThis = (CShareBase*) GetWindowLongPtr(hwnd,GWLP_USERDATA);
    }

    if (pThis != NULL)
    {
        return pThis->_PageProc(hwnd,msg,wParam,lParam);
    }
    else
    {
        return FALSE;
    }
}


//+--------------------------------------------------------------------------
//
//  Method:     CShareBase::CShareBase, public
//
//  Synopsis:   Constructor
//
//---------------------------------------------------------------------------

CShareBase::CShareBase(
    IN BOOL bDialog     // called as a dialog, not a property page?
    )
    :
    _cRef(1),
    _pszPath(NULL),
    _hwndPage(NULL),
    _fInitializingPage(0),  // JonN 7/11/00 140878
    _bDirty(FALSE),
    _pInfoList(NULL),
    _pReplaceList(NULL),
    _pCurInfo(NULL),
    _cShares(0),
    _bNewShare(TRUE),
    _bDialog(bDialog)
{
    INIT_SIG(CShareBase);
}


//+--------------------------------------------------------------------------
//
//  Method:     CShareBase::~CShareBase, public
//
//  Synopsis:   Destructor
//
//---------------------------------------------------------------------------

CShareBase::~CShareBase()
{
    CHECK_SIG(CShareBase);

    // delete the the list of shares
    appAssert(NULL != _pInfoList);
    DeleteShareInfoList(_pInfoList, TRUE);
    _pInfoList = NULL;
    _pCurInfo = NULL;

    // delete the "replacement" list
    appAssert(NULL != _pReplaceList);
    DeleteShareInfoList(_pReplaceList, TRUE);
    _pReplaceList = NULL;

    delete[] _pszPath;
    _pszPath = NULL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::InitInstance, public
//
//  Synopsis:   Part II of the constuctor process
//
//  Notes:      We don't want to handle any errors in constuctor, so this
//              method is necessary for the second phase error detection.
//
//--------------------------------------------------------------------------

HRESULT
CShareBase::InitInstance(
    IN PCWSTR pszPath
    )
{
    CHECK_SIG(CShareBase);
    appDebugOut((DEB_ITRACE, "CShareBase::InitInstance\n"));

    _pszPath = NewDup(pszPath);
    if (NULL == _pszPath)
    {
        return E_OUTOFMEMORY;
    }

    _pInfoList = new CShareInfo();  // dummy head node
    if (NULL == _pInfoList)
    {
        return E_OUTOFMEMORY;
    }

    _pReplaceList = new CShareInfo();  // dummy head node
    if (NULL == _pReplaceList)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_PageProc, private
//
//  Synopsis:   Dialog Procedure for this object
//
//--------------------------------------------------------------------------

BOOL
CShareBase::_PageProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CHECK_SIG(CShareBase);

    switch (msg)
    {
    case WM_INITDIALOG:
        _hwndPage = hwnd;
        //
        // We know this drive is allowed to be shared. However, someone may
        // have changed the number or characteristics of the share using the
        // command line or winfile or server manager or the new file server
        // tool, and the cache may not have been refreshed. Force a refresh
        // now, to pick up any new shares for this path.
        //
        // Note that for the SharingDialog() API, this is the first time the
        // cache gets loaded. If the server is not running, we nuke the dialog
        // and return an error code.
        //
        g_ShareCache.Refresh();
        if (_bDialog && !g_fSharingEnabled)
        {
            EndDialog(hwnd, -1);
        }
        _ConstructShareList();
        return _OnInitDialog(hwnd, (HWND)wParam, lParam);

    case WM_COMMAND:
        return _OnCommand(hwnd, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);

    case WM_NOTIFY:
        return _OnNotify(hwnd, (int)wParam, (LPNMHDR)lParam);

    case WM_HELP:
        return _OnHelp(hwnd, (LPHELPINFO)lParam);

    case WM_CONTEXTMENU:
        return _OnContextMenu(hwnd, (HWND)wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
    } // end switch (msg)

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_OnCommand, private
//
//  Synopsis:   WM_COMMAND handler
//
//--------------------------------------------------------------------------

BOOL
CShareBase::_OnCommand(
    IN HWND hwnd,
    IN WORD /*wNotifyCode*/,
    IN WORD wID,
    IN HWND /*hwndCtl*/
    )
{
    CHECK_SIG(CShareBase);

//
// Commands only used when this page is invoked as a dialog box, via the
// SharingDialog() API:
//
    if (_bDialog)
    {
        switch (wID)
        {
        case IDCANCEL:
            if (!_DoCancel(hwnd))
            {
                // We might consider not going away. But instead, go away anyway.
            }
            EndDialog(hwnd, FALSE);
            return TRUE;

        case IDOK:
            if (!_ValidatePage(hwnd))
            {
                // don't go away
                return TRUE;
            }
            if (!_DoApply(hwnd, TRUE))
            {
                // don't go away
                return TRUE;
            }
            EndDialog(hwnd, TRUE);
            return TRUE;

        default:
            break;
        }
    }

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_OnNotify, private
//
//  Synopsis:   WM_NOTIFY handler
//
//--------------------------------------------------------------------------

BOOL
CShareBase::_OnNotify(
    IN HWND hwnd,
    IN int /*idCtrl*/,
    IN LPNMHDR phdr
    )
{
    CHECK_SIG(CShareBase);

    // assume a property sheet notification
    return _OnPropertySheetNotify(hwnd, phdr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_OnPropertySheetNotify, private
//
//  Synopsis:   WM_NOTIFY handler for the property sheet notification
//
//--------------------------------------------------------------------------

BOOL
CShareBase::_OnPropertySheetNotify(
    IN HWND hwnd,
    IN LPNMHDR phdr
    )
{
    CHECK_SIG(CShareBase);

    switch (phdr->code)
    {
    case PSN_RESET:         // cancel
        if (_DoCancel(hwnd))
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR); // go away
        }
        else
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID);
        }
        return TRUE;

    case PSN_KILLACTIVE:    // change to another page
        if (_ValidatePage(hwnd))
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
            return FALSE;
        }
        else
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            return TRUE;
        }

    case PSN_APPLY:
        if (_DoApply(hwnd, !!(((LPPSHNOTIFY)phdr)->lParam)))
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR); // go away
        }
        else
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID);
        }
        return TRUE;

    } // end switch (phdr->code)

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_DoApply, public
//
//  Synopsis:   If anything has changed, apply the data
//
//--------------------------------------------------------------------------

BOOL
CShareBase::_DoApply(
    IN HWND /*hwnd*/,
    IN BOOL /*bClose*/
    )
{
    CHECK_SIG(CShareBase);

    if (_bDirty)
    {
        _bDirty = FALSE;
        PropSheet_UnChanged(_GetFrameWindow(),_hwndPage);
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_DoCancel, public
//
//  Synopsis:   Do whatever is necessary to cancel the changes
//
//--------------------------------------------------------------------------

BOOL
CShareBase::_DoCancel(
    IN HWND /*hwnd*/
    )
{
    CHECK_SIG(CShareBase);

    if (_bDirty)
    {
        _bDirty = FALSE;
        PropSheet_UnChanged(_GetFrameWindow(),_hwndPage);
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_MarkPageDirty, private
//
//  Synopsis:   A change has made such that the page is now dirty
//
//--------------------------------------------------------------------------

VOID
CShareBase::_MarkPageDirty(
    VOID
    )
{
    CHECK_SIG(CShareBase);

    if (!_fInitializingPage)
    {
        if (!_bDirty)
        {
            appDebugOut((DEB_ITRACE, "Marking Sharing page dirty\n"));
            _bDirty = TRUE;
            PropSheet_Changed(_GetFrameWindow(),_hwndPage);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_ConnstructShareList, private
//
//  Synopsis:   Construct the list of shares for the current path by
//              iterating through the entire cache of shares and adding an
//              element for every path that matches.
//
//--------------------------------------------------------------------------

HRESULT
CShareBase::_ConstructShareList(
    VOID
    )
{
    CHECK_SIG(CShareBase);
    appDebugOut((DEB_ITRACE, "_ConstructShareList\n"));

    // This routine sets _cShares, and _bNewShare, and adds to
    // the _pInfoList list

    HRESULT hr;

    DeleteShareInfoList(_pInfoList);
    _pCurInfo = NULL;
    _bNewShare = FALSE;
    _cShares = 0;

    appAssert(_pInfoList->IsSingle());
    appAssert(_pCurInfo == NULL);
    appAssert(_pszPath != NULL);

    hr = g_ShareCache.ConstructList(_pszPath, _pInfoList, &_cShares);

    if (SUCCEEDED(hr) && _cShares == 0)
    {
        // There are no existing shares. Construct an element to be used
        // by the UI to stash the new share's data

        hr = _ConstructNewShareInfo();
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_ConstructNewShareInfo, private
//
//  Synopsis:   Construct an element to be used by the UI to stash the new
//              share's data
//
//--------------------------------------------------------------------------

HRESULT
CShareBase::_ConstructNewShareInfo(
    VOID
    )
{
    CHECK_SIG(CShareBase);
    HRESULT hr;

    CShareInfo* pNewInfo = new CShareInfo();
    if (NULL == pNewInfo)
    {
        return E_OUTOFMEMORY;
    }

    hr = pNewInfo->InitInstance();
    CHECK_HRESULT(hr);
    if (FAILED(hr))
    {
        delete pNewInfo;
        return hr;
    }

    hr = pNewInfo->SetPath(_pszPath);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
    {
        delete pNewInfo;
        return hr;
    }

    // NTRAID#NTBUG9-603727-2002/04/15 JonN
    // There is no point in calling ReadCacheFlags, since the
    // netname has not been set.
    NET_API_STATUS    ret = pNewInfo->ReadCacheFlags ();
    appAssert( NERR_Success == ret );
    /*
    if ( NERR_Success != ret )
    {
        delete pNewInfo;
        return HRESULT_FROM_WIN32 (ret);
    }
    */

    _bNewShare = TRUE;

    pNewInfo->SetDirtyFlag(SHARE_FLAG_ADDED);
    pNewInfo->InsertBefore(_pInfoList);

    //NOTE: leave the count of shares to be zero. The count of shares only
    // reflects the number of committed shares (?)

    // Get the shell's name for the folder to use as the share name. This
    // gives us localized names for things like "Shared Documents".
    //
    // Sometimes the shell's name contains invalid characters, such
    // as when we're looking at the root of the drive. In that case
    // SHGetFileInfo returns "label (X:)" and IsValidShareName fails
    // on the colon. For those, try calling shell32's PathCleanupSpec
    // to make the name valid.
    //
    // If SHGetFileInfo and PathCleanupSpec fail to give us a good name,
    // fall back on the old method, which is...
    //
    // Give the share a default name. For paths like "X:\", use the default
    // "X", for paths like "X:\foo\bar\baz", use the default "baz".
    // For everything else, juse leave it blank. Also, check that the
    // computed default is not already a share name. If it is, leave it
    // blank.

    appAssert(NULL != _pszPath);

    WCHAR szDefault[2] = L"";
    PWSTR pszDefault = NULL;
    SHFILEINFOW sfi = {0};

    if (SHGetFileInfoW(_pszPath, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME))
    {
        if (IsValidShareName(sfi.szDisplayName, &hr))
        {
            pszDefault = sfi.szDisplayName;
        }
        else
        {
            int iResult = PathCleanupSpec(NULL, sfi.szDisplayName);
            if (0 == (iResult & (PCS_TRUNCATED|PCS_PATHTOOLONG|PCS_FATAL))
                && IsValidShareName(sfi.szDisplayName, &hr))
            {
                pszDefault = sfi.szDisplayName;
            }
        }
        //
        // NTRAID#NTBUG9-225755-2000/12/19-jeffreys
        // NTRAID#NTBUG9-479914-2001/11/07-jeffreys
        //
        // Win9x boxes can't see the share if the name is long
        //
        if (NULL != pszDefault && !IsValidWin9xShareLength(pszDefault))
        {
            // Go back to the old way below
            pszDefault = NULL;
        }
    }
    if (NULL == pszDefault)
    {
        int len = lstrlenW(_pszPath);
        if (len == 3 && _pszPath[1] == L':' && _pszPath[2] == L'\\')
        {
            szDefault[0] = _pszPath[0];
            szDefault[1] = L'\0';
            pszDefault = szDefault;
        }
        else
        {
            PWSTR pszTmp = wcsrchr(_pszPath, L'\\');
            if (pszTmp != NULL)
            {
                pszTmp++;   // skip L'\\'
                if (IsValidShareName(pszTmp, &hr))
                {
                    pszDefault = pszTmp;
                }
                else
                {
                    // NTRAID#NTBUG9-513408-2002/01/07-jeffreys
                    //
                    // The path is presumably valid, so is unlikely to contain
                    // invalid characters.  The more likely answer is that the
                    // directory name is too long.  In that case, truncate.

                    if (wcslen(pszTmp) > NNLEN)
                    {
                        appAssert(ARRAYLEN(sfi.szDisplayName) > NNLEN);
                        lstrcpynW(sfi.szDisplayName, pszTmp, NNLEN+1);
                        if (IsValidShareName(sfi.szDisplayName, &hr))
                        {
                            pszDefault = sfi.szDisplayName;
                        }
                    }
                }
            }
        }
    }

    if (NULL == pszDefault || g_ShareCache.IsShareNameUsed(pszDefault))
    {
        pszDefault = szDefault;
        szDefault[0] = L'\0';
    }

    hr = pNewInfo->SetNetname(pszDefault);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
    {
        // FEATURE: error handling?
        _bNewShare = FALSE;
        pNewInfo->Unlink();
        delete pNewInfo;
        return hr;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_ValidateNewShareName, protected
//
//  Synopsis:   Return TRUE if the sharename is valid, performing
//              confirmations if necessary
//
//--------------------------------------------------------------------------

BOOL
CShareBase::_ValidateNewShareName(
    VOID
    )
{
    CHECK_SIG(CShareBase);

    if (!_bNewShare)
    {
        // nothing to do
        return TRUE;
    }

    appAssert(NULL != _pCurInfo);
    if (NULL == _pCurInfo) // JonN 5/2/01 384155
        return FALSE;

    PWSTR pszShareName = _pCurInfo->GetNetname();
    appAssert(NULL != pszShareName);

    if ((NULL == pszShareName) || (0 == wcslen(pszShareName))) // PREFIX 240253
    {
        MyErrorDialog(_hwndPage, IERR_BlankShareName);
        return FALSE;
    }

    HRESULT uTemp;
    if (!IsValidShareName(pszShareName, &uTemp))
    {
        MyErrorDialog(_hwndPage, uTemp);
        return FALSE;
    }

    // Trying to create a reserved share?
    if (0 == _wcsicmp(g_szIpcShare,   pszShareName))
    {
        MyErrorDialog(_hwndPage, IERR_SpecialShare);
        return FALSE;
    }

    if (0 == _wcsicmp(g_szAdminShare, pszShareName))
    {
        // We will let the admin create the admin$ share if they create
        // it in the directory specified by GetWindowsDirectory().
        WCHAR szWindowsDir[MAX_PATH];
        UINT err = GetWindowsDirectory(szWindowsDir, ARRAYLEN(szWindowsDir));
        if (err == 0)
        {
            // oh well, give them this error
            MyErrorDialog(_hwndPage, IERR_SpecialShare);
            return FALSE;
        }

        if (0 != _wcsicmp(_pCurInfo->GetPath(), szWindowsDir))
        {
            MyErrorDialog(_hwndPage, IERR_SpecialShare);
            return FALSE;
        }

        // otherwise, it is the right directory. Let them create it.
    }

    /* removed JonN 10/5/98
    // Check for downlevel accessibility
    // we should really get rid of this at some point -- JonN 7/18/97
    ULONG nType;
    if (NERR_Success != NetpPathType(NULL, pszShareName, &nType, INPT_FLAGS_OLDPATHS))
    {
        DWORD id = MyConfirmationDialog(
                        _hwndPage,
                        IERR_InaccessibleByDos,
                        MB_YESNO | MB_ICONEXCLAMATION,
                        pszShareName);
        if (id == IDNO)
        {
            return FALSE;
        }
    }
    */

    WCHAR szOldPath[PATHLEN+1];

    if (g_ShareCache.IsExistingShare(pszShareName, _pCurInfo->GetPath(),
                szOldPath, ARRAYLEN(szOldPath))) // 585682-2002/04/12-JonN
    {
        DWORD id = ConfirmReplaceShare(_hwndPage, pszShareName, szOldPath, _pCurInfo->GetPath());
        if (id != IDYES)
        {
            return FALSE;
        }

        // User said to replace the old share. We need to add
        // a "delete" record for the old share.

        HRESULT hr;

        CShareInfo* pNewInfo = new CShareInfo();
        if (NULL == pNewInfo)
        {
            return FALSE;
        }

        hr = pNewInfo->InitInstance();
        CHECK_HRESULT(hr);
        if (FAILED(hr))
        {
            delete pNewInfo;
            return FALSE;
        }

        // only need net name for delete; ignore other fields
        hr = pNewInfo->SetNetname(pszShareName);
        CHECK_HRESULT(hr);
        if (FAILED(hr))
        {
            delete pNewInfo;
            return FALSE;
        }

        hr = pNewInfo->SetPath(szOldPath);
        CHECK_HRESULT(hr);
        if (FAILED(hr))
        {
            delete pNewInfo;
            return FALSE;
        }

        // NTRAID#NTBUG9-603727-2002/04/15 JonN
        // We should fail-through if this API fails,
        //   since the caller is unlikely to use that field.
        //   It matters because the API could fail
        //   and cause _ValidateNewShareName to fail.
        NET_API_STATUS    ret = pNewInfo->ReadCacheFlags ();
        appAssert( NERR_Success == ret );
        /*
        if ( NERR_Success != ret )
        {
            delete pNewInfo;
            return HRESULT_FROM_WIN32 (ret);
        }
        */

        pNewInfo->SetDirtyFlag(SHARE_FLAG_REMOVE);
        pNewInfo->InsertBefore(_pReplaceList); // add to end of replace list
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CShareBase::_CommitShares, protected
//
//  Synopsis:   Commit outstanding share edits.  Note that this method does
//              not reset _bDirty.
//
//--------------------------------------------------------------------------

VOID
CShareBase::_CommitShares(
    IN BOOL bNotShared
    )
{
    CShareInfo* p;

    CHECK_SIG(CShareBase);

    if (!_bDirty)
    {
        // nothing to do
        return;
    }

    if (bNotShared)
    {
        // When the user hits "Not Shared" after having had "Shared As"
        // selected, we don't actually delete anything (or even mark it
        // for deletion). This is so the user can hit "Shared As" again
        // and they haven't lost anything. However, if they subsequently
        // apply changes, we must go through and actually delete anything
        // that they wanted to delete. So, fix up our list to do this.
        // Delete SHARE_FLAG_ADDED nodes, and mark all others as
        // SHARE_FLAG_REMOVE.

        for (p = (CShareInfo*) _pInfoList->Next();
             p != _pInfoList;
             )
        {
            CShareInfo* pNext = (CShareInfo*)p->Next();

            if (p->GetFlag() == SHARE_FLAG_ADDED)
            {
                // get rid of p
                p->Unlink();
                delete p;
            }
            else
            {
                p->SetDirtyFlag(SHARE_FLAG_REMOVE);
            }

            p = pNext;
        }
    }

    //
    // Commit the changes!
    //

    // Delete all "replace" shares first. These are all the shares whos
    // names are being reused to share a different directory.
    // These replace deletes have already been confirmed.

    for (p = (CShareInfo*) _pReplaceList->Next();
         p != _pReplaceList;
         p = (CShareInfo*) p->Next())
    {
        appAssert(p->GetFlag() == SHARE_FLAG_REMOVE);
        NET_API_STATUS ret = p->Commit(NULL);
        if (ret != NERR_Success)
        {
            DisplayError(_hwndPage, IERR_CANT_DEL_SHARE, ret, p->GetNetname());
            // We've got a problem here because we couldn't delete a
            // share that will be added subsequently. Oh well...
        }

        // Note that we don't delete this list because we need to notify
        // the shell (*after* all changes) that all these guys have
        // changed (and get rid of those little hands)...
        //
        // REVIEW: (jeffreys) I see no reason why we can't issue change
        // notifications for these right here.  Why wait?
    }

    // Now, do all add/delete/modify of the current

    for (p = (CShareInfo*) _pInfoList->Next();
         p != _pInfoList;
         )
    {
        CShareInfo* pNext = (CShareInfo*)p->Next();

        if (0 != p->GetFlag())
        {
            if (SHARE_FLAG_REMOVE == p->GetFlag())
            {
                // confirm the delete, if there are connections
                DWORD id = ConfirmStopShare(_hwndPage, MB_YESNO, p->GetNetname());
                if (id != IDYES)
                {
                    p->SetDirtyFlag(0);  // don't do anything to it
                }
            }

            NET_API_STATUS ret = p->Commit(NULL);
            if (ret != NERR_Success)
            {
                HRESULT hrMsg = 0;
                switch (p->GetFlag())
                {
                case SHARE_FLAG_ADDED:  hrMsg = IERR_CANT_ADD_SHARE;    break;
                case SHARE_FLAG_MODIFY: hrMsg = IERR_CANT_MODIFY_SHARE; break;
                case SHARE_FLAG_REMOVE: hrMsg = IERR_CANT_DEL_SHARE;    break;
                default:
                    appAssert(!"Illegal flag for a failed commit!");
                }
                DisplayError(_hwndPage, hrMsg, ret, p->GetNetname());
            }
            else
            {
                if (p->GetFlag() == SHARE_FLAG_REMOVE)
                {
                    // nuke it!
                    p->Unlink();
                    delete p;
                }
                else
                {
                    p->SetDirtyFlag(0);  // clear flag on success
                }
            }
        }

        p = pNext;
    }

    appDebugOut((DEB_TRACE,
        "Changed share for path %ws, notifying shell\n",
        _pszPath));

    SHChangeNotify(SHCNE_NETSHARE, SHCNF_PATH, _pszPath, NULL);
    // FEATURE: might want to use SHCNE_NETUNSHARE, but the shell doesn't
    // distinguish them

    // Now, notify the shell about all the paths we got rid of to be able
    // to use their share names ...
    for (p = (CShareInfo*) _pReplaceList->Next();
         p != _pReplaceList;
         )
    {
        appAssert(p->GetFlag() == SHARE_FLAG_REMOVE);

        appDebugOut((DEB_TRACE,
            "Got rid of share on path %ws, notifying shell\n",
            p->GetPath()));

        // We're going to be asked by the shell to refresh the cache once
        // for every notify. But, seeing as how the average case is zero
        // of these notifies, don't worry about it.
        SHChangeNotify(SHCNE_NETSHARE, SHCNF_PATH, p->GetPath(), NULL);

        CShareInfo* pNext = (CShareInfo*) p->Next();
        p->Unlink();
        delete p;
        p = pNext;
    }

    // I refresh the cache, even though the shell comes back and asks
    // for a refresh after every SHChangeNotify. However, SHChangeNotify
    // is asynchronous, and I need the cache refreshed immediately so I
    // can display the new share information, if the "apply" button was
    // hit and the page didn't go away.
    //
    // PERF: these 2 calls should move to CShareBase::_DoApply and only
    // happen when bClose = FALSE.  There is no reason to do this when
    // the dialog is going away.

    g_ShareCache.Refresh();
    _ConstructShareList();
}


//+-------------------------------------------------------------------------
//
//  Member:     CSharingPropertyPage::SizeWndProc, public
//
//  Synopsis:   "allow" edit window subclass proc to disallow non-numeric
//              characters.
//
//  History:    5-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

// NTRAID#NTBUG9-585729-2002/03/19 JonN Wouldn't it be easier to just use ES_NUMBER?
LRESULT CALLBACK
CSharingPropertyPage::SizeWndProc(
    IN HWND hwnd,
    IN UINT wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (wMsg)
    {
    case WM_CHAR:
    {
        WCHAR chCharCode = (WCHAR)wParam;
        if (   (chCharCode == TEXT('\t'))
            || (chCharCode == TEXT('\b'))
            || (chCharCode == TEXT('\n'))
//          || (chCharCode == TEXT('\x1b')) // ESCAPE key
            )
        {
            break;
        }

        if (chCharCode < TEXT('0') || chCharCode > TEXT('9'))
        {
            // bad key: ignore it
            MessageBeep(0xffffffff);    // let user know it's an illegal char
            return FALSE;
        }

        break;
    }
    } // end of switch

    CSharingPropertyPage* pThis = (CSharingPropertyPage*)GetWindowLongPtr(GetParent(hwnd),GWLP_USERDATA);
    // 585755-2002/03/21 handle NULL in pThis and pThis->_pfnAllowProc
    if (NULL == pThis || NULL == pThis->_pfnAllowProc)
    {
        appAssert(FALSE);
        return FALSE;
    }
    return CallWindowProc(pThis->_pfnAllowProc, hwnd, wMsg, wParam, lParam);
}


//+--------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::CSharingPropertyPage, public
//
//  Synopsis:   Constructor
//
//---------------------------------------------------------------------------

CSharingPropertyPage::CSharingPropertyPage(
    IN BOOL bDialog     // called as a dialog, not a property page?
    )
    :
    CShareBase(bDialog),
    _wIDSelected(0),        // JonN 7/12/00 140878
    _bItemDirty(FALSE),
    _bShareNameChanged(FALSE),
    _bCommentChanged(FALSE),
    _bUserLimitChanged(FALSE),
    _wMaxUsers(DEFAULT_MAX_USERS),
    _pfnAllowProc(NULL),
    _bIsCachingSupported (false)
{
    INIT_SIG(CSharingPropertyPage);
}


//+--------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::~CSharingPropertyPage, public
//
//  Synopsis:   Destructor
//
//---------------------------------------------------------------------------

CSharingPropertyPage::~CSharingPropertyPage()
{
    CHECK_SIG(CSharingPropertyPage);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_PageProc, private
//
//  Synopsis:   Dialog Procedure for this object
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_PageProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CHECK_SIG(CSharingPropertyPage);

    switch (msg)
    {
    case WM_VSCROLL:
        // The up/down control changed the edit control: select it again
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
        return TRUE;

    case WM_CLOSE:
        // NOTE: There is a bug where hitting "ESCAPE" with the focus on the
        // MLE for the "allow" text doesn't kill the property sheet unless we
        // forward the WM_CLOSE message on to the property sheet root dialog.
        return (BOOL)SendMessage(_GetFrameWindow(), msg, wParam, lParam);

    case WM_DESTROY:
        // restore original subclass to window.
        appAssert(NULL != GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE));
        SetWindowLongPtr(GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE), GWLP_WNDPROC, (LONG_PTR)_pfnAllowProc);
        break;

    } // end switch (msg)

    return CShareBase::_PageProc(hwnd, msg, wParam, lParam);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnInitDialog, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnInitDialog(
    IN HWND hwnd,
    IN HWND /*hwndFocus*/,
    IN LPARAM /*lInitParam*/
    )
{
    CHECK_SIG(CSharingPropertyPage);
    appDebugOut((DEB_ITRACE, "_OnInitDialog\n"));

    // Subclass allow edit control to disallow non-positive numbers
    _pfnAllowProc = (WNDPROC)SetWindowLongPtr(
                                    GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE),
                                    GWLP_WNDPROC,
                                    (LONG_PTR)&SizeWndProc);

    // use LanMan API constants to set maximum share name & comment lengths
    SendDlgItemMessage(hwnd, IDC_SHARE_SHARENAME, EM_LIMITTEXT, NNLEN, 0L);         // 80
    SendDlgItemMessage(hwnd, IDC_SHARE_COMMENT,   EM_LIMITTEXT, MAXCOMMENTSZ, 0L);  // 256

    if (_bDialog)
    {
        SetWindowText(hwnd, _pszPath);
    }
    else
    {
        _MyShow( hwnd, IDOK, FALSE );
        _MyShow( hwnd, IDCANCEL, FALSE );
    }

    _InitializeControls(hwnd);

// #if DBG == 1
//  Dump(L"_OnInitDialog finished");
// #endif // DBG == 1

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnCommand, private
//
//  Synopsis:   WM_COMMAND handler
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnCommand(
    IN HWND hwnd,
    IN WORD wNotifyCode,
    IN WORD wID,
    IN HWND hwndCtl
    )
{
    CHECK_SIG(CSharingPropertyPage);

    switch (wID)
    {

//
// Notifications
//

    case IDC_SHARE_NOTSHARED:
    {
        if (BN_CLICKED == wNotifyCode)
        {
            if (   (!_fInitializingPage)
                && (IDC_SHARE_NOTSHARED != _wIDSelected) // JonN 7/11/00 140878
                // JonN 7/11/00 140878
                // sometimes you get BN_CLICKED even before the
                // button is selected according to IsDlgButtonChecked
                && (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_NOTSHARED))
               )
            {
                _wIDSelected = IDC_SHARE_NOTSHARED;

                _ReadControls(hwnd);

                // Delete all shares from the combo box; convert the combo box
                // to the edit control (default state), and then disable
                // all the controls.  Cache whatever shares we had, so if
                // the user hits "Shared As", we can put them back.

                if (_cShares > 1)
                {
                    // JonN 7/11/00 140878
                    // Additional BN_CLICKED notifications are coming in while
                    // the MSG_MULTIDEL dialog is still onscreen, resulting
                    // in multiple copies of the dialog.
                    _fInitializingPage++; // JonN 7/11/00 140878

                    DWORD id = MyConfirmationDialog(
                                    hwnd,
                                    MSG_MULTIDEL,
                                    MB_YESNO | MB_ICONQUESTION);
                    if (IDNO == id)
                    {
                        CheckRadioButton(
                                hwnd,
                                IDC_SHARE_NOTSHARED,
                                IDC_SHARE_SHAREDAS,
                                IDC_SHARE_SHAREDAS);

                        //
                        // JonN 3/8/01 140878 part 2 (unit-test 3/9/01)
                        // At this point, IDC_SHARE_SHAREDAS is selected,
                        // but focus is still on IDC_SHARE_NOTSHARED and
                        // _wIDSelected == IDC_SHARE_NOTSHARED.
                        // Correct this, but stay in the _fInitializingPage
                        // block so that the page will not be marked dirty.
                        //
                        SendMessage(hwnd, WM_NEXTDLGCTL,
                            (WPARAM)GetDlgItem(hwnd,IDC_SHARE_SHAREDAS),
                            (LPARAM)TRUE);
                        _wIDSelected = IDC_SHARE_SHAREDAS;

                        _fInitializingPage--; // JonN 7/11/00 140878
                        return TRUE;
                    }
                    _fInitializingPage--; // JonN 7/11/00 140878
                }

                //
                // Next, regenerate the UI
                //

                _SetControlsFromData(hwnd, NULL);

                _MarkPageDirty();
            }
        }

        return TRUE;
    }

    case IDC_SHARE_SHAREDAS:
    {
        if (BN_CLICKED == wNotifyCode)
        {

            if (   (!_fInitializingPage)
                && (IDC_SHARE_SHAREDAS != _wIDSelected) // JonN 7/11/00 140878
                // JonN 7/11/00 140878
                // Sometimes you get BN_CLICKED even before the
                // button is selected according to IsDlgButtonChecked
                && (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_SHAREDAS))
               )
            {
                _wIDSelected = IDC_SHARE_SHAREDAS;

                // if there were shares there that we just hid when the user
                // pressed "Not Shared", then put them back.

                //
                // Regenerate the UI
                //

                _SetControlsFromData(hwnd, NULL);

                _MarkPageDirty();
            }
        }

        return TRUE;
    }

    case IDC_SHARE_SHARENAME:
    {
        if (EN_CHANGE == wNotifyCode)
        {
            if (!_fInitializingPage)
            {
                _bShareNameChanged = TRUE;
                _MarkItemDirty();
            }
            EnableWindow(GetDlgItem(hwnd, IDC_SHARE_CACHING),
                    IsCachingSupported());
        }
        return TRUE;
    }

    case IDC_SHARE_COMMENT:
    {
        if (EN_CHANGE == wNotifyCode)
        {
            if (!_fInitializingPage)
            {
                _bCommentChanged = TRUE;
                _MarkItemDirty();
            }
        }
        return TRUE;
    }

    case IDC_SHARE_SHARENAME_COMBO:
    {
        if (CBN_SELCHANGE == wNotifyCode)
        {
            _ReadControls(hwnd);

            HWND hwndCombo = GetDlgItem(hwnd, IDC_SHARE_SHARENAME_COMBO);
            int item = ComboBox_GetCurSel(hwndCombo);
            appAssert(CB_ERR != item);
            LRESULT itemData = ComboBox_GetItemData(hwndCombo, item);
            _pCurInfo = (CB_ERR == itemData) ? NULL : (CShareInfo *)itemData;
            appAssert(NULL != _pCurInfo);

            _SetFieldsFromCurrent(hwnd);
        }

        return TRUE;
    }

    case IDC_SHARE_MAXIMUM:
        if (BN_CLICKED == wNotifyCode)
        {
            // Take away WS_TABSTOP from the "allow users" edit control
            HWND hwndEdit = GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE);
            SetWindowLong(hwndEdit, GWL_STYLE, GetWindowLong(hwndEdit, GWL_STYLE) & ~WS_TABSTOP);

            _CacheMaxUses(hwnd);
            SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");

            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }
        return TRUE;

    case IDC_SHARE_ALLOW:
        if (BN_CLICKED == wNotifyCode)
        {
            // Give WS_TABSTOP to the "allow users" edit control
            HWND hwndEdit = GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE);
            SetWindowLong(hwndEdit, GWL_STYLE, GetWindowLong(hwndEdit, GWL_STYLE) | WS_TABSTOP);

            // let the spin control set the edit control
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);

            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }
        return TRUE;

    case IDC_SHARE_ALLOW_VALUE:
    {
        if (EN_CHANGE == wNotifyCode)
        {
            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }

        if (EN_SETFOCUS == wNotifyCode)
        {
            if (1 != IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
            {
                CheckRadioButton(
                    hwnd,
                    IDC_SHARE_MAXIMUM,
                    IDC_SHARE_ALLOW,
                    IDC_SHARE_ALLOW);
            }

            // let the spin control set the edit control
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);

            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }

        if (EN_KILLFOCUS == wNotifyCode)
        {
            _CacheMaxUses(hwnd);
        }

        return TRUE;
    }

    case IDC_SHARE_ALLOW_SPIN:
        if (UDN_DELTAPOS == wNotifyCode)
        {
            if (1 != IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
            {
                CheckRadioButton(
                    hwnd,
                    IDC_SHARE_MAXIMUM,
                    IDC_SHARE_ALLOW,
                    IDC_SHARE_ALLOW);
            }

            _bUserLimitChanged = TRUE;
            _MarkItemDirty();
        }
        return TRUE;

//
// Commands
//

    case IDC_SHARE_PERMISSIONS:
        return _OnPermissions(hwnd);

    case IDC_SHARE_REMOVE:
        return _OnRemove(hwnd);

    case IDC_SHARE_NEWSHARE:
        return _OnNewShare(hwnd);

    case IDC_SHARE_CACHING:
        return _OnCaching(hwnd);

    default:
        break;
    }

    return CShareBase::_OnCommand(hwnd, wNotifyCode, wID, hwndCtl);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnHelp, private
//
//  Synopsis:   WM_HELP handler
//
//--------------------------------------------------------------------------

static const DWORD aHelpIds[] =
{
    IDOK,                       HC_OK,
    IDCANCEL,                   HC_CANCEL,
    IDC_SHARE_SHARENAME,        HC_SHARE_SHARENAME,
    IDC_SHARE_SHARENAME_TEXT,   HC_SHARE_SHARENAME,
    IDC_SHARE_COMMENT,          HC_SHARE_COMMENT,
    IDC_SHARE_COMMENT_TEXT,     HC_SHARE_COMMENT,
    IDC_SHARE_MAXIMUM,          HC_SHARE_MAXIMUM,
    IDC_SHARE_ALLOW,            HC_SHARE_ALLOW,
    IDC_SHARE_ALLOW_VALUE,      HC_SHARE_ALLOW_VALUE,
    IDC_SHARE_ALLOW_SPIN,       (DWORD)-1L, // 257807 by request of JillZ
    IDC_SHARE_PERMISSIONS,      HC_SHARE_PERMISSIONS,
    IDC_SHARE_LIMIT,            HC_SHARE_LIMIT,

    IDC_SHARE_NOTSHARED,        HC_SHARE_NOTSHARED,
    IDC_SHARE_SHAREDAS,         HC_SHARE_SHAREDAS,
    IDC_SHARE_SHARENAME_COMBO,  HC_SHARE_SHARENAME_COMBO,
    IDC_SHARE_REMOVE,           HC_SHARE_REMOVE,
    IDC_SHARE_NEWSHARE,         HC_SHARE_NEWSHARE,
    IDC_SHARE_ICON,             (DWORD)-1L, // 311328 JillZ
    IDC_SHARE_TOPTEXT,          (DWORD)-1L, // 311328 JillZ
    0,0
};
static const DWORD aCSCUIHelpIds[] =
{
    IDC_SHARE_CACHING,          IDH_SHARE_CACHING_BTN,
    IDC_SHARE_CACHING_TEXT,     IDH_SHARE_CACHING_BTN,
    0,0
};

BOOL
CSharingPropertyPage::_OnHelp(
    IN HWND /*hwnd*/,
    IN LPHELPINFO lphi
    )
{
    if (lphi->iContextType == HELPINFO_WINDOW)  // a control
    {
        WCHAR szHelp[50];
        if ( IDC_SHARE_CACHING == lphi->iCtrlId || IDC_SHARE_CACHING_TEXT == lphi->iCtrlId )
        {
            LoadString(g_hInstance, IDS_CSCUI_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
            WinHelp(
                    (HWND)lphi->hItemHandle,
                    szHelp,
                    HELP_WM_HELP,
                    (DWORD_PTR)aCSCUIHelpIds);
        }
        else
        {
            LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
            WinHelp(
                    (HWND)lphi->hItemHandle,
                    szHelp,
                    HELP_WM_HELP,
                    (DWORD_PTR)aHelpIds);
        }
    }

    return TRUE;
}


#define _AfxGetDlgCtrlID(hWnd)          ((UINT)(WORD)::GetDlgCtrlID(hWnd))
HWND MyChildWindowFromPoint(HWND hWnd, POINT pt)
{
    appAssert(hWnd != NULL);

    // check child windows
    ::ClientToScreen(hWnd, &pt);
    HWND hWndChild = ::GetWindow(hWnd, GW_CHILD);
    for (; hWndChild != NULL; hWndChild = ::GetWindow(hWndChild, GW_HWNDNEXT))
    {
        if (_AfxGetDlgCtrlID(hWndChild) != (WORD)-1 &&
	        (::GetWindowLong(hWndChild, GWL_STYLE) & WS_VISIBLE))
        {
            // see if point hits the child window
            RECT rect;
            ::GetWindowRect(hWndChild, &rect);
            if (PtInRect(&rect, pt))
                return hWndChild;
        }
    }

    return NULL;    // not found
}

//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnContextMenu, private
//
//  Synopsis:   WM_CONTEXTMENU handler
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnContextMenu(
    IN HWND hwnd,
    IN HWND hCtrlWnd,
    IN int xPos,
    IN int yPos
    )
{
    WCHAR   szHelp[50];
    int     ctrlID = 0;

    if ( hwnd == hCtrlWnd )
    {
        POINT	point;

        point.x = xPos;
        point.y = yPos;
        if ( ScreenToClient (hwnd, &point) )
        {
            hCtrlWnd = MyChildWindowFromPoint (hwnd, point); // takes client coords
            if ( !hCtrlWnd )
                hCtrlWnd = hwnd;
        }
    }

    ctrlID = GetDlgCtrlID (hCtrlWnd);
    if ( IDC_SHARE_CACHING == ctrlID || IDC_SHARE_CACHING_TEXT == ctrlID )
    {
        LoadString(g_hInstance, IDS_CSCUI_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
        WinHelp(
                hCtrlWnd,
                szHelp,
                HELP_CONTEXTMENU,
                (DWORD_PTR)aCSCUIHelpIds);
    }
    else
    {
        LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
        WinHelp(
                hCtrlWnd,
                szHelp,
                HELP_CONTEXTMENU,
                (DWORD_PTR)aHelpIds);
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnPermissions, private
//
//  Synopsis:   WM_COMMAND handler: the permissions button
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnPermissions(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);
    appAssert(NULL != _pCurInfo);
    if (NULL == _pCurInfo) // JonN 5/2/01 384155
        return TRUE;

    if (STYPE_SPECIAL & _pCurInfo->GetType())
    {
        MyErrorDialog(hwnd, IERR_AdminShare);
        return TRUE;
    }

    WCHAR szShareName[NNLEN + 1];
    if (_cShares > 0)
    {
        lstrcpynW(szShareName, _pCurInfo->GetNetname(), ARRAYLEN(szShareName));
    }
    else
    {
        GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName));
        // don't trim spaces, this might be an existing share with spaces in its name
    }

    PSECURITY_DESCRIPTOR pNewSecDesc = NULL;
    PSECURITY_DESCRIPTOR pSecDesc = _pCurInfo->GetSecurityDescriptor();
    appAssert(NULL == pSecDesc || IsValidSecurityDescriptor(pSecDesc));

    BOOL bSecDescChanged;
    EditShareAcl(hwnd,
                 NULL,
                 szShareName,
                 pSecDesc,
                 &bSecDescChanged,
                 &pNewSecDesc);

    if (bSecDescChanged)
    {
        appAssert(IsValidSecurityDescriptor(pNewSecDesc));
        _pCurInfo->TransferSecurityDescriptor(pNewSecDesc);
        _MarkPageDirty();
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnRemove, private
//
//  Synopsis:   WM_COMMAND handler: the Remove button
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnRemove(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);
    appAssert(_cShares > 1);
    appAssert(_pCurInfo != NULL);
    if (NULL == _pCurInfo) // JonN 5/2/01 384155
        return TRUE;

    //
    // Alter the data structures
    //

    if (_pCurInfo->GetFlag() == SHARE_FLAG_ADDED)
    {
        // Something that was added this session is being removed: get rid of
        // it from our list.

        _pCurInfo->Unlink();
        delete _pCurInfo;
        _pCurInfo = NULL;
        // the _SetControlsFromData call resets the _pCurInfo pointer
    }
    else
    {
        // if the state was MODIFY or no state, then set it to REMOVE
        _pCurInfo->SetDirtyFlag(SHARE_FLAG_REMOVE);
    }

    --_cShares;

    //
    // Next, regenerate the UI
    //

    _SetControlsFromData(hwnd, NULL);

    _MarkPageDirty();

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnNewShare, private
//
//  Synopsis:   WM_COMMAND handler: the New Share button
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnNewShare(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    //
    // First, create an object to put the new share into.
    // FEATURE: for out of memory errors, should we pop up an error box?
    //

    HRESULT hr;

    CShareInfo* pNewInfo = new CShareInfo();
    if (NULL == pNewInfo)
    {
        return FALSE;
    }

    hr = pNewInfo->InitInstance();
    CHECK_HRESULT(hr);
    if (FAILED(hr))
    {
        delete pNewInfo;
        return FALSE;
    }

    hr = pNewInfo->SetPath(_pszPath);
    CHECK_HRESULT(hr);
    if (FAILED(hr))
    {
        delete pNewInfo;
        return FALSE;
    }

    // NTRAID#NTBUG9-603727-2002/04/15 JonN
    // There is no point in calling ReadCacheFlags, since the
    // netname has not been set.
    NET_API_STATUS    ret = pNewInfo->ReadCacheFlags ();
    appAssert( NERR_Success == ret );
    /*
    if ( NERR_Success != ret )
    {
        delete pNewInfo;
        return HRESULT_FROM_WIN32 (ret);
    }
    */

    pNewInfo->SetDirtyFlag(SHARE_FLAG_ADDED);

    CDlgNewShare dlg(hwnd);
    dlg.m_pInfoList = _pInfoList;
    dlg.m_pReplaceList = _pReplaceList;
    dlg.m_pShareInfo = pNewInfo;
    if (dlg.DoModal())
    {
        _ReadControls(hwnd);    // read current stuff

        //
        // Add the new one to the list
        //

        pNewInfo->InsertBefore(_pInfoList); // add to end of list

        ++_cShares; // one more share in the list...

        //
        // Next, regenerate the UI
        //

        _SetControlsFromData(hwnd, pNewInfo->GetNetname());

        _MarkPageDirty();
    }
    else
    {
        // user hit "cancel"
        delete pNewInfo;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_OnCaching, private
//
//  Synopsis:   WM_COMMAND handler: the Caching button
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_OnCaching(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    // show wait cursor ??
    HINSTANCE    hInstance = ::LoadLibrary (L"FileMgmt.dll");
    if ( hInstance )
    {
        typedef HRESULT (*PfnCacheSettingsDlg)(HWND hwndParent, DWORD & dwFlags);
        PfnCacheSettingsDlg pfn = (PfnCacheSettingsDlg) ::GetProcAddress (
                hInstance, "CacheSettingsDlg");
        appAssert( NULL != _pCurInfo );
        if ( pfn && NULL != _pCurInfo) // JonN 5/2/01 384155
        {
            DWORD    dwFlags = _pCurInfo->GetCacheFlags ();

            HRESULT    hResult = pfn (hwnd, dwFlags);
            if ( S_OK == hResult )
            {
                _pCurInfo->SetCacheFlags (dwFlags);
                _MarkPageDirty();
            }
        }
        ::FreeLibrary (hInstance);
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_InitializeControls, private
//
//  Synopsis:   Initialize the controls from scratch
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_InitializeControls(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    //
    // Set defaults first
    //

    _SetControlsToDefaults(hwnd);

    _fInitializingPage++; // JonN 7/11/00 140878
    CheckRadioButton(
            hwnd,
            IDC_SHARE_NOTSHARED,
            IDC_SHARE_SHAREDAS,
            (_cShares > 0) ? IDC_SHARE_SHAREDAS : IDC_SHARE_NOTSHARED);
    _fInitializingPage--; // JonN 7/11/00 140878

    _SetControlsFromData(hwnd, NULL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_SetControlsToDefaults, private
//
//  Synopsis:   Set all the controls on the page to their default values
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_SetControlsToDefaults(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    _fInitializingPage++; // JonN 7/11/00 140878

    // Make "Maximum" the default number of users, and clear the value field
    // (which the spin button set on creation?).

    CheckRadioButton(
            hwnd,
            IDC_SHARE_MAXIMUM,
            IDC_SHARE_ALLOW,
            IDC_SHARE_MAXIMUM);

    SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");

    // set the spin control range: 1 <--> large number
    SendDlgItemMessage(
            hwnd,
            IDC_SHARE_ALLOW_SPIN,
            UDM_SETRANGE,
            0,
            MAKELONG(g_uiMaxUsers, 1));

    _HideControls(hwnd, 0);

    HWND hwndCombo = GetDlgItem(hwnd, IDC_SHARE_SHARENAME_COMBO);
    ComboBox_ResetContent(hwndCombo);

    SetDlgItemText(hwnd, IDC_SHARE_SHARENAME,   L"");
    SetDlgItemText(hwnd, IDC_SHARE_COMMENT,     L"");

    _fInitializingPage--; // JonN 7/11/00 140878
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::SetControlsFromData, private
//
//  Synopsis:   From the class variables and current state of the radio
//              buttons, set the enabled/disabled state of the buttons, as
//              well as filling the controls with the appropriate values.
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_SetControlsFromData(
    IN HWND hwnd,
    IN PWSTR pszPreferredSelection
    )
{
    CHECK_SIG(CSharingPropertyPage);

    BOOL bIsShared = (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_SHAREDAS));

    _EnableControls(hwnd, bIsShared);

    if (bIsShared)
    {
        appDebugOut((DEB_ITRACE, "_SetControlsFromData: path is shared\n"));

        _HideControls(hwnd, _cShares);

        //
        // Now, set controls based on actual data
        //

        _fInitializingPage++; // JonN 7/11/00 140878

        // if there is a new share, we only show the edit control for the
        // share name, not the combo box.

        if (_cShares == 0)
        {
            _pCurInfo = (CShareInfo*)_pInfoList->Next();
            if (NULL != _pCurInfo) // JonN 5/2/01 384155
            {
                // Note that EM_LIMITTEXT doesn't prevent us from putting
                // too much text into the control here.
                appAssert(wcslen(_pCurInfo->GetNetname()) <= NNLEN);
                SetDlgItemText(hwnd, IDC_SHARE_SHARENAME, _pCurInfo->GetNetname());
            }
            else // JonN 2/11/02 529168
            {
                appAssert(FALSE);
                _pCurInfo = _pInfoList;
            }
        }
        else // (_cShares > 0)
        {
            // in the combo box, the "item data" is the CShareInfo pointer of
            // the item.

            // fill the combo.

            HWND hwndCombo = GetDlgItem(hwnd, IDC_SHARE_SHARENAME_COMBO);
            ComboBox_ResetContent(hwndCombo);

            for (CShareInfo* p = (CShareInfo*) _pInfoList->Next();
                 p != _pInfoList;
                 p = (CShareInfo*) p->Next())
            {
                if (p->GetFlag() != SHARE_FLAG_REMOVE)
                {
                    int item = ComboBox_AddString(hwndCombo, p->GetNetname());
                    if (CB_ERR == item || CB_ERRSPACE == item)
                    {
                        // FEATURE: how to recover here?
                        break;
                    }

                    if (CB_ERR == ComboBox_SetItemData(hwndCombo, item, p))
                    {
                        // FEATURE: how to recover here?
                    }
                }
            }

            int sel = 0;
            if (NULL != pszPreferredSelection)
            {
                sel = ComboBox_FindStringExact(hwndCombo, -1, pszPreferredSelection);
                if (CB_ERR == sel)
                {
                    sel = 0;
                }
            }
            ComboBox_SetCurSel(hwndCombo, sel);

            _pCurInfo = (CShareInfo*)ComboBox_GetItemData(hwndCombo, sel);
            if ( NULL == _pCurInfo
              || (CShareInfo*)CB_ERR == _pCurInfo) // JonN 2/11/02 529168
            {
                appAssert(FALSE);
                _pCurInfo = _pInfoList;
            }
        }

        _fInitializingPage--; // JonN 7/11/00 140878

        // From the current item, set the rest of the fields

        _SetFieldsFromCurrent(hwnd);

        // This must be called after the share name field is initialized.
        EnableWindow(GetDlgItem(hwnd, IDC_SHARE_CACHING), IsCachingSupported());
    }
    else
    {
        appDebugOut((DEB_ITRACE, "_SetControlsFromData: path is not shared\n"));
        _pCurInfo = NULL;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_EnableControls, private
//
//  Synopsis:   Enable/disable controls
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_EnableControls(
    IN HWND hwnd,
    IN BOOL bEnable
    )
{
    CHECK_SIG(CSharingPropertyPage);

    int idControls[] =
    {
        IDC_SHARE_SHARENAME_TEXT,
        IDC_SHARE_SHARENAME,
        IDC_SHARE_SHARENAME_COMBO,
        IDC_SHARE_COMMENT_TEXT,
        IDC_SHARE_COMMENT,
        IDC_SHARE_LIMIT,
        IDC_SHARE_MAXIMUM,
        IDC_SHARE_ALLOW,
        IDC_SHARE_ALLOW_SPIN,
        IDC_SHARE_ALLOW_VALUE,
        IDC_SHARE_REMOVE,
        IDC_SHARE_NEWSHARE,
        IDC_SHARE_PERMISSIONS
    };

    for (int i = 0; i < ARRAYLEN(idControls); i++)
    {
        EnableWindow(GetDlgItem(hwnd, idControls[i]), bEnable);
    }

    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_CACHING),
            bEnable && IsCachingSupported());
}



//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_HideControls, private
//
//  Synopsis:   Hide or show the controls based on the current number
//              of shares.
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_HideControls(
    IN HWND hwnd,
    IN int cShares
    )
{
    CHECK_SIG(CSharingPropertyPage);

    _MyShow( hwnd, IDC_SHARE_REMOVE,          !!(cShares > 1) );
    _MyShow( hwnd, IDC_SHARE_NEWSHARE,        !!(cShares >= 1) );
    _MyShow( hwnd, IDC_SHARE_SHARENAME,       !!(cShares < 1) );
    _MyShow( hwnd, IDC_SHARE_SHARENAME_COMBO, !!(cShares >= 1) );
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_SetFieldsFromCurrent, private
//
//  Synopsis:   From the currently selected share, set the property page
//              controls.
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_SetFieldsFromCurrent(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);
    appAssert(NULL != _pCurInfo);

    _fInitializingPage++; // JonN 7/11/00 140878

    SetDlgItemText(hwnd, IDC_SHARE_COMMENT,
        (NULL == _pCurInfo) ? L'\0' : _pCurInfo->GetRemark());

    DWORD dwLimit = (NULL == _pCurInfo) // JonN 5/2/01 384155
                        ? SHI_USES_UNLIMITED : _pCurInfo->GetMaxUses(); 
    if (dwLimit == SHI_USES_UNLIMITED)
    {
        _wMaxUsers = DEFAULT_MAX_USERS;

        appDebugOut((DEB_ITRACE, "_SetFieldsFromCurrent: unlimited users\n"));

        CheckRadioButton(
                hwnd,
                IDC_SHARE_MAXIMUM,
                IDC_SHARE_ALLOW,
                IDC_SHARE_MAXIMUM);

        SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");
    }
    else
    {
        _wMaxUsers = (WORD)dwLimit;

        appDebugOut((DEB_ITRACE,
            "_SetFieldsFromCurrent: max users = %d\n",
            _wMaxUsers));

        CheckRadioButton(
                hwnd,
                IDC_SHARE_MAXIMUM,
                IDC_SHARE_ALLOW,
                IDC_SHARE_ALLOW);

        // let the spin control set the edit control
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));

        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
    }

    _fInitializingPage--; // JonN 7/11/00 140878
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_ReadControls, private
//
//  Synopsis:   Load the data in the controls into internal data structures.
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_ReadControls(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    if (!_bItemDirty)
    {
        // nothing to read
        appDebugOut((DEB_ITRACE, "_ReadControls: item not dirty\n"));
        return TRUE;
    }

    appDebugOut((DEB_ITRACE, "_ReadControls: item dirty\n"));
    appAssert(NULL != _pCurInfo);
    if (NULL == _pCurInfo) // JonN 5/2/01 384155
        return TRUE;

    if (_bShareNameChanged)
    {
        appDebugOut((DEB_ITRACE, "_ReadControls: share name changed\n"));
        appAssert(GetWindowTextLength(GetDlgItem(hwnd, IDC_SHARE_SHARENAME)) <= NNLEN);

        WCHAR szShareName[NNLEN + 1];
        GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName));
        TrimLeadingAndTrailingSpaces(szShareName);
        _pCurInfo->SetNetname(szShareName);
        _bShareNameChanged = FALSE;
    }

    if (_bCommentChanged)
    {
        appDebugOut((DEB_ITRACE, "_ReadControls: comment changed\n"));

        WCHAR szComment[MAXCOMMENTSZ + 1];
        GetDlgItemText(hwnd, IDC_SHARE_COMMENT, szComment, ARRAYLEN(szComment));
        _pCurInfo->SetRemark(szComment);
        _bCommentChanged = FALSE;
    }

    if (_bUserLimitChanged)
    {
        appDebugOut((DEB_ITRACE, "_ReadControls: user limit changed\n"));

        if (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_MAXIMUM))
        {
            _pCurInfo->SetMaxUses(SHI_USES_UNLIMITED);
        }
        else if (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
        {
            _CacheMaxUses(hwnd);
            _pCurInfo->SetMaxUses(_wMaxUsers);
        }
        _bUserLimitChanged = FALSE;
    }

    _bItemDirty = FALSE;

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_MarkItemDirty, private
//
//  Synopsis:   A change has made such that the current item (and page)
//              is now dirty
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_MarkItemDirty(
    VOID
    )
{
    CHECK_SIG(CSharingPropertyPage);

    if (!_fInitializingPage)
    {
        if (!_bItemDirty)
        {
            appDebugOut((DEB_ITRACE, "Marking Sharing page---current item---dirty\n"));
            _bItemDirty = TRUE;
        }

        _MarkPageDirty();
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_ValidatePage, private
//
//  Synopsis:   Return TRUE if the current page is valid
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_ValidatePage(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    _ReadControls(hwnd);    // read current stuff

    if (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_SHAREDAS))
    {
        // If the user is creating a share on the property sheet (as
        // opposed to using the "new share" dialog), we must validate the
        // share.... Note that _bNewShare is still TRUE if the the user has
        // clicked on "Not Shared", so we must check that too.

        // Validate the share

        if (!_ValidateNewShareName())
        {
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            return FALSE;
        }
    }

#if DBG == 1
    Dump(L"_ValidatePage finished");
#endif // DBG == 1

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_DoApply, public
//
//  Synopsis:   If anything has changed, apply the data
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_DoApply(
    IN HWND hwnd,
    IN BOOL bClose
    )
{
    CHECK_SIG(CSharingPropertyPage);

    if (_bDirty)
    {
        BOOL bNotShared = (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_NOTSHARED));

        if (!bNotShared)
        {
            _ReadControls(hwnd);
        }

        _CommitShares(bNotShared);

        CShareBase::_DoApply(hwnd, bClose);

        if (!bClose)
        {
            _InitializeControls(hwnd);
        }
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_DoCancel, public
//
//  Synopsis:   Do whatever is necessary to cancel the changes
//
//--------------------------------------------------------------------------

BOOL
CSharingPropertyPage::_DoCancel(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    if (_bDirty)
    {
        _bItemDirty = FALSE;
        _bShareNameChanged = FALSE;
        _bCommentChanged = FALSE;
        _bUserLimitChanged = FALSE;
    }

    return CShareBase::_DoCancel(hwnd);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::_CacheMaxUses, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------

VOID
CSharingPropertyPage::_CacheMaxUses(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSharingPropertyPage);

    DWORD dwRet = (DWORD)SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_GETPOS, 0, 0);
    if (HIWORD(dwRet) != 0)
    {
        _wMaxUsers = DEFAULT_MAX_USERS;

        // Reset the edit control to the new value
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
    }
    else
    {
        _wMaxUsers = LOWORD(dwRet);
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::IsCachingSupported
//
//  Synopsis:   Does the operating system support caching on this share?
//              This method initializes _bIsCachingSupported, if it is not already true
//
//--------------------------------------------------------------------------
bool CSharingPropertyPage::IsCachingSupported()
{
    if (!_bIsCachingSupported)
    {
        LPWSTR  pszShareName = 0;
        WCHAR   szShareName[NNLEN + 1];
        UINT    nRet =  GetDlgItemText (_hwndPage, IDC_SHARE_SHARENAME, szShareName,
                ARRAYLEN(szShareName));
        if ( nRet > 0 )
            pszShareName = szShareName;
        else if ( _pCurInfo )
            pszShareName = _pCurInfo->GetNetname ();

        if ( pszShareName )
        {
            SHARE_INFO_501* pshi501 = NULL;
            //
            // On pre-NT5 systems (per IsaacHe), NetShareGetInfo will return
            // ERROR_INVALID_LEVEL for info level 501 regardless of the share
            // name provided.  This is because the net code validates the
            // requested level *before* validating the share name.
            // Therefore, passing a blank share name works for our purposes
            // here.  If NetShareGetInfo returns ERROR_INVALID_LEVEL, this
            // means level 501 is not supported which means the system
            // isn't NT5 which means caching is not supported.  No need to
            // query the contents of *pshi501 because we're not interested in
            // the level of caching at this point. [brianau - 8/11/98]
            //
            NET_API_STATUS retval = ::NetShareGetInfo(
                    L"",            // machine name
                    L"",            // share name
                    501,
                    (LPBYTE*)&pshi501);

            if (ERROR_INVALID_LEVEL != retval)
            {
                _bIsCachingSupported = true;
            }
            if ( pshi501 )
            {
                ::NetApiBufferFree (pshi501);
            }
        }
    }

    return _bIsCachingSupported;
}


#if DBG == 1

//+-------------------------------------------------------------------------
//
//  Method:     CSharingPropertyPage::Dump, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------
VOID
CSharingPropertyPage::Dump(
    IN PWSTR pszCaption
    )
{
    CHECK_SIG(CSharingPropertyPage);

    appDebugOut((DEB_TRACE,
        "CSharingPropertyPage::Dump, %ws\n",
        pszCaption));

    appDebugOut((DEB_TRACE | DEB_NOCOMPNAME,
"\t            This: 0x%08lx\n"
"\t            Path: %ws\n"
"\t            Page: 0x%08lx\n"
"\t   Initializing?: %ws\n"
"\t          Dirty?: %ws\n"
"\t     Item dirty?: %ws\n"
"\t  Share changed?: %ws\n"
"\tComment changed?: %ws\n"
"\tUsr Lim changed?: %ws\n"
"\t        Max uses: %d\n"
"\t      _pInfoList: 0x%08lx\n"
"\t       _pCurInfo: 0x%08lx\n"
"\t          Shares: %d\n"
,
this,
_pszPath,
_hwndPage,
_fInitializingPage ? L"yes" : L"no",
_bDirty ? L"yes" : L"no",
_bItemDirty ? L"yes" : L"no",
_bShareNameChanged ? L"yes" : L"no",
_bCommentChanged ? L"yes" : L"no",
_bUserLimitChanged ? L"yes" : L"no",
_wMaxUsers,
_pInfoList,
_pCurInfo,
_cShares
));

    CShareInfo* p;

    for (p = (CShareInfo*) _pInfoList->Next();
         p != _pInfoList;
         p = (CShareInfo*) p->Next())
    {
        p->Dump(L"Prop page list");
    }

    for (p = (CShareInfo*) _pReplaceList->Next();
         p != _pReplaceList;
         p = (CShareInfo*) p->Next())
    {
        p->Dump(L"Replace list");
    }
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\ntshrui\util.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       util.cxx
//
//  Contents:   Misc helper functions
//
//  History:    5-Apr-95    BruceFo Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "util.hxx"
#include <safeboot.h>   // SAFEBOOT_* flags

//////////////////////////////////////////////////////////////////////////////

#define NETMSG_DLL TEXT("netmsg.dll")

//////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Function:   MyFormatMessageText
//
//  Synopsis:   Given a resource IDs, load strings from given instance
//              and format the string into a buffer
//
//  History:    11-Aug-93 WilliamW   Created.
//
//--------------------------------------------------------------------------
DWORD
MyFormatMessageText(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     cchBuffer,
    IN va_list * parglist
    )
{
    //
    // get message from system or app msg file.
    //

    DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE,
                             g_hInstance,
                             dwMsgId,
                             LANG_USER_DEFAULT,
                             pszBuffer,
                             cchBuffer,
                             parglist);

    if (0 == dwReturn)   // couldn't find message
    {
        appDebugOut((DEB_IERROR,
            "FormatMessage failed, 0x%08lx\n",
            GetLastError()));

        WCHAR szText[200];
        dwReturn = LoadString(g_hInstance, IDS_APP_MSG_NOT_FOUND, szText, ARRAYLEN(szText));
        if (0 != dwReturn)
        {
            int iReturn = wnsprintf(pszBuffer, cchBuffer, szText, dwMsgId);
            dwReturn = (iReturn < 0) ? 0 : iReturn;
        }
    }
    return dwReturn;
}


//+-------------------------------------------------------------------------
//
//  Function:   MyCommonDialog
//
//  Synopsis:   Common popup dialog routine - stole from diskadm directory
//
//--------------------------------------------------------------------------
DWORD
MyCommonDialog(
    IN HWND    hwnd,
    IN HRESULT dwMsgCode,
    IN PWSTR   pszCaption,
    IN DWORD   dwFlags,
    IN va_list arglist
    )
{
    WCHAR szMsgBuf[500];

    if (0 == MyFormatMessageText(dwMsgCode, szMsgBuf, ARRAYLEN(szMsgBuf), &arglist))
    {
        return 0;
    }
    return MessageBox(hwnd, szMsgBuf, pszCaption, dwFlags);
}


//+-------------------------------------------------------------------------
//
//  Function:   MyConfirmationDialog
//
//  Synopsis:   This routine retreives a message from the app or system
//              message file and displays it in a message box.
//
//  Note:       Stole from diskadm directory
//
//--------------------------------------------------------------------------
DWORD
MyConfirmationDialog(
    IN HWND hwnd,
    IN HRESULT dwMsgCode,
    IN DWORD dwFlags,
    ...
    )
{
    WCHAR szCaption[100];
    DWORD dwReturn;
    va_list arglist;

    va_start(arglist, dwFlags);

    LoadString(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));
    dwReturn = MyCommonDialog(hwnd, dwMsgCode, szCaption, dwFlags, arglist);
    va_end(arglist);

    return dwReturn;
}


//+-------------------------------------------------------------------------
//
//  Function:   MyErrorDialog
//
//  Synopsis:   This routine retreives a message from the app or system
//              message file and displays it in a message box.
//
//  Note:       Stole from diskadm directory
//
//--------------------------------------------------------------------------
VOID
MyErrorDialog(
    IN HWND hwnd,
    IN HRESULT dwErrorCode,
    ...
    )
{
    WCHAR szCaption[100];
    va_list arglist;

    va_start(arglist, dwErrorCode);

    LoadString(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));
    MyCommonDialog(hwnd, dwErrorCode, szCaption, MB_ICONSTOP | MB_OK, arglist);

    va_end(arglist);
}


//+---------------------------------------------------------------------------
//
//  Function:   NewDup
//
//  Synopsis:   Duplicate a string using '::new'
//
//  History:    28-Dec-94   BruceFo   Created
//
//----------------------------------------------------------------------------

PWSTR
NewDup(
    IN const WCHAR* psz
    )
{
    if (NULL == psz)
    {
        appDebugOut((DEB_IERROR,"Illegal string to duplicate: NULL\n"));
        return NULL;
    }

    int cch = lstrlenW(psz) + 1;
    PWSTR pszRet = new WCHAR[cch];
    if (NULL == pszRet)
    {
        appDebugOut((DEB_ERROR,"OUT OF MEMORY\n"));
        return NULL;
    }

    lstrcpynW(pszRet, psz, cch);
    return pszRet;
}


//+-------------------------------------------------------------------------
//
//  Member:     CopySecurityDescriptor, public
//
//  Synopsis:   Copy an NT security descriptor. Delete the result
//              using LocalFree().
//
//  History:    19-Apr-95   BruceFo     Created
//
//--------------------------------------------------------------------------

HRESULT
CopySecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecDesc,
    OUT PSECURITY_DESCRIPTOR *ppsdResult
    )
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSelfSecDesc = NULL;

    appDebugOut((DEB_ITRACE, "CopySecurityDescriptor, pSecDesc = 0x%08lx\n", pSecDesc));

    if (NULL == ppsdResult)
    {
        return E_POINTER;
    }

    *ppsdResult = NULL;

    if (NULL == pSecDesc)
    {
        // nothing to do
        return S_OK;
    }

    if (!IsValidSecurityDescriptor(pSecDesc))
    {
        return E_INVALIDARG;
    }

    SECURITY_DESCRIPTOR_CONTROL sdc = 0;
    DWORD dwRevision = 0;
    if ( ::GetSecurityDescriptorControl( pSecDesc, &sdc, &dwRevision ) )
    {
        DWORD dwLen = GetSecurityDescriptorLength(pSecDesc);
        pSelfSecDesc = reinterpret_cast<PSECURITY_DESCRIPTOR>(::LocalAlloc(LPTR, dwLen));
        if (NULL != pSelfSecDesc)
        {
            // if the original is already self-relative, just copy it
            if ( sdc & SE_SELF_RELATIVE )
            {
                CopyMemory(pSelfSecDesc, pSecDesc, dwLen);
            }
            else if (!MakeSelfRelativeSD(pSecDesc, pSelfSecDesc, &dwLen))
            {
                appDebugOut((DEB_TRACE, "MakeSelfRelativeSD failed, 0x%08lx\n", GetLastError()));

                DWORD err = ::GetLastError();
                hr = HRESULT_FROM_WIN32( err );
            }

            if (SUCCEEDED(hr))
            {
                appAssert(IsValidSecurityDescriptor(pSelfSecDesc));
                *ppsdResult = pSelfSecDesc;
            }
            else
            {
                ::LocalFree(pSelfSecDesc);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        DWORD err = ::GetLastError();
        hr = HRESULT_FROM_WIN32( err );
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     WarnDelShare, public
//
//  Synopsis:   Function to warn a user that a share will be deleted, and give
//              the user a chance to cancel.
//
//  Arguments:  [hwnd] - parent window handle for messages
//              [idMsg] - message ID to display (rmdir vs. move)
//              [pszShare] - share name
//              [pszPath] - path that share affects
//
//  Returns:    IDYES if share was deleted, IDNO if we don't want to delete,
//              but keep going, IDCANCEL to stop going.
//
//  History:    19-Apr-95   BruceFo     Created
//
//--------------------------------------------------------------------------

UINT
WarnDelShare(
    IN HWND hwnd,
    IN UINT idMsg,
    IN PWSTR pszShare,
    IN PWSTR pszPath
    )
{
    DWORD id = MyConfirmationDialog(
                    hwnd,
                    idMsg,
                    MB_YESNOCANCEL | MB_ICONEXCLAMATION,
                    pszPath,
                    pszShare);
    if (id != IDYES)
    {
        return id;
    }

    id = ConfirmStopShare(hwnd, MB_YESNOCANCEL, pszShare);
    if (id != IDYES)
    {
        return id;
    }

    UINT ret = NetShareDel(NULL, pszShare, 0);
    if (ret != NERR_Success)
    {
        DisplayError(hwnd, IERR_CANT_DEL_SHARE, ret, pszShare);
        return IDYES;   // allow the stop anyway
    }

    return IDYES;
}


//+-------------------------------------------------------------------------
//
//  Member:     ConfirmStopShare, public
//
//  Synopsis:   Display the appropriate confirmations when stopping a share.
//
//  Arguments:  [hwnd] - parent window handle for messages
//              [uType] - either MB_YESNO or MB_YESNOCANCEL
//              [pszShare] - ptr to affected share name
//
//  Returns:    IDYES if share should be deleted, IDNO if we don't want to
//              delete, but keep going, IDCANCEL to stop going.
//
//  History:    19-Apr-95   BruceFo     Created
//
//--------------------------------------------------------------------------

DWORD
ConfirmStopShare(
    IN HWND hwnd,
    IN UINT uType,
    IN LPWSTR pszShare
    )
{
    DWORD id = IDYES;
    DWORD cConns = 0;
    DWORD cOpens = 0;
    NET_API_STATUS err = ShareConnectionInfo(pszShare, &cConns, &cOpens);
    if (err != NERR_Success)
    {
        DisplayError(hwnd, IERR_CANT_DEL_SHARE, err, pszShare);
        // allow the stop anyway
    }
    else if (cConns != 0)
    {
        // If there are any open files, just give the more detailed
        // message about there being open files. Otherwise, just say how
        // many connections there are.

        if (cOpens != 0)
        {
            id = MyConfirmationDialog(
                        hwnd,
                        MSG_STOPSHAREOPENS,
                        uType | MB_ICONEXCLAMATION,
                        cOpens,
                        cConns,
                        pszShare);
        }
        else
        {
            id = MyConfirmationDialog(
                        hwnd,
                        MSG_STOPSHARECONNS,
                        uType | MB_ICONEXCLAMATION,
                        cConns,
                        pszShare);
        }
    }

    // JonN 4/4/01 328512
    // Explorer Sharing Tab (NTSHRUI) should popup warning on deleting
    // SYSVOL,NETLOGON and C$, D$... shares
    //
    // No need to worry about IPC$, that won't turn up in NTSHRUI

    if (IDYES == id)
    {
        bool fSpecialShare = !lstrcmpi(pszShare,L"NETLOGON")
                          || !lstrcmpi(pszShare,L"SYSVOL");
        if (   fSpecialShare
            || (lstrlen(pszShare) == 2 && L'$'== pszShare[1])
           )
        {
            id = MyConfirmationDialog(
                        hwnd,
                        (fSpecialShare) ? MSG_DELSPECIALSHARE
                                        : MSG_DELADMINSHARE,
                        uType | MB_ICONEXCLAMATION,
                        pszShare);
        }
    }

    return id;
}



//+-------------------------------------------------------------------------
//
//  Member:     ShareConnectionInfo, public
//
//  Synopsis:   Determine how many connections and file opens exist for a
//              share, for use by confirmation dialogs.
//
//  Arguments:  [pszShare] - ptr to affected share name
//              [pcConns]  - *pcConns get the number of connections
//              [pcOpens]  - *pcOpens get the number of file opens
//
//  Returns:    standard net api code, NERR_Success if everything ok.
//
//  History:    19-Apr-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

NET_API_STATUS
ShareConnectionInfo(
    IN LPWSTR pszShare,
    OUT LPDWORD pcConns,
    OUT LPDWORD pcOpens
    )
{
    CONNECTION_INFO_1* pBuf;

    DWORD iEntry, iTotal;
    NET_API_STATUS err = NetConnectionEnum(
                            NULL,
                            pszShare,
                            1,
                            (LPBYTE*)&pBuf,
                            0xffffffff,     // no buffer limit; get them all!
                            &iEntry,
                            &iTotal,
                            NULL);

   if ((err == NERR_Success) || (err == ERROR_MORE_DATA))
   {
      int iConnections = 0;
      for (DWORD i = 0; i < iEntry; i++)
      {
          iConnections += pBuf[i].coni1_num_opens;
      }

      *pcConns = iTotal;
      *pcOpens = iConnections;
      err = NERR_Success;
   }
   else
   {
      *pcConns = 0;
      *pcOpens = 0;
   }
   NetApiBufferFree(pBuf);

   appDebugOut((DEB_ITRACE,"Share '%ws' has %d connections and %d opens\n", pszShare, *pcConns, *pcOpens));

   return err;
}


//+-------------------------------------------------------------------------
//
//  Function:   DisplayError
//
//  Synopsis:   Display an error message
//
//  History:    24-Apr-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

VOID
DisplayError(
    IN HWND           hwnd,
    IN HRESULT        dwErrorCode, // message file number. not really an HRESULT
    IN NET_API_STATUS err,
    IN PWSTR          pszShare
    )
{
    if (   err < MIN_LANMAN_MESSAGE_ID
        || err > MAX_LANMAN_MESSAGE_ID
        )
    {
        // a Win32 error?

        WCHAR szMsg[500];
        DWORD dwReturn = FormatMessage(
                                 FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                                 NULL,
                                 err,
                                 LANG_USER_DEFAULT,
                                 szMsg,
                                 ARRAYLEN(szMsg),
                                 NULL);
        if (0 == dwReturn)   // couldn't find message
        {
            appDebugOut((DEB_IERROR,
                "FormatMessage (from system) failed, 0x%08lx\n",
                GetLastError()));

            MyErrorDialog(hwnd, IERR_UNKNOWN, err);
        }
        else
        {
            MyErrorDialog(hwnd, dwErrorCode, pszShare, szMsg);
        }
    }
    else
    {
        DisplayLanmanError(hwnd, dwErrorCode, err, pszShare);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   DisplayLanmanError
//
//  Synopsis:   Display an error message from a LanMan error.
//
//  History:    24-Apr-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

VOID
DisplayLanmanError(
    IN HWND           hwnd,
    IN HRESULT        dwErrorCode, // message file number. not really an HRESULT
    IN NET_API_STATUS err,
    IN PWSTR          pszShare
    )
{
    if (   err < MIN_LANMAN_MESSAGE_ID
        || err > MAX_LANMAN_MESSAGE_ID
        )
    {
        MyErrorDialog(hwnd, IERR_UNKNOWN, err);
        return;
    }

    WCHAR szCaption[100];
    LoadString(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));

    //
    // get LanMan message from system message file.
    //

    WCHAR szNetMsg[500];
    WCHAR szBuf[500];

    HINSTANCE hInstanceNetMsg = LoadLibrary(NETMSG_DLL);
    if (NULL == hInstanceNetMsg)
    {
        appDebugOut((DEB_IERROR,
            "LoadLibrary(netmsg.dll) failed, 0x%08lx\n",
            GetLastError()));

        LoadString(g_hInstance, IDS_NO_NET_MSG, szBuf, ARRAYLEN(szBuf));
        MessageBox(hwnd, szBuf, szCaption, MB_ICONSTOP | MB_OK);
        return;
    }

    DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                             hInstanceNetMsg,
                             err,
                             LANG_USER_DEFAULT,
                             szNetMsg,
                             ARRAYLEN(szNetMsg),
                             NULL);
    if (0 == dwReturn)   // couldn't find message
    {
        appDebugOut((DEB_IERROR,
            "FormatMessage failed, 0x%08lx\n",
            GetLastError()));

        if (LoadString(g_hInstance, IDS_NET_MSG_NOT_FOUND, szBuf, ARRAYLEN(szBuf)) &&
            wnsprintf(szNetMsg, ARRAYLEN(szNetMsg), szBuf, GetLastError()) > 0)
        {
            MessageBox(hwnd, szNetMsg, szCaption, MB_ICONSTOP | MB_OK);
        }
    }
    else
    {
        MyErrorDialog(hwnd, dwErrorCode, pszShare, szNetMsg);
    }

    FreeLibrary(hInstanceNetMsg);
}


//+-------------------------------------------------------------------------
//
//  Function:   IsValidShareName
//
//  Synopsis:   Checks if the proposed share name is valid or not. If not,
//              it will return a message id for the reason why.
//
//  Arguments:  [pszShareName] - Proposed share name
//              [puId] - If name is invalid, this will contain the reason why.
//
//  Returns:    TRUE if name is valid, else FALSE.
//
//  History:    3-May-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

BOOL
IsValidShareName(
    IN  PCWSTR pszShareName,
    OUT HRESULT* uId
    )
{
    if (NetpNameValidate(NULL, (PWSTR)pszShareName, NAMETYPE_SHARE, 0L) != NERR_Success)
    {
        *uId = IERR_InvalidShareName;
        return FALSE;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:   IsValidWin9xShareLength
//
//  Synopsis:   Checks if the proposed share name is within the maximum length
//              that Win9x clients can use, which is LM20_NNLEN *bytes* for
//              the MBCS version of the name.
//
//  Arguments:  [pszShareName] - Proposed share name
//
//  Returns:    TRUE if name is valid, else FALSE.
//
//  History:    07-Nov-01 JeffreyS  Created
//
//--------------------------------------------------------------------------

BOOL
IsValidWin9xShareLength(
    IN  PCWSTR pszShare
    )
{
    char szBuf[LM20_NNLEN+1];   // +1 for '\0'

    // If WideCharToMultiByte fails with ERROR_INSUFFICIENT_BUFFER, then we
    // know the name is too long.  There is no need to check the string
    // length on success.

    if (pszShare &&
        WideCharToMultiByte(CP_ACP, 0, pszShare, -1, szBuf, LM20_NNLEN+1, NULL, NULL))
    {
        return TRUE;
    }

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Function:   SetErrorFocus
//
//  Synopsis:   Set focus to an edit control and select its text.
//
//  Arguments:  [hwnd] - dialog window
//              [idCtrl] - edit control to set focus to (and select)
//
//  Returns:    nothing
//
//  History:    3-May-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

VOID
SetErrorFocus(
    IN HWND hwnd,
    IN UINT idCtrl
    )
{
    HWND hCtrl = ::GetDlgItem(hwnd, idCtrl);
    ::SetFocus(hCtrl);
    ::SendMessage(hCtrl, EM_SETSEL, 0, -1);
}


//+-------------------------------------------------------------------------
//
//  Function:   ConfirmReplaceShare
//
//  Synopsis:   Display confirmations for replacing an existing share
//
//  Arguments:  [hwnd] - dialog window
//              [pszShareName] - name of share being replaced
//              [pszOldPath] - current path for the share
//              [pszNewPath] - directory the user's trying to share
//
//  Returns:    Returns IDYES or IDNO
//
//  History:    4-May-95   BruceFo     Stolen
//
//--------------------------------------------------------------------------

DWORD
ConfirmReplaceShare(
    IN HWND hwnd,
    IN PCWSTR pszShareName,
    IN PCWSTR pszOldPath,
    IN PCWSTR pszNewPath
    )
{
    DWORD id = MyConfirmationDialog(
                    hwnd,
                    MSG_RESHARENAMECONFIRM,
                    MB_YESNO | MB_ICONEXCLAMATION,
                    pszOldPath,
                    pszShareName,
                    pszNewPath);
    if (id != IDYES)
    {
        return id;
    }

    return ConfirmStopShare(hwnd, MB_YESNO, (PWSTR)pszShareName);
}


//+---------------------------------------------------------------------------
//
//  Function:   TrimLeadingAndTrailingSpaces
//
//  Synopsis:   Trims the leading and trailing spaces from a null-terminated string.
//              Used primarily for share names.
//
//  History:    18-Jul-97 JonN      Created
//
//----------------------------------------------------------------------------

VOID
TrimLeadingAndTrailingSpaces(
    IN OUT PWSTR psz
    )
{
    int cchStrlen = ::wcslen(psz);
    int cchLeadingSpaces = 0;
    int cchTrailingSpaces = 0;
    while (L' ' == psz[cchLeadingSpaces])
        cchLeadingSpaces++;
    if (cchLeadingSpaces < cchStrlen)
    {
        while (L' ' == psz[cchStrlen-(cchTrailingSpaces+1)])
            cchTrailingSpaces++;
    }
    if ((cchLeadingSpaces+cchTrailingSpaces) > 0)
    {
        cchStrlen -= (cchLeadingSpaces+cchTrailingSpaces);
        (void)memmove( psz,
                       psz+cchLeadingSpaces,
                       cchStrlen*sizeof(WCHAR) );
        psz[cchStrlen] = L'\0';
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   IsSafeMode
//
//  Synopsis:   Checks the registry to see if the system is in safe mode.
//
//  History:    06-Oct-00 JeffreyS  Created
//
//----------------------------------------------------------------------------

BOOL
IsSafeMode(
    VOID
    )
{
    BOOL  fIsSafeMode = FALSE;
    LONG  ec;
    DWORD dwValue;
    DWORD dwValueSize = sizeof(dwValue);

    ec = SHRegGetValue(HKEY_LOCAL_MACHINE,
                       TEXT("SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Option"),
                       TEXT("OptionValue"),
                       SRRF_RT_DWORD,
                       NULL,
                       &dwValue,
                       &dwValueSize);

    if (ec == NO_ERROR)
    {
        fIsSafeMode = (dwValue == SAFEBOOT_MINIMAL || dwValue == SAFEBOOT_NETWORK);
    }

    return fIsSafeMode;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsForcedGuestModeOn
//
//  Synopsis:   Checks the registry to see if the system is using the
//              Guest-only network access mode.
//
//  History:    06-Oct-00 JeffreyS  Created
//              19-Apr-00 GPease    Modified and changed name
//
//----------------------------------------------------------------------------

BOOL
IsForcedGuestModeOn(
    VOID
    )
{
    BOOL fIsForcedGuestModeOn = FALSE;

    if (IsOS(OS_PERSONAL))
    {
        // Guest mode is always on for Personal
        fIsForcedGuestModeOn = TRUE;
    }
    else if (IsOS(OS_PROFESSIONAL) && !IsOS(OS_DOMAINMEMBER))
    {
        LONG  ec;
        DWORD dwValue;
        DWORD dwValueSize = sizeof(dwValue);

        // Professional, not in a domain. Check the ForceGuest value.

        ec = SHRegGetValue(HKEY_LOCAL_MACHINE,
                           TEXT("SYSTEM\\CurrentControlSet\\Control\\LSA"),
                           TEXT("ForceGuest"),
                           SRRF_RT_DWORD,
                           NULL,
                           &dwValue,
                           &dwValueSize);

        if (ec == NO_ERROR && 1 == dwValue)
        {
            fIsForcedGuestModeOn = TRUE;
        }
    }

    return fIsForcedGuestModeOn;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsSimpleUI
//
//  Synopsis:   Checks whether to show the simple version of the UI.
//
//  History:    06-Oct-00 JeffreyS  Created
//              19-Apr-00 GPease    Removed CTRL key check
//
//----------------------------------------------------------------------------

BOOL
IsSimpleUI(
    VOID
    )
{
    // Show old UI in safe mode and anytime network access involves
    // true user identity (server, pro with GuestMode off).
    
    // Show simple UI anytime network access is done using the Guest
    // account (personal, pro with GuestMode on) except in safe mode.

    return (!IsSafeMode() && IsForcedGuestModeOn());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\ntshrui\strhash.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       strhash.cxx
//
//  Contents:   A hash table for strings
//
//  History:    7-Nov-94    BruceFo Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "strhash.hxx"

const DWORD g_cMinElemsRehash = 3;
const DWORD g_cMinBuckets     = 13;

//////////////////////////////////////////////////////////////////////////////
// Methods for the CStrHashBucketElem class
//////////////////////////////////////////////////////////////////////////////

CStrHashBucketElem::CStrHashBucketElem(
    IN const WCHAR* pszKey
    )
    :
    m_pszKey(pszKey),
    m_next(NULL)
{
    INIT_SIG(CStrHashBucketElem);
}

CStrHashBucketElem::~CStrHashBucketElem()
{
    CHECK_SIG(CStrHashBucketElem);
}

BOOL
CStrHashBucketElem::IsEqual(
    IN const WCHAR* pszKey
    )
{
    CHECK_SIG(CStrHashBucketElem);
    appAssert(NULL != pszKey);
    appAssert(NULL != m_pszKey);

    // NOTE: case-insensitive compare. This affects the hash function!
    return (0 == _wcsicmp(pszKey, m_pszKey));
}

//////////////////////////////////////////////////////////////////////////////
// Methods for the CStrHashBucket class
//////////////////////////////////////////////////////////////////////////////

CStrHashBucket::CStrHashBucket(
    VOID
    )
    :
    m_head(NULL)
{
    INIT_SIG(CStrHashBucket);
}

CStrHashBucket::~CStrHashBucket(
    VOID
    )
{
    CHECK_SIG(CStrHashBucket);

    for (CStrHashBucketElem* x = m_head; NULL != x; )
    {
        CStrHashBucketElem* tmp = x->m_next;
        delete x;
        x = tmp;
    }
}

HRESULT
CStrHashBucket::Insert(
    IN const WCHAR* pszKey
    )
{
    CHECK_SIG(CStrHashBucket);
    appAssert(NULL != pszKey);

    CStrHashBucketElem* x = new CStrHashBucketElem(pszKey);
    if (NULL == x)
    {
        return E_OUTOFMEMORY;
    }

    x->m_next = m_head;
    m_head = x;
    return S_OK;
}

// return TRUE if it was found and removed, FALSE if it wasn't even found
BOOL
CStrHashBucket::Remove(
    IN const WCHAR* pszKey
    )
{
    CHECK_SIG(CStrHashBucket);
    appAssert(NULL != pszKey);

    CStrHashBucketElem** pPrev = &m_head;

    for (CStrHashBucketElem* x = m_head; NULL != x; x = x->m_next)
    {
        if (x->IsEqual(pszKey)) // found it
        {
            *pPrev = x->m_next;
            delete x;
            return TRUE;
        }

        pPrev = &x->m_next;
    }

    return FALSE; // didn't find it
}

BOOL
CStrHashBucket::IsMember(
    IN const WCHAR* pszKey
    )
{
    CHECK_SIG(CStrHashBucket);
    appAssert(NULL != pszKey);

    for (CStrHashBucketElem* x = m_head; NULL != x; x = x->m_next)
    {
        if (x->IsEqual(pszKey))
        {
            return TRUE; // found it
        }
    }
    return FALSE; // didn't find it
}

//////////////////////////////////////////////////////////////////////////////
// Methods for the CStrHashTable class
//////////////////////////////////////////////////////////////////////////////

CStrHashTable::CStrHashTable(
    IN DWORD cNumBuckets
    )
    :
    m_cElems(0),
    m_cMinNumBuckets(cNumBuckets)
{
    INIT_SIG(CStrHashTable);

    m_cNumBuckets = max(cNumBuckets, g_cMinBuckets);
    m_ht = new CStrHashBucket[m_cNumBuckets];
    if (NULL == m_ht)
    {
        appDebugOut((DEB_ERROR,
            "Failed to allocate hash table with %d buckets\n",
            m_cNumBuckets));

        m_cMinNumBuckets = 0;
        m_cNumBuckets = 0;
    }
}

HRESULT
CStrHashTable::QueryError(
    VOID
    )
{
    if (NULL == m_ht)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

CStrHashTable::~CStrHashTable(
    VOID
    )
{
    CHECK_SIG(CStrHashTable);

    delete[] m_ht;
}

HRESULT
CStrHashTable::Insert(
    IN const WCHAR* pszKey
    )
{
    CHECK_SIG(CStrHashTable);

    if (NULL == pszKey)
    {
        return E_INVALIDARG;
    }

    appAssert(NULL != m_ht);

    DWORD key = HashFunction(pszKey);
    if (!(m_ht[key].IsMember(pszKey)))
    {
        // only insert if the key isn't already in the table.
        HRESULT hr = m_ht[key].Insert(pszKey);
        CHECK_HRESULT(hr);
        if (FAILED(hr))
        {
            return hr;
        }
        ++m_cElems;
        return CheckRehash();
    }

    return S_OK;
}

HRESULT
CStrHashTable::Remove(
    IN const WCHAR* pszKey
    )
{
    CHECK_SIG(CStrHashTable);

    if (NULL == pszKey)
    {
        return E_INVALIDARG;
    }

    appAssert(NULL != m_ht);

    if (m_ht[HashFunction(pszKey)].Remove(pszKey))
    {
        --m_cElems;
        return CheckRehash();
    }

    return S_OK;    // key was not found and hence not deleted
}

BOOL
CStrHashTable::IsMember(
    IN const WCHAR* pszKey
    )
{
    CHECK_SIG(CStrHashTable);

    if (NULL == pszKey)
    {
        return FALSE;   // invalid argument, really
    }

    appAssert(NULL != m_ht);

    return m_ht[HashFunction(pszKey)].IsMember(pszKey);
}

DWORD
CStrHashTable::Count(
    VOID
    )
{
    CHECK_SIG(CStrHashTable);

    return m_cElems;
}

// This returns the iteration data, or NULL on failure
CIterateData*
CStrHashTable::IterateStart(
    VOID
    )
{
    CHECK_SIG(CStrHashTable);

    CIterateData* pData = new CIterateData;
    if (NULL != pData)
    {
        IterateGetNext(pData);
    }
    return pData;
}

const WCHAR*
CStrHashTable::IterateGetData(
    IN OUT CIterateData* pCurrent
    )
{
    CHECK_SIG(CStrHashTable);
    appAssert(NULL != pCurrent);
    appAssert(ITERATE_END != pCurrent->m_CurrentBucket);

    return pCurrent->m_pCurrentElem->m_pszKey;
}

BOOL
CStrHashTable::IterateDone(
    IN CIterateData* pCurrent
    )
{
    CHECK_SIG(CStrHashTable);
    appAssert(NULL != pCurrent);

    return (ITERATE_END == pCurrent->m_CurrentBucket);
}

VOID
CStrHashTable::IterateEnd(
    IN CIterateData* pCurrent
    )
{
    CHECK_SIG(CStrHashTable);

    delete pCurrent;
}

VOID
CStrHashTable::IterateGetNext(
    IN OUT CIterateData* pCurrent
    )
{
    CHECK_SIG(CStrHashTable);
    appAssert(NULL != pCurrent);
    appAssert(ITERATE_END != pCurrent->m_CurrentBucket);

    if (NULL != pCurrent->m_pCurrentElem)
    {
        if (NULL != pCurrent->m_pCurrentElem->m_next)
        {
            // just get next element in bucket
            pCurrent->m_pCurrentElem = pCurrent->m_pCurrentElem->m_next;
        }
        else
        {
            // need to search to new bucket
            ++pCurrent->m_CurrentBucket;
            IterateGetBucket(pCurrent);
        }
    }
    else
    {
        IterateGetBucket(pCurrent);
    }
}

VOID
CStrHashTable::IterateGetBucket(
    IN OUT CIterateData* pCurrent
    )
{
    CHECK_SIG(CStrHashTable);
    appAssert(NULL != m_ht);

    for (DWORD i = pCurrent->m_CurrentBucket; i < m_cNumBuckets; i++)
    {
        if (NULL != m_ht[i].m_head)
        {
            pCurrent->m_pCurrentElem  = m_ht[i].m_head;
            pCurrent->m_CurrentBucket = i;
            return;
        }
    }
    pCurrent->m_CurrentBucket = ITERATE_END; // we've iterated through all!
}

DWORD
CStrHashTable::HashFunction(
    IN const WCHAR* pszKey
    )
{
    CHECK_SIG(CStrHashTable);

    appAssert(NULL != pszKey);
    appAssert(m_cNumBuckets > 0);

    DWORD total = 0;
    for (const WCHAR* p = pszKey; L'\0' != *p; p++)
    {
        // lower case it, so case-insensitive IsEqual works
        total += towlower(*p);
    }
    return total % m_cNumBuckets;
}

HRESULT
CStrHashTable::CheckRehash(
    VOID
    )
{
    CHECK_SIG(CStrHashTable);

    if (m_cElems > g_cMinElemsRehash && m_cElems > m_cMinNumBuckets)
    {
        if (   (m_cElems > m_cNumBuckets)
            || (m_cElems < m_cNumBuckets / 4) )
        {
            // add one to at least make it odd (for better hashing behavior)
            return Rehash(m_cElems * 2 + 1);
        }
    }
    return S_OK;
}

HRESULT
CStrHashTable::Rehash(
    IN DWORD cNumBuckets
    )
{
    CHECK_SIG(CStrHashTable);

    cNumBuckets = max(cNumBuckets, g_cMinBuckets);
    CStrHashBucket* ht = new CStrHashBucket[cNumBuckets];
    if (NULL == ht)
    {
        // return error, but don't delete the existing table
        return E_OUTOFMEMORY;
    }

    appAssert(NULL != m_ht);

    // now transfer all data from old to new

    ULONG cOldNumBuckets = m_cNumBuckets;
    m_cNumBuckets = cNumBuckets;    // set this so HashFunction() uses it

    for (ULONG i=0; i < cOldNumBuckets; i++)
    {
        for (CStrHashBucketElem* x = m_ht[i].m_head; NULL != x; )
        {
            CStrHashBucketElem* tmp = x->m_next;

            // now, just put this bucket in the right place in the new
            // hash table. Avoid performing new's and copying the keys.

            DWORD bucket = HashFunction(x->m_pszKey);
            x->m_next = ht[bucket].m_head;
            ht[bucket].m_head = x;

            x = tmp;
        }

        m_ht[i].m_head = NULL; // there isn't anything left in the list!
    }

    // the data is transfered; complete the switchover

    delete[] m_ht;
    m_ht = ht;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\ntshrui\shrpage2.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000.
//
//  File:       shrpage2.cxx
//
//  Contents:   "Simple Sharing" shell property page extension
//
//  History:    06-Oct-00       jeffreys    Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "helpids.h"
#include "dlgnew.hxx"
#include "cache.hxx"
#include "share.hxx"
#include "acl.hxx"
#include "shrinfo.hxx"
#include "shrpage2.hxx"
#include "util.hxx"
#include <userenv.h>    // GetProfilesDirectory
#undef ClearFlag        // #defined in both ccstock.h and seopaque.h
#include <seopaque.h>   // FirstAce, etc.
#include <shgina.h>     // ILocalMachine, ILogonUser
#include <shpriv.h>     // IHomeNetworkWizard

extern GENERIC_MAPPING ShareMap;    // permpage.cpp

//
//  Forward Decl.
//

INT_PTR
WarningDlgProc(
    IN HWND hWnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

// Security descriptor stuff used on this page
//
// (A;OICI;GA;;;SY) == Allow GENERIC_ALL to SYSTEM
// (A;OICI;GA;;;%s) == Allow GENERIC_ALL to <current user>
// (A;OICI;GA;;;BA) == Allow GENERIC_ALL to Builtin (local) Administrators
// (A;OICI;GRGWGXSD;;;WD) == Allow Modify access to Everyone (Read, Write, eXecute, Delete)
//
// "OI" == Object Inherit (inherit onto files)
// "CI" == Container Inherit (inherit onto subfolders)
//
// See sddl.h for more info.

// Share permissions
const WCHAR c_szFullShareSD[]     = L"D:(A;;GRGWGXSD;;;WD)";
const WCHAR c_szReadonlyShareSD[] = L"D:(A;;GRGX;;;WD)";

// Folder permissions (used only on profile folders)
const WCHAR c_szPrivateFolderSD[] = L"D:P(A;OICI;GA;;;SY)(A;OICI;GA;;;%1)";
const WCHAR c_szDefaultProfileSD[]= L"D:P(A;OICI;GA;;;SY)(A;OICI;GA;;;%1)(A;OICI;GA;;;BA)";

// Root folder permissions (see SDDLRoot in ds\security\services\scerpc\headers.h)
const WCHAR c_szRootSDSecure[] = L"D:(A;OICI;GA;;;BA)(A;OICI;GA;;;SY)(A;OICIIO;GA;;;CO)(A;CIOI;GRGX;;;BU)(A;CI;4;;;BU)(A;CIIO;2;;;BU)(A;;GRGX;;;WD)";
const WCHAR c_szRootSDUnsecure[]= L"D:P(A;OICI;GA;;;WD)";

typedef struct
{
    SID sid;            // contains 1 subauthority
    DWORD dwSubAuth[1]; // we currently need at most 2 subauthorities
} _SID2;

const  SID  g_WorldSid  =  {SID_REVISION,1,SECURITY_WORLD_SID_AUTHORITY,  {SECURITY_WORLD_RID}         };
const _SID2 g_AdminsSid = {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}}, {DOMAIN_ALIAS_RID_ADMINS}};
const _SID2 g_PowerUSid = {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}}, {DOMAIN_ALIAS_RID_POWER_USERS}};
const _SID2 g_UsersSid  = {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}}, {DOMAIN_ALIAS_RID_USERS}};
const _SID2 g_GuestsSid = {{SID_REVISION,2,SECURITY_NT_AUTHORITY,         {SECURITY_BUILTIN_DOMAIN_RID}}, {DOMAIN_ALIAS_RID_GUESTS}};

static const UINT g_rgHideTheseControlsOnDriveBlockade[] = {
      IDC_GB_SECURITY
    , IDC_GB_NETWORK_SHARING
    , IDC_SIMPLE_SHARE_SECURITY_STATIC
    , IDC_SHARE_NOTSHARED
    , IDC_LNK_SHARE_PARENT_PROTECTED
    , IDC_SHARE_ICON
    , IDC_SIMPLE_SHARE_NETWORKING_STATIC
    , IDC_SHARE_SHAREDAS
    , IDC_SHARE_SHARENAME_TEXT
    , IDC_SHARE_SHARENAME
    , IDC_SHARE_PERMISSIONS
    , IDC_I_SHARE_INFORMATION
    , IDC_LNK_SHARE_NETWORK_WIZARD
    , IDC_LNK_SHARE_OPEN_SHARED_DOCS
    , IDC_LNK_SHARE_HELP_SHARING_AND_SECURITY
    , IDC_LNK_SHARE_HELP_ON_SECURITY
    , IDC_S_SHARE_SYSTEM_FOLDER
    , IDC_LNK_SHARE_SECURITY_OVERRIDE
    };




//+-------------------------------------------------------------------------
//
//  Method:     _GetUserSid
//
//  Synopsis:   Get the current user's SID from the thread or process token.
//
//--------------------------------------------------------------------------

BOOL
_GetUserSid(
    OUT PWSTR *ppszSID
    )
{
    BOOL bResult = FALSE;
    HANDLE hToken;

    *ppszSID = NULL;

    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken)
        || OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
    {
        BYTE buffer[sizeof(TOKEN_USER) + sizeof(SID) + SID_MAX_SUB_AUTHORITIES*sizeof(DWORD)];
        ULONG cbBuffer = sizeof(buffer);

        if (GetTokenInformation(hToken,
                                TokenUser,
                                buffer,
                                cbBuffer,
                                &cbBuffer))
        {
            PTOKEN_USER ptu = (PTOKEN_USER)buffer;
            bResult = ConvertSidToStringSidW(ptu->User.Sid, ppszSID);
        }

        CloseHandle(hToken);
    }

    return bResult;
}


//+-------------------------------------------------------------------------
//
//  Method:     _GetUserProfilePath
//
//  Synopsis:   Retrieve the profile path for a particular user.
//
//--------------------------------------------------------------------------

HRESULT _GetUserProfilePath(PCWSTR pszUserSID, PWSTR szPath, DWORD cchPath)
{
    WCHAR szKey[MAX_PATH];
    DWORD dwErr;

    if (PathCombineW(szKey, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList", pszUserSID))
    {
        DWORD cbSize = cchPath * sizeof(WCHAR);
        dwErr = SHGetValue(HKEY_LOCAL_MACHINE, szKey, L"ProfileImagePath", NULL, szPath, &cbSize);
    }
    else
    {
        dwErr = ERROR_FILENAME_EXCED_RANGE;
    }

    return HRESULT_FROM_WIN32(dwErr);
}


//+-------------------------------------------------------------------------
//
//  Method:     _CheckFolderType
//
//  Synopsis:   Check whether the target folder is contained in a
//              special folder, such as the user's profile.
//
//--------------------------------------------------------------------------

static const struct
{
    int csidl;
    BOOL bTestSubfolder;
    BOOL bUserSpecific;
    DWORD dwFlags;
    PCWSTR pszDefaultSD;    // needed if CFT_FLAG_CAN_MAKE_PRIVATE is on
} c_rgFolderInfo[] =
{
    // NOTE: Order is important here!
    {CSIDL_SYSTEM,                  TRUE,   FALSE,  CFT_FLAG_ALWAYS_SHARED | CFT_FLAG_SYSTEM_FOLDER,  NULL},
    {CSIDL_PROGRAM_FILES,           FALSE,  FALSE,  CFT_FLAG_ALWAYS_SHARED | CFT_FLAG_SYSTEM_FOLDER,  NULL},
    {CSIDL_COMMON_DOCUMENTS,        TRUE,   FALSE,  CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_ALWAYS_SHARED, NULL},
    {CSIDL_COMMON_DESKTOPDIRECTORY, TRUE,   FALSE,  CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_ALWAYS_SHARED, NULL},
    {CSIDL_COMMON_PICTURES,         TRUE,   FALSE,  CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_ALWAYS_SHARED, NULL},
    {CSIDL_COMMON_MUSIC,            TRUE,   FALSE,  CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_ALWAYS_SHARED, NULL},
    {CSIDL_COMMON_VIDEO,            TRUE,   FALSE,  CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_ALWAYS_SHARED, NULL},
    {CSIDL_PROFILE,                 TRUE,   TRUE,   CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_CAN_MAKE_PRIVATE, c_szDefaultProfileSD},
    {CSIDL_DESKTOPDIRECTORY,        TRUE,   TRUE,   CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_CAN_MAKE_PRIVATE, c_szDefaultProfileSD},
    {CSIDL_PERSONAL,                TRUE,   TRUE,   CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_CAN_MAKE_PRIVATE, c_szDefaultProfileSD},
    {CSIDL_MYPICTURES,              TRUE,   TRUE,   CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_CAN_MAKE_PRIVATE, c_szDefaultProfileSD},
    {CSIDL_MYMUSIC,                 TRUE,   TRUE,   CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_CAN_MAKE_PRIVATE, c_szDefaultProfileSD},
    {CSIDL_MYVIDEO,                 TRUE,   TRUE,   CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_CAN_MAKE_PRIVATE, c_szDefaultProfileSD},
    {CSIDL_WINDOWS,                 TRUE,   FALSE,  CFT_FLAG_ALWAYS_SHARED | CFT_FLAG_SYSTEM_FOLDER,  NULL},
};
// Some of the folders above are normally contained within another, e.g. MyDocs
// inside Profile, but may be redirected elsewhere. In such cases, the child
// folder should be listed *after* the parent folder. This is important for
// correctly finding the point at which the protected ACL is set.
//
// Also, upgrades from previous OS's can leave profiles under CSIDL_WINDOWS.
// We don't allow sharing under CSIDL_WINDOWS, except we want to allow the user
// to share folders in their profile.  So leave CSIDL_WINDOWS last.


BOOL
_PathIsEqualOrSubFolder(
    PWSTR pszParent,
    PCWSTR pszSubFolder
    )
{
    WCHAR szCommon[MAX_PATH];

    //  PathCommonPrefix() always removes the slash on common
    return (pszParent[0] && PathRemoveBackslashW(pszParent)
            && PathCommonPrefixW(pszParent, pszSubFolder, szCommon)
            && lstrcmpiW(pszParent, szCommon) == 0);
}

DWORD
_CheckFolderType(
    PCWSTR pszFolder,
    PCWSTR pszUserSID,
    BOOL *pbFolderRoot,
    PCWSTR *ppszDefaultAcl
    )
{
    // Default is to allow sharing, unless there is a reason not to
    DWORD dwSharingFlags = CFT_FLAG_SHARING_ALLOWED;

    if (pbFolderRoot)
    {
        *pbFolderRoot = FALSE;
    }

    if (ppszDefaultAcl)
    {
        *ppszDefaultAcl = NULL;
    }

    // Note that we don't mess with UNC paths

    if (NULL == pszFolder       ||
        L'\0' == *pszFolder     ||
        PathIsUNC(pszFolder))
    {
        return CFT_FLAG_NO_SHARING;
    }

    //  We warn about sharing out the root folder of drives.
    if (PathIsRoot(pszFolder))
    {
        return CFT_FLAG_ROOT_FOLDER;
    }

    WCHAR szPath[MAX_PATH];
    BOOL bFolderRoot = FALSE;
    int i;
    HRESULT hr;

    if (NULL != pszUserSID)
    {
        LPWSTR pszCurrentSID = NULL;
        if (_GetUserSid(&pszCurrentSID))
        {
            appAssert(NULL != pszCurrentSID);
            if (0 == lstrcmpiW(pszUserSID, pszCurrentSID))
            {
                // Use NULL for current user to avoid E_NOTIMPL cases below
                pszUserSID = NULL;
            }
            LocalFree(pszCurrentSID);
        }
    }

    for (i = 0; i < ARRAYLEN(c_rgFolderInfo); i++)
    {
        // If the user is specified, need to check the correct profile
        if (c_rgFolderInfo[i].bUserSpecific && NULL != pszUserSID)
        {
            switch (c_rgFolderInfo[i].csidl)
            {
            case CSIDL_PROFILE:
                hr = _GetUserProfilePath(pszUserSID, szPath, ARRAYLEN(szPath));
                break;

            case CSIDL_DESKTOPDIRECTORY:
            case CSIDL_PERSONAL:
            case CSIDL_MYPICTURES:
            case CSIDL_MYMUSIC:
            case CSIDL_MYVIDEO:
            default:
                // Need to load the user's hive and read the shell folder
                // path from there.
                //
                // For now, we don't really need these, so just skip them.
                appAssert(FALSE);
                hr = E_NOTIMPL;
                break;
            }
        }
        else
        {
            hr = SHGetFolderPathW(NULL, c_rgFolderInfo[i].csidl | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPath);
        }
        if (S_OK == hr)
        {
            bFolderRoot = (lstrcmpiW(szPath, pszFolder) == 0);
            if (bFolderRoot ||
                (c_rgFolderInfo[i].bTestSubfolder && _PathIsEqualOrSubFolder(szPath, pszFolder)))
            {
                if (bFolderRoot && ppszDefaultAcl)
                {
                    *ppszDefaultAcl = c_rgFolderInfo[i].pszDefaultSD;
                }
                dwSharingFlags = c_rgFolderInfo[i].dwFlags;
                break;
            }
        }
    }

    if (ARRAYLEN(c_rgFolderInfo) == i)
    {
        // Check for other profile dirs. If there were a CSIDL for this we
        // could just add it to the list above.
        DWORD cchPath = ARRAYLEN(szPath);
        if (GetProfilesDirectoryW(szPath, &cchPath))
        {
            bFolderRoot = (lstrcmpiW(szPath, pszFolder) == 0);
            if (bFolderRoot || _PathIsEqualOrSubFolder(szPath, pszFolder))
            {
                // No sharing
                dwSharingFlags = CFT_FLAG_SYSTEM_FOLDER;
            }
        }
    }

    if (pbFolderRoot)
    {
        *pbFolderRoot = bFolderRoot;
    }

    return dwSharingFlags;
}


//+-------------------------------------------------------------------------
//
//  Method:     IsGuestEnabledForNetworkAccess
//
//  Synopsis:   Test whether the Guest account can be used for incoming
//              network connections.
//
//--------------------------------------------------------------------------

BOOL IsGuestEnabledForNetworkAccess()
{
    BOOL bResult = FALSE;
    ILocalMachine *pLM;

    if (SUCCEEDED(CoCreateInstance(CLSID_ShellLocalMachine, NULL, CLSCTX_INPROC_SERVER, IID_ILocalMachine, (void**)&pLM)))
    {
        VARIANT_BOOL vbEnabled = VARIANT_FALSE;
        bResult = (SUCCEEDED(pLM->get_isGuestEnabled(ILM_GUEST_NETWORK_LOGON, &vbEnabled)) && VARIANT_TRUE == vbEnabled);
        pLM->Release();
    }

    return bResult;
}


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSimpleSharingPage::CSimpleSharingPage()
    :
    CShareBase(FALSE),
    _bSharingEnabled(TRUE),
    _bShareNameChanged(FALSE),
    _bSecDescChanged(FALSE),
    _bIsPrivateVisible(FALSE),
    _bDriveRootBlockade(TRUE),
    _dwPermType(0),
    _pszInheritanceSource(NULL)
{
    INIT_SIG(CSimpleSharingPage);
}

CSimpleSharingPage::~CSimpleSharingPage()
{
    CHECK_SIG(CSimpleSharingPage);

    if (NULL != _pszInheritanceSource)
    {
        LocalFree(_pszInheritanceSource);
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_PageProc, private
//
//  Synopsis:   Dialog Procedure for this object
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_PageProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CHECK_SIG(CSimpleSharingPage);

    switch (msg)
    {
    case WM_SETTINGCHANGE:
        // Reinitialize the dialog
        _InitializeControls(hwnd);
        break;
    }

    return CShareBase::_PageProc(hwnd, msg, wParam, lParam);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_OnInitDialog, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_OnInitDialog(
    IN HWND hwnd,
    IN HWND /*hwndFocus*/,
    IN LPARAM /*lInitParam*/
    )
{
    CHECK_SIG(CSimpleSharingPage);
    appDebugOut((DEB_ITRACE, "_OnInitDialog\n"));

    // use LanMan API constant to set maximum share name length
    SendDlgItemMessage(hwnd, IDC_SHARE_SHARENAME, EM_LIMITTEXT, NNLEN, 0L);

    _InitializeControls(hwnd);

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_OnCommand, private
//
//  Synopsis:   WM_COMMAND handler
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_OnCommand(
    IN HWND hwnd,
    IN WORD wNotifyCode,
    IN WORD wID,
    IN HWND hwndCtl
    )
{
    CHECK_SIG(CSimpleSharingPage);

    switch (wID)
    {
    case IDC_SHARE_SHAREDAS:
        if (BST_UNCHECKED == IsDlgButtonChecked(hwnd, IDC_SHARE_SHAREDAS))
        {
            _ReadControls(hwnd);
        }
        // Fall through...
    case IDC_SHARE_NOTSHARED:
        if (BN_CLICKED == wNotifyCode)
        {
            _SetControlsFromData(hwnd);
            _MarkPageDirty();
        }
        return TRUE;

    case IDC_SHARE_SHARENAME:
        if (EN_CHANGE == wNotifyCode && !_fInitializingPage)
        {
            _bShareNameChanged = TRUE;
            _MarkPageDirty();
        }
        return TRUE;

    case IDC_SHARE_PERMISSIONS:
        if (BN_CLICKED == wNotifyCode)
        {
            _bSecDescChanged = TRUE;
            _MarkPageDirty();
        }
        return TRUE;
    }

    return CShareBase::_OnCommand(hwnd, wNotifyCode, wID, hwndCtl);
}

BOOL
RunTheNetworkSharingWizard(
    HWND hwnd
    )
{
    HRESULT hr;
    IHomeNetworkWizard *pHNW;

    hr = CoCreateInstance( CLSID_HomeNetworkWizard, NULL, CLSCTX_INPROC_SERVER, IID_IHomeNetworkWizard, (void**)&pHNW );
    if (SUCCEEDED(hr))
    {
        BOOL bRebootRequired = FALSE;

        hr = pHNW->ShowWizard(hwnd, &bRebootRequired);
        if ( SUCCEEDED(hr) && bRebootRequired )
        {
            RestartDialogEx(hwnd, NULL, EWX_REBOOT, SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_RECONFIG);
        }

        pHNW->Release();
    }

    return (SUCCEEDED(hr));
}

//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_OnPropertySheetNotify, private
//
//  Synopsis:   WM_NOTIFY handler
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_OnPropertySheetNotify(
    IN HWND hwnd,
    IN LPNMHDR phdr
    )
{
    CHECK_SIG(CSimpleSharingPage);

    switch (phdr->code)
    {
    case NM_RETURN:
    case NM_CLICK:
        switch (phdr->idFrom)
        {
        case IDC_LNK_SHARE_PARENT_PROTECTED:
            {
                HWND hwndFrame = _GetFrameWindow();

                // Close the current propsheet
                PropSheet_PressButton(hwndFrame, PSBTN_CANCEL);

                appAssert(NULL != _pszInheritanceSource);

                // Show the sharing page for the ancestor folder
                WCHAR szCaption[50];
                LoadStringW(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));
                SHObjectProperties(GetParent(hwndFrame), SHOP_FILEPATH, _pszInheritanceSource, szCaption);

            }
            return TRUE;

        case IDC_LNK_SHARE_NETWORK_WIZARD:
            appAssert(!_bSharingEnabled);
            if ( RunTheNetworkSharingWizard( hwnd ) )
            {
                // Reinitialize the dialog
                _InitializeControls(hwnd);
            }
            break;

        case IDC_LNK_SHARE_SECURITY_OVERRIDE:
            {
                UINT iRet = (UINT) DialogBox( g_hInstance, MAKEINTRESOURCE(IDD_SIMPLE_SHARE_ENABLE_WARNING), hwnd, WarningDlgProc );
                if ( IDC_RB_RUN_THE_WIZARD == iRet )
                {
                    appAssert(!_bSharingEnabled);
                    if ( RunTheNetworkSharingWizard( hwnd ) )
                    {
                        //
                        //  Now that we changed the "networking state," re-initialize the dialog
                        //  and update the control to the new state.
                        //

                        _InitializeControls(hwnd);
                    }
                }
                else if ( IDC_RB_ENABLE_FILE_SHARING == iRet )
                {
                    ILocalMachine *pLM;
                    HRESULT hr = CoCreateInstance(CLSID_ShellLocalMachine, NULL, CLSCTX_INPROC_SERVER, IID_ILocalMachine, (void**)&pLM);
                    if (SUCCEEDED(hr))
                    {
                        hr = pLM->EnableGuest(ILM_GUEST_NETWORK_LOGON);
                        pLM->Release();

                        SendNotifyMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0, 0);
                    }

                    //
                    //  Now that we changed the "networking state," re-initialize the dialog
                    //  and update the control to the new state.
                    //

                    _InitializeControls(hwnd);
                }
            }
            break;

        case IDC_LNK_SHARE_DRIVE_BLOCADE:
            if (_bDriveRootBlockade)
            {
                //  Unhide the other controls
                for (ULONG idx = 0; idx < ARRAYLEN(g_rgHideTheseControlsOnDriveBlockade); idx ++ )
                {
                    ShowWindow(GetDlgItem(hwnd, g_rgHideTheseControlsOnDriveBlockade[idx]), SW_SHOW);
                }
                _bDriveRootBlockade = FALSE;
                _InitializeControls( hwnd );
            }
            return TRUE;

        case IDC_LNK_SHARE_OPEN_SHARED_DOCS:
            {
                WCHAR szPath[MAX_PATH];

                BOOL b = SHGetSpecialFolderPath(NULL, szPath, CSIDL_COMMON_DOCUMENTS, TRUE);
                if (b)
                {
                    DWORD_PTR dwRet = (DWORD_PTR) ShellExecute(hwnd, L"Open", szPath, NULL, NULL, SW_SHOW);
                    if ( 32 < dwRet )
                    {
                        HWND hwndFrame = _GetFrameWindow();

                        // Close the current propsheet
                        PropSheet_PressButton(hwndFrame, PSBTN_CANCEL);
                    }
                }
            }
            return TRUE;

        case IDC_LNK_SHARE_HELP_SHARING_AND_SECURITY:
            {
                WCHAR szPath[MAX_PATH];

                if (LoadString(g_hInstance,
                               IsOS(OS_PERSONAL) ? IDS_SHARE_HELP_SHARING_AND_SECURITY_PER : IDS_SHARE_HELP_SHARING_AND_SECURITY_WKS,
                               szPath, ARRAYLEN(szPath)))
                {
                    HWND hwndFrame = _GetFrameWindow();
                    ShellExecute(hwndFrame, NULL, szPath, NULL, NULL, SW_NORMAL);
                }
            }
            return TRUE;

        }
        break;

    default:
        break;
    }

    return CShareBase::_OnPropertySheetNotify(hwnd, phdr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_OnHelp, private
//
//  Synopsis:   WM_HELP handler
//
//--------------------------------------------------------------------------

static const DWORD aHelpIds[] =
{
    IDC_SHARE_SHARENAME,        IDH_SHARE2_ShareName,
    IDC_SHARE_SHARENAME_TEXT,   IDH_SHARE2_ShareName,
    IDC_SHARE_NOTSHARED,        IDH_SHARE2_MakePrivate,
    IDC_SHARE_SHAREDAS,         IDH_SHARE2_ShareOnNet,
    IDC_SHARE_PERMISSIONS,      IDH_SHARE2_ReadOnly,
    IDC_LNK_SHARE_DRIVE_BLOCADE,(DWORD)-1,  // no help
    0,0
};

BOOL
CSimpleSharingPage::_OnHelp(
    IN HWND /*hwnd*/,
    IN LPHELPINFO lphi
    )
{
    CHECK_SIG(CSimpleSharingPage);

    if (lphi->iContextType == HELPINFO_WINDOW)  // a control
    {
        WCHAR szHelp[50];
        LoadString(g_hInstance, IDS_SIMPLE_SHARE_HELPFILE, szHelp, ARRAYLEN(szHelp));
        WinHelp(
            (HWND)lphi->hItemHandle,
            szHelp,
            HELP_WM_HELP,
            (DWORD_PTR)aHelpIds);
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_OnContextMenu, private
//
//  Synopsis:   WM_CONTEXTMENU handler
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_OnContextMenu(
    IN HWND /*hwnd*/,
    IN HWND hwndCtl,
    IN int /*xPos*/,
    IN int /*yPos*/
    )
{
    CHECK_SIG(CSimpleSharingPage);

    WCHAR szHelp[50];
    LoadString(g_hInstance, IDS_SIMPLE_SHARE_HELPFILE, szHelp, ARRAYLEN(szHelp));
    WinHelp(
        hwndCtl,
        szHelp,
        HELP_CONTEXTMENU,
        (DWORD_PTR)aHelpIds);

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_InitializeControls, private
//
//  Synopsis:   Initialize the controls from scratch
//
//--------------------------------------------------------------------------

VOID
CSimpleSharingPage::_InitializeControls(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSimpleSharingPage);

    _fInitializingPage++;

    _dwPermType = IFPFU_NOT_NTFS;
    _bIsPrivateVisible = FALSE;
    if (NULL != _pszInheritanceSource)
    {
        LocalFree(_pszInheritanceSource);
        _pszInheritanceSource = NULL;
    }

    // Check whether to show the "Make Private" stuff
    DWORD dwFolderFlags = _CheckFolderType(_pszPath, NULL, NULL, NULL);
    if (dwFolderFlags & CFT_FLAG_CAN_MAKE_PRIVATE)
    {
        _dwPermType = IFPFU_NOT_PRIVATE;

        LPWSTR pszSID = NULL;
        if (_GetUserSid(&pszSID))
        {
            appAssert(NULL != pszSID);
            IsFolderPrivateForUser(_pszPath, pszSID, &_dwPermType, &_pszInheritanceSource);
            LocalFree(pszSID);
        }

        if ((_dwPermType & IFPFU_NOT_NTFS) == 0)
        {
            _bIsPrivateVisible = TRUE;
        }
    }
    CheckDlgButton(hwnd, IDC_SHARE_NOTSHARED, (_bIsPrivateVisible && (_dwPermType & IFPFU_PRIVATE) != 0) ? BST_CHECKED : BST_UNCHECKED);
    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_NOTSHARED), _bIsPrivateVisible);

    BOOL bIsFolderNetworkShared = FALSE;

    if ( g_fSharingEnabled )
    {
        // Is there a net share?
        if (_cShares > 0)
        {
            // It's shared, but check for hidden (admin$) shares and
            // ignore them by removing them from the list.

            appAssert(_bNewShare == FALSE);

            for (CShareInfo* p = (CShareInfo*)_pInfoList->Next();
                 p != _pInfoList && _cShares > 0;
                 )
            {
                CShareInfo* pNext = (CShareInfo*)p->Next();

                if (STYPE_SPECIAL & p->GetType())
                {
                    // remove p from the list
                    p->Unlink();
                    delete p;
                    _cShares--;
                }

                p = pNext;
            }
            if (_cShares == 0)
            {
                // No shares left, so construct an element to be used
                // by the UI to stash the new share's data.
                _ConstructNewShareInfo();
            }
        }

        // Now is it shared?
        if (_cShares > 0)
        {
            CheckDlgButton(hwnd, IDC_SHARE_SHAREDAS, BST_CHECKED);
            bIsFolderNetworkShared = TRUE;
        }
        else
        {
            SetDlgItemText(hwnd, IDC_SHARE_SHARENAME,   L"");
            CheckDlgButton(hwnd, IDC_SHARE_SHAREDAS, BST_UNCHECKED);
        }
    }

    //
    // The Simple Sharing page (shrpage2.cxx) assumes ForceGuest
    // mode is in effect for incoming network access. This mode uses
    // the Guest account for all network connections.
    //
    // Out of the box, the Guest account is disabled, effectively
    // disabling network sharing.  The Home Networking Wizard is
    // used to enable network sharing (and the Guest account).
    //
    // So we test whether the Guest account is enabled for network
    // logon to determine whether to enable the sharing UI. If
    // network sharing is disabled, we disable the UI and offer
    // to launch the Home Networking Wizard.
    //
    // Note that it is possible for a net share to exist even though
    // the Guest account is disabled.
    //
    _bSharingEnabled = IsGuestEnabledForNetworkAccess();

    BOOL bShowPrivateWarning = (_bIsPrivateVisible && (_dwPermType & IFPFU_PRIVATE_INHERITED));
    BOOL bInheritanceSource  = (NULL == _pszInheritanceSource);
    BOOL bIsRootFolder       = (dwFolderFlags & CFT_FLAG_ROOT_FOLDER);
    BOOL bIsSystemFolder     = (dwFolderFlags & CFT_FLAG_SYSTEM_FOLDER);
    //BOOL bIsInSharedFolder   = (dwFolderFlags & CFT_FLAG_ALWAYS_SHARED);

    // see if the path is the root of a drive. if so, put up the blockade.
    if (_bDriveRootBlockade && bIsRootFolder && !bIsFolderNetworkShared)
    {
        _MyShow(hwnd, IDC_LNK_SHARE_DRIVE_BLOCADE, TRUE);

        //  Hide all the other controls when the blockade is up.
        for (ULONG idx = 0; idx < ARRAYLEN(g_rgHideTheseControlsOnDriveBlockade); idx ++ )
        {
            ShowWindow(GetDlgItem(hwnd, g_rgHideTheseControlsOnDriveBlockade[idx]), SW_HIDE);
        }
    }
    else
    {
        BOOL bShowInfoIcon          = FALSE;
        BOOL bShowNetworkWizard     = FALSE;
        BOOL bShowParentProteced    = FALSE;
        BOOL bShowSystemFolder      = FALSE;

        //  Hide the blockade
        _MyShow(hwnd, IDC_LNK_SHARE_DRIVE_BLOCADE, FALSE );

        //  Turn on the "special info" as nessecary.
        if (bIsSystemFolder)
        {
            _bSharingEnabled = FALSE;
            bShowSystemFolder = TRUE;
            bShowInfoIcon = TRUE;
        }
        else if (bShowPrivateWarning && !bInheritanceSource)
        {
            bShowParentProteced = TRUE;
            bShowInfoIcon = TRUE;
        }
        else if (!bShowPrivateWarning && !_bSharingEnabled && g_fSharingEnabled)
        {
            bShowNetworkWizard = TRUE;
        }

        _MyShow(hwnd, IDC_LNK_SHARE_PARENT_PROTECTED    , bShowParentProteced);
        _MyShow(hwnd, IDC_LNK_SHARE_NETWORK_WIZARD      , bShowNetworkWizard);
        _MyShow(hwnd, IDC_LNK_SHARE_SECURITY_OVERRIDE   , bShowNetworkWizard);
        _MyShow(hwnd, IDC_SIMPLE_SHARE_NETWORKING_STATIC, !bShowNetworkWizard);
        _MyShow(hwnd, IDC_SHARE_SHAREDAS                , !bShowNetworkWizard);
        _MyShow(hwnd, IDC_SHARE_SHARENAME_TEXT          , !bShowNetworkWizard);
        _MyShow(hwnd, IDC_SHARE_SHARENAME               , !bShowNetworkWizard);
        _MyShow(hwnd, IDC_SHARE_PERMISSIONS             , !bShowNetworkWizard);
        _MyShow(hwnd, IDC_S_SHARE_SYSTEM_FOLDER         , bShowSystemFolder);
        _MyShow(hwnd, IDC_I_SHARE_INFORMATION           , bShowInfoIcon);
    }

    _SetControlsFromData(hwnd);

    _fInitializingPage--;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::SetControlsFromData, private
//
//  Synopsis:   From the class variables and current state of the radio
//              buttons, set the enabled/disabled state of the buttons, as
//              well as filling the controls with the appropriate values.
//
//--------------------------------------------------------------------------

VOID
CSimpleSharingPage::_SetControlsFromData(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSimpleSharingPage);

    _fInitializingPage++;

    BOOL bIsPrivate = (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_SHARE_NOTSHARED));
    BOOL bIsShared = (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_SHARE_SHAREDAS));

    // We don't allow both to be checked at the same time
    appAssert(!(bIsPrivate && bIsShared));

    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_NOTSHARED), !bIsShared && _bIsPrivateVisible && !(_dwPermType & IFPFU_PRIVATE_INHERITED));
    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_SHAREDAS),       _bSharingEnabled && !bIsPrivate);
    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_SHARENAME_TEXT), _bSharingEnabled && bIsShared);
    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_SHARENAME),      _bSharingEnabled && bIsShared);
    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_PERMISSIONS),    _bSharingEnabled && bIsShared);

    if (bIsShared)
    {
        appDebugOut((DEB_ITRACE, "_SetControlsFromData: path is shared\n"));

        _pCurInfo = (CShareInfo*)_pInfoList->Next();
        if (NULL != _pCurInfo)
        {
            // Note that EM_LIMITTEXT doesn't prevent us from putting
            // too much text into the control here.
            appAssert(wcslen(_pCurInfo->GetNetname()) <= NNLEN);
            SetDlgItemText(hwnd, IDC_SHARE_SHARENAME, _pCurInfo->GetNetname());

            // If the share really exists, then make the name read-only.
            // This corresponds to the non-editable combo-box on the full
            // sharing page.
            SendDlgItemMessage(hwnd, IDC_SHARE_SHARENAME, EM_SETREADONLY, (_cShares > 0), 0);

            CheckDlgButton(hwnd, IDC_SHARE_PERMISSIONS, _IsReadonlyShare(_pCurInfo) ? BST_UNCHECKED : BST_CHECKED);
        }
        else
        {
            CheckDlgButton(hwnd, IDC_SHARE_SHAREDAS, BST_UNCHECKED );
        }
    }
    else
    {
        appDebugOut((DEB_ITRACE, "_SetControlsFromData: path is not shared\n"));
        _pCurInfo = NULL;
    }

    _fInitializingPage--;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_ReadControls, private
//
//  Synopsis:   Load the data in the controls into internal data structures.
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_ReadControls(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSimpleSharingPage);

    if (_bShareNameChanged)
    {
        appDebugOut((DEB_ITRACE, "_ReadControls: share name changed\n"));
        if (NULL != _pCurInfo)
        {
            appAssert(GetWindowTextLength(GetDlgItem(hwnd, IDC_SHARE_SHARENAME)) <= NNLEN);

            WCHAR szShareName[NNLEN + 1];
            GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName));
            TrimLeadingAndTrailingSpaces(szShareName);
            _pCurInfo->SetNetname(szShareName);
            _bShareNameChanged = FALSE;
        }
        else
        {
            appDebugOut((DEB_ITRACE, "_ReadControls: _pCurInfo is NULL\n"));
        }
    }

    if (_bSecDescChanged)
    {
        appDebugOut((DEB_ITRACE, "_ReadControls: permissions changed\n"));
        if(NULL != _pCurInfo)
        {
            PSECURITY_DESCRIPTOR pSD;
            BOOL bIsReadonly = (BST_UNCHECKED == IsDlgButtonChecked(hwnd, IDC_SHARE_PERMISSIONS));

            if (ConvertStringSecurityDescriptorToSecurityDescriptorW(
                    bIsReadonly ? c_szReadonlyShareSD : c_szFullShareSD,
                    SDDL_REVISION_1,
                    &pSD,
                    NULL))
            {
                appAssert(IsValidSecurityDescriptor(pSD));

                // _pCurInfo takes ownership of pSD; no need to free on success
                if (FAILED(_pCurInfo->TransferSecurityDescriptor(pSD)))
                {
                    LocalFree(pSD);
                }
            }

            _bSecDescChanged = FALSE;
        }
        else
        {
            appDebugOut((DEB_ITRACE, "_ReadControls: _pCurInfo is NULL\n"));
        }
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_ValidatePage, private
//
//  Synopsis:   Return TRUE if the current page is valid
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_ValidatePage(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSimpleSharingPage);

    _ReadControls(hwnd);    // read current stuff

    if (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_SHARE_SHAREDAS))
    {
        // If the user is creating a share on the property sheet (as
        // opposed to using the "new share" dialog), we must validate the
        // share.... Note that _bNewShare is still TRUE if the the user has
        // clicked on "Not Shared", so we must check that too.

        // Validate the share

        if (!_ValidateNewShareName())
        {
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            return FALSE;
        }
    }

#if DBG == 1
    Dump(L"_ValidatePage finished");
#endif // DBG == 1

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_DoApply, private
//
//  Synopsis:   If anything has changed, apply the data
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_DoApply(
    IN HWND hwnd,
    IN BOOL bClose
    )
{
    CHECK_SIG(CSimpleSharingPage);

    if (_bDirty)
    {
        HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

        BOOL bIsShared = (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_SHARE_SHAREDAS));

        if (bIsShared)
        {
            _ReadControls(hwnd);

            //
            // NTRAID#NTBUG9-382492-2001/05/05-jeffreys
            // NTRAID#NTBUG9-479914-2001/11/07-jeffreys
            //
            // Win9x boxes can't see the share if the name is longer than LM20_NNLEN
            //
            if (NULL != _pCurInfo)
            {
                if (_pCurInfo->GetFlag() == SHARE_FLAG_ADDED)
                {
                    PCWSTR pszName = _pCurInfo->GetNetname();
                    if (NULL != pszName &&
                        !IsValidWin9xShareLength(pszName) &&
                        IDNO == MyConfirmationDialog(hwnd, MSG_LONGNAMECONFIRM, MB_YESNO | MB_ICONWARNING, pszName))
                    {
                        return FALSE;
                    }
                }
            }
        }

        _CommitShares(!bIsShared);

        if (_bDirty)
        {
            DWORD dwLevel;
            BOOL bIsPrivate = (_bIsPrivateVisible && BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_SHARE_NOTSHARED));

            appAssert(!(bIsShared && bIsPrivate));

            if (bIsPrivate)
            {
                // Private to the current user
                dwLevel = 0;
            }
            else if (!bIsShared)
            {
                // Default ACL (neither private nor shared)
                dwLevel = 1;
            }
            else if (BST_UNCHECKED == IsDlgButtonChecked(hwnd, IDC_SHARE_PERMISSIONS))
            {
                // Read-only share
                dwLevel = 2;
            }
            else
            {
                // Read-write share
                dwLevel = 3;
            }

            _SetFolderPermissions(dwLevel);
        }

        CShareBase::_DoApply(hwnd, bClose);

        if (!bClose)
        {
            _InitializeControls(hwnd);
        }

        SetCursor(hcur);
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_DoCancel, private
//
//  Synopsis:   Do whatever is necessary to cancel the changes
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_DoCancel(
    IN HWND hwnd
    )
{
    CHECK_SIG(CSimpleSharingPage);

    if (_bDirty)
    {
        _bShareNameChanged = FALSE;
    }

    return CShareBase::_DoCancel(hwnd);
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_SetFolderPermissions, private
//
//  Synopsis:   Set new permissions on the subtree, either restricting
//              access to the current user or making the folder accessible
//              to everyone.
//
//--------------------------------------------------------------------------

typedef struct _SET_PERM_THREAD_DATA
{
    DWORD dwLevel;
    HWND hwndOwner;
    WCHAR szPath[1];
} SET_PERM_THREAD_DATA;

DWORD WINAPI _SetFolderPermissionsThread(LPVOID pv)
{
    DWORD dwError = ERROR_INVALID_DATA;
    SET_PERM_THREAD_DATA *ptd = (SET_PERM_THREAD_DATA*)pv;
    if (ptd)
    {
        dwError = ERROR_SUCCESS;
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);
        if (!SetFolderPermissionsForSharing(ptd->szPath, NULL, ptd->dwLevel, ptd->hwndOwner))
        {
            dwError = GetLastError();
        }
        LocalFree(ptd);
    }
    FreeLibraryAndExitThread(g_hInstance, dwError);
    return 0;
}

BOOL
CSimpleSharingPage::_SetFolderPermissions(
    IN DWORD dwLevel
    )
{
    CHECK_SIG(CSimpleSharingPage);

    BOOL bResult = FALSE;

    IActionProgressDialog *papd = NULL;
    IActionProgress *pap = NULL;

    // Show progress UI so the user understands that we're doing a lengthy
    // operation, even though there's no way to cancel SetNamedSecurityInfo
    // or get progress from it.  This requires us to call SetNamedSecurityInfo
    // on a different thread.
    //
    // Also, if the user cancels the progress dialog, we'll release the UI
    // thread even though we can't stop the SetNamedSecurityInfo call.  Just
    // abandon the thread and let it run.
    //
    // This can lead to weird results when toggling the "Make private" checkbox
    // on a large subtree:
    // 1. toggle "Make private" and click Apply
    // 2. cancel the progress UI
    // 3. the "Make private" checkbox reverts to the previous state
    // 4. Cancel the property sheet and reopen after the disk stops grinding
    // 5. the "Make private" checkbox shows the new state
    // Apparently, SetNamedSecurityInfo sets folder security in post-order, so
    // the top folder doesn't get the new permissions until then end.
    //
    // Hopefully, this is rare enough that we don't need to do anything about it.

    HRESULT hr = CoCreateInstance(CLSID_ProgressDialog,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IActionProgressDialog,
                                  (void**)&papd);
    if (SUCCEEDED(hr))
    {
        WCHAR szTitle[64];

        IUnknown_SetSite(papd, this); // needed for modality

        LoadStringW(g_hInstance, IDS_PERM_PROGRESS_TITLE, szTitle, ARRAYLEN(szTitle));

        hr = papd->Initialize(SPINITF_MODAL | SPINITF_NOMINIMIZE, szTitle, NULL);
        if (SUCCEEDED(hr))
        {
            hr = papd->QueryInterface(IID_IActionProgress, (void**)&pap);
            if (SUCCEEDED(hr))
            {
                hr = pap->Begin(SPACTION_APPLYINGATTRIBS, SPBEGINF_MARQUEEPROGRESS);
            }
        }
    }

    // Kick off a thread to do the grunge work

    int cchPath = lstrlenW(_pszPath);
    // SET_PERM_THREAD_DATA includues room for the terminating '\0' already
    SET_PERM_THREAD_DATA *ptd = (SET_PERM_THREAD_DATA*)LocalAlloc(LPTR, sizeof(SET_PERM_THREAD_DATA) + cchPath*sizeof(WCHAR));
    if (NULL != ptd)
    {
        DWORD dwT;

        // It is possible to make a folder private with net sharing disabled.
        // It is also possible that net sharing was previously enabled and net
        // shares may still exist. Let's not confuse the user with a warning
        // about deleting net shares on child folders if we happen to have this
        // rare combination.  That is, pass NULL for the HWND when sharing is
        // disabled.

        ptd->dwLevel = dwLevel;
        ptd->hwndOwner = _bSharingEnabled ? _hwndPage : NULL;
        lstrcpynW(ptd->szPath, _pszPath, cchPath+1); // +1 for '\0'

        LoadLibraryW(L"ntshrui.dll");

        HANDLE hThread = CreateThread(NULL, 0, _SetFolderPermissionsThread, ptd, 0, &dwT);
        if (NULL == hThread)
        {
            // CreateThread failed? Do it synchronously
            bResult = SetFolderPermissionsForSharing(ptd->szPath, NULL, ptd->dwLevel, ptd->hwndOwner);
            LocalFree(ptd);
            FreeLibrary(g_hInstance);
        }
        else
        {
            // Poll for cancel every 1/2 second
            dwT = pap ? 500 : INFINITE;
            while (WAIT_TIMEOUT == WaitForSingleObject(hThread, dwT))
            {
                BOOL bCancelled;
                hr = pap->QueryCancel(&bCancelled);

                // QueryCancel pumps messages, which somehow resets
                // the cursor to normal. (_DoApply sets the hourglass)
                SetCursor(LoadCursor(NULL, IDC_WAIT));

                if (SUCCEEDED(hr) && bCancelled)
                {
                    // Abandon the worker thread
                    break;
                }
            }

            // Check the result

            bResult = TRUE;
            dwT = ERROR_SUCCESS;
            GetExitCodeThread(hThread, &dwT);

            // If the exit code is STILL_ACTIVE, assume success.
            // (failure tends to happen quickly -- access denied, etc.)
            if (STILL_ACTIVE == dwT)
            {
                dwT = ERROR_SUCCESS;
            }

            if (ERROR_SUCCESS != dwT)
            {
                SetLastError(dwT);
                bResult = FALSE;
            }

            CloseHandle(hThread);
        }
    }

    if (pap)
    {
        pap->End();
        pap->Release();
    }

    if (papd)
    {
        IUnknown_SetSite(papd, NULL);
        papd->Stop();
        papd->Release();
    }

    // If we just made the folder private, check whether the user has
    // a password. If not, offer to launch the User Accounts CPL.

    if (bResult && 0 == dwLevel && !_UserHasPassword())
    {
        WCHAR szMsg[MAX_PATH];
        WCHAR szCaption[50];
        LoadStringW(g_hInstance, IDS_PRIVATE_CREATE_PASSWORD, szMsg, ARRAYLEN(szMsg));
        LoadStringW(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));

        if (IDYES == MessageBoxW(_hwndPage, szMsg, szCaption, MB_YESNO | MB_ICONWARNING))
        {
            // Launch the User Accounts CPL to the password page
            SHELLEXECUTEINFO sei = {0};
            sei.cbSize = sizeof(SHELLEXECUTEINFO);
            sei.fMask = 0;
            sei.hwnd = _hwndPage;
            sei.nShow = SW_SHOWNORMAL;
            sei.lpFile = TEXT("nusrmgr.cpl");
            sei.lpParameters = TEXT(",initialTask=ChangePassword");
            sei.lpDirectory = NULL;
            ShellExecuteEx(&sei);
        }
    }

    return bResult;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_IsReadonlyShare, private
//
//  Synopsis:   Test whether the share ACL grants more than read access to
//              Everyone or Guest.
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_IsReadonlyShare(
    IN CShareInfo *pShareInfo
    )
{
    CHECK_SIG(CSimpleSharingPage);

    BOOL bReadonly = TRUE;

    // Get the current share ACL and check for read-only
    PSECURITY_DESCRIPTOR pSD = pShareInfo->GetSecurityDescriptor();
    if (NULL == pSD)
    {
        // Default security allows anyone to connect with Full Control
        bReadonly = FALSE;
    }
    else
    {
        PACL pDacl;
        BOOL bPresent;
        BOOL bDefault;

        if (GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefault) && NULL != pDacl)
        {
            TRUSTEE tEveryone;
            TRUSTEE tGuests;
            ACCESS_MASK dwAllMask = 0;
            ACCESS_MASK dwGuestMask = 0;

            // The masks are all initialized to zero. If one or more of the
            // calls to GetEffectiveRightsFromAcl fails, then it will look like
            // that trustee has no rights and the UI will adjust accordingly.
            // There is nothing we could do better by trapping errors from
            // GetEffectiveRightsFromAcl, so don't bother.

            BuildTrusteeWithSid(&tEveryone, (PSID)&g_WorldSid);
            tEveryone.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
            GetEffectiveRightsFromAcl(pDacl, &tEveryone, &dwAllMask);

            BuildTrusteeWithSid(&tGuests, (PSID)&g_GuestsSid);
            tGuests.TrusteeType = TRUSTEE_IS_ALIAS;
            GetEffectiveRightsFromAcl(pDacl, &tGuests, &dwGuestMask);

            if ((dwAllMask & ~(FILE_GENERIC_READ | FILE_GENERIC_EXECUTE)) != 0
                || (dwGuestMask & ~(FILE_GENERIC_READ | FILE_GENERIC_EXECUTE)) != 0)
            {
                bReadonly = FALSE;
            }
        }
        else
        {
            // NULL DACL means no security
            bReadonly = FALSE;
        }
    }

    return bReadonly;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::_UserHasPassword, private
//
//  Synopsis:   Test whether the current user has a non-blank password.
//
//--------------------------------------------------------------------------

BOOL
CSimpleSharingPage::_UserHasPassword(
    VOID
    )
{
    CHECK_SIG(CSimpleSharingPage);

    // If anything fails, we assume the user has a password
    BOOL bHasPassword = TRUE;
    ILogonEnumUsers *pEnumUsers;

    HRESULT hr = CoCreateInstance(
        CLSID_ShellLogonEnumUsers,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ILogonEnumUsers,
        (void**)&pEnumUsers);

    if (SUCCEEDED(hr))
    {
        ILogonUser *pUser;

        // Currently, this function always returns S_OK, so need to check NULL
        hr = pEnumUsers->get_currentUser(&pUser);
        if (SUCCEEDED(hr) && NULL != pUser)
        {
            VARIANT_BOOL vb = VARIANT_TRUE;

            hr = pUser->get_passwordRequired(&vb);
            if (SUCCEEDED(hr))
            {
                if (VARIANT_FALSE == vb)
                {
                    bHasPassword = FALSE;
                }
            }

            pUser->Release();
        }
        pEnumUsers->Release();
    }

    return bHasPassword;
}


#if DBG == 1

//+-------------------------------------------------------------------------
//
//  Method:     CSimpleSharingPage::Dump, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------
VOID
CSimpleSharingPage::Dump(
    IN PWSTR pszCaption
    )
{
    CHECK_SIG(CSimpleSharingPage);

    appDebugOut((DEB_TRACE,
        "CSimpleSharingPage::Dump, %ws\n",
        pszCaption));

    appDebugOut((DEB_TRACE | DEB_NOCOMPNAME,
"\t            This: 0x%08lx\n"
"\t            Path: %ws\n"
"\t            Page: 0x%08lx\n"
"\t   Initializing?: %ws\n"
"\t          Dirty?: %ws\n"
"\t  Share changed?: %ws\n"
"\tPrivate visible?: %ws\n"
"\t     _dwPermType: 0x%08lx\n"
"\t      _pInfoList: 0x%08lx\n"
"\t       _pCurInfo: 0x%08lx\n"
"\t          Shares: %d\n"
,
this,
_pszPath,
_hwndPage,
_fInitializingPage ? L"yes" : L"no",
_bDirty ? L"yes" : L"no",
_bShareNameChanged ? L"yes" : L"no",
_bIsPrivateVisible ? L"yes" : L"no",
_dwPermType,
_pInfoList,
_pCurInfo,
_cShares
));

    CShareInfo* p;

    for (p = (CShareInfo*) _pInfoList->Next();
         p != _pInfoList;
         p = (CShareInfo*) p->Next())
    {
        p->Dump(L"Prop page list");
    }

    for (p = (CShareInfo*) _pReplaceList->Next();
         p != _pReplaceList;
         p = (CShareInfo*) p->Next())
    {
        p->Dump(L"Replace list");
    }
}

#endif // DBG == 1


//+-------------------------------------------------------------------------
//
//  Method:     _IsDaclPrivateForUser
//
//  Synopsis:   See whether the DACL grants Full Control to the user
//              and locks everyone else out
//
//--------------------------------------------------------------------------

BOOL WINAPI
_IsDaclPrivateForUser(
    IN     PACL   pDacl,
    IN     PCWSTR pszUserSID
    )
{
    BOOL bResult = FALSE;

    static const struct
    {
        PSID psid;
        TRUSTEE_TYPE type;
    } rgTrustees[] =
    {
        {(PSID)&g_WorldSid,     TRUSTEE_IS_WELL_KNOWN_GROUP},
        {(PSID)&g_AdminsSid,    TRUSTEE_IS_ALIAS},
        {(PSID)&g_PowerUSid,    TRUSTEE_IS_ALIAS},
        {(PSID)&g_UsersSid,     TRUSTEE_IS_ALIAS},
    };

    if (pDacl)
    {
        PSID psidUser = NULL;
        TRUSTEE tTemp;
        ACCESS_MASK dwUserMask = 0;

        // The masks are all initialized to zero. If one or more of the
        // calls to GetEffectiveRightsFromAcl fails, then it will look like
        // that trustee has no rights and the UI will adjust accordingly.
        // There is nothing we could do better by trapping errors from
        // GetEffectiveRightsFromAcl, so don't bother.

        if (ConvertStringSidToSid(pszUserSID, &psidUser))
        {
            BuildTrusteeWithSid(&tTemp, psidUser);
            tTemp.TrusteeType = TRUSTEE_IS_USER;
            GetEffectiveRightsFromAcl(pDacl, &tTemp, &dwUserMask);
            LocalFree(psidUser);
        }

        //
        // These tests may need some fine tuning
        //
        if ((dwUserMask & FILE_ALL_ACCESS) == FILE_ALL_ACCESS)
        {
            ACCESS_MASK dwOtherMask = 0;
            UINT i;

            for (i = 0; i < ARRAYLEN(rgTrustees); i++)
            {
                ACCESS_MASK dwTempMask = 0;
                BuildTrusteeWithSid(&tTemp, rgTrustees[i].psid);
                tTemp.TrusteeType = rgTrustees[i].type;
                GetEffectiveRightsFromAcl(pDacl, &tTemp, &dwTempMask);
                dwOtherMask |= dwTempMask;
            }

            if ((dwOtherMask & ~(READ_CONTROL | SYNCHRONIZE)) == 0)
            {
                // Looks like the folder is private for this user
                bResult = TRUE;
            }
        }
    }

    return bResult;
}


BOOL _IsVolumeNTFS(PCWSTR pszFolder)
{
    WCHAR szVolume[MAX_PATH];
    DWORD dwFSFlags = 0;

    return (GetVolumePathNameW(pszFolder, szVolume, ARRAYLEN(szVolume)) &&
            GetVolumeInformationW(szVolume, NULL, 0, NULL, NULL, &dwFSFlags, NULL, 0) &&
            0 != (FS_PERSISTENT_ACLS & dwFSFlags));
}


//+-------------------------------------------------------------------------
//
//  Method:     IsFolderPrivateForUser, exported
//
//  Synopsis:   Check the DACL on a folder
//
//--------------------------------------------------------------------------

STDAPI_(BOOL)
IsFolderPrivateForUser(
    IN     PCWSTR pszFolderPath,
    IN     PCWSTR pszUserSID,
    OUT    PDWORD pdwPrivateType,
    OUT    PWSTR* ppszInheritanceSource
    )
{
    if (NULL != ppszInheritanceSource)
    {
        *ppszInheritanceSource = NULL;
    }

    if (NULL == pdwPrivateType)
    {
        return FALSE;
    }

    *pdwPrivateType = IFPFU_NOT_PRIVATE;

    if (NULL == pszFolderPath || NULL == pszUserSID)
    {
        return FALSE;
    }

    // One would think that we could call GetNamedSecurityInfo without first
    // checking for NTFS, and just let it fail on FAT volumes. However,
    // GetNamedSecurityInfo succeeds on FAT and returns a valid security
    // descriptor with a NULL DACL.  This is actually correct in that
    // a NULL DACL means no security, which is true on FAT.
    //
    // We then have the problem of trying to differentiate between a NULL
    // DACL on an NTFS volume (it can happen), and a NULL DACL from a FAT
    // volume.  Let's just check for NTFS first.

    if (!_IsVolumeNTFS(pszFolderPath))
    {
        // No ACLs, so we're done
        *pdwPrivateType = IFPFU_NOT_NTFS;
        return TRUE;
    }

    PSECURITY_DESCRIPTOR pSD = NULL;
    PACL pDacl = NULL;
    DWORD dwErr = GetNamedSecurityInfoW(
        (PWSTR)pszFolderPath,
        SE_FILE_OBJECT,
        DACL_SECURITY_INFORMATION,
        NULL,
        NULL,
        &pDacl,
        NULL,
        &pSD);

    if (ERROR_SUCCESS == dwErr)
    {
        appAssert(NULL != pSD);

        if (_IsDaclPrivateForUser(pDacl, pszUserSID))
        {
            SECURITY_DESCRIPTOR_CONTROL wControl = 0;
            DWORD dwRevision;

            *pdwPrivateType = IFPFU_PRIVATE;

            // Check the control bits to see if we are inheriting
            GetSecurityDescriptorControl(pSD, &wControl, &dwRevision);

            if ((wControl & SE_DACL_PROTECTED) == 0)
            {
                // The DACL is not protected; assume the rights are inherited.
                //
                // When making a folder private, we always protect the DACL
                // on the folder and reset child ACLs, so the assumption
                // about inheriting is correct when using the simple UI.
                //
                // If someone uses the old Security page or cacls.exe to
                // modify ACLs, then the safest thing is to disable the
                // page and only let them reset everything from higher up.
                // Well, it turns out that that's exactly what happens when
                // we set IFPFU_PRIVATE_INHERITED.

                *pdwPrivateType |= IFPFU_PRIVATE_INHERITED;

                // Does the caller want the ancestor that made this
                // subtree private?
                if (NULL != ppszInheritanceSource)
                {
                    PINHERITED_FROMW pInheritedFrom = (PINHERITED_FROMW)LocalAlloc(LPTR, sizeof(INHERITED_FROMW)*pDacl->AceCount);

                    if (pInheritedFrom != NULL)
                    {
                        dwErr = GetInheritanceSourceW(
                            (PWSTR)pszFolderPath,
                            SE_FILE_OBJECT,
                            DACL_SECURITY_INFORMATION,
                            TRUE,
                            NULL,
                            0,
                            pDacl,
                            NULL,
                            &ShareMap,
                            pInheritedFrom);

                        if (ERROR_SUCCESS == dwErr)
                        {
                            PACE_HEADER pAceHeader;
                            UINT i;

                            PSID psidUser = NULL;
                            if (ConvertStringSidToSid(pszUserSID, &psidUser))
                            {
                                // Enumerate the ACEs looking for the ACE that grants
                                // Full Control to the current user

                                for (i = 0, pAceHeader = (PACE_HEADER)FirstAce(pDacl);
                                     i < pDacl->AceCount;
                                     i++,   pAceHeader = (PACE_HEADER)NextAce(pAceHeader))
                                {
                                    PKNOWN_ACE pAce = (PKNOWN_ACE)pAceHeader;
                                    if (IsKnownAceType(pAceHeader) &&
                                        EqualSid(psidUser, &pAce->SidStart) &&
                                        (pAce->Mask & FILE_ALL_ACCESS) == FILE_ALL_ACCESS)
                                    {
                                        // Found it. But we only want the inheritance
                                        // source if it's not explicit.
                                        if (pInheritedFrom[i].GenerationGap > 0)
                                        {
                                            int cch = lstrlenW(pInheritedFrom[i].AncestorName) + 1;
                                            *ppszInheritanceSource = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*cch);
                                            if (NULL != *ppszInheritanceSource)
                                            {
                                                lstrcpynW(*ppszInheritanceSource, pInheritedFrom[i].AncestorName, cch);
                                            }
                                        }

                                        // Stop looking
                                        break;
                                    }
                                }
                                LocalFree(psidUser);
                            }
                        }

                        LocalFree(pInheritedFrom);
                    }
                }
            }
        }

        LocalFree(pSD);
    }
    else
    {
        // GetNamedSecurityInfo failed.  The path may not exist, or it may
        // be FAT. In any case, assume permissions are not available.
        *pdwPrivateType = IFPFU_NOT_NTFS;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     _MakeSecurityDescriptorForUser
//
//  Synopsis:   Insert a SID string into a string SD and convert it
//              to a binary SD.
//
//--------------------------------------------------------------------------

BOOL
_MakeSecurityDescriptorForUser(PCWSTR pszSDFormat, PCWSTR pszUserSID, PSECURITY_DESCRIPTOR *ppSD, PACL *ppDacl)
{
    BOOL bResult = FALSE;
    LPWSTR pszSD = NULL;

    *ppDacl = NULL;

    DWORD dwResult = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                    pszSDFormat,
                                    0,
                                    0,
                                    (LPWSTR)&pszSD,
                                    1,
                                    (va_list*)&pszUserSID);
    if (dwResult)
    {
        PSECURITY_DESCRIPTOR pSD;

        bResult = ConvertStringSecurityDescriptorToSecurityDescriptorW(pszSD, SDDL_REVISION_1, &pSD, NULL);
        if (bResult)
        {
            *ppSD = pSD;

            if (ppDacl)
            {
                BOOL bPresent;
                BOOL bDefault;

                GetSecurityDescriptorDacl(pSD, &bPresent, ppDacl, &bDefault);
            }
        }
        LocalFree(pszSD);
    }

    return bResult;
}


int _ShowDeleteShareWarning(HWND hwndParent)
{
    WCHAR szMsg[MAX_PATH];
    WCHAR szCaption[50];
    LoadStringW(g_hInstance, IDS_PRIVATE_CONFIRM_DELSHARE, szMsg, ARRAYLEN(szMsg));
    LoadStringW(g_hInstance, IDS_MSGTITLE, szCaption, ARRAYLEN(szCaption));

    return MessageBoxW(hwndParent, szMsg, szCaption, MB_YESNO | MB_ICONWARNING);
}


BOOL _IsRootACLSecure(PACL pDacl)
{
    TRUSTEE tTemp;
    ACCESS_MASK dwMask = 0;
    BuildTrusteeWithSid(&tTemp, (PSID)&g_WorldSid);
    tTemp.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    GetEffectiveRightsFromAcl(pDacl, &tTemp, &dwMask);
    return !(dwMask & (WRITE_DAC | WRITE_OWNER));
}


//+-------------------------------------------------------------------------
//
//  Method:     SetFolderPermissionsForSharing, exported
//
//  Parameters:
//  pszFolderPath   - Folder to adjust permissions on
//  pszUserSID      - User SID (NULL for current user)
//  dwLevel         - 0 = "private". Only the user and local system get access.
//                    1 = "not shared". Remove explicit Everyone ACE.
//                    2 = "shared read-only". Grant explicit RX to Everyone.
//                    3 = "shared read/write". Grant explicit RWXD to Everyone.
//  hwndParent      - MessageBox parent. Set to NULL to prevent warnings.
//
//  Synopsis:   Set the DACL on a folder according to the sharing level
//
//--------------------------------------------------------------------------

#define SIZEOF_EVERYONE_ACE     (sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG) + sizeof(g_WorldSid))

static const struct
{
    DWORD AceFlags;
    DWORD AccessMask;
} c_rgEveryoneAces[] =
{
    {0,                                          0},
    {CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE, FILE_GENERIC_READ | FILE_GENERIC_EXECUTE},
    {CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE, FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE | DELETE},
};

//
// Hash algorithm borrowed from shell32\hash.c
//
ULONG _HashString(PCWSTR psz)
{
    UINT hash  = 314159269;
    for(; *psz; psz++)
    {
        hash ^= (hash<<11) + (hash<<5) + (hash>>2) + (UINT)*psz;
    }
    return (hash & 0x7FFFFFFF);
}

STDAPI_(BOOL)
SetFolderPermissionsForSharing(
    IN     PCWSTR pszFolderPath,
    IN     PCWSTR pszUserSID,
    IN     DWORD  dwLevel,
    IN     HWND   hwndParent
    )
{
    BOOL bResult = FALSE;
    DWORD dwFolderFlags;
    BOOL bSpecialFolderRoot = FALSE;
    PCWSTR pszDefaultSD = NULL;
    LPWSTR pszUserSIDToFree = NULL;

    appDebugOut((DEB_ITRACE, "SetFolderPermissionsForSharing\n"));

    if (dwLevel > 3)
    {
        appDebugOut((DEB_ITRACE, "Invalid sharing level\n"));
        return FALSE;
    }

    dwFolderFlags = _CheckFolderType(pszFolderPath, pszUserSID, &bSpecialFolderRoot, &pszDefaultSD);

    if (0 == (dwFolderFlags & (CFT_FLAG_SHARING_ALLOWED | CFT_FLAG_ROOT_FOLDER)))
    {
        appDebugOut((DEB_ITRACE, "Sharing not allowed on this folder\n"));
        return FALSE;
    }

    if (0 == (dwFolderFlags & CFT_FLAG_CAN_MAKE_PRIVATE) && 0 == dwLevel)
    {
        appDebugOut((DEB_ITRACE, "Can't make this folder private\n"));
        return FALSE;
    }

    // One would think that we could call GetNamedSecurityInfo without first
    // checking for NTFS, and just let it fail on FAT volumes. However,
    // GetNamedSecurityInfo succeeds on FAT and returns a valid security
    // descriptor with a NULL DACL.  This is actually correct in that
    // a NULL DACL means no security, which is true on FAT.
    //
    // We then have the problem of trying to differentiate between a NULL
    // DACL on an NTFS volume (it can happen), and a NULL DACL from a FAT
    // volume.  Let's just check for NTFS first.

    if (!_IsVolumeNTFS(pszFolderPath))
    {
        // No ACLs, so we're done
        return (0 != dwLevel);
    }

    // If we are making the folder private, first check whether any child
    // folders are shared on the net. If so, warn that we are going to nuke them.

    CShareInfo* pWarnList = NULL;
    if (0 == dwLevel &&
        SUCCEEDED(g_ShareCache.ConstructParentWarnList(pszFolderPath, &pWarnList)) &&
        NULL != pWarnList &&
        NULL != hwndParent)
    {
        if (IDNO == _ShowDeleteShareWarning(hwndParent))
        {
            DeleteShareInfoList(pWarnList, TRUE);
            return FALSE;
        }

        // JonN 4/04/01 328512
        // Explorer Sharing Tab (NTSHRUI) should popup warning on deleting
        // SYSVOL,NETLOGON and C$, D$... shares
        for (CShareInfo* p = (CShareInfo*)pWarnList->Next();
                         p != pWarnList;
            )
        {
            CShareInfo* pNext = (CShareInfo*)p->Next();

            DWORD id = ConfirmStopShare( hwndParent, MB_YESNO, p->GetNetname() );
            if ( IDYES != id )
            {
                DeleteShareInfoList(pWarnList, TRUE);
                return FALSE;
            }

            p = pNext;
        }

    }
    // No more early returns after this point (have to free pWarnList)

    if (NULL == pszUserSID || L'\0' == pszUserSID[0])
    {
        _GetUserSid(&pszUserSIDToFree);
        pszUserSID = pszUserSIDToFree;
    }

    // Use a mutex to prevent multiple threads from setting permissions on the
    // same folder at the same time. The mutex name cannot contain '\' so hash
    // the path to obtain a name unique to this folder.

    WCHAR szMutex[30] = L"";
    wnsprintfW(szMutex, ARRAYLEN(szMutex), L"share perms %x", _HashString(pszFolderPath));

    HANDLE hMutex = CreateMutex(NULL, FALSE, szMutex);
    if (NULL != hMutex)
    {
        // Wait at most 30 seconds for any abandoned thread (or if someone is
        // squatting on the mutex), then blindly continue. This wait normally
        // completes quickly and prevents 2 threads from trying to ACL the
        // folder at the same time.
        WaitForSingleObject(hMutex, 30*1000);

        if (pszUserSID)
        {
            PSECURITY_DESCRIPTOR pSD = NULL;
            PACL pDacl = NULL;
            DWORD dwErr = GetNamedSecurityInfoW(
                (PWSTR)pszFolderPath,
                SE_FILE_OBJECT,
                DACL_SECURITY_INFORMATION,
                NULL,
                NULL,
                &pDacl,
                NULL,
                &pSD);

            if (ERROR_SUCCESS == dwErr)
            {
                PACL pDaclToFree = NULL;

                appAssert(NULL != pSD);

                if (dwFolderFlags & CFT_FLAG_CAN_MAKE_PRIVATE)
                {
                    if (_IsDaclPrivateForUser(pDacl, pszUserSID))
                    {
                        // _IsDaclPrivateForUser returns FALSE if pDacl is NULL
                        appAssert(NULL != pDacl);

                        if (0 == dwLevel)
                        {
                            // Already private, nothing to do
                            bResult = TRUE;
                            pDacl = NULL;
                        }
                        else // making public
                        {
                            if (bSpecialFolderRoot)
                            {
                                // Taking a special folder that was private, and making
                                // it public. First need to reset the DACL to default.
                                // (Special folders often have protected DACLs.)
                                if (pszDefaultSD)
                                {
                                    LocalFree(pSD);
                                    pSD = NULL;
                                    pDacl = NULL;

                                    // If this fails, pDacl will be NULL and we will fail below
                                    _MakeSecurityDescriptorForUser(pszDefaultSD, pszUserSID, &pSD, &pDacl);

                                    appDebugOut((DEB_ITRACE, "Using default security descriptor\n"));
                                }
                            }
                            else // not root of special folder
                            {
                                SECURITY_DESCRIPTOR_CONTROL wControl = 0;
                                DWORD dwRevision;

                                // Check the control bits to see if we are inheriting
                                GetSecurityDescriptorControl(pSD, &wControl, &dwRevision);

                                if ((wControl & SE_DACL_PROTECTED) == 0)
                                {
                                    // Inheriting from parent, assume the parent folder
                                    // is private. Can't make a subfolder public.
                                    pDacl = NULL;

                                    appDebugOut((DEB_ITRACE, "Can't make private subfolder public\n"));
                                }
                                else
                                {
                                    // This folder is private and we're making it public.
                                    // Eliminate all explicit ACEs and reset the protected
                                    // bit so it inherits normal permissions from its parent.

                                    pDacl->AceCount = 0;
                                    SetSecurityDescriptorControl(pSD, SE_DACL_PROTECTED, 0);
                                }
                            }
                        }
                    }
                    else // Not currently private
                    {
                        if (0 == dwLevel)
                        {
                            // Reset the DACL to private before continuing below
                            LocalFree(pSD);
                            pSD = NULL;
                            pDacl = NULL;

                            // If this fails, pDacl will be NULL and we will fail below
                            _MakeSecurityDescriptorForUser(c_szPrivateFolderSD, pszUserSID, &pSD, &pDacl);
                        }
                    }
                }
                else // can't make private
                {
                    // We check for this above
                    appAssert(0 != dwLevel);
                }

                if ((dwFolderFlags & CFT_FLAG_ROOT_FOLDER) && NULL != pDacl)
                {
                    // Currently can't make root folders private
                    appAssert(0 != dwLevel);

                    //
                    // NTRAID#NTBUG9-378617-2001/05/04-jeffreys
                    //
                    // Root ACLs tend to have an explicit Everyone ACE, which
                    // screws us up in some cases.  Easiest thing is to start
                    // with a new ACL and don't touch the Everyone entry below.
                    //

                    BOOL bRootIsSecure = _IsRootACLSecure(pDacl);

                    LocalFree(pSD);
                    pSD = NULL;
                    pDacl = NULL;

                    // If this fails, pDacl will be NULL and we will fail below
                    _MakeSecurityDescriptorForUser(bRootIsSecure ? c_szRootSDSecure : c_szRootSDUnsecure, pszUserSID, &pSD, &pDacl);

                    appDebugOut((DEB_ITRACE, "Using default security descriptor\n"));
                }

                //
                // If we're making the folder public, adjust the existing ACL
                //
                if (NULL != pDacl && 0 != dwLevel)
                {
                    PKNOWN_ACE pAce;
                    int iEntry;
                    USHORT cAces = 0;
                    ULONG cbExplicitAces = 0;

                    // Adjust the level to use as an index into c_rgEveryoneAces
                    DWORD dwPublicLevel = dwLevel - 1;
                    appAssert(dwPublicLevel < ARRAYLEN(c_rgEveryoneAces));

                    for (iEntry = 0, pAce = (PKNOWN_ACE)FirstAce(pDacl);
                         iEntry < pDacl->AceCount;
                         iEntry++, pAce = (PKNOWN_ACE)NextAce(pAce))
                    {
                        // Assuming the ACL is canonical, we can stop as soon as we find
                        // an inherited ACE, since the rest will all be inherited and we
                        // can't modify those.
                        if (AceInherited(&pAce->Header))
                            break;

                        cAces++;
                        cbExplicitAces += pAce->Header.AceSize;

                        if (!(dwFolderFlags & CFT_FLAG_ROOT_FOLDER) &&
                            IsKnownAceType(pAce) &&
                            EqualSid((PSID)&pAce->SidStart, (PSID)&g_WorldSid))
                        {
                            pAce->Header.AceFlags = (UCHAR)c_rgEveryoneAces[dwPublicLevel].AceFlags;
                            pAce->Mask = c_rgEveryoneAces[dwPublicLevel].AccessMask;

                            // We don't need to add another Everyone ACE below
                            dwPublicLevel = 0;
                        }
                    }

                    // Trim off inherited ACEs. We don't need to include them when
                    // saving the new ACL, and this generally leaves enough space
                    // in the ACL to add an Everyone ACE if we need to.
                    pDacl->AceCount = cAces;

                    if (0 != dwPublicLevel)
                    {
                        // Need to add an explicit entry for Everyone.

                        ULONG cbAclSize = sizeof(ACL) + SIZEOF_EVERYONE_ACE + cbExplicitAces;

                        if (cbAclSize > (ULONG)pDacl->AclSize)
                        {
                            // No room in the existing ACL.  Allocate a new
                            // ACL and copy existing entries (if any)
                            pDaclToFree = (PACL)LocalAlloc(LPTR, cbAclSize);
                            if (NULL != pDaclToFree)
                            {
                                CopyMemory(pDaclToFree, pDacl, pDacl->AclSize);
                                pDaclToFree->AclSize = (USHORT)cbAclSize;
                                pDacl = pDaclToFree;
                            }
                            else
                            {
                                // Fail
                                pDacl = NULL;
                                appDebugOut((DEB_ITRACE, "Unable to alloc buffer for new ACL\n"));
                            }
                        }

                        if (NULL != pDacl)
                        {
                            appAssert(cbAclSize <= (ULONG)pDacl->AclSize);

                            if (!AddAccessAllowedAceEx(pDacl,
                                                       ACL_REVISION2,
                                                       c_rgEveryoneAces[dwPublicLevel].AceFlags,
                                                       c_rgEveryoneAces[dwPublicLevel].AccessMask,
                                                       (PSID)&g_WorldSid))
                            {
                                // Fail
                                pDacl = NULL;
                                appDebugOut((DEB_ITRACE, "Unable to add Everyone ACE\n"));
                            }
                        }
                    }
                }

                //
                // Set the new DACL on the folder
                //
                if (NULL != pDacl)
                {
                    SECURITY_INFORMATION si;
                    SECURITY_DESCRIPTOR_CONTROL wControl = 0;
                    DWORD dwRevision;

                    GetSecurityDescriptorControl(pSD, &wControl, &dwRevision);

                    if (SE_DACL_PROTECTED & wControl)
                    {
                        // The security descriptor specifies SE_DACL_PROTECTED
                        si = DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION;
                    }
                    else
                    {
                        // Prevent the system from automagically protecting the DACL
                        si = DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION;
                    }

                    if (0 == dwLevel)
                    {
                        // To make the folder private, we have to make sure we blow
                        // away any explicit permissions on children, so use
                        // TreeResetNamedSecurityInfo with KeepExplicit = FALSE.

                        // TreeResetNamedSecurityInfo has a callback mechanism, but
                        // we currently don't use it. Note that the paths passed to
                        // the callback look like
                        //     "\Device\HarddiskVolume1\dir\name"

                        appDebugOut((DEB_ITRACE, "Making folder private; resetting child ACLs\n"));
                        appAssert(si == (DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION));

                        dwErr = TreeResetNamedSecurityInfoW(
                            (PWSTR)pszFolderPath,
                            SE_FILE_OBJECT,
                            si,
                            NULL,
                            NULL,
                            pDacl,
                            NULL,
                            FALSE,  // KeepExplicit (perms on children)
                            NULL,
                            ProgressInvokeNever,
                            NULL
                            );

                        if (ERROR_SUCCESS == dwErr && NULL != pWarnList)
                        {
                            // Nuke child shares
                            for (CShareInfo* p = (CShareInfo*)pWarnList->Next();
                                 p != pWarnList;
                                 )
                            {
                                CShareInfo* pNext = (CShareInfo*)p->Next();

                                if (p->GetFlag() != SHARE_FLAG_ADDED)
                                {
                                    p->SetDirtyFlag(SHARE_FLAG_REMOVE);
                                    p->Commit(NULL);
                                    SHChangeNotify(SHCNE_NETSHARE, SHCNF_PATH, p->GetPath(), NULL);
                                }

                                // get rid of p
                                p->Unlink();
                                delete p;

                                p = pNext;
                            }
                        }
                    }
                    else
                    {
                        // To make the folder public, we grant access at this level
                        // without blowing away child permissions, including DACL
                        // protection. This means that a private subfolder will still
                        // be private. Use SetNamedSecurityInfo for these, since
                        // TreeResetNamedSecurityInfo always removes SE_DACL_PROTECTED
                        // from children.

                        dwErr = SetNamedSecurityInfoW(
                            (PWSTR)pszFolderPath,
                            SE_FILE_OBJECT,
                            si,
                            NULL,
                            NULL,
                            pDacl,
                            NULL);
                    }

                    if (ERROR_SUCCESS == dwErr)
                    {
                        bResult = TRUE;
                    }
                }

                LocalFree(pDaclToFree);
                LocalFree(pSD);
            }
        }

        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
    }

    LocalFree(pszUserSIDToFree);

    if (NULL != pWarnList)
    {
        DeleteShareInfoList(pWarnList, TRUE);
    }

    return bResult;
}


//
//  Description:
//      Dialog proc for the enabling sharing warning dialog.
//  
INT_PTR
WarningDlgProc(
    IN HWND hWnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM /*lParam*/
    )
{
    switch (msg)
    {
    case WM_INITDIALOG:
        {
            //
            //  Load warning icon from USER32.
            //

            HICON hIcon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_WARNING));
            if (hIcon)
            {
                SendDlgItemMessage(hWnd, IDC_ICON_INFO, STM_SETICON, (WPARAM )hIcon, 0L);
            }

            //
            //  Set default radio item.
            //

            SendDlgItemMessage(hWnd, IDC_RB_RUN_THE_WIZARD, BM_SETCHECK, BST_CHECKED, 0);
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            if ( BN_CLICKED == HIWORD(wParam) )
            {
                UINT iRet = (UINT) SendDlgItemMessage(hWnd, IDC_RB_RUN_THE_WIZARD, BM_GETCHECK, 0, 0 );
                if ( BST_CHECKED == iRet )
                {
                    EndDialog(hWnd, IDC_RB_RUN_THE_WIZARD );
                }
                else
                {
                    EndDialog(hWnd, IDC_RB_ENABLE_FILE_SHARING );
                }
            }
            break;

        case IDCANCEL:
            if ( BN_CLICKED == HIWORD(wParam) )
            {
                EndDialog(hWnd, IDCANCEL);
                return TRUE;
            }
            break;
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\dlgnew.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dlgnew.cxx
//
//  Contents:   "New Share" dialog
//
//  History:    21-Feb-95 BruceFo Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "helpids.h"
#include "dlgnew.hxx"
#include "acl.hxx"
#include "util.hxx"
#include "shrinfo.hxx"

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Member:     CDlgNewShare::SizeWndProc, public
//
//  Synopsis:   "allow" edit window subclass proc to disallow non-numeric
//              characters.
//
//  History:    5-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

LRESULT CALLBACK
CDlgNewShare::SizeWndProc(
    IN HWND hwnd,
    IN UINT wMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (wMsg)
    {
    case WM_CHAR:
    {
        WCHAR chCharCode = (WCHAR)wParam;
        if (   (chCharCode == TEXT('\t'))
            || (chCharCode == TEXT('\b'))
            || (chCharCode == TEXT('\n'))
            )
        {
            break;
        }

        if (chCharCode < TEXT('0') || chCharCode > TEXT('9'))
        {
            // bad key: ignore it
            MessageBeep(0xffffffff);    // let user know it's an illegal char
            return FALSE;
        }

        break;
    }
    } // end of switch

    CDlgNewShare* pThis = (CDlgNewShare*)GetWindowLongPtr(GetParent(hwnd),GWLP_USERDATA);
    appAssert(NULL != pThis);
    return CallWindowProc(pThis->_pfnAllowProc, hwnd, wMsg, wParam, lParam);
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::CDlgNewShare, private
//
//  Synopsis:   constructor
//
//--------------------------------------------------------------------------
CDlgNewShare::CDlgNewShare(
    IN HWND hwndParent,
    IN PWSTR pszMachine
    )
    :
    CDialog(hwndParent, MAKEINTRESOURCE(IDD_NEW_SHARE)),
    _pszMachine(pszMachine),
    _bShareNameChanged(FALSE),
    _bPathChanged(FALSE),
    _bCommentChanged(FALSE),
    _wMaxUsers(DEFAULT_MAX_USERS),
    _fSecDescModified(FALSE),
    _pfnAllowProc(NULL),
    _pShareInfo(NULL)
{
    INIT_SIG(CDlgNewShare);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::~CDlgNewShare, private
//
//  Synopsis:   destructor
//
//--------------------------------------------------------------------------
CDlgNewShare::~CDlgNewShare()
{
    CHECK_SIG(CDlgNewShare);

    delete _pShareInfo;
    _pShareInfo = NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::DlgProc, private
//
//  Synopsis:   Dialog Procedure for this object
//
//--------------------------------------------------------------------------
INT_PTR
CDlgNewShare::DlgProc(
    IN HWND hwnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    CHECK_SIG(CDlgNewShare);

    static DWORD aHelpIds[] =
    {
        IDOK,                   HC_OK,
        IDCANCEL,               HC_CANCEL,
        IDC_SHARE_SHARENAME,    HC_SHARE_SHARENAME,
        IDC_SHARE_PATH,         HC_SHARE_PATH,
        IDC_SHARE_COMMENT,      HC_SHARE_COMMENT,
        IDC_SHARE_MAXIMUM,      HC_SHARE_MAXIMUM,
        IDC_SHARE_ALLOW,        HC_SHARE_ALLOW,
        IDC_SHARE_ALLOW_VALUE,  HC_SHARE_ALLOW_VALUE,
        IDC_SHARE_PERMISSIONS,  HC_SHARE_PERMISSIONS,
        0,0
    };

    switch (msg)
    {
    case WM_INITDIALOG:
        return _OnInitDialog(hwnd);

    case WM_COMMAND:
        return _OnCommand(hwnd, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);

    case WM_VSCROLL:
        // The up/down control changed the edit control: select it again
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
        return TRUE;

    case WM_HELP:
    {
        LPHELPINFO lphi = (LPHELPINFO)lParam;

        if (lphi->iContextType == HELPINFO_WINDOW)  // a control
        {
            WCHAR szHelp[50];
            LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
            WinHelp(
                (HWND)lphi->hItemHandle,
                szHelp,
                HELP_WM_HELP,
                (DWORD_PTR)aHelpIds);
        }
        break;
    }

    case WM_CONTEXTMENU:
    {
        WCHAR szHelp[50];
        LoadString(g_hInstance, IDS_HELPFILENAME, szHelp, ARRAYLEN(szHelp));
        WinHelp(
            (HWND)wParam,
            szHelp,
            HELP_CONTEXTMENU,
            (DWORD_PTR)aHelpIds);
        break;
    }

    case WM_DESTROY:
    {
        // restore original subclass to window.
        appAssert(NULL != GetDlgItem(hwnd,IDC_SHARE_ALLOW_VALUE));
        SetWindowLongPtr(GetDlgItem(hwnd,IDC_SHARE_ALLOW_VALUE), GWLP_WNDPROC, (LONG_PTR)_pfnAllowProc);
        return FALSE;
    }

    } // end of switch

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::_OnInitDialog, private
//
//  Synopsis:   WM_INITDIALOG handler
//
//--------------------------------------------------------------------------

BOOL
CDlgNewShare::_OnInitDialog(
    IN HWND hwnd
    )
{
    CHECK_SIG(CDlgNewShare);

    HRESULT hr;

    // for some reason, this dialog comes up on the bottom!
//  SetWindowPos(hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
//  SetActiveWindow(hwnd);
    SetForegroundWindow(hwnd);

    // Use a trick from the property sheet code to properly place the dialog.
    // Basically, we want it to go wherever a new window would have gone, not
    // always in the upper-left corner of the screen. This avoids the problem
    // of multiple dialogs showing up in the same place on the screen,
    // overlapping each other.

    const TCHAR c_szStatic[] = TEXT("Static");

    HWND hwndT = CreateWindowEx(0, c_szStatic, NULL,
                    WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT,
                    0, 0, NULL, NULL, g_hInstance, NULL);
    if (hwndT)
    {
        RECT rc;
        GetWindowRect(hwndT, &rc);
        DestroyWindow(hwndT);
        SetWindowPos(hwnd, NULL, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    SetDialogIconBig(hwnd, IDI_SHARESFLD);
    SetDialogIconSmall(hwnd, IDI_SHARESFLD);

    // storage for security descriptor

    _pShareInfo = new CShareInfo();
    if (NULL == _pShareInfo)
    {
        return FALSE;
    }

    hr = _pShareInfo->InitInstance();
    CHECK_HRESULT(hr);
    if (FAILED(hr))
    {
        delete _pShareInfo;
        return FALSE;
    }

    // Subclass allow edit control to disallow non-positive numbers
    _pfnAllowProc = (WNDPROC)SetWindowLongPtr(
                                    GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE),
                                    GWLP_WNDPROC,
                                    (LONG_PTR)&SizeWndProc);

    // use LanMan API constants to set maximum share name & comment lengths
    SendDlgItemMessage(hwnd, IDC_SHARE_SHARENAME, EM_LIMITTEXT, NNLEN, 0L);
    SendDlgItemMessage(hwnd, IDC_SHARE_PATH,      EM_LIMITTEXT, MAX_PATH-1, 0L);
    SendDlgItemMessage(hwnd, IDC_SHARE_COMMENT,   EM_LIMITTEXT, MAXCOMMENTSZ, 0L);

    CheckRadioButton(
            hwnd,
            IDC_SHARE_MAXIMUM,
            IDC_SHARE_ALLOW,
            IDC_SHARE_MAXIMUM);

    SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");

    // set the spin control range: 1 <--> large number
    SendDlgItemMessage(
            hwnd,
            IDC_SHARE_ALLOW_SPIN,
            UDM_SETRANGE,
            0,
            MAKELONG(g_uiMaxUsers, 1));

    SetFocus(GetDlgItem(hwnd, IDC_SHARE_SHARENAME));

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDlgNewShare::_OnCommand, private
//
//  Synopsis:   WM_COMMAND handler
//
//  History:    21-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

BOOL
CDlgNewShare::_OnCommand(
    IN HWND hwnd,
    IN WORD wNotifyCode,
    IN WORD wID,
    IN HWND hwndCtl
    )
{
    CHECK_SIG(CDlgNewShare);

    switch (wID)
    {

//
// Notifications
//

    case IDC_SHARE_MAXIMUM:
        if (BN_CLICKED == wNotifyCode)
        {
            // Take away WS_TABSTOP from the "allow users" edit control
            HWND hwndEdit = GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE);
            SetWindowLong(hwndEdit, GWL_STYLE, GetWindowLong(hwndEdit, GWL_STYLE) & ~WS_TABSTOP);

            _CacheMaxUses(hwnd);
            SetDlgItemText(hwnd, IDC_SHARE_ALLOW_VALUE, L"");
        }
        return TRUE;

    case IDC_SHARE_ALLOW:
        if (BN_CLICKED == wNotifyCode)
        {
            // Give WS_TABSTOP to the "allow users" edit control
            HWND hwndEdit = GetDlgItem(hwnd, IDC_SHARE_ALLOW_VALUE);
            SetWindowLong(hwndEdit, GWL_STYLE, GetWindowLong(hwndEdit, GWL_STYLE) | WS_TABSTOP);

            // let the spin control set the edit control
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
        }
        return TRUE;

    case IDC_SHARE_ALLOW_VALUE:
    {
        if (EN_SETFOCUS == wNotifyCode)
        {
            if (1 != IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
            {
                CheckRadioButton(
                    hwnd,
                    IDC_SHARE_MAXIMUM,
                    IDC_SHARE_ALLOW,
                    IDC_SHARE_ALLOW);
            }

            // let the spin control set the edit control
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
            SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
        }
        if (EN_KILLFOCUS == wNotifyCode)
        {
            _CacheMaxUses(hwnd);
        }

        return TRUE;
    }

    case IDC_SHARE_ALLOW_SPIN:
        if (UDN_DELTAPOS == wNotifyCode)
        {
            if (1 != IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
            {
                CheckRadioButton(
                    hwnd,
                    IDC_SHARE_MAXIMUM,
                    IDC_SHARE_ALLOW,
                    IDC_SHARE_ALLOW);
            }
        }
        return TRUE;

    case IDC_SHARE_SHARENAME:
    {
        if (wNotifyCode == EN_CHANGE)
        {
            _bShareNameChanged = TRUE;
        }
        return TRUE;
    }

    case IDC_SHARE_PATH:
    {
        if (wNotifyCode == EN_CHANGE)
        {
            _bPathChanged = TRUE;
        }
        return TRUE;
    }

    case IDC_SHARE_COMMENT:
    {
        if (wNotifyCode == EN_CHANGE)
        {
            _bCommentChanged = TRUE;
        }
        return TRUE;
    }


//
// Commands
//

    case IDOK:
        return _OnOK(hwnd);

    case IDCANCEL:
        EndDialog(hwnd, FALSE);
        return TRUE;

    case IDC_SHARE_PERMISSIONS:
        return _OnPermissions(hwnd);

    } // end of switch (wID)

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::_OnOK, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------

BOOL
CDlgNewShare::_OnOK(
    IN HWND hwnd
    )
{
    CHECK_SIG(CDlgNewShare);

    HRESULT hr;
    HRESULT uTemp;
    BOOL    fSpecial = FALSE;   // IPC$ or ADMIN$

    // Validate the share

    WCHAR szShareName[NNLEN + 1];

    if (0 == GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName)))
    {
        MyErrorDialog(hwnd, IERR_BlankShareName);
        SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
        return TRUE;
    }
    TrimLeadingAndTrailingSpaces(szShareName);

    WCHAR szPath[MAX_PATH];
    GetDlgItemText(hwnd, IDC_SHARE_PATH, szPath, ARRAYLEN(szPath));

    // Trying to create a reserved share?
    if (   (0 == _wcsicmp(g_szIpcShare,   szShareName))
        || (0 == _wcsicmp(g_szAdminShare, szShareName)))
    {
        // We will let you add IPC$ and ADMIN$ as long as there is no
        // path specified.
        if (szPath[0] != TEXT('\0'))
        {
            MyErrorDialog(hwnd, MSG_ADDSPECIAL);
            SetErrorFocus(hwnd, IDC_SHARE_PATH);
            return TRUE;
        }

        fSpecial = TRUE;
    }
    else if (!IsValidShareName(szShareName, &uTemp))
    {
        MyErrorDialog(hwnd, uTemp);
        SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
        return TRUE;
    }

    // If the user entered some ACL, warn them that we're going to nuke
    // it and let the system use its default (since special shares can't
    // have their security set).
    if (fSpecial || DriveLetterShare(szShareName))
    {
        if (_fSecDescModified)
        {
            DWORD id = MyConfirmationDialog(
                            hwnd,
                            MSG_NOSECURITYONSPECIAL,
                            MB_YESNO | MB_ICONEXCLAMATION);
            if (id == IDNO)
            {
                SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
                return TRUE;
            }
            _pShareInfo->TransferSecurityDescriptor(NULL);
        }
    }

    // Check to see that the same share isn't already used, for either the
    // same path or for another path.

    SHARE_INFO_2* info2;
    NET_API_STATUS ret = NetShareGetInfo(_pszMachine, szShareName, 2, (LPBYTE*)&info2);
    if (ret == NERR_Success)
    {
        // It is already shared. Trying to re-share IPC$ or ADMIN$?

        if (fSpecial)
        {
            MyErrorDialog(hwnd, IERR_AlreadyExistsSpecial, szShareName);
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            NetApiBufferFree(info2);
            return TRUE;
        }

        // Is it already shared for the same path?
        if (0 == _wcsicmp(info2->shi2_path, szPath))
        {
            MyErrorDialog(hwnd, IERR_AlreadyExists, szShareName);
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            NetApiBufferFree(info2);
            return TRUE;
        }

        // Shared for a different path. Ask the user if they wish to delete
        // the old share and create the new one using the name.

        DWORD id = ConfirmReplaceShare(hwnd, szShareName, info2->shi2_path, szPath);
        if (id == IDNO)
        {
            SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
            NetApiBufferFree(info2);
            return TRUE;
        }
        else if (id == IDCANCEL)
        {
            EndDialog(hwnd, FALSE);
            NetApiBufferFree(info2);
            return TRUE;
        }

        // User said to replace the old share. Do it.
        ret = NetShareDel(_pszMachine, szShareName, 0);
        if (ret != NERR_Success)
        {
            DisplayError(hwnd, IERR_CANT_DEL_SHARE, ret, szShareName);
            NetApiBufferFree(info2);
            return FALSE;
        }
        else
        {
            SHChangeNotify(SHCNE_NETUNSHARE, SHCNF_PATH, info2->shi2_path, NULL);
        }

        NetApiBufferFree(info2);
    }

    if (!fSpecial)
    {
        // Check for downlevel accessibility
        // CODEWORK we should really get rid of this at some point -- JonN 7/18/97
        ULONG nType;
        if (NERR_Success != NetpPathType(NULL, szShareName, &nType, INPT_FLAGS_OLDPATHS))
        {
            DWORD id = MyConfirmationDialog(
                            hwnd,
                            IERR_InaccessibleByDos,
                            MB_YESNO | MB_ICONEXCLAMATION,
                            szShareName);
            if (id == IDNO)
            {
                SetErrorFocus(hwnd, IDC_SHARE_SHARENAME);
                return TRUE;
            }
        }
    }

    // Everything OK, save away the data

    if (_bShareNameChanged)
    {
        hr = _pShareInfo->SetNetname(szShareName);
        CHECK_HRESULT(hr);
    }

    if (_bPathChanged)
    {
        hr = _pShareInfo->SetPath(szPath);
        CHECK_HRESULT(hr);
    }

    if (_bCommentChanged)
    {
    	WCHAR szComment[MAXCOMMENTSZ + 1];
        GetDlgItemText(hwnd, IDC_SHARE_COMMENT, szComment, ARRAYLEN(szComment));
        hr = _pShareInfo->SetRemark(szComment);
        CHECK_HRESULT(hr);
    }

    if (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_MAXIMUM))
    {
        hr = _pShareInfo->SetMaxUses(SHI_USES_UNLIMITED);
        CHECK_HRESULT(hr);
    }
    else if (1 == IsDlgButtonChecked(hwnd, IDC_SHARE_ALLOW))
    {
        _CacheMaxUses(hwnd);
        hr = _pShareInfo->SetMaxUses(_wMaxUsers);
        CHECK_HRESULT(hr);
    }

    _pShareInfo->SetDirtyFlag(SHARE_FLAG_ADDED);
    ret = _pShareInfo->Commit(_pszMachine);
    if (ret != NERR_Success)
    {
        DisplayError(hwnd, IERR_CANT_ADD_SHARE, ret, _pShareInfo->GetNetname());
    }

    if (fSpecial)
    {
        // IPC$ doesn't have a path. ADMIN$ does, but we need to get it: we
        // create the share passing in no path, as required by the API, but
        // then we ask the server what it decided to share it as.

        if (0 == _wcsicmp(g_szAdminShare, szShareName))
        {
            SHARE_INFO_2* info2;
            NET_API_STATUS ret = NetShareGetInfo(_pszMachine, szShareName, 2, (LPBYTE*)&info2);
            if (ret == NERR_Success)
            {
                SHChangeNotify(SHCNE_NETSHARE, SHCNF_PATH, info2->shi2_path, NULL);
                NetApiBufferFree(info2);
            }
            // else... oh well. No notification to the shell.
        }
    }
    else
    {
        SHChangeNotify(SHCNE_NETSHARE, SHCNF_PATH, _pShareInfo->GetPath(), NULL);
    }

    EndDialog(hwnd, TRUE);
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::_OnPermissions, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------
BOOL
CDlgNewShare::_OnPermissions(
    IN HWND hwnd
    )
{
    CHECK_SIG(CDlgNewShare);

    WCHAR szShareName[NNLEN + 1];
    GetDlgItemText(hwnd, IDC_SHARE_SHARENAME, szShareName, ARRAYLEN(szShareName));
    // don't trim spaces, this might be an existing share with spaces in its name

    PSECURITY_DESCRIPTOR pNewSecDesc = NULL;
    PSECURITY_DESCRIPTOR pSecDesc = _pShareInfo->GetSecurityDescriptor();
    appAssert(NULL == pSecDesc || IsValidSecurityDescriptor(pSecDesc));

    BOOL bSecDescChanged;
    LONG err = EditShareAcl(
                        hwnd,
                        _pszMachine,
                        szShareName,
                        pSecDesc,
                        &bSecDescChanged,
                        &pNewSecDesc);

    if (bSecDescChanged)
    {
        _fSecDescModified = TRUE;

        appAssert(IsValidSecurityDescriptor(pNewSecDesc));
        _pShareInfo->TransferSecurityDescriptor(pNewSecDesc);
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDlgNewShare::_CacheMaxUses, private
//
//  Synopsis:
//
//--------------------------------------------------------------------------
VOID
CDlgNewShare::_CacheMaxUses(
    IN HWND hwnd
    )
{
    DWORD dwRet = (DWORD)SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_GETPOS, 0, 0);
    if (HIWORD(dwRet) != 0)
    {
        _wMaxUsers = DEFAULT_MAX_USERS;

        // Reset the edit control to the new value
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_SPIN, UDM_SETPOS, 0, MAKELONG(_wMaxUsers, 0));
        SendDlgItemMessage(hwnd, IDC_SHARE_ALLOW_VALUE, EM_SETSEL, 0, (LPARAM)-1);
    }
    else
    {
        _wMaxUsers = LOWORD(dwRet);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\dutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       dutil.cxx
//
//  Contents:   Utility functions and macros for data objects
//
//  History:    14-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "dutil.hxx"

LPIDA
DataObj_GetHIDA(
    LPDATAOBJECT pdtobj,
    STGMEDIUM* pmedium
    )
{
    FORMATETC fmte = {(CLIPFORMAT)g_cfHIDA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    if (NULL != pmedium)
    {
        pmedium->pUnkForRelease = NULL;
        pmedium->hGlobal = NULL;
    }

    if (NULL == pmedium)
    {
        if (SUCCEEDED(pdtobj->QueryGetData(&fmte)))
        {
            return (LPIDA)TRUE;
        }
        else
        {
            return (LPIDA)FALSE;
        }
    }
    else if (SUCCEEDED(pdtobj->GetData(&fmte, pmedium)))
    {
        return (LPIDA)GlobalLock(pmedium->hGlobal);
    }
    return NULL;
}


VOID
HIDA_ReleaseStgMedium(
    LPIDA pida,
    STGMEDIUM* pmedium
    )
{
    if ((NULL != pmedium->hGlobal) && (pmedium->tymed==TYMED_HGLOBAL))
    {
#if DBG == 1
        if (NULL != pida)
        {
            LPIDA pidaT = (LPIDA)GlobalLock(pmedium->hGlobal);
            appAssert(pidaT == pida);
            GlobalUnlock(pmedium->hGlobal);
        }
#endif
        GlobalUnlock(pmedium->hGlobal);
    }
    else
    {
        appAssert(FALSE);
    }

    ReleaseStgMedium(pmedium);
}

LPITEMIDLIST*
ILA_Clone(
    UINT cidl,
    LPCITEMIDLIST* apidl
    )
{
    LPITEMIDLIST* aNewPidl = new LPITEMIDLIST[cidl];
    if (NULL == aNewPidl)
    {
        return NULL;
    }

    for (UINT i = 0; i < cidl; i++)
    {
        aNewPidl[i] = ILClone(apidl[i]);
        if (NULL == aNewPidl[i])
        {
            // delete what we've allocated so far
            for (UINT j = 0; j < i; j++)
            {
                ILFree(aNewPidl[i]);
            }
            delete[] aNewPidl;
            return NULL;
        }
    }

    return aNewPidl;
}

VOID
ILA_Free(
    UINT cidl,
    LPITEMIDLIST* apidl
    )
{
    for (UINT i = 0; i < cidl; i++)
    {
        ILFree(apidl[i]);
    }
    delete[] apidl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\dllmain.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       dllmain.hxx
//
//  Contents:   DLL initialization entrypoint and global variables
//
//  History:    4-Apr-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <locale.h>
#include <setupapi.h>
#include "resource.h"
#include "util.hxx"

const TCHAR c_szShellIDList[] = CFSTR_SHELLIDLIST;

//+--------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Win32 DLL initialization function
//
//  Arguments:  [hInstance] - Handle to this dll
//              [dwReason]  - Reason this function was called.  Can be
//                            Process/Thread Attach/Detach.
//
//  Returns:    BOOL    - TRUE if no error.  FALSE otherwise
//
//  History:    4-Apr-95 BruceFo  Created
//
//---------------------------------------------------------------------------

extern "C"
BOOL
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
    {
#if DBG == 1
        InitializeDebugging();
//         SharingInfoLevel = DEB_ERROR | DEB_TRACE;
        SharingInfoLevel = DEB_ERROR;
        SetWin4AssertLevel(ASSRT_BREAK | ASSRT_MESSAGE);
#endif // DBG == 1

        appDebugOut((DEB_TRACE, "shareui.dll: DllMain enter\n"));

        // Disable thread notification from OS
        DisableThreadLibraryCalls(hInstance);
        g_hInstance = hInstance;
        InitCommonControls();   // get up/down control
        setlocale(LC_CTYPE, ""); // set the C runtime library locale, for string operations
        g_cfHIDA = RegisterClipboardFormat(c_szShellIDList);

        // Determine the maximum number of users
        g_uiMaxUsers = IsWorkstationProduct()
                            ? MAX_USERS_ON_WORKSTATION
                            : MAX_USERS_ON_SERVER
                            ;

        break;
    }

    case DLL_PROCESS_DETACH:
        appDebugOut((DEB_TRACE, "shareui.dll: DllMain leave\n"));
#if DBG == 1
        UninitializeDebugging();
#endif // DBG == 1
        break;
    }

    return TRUE;
}


//
// Procedure for uninstalling this DLL (given an INF file). Note: this DLL
// really should dynamically load setupapi.dll, to avoid its overhead all the
// time.
//
void WINAPI
UninstallW(
  HWND hwndStub,
  HINSTANCE hInstance,
  LPTSTR lpszCmdLine,
  int nCmdShow
  )
{
    RUNDLLPROC pfnCheckAPI = UninstallW;  // let compiler check the prototype

    if (!lpszCmdLine || lstrlen(lpszCmdLine) >= MAX_PATH)
    {
        return;
    }

    TCHAR szSure[200];
    LoadString(g_hInstance, IDS_SUREUNINST, szSure, ARRAYLEN(szSure));
    TCHAR szTitle[200];
    LoadString(g_hInstance, IDS_MSGTITLE, szTitle, ARRAYLEN(szTitle));

    if (MessageBox(hwndStub, szSure, szTitle, MB_YESNO | MB_ICONSTOP) != IDYES)
    {
        return;
    }

    HINF hinf = SetupOpenInfFile(
                  lpszCmdLine,  // should be the name of the inf
                  NULL,         // optional Version section CLASS info
                  INF_STYLE_WIN4,
                  NULL);        // optional error line info
    if (INVALID_HANDLE_VALUE == hinf)
    {
        appDebugOut((DEB_ERROR,
            "SetupOpenInfFile failed, 0x%x\n",
            GetLastError()));
        return;
    }

    PVOID pContext = SetupInitDefaultQueueCallback(hwndStub);

    BOOL ret = SetupInstallFromInfSection(
                  hwndStub,     // optional, handle of a parent window
                  hinf,         // handle to the INF file
                  TEXT("DefaultUninstall"), // section of the INF file to install
                  SPINST_REGISTRY | SPINST_FILES,   // which lines to install from section
                  HKEY_CURRENT_USER,    // optional, key for registry installs
                  NULL,                 // optional, path for source files
                  SP_COPY_FORCE_NEWER,  // optional, specifies copy behavior
                  SetupDefaultQueueCallback, // optional, specifies callback routine
                  pContext,             // optional, callback routine context
                  NULL,                 // optional, device information set
                  NULL);                // optional, device info structure
    if (!ret)
    {
      appDebugOut((DEB_ERROR,
          "SetupInstallFromInfSection failed, 0x%x\n",
          GetLastError()));
    }

    SetupCloseInfFile(hinf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\guids.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       guids.h
//
//  Contents:   All GUIDs
//
//  History:    13-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

DEFINE_GUID(CLSID_CShares, 0x02a36f10, 0x2f6f, 0x11cf, 0x8c, 0xe4, 0x00,0xaa,0x00,0x3c,0xa9,0xf6);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\enum.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       enum.cxx
//
//  Contents:   Implementation of IEnumIDList
//
//  History:    13-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "resource.h"
#include "enum.hxx"
#include "util.hxx"


CSharesEnum::CSharesEnum(
    IN PWSTR pszMachine,
    IN DWORD level
    )
    :
    m_pszMachine(pszMachine),
    m_level(level),
    m_uFlags(0),
    m_pShares(NULL),
    m_cShares(0),
    m_dwEnumFlags(0),
    m_iCurrent(0),
    m_ulRefs(0)
{
    AddRef();
}


HRESULT
CSharesEnum::Init(
    ULONG uFlags
    )
{
    HRESULT hr = S_OK;
    LPBYTE pBuf = NULL;
    DWORD entriesread, totalentries;
    NET_API_STATUS ret = NERR_Success;

    m_uFlags = uFlags;

    //
    // Enumerate shares.
    //

    appAssert(m_level == 1 || m_level == 2);

    ret = NetShareEnum(
                m_pszMachine,
                m_level,
                &pBuf,
                0xffffffff,     // get them all!
                &entriesread,
                &totalentries,
                NULL);
    if (NERR_Success != ret)
    {
        hr = HRESULT_FROM_WIN32(ret);
    }
    else
    {
        appAssert(entriesread == totalentries);

        m_pShares = (SHARE_INFO_2*)pBuf;    // possibly level one info
        m_cShares = entriesread;

#ifdef WIZARDS
        m_dwEnumFlags = EF_SHOW_NEW_WIZARD;

        // Now, see if the machine is running the NetWare or Mac server.

        PSERVER_INFO_101 pServerInfo;
        NET_API_STATUS ret = NetServerGetInfo(m_pszMachine, 101, (LPBYTE*)&pServerInfo);
        if (NERR_Success != ret)
        {
            hr = HRESULT_FROM_WIN32(ret);
        }
        else
        {
            if (pServerInfo->sv101_type & SV_TYPE_AFP)
            {
                m_dwEnumFlags |= EF_SHOW_MAC_WIZARD;
            }
            if (pServerInfo->sv101_type & SV_TYPE_NOVELL)
            {
                m_dwEnumFlags |= EF_SHOW_NW_WIZARD;
            }

            // If *either* of the non-SMB servers are running, then all the
            // special "all" wizard object.

            if (m_dwEnumFlags & (EF_SHOW_MAC_WIZARD | EF_SHOW_NW_WIZARD))
            {
                m_dwEnumFlags |= EF_SHOW_ALL_WIZARD;
            }
        }
        NetApiBufferFree(pServerInfo);
#endif // WIZARDS
    }

    return hr;
}


CSharesEnum::~CSharesEnum()
{
    if (NULL != m_pShares)
    {
        NetApiBufferFree(m_pShares);
    }
}


STDMETHODIMP
CSharesEnum::Next(
    ULONG celt,
    LPITEMIDLIST* ppidlOut,
    ULONG* pceltFetched
    )
{
    HRESULT hr = S_OK;
    IDSHARE ids;
    ULONG celtFetched = 0;

    if (NULL == pceltFetched)
    {
        if (celt != 1)
        {
            return E_INVALIDARG;
        }
    }
    else
    {
        *pceltFetched = 0;
    }

    if (celt == 0)
    {
        return S_OK;
    }

    if (!(m_uFlags & SHCONTF_NONFOLDERS))
    {
        return S_FALSE;
    }

CopyAnother:

    if (celtFetched == celt)
    {
        if (NULL != pceltFetched)
        {
            *pceltFetched = celtFetched;
        }
        return S_OK;    // got celt elements
    }

#ifdef WIZARDS
    if (0 != m_dwEnumFlags)
    {
        // We still have some special stuff to enumerate

        if (m_dwEnumFlags & EF_SHOW_NEW_WIZARD)
        {
            FillSpecialID(&ids, SHID_SHARE_NEW, IDS_SHARE_NEW);
            m_dwEnumFlags &= ~EF_SHOW_NEW_WIZARD;
            goto CopyOne;
        }

        if (m_dwEnumFlags & EF_SHOW_NW_WIZARD)
        {
            FillSpecialID(&ids, SHID_SHARE_NW, IDS_SHARE_NW);
            m_dwEnumFlags &= ~EF_SHOW_NW_WIZARD;
            goto CopyOne;
        }

        if (m_dwEnumFlags & EF_SHOW_MAC_WIZARD)
        {
            FillSpecialID(&ids, SHID_SHARE_MAC, IDS_SHARE_MAC);
            m_dwEnumFlags &= ~EF_SHOW_MAC_WIZARD;
            goto CopyOne;
        }

        if (m_dwEnumFlags & EF_SHOW_ALL_WIZARD)
        {
            FillSpecialID(&ids, SHID_SHARE_ALL, IDS_SHARE_ALL);
            m_dwEnumFlags &= ~EF_SHOW_ALL_WIZARD;
            goto CopyOne;
        }
    }
#endif // WIZARDS

    if (m_iCurrent >= m_cShares)
    {
        // already enumerated all of them
        if (NULL != pceltFetched)
        {
            *pceltFetched = celtFetched;
        }
        return S_FALSE; // didn't copy celt
    }

    switch (m_level)
    {
    case 1: FillID1(&ids, &(((LPSHARE_INFO_1)m_pShares)[m_iCurrent])); break;
    case 2: FillID2(&ids, &(((LPSHARE_INFO_2)m_pShares)[m_iCurrent])); break;
    default: appAssert(FALSE);
    }

    ++m_iCurrent;

#ifdef WIZARDS
CopyOne:
#endif // WIZARDS

    ppidlOut[celtFetched] = ILClone((LPCITEMIDLIST)(&ids));
    if (NULL == ppidlOut[celtFetched])
    {
        // free up everything so far
        for (ULONG i = 0; i < celtFetched; i++)
        {
            ILFree(ppidlOut[i]);
        }
        return E_OUTOFMEMORY;
    }

    ++celtFetched;
    goto CopyAnother;
}


STDMETHODIMP
CSharesEnum::Skip(
    ULONG celt
    )
{
    if (m_iCurrent >= m_cShares)
    {
        return S_FALSE;
    }

    m_iCurrent += celt;
    return NOERROR;
}


STDMETHODIMP
CSharesEnum::Reset(
    VOID
    )
{
    m_iCurrent = 0;
    return NOERROR;
}


STDMETHODIMP
CSharesEnum::Clone(
    IEnumIDList** ppenum
    )
{
    return E_FAIL;  // not supported
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\makefile.inc ===
app.rc: $(SDK_INC_PATH)\windows.h \
        $(SDK_INC_PATH)\common.ver \
        $(SDK_INC_PATH)\ntverp.h \
        app.rc2 \
        share.ico \
        shrfld.ico \
        ipc.ico \
        resource.h \
        $(O)\messages.h \
        $(O)\messages.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\helpids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       helpids.h
//
//  Contents:   Help context identifiers
//
//  History:    13-Sep-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#define HC_OK                       1
#define HC_CANCEL                   2
#define HC_SHARE_SHARENAME          3
#define HC_SHARE_COMMENT            4
#define HC_SHARE_MAXIMUM            5
#define HC_SHARE_ALLOW              6
#define HC_SHARE_ALLOW_VALUE        7
#define HC_SHARE_PERMISSIONS        8
#define HC_SHARE_PATH               9

// The following are help ids for the ACL editor

#define ACL_HC_MAIN_DLG                 20
#define ACL_HC_ADD_USER_DLG             21
#define ACL_HC_ADD_USER_MEMBERS_LG_DLG  22
#define ACL_HC_ADD_USER_MEMBERS_GG_DLG  23
#define ACL_HC_ADD_USER_SEARCH_DLG      24
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\menu.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       menu.cxx
//
//  Contents:   Implementation of IContextMenu
//
//  History:    20-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "util.hxx"
#include "dutil.hxx"
#include "menu.hxx"
#include "menuutil.hxx"
#include "shares.h"
#include "resource.h"


CSharesCM::CSharesCM(
    IN HWND hwnd
    )
    :
    m_pszMachine(NULL),
    m_ulRefs(0),
    m_hwnd(hwnd),
    m_cidl(0),
    m_apidl(NULL),
    m_psf(NULL)
{
    AddRef();
}


HRESULT
CSharesCM::InitInstance(
    IN PWSTR pszMachine,
    IN UINT cidl,
    IN LPCITEMIDLIST* apidl,
    IN IShellFolder* psf
    )
{
    m_pszMachine = pszMachine;

    m_cidl = cidl;
    m_apidl = ILA_Clone(cidl, apidl);
    if (NULL == m_apidl)
    {
        return E_OUTOFMEMORY;
    }

    appAssert(NULL != psf);
    m_psf = psf;
    m_psf->AddRef();

    return S_OK;
}


CSharesCM::~CSharesCM()
{
    ILA_Free(m_cidl, m_apidl);
    m_cidl = 0;
    m_apidl = NULL;

    appAssert(NULL != m_psf);
    m_psf->Release();
    m_psf = NULL;

    m_pszMachine = NULL;
}


STDMETHODIMP
CSharesCM::QueryContextMenu(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags
    )
{
    if (uFlags & CMF_DVFILE)
    {
        // This IContextMenu was created to add items to the DefView "File"
        // menu. This menu already has 4 standard items: Create Shortcut,
        // Delete, Rename, and Properties. Since we only want Delete and
        // Properties, and don't need to add anything, we simply do nothing
        // and let DefView do the work.
        return ResultFromShort(0);
    }
    else
    {
        // Got an IContextMenu because of a double-click on the item (to get
        // the default item) or a right-click on the item (to display the
        // entire context menu). So, put it up.

        QCMINFO qcm = { hmenu, indexMenu, idCmdFirst, idCmdLast };
        MyMergeMenu(g_hInstance, POPUP_SHARE, 0, &qcm);

        ULONG dwInOut = SFGAO_CANDELETE | SFGAO_HASPROPSHEET | SFGAO_CANRENAME;
        HRESULT hr = m_psf->GetAttributesOf(m_cidl, (LPCITEMIDLIST*)m_apidl, &dwInOut);
        CHECK_HRESULT(hr);
        if (FAILED(hr))
        {
            return hr;
        }

        if (!(dwInOut & SFGAO_CANDELETE))
        {
            EnableMenuItem(hmenu, idCmdFirst + SHARED_FILE_DELETE, MF_GRAYED | MF_BYCOMMAND);
        }
        if (!(dwInOut & SFGAO_CANRENAME))
        {
            EnableMenuItem(hmenu, idCmdFirst + SHARED_FILE_RENAME, MF_GRAYED | MF_BYCOMMAND);
        }
        if (!(dwInOut & SFGAO_HASPROPSHEET))
        {
            EnableMenuItem(hmenu, idCmdFirst + SHARED_FILE_PROPERTIES, MF_GRAYED | MF_BYCOMMAND);
        }

        SetMenuDefaultItem(hmenu, idCmdFirst + SHARED_FILE_PROPERTIES, FALSE);
        return ResultFromShort(qcm.idCmdFirst - idCmdFirst);
    }
}

STDMETHODIMP
CSharesCM::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici
    )
{
    HRESULT hr = S_OK;
    LPIDSHARE pids;
    UINT i;
    UINT idCmd = (UINT)LOWORD(lpici->lpVerb);

    if (HIWORD(lpici->lpVerb))
    {
        // Deal with string commands
        PSTR pszCmd = (PSTR)lpici->lpVerb;

        // Check for "delete" and "properties" that come from the toolbar or
        // the shell view.
        if (0 == lstrcmpA(pszCmd, "delete"))
        {
            idCmd = SHARED_FILE_DELETE;
        }
        else if (0 == lstrcmpA(pszCmd, "rename"))
        {
            idCmd = SHARED_FILE_RENAME;
        }
        else if (0 == lstrcmpA(pszCmd, "properties"))
        {
            idCmd = SHARED_FILE_PROPERTIES;
        }
        else
        {
            return E_INVALIDARG;
        }
    }

    switch(idCmd)
    {
    case SHARED_FILE_DELETE:
    {
        for (UINT i = 0; i < m_cidl; i++)
        {
            pids = (LPIDSHARE)m_apidl[i];
            hr = ShareDoDelete(m_hwnd, m_pszMachine, Share_GetName(pids));
            CHECK_HRESULT(hr);
            // even if failure, keep going
        }
        break;
    }

    case SHARED_FILE_RENAME:
    {
        appAssert(!"Shouldn't get rename command here!");
        hr = E_FAIL;
        break;
    }

    case SHARED_FILE_PROPERTIES:
    {
        // should we do multiple-select properties?
        appAssert(m_cidl == 1);
        pids = (LPIDSHARE)m_apidl[0];

        // pass in a pointer to our own IUnknown
        IUnknown* punk;
        hr = QueryInterface(IID_IUnknown, (LPVOID*)&punk);
        if (SUCCEEDED(hr))
        {
            hr = ShareDoProperties(punk, m_pszMachine, Share_GetName(pids));
            punk->Release();
        }
        break;
    }

    } // switch(wParam)

    return hr;
}

STDMETHODIMP
CSharesCM::GetCommandString(
    UINT_PTR    idCmd,
    UINT        uType,
    UINT      * pwReserved,
    LPSTR       pszName,
    UINT        cchMax
    )
{
    HRESULT hr = E_FAIL;

    *((LPWSTR)pszName) = TEXT('\0');
    if (uType == GCS_HELPTEXT)
    {
        LoadStringW(g_hInstance, (UINT)(idCmd + IDS_MH_FSIDM_FIRST), (LPWSTR)pszName, cchMax);
        hr = S_OK;
    }
    else if (uType == GCS_VERB)
    {
        switch(idCmd)
        {
        case SHARED_FILE_DELETE:
        case SHARED_FILE_PROPERTIES:
            break;

        case SHARED_FILE_RENAME:
            StrNCopy((LPWSTR)pszName, c_szRename, cchMax);
            hr = S_OK;
            break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\menubg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       menubg.cxx
//
//  Contents:   Implementation of IContextMenu
//
//  History:    20-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "util.hxx"
#include "menubg.hxx"
#include "menuutil.hxx"
#include "resource.h"


STDMETHODIMP
CSharesCMBG::QueryContextMenu(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags
    )
{
    UINT idMainMerge;
    if (uFlags & CMF_DVFILE)
    {
        // This IContextMenu was created to add items to the DefView menu.
        // We only want to add a "new" item to the "File" menu, so set don't
        // do any "main" merge.
        idMainMerge = 0;
    }
    else
    {
        // In this case, it's actually a background right-click context menu,
        // so merge in the "New" menu.
        idMainMerge = POPUP_SHARESBG_POPUPMERGE2;
    }

    QCMINFO qcm = { hmenu, indexMenu, idCmdFirst, idCmdLast };

    switch (m_level)
    {
    case 1:
        MyMergeMenu(
                g_hInstance,
                0,
                POPUP_SHARESBG_POPUPMERGE1,
                &qcm);
        break;

    case 2:
        MyMergeMenu(
                g_hInstance,
                idMainMerge,
                POPUP_SHARESBG_POPUPMERGE2,
                &qcm);
        break;

    default: appAssert(FALSE);
    }

    return ResultFromShort(qcm.idCmdFirst - idCmdFirst);
}

STDMETHODIMP
CSharesCMBG::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici
    )
{
    if (HIWORD(lpici->lpVerb))
    {
        // Deal with string commands
        return E_INVALIDARG;
    }

    appAssert(ICOL1_NAME    == ICOL2_NAME);
    appAssert(ICOL1_COMMENT == ICOL2_COMMENT);

    UINT idCmd = (UINT)LOWORD(lpici->lpVerb);
    switch (idCmd)
    {
    case FSIDM_SORTBYNAME:
        ShellFolderView_ReArrange(m_hwnd, ICOL2_NAME);
        return NOERROR;

    case FSIDM_SORTBYCOMMENT:
        ShellFolderView_ReArrange(m_hwnd, ICOL2_COMMENT);
        return NOERROR;

    case FSIDM_SORTBYPATH:
        appAssert(m_level >= 2);
        ShellFolderView_ReArrange(m_hwnd, ICOL2_PATH);
        return NOERROR;

    case FSIDM_SORTBYMAXUSES:
        appAssert(m_level >= 2);
        ShellFolderView_ReArrange(m_hwnd, ICOL2_MAXUSES);
        return NOERROR;

    case FSIDM_NEWSHARE:
    {
        appAssert(m_level >= 2);
        // pass in a pointer to our own IUnknown
        IUnknown* punk;
        HRESULT hr = QueryInterface(IID_IUnknown, (LPVOID*)&punk);
        if (SUCCEEDED(hr))
        {
            hr = ShareDoNew(punk, m_pszMachine);
            punk->Release();
        }
        return hr;
    }

    default:
        return E_INVALIDARG;
    }
}

STDMETHODIMP
CSharesCMBG::GetCommandString(
    UINT_PTR    idCmd,
    UINT        uType,
    UINT      * pwReserved,
    LPSTR       pszName,
    UINT        cchMax
    )
{
    *((LPWSTR)pszName) = TEXT('\0');
    if (uType == GCS_HELPTEXT)
    {
        LoadStringW(g_hInstance, (UINT)(idCmd + IDS_MH_FSIDM_FIRST), (LPWSTR)pszName, cchMax);
        return NOERROR;
    }

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\menusp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       menusp.cxx
//
//  Contents:   Implementation of IContextMenu
//
//  History:    20-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "util.hxx"
#include "dutil.hxx"
#include "menusp.hxx"
#include "menuutil.hxx"
#include "shares.h"
#include "resource.h"


#ifdef WIZARDS

CSharesCMSpecial::CSharesCMSpecial(
    IN HWND hwnd
    )
    :
    m_pszMachine(NULL),
    m_ulRefs(0),
    m_hwnd(hwnd),
    m_pidl(NULL),
    m_psf(NULL)
{
    AddRef();
}


HRESULT
CSharesCMSpecial::InitInstance(
    IN PWSTR pszMachine,
    IN LPCITEMIDLIST pidl,
    IN IShellFolder* psf
    )
{
    m_pszMachine = pszMachine;

    m_pidl = ILClone(pidl);
    if (NULL == m_pidl)
    {
        return E_OUTOFMEMORY;
    }

    m_psf = psf;
    m_psf->AddRef();

    return S_OK;
}


CSharesCMSpecial::~CSharesCMSpecial()
{
    ILFree(m_pidl);
    m_pidl = NULL;
    m_psf->Release();
    m_psf = NULL;
    m_pszMachine = NULL;
}


STDMETHODIMP
CSharesCMSpecial::QueryContextMenu(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags
    )
{
    UINT idMerge;
    if (uFlags & CMF_DVFILE)
    {
        idMerge = POPUP_SPECIAL_FILE;
    }
    else
    {
        idMerge = POPUP_SPECIAL;
    }

    QCMINFO qcm = { hmenu, indexMenu, idCmdFirst, idCmdLast };
    MyMergeMenu(g_hInstance, idMerge, 0, &qcm);
    SetMenuDefaultItem(hmenu, idCmdFirst + FSIDM_OPENSPECIAL, FALSE);
    return ResultFromShort(qcm.idCmdFirst - idCmdFirst);
}

STDMETHODIMP
CSharesCMSpecial::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici
    )
{
    HRESULT hr = S_OK;
    LPIDSHARE pids;
    UINT i;
    UINT idCmd = (UINT)LOWORD((DWORD)lpici->lpVerb);

    if (HIWORD(lpici->lpVerb))
    {
        // Deal with string commands
        PSTR pszCmd = (PSTR)lpici->lpVerb;

        // Check for "link" that comes from the toolbar or the shell view.
        if (0 == lstrcmpA(pszCmd, "link"))
        {
            idCmd = SHARED_FILE_LINK;
        }
        else
        {
            return E_INVALIDARG;
        }
    }

    switch(idCmd)
    {
    case FSIDM_OPENSPECIAL:
    {
        pids = (LPIDSHARE)m_pidl;
        hr = ShareDoSpecial(m_hwnd, m_pszMachine, Share_GetFlags(pids));
        CHECK_HRESULT(hr);
        break;
    }

    case SHARED_FILE_LINK:
    {
        UINT dwfInOut = 0;
        IDataObject* pDataObject;
        hr = m_psf->GetUIObjectOf(
                        lpici->hwnd,
                        1,
                        (LPCITEMIDLIST*)&m_pidl,
                        IID_IDataObject,
                        &dwfInOut,
                        (LPVOID*)&pDataObject);
        if (SUCCEEDED(hr))
        {
            SHCreateLinks(
                lpici->hwnd,
                NULL,
                pDataObject,
                SHCL_USETEMPLATE,
                NULL);
            pDataObject->Release();
        }
        break;
    }

    } // switch(wParam)

    return hr;
}

STDMETHODIMP
CSharesCMSpecial::GetCommandString(
    UINT_PTR    idCmd,
    UINT        uType,
    UINT      * pwReserved,
    LPSTR       pszName,
    UINT        cchMax
    )
{
    *((LPWSTR)pszName) = TEXT('\0');
    if (uType == GCS_HELPTEXT)
    {
        LoadStringW(g_hInstance, idCmd + IDS_MH_FSIDM_FIRST, (LPWSTR)pszName, cchMax);
        return NOERROR;
    }

    return E_FAIL;
}

#endif // WIZARDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\menuutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       menuutil.cxx
//
//  Contents:   Context menu utilities, stolen from the shell. This is
//              basically CDefFolderMenu_MergeMenu and its support.
//
//  History:    20-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "menuutil.hxx"

// Cannonical command names stolen from the shell
TCHAR const c_szDelete[]     = TEXT("delete");
TCHAR const c_szCut[]        = TEXT("cut");
TCHAR const c_szCopy[]       = TEXT("copy");
TCHAR const c_szLink[]       = TEXT("link");
TCHAR const c_szProperties[] = TEXT("properties");
TCHAR const c_szPaste[]      = TEXT("paste");
TCHAR const c_szPasteLink[]  = TEXT("pastelink");
TCHAR const c_szRename[]     = TEXT("rename");

HMENU
LoadPopupMenu(
    HINSTANCE hinst,
    UINT id
    )
{
    HMENU hmParent = LoadMenu(hinst, MAKEINTRESOURCE(id));
    if (NULL == hmParent)
    {
        return NULL;
    }

    HMENU hmPopup = GetSubMenu(hmParent, 0);
    RemoveMenu(hmParent, 0, MF_BYPOSITION);
    DestroyMenu(hmParent);

    return hmPopup;
}

HMENU
MyGetMenuFromID(
    HMENU hmMain,
    UINT uID
    )
{
    MENUITEMINFO mii;

    mii.cbSize = sizeof(mii);
    mii.fMask  = MIIM_SUBMENU;
    mii.cch    = 0;     // just in case

    if (!GetMenuItemInfo(hmMain, uID, FALSE, &mii))
    {
        return NULL;
    }

    return mii.hSubMenu;
}

int
MyMergePopupMenus(
    HMENU hmMain,
    HMENU hmMerge,
    int idCmdFirst,
    int idCmdLast)
{
    int i;
    int idTemp;
    int idMax = idCmdFirst;

    for (i = GetMenuItemCount(hmMerge) - 1; i >= 0; --i)
    {
        MENUITEMINFO mii;

        mii.cbSize = sizeof(mii);
        mii.fMask  = MIIM_ID | MIIM_SUBMENU;
        mii.cch    = 0;     // just in case

        if (!GetMenuItemInfo(hmMerge, i, TRUE, &mii))
        {
            continue;
        }

        idTemp = Shell_MergeMenus(
                    MyGetMenuFromID(hmMain, mii.wID),
                    mii.hSubMenu,
                    0,
                    idCmdFirst,
                    idCmdLast,
                    MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);
        if (idMax < idTemp)
        {
            idMax = idTemp;
        }
    }

    return idMax;
}


VOID
MyMergeMenu(
    HINSTANCE hinst,
    UINT idMainMerge,
    UINT idPopupMerge,
    LPQCMINFO pqcm)
{
    HMENU hmMerge;
    UINT idMax = pqcm->idCmdFirst;
    UINT idTemp;

    if (idMainMerge
        && (hmMerge = LoadPopupMenu(hinst, idMainMerge)) != NULL)
    {
        idMax = Shell_MergeMenus(
                        pqcm->hmenu,
                        hmMerge,
                        pqcm->indexMenu,
                        pqcm->idCmdFirst,
                        pqcm->idCmdLast,
                        MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);
        DestroyMenu(hmMerge);
    }

    if (idPopupMerge
        && (hmMerge = LoadMenu(hinst, MAKEINTRESOURCE(idPopupMerge))) != NULL)
    {
        idTemp = MyMergePopupMenus(
                        pqcm->hmenu,
                        hmMerge,
                        pqcm->idCmdFirst,
                        pqcm->idCmdLast);
        if (idMax < idTemp)
        {
            idMax = idTemp;
        }
        DestroyMenu(hmMerge);
    }

    pqcm->idCmdFirst = idMax;
}


VOID
MyInsertMenu(
    HINSTANCE hinst,
    UINT idInsert,
    LPQCMINFO pqcm)
{
    HMENU hmInsert;
    UINT idMax = pqcm->idCmdFirst;

    if (idInsert
        && (hmInsert = LoadPopupMenu(hinst, idInsert)) != NULL)
    {
        for (int i = GetMenuItemCount(hmInsert) - 1; i >= 0; --i)
        {
            MENUITEMINFO mii;

            mii.cbSize = sizeof(mii);
            mii.fMask  = MIIM_ID | MIIM_SUBMENU;
            mii.cch    = 0;     // just in case

            if (!GetMenuItemInfo(hmInsert, i, TRUE, &mii))
            {
                continue;
            }

            if (!InsertMenuItem(pqcm->hmenu, idMax, TRUE, &mii))
            {
                ++idMax;
            }
        }
        DestroyMenu(hmInsert);
    }

    pqcm->idCmdFirst = idMax;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\pfolder.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       pfolder.cxx
//
//  Contents:   Implementation of IPersistFolder
//
//  History:    13-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "guids.h"
#include "pfolder.hxx"
#include "shares.hxx"
#include "util.hxx"

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesPF::GetClassID(
    LPCLSID lpClassID
    )
{
    CShares* This = IMPL(CShares,m_PersistFolder,this);
    *lpClassID = CLSID_CShares;
    return S_OK;
}


STDMETHODIMP
CSharesPF::Initialize(
    LPCITEMIDLIST pidl
    )
{
    CShares* This = IMPL(CShares,m_PersistFolder,this);
    This->m_pidl = ILClone(pidl);
    if (NULL == This->m_pidl)
    {
        return E_OUTOFMEMORY;
    }

    // Determine what share info level to use, based on which level succeeds.
    // NOTE: if this is being invoked remotely, we assume that IRemoteComputer
    // is invoked *before* IPersistFolder.

    // Try 2, then 1.
    if (IsLevelOk(This->m_pszMachine, 2))
    {
        This->m_level = 2;
    }
    else if (IsLevelOk(This->m_pszMachine, 1))
    {
        This->m_level = 1;
    }
    else
    {
        // error: can't enumerate
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\ole.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       ole.cxx
//
//  Contents:   IUnknown & IClassFactory for all OLE objects
//
//  History:    13-Dec-95    BruceFo     Created
//
//  Note:  There are three types of IUnknown implementations here. The first
//  is for the "Shared Folders" COM objects. Each of these interfaces can be
//  QueryInterface'd from the others, and all return the same IUnknown. There
//  is a single shared object reference count (not interface reference count).
//  These interfaces include: IShellFolder, IPersistFolder, IRemoteComputer.
//
//  The second type is standard, separate interfaces that get interface-specific
//  reference counts. This includes: IShellDetails, IEnumIDList,
//  IExtractIcon, IExtractIconA.
//
//  The third type is the IUnknown implementation for the "Shared Folders"
//  COM object class factory. This object is a global static object, so it
//  never gets destructed.
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <initguid.h>
#include "guids.h"

#include "ole.hxx"
#include "shares.h"
#include "shares.hxx"
#include "sdetails.hxx"
#include "sfolder.hxx"
#include "pfolder.hxx"
#include "rcomp.hxx"
#include "menu.hxx"
#include "menusp.hxx"
#include "menubg.hxx"
#include "enum.hxx"
#include "xicon.hxx"

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

ULONG g_ulcInstances = 0;

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CShares::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT hr;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        AddRef();
        *ppvObj = (IUnknown*) this;
        hr = S_OK;
    }
    else if (IsEqualIID(IID_IShellFolder, riid))
    {
        hr = m_ShellFolder.QueryInterface(riid, ppvObj);
    }
    else if (IsEqualIID(IID_IPersistFolder, riid))
    {
        hr = m_PersistFolder.QueryInterface(riid, ppvObj);
    }
    else if (IsEqualIID(IID_IRemoteComputer, riid))
    {
        hr = m_RemoteComputer.QueryInterface(riid, ppvObj);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}

STDMETHODIMP_(ULONG)
CShares::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstances);
    return InterlockedIncrement((LONG*)&m_ulRefs);
}

STDMETHODIMP_(ULONG)
CShares::Release()
{
    appAssert( 0 != m_ulRefs );
    ULONG cRef = InterlockedDecrement((LONG*)&m_ulRefs);
    if (0 == cRef)
    {
        delete this;
    }
    appAssert( 0 != g_ulcInstances );
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return cRef;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesSF::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT hr;

    if (IsEqualIID(IID_IShellFolder, riid))
    {
        AddRef();
        *ppvObj = (IShellFolder*) this;
        hr = S_OK;
    }
    else
    {
        CShares* This = IMPL(CShares,m_ShellFolder,this);
        hr = This->QueryInterface(riid, ppvObj);
    }

    return hr;
}

STDMETHODIMP_(ULONG)
CSharesSF::AddRef()
{
    CShares* This = IMPL(CShares,m_ShellFolder,this);
    return This->AddRef();
}

STDMETHODIMP_(ULONG)
CSharesSF::Release()
{
    CShares* This = IMPL(CShares,m_ShellFolder,this);
    return This->Release();
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesPF::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT hr;

    if (IsEqualIID(IID_IPersistFolder, riid))
    {
        AddRef();
        *ppvObj = (IPersistFolder*) this;
        hr = S_OK;
    }
    else
    {
        CShares* This = IMPL(CShares,m_PersistFolder,this);
        hr = This->QueryInterface(riid, ppvObj);
    }

    return hr;
}

STDMETHODIMP_(ULONG)
CSharesPF::AddRef()
{
    CShares* This = IMPL(CShares,m_PersistFolder,this);
    return This->AddRef();
}

STDMETHODIMP_(ULONG)
CSharesPF::Release()
{
    CShares* This = IMPL(CShares,m_PersistFolder,this);
    return This->Release();
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesRC::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT hr;

    if (IsEqualIID(IID_IRemoteComputer, riid))
    {
        AddRef();
        *ppvObj = (IRemoteComputer*) this;
        hr = S_OK;
    }
    else
    {
        CShares* This = IMPL(CShares,m_RemoteComputer,this);
        hr = This->QueryInterface(riid, ppvObj);
    }

    return hr;
}

STDMETHODIMP_(ULONG)
CSharesRC::AddRef()
{
    CShares* This = IMPL(CShares,m_RemoteComputer,this);
    return This->AddRef();
}

STDMETHODIMP_(ULONG)
CSharesRC::Release()
{
    CShares* This = IMPL(CShares,m_RemoteComputer,this);
    return This->Release();
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesSD::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        pUnkTemp = (IUnknown*)(IShellDetails*) this;
    }
    else if (IsEqualIID(IID_IShellDetails, riid))
    {
        pUnkTemp = (IUnknown*)(IShellDetails*) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;
    return hr;
}

STDMETHODIMP_(ULONG)
CSharesSD::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstances);
    return InterlockedIncrement((LONG*)&m_ulRefs);
}

STDMETHODIMP_(ULONG)
CSharesSD::Release()
{
    appAssert( 0 != m_ulRefs );
    ULONG cRef = InterlockedDecrement((LONG*)&m_ulRefs);
    if (0 == cRef)
    {
        delete this;
    }
    appAssert( 0 != g_ulcInstances );
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return cRef;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesCM::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        pUnkTemp = (IUnknown*)(IContextMenu*) this;
    }
    else if (IsEqualIID(IID_IContextMenu, riid))
    {
        pUnkTemp = (IUnknown*)(IContextMenu*) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;
    return hr;
}

STDMETHODIMP_(ULONG)
CSharesCM::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstances);
    return InterlockedIncrement((LONG*)&m_ulRefs);
}

STDMETHODIMP_(ULONG)
CSharesCM::Release()
{
    appAssert( 0 != m_ulRefs );
    ULONG cRef = InterlockedDecrement((LONG*)&m_ulRefs);
    if (0 == cRef)
    {
        delete this;
    }
    appAssert( 0 != g_ulcInstances );
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return cRef;
}

//////////////////////////////////////////////////////////////////////////////

#ifdef WIZARDS

STDMETHODIMP
CSharesCMSpecial::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        pUnkTemp = (IUnknown*)(IContextMenu*) this;
    }
    else if (IsEqualIID(IID_IContextMenu, riid))
    {
        pUnkTemp = (IUnknown*)(IContextMenu*) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;
    return hr;
}

STDMETHODIMP_(ULONG)
CSharesCMSpecial::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstances);
    return InterlockedIncrement((LONG*)&m_ulRefs);
}

STDMETHODIMP_(ULONG)
CSharesCMSpecial::Release()
{
    appAssert( 0 != m_ulRefs );
    ULONG cRef = InterlockedDecrement((LONG*)&m_ulRefs);
    if (0 == cRef)
    {
        delete this;
    }
    appAssert( 0 != g_ulcInstances );
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return cRef;
}

#endif // WIZARDS

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesCMBG::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        pUnkTemp = (IUnknown*)(IContextMenu*) this;
    }
    else if (IsEqualIID(IID_IContextMenu, riid))
    {
        pUnkTemp = (IUnknown*)(IContextMenu*) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;
    return hr;
}

STDMETHODIMP_(ULONG)
CSharesCMBG::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstances);
    return InterlockedIncrement((LONG*)&m_ulRefs);
}

STDMETHODIMP_(ULONG)
CSharesCMBG::Release()
{
    appAssert( 0 != m_ulRefs );
    ULONG cRef = InterlockedDecrement((LONG*)&m_ulRefs);
    if (0 == cRef)
    {
        delete this;
    }
    appAssert( 0 != g_ulcInstances );
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return cRef;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesEnum::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        pUnkTemp = (IUnknown*)(IEnumIDList*) this;
    }
    else if (IsEqualIID(IID_IEnumIDList, riid))
    {
        pUnkTemp = (IUnknown*)(IEnumIDList*) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;
    return hr;
}

STDMETHODIMP_(ULONG)
CSharesEnum::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstances);
    return InterlockedIncrement((LONG*)&m_ulRefs);
}

STDMETHODIMP_(ULONG)
CSharesEnum::Release()
{
    appAssert( 0 != m_ulRefs );
    ULONG cRef = InterlockedDecrement((LONG*)&m_ulRefs);
    if (0 == cRef)
    {
        delete this;
    }
    appAssert( 0 != g_ulcInstances );
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return cRef;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesEI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        pUnkTemp = (IUnknown*)(IExtractIcon*) this;
    }
    else if (IsEqualIID(IID_IExtractIcon, riid))
    {
        pUnkTemp = (IUnknown*)(IExtractIcon*) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;
    return hr;
}

STDMETHODIMP_(ULONG)
CSharesEI::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstances);
    return InterlockedIncrement((LONG*)&m_ulRefs);
}

STDMETHODIMP_(ULONG)
CSharesEI::Release()
{
    appAssert( 0 != m_ulRefs );
    ULONG cRef = InterlockedDecrement((LONG*)&m_ulRefs);
    if (0 == cRef)
    {
        delete this;
    }
    appAssert( 0 != g_ulcInstances );
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return cRef;
}

//////////////////////////////////////////////////////////////////////////////

#ifdef UNICODE

STDMETHODIMP
CSharesEIA::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        pUnkTemp = (IUnknown*)(IExtractIconA*) this;
    }
    else if (IsEqualIID(IID_IExtractIcon, riid))
    {
        pUnkTemp = (IUnknown*)(IExtractIconA*) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;
    return hr;
}

STDMETHODIMP_(ULONG)
CSharesEIA::AddRef()
{
    InterlockedIncrement((LONG*)&g_ulcInstances);
    return InterlockedIncrement((LONG*)&m_ulRefs);
}

STDMETHODIMP_(ULONG)
CSharesEIA::Release()
{
    appAssert( 0 != m_ulRefs );
    ULONG cRef = InterlockedDecrement((LONG*)&m_ulRefs);
    if (0 == cRef)
    {
        delete this;
    }
    appAssert( 0 != g_ulcInstances );
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return cRef;
}

#endif // UNICODE

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesCF::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;

    IUnknown* pUnkTemp = NULL;
    HRESULT   hr = S_OK;

    if (IsEqualIID(IID_IUnknown, riid))
    {
        pUnkTemp = (IUnknown*)(IClassFactory*) this;
    }
    else if (IsEqualIID(IID_IClassFactory, riid))
    {
        pUnkTemp = (IUnknown*)(IClassFactory*) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if (pUnkTemp != NULL)
    {
        pUnkTemp->AddRef();
    }

    *ppvObj = pUnkTemp;
    return hr;
}

STDMETHODIMP_(ULONG)
CSharesCF::AddRef()
{
    return InterlockedIncrement((LONG*)&g_ulcInstances);
}

STDMETHODIMP_(ULONG)
CSharesCF::Release()
{
    appAssert( 0 != g_ulcInstances );
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return g_ulcInstances;
}

STDMETHODIMP
CSharesCF::CreateInstance(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj)
{
    if (pUnkOuter != NULL)
    {
        // don't support aggregation
        return E_NOTIMPL;
    }

    CShares* pShare = new CShares();
    if (NULL == pShare)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pShare->QueryInterface(riid, ppvObj);
    pShare->Release();
    return hr;
}

STDMETHODIMP
CSharesCF::LockServer(BOOL fLock)
{
    return S_OK; // FEATURE: Whats supposed to happen here?
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

STDAPI
DllCanUnloadNow(
    VOID
    )
{
    if (0 == g_ulcInstances
        && 0 == g_NonOLEDLLRefs)
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

CSharesCF cfCShares;

STDAPI
DllGetClassObject(
    REFCLSID cid,
    REFIID iid,
    LPVOID* ppvObj
    )
{
    InterlockedIncrement((LONG*)&g_ulcInstances); // don't nuke me now!

    HRESULT hr = E_NOINTERFACE;

    if (IsEqualCLSID(cid, CLSID_CShares))
    {
        hr = cfCShares.QueryInterface(iid, ppvObj);
    }

    appAssert( 0 != g_ulcInstances );
    InterlockedDecrement((LONG*)&g_ulcInstances);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\rcomp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       rcomp.cxx
//
//  Contents:   Implementation of IRemoteComputer
//
//  History:    13-Dec-95    BruceFo     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "guids.h"
#include "rcomp.hxx"
#include "shares.hxx"
#include "util.hxx"

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSharesRC::Initialize(
    LPCWSTR pszMachine,
    BOOL bEnumerating
    )
{
    CShares* This = IMPL(CShares,m_RemoteComputer,this);

    if (NULL == pszMachine)
    {
        return E_INVALIDARG;
    }

    //
    // We only want to show the remote shares folder if it is an NT
    // server and the user has administrative access. That means that
    // NetShareEnum must pass at least level 2.
    //

    if (bEnumerating)
    {
        if (!IsLevelOk(const_cast<LPWSTR>(pszMachine), 2))
        {
            return E_FAIL;
        }
    }

    This->m_pszMachine = NewDup(pszMachine);
    if (NULL == This->m_pszMachine)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\lmui\shareui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by app.rc
//

#include <shlobj.h>
#include <shlobjp.h>

#define IDS_APP_MSG_NOT_FOUND           100
#define IDS_NET_MSG_NOT_FOUND           101
#define IDS_NO_NET_MSG                  102
#define IDS_MSGTITLE                    103
#define IDS_SHARE_MENUHELP              105
#define IDS_ACLEDIT_PERM_GEN_NO_ACCESS  106
#define IDS_ACLEDIT_PERM_GEN_READ       107
#define IDS_ACLEDIT_PERM_GEN_MODIFY     108
#define IDS_ACLEDIT_PERM_GEN_ALL        109
#define IDS_ACLEDIT_TITLE               110
#define IDS_HELPFILENAME                111
#define IDS_NAME                        112
#define IDS_COMMENT                     113
#define IDS_PATH                        114
#define IDS_MAXUSES                     115
#define IDS_UNLIMITED                   116
#define IDS_SHARE_PROPTITLE             117
#ifdef WIZARDS
#define IDS_SHARE_NEW                   118
#define IDS_SHARE_NW                    119
#define IDS_SHARE_MAC                   120
#define IDS_SHARE_ALL                   121
#endif // WIZARDS
#define IDS_SUREUNINST                  122
#define IDS_SHAREPERM_READ              123
#define IDS_SHAREPERM_MODIFY            124
#define IDS_SHAREPERM_ALL               125
#define IDI_SHARESFLD                   200
#define IDI_SHARE                       201
#ifdef WIZARDS
#define IDI_NEWSHARE                    202
#define IDI_NWSHARE                     203
#define IDI_MACSHARE                    204
#define IDI_ALLSHARE                    205
#endif // WIZARDS
#define IDI_IPC                         206
#define POPUP_SHARESBG_MERGE            300
#define POPUP_SHARESBG_POPUPMERGE1      301
#define POPUP_SHARESBG_POPUPMERGE2      302
#define POPUP_SHARE                     303
#ifdef WIZARDS
#define POPUP_SPECIAL                   304
#define POPUP_SPECIAL_FILE              305
#endif // WIZARDS
#define IDD_SHARE_PROPERTIES            1000
#define IDC_SHARE_SHARENAME             1001
#define IDC_SHARE_COMMENT               1002
#define IDC_SHARE_SHARENAME_TEXT        1003
#define IDC_SHARE_COMMENT_TEXT          1004
#define IDC_SHARE_LIMIT                 1005
#define IDC_SHARE_MAXIMUM               1006
#define IDC_SHARE_ALLOW                 1007
#define IDC_SHARE_PERMISSIONS           1008
#define IDC_SHARE_USERS_TEXT            1009
#define IDC_SHARE_ALLOW_SPIN            1010
#define IDC_SHARE_ALLOW_VALUE           1011
#define IDC_SHARE_PATH_TEXT             1012
#define IDC_SHARE_PATH                  1013
#define IDD_NEW_SHARE                   1018

#define FSIDM_SORT_FIRST                0x0030
#define FSIDM_SORTBYNAME                (FSIDM_SORT_FIRST + 0x0009)
#define FSIDM_SORTBYCOMMENT             (FSIDM_SORT_FIRST + 0x000a)
#define FSIDM_SORTBYPATH                (FSIDM_SORT_FIRST + 0x000b)
#define FSIDM_SORTBYMAXUSES             (FSIDM_SORT_FIRST + 0x000c)

#define FSIDM_MENU_NEW                  0x0060
#define FSIDM_NEWSHARE                  (FSIDM_MENU_NEW + 0x0003)

#define FSIDM_MENU_OPEN                 0x0070
#ifdef WIZARDS
#define FSIDM_OPENSPECIAL               (FSIDM_MENU_OPEN + 0x0001)
#endif // WIZARDS

#define IDS_MH_FSIDM_FIRST              2000
#define IDS_MH_FSIDM_LAST               2999

#define IDS_MH_SORTBYNAME               (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYNAME)
#define IDS_MH_SORTBYCOMMENT            (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYCOMMENT)
#define IDS_MH_SORTBYPATH               (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYPATH)
#define IDS_MH_SORTBYMAXUSES            (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYMAXUSES)
#define IDS_MH_MENU_NEW                 (IDS_MH_FSIDM_FIRST + FSIDM_MENU_NEW)
#define IDS_MH_NEWSHARE                 (IDS_MH_FSIDM_FIRST + FSIDM_NEWSHARE)

#define IDS_MH_DELETE                   (IDS_MH_FSIDM_FIRST + SHARED_FILE_DELETE)
#define IDS_MH_PROPERTIES               (IDS_MH_FSIDM_FIRST + SHARED_FILE_PROPERTIES)

#ifdef WIZARDS
#define IDS_MH_OPENSPECIAL              (IDS_MH_FSIDM_FIRST + FSIDM_OPENSPECIAL)
#endif // WIZARDS
#