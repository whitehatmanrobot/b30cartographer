VIDM_HELPSEARCH     )
#define IDS_HELP_HELPTUTORIAL   IDS_HELP_OF(DVIDM_HELPTUTORIAL   )
#define IDS_HELP_HELPMSWEB      IDS_HELP_OF(DVIDM_HELPMSWEB      )
#ifndef POSTPOSTSPLIT
#define IDS_HELP_COPYTO         IDS_HELP_OF(DVIDM_COPYTO         )
#define IDS_HELP_MOVETO         IDS_HELP_OF(DVIDM_MOVETO         )
#endif

#define IDS_HELP_NEW            IDS_HELP_OF(DVIDM_NEW            )
#define IDS_HELP_NEWPOST        IDS_HELP_OF(DVIDM_NEWPOST        )
#define IDS_HELP_NEWAPPOINTMENT IDS_HELP_OF(DVIDM_NEWAPPOINTMENT )
#define IDS_HELP_NEWMEETING     IDS_HELP_OF(DVIDM_NEWMEETING     )
#define IDS_HELP_NEWCONTACT     IDS_HELP_OF(DVIDM_NEWCONTACT     )
#define IDS_HELP_NEWTASK        IDS_HELP_OF(DVIDM_NEWTASK        )
#define IDS_HELP_NEWTASKREQUEST IDS_HELP_OF(DVIDM_NEWTASKREQUEST )
#define IDS_HELP_NEWJOURNAL     IDS_HELP_OF(DVIDM_NEWJOURNAL     )
#define IDS_HELP_NEWNOTE        IDS_HELP_OF(DVIDM_NEWNOTE        )
#define IDS_HELP_CALL           IDS_HELP_OF(DVIDM_CALL           )

#define IDS_HELP_SENDTO         IDS_HELP_OF(DVIDM_SENDTO         )
#define IDS_HELP_SENDTOFIRST    IDS_HELP_OF(DVIDM_SENDTOFIRST    )


SHDOCAPI CShellUIHelper_CreateInstance2(IUnknown** ppunk, REFIID riid, 
                                      IUnknown *pSite, IDispatch *pExternalDisp);
SHDOCAPI_(IStream*) SHGetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pszName, LPCWSTR pszStreamMRU, LPCWSTR pszStreams);


// these two MUST be in order because we peek them together
#define WMC_PRIVATE_BASE        (WM_USER + 0x0300)
#define WMC_RESERVED_FIRST      (WMC_PRIVATE_BASE + 0x0000)
#define WMC_RESERVED_LAST       (WMC_PRIVATE_BASE + 0x0002)
#define WMC_FAV_CHANGE          (WMC_PRIVATE_BASE + 0x0003)
#define WMC_REMOTENAV           (WMC_PRIVATE_BASE + 0x0004)
#define WMC_DISPATCH            (WMC_PRIVATE_BASE + 0x0005)
#ifndef POSTPOSTSPLIT
#define WMC_GETTHISPTR          (WMC_PRIVATE_BASE + 0x0006)
#endif
#define WMC_ACTIVATE            (WMC_PRIVATE_BASE + 0x0007)
#define WMC_MARSHALIDISPATCH    (WMC_PRIVATE_BASE + 0x0008)
#define WMC_MARSHALIDISPATCHSLOW (WMC_PRIVATE_BASE + 0x0009)
#define WMC_ONREFRESHTIMER       (WMC_PRIVATE_BASE + 0x000A)
#define WMC_DELAYEDDDEEXEC       (WMC_PRIVATE_BASE + 0x000B)
#define WMC_IEHARD_NAVWARNING    (WMC_PRIVATE_BASE + 0x000C)

// WMC_DISPATCH #defines
#define DSID_NAVIGATEIEBROWSER  1
#define DSID_GETLOCATIONURL     2
#define DSID_GETLOCATIONTITLE   3
#define DSID_GETHWND            4
#define DSID_CANCEL             5
#define DSID_EXIT               6
#define DSID_NOACTION           7

//Functions exported by shdocvw and used by browseui
SHDOCAPI_(BOOL) IsIEDefaultBrowser(void);
SHDOCAPI_(void) _DeletePidlDPA(HDPA hdpa);
SHDOCAPI IURLQualify(LPCWSTR pcszURL, DWORD  dwFlags,LPWSTR  pszTranslatedURL, LPBOOL pbWasSearchURL, LPBOOL pbWasCorrected);

SHDOCAPI_(BOOL) ParseURLFromOutsideSourceA (LPCSTR psz, LPSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL);
SHDOCAPI_(BOOL) ParseURLFromOutsideSourceW (LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL);
#ifdef UNICODE
#define ParseURLFromOutsideSource ParseURLFromOutsideSourceW 
#else
#define ParseURLFromOutsideSource ParseURLFromOutsideSourceA 
#endif


//
// Packages both the url and transaction id into one parameter
// to pass as a message.
//
typedef struct tagDDENAVIGATESTRUCT
{
    LPWSTR wszUrl;
    long transID;
} DDENAVIGATESTRUCT;

SHDOCAPI WinList_NotifyNewLocation(IShellWindows* psw, long dwRegister, LPCITEMIDLIST pidl);
SHDOCAPI WinList_FindFolderWindow(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlRoot, HWND *phwnd, IWebBrowserApp** ppauto);
SHDOCAPI_(IShellWindows*) WinList_GetShellWindows(BOOL fForceNew);
SHDOCAPI WinList_RegisterPending(DWORD dwThread, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlRoot, long *pdwRegister);
SHDOCAPI WinList_Revoke(long dwRegister);
SHDOCAPI WinList_OnActivate(IShellWindows* psw, long dwRegister, BOOL fActivate, LPCITEMIDLIST pidl);
SHDOCAPI_(BOOL) WinList_Init(void);
SHDOCAPI_(void) WinList_Terminate(void);

SHDOCAPI SHMapNbspToSp(LPCWSTR lpwszIn, LPSTR lpszOut, int cbszOut);

SHDOCAPI_(BOOL) SHIsGlobalOffline(void);
SHDOCAPI_(DWORD) SHRestricted2A(BROWSER_RESTRICTIONS rest, LPCSTR pszUrl, DWORD dwReserved);
SHDOCAPI_(DWORD) SHRestricted2W(BROWSER_RESTRICTIONS rest, LPCWSTR pwzUrl, DWORD dwReserved);
#ifndef _SHELL32_   // shell32 has its own implementation of this function
SHDOCAPI_(BOOL) SHIsRestricted(HWND hwnd, RESTRICTIONS rest);
#endif // _SHELL32_
SHDOCAPI_(BOOL) SHIsRestricted2W(HWND hwnd, BROWSER_RESTRICTIONS rest, LPCWSTR pwzUrl, DWORD dwReserved);
SHDOCAPI_(void)    DetectAndFixAssociations();
SHDOCAPI_(void)    EnsureWebViewRegSettings();

#ifdef UNICODE
#define UrlHitsNet UrlHitsNetW
#endif

SHDOCAPI_(BOOL) UrlHitsNetW(LPCWSTR pszURL);
#ifdef UNICODE
#define SHRestricted2     SHRestricted2W
#else // UNICODE
#define SHRestricted2     SHRestricted2A
#endif // UNICODE


/// event firing helper functions
//
// FireEvent_XXX functions do a bunch of the work of firing an event.
// punk points to the object that contains the connection point
// that you want to fire the event from. The hwnd parameter is for DDE.
//


SHDOCAPI_(void) FireEvent_BeforeNavigate(IUnknown* punk, HWND hwnd, IWebBrowser2* pwb2,
        LPCITEMIDLIST pidl,LPCWSTR pwzLocation,
        DWORD dwFlags,LPCWSTR pszFrameName,LPBYTE pPostData,
        DWORD cbPostData,LPCWSTR pszHeaders,BOOL * pfCancel);

SHDOCAPI_(void) FireEvent_NavigateError(IUnknown     * punk, 
                                        IWebBrowser2 * pwb2,
                                        LPCITEMIDLIST  pidl,
                                        BSTR           bstrTargetFrameName,
                                        DWORD          dwStatusCode,
                                        BOOL         * pfCancel);

SHDOCAPI_(void) FireEvent_NewWindow(IUnknown* punk, HWND hwnd,
        LPCITEMIDLIST pidl,LPWSTR pwzLocation,
        DWORD dwFlags,LPWSTR pszFrameName,LPBYTE pPostData,
        DWORD cbPostData,LPWSTR pszHeaders,BOOL * pfProcessed);

SHDOCAPI_(void) FireEvent_NewWindow2(IUnknown* punk, IUnknown ** ppunkNewWindow, BOOL* pfCancel);
SHDOCAPI_(void) FireEvent_NavigateComplete(IUnknown* punk, IWebBrowser2* pwb2, LPCITEMIDLIST pidl, HWND hwnd);
SHDOCAPI_(void) FireEvent_DocumentComplete(IUnknown* punk, IWebBrowser2* pwb2, LPCITEMIDLIST pidl);
SHDOCAPI_(void) FireEvent_PrintTemplateEvent(IUnknown* punk, IWebBrowser2* pwb2, DISPID dispidPrintEvent);
SHDOCAPI_(void) FireEvent_UpdatePageStatus(IUnknown* punk, IWebBrowser2* pwb2, DWORD nPage, BOOL fDone);
SHDOCAPI_(void) FireEvent_PrivacyImpactedStateChange(IUnknown* punk, BOOL);
SHDOCAPI_(void) FireEvent_DoInvokeString(IExpDispSupport* peds, DISPID dispid, LPSTR psz);
SHDOCAPI_(void) FireEvent_DoInvokeStringW(IExpDispSupport* peds, DISPID dispid, LPWSTR psz);
SHDOCAPI_(void) FireEvent_DoInvokeDispid(IUnknown* punk, DISPID dispid);
SHDOCAPI_(void) FireEvent_DoInvokeDwords(IExpDispSupport* peds, DISPID dispid,DWORD dw1,DWORD dw2);
SHDOCAPI_(void) FireEvent_DoInvokeBstr(IUnknown* punk, DISPID dispid, BSTR bstr);
SHDOCAPI_(void) FireEvent_Quit(IExpDispSupport* peds);
SHDOCAPI_(void) FireEvent_OnAdornment(IUnknown* punk, DISPID dispid, VARIANT_BOOL f);
SHDOCAPI_(void) FireEvent_FileDownload(IUnknown * punk, BOOL * pfCancel, VARIANT_BOOL bDocObject);


#define IDP_START       0
#define IDP_SEARCH      1
#define IDP_UPDATE      2
#define IDP_CHANNELGUIDE  3
SHDOCAPI SHDGetPageLocation(HWND hwndOwner, UINT idp, LPWSTR pszPath, UINT cchMax, LPITEMIDLIST *ppidlOut);

SHDOCAPI SHGetHistoryPIDL(LPITEMIDLIST *ppidlHistory);
SHDOCAPI_(UINT) SHIEErrorMsgBox(IShellBrowser* psb,
                    HWND hwndOwner, HRESULT hrError, LPCWSTR szError, LPCWSTR pszURLparam,
                    UINT idResource, UINT wFlags);

// pszClient values:
#define MAIL_DEF_KEY            L"Mail"
#define NEWS_DEF_KEY            L"News"
#define CONTACTS_DEF_KEY        L"Contacts"
#define CALENDAR_DEF_KEY        L"Calendar"
#define TASKS_DEF_KEY           L"Task"
#define JOURNAL_DEF_KEY         L"Journal"
#define NOTES_DEF_KEY           L"Note"
#define CALL_DEF_KEY            L"Internet Call"

SHDOCAPI_(BOOL) SHIsRegisteredClient(LPCWSTR pszClient);

// stopgap export for shell32\unicpp\dcomp.cpp
SHDOCAPI NavToUrlUsingIEW(LPCWSTR wszUrl, BOOL fNewWindow);
SHDOCAPI NavToUrlUsingIEA(LPCSTR szUrl, BOOL fNewWindow);
#ifdef UNICODE
#define NavToUrlUsingIE     NavToUrlUsingIEW
#else // UNICODE
#define NavToUrlUsingIE     NavToUrlUsingIEA
#endif // UNICODE

/// shared icons that browseUI grabs from shdocvw.
// we leave them in shdocvw instead of moving them for back compat.
// folks may have relied upon the icons in the dll for their shortcuts.
// (do we care?)
#define IDI_OFFLINE                     105   //          5
#define IDI_STATE_NORMAL                110
#define ICO_TREEUP                      204
#define ICO_GLEAM                       205



// stopgap export for shell32\unicpp\dcomp.cpp
SHDOCAPI UseDefaultAutoComplete(HWND hwndEdit,
                               IBrowserService * pbs,          IN  OPTIONAL
                               IAutoComplete ** ppac,          OUT OPTIONAL
                               IShellService ** ppssACLISF,    OUT OPTIONAL
                               BOOL fUseCMDMRU);

// stopgap export for shell32\unicpp\dcomp.cpp, deskstat.cpp


#define JITCOCREATEINSTANCE_ORD 209
SHDOCAPI JITCoCreateInstance(
    REFCLSID rclsid, 
    IUnknown *pUnkOuter,
    DWORD dwClsContext, 
    REFIID riid, 
    LPVOID FAR* ppv,
    HWND hwndParent,
    DWORD dwJitFlags
);


SHDOCAPI_(void) TLTransferToThreadMemlist(struct ITravelLog *, DWORD);

SHDOCAPI_(BOOL) DoOrganizeFavDlg(HWND hwnd, LPSTR pszInitDir);
SHDOCAPI_(BOOL) DoOrganizeFavDlgW(HWND hwnd, LPWSTR pszInitDir);

#define NAVCANCELLED_URL                 TEXT("about:NavigationCanceled")
#define OFFLINEINFO_URL                  TEXT("about:OfflineInformation")
#define FOLDERBROWSINGINFO_URL           TEXT("about:FolderBrowsing")

#define SEARCH_SETTINGS_CHANGEDW         L"SearchSettingsChanged"
#define SEARCH_SETTINGS_CHANGEDA         "SearchSettingsChanged"

#ifdef UNICODE
#define SEARCH_SETTINGS_CHANGED          SEARCH_SETTINGS_CHANGEDW
#else
#define SEARCH_SETTINGS_CHANGED          SEARCH_SETTINGS_CHANGEDA
#endif

SHDOCAPI_(VARIANT_BOOL) UseCustomInternetSearch();
SHDOCAPI_(BOOL) GetSearchAssistantUrlW(LPWSTR pwszUrl, int cchUrl, BOOL bSubstitute, BOOL bCustomize);
SHDOCAPI_(BOOL) GetDefaultInternetSearchUrlW(LPWSTR pwszUrl, int cchUrl, BOOL bSubstitute);
SHDOCAPI_(BOOL) GetSearchAssistantUrlA(LPSTR pszUrl, int cchUrl, BOOL bSubstitute, BOOL bCustomize);
SHDOCAPI_(BOOL) GetDefaultInternetSearchUrlA(LPSTR pszUrl, int cchUrl, BOOL bSubstitute);

#ifdef UNICODE
#define GetSearchAssistantUrl GetSearchAssistantUrlW
#define GetDefaultInternetSearchUrl GetDefaultInternetSearchUrlW
#else
#define GetSearchAssistantUrl GetSearchAssistantUrlA
#define GetDefaultInternetSearchUrl GetDefaultInternetSearchUrlA
#endif

typedef enum
{
    ILS_ADDTOFAV = 0,
    ILS_LINK     = 1,
    ILS_HOME     = 2,
    ILS_NAVIGATE = 3,
}ILS_ACTION;

SHDOCAPI_(BOOL) IEIsLinkSafe(HWND hwnd, LPCITEMIDLIST pidl, ILS_ACTION ilsFlag);
SHDOCAPI_(BOOL) SHUseClassicToolbarGlyphs (void);
SHDOCAPI_(BOOL) SafeOpenPromptForShellExec(HWND hwnd, PCWSTR pszFile);
#endif // _SHDOCVW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\sherror.h ===
#ifndef _SHERROR_H_
#define _SHERROR_H_



#endif // _SHERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\shdguid.h ===
#ifndef __shdguid_h__
#define __shdguid_h__

// GUIDs for COM objects that live in SHDOCVW.DLL. currently this is shared with SHELL32.DLL only

// this is the IE30 WebBrowser's CLSID
DEFINE_GUID(CLSID_WebBrowser_V1,0xEAB22AC3L,0x30C1,0x11CF,0xA7,0xEB,0x00,0x00,0xC0,0x5B,0xAE,0x0B);

// 7BA4C740-9E81-11CF-99D3-00AA004AE837
DEFINE_GUID(CLSID_SendToMenu, 0x7BA4C740L, 0x9E81, 0x11CF, 0x99, 0xD3, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// {C2FBB630-2971-11d1-A18C-00C04FD75D13}
DEFINE_GUID(CLSID_CopyToMenu, 0xc2fbb630, 0x2971, 0x11d1, 0xa1, 0x8c, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

// {C2FBB631-2971-11d1-A18C-00C04FD75D13}
DEFINE_GUID(CLSID_MoveToMenu, 0xc2fbb631, 0x2971, 0x11d1, 0xa1, 0x8c, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

// 59FEBFE0-2ED3-11D1-83E5-00A0C90DC849
DEFINE_GUID(CLSID_NavigationBand, 0x59FEBFE0, 0x2ED3, 0x11D1, 0x83, 0xE5, 0x0, 0xA0, 0xC9, 0x0D, 0xC8, 0x49);

// {353ECE21-74CB-11d0-80CA-00AA005B4383}
DEFINE_GUID(CLSID_SNSList, 0x353ece21, 0x74cb, 0x11d0, 0x80, 0xca, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {2466C261-78ED-11d0-80FB-00AA005B4383}
DEFINE_GUID(CLSID_ACPList, 0x2466c261, 0x78ed, 0x11d0, 0x80, 0xfb, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// 90A756E0-AFCF-11CE-927B-0800095AE340
DEFINE_GUID(CLSID_TargetMenu, 0x90A756E0L, 0xAFCF, 0x11CE, 0x92, 0x7B, 0x08, 0x00, 0x09, 0x5A, 0xE3, 0x40);

// 57D5ECC0-A23F-11CE-AE65-08002B2E1262
DEFINE_GUID(CLSID_ContentsMenu, 0x57D5ECC0L, 0xA23F, 0x11CE, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);

// 26027EA0-3992-11D0-A271-00A0C90A90CE
DEFINE_GUID(CLSID_NewFileMenu, 0x26027EA0, 0x3992, 0x11D0, 0xA2, 0x71, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xCE);

// *** Really private (never move to even to semi-public header) ***

// 6667E240-0F9D-11CF-A9BB-00AA004AE837
DEFINE_GUID(CLSID_CDocObjMenuExt,   0x6667E240L, 0x0F9D, 0x11CF, 0xA9, 0xBB, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);
// 131A6952-7F78-11D0-A979-00C04FD705A2
// 02BA3B52-0547-11D1-B833-00C04FC9B31F

// {D1F15BC1-D650-11d1-9839-006097DF5BD4}
DEFINE_GUID(IID_IFtpLegacySupport, 0xd1f15bc1, 0xd650, 0x11d1, 0x98, 0x39, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);
DEFINE_GUID(CLSID_CFtpLegacySupport, 0xd1f15bc1, 0xd650, 0x11d1, 0x98, 0x39, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// 2D8ECD81-4A7B-11CF-A0B9-00AA002F954E
DEFINE_GUID(IID_INavigationStack,          0x2D8ECD81L, 0x4A7B, 0x11CF, 0xA0, 0xB9, 0x00, 0xAA, 0x00, 0x2F, 0x95, 0x4E);
DEFINE_GUID(IID_INavigationStackItem,      0x2D8ECD82L, 0x4A7B, 0x11CF, 0xA0, 0xB9, 0x00, 0xAA, 0x00, 0x2F, 0x95, 0x4E);
DEFINE_GUID(CLSID_CShellDataSource,        0xD4903360L, 0x44da, 0x11d0, 0x89, 0xe2, 0x00, 0xa0, 0xc9, 0x0a, 0x90, 0xac);

//CLSID_CDeskHtmlProp  3FC0B520-68A9-11D0-8D77-00C04FD70822

// This is the property sheet extension for the desk.cpl
// 3FC0B520-68A9-11D0-8D77-00C04FD70822
DEFINE_GUID(CLSID_CDeskHtmlProp, 0x3FC0B520L, 0x68A9, 0x11D0, 0x8D, 0x77, 0x00, 0xC0, 0x4F, 0xD7, 0x08, 0x22);


// {F46EDB3B-BC2F-11d0-9412-00AA00A3EBD3}
DEFINE_GUID(IID_ITravelEntry,  0xf46edb3b, 0xbc2f, 0x11d0, 0x94, 0x12, 0x0, 0xaa, 0x0, 0xa3, 0xeb, 0xd3);

// (old: F46EDB3C-BC2F-11d0-9412-00AA00A3EBD3 until 980909)
// {66A9CB08-4802-11d2-A561-00A0C92DBFE8}
DEFINE_GUID(IID_ITravelLog, 0x66a9cb08, 0x4802, 0x11d2, 0xa5, 0x61, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);

// {3050f679-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(IID_ITravelLogEx, 0x3050f679, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// {3050f67A-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(IID_ITravelLogClient, 0x3050f67a, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// {26fdc864-be88-46e7-9235-032d8ea5162e}
DEFINE_GUID(CLSID_MergedFolder,             0x26fdc864, 0xbe88, 0x46e7, 0x92, 0x35, 0x03, 0x2d, 0x8e, 0xa5, 0x16, 0x2e);
// {0d867ed2-247d-479b-9181-227d09c2e001}
DEFINE_GUID(IID_IAugmentedShellFolder3,     0x0d867ed2, 0x247d, 0x479b, 0x91, 0x81, 0x22, 0x7d, 0x09, 0xc2, 0xe0, 0x01);

// {568804CE-CBD7-11d0-9816-00C04FD91972}
DEFINE_GUID(CLSID_FavoriteMenu,             0x568804ce, 0xcbd7, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {568804CF-CBD7-11d0-9816-00C04FD91972}
DEFINE_GUID(IID_FavoriteMenu,               0x568804cf, 0xcbd7, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {C501AE8A-5A64-11d1-9838-00C04FD91972}
DEFINE_GUID(IID_IProxyShellFolder,          0xc501ae8a, 0x5a64, 0x11d1, 0x98, 0x38, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {70A77D84-D78C-11d0-9816-00C04FD91972}
DEFINE_GUID(IID_ISetWinHandler,             0x70a77d84, 0xd78c, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {A82A3FDE-ECE6-11d0-981C-00C04FD91972}
DEFINE_GUID(IID_IDropTargetBackground,      0xa82a3fde, 0xece6, 0x11d0, 0x98, 0x1c, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {e17d4fc0-5564-11d1-83f2-00a0c90dc849}
DEFINE_GUID(CLSID_DocFindFolder, 0xe17d4fc0, 0x5564, 0x11d1, 0x83, 0xf2, 0x0, 0xa0, 0xc9, 0x0d, 0xc8, 0x49);

// {1f4de370-d627-11d1-ba4f-00a0c91eedba}
DEFINE_GUID(CLSID_ComputerFindFolder, 0x1f4de370, 0xd627, 0x11d1, 0xba, 0x4f, 0x00, 0xa0, 0xc9, 0x1e, 0xed, 0xba);

// {B005E690-678D-11d1-B758-00A0C90564FE}
DEFINE_GUID(CLSID_DocFindCommand, 0xb005e690, 0x678d, 0x11d1, 0xb7, 0x58, 0x0, 0xa0, 0xc9, 0x5, 0x64, 0xfe);

// {3409E930-5A39-11d1-83FA-00A0C90DC849}
DEFINE_GUID(IID_IContextMenuCB, 0x3409e930, 0x5a39, 0x11d1, 0x83, 0xfa, 0x0, 0xa0, 0xc9, 0xd, 0xc8, 0x49);

// {50a7e9b0-70ef-11d1-b75a-00a0c90564fe}
DEFINE_GUID(LIBID_Shell32, 0x50a7e9b0, 0x70ef, 0x11d1, 0xb7, 0x5a, 0x0,
 0xa0, 0xc9, 0x5, 0x64, 0xfe);


// {A85C4BB0-5AEE-11d1-83FA-00A0C90DC849}
DEFINE_GUID(SID_DocFindFolder, 0xa85c4bb0, 0x5aee, 0x11d1, 0x83, 0xfa, 0x0, 0xa0, 0xc9, 0xd, 0xc8, 0x49);

#endif // __shdguid_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\shellp.h ===
#ifndef _SHELLP_H_
#define _SHELLP_H_

#include <shldisp.h>

//
// shell private header
//

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#define DECLAREWAITCURSOR  HCURSOR hcursor_wait_cursor_save
#define SetWaitCursor()   hcursor_wait_cursor_save = SetCursor(LoadCursor(NULL, IDC_WAIT))
#define ResetWaitCursor() SetCursor(hcursor_wait_cursor_save)


#ifdef __cplusplus
}
#endif // __cplusplus


//
// Context menu helper functions
//
STDAPI_(UINT) GetMenuIndexForCanonicalVerb(HMENU hMenu, IContextMenu* pcm, UINT idCmdFirst, LPCWSTR pwszVerb);
STDAPI ContextMenu_GetCommandStringVerb(IContextMenu *pcm, UINT idCmd, LPWSTR pszVerb, int cchVerb);
STDAPI ContextMenu_DeleteCommandByName(IContextMenu *pcm, HMENU hpopup, UINT idFirst, LPCWSTR pszCommand);

//
// Info tip helper functions
//
BOOL GetInfoTipHelpA(IShellFolder* psf, LPCITEMIDLIST pidl, LPSTR pszText, int cchTextMax);
BOOL GetInfoTipHelpW(IShellFolder* psf, LPCITEMIDLIST pidl, LPWSTR pszText, int cchTextMax);

BOOL GetInfoTipHelpExA(IShellFolder* psf, DWORD dwFlags, LPCITEMIDLIST pidl, LPSTR pszText, int cchTextMax);
BOOL GetInfoTipHelpExW(IShellFolder* psf, DWORD dwFlags, LPCITEMIDLIST pidl, LPWSTR pszText, int cchTextMax);

#ifdef UNICODE
#define GetInfoTipHelp          GetInfoTipHelpW
#define GetInfoTipHelpEx        GetInfoTipHelpExW
#else // UNICODE
#define GetInfoTipHelp          GetInfoTipHelpA
#define GetInfoTipHelpEx        GetInfoTipHelpExA
#endif // UNICODE


#endif // _SHELLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\shstyle.h ===
//
// Resource id header file for shellstyle.dll
//

#ifndef _SHSTYLE_H_
#define _SHSTYLE_H_

#define IDR_DUI_STYLESHEET            1
#define IDR_DUI_CPSTYLE               2


#define IDB_MUSIC_ICON_BMP            10
#define IDB_MUSIC_TASKS_BMP           11
#define IDB_MUSIC_LISTVIEW_BMP        12
#define IDB_PICTURES_ICON_BMP         13
#define IDB_PICTURES_TASKS_BMP        14
#define IDB_PICTURES_LISTVIEW_BMP     15
#define IDB_SEARCH_ICON_BMP           16
#define IDB_SEARCH_TASKS_BMP          17
#define IDB_SEARCH_LISTVIEW_BMP       18
#define IDB_VIDEO_ICON_BMP            19
#define IDB_VIDEO_TASKS_BMP           20
#define IDB_VIDEO_LISTVIEW_BMP        21
#define IDB_CPANEL_ICON_BMP           22


#define IDB_BLOCKADE_WATERMARK        25
#define IDB_CPANEL_WATERMARK          26


#define IDS_PREVIEW_BACKGROUND_COLOR  100

#endif //_SHSTYLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\shsemip.h ===
//***************************************************************************
//  --- SHELLAPI.W SHSEMIP.H SHLOBJ.W SHOBJIDL.IDL SHLDISP.IDL SHPRIV.IDL ---
//                Which header is best for my new API?
//
//  SHSEMIP     - *AVOID _ALL_ USAGE*, NO EXPORTS, SUPER PRIVATE
//              used for very private shell defines.
//
//  SHELLAPI    - ALL NEW SHELL32 EXPORTS public and private
//              used for both public and private exports from shell32
//
//  SHLOBJ      - *AVOID NEW USAGE*, PREFER OTHER HEADERS
//              used primarily for legacy compatibility
//
//  SHOBJIDL    - ALL NEW SHELL PUBLIC INTERFACES
//              primary file for public shell (shell32+) interfaces
//
//  SHLDISP     - ALL NEW SHELL AUTOMATION INTERFACES
//              automation interfaces are always public
//
//  SHPRIV      - ALL NEW SHELL PRIVATE INTERFACES
//              private interfaces used anywhere in the shell
//
//***************************************************************************

#ifndef _SHSEMIP_H_
#define _SHSEMIP_H_

#ifndef LPNTSTR_DEFINED
#define LPNTSTR_DEFINED

typedef UNALIGNED const WCHAR * LPNCWSTR;
typedef UNALIGNED WCHAR *       LPNWSTR;

#ifdef UNICODE
#define LPNCTSTR        LPNCWSTR
#define LPNTSTR         LPNWSTR
#else
#define LPNCTSTR        LPCSTR
#define LPNTSTR         LPSTR
#endif

#endif // LPNTSTR_DEFINED

#ifndef DONT_WANT_SHELLDEBUG

#ifndef DebugMsg                                                                /* ;Internal */
#define DM_TRACE    0x0001      // Trace messages                               /* ;Internal */
#define DM_WARNING  0x0002      // Warning                                      /* ;Internal */
#define DM_ERROR    0x0004      // Error                                        /* ;Internal */
#define DM_ASSERT   0x0008      // Assertions                                   /* ;Internal */
#define Assert(f)                                                               /* ;Internal */
#define AssertE(f)      (f)                                                     /* ;Internal */
#define AssertMsg   1 ? (void)0 : (void)                                        /* ;Internal */
#define DebugMsg    1 ? (void)0 : (void)                                        /* ;Internal */
#endif                                                                          /* ;Internal */
                                                                                /* ;Internal */
#endif



//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if !defined(_SHELL32_)
#define WINSHELLAPI DECLSPEC_IMPORT
#else
#define WINSHELLAPI
#endif
#endif // WINSHELLAPI

#ifndef NOPRAGMAS
#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//====== Ranges for WM_NOTIFY codes ==================================
// If a new set of codes is defined, make sure the range goes   /* ;Internal */
// here so that we can keep them distinct                       /* ;Internal */
// Note that these are defined to be unsigned to avoid compiler warnings
// since NMHDR.code is declared as UINT.
//
// NM_FIRST - NM_LAST defined in commctrl.h (0U-0U) - (OU-99U)
//
// LVN_FIRST - LVN_LAST defined in commctrl.h (0U-100U) - (OU-199U)
//
// PSN_FIRST - PSN_LAST defined in prsht.h (0U-200U) - (0U-299U)
//
// HDN_FIRST - HDN_LAST defined in commctrl.h (0U-300U) - (OU-399U)
//
// TVN_FIRST - TVN_LAST defined in commctrl.h (0U-400U) - (OU-499U)

// TTN_FIRST - TTN_LAST defined in commctrl.h (0U-520U) - (OU-549U)

#define SEN_FIRST       (0U-550U)       // ;Internal
#define SEN_LAST        (0U-559U)       // ;Internal


#ifndef UNIX
#define MAXPATHLEN      MAX_PATH        // ;Internal
#endif

#ifdef UNICODE
#define OTHER_TCHAR_NAME(sz)      sz##A
#else // !UNICODE
#define OTHER_TCHAR_NAME(sz)      sz##W
#endif

//===========================================================================
// ITEMIDLIST
//===========================================================================

// unsafe macros
#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)

__inline BOOL SHIsConsistentPidl(LPCITEMIDLIST pidl, UINT cbAlloc)
{
    //  test to make sure that the pidl does not overrun itself
    //  this is for callers that un-persist pidl data, and
    //  assumes that the caller knows the allocated size of the pidl
    //  similar to ILGetSize(pidl) <= cbAlloc except that 
    //  it doesnt assert or throw exceptions
    UINT cbPidl = sizeof(pidl->mkid.cb);
    while (cbPidl < cbAlloc && pidl->mkid.cb)
    {
        cbPidl += pidl->mkid.cb;
        pidl = _ILNext(pidl);
    }

    return cbPidl <= cbAlloc && 0 == pidl->mkid.cb;
}

//===================================================================
// Smart tiling API's
WINSHELLAPI WORD WINAPI ArrangeWindows(HWND hwndParent, WORD flags, LPCRECT lpRect, WORD chwnd, const HWND *ahwnd);


/* Avoid multiple typedefs C warnings. Defined in shlapip.h as well. */
#ifndef RUNDLLPROC

typedef void (WINAPI *RUNDLLPROCA)(HWND hwndStub, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow);
typedef void (WINAPI * RUNDLLPROCW)(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpszCmdLine, int nCmdShow);

#ifdef UNICODE
#define RUNDLLPROC  RUNDLLPROCW
#else
#define RUNDLLPROC  RUNDLLPROCA
#endif
#endif

// Maximum length of a path string
#define CCHPATHMAX      MAX_PATH
#define MAXSPECLEN      MAX_PATH
#define MAX_PATH_URL    INTERNET_MAX_URL_LENGTH
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#ifndef SIZEOF
#define SIZEOF(a)       sizeof(a)
#endif

#define PathRemoveBlanksORD     33
#define PathFindFileNameORD     34
#define PathFindExtensionORD    31

#ifdef OVERRIDE_SHLWAPI_PATH_FUNCTIONS
// SHLWAPI provides the majority of the Path functions.  There are
// some cases where the shell code (shell32 and explorer) need to
// call a different variation of these calls.  Because of this, we
// have OVERRIDE_SHLWAPI_PATH_FUNCTIONS.  Components such as shdocvw
// should strive to *not* have this defined.
//
// Some reasons why something like shell32 would need this:
//   1)  Shell32 calls some WNet APIs due to the NT merge.  Shlwapi
//       cannot take these.
//   2)  Shell32 needs the unaligned version PathBuildRoot,
//       PathCombine, etc.
//

#undef PathIsDirectory
#undef PathMakePretty

WINSHELLAPI BOOL  WINAPI PathIsDirectory(LPCTSTR lpszPath);
WINSHELLAPI BOOL  WINAPI PathMakePretty(LPTSTR lpszPath);

#endif // OVERRIDE_SHLWAPI_PATH_FUNCTIONS


WINSHELLAPI void  WINAPI ExitWindowsDialog(HWND hwnd);
WINSHELLAPI void  WINAPI LogoffWindowsDialog(HWND hwnd);
WINSHELLAPI void  WINAPI DisconnectWindowsDialog(HWND hwnd);
WINSHELLAPI BOOL  WINAPI IsSuspendAllowed(void);

WINSHELLAPI void WINAPI SHRefreshSettings(void);



EXTERN_C WINSHELLAPI HRESULT STDAPICALLTYPE SHCopyMonikerToTemp(IMoniker *pmk, LPCWSTR pszIn, LPWSTR pszOut, int cchOut);

WINSHELLAPI BOOL WINAPI IsVolumeNTFS(LPCTSTR pszRootPath);

#ifdef WINNT
WINSHELLAPI LPWSTR WINAPI GetDownlevelCopyDataLossText(LPCWSTR pszSrcFile, LPCWSTR pszDestDir, BOOL bIsADir, BOOL * pbLossPossibleThisDir);
#endif

//-------- file engine stuff ----------

// "current directory" management routines.  used to set parameters
// that paths are qualfied against in MoveCopyDeleteRename()

WINSHELLAPI int  WINAPI GetDefaultDrive();
WINSHELLAPI int  WINAPI SetDefaultDrive(int iDrive);
WINSHELLAPI int  WINAPI SetDefaultDirectory(LPCTSTR lpPath);
WINSHELLAPI void WINAPI GetDefaultDirectory(int iDrive, LPSTR lpPath);
//
// NOTES: No reason to have this one here, but I don't want to break the build.
//
#ifndef WINCOMMCTRLAPI
int WINAPI StrToInt(LPCTSTR lpSrc);  // atoi()
#endif

#define POSINVALID  32767       // values for invalid position

#define IDCMD_SYSTEMFIRST       0x8000
#define IDCMD_SYSTEMLAST        0xbfff
#define IDCMD_CANCELED          0xbfff
#define IDCMD_PROCESSED         0xbffe
#define IDCMD_DEFAULT           0xbffe

/* timedate.c */

// **********************************************************************
//  DATE is a structure with a date packed into a WORD size value. It
//  is compatible with a file date in a directory entry structure.
// **********************************************************************

#ifndef DATE_DEFINED
typedef struct
{
    WORD    Day     :5; // Day number 1 - 31
    WORD    Month   :4; // Month number 1 - 12
    WORD    Year    :7; // Year subtracted from 1980, 0-127
} WORD_DATE;

typedef union
{
    WORD            wDate;
    WORD_DATE       sDate;
} WDATE;

#define DATE_DEFINED
#endif

// **********************************************************************
//  TIME is a structure with a 24 hour time packed into a WORD size value.
//  It is compatible with a file time in a directory entry structure.
// **********************************************************************

#ifndef TIME_DEFINED

typedef struct
{
        WORD    Sec     :5;     // Seconds divided by 2 (0 - 29).
        WORD    Min     :6;     // Minutes 0 - 59
        WORD    Hour    :5;     // Hours 0 - 24
} WORD_TIME;

typedef union
{
        WORD        wTime;
        WORD_TIME   sTime;
} WTIME;

#define TIME_DEFINED
#endif

WINSHELLAPI WORD WINAPI Shell_GetCurrentDate(void);
WINSHELLAPI WORD WINAPI Shell_GetCurrentTime(void);

//====== SEMI-PRIVATE API ===============================
#ifndef HPSXA_DEFINED
#define HPSXA_DEFINED
DECLARE_HANDLE( HPSXA );
#endif // HPSXA_DEFINED

//====== SEMI-PRIVATE API ORDINALS ===============================
// This is the list of semi-private ordinals we semi-publish.
#define SHObjectPropertiesORD                   178
#define SHCreateDefClassObjectORD                70
#define SHGetNetResourceORD                      69

#define SHEXP_SHCREATEDEFCLASSOBJECT            MAKEINTRESOURCE(SHCreateDefClassObjectORD)
#define SHEXP_SHGETNETRESOURCE                  MAKEINTRESOURCE(SHGetNetResourceORD)


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#ifndef NOPRAGMAS
#pragma pack()
#endif /* NOPRAGMAS */
#endif  /* !RC_INVOKED */

#endif // _SHSEMIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\shguidp.h ===
//
// CLSIDs of shell object classes. They don't have to be in a public header
// unless we decided to let ISVs to create shell objects directly by calling
// OleCreateInstance with one of class IDs.
//
// NOTE: those that are commented out are ready to be used again...
//

DEFINE_GUID(CLSID_NetworkRoot,          0x953d732d, 0xab45, 0x11d2, 0x84, 0xe0, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);// {953D732D-AB45-11d2-84E0-00C04FA31A86}

DEFINE_GUID(GUID_SystemPidlChange,      0x210A4BA0, 0x3AEA, 0x1069, 0xA2,0xD9,0x08,0x00,0x2B,0x30,0x30,0x9D);//210A4BA0-3AEA-1069-A2D9-08002B30309D

DEFINE_GUID(CLSID_ShellCopyHook,        0x217FC9C0, 0x3AEA, 0x1069, 0xA2,0xDB,0x08,0x00,0x2B,0x30,0x30,0x9D);//217FC9C0-3AEA-1069-A2DB-08002B30309D
DEFINE_GUID(CLSID_ShellFileDefExt,      0x21B22460, 0x3AEA, 0x1069, 0xA2,0xDC,0x08,0x00,0x2B,0x30,0x30,0x9D);//21B22460-3AEA-1069-A2DC-08002B30309D
DEFINE_GUID(CLSID_ShellDrvDefExt,       0x5F5295E0, 0x429F, 0x1069, 0xA2,0xE2,0x08,0x00,0x2B,0x30,0x30,0x9D);//5F5295E0-429F-1069-A2E2-08002B30309D
DEFINE_GUID(CLSID_ShellNetDefExt,       0x86422020, 0x42A0, 0x1069, 0xA2,0xE5,0x08,0x00,0x2B,0x30,0x30,0x9D);//86422020-42A0-1069-A2E5-08002B30309D
DEFINE_GUID(CLSID_CCommonShellExtInit,  0xA2AD3100, 0x3B84, 0x1069, 0xA2,0xDF,0x08,0x00,0x2B,0x30,0x30,0x9D);//A2AD3100-3B84-1069-A2DF-08002B30309D
DEFINE_GUID(CLSID_Briefcase,            0x85BBD920, 0x42A0, 0x1069, 0xA2,0xE4,0x08,0x00,0x2B,0x30,0x30,0x9D);//85BBD920-42A0-1069-A2E4-08002B30309D
DEFINE_GUID(CLSID_BriefcaseFolder,      0x86747AC0, 0x42A0, 0x1069, 0xA2,0xE6,0x08,0x00,0x2B,0x30,0x30,0x9D);//86747AC0-42A0-1069-A2E6-08002B30309D
DEFINE_GUID(CLSID_Clouds,               0x869DADA0, 0x42A0, 0x1069, 0xA2,0xE7,0x08,0x00,0x2B,0x30,0x30,0x9D);//869DADA0-42A0-1069-A2E7-08002B30309D   // secret credits object
DEFINE_GUID(CLSID_ExeDropTarget,        0x86C86720, 0x42A0, 0x1069, 0xA2,0xE8,0x08,0x00,0x2B,0x30,0x30,0x9D);//86C86720-42A0-1069-A2E8-08002B30309D
DEFINE_GUID(CLSID_PifProperties,        0x86F19A00, 0x42A0, 0x1069, 0xA2,0xE9,0x08,0x00,0x2B,0x30,0x30,0x9D);//86F19A00-42A0-1069-A2E9-08002B30309D   // pifprops


DEFINE_GUID(CLSID_Remote,               0x992CFFA0, 0xF557, 0x101A, 0x88,0xEC,0x00,0xDD,0x01,0x0C,0xCC,0x48);
DEFINE_GUID(CLSID_ShellFindExt,         0x61E218E0, 0x65D3, 0x101B, 0x9F,0x08,0x06,0x1C,0xEA,0xC3,0xD5,0x0D);//61E218E0-65D3-101B-9F08-061CEAC3D50D
DEFINE_GUID(CLSID_CFonts,               0xBD84B380, 0x8CA2, 0x1069, 0xAB,0x1D,0x08,0x00,0x09,0x48,0xF5,0x34);//bd84b380-8ca2-1069-ab1d-08000948f534
DEFINE_GUID(CLSID_CmdFileIcon,          0x57651662, 0xCE3E, 0x11D0, 0x8D,0x77,0x00,0xC0,0x4F,0xC9,0x9D,0x61);//57651662-CE3E-11D0-8D77-00C04FC99D61

DEFINE_GUID(CLSID_CSiteMapEmbedding,    0x438C0EA0, 0x5731, 0x11CF, 0x9A,0xF8,0x00,0x20,0xAF,0x73,0xAD,0x51);
DEFINE_GUID(CLSID_CSiteMapNode,         0xA61D5780, 0xBA29, 0x11CF, 0x95,0x2E,0x00,0xC0,0x4F,0xD7,0x05,0xB4);// A61D5780-BA29-11CF-952E-00C04FD705B4

DEFINE_GUID(IID_IDefViewBrowser,        0x9692C5C0, 0x7C21, 0x11CF, 0x95, 0x34, 0x00, 0x00, 0xC0, 0x5B, 0xAE, 0x0B);

DEFINE_GUID(CLSID_CShellHlinkFrame,     0x2C5A8FC0, 0x8401, 0x11CF, 0xA1, 0x2B, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);// 2C5A8FC0-8401-11CF-A12B-00AA004AE837
DEFINE_GUID(CLSID_CShellFrameAuto,      0x20C46560, 0x8491, 0x11CF, 0x96, 0x0C, 0x00, 0x80, 0xC7, 0xF4, 0xEE, 0x85);// 20C46560-8491-11CF-960C-0080C7F4EE85

// {E770AD23-7346-11d1-8AEE-00C04FC9E26E}
DEFINE_GUID(IID_IWebViewOCWinMan, 0xe770ad23, 0x7346, 0x11d1, 0x8a, 0xee, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

#if 0
// The old IMRU interface used by IE4.  This interface was not accessible
// to outside components, so I'm #if'ing it out completely, but I left it
// in the header so at least we'll recognize it if we see it again.
// {D095EB91-A7B2-11d0-8274-00AA005B4383}
DEFINE_GUID(IID_IMRU_IE4,               0xd095eb91, 0xa7b2, 0x11d0, 0x82, 0x74, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);
#endif



// This is Semi-gross, but if the IShellFolder can be agregated, there are times we need to get
// back to the real inner class.  So we create an internal GUID which we use to QueryInterface for
// which hopefully the outer object will allow through...
// ABCB3A00-1B2B-11CF-A49F-444553540000
DEFINE_GUID(IID_INeedRealCFSFolder,     0xABCB3A00, 0x1B2B, 0x11CF, 0xA4, 0x9F, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);


//
// this interface is used by DefView when it wants to run a script in one
// of its extended views.  the actual script triggers currently live in shdisp
//
// 4706B500-09EF-11D0-99CB-00C04FD64497
DEFINE_GUID(IID_IDefViewScript,         0x4706B500L, 0x09EF, 0x11D0, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);


DEFINE_GUID(IID_IObjectCache,           0xEA5F2D60L, 0xE008, 0x11CF, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);   // ;internal

DEFINE_GUID(SID_SDesktopExtMenu,        0x6F272F90L, 0x2380, 0x11D0, 0x89, 0xB9, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);

DEFINE_GUID(IID_IDelegateDropTargetCB,  0xbefd347e, 0xc7ec, 0x11d0, 0xb9, 0x3b, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);


// The thumbnail view extension
// {8BEBB290-52D0-11d0-B7F4-00C04FD706EC}
DEFINE_GUID(CLSID_ThumbnailViewExt,     0x8bebb290, 0x52d0, 0x11d0, 0xb7, 0xf4, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// The Favorites Shell extension
// for 1A9BA3A0-143A-11CF-8350-444553540000
DEFINE_GUID(CLSID_FavoritesFolder,      0x1A9BA3A0, 0x143A, 0x11CF, 0x83, 0x50, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00 );

// the Task band (for the tray).
// n.b. while we have a CLSID, we can't actually CoCreateInst it
// we fake it in tray's IBandSiteHelper implementation.
// {68284FAA-6A48-11d0-8C78-00C04FD918B4}
DEFINE_GUID(CLSID_TaskBand,             0x68284faa, 0x6a48, 0x11d0, 0x8c, 0x78, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xb4);

// MIME-enabled File Types Hook for browser-only installs
DEFINE_GUID(CLSID_MIMEFileTypesHook,    0xFBF23B41L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0xF8);

//  Cache Shellfolder Item private interface
DEFINE_GUID (IID_IHistCache,            0xF7FE8CA0L, 0xEC5A, 0x11CF, 0xBF, 0xF4, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);

//3531F060-22B3-11D0-969E-00AA00B60104

// {FFB4B000-9FAB-11d0-A3A4-00C04FD706EC}
DEFINE_GUID(VID_DefaultCustomWebView, 0xffb4b000, 0x9fab, 0x11d0, 0xa3, 0xa4, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

//FB4A79C0-C808-11D0-8D57-00C04FC99D61
DEFINE_GUID(CGID_MenuISF, 0xFB4A79C0L, 0xC808, 0x11D0, 0x8D, 0x57, 0x00, 0xC0, 0x4F, 0xC9, 0x9D, 0x61);

// {89820200-ECBD-11cf-8B85-00AA005B4383}
DEFINE_GUID(COMPID_IE4, 0x89820200, 0xecbd, 0x11cf, 0x8B, 0x85, 0x00, 0xAA, 0x00, 0x5B, 0x43, 0x83 );

// {4622AD10-FF23-11d0-8D34-00A0C90F2719}
DEFINE_GUID(IID_ITrayPriv,0x4622ad10, 0xff23, 0x11d0, 0x8d, 0x34, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// Whistler
// {9e83c057-6823-4f1f-bfa3-7461d40a8173}
DEFINE_GUID(IID_ITrayPriv2,0x9e83c057, 0x6823, 0x4f1f, 0xbf, 0xa3, 0x74, 0x61, 0xd4, 0x0a, 0x81, 0x73);

// {4622AD11-FF23-11d0-8D34-00A0C90F2719}
DEFINE_GUID(CLSID_StartMenu,0x4622ad11, 0xff23, 0x11d0, 0x8d, 0x34, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);
#define CLSID_StartMenuBar CLSID_StartMenu 

// Whistler
// {3f6953f0-5359-47fc-bd99-9f2cb95a62fd}
DEFINE_GUID(CLSID_PersonalStartMenu, 0x3f6953f0, 0x5359, 0x47fc, 0xbd, 0x99, 0x9f, 0x2c, 0xb9, 0x5a, 0x62, 0xfd);


// {733AC4CB-F1A4-11d0-B951-00A0C90312E1}
DEFINE_GUID(CLSID_CWebViewMimeFilter, 0x733ac4cb, 0xf1a4, 0x11d0, 0xb9, 0x51, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);

// Disk cleaner for the recycle bin
/* 5ef4af3a-f726-11d0-b8a2-00c04fc309a4 */
DEFINE_GUID(CLSID_RecycleBinCleaner,  0x5ef4af3a, 0xf726, 0x11d0, 0xb8, 0xa2, 0x00, 0xc0, 0x4f, 0xc3, 0x09, 0xa4 );

// {1820FED0-473E-11D0-A96C-00C04FD705A2}
// WARNING: CLSID_CDefViewOC is also stored in shell\shdocvw\selfreg.inx and shell\ext\shwizard\finisha.cpp
//          and D:\nt\private\shell\ext\html\construc\*.htt
DEFINE_GUID(CLSID_CDefViewOC, 0x1820FED0, 0x473E, 0x11D0, 0xA9, 0x6C, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

// {1430A130-103F-11d1-8D45-00A0C90F2719}
DEFINE_GUID(SID_SBandHandler, 0x1430a130, 0x103f, 0x11d1, 0x8d, 0x45, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {21090CB1-103F-11d1-8D45-00A0C90F2719}
DEFINE_GUID(CGID_BandHandler, 0x21090cb1, 0x103f, 0x11d1, 0x8d, 0x45, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {2E420C00-1361-11d1-8D49-00A0C90F2719}
DEFINE_GUID(CGID_Persist, 0x2e420c00, 0x1361, 0x11d1, 0x8d, 0x49, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {DDB008FE-048D-11d1-B9CD-00C04FC2C1D2}
DEFINE_GUID(CLSID_StartMenuTask,    0xddb008fe, 0x48d, 0x11d1, 0xb9, 0xcd, 0x0, 0xc0, 0x4f, 0xc2, 0xc1, 0xd2);

// {E7D3DB4E-199C-11d1-9828-00C04FD91972}
DEFINE_GUID(CLSID_DesktopTask,      0xe7d3db4e, 0x199c, 0x11d1, 0x98, 0x28, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {80D4A420-3167-11d2-BE3C-3078302C2030}
DEFINE_GUID(IID_IShellFolderTask,   0x80d4a420, 0x3167, 0x11d2, 0xbe, 0x3c, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30);

// {80D4A41F-3167-11d2-BE3C-3078302C2030}
DEFINE_GUID(IID_IStartMenuTask,     0x80d4a41f, 0x3167, 0x11d2, 0xbe, 0x3c, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30);

// {5EA35BC9-19B1-11d1-9828-00C04FD91972}
DEFINE_GUID(IID_IShellHotKey,       0x5ea35bc9, 0x19b1, 0x11d1, 0x98, 0x28, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {5c191fec-2d33-11d1-bd7e-0000f8753a75}
DEFINE_GUID(CGID_MenuBandItem,      0x5c191fec, 0x2d33, 0x11d1, 0xbd, 0x7e, 0x0, 0x00, 0xf8, 0x75, 0x3a, 0x75);

// {0563BC42-4418-11d1-8CB4-00C04FD918D0}
DEFINE_GUID(CGID_MenuBandRestriction, 0x563bc42, 0x4418, 0x11d1, 0x8c, 0xb4, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);
#define SID_SMenuBandRestriction CGID_MenuBandRestriction

// {B49C1CD0-5256-11d1-8CBB-00C04FD918D0}
DEFINE_GUID(NSID_Menu,             0xb49c1cd0, 0x5256, 0x11d1, 0x8c, 0xbb, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {CE422100-6CE1-11d1-838D-0000F80461CF}
DEFINE_GUID(CLSID_ShellMallocSpy,   0xce422100, 0x6ce1, 0x11d1, 0x83, 0x8d, 0x0, 0x0, 0xf8, 0x4, 0x61, 0xcf);

// {CE422101-6CE1-11d1-838D-0000F80461CF}
DEFINE_GUID(IID_IShellMallocSpy,    0xce422101, 0x6ce1, 0x11d1, 0x83, 0x8d, 0x0, 0x0, 0xf8, 0x4, 0x61, 0xcf);

// Defview background task IDs
// {956B35B8-6DCB-11d1-AD2F-00C04FB687DA}
DEFINE_GUID(TOID_DVIconExtract,    0x956b35b8, 0x6dcb, 0x11d1, 0xad, 0x2f, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {76119F10-B9E3-11D1-A7F4-006008059382}
DEFINE_GUID(TOID_DVIconOverlay, 0x76119F10L, 0xB9E3, 0x11D1, 0xA7, 0xF4, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);

// {956B35B9-6DCB-11d1-AD2F-00C04FB687DA}
DEFINE_GUID(TOID_DVBackgroundEnum, 0x956b35b9, 0x6dcb, 0x11d1, 0xad, 0x2f, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {77EDBB11-5E1B-41ed-B82E-A6211B0795DF}
DEFINE_GUID(TOID_DVBackgroundGroup, 0x77edbb11, 0x5e1b, 0x41ed, 0xb8, 0x2e, 0xa6, 0x21, 0x1b, 0x7, 0x95, 0xdf);

// {D6536934-9891-49a8-A137-B97FD8EDE243}
DEFINE_GUID(TOID_DVBackgroundStatusBar, 0xd6536934, 0x9891, 0x49a8, 0xa1, 0x37, 0xb9, 0x7f, 0xd8, 0xed, 0xe2, 0x43);

// {6FD71035-7E55-4aea-BBDE-C210FEF0301B}
DEFINE_GUID(TOID_DVBackgroundInfoTip, 0x6fd71035, 0x7e55, 0x4aea, 0xbb, 0xde, 0xc2, 0x10, 0xfe, 0xf0, 0x30, 0x1b);

// {A13E74D9-8A25-4b6e-AB43-0A6058AF18C5}
DEFINE_GUID(TOID_DVBackgroundDetailsSectionInfo, 0xa13e74d9, 0x8a25, 0x4b6e, 0xab, 0x43, 0xa, 0x60, 0x58, 0xaf, 0x18, 0xc5);

// {FCC504B5-92EC-4a72-B88E-358D72689233}
DEFINE_GUID(TOID_DVFileTypeProperties, 0xfcc504b5, 0x92ec, 0x4a72, 0xb8, 0x8e, 0x35, 0x8d, 0x72, 0x68, 0x92, 0x33);

// {F35C5BFB-C46F-4c35-ABE1-3605E9352152}
DEFINE_GUID(TOID_DVGetCommandState, 0xf35c5bfb, 0xc46f, 0x4c35, 0xab, 0xe1, 0x36, 0x5, 0xe9, 0x35, 0x21, 0x52);



// Offline Files property sheet extension.  Implemented in cscui.dll.
// {10CFC467-4392-11d2-8DB4-00C04FA31A66}
DEFINE_GUID(CLSID_OfflineFilesOptions, 0x10cfc467, 0x4392, 0x11d2, 0x8d, 0xb4, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x66);

// {169A0694-8DF9-11d1-A1C4-00C04FD75D13}
DEFINE_GUID(IID_ISearchProvider,   0x169a0694, 0x8df9, 0x11d1, 0xa1, 0xc4, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);


// 96a23e16-a1bc-11d1-b084-00c04fc33aa5
DEFINE_GUID(IID_ILVRange,          0x96a23e16L, 0xa1bc, 0x11d1, 0xb0, 0x84, 0x00, 0xc0, 0x4f, 0xc3, 0x3a, 0xa5);

// CLSID whose sole purpose is to let us locate BROWSEUI, wherever it happens to be installed
// ef8ad2d0-ae36-11d1-b2d2-006097df8c11
DEFINE_GUID(CLSID_BROWSEUI,        0xef8ad2d0L, 0xae36, 0x11d1, 0xb2, 0xd2, 0x00, 0x60, 0x97, 0xdf, 0x8c, 0x11);

// {09799AFB-AD67-11d1-ABCD-00C04FC30936}
DEFINE_GUID(CLSID_OpenWithMenu, 0x9799afb, 0xad67, 0x11d1, 0xab, 0xcd, 0x0, 0xc0, 0x4f, 0xc3, 0x9, 0x36);

// {7febaf7c-18cf-11d2-993f-00a0c91f3880}
DEFINE_GUID(CLSID_DefViewPersistHistory, 0x7febaf7c, 0x18cf, 0x11d2, 0x99, 0x3f, 0x00, 0xa0, 0xc9, 0x1f, 0x38, 0x80);

// {bab33640-1280-11d2-aa30-00a0c91eedba}
DEFINE_GUID(CLSID_DocFindPersistHistory, 0xbab33640, 0x1280, 0x11d2, 0xaa, 0x30, 0x00, 0xa0, 0xc9, 0x1e, 0xed, 0xba);

// {5CFCC662-1767-11d2-A222-0000F81FEDEE}
DEFINE_GUID(IID_IFolderShortcutConvert, 0x5cfcc662, 0x1767, 0x11d2, 0xa2, 0x22, 0x0, 0x0, 0xf8, 0x1f, 0xed, 0xee);


// {C0C66348-C440-11d2-9F03-006097C686F6}
DEFINE_GUID(CLSID_FolderShortcutToShortcut, 0xc0c66348, 0xc440, 0x11d2, 0x9f, 0x3, 0x0, 0x60, 0x97, 0xc6, 0x86, 0xf6);

// {C8B35474-C440-11d2-9F03-006097C686F6}
DEFINE_GUID(CLSID_ShortcutToFolderShortcut, 0xc8b35474, 0xc440, 0x11d2, 0x9f, 0x3, 0x0, 0x60, 0x97, 0xc6, 0x86, 0xf6);

// {BDEADF00-C265-11d0-BCED-00A0C90AB50F}	IID_WebFolders
DEFINE_GUID(CLSID_WebFolders, 0xBDEADF00, 0xC265, 0x11d0, 0xbc, 0xed, 0x0, 0xa0, 0xc9, 0xa, 0xb5, 0x0f);

// map old names to nice names
#define CLSID_CControls         CLSID_ControlPanel
#define CLSID_ShellBitBucket    CLSID_RecycleBin
#define CLSID_ShellDrives       CLSID_MyComputer
#define CLSID_CPrinters         CLSID_Printers
#define CLSID_ShellNetwork      CLSID_NetworkPlaces
#define CLSID_ShellInetRoot     CLSID_Internet

#define CLSID_ShellNetworkDomain    CLSID_NetworkDomain
#define CLSID_ShellNetworkServer    CLSID_NetworkServer
#define CLSID_ShellNetworkShare     CLSID_NetworkShare

// {3F454F0E-42AE-4D7C-8EA3-328250D6E272}
DEFINE_GUID(CLSID_AutomationCM, 0x3f454f0e, 0x42ae, 0x4d7c, 0x8e, 0xa3, 0x32, 0x82, 0x50, 0xd6, 0xe2, 0x72 );

// B347B4F1-112D-4C31-A69F-F68B34A4F72E
DEFINE_GUID(CLSID_WebViewPluggableProtocol, 0xB347B4F1L, 0x112D, 0x4C31, 0xA6, 0x9F, 0xF6, 0x8B, 0x34, 0xA4, 0xF7, 0x2E);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\startids.h ===
#ifndef _STARTIDS_H
#define _STARTIDS_H

#define IDM_FILERUN                 401
#define IDM_LOGOFF                  402
#define IDM_EJECTPC                 410
#define IDM_SETTINGSASSIST          411
#define IDM_TRAYPROPERTIES          413
#define IDM_UPDATEWIZARD            414
#define IDM_UPDATE_SEP              415

#ifdef WINNT // hydra specific ids
#define IDM_MU_DISCONNECT           5000
#define IDM_MU_SECURITY             5001
#endif

#define IDM_RECENT              501
#define IDM_FIND                502
#define IDM_HELPSEARCH          503
#define IDM_PROGRAMS            504
#define IDM_CONTROLS            505
#define IDM_EXITWIN             506
#define IDM_SETTINGS            508
#define IDM_PRINTERS            510
#define IDM_STARTMENU           511
#define IDM_MYCOMPUTER          512
#define IDM_PROGRAMSINIT        513
#define IDM_RECENTINIT          514
#define IDM_MYDOCUMENTS         516
#define IDM_MENU_FIND           520
#define TRAY_IDM_FINDFIRST      521  // this range
#define TRAY_IDM_FINDLAST       550  // is reserved for find command
#define IDM_NETCONNECT          557


// Orphans from IE401....
#ifdef FEATURE_BROWSEWEB
#define IDM_MENU_WEB            551
#endif

#define IDM_DESKTOPHTML_CUSTOMIZE   552
#define IDM_DESKTOPHTML_UPDATE      553
#define IDM_DESKTOPHTML_ONOFF       554
#define IDM_FOLDERPROPERTIES        555
#define IDM_ACTIVEDESKTOP_PROP      556
#define IDM_FAVORITES               507
#define IDM_SUSPEND                 409

#define IDM_CSC                 553

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\shui.h ===
#ifndef _SHUI_H_
#define _SHUI_H_

/* Declaration needed for shdocvw and browseui to work together and 
for whatever reason they cannot go into shdocvw.h or browseui.h
*/
#include <mshtml.h>

STDAPI SearchForElementInHead
(
    IHTMLDocument2* pHTMLDocument,  // [in] document to search
    LPOLESTR        pszAttribName,  // [in] attribute to check for
    LPOLESTR        pszAttrib,      // [in] value the attribute must have
    REFIID          iidDesired,     // [in] element interface to return
    IUnknown**      ppunkDesired    // [out] returned interface

);


typedef HRESULT (*PFNSEARCHFORELEMENTINHEAD)(
    IHTMLDocument2* pHTMLDocument,  // [in] document to search
    LPOLESTR        pszAttribName,  // [in] attribute to check for
    LPOLESTR        pszAttrib,      // [in] value the attribute must have
    REFIID          iidDesired,     // [in] element interface to return
    IUnknown**      ppunkDesired    // [out] returned interface
    );


#define SEARCHFORELEMENTINHEAD_ORD 208

typedef struct _internet_shortcut_params
{
    LPCITEMIDLIST pidlTarget;
    LPCTSTR  pszTitle;           
                              // when shdocvw is made unicode - then the use of this struct in browseui
                              // will have to be changed to reflect that these are TCHAR
    LPCTSTR pszDir;
    LPTSTR  pszOut;
    int     cchOut;
    BOOL    bUpdateProperties;
    BOOL    bUniqueName;
    BOOL    bUpdateIcon;
    IOleCommandTarget *pCommand;
    IHTMLDocument2 *pDoc;
} ISHCUT_PARAMS;


STDAPI
CreateShortcutInDirEx(ISHCUT_PARAMS *pIShCutParams);


typedef HRESULT (*PFNDOWNLOADICONFORSHORTCUT)(WCHAR *pwszFileName, WCHAR *pwszShortcutUrl, WCHAR *pwszIconUrl);
#define DOWNLOADICONFORSHORTCUT_ORD 207   
STDAPI
DownloadIconForShortcut(
    WCHAR *pwszFileName,            // [in] Optional, File name of shortcut - full path
    WCHAR *pwszShortcutUrl,         // [in] Url of Shortcut
    IHTMLDocument2* pHTMLDocument  // [in] document to search for icon URL 
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\shmenu.cpp ===
/*++

  shmenu.cpp

  this is for IShellMenu and related stuff.  eventually all
  of the fsmenu.c functionality should be in here

--*/




class CFMDropTarget : public IDropTarget 
{
public:

    CFMDropTarget();
    ~CFMDropTarget();

    HRESULT Init (
        HWND hwnd, 
        IShellFolder *psf, 
        LPITEMIDLIST pidl,
        DWORD dwFlags);

    // IUnknown methods

    virtual STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP DragEnter(
        IDataObject *pdata,
        DWORD grfKeyState,
        POINTL pt,
        DWORD *pdwEffect)
    {return _pdrop->DragEnter(pdata, grfKeyState, pt, pdwEffect);}
    
    STDMETHODIMP DragOver( 
        DWORD grfKeyState,
        POINTL pt,
        DWORD *pdwEffect)
    {return _pdrop->DragOver(grfKeyState, pt, pdwEffect);}
    
    STDMETHODIMP DragLeave( void)
    {return _pdrop->DragLeave();}
    
    STDMETHODIMP  Drop( 
        IDataObject *pDataObj,
        DWORD grfKeyState,
        POINTL pt,
        DWORD *pdwEffect)
    {return _pdrop->Drop(pDataObj, grfKeyState, pt, pdwEffect);}

private:

    ULONG _cRef;
    IShellFolder *_psf;     //  the psf to use...
    LPITEMIDLIST _pidl;
    DWORD _dwFlags;
    IDropTarget *_pdrop;      //  the actual droptarget


}

CFMDropTarget :: CFMDropTarget ()
{
    _cRef = 1;
    DllAddRef();
}

CFMDropTarget :: ~CFMDropTarget ()
{
    SAFERELEASE(_psf);
    if(pidl)
        ILFree(pidl);
    SAFERELEASE(_pdrop);
    DllRelease();
}

HRESULT
CFMDropTarget :: QueryInterface(REFIID riid, PVOID *ppvObj)
{
    HRESULT hr = E_NOINTERFACE;


    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDropTarget))
    {
        AddRef();
        *ppvObj = (LPVOID) SAFECAST(this, IDropTarget*);
        hr = S_OK;

    }

    return hr;
}


ULONG
CFMDropTarget :: AddRef(void)
{

    _cRef++;

    return _cRef;

}

ULONG
CFMDropTarget :: Release(void)
{
    ASSERT (_cRef > 0);

    cRef--;

    if (!cRef)
    {
        //time to go bye bye
        delete this;
        return 0;
    }

    return cRef;

}

// FEATURE: ZEKEL we are just using the psf here...we need to support more
HRESULT Init (
        HWND hwnd, 
        IShellFolder *psf, 
        LPITEMIDLIST pidl,
        DWORD dwFlags)
{
    HRESULT hr = E_INVALIDARG;

    if(psf)
        hr = psf->QueryInterface(IID_IShellFolder, (LPVOID *) &_psf);

    _pidl = ILClone(pidl);
    _dwFlags = dwFlags;

    if(SUCCEEDED(hr) && _psf && _pidl)
    {
        hr = _psf->CreateViewObject(hwnd, IID_IDropTarget, (LPVOID*) &_pdrop);
    }

    return hr;
}

//FEATURE: ZEKEL right now this doesnt support ordering, and assumes that you 
//want to drop right onto the current menu.  this is just a start.
//pidl and dwFlags are just dummy params
HRESULT
CFMDropTarget_CreateAndInit(
                            HWND hwnd, 
                            IShellFolder *psf, 
                            LPITEMIDLIST pidl,
                            DWORD dwFlags,
                            LPVOID *ppvObj)
{
    HRESULT hr = E_OUTOFMEMORY;
    CFMDropTarget *pdt;

    ASSERT(ppvObj)
    if(ppvObj)
        *ppvObj = NULL;
    else
        return E_INVALIDARG;


    pdt = new CFMDropTargetNULL;

    if (pdt)
    {
        hr = pdt->Init(hwnd, psf, pidl, dwFlags);

        if (SUCCEEDED(hr))
            *ppvObj= SAFECAST(pdt, IDropTarget * );
        else
            pdt->Release();
    }
    
    return hr;
}

    if (psf)
    {


        hr = psf->QueryInterface(IID_IShellFolder, (LPVOID *) &psfMine);

        if(SUCCEEDED(hr) && psfMine)
        {


    }


#if 0  // ZEKEL
    {
        if(pmgoi->dwFlags & (MNGO_TOPGAP | MNGO_BOTTOMGAP))
        {
            //then we need to use the current psf as the droptarget
            // and the pidl is just a marker
        }
        else
        {
            //  we need to use the pidl's psf as the droptarget if possible
                DWORD dwAttr = SFGAO_DROPTARGET;
                hr = psf->lpVtbl->GetAttributesOf(1, (LPCITEMIDLIST*)&pfmi->pidl, &dwAttr);
                if (SUCCEEDED(hres) && (dwAttr & SFGAO_DROPTARGET))
                {
                    hr = psf->lpVtbl->GetUIObjectOf(hwnd, 1, (LPCITEMIDLIST*)&pfmi->pidl,
                                              IID_IDropTarget, NULL, (LPVOID*)&_pdropgtCur);
                }
        }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\shstr.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: Shell String Class

    shstr.h

Author:

    Zeke Lucas (zekel)  27-Oct-96

Environment:

    User Mode - Win32

Revision History:


Abstract:

    this allows automatic resizing and stuff

    NOTE: this class is specifically designed to be used as a stack variable


--*/

#ifndef _SHSTR_H_

//  default shstr to something small, so we don't waste too much stack space
//  MAX_PATH is used frequently, so we'd like to a factor of that - so that
//  if we do grow to MAX_PATH size, we don't waste any extra.
#define DEFAULT_SHSTR_LENGTH    (MAX_PATH/4)


#ifdef UNICODE
#define ShStr ShStrW
#define UrlStr UrlStrW
#else
#define ShStr ShStrA
#define UrlStr UrlStrA
#endif //UNICODE

class ShStrA
{
public:

    //
    //  Constructors
    //
    ShStrA();

    //
    //  Destructor
    //
    ~ShStrA()
        {Reset();}

    //
    // the first are the only ones that count
    //
    HRESULT SetStr(LPCSTR pszStr, DWORD cchStr);
    HRESULT SetStr(LPCSTR pszStr);
    HRESULT SetStr(LPCWSTR pwszStr, DWORD cchStr);

    // the rest just call into the first three
    HRESULT SetStr(LPCWSTR pwszStr)
        {return SetStr(pwszStr, (DWORD) -1);}
    HRESULT SetStr(ShStrA &shstr)
        {return SetStr(shstr._pszStr);}


    ShStrA& operator=(LPCSTR pszStr)
        {SetStr(pszStr); return *this;}
    ShStrA& operator=(LPCWSTR pwszStr)
        {SetStr(pwszStr); return *this;}
    ShStrA& operator=(ShStrA &shstr)
        {SetStr(shstr._pszStr); return *this;}


    LPCSTR GetStr()
        {return _pszStr;}
    operator LPCSTR()
        {return _pszStr;}

    LPSTR GetInplaceStr(void)
        {return _pszStr;}

    // People want to play with the bytes in OUR internal buffer.  If they
    // call us correctly, and assume that the resulting pointer is only valid
    // as far as they want or as far as the current length, then let them.
    LPSTR GetModifyableStr(DWORD cchSizeToModify)
        {
         if (cchSizeToModify > _cchSize)
            if (FAILED(SetSize(cchSizeToModify)))
                return NULL;
          return _pszStr;
        }


    HRESULT Append(LPCSTR pszStr, DWORD cchStr);
    HRESULT Append(LPCSTR pszStr)
        {return Append(pszStr, (DWORD) -1);}
    HRESULT Append(CHAR ch)
        {return Append(&ch, 1);}

    //
    //  the Clone methods return memory that must be freed
    //
    ShStrA *Clone();
    LPSTR CloneStrA();
    LPWSTR CloneStrW();
    LPSTR CloneStr()
        {return CloneStrA();}

    
    VOID Reset();
    VOID Trim();

#ifdef DEBUG
    BOOL IsValid();
#else
    inline BOOL IsValid()
    {return _pszStr != NULL;}
#endif //DEBUG

    DWORD GetSize()
        {ASSERT(!(_cchSize % DEFAULT_SHSTR_LENGTH)); return (_pszStr ? _cchSize : 0);}

    HRESULT SetSize(DWORD cchSize);
    DWORD GetLen()
        {return lstrlenA(_pszStr);}



protected:
//    friend UrlStr;
/*
    TCHAR GetAt(DWORD cch)
        {return cch < _cchSize ? _pszStr[cch] : TEXT('\0');}
    TCHAR SetAt(TCHAR ch, DWORD cch)
        {return cch < _cchSize ? _pszStr[cch] = ch : TEXT('\0');}
*/
private:

    HRESULT _SetStr(LPCSTR psz);
    HRESULT _SetStr(LPCSTR psz, DWORD cb);
    HRESULT _SetStr(LPCWSTR pwszStr, DWORD cchStr);

    CHAR _szDefaultBuffer[DEFAULT_SHSTR_LENGTH];
    LPSTR _pszStr;
    DWORD _cchSize;


}; //ShStrA


class ShStrW
{
public:

    //
    //  Constructors
    //
    ShStrW();

    //
    //  Destructor
    //
    ~ShStrW()
        {Reset();}

    //
    // the first are the only ones that count
    //
    HRESULT SetStr(LPCSTR pszStr, DWORD cchStr);
    HRESULT SetStr(LPCSTR pszStr);
    HRESULT SetStr(LPCWSTR pwszStr, DWORD cchStr);

    // the rest just call into the first three
    HRESULT SetStr(LPCWSTR pwszStr)
        {return SetStr(pwszStr, (DWORD) -1);}
    HRESULT SetStr(ShStrW &shstr)
        {return SetStr(shstr._pszStr);}


    ShStrW& operator=(LPCSTR pszStr)
        {SetStr(pszStr); return *this;}
    ShStrW& operator=(LPCWSTR pwszStr)
        {SetStr(pwszStr); return *this;}
    ShStrW& operator=(ShStrW &shstr)
        {SetStr(shstr._pszStr); return *this;}


    LPCWSTR GetStr()
        {return _pszStr;}
    operator LPCWSTR()
        {return _pszStr;}

    LPWSTR GetInplaceStr(void)
        {return _pszStr;}

    // People want to play with the bytes in OUR internal buffer.  If they
    // call us correctly, and assume that the resulting pointer is only valid
    // as far as they want or as far as the current length, then let them.
    LPWSTR GetModifyableStr(DWORD cchSizeToModify)
        {
         if (cchSizeToModify > _cchSize)
            if (FAILED(SetSize(cchSizeToModify)))
                return NULL;
          return _pszStr;
        }

    HRESULT Append(LPCWSTR pszStr, DWORD cchStr);
    HRESULT Append(LPCWSTR pszStr)
        {return Append(pszStr, (DWORD) -1);}
    HRESULT Append(WCHAR ch)
        {return Append(&ch, 1);}

    //
    //  the Clone methods return memory that must be freed
    //
    ShStrW *Clone();
    LPSTR CloneStrA();
    LPWSTR CloneStrW();
    LPWSTR CloneStr()
        {return CloneStrW();}

    
    VOID Reset();
    VOID Trim();

#ifdef DEBUG
    BOOL IsValid();
#else
    BOOL IsValid() 
    {return (BOOL) (_pszStr ? TRUE : FALSE);}
#endif //DEBUG

    DWORD GetSize()
        {ASSERT(!(_cchSize % DEFAULT_SHSTR_LENGTH)); return (_pszStr ? _cchSize : 0);}

    HRESULT SetSize(DWORD cchSize);
    DWORD GetLen()
        {return lstrlenW(_pszStr);}



protected:
//    friend UrlStr;
/*
    TCHAR GetAt(DWORD cch)
        {return cch < _cchSize ? _pszStr[cch] : TEXT('\0');}
    TCHAR SetAt(TCHAR ch, DWORD cch)
        {return cch < _cchSize ? _pszStr[cch] = ch : TEXT('\0');}
*/
private:

    HRESULT _SetStr(LPCSTR psz);
    HRESULT _SetStr(LPCSTR psz, DWORD cb);
    HRESULT _SetStr(LPCWSTR pwszStr, DWORD cchStr);

    WCHAR _szDefaultBuffer[DEFAULT_SHSTR_LENGTH];
    LPWSTR _pszStr;
    DWORD _cchSize;


}; //ShStrW

#ifdef UNICODE
typedef ShStrW  SHSTR;
typedef ShStrW  *PSHSTR;
#else
typedef ShStrA  SHSTR;
typedef ShStrA  *PSHSTR;
#endif //UNICODE

typedef ShStrW  SHSTRW;
typedef ShStrW  *PSHSTRW;

typedef ShStrA  SHSTRA;
typedef ShStrA  *PSHSTRA;



#if 0  //DISABLED until i have written the SHUrl* functions - zekel 7-Nov-96

class UrlStr 
{
public:
    UrlStr()
        {return;}

    operator LPCTSTR();
    operator SHSTR();

    UrlStr &SetUrl(LPCSTR pszUrl);
    UrlStr &SetUrl(LPCWSTR pwszUrl);
    UrlStr &SetUrl(LPCSTR pszUrl, DWORD cchUrl);
    UrlStr &SetUrl(LPCWSTR pwszUrl, DWORD cchUrl);

    DWORD GetScheme();
    VOID GetSchemeStr(PSHSTR pstrScheme);

    HRESULT Combine(LPCTSTR pszUrl, DWORD dwFlags);

/*
    ShStr &GetLocation();
    ShStr &GetAnchor();
    ShStr &GetQuery();

    HRESULT Canonicalize(DWORD dwFlags);
*/
protected:
    SHSTR  _strUrl;
};
#endif //DISABLED


#endif // _SHSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\stubres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by inststub.rc
//
/* IDD_InstallStubProgress and IDS_UNINSTALL should be defined by the including
 * component to not conflict with other resources.
 *
 * Control IDs can live here since they don't need to be unique across dialogs.
 */

#define IDC_RUNNING_INSTALL_STUB        1000
#define IDC_RUNNING_UNINSTALL_STUB      1001
#define IDC_INSTALL_STUB_NAME           1002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\stdenum.h ===
//=--------------------------------------------------------------------------=
// StandardEnum.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// object definition for a generic enumerator object.
//
#ifndef _STANDARDENUM_H_

// A specific implementation of the Clone function
void WINAPI CopyAndAddRefObject(void *pDest, const void *pSource, DWORD dwSize);

// An IEnumConnectionPoints creation function
HRESULT CreateInstance_IEnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum, DWORD count, ...);

// to support a generic Enumerator object, we'll just define this
// interface.  it can be safely cast to any other enumerator, since all
// they differ in is their pointer type in Next().
//
class IEnumGeneric: public IUnknown {

  public:
    virtual HRESULT __stdcall Next(ULONG celt, LPVOID rgelt, ULONG *pceltFetched) = 0;
    virtual HRESULT __stdcall Skip(ULONG celt) = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(IEnumGeneric **ppenum) = 0;
};

//=--------------------------------------------------------------------------=
// StandardEnum
//=--------------------------------------------------------------------------=
// a generic enumerator object.  given a pointer to generic data, some
// information about the elements, and a function to copy the elements,
// we can implement a generic enumerator.
//
// NOTE: this class assumes that rgElements is HeapAlloc'd, and will free it
//       in it's destructor [although it IS valid for this to be NULL if there
//       are no elements to enumerate over.]
//
class CStandardEnum: public IEnumGeneric {

public:
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IEnumVariant methods
    //
    STDMETHOD(Next)(unsigned long celt, void * rgvar, unsigned long * pceltFetched); 
    STDMETHOD(Skip)(unsigned long celt); 
    STDMETHOD(Reset)(); 
    STDMETHOD(Clone)(IEnumGeneric **ppEnumOut); 

    CStandardEnum(REFIID riid, BOOL fMembersAreInterfaces, int cElement, int cbElement, void *rgElements,
                 void (WINAPI * pfnCopyElement)(void *, const void *, DWORD));
    virtual ~CStandardEnum();

private:
    int m_cRef;

    IID m_iid;                        // type of enumerator that we are
    int m_cElements;                  // Total number of elements
    int m_cbElementSize;              // Size of each element
    int m_iCurrent;                   // Current position: 0 = front, m_cElt = end
    BOOL m_fMembersAreInterfaces;   // Indicates that members of the enumerated array are
                                      // Interfaces and that we need to hold refs on them
    VOID * m_rgElements;              // Array of elements  
    CStandardEnum *m_pEnumClonedFrom; // If we were cloned, from whom?
    void  (WINAPI * m_pfnCopyElement)(void *, const void *, DWORD);

    const void *GetNthElement(int n)
    {   return (const BYTE *)m_rgElements + (m_cbElementSize * n);  }
};


STDAPI_(void*) CStandardEnum_CreateInstance(REFIID riid, BOOL fMembersAreInterfaces, int cElement, int cbElement, void *rgElements,
                 void (WINAPI * pfnCopyElement)(void *, const void *, DWORD));


#define _STANDARDENUM_H_
#endif // _STANDARDENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\tokenutil.h ===
//  --------------------------------------------------------------------------
//  Module Name: TokenUtil.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class to handle privilege enabling and restoring across function calls.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//              2000-03-31  vtan        duplicated from ds to shell
//  --------------------------------------------------------------------------

#ifndef     _TokenUtil_
#define     _TokenUtil_

STDAPI_(BOOL)   OpenEffectiveToken (IN DWORD dwDesiredAccess, OUT HANDLE *phToken);

//  --------------------------------------------------------------------------
//  CPrivilegeEnable
//
//  Purpose:    This class enables a privilege for the duration of its scope.
//              The privilege is restored to its original state on
//              destruction.
//
//  History:    1999-08-18  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//              2000-03-31  vtan        duplicated from ds to shell
//  --------------------------------------------------------------------------

class   CPrivilegeEnable
{
    private:
                                    CPrivilegeEnable (void);
                                    CPrivilegeEnable (const CPrivilegeEnable& copyObject);
        const CPrivilegeEnable&     operator = (const CPrivilegeEnable& assignObject);
    public:
                                    CPrivilegeEnable (const TCHAR *pszName);
                                    CPrivilegeEnable (ULONG ulPrivilegeValue);
                                    ~CPrivilegeEnable (void);
    private:
        bool                        _fSet;
        HANDLE                      _hToken;
        TOKEN_PRIVILEGES            _tokenPrivilegePrevious;
};

#endif  /*  _TokenUtil_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\trayp.h ===
#ifndef _TRAYP_INC
#define _TRAYP_INC


#define TBC_SETACTIVEALT            (WM_USER + 50)      //  50=0x32
#define TBC_VERIFYBUTTONHEIGHT      (WM_USER + 51)
#define TBC_CANMINIMIZEALL          (WM_USER + 52)
#define TBC_MINIMIZEALL             (WM_USER + 53)
#define TBC_WARNNODROP              (WM_USER + 54)
#define TBC_SETPREVFOCUS            (WM_USER + 55)
#define TBC_FREEPOPUPMENUS          (WM_USER + 56)
#define TBC_SYSMENUCOUNT            (WM_USER + 57)
#define TBC_CHANGENOTIFY            (WM_USER + 58)
#define TBC_POSTEDRCLICK            (WM_USER + 59)
#define TBC_MARKFULLSCREEN          (WM_USER + 60)
#define TBC_TASKTAB                 (WM_USER + 61)
#define TBC_BUTTONHEIGHT            (WM_USER + 62)

#define WMTRAY_PROGCHANGE           (WM_USER + 200)     // 200=0xc8
#define WMTRAY_RECCHANGE            (WM_USER + 201)
#define WMTRAY_FASTCHANGE           (WM_USER + 202)
// was  WMTRAY_DESKTOPCHANGE        (WM_USER + 204)

#define WMTRAY_COMMONPROGCHANGE     (WM_USER + 205)
#define WMTRAY_COMMONFASTCHANGE     (WM_USER + 206)

#define WMTRAY_FAVORITESCHANGE      (WM_USER + 207)

#define WMTRAY_REGISTERHOTKEY       (WM_USER + 230)
#define WMTRAY_UNREGISTERHOTKEY     (WM_USER + 231)
#define WMTRAY_SETHOTKEYENABLE      (WM_USER + 232)
#define WMTRAY_SCREGISTERHOTKEY     (WM_USER + 233)
#define WMTRAY_SCUNREGISTERHOTKEY   (WM_USER + 234)
#define WMTRAY_QUERY_MENU           (WM_USER + 235)
#define WMTRAY_QUERY_VIEW           (WM_USER + 236)     // 236=0xec
#define WMTRAY_TOGGLEQL             (WM_USER + 237)

// #define TM_POSTEDRCLICK             (WM_USER+0x101)
#define TM_CONTEXTMENU              (WM_USER+0x102)
#define TM_FACTORY                  (WM_USER+0x103)     // OPK tools use this
#define TM_ACTASTASKSW              (WM_USER+0x104)
#define TM_LANGUAGEBAND             (WM_USER+0x105)

#define TM_RELAYPOSCHANGED          (WM_USER + 0x150)
#define TM_CHANGENOTIFY             (WM_USER + 0x151)
#define TM_BRINGTOTOP               (WM_USER + 0x152)
#define TM_WARNNOAUTOHIDE           (WM_USER + 0x153)
// #define TM_WARNNODROP               (WM_USER + 0x154)
// #define TM_NEXTCTL                  (WM_USER + 0x155)
#define TM_DOEXITWINDOWS            (WM_USER + 0x156)
#define TM_SHELLSERVICEOBJECTS      (WM_USER + 0x157)
#define TM_DESKTOPSTATE             (WM_USER + 0x158)
#define TM_HANDLEDELAYBOOTSTUFF     (WM_USER + 0x159)
#define TM_GETHMONITOR              (WM_USER + 0x15a)

#ifdef DEBUG
#define TM_NEXTCTL                  (WM_USER + 0x15b)
#endif
#define TM_UIACTIVATEIO             (WM_USER + 0x15c)
#define TM_ONFOCUSCHANGEIS          (WM_USER + 0x15d)

#define TM_MARSHALBS                (WM_USER + 0x15e)
// was TM_THEATERMODE, do not reuse (WM_USER + 0x15f)
#define TM_KILLTIMER                (WM_USER + 0x160)
#define TM_REFRESH                  (WM_USER + 0x161)
#define TM_SETTIMER                 (WM_USER + 0x162)
#define TM_DOTRAYPROPERTIES         (WM_USER + 0x163)

#define TM_PRIVATECOMMAND           (WM_USER + 0x175)
#define TM_HANDLESTARTUPFAILED      (WM_USER + 0x176)
// #define TM_CHANGENOTIFY             (WM_USER + 0x177)
#define TM_STARTUPAPPSLAUNCHED      (WM_USER + 0x178)
#define TM_RAISEDESKTOP             (WM_USER + 0x179)
#define TM_SETPUMPHOOK              (WM_USER + 0x180)

#define TM_WORKSTATIONLOCKED        (WM_USER + 0x181)
#define TM_STARTMENUDISMISSED       (WM_USER + 0x182)
#define TM_SHOWTRAYBALLOON          (WM_USER + 0x190)

#define Tray_GetHMonitor(hwndTray, phMon) \
        (DWORD)SendMessage((hwndTray), TM_GETHMONITOR, 0, (LPARAM)(HMONITOR *)phMon)

#endif // _TRAYP_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\tb_ids.h ===
#ifndef _TB_IDS_H_
#define _TB_IDS_H_


// IE toolbar strips

#define IDB_TB_IE_BASE          200
#define IDB_TB_IE_DEF_24        204
#define IDB_TB_IE_HOT_24        205
#define IDB_TB_IE_DEF_16        206
#define IDB_TB_IE_HOT_16        207


// Shell toolbar strips

#define IDB_TB_SH_BASE          210
#define IDB_TB_SH_DEF_24        214
#define IDB_TB_SH_HOT_24        215
#define IDB_TB_SH_DEF_16        216
#define IDB_TB_SH_HOT_16        217


// Extension strips

#define IDB_TB_EXT_DEF_16       225
#define IDB_TB_EXT_HOT_16       226
#define IDB_TB_EXT_DEF_24       227
#define IDB_TB_EXT_HOT_24       228

// "Go" toolbar strips

#define IDB_TB_GO_DEF_20        230
#define IDB_TB_GO_HOT_20        231

// Branding strips

#define IDB_BRAND_BITMAP_MICRO  240
#define IDB_BRAND_BITMAP_SMALL  241
#define IDB_BRAND_BITMAP_LARGE  242

#define IDB_BRAND256_BITMAP_MICRO  245
#define IDB_BRAND256_BITMAP_SMALL  246
#define IDB_BRAND256_BITMAP_LARGE  247


#endif //_TB_IDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\uassist.cpp ===
//***   uassist.cpp -- User Assist helpers (retail and debug)
//
// DESCRIPTION
//  this file has the shared-source 'master' implementation.  it is
// #included in each DLL that uses it.  NEEDED because of ENTERCRITICAL
// as stocklib.dll does not have a critical section in it.
//
//  clients do something like:
//      #include "priv.h"   // for types, ASSERT, DM_*, DF_*, etc.
//      #include "../lib/uassist.cpp"
//
//  we cache the UAssist object and provide thunks for 'safe' access to it.

#include "uemapp.h"

#define DM_UASSIST             0

IUserAssist *g_uempUa;      // 0:uninit, -1:failed, o.w.:cached obj

//***   GetUserAssist -- get (and create) cached UAssist object
//
IUserAssist *GetUserAssist()
{
    HRESULT hr;
    IUserAssist * pua = NULL;

    if (g_uempUa == 0)
    {
        // re: CLSCTX_NO_CODE_DOWNLOAD
        // an ('impossible') failed CCI of UserAssist is horrendously slow.
        // e.g. click on the start menu, wait 10 seconds before it pops up.
        // we'd rather fail than hose perf like this, plus this class should
        // never be remote.
        // FEATURE: there must be a better way to tell if CLSCTX_NO_CODE_DOWNLOAD
        // is supported, i've sent mail to 'com' to find out...
        DWORD dwFlags = staticIsOS(OS_WIN2000ORGREATER) ? (CLSCTX_INPROC|CLSCTX_NO_CODE_DOWNLOAD) : CLSCTX_INPROC;
        hr = THR(CoCreateInstance(CLSID_UserAssist, NULL, dwFlags, IID_IUserAssist, (void**)&pua));
        ASSERT(SUCCEEDED(hr) || pua == NULL);  // follow COM rules

        if (pua)
        {
            HINSTANCE hInst;

            hInst = SHPinDllOfCLSID(&CLSID_UserAssist); // cached across threads
            // we're toast if this fails!!! (but happily, that's 'impossible')
            // e.g. during logon when grpconv.exe is ShellExec'ed, we do
            // a GetUserAssist, which caches a ptr to browseui's singleton
            // object.  then when the ShellExec returns, we do CoUninit,
            // which would free up the (non-pinned) browseui.dll.  then
            // a later use of the cache would go off into space.
        }

        ENTERCRITICAL;
        if (g_uempUa == 0) {
            g_uempUa = pua;     // xfer refcnt (if any)
            if (!pua) {
                // mark it failed so we won't try any more
                g_uempUa = (IUserAssist *)-1;
            }
            pua = NULL;
        }
        LEAVECRITICAL;
        if (pua)
            pua->Release();
        TraceMsg(DM_UASSIST, "sl.gua: pua=0x%x g_uempUa=%x", pua, g_uempUa);
    }

    return (g_uempUa == (IUserAssist *)-1) ? 0 : g_uempUa;
}

extern "C"
BOOL UEMIsLoaded()
{
    BOOL fRet;

    fRet = GetModuleHandle(TEXT("ole32.dll")) &&
        GetModuleHandle(TEXT("browseui.dll"));
    
    return fRet;
}

//***   UEMFireEvent, QueryEvent, SetEvent -- 'safe' thunks
// DESCRIPTION
//  call these so don't have to worry about cache or whether Uassist object
// even was successfully created.
extern "C"
HRESULT UEMFireEvent(const GUID *pguidGrp, int eCmd, DWORD dwFlags, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = E_FAIL;
    IUserAssist *pua;

    pua = GetUserAssist();
    if (pua) {
        hr = pua->FireEvent(pguidGrp, eCmd, dwFlags, wParam, lParam);
    }
    return hr;
}

extern "C"
HRESULT UEMQueryEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui)
{
    HRESULT hr = E_FAIL;
    IUserAssist *pua;

    pua = GetUserAssist();
    if (pua) {
        hr = pua->QueryEvent(pguidGrp, eCmd, wParam, lParam, pui);
    }
    return hr;
}

extern "C"
HRESULT UEMSetEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui)
{
    HRESULT hr = E_FAIL;
    IUserAssist *pua;

    pua = GetUserAssist();
    if (pua) {
        hr = pua->SetEvent(pguidGrp, eCmd, wParam, lParam, pui);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\uemapp.h ===
#ifndef _UEMAPP_H_ // {
#define _UEMAPP_H_

//***   uemapp.h -- application (client) side of event monitor
//

#ifdef __cplusplus
extern "C" {
#endif

// {
//***   UEME_* -- events
#include "uemevt.h"         // separate #include so rulc.exe can use it

#define UEME_FBROWSER   0x80000000  // 0:shell 1:browser

//***   UEMF_* -- Flags used when calling FireEvent
#define UEMF_EVENTMON   0x00000001       // Traditional Event Monitor use of FireEvent
#define UEMF_INSTRUMENT 0x00000002       // These events are being instrumented
#define UEMF_MASK       (UEMF_EVENTMON | UEMF_INSTRUMENT)

//****  UEMF_ Meta Categories
#define UEMF_XEVENT     (UEMF_EVENTMON | UEMF_INSTRUMENT)

//***   UIG_* -- UI 'groups'
// NOTES
//  NOTE not sure if this is the right partitioning
#define UIG_NIL         (-1)
#define UIG_COMMON      1       // common UI elements (e.g. back/stop/refresh)
#define UIG_INET        2       // inet (html) elements (e.g. search/favs)
#define UIG_FILE        3       // file (defview) elements (e.g. up)
#define UIG_OTHER       4       // custom (isf, isv, docobj) elements

//***   UIM_* -- modules
// NOTES
//  used to separate namespaces.  e.g. IDMs for UEME_RUNWMCMD.
#define UIM_NIL         (-1)    // none (global)
#define UIM_EXPLORER    1       // explorer.exe
#define UIM_BROWSEUI    2       // browseui.dll
#define UIM_SHDOCVW     3       // shdocvw.dll
#define UIM_SHELL32     4       // shell32.dll

// Instrumented Browser wparams 
#define UIBW_ADDTOFAV   1
#define UIBW_404ERROR   2
#define UIBW_NAVIGATE   3       // navigation lP=how
    #define UIBL_NAVOTHER   0   // via other
    #define UIBL_NAVADDRESS 1   // via address bar
    #define UIBL_NAVGO      2   // (NYI) via 'go' button on address bar
    #define UIBL_NAVHIST    3   // via history pane
    #define UIBL_NAVFAVS    4   // via favorites pane
    #define UIBL_NAVFOLDERS 5   // (NYI) via all-folders pane
    #define UIBL_NAVSEARCH  6   // (NYI) via search pane
#define UIBW_RUNASSOC   4       // run lP=assoc
    #define UIBL_DOTOTHER   0   // other
    #define UIBL_DOTEXE     1   // .exe
    #define UIBL_DOTASSOC   2   // associated w/ some .exe
    #define UIBL_DOTNOASSOC 3   // not associated w/ some .exe (OpenWith)
    #define UIBL_DOTFOLDER  4   // folder
    #define UIBL_DOTLNK     5   // .lnk
#define UIBW_UICONTEXT  5       // context menu lP=where
    #define UIBL_CTXTOTHER      0   // (NYI) other
    #define UIBL_CTXTDEFBKGND   1   // defview background
    #define UIBL_CTXTDEFITEM    2   // defview item
    #define UIBL_CTXTDESKBKGND  3   // desktop background
    #define UIBL_CTXTDESKITEM   4   // desktop item
//  #define UIBL_CTXTQCUTBKGND  5   // (n/a) qlaunch background
    #define UIBL_CTXTQCUTITEM   6   // qlaunch/qlinks item
//  #define UIBL_CTXTISFBKGND   7   // (n/a) arb. isf background
    #define UIBL_CTXTISFITEM    8   // arb. isf item
    #define UIBL_CTXTITBBKGND   9   // (n/a) itbar background
    #define UIBL_CTXTITBITEM    10  // itbar item
// for input, however the menu is *1st* invoked is assumed to be representative
// of the *entire* menu action
#define UIBW_UIINPUT    6       // input method lP=source
    // n.b. no desktop/browser distinction
    #define UIBL_INPOTHER   0       // (NYI) other
    #define UIBL_INPMOUSE   1       // mouse
    #define UIBL_INPMENU    2       // menu key (alt or alt+letter)
    #define UIBL_INPACCEL   3       // (NYI) accelerator
    #define UIBL_INPWIN     4       // (NYI) 'windows' key

// Instrumented Browser lparams
#define UIBL_KEYBOARD   1
#define UIBL_MENU       2
#define UIBL_PANE       3


//***   UEM*_* -- app 'groups'
//
#define UEMIID_NIL      CLSID_NULL              // nil (office uses 0...)
#define UEMIID_SHELL    CLSID_ActiveDesktop     // FEATURE need better one
#define UEMIID_BROWSER  CLSID_InternetToolbar   // FEATURE need better one

#define UEMIND_NIL      (-1)
#define UEMIND_SHELL    0
#define UEMIND_BROWSER  1

#define UEMIND_NSTANDARD    2   // cardinality(UEMIND_*)

//***   UEM*Event -- helpers from ../lib/uassist.cpp
// NOTES
//  FEATURE rename to UA* (from UEM*)
BOOL UEMIsLoaded();
HRESULT UEMFireEvent(const GUID *pguidGrp, int eCmd, DWORD dwFlags, WPARAM wParam, LPARAM lParam);
HRESULT UEMQueryEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui);
HRESULT UEMSetEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui);


typedef int (CALLBACK *UEMCallback)(void *param, const GUID *pguidGrp, int eCmd);

HRESULT UEMRegisterNotify(UEMCallback pfnUEMCB, void *param);

#if 1 // {
//***   obsolete -- old exports, nuke after all callers fixed
//

STDAPI_(void) UEMEvalMsg(const GUID *pguidGrp, int uemCmd, WPARAM wParam, LPARAM lParam);

// obsolete! use UEMEvalMsg
//STDAPI_(void) UEMTrace(int uemCmd, LPARAM lParam);
#define UEMTrace(uemCmd, lParam)    UEMEvalMsg(&UEMIID_NIL, uemCmd, -1, lParam)

#define UEIA_RARE       0x01    // rare (demotion candidate)

STDAPI_(BOOL) UEMGetInfo(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui);
#endif // }

// }

// {
//***   UEMC_* -- commands
//
#define TABDAT(uemc)   uemc,
enum {
    #include "uemcdat.h"
};
#undef  TABDAT
// }


// {
//***   misc helpers
//

//***   XMB_ICONERROR -- guys that look like an error (vs. idle chit-chat)
// error stop (question) exclamation hand (info) (aster) (warn)
// is this the right set? sounds good to me -justmann
#define XMB_ICONERROR   (MB_ICONERROR|MB_ICONSTOP|MB_ICONEXCLAMATION|MB_ICONHAND)
// }

#ifdef __cplusplus
}
#endif

#endif // } _UEMAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\uemcdat.h ===
//***   uemcmddat.h -- generator file for UEMC_*
// NOTES
//  this file is included in numerous contexts w/ TABDAT #defined
//  to give the desired behavior.   see the individ files for details.
//
//  NOTE:FEATURE: many of these are NYI.
//

TABDAT(UEMC_NIL)
TABDAT(UEMC_FIRST)

TABDAT(UEMC_STARTMENU)      // (pseudo) start menu

//
TABDAT(UEMC_PROGS)          // (NYI) (pseudo) catchall for FS programs
TABDAT(UEMC_FAVS)           // (NYI) (pseudo) catchall for FS favorites
TABDAT(UEMC_DOCS)           // (NYI) (pseudo) catchall for FS documents

// settings...
TABDAT(UEMC_CONTROLS)
TABDAT(UEMC_PRINTERS)
TABDAT(UEMC_TASKBAR)
TABDAT(UEMC_FOLDERS)
TABDAT(UEMC_ACTDESK)

// find...
TABDAT(UEMC_FINDFILES)
TABDAT(UEMC_FINDCOMP)
TABDAT(UEMC_FINDINTER)      // (NYI?)
TABDAT(UEMC_FINDOTHERS)     // (NYI) (pseudo) catchall for installed extensions

TABDAT(UEMC_HELPSEARCH)
TABDAT(UEMC_FILERUN)
TABDAT(UEMC_LOGOFF)         // unused?
TABDAT(UEMC_SHUTDOWN)       // unused?

TABDAT(UEMC_LAST)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\uemedat.h ===
//***   uemedat.h -- generator file for UEME_*
// NOTES
//  this file is included in numerous contexts w/ TABDAT #defined
//  to give the desired behavior.   see the individ files for details.
//
//  NOTE:FEATURE many of these are NYI.
//
//  e<n>    encode up to step <= n
//  f       fire event
//  l       log event
//  @       escape to custom code
//  !       ASSERT
//  x       NYI
//

// UI (menu, shortcut, etc.)
TABDAT(UEME_UIMENU     , "e2fl@" , 0, 0, 0, 0)
TABDAT(UEME_UIHOTKEY   , "e1fl"  , 0, 0, 0, 0)
TABDAT(UEME_UISCUT     , "e1fl"  , 0, 0, 0, 0)
TABDAT(UEME_UIQCUT     , "e1fl"  , 0, 0, 0, 0)
TABDAT(UEME_UITOOLBAR  , "e2fl"  , 0, 0, 0, 0)
#if 0 // 980825 uncomment in uemevt.h, uemedat.h if build breaks (tmp hack)
TABDAT(UEME_UIASSOC    , "e1fl"  , 0, 0, 0, 0)
#endif

// run (spawn, invoke, etc.)
TABDAT(UEME_RUNWMCMD   , "e2fl"  , 0, 0, 0, 0)
TABDAT(UEME_RUNPIDL    , "e2fl"  , 0, 0, 0, 0)
TABDAT(UEME_RUNINVOKE  , "xe1fl" , 0, 0, 0, 0)
TABDAT(UEME_RUNOLECMD  , "xe1fl" , 0, 0, 0, 0)
TABDAT(UEME_RUNPATHA   , "e2fl"  , 0, 0, 0, 0)
TABDAT(UEME_RUNPATHW   , "e2fl"  , 0, 0, 0, 0)
TABDAT(UEME_RUNCPLA    , "e2fl"  , 0, 0, 0, 0)
TABDAT(UEME_RUNCPLW    , "e2fl"  , 0, 0, 0, 0)

// exit status
TABDAT(UEME_DONECANCEL , "e1fl"  , 0, 0, 0, 0)
TABDAT(UEME_DONEOK     , "e1fl"  , 0, 0, 0, 0)
TABDAT(UEME_DONEFAIL   , "e1fl"  , 0, 0, 0, 0)

// error
// NOTES
//  for now lParam=szMsg, that's just temporary but not sure what we need yet
TABDAT(UEME_ERRORA     , "e1fl"  , 0, 0, 0, 0)
TABDAT(UEME_ERRORW     , "e1fl"  , 0, 0, 0, 0)

#ifdef UNICODE
TABDAT(UEME_ERROR      , "e1fl"  , 0, 0, 0, 0)
#else
TABDAT(UEME_ERROR      , "e1fl"  , 0, 0, 0, 0)
#endif

// control
TABDAT(UEME_CTLSESSION , "@"     , 0, 0, 0, 0)

// debug
TABDAT(UEME_DBTRACEA   , "@"     , 0, 0, 0, 0)
TABDAT(UEME_DBTRACEW   , "@"     , 0, 0, 0, 0)

#ifdef UNICODE
TABDAT(UEME_DBTRACE    , "@"     , 0, 0, 0, 0)
#else
TABDAT(UEME_DBTRACE    , "@"     , 0, 0, 0, 0)
#endif
TABDAT(UEME_DBSLEEP    , "@"     , 0, 0, 0, 0)

// Instrumented Browser
TABDAT(UEME_INSTRBROWSER, "e2fl" , 0, 0, 0, 0)

// all events below here (msg < UEME_USER) are reserved
// private messages start here (at UEME_USER + 0)
// FEATURE: NYI we don't support private messages for now
TABDAT(UEME_USER       , "x"     , 0, 0, 0, 0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\uemevt.h ===
// {
//***   UEME_* -- events
// DESCRIPTION
//  UEME_UI*
//  UEME_RUN*
//  UEME_DONE*
//  UEME_ERROR*
//  UEME_DB*
// NOTES
//  since rulc.exe must process this, it can *only* contain #defines.

// UI (menu, shortcut, etc.)
#define UEME_UIMENU     1   // did a UI menu, wP=grp lParam=IDM_*
#define UEME_UIHOTKEY   2   // did a UI hotkey, lParam=GHID_*
#define UEME_UISCUT     3   // did a UI shortcut, lParam=???
#define UEME_UIQCUT     4   // did a UI qlink/isfband, lParam=???
#define UEME_UITOOLBAR  5   // did a UI toolbar button, wP=lParam=???
#if 0 // 980825 uncomment in uemevt.h, uemedat.h if build breaks (tmp hack)
#define UEME_UIASSOC    6   // did a semi-UI association, wP=-1 lP=-1
#endif

// run (spawn, invoke, etc.)
#define UEME_RUNWMCMD   12  // ran a WM_COMMAND, lParam=UEMC_*
#define _UEME_RUNPIDL1  10  // (obsolete) ran a pidl, wP=csidl, lParam=pidl
#define UEME_RUNPIDL    18  // ran a pidl, wP=isf lP=pidlItem
#define UEME_RUNINVOKE  11  // ran an Ixxx::Invoke, lParam=???
#define UEME_RUNOLECMD  13  // ran an IOleCT::Exec wP=nCmdID lP=pguidCmdGrp
#define UEME_RUNPATHA   14  // ran a path, lParam=path
#define UEME_RUNPATHW   15  // ran a path, lParam=path
#define UEME_RUNCPLA    16  // ran a cpl path, wP=index lP=path
#define UEME_RUNCPLW    17  // ran a cpl path, wP=index lP=path

#ifdef UNICODE
#define UEME_RUNPATH    UEME_RUNPATHW
#define UEME_RUNCPL     UEME_RUNCPLW
#else
#define UEME_RUNPATH    UEME_RUNPATHA
#define UEME_RUNCPL     UEME_RUNCPLA
#endif

// exit status
#define UEME_DONECANCEL 32  // cancel
#define UEME_DONEOK     30  // (NYI) ok (==0)
#define UEME_DONEFAIL   31  // (NYI) fail (!=0)

// error
// NOTES
//  for now lParam=szMsg, that's just temporary but not sure what we need yet
#define UEME_ERRORA     20  // error (generic), lParam=szMsg
#define UEME_ERRORW     21  // error (generic), lParam=szMsg

#ifdef UNICODE
#define UEME_ERROR      UEME_ERRORW
#else
#define UEME_ERROR      UEME_ERRORA
#endif

// control
#define UEME_CTLSESSION 40  // do UASetSession

// instrumented browser
#define UEME_INSTRBROWSER 50

// debug
#define UEME_DBTRACEA   90  // just a midpoint trace..., lParam=szMsg
#define UEME_DBTRACEW   91  // just a midpoint trace..., lParam=szMsg

#ifdef UNICODE
#define UEME_DBTRACE    UEME_DBTRACEW
#else
#define UEME_DBTRACE    UEME_DBTRACEA
#endif

#define UEME_DBSLEEP    92  // sleep, lParam=mSec (per Sleep API)

// all events below here (msg < UEME_USER) are reserved
// private messages start here (at UEME_USER + 0)
// NOTE:FEATURE: NYI we don't support private messages for now
#define UEME_USER       256

// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\uihostipc.h ===
//  --------------------------------------------------------------------------
//  Module Name: UIHostIPC.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Messages for communication between SHGINA and the UI host.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _UIHostIPC_
#define     _UIHostIPC_

//  This comes in uMsg.

#define WM_UIHOSTMESSAGE                (WM_USER + 8517)

//  This comes in WPARAM.

#define HM_NOACTION                     (WPARAM)(-1)
#define HM_DISPLAYSTATUS                0
#define HM_DISPLAYREFRESH               1
#define HM_DISPLAYRESIZE                2
#define HM_SWITCHSTATE_STATUS          10
#define HM_SWITCHSTATE_LOGON           11
#define HM_SWITCHSTATE_LOGGEDON        12
#define HM_SWITCHSTATE_HIDE            13
#define HM_SWITCHSTATE_DONE            14
#define HM_NOTIFY_WAIT                 20
#define HM_SELECT_USER                 21
#define HM_SET_ANIMATIONS              22
#define HM_INTERACTIVE_LOGON_REQUEST   30

//  LPARAM depends on the WPARAM.

typedef struct _INTERACTIVE_LOGON_REQUEST
{
    WCHAR   szUsername[UNLEN + sizeof('\0')];
    WCHAR   szDomain[DNLEN + sizeof('\0')];
    WCHAR   szPassword[PWLEN + sizeof('\0')];
} INTERACTIVE_LOGON_REQUEST, *PINTERACTIVE_LOGON_REQUEST;

typedef struct _SELECT_USER
{
    WCHAR   szUsername[UNLEN + sizeof('\0')];
    WCHAR   szDomain[DNLEN + sizeof('\0')];
} SELECT_USER, *PSELECT_USER;

#endif  /*  _UIHostIPC_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\unimp.h ===
#ifdef DEBUG
#ifdef K32
const char UnimpMessage[] = "Unimplemented API %s";
const char AttentionMessage[] = "ATTENTION !!! API stub might corrupt the stack";

enum {DEB_FATAL, DEB_ERR, DEB_WARN, DEB_TRACE };
int apiLevel = DEB_WARN;
VOID    KERNENTRY   vDebugOut(int level, const char *pfmt, ...);

#define DebugOut(args) vDebugOut args
#define UNIMP_MESSAGE DebugOut((apiLevel, UnimpMessage, api_string));
#define DEBUG_OOPS    DebugOut((DEB_ERR, UnimpMessage, api_string)); \

#else

const char UnimpMessage[] = "Unimplemented API %s\r\n";
const char AttentionMessage[] = "ATTENTION !!! API stub might corrupt the stack\r\n";
#define UNIMP_MESSAGE DebugPrintf(UnimpMessage, api_string);
#define DEBUG_OOPS    DebugPrintf(UnimpMessage, api_string); _asm { int 3 };
#endif
#endif
/*
 * Macros for unimplemented APIs stubs.
 *
 */



#define API_name(api_name) api_name

#define API_decl(api_name) long APIENTRY API_name(api_name)

#ifdef DEBUG
#define API_body(api_name, return_value) \
    const char api_string[] = #api_name; \
    UNIMP_MESSAGE \
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED); \
    return(return_value);
#else
#define API_body(api_name, return_value) \
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED); \
    return(return_value);
#endif

#ifdef DEBUG
#define APISTUB_(api_name, return_value) \
API_decl(api_name) (VOID) \
{ \
    const char api_string[] = #api_name; \
    DebugPrintf(AttentionMessage); \
    DEBUG_OOPS \
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED); \
    return(return_value); \
}
#else
#define APISTUB_(api_name, return_value) \
API_decl(api_name) (VOID) \
{ \
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED); \
    return(return_value); \
}
#endif

#define APISTUB_0(api_name, return_value) \
API_decl(api_name) (VOID) \
{ \
API_body(api_name, return_value) \
}

#define APISTUB_1(api_name, return_value) \
API_decl(api_name) ( \
    int p1 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
}

#define APISTUB_2(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
}

#define APISTUB_3(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
}

#define APISTUB_4(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
}

#define APISTUB_5(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
}

#define APISTUB_6(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
}

#define APISTUB_7(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
}

#define APISTUB_8(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
}

#define APISTUB_9(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8, \
    int p9 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
    p9; \
}

#define APISTUB_10(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8, \
    int p9, \
    int p10 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
    p9; \
    p10; \
}

#define APISTUB_11(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8, \
    int p9, \
    int p10, \
    int p11 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
    p9; \
    p10; \
    p11; \
}

#define APISTUB_12(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8, \
    int p9, \
    int p10, \
    int p11, \
    int p12 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
    p9; \
    p10; \
    p11; \
    p12; \
}

#define APISTUB_13(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8, \
    int p9, \
    int p10, \
    int p11, \
    int p12, \
    int p13 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
    p9; \
    p10; \
    p11; \
    p12; \
    p13; \
}

#define APISTUB_14(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8, \
    int p9, \
    int p10, \
    int p11, \
    int p12, \
    int p13, \
    int p14 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
    p9; \
    p10; \
    p11; \
    p12; \
    p13; \
    p14; \
}

/*
 * Miscelaneous declarations needed for the APIs
 */
extern void _cdecl DebugPrintf();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\varutil.h ===
#ifndef _VARUTIL_H_
#define _VARUTIL_H_

// -------------------------------------------------------------------
// ANSI/UNICODE-neutral prototypes

STDAPI VariantChangeTypeForRead(VARIANT *pvar, VARTYPE vtDesired);

STDAPI_(LPITEMIDLIST) VariantToIDList(const VARIANT *pv);
STDAPI_(BOOL) VariantToBuffer(const VARIANT* pvar, void *pv, UINT cb);
STDAPI_(BOOL) VariantToGUID(const VARIANT *pvar, GUID *pguid);
STDAPI_(LPCWSTR) VariantToStrCast(const VARIANT *pvar);
STDAPI InitVariantFromBuffer(VARIANT *pvar, const void *pv, UINT cb);
STDAPI InitVariantFromIDList(VARIANT* pvar, LPCITEMIDLIST pidl);
STDAPI InitVariantFromGUID(VARIANT *pvar, REFGUID guid);
STDAPI InitBSTRVariantFromGUID(VARIANT *pvar, REFGUID guid);
STDAPI InitVariantFromStrRet(STRRET *pstrret, LPCITEMIDLIST pidl, VARIANT *pv);
STDAPI InitVariantFromFileTime(const FILETIME *pft, VARIANT *pv);

STDAPI_(BOOL) VariantToBOOL(VARIANT varIn);
STDAPI_(int) VariantToInt(VARIANT varIn);
STDAPI_(UINT) VariantToUINT(VARIANT varIn);
STDAPI_(ULONGLONG) VariantToULONGLONG(VARIANT varIn);
STDAPI InitVariantFromUINT(VARIANT *pvar, UINT ulVal);
STDAPI InitVariantFromInt(VARIANT *pvar, int lVal);
STDAPI InitVariantFromULONGLONG(VARIANT *pvar, ULONGLONG ullVal);

// -------------------------------------------------------------------
// ANSI- and UNICODE-specific prototypes

STDAPI_(BSTR) SysAllocStringA(LPCSTR);

STDAPI StringToStrRetW(LPCWSTR pszName, STRRET *pStrRet);

STDAPI_(void) DosTimeToDateTimeString(WORD wDate, WORD wTime, LPWSTR pszText, UINT cchText, int fmt);

STDAPI_(LPTSTR) VariantToStr(const VARIANT *pvar, LPWSTR pszBuf, int cchBuf);

STDAPI InitVariantFromStr(VARIANT *pvar, LPCWSTR psz);

STDAPI QueryInterfaceVariant(VARIANT v, REFIID riid, void **ppv);

// -------------------------------------------------------------------
// TCHAR-version defines

#ifdef UNICODE

#define SysAllocStringT(psz)        SysAllocString(psz)

#else // UNICODE

#define SysAllocStringT(psz)        SysAllocStringA(psz)

#endif // UNICODE

#endif // _VARUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\uxthemeserver.h ===
//---------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// File   : UxThemeServer.h
// Version: 1.0
//---------------------------------------------------------------------------
#ifndef _UXTHEMESERVER_H_                   
#define _UXTHEMESERVER_H_                   
//---------------------------------------------------------------------------
#include <uxtheme.h> 
//---------------------------------------------------------------------------
// These are private uxtheme exports used exclusively by the theme service
//---------------------------------------------------------------------------

THEMEAPI_(void *) SessionAllocate (HANDLE hProcess, DWORD dwServerChangeNumber, void *pfnRegister, 
                                   void *pfnUnregister, void *pfnClearStockObjects, DWORD dwStackSizeReserve, DWORD dwStackSizeCommit);
THEMEAPI_(void)   SessionFree (void *pvContext);
THEMEAPI_(int)    GetCurrentChangeNumber (void *pvContext);
THEMEAPI_(int)    GetNewChangeNumber (void *pvContext);
THEMEAPI_(void)   ThemeHooksInstall (void *pvContext);
THEMEAPI_(void)   ThemeHooksRemove (void *pvContext);
THEMEAPI_(void)   MarkSection (HANDLE hSection, DWORD dwAdd, DWORD dwRemove);
THEMEAPI_(BOOL)   AreThemeHooksActive (void *pvContext);

THEMEAPI ThemeHooksOn (void *pvContext);
THEMEAPI ThemeHooksOff (void *pvContext);
THEMEAPI SetGlobalTheme (void *pvContext, HANDLE hSection);
THEMEAPI GetGlobalTheme (void *pvContext, HANDLE *phSection);
THEMEAPI ServiceClearStockObjects(void* pvContext, HANDLE hSection);
THEMEAPI InitUserTheme (BOOL fPolicyCheckOnly);
THEMEAPI InitUserRegistry (void);
THEMEAPI ReestablishServerConnection (void);

THEMEAPI LoadTheme (void *pvContext, 
                    HANDLE hSectionIn, HANDLE *phSectionOut, 
                    LPCWSTR pszName, LPCWSTR pszColor, LPCWSTR pszSize,
                    OPTIONAL DWORD dwFlags /*LTF_xxx*/ );

#define LTF_TRANSFERSTOCKOBJOWNERSHIP   0x00000001
#define LTF_GLOBALPRIVILEGEDCLIENT      0x00000002

//---------------------------------------------------------------------------
#endif // _UXTHEMESERVER_H_                               
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\validate.h ===
#ifndef _validate_h_
#define _validate_h_

#ifdef __cplusplus
extern "C" {
#endif

/* parameter validation macros */

/*
 * call as:
 *
 * bOK = IS_VALID_READ_PTR(pfoo, CFOO);
 *
 * bOK = IS_VALID_HANDLE(hfoo, FOO);
 */

#ifdef DEBUG

#define IS_VALID_READ_PTR(ptr, type) \
   (IsBadReadPtr((ptr), sizeof(type)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs read pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_PTR(ptr, type) \
   (IsBadWritePtr((PVOID)(ptr), sizeof(type)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs write pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRA(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(char)) || IsBadStringPtrA((ptr), (UINT_PTR)(cch))) ? \
    (TraceMsgA(TF_ERROR, "invalid LPSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRW(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(WCHAR)) || IsBadStringPtrW((ptr), (UINT_PTR)(cch))) ? \
    (TraceMsgA(TF_ERROR, "invalid LPWSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_CODE_PTR(ptr, type) \
   (IsBadCodePtr((FARPROC)(ptr)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs code pointer - %#08lx", (LPCSTR)#type, (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (IsBadReadPtr((ptr), sizeof(type)*(len)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs read buffer pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (IsBadWritePtr((ptr), sizeof(type)*(len)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs write buffer pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? \
    (TraceMsgA(TF_ERROR, "invalid flags set - %#08lx", ((dwFlags) & (~(dwAllFlags)))), FALSE) : \
    TRUE)

#define IS_VALID_PIDL(ptr) \
   ( !IsValidPIDL(ptr) ? \
    (TraceMsgA(TF_ERROR, "invalid PIDL pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) != (cbExpected) ? \
    (TraceMsgA(TF_ERROR, "invalid size - is %#08lx, expected %#08lx", (cb), (cbExpected)), FALSE) : \
    TRUE)


#else

#define IS_VALID_READ_PTR(ptr, type) \
   (TRUE)

#define IS_VALID_WRITE_PTR(ptr, type) \
   (TRUE)

#define IS_VALID_STRING_PTRA(ptr, cch) \
   (TRUE)

#define IS_VALID_STRING_PTRW(ptr, cch) \
   (TRUE)

#define IS_VALID_CODE_PTR(ptr, type) \
   (TRUE)

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (TRUE)

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (TRUE)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? FALSE : TRUE)

#define IS_VALID_PIDL(ptr) \
   (TRUE)

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) == (cbExpected))

#endif

#ifdef UNICODE
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRW
#else
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRA
#endif


/* handle validation macros */

#ifdef DEBUG

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid H" #type " - %#08lx", (hnd)), FALSE))

#else

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd))

#endif

/* structure validation macros */

// Define VSTF if you want to validate the fields in structures.  This
// requires a handler function (of the form IsValid*()) that knows how
// to validate the specific structure type.

#ifdef VSTF

#ifdef DEBUG

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid %hs pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid %hs pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE))

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x))

#endif

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#endif  // VSTF

/* OLE interface validation macro */

#define IS_VALID_INTERFACE_PTR(ptr, iface) \
   IS_VALID_STRUCT_PTR(ptr, ##iface)


#if !defined(NO_SHELL_VALIDATION)

BOOL IsValidPathA(LPCSTR pcszPath);
BOOL IsValidPathW(LPCWSTR pcszPath);

BOOL IsValidPathResultA(HRESULT hr, LPCSTR pcszPath, UINT cchPathBufLen);
BOOL IsValidPathResultW(HRESULT hr, LPCWSTR pcszPath, UINT cchPathBufLen);

BOOL IsValidExtensionA(LPCSTR pcszExt);
BOOL IsValidExtensionW(LPCWSTR pcszExt);

BOOL IsValidIconIndexA(HRESULT hr, LPCSTR pcszIconFile, UINT cchIconFileBufLen, int niIcon);
BOOL IsValidIconIndexW(HRESULT hr, LPCWSTR pcszIconFile, UINT cchIconFileBufLen, int niIcon);

BOOL IsFullPathA(LPCSTR pcszPath);
BOOL IsFullPathW(LPCWSTR pcszPath);

BOOL IsStringContainedA(LPCSTR pcszBigger, LPCSTR pcszSuffix);
BOOL IsStringContainedW(LPCWSTR pcszBigger, LPCWSTR pcszSuffix);

#ifdef UNICODE
#define IsValidPath         IsValidPathW
#define IsValidPathResult   IsValidPathResultW
#define IsValidExtension    IsValidExtensionW
#define IsValidIconIndex    IsValidIconIndexW
#define IsFullPath          IsFullPathW
#define IsStringContained   IsStringContainedW
#else
#define IsValidPath         IsValidPathA
#define IsValidPathResult   IsValidPathResultA
#define IsValidExtension    IsValidExtensionA
#define IsValidIconIndex    IsValidIconIndexA
#define IsFullPath          IsFullPathA
#define IsStringContained   IsStringContainedA
#endif

BOOL IsValidHANDLE(HANDLE hnd);         // Compares with NULL and INVALID_HANDLE_VALUE
BOOL IsValidHANDLE2(HANDLE hnd);        // Compares with INVALID_HANDLE_VALUE

#define IsValidHEVENT       IsValidHANDLE
#define IsValidHGLOBAL      IsValidHANDLE
#define IsValidHFILE        IsValidHANDLE
#define IsValidHINSTANCE    IsValidHANDLE
#define IsValidHICON        IsValidHANDLE
#define IsValidHKEY         IsValidHANDLE
#define IsValidHMODULE      IsValidHANDLE
#define IsValidHPROCESS     IsValidHANDLE

BOOL
IsValidHWND(
    HWND hwnd);

BOOL
IsValidHMENU(
    HMENU hmenu);

BOOL
IsValidShowCmd(
    int nShow);

// The next few functions must declare the structure types explicitly
// so we don't need to worry about whether <shlobj.h> and/or <comctrlp.h>
// was included before or after us.
#include <shtypes.h>

BOOL
IsValidPIDL(
    LPCITEMIDLIST pidl);

BOOL
IsValidHDPA(
    struct _DPA *hdpa);

BOOL
IsValidHDSA(
    struct _DSA *hdsa);

#endif // NO_SHELL_VALIDATION

#ifdef __cplusplus
};
#endif

#endif // _validate_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\stubs\commctrl.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\commctrl.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/commctrl.h"
#endif /* UNIX */
#ifndef NO_PRIVATE_HEADERS
#include <comctrlp.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\wutilsp.h ===
#define MAX_PRN_PAGES 10

//
// This data structure is privately shared with 
// prtprop.c in SHELLDLL
// prt16.c in LIBRARY
//
typedef struct // apg
{
    DWORD cpages;
    HPROPSHEETPAGE ahpage[MAX_PRN_PAGES];
} PAGEARRAY, FAR * LPPAGEARRAY;

// thunk from shell232.dll -> shell.dll
VOID WINAPI CallAddPropSheetPages16(LPFNADDPROPSHEETPAGES lpfn16, LPVOID hdrop, LPPAGEARRAY papg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\w4warn.h ===
/*----------------------------------------------------------------------------
*  Note that we don't want to use a single line comment before the warning is
*   disabled.
*
*   Microsoft Windows
*   Copyright (C) Microsoft Corporation, 1992 - 2000.
*
*   File:       w4warn.h
*
*   Contents:   #pragmas to adjust warning levels.
*
*---------------------------------------------------------------------------*/

/*
 *   Level 4 warnings to suppress.
 */

#pragma warning(disable:4001) /* nonstandard extension 'extension' was used                            */
#pragma warning(disable:4097) /* typedef name 'type' used as synonym for class 'class'                 */
#pragma warning(disable:4100) /* unreferenced formal parameter                                         */
#pragma warning(disable:4115) /* named type definition in parentheses                                  */
#pragma warning(disable:4134) /* conversion between pointers to members of same class                  */
#pragma warning(disable:4152) /* nonstandard extension, function/data pointer conversion in expression */
#pragma warning(disable:4200) /* nonstandard extension used : zero-sized array in struct/union         */
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union                    */
#pragma warning(disable:4204) /* nonstandard extension used : non-constant aggregate initializer       */
#pragma warning(disable:4209) /* nonstandard extension used : benign typedef redefinition              */
#pragma warning(disable:4214) /* nonstandard extension used : bit field types other than int           */
#pragma warning(disable:4505) /* unreferenced local function has been removed                          */
#pragma warning(disable:4511) /* 'class' : copy constructor could not be generated                     */
#pragma warning(disable:4512) /* 'class': assignment operator could not be generated                   */
#pragma warning(disable:4514) /* 'function' : unreferenced inline function has been removed            */
#pragma warning(disable:4552) /* operator has no effect; expected operator with side-effect            */
#pragma warning(disable:4553) /* operator has no effect; did you intend '='?                           */
#pragma warning(disable:4705) /* statement has no effect                                               */
#pragma warning(disable:4710) /* function call not expanded                                            */
#pragma warning(disable:4711) /* function 'function' selected for inline expansion                     */
#pragma warning(disable:4068) /* unknown pragma */
/*
 * Warning 4244 is benign more often than not, so if you don't want it then
 * uncomment this to filter out those errors.
 *
 */
#pragma warning(disable:4244) /* conversion from 'type' to 'type', possible loss of data               */


/*
 * This helps to track down "Illegal attempt to instantiate abstract class" messages
 */
#pragma warning(error:4259) /* pure virtual function not defined                                       */

#pragma warning(error:4102) /* 'label' : unreferenced label                                            */

/*
 *   Level 4 warnings that we want treated as level 3 warnings.
 */
#ifndef DEBUG
#pragma warning(3:4127) /* conditional expression is constant                                          */
#else
// Too many places w/ ASSERT(FALSE); which will trigger this
#pragma warning(disable:4127) /* conditional expression is constant                                    */
#endif
#pragma warning(3:4702) /* unreachable code                                                            */
#pragma warning(3:4706) /* assignment within conditional expression                                    */

#pragma warning(disable:4041) /* compiler limit reached: terminating browser output                    */

#ifdef _MAC
#pragma warning(disable:4229) /* anachronism used : modifiers on data are ignored                      */
#pragma warning(disable:4798) /* pcode: constructors and destructors have native code generated        */
#endif

#ifdef _M_IA64
#pragma warning(disable:4268) /* 'variable' : 'const' static/global data initialized with compiler generated default constructor fills the object with zeros */
#endif

/*
 * VC6.0 temporary hack
 */

/*
#pragma warning(disable:4189) // local variable initialized but not used 
#pragma warning(disable:4701) // local variable used and may not have been initialized
#pragma warning(disable:4096) // __cdecl must be used with ...
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\windisk.h ===
/*
 * PLEASE NOTE: WINDISK is the file "WINDISK.CPL", this means
 *		you cannot implicit link to these APIs by simply
 *		linking with WINDISK.LIB. This is because KERNEL
 *		will only implicit link to module file names with
 *		the .DLL or .EXE extensions.
 *
 *		To use these APIs you need to LoadLibrary("WINDISK.CPL")
 *		and then use GetProcAddress.
 *
 *		  WDFMTDRVPROC lpfnFmtDrv;
 *		  HINSTANCE wdInst;
 *
 *		  wdInst = LoadLibrary("WINDISK.CPL");
 *		  if (wdInst) {
 *		    lpfnFmtDrv = (WDFMTDRVPROC)GetProcAddress(wdInst,"WinDisk_FormatDrive");
 *		    if (HIWORD(lpfnFmtDrv)) {
 *		      switch ((*lpfnFmtDrv)(hwnd, drive, WD_FMTID_DEFAULT, WD_FMT_OPT_FULL)) {
 *
 *			  case WD_FMT_ERROR:
 *
 *			  ...
 *
 *		      }
 *		      FreeLibrary(wdInst);
 *		    } else {
 *		      FreeLibrary(wdInst);
 *		      goto NoLib;
 *		    }
 *		  } else {
 *		NoLib:
 *
 *		WINDISK.LIB is provided for completeness only (and also
 *		allows you to figure out the ordinal, note that
 *		GetProcAddress "by name" is recommended however).
 */

/*
 * The WinDisk_FormatDrive API provides access to the WINDISK
 *   format dialog. This allows apps which want to format disks
 *   to bring up the same dialog that WINDISK does to do it.
 *
 *   This dialog is not sub-classable. You cannot put custom
 *   controls in it. If you want this ability, you will have
 *   to write your own front end for the DMaint_FormatDrive
 *   engine.
 *
 *   NOTE that the user can format as many diskettes in the specified
 *   drive, or as many times, as he/she wishes to. There is no way to
 *   force any specififc number of disks to format. If you want this
 *   ability, you will have to write your own front end for the
 *   DMaint_FormatDrive engine.
 *
 *   NOTE also that the format will not start till the user pushes the
 *   start button in the dialog. There is no way to do auto start. If
 *   you want this ability, you will have to write your own front end
 *   for the DMaint_FormatDrive engine.
 *
 *   PARAMETERS
 *
 *     hwnd    = The window handle of the window which will own the dialog
 *     drive   = The 0 based (A: == 0) drive number of the drive to format
 *     fmtID   = The ID of the physical format to format the disk with
 *		 NOTE: The special value WD_FMTID_DEFAULT means "use the
 *		       default format specified by the DMaint_FormatDrive
 *		       engine". If you want to FORCE a particular format
 *		       ID "up front" you will have to call
 *		       DMaint_GetFormatOptions yourself before calling
 *		       this to obtain the valid list of phys format IDs
 *		       (contents of the PhysFmtIDList array in the
 *		       FMTINFOSTRUCT).
 *     options = There is currently only one option bit defined
 *
 *		  WD_FMT_OPT_FULL
 *
 *		 The normal defualt in the WINDISK format dialog is
 *		 "Quick Format", setting this option bit indicates that
 *		 the caller wants to start with FULL format selected
 *		 (this is useful for folks detecting "unformatted" disks
 *		 and wanting to bring up the format dialog).
 *
 *		 All other bits are reserved for future expansion and
 *		 must be 0.
 *
 *		 Please note that this is a bit field and not a value
 *		 and treat it accordingly.
 *
 *   RETURN
 *	The return is either one of the WD_FMT_* values, or if the
 *	returned DWORD value is not == to one of these values, then
 *	the return is the physical format ID of the last succesful
 *	format. The LOWORD of this value can be passed on subsequent
 *	calls as the fmtID parameter to "format the same type you did
 *	last time".
 *
 */
DWORD WINAPI WinDisk_FormatDrive(HWND hwnd, WORD drive, WORD fmtID,
				 WORD options);

typedef DWORD (CALLBACK* WDFMTDRVPROC)(HWND,WORD,WORD,WORD);

//
// Special value of fmtID which means "use the default format"
//
#define WD_FMTID_DEFAULT    0xFFFF

//
// Option bits for options parameter
//
#define WD_FMT_OPT_FULL     0x0001

//
// Special return values. PLEASE NOTE that these are DWORD values.
//
#define WD_FMT_ERROR	0xFFFFFFFFL	// Error on last format, drive may be formatable
#define WD_FMT_CANCEL	0xFFFFFFFEL	// Last format was canceled
#define WD_FMT_NOFORMAT 0xFFFFFFFDL	// Drive is not formatable


/*
 * The WinDisk_CheckDrive API provides access to the WINDISK
 *   Check Disk dialog. This allows apps which want to check disks
 *   to bring up the same dialog that WINDISK does to do it.
 *
 *   This dialog is not sub-classable. You cannot put custom
 *   controls in it. If you want this ability, you will have
 *   to write your own front end for the DMaint_FixDrive
 *   engine.
 *
 *   NOTE that the check will not start till the user pushes the
 *   start button in the dialog unless the CHKOPT_AUTO option is set.
 *
 *   PARAMETERS
 *
 *     hwnd    = The window handle of the window which will own the dialog
 *     options = These options basically coorespond to the check boxes
 *		 in the Advanced Options dialog. See CHKOPT_ defines
 *		 below.
 *     DrvList = This is a DWORD bit field which indicates the 0 based
 *		 drive numbers to check. Bit 0 = A, Bit 1 = B, ...
 *		 For use on this API at least one bit must be set (if
 *		 this argument is 0, the call will return WD_CHK_NOCHK).
 *
 *   RETURN
 *	The return is either one of the WD_CHK_* values.
 *
 */
DWORD WINAPI WinDisk_CheckDrive(HWND hwnd, WORD options, DWORD DrvList);


typedef DWORD (CALLBACK* WDCHKDRVPROC)(HWND,WORD,DWORD);

//
// Special return values. PLEASE NOTE that these are DWORD values.
//
#define WD_CHK_ERROR	0xFFFFFFFFL	// Fatal Error on check
#define WD_CHK_CANCEL	0xFFFFFFFEL	// Check was canceled
#define WD_CHK_NOCHK	0xFFFFFFFDL	// At least one Drive is not "checkable"
#define WD_CHK_SMNOTFIX 0xFFFFFFFCL	// Some errors were not fixed

//
// Option bits
//
// IMPORTANT NOTE: These are set up so that the default setting is 0
//		   for all bits WITH ONE EXCEPTION. Currently the default
//		   setting has the CHKOPT_XLCPY bit set......
//
// Also note that specification of invalid combonations of bits (for example
// setting both CHKOPT_XLCPY and CHKOPT_XLDEL) will result in very random
// behavior.
//
#define CHKOPT_REP	       0x0001	// Generate detail report
#define CHKOPT_RO	       0x0002	// Run in preview mode
#define CHKOPT_NOSYS	       0x0004	// Surf Anal don't check system area
#define CHKOPT_NODATA	       0x0008	// Surf Anal don't check data area
#define CHKOPT_NOBAD	       0x0010	// Disable Surface Analysis
#define CHKOPT_LSTMF	       0x0020	// Convert lost clusters to files
#define CHKOPT_NOCHKNM	       0x0040	// Don't check file names
#define CHKOPT_NOCHKDT	       0x0080	// DOn't check date/time fields
#define CHKOPT_INTER	       0x0100	// Interactive mode
#define CHKOPT_XLCPY	       0x0200	// Def cross link resolution is COPY
#define CHKOPT_XLDEL	       0x0400	// Def cross link resolution is DELETE
#define CHKOPT_ALLHIDSYS       0x0800	// All HID SYS files are unmovable
#define CHKOPT_NOWRTTST        0x1000	// Surf Anal no write testing.
#define CHKOPT_DRVLISTONLY     0x4000	// Normaly all drives in the system
					// are shown in the drive list box
					// and those on the DrvList are selected
					// This option says put only the drives
					// in DrvList in the list box and
					// disable the control
#define CHKOPT_AUTO	       0x8000	// Auto push start button

/*
 * The WinDisk_GetBigDriveBM API provides access to the drive bitmaps
 *   WINDISK uses in its main drive dialogs.
 *
 *   These bitmaps are intended for dialogs, and are intended
 *   to have a "chart" drawn on top of them. WINDISK draws
 *   the Used/Free chart. This chart is intended to look like
 *   the disk inside the drive.
 *
 *   These bitmaps are placed on a background of COLOR_DIALOG. There
 *   is no way to change this mapping color.
 *
 *   The returned HBITMAP belongs to the calling app, it is up to the
 *   caller to call DeleteObject on it to free it.
 *
 *   PARAMETERS
 *
 *     drive   = The 0 based (A: == 0) drive number of the drive to get
 *		 the drive bitmap of.
 *     lpChrt  -> an array of 9 words whose format and meaning
 *		  depends on the returned "chart style" type
 *     options = There are currently no options defined this param should
 *		 be zero. This field is reserved for future expansion.
 *
 *   RETURN
 *	The return is 0 if the bitmap could not be loaded (memory or
 *	invalid drive).
 *
 *	If the return is non-zero, the LOWORD is an HBITMAP,
 *	and the HIWORD is a "chart style" ID which defines the
 *	format of the data placed at lpChrt and the style for
 *	the chart placed on top of the bitmap by WINDISK.
 *
 *	 USETYPE_NONE	is for never-writable drives (like CD-ROM).
 *			lpChrt data is not used.
 *	 USETYPE_ELLIPS is for circular type drives (Fixed,Floppy).
 *	 USETYPE_BARH	is a horizontal parallelogram (RAMDrive).
 *	 USETYPE_BARV	is a verticle parallelogram.
 *
 * lpChrt[0] word is the "3-D effect" height/width for the parallelogram or
 *   ellips. NOTE that the 3-D effect is disabled if the height/width
 *   is 0. Also note that with 3-D effect disabled, the parallelogram
 *   can be turned into a rectangle.
 *
 * For USETYPE_ELLIPS, the next four words (lpChrt[1],lpChrt[2],lpChrt[3]
 *   and lpChrt[4]) form a RECT structure which defines the bounding
 *   rect for the ellips (including the 3-D effect). This RECT is in
 *   coordinates of the returned bitmap (0,0 corresponds to the top
 *   leftmost pixel of the bitmap).
 *
 * For USETYPE_BARH or USETYPE_BARV the 8 words starting at lpChrt[1]
 *   are four POINT structures which define a parallelogram for the
 *   chart (NOT including the 3-D effect).
 *
 *    POINT 0 is at lpChrt[1]
 *    POINT 1 is at lpChrt[3]
 *    POINT 2 is at lpChrt[5]
 *    POINT 3 is at lpChrt[7]
 *
 *    the "3-D->" in the following indicate the sides that the 3-D effect
 *    is drawn on. And the numbers are the point array
 *    indexes.
 *
 *	 USETYPE_BARH (0.y)==(1.y) and (3.y)==(2.y)
 *
 *	       0 _____________ 1
 *		 \ 	      \
 *	    3-D-> \ 	       \
 *		   \ 		\
 *		  3 ------------- 2
 *			  ^
 *			 3-D
 *
 *	 USETYPE_BARV (0.x)==(3.x) and (1.x)==(2.x)
 *
 *		     1
 *		  /|
 *		 / |
 *		/  |
 *	     0 |   |
 *	       |   |
 *	       |   | <- 3-D
 *	       |   |
 *	       |   |
 *	       |   |
 *	       |   |
 *	       |   | 2
 *	       |  /
 *	       | / <- 3-D
 *	       |/
 *
 *	       3
 *
 */
DWORD WINAPI WinDisk_GetBigDriveBM(WORD drive, LPWORD lpChrt, WORD options);

typedef DWORD (CALLBACK* WDGETBDBMPROC)(WORD,LPWORD,WORD);

//
// HIWORD return "chart type" values
//
#define USETYPE_ELLIPS	0
#define USETYPE_BARV	1
#define USETYPE_BARH	2
#define USETYPE_NONE	3

/*
 * The WinDisk_PropSheet API provides access to the main drive
 *   dialog.
 *
 *   This API is intended for the SHELL so it can bring up a
 *   drive property sheet.
 *
 *   PARAMETERS
 *
 *     drive   = The 0 based (A: == 0) drive number of the drive to bring
 *		 up the property dialog for.
 *     hwnd    = The HWND which will own the dialog
 *     options = There are currently no options defined this param should
 *		 be zero. This field is reserved for future expansion.
 *
 *   RETURN
 *	The return is -2 if the drive number is invalid.
 *	Else the return is the return from a DialogBox call to bring
 *	up the dialog. NOTE that -1 means that the DialogBox failed.
 *
 */
int WINAPI WinDisk_PropSheet(int drive, HWND hwndpar, WORD options);

typedef int (CALLBACK* WDPROPSHEET)(int,HWND,WORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\stubs\commdlg.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\commdlg.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/commdlg.h"
#endif /* UNIX */
#include <commdlgp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\stubs\shellapi.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\shellapi.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/shellapi.h"
#endif /* UNIX */
#include <shlapip.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\stubs\shlobj.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\shlobj.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/shlobj.h"
#endif /* UNIX */
#include <shlobjp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\stubs\prsht.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\prsht.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/prsht.h"
#endif /* UNIX */
#include <prshtp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\stubs\winbase.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\winbase.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/winbase.h"
#endif /* UNIX */
#include <winbasep.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\stubs\shlguid.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\shlguid.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/shlguid.h"
#endif /* UNIX */
#include <shlguidp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\stubs\shlwapi.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\shlwapi.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/shlwapi.h"
#endif /* UNIX */
#include <shlwapip.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\stubs\winspool.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\winspool.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/winspool.h"
#endif /* UNIX */
#include <winsprlp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\stubs\wingdi.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\wingdi.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/wingdi.h"
#endif /* UNIX */
#include <wingdip.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\stubs\winuser.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\winuser.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/winuser.h"
#endif /* UNIX */
#include <winuserp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\win95\frosting.h ===
/*****************************************************************************
 *
 * frosting.h -  COOL.DLL functions, types, and definitions
 *
 * Copyright (c) 1993-1994, Microsoft Corp.	All rights reserved
 *
 *****************************************************************************/

#ifndef _FROSTING_H
#define _FROSTING_H

#define ordCoolWEP		    1

DWORD WINAPI CoolEnable(DWORD param);
#define ordCoolEnable		    2

void WINAPI CoolGetDosBoxTtFonts(LPSTR pszFaceSbcs, LPSTR pszFaceDbcs);
#define ordCoolGetDosBoxTtFonts	    3

#endif /* _FROSTING_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\win95\bios.h ===
/*****************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp., 1994
 *
 *   Title:	BIOS.H - PnP BIOS Enumerator VxD
 *
 *   Version:	4.00
 *
 *   Date:	6-Feb-1994
 *
 *   Author:	MSq
 *
 *------------------------------------------------------------------------------
 *
 *   Change log:
 *
 *      DATE	REV		    DESCRIPTION
 *   ----------- --- -----------------------------------------------------------
 *    6-Feb-1994 MSq Original
 *****************************************************************************/

/*XLATOFF*/
#define	BIOS_Service	Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(BIOS, VxD)
BIOS_Service	(_BIOSGetVersion, VxD_CODE)
BIOS_Service	(_BIOSSoftUndock, VxD_CODE)
BIOS_Service	(_BIOSGetCapabilities, VxD_CODE)
BIOS_Service	(_BIOSGetAPMTable, VxD_CODE)
End_Service_Table(BIOS, VxD)
/*ENDMACROS*/

/*
 * One can add a VxD to fix a broken BIOS. This VxD must have
 * BIOS_EXT_DEVICE_ID as device ID and must export three services, in that
 * order:
 *
 * GetVersion: must return in eax 0x00000100 for this release and carry
 * clear (ie standard version code).
 *
 * GetHeader: must return in eax the linear address to an installation
 * structure, this need not be in BIOS space, but need to have the correct
 * values for building BIOS selectors. The structure will be used instead of
 * the one found by the scan. Also, the BIOS EXT VxD must use this time to
 * initialize. If initialization failed, the value 0 must be return.
 *
 * CallBIOS: will be called instead of calling the BIOS entry point. The
 * stack will be the exact same as if we were calling the BIOS except that
 * the return address is a 32-bit ret to BIOS.VxD. Also CS=DS=ES=SS=Flat
 * segment. Thus the BIOS_EXT VxD can pop the return address in a local
 * variable (this API will never be reentered) and do stack munging before
 * calling its internal function or call BIOS even. All registers except
 * eax, which is the return value, must be preserved. The high word of eax
 * is discarded by BIOS.VxD.
 */

/*XLATOFF*/
#define	BIOS_EXT_Service	Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(BIOS_EXT, VxD)
BIOS_EXT_Service	(_BIOSEXTGetVersion, VxD_CODE)
BIOS_EXT_Service	(_BIOSEXTGetHeader, VxD_CODE)
BIOS_EXT_Service	(_BIOSEXTCallBIOS, VxD_CODE)
End_Service_Table(BIOS_EXT, VxD)
/*ENDMACROS*/

#define	PNPBIOS_SERVICE_GETVERSION		0x000
#define	PNPBIOS_SERVICE_SOFTUNDOCK		0x100
#define	PNPBIOS_SERVICE_GETDOCKCAPABILITIES	0x200
#define	PNPBIOS_SERVICE_GETAPMTABLE		0x300

struct BIOSPARAMSTAG {
	DWORD bp_ret;
	WORD *bp_pTableSize;
	char *bp_pTable;
};

typedef struct BIOSPARAMSTAG BIOSPARAMS;
typedef struct BIOSPARAMSTAG *PBIOSPARAMS;

#define	PNPBIOS_ERR_NONE			0x00
#define	PNPBIOS_ERR_SUCCESS			PNPBIOS_ERR_NONE
#define	PNPBIOS_WARN_NOT_SET_STATICALLY		0x7F
#define	PNPBIOS_ERR_UNKNOWN_FUNCTION		0x81
#define	PNPBIOS_ERR_FUNCTION_NOT_SUPPORTED	0x82
#define	PNPBIOS_ERR_INVALID_HANDLE		0x83
#define	PNPBIOS_ERR_BAD_PARAMETER		0x84
#define	PNPBIOS_ERR_SET_FAILED			0x85
#define	PNPBIOS_ERR_EVENTS_NOT_PENDING		0x86
#define	PNPBIOS_ERR_SYSTEM_NOT_DOCKED		0x87
#define	PNPBIOS_ERR_NO_ISA_PNP_CARDS		0x88
#define	PNPBIOS_ERR_CANT_DETERMINE_DOCKING	0x89
#define	PNPBIOS_ERR_CHANGE_FAILED_NO_BATTERY	0x8A
#define	PNPBIOS_ERR_CHANGE_FAILED_CONFLICT	0x8B
#define	PNPBIOS_ERR_BUFFER_TOO_SMALL		0x8C
#define	PNPBIOS_ERR_USE_ESCD_SUPPORT		0x8D
#define	PNPBIOS_ERR_MS_INTERNAL			0xFE

#define PNPBIOS_DOCK_CAPABILITY_VCR		0x0001
#define PNPBIOS_DOCK_CAPABILITY_TEMPERATURE	0x0006
#define PNPBIOS_DOCK_CAPABILITY_COLD		0x0000
#define PNPBIOS_DOCK_CAPABILITY_WARM		0x0002
#define PNPBIOS_DOCK_CAPABILITY_HOT		0x0004
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\win95\configmg.h ===
/*****************************************************************************
 *
 *	(C) Copyright MICROSOFT Corp., 1993-1998
 *
 *	Title:		CONFIGMG.H - Configuration manager header file
 *
 *	Version:	1.00
 *
 *	Date:		02-Feb-1993
 *
 *	Authors:	PYS & RAL
 *
 *------------------------------------------------------------------------------
 *
 *	Change log:
 *
 *	   DATE     REV DESCRIPTION
 *	----------- --- -----------------------------------------------------------
 *	02-Feb-1993 PYS Original
 *****************************************************************************/

#ifndef _CONFIGMG_H
#define	_CONFIGMG_H

#define	CONFIGMG_VERSION	0x0400

#define	PNPDRVS_Major_Ver	0x0004
#define	PNPDRVS_Minor_Ver	0x0000

#ifdef	MAXDEBUG
#define	CM_PERFORMANCE_INFO
#endif

#ifdef	GOLDEN	
#ifdef	RETAIL
#define	CM_GOLDEN_RETAIL
#endif
#endif

/*XLATOFF*/
#pragma	pack(1)
/*XLATON*/

#ifndef	NORESDES

/****************************************************************************
 *
 *			EQUATES FOR RESOURCE DESCRIPTOR
 *
 *	The equates for resource descriptor work the exact same way as those
 *	for VxD IDs, which is:
 *
 *	Device ID's are a combination of OEM # and device # in the form:
 *
 *		xOOOOOOOOOODDDDD
 *
 *	The high bit of the device ID is reserved for future use.  The next
 *	10 bits are the OEM # which is assigned by Microsoft.  The last 5 bits
 *	are the device #.  This allows each OEM to create 32 unique devices.
 *	If an OEM is creating a replacement for a standard device, then it
 *	should re-use the standard ID listed below.  Microsoft reserves the
 *	first 16 OEM #'s (0 thru 0Fh)
 *
 *	To make your resource ID, you must use the same 10 OEMs bit that
 *	have been given by Microsoft as OEM VxD ID range. You can then tag
 *	any of the 32 unique number in that range (it does not have to be
 *	the same as the VxD as some VxD may have mupltiple arbitrators).
 *
 *	If the ResType_Ignored_Bit is set, the resource is not arbitrated.
 *	You cannot register a handler for such a resource.
 *
 ***************************************************************************/
#define	ResType_All		0x00000000	// Return all resource types.
#define	ResType_None		0x00000000	// Arbitration always succeeded.
#define	ResType_Mem		0x00000001	// Physical address resource.
#define	ResType_IO		0x00000002	// Physical IO address resource.
#define	ResType_DMA		0x00000003	// DMA channels 0-7 resource.
#define	ResType_IRQ		0x00000004	// IRQ 0-15 resource.
#define	ResType_Max		0x00000004	// Max KNOWN ResType (for DEBUG).
#define	ResType_Ignored_Bit	0x00008000	// This resource is to be ignored.

#define	DEBUG_RESTYPE_NAMES \
char	CMFAR *lpszResourceName[ResType_Max+1]= \
{ \
	"All/None", \
	"Mem     ", \
	"IO      ", \
	"DMA     ", \
	"IRQ     ", \
};

/************************************************************************
 *									*
 *	OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,  		*
 *	PLEASE CONTACT MICROSOFT PRODUCT SUPPORT 			*
 *									*
 ************************************************************************/

/****************************************************************************
 *
 * RESOURCE DESCRIPTORS
 *
 *	Each resource descriptor consists of an array of resource requests.
 *	Exactly one element of the array must be satisfied. The data
 *	of each array element is resource specific an described below.
 *	The data may specify one or more resource requests. At least
 *	one element of a Res_Des must be satisfied to satisfy the request
 *	represented by the Res_Des. The values allocated to the Res_Des
 *	are stored within the Res_Des.
 *	Each subarray (OR element) is a single Res_Des followed
 *	by data specific to the type of resource. The data includes the
 *	allocated resource (if any) followed by resource requests (which
 *	will include the values indicated by the allocated resource.
 *
 ***************************************************************************/

/****************************************************************************
 * Memory resource requests consist of ranges of pages
 ***************************************************************************/
#define	MType_Range		sizeof(struct Mem_Range_s)

#define	fMD_MemoryType		1		// Memory range is ROM/RAM
#define	fMD_ROM			0		// Memory range is ROM
#define	fMD_RAM			1		// Memory range is RAM
#define	fMD_32_24		2		// Memory range is 32/24 (for ISAPNP only)
#define	fMD_24			0		// Memory range is 24
#define	fMD_32			2		// Memory range is 32

/* Memory Range descriptor data
 */
struct	Mem_Range_s {
	ULONG			MR_Align;	// Mask for base alignment
	ULONG			MR_nBytes;	// Count of bytes
	ULONG			MR_Min;		// Min Address
	ULONG			MR_Max;		// Max Address
	WORD			MR_Flags;	// Flags
	WORD			MR_Reserved;
};

typedef	struct Mem_Range_s	MEM_RANGE;

/* Mem Resource descriptor header structure
 *	MD_Count * MD_Type bytes of data follow header in an
 *	array of MEM_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the MD_Alloc_... variables.
 *
 *	Example for memory Resource Description:
 *		Mem_Des_s {
 *			MD_Count = 1;
 *			MD_Type = MTypeRange;
 *			MD_Alloc_Base = 0;
 *			MD_Alloc_End = 0;
 *			MD_Flags = 0;
 *			MD_Reserved = 0;
 *			};
 *		Mem_Range_s {
 *			MR_Align = 0xFFFFFF00;	// 256 byte alignment
 *			MR_nBytes = 32;		// 32 bytes needed
 *			MR_Min = 0;
 *			MR_Max = 0xFFFFFFFF;	// Any place in address space
 *			MR_Flags = 0;
 *			MR_Reserved = 0;
 *			};
 */
struct	Mem_Des_s {
	WORD			MD_Count;
	WORD			MD_Type;
	ULONG			MD_Alloc_Base;
	ULONG			MD_Alloc_End;
	WORD			MD_Flags;
	WORD			MD_Reserved;
};

typedef	struct Mem_Des_s 	MEM_DES;

/****************************************************************************
 * IO resource allocations consist of fixed ranges or variable ranges
 *	The Alias and Decode masks provide additional flexibility
 *	in specifying how the address is handled. They provide a convenient
 *	method for specifying what port aliases a card responds to. An alias
 *	is a port address that is responded to as if it were another address.
 *	Additionally, some cards will actually use additional ports for
 *	different purposes, but use a decoding scheme that makes it look as
 *	though it were using aliases. E.G., an ISA card may decode 10 bits
 *	and require port 03C0h. It would need to specify an Alias offset of
 *	04h and a Decode of 3 (no aliases are used as actual ports). For
 *	convenience, the alias field can be set to zero indicate no aliases
 *	are required and then decode is ignored.
 *	If the card were to use the ports at 7C0h, 0BC0h and 0FC0h, where these
 *	ports have different functionality, the Alias would be the same and the
 *	the decode would be 0Fh indicating bits 11 and 12 of the port address
 *	are significant. Thus, the allocation is for all of the ports
 *	(PORT[i] + (n*Alias*256)) & (Decode*256 | 03FFh), where n is
 *	any integer and PORT is the range specified by the nPorts, Min and
 *	Max fields. Note that the minimum Alias is 4 and the minimum
 *	Decode is 3.
 *	Because of the history of the ISA bus, all ports that can be described
 *	by the formula PORT = n*400h + zzzz, where "zzzz" is a port in the
 *	range 100h - 3FFh, will be checked for compatibility with the port
 *	zzzz, assuming that the port zzzz is using a 10 bit decode. If a card
 *	is on a local bus that can prevent the IO address from appearing on
 *	the ISA bus (e.g. PCI), then the logical configuration should specify
 *	an alias of IOA_Local which will prevent the arbitrator from checking
 *	for old ISA bus compatibility.
 */
#define	IOType_Range		sizeof(struct IO_Range_s) // Variable range

/* IO Range descriptor data */
struct	IO_Range_s {
	WORD			IOR_Align;	// Mask for base alignment
	WORD			IOR_nPorts;	// Number of ports
	WORD			IOR_Min;	// Min port address
	WORD			IOR_Max;	// Max port address
	WORD			IOR_RangeFlags;	// Flags
	BYTE			IOR_Alias;	// Alias offset
	BYTE			IOR_Decode;	// Address specified
};

typedef	struct IO_Range_s	IO_RANGE;

/* IO Resource descriptor header structure
 *	IOD_Count * IOD_Type bytes of data follow header in an
 *	array of IO_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the IOD_Alloc_... variables.
 *
 *	Example for IO Resource Description:
 *		IO_Des_s {
 *			IOD_Count = 1;
 *			IOD_Type = IOType_Range;
 *			IOD_Alloc_Base = 0;
 *			IOD_Alloc_End = 0;
 *			IOD_Alloc_Alias = 0;
 *			IOD_Alloc_Decode = 0;
 *			IOD_DesFlags = 0;
 *			IOD_Reserved = 0;
 *			};
 *		IO_Range_s {
 *			IOR_Align = 0xFFF0;	// 16 byte alignment
 *			IOR_nPorts = 16;	// 16 ports required
 *			IOR_Min = 0x0100;
 *			IOR_Max = 0x03FF;	// Anywhere in ISA std ports
 *			IOR_RangeFlags = 0;
 *			IOR_Alias = 0004;	// Standard ISA 10 bit aliasing
 *			IOR_Decode = 0x000F;	// Use first 3 aliases (e.g. if
 *						// 0x100 were base port, 0x500
 *						// 0x900, and 0xD00 would
 *						// also be allocated)
 *			};
 */
struct	IO_Des_s {
	WORD			IOD_Count;
	WORD			IOD_Type;
	WORD			IOD_Alloc_Base;
	WORD			IOD_Alloc_End;
	WORD			IOD_DesFlags;
	BYTE			IOD_Alloc_Alias;
	BYTE			IOD_Alloc_Decode;
};

typedef	struct IO_Des_s 	IO_DES;

/* Definition for special alias value indicating card on PCI or similar local bus
 *  This value should used for the IOR_Alias and IOD_Alias fields
 */
#define	IOA_Local		0xff

/****************************************************************************
 * DMA channel resource allocations consist of one WORD channel bit masks.
 *	The mask indcates alternative channel allocations,
 *	one bit for each alternative (only one is allocated per mask).
 */

/*DMA flags
 *First two are DMA channel width: BYTE, WORD or DWORD
 */
#define	mDD_Width		0003h		// Mask for channel width
#define	fDD_BYTE		0
#define	fDD_WORD		1
#define	fDD_DWORD		2
#define	szDMA_Des_Flags		"WD"

/* DMA Resource descriptor structure
 *
 *	Example for DMA Resource Description:
 *
 *		DMA_Des_s {
 *			DD_Flags = fDD_Byte;	// Byte transfer
 *			DD_Alloc_Chan = 0;
 *			DD_Req_Mask = 0x60;	// Channel 5 or 6
 *			DD_Reserved = 0;
 *			};
 */
struct	DMA_Des_s {
	BYTE			DD_Flags;
	BYTE			DD_Alloc_Chan;	// Channel number allocated
	BYTE			DD_Req_Mask;	// Mask of possible channels
	BYTE			DD_Reserved;
};


typedef	struct DMA_Des_s 	DMA_DES;

/****************************************************************************
 * IRQ resource allocations consist of two WORD IRQ bit masks.
 *	The first mask indcates alternatives for IRQ allocation,
 *	one bit for each alternative (only one is allocated per mask). The
 *	second mask is used to specify that the IRQ can be shared.
 */

/*
 * IRQ flags
 */
#define	fIRQD_Share		1			// IRQ can be shared
#define	cIRQ_Des_Flags		'S'

/* IRQ Resource descriptor structure
 *
 *	Example for IRQ Resource Description:
 *
 *		IRQ_Des_s {
 *			IRQD_Flags = fIRQD_Share	// IRQ can be shared
 *			IRQD_Alloc_Num = 0;
 *			IRQD_Req_Mask = 0x18;		// IRQ 3 or 4
 *			IRQD_Reserved = 0;
 *			};
 */
struct	IRQ_Des_s {
	WORD			IRQD_Flags;
	WORD			IRQD_Alloc_Num;		// Allocated IRQ number
	WORD			IRQD_Req_Mask;		// Mask of possible IRQs
	WORD			IRQD_Reserved;
};

typedef	struct IRQ_Des_s 	IRQ_DES;

/*XLATOFF*/

/****************************************************************************
 *
 * 'C'-only defined total resource structure. Since a resource consists of
 * one resource header followed by an undefined number of resource data
 * structure, we use the undefined array size [] on the *_DATA structure
 * member. Unfortunately, this does not H2INC since the total size of the
 * array cannot be computed from the definition.
 *
 ***************************************************************************/

#pragma warning (disable:4200)			// turn off undefined array size

typedef	MEM_DES			*PMEM_DES;
typedef	MEM_RANGE		*PMEM_RANGE;
typedef	IO_DES			*PIO_DES;
typedef	IO_RANGE		*PIO_RANGE;
typedef	DMA_DES			*PDMA_DES;
typedef	IRQ_DES			*PIRQ_DES;

struct	MEM_Resource_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data[];
};

typedef	struct MEM_Resource_s	MEM_RESOURCE;
typedef	MEM_RESOURCE		*PMEM_RESOURCE;

struct	MEM_Resource1_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data;
};

typedef	struct MEM_Resource1_s	MEM_RESOURCE1;
typedef	MEM_RESOURCE1		*PMEM_RESOURCE1;

#define	SIZEOF_MEM(x)		(sizeof(MEM_DES)+(x)*sizeof(MEM_RANGE))

struct	IO_Resource_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data[];
};

typedef	struct IO_Resource_s	IO_RESOURCE;
typedef	IO_RESOURCE		*PIO_RESOURCE;

struct	IO_Resource1_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data;
};

typedef	struct IO_Resource1_s	IO_RESOURCE1;
typedef	IO_RESOURCE1		*PIO_RESOURCE1;

#define	SIZEOF_IORANGE(x)	(sizeof(IO_DES)+(x)*sizeof(IO_RANGE))

struct	DMA_Resource_s {
	DMA_DES			DMA_Header;
};

typedef	struct DMA_Resource_s	DMA_RESOURCE;

#define	SIZEOF_DMA		sizeof(DMA_DES)

struct	IRQ_Resource_s {
	IRQ_DES			IRQ_Header;
};

typedef	struct IRQ_Resource_s	IRQ_RESOURCE;

#define	SIZEOF_IRQ		sizeof(IRQ_DES)

#pragma warning (default:4200)			// turn on undefined array size

/*XLATON*/

#endif	// ifndef NORESDES

#define	LCPRI_FORCECONFIG	0x00000000	// Logical configuration priorities.
#define	LCPRI_BOOTCONFIG	0x00000001
#define	LCPRI_HARDWIRED		0x00001000
#define	LCPRI_DESIRED		0x00002000
#define	LCPRI_NORMAL		0x00003000
#define	LCPRI_LASTBESTCONFIG	0x00003FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_SUBOPTIMAL	0x00005000
#define	LCPRI_LASTSOFTCONFIG	0x00007FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_RESTART		0x00008000
#define	LCPRI_REBOOT		0x00009000
#define	LCPRI_POWEROFF		0x0000A000
#define	LCPRI_HARDRECONFIG	0x0000C000
#define	LCPRI_DISABLED		0x0000FFFF
#define	MAX_LCPRI		0x0000FFFF

#define	MAX_MEM_REGISTERS		9
#define	MAX_IO_PORTS			20
#define	MAX_IRQS			7
#define	MAX_DMA_CHANNELS		7

struct Config_Buff_s {
WORD	wNumMemWindows;			// Num memory windows
DWORD	dMemBase[MAX_MEM_REGISTERS];	// Memory window base
DWORD	dMemLength[MAX_MEM_REGISTERS];	// Memory window length
WORD	wMemAttrib[MAX_MEM_REGISTERS];	// Memory window Attrib
WORD	wNumIOPorts;			// Num IO ports
WORD	wIOPortBase[MAX_IO_PORTS];	// I/O port base
WORD	wIOPortLength[MAX_IO_PORTS];	// I/O port length
WORD	wNumIRQs;			// Num IRQ info
BYTE	bIRQRegisters[MAX_IRQS];	// IRQ list
BYTE	bIRQAttrib[MAX_IRQS];		// IRQ Attrib list
WORD	wNumDMAs;			// Num DMA channels
BYTE	bDMALst[MAX_DMA_CHANNELS];	// DMA list
WORD	wDMAAttrib[MAX_DMA_CHANNELS];	// DMA Attrib list
BYTE	bReserved1[3];			// Reserved
};

typedef	struct Config_Buff_s	CMCONFIG;	// Config buffer info

#ifndef	CMJUSTRESDES

#define	MAX_DEVICE_ID_LEN	200

#include <vmmreg.h>

/*XLATOFF*/

#ifdef	Not_VxD

#include <dbt.h>

#pragma warning(disable:4001)	// Non-standard extensions
#pragma warning(disable:4505)	// Unreferenced local functions

#ifdef	IS_32

#define	CMFAR

#else

#define	CMFAR	_far

#endif

#else	// Not_VxD

#define	CMFAR

#endif	// Not_VxD

#ifdef	IS_32

typedef	DWORD			RETURN_TYPE;

#else	// IS_32

typedef	WORD			RETURN_TYPE;

#endif	// IS_32

#define	CONFIGMG_Service	Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(CONFIGMG, VxD)
CONFIGMG_Service	(_CONFIGMG_Get_Version, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Initialize, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Locate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Parent, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Child, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Sibling, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Depth, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Deregister_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Sort_NodeList, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Yield, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Lock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Unlock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Empty_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_First_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Modify_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Performance_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Process_Events_Now, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Delete_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Test_Range_Available, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dup_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Invert_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Intersect_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_First_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Next_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dump_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Load_DLVxDs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DDBs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_CRC_CheckSum, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_DevLoader, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reenumerate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Setup_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reset_Children_Marks, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Status, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_Unmarked_Children, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_ISAPNP_To_CM, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Alloc_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Write_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Disable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Enable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Move_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Recompute_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Log_Confs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Run_Detection, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_At_Appy_Time, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Fail_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_Problem, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Debug_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Hardware_Profile_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_ID, VxD_CODE)
End_Service_Table(CONFIGMG, VxD)

/*ENDMACROS*/

/*XLATOFF*/

#define	NUM_CM_SERVICES		((WORD)(Num_CONFIGMG_Services & 0xFFFF))

#define	DEBUG_SERVICE_NAMES \
char	CMFAR *lpszServiceName[NUM_CM_SERVICES]= \
{ \
	"Get_Version", \
	"Initialize", \
	"Locate_DevNode", \
	"Get_Parent", \
	"Get_Child", \
	"Get_Sibling", \
	"Get_Device_ID_Size", \
	"Get_Device_ID", \
	"Get_Depth", \
	"Get_Private_DWord", \
	"Set_Private_DWord", \
	"Create_DevNode", \
	"Query_Remove_SubTree", \
	"Remove_SubTree", \
	"Register_Device_Driver", \
	"Register_Enumerator", \
	"Register_Arbitrator", \
	"Deregister_Arbitrator", \
	"Query_Arbitrator_Free_Size", \
	"Query_Arbitrator_Free_Data", \
	"Sort_NodeList", \
	"Yield", \
	"Lock", \
	"Unlock", \
	"Add_Empty_Log_Conf", \
	"Free_Log_Conf", \
	"Get_First_Log_Conf", \
	"Get_Next_Log_Conf", \
	"Add_Res_Des", \
	"Modify_Res_Des", \
	"Free_Res_Des", \
	"Get_Next_Res_Des", \
	"Get_Performance_Info", \
	"Get_Res_Des_Data_Size", \
	"Get_Res_Des_Data", \
	"Process_Events_Now", \
	"Create_Range_List", \
	"Add_Range", \
	"Delete_Range", \
	"Test_Range_Available", \
	"Dup_Range_List", \
	"Free_Range_List", \
	"Invert_Range_List", \
	"Intersect_Range_List", \
	"First_Range", \
	"Next_Range", \
	"Dump_Range_List", \
	"Load_DLVxDs", \
	"Get_DDBs", \
	"Get_CRC_CheckSum", \
	"Register_DevLoader", \
	"Reenumerate_DevNode", \
	"Setup_DevNode", \
	"Reset_Children_Marks", \
	"Get_DevNode_Status", \
	"Remove_Unmarked_Children", \
	"ISAPNP_To_CM", \
	"CallBack_Device_Driver", \
	"CallBack_Enumerator", \
	"Get_Alloc_Log_Conf", \
	"Get_DevNode_Key_Size", \
	"Get_DevNode_Key", \
	"Read_Registry_Value", \
	"Write_Registry_Value", \
	"Disable_DevNode", \
	"Enable_DevNode", \
	"Move_DevNode", \
	"Set_Bus_Info", \
	"Get_Bus_Info", \
	"Set_HW_Prof", \
	"Recompute_HW_Prof", \
	"Query_Change_HW_Prof", \
	"Get_Device_Driver_Private_DWord", \
	"Set_Device_Driver_Private_DWord", \
	"Get_HW_Prof_Flags", \
	"Set_HW_Prof_Flags", \
	"Read_Registry_Log_Confs", \
	"Run_Detection", \
	"Call_At_Appy_Time", \
	"Fail_Change_HW_Prof", \
	"Set_Private_Problem", \
	"Debug_DevNode", \
	"Get_Hardware_Profile_Info", \
	"Register_Enumerator_Function", \
	"Call_Enumerator_Function", \
	"Add_ID", \
};

/*XLATON*/

/****************************************************************************
 *
 *				GLOBALLY DEFINED TYPEDEFS
 *
 ***************************************************************************/
typedef	RETURN_TYPE		CONFIGRET;	// Standardized return value.
typedef	PPVMMDDB		*PPPVMMDDB;	// Too long to describe.
typedef	VOID		CMFAR	*PFARVOID;	// Pointer to a VOID.
typedef	ULONG		CMFAR	*PFARULONG;	// Pointer to a ULONG.
typedef	char		CMFAR	*PFARCHAR;	// Pointer to a string.
typedef	VMMHKEY		CMFAR	*PFARHKEY;	// Pointer to a HKEY.
typedef	char		CMFAR	*DEVNODEID;	// Device ID ANSI name.
typedef	DWORD			LOG_CONF;	// Logical configuration.
typedef	LOG_CONF	CMFAR	*PLOG_CONF;	// Pointer to logical configuration.
typedef	DWORD			RES_DES;	// Resource descriptor.
typedef	RES_DES		CMFAR	*PRES_DES;	// Pointer to resource descriptor.
typedef	DWORD			DEVNODE;	// Devnode.
typedef	DEVNODE		CMFAR	*PDEVNODE;	// Pointer to devnode.
typedef	DWORD			NODELIST;	// Pointer to a nodelist element.
typedef	DWORD			NODELIST_HEADER;// Pointer to a nodelist header.
typedef	DWORD			REGISTERID;	// Arbitartor registration.
typedef	REGISTERID	CMFAR	*PREGISTERID;	// Pointer to arbitartor registration.
typedef	ULONG			RESOURCEID;	// Resource type ID.
typedef	RESOURCEID	CMFAR	*PRESOURCEID;	// Pointer to resource type ID.
typedef	ULONG			PRIORITY;	// Priority number.
typedef	DWORD			RANGE_LIST;	// Range list handle.
typedef	RANGE_LIST	CMFAR	*PRANGE_LIST;	// Pointer to a range list handle.
typedef	DWORD			RANGE_ELEMENT;	// Range list element handle.
typedef	RANGE_ELEMENT	CMFAR	*PRANGE_ELEMENT;// Pointer to a range element handle.
typedef	DWORD			LOAD_TYPE;	// For the loading function.
typedef	CMCONFIG	CMFAR	*PCMCONFIG;	// Pointer to a config buffer info.
typedef	DWORD			CMBUSTYPE;	// Type of the bus.
typedef	CMBUSTYPE	CMFAR	*PCMBUSTYPE;	// Pointer to a bus type.
typedef	double			VMM_TIME;	// Time in microticks.
#define	LODWORD(x)		((DWORD)(x))
#define	HIDWORD(x)		(*(PDWORD)(PDWORD(&x)+1))

typedef	ULONG			CONFIGFUNC;
typedef	ULONG			SUBCONFIGFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMCONFIGHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, ULONG, ULONG);
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, DEVNODE, ULONG);
typedef	VOID			(CMFAR _cdecl *CMAPPYCALLBACKHANDLER)(ULONG);

typedef	ULONG			ENUMFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMFUNCTION)(ENUMFUNC, ULONG, DEVNODE, PFARVOID, ULONG);

typedef	ULONG			ARBFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMARBHANDLER)(ARBFUNC, ULONG, DEVNODE, NODELIST_HEADER);

/****************************************************************************
 *
 *				CONFIGURATION MANAGER BUS TYPE
 *
 ***************************************************************************/
#define	BusType_None		0x00000000
#define	BusType_ISA		0x00000001
#define	BusType_EISA		0x00000002
#define	BusType_PCI		0x00000004
#define	BusType_PCMCIA		0x00000008
#define	BusType_ISAPNP		0x00000010
#define	BusType_MCA		0x00000020

/****************************************************************************
 *
 *				CONFIGURATION MANAGER RETURN VALUES
 *
 ***************************************************************************/
#define	CR_SUCCESS		0x00000000
#define	CR_DEFAULT		0x00000001
#define	CR_OUT_OF_MEMORY	0x00000002
#define	CR_INVALID_POINTER	0x00000003
#define	CR_INVALID_FLAG		0x00000004
#define	CR_INVALID_DEVNODE	0x00000005
#define	CR_INVALID_RES_DES	0x00000006
#define	CR_INVALID_LOG_CONF	0x00000007
#define	CR_INVALID_ARBITRATOR	0x00000008
#define	CR_INVALID_NODELIST	0x00000009
#define	CR_DEVNODE_HAS_REQS	0x0000000A
#define	CR_INVALID_RESOURCEID	0x0000000B
#define	CR_DLVXD_NOT_FOUND	0x0000000C
#define	CR_NO_SUCH_DEVNODE	0x0000000D
#define	CR_NO_MORE_LOG_CONF	0x0000000E
#define	CR_NO_MORE_RES_DES	0x0000000F
#define	CR_ALREADY_SUCH_DEVNODE	0x00000010
#define	CR_INVALID_RANGE_LIST	0x00000011
#define	CR_INVALID_RANGE	0x00000012
#define	CR_FAILURE		0x00000013
#define	CR_NO_SUCH_LOGICAL_DEV	0x00000014
#define	CR_CREATE_BLOCKED	0x00000015
#define	CR_NOT_SYSTEM_VM	0x00000016
#define	CR_REMOVE_VETOED	0x00000017
#define	CR_APM_VETOED		0x00000018
#define	CR_INVALID_LOAD_TYPE	0x00000019
#define	CR_BUFFER_SMALL		0x0000001A
#define	CR_NO_ARBITRATOR	0x0000001B
#define	CR_NO_REGISTRY_HANDLE	0x0000001C
#define	CR_REGISTRY_ERROR	0x0000001D
#define	CR_INVALID_DEVICE_ID	0x0000001E
#define	CR_INVALID_DATA		0x0000001F
#define	CR_INVALID_API		0x00000020
#define	CR_DEVLOADER_NOT_READY	0x00000021
#define	CR_NEED_RESTART		0x00000022
#define	CR_INTERRUPTS_DISABLED	0x00000023
#define	CR_DEVICE_NOT_THERE	0x00000024
#define	CR_NO_SUCH_VALUE	0x00000025
#define	CR_WRONG_TYPE		0x00000026
#define	CR_INVALID_PRIORITY	0x00000027
#define	CR_NOT_DISABLEABLE	0x00000028
#define	CR_NO_MORE_HW_PROFILES	0x00000029
#define	NUM_CR_RESULTS		0x0000002A

/*XLATOFF*/

#define	DEBUG_RETURN_CR_NAMES \
char	CMFAR *lpszReturnCRName[NUM_CR_RESULTS]= \
{ \
	"CR_SUCCESS", \
	"CR_DEFAULT", \
	"CR_OUT_OF_MEMORY", \
	"CR_INVALID_POINTER", \
	"CR_INVALID_FLAG", \
	"CR_INVALID_DEVNODE", \
	"CR_INVALID_RES_DES", \
	"CR_INVALID_LOG_CONF", \
	"CR_INVALID_ARBITRATOR", \
	"CR_INVALID_NODELIST", \
	"CR_DEVNODE_HAS_REQS", \
	"CR_INVALID_RESOURCEID", \
	"CR_DLVXD_NOT_FOUND", \
	"CR_NO_SUCH_DEVNODE", \
	"CR_NO_MORE_LOG_CONF", \
	"CR_NO_MORE_RES_DES", \
	"CR_ALREADY_SUCH_DEVNODE", \
	"CR_INVALID_RANGE_LIST", \
	"CR_INVALID_RANGE", \
	"CR_FAILURE", \
	"CR_NO_SUCH_LOGICAL_DEVICE", \
	"CR_CREATE_BLOCKED", \
	"CR_NOT_SYSTEM_VM", \
	"CR_REMOVE_VETOED", \
	"CR_APM_VETOED", \
	"CR_INVALID_LOAD_TYPE", \
	"CR_BUFFER_SMALL", \
	"CR_NO_ARBITRATOR", \
	"CR_NO_REGISTRY_HANDLE", \
	"CR_REGISTRY_ERROR", \
	"CR_INVALID_DEVICE_ID", \
	"CR_INVALID_DATA", \
	"CR_INVALID_API", \
	"CR_DEVLOADER_NOT_READY", \
	"CR_NEED_RESTART", \
	"CR_INTERRUPTS_DISABLED", \
	"CR_DEVICE_NOT_THERE", \
	"CR_NO_SUCH_VALUE", \
	"CR_WRONG_TYPE", \
	"CR_INVALID_PRIORITY", \
	"CR_NOT_DISABLEABLE", \
	"CR_NO_MORE_HW_PROFILES", \
};

/*XLATON*/

#define	CM_PROB_NOT_CONFIGURED			0x00000001
#define	CM_PROB_DEVLOADER_FAILED		0x00000002
#define	CM_PROB_OUT_OF_MEMORY			0x00000003
#define	CM_PROB_ENTRY_IS_WRONG_TYPE		0x00000004
#define	CM_PROB_LACKED_ARBITRATOR		0x00000005
#define	CM_PROB_BOOT_CONFIG_CONFLICT		0x00000006
#define	CM_PROB_FAILED_FILTER			0x00000007
#define	CM_PROB_DEVLOADER_NOT_FOUND		0x00000008
#define	CM_PROB_INVALID_DATA			0x00000009
#define	CM_PROB_FAILED_START			0x0000000A
#define	CM_PROB_LIAR				0x0000000B
#define	CM_PROB_NORMAL_CONFLICT			0x0000000C
#define	CM_PROB_NOT_VERIFIED			0x0000000D
#define	CM_PROB_NEED_RESTART			0x0000000E
#define	CM_PROB_REENUMERATION			0x0000000F
#define	CM_PROB_PARTIAL_LOG_CONF		0x00000010
#define	CM_PROB_UNKNOWN_RESOURCE		0x00000011
#define	CM_PROB_REINSTALL			0x00000012
#define	CM_PROB_REGISTRY			0x00000013
#define	CM_PROB_VXDLDR				0x00000014
#define	CM_PROB_WILL_BE_REMOVED			0x00000015
#define	CM_PROB_DISABLED			0x00000016
#define	CM_PROB_DEVLOADER_NOT_READY		0x00000017
#define	CM_PROB_DEVICE_NOT_THERE		0x00000018
#define	CM_PROB_MOVED				0x00000019
#define	CM_PROB_TOO_EARLY			0x0000001A
#define	CM_PROB_NO_VALID_LOG_CONF		0x0000001B
#define	NUM_CM_PROB				0x0000001C

/*XLATOFF*/

#define	DEBUG_CM_PROB_NAMES \
char	CMFAR *lpszCMProbName[NUM_CM_PROB]= \
{ \
	"No Problem", \
	"No ConfigFlags (not configured)", \
	"Devloader failed", \
	"Run out of memory", \
	"Devloader/StaticVxD/Configured is of wrong type", \
	"Lacked an arbitrator", \
	"Boot config conflicted", \
	"Filtering failed", \
	"Devloader not found", \
	"Invalid data in registry", \
	"Device failed to start", \
	"Device failed something not failable", \
	"Was normal conflicting", \
	"Did not verified", \
	"Need restart", \
	"Is probably reenumeration", \
	"Was not fully detected", \
	"Resource number was not found", \
	"Reinstall", \
	"Registry returned unknown result", \
	"VxDLdr returned unknown result", \
	"Will be removed", \
	"Disabled", \
	"Devloader was not ready", \
	"Device not there", \
	"Was moved", \
	"Too early", \
	"No valid log conf", \
};

/*XLATON*/

#define	CM_INITIALIZE_VMM			0x00000000
#define	CM_INITIALIZE_VXDLDR			0x00000001
#define	CM_INITIALIZE_BITS			0x00000001

#define	CM_YIELD_NO_RESUME_EXEC			0x00000000
#define	CM_YIELD_RESUME_EXEC			0x00000001
#define	CM_YIELD_BITS				0x00000001

#define	CM_CREATE_DEVNODE_NORMAL		0x00000000
#define	CM_CREATE_DEVNODE_NO_WAIT_INSTALL	0x00000001
#define	CM_CREATE_DEVNODE_BITS			0x00000001

#define	CM_REGISTER_DEVICE_DRIVER_STATIC	0x00000000
#define	CM_REGISTER_DEVICE_DRIVER_DISABLEABLE	0x00000001
#define	CM_REGISTER_DEVICE_DRIVER_REMOVABLE	0x00000002
#define	CM_REGISTER_DEVICE_DRIVER_BITS		0x00000003

#define	CM_REGISTER_ENUMERATOR_SOFTWARE		0x00000000
#define	CM_REGISTER_ENUMERATOR_HARDWARE		0x00000001
#define	CM_REGISTER_ENUMERATOR_BITS		0x00000001

#define	CM_SETUP_DEVNODE_READY			0x00000000
#define	CM_SETUP_DOWNLOAD			0x00000001
#define	CM_SETUP_BITS				0x00000001

#define	CM_ADD_RANGE_ADDIFCONFLICT		0x00000000
#define	CM_ADD_RANGE_DONOTADDIFCONFLICT		0x00000001
#define	CM_ADD_RANGE_BITS			0x00000001

#define	CM_ISAPNP_ADD_RES_DES			0x00000000
#define	CM_ISAPNP_SETUP				0x00000001
#define	CM_ISAPNP_ADD_BOOT_RES_DES		0x00000002
#define	CM_ISAPNP_INVALID			0x00000003
#define	CM_ISAPNP_BITS				0x00000003

#define	CM_GET_PERFORMANCE_INFO_DATA		0x00000000
#define	CM_GET_PERFORMANCE_INFO_RESET		0x00000001
#define	CM_GET_PERFORMANCE_INFO_START		0x00000002
#define	CM_GET_PERFORMANCE_INFO_STOP		0x00000003
#define	CM_RESET_HIT_DATA			0x00000004
#define	CM_GET_HIT_DATA 			0x00000005
#define	CM_GET_PERFORMANCE_INFO_BITS		0x0000000F
#define	CM_HIT_DATA_FILES			0xFFFF0000
#define	CM_HIT_DATA_SIZE			((256*8)+8)  // magic number!

#define	CM_GET_ALLOC_LOG_CONF_ALLOC		0x00000000
#define	CM_GET_ALLOC_LOG_CONF_BOOT_ALLOC	0x00000001
#define	CM_GET_ALLOC_LOG_CONF_BITS		0x00000001

#define	CM_REGISTRY_HARDWARE			0x00000000	// Select hardware branch if NULL subkey
#define	CM_REGISTRY_SOFTWARE			0x00000001	// Select software branch if NULL subkey
#define	CM_REGISTRY_USER			0x00000100	// Use HKEY_CURRENT_USER
#define	CM_REGISTRY_CONFIG			0x00000200	// Use HKEY_CURRENT_CONFIG
#define	CM_REGISTRY_BITS			0x00000301	// The bits for the registry functions

#define	CM_DISABLE_POLITE			0x00000000	// Ask the driver
#define	CM_DISABLE_ABSOLUTE			0x00000001	// Don't ask the driver
#define	CM_DISABLE_BITS				0x00000001	// The bits for the disable function

#define	CM_HW_PROF_UNDOCK			0x00000000	// Computer not in a dock.
#define	CM_HW_PROF_DOCK				0x00000001	// Computer in a docking station
#define	CM_HW_PROF_RECOMPUTE_BITS		0x00000001	// RecomputeConfig
#define	CM_HW_PROF_DOCK_KNOWN			0x00000002	// Computer in a known docking station
#define	CM_HW_PROF_QUERY_CHANGE_BITS		0x00000003	// QueryChangeConfig

#define	CM_DETECT_NEW_PROFILE			0x00000001	// run detect for a new profile
#define	CM_DETECT_CRASHED			0x00000002	// detection crashed before
#define	CM_DETECT_HWPROF_FIRST_BOOT		0x00000004	// first boot in a new profile
#define	CM_DETECT_RUN				0x80000000	// run detection for new hardware

#define	CM_ADD_ID_HARDWARE			0x00000000
#define	CM_ADD_ID_COMPATIBLE			0x00000001
#define	CM_ADD_ID_BITS				0x00000001

#define	CM_REENUMERATE_NORMAL			0x00000000
#define	CM_REENUMERATE_SYNCHRONOUS		0x00000001
#define	CM_REENUMERATE_BITS			0x00000001

/****************************************************************************
 *
 *				CONFIGURATION MANAGER FUNCTIONS
 *
 ****************************************************************************
 *
 *	Each devnode has a config handler field and a enum handler field
 *	which are getting called every time Configuration Manager wants a
 *	devnode to perform some configuration related function. The handler
 *	is registered with CM_Register_Device_Driver or
 *	CM_Register_Enumerator, depending if the handler is for the device
 *	itself or for one of the children of the devnode.
 *
 *	The registered handler is called with:
 *
 *	result=dnToDevNode->dn_Config(if dnToDevNode==dnAboutDevNode)
 *	result=dnToDevNode->dn_Enum(if dnToDevNode!=dnAboutDevNode)
 *					(	FuncName,
 *					 	SubFuncName,
 *						dnToDevNode,
 *						dnAboutDevNode, (if enum)
 *						dwRefData, (if driver)
 *						ulFlags);
 *	Where:
 *
 *	FuncName is one of CONFIG_FILTER, CONFIG_START, CONFIG_STOP,
 *	CONFIG_TEST, CONFIG_REMOVE, CONFIG_ENUMERATE, CONFIG_SETUP or
 *	CONFIG_CALLBACK.
 *
 *	SubFuncName is the specific CONFIG_xxxx_* that further describe
 *	we START, STOP or TEST.
 *
 *	dnToDevNode is the devnode we are calling. This is given so that
 *	a signle handler can handle multiple devnodes.
 *
 *	dnAboutDevNode specifies which devnode the function is about. For
 *	a config handler, this is necessarily the same as dnToDevNode. For
 *	an enumerator handler, this devnode is necessarily different as it
 *	is a child of the dnToDevNode (special case: CONFIG_ENUMERATE
 *	necessarily has dnAboutDevNode==NULL). For instance, when starting
 *	a COM devnode under a BIOS enumerator, we would make the following
 *	two calls:
 *
 *		To BIOS with (CONFIG_START, ?, BIOS, COM, ?, 0).
 *
 *		To COM with (CONFIG_START, ?, COM, COM, ?, 0).
 *
 *	dwRefData is a dword of reference data. For a config handler, it is
 *	the DWORD passed on the CONFIGMG_Register_Device_Driver call. For an
 *	enumerator, it is the same as CONFIGMG_Get_Private_DWord(?,
 *	dnToDevNode, dnToDevNode, 0).
 *
 *	ulFlags is 0 and is reserved for future extensions.
 *
 *	Here is the explanation of each event, in parenthesis I put the
 *	order the devnodes will be called:
 *
 *	CONFIG_FILTER (BRANCH GOING UP) is the first thing called when a new
 *	insertion or change of configuration need to be processed. First
 *	CM copies the requirement list (BASIC_LOG_CONF) onto the filtered
 *	requirement list (FILTER_LOG_CONF) so that they are originally
 *	the same. CM then calls every node up, giving them the chance to
 *	patch the requirement of the dnAboutDevNode (they can also
 *	alter their own requirement). Examples are PCMCIA which would
 *	remove some IRQ that the adapter can't do, prealloc some IO
 *	windows and memory windows. ISA which would limit address space
 *	to being <16Meg. A device driver should look only at
 *	FILTER_LOG_CONF during this call.
 *
 *	CONFIG_START (BRANCH GOING DOWN) are called to change the
 *	configuration. A config handler/enumerator hander should look
 *	only at the allocated list (ALLOC_LOG_CONF).
 *
 *	CONFIG_STOP (WHOLE TREE BUT ONLY DEVNODES THAT CHANGE
 *	CONFIGURATION (FOR EACH DEVNODE, BRANCH GOING UP)) is called
 *	for two reasons:
 *
 *		1) Just after the rebalance algorithm came up with a
 *		solution and we want to stop all devnodes that will be
 *		rebalance. This is to avoid the problem of having two cards
 *		that can respond to 110h and 220h and that need to toggle
 *		their usage. We do not want two people responding to 220h,
 *		even for a brief amount of time. This is the normal call
 *		though.
 *
 *		2) There was a conflict and the user selected this device
 *		to kill.
 *
 *	CONFIG_TEST (WHOLE TREE) is called before starting the rebalance
 *	algorithm. Device drivers that fail this call will be considered
 *	worst than jumpered configured for the reminder of this balancing
 *	process.
 *
 *	CONFIG_REMOVE (FOR EACH SUB TREE NODE, DOING BRANCH GOING UP), is
 *	called when someone notify CM via CM_Remove_SubTree that a devnode
 *	is not needed anymore. A static VxD probably has nothing to do. A
 *	dynamic VxD should check whether it should unload itself (return
 *	CR_SUCCESS_UNLOAD) or not (CR_SUCCESS).
 *
 *	Note, failing any of CONFIG_START, or CONFIG_STOP is really bad,
 *	both in terms of performance and stability. Requirements for a
 *	configuration to succeed should be noted/preallocated during
 *	CONFIG_FILTER. Failing CONFIG_TEST is less bad as what basically
 *	happens is that the devnode is considered worst than jumpered
 *	configured for the reminder of this pass of the balancing algorithm.
 *
 *	COMFIG_ENUMERATE, the called node should create children devnodes
 *	using CM_Create_DevNode (but no need for grand children) and remove
 *	children using CM_Remove_SubTree as appropriate. Config Manager
 *	will recurse calling the children until nothing new appears. During
 *	this call, dnAboutDevNode will be NULL. Note that there is an easy
 *	way for buses which do not have direct children accessibility to
 *	detect (ISAPNP for instance will isolate one board at a time and
 *	there is no way to tell one specific board not to participate in
 *	the isolation sequence):
 *
 *	If some children have soft-eject capability, check those first.
 *	If the user is pressing the eject button, call Query_Remove_SubTree
 *	and if that succeed, call Remove_SubTree.
 *
 *	Do a CM_Reset_Children_Marks on the bus devnode.
 *
 *	Do the usual sequence doing CM_Create_DevNode calls. If a devnode
 *	was already there, CR_ALREADY_SUCH_DEVNODE is returned and this
 *	devnode's DN_HAS_MARK will be set. There is nothing more to do with
 *	this devnode has it should just continue running. If the devnode
 *	was not previously there, CR_SUCCESS will be return, in which case
 *	the enumerator should add the logical configurations.
 *
 *	Once all the devnode got created. The enumerator can call
 *	CM_Remove_Unmarked_Children to remove the devnode that are now gone.
 *	Essentially, this is a for loop thru all the children of the bus
 *	devnode, doing Remove_SubTree on the the devnode which have their
 *	mark cleared. Alternatively, an enumerator can use CM_Get_Child,
 *	CM_Get_Sibling, CM_Remove_SubTree and CM_Get_DevNode_Status.
 *
 *	For CONFIG_SETUP, the called node should install drivers if it
 *	know out to get them. This is mostly for drivers imbeded in the
 *	cards (ISA_RTR, PCI or PCMCIA). For most old cards/driver, this
 *	should return CR_NO_DRIVER.
 *
 *	WARNING: For any non-defined service, the enumertor / device
 *	driver handler should return CR_DEFAULT. This will be treated
 *	as the compatibility case in future version.
 *
 *	So normally what happens is as follows:
 *
 *	- Some detection code realize there is a new device. This can be at
 *	initialization time or at run-time (usually during a media_change
 *	interrupt). The code does a CM_Reenumerate_DevNode(dnBusDevNode)
 *	asynchronous call.
 *
 *	- During appy time event, CM gets notified.
 *
 *	- CM calls the enumerator with:
 *
 *		BusEnumHandler(CONFIG_ENUMERATE, 0, dnBusDevNode, NULL, ?, 0);
 *
 *	- The parent uses CM_Create_DevNode and CM_Remove_SubTree as
 *	appropriate, usually for only its immediate children.
 *
 *	- The parent return to CM from the enumerator call.
 *
 *	- CM walks the children, first loading their device driver if
 *	needed, then calling their enumerators. Thus the whole process
 *	will terminate only when all grand-...-grand-children have stopped
 *	using CM_Create_DevNode.
 *
 *	If rebalance is called (a new devnode is conflicting):
 *
 *	- All devnode receives the CONFIG_TEST. Devnodes that
 *	fail it are considered worst than jumpered configured.
 *
 *	- CM does the rebalance algorithm.
 *
 *	- All affected devnodes that where previously loaded get the
 *	CONFIG_STOP event.
 *
 *	- All affected devnode and the new devnodes receives a CONFIG_START.
 *
 *	If rebalancing failed (couldn't make one or more devnodes work):
 *
 *	- Device installer is called which will present the user with a
 *	choice of devnode to kill.
 *
 *	- Those devnodes will received a CONFIG_STOP message.
 *	
 ***************************************************************************/

// Possible CONFIGFUNC FuncNames:

#define	CONFIG_FILTER		0x00000000	// Ancestors must filter requirements.
#define	CONFIG_START		0x00000001	// Devnode dynamic initialization.
#define	CONFIG_STOP		0x00000002	// Devnode must stop using config.
#define	CONFIG_TEST		0x00000003	// Can devnode change state now.
#define	CONFIG_REMOVE		0x00000004	// Devnode must stop using config.
#define	CONFIG_ENUMERATE	0x00000005	// Devnode must enumerated.
#define	CONFIG_SETUP		0x00000006	// Devnode should download driver.
#define	CONFIG_CALLBACK		0x00000007	// Devnode is being called back.
#define	CONFIG_APM		0x00000008	// APM functions.
#define	CONFIG_TEST_FAILED	0x00000009	// Continue as before after a TEST.
#define	CONFIG_TEST_SUCCEEDED	0x0000000A	// Prepare for the STOP/REMOVE.
#define	CONFIG_VERIFY_DEVICE	0x0000000B	// Insure the legacy card is there.
#define	CONFIG_PREREMOVE	0x0000000C	// Devnode must stop using config.
#define	CONFIG_SHUTDOWN		0x0000000D	// We are shutting down.
#define	CONFIG_PREREMOVE2	0x0000000E	// Devnode must stop using config.
#define	CONFIG_READY		0x0000000F	// The devnode has been setup.

#define	NUM_CONFIG_COMMANDS	0x00000010	// For DEBUG.

/*XLATOFF*/

#define	DEBUG_CONFIG_NAMES \
char	CMFAR *lpszConfigName[NUM_CONFIG_COMMANDS]= \
{ \
	"CONFIG_FILTER", \
	"CONFIG_START", \
	"CONFIG_STOP", \
	"CONFIG_TEST", \
	"CONFIG_REMOVE", \
	"CONFIG_ENUMERATE", \
	"CONFIG_SETUP", \
	"CONFIG_CALLBACK", \
	"CONFIG_APM", \
	"CONFIG_TEST_FAILED", \
	"CONFIG_TEST_SUCCEEDED", \
	"CONFIG_VERIFY_DEVICE", \
	"CONFIG_PREREMOVE", \
	"CONFIG_SHUTDOWN", \
	"CONFIG_PREREMOVE2", \
	"CONFIG_READY", \
};

/*XLATON*/

// Possible SUBCONFIGFUNC SubFuncNames:

#define	CONFIG_START_DYNAMIC_START			0x00000000
#define	CONFIG_START_FIRST_START			0x00000001

#define	CONFIG_STOP_DYNAMIC_STOP			0x00000000
#define	CONFIG_STOP_HAS_PROBLEM				0x00000001

//
// For both CONFIG_REMOVE and CONFIG_POSTREMOVE
//
#define	CONFIG_REMOVE_DYNAMIC				0x00000000
#define	CONFIG_REMOVE_SHUTDOWN				0x00000001
#define	CONFIG_REMOVE_REBOOT				0x00000002

#define	CONFIG_TEST_CAN_STOP				0x00000000
#define	CONFIG_TEST_CAN_REMOVE				0x00000001

#define	CONFIG_APM_TEST_STANDBY				0x00000000
#define	CONFIG_APM_TEST_SUSPEND				0x00000001
#define	CONFIG_APM_TEST_STANDBY_FAILED			0x00000002
#define	CONFIG_APM_TEST_SUSPEND_FAILED			0x00000003
#define	CONFIG_APM_TEST_STANDBY_SUCCEEDED		0x00000004
#define	CONFIG_APM_TEST_SUSPEND_SUCCEEDED		0x00000005
#define	CONFIG_APM_RESUME_STANDBY			0x00000006
#define	CONFIG_APM_RESUME_SUSPEND			0x00000007
#define	CONFIG_APM_RESUME_CRITICAL			0x00000008
#define	CONFIG_APM_UI_ALLOWED                  		0x80000000

/****************************************************************************
 *
 *				ARBITRATOR FUNCTIONS
 *
 ****************************************************************************
 *
 *	Each arbitrator has a handler field which is getting called every
 *	time Configuration Manager wants it to perform a function. The
 *	handler is called with:
 *
 *	result=paArbitrator->Arbitrate(	EventName,
 *					paArbitrator->DWordToBePassed,
 *					paArbitrator->dnItsDevNode,
 *					pnlhNodeListHeader);
 *
 *	ENTRY:	NodeListHeader contains a logical configuration for all
 *		devices the configuration manager would like to reconfigure.
 *		DWordToBePassed is the arbitrator reference data.
 *		ItsDevNode is the pointer to arbitrator's devnode.
 *		EventName is one of the following:
 *
 *	ARB_TEST_ALLOC - Test allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. See individual arbitrator for the algorithm
 *		employed. Generally, the arbitration consists
 *		of sorting the list according to most likely succesful
 *		allocation order, making a copy of the current allocation
 *		data strucuture(s), releasing all resource currently
 *		allocated to devnodes on the list from the copy data structure
 *		and then attempting to satisfy allocation requests
 *		by passing through the entire list, trying all possible
 *		combinations of allocations before failing. The arbitrator
 *		saves the resultant successful allocations, both in the node
 *		list per device and the copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_RETEST_ALLOC - Retest allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and attempt to allocate that resource for each allcoation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then attempt to satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_FORCE_ALLOC - Retest allocation of resource, always succeed
 *
 *	DESC:	The arbitration routine will satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and allocate that resource for each allocation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_SET_ALLOC - Makes a test allocation the real allocation
 *
 *	DESC:	Makes the copy of the allocation data structure the
 *		current valid allocation.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	ARB_RELEASE_ALLOC - Clean up after failed test allocation
 *
 *	DESC:	Free all allocation that were allocated by the previous
 *		ARB_TEST_ALLOC.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	ARB_QUERY_FREE - Add all free resource logical configuration
 *
 *	DESC:	Return resource specific data on the free element. Note
 *		than the pnlhNodeListHeader is a cast of an arbitfree_s.
 *
 *	EXIT:	CR_SUCCESS if successful
 *		CR_FAILURE if the request makles no sense.
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_REMOVE - The devnode the arbitrator registered with is going away
 *
 *	DESC:	Arbitrator registered with a non-NULL devnode (thus is
 *		normally local), and the devnode is being removed. Arbitrator
 *		should do appropriate cleanup.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	WARNING: For any non-defined service, the arbitrator should return
 *	CR_DEFAULT. This will be treated as the compatibility case in future
 *	version.
 *
 ***************************************************************************/
#define	ARB_TEST_ALLOC		0x00000000	// Check if can make alloc works.
#define	ARB_RETEST_ALLOC	0x00000001	// Check if can take previous alloc.
#define	ARB_SET_ALLOC		0x00000002	// Set the tested allocation.
#define	ARB_RELEASE_ALLOC	0x00000003	// Release the tested allocation.
#define	ARB_QUERY_FREE		0x00000004	// Return free resource.
#define	ARB_REMOVE		0x00000005	// DevNode is gone.
#define	ARB_FORCE_ALLOC		0x00000006	// Force previous TEST_ALLOC
#define	NUM_ARB_COMMANDS	0x00000007	// Number of arb commands

#define	DEBUG_ARB_NAMES \
char	CMFAR *lpszArbFuncName[NUM_ARB_COMMANDS]= \
{ \
	"ARB_TEST_ALLOC",\
	"ARB_RETEST_ALLOC",\
	"ARB_SET_ALLOC",\
	"ARB_RELEASE_ALLOC",\
	"ARB_QUERY_FREE",\
	"ARB_REMOVE",\
	"ARB_FORCE_ALLOC",\
};

/****************************************************************************
 *
 *				DEVNODE STATUS
 *
 ****************************************************************************
 *
 *	These are the bits in the devnode's status that someone can query
 *	with a CM_Get_DevNode_Status. The A/S column tells wheter the flag
 *	cann be change asynchronously or not.
 *
 ***************************************************************************/
#define	DN_ROOT_ENUMERATED	0x00000001	// S: Was enumerated by ROOT
#define	DN_DRIVER_LOADED	0x00000002	// S: Has Register_Device_Driver
#define	DN_ENUM_LOADED		0x00000004	// S: Has Register_Enumerator
#define	DN_STARTED		0x00000008	// S: Is currently configured
#define	DN_MANUAL		0x00000010	// S: Manually installed
#define	DN_NEED_TO_ENUM		0x00000020	// A: May need reenumeration
#define	DN_NOT_FIRST_TIME	0x00000040	// S: Has received a config
#define	DN_HARDWARE_ENUM	0x00000080	// S: Enum generates hardware ID
#define	DN_LIAR 		0x00000100	// S: Lied about can reconfig once
#define	DN_HAS_MARK		0x00000200	// S: Not CM_Create_DevNode lately
#define	DN_HAS_PROBLEM		0x00000400	// S: Need device installer
#define	DN_FILTERED		0x00000800	// S: Is filtered
#define	DN_MOVED		0x00001000	// S: Has been moved
#define	DN_DISABLEABLE		0x00002000	// S: Can be rebalanced
#define	DN_REMOVABLE		0x00004000	// S: Can be removed
#define	DN_PRIVATE_PROBLEM	0x00008000	// S: Has a private problem
#define	DN_MF_PARENT		0x00010000	// S: Multi function parent
#define	DN_MF_CHILD		0x00020000	// S: Multi function child
#define	DN_WILL_BE_REMOVED	0x00040000	// S: Devnode is being removed

/*XLATOFF*/

#define	NUM_DN_FLAG		0x00000013	// DEBUG: maximum flag (number)
#define	DN_FLAG_LEN		0x00000002	// DEBUG: flag length

#define	DEBUG_DN_FLAGS_NAMES \
char	CMFAR lpszDNFlagsName[NUM_DN_FLAG][DN_FLAG_LEN]= \
{ \
	"rt", \
	"dl", \
	"el", \
	"st", \
	"mn", \
	"ne", \
	"fs", \
	"hw", \
	"lr", \
	"mk", \
	"pb", \
	"ft", \
	"mv", \
	"db", \
	"rb", \
	"pp", \
	"mp", \
	"mc", \
	"rm", \
};

struct vmmtime_s {
DWORD		vmmtime_lo;
DWORD		vmmtime_hi;
};

typedef	struct vmmtime_s	VMMTIME;
typedef	VMMTIME			*PVMMTIME;

struct cmtime_s {
DWORD		dwAPICount;
VMMTIME		vtAPITime;
};

typedef	struct cmtime_s		CMTIME;
typedef	CMTIME			*PCMTIME;

struct cm_performance_info_s {
CMTIME		ctBoot;
CMTIME		ctAPI[NUM_CM_SERVICES];
CMTIME		ctRing3;
CMTIME		ctProcessTree;
CMTIME		ctAssignResources;
CMTIME		ctSort;
CMTIME		ctRegistry;
CMTIME		ctVxDLdr;
CMTIME		ctNewDevNode;
CMTIME		ctSendMessage;
CMTIME		ctShell;
CMTIME		ctReceiveMessage;
CMTIME		ctAppyTime;
CMTIME		ctConfigMessage[NUM_CONFIG_COMMANDS];
CMTIME		ctArbTime[ResType_Max+1][NUM_ARB_COMMANDS];
DWORD		dwStackSize;
DWORD		dwMaxProcessTreePasses;
DWORD		dwStackAlloc;
};

typedef	struct	cm_performance_info_s	CMPERFINFO;
typedef	CMPERFINFO		CMFAR	*PCMPERFINFO;

/*XLATON*/

/****************************************************************************
 *
 *				DLVXD FUNCTIONS
 *
 ****************************************************************************
 *
 *	We load a Dynamically loaded VxD when there is a DEVLOADER=... line
 *	in the registry, or when someone calls CM_Load_Device. We then do
 *	a direct system control call (PNP_NEW_DEVNODE) to it, telling the
 *	DLVXD whether we loaded it to be an enumerator, a driver or a
 *	devloader (config manager does only deal with devloaders, but the
 *	default devloaders does CM_Load_Device with DLVXD_LOAD_ENUMERATOR
 *	and DLVXD_LOAD_DRIVER).
 *
 ***************************************************************************/
#define	DLVXD_LOAD_ENUMERATOR	0x00000000	// We loaded DLVxD as an enumerator.
#define	DLVXD_LOAD_DEVLOADER	0x00000001	// We loaded DLVxD as a devloader.
#define	DLVXD_LOAD_DRIVER	0x00000002	// We loaded DLVxD as a device driver.
#define	NUM_DLVXD_LOAD_TYPE	0x00000003	// Number of DLVxD load type.

/****************************************************************************
 *
 *				GLOBALLY DEFINED FLAGS
 *
 ***************************************************************************/
#define	ARB_GLOBAL		0x00000001	// Arbitrator is global.
#define	ARB_LOCAL		0x00000000	// Arbitrator is local.
#define	ARB_SCOPE_BIT		0x00000001	// Arbitrator is global/local bit.

#define	BASIC_LOG_CONF		0x00000000	// Specifies the req list.
#define	FILTERED_LOG_CONF	0x00000001	// Specifies the filtered req list.
#define	ALLOC_LOG_CONF		0x00000002	// Specifies the Alloc Element.
#define	BOOT_LOG_CONF		0x00000003	// Specifies the RM Alloc Element.
#define	FORCED_LOG_CONF		0x00000004	// Specifies the Forced Log Conf
#define	NUM_LOG_CONF		0x00000005	// Number of Log Conf type
#define	LOG_CONF_BITS		0x00000007	// The bits of the log conf type.

#define	DEBUG_LOG_CONF_NAMES \
char	CMFAR *lpszLogConfName[NUM_LOG_CONF]= \
{ \
	"BASIC_LOG_CONF",\
	"FILTERED_LOG_CONF",\
	"ALLOC_LOG_CONF",\
	"BOOT_LOG_CONF",\
	"FORCED_LOG_CONF",\
};

#define	PRIORITY_EQUAL_FIRST	0x00000008	// Same priority, new one is first.
#define	PRIORITY_EQUAL_LAST	0x00000000	// Same priority, new one is last.
#define	PRIORITY_BIT		0x00000008	// The bit of priority.

#ifndef	Not_VxD

/****************************************************************************
 *
 * Arbitration list structures
 *
 ***************************************************************************/
struct	nodelist_s {
	struct nodelist_s	*nl_Next;		// Next node element
	struct nodelist_s	*nl_Previous;		// Previous node element
	struct devnode_s	*nl_ItsDevNode;		// The dev node it represent

	// You can add fields to this structure, but the first three
	// fields must NEVER be changed.

	struct Log_Conf 	*nl_Test_Req;		// Test resource alloc request
	ULONG			nl_ulSortDWord;		// Specifies the sort order
};

struct	nodelistheader_s {
	struct	nodelist_s	*nlh_Head;		// First node element
	struct	nodelist_s	*nlh_Tail;		// Last node element
};

struct	arbitfree_s {
	PVOID			*af_PointerToInfo;	// the arbitrator info
	ULONG			af_SizeOfInfo;		// size of the info
};

#endif

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for memory returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken memory address space.
 */
struct	MEM_Arb_s {
	RANGE_LIST		MEMA_Alloc;
};

typedef	struct MEM_Arb_s	MEMA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for IO returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken IO address space.
 */
struct	IO_Arb_s {
	RANGE_LIST		IOA_Alloc;
};

typedef	struct IO_Arb_s		IOA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for DMA returns the DMA_Arb_s,
 *	16 bits of allocation bit mask, where DMAA_Alloc is inverted
 *	(set bit indicates free port).
 */
struct	DMA_Arb_s {
	WORD			DMAA_Alloc;
};

typedef	struct DMA_Arb_s	DMA_ARB;

/***************************************************************************
 * ARB_QUERY_FREE arbitrator function for IRQ returns the IRQ_Arb_s,
 *	16 bits of allocation bit mask, 16 bits of share bit mask and 16
 *	BYTES of share count. IRQA_Alloc is inverted (bit set indicates free
 *	port). If port is not free, IRQA_Share bit set indicates port
 *	that is shareable. For shareable IRQs, IRQA_Share_Count indicates
 *	number of devices that are sharing an IRQ.
 */
struct	IRQ_Arb_s {
	WORD			IRQA_Alloc;
	WORD			IRQA_Share;
	BYTE			IRQA_Share_Count[16];
};

typedef	struct IRQ_Arb_s	IRQ_ARB;

/* ASM
DebugCommand	Macro	FuncName
		local	DC_01
ifndef	CM_GOLDEN_RETAIL
ifdef	retail
 	IsDebugOnlyLoaded	DC_01
endif
	Control_Dispatch	DEBUG_QUERY, FuncName, sCall
endif
DC_01:
endm
IFDEF CM_PERFORMANCE_INFO
CM_PAGEABLE_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_LOCKED_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_LOCKED_DATA_ENDS>
ELSE
CM_PAGEABLE_CODE_SEG	TEXTEQU <VxD_PNP_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU <VxD_PNP_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_PAGEABLE_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_PAGEABLE_DATA_ENDS>
ENDIF
*/

struct	CM_API_s {
DWORD		pCMAPIStack;
DWORD		dwCMAPIService;
DWORD		dwCMAPIRet;
};

typedef	struct	CM_API_s	CMAPI;

/*XLATOFF*/

#define	CM_VXD_RESULT		int

#define	CM_EXTERNAL		_cdecl
#define	CM_HANDLER		_cdecl
#define	CM_SYSCTRL		_stdcall
#define	CM_GLOBAL_DATA
#define	CM_LOCAL_DATA		static

#define	CM_OFFSET_OF(type, id)	((DWORD)(&(((type)0)->id)))

#define	CM_BUUGBUUG(d, id, msg)	message("BUUGBUUG: "##d##", "##id##": "##msg)

#if	DEBLEVEL==DEBLEVELRETAIL

#define	CM_WARN(strings)
#define	CM_ERROR(strings)

#else

#if	DEBLEVEL==DEBLEVELNORMAL

#define	CM_WARN(strings)
#define	CM_ERROR(strings) {\
	_Debug_Printf_Service(WARNNAME " ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}

#else

#define	CM_WARN(strings) {\
	_Debug_Printf_Service(WARNNAME " WARNS: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}

#define	CM_ERROR(strings) {\
	_Debug_Printf_Service(WARNNAME " ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n"); \
	{_asm	int	3}}
#endif

#endif

#ifdef	DEBUG
#define	CM_DEBUG_CODE		VxD_LOCKED_CODE_SEG
#define	CM_DEBUG_DATA		VxD_LOCKED_DATA_SEG
#else
#define	CM_DEBUG_CODE		VxD_DEBUG_ONLY_CODE_SEG
#define	CM_DEBUG_DATA		VxD_DEBUG_ONLY_DATA_SEG
#endif

#ifdef	CM_PERFORMANCE_INFO

#define	CM_PAGEABLE_CODE	VxD_LOCKED_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_LOCKED_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG
#define	CURSEG()		LCODE

#else

#define	CM_PAGEABLE_CODE	VxD_PNP_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_PAGEABLE_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG

#pragma warning (disable:4005)			// turn off redefinition

#define	CURSEG()		CCODE

#pragma warning (default:4005)			// turn on redefinition

#endif

#ifndef	MAX_PROFILE_LEN
#define	MAX_PROFILE_LEN	80
#endif

struct	HWProfileInfo_s {
ULONG	HWPI_ulHWProfile;			// the profile handle
char	HWPI_szFriendlyName[MAX_PROFILE_LEN];	// the friendly name
DWORD	HWPI_dwFlags;				// CM_HWPI_* flags
};

typedef	struct	HWProfileInfo_s	       HWPROFILEINFO;
typedef	struct	HWProfileInfo_s	      *PHWPROFILEINFO;
typedef	struct	HWProfileInfo_s	CMFAR *PFARHWPROFILEINFO;

#define	CM_HWPI_NOT_DOCKABLE	0x00000000
#define	CM_HWPI_UNDOCKED	0x00000001
#define	CM_HWPI_DOCKED		0x00000002

#ifdef	DEBUG

#define	CM_INTERNAL		_cdecl

#else

#define	CM_INTERNAL		_fastcall

#endif

#define	CM_NAKED		__declspec ( naked )
#define	CM_LOCAL		CM_INTERNAL
#define	CM_UNIQUE		static CM_INTERNAL

#define	CM_BEGIN_CRITICAL {\
_asm	pushfd	\
_asm	cli	\
}

#define	CM_END_CRITICAL \
_asm	popfd\

#define	CM_FOREVER		for (;;)

#ifndef	No_CM_Calls

#ifdef	Not_VxD

/****************************************************************************
 *
 *	CONFIGMG_Get_Entry_Point - Return the address to call to get in
 *				   Config Manager.
 *
 *	Exported.
 *
 *	ENTRY:	None.
 *
 *	EXIT:	None.
 *
 *	On return, the variable CMEntryPoint has been updated with the
 *	proper address to call to get to Configuration Manager.
 *
 ***************************************************************************/
DWORD static
CM_Get_Entry_Point(void)
{
	static	DWORD		CMEntryPoint=NULL;

	if (CMEntryPoint)
		return(CMEntryPoint);

	_asm	push	bx
	_asm	push	es
	_asm	push	di
	_asm	xor	di, di

	_asm	mov	ax, 0x1684
	_asm	mov	bx, 0x33
	_asm	mov	es, di
	_asm	int	0x2f

	_asm	mov	word ptr [CMEntryPoint+2], es
	_asm	mov	word ptr [CMEntryPoint], di

	_asm	pop	di
	_asm	pop	es
	_asm	pop	bx

	return(CMEntryPoint);
}

#define	MAKE_CM_HEADER(Function, Parameters) \
CONFIGRET static _near _cdecl \
CM_##Function##Parameters \
{ \
	CONFIGRET	CMRetValue=0; \
	DWORD		CMEntryPoint; \
	WORD		wCMAPIService=GetVxDServiceOrdinal(_CONFIGMG_##Function); \
	if ((CMEntryPoint=CM_Get_Entry_Point())==0) \
		return(0); \
	_asm	{mov	ax, wCMAPIService};\
	_asm	{call	CMEntryPoint}; \
	_asm	{mov	CMRetValue, ax};\
	return(CMRetValue); \
}

#else	// Not_VxD

#define	MAKE_CM_HEADER(Function, Parameters) \
MAKE_HEADER(CONFIGRET, _cdecl, CAT(_CONFIGMG_, Function), Parameters)

#endif	// Not_VxD

/****************************************************************************
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 * Each of the following functions must match their equivalent service
 * and the parameter table in dos386\vmm\configmg\services.*.
 *
 * Except for the Get_Version, each function return a CR_* result in EAX
 * (AX for non IS_32 app) and can trash ECX and/or EDX as they are 'C'
 * callable.
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 ***************************************************************************/

#pragma warning (disable:4100)		// Param not used

#ifdef	Not_VxD

MAKE_CM_HEADER(Get_Version, (VOID))

#else

WORD VXDINLINE
CONFIGMG_Get_Version(VOID)
{
	WORD	w;
	VxDCall(_CONFIGMG_Get_Version);
	_asm mov [w], ax
	return(w);
}

#endif

MAKE_CM_HEADER(Initialize, (ULONG ulFlags))
MAKE_CM_HEADER(Locate_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Parent, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Child, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Sibling, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID_Size, (PFARULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID, (DEVNODE dnDevNode, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Get_Depth, (PFARULONG pulDepth, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Private_DWord, (PFARULONG pulPrivate, DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_DWord, (DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Create_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, DEVNODE dnParent, ULONG ulFlags))
MAKE_CM_HEADER(Query_Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Register_Device_Driver, (DEVNODE dnDevNode, CMCONFIGHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator, (DEVNODE dnDevNode, CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Register_Arbitrator, (PREGISTERID pRid, RESOURCEID id, CMARBHANDLER Handler, ULONG ulDWordToBePassed, DEVNODE dnArbitratorNode, ULONG ulFlags))
MAKE_CM_HEADER(Deregister_Arbitrator, (REGISTERID id, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Size, (PFARULONG pulSize, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Data, (PFARVOID pData, ULONG DataLen, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Sort_NodeList, (NODELIST_HEADER nlhNodeListHeader, ULONG ulFlags))
MAKE_CM_HEADER(Yield, (ULONG ulMicroseconds, ULONG ulFlags))
MAKE_CM_HEADER(Lock, (ULONG ulFlags))
MAKE_CM_HEADER(Unlock, (ULONG ulFlags))
MAKE_CM_HEADER(Add_Empty_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, PRIORITY Priority, ULONG ulFlags))
MAKE_CM_HEADER(Free_Log_Conf, (LOG_CONF lcLogConfToBeFreed, ULONG ulFlags))
MAKE_CM_HEADER(Get_First_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Log_Conf, (PLOG_CONF plcLogConf, LOG_CONF lcLogConf, ULONG ulFlags))
MAKE_CM_HEADER(Add_Res_Des, (PRES_DES prdResDes, LOG_CONF lcLogConf, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Modify_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Free_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Res_Des, (PRES_DES prdResDes, RES_DES CurrentResDesOrLogConf, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Performance_Info, (PCMPERFINFO pPerfInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data_Size, (PFARULONG pulSize, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data, (RES_DES rdResDes, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Process_Events_Now, (ULONG ulFlags))
MAKE_CM_HEADER(Create_Range_List, (PRANGE_LIST prlh, ULONG ulFlags))
MAKE_CM_HEADER(Add_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Delete_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Test_Range_Available, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Dup_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(Free_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Invert_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulMaxVal, ULONG ulFlags))
MAKE_CM_HEADER(Intersect_Range_List, (RANGE_LIST rlhOld1, RANGE_LIST rlhOld2, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(First_Range, (RANGE_LIST rlh, PFARULONG pulStart, PFARULONG pulEnd, PRANGE_ELEMENT preElement, ULONG ulFlags))
MAKE_CM_HEADER(Next_Range, (PRANGE_ELEMENT preElement, PFARULONG pulStart, PFARULONG pulEnd, ULONG ulFlags))
MAKE_CM_HEADER(Dump_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Load_DLVxDs, (DEVNODE dnDevNode, PFARCHAR FileNames, LOAD_TYPE LoadType, ULONG ulFlags))
MAKE_CM_HEADER(Get_DDBs, (PPPVMMDDB ppDDB, PFARULONG pulCount, LOAD_TYPE LoadType, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_CRC_CheckSum, (PFARVOID pBuffer, ULONG ulSize, PFARULONG pulSeed, ULONG ulFlags))
MAKE_CM_HEADER(Register_DevLoader, (PVMMDDB pDDB, ULONG ulFlags))
MAKE_CM_HEADER(Reenumerate_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Setup_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Reset_Children_Marks, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Status, (PFARULONG pulStatus, PFARULONG pulProblemNumber, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Remove_Unmarked_Children, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(ISAPNP_To_CM, (PFARVOID pBuffer, DEVNODE dnDevNode, ULONG ulLogDev, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Device_Driver, (CMCONFIGHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Enumerator, (CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Get_Alloc_Log_Conf, (PCMCONFIG pccBuffer, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key_Size, (PFARULONG pulLen, DEVNODE dnDevNode, PFARCHAR pszSubKey, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulExpectedType, PFARVOID pBuffer, PFARULONG pulLength, ULONG ulFlags))
MAKE_CM_HEADER(Write_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulType, PFARVOID pBuffer, ULONG ulLength, ULONG ulFlags))
MAKE_CM_HEADER(Disable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Enable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Move_DevNode, (DEVNODE dnFromDevNode, DEVNODE dnToDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Bus_Info, (DEVNODE dnDevNode, CMBUSTYPE btBusType, ULONG ulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Bus_Info, (DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, PFARULONG pulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof, (ULONG ulConfig, ULONG ulFlags))
MAKE_CM_HEADER(Recompute_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Query_Change_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_Driver_Private_DWord, (DEVNODE dnDevNode, PFARULONG pulDWord, ULONG ulFlags))
MAKE_CM_HEADER(Set_Device_Driver_Private_DWord, (DEVNODE dnDevNode, ULONG ulDword, ULONG ulFlags))
MAKE_CM_HEADER(Get_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, PFARULONG pulValue, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Log_Confs, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Run_Detection, (ULONG ulFlags))
MAKE_CM_HEADER(Call_At_Appy_Time, (CMAPPYCALLBACKHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Fail_Change_HW_Prof, (ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_Problem, (DEVNODE dnDevNode, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Debug_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Hardware_Profile_Info, (ULONG ulIndex, PFARHWPROFILEINFO pHWProfileInfo, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator_Function, (DEVNODE dnDevNode, CMENUMFUNCTION Handler, ULONG ulFlags))
MAKE_CM_HEADER(Call_Enumerator_Function, (DEVNODE dnDevNode, ENUMFUNC efFunc, ULONG ulRefData, PFARVOID pBuffer, ULONG ulBufferSize, ULONG ulFlags))
MAKE_CM_HEADER(Add_ID, (DEVNODE dnDevNode, PFARCHAR pszID, ULONG ulFlags))

#pragma warning (default:4100)		// Param not used

#endif	// ifndef No_CM_Calls

/*XLATON*/

#endif	// ifndef CMJUSTRESDES

#endif	// _CONFIGMG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\win95\pbt.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*
*  TITLE:       PBT.H
*
*  VERSION:     1.0
*
*  DATE:        15 Jan 1994
*
*  Definitions for the Virtual Power Management Device.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  15 Jan 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_PBT
#define _INC_PBT

#ifndef WM_POWERBROADCAST
#define WM_POWERBROADCAST               0x218
#endif

#define PBT_APMQUERYSUSPEND             0x0000
#define PBT_APMQUERYSTANDBY             0x0001

#define PBT_APMQUERYSUSPENDFAILED       0x0002
#define PBT_APMQUERYSTANDBYFAILED       0x0003

#define PBT_APMSUSPEND                  0x0004
#define PBT_APMSTANDBY                  0x0005

#define PBT_APMRESUMECRITICAL           0x0006
#define PBT_APMRESUMESUSPEND            0x0007
#define PBT_APMRESUMESTANDBY            0x0008

#define PBTF_APMRESUMEFROMFAILURE       0x00000001

#define PBT_APMBATTERYLOW               0x0009
#define PBT_APMPOWERSTATUSCHANGE        0x000A

#define PBT_APMOEMEVENT                 0x000B

#define PBT_CAPABILITIESCHANGE			0x0010

// APM 1.2 hibernate

// #ifdef SUPPORT_HIBERNATE

#define PBT_APMQUERYHIBERNATE			0x000C
#define PBT_APMQUERYHIBERNATEFAILED		0x000D
#define PBT_APMHIBERNATE				0x000E
#define PBT_APMRESUMEHIBERNATE			0x000F

// #endif

#endif // _INC_PBT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\win95\pwrioctl.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       PWRIOCTL.H
*
*  VERSION:     1.0
*
*  DATE:        01 Feb 1994
*
*  AUTHOR:      TCS
*
*  Definitions for the Virtual Power Management Device DeviceIoControl
*  interface.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  01 Feb 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_PWRIOCTL
#define _INC_PWRIOCTL

#ifndef Not_VxD
#define Not_VxD
#endif

#ifndef IS_32
#define IS_32
#endif

#include <vpowerd.h>

//
//  The IOCTL codes match up exactly to the order of the services in the VPOWERD
//  service table (plus one).  The input buffer for each IOCTL code follows the
//  same structure as the corresponding VPOWERD service would expect.  The
//  output buffer is used to store the return value from the VPOWERD service.
//

//  VPOWERD_IOCTL_GET_VERSION
//      Gets the version of the installed VPOWERD device.
//
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to DWORD to receive the VPOWERD version.
#define VPOWERD_IOCTL_GET_VERSION               0x00000001

//  VPOWERD_IOCTL_GET_APM_BIOS_VERSION
//      Gets the version of the APM BIOS that VPOWERD has detected.
//
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to DWORD to receive the APM BIOS version.
#define VPOWERD_IOCTL_GET_APM_BIOS_VERSION      0x00000002

//  VPOWERD_IOCTL_GET_PM_LEVEL
//      Gets the level of power management interaction between VPOWERD and the
//      APM BIOS.
//
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to DWORD to receive the current power management
//                  level.
#define VPOWERD_IOCTL_GET_PM_LEVEL              0x00000003

//  VPOWERD_IOCTL_SET_PM_LEVEL
//      Sets the level of power management interaction between VPOWERD and the
//      APM BIOS.
//
//  lpvInBuffer:    Pointer to VPOWERD_SET_PM_LEVEL_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the VPOWERD return code.
#define VPOWERD_IOCTL_SET_PM_LEVEL              0x00000004

typedef struct _VPOWERD_SET_PM_LEVEL_PARAM {
    DWORD PowerManagementLevel;
}   VPOWERD_SET_PM_LEVEL_PARAM;

//  VPOWERD_IOCTL_SET_DEVICE_STATE
//      Sets the power state (e.g., OFF) of the specified device ID.  Not valid
//      for the system device (all devices power managed by the APM BIOS).
//
//  lpvInBuffer:    Pointer to VPOWERD_SET_DEVICE_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the VPOWERD return code.
#define VPOWERD_IOCTL_SET_DEVICE_STATE          0x00000005

typedef struct _VPOWERD_SET_DEVICE_PARAM {
    POWER_DEVICE_ID PowerDeviceID;
    POWER_STATE PowerState;
}   VPOWERD_SET_DEVICE_PARAM;

//  VPOWERD_IOCTL_RESTORE_DEFAULTS
//      Reinitializes all APM BIOS power-on defaults.
//
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to DWORD to receive the VPOWERD return code.
#define VPOWERD_IOCTL_RESTORE_DEFAULTS          0x00000007

//  VPOWERD_IOCTL_GET_STATUS
//      Gets the current power status of the specified device ID.
//
//  lpvInBuffer:    Pointer to VPOWERD_GET_STATUS_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the VPOWERD return code.
#define VPOWERD_IOCTL_GET_STATUS                0x00000008

typedef struct _VPOWERD_GET_STATUS_PARAM {
    POWER_DEVICE_ID PowerDeviceID;
    LPPOWER_STATUS lpPowerStatus;
}   VPOWERD_GET_STATUS_PARAM;

//  VPOWERD_IOCTL_GET_STATE
//      Gets the power state (e.g., OFF) of the specified device ID.
//
//  lpvInBuffer:    Pointer to VPOWERD_GET_STATE_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the VPOWERD return code.
#define VPOWERD_IOCTL_GET_STATE                 0x00000009

typedef struct _VPOWERD_GET_STATE_PARAM {
    POWER_DEVICE_ID PowerDeviceID;
    LPPOWER_STATE lpPowerState;
}   GET_STATE_PARAM;

//  VPOWERD_IOCTL_OEM_APM_FUNCTION
//      Calls an OEM defined APM BIOS extension.
//
//  lpvInBuffer:    Pointer to VPOWERD_OEM_APM_FUNCTION_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the VPOWERD return code.
#define VPOWERD_IOCTL_OEM_APM_FUNCTION          0x0000000A

typedef struct _VPOWERD_OEM_APM_FUNCTION_PARAM {
    LPOEM_APM_REGS lpOemApmRegs;
}   VPOWERD_OEM_APM_FUNCTION_PARAM;

//  VPOWERD_IOCTL_W32_GET_SYSTEM_STATUS
//      Gets the current power status of the system.  Follows the Win32
//      GetSystemPowerStatus API convention.
//
//  lpvInBuffer:    Pointer to VPOWERD_W32_GET_SYSTEM_STATUS_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the boolean return code.
#define VPOWERD_IOCTL_W32_GET_SYSTEM_STATUS     0x0000000D

typedef struct _VPOWERD_W32_GET_SYSTEM_STATUS_PARAM {
    LPWIN32_SYSTEM_POWER_STATUS lpWin32SystemPowerStatus;
}   VPOWERD_W32_GET_SYSTEM_STATUS_PARAM;

//  VPOWERD_IOCTL_GET_CAPABILITIES
//		Gets the capabilities bitmask of an APM 1.2 machine.
//  lpvInBuffer:    Pointer to VPOWERD_GET_CAPABILITIES_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the boolean return code.
#define VPOWERD_IOCTL_GET_CAPABILITIES			0x000000F

typedef struct _VPOWERD_GET_CAPABILITIES_PARAM {
    PAPM_CAPABILITIES	pApmCaps;
}   VPOWERD_GET_CAPABILITIES_PARAM;

// VPOWERD_IOCTL_ENABLE_RING_RESUME
// 		Calls into the BIOS and attempts to enable the Resume on Ring capability.  This is only supported on APM 1.2 machines
//	lpvInBuffer: 	Not used for this operation, set to NULL
//  lpvOutBuffer: 	pointer to dword to receive the VPOWERD return code. (Expect PR_FUNC_NOT_SUPPORTED on APM 1.1 or lower machines.)
#define VPOWERD_IOCTL_ENABLE_RING_RESUME		0x00000010

// VPOWERD_IOCTL_DISABLE_RING_RESUME
// 		Calls into the BIOS and attempts to disable the Resume on Ring capability.  This is only supported on APM 1.2 machines
//	lpvInBuffer: 	Not used for this operation, set to NULL
//  lpvOutBuffer: 	pointer to dword to receive the VPOWERD return code. (Expect PR_FUNC_NOT_SUPPORTED on APM 1.1 or lower machines.)
#define VPOWERD_IOCTL_DISABLE_RING_RESUME		0x00000011

//  VPOWERD_IOCTL_W32_GET_STATUS
//      Gets the current power status of a particular battery on an APM 1.2 machine.
//		BatteryNumber is the battery device ID in which your interested.  
//		The device ID is formed by adding 0x8000 to the *1* based battery number.
//		e.g. if your interested in the first battery, BatteryNumber=0x8001
//  lpvInBuffer:    Pointer to VPOWERD_W32_GET_STATUS_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the boolean return code.
#define VPOWERD_IOCTL_W32_GET_STATUS     0x00000017

typedef struct _VPOWERD_W32_GET_STATUS_PARAM {
	DWORD	BatteryNumber;
    LPWIN32_SYSTEM_POWER_STATUS lpWin32SystemPowerStatus;
}   VPOWERD_W32_GET_STATUS_PARAM;

// VPOWERD_IOCTL_GET_RING_RESUME_STATUS
// 		Calls into the BIOS and attempts to determine whether Resume on Ring is enabled or disabled. 
//		This is only supported on APM 1.2 machines.  
//	lpvInBuffer: 	Pointer to VPOWERD_GET_RING_RESUME_STATUS_PARAM structure
//  lpvOutBuffer: 	pointer to dword to receive the VPOWERD return code.  (Expect PR_FUNC_NOT_SUPPORTED on APM 1.1 or lower machines.) 
#define VPOWERD_IOCTL_GET_RING_RESUME_STATUS	0x00000019

typedef struct	_VPOWERD_GET_RING_RESUME_STATUS_PARAM {
LPDWORD	pStatus;
} VPOWERD_GET_RING_RESUME_STATUS_PARAM;

#endif // _INC_PWRIOCTL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\win95\vmmreg.h ===
/*****************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp., 1993
 *
 *   Title:	VMMREG.H - Include file for VMM/Loader Registry Services
 *
 *   Version:	1.00
 *
 *   Date:	03-June-1993
 *
 *   Author:	Nagara
 *
 *-----------------------------------------------------------------------------
 *
 *   Change log:
 *
 ******************************************************************************
 */

#ifndef	_VMMREG_H
#define _VMMREG_H

typedef DWORD	VMMHKEY;
typedef	VMMHKEY	*PVMMHKEY;
typedef DWORD	VMMREGRET;			// return type for the REG Functions

#define	MAX_VMM_REG_KEY_LEN	256	// includes the \0 terminator

#ifndef REG_SZ		// define only if not there already
#define REG_SZ		0x0001
#endif
#ifndef REG_BINARY	// define only if not there already
#define REG_BINARY	0x0003
#endif
#ifndef REG_DWORD	// define only if not there already
#define	REG_DWORD	0x0004
#endif


#ifndef HKEY_LOCAL_MACHINE	// define only if not there already

#define HKEY_CLASSES_ROOT		0x80000000
#define HKEY_CURRENT_USER		0x80000001
#define HKEY_LOCAL_MACHINE		0x80000002
#define HKEY_USERS			0x80000003
#define HKEY_PERFORMANCE_DATA		0x80000004
#define HKEY_CURRENT_CONFIG		0x80000005
#define HKEY_DYN_DATA			0x80000006

#endif


// ERROR CODES returned by Registry
// NOTE THAT THESE ARE ALSO DEFINED IN WINERROR.H 
// and so VMMREG.H should be included after WINERROR.H

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND             2L
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                      1009L
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA                  234L    
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY			 1010L
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN                   1011L
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD                   1012L
#define ERROR_CANTWRITE                  1013L
#endif

#ifndef ERROR_REGISTRY_CORRUPT
#define ERROR_REGISTRY_CORRUPT           1015L
#define ERROR_REGISTRY_IO_FAILED         1016L
#endif

#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED                1018L
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY		   14L
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER		   87L
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED                167L
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS		  259L
#endif	


#ifndef  ERROR_SUCCESS           
#define ERROR_SUCCESS           0L
#endif

// END ERROR CODES

/*XLATOFF*/
#ifndef Not_VxD

/*NOINC*/
#ifndef _PROVIDER_STRUCTS_DEFINED
#define _PROVIDER_STRUCTS_DEFINED

struct val_context {
    int valuelen;		// the total length of this value
    PVOID value_context;	// provider's context
    PVOID val_buff_ptr;	// where in the ouput buffer the value is.
};

typedef struct val_context *PVALCONTEXT;

typedef struct pvalue {		      // Provider supplied value/context.
    PCHAR pv_valuename;          // The value name pointer
    DWORD pv_valuelen;
    PVOID pv_value_context;
    DWORD pv_type;
}PVALUE;

typedef struct pvalue *PPVALUE;

typedef VMMREGRET (_cdecl *PQUERYHANDLER)(PVOID pvKeyContext, PVALCONTEXT pvalcontextValues, DWORD cvalcontextValues, PVOID pbData, DWORD * pcbData, DWORD dwReserved);

#define PROVIDER_KEEPS_VALUE_LENGTH	0x1
typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags;		// Only PROVIDER_KEEPS_VALUE_LENGTH for now.
}PROVIDER;

typedef PROVIDER *PPROVIDER;

struct value_ent {
    PCHAR ve_valuename;
    DWORD ve_valuelen;
    DWORD ve_valueptr;
    DWORD ve_type;
};

typedef struct value_ent VALENT;
typedef VALENT *PVALENT;

#endif // not(_PROVIDER_STRUCTS_DEFINED)
/*INC*/

#ifndef WIN31COMPAT

#pragma warning (disable:4035)		// turn off no return code warning

#ifndef	WANTVXDWRAPS



VMMREGRET VXDINLINE
VMM_RegOpenKey(VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegOpenKey);
    _asm add  esp, 3*4
}

VMMREGRET VXDINLINE
VMM_RegCloseKey(VMMHKEY hkey)
{
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCloseKey);
    _asm add  esp, 1*4 
}

VMMREGRET VXDINLINE
VMM_RegCreateKey(VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCreateKey);
    _asm add  esp, 3*4
}


VMMREGRET VXDINLINE
VMM_RegCreateDynKey(PCHAR lpszSubKey, PVOID pvKeyContext, PVOID pprovHandlerInfo, PVOID ppvalueValueInfo, DWORD cpvalueValueInfo, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push cpvalueValueInfo
    _asm push ppvalueValueInfo
    _asm push pprovHandlerInfo
    _asm push pvKeyContext
    _asm push lpszSubKey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCreateDynKey);
    _asm add  esp, 6*4
}

VMMREGRET VXDINLINE
VMM_RegQueryMultipleValues (VMMHKEY hKey, PVOID val_list, DWORD num_vals, PCHAR lpValueBuf, DWORD *ldwTotsize)
{
    _asm push ldwTotsize
    _asm push lpValueBuf
    _asm push num_vals
    _asm push val_list
    _asm push hKey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryMultipleValues);
    _asm add  esp, 5*4
}

VMMREGRET VXDINLINE
VMM_RegDeleteKey(VMMHKEY hkey, PCHAR lpszSubKey)
{
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegDeleteKey);
    _asm add  esp, 2*4
}

VMMREGRET VXDINLINE
VMM_RegEnumKey(VMMHKEY hkey, DWORD iSubKey, PCHAR lpszName, DWORD cchName)
{
    _asm push cchName
    _asm push lpszName
    _asm push iSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegEnumKey);
    _asm add  esp, 4*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryValue(VMMHKEY hkey, PCHAR lpszSubKey, PCHAR lpszValue, PDWORD lpcbValue)
{
    _asm push lpcbValue
    _asm push lpszValue
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryValue);
    _asm add  esp, 4*4 
}

VMMREGRET VXDINLINE
VMM_RegSetValue(VMMHKEY hkey, PCHAR lpszSubKey, DWORD fdwType, PCHAR lpszData, DWORD cbData)
{
    _asm push cbData
    _asm push lpszData
    _asm push fdwType
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegSetValue);
    _asm add  esp, 5*4 
}

VMMREGRET VXDINLINE
VMM_RegDeleteValue(VMMHKEY hkey, PCHAR lpszValue)
{
    _asm push lpszValue
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegDeleteValue);
    _asm add  esp, 2*4 
}

VMMREGRET VXDINLINE
VMM_RegEnumValue(VMMHKEY hkey, DWORD iValue, PCHAR lpszValue, PDWORD lpcbValue, PDWORD lpdwReserved, PDWORD lpdwType, PBYTE lpbData, PDWORD lpcbData)
{
    _asm push lpcbData
    _asm push lpbData
    _asm push lpdwType
    _asm push lpdwReserved
    _asm push lpcbValue
    _asm push lpszValue
    _asm push iValue
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegEnumValue);
    _asm add  esp, 8*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryValueEx(VMMHKEY hkey, PCHAR lpszValueName, PDWORD lpdwReserved, PDWORD lpdwType, PBYTE lpbData, PDWORD lpcbData)
{
    _asm push lpcbData
    _asm push lpbData
    _asm push lpdwType
    _asm push lpdwReserved
    _asm push lpszValueName
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryValueEx);
    _asm add  esp, 6*4 
}

VMMREGRET VXDINLINE
VMM_RegSetValueEx(VMMHKEY hkey, PCHAR lpszValueName, DWORD dwReserved, DWORD fdwType, PBYTE lpbData, DWORD cbData)
{
    _asm push cbData
    _asm push lpbData
    _asm push fdwType
    _asm push dwReserved
    _asm push lpszValueName
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegSetValueEx);
    _asm add  esp, 6*4
}

VMMREGRET VXDINLINE
VMM_RegFlushKey(VMMHKEY hkey)
{
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegFlushKey);
    _asm add  esp, 1*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryInfoKey(VMMHKEY hkey, PCHAR lpszClass, PDWORD lpcchClass,PDWORD lpdwReserved, PDWORD lpcSubKeys, PDWORD lpcchMaxSubKey, PDWORD lpcchMaxClass, 
PDWORD lpcValues, PDWORD lpcchMaxValueName, PDWORD lpcbMaxValueData,PDWORD lpcbSecurityDesc, PDWORD lpftLastWriteTime)
{
    _asm push lpftLastWriteTime
    _asm push lpcbSecurityDesc
    _asm push lpcbMaxValueData
    _asm push lpcchMaxValueName
    _asm push lpcValues
    _asm push lpcchMaxClass
    _asm push lpcchMaxSubKey
    _asm push lpcSubKeys
    _asm push lpdwReserved
    _asm push lpcchClass
    _asm push lpszClass
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryInfoKey);
    _asm add  esp, 12*4 
}

#endif	// WANTVXDWRAPS

#pragma warning (default:4035)		// turn on no return code warning

#endif // WIN31COMPAT

#endif // Not_VxD

/*XLATON*/

/* ASM
;**************************************************************
; Macros for Realmode loader registry Services
;
;**************************************************************
LDR_RegOpenKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey		; lphKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegOpenKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4		; for 3 parameters on stack
ENDM
;**************************************************************
LDR_RegCloseKey	Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegCloseKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4		; for 1 parameter on stack
ENDM
;**************************************************************
LDR_RegCreateKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey		; lphKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegCreateKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4		; for 3 parameters on stack
ENDM
;**************************************************************
LDR_RegDeleteKey	Macro	hKey,OffSubKey,SegSubKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegDeleteKey
	call	dword ptr [_ServiceEntry]
	add	sp,2*4		; for 2 parameters on stack
ENDM
;**************************************************************
LDR_RegEnumKey	Macro	hKey,iSubKey,OffszName,SegszName,BufLen
	push	dword ptr BufLen
	push	SegszName
	push	OffszName
	push	dword ptr iSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegEnumKey
	call	dword ptr [_ServiceEntry]
	add	sp,4*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegQueryValue	Macro	hKey,OffSubKey,SegSubKey,OffValue,SegValue,OffcbValue,SegcbValue
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValue
	call	dword ptr [_ServiceEntry]
	add	sp,4*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegSetValue	Macro	hKey,OffSubKey,SegSubKey,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValue
	call	dword ptr [_ServiceEntry]
	add	sp,5*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegDeleteValue	Macro	hKey,OffValue,SegValue
	push	SegValue
	push	OffValue		; lpszValue
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegDeleteValue
	call	dword ptr [_ServiceEntry]
	add	sp,2*4		; for 2 parameters on stack
ENDM
;**************************************************************
LDR_RegEnumValue	Macro hKey,iValue,OffValue,SegValue,OffcbValue,SegcbValue,RegReserved,OffdwType,SegdwType,OffData,SegData,OffcbData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	dword ptr iValue
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegEnumValue
	call	dword ptr [_ServiceEntry]
	add	sp,8*4		; for 8 parameters on stack
ENDM
;**************************************************************
LDR_RegQueryValueEx	Macro	hKey,OffValue,SegValue,RegReserved,OffdwType,SegdwType,OffData,SegData,OffcbData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4		; for 6 parameters on stack
ENDM
;**************************************************************
LDR_RegSetValueEx	Macro	hKey,OffValue,SegValue,RegReserved,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4		; for 6 parameters on stack
ENDM
;**************************************************************
LDR_RegFlushKey		Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegFlushKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4		; for 1 parameter on stack
ENDM
;**************************************************************
*/
#endif		/* _VMMREG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\win95\vwin32.h ===
/******************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp.  All Rights Reserved, 1989-1995
 *
 *   Title: vwin32.h -
 *
 *   Version:   4.00
 *
 *   Date:  24-May-1993
 *
 ******************************************************************************/

/*INT32*/

#ifndef _VWIN32_H_
#define _VWIN32_H_

// ;BeginInternal
// Note that this ID has been reserved for us in VMM.H

#define VWIN32_DEVICE_ID    0x0002A

#define VWIN32_VER_MAJOR    1
#define VWIN32_VER_MINOR    4

#define THREAD_TYPE_WIN32 VWIN32_DEVICE_ID

// ;EndInternal

#ifndef Not_VxD

/*XLATOFF*/
#define VWIN32_Service  Declare_Service
#define VWIN32_StdCall_Service Declare_SCService
#pragma warning (disable:4003)      // turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VWIN32)

VWIN32_Service  (VWIN32_Get_Version, LOCAL)
VWIN32_Service  (VWIN32_DIOCCompletionRoutine, LOCAL)
VWIN32_Service  (_VWIN32_QueueUserApc)
VWIN32_Service  (_VWIN32_Get_Thread_Context)
VWIN32_Service  (_VWIN32_Set_Thread_Context)
VWIN32_Service  (_VWIN32_CopyMem, LOCAL)
VWIN32_Service  (_VWIN32_Npx_Exception)
VWIN32_Service  (_VWIN32_Emulate_Npx)
VWIN32_Service  (_VWIN32_CheckDelayedNpxTrap)
VWIN32_Service  (VWIN32_EnterCrstR0)
VWIN32_Service  (VWIN32_LeaveCrstR0)
VWIN32_Service  (_VWIN32_FaultPopup)
VWIN32_Service  (VWIN32_GetContextHandle)
VWIN32_Service  (VWIN32_GetCurrentProcessHandle, LOCAL)
VWIN32_Service  (_VWIN32_SetWin32Event)
VWIN32_Service  (_VWIN32_PulseWin32Event)
VWIN32_Service  (_VWIN32_ResetWin32Event)
VWIN32_Service  (_VWIN32_WaitSingleObject)
VWIN32_Service  (_VWIN32_WaitMultipleObjects)
VWIN32_Service  (_VWIN32_CreateRing0Thread)
VWIN32_Service  (_VWIN32_CloseVxDHandle)
VWIN32_Service  (VWIN32_ActiveTimeBiasSet, LOCAL)
VWIN32_Service  (VWIN32_GetCurrentDirectory, LOCAL)
VWIN32_Service  (VWIN32_BlueScreenPopup)
VWIN32_Service  (VWIN32_TerminateApp)
VWIN32_Service  (_VWIN32_QueueKernelAPC)
VWIN32_Service  (VWIN32_SysErrorBox)
VWIN32_Service  (_VWIN32_IsClientWin32)
VWIN32_Service  (VWIN32_IFSRIPWhenLev2Taken, LOCAL)
VWIN32_Service  (_VWIN32_InitWin32Event)
VWIN32_Service  (_VWIN32_InitWin32Mutex)
VWIN32_Service  (_VWIN32_ReleaseWin32Mutex)
VWIN32_Service  (_VWIN32_BlockThreadEx)
VWIN32_Service  (VWIN32_GetProcessHandle, LOCAL)
VWIN32_Service  (_VWIN32_InitWin32Semaphore)
VWIN32_Service  (_VWIN32_SignalWin32Sem)
VWIN32_Service  (_VWIN32_QueueUserApcEx)
VWIN32_Service	(_VWIN32_OpenVxDHandle)
VWIN32_Service	(_VWIN32_CloseWin32Handle)
VWIN32_Service	(_VWIN32_AllocExternalHandle)
VWIN32_Service	(_VWIN32_UseExternalHandle)
VWIN32_Service	(_VWIN32_UnuseExternalHandle)
VWIN32_StdCall_Service	(KeInitializeTimer, 1)
VWIN32_StdCall_Service	(KeSetTimer, 4)
VWIN32_StdCall_Service	(KeCancelTimer, 1)
VWIN32_StdCall_Service	(KeReadStateTimer, 1)
VWIN32_Service	(_VWIN32_ReferenceObject)
VWIN32_Service	(_VWIN32_GetExternalHandle)

End_Service_Table(VWIN32)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)      // turn on not enough params warning
/*XLATON*/

#endif // Not_VxD

// ;BeginInternal

// PM API list

#define VWIN32_GET_VER      0
#define VWIN32_THREAD_SWITCH    1   // ECX = wake param, EBX = ring 0 handle
#define VWIN32_DPMI_FAULT   2   // SS:BP = FAULTSTACKFRAME, AL = ignore
#define VWIN32_MMGR_FUNCTIONS   3
#define VWIN32_EVENT_CREATE 4
#define VWIN32_EVENT_DESTROY    5
#define VWIN32_EVENT_WAIT   6
#define VWIN32_EVENT_SET    7
#define VWIN32_RealNetx_Info    8
#define VWIN32_THREAD_BOOST_PRI 9
#define VWIN32_WAIT_CRST    10
#define VWIN32_WAKE_CRST    11
#define VWIN32_SET_FAULT_INFO   12
#define VWIN32_EXIT_TIME    13
#define VWIN32_BOOST_THREAD_GROUP 14
#define VWIN32_BOOST_THREAD_STATIC 15
#define VWIN32_WAKE_IDLE_SYS    16
#define VWIN32_MAKE_IDLE_SYS    17
#define VWIN32_DELIVER_PENDING_KERNEL_APCS 18
#define VWIN32_SYS_ERROR_BOX    19
#define VWIN32_GET_IFSMGR_XLAT_PTR 20
#define VWIN32_BOOST_THREAD_DECAY 21
#define VWIN32_LAST_CMD     21

#define VWIN32_MMGR_RESERVE ((VWIN32_MMGR_FUNCTIONS << 8) + 0)
#define VWIN32_MMGR_COMMIT  ((VWIN32_MMGR_FUNCTIONS << 8) + 1)
#define VWIN32_MMGR_DECOMMIT    ((VWIN32_MMGR_FUNCTIONS << 8) + 2)
#define VWIN32_MMGR_PAGEFREE    ((VWIN32_MMGR_FUNCTIONS << 8) + 3)

//
// Current Win32 thread/process handles.
//
// Updated every context switch.
//

typedef struct _K32CURRENT {
    DWORD   CurThreadHandle;    // win32 thread handle
    DWORD   CurProcessHandle;   // win32 process handle
    DWORD   CurTDBX;        // current TDBX
    DWORD   pCurK16Task;        // flat pointer to kernel 16 CurTDB
    DWORD   CurContextHandle;   // win32 memory context handle
} K32CURRENT;

//
// Flag values for CreateThread
//
#define VWIN32_CT_EMULATE_NPX   0x01    // set EM bit in CR0 for thread
#define VWIN32_CT_WIN32_NPX 0x02    // use Win32 FP exception model
#define VWIN32_CT_WIN32     0x04    // thread is Win32 (not Win16)

//
// Return values from VWIN32_CheckDelayedNpxTrap
//
#define CX_RAISE    0       // instruction raises exception
#define CX_IGNORE   1       // instruction ignores exception
#define CX_CLEAR    2       // instruction clears or masks exception

// flags to use for win32 blocking
#define WIN32_BLOCK_FLAGS (BLOCK_FORCE_SVC_INTS+BLOCK_SVC_INTS+BLOCK_THREAD_IDLE+BLOCK_ENABLE_INTS)

//
// Flags for VWIN32_BlueScreenPopup
//

#define VBSP_CANCEL     0x00000001
#define VBSP_DISPLAY_VXD_NAME   0x00000002

//
// Fault stack frame structure
//

typedef struct fsf_s {
    WORD fsf_GS;
    WORD fsf_FS;
    WORD fsf_ES;
    WORD fsf_DS;
    DWORD fsf_EDI;
    DWORD fsf_ESI;
    DWORD fsf_EBP;
    DWORD fsf_locked_ESP;
    DWORD fsf_EBX;
    DWORD fsf_EDX;
    DWORD fsf_ECX;
    DWORD fsf_EAX;
    WORD fsf_num;       // Fault number
    WORD fsf_prev_IP;   // IP of previous fault handler
    WORD fsf_prev_CS;   // CS of previous fault handler
    WORD fsf_ret_IP;    // DPMI fault handler frame follows
    WORD fsf_ret_CS;
    WORD fsf_err_code;
    WORD fsf_faulting_IP;
    WORD fsf_faulting_CS;
    WORD fsf_flags;
    WORD fsf_SP;
    WORD fsf_SS;
} FAULTSTACKFRAME;

typedef FAULTSTACKFRAME *PFAULTSTACKFRAME;

// ;EndInternal

//
// structure for VWIN32_SysErrorBox
//

typedef struct vseb_s {
    DWORD vseb_resp;
    WORD vseb_b3;
    WORD vseb_b2;
    WORD vseb_b1;
    DWORD vseb_pszCaption;
    DWORD vseb_pszText;
} VSEB;

typedef VSEB *PVSEB;

#define SEB_ANSI    0x4000      // ANSI strings if set on vseb_b1
#define SEB_TERMINATE   0x2000      // forces termination if button pressed

// VWIN32_QueueKernelAPC flags

#define KERNEL_APC_IGNORE_MC        0x00000001
#define KERNEL_APC_STATIC       0x00000002
#define KERNEL_APC_WAKE         0x00000004

// for DeviceIOControl support
// On a DeviceIOControl call vWin32 will pass following parameters to
// the Vxd that is specified by hDevice. hDevice is obtained thru an
// earlier call to hDevice = CreateFile("\\.\vxdname", ...);
// ESI = DIOCParams STRUCT (defined below)
typedef struct DIOCParams   {
    DWORD   Internal1;      // ptr to client regs
    DWORD   VMHandle;       // VM handle
    DWORD   Internal2;      // DDB
    DWORD   dwIoControlCode;
    DWORD   lpvInBuffer;
    DWORD   cbInBuffer;
    DWORD   lpvOutBuffer;
    DWORD   cbOutBuffer;
    DWORD   lpcbBytesReturned;
    DWORD   lpoOverlapped;
    DWORD   hDevice;
    DWORD   tagProcess;
} DIOCPARAMETERS;

typedef DIOCPARAMETERS *PDIOCPARAMETERS;

// dwIoControlCode values for vwin32's DeviceIOControl Interface
// all VWIN32_DIOC_DOS_ calls require lpvInBuffer abd lpvOutBuffer to be
// struct * DIOCRegs
#define VWIN32_DIOC_GETVERSION DIOC_GETVERSION
#define VWIN32_DIOC_DOS_IOCTL       1
#define VWIN32_DIOC_DOS_INT25       2
#define VWIN32_DIOC_DOS_INT26       3
#define VWIN32_DIOC_DOS_INT13       4
#define VWIN32_DIOC_SIMCTRLC        5
#define VWIN32_DIOC_DOS_DRIVEINFO   6
#define VWIN32_DIOC_CLOSEHANDLE DIOC_CLOSEHANDLE

// DIOCRegs
// Structure with i386 registers for making DOS_IOCTLS
// vwin32 DIOC handler interprets lpvInBuffer , lpvOutBuffer to be this struc.
// and does the int 21
// reg_flags is valid only for lpvOutBuffer->reg_Flags
typedef struct DIOCRegs {
    DWORD   reg_EBX;
    DWORD   reg_EDX;
    DWORD   reg_ECX;
    DWORD   reg_EAX;
    DWORD   reg_EDI;
    DWORD   reg_ESI;
    DWORD   reg_Flags;      
} DIOC_REGISTERS;

// if we are not included along with winbase.h
#ifndef FILE_FLAG_OVERLAPPED
  // OVERLAPPED structure for DeviceIOCtl VxDs
  typedef struct _OVERLAPPED {
          DWORD O_Internal;
          DWORD O_InternalHigh;
          DWORD O_Offset;
          DWORD O_OffsetHigh;
          HANDLE O_hEvent;
  } OVERLAPPED;
#endif

//  Parameters for _VWIN32_OpenVxDHandle to validate the Win32 handle type.
#define OPENVXD_TYPE_SEMAPHORE  0
#define OPENVXD_TYPE_EVENT      1
#define OPENVXD_TYPE_MUTEX      2
#define	OPENVXD_TYPE_ANY	3
  
// ;BeginInternal
#define OPENVXD_TYPE_MAXIMUM    3
// ;EndInternal

//
//  Object type table declaration for _VWIN32_AllocExternalHandle
//
/*XLATOFF*/
#define R0OBJCALLBACK           __stdcall
typedef VOID    (R0OBJCALLBACK *R0OBJFREE)(PVOID pR0ObjBody);
typedef PVOID   (R0OBJCALLBACK *R0OBJDUP)(PVOID pR0ObjBody, DWORD hDestProc);
/*XLATON*/
/* ASM
R0OBJFREE   TYPEDEF     DWORD
R0OBJDUP    TYPEDEF     DWORD
*/

typedef struct _R0OBJTYPETABLE {
    DWORD       ott_dwSize;             //  sizeof(R0OBJTYPETABLE)
    R0OBJFREE   ott_pfnFree;            //  called by Win32 CloseHandle
    R0OBJDUP    ott_pfnDup;             //  called by Win32 DuplicateHandle
} R0OBJTYPETABLE, *PR0OBJTYPETABLE;
/* ASM
R0OBJTYPETABLE  typedef _R0OBJTYPETABLE;
*/

#define R0EHF_INHERIT   0x00000001      //  Handle is inheritable
#define R0EHF_GLOBAL    0x00000002      //  Handle is valid in all contexts
// ;BeginInternal
#define R0EHF_ALL       (R0EHF_INHERIT | R0EHF_GLOBAL)
// ;EndInternal

// ;BeginInternal

/* ASM

FSF_CLEANUP_RETURN  EQU fsf_ret_IP - fsf_num
FSF_CLEANUP_CHAIN   EQU fsf_prev_IP - fsf_num

K32CURRENT typedef _K32CURRENT

;***LT  W32Fun - macro to make a function callable from Kernel32
;
;   This macro will create a stub of the format that the Ring0/Ring3
;   Win32 calling interface likes.
;   It plays around with the stack so that the arguments are set
;   up right and clean off right and it also sets the ring 3
;   registers to reflect the outcome of the operation.
;
;   This macro is taken from VMM's memory manager, file: mma.asm
;
;   ENTRY:  fun - function name
;       cargs - number of dword arguments it has
;       prefix - prefix for function
;   EXIT:   none
;
;   Note that when the function is called:
;       EBX is the VM handle
;       ESI points to client registers
;       EDI points to the return address
;   THESE REGISTERS MUST NOT BE TRASHED!
;
W32Fun  MACRO   fun, cbargs, prefix

BeginProc   VW32&fun, esp, W32SVC, public
    ArgVar  pcrs,dword
    ArgVar  hvm,dword
    x = 0
    REPT    cbargs
        x = x + 1
        ArgVar  arg&x,dword
    ENDM

    EnterProc
    pop edi     ;Save and remove return address
    pop esi     ;Save and remove client regs
    pop ebx     ;Save and remove hvm

    call    prefix&fun  ;Call function somewhere in VxD
                ;Note that this function may be a C function

    mov [esi].Client_EAX,eax    ;Put return values into client regs

    push    ebx     ;Put hvm back on stack
    push    esi     ;Put client regs back on stack
    push    edi     ;Restore return address

    LeaveProc
    Return
EndProc VW32&fun

ENDM
*/

// ;EndInternal

#endif  // _VWIN32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\win95\vmm.h ===
/*****************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp., 1988-1990
 *
 *   Title: VMM.H - Include file for Virtual Machine Manager
 *
 *   Version:	1.00
 *
 *   Date:  05-May-1988
 *
 *   Author:	RAL
 *
 *-----------------------------------------------------------------------------
 *
 *   Change log:
 *
 *   DATE    REV DESCRIPTION
 *   ----------- --- -----------------------------------------------------------
 *   05-May-1988 RAL Original
 *   13-Nov-1991 PBS C version
 *   17-Dec-1993     Adds Far East VxDs identifiers
 */

#ifndef _VMM_
#define _VMM_


/*
 *  NON Windows/386 Virtual Device sources can include this file to get
 *  some useful equates by declaring the symbol "Not_VxD" If this symbol
 *  is defined, then everything that has to do with the specifics of the
 *  32 bit environment for virtual devices is removed.	Useful equates
 *  include: device ID's, pushad structure, BeginDoc, EndDoc, BeginMsg,
 *  EndMsg, page table equates, etc.
 */

#define FALSE	    0	    // False
#define VMM_TRUE    (~FALSE)	// The opposite of False!

#define DEBLEVELRETAIL	0
#define DEBLEVELNORMAL	1
#define DEBLEVELMAX 2

#ifndef DEBLEVEL
#ifdef DEBUG
#define DEBLEVEL DEBLEVELNORMAL
#else
#define DEBLEVEL DEBLEVELRETAIL
#endif
#endif

#ifndef WIN31COMPAT
#define WIN40SERVICES
#define WIN403SERVICES		/*OPK-3 Services*/
#endif

#ifndef WIN40COMPAT
#define WIN41SERVICES
#endif

/* ASM
ifdef MASM6
ifndef NO_MASM6_OPTIONS
;
;   option switches necessary to build VMM/VxD sources with MASM 6
;
    option oldmacros
ifndef	NEWSTRUCTS	; define NEWSTRUCTS for MASM6 struct semantics
    option oldstructs
endif
    option noscoped
    option segment:flat
    option offset:flat
    option proc:private
endif
endif
;
;   These null macros are recognized by a utility program that produces
;   documentation files.
;
IFDEF MASM6
BeginDoc MACRO
     ENDM
EndDoc MACRO
       ENDM

BeginMsg MACRO
     ENDM
EndMsg MACRO
       ENDM
ELSE
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>
ENDIF
*/


/******************************************************************************
 *
 *	    EQUATES FOR REQUIRED DEVICES
 *
 *   Device ID formulation note:
 *
 *  The high bit of the device ID is reserved for future use.
 *  Microsoft reserves the device ID's 0-1FFh for standard devices.  If
 *  an OEM VxD is a replacement for a standard VxD, then it must use the
 *  standard VxD ID.
 *
 *  OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,
 *  PLEASE CONTACT MICROSOFT PRODUCT SUPPORT.  ID's are only required for
 *  devices which provide services, V86 API's or PM API's.  Also, calling
 *  services or API's by VxD name is now supported in version 4.0, so an
 *  ID may not be necessary as long as a unique 8 character name is used.
 *
 *****************************************************************************/

#define UNDEFINED_DEVICE_ID 0x00000
#define VMM_DEVICE_ID	    0x00001 /* Used for dynalink table */
#define DEBUG_DEVICE_ID     0x00002
#define VPICD_DEVICE_ID     0x00003
#define VDMAD_DEVICE_ID     0x00004
#define VTD_DEVICE_ID	    0x00005
#define V86MMGR_DEVICE_ID   0x00006
#define PAGESWAP_DEVICE_ID  0x00007
#define PARITY_DEVICE_ID    0x00008
#define REBOOT_DEVICE_ID    0x00009
#define VDD_DEVICE_ID	    0x0000A
#define VSD_DEVICE_ID	    0x0000B
#define VMD_DEVICE_ID	    0x0000C
#define VKD_DEVICE_ID	    0x0000D
#define VCD_DEVICE_ID	    0x0000E
#define VPD_DEVICE_ID	    0x0000F
#define BLOCKDEV_DEVICE_ID  0x00010
#define VMCPD_DEVICE_ID     0x00011
#define EBIOS_DEVICE_ID     0x00012
#define BIOSXLAT_DEVICE_ID  0x00013
#define VNETBIOS_DEVICE_ID  0x00014
#define DOSMGR_DEVICE_ID    0x00015
#define WINLOAD_DEVICE_ID   0x00016
#define SHELL_DEVICE_ID     0x00017
#define VMPOLL_DEVICE_ID    0x00018
#define VPROD_DEVICE_ID     0x00019
#define DOSNET_DEVICE_ID    0x0001A
#define VFD_DEVICE_ID	    0x0001B
#define VDD2_DEVICE_ID	    0x0001C /* Secondary display adapter */
#define WINDEBUG_DEVICE_ID  0x0001D
#define TSRLOAD_DEVICE_ID   0x0001E /* TSR instance utility ID */
#define BIOSHOOK_DEVICE_ID  0x0001F /* Bios interrupt hooker VxD */
#define INT13_DEVICE_ID     0x00020
#define PAGEFILE_DEVICE_ID  0x00021 /* Paging File device */
#define SCSI_DEVICE_ID	    0x00022 /* SCSI device */
#define MCA_POS_DEVICE_ID   0x00023 /* MCA_POS device */
#define SCSIFD_DEVICE_ID    0x00024 /* SCSI FastDisk device */
#define VPEND_DEVICE_ID     0x00025 /* Pen device */
#define APM_DEVICE_ID	    0x00026 /* Power Management device */
#define VPOWERD_DEVICE_ID   APM_DEVICE_ID   /* We overload APM since we replace it */
#define VXDLDR_DEVICE_ID    0x00027 /* VxD Loader device */
#define NDIS_DEVICE_ID	    0x00028 /* NDIS wrapper */
#define BIOS_EXT_DEVICE_ID   0x00029 /* Fix Broken BIOS device */
#define VWIN32_DEVICE_ID	0x0002A /* for new WIN32-VxD */
#define VCOMM_DEVICE_ID 	0x0002B /* New COMM device driver */
#define SPOOLER_DEVICE_ID	0x0002C /* Local Spooler */
#define WIN32S_DEVICE_ID    0x0002D /* Win32S on Win 3.1 driver */
#define DEBUGCMD_DEVICE_ID	0x0002E /* Debug command extensions */
/* #define RESERVED_DEVICE_ID	0x0002F /* Not currently in use */
/* #define ATI_HELPER_DEVICE_ID    0x00030 /* grabbed by ATI */

/* 31-32 USED BY WFW NET COMPONENTS	*/
/* #define VNB_DEVICE_ID	   0x00031 /* Netbeui of snowball */
/* #define SERVER_DEVICE_ID	   0x00032 /* Server of snowball */

#define CONFIGMG_DEVICE_ID  0x00033 /* Configuration manager (Plug&Play) */
#define DWCFGMG_DEVICE_ID   0x00034 /* Configuration manager for win31 and DOS */
#define SCSIPORT_DEVICE_ID  0x00035 /* Dragon miniport loader/driver */
#define VFBACKUP_DEVICE_ID  0x00036 /* allows backup apps to work with NEC */
#define ENABLE_DEVICE_ID    0x00037 /* for access VxD */
#define VCOND_DEVICE_ID     0x00038 /* Virtual Console Device - check vcond.inc */
/* 39 used by WFW VFat Helper device */

/* 3A used by WFW E-FAX */
/* #define EFAX_DEVICE_ID   0x0003A /* EFAX VxD ID	*/

/* 3B used by MS-DOS 6.1 for the DblSpace VxD which has APIs */
/* #define DSVXD_DEVICE_ID  0x0003B /* Dbl Space VxD ID */

#define ISAPNP_DEVICE_ID    0x0003C /* ISA P&P Enumerator */
#define BIOS_DEVICE_ID	    0x0003D /* BIOS P&P Enumerator */
/* #define WINSOCK_DEVICE_ID	   0x0003E  /* WinSockets */
/* #define WSIPX_DEVICE_ID     0x0003F	/* WinSockets for IPX */

#define IFSMgr_Device_ID    0x00040 /* Installable File System Manager */
#define VCDFSD_DEVICE_ID    0x00041 /* Static CDFS ID */
#define MRCI2_DEVICE_ID     0x00042 /* DrvSpace compression engine */
#define PCI_DEVICE_ID	    0x00043 /* PCI P&P Enumerator */
#define PELOADER_DEVICE_ID  0x00044 /* PE Image Loader */
#define EISA_DEVICE_ID	    0x00045 /* EISA P&P Enumerator */
#define DRAGCLI_DEVICE_ID   0x00046 /* Dragon network client */
#define DRAGSRV_DEVICE_ID   0x00047 /* Dragon network server */
#define PERF_DEVICE_ID	    0x00048 /* Config/stat info */

#define AWREDIR_DEVICE_ID   0x00049 /* AtWork Network FSD */
#define DDS_DEVICE_ID	    0x0004A /* Device driver services */
#define NTKERN_DEVICE_ID    0x0004B /* NT kernel device id */
#define VDOSKEYD_DEVICE_ID  0x0004B /* DOSKEY device id */

/*
 *   Far East DOS support VxD ID
 */

#define ETEN_Device_ID	    0x00060 /* ETEN DOS (Taiwan) driver */
#define CHBIOS_Device_ID    0x00061 /* CHBIOS DOS (Korean) driver */
#define VMSGD_Device_ID    0x00062 /* DBCS Message Mode driver */
#define VPPID_Device_ID     0x00063 /* PC-98 System Control PPI */
#define VIME_Device_ID	    0x00064 /* Virtual DOS IME */
#define VHBIOSD_Device_ID   0x00065 /* HBIOS (Korean) for HWin31 driver */

#define BASEID_FOR_NAMEBASEDVXD        0xf000 /* Name based VxD IDs start here */
#define BASEID_FOR_NAMEBASEDVXD_MASK   0x0fff /* Mask to get the real vxd id */
/*
 *   Initialization order equates.  Devices are initialized in order from
 *   LOWEST to HIGHEST. If 2 or more devices have the same initialization
 *   order value, then they are initialized in order of occurance, so a
 *   specific order is not guaranteed.	Holes have been left to allow maximum
 *   flexibility in ordering devices.
 */

#define VMM_INIT_ORDER	    0x000000000
#define DEBUG_INIT_ORDER    0x000000000 /* normally using 0 is bad */
#define DEBUGCMD_INIT_ORDER	0x000000000 /*	but debug must be first */
#define PERF_INIT_ORDER     0x000900000
#define APM_INIT_ORDER		0x001000000
#define VPOWERD_INIT_ORDER  APM_INIT_ORDER  /* We overload APM since we replace it */
#define BIOSHOOK_INIT_ORDER 0x006000000
#define VPROD_INIT_ORDER    0x008000000
#define VPICD_INIT_ORDER    0x00C000000
#define VTD_INIT_ORDER	    0x014000000
#define VWIN32_INIT_ORDER   0x014100000
#define NTKERN_INIT_ORDER   0x015000000 /* Must be before VxDLdr (so that it is ready for devnodes) */
#define VXDLDR_INIT_ORDER   0x016000000

#define ENUMERATOR_INIT_ORDER	0x016800000 /* Should be before IOS */
#define ISAPNP_INIT_ORDER   ENUMERATOR_INIT_ORDER
#define EISA_INIT_ORDER     ENUMERATOR_INIT_ORDER
#define PCI_INIT_ORDER	    ENUMERATOR_INIT_ORDER
#define BIOS_INIT_ORDER     ENUMERATOR_INIT_ORDER+1 /* To simplify reenumeration */
#define CONFIGMG_INIT_ORDER ENUMERATOR_INIT_ORDER+0xFFFF    /* After all enumerators */

#define VCDFSD_INIT_ORDER   0x016F00000
#define IOS_INIT_ORDER	    0x017000000
#define PAGEFILE_INIT_ORDER 0x018000000
#define PAGESWAP_INIT_ORDER 0x01C000000
#define PARITY_INIT_ORDER   0x020000000
#define REBOOT_INIT_ORDER   0x024000000
#define EBIOS_INIT_ORDER    0x026000000
#define VDD_INIT_ORDER	    0x028000000
#define VSD_INIT_ORDER	    0x02C000000

#define VCD_INIT_ORDER	    0x030000000
#define COMMDRVR_INIT_ORDER (VCD_INIT_ORDER - 1)
#define PRTCL_INIT_ORDER    (COMMDRVR_INIT_ORDER - 2)
#define MODEM_INIT_ORDER    (COMMDRVR_INIT_ORDER - 3)
#define PORT_INIT_ORDER     (COMMDRVR_INIT_ORDER - 4)

#define VMD_INIT_ORDER	    0x034000000
#define VKD_INIT_ORDER	    0x038000000
#define VPD_INIT_ORDER	    0x03C000000
#define BLOCKDEV_INIT_ORDER 0x040000000
#define MCA_POS_INIT_ORDER  0x041000000
#define SCSIFD_INIT_ORDER   0x041400000
#define SCSIMASTER_INIT_ORDER	0x041800000
#define INT13_INIT_ORDER    0x042000000
#define VMCPD_INIT_ORDER    0x048000000
#define BIOSXLAT_INIT_ORDER 0x050000000
#define VNETBIOS_INIT_ORDER 0x054000000
#define DOSMGR_INIT_ORDER   0x058000000
#define DOSNET_INIT_ORDER   0x05C000000
#define WINLOAD_INIT_ORDER  0x060000000
#define VMPOLL_INIT_ORDER   0x064000000

#define UNDEFINED_INIT_ORDER	0x080000000
#define VCOND_INIT_ORDER    UNDEFINED_INIT_ORDER

#define WINDEBUG_INIT_ORDER 0x081000000
#define VDMAD_INIT_ORDER    0x090000000
#define V86MMGR_INIT_ORDER  0x0A0000000

#define IFSMgr_Init_Order   0x10000 + V86MMGR_Init_Order
#define FSD_Init_Order	    0x00100 + IFSMgr_Init_Order
#define VFD_INIT_ORDER	    0x50000 + IFSMgr_Init_Order

/* Device that must touch memory in 1st Mb at crit init (after V86mmgr) */
#define UNDEF_TOUCH_MEM_INIT_ORDER  0x0A8000000
#define SHELL_INIT_ORDER    0x0B0000000

/* ASM
;******************************************************************************
;
;   Macro to cause a delay in between I/O accesses to the same device.
;
;------------------------------------------------------------------------------

IO_Delay    macro
jmp $+2
ENDM
*/

#define VXD_FAILURE 0
#define VXD_SUCCESS 1

typedef ULONG HVM;	    /* VM handle typedef */

/*
 *  Registers as they appear on the stack after a PUSHAD.
 */

struct Pushad_Struc {
    ULONG Pushad_EDI;		/* Client's EDI */
    ULONG Pushad_ESI;		/* Client's ESI */
    ULONG Pushad_EBP;		/* Client's EBP */
    ULONG Pushad_ESP;		/* ESP before pushad */
    ULONG Pushad_EBX;		/* Client's EBX */
    ULONG Pushad_EDX;		/* Client's EDX */
    ULONG Pushad_ECX;		/* Client's ECX */
    ULONG Pushad_EAX;		/* Client's EAX */
};

/* XLATOFF */

#ifdef RC_INVOKED
#define NOBASEDEFS
#endif

#ifndef NOBASEDEFS

#pragma warning (disable:4209)	// turn off redefinition warning

typedef unsigned char	UCHAR;
typedef unsigned short	USHORT;

#pragma warning (default:4209)	// turn off redefinition warning

#endif

#define GetVxDServiceOrdinal(service)	__##service

#define Begin_Service_Table(device, seg) \
    enum device##_SERVICES { \
    device##_dummy = (device##_DEVICE_ID << 16) - 1,

#define Declare_Service(service, local) \
    GetVxDServiceOrdinal(service),

#define Declare_SCService(service, args, local) \
    GetVxDServiceOrdinal(service),

#define End_Service_Table(device, seg) \
    Num_##device##_Services};

#define VXDINLINE static __inline
/* XLATON */

#ifndef Not_VxD

/* XLATOFF */
#define VxD_LOCKED_CODE_SEG code_seg("_LTEXT", "LCODE")
#define VxD_LOCKED_DATA_SEG data_seg("_LDATA", "LCODE")
#define VxD_INIT_CODE_SEG   code_seg("_ITEXT", "ICODE")
#define VxD_INIT_DATA_SEG   data_seg("_IDATA", "ICODE")
#define VxD_ICODE_SEG	    code_seg("_ITEXT", "ICODE")
#define VxD_IDATA_SEG	    data_seg("_IDATA", "ICODE")
#define VxD_PAGEABLE_CODE_SEG	code_seg("_PTEXT", "PCODE")
#define VxD_PAGEABLE_DATA_SEG	data_seg("_PDATA", "PDATA")
#define VxD_STATIC_CODE_SEG code_seg("_STEXT", "SCODE")
#define VxD_STATIC_DATA_SEG data_seg("_SDATA", "SCODE")
#define VxD_DEBUG_ONLY_CODE_SEG code_seg("_DBOCODE", "DBOCODE")
#define VxD_DEBUG_ONLY_DATA_SEG data_seg("_DBODATA", "DBOCODE")

#define VxD_SYSEXIT_CODE_SEG	code_seg("SYSEXIT", "SYSEXITCODE")
#define VxD_INT21_CODE_SEG  code_seg("INT21", "INT21CODE")
#define VxD_RARE_CODE_SEG   code_seg("RARE", "RARECODE")
#define VxD_W16_CODE_SEG    code_seg("W16", "W16CODE")
#define VxD_W32_CODE_SEG    code_seg("W32", "W32CODE")
#define VxD_VMCREATE_CODE_SEG	code_seg("VMCREATE", "VMCREATECODE")
#define VxD_VMDESTROY_CODE_SEG	code_seg("VMDESTROY", "VMDESTROYCODE")
#define VxD_THCREATE_CODE_SEG	code_seg("THCREATE", "THCREATECODE")
#define VxD_THDESTROY_CODE_SEG	code_seg("THDESTROY", "THDESTROYCODE")
#define VxD_VMSUSPEND_CODE_SEG	code_seg("VMSUSPEND", "VMSUSPENDCODE")
#define VxD_VMRESUME_CODE_SEG	code_seg("VMRESUME", "VMRESUMECODE")
#define VxD_PNP_CODE_SEG    code_seg("PNP", "PNPCODE")
#define VxD_DOSVM_CODE_SEG  code_seg("DOSVM", "DOSVMCODE")
#define VxD_LOCKABLE_CODE_SEG	code_seg("LOCKABLE", "LOCKABLECODE")
/* XLATON */

/* ASM
??_CUR_CODE_SEG = 0

??_LCODE    =	1
??_ICODE    =	2
??_PCODE    =	3
??_SCODE    =	4
??_DBOCODE  =	5
??_16ICODE  =	6
??_RCODE    =	7
??_LOCKABLECODE =   8

?_LCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_LCODE>
?_ICODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_ICODE>
?_PCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_PCODE>
?_SCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_SCODE>
?_DBOCODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_DBOCODE>
?_16ICODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_16ICODE>
?_RCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_RCODE>
?_LOCKABLECODE	equ <(??_CUR_CODE_SEG MOD 16) - ??_LOCKABLECODE>

ifndef NO_SEGMENTS

;
;  SEGMENT definitions and order
;

IFDEF	MASM6
_FLAT	EQU FLAT
ELSE
_FLAT	EQU USE32
ENDIF

;*  32 bit locked code
_LTEXT	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LTEXT	    ENDS

_TEXT	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TEXT	    ENDS

;*  32 bit pageable code
_PTEXT	    SEGMENT DWORD PUBLIC _FLAT 'PCODE'
_PTEXT	    ENDS



MakeCodeSeg MACRO seglist, classname, grpname, iseg

    IRP segname,<seglist>   ;; For each name in the list

IFNB	<classname>
    segname	SEGMENT DWORD PUBLIC _FLAT "&classname&CODE"
ELSE
    segname	SEGMENT DWORD PUBLIC _FLAT "&segname&CODE"
ENDIF

IFB <iseg>
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM
ELSE
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + iseg
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM
ENDIF

VxD_&&segname&&_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
segname ENDS
	ENDM

segname     ENDS

IFNDEF BLD_COFF
IFNB	<grpname>
    _&grpname GROUP segname
ELSE
    _&&segname GROUP segname
ENDIF
ENDIF

    ENDM		;; End for each segment

    ENDM

MakeCodeSeg <LOCKABLE_BEGIN, LOCKABLE, LOCKABLE_END>, \
    LOCKABLE, LOCKABLE, ??_LOCKABLECODE
MakeCodeSeg INT21
MakeCodeSeg SYSEXIT
MakeCodeSeg RARE
MakeCodeSeg W16
MakeCodeSeg W32
MakeCodeSeg VMCREATE
MakeCodeSeg VMDESTROY
MakeCodeSeg THCREATE
MakeCodeSeg THDESTROY
MakeCodeSeg VMSUSPEND
MakeCodeSeg VMRESUME
MakeCodeSeg PNP
MakeCodeSeg DOSVM


;***	DefLockableCodeBegin - define beginning of lockable code
;
;   Defines a label with the given name to mark the beginning
;   of the lockable code area for this VxD.  In the debug version,
;   also defines a DWORD containing DFS_TEST_BLOCK so that
;   procedures in the lockable code segment defined with
;   BeginProc may call _Debug_Flags_Service with flags appropriate
;   to the code's current state.

DefLockableCodeBegin MACRO name, private
VxD_LOCKABLE_BEGIN_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name	LABEL	NEAR
VxD_LOCKABLE_BEGIN_CODE_ENDS
ifndef WIN31COMPAT
if DEBLEVEL
VxD_LOCKED_DATA_SEG
    PUBLIC name&_Debug_Flags
name&_Debug_Flags DD DFS_TEST_BLOCK
VxD_LOCKED_DATA_ENDS
??_debug_flags equ <name&_Debug_Flags>
endif
endif
    ENDM

;***	DefLockableCodeEnd - define end of lockable code
;
;   Defines a label with the given name to mark the end
;   of the lockable code area for this VxD.  By subtracting
;   the offset of the beginning label from the offset of
;   the ending label, the VxD may determine how many bytes
;   of memory to lock or unlock.

DefLockableCodeEnd MACRO name, private
VxD_LOCKABLE_END_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name	LABEL	NEAR
VxD_LOCKABLE_END_CODE_ENDS
    ENDM

;***	CodeLockFlags - declare locked code debug flags
;
;   This macro declares the locked code debug flags.

CodeLockFlags MACRO name
ifndef WIN31COMPAT
if DEBLEVEL
    ifndef name&_Debug_Flags
    VxD_LOCKED_DATA_SEG
	extrn	name&_Debug_Flags:dword
    VxD_LOCKED_DATA_ENDS
    ??_debug_flags equ <name&_Debug_Flags>
    endif
endif
endif
    ENDM

;***	MarkCodeLocked - signify that lockable code is locked
;
;   This macro clears DFS_TEST_BLOCK in the debug flags
;   DWORD.

MarkCodeLocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    and ??_debug_flags,NOT DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM

;***	MarkCodeUnlocked - signify that lockable code is unlocked
;
;   This macro sets DFS_TEST_BLOCK in the debug flags
;   DWORD.

MarkCodeUnlocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    or	??_debug_flags,DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM


;*  32 bit initialization code
_ITEXT	    SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_ITEXT	    ENDS

;*  32 bit locked data
_LDATA	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LDATA	    ENDS

_DATA	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_DATA	    ENDS

;*  32 bit pageable data
_PDATA	    SEGMENT DWORD PUBLIC _FLAT 'PDATA'
_PDATA	    ENDS

;*  32 Bit initialization data
_IDATA	    SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_IDATA	    ENDS

;*  Created by C8
_BSS	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_BSS	    ENDS

CONST	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
CONST	    ENDS

_TLS	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TLS	    ENDS

;*  32 Bit static code for DL-VxDs
_STEXT	    SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_STEXT	    ENDS

;*  32 Bit static data for DL-VxDs
_SDATA	    SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_SDATA	    ENDS

;*	dummy segment for IsDebugOnlyLoaded
_DBOSTART   SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOSTART   ENDS

;*	32 bit debug only code; loaded only if debugger is present
_DBOCODE    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOCODE    ENDS

;*	32 bit debug only data; loaded only if debugger is present
_DBODATA    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBODATA    ENDS

if DEBLEVEL
;*  Start of 32 bit path coverage data
_PATHSTART  SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHSTART  ENDS

;*  32 bit path coverage data
_PATHDATA   SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHDATA   ENDS

;*  End of 32 bit path coverage data
_PATHEND    SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHEND    ENDS
endif

;*  16 bit code/data that is put into IGROUP automaticly
_16ICODE    SEGMENT WORD USE16 PUBLIC '16ICODE'
_16ICODE    ENDS

;*  Real Mode initialization code/data for devices
_RCODE	    SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE	    ENDS

IFNDEF BLD_COFF
_LGROUP   GROUP _LTEXT, _TEXT, _LDATA, _DATA, _BSS, CONST, _TLS
_IGROUP   GROUP _ITEXT, _IDATA
_SGROUP   GROUP _STEXT, _SDATA
_DBOGROUP GROUP _DBOSTART, _DBOCODE, _DBODATA
IF DEBLEVEL
_PGROUP   GROUP _PATHSTART, _PATHDATA, _PATHEND
ENDIF
ENDIF

endif ; NO_SEGMENTS

    ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT

OFFSET32 EQU <OFFSET FLAT:>


BeginDoc
;==============================================================================
; The following macros are used in defining the routines
;   in a VxD which are going to be registered with VMM as callable entry
;   points. Once registered, the entry points can be called by any other
;   devices via the "VxDCall" macro, defined below. In the comments below,
;   replace "VxD" with the appropriate device name.
;
;*******
;   In the VxD.INC file, put the following lines, replacing <function_name>
;   with an appropriate name describing the function of the routine.
;
;   Begin_Service_Table VxD[,<segname>]
;   VxD_Service <function_name>[,<local segname>]
;   VxD_Service <function_name>[,<local segname>]
;	. . .
;   VxD_Service <function_name>[,<local segname>]
;   End_Service_Table	VxD[,<segname>]
;
;   Note that <segname> is an optional argument and, if specified, the
;   table is put in the segment defined by the macro "yyy_Data_Seg",
;   where yyy=segname. Otherwise the segment is defined by the
;   "VxD_Data_Seg" macro, defined below.
;   Note that <local segname> is an optional argument and, if specified,
;   the procedure's segment is defined by the macro "zzz_Code_Seg",
;   where zzz=segname. Otherwise the segment is defined by the
;   "VxD_Code_Seg" macro, defined below.
;
;*******
; One VxD module should have the following in order to define the entry points:
;Create_VxD_Service_Table = 1		; Only in module where table is
;   INCLUDE	VxD.INC 	; Include the table definition
;
;*******
; All modules that want to call the services defined in the table should include
;   VxD.INC, but not define the label "Create_VxD_Service_Table". This
;   will define the service names to be used with the VxDCall macro.
;
EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment

IFDEF	Device_Name&_Name_Based
 IFNDEF @@NextInternalID
    @@NextInternalID	= 0
 ENDIF
 @@NextInternalID = (@@NextInternalID + 1)
 Device_Name&_Internal_ID   = @@NextInternalID + BASEID_FOR_NAMEBASEDVXD
 DefineVxDName	Device_Name, %Device_Name&_Internal_ID
ENDIF

IFB <Def_Segment>
    BST2 Device_Name, VxD
ELSE
    BST2 Device_Name, Def_Segment
ENDIF
    ENDM

DefineVxDName	MACRO Device_Name, InternalID
 @@VxDName&InternalID EQU   <___&Device_Name&STable>
ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table


Def_Segment&_LOCKED_DATA_SEG

Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg, Condition, StdCallBytes, fastcall
LOCAL $$&Procedure, extrnproc, tableproc

  extrnproc MACRO
    IFNB <fastcall>
      IFB <StdCallBytes>
	.err	;StdCallBytes required
      ENDIF
      EXTRN @&&Procedure&&@&&StdCallBytes:NEAR
    ELSE
      IFNB <StdCallBytes>
	EXTRN _&&Procedure&&@&&StdCallBytes:NEAR
      ELSE
	EXTRN Procedure:NEAR
      ENDIF
    ENDIF
    ENDM

  tableproc MACRO
    IFNB <fastcall>
      dd  OFFSET32 @&&Procedure&&@&&StdCallBytes
    ELSE
      IFNB <StdCallBytes>
	dd  OFFSET32 _&&Procedure&&@&&StdCallBytes
      ELSE
	dd  OFFSET32 Procedure
      ENDIF
    ENDIF
    ENDM

  IFNB <Condition>
  $$&&Procedure MACRO extern
    IFDEF &Condition
      IFNB <extern>
	extrnproc
      ELSE
	tableproc
      ENDIF
    ELSE
      IFB <extern>
      dd      0
      ENDIF
    ENDIF
    ENDM
  ENDIF

  IFDIFI <Procedure>, <RESERVED>
    PUBLIC _&&Procedure
     IF1
    _&&Procedure LABEL DWORD
     IFNB <fastcall>
    PUBLIC __&&Procedure
     __&&Procedure LABEL DWORD
     ENDIF
     ENDIF
     IFDIFI <Local_Seg>, <LOCAL>
	IFNB <Local_Seg>
Local_Seg&&_SEG
       ELSE
Def_Segment&_CODE_SEG
	ENDIF
	IFNB <Condition>
    $$&&Procedure extern
       ELSE
	extrnproc
	ENDIF
	IFNB <Local_Seg>
Local_Seg&&_ENDS
	ELSE
Def_Segment&_CODE_ENDS
	ENDIF
     ENDIF
      IFNB <Condition>
    $$&&Procedure
      ELSE
	tableproc
      ENDIF

	  IFDEF Device_Name&_Name_Based
	@@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
	  ELSE
	@@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
	  ENDIF
  ELSE
    dd	0
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
  IFNB <Condition>
    Purge $$&&Procedure
  ENDIF
    Purge extrnproc
    Purge tableproc
    ENDM

  Device_Name&_StdCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition, %Args*4
    ??_standardccall&&_Procedure = Args
    ENDM

  Device_Name&_FastCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition, %Args*4, TRUE
    ??_fastcall&&_Procedure = Args
    ENDM

ELSE

; Local_Seg and Condition are placeholders only in this form

IFDEF	Device_Name&_Name_Based

Device_Name&_Service MACRO Procedure, Local_Seg, Condition


  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ELSE

Device_Name&_Service MACRO Procedure, Local_Seg, Condition

  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM

ENDIF

  Device_Name&_StdCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition
    ??_standardccall_&&Procedure = Args
    ENDM

  Device_Name&_FastCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition
    ??_fastcall_&&Procedure = Args
    ENDM

ENDIF

    ENDM


;------------------------------------------------------------------------------

End_Service_Table MACRO Device_Name, Def_Segment

    PURGE   Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table

IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF

ENDIF

    ENDM

GetVxDServiceOrdinal	macro	reg,service
    mov reg,@@&service
    endm

GetVxDServiceAddress	macro	reg,service
    mov reg,OFFSET32 service
    endm


;***	Begin_Win32_Services - begin defining Win32 Service Table
;
;   This macro is used to begin the definition of the Win32
;   Service table.  It is modelled after, but not identical
;   to, the Begin_Service_Table macro.	If the the special
;   symbol Create_Win32_Services is defined to be true, then
;   the actual table is emitted.  Otherwise, only the service
;   numbers are defined.
;
;   ENTRY   VxDName	- the name of the VxD; it is assumed
;		  that a corresponding Device_ID is
;		  also defined.
;   EXIT    The macro VxDName&_Win32_Sevice is defined; it
;	accepts a service name as its only parameter.
;	This macro is then used to define each service.

Begin_Win32_Services MACRO VxDName
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
    .errb <VxDName>, <VxD name missing>
    ??w32svcno = 0
if Create_Win32_Services
VxDName&_Win32_Services label dword
    dd	csvc&VxDName, 0
endif
    ??inw32svc = 1

    VxDName&_Win32_Service MACRO Name
	.erre ??inw32svc, <Missing Begin_Win32_Services>
    if Create_Win32_Services
	dd  OFFSET32 Name,cparm&&Name
    endif
	@32&&Name equ	((VxDName&_Device_ID SHL 16) + ??w32svcno)
	??w32svcno = ??w32svcno + 1
	ENDM
    ENDM


;***	End_Win32_Services - mark end of Win32 Service Table
;
;   This macro completes initialization of the Win32
;   Service table.
;
;   ENTRY   VxDName	- the same name passed to
;		  Begin_Win32_services

End_Win32_Services MACRO VxDName
    .errb <VxDName>, <VxD name misssing>
if Create_Win32_Services
    csvc&VxDName    equ ($ - VxDName&_Win32_Services)/8 - 1
endif
    ??inw32svc = 0
    PURGE VxDName&_Win32_Service
    ENDM


;***	Declare_Win32_Service - declare an external Win32 Service
;
;   This macro is used to declare a Win32 service that
;   is defined elsewhere, perhaps in a C module.
;
;   ENTRY   Name	- the service name
;	cParms	    - the number of DWORD parameters
;   EXIT    The name is defined as external

Declare_Win32_Service MACRO Name, cParms
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
if Create_Win32_Services
    ?merge  <Name>,,,,<EQU>,<_>,<Name>,<@>,%(cParms*4 + 8)
    ?merge  <cparm>,<Name>,,,<EQU>,<cParms>
VxD_CODE_SEG
    ?merge  <EXTRN>,,,,,<_>,<Name>,<@>,%(cParms*4 + 8),<:NEAR>
VxD_CODE_ENDS
endif
    ENDM


;***	Win32call - call a Win32 service from a ring 3 thunk
;
;   This macro is used to call a Win32 service from
;   a ring 3 thunk.  Note that control will not return
;   to the instruction following the call, but to the
;   instruction following the call to the thunk.
;
;   ENTRY   Service	- the name of the service
;	CallBack    - the fword containing the callback

Win32call MACRO Service, CallBack
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
ife Create_Win32_Services
    mov eax,@32&Service
ifdef IS_16
    movzx   esp,sp
endif
    call    fword ptr [CallBack]
ifdef DEBUG
    int 3
endif
endif
    ENDM
*/

/*XLATOFF*/
#define GetVxDServiceAddress(service)	service

#define VxDCall(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (GetVxDServiceOrdinal(service) & 0xff) \
    _asm _emit (GetVxDServiceOrdinal(service) >> 8) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 16) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 24) & 0xff \

#define VMMCall VxDCall

#define VxDJmp(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (GetVxDServiceOrdinal(service) & 0xff) \
    _asm _emit ((GetVxDServiceOrdinal(service) >> 8) & 0xff) | 0x80 \
    _asm _emit (GetVxDServiceOrdinal(service) >> 16) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 24) & 0xff \

#define VMMJmp	VxDJmp

#define SERVICE 	__cdecl
#define ASYNC_SERVICE	__cdecl
#define WIN32_SERVICE	void __stdcall

#ifndef FASTCALL
#define FASTCALL	__fastcall
#endif
/*XLATON*/

/* ASM
;******************************************************************************
;
;   Dword_Align -- Aligns code to dword boundry by inserting nops
;
;------------------------------------------------------------------------------

Dword_Align MACRO Seg_Name
    LOCAL segn
IFDEF MASM6
    align 4
ELSE
IFNB <Seg_Name>
    segn equ Seg_Name
ELSE
IFE ?_LCODE
    segn equ <_LTEXT>
ELSE
IFE ?_ICODE
    segn equ <_ITEXT>
ELSE
IFE ?_PCODE
    segn equ <_PTEXT>
ELSE
IFE ?_SCODE
    segn equ <_STEXT>
ELSE
.err <Dword_Align not supported>
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
ENDIF
	ENDM


BeginDoc
;******************************************************************************
;
;   Fatal_Error
;
;   DESCRIPTION:
;   This macro is used to crash Windows/386 when an unrecoverable error
;   is detected.  If Msg_Ptr is ommitted then no error message will be
;   displayed, otherwise Msg_Ptr is the address
;   when the
;
;   PARAMETERS:
;   Msg_Ptr (OPTIONAL) - Points to an ASCIIZ string to display.
;
;   EXIT:
;   To DOS (hopefully).  This macro never returns.
;
;==============================================================================
EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
    pushad
IFB <Msg_Ptr>
    xor esi, esi
ELSE
    mov esi, Msg_Ptr
IFB <Exit_Flags>
    xor eax, eax
ELSE
    mov eax, Exit_Flags
ENDIF
ENDIF
    VMMCall Fatal_Error_Handler
    ENDM

EF_Hang_On_Exit     EQU     1h
*/


/******************************************************************************
 *
 *   The following are control block headers and flags of interest to VxDs.
 *
 *****************************************************************************/

struct cb_s {
    ULONG CB_VM_Status; 	/* VM status flags */
    ULONG CB_High_Linear;	/* Address of VM mapped high */
    ULONG CB_Client_Pointer;
    ULONG CB_VMID;
    ULONG CB_Signature;
};

#define VMCB_ID 0x62634D56	/* VMcb */

/*
 *  VM status indicates globally interesting VM states
 */

#define VMSTAT_EXCLUSIVE_BIT	0x00	/* VM is exclusive mode */
#define VMSTAT_EXCLUSIVE	(1L << VMSTAT_EXCLUSIVE_BIT)
#define VMSTAT_BACKGROUND_BIT	0x01	/* VM runs in background */
#define VMSTAT_BACKGROUND	(1L << VMSTAT_BACKGROUND_BIT)
#define VMSTAT_CREATING_BIT 0x02    /* In process of creating */
#define VMSTAT_CREATING 	(1L << VMSTAT_CREATING_BIT)
#define VMSTAT_SUSPENDED_BIT	0x03	/* VM not scheduled */
#define VMSTAT_SUSPENDED	(1L << VMSTAT_SUSPENDED_BIT)
#define VMSTAT_NOT_EXECUTEABLE_BIT 0x04 /* VM partially destroyed */
#define VMSTAT_NOT_EXECUTEABLE	(1L << VMSTAT_NOT_EXECUTEABLE_BIT)
#define VMSTAT_PM_EXEC_BIT  0x05    /* Currently in PM app */
#define VMSTAT_PM_EXEC		(1L << VMSTAT_PM_EXEC_BIT)
#define VMSTAT_PM_APP_BIT   0x06    /* PM app present in VM */
#define VMSTAT_PM_APP		(1L << VMSTAT_PM_APP_BIT)
#define VMSTAT_PM_USE32_BIT 0x07    /* PM app is 32-bit */
#define VMSTAT_PM_USE32 	(1L << VMSTAT_PM_USE32_BIT)
#define VMSTAT_VXD_EXEC_BIT 0x08    /* Call from VxD */
#define VMSTAT_VXD_EXEC 	(1L << VMSTAT_VXD_EXEC_BIT)
#define VMSTAT_HIGH_PRI_BACK_BIT 0x09	/* High pri background */
#define VMSTAT_HIGH_PRI_BACK	(1L << VMSTAT_HIGH_PRI_BACK_BIT)
#define VMSTAT_BLOCKED_BIT  0x0A    /* Blocked on semaphore */
#define VMSTAT_BLOCKED		(1L << VMSTAT_BLOCKED_BIT)
#define VMSTAT_AWAKENING_BIT	0x0B	/* Woke up after blocked */
#define VMSTAT_AWAKENING	(1L << VMSTAT_AWAKENING_BIT)
#define VMSTAT_PAGEABLEV86BIT	0x0C	/* part of V86 is pageable (PM app) */
#define VMSTAT_PAGEABLEV86_BIT	VMSTAT_PAGEABLEV86BIT
#define VMSTAT_PAGEABLEV86	(1L << VMSTAT_PAGEABLEV86BIT)
#define VMSTAT_V86INTSLOCKEDBIT 0x0D	/* Locked regardless of pager type */
#define VMSTAT_V86INTSLOCKED_BIT VMSTAT_V86INTSLOCKEDBIT
#define VMSTAT_V86INTSLOCKED	(1L << VMSTAT_V86INTSLOCKEDBIT)
#define VMSTAT_IDLE_TIMEOUT_BIT 0x0E	/* Scheduled by time-slicer */
#define VMSTAT_IDLE_TIMEOUT	(1L << VMSTAT_IDLE_TIMEOUT_BIT)
#define VMSTAT_IDLE_BIT 	0x0F	/* VM has released time slice */
#define VMSTAT_IDLE		(1L << VMSTAT_IDLE_BIT)
#define VMSTAT_CLOSING_BIT  0x10    /* Close_VM called for VM */
#define VMSTAT_CLOSING		(1L << VMSTAT_CLOSING_BIT)
#define VMSTAT_TS_SUSPENDED_BIT 0x11	/* VM suspended by */
#define VMSTAT_TS_SUSPENDED	(1L << VMSTAT_TS_SUSPENDED_BIT)
#define VMSTAT_TS_MAXPRI_BIT	0x12	/* this is fgd_pri 10,000 internally*/
#define VMSTAT_TS_MAXPRI	(1L << VMSTAT_TS_MAXPRI_BIT)

#define VMSTAT_USE32_MASK   (VMSTAT_PM_USE32 | VMSTAT_VXD_EXEC)

struct tcb_s {
    ULONG   TCB_Flags;		/* Thread status flags */
    ULONG   TCB_Reserved1;	/* Used internally by VMM */
    ULONG   TCB_Reserved2;	/* Used internally by VMM */
    ULONG   TCB_Signature;
    ULONG   TCB_ClientPtr;	/* Client registers of thread */
    ULONG   TCB_VMHandle;	/* VM that thread is part of */
    USHORT  TCB_ThreadId;	/* Unique Thread ID */
    USHORT  TCB_PMLockOrigSS;	    /* Original SS:ESP before lock stack */
    ULONG   TCB_PMLockOrigESP;
    ULONG   TCB_PMLockOrigEIP;	    /* Original CS:EIP before lock stack */
    ULONG   TCB_PMLockStackCount;
    USHORT  TCB_PMLockOrigCS;
    USHORT  TCB_PMPSPSelector;
    ULONG   TCB_ThreadType;	/* dword passed to VMMCreateThread */
    USHORT  TCB_pad1;		/* reusable; for dword align */
    UCHAR   TCB_pad2;		/* reusable; for dword align */
    UCHAR   TCB_extErrLocus;	    /* extended error Locus */
    USHORT  TCB_extErr; 	/* extended error Code */
    UCHAR   TCB_extErrAction;	    /*	    "   "   Action */
    UCHAR   TCB_extErrClass;	    /*	    "   "   Class */
    ULONG   TCB_extErrPtr;	/*	"   pointer */

};

typedef struct tcb_s TCB;
typedef TCB *PTCB;

#define SCHED_OBJ_ID_THREAD	    0x42434854	  // THCB in ASCII

/*
 *  Thread status indicates globally interesting thread states.
 *  Flags are for information only and must not be modified.
 */

#define THFLAG_SUSPENDED_BIT	    0x03   // Thread not scheduled
#define THFLAG_SUSPENDED		   (1L << THFLAG_SUSPENDED_BIT)
#define THFLAG_NOT_EXECUTEABLE_BIT  0x04   // Thread partially destroyed
#define THFLAG_NOT_EXECUTEABLE		   (1L << THFLAG_NOT_EXECUTEABLE_BIT)
#define THFLAG_THREAD_CREATION_BIT  0x08   // Thread in status nascendi
#define THFLAG_THREAD_CREATION		   (1L << THFLAG_THREAD_CREATION_BIT)
#define THFLAG_THREAD_BLOCKED_BIT   0x0A   // Blocked on semaphore
#define THFLAG_THREAD_BLOCKED		   (1L << THFLAG_THREAD_BLOCKED_BIT)
#define THFLAG_RING0_THREAD_BIT     0x1C   // thread runs only at ring 0
#define THFLAG_RING0_THREAD		   (1L << THFLAG_RING0_THREAD_BIT)
#define THFLAG_ASYNC_THREAD_BIT	    0x1F   // thread is asynchronous
#define THFLAG_ASYNC_THREAD	       	   (1L << THFLAG_ASYNC_THREAD_BIT)
#define THFLAG_CHARSET_BITS	0x10   // Default character set
#define THFLAG_CHARSET_MASK	   (3L << THFLAG_CHARSET_BITS)
#define THFLAG_ANSI	       (0L << THFLAG_CHARSET_BITS)
#define THFLAG_OEM	       (1L << THFLAG_CHARSET_BITS)
#define THFLAG_UNICODE		   (2L << THFLAG_CHARSET_BITS)
#define THFLAG_RESERVED 	   (3L << THFLAG_CHARSET_BITS)
#define THFLAG_EXTENDED_HANDLES_BIT 0x12   // Thread uses extended file handles
#define THFLAG_EXTENDED_HANDLES 	   (1L << THFLAG_EXTENDED_HANDLES_BIT)
/* the win32 loader opens win32 exes with this bit set to notify IFS
 * so a defragger won't move these files
 * the bit is turned off once the open completes.
 * file open flags are overloaded which is why this is here
 */
#define THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT 0x13	 // File thus opened not moved
#define THFLAG_OPEN_AS_IMMOVABLE_FILE		 (1L << THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT)

/*
 *   Protected mode application control blocks
 */
struct pmcb_s {
    ULONG PMCB_Flags;
    ULONG PMCB_Parent;
};

/*
 *  The reference data for fault error codes 1-5 (GSDVME_PRIVINST through
 *  GSDVME_INVALFLT) is a pointer to the following fault information structure.
 */
struct VMFaultInfo {
    ULONG VMFI_EIP;		// faulting EIP
    WORD  VMFI_CS;		// faulting CS
    WORD  VMFI_Ints;		// interrupts in service, if any
};

typedef struct VMFaultInfo *PVMFaultInfo;

/******************************************************************************
 *		V M M	S E R V I C E S
 ******************************************************************************/

/*XLATOFF*/
#define VMM_Service Declare_Service
#define VMM_StdCall_Service Declare_SCService
#define VMM_FastCall_Service Declare_SCService
#pragma warning (disable:4003)	    // turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VMM, VMM)

VMM_Service (Get_VMM_Version, LOCAL)	// MUST REMAIN SERVICE 0!

VMM_Service (Get_Cur_VM_Handle)
VMM_Service (Test_Cur_VM_Handle)
VMM_Service (Get_Sys_VM_Handle)
VMM_Service (Test_Sys_VM_Handle)
VMM_Service (Validate_VM_Handle)

VMM_Service (Get_VMM_Reenter_Count)
VMM_Service (Begin_Reentrant_Execution)
VMM_Service (End_Reentrant_Execution)

VMM_Service (Install_V86_Break_Point)
VMM_Service (Remove_V86_Break_Point)
VMM_Service (Allocate_V86_Call_Back)
VMM_Service (Allocate_PM_Call_Back)

VMM_Service (Call_When_VM_Returns)

VMM_Service (Schedule_Global_Event)
VMM_Service (Schedule_VM_Event)
VMM_Service (Call_Global_Event)
VMM_Service (Call_VM_Event)
VMM_Service (Cancel_Global_Event)
VMM_Service (Cancel_VM_Event)
VMM_Service (Call_Priority_VM_Event)
VMM_Service (Cancel_Priority_VM_Event)

VMM_Service (Get_NMI_Handler_Addr)
VMM_Service (Set_NMI_Handler_Addr)
VMM_Service (Hook_NMI_Event)

VMM_Service (Call_When_VM_Ints_Enabled)
VMM_Service (Enable_VM_Ints)
VMM_Service (Disable_VM_Ints)

VMM_Service (Map_Flat)
VMM_Service (Map_Lin_To_VM_Addr)

//   Scheduler services

VMM_Service (Adjust_Exec_Priority)
VMM_Service (Begin_Critical_Section)
VMM_Service (End_Critical_Section)
VMM_Service (End_Crit_And_Suspend)
VMM_Service (Claim_Critical_Section)
VMM_Service (Release_Critical_Section)
VMM_Service (Call_When_Not_Critical)
VMM_Service (Create_Semaphore)
VMM_Service (Destroy_Semaphore)
VMM_Service (Wait_Semaphore)
VMM_Service (Signal_Semaphore)
VMM_Service (Get_Crit_Section_Status)
VMM_Service (Call_When_Task_Switched)
VMM_Service (Suspend_VM)
VMM_Service (Resume_VM)
VMM_Service (No_Fail_Resume_VM)
VMM_Service (Nuke_VM)
VMM_Service (Crash_Cur_VM)

VMM_Service (Get_Execution_Focus)
VMM_Service (Set_Execution_Focus)
VMM_Service (Get_Time_Slice_Priority)
VMM_Service (Set_Time_Slice_Priority)
VMM_Service (Get_Time_Slice_Granularity)
VMM_Service (Set_Time_Slice_Granularity)
VMM_Service (Get_Time_Slice_Info)
VMM_Service (Adjust_Execution_Time)
VMM_Service (Release_Time_Slice)
VMM_Service (Wake_Up_VM)
VMM_Service (Call_When_Idle)

VMM_Service (Get_Next_VM_Handle)

//   Time-out and system timer services

VMM_Service (Set_Global_Time_Out)
VMM_Service (Set_VM_Time_Out)
VMM_Service (Cancel_Time_Out)
VMM_Service (Get_System_Time)
VMM_Service (Get_VM_Exec_Time)

VMM_Service (Hook_V86_Int_Chain)
VMM_Service (Get_V86_Int_Vector)
VMM_Service (Set_V86_Int_Vector)
VMM_Service (Get_PM_Int_Vector)
VMM_Service (Set_PM_Int_Vector)

VMM_Service (Simulate_Int)
VMM_Service (Simulate_Iret)
VMM_Service (Simulate_Far_Call)
VMM_Service (Simulate_Far_Jmp)
VMM_Service (Simulate_Far_Ret)
VMM_Service (Simulate_Far_Ret_N)
VMM_Service (Build_Int_Stack_Frame)

VMM_Service (Simulate_Push)
VMM_Service (Simulate_Pop)

// Heap Manager

VMM_Service (_HeapAllocate)
VMM_Service (_HeapReAllocate)
VMM_Service (_HeapFree)
VMM_Service (_HeapGetSize)

/*ENDMACROS*/

/****************************************************
 *
 *   Flags for heap allocator calls
 *
 *   NOTE: HIGH 8 BITS (bits 24-31) are reserved
 *
 ***************************************************/

//
// Flags affecting the returned block
//

#define HEAPZEROINIT        0x00000001
#define HEAPZEROREINIT      0x00000002
#define HEAPNOCOPY          0x00000004

//
// Alignment flags
//

#define HEAPALIGN_SHIFT     16
#define HEAPALIGN_MASK      0x000F0000

#define HEAPALIGN_4         0x00000000                // dword aligned
#define HEAPALIGN_8         0x00000000                // quadword aligned
#define HEAPALIGN_16        0x00000000                // paragraph aligned
#define HEAPALIGN_32        0x00010000                // etc.
#define HEAPALIGN_64        0x00020000
#define HEAPALIGN_128       0x00030000
#define HEAPALIGN_256       0x00040000
#define HEAPALIGN_512       0x00050000
#define HEAPALIGN_1K        0x00060000
#define HEAPALIGN_2K        0x00070000
#define HEAPALIGN_4K        0x00080000
#define HEAPALIGN_8K        0x00090000
#define HEAPALIGN_16K       0x000A0000
#define HEAPALIGN_32K       0x000B0000
#define HEAPALIGN_64K       0x000C0000
#define HEAPALIGN_128K      0x000D0000

//
// Flags indicating which system heap to use.  There are four bits reserved
// to identify the heap to use.  Four are currently defined by the system.
//

#define HEAPTYPESHIFT       8
#define HEAPTYPEMASK        0x00000700

#define HEAPLOCKEDHIGH      0x00000000
#define HEAPLOCKEDIFDP      0x00000100
#define HEAPSWAP            0x00000200
#define HEAPLOCKEDLOW       0x00000300
#define HEAPINIT            0x00000400  // will be automatically freed after
                                        // init complete
#define HEAPSYSVM           0x00000500

//
// other flags
//

#define HEAPCLEAN           0x00000800
#define HEAPCONTIG          0x00001000  // memory must be physically contiguous
#define HEAPFORGET          0x00002000  // this memory will never be freed

// Page Manager

/*MACROS*/
VMM_Service (_PageAllocate)
VMM_Service (_PageReAllocate)
VMM_Service (_PageFree)
VMM_Service (_PageLock)
VMM_Service (_PageUnLock)
VMM_Service (_PageGetSizeAddr)
VMM_Service (_PageGetAllocInfo)
VMM_Service (_GetFreePageCount)
VMM_Service (_GetSysPageCount)
VMM_Service (_GetVMPgCount)
VMM_Service (_MapIntoV86)
VMM_Service (_PhysIntoV86)
VMM_Service (_TestGlobalV86Mem)
VMM_Service (_ModifyPageBits)
VMM_Service (_CopyPageTable)
VMM_Service (_LinMapIntoV86)
VMM_Service (_LinPageLock)
VMM_Service (_LinPageUnLock)
VMM_Service (_SetResetV86Pageable)
VMM_Service (_GetV86PageableArray)
VMM_Service (_PageCheckLinRange)
VMM_Service (_PageOutDirtyPages)
VMM_Service (_PageDiscardPages)
/*ENDMACROS*/

/****************************************************
 *
 *  Flags for other page allocator calls
 *
 *  NOTE: HIGH 8 BITS (bits 24-31) are reserved
 *
 ***************************************************/

#define PAGEZEROINIT		0x00000001
#define PAGEUSEALIGN		0x00000002
#define PAGECONTIG		0x00000004
#define PAGEFIXED		0x00000008
#define PAGEDEBUGNULFAULT	0x00000010
#define PAGEZEROREINIT		0x00000020
#define PAGENOCOPY		0x00000040
#define PAGELOCKED		0x00000080
#define PAGELOCKEDIFDP		0x00000100
#define PAGESETV86PAGEABLE	0x00000200
#define PAGECLEARV86PAGEABLE	0x00000400
#define PAGESETV86INTSLOCKED	0x00000800
#define PAGECLEARV86INTSLOCKED	0x00001000
#define PAGEMARKPAGEOUT 	0x00002000
#define PAGEPDPSETBASE		0x00004000
#define PAGEPDPCLEARBASE	0x00008000
#define PAGEDISCARD		0x00010000
#define PAGEPDPQUERYDIRTY	0x00020000
#define PAGEMAPFREEPHYSREG	0x00040000
#define PAGEPHYSONLY		0x04000000
//efine PAGEDONTUSE		0x08000000  // ;Internal
#define PAGENOMOVE		0x10000000
#define PAGEMAPGLOBAL		0x40000000
#define PAGEMARKDIRTY		0x80000000

/****************************************************
 *
 *	Flags for _PhysIntoV86,
 *	_MapIntoV86, and _LinMapIntoV86
 *
 ***************************************************/

#define MAPV86_IGNOREWRAP	0x00000001


// Informational services

/*MACROS*/
VMM_Service (_GetNulPageHandle)
VMM_Service (_GetFirstV86Page)
VMM_Service (_MapPhysToLinear)
VMM_Service (_GetAppFlatDSAlias)
VMM_Service (_SelectorMapFlat)
VMM_Service (_GetDemandPageInfo)
VMM_Service (_GetSetPageOutCount)
/*ENDMACROS*/

/*
 *  Flags bits for _GetSetPageOutCount
 */
#define GSPOC_F_GET 0x00000001

// Device VM page manager

/*MACROS*/
VMM_Service (Hook_V86_Page)
VMM_Service (_Assign_Device_V86_Pages)
VMM_Service (_DeAssign_Device_V86_Pages)
VMM_Service (_Get_Device_V86_Pages_Array)
VMM_Service (MMGR_SetNULPageAddr)

// GDT/LDT management

VMM_Service (_Allocate_GDT_Selector)
VMM_Service (_Free_GDT_Selector)
VMM_Service (_Allocate_LDT_Selector)
VMM_Service (_Free_LDT_Selector)
VMM_Service (_BuildDescriptorDWORDs)
VMM_Service (_GetDescriptor)
VMM_Service (_SetDescriptor)
/*ENDMACROS*/

/*
 *  Flag equates for _BuildDescriptorDWORDs
 */
#define BDDEXPLICITDPL	0x00000001

/*
 *  Flag equates for _Allocate_LDT_Selector
 */
#define ALDTSPECSEL 0x00000001

/*MACROS*/
VMM_Service (_MMGR_Toggle_HMA)
/*ENDMACROS*/

/*
 *  Flag equates for _MMGR_Toggle_HMA
 */
#define MMGRHMAPHYSICAL 0x00000001
#define MMGRHMAENABLE	0x00000002
#define MMGRHMADISABLE	0x00000004
#define MMGRHMAQUERY	0x00000008

/*MACROS*/
VMM_Service (Get_Fault_Hook_Addrs)
VMM_Service (Hook_V86_Fault)
VMM_Service (Hook_PM_Fault)
VMM_Service (Hook_VMM_Fault)
VMM_Service (Begin_Nest_V86_Exec)
VMM_Service (Begin_Nest_Exec)
VMM_Service (Exec_Int)
VMM_Service (Resume_Exec)
VMM_Service (End_Nest_Exec)

VMM_Service (Allocate_PM_App_CB_Area, VMM_ICODE)
VMM_Service (Get_Cur_PM_App_CB)

VMM_Service (Set_V86_Exec_Mode)
VMM_Service (Set_PM_Exec_Mode)

VMM_Service (Begin_Use_Locked_PM_Stack)
VMM_Service (End_Use_Locked_PM_Stack)

VMM_Service (Save_Client_State)
VMM_Service (Restore_Client_State)

VMM_Service (Exec_VxD_Int)

VMM_Service (Hook_Device_Service)

VMM_Service (Hook_Device_V86_API)
VMM_Service (Hook_Device_PM_API)

VMM_Service (System_Control)

//   I/O and software interrupt hooks

VMM_Service (Simulate_IO)
VMM_Service (Install_Mult_IO_Handlers)
VMM_Service (Install_IO_Handler)
VMM_Service (Enable_Global_Trapping)
VMM_Service (Enable_Local_Trapping)
VMM_Service (Disable_Global_Trapping)
VMM_Service (Disable_Local_Trapping)

//   Linked List Abstract Data Type Services

VMM_Service (List_Create)
VMM_Service (List_Destroy)
VMM_Service (List_Allocate)
VMM_Service (List_Attach)
VMM_Service (List_Attach_Tail)
VMM_Service (List_Insert)
VMM_Service (List_Remove)
VMM_Service (List_Deallocate)
VMM_Service (List_Get_First)
VMM_Service (List_Get_Next)
VMM_Service (List_Remove_First)
/*ENDMACROS*/

/*
 *   Flags used by List_Create
 */
#define LF_ASYNC_BIT	    0
#define LF_ASYNC	(1 << LF_ASYNC_BIT)
#define LF_USE_HEAP_BIT     1
#define LF_USE_HEAP	(1 << LF_USE_HEAP_BIT)
#define LF_ALLOC_ERROR_BIT  2
#define LF_ALLOC_ERROR	    (1 << LF_ALLOC_ERROR_BIT)
/*
 * Swappable lists must use the heap.
 */
#define LF_SWAP 	(LF_USE_HEAP + (1 << 3))

/******************************************************************************
 *  I N I T I A L I Z A T I O N   P R O C E D U R E S
 ******************************************************************************/

// Instance data manager

/*MACROS*/
VMM_Service (_AddInstanceItem)

// System structure data manager

VMM_Service (_Allocate_Device_CB_Area)
VMM_Service (_Allocate_Global_V86_Data_Area, VMM_ICODE)
VMM_Service (_Allocate_Temp_V86_Data_Area, VMM_ICODE)
VMM_Service (_Free_Temp_V86_Data_Area, VMM_ICODE)
/*ENDMACROS*/

/*
 *  Flag bits for _Allocate_Global_V86_Data_Area
 */
#define GVDAWordAlign	    0x00000001
#define GVDADWordAlign	    0x00000002
#define GVDAParaAlign	    0x00000004
#define GVDAPageAlign	    0x00000008
#define GVDAInstance	    0x00000100
#define GVDAZeroInit	    0x00000200
#define GVDAReclaim	0x00000400
#define GVDAInquire	0x00000800
#define GVDAHighSysCritOK   0x00001000
#define GVDAOptInstance     0x00002000
#define GVDAForceLow	    0x00004000

/*
 *  Flag bits for _Allocate_Temp_V86_Data_Area
 */
#define TVDANeedTilInitComplete 0x00000001

// Initialization information calls (win.ini and environment parameters)

/*MACROS*/
VMM_Service (Get_Profile_Decimal_Int, VMM_ICODE)
VMM_Service (Convert_Decimal_String, VMM_ICODE)
VMM_Service (Get_Profile_Fixed_Point, VMM_ICODE)
VMM_Service (Convert_Fixed_Point_String, VMM_ICODE)
VMM_Service (Get_Profile_Hex_Int, VMM_ICODE)
VMM_Service (Convert_Hex_String, VMM_ICODE)
VMM_Service (Get_Profile_Boolean, VMM_ICODE)
VMM_Service (Convert_Boolean_String, VMM_ICODE)
VMM_Service (Get_Profile_String, VMM_ICODE)
VMM_Service (Get_Next_Profile_String, VMM_ICODE)
VMM_Service (Get_Environment_String, VMM_ICODE)
VMM_Service (Get_Exec_Path, VMM_ICODE)
VMM_Service (Get_Config_Directory, VMM_ICODE)
VMM_Service (OpenFile, VMM_ICODE)
/*ENDMACROS*/

// OpenFile, if called after init, must point EDI to a buffer of at least
// this size.

#define VMM_OPENFILE_BUF_SIZE	    260

/*MACROS*/
VMM_Service (Get_PSP_Segment, VMM_ICODE)
VMM_Service (GetDOSVectors, VMM_ICODE)
VMM_Service (Get_Machine_Info)
/*ENDMACROS*/

#define GMIF_80486_BIT	0x10
#define GMIF_80486  (1 << GMIF_80486_BIT)
#define GMIF_PCXT_BIT	0x11
#define GMIF_PCXT   (1 << GMIF_PCXT_BIT)
#define GMIF_MCA_BIT	0x12
#define GMIF_MCA    (1 << GMIF_MCA_BIT)
#define GMIF_EISA_BIT	0x13
#define GMIF_EISA   (1 << GMIF_EISA_BIT)
#define GMIF_CPUID_BIT	0x14
#define GMIF_CPUID  (1 << GMIF_CPUID_BIT)

// Following service is not restricted to initialization

/*MACROS*/
VMM_Service (GetSet_HMA_Info)
VMM_Service (Set_System_Exit_Code)

VMM_Service (Fatal_Error_Handler)
VMM_Service (Fatal_Memory_Error)

//   Called by VTD only

VMM_Service (Update_System_Clock)

/******************************************************************************
 *	    D E B U G G I N G	E X T E R N S
 ******************************************************************************/

VMM_Service (Test_Debug_Installed)	// Valid call in retail also

VMM_Service (Out_Debug_String)
VMM_Service (Out_Debug_Chr)
VMM_Service (In_Debug_Chr)
VMM_Service (Debug_Convert_Hex_Binary)
VMM_Service (Debug_Convert_Hex_Decimal)

VMM_Service (Debug_Test_Valid_Handle)
VMM_Service (Validate_Client_Ptr)
VMM_Service (Test_Reenter)
VMM_Service (Queue_Debug_String)
VMM_Service (Log_Proc_Call)
VMM_Service (Debug_Test_Cur_VM)

VMM_Service (Get_PM_Int_Type)
VMM_Service (Set_PM_Int_Type)

VMM_Service (Get_Last_Updated_System_Time)
VMM_Service (Get_Last_Updated_VM_Exec_Time)

VMM_Service (Test_DBCS_Lead_Byte)	// for DBCS Enabling
/*ENDMACROS*/

/* ASM
.errnz	@@Test_DBCS_Lead_Byte - 100D1h	 ; VMM service table changed above this service
*/

/*************************************************************************
 *************************************************************************
 * END OF 3.00 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
 *  FOR COMPATIBILITY.
 *************************************************************************
 *************************************************************************/

/*MACROS*/
VMM_Service (_AddFreePhysPage, VMM_ICODE)
VMM_Service (_PageResetHandlePAddr)
VMM_Service (_SetLastV86Page, VMM_ICODE)
VMM_Service (_GetLastV86Page)
VMM_Service (_MapFreePhysReg)
VMM_Service (_UnmapFreePhysReg)
VMM_Service (_XchgFreePhysReg)
VMM_Service (_SetFreePhysRegCalBk, VMM_ICODE)
VMM_Service (Get_Next_Arena, VMM_ICODE)
VMM_Service (Get_Name_Of_Ugly_TSR, VMM_ICODE)
VMM_Service (Get_Debug_Options, VMM_ICODE)
/*ENDMACROS*/

/*
 *  Flags for AddFreePhysPage
 */
#define AFPP_SWAPOUT	 0x0001 // physical memory that must be swapped out
				// and subsequently restored at system exit
/*
 *  Flags for PageChangePager
 */
#define PCP_CHANGEPAGER     0x1 // change the pager for the page range
#define PCP_CHANGEPAGERDATA 0x2 // change the pager data dword for the pages
#define PCP_VIRGINONLY	    0x4 // make the above changes to virgin pages only


/*
 *  Bits for the ECX return of Get_Next_Arena
 */
#define GNA_HIDOSLINKED  0x0002 // High DOS arenas linked when WIN386 started
#define GNA_ISHIGHDOS	 0x0004 // High DOS arenas do exist

/*MACROS*/
VMM_Service (Set_Physical_HMA_Alias, VMM_ICODE)
VMM_Service (_GetGlblRng0V86IntBase, VMM_ICODE)
VMM_Service (_Add_Global_V86_Data_Area, VMM_ICODE)

VMM_Service (GetSetDetailedVMError)
/*ENDMACROS*/

/*
 *  Error code values for the GetSetDetailedVMError service. PLEASE NOTE
 *  that all of these error code values need to have bits set in the high
 *  word. This is to prevent collisions with other VMDOSAPP standard errors.
 *  Also, the low word must be non-zero.
 *
 *  First set of errors (high word = 0001) are intended to be used
 *  when a VM is CRASHED (VNE_Crashed or VNE_Nuked bit set on
 *  VM_Not_Executeable).
 *
 *  PLEASE NOTE that each of these errors (high word == 0001) actually
 *  has two forms:
 *
 *  0001xxxxh
 *  8001xxxxh
 *
 *  The device which sets the error initially always sets the error with
 *  the high bit CLEAR. The system will then optionally set the high bit
 *  depending on the result of the attempt to "nicely" crash the VM. This
 *  bit allows the system to tell the user whether the crash is likely or
 *  unlikely to destabalize the system.
 */
#define GSDVME_PRIVINST     0x00010001	/* Privledged instruction */
#define GSDVME_INVALINST    0x00010002	/* Invalid instruction */
#define GSDVME_INVALPGFLT   0x00010003	/* Invalid page fault */
#define GSDVME_INVALGPFLT   0x00010004	/* Invalid GP fault */
#define GSDVME_INVALFLT     0x00010005	/* Unspecified invalid fault */
#define GSDVME_USERNUKE     0x00010006	/* User requested NUKE of VM */
#define GSDVME_DEVNUKE	    0x00010007	/* Device specific problem */
#define GSDVME_DEVNUKEHDWR  0x00010008	/* Device specific problem:
			 *   invalid hardware fiddling
			 *   by VM (invalid I/O)
			 */
#define GSDVME_NUKENOMSG    0x00010009	/* Supress standard messages:
			 *   SHELL_Message used for
			 *   custom msg.
			 */
#define GSDVME_OKNUKEMASK   0x80000000	/* "Nice nuke" bit */

/*
 *  Second set of errors (high word = 0002) are intended to be used
 *  when a VM start up is failed (VNE_CreateFail, VNE_CrInitFail, or
 *  VNE_InitFail bit set on VM_Not_Executeable).
 */
#define GSDVME_INSMEMV86    0x00020001	/* base V86 mem    - V86MMGR */
#define GSDVME_INSV86SPACE  0x00020002	/* Kb Req too large - V86MMGR */
#define GSDVME_INSMEMXMS    0x00020003	/* XMS Kb Req	   - V86MMGR */
#define GSDVME_INSMEMEMS    0x00020004	/* EMS Kb Req	   - V86MMGR */
#define GSDVME_INSMEMV86HI  0x00020005	/* Hi DOS V86 mem   - DOSMGR
			 *	     V86MMGR
			 */
#define GSDVME_INSMEMVID    0x00020006	/* Base Video mem   - VDD */
#define GSDVME_INSMEMVM     0x00020007	/* Base VM mem	   - VMM
			 *   CB, Inst Buffer
			 */
#define GSDVME_INSMEMDEV    0x00020008	/* Couldn't alloc base VM
			 * memory for device.
			 */
#define GSDVME_CRTNOMSG     0x00020009	/* Supress standard messages:
			 *   SHELL_Message used for
			 *   custom msg.
			 */

/*MACROS*/
VMM_Service (Is_Debug_Chr)

//   Mono_Out services

VMM_Service (Clear_Mono_Screen)
VMM_Service (Out_Mono_Chr)
VMM_Service (Out_Mono_String)
VMM_Service (Set_Mono_Cur_Pos)
VMM_Service (Get_Mono_Cur_Pos)
VMM_Service (Get_Mono_Chr)

//   Service locates a byte in ROM

VMM_Service (Locate_Byte_In_ROM, VMM_ICODE)

VMM_Service (Hook_Invalid_Page_Fault)
VMM_Service (Unhook_Invalid_Page_Fault)
/*ENDMACROS*/

/*
 *  Flag bits of IPF_Flags
 */
#define IPF_PGDIR   0x00000001	/* Page directory entry not-present */
#define IPF_V86PG   0x00000002	/* Unexpected not present Page in V86 */
#define IPF_V86PGH  0x00000004	/* Like IPF_V86PG at high linear */
#define IPF_INVTYP  0x00000008	/* page has invalid not present type */
#define IPF_PGERR   0x00000010	/* pageswap device failure */
#define IPF_REFLT   0x00000020	/* re-entrant page fault */
#define IPF_VMM     0x00000040	/* Page fault caused by a VxD */
#define IPF_PM	    0x00000080	/* Page fault by VM in Prot Mode */
#define IPF_V86     0x00000100	/* Page fault by VM in V86 Mode */

/*MACROS*/
VMM_Service (Set_Delete_On_Exit_File)

VMM_Service (Close_VM)
/*ENDMACROS*/

/*
 *   Flags for Close_VM service
 */

#define CVF_CONTINUE_EXEC_BIT	0
#define CVF_CONTINUE_EXEC   (1 << CVF_CONTINUE_EXEC_BIT)

/*MACROS*/
VMM_Service (Enable_Touch_1st_Meg)	// Debugging only
VMM_Service (Disable_Touch_1st_Meg)	// Debugging only

VMM_Service (Install_Exception_Handler)
VMM_Service (Remove_Exception_Handler)

VMM_Service (Get_Crit_Status_No_Block)
/*ENDMACROS*/

/* ASM
; Check if VMM service table has changed above this service
.errnz	 @@Get_Crit_Status_No_Block - 100F1h
*/

#ifdef WIN40SERVICES

/*************************************************************************
 *************************************************************************
 *
 * END OF 3.10 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
 *  FOR COMPATIBILITY.
 *************************************************************************
 *************************************************************************/

/*MACROS*/
VMM_Service (_GetLastUpdatedThreadExecTime)

VMM_Service (_Trace_Out_Service)
VMM_Service (_Debug_Out_Service)
VMM_Service (_Debug_Flags_Service)
/*ENDMACROS*/

#endif /* WIN40SERVICES */


/*
 *   Flags for _Debug_Flags_Service service.
 *
 *   Don't change these unless you really really know what you're doing.
 *   We need to define these even if we are in WIN31COMPAT mode.
 */

#define DFS_LOG_BIT	    0
#define DFS_LOG 	    (1 << DFS_LOG_BIT)
#define DFS_PROFILE_BIT 	1
#define DFS_PROFILE	    (1 << DFS_PROFILE_BIT)
#define DFS_TEST_CLD_BIT	2
#define DFS_TEST_CLD		(1 << DFS_TEST_CLD_BIT)
#define DFS_NEVER_REENTER_BIT	    3
#define DFS_NEVER_REENTER	(1 << DFS_NEVER_REENTER_BIT)
#define DFS_TEST_REENTER_BIT	    4
#define DFS_TEST_REENTER	(1 << DFS_TEST_REENTER_BIT)
#define DFS_NOT_SWAPPING_BIT	    5
#define DFS_NOT_SWAPPING	(1 << DFS_NOT_SWAPPING_BIT)
#define DFS_TEST_BLOCK_BIT	6
#define DFS_TEST_BLOCK		(1 << DFS_TEST_BLOCK_BIT)

#define DFS_RARE_SERVICES   0xFFFFFF80

#define DFS_EXIT_NOBLOCK	(DFS_RARE_SERVICES+0)
#define DFS_ENTER_NOBLOCK	(DFS_RARE_SERVICES+DFS_TEST_BLOCK)

#define DFS_TEST_NEST_EXEC  (DFS_RARE_SERVICES+1)

#ifdef WIN40SERVICES

/*MACROS*/
VMM_Service (VMMAddImportModuleName)

VMM_Service (VMM_Add_DDB)
VMM_Service (VMM_Remove_DDB)

VMM_Service (Test_VM_Ints_Enabled)
VMM_Service (_BlockOnID)

VMM_Service (Schedule_Thread_Event)
VMM_Service (Cancel_Thread_Event)
VMM_Service (Set_Thread_Time_Out)
VMM_Service (Set_Async_Time_Out)

VMM_Service (_AllocateThreadDataSlot)
VMM_Service (_FreeThreadDataSlot)
/*ENDMACROS*/

/*
 *  Flag equates for _CreateMutex
 */
#define MUTEX_MUST_COMPLETE	1L
#define MUTEX_NO_CLEANUP_THREAD_STATE	2L

/*MACROS*/
VMM_Service (_CreateMutex)

VMM_Service (_DestroyMutex)
VMM_Service (_GetMutexOwner)
VMM_Service (Call_When_Thread_Switched)

VMM_Service (VMMCreateThread)
VMM_Service (_GetThreadExecTime)
VMM_Service (VMMTerminateThread)

VMM_Service (Get_Cur_Thread_Handle)
VMM_Service (Test_Cur_Thread_Handle)
VMM_Service (Get_Sys_Thread_Handle)
VMM_Service (Test_Sys_Thread_Handle)
VMM_Service (Validate_Thread_Handle)
VMM_Service (Get_Initial_Thread_Handle)
VMM_Service (Test_Initial_Thread_Handle)
VMM_Service (Debug_Test_Valid_Thread_Handle)
VMM_Service (Debug_Test_Cur_Thread)

VMM_Service (VMM_GetSystemInitState)

VMM_Service (Cancel_Call_When_Thread_Switched)
VMM_Service (Get_Next_Thread_Handle)
VMM_Service (Adjust_Thread_Exec_Priority)

VMM_Service (_Deallocate_Device_CB_Area)
VMM_Service (Remove_IO_Handler)
VMM_Service (Remove_Mult_IO_Handlers)
VMM_Service (Unhook_V86_Int_Chain)
VMM_Service (Unhook_V86_Fault)
VMM_Service (Unhook_PM_Fault)
VMM_Service (Unhook_VMM_Fault)
VMM_Service (Unhook_Device_Service)

VMM_Service (_PageReserve)
VMM_Service (_PageCommit)
VMM_Service (_PageDecommit)
VMM_Service (_PagerRegister)
VMM_Service (_PagerQuery)
VMM_Service (_PagerDeregister)
VMM_Service (_ContextCreate)
VMM_Service (_ContextDestroy)
VMM_Service (_PageAttach)
VMM_Service (_PageFlush)
VMM_Service (_SignalID)
VMM_Service (_PageCommitPhys)

VMM_Service (_Register_Win32_Services)

VMM_Service (Cancel_Call_When_Not_Critical)
VMM_Service (Cancel_Call_When_Idle)
VMM_Service (Cancel_Call_When_Task_Switched)

VMM_Service (_Debug_Printf_Service)
VMM_Service (_EnterMutex)
VMM_Service (_LeaveMutex)
VMM_Service (Simulate_VM_IO)
VMM_Service (Signal_Semaphore_No_Switch)

VMM_Service (_ContextSwitch)
VMM_Service (_PageModifyPermissions)
VMM_Service (_PageQuery)

VMM_Service (_EnterMustComplete)
VMM_Service (_LeaveMustComplete)
VMM_Service (_ResumeExecMustComplete)
/*ENDMACROS*/

/*
 *  Flag equates for _GetThreadTerminationStatus
 */
#define THREAD_TERM_STATUS_CRASH_PEND	    1L
#define THREAD_TERM_STATUS_NUKE_PEND	    2L
#define THREAD_TERM_STATUS_SUSPEND_PEND     4L

/*MACROS*/
VMM_Service (_GetThreadTerminationStatus)
VMM_Service (_GetInstanceInfo)
/*ENDMACROS*/

/*
 *  Return values for _GetInstanceInfo
 */
#define INSTINFO_NONE	0	/* no data instanced in range */
#define INSTINFO_SOME	1	/* some data instanced in range */
#define INSTINFO_ALL	2	/* all data instanced in range */

/*MACROS*/
VMM_Service (_ExecIntMustComplete)
VMM_Service (_ExecVxDIntMustComplete)

VMM_Service (Begin_V86_Serialization)

VMM_Service (Unhook_V86_Page)
VMM_Service (VMM_GetVxDLocationList)
VMM_Service (VMM_GetDDBList)
VMM_Service (Unhook_NMI_Event)

VMM_Service (Get_Instanced_V86_Int_Vector)
VMM_Service (Get_Set_Real_DOS_PSP)
/*ENDMACROS*/

#define GSRDP_Set   0x0001

/*MACROS*/
VMM_Service (Call_Priority_Thread_Event)
VMM_Service (Get_System_Time_Address)
VMM_Service (Get_Crit_Status_Thread)

VMM_Service (Get_DDB)
VMM_Service (Directed_Sys_Control)
/*ENDMACROS*/

// Registry APIs for VxDs
/*MACROS*/
VMM_Service (_RegOpenKey)
VMM_Service (_RegCloseKey)
VMM_Service (_RegCreateKey)
VMM_Service (_RegDeleteKey)
VMM_Service (_RegEnumKey)
VMM_Service (_RegQueryValue)
VMM_Service (_RegSetValue)
VMM_Service (_RegDeleteValue)
VMM_Service (_RegEnumValue)
VMM_Service (_RegQueryValueEx)
VMM_Service (_RegSetValueEx)
/*ENDMACROS*/

#ifndef REG_SZ	    // define only if not there already

#define REG_SZ	    0x0001
#define REG_BINARY  0x0003

#endif

#ifndef HKEY_LOCAL_MACHINE  // define only if not there already

#define HKEY_CLASSES_ROOT	0x80000000
#define HKEY_CURRENT_USER	0x80000001
#define HKEY_LOCAL_MACHINE	0x80000002
#define HKEY_USERS		0x80000003
#define HKEY_PERFORMANCE_DATA	0x80000004
#define HKEY_CURRENT_CONFIG	0x80000005
#define HKEY_DYN_DATA		0x80000006

#endif

/*MACROS*/
VMM_Service (_CallRing3)
VMM_Service (Exec_PM_Int)
VMM_Service (_RegFlushKey)
VMM_Service (_PageCommitContig)
VMM_Service (_GetCurrentContext)

VMM_Service (_LocalizeSprintf)
VMM_Service (_LocalizeStackSprintf)

VMM_Service (Call_Restricted_Event)
VMM_Service (Cancel_Restricted_Event)

VMM_Service (Register_PEF_Provider, VMM_ICODE)

VMM_Service (_GetPhysPageInfo)

VMM_Service (_RegQueryInfoKey)
VMM_Service (MemArb_Reserve_Pages)
/*ENDMACROS*/

/*
 *  Return values for _GetPhysPageInfo
 */
#define PHYSINFO_NONE	0	/* no pages in the specified range exist */
#define PHYSINFO_SOME	1	/* some pages in the specified range exist */
#define PHYSINFO_ALL	2	/* all pages in the specified range exist */

// New timeslicer services
/*MACROS*/
VMM_Service (Time_Slice_Sys_VM_Idle)
VMM_Service (Time_Slice_Sleep)
VMM_Service (Boost_With_Decay)
VMM_Service (Set_Inversion_Pri)
VMM_Service (Reset_Inversion_Pri)
VMM_Service (Release_Inversion_Pri)
VMM_Service (Get_Thread_Win32_Pri)
VMM_Service (Set_Thread_Win32_Pri)
VMM_Service (Set_Thread_Static_Boost)
VMM_Service (Set_VM_Static_Boost)
VMM_Service (Release_Inversion_Pri_ID)
VMM_Service (Attach_Thread_To_Group)
VMM_Service (Detach_Thread_From_Group)
VMM_Service (Set_Group_Static_Boost)

VMM_Service (_GetRegistryPath, VMM_ICODE)
VMM_Service (_GetRegistryKey)
/*ENDMACROS*/

// TYPE definitions for _GetRegistryKey

#define REGTYPE_ENUM	0
#define REGTYPE_CLASS	1
#define REGTYPE_VXD	2

// Flag definitions for _GetRegistryKey
#define REGKEY_OPEN		    0
#define REGKEY_CREATE_IFNOTEXIST    1

// Flag definitions for _Assert_Range
#define ASSERT_RANGE_NULL_BAD	    0x00000000
#define ASSERT_RANGE_NULL_OK	    0x00000001
#define ASSERT_RANGE_IS_ASCIIZ	    0x00000002
#define ASSERT_RANGE_IS_NOT_ASCIIZ  0x00000000
#define ASSERT_RANGE_NO_DEBUG	    0x80000000
#define ASSERT_RANGE_BITS	    0x80000003

/*MACROS*/
VMM_Service (Cleanup_Thread_State)
VMM_Service (_RegRemapPreDefKey)
VMM_Service (End_V86_Serialization)
VMM_Service (_Assert_Range)
VMM_Service (_Sprintf)
VMM_Service (_PageChangePager)
VMM_Service (_RegCreateDynKey)
VMM_Service (_RegQueryMultipleValues)

// Additional timeslicer services
VMM_Service (Boost_Thread_With_VM)
/*ENDMACROS*/

// Flag definitions for Get_Boot_Flags

#define BOOT_CLEAN		0x00000001
#define BOOT_DOSCLEAN		0x00000002
#define BOOT_NETCLEAN		0x00000004
#define BOOT_INTERACTIVE	0x00000008

/*MACROS*/
VMM_Service (Get_Boot_Flags)
VMM_Service (Set_Boot_Flags)

// String and memory services
VMM_Service (_lstrcpyn)
VMM_Service (_lstrlen)
VMM_Service (_lmemcpy)

VMM_Service (_GetVxDName)

// For vwin32 use only
VMM_Service (Force_Mutexes_Free)
VMM_Service (Restore_Forced_Mutexes)
/*ENDMACROS*/

// Reclaimable low memory services
/*MACROS*/
VMM_Service (_AddReclaimableItem)
VMM_Service (_SetReclaimableItem)
VMM_Service (_EnumReclaimableItem)
/*ENDMACROS*/

// completely wake sys VM from idle state
/*MACROS*/
VMM_Service (Time_Slice_Wake_Sys_VM)
VMM_Service (VMM_Replace_Global_Environment)
VMM_Service (Begin_Non_Serial_Nest_V86_Exec)
VMM_Service (Get_Nest_Exec_Status)
/*ENDMACROS*/

// Bootlogging services

/*MACROS*/
VMM_Service (Open_Boot_Log)
VMM_Service (Write_Boot_Log)
VMM_Service (Close_Boot_Log)
VMM_Service (EnableDisable_Boot_Log)
VMM_Service (_Call_On_My_Stack)
/*ENDMACROS*/

// Another instance data service

/*MACROS*/
VMM_Service (Get_Inst_V86_Int_Vec_Base)
/*ENDMACROS*/

// Case insensitive functions -- SEE WARNINGS IN DOCS BEFORE USING!
/*MACROS*/
VMM_Service (_lstrcmpi)
VMM_Service (_strupr)
/*ENDMACROS*/

/*MACROS*/
VMM_Service (Log_Fault_Call_Out)
VMM_Service (_AtEventTime)
/*ENDMACROS*/

#endif /* WIN40SERVICES */

#ifdef WIN403SERVICES
//
// 4.03 Services
//

/*MACROS*/
VMM_Service (_PageOutPages)
/*ENDMACROS*/

// Flag definitions for _PageOutPages

#define PAGEOUT_PRIVATE 0x00000001
#define PAGEOUT_SHARED	0x00000002
#define PAGEOUT_SYSTEM	0x00000004
#define PAGEOUT_REGION	0x00000008
#define PAGEOUT_ALL	(PAGEOUT_PRIVATE | PAGEOUT_SHARED | PAGEOUT_SYSTEM)

/*MACROS*/
VMM_Service (_Call_On_My_Not_Flat_Stack)
VMM_Service (_LinRegionLock)
VMM_Service (_LinRegionUnLock)
VMM_Service (_AttemptingSomethingDangerous)
VMM_Service (_Vsprintf)
VMM_Service (_Vsprintfw)
VMM_Service (Load_FS_Service)
VMM_Service (Assert_FS_Service)
VMM_StdCall_Service (RtlUnwind, 4)
VMM_StdCall_Service (RtlRaiseException, 1)
VMM_StdCall_Service (RtlRaiseStatus, 1)

VMM_StdCall_Service (KeGetCurrentIrql, 0)
VMM_FastCall_Service (KfRaiseIrql, 1)
VMM_FastCall_Service (KfLowerIrql, 1)

VMM_Service (_Begin_Preemptable_Code)
VMM_Service (_End_Preemptable_Code)
VMM_FastCall_Service (Set_Preemptable_Count, 1)

VMM_StdCall_Service (KeInitializeDpc, 3)
VMM_StdCall_Service (KeInsertQueueDpc, 3)
VMM_StdCall_Service (KeRemoveQueueDpc, 1)

VMM_StdCall_Service (HeapAllocateEx, 4)
VMM_StdCall_Service (HeapReAllocateEx, 5)
VMM_StdCall_Service (HeapGetSizeEx, 2)
VMM_StdCall_Service (HeapFreeEx, 2)
//VMM_Service (_Get_CPUID_Flags)

/*ENDMACROS*/

#endif /* WIN403SERVICES */

/*MACROS*/
End_Service_Table(VMM, VMM)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)		// turn on not enough params warning

#ifndef try
#define try				__try
#define except				__except
#define finally 			__finally
#define leave				__leave
#ifndef exception_code
#define exception_code			__exception_code
#endif  // exception_code
#endif  // try

#ifndef EXCEPTION_EXECUTE_HANDLER
#define EXCEPTION_EXECUTE_HANDLER	1
#define EXCEPTION_CONTINUE_SEARCH	0
#define EXCEPTION_CONTINUE_EXECUTION	-1
#endif
/*XLATON*/

#define COMNFS_FLAT	0xFFFFFFFF

#define ASD_MAX_REF_DATA    64	    // If bigger than this, a checksum is used

struct	_vmmguid {
unsigned long Data1;
unsigned short Data2;
unsigned short Data3;
unsigned char Data4[8];
};

typedef struct _vmmguid VMMGUID;
typedef VMMGUID     *VMMREFIID;

typedef DWORD		ASD_RESULT;

#define ASD_ERROR_NONE	    0x00000000
#define ASD_CHECK_FAIL	    0x00000001	// The flag is set that this failed before
#define ASD_CHECK_SUCCESS   0x00000002	// The flag is set that this succeeded before
#define ASD_CHECK_UNKNOWN   0x00000003	// No flag is set
#define ASD_ERROR_BAD_TIME  0x00000004	// Under cli
#define ASD_REGISTRY_ERROR  0x00000005	// Unknown registry error
#define ASD_CLEAN_BOOT	    0x00000006	// Clean booting fails everything
#define ASD_OUT_OF_MEMORY   0x00000007	// Ran out of memory (extremely rare)
#define ASD_FILE_ERROR	    0x00000008	// Int 21 to flush the info file failed
#define ASD_ALREADY_SET     0x00000009	// ASD_CHECK* done twice on same vgOperation/pRefData
#define ASD_MISSING_CHECK   0x0000000A	// ASD_DONE* on something not set
#define ASD_BAD_PARAMETER   0x0000000B	// Invalid operation, refiid or ref pointer

#define ASD_OP_CHECK_AND_WRITE_FAIL_IF_UNKNOWN	0x00000000
#define ASD_OP_CHECK_AND_ALWAYS_WRITE_FAIL	0x00000001
#define ASD_OP_CHECK				0x00000002
#define ASD_OP_DONE_AND_SET_SUCCESS		0x00000003
#define ASD_OP_SET_FAIL 			0x00000004
#define ASD_OP_SET_SUCCESS			0x00000005
#define ASD_OP_SET_UNKNOWN			0x00000006
#define ASD_OP_DONE				0x00000007

// Flag definitions for _Add/_Set/_EnumReclaimableItem

#define RS_RECLAIM		0x00000001
#define RS_RESTORE		0x00000002
#define RS_DOSARENA		0x00000004

// Structure definition for _EnumReclaimableItem

struct ReclaimStruc {
    ULONG   RS_Linear;			// low (< 1meg) address of item
    ULONG   RS_Bytes;			// size of item in bytes
    ULONG   RS_CallBack;		// callback, if any (zero if none)
    ULONG   RS_RefData; 		// reference data for callback, if any
    ULONG   RS_HookTable;		// real-mode hook table (zero if none)
    ULONG   RS_Flags;			// 0 or more of the RS_* equates
};

typedef struct ReclaimStruc *PReclaimStruc;

//
// Structures for Force_Mutexes_Free/Restore_Forced_Mutexes
//
typedef struct frmtx {
    struct frmtx *frmtx_pfrmtxNext;
    DWORD frmtx_hmutex;
    DWORD frmtx_cEnterCount;
    DWORD frmtx_pthcbOwner;
    DWORD frmtx_htimeout;
} FRMTX;

typedef struct vmmfrinfo {
    struct frmtx vmmfrinfo_frmtxDOS;
    struct frmtx vmmfrinfo_frmtxV86;
    struct frmtx vmmfrinfo_frmtxOther;
} VMMFRINFO;

/*
 *  Data structure for _GetDemandPageInfo
 */
struct DemandInfoStruc {
    ULONG DILin_Total_Count;	/* # pages in linear address space */
    ULONG DIPhys_Count; 	/* Count of phys pages */
    ULONG DIFree_Count; 	/* Count of free phys pages */
    ULONG DIUnlock_Count;	/* Count of unlocked Phys Pages */
    ULONG DILinear_Base_Addr;	/* Base of pageable address space */
    ULONG DILin_Total_Free;	/* Total Count of free linear pages */

    /*
     *	The following 5 fields are all running totals, kept from the time
     *	the system was started
     */
    ULONG DIPage_Faults;	/* total page faults */
    ULONG DIPage_Ins;		/* calls to pagers to page in a page */
    ULONG DIPage_Outs;		/* calls to pagers to page out a page*/
    ULONG DIPage_Discards;	/* pages discarded w/o calling pager */
    ULONG DIInstance_Faults;	/* instance page faults */

    ULONG DIPagingFileMax;	/* maximum # of pages that could be in paging file */
    ULONG DIPagingFileInUse;	/* # of pages of paging file currently in use */

    ULONG DICommit_Count;	/* Total committed memory, in pages */

    ULONG DIReserved[2];	/* Reserved for expansion */
};

/*
 *  Data structure for _AddInstanceItem
 */
struct InstDataStruc {
    ULONG InstLinkF;	    /* INIT <0> RESERVED */
    ULONG InstLinkB;	    /* INIT <0> RESERVED */
    ULONG InstLinAddr;	    /* Linear address of start of block */
    ULONG InstSize;	    /* Size of block in bytes */
    ULONG InstType;	    /* Type of block */
};

/*
 *  Values for InstType
 */
#define INDOS_FIELD	0x100	/* Bit indicating INDOS switch requirements */
#define ALWAYS_FIELD	0x200	/* Bit indicating ALWAYS switch requirements */
#define OPTIONAL_FIELD	0x400	/* Bit indicating optional instancing requirements */

/*
 *  Data structure for Hook_Invalid_Page_Fault handlers.
 *
 *  This is the structure of the "invalid page fault information"
 *  which is pointed to by EDI when Invalid page fault hookers
 *  are called.
 *
 *  Page faults can occur on a VM which is not current by touching the VM at
 *  its high linear address.  In this case, IPF_FaultingVM may not be the
 *  current VM, it will be set to the VM whos high linear address was touched.
 */

struct IPF_Data {
    ULONG IPF_LinAddr;	    /* CR2 address of fault */
    ULONG IPF_MapPageNum;   /* Possible converted page # of fault */
    ULONG IPF_PTEEntry;     /* Contents of PTE that faulted */
    ULONG IPF_FaultingVM;   /* May not = Current VM (IPF_V86PgH set) */
    ULONG IPF_Flags;	    /* Flags */
};

/*
 *
 * Install_Exception_Handler data structure
 *
 */

struct Exception_Handler_Struc {
    ULONG EH_Reserved;
    ULONG EH_Start_EIP;
    ULONG EH_End_EIP;
    ULONG EH_Handler;
};

/*
 *  Flags passed in new memory manager functions
 */

/* PageReserve arena values */
#define PR_PRIVATE  0x80000400	/* anywhere in private arena */
#define PR_SHARED   0x80060000	/* anywhere in shared arena */
#define PR_SYSTEM   0x80080000	/* anywhere in system arena */

/* PageReserve flags */
#define PR_FIXED    0x00000008	/* don't move during PageReAllocate */
#define PR_4MEG     0x00000001	/* allocate on 4mb boundary */
#define PR_STATIC   0x00000010	/* see PageReserve documentation */

/* PageCommit default pager handle values */
#define PD_ZEROINIT 0x00000001	/* swappable zero-initialized pages */
#define PD_NOINIT   0x00000002	/* swappable uninitialized pages */
#define PD_FIXEDZERO	0x00000003  /* fixed zero-initialized pages */
#define PD_FIXED    0x00000004	/* fixed uninitialized pages */

/* PageCommit flags */
#define PC_FIXED    0x00000008	/* pages are permanently locked */
#define PC_LOCKED   0x00000080	/* pages are made present and locked*/
#define PC_LOCKEDIFDP	0x00000100  /* pages are locked if swap via DOS */
#define PC_WRITEABLE	0x00020000  /* make the pages writeable */
#define PC_USER     0x00040000	/* make the pages ring 3 accessible */
#define PC_INCR     0x40000000	/* increment "pagerdata" each page */
#define PC_PRESENT  0x80000000	/* make pages initially present */
#define PC_STATIC   0x20000000	/* allow commit in PR_STATIC object */
#define PC_DIRTY    0x08000000	/* make pages initially dirty */
#define PC_CACHEDIS 0x00100000  /* Allocate uncached pages - new for WDM */
#define PC_CACHEWT  0x00080000  /* Allocate write through cache pages - new for WDM */

/* PageCommitContig additional flags */
#define PCC_ZEROINIT	0x00000001  /* zero-initialize new pages */
#define PCC_NOLIN   0x10000000	/* don't map to any linear address */


/*MTRR type flags */
#define MTRR_UC 0
#define MTRR_WC 1
#define	MTRR_WT 4
#define	MTRR_WP 5
#define	MTRR_WB 6

/*
 *  Structure and flags for PageQuery
 */
#ifndef _WINNT_
typedef struct _MEMORY_BASIC_INFORMATION {
    ULONG mbi_BaseAddress;
    ULONG mbi_AllocationBase;
    ULONG mbi_AllocationProtect;
    ULONG mbi_RegionSize;
    ULONG mbi_State;
    ULONG mbi_Protect;
    ULONG mbi_Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

#define PAGE_NOACCESS	       0x01
#define PAGE_READONLY	       0x02
#define PAGE_READWRITE	       0x04
#define MEM_COMMIT	     0x1000
#define MEM_RESERVE	     0x2000
#define MEM_FREE	    0x10000
#define MEM_PRIVATE	    0x20000
#endif


/***ET+ PD - Pager Descriptor
 *
 *  A PD describes a set of routines to call to bring a page into
 *  the system or to get it out.  Each committed page in the system
 *  has an associated PD, a handle to which is stored in the page's
 *  VP.
 *
 *  For any field that is 0, the pager will not be notified
 *  when that action takes place.
 *
 *  For the purpose of pagers, a page can be in one of the two states
 *  describing its current contents:
 *
 *	clean - page has not been written to since its last page out
 *	dirty - page has been written to since its last page out
 *
 *  A page also is in one of two persistent states:
 *
 *	virgin - page has never been written to since it was committed
 *	tainted - page has been written to since it was committed
 *
 *  Note that a tainted page may be either dirty or clean, but a
 *  virgin page is by definition clean.
 *
 *  Examples of PDs:
 *
 *	For 32-bit EXE code or read-only data:
 *
 *	  pd_virginin = routine to load page from an exe file
 *	  pd_taintedin = 0
 *	  pd_cleanout = 0
 *	  pd_dirtyout = 0
 *	  pd_virginfree = 0
 *    pd_taintedfree = 0
 *    pd_dirty = 0
 *	  pd_type = PD_PAGERONLY
 *
 *	For 32-bit EXE writeable data:
 *
 *	  pd_virginin = routine to load page from an exe file
 *	  pd_taintedin = routine to load page from swap file
 *	  pd_cleanout = 0
 *	  pd_dirtyout = routine to write a page out to the swap file
 *	  pd_virginfree = 0
 *	  pd_taintedfree = routine to free page from the swap file
 *	  pd_dirty = routine to free page from the swap file
 *	  pd_type = PD_SWAPPER
 *
 *	For zero-initialized swappable data:
 *
 *	  pd_virginin = routine to zero-fill a page
 *	  pd_taintedin = routine to load page from swap file
 *	  pd_cleanout = 0
 *	  pd_dirtyout = routine to write a page out to the swap file
 *	  pd_virginfree = 0
 *	  pd_taintedfree = routine to free page from the swap file
 *	  pd_dirty = routine to free page from the swap file
 *	  pd_type = PD_SWAPPER
 */
/* typedefs for various pager functions */

typedef ULONG _cdecl FUNPAGE(PULONG ppagerdata, PVOID ppage, ULONG faultpage);

typedef FUNPAGE * PFUNPAGE;

struct pd_s {
    /*
     *	The following four fields are entry points in the pager which
     *	we call to page in or page out a page.	The following parameters
     *	are passed to the pager during these calls:
     *
     *	ppagerdata - pointer to the pager-specific dword of data
     *		 stored with the virtual page.	The pager is
     *		 free to modify the contents of this dword
     *		 DURING the page in or out, but not afterwards.
     *
     *	ppage - pointer to page going in or out (a ring 0 alias
     *	    to the physical page).  The pager should use this
     *	    address to access the contents of the page.
     *
     *	faultpage - faulting linear page number for page-ins, -1 for
     *		page-outs.  This address should not be accessed
     *		by the pager.  It is provided for information
     *		only.  Note that a single page can be mapped at
     *		more than one linear address because of the
     *		MapIntoV86 and LinMapIntoV86 services.
     *
     *	The pager should return non-0 if the page was successfully
     *	paged, or 0 if it failed.
     */
    PFUNPAGE pd_virginin;   /* in - while page has never been written to */
    PFUNPAGE pd_taintedin;  /* in - page written to at least once */
    PFUNPAGE pd_cleanout;   /* out - page not written to since last out */
    PFUNPAGE pd_dirtyout;   /* out - page was written to since last out */

    /*
     *	The pd_*free routines are used to inform the pager when the last
     *	reference to a virtual page controlled by the pager is
     *	decommitted.  A common use of this notification is to
     *	free space in a backing file, or write the page contents
     *	into the backing file.
     *
     *	These calls take the same parameters as the page-out and -in
     *	functions, but no return value is recognized.  The "ppage"
     *	and "faultpage" parameters will always be 0.
     */
    PFUNPAGE pd_virginfree;  /* decommit of never-written-to page */
    PFUNPAGE pd_taintedfree; /* decommit of page written to at least once*/

    /*
     *	The pd_dirty routine is used to inform the pager when the
     *	memory manager detects that a page has been written to.  The memory
     *	manager does not detect the write at the instant it occurs, so
     *	the pager should not depend upon prompt notification.  A common
     *	use of this notification might be to invalidate cached data.
     *	If the page was dirtied in more than one memory context,
     *	the pager's pd_dirty routine will be called once for each
     *	context.
     *
     *	These calls take the same parameters as the page-out and -in
     *	functions except that the "ppage" parameter isn't valid and
     *	no return value is recognized.
     */
    PFUNPAGE pd_dirty;

    /*
     *	The pd_type field gives the sytem information about the
     *	overcommit characteristics of pages controlled by this pager.
     *	The following are allowable values for the field:
     *
     *	PD_SWAPPER - under some conditions, pages of this type
     *	    may be paged out into the swap file
     *	PD_PAGERONLY - pages controlled by this pager will never
     *	    be paged out to the swap file
     *
     *	In addition, the following value may be or'ed in to the pd_type field:
     *
     *	PD_NESTEXEC - must be specified if either the pd_cleanout or pd_dirtyout
     *	    functions perform nested excecution or block using the
     *	    BLOCK_SVC_INTS flag.  To be safe, this flag should always be
     *	    specified if the pager does any sort of file i/o to anything
     *	    other than the default paging file.
     */
    ULONG pd_type;
};
typedef struct pd_s PD;
typedef PD * PPD;

/* values for pd_type */
#define PD_SWAPPER  0	/* pages need direct accounting in swap file */
#define PD_PAGERONLY	1   /* pages will never be swapped */
#define PD_NESTEXEC 2	/* page out funtion uses nested execution */

#endif // Not_VxD

/*
 *  The size of a page of memory
 */
#define PAGESHIFT   12
#define PAGESIZE    (1 << PAGESHIFT)
#define PAGEMASK    (PAGESIZE - 1)

#define PAGE(p) ((DWORD)(p) >> PAGESHIFT)
#define NPAGES(cb) (((DWORD)(cb) + PAGEMASK) >> PAGESHIFT)

/*
 *  Address space (arena) boundaries
 */
#define MAXSYSTEMLADDR	    ((ULONG) 0xffbfffff)    /* 4 gig - 4meg */
#define MINSYSTEMLADDR	    ((ULONG) 0xc0000000)    /* 3 gig */
#define MAXSHAREDLADDR	    ((ULONG) 0xbfffffff)
#define MINSHAREDLADDR	    ((ULONG) 0x80000000)    /* 2   gig */
#define MAXPRIVATELADDR     ((ULONG) 0x7fffffff)
#define MINPRIVATELADDR     ((ULONG) 0x00400000)    /* 4 meg */
#define MAXDOSLADDR	((ULONG) 0x003fffff)
#define MINDOSLADDR	((ULONG) 0x00000000)

#define MAXSYSTEMPAGE	    (MAXSYSTEMLADDR >> PAGESHIFT)
#define MINSYSTEMPAGE	    (MINSYSTEMLADDR >> PAGESHIFT)
#define MAXSHAREDPAGE	    (MAXSHAREDLADDR >> PAGESHIFT)
#define MINSHAREDPAGE	    (MINSHAREDLADDR >> PAGESHIFT)
#define MAXPRIVATEPAGE	    (MAXPRIVATELADDR >> PAGESHIFT)
#define MINPRIVATEPAGE	    (MINPRIVATELADDR >> PAGESHIFT)
#define MAXDOSPAGE	(MAXDOSLADDR >> PAGESHIFT)
#define MINDOSPAGE	(MINDOSLADDR >> PAGESHIFT)

#define CBPRIVATE	(1 + MAXPRIVATELADDR - MINPRIVATELADDR)
#define CBSHARED	(1 + MAXSHAREDLADDR - MINSHAREDLADDR)
#define CBSYSTEM	(1 + MAXSYSTEMLADDR - MINSYSTEMLADDR)
#define CBDOS		(1 + MAXDOSLADDR - MINDOSLADDR)

#define CPGPRIVATE	(1 + MAXPRIVATEPAGE - MINPRIVATEPAGE)
#define CPGSHARED	(1 + MAXSHAREDPAGE - MINSHAREDPAGE)
#define CPGSYSTEM	(1 + MAXSYSTEMPAGE - MINSYSTEMPAGE)
#define CPGDOS		(1 + MAXDOSPAGE - MINDOSPAGE)

/*XLATOFF*/
/*
 *  Largest object that could theoretically be allocated
 */
#define CBMAXALLOC	(max(CBSHARED,max(CBPRIVATE, CBSYSTEM)))
#define CPGMAXALLOC	(max(CPGSHARED,max(CPGPRIVATE, CPGSYSTEM)))

/*XLATON*/

/* ASM
IFDEF DEBUG
DebFar	EQU NEAR PTR
ELSE
DebFar	EQU SHORT
ENDIF
*/

#ifndef Not_VxD

/******************************************************************************
 *
 *	     EQUATES FOR SYSTEM_CONTROL CALLS
 *
 *****************************************************************************/

/*
 *  SYS_CRITICAL_INIT is a device init call.  Devices that have a
 *  critical function that needs initializing before interrupts are
 *  enabled should do it at Sys_Critical_Init.	Devices which REQUIRE a
 *  certain range of V86 pages to operate (such as the VDD video memory)
 *  should claim them at Sys_Critical_Init.  SYS VM Simulate_Int,
 *  Exec_Int ACTIVITY IS NOT ALLOWED.  Returning carry aborts device
 *  load only.
 */
#define SYS_CRITICAL_INIT   0x0000	/* Devices req'd for virt mode */

/*
 *  DEVICE_INIT is where most devices do the bulk of their initialization.
 *  SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
 *  aborts device load only.
 */
#define DEVICE_INIT	0x0001	    /* All other devices init */

/*
 *  INIT_COMPLETE is the final phase of device init called just before the
 *  WIN386 INIT pages are released and the Instance snapshot is taken.
 *  Devices which wish to search for a region of V86 pages >= A0h to use
 *  should do it at INIT_COMPLETE.
 *  SYS VM Simulate_Int, Exec_Int activity is allowed.	Returning carry
 *  aborts device load only.
 */
#define INIT_COMPLETE	    0x0002	/* All devices initialized */

/* --------------- INITIALIZATION CODE AND DATA DISCARDED ------------------ */

/*
 *  Same as VM_Init, except for SYS VM.
 */
#define SYS_VM_INIT	0x0003	    /* Execute the system VM */

/*
 *  Same as VM_Terminate, except for SYS VM (Normal WIN386 exit ONLY, on a crash
 *  exit this call is not made).  SYS VM Simulate_Int, Exec_Int activity is
 *  allowed.  This and Sys_VM_Terminate2 are your last chances to access
 *  and/or lock pageable data.
 */
#define SYS_VM_TERMINATE    0x0004	/* System VM terminated */

/*
 *  System_Exit call is made when WIN386 is exiting either normally or via
 *  a crash.  INTERRUPTS ARE ENABLED.  Instance snapshot has been restored.
 *  SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT ALLOWED.
 */
#define SYSTEM_EXIT	0x0005	    /* Devices prepare to exit */

/*
 *  SYS_CRITICAL_EXIT call is made when WIN386 is exiting either normally or via
 *  a crash.  INTERRUPTS ARE DISABLED.	SYS VM Simulate_Int, Exec_Int ACTIVITY
 *   IS NOT ALLOWED.
 */
#define SYS_CRITICAL_EXIT   0x0006	/* System critical devices reset */


/*
 *  Create_VM creates a new VM.  EBX = VM handle of new VM.  Returning
 *  Carry will fail the Create_VM.
 */
#define CREATE_VM	0x0007

/*
 *  Second phase of Create_VM.	EBX = VM handle of new VM.  Returning
 *  Carry will cause the VM to go Not_Executeable, then be destroyed.
 *  VM Simulate_Int, Exec_Int activity is NOT allowed.
 */
#define VM_CRITICAL_INIT    0x0008

/*
 *  Third phase of Create_VM.  EBX = VM handle of new VM.  Returning
 *  Carry will cause the VM to go Not_Executeable, then be destroyed.
 *  VM Simulate_Int, Exec_Int activity is allowed.
 */
#define VM_INIT 	0x0009

/*
 *  NORMAL (First phase) of Destroy_VM.  EBX = VM Hanlde.  This occurs
 *  on normal termination of the VM.  Call cannot be failed.  VM
 *  Simulate_Int, Exec_Int activity is allowed.
 */
#define VM_TERMINATE	    0x000A	/* Still in VM -- About to die */

/*
 *  Second phase of Destroy_VM.  EBX = VM Handle, EDX = Flags (see
 *  below).  Note that in the case of destroying a running VM, this is
 *  the first call made (VM_Terminate call does not occur).  Call cannot
 *  be failed.	VM Simulate_Int, Exec_Int activity is NOT allowed.
 */
#define VM_NOT_EXECUTEABLE  0x000B	/* Most devices die (except VDD) */

/*
 *  Final phase of Destroy_VM.	EBX = VM Handle.  Note that considerable
 *  time can elaps between the VM_Not_Executeable call and this call.
 *  Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
 *  allowed.
 */
#define DESTROY_VM	0x000C	    /* VM's control block about to go */


/*
 *  Flags for VM_Not_Executeable control call (passed in EDX)
 */
#define VNE_CRASHED_BIT     0x00	/* VM was crashed */
#define VNE_CRASHED	(1 << VNE_CRASHED_BIT)
#define VNE_NUKED_BIT	    0x01	/* VM was destroyed while active */
#define VNE_NUKED	(1 << VNE_NUKED_BIT)
#define VNE_CREATEFAIL_BIT  0x02	/* Some device failed Create_VM */
#define VNE_CREATEFAIL	    (1 << VNE_CREATEFAIL_BIT)
#define VNE_CRINITFAIL_BIT  0x03	/* Some device failed VM_Critical_Init */
#define VNE_CRINITFAIL	    (1 << VNE_CRINITFAIL_BIT)
#define VNE_INITFAIL_BIT    0x04	/* Some device failed VM_Init */
#define VNE_INITFAIL	    (1 << VNE_INITFAIL_BIT)
#define VNE_CLOSED_BIT	    0x05
#define VNE_CLOSED	(1 << VNE_CLOSED_BIT)


/*
 *  EBX = VM Handle. Call cannot be failed.
 */
#define VM_SUSPEND	0x000D	    /* VM not runnable until resume */

/*
 *  EBX = VM Handle. Returning carry fails and backs out the resume.
 */
#define VM_RESUME	0x000E	    /* VM is leaving suspended state */


/*
 *  EBX = VM Handle to set device focus to.  EDX = Device ID if device
 *  specific setfocus, == 0 if device critical setfocus (all devices).
 *  THIS CALL CANNOT BE FAILED.
 *
 *  NOTE: In case where EDX == 0, ESI is a FLAG word that indicates
 *  special functions.	Currently Bit 0 being set indicates that this
 *  Device critical set focus is also "VM critical".  It means that we
 *  do not want some other VM to take the focus from this app now.  This
 *  is primarily used when doing a device critical set focus to Windows
 *  (the SYS VM) it is interpreted by the SHELL to mean "if an old app
 *  currently has the Windows activation, set the activation to the
 *  Windows Shell, not back to the old app".  ALSO in the case where Bit
 *  0 is set, EDI = The VM handle of the VM that is "having trouble".
 *  Set this to 0 if there is no specific VM associated with the
 *  problem.
 */
#define SET_DEVICE_FOCUS    0x000F


/*
 *  EBX = VM Handle going into message mode.  THIS CALL CANNOT BE FAILED.
 */
#define BEGIN_MESSAGE_MODE  0x0010

/*
 *  EBX = VM Handle leaving message mode.  THIS CALL CANNOT BE FAILED.
 */
#define END_MESSAGE_MODE    0x0011


/* ----------------------- SPECIAL CONTROL CALLS --------------------------- */

/*
 *  Request for reboot.  Call cannot be failed.
 */
#define REBOOT_PROCESSOR    0x0012	/* Request a machine reboot */

/*
 *  Query_Destroy is an information call made by the SHELL device before
 *  an attempt is made to initiate a destroy VM sequence on a running VM
 *  which has not exited normally.  EBX = VM Handle.  Returning carry
 *  indicates that a device "has a problem" with allowing this.  THE
 *  DESTROY SEQUENCE CANNOT BE ABORTED HOWEVER, this decision is up to
 *  the user.  All this does is indicate that there is a "problem" with
 *  allowing the destroy.  The device which returns carry should call
 *  the SHELL_Message service to post an informational dialog about the
 *  reason for the problem.
 */
#define QUERY_DESTROY	    0x0013	/* OK to destroy running VM? */


/* ----------------------- DEBUGGING CONTROL CALL -------------------------- */

/*
 *  Special call for device specific DEBUG information display and activity.
 */
#define DEBUG_QUERY	0x0014


/* -------- CALLS FOR BEGIN/END OF PROTECTED MODE VM EXECUTION ------------- */

/*
 *   About to run a protected mode application.
 *   EBX = Current VM handle.
 *   EDX = Flags
 *   EDI -> Application Control Block
 *   Returning with carry set fails the call.
 */
#define BEGIN_PM_APP	    0x0015

/*
 *  Flags for Begin_PM_App (passed in EDX)
 */
#define BPA_32_BIT	0x01
#define BPA_32_BIT_FLAG     1

/*
 *  Protected mode application is terminating.
 *  EBX = Current VM handle.  THIS CALL CAN NOT FAIL.
 *  EDI -> Application Control Block
 */
#define END_PM_APP	0x0016

/*
 *  Called whenever system is about to be rebooted.  Allows VxDs to clean
 *  up in preperation for reboot.
 */
#define DEVICE_REBOOT_NOTIFY	0x0017
#define CRIT_REBOOT_NOTIFY  0x0018

/*
 *  Called when VM is about to be terminated using the Close_VM service
 *  EBX = Current VM handle (Handle of VM to close)
 *  EDX = Flags
 *	  CVNF_CRIT_CLOSE = 1 if VM is in critical section while closing
 */
#define CLOSE_VM_NOTIFY     0x0019

#define CVNF_CRIT_CLOSE_BIT 0
#define CVNF_CRIT_CLOSE     (1 << CVNF_CRIT_CLOSE_BIT)

/*
 *  Power management event notification.
 *  EBX = 0
 *  ESI = event notification message
 *  EDI -> DWORD return value; VxD's modify the DWORD to return info, not EDI
 *  EDX is reserved
 */
#define POWER_EVENT	0x001A

#define SYS_DYNAMIC_DEVICE_INIT 0x001B
#define SYS_DYNAMIC_DEVICE_EXIT 0x001C

/*
 *  Create_THREAD creates a new thread.  EDI = handle of new thread.
 *  Returning Carry will fail the Create_THREAD. Message is sent in the
 *  context of the creating thread.
 *
 */
#define  CREATE_THREAD	0x001D

/*
 *  Second phase of creating a thread.	EDI = handle of new thread.  Call cannot
 *  be failed. VM Simulate_Int, Exec_Int activity is not allowed (because
 *  never allowed in non-initial threads). Message is sent in the context
 *  of the newly created thread.
 *
 */
#define  THREAD_INIT	0x001E

/*
 *  Normal (first) phase of Destroy_THREAD. EDI = handle of thread.
 *  This occurs on normal termination of the thread.  Call cannot be failed.
 *  Simulate_Int, Exec_Int activity is allowed.
 */
#define  TERMINATE_THREAD  0x001F

/*
 *  Second phase of Destroy_THREAD.  EDI = Handle of thread,
 *  EDX = flags (see below).  Note that in the case of destroying a
 *  running thread, this is the first call made (THREAD_Terminate call
 *  does not occur).  Call cannot be failed.  VM Simulate_Int, Exec_Int
 *  activity is NOT allowed.
 *
 */
#define  THREAD_Not_Executeable  0x0020

/*
 *  Final phase of Destroy_THREAD.  EDI = Thread Handle.  Note that considerable
 *  time can elapse between the THREAD_Not_Executeable call and this call.
 *  Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
 *  allowed.
 *
 */
#define  DESTROY_THREAD    0x0021

/* -------------------- CALLS FOR PLUG&PLAY ------------------------- */

/*
 *  Configuration manager or a devloader is telling a DLVxD that a new devnode
 *  has been created. EBX is the handle of the new devnode and EDX is the load
 *  type (one of the DLVxD_LOAD_* defined in CONFIGMG.H). This is a 'C'
 *  system control call. Contrarily to the other calls, carry flags must be
 *  set if any error code other than CR_SUCCESS is to be return.
 *
 */
#define PNP_NEW_DEVNODE     0x0022


/* -------------------- CALLS FOR Win32  ------------------------- */

/* vWin32 communicates with Vxds on behalf of Win32 apps thru this mechanism.
 * FEATURE: need more doc here, describing the interface
 */

#define W32_DEVICEIOCONTROL 0x0023

/* sub-functions */
#define DIOC_GETVERSION     0x0
#define DIOC_OPEN	DIOC_GETVERSION
#define DIOC_CLOSEHANDLE    -1

/* -------------------- MORE SYSTEM CALLS ------------------------- */

/*
 * All these messages are sent immediately following the corresponding
 * message of the same name, except that the "2" messages are sent
 * in *reverse* init order.
 */

#define SYS_VM_TERMINATE2   0x0024
#define SYSTEM_EXIT2	    0x0025
#define SYS_CRITICAL_EXIT2  0x0026
#define VM_TERMINATE2	    0x0027
#define VM_NOT_EXECUTEABLE2 0x0028
#define DESTROY_VM2	0x0029
#define VM_SUSPEND2	0x002A
#define END_MESSAGE_MODE2   0x002B
#define END_PM_APP2	0x002C
#define DEVICE_REBOOT_NOTIFY2	0x002D
#define CRIT_REBOOT_NOTIFY2 0x002E
#define CLOSE_VM_NOTIFY2    0x002F

/*
 * VCOMM gets Address of Contention handler from VxDs by sending this
 * control message
 */

#define GET_CONTENTION_HANDLER	0x0030

#define KERNEL32_INITIALIZED	0x0031

#define KERNEL32_SHUTDOWN	0x0032

#define CREATE_PROCESS		0x0033
#define DESTROY_PROCESS 	0x0034

#define MAX_SYSTEM_CONTROL	0x0034

/*
 * Dynamic VxD's can communicate with each other using Directed_Sys_Control
 * and a private control message in the following range:
 */

#define BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL	0x70000000
#define END_RESERVED_PRIVATE_SYSTEM_CONTROL 0x7FFFFFFF

#endif // Not_VxD

/*
 * Values returned from VMM_GetSystemInitState in EAX.
 *
 * Comments represent operations performed by VMM; #define's indicate
 * what VMM_GetSystemInitState will return if you call it between the
 * previous operation and the next.
 *
 * Future versions of Windows may have additional init states between the
 * ones defined here, so you should be careful to use range checks instead
 * of test for equality.
 */

		    /* Protected mode is entered */
#define SYSSTATE_PRESYSCRITINIT     0x00000000
		    /* SYS_CRITICAL_INIT is broadcast */
#define SYSSTATE_PREDEVICEINIT	    0x10000000
		    /* DEVICE_INIT is broadcast */
#define SYSSTATE_PREINITCOMPLETE    0x20000000
		    /* INIT_COMPLETE is broadcast */
		    /* VxD initialization complete */
#define SYSSTATE_VXDINITCOMPLETED   0x40000000
		    /* KERNEL32_INITIALIZED is broadcast */
#define SYSSTATE_KERNEL32INITED     0x50000000
		    /* All initialization completed */
		    /* System running normally */
		    /* System shutdown initiated */
		    /* KERNEL32_SHUTDOWN is broadcast */
#define SYSSTATE_KERNEL32TERMINATED 0xA0000000
		    /* System shutdown continues */
#define SYSSTATE_PRESYSVMTERMINATE  0xB0000000
		    /* SYS_VM_TERMINATE is broadcast */
#define SYSSTATE_PRESYSTEMEXIT	    0xE0000000
		    /* SYSTEM_EXIT is broadcast */
#define SYSSTATE_PRESYSTEMEXIT2     0xE4000000
		    /* SYSTEM_EXIT2 is broadcast */
#define SYSSTATE_PRESYSCRITEXIT     0xF0000000
		    /* SYS_CRITICAL_EXIT is broadcast */
#define SYSSTATE_PRESYSCRITEXIT2    0xF4000000
		    /* SYS_CRITICAL_EXIT2 is broadcast */
#define SYSSTATE_POSTSYSCRITEXIT2   0xFFF00000
		    /* Return to real mode */
		    /* Alternate path: CAD reboot */
#define SYSSTATE_PREDEVICEREBOOT    0xFFFF0000
		    /* DEVICE_REBOOT_NOTIFY is broadcast */
#define SYSSTATE_PRECRITREBOOT	    0xFFFFF000
		    /* CRIT_REBOOT_NOTIFY is broadcast */
#define SYSSTATE_PREREBOOTCPU	    0xFFFFFF00
		    /* REBOOT_PROCESSOR is broadcast */
		    /* Return to real mode */

/* ASM
BeginDoc
;******************************************************************************
; BeginProc is a macro for defining entry points to routines in VMM and in the
;   VxDs. It correctly defines the procedure name for VxD services, DWORD
;   aligns the procedure, takes care of public declaration and does some
;   calling verification for debug versions of the software. EndProc is a
;   macro which defines the end of the procedure.
;
; Valid parameters to the BeginProc macro are:
;   PUBLIC		; Used outside this module (default)
;   LOCAL		; Local to this module
;   HIGH_FREQ		; DWORD align procedure
;   SERVICE		; Routine is called via VxDCall
;   ASYNC_SERVICE	    ; Same as "SERVICE" plus routine can
;		    ;	be called under interrupt.
;   HOOK_PROC		; Proc is a handler installed with
;		    ;	with a call to Hook_xxx_Fault
;		    ;	or Hook_Device_Service.  The
;		    ;	following parameter must be
;		    ;	the label of a DWORD location
;		    ;	which will hold the ptr to next
;		    ;	hook proc. e.g.
;
;		   ;BeginProc foo, SERVICE, HOOK_PROC, foo_next_ptr
;
;   NO_LOG		; Disable Queue_Out call logging
;   NO_PROFILE		; Disable DynaLink profile counts
;   NO_TEST_CLD 	; Disable direction flag check
;
;   TEST_BLOCK		; Trap if in NOBLOCK state
;		    ;  (default if in pageable code seg)
;   TEST_REENTER	    ; Trap if Get_VMM_Reenter_Count != 0
;		    ;  (default for non-async services)
;   NEVER_REENTER	    ; Trap if VMM has been reentered
;   NOT_SWAPPING	    ; Trap if this thread is swapping
;
;   NO_PROLOG		; Disable all prolog tests
;
;   ESP 	    ; Use ESP instead of EBP for stack
;		    ;  frame base
;   PCALL		; pascal calling convention
;   SCALL		; stdcall calling convention
;   FASTCALL		; stdcall, but first 2 parameters are passed in ECX & EDX
;   CCALL		; "C" calling convention
;   ICALL		; default calling convention
;   W32SVC		; Win32 service
;
;   segment type	    ; Place function in specified segment
;
; The NO_PROFILE flag merely suppresses incrementing the profile count.
; The DWORD of profiling information will still be emitted to appease
; the debugger.  If you want to increment the profile count manually,
; use the IncProfileCount macro.
;
; TEST_REENTER and NEVER_REENTER differ in that the VMM reentry count
; returned by Get_VMM_Reenter_Count is artifically forced to zero by
; Begin_Reentrant_Execution, whereas the counter checked by NEVER_REENTER
; reflects the genuine count of VMM reentry.
;
; A segment type (such as LOCKED, PAGEABLE, STATIC, INIT, DEBUG_ONLY) can be
; provided, in which case the BeginProc and EndProc macros will
; automatically place the appropriate segment directives around the
; definition of the function.
;
;   segment type	    ; Place function in specified segment
;
; After the routine header in which the routine entry conditions, exit
;   conditions, side affects and functionality are specified, the BeginProc
;   macro should be used to define the routine's entry point. It has up to
;   four parameters as specified below. For example:
;
;BeginProc  <Function_Name>,PUBLIC, HIGH_FREQ, SERVICE, ASYNC_SERVICE, ESP
;
;   <code>
;
;EndProc    <Function_Name>
;==============================================================================
EndDoc
;
; BeginProc handling takes place in the following phases:
;
;   Phase 1:  Parsing the arguments.
;   Phase 2:  Setting default flags.
;   Phase 3:  Combining the flags.
;   Phase 4:  Code emitted before the label
;   Phase 5:  Munge the name as exported to C/Pascal/whoever
;   Phase 6:  _Debug_Flags_Service prolog
;   Phase 7:  Code emitted after the label
;

??_pf_Check equ 1	;; Do Enter/LeaveProc checking?
??_pf_ArgsUsed	equ 2	    ;; ArgVars were used
??_pf_Entered	equ 4	    ;; EnterProc performed
??_pf_Left  equ 8	;; LeaveProc performed
??_pf_Returned	equ    16		;; Return performed

??_pushed	=	0		;; For WIN31COMPAT
??_align    =	0	;; For WIN31COMPAT
??_ends     equ <>	;; BeginProc segment

BeginProc macro Name, P1, P2, P3, P4, P5, P6, P7, LastArg
    local   Profile_Data, prelabeldata, ??_hookvar
    ??_frame = 0	    ;; local frame base
    ??_aframe = 0	    ;; argument frame base
    ??_taframe = 0	    ;; true argument frame base
    ??_initaframe = 0	    ;; initial aframe value
    ??_numargs = 0	    ;; number of argvars
    ??_numlocals = 0	    ;; number of localvars
    ??_numlocalsymbols = 0	;; number of local symbols
    ??_procflags = 0	    ;; misc. Enter/LeaveProc flags
    ??_esp = 0		;; if VMM_TRUE, use esp instead of ebp
    ??_pushed = 0	    ;; number of bytes pushed
    ??_align = 0	    ;; set if proc should be dword aligned
    ??_hook = 0 	;; set if proc is a Hook_Proc
    ??_hookarg = 0
    ??_service = 0
    ??_async_service = 0
IF DEBLEVEL GT DEBLEVELNORMAL
    ??_log = DFS_LOG	    ;; logging on by default
    ??_profile = DFS_PROFILE	;; service profiling on by default
    ??_test_cld = DFS_TEST_CLD	;; test that direction is clear
ELSE
    ??_log = 0		;; logging off
IFDEF DEBUG
IFDEF profileall
IF ?_ICODE
    ??_profile = DFS_PROFILE	;; service profiling on by default
ELSE
    ??_profile = 0	    ;; service profiling off
ENDIF
ELSE
    ??_profile = 0	    ;; service profiling off
ENDIF
ELSE
    ??_profile = 0	    ;; service profiling off
ENDIF
    ??_test_cld = 0	    ;; test that direction is clear
ENDIF
    ??_might_block = 0	    ;; entering fn might cause VM to block
    ??_test_reenter = 0     ;; don't test for VMM reentry
    ??_never_reenter = 0	;; don't test for genuine VMM reentry
    ??_not_swapping = 0     ;; don't test that we're not swapping
    ??_prolog_disabled = 0	;; use a prolog by default
    ??_public = 1	    ;; everything's public by default
    ??_cleanoff = 0	    ;; don't cleanoff parameters
    ??_ccall = 0
    ??_pcall = 0
    ??_scall = 0
    ??_fastcall = 0
    ??_w32svc = 0
    ??_fleave = FALSE
;   ??_dfs = 0		;; parm for _Debug_Flags_Service
    ??_name equ <Name>

    .errnb ??_ends, <Cannot nest functions with named segments>
    .errnb <LastArg>, <Too many arguments to BeginProc>

    ;; Phase 1: Parsing the arguments
    irp arg, <P1, P2, P3, P4, P5, P6, P7>
	if ??_hookarg
	??_hookarg = 0
	??_hookvar equ <arg>
	elseifdef ?&&arg&&_BeginProc
	    ?&&arg&&_BeginProc
	elseifdef VxD_&&arg&&_CODE_SEG
	??_ends textequ <VxD_&&arg&&_CODE_ENDS>
	VxD_&&arg&&_CODE_SEG
	else
	.err <Bad param "&arg" to BeginProc>
	endif
    endm

    ;; Phase 2:  Setting default flags
    ifndef Not_VxD
    ife ??_service
	ifndef profileall
	  ??_profile = 0      ;; only services can be profiled
	endif
	ifdef VMMSYS
	??_prolog_disabled = 1
	endif
    else
	??_test_cld = DFS_TEST_CLD
    endif	; ife ??_service

    ife ?_16ICODE
	??_prolog_disabled = 1
    else
    ife ?_RCODE 	    ;; if real-mode code segment
	??_prolog_disabled = 1	;; don't do anything bad
    else		;; else protected mode code segment
	ife ?_PCODE	;; if swappable code
	??_might_block = DFS_TEST_BLOCK
	endif
	if ??_service
	ife ??_async_service
	    ??_test_reenter = DFS_TEST_REENTER
	endif
	endif
    endif	; ife ?_RCODE
    endif	; ife ?_16ICODE
    endif   ; Not_VxD

    if ??_esp
    ;; just return address on stack
    ??_basereg equ <esp+??_pushed>
    ??_initaframe = 4
    else
    ;; ret addr and EBP on stack
    ??_basereg equ <ebp>
    ??_initaframe = 8
    endif
    @Caller equ <dword ptr [??_basereg+??_initaframe-4]>

    ??_cleanoff = ??_pcall or ??_scall or ??_fastcall

    ;; Phase 3:  Combining the flags
    ??_dfs = ??_never_reenter + ??_test_reenter + ??_not_swapping + \
	 ??_log + ??_profile + ??_test_cld + ??_might_block

    if ??_prolog_disabled
	??_dfs = 0
    endif

    ;; Phase 4:  Pre-label code

    ifndef Not_VxD

    if ??_hook
	if ??_align
	Dword_Align
	endif
	prelabeldata:
	ifndef ??_hookvar
	.err <HOOK_PROC requires next arg to be name of dword location>
	endif
	jmp short Name
	jmp [??_hookvar]
	ifdef DEBUG
	Profile_Data dd  0
	endif
	if ??_align
	.errnz ($ - prelabeldata) mod 4
	endif
    endif

    ifdef DEBUG
	?prolog_&Name label near
	if (??_service OR ??_profile) AND (??_hook EQ 0)
	jmp short Name
	if ??_align
	Dword_Align	; This also aligns the proc
	endif		;   since Profile_Data is a dd

	IF ?_ICODE
	ifdef profileall
	  ?ProfileHeader_BeginProc Profile_Data, %@filename
	else
	  Profile_Data dd 0
	endif
	ELSE
	  Profile_Data dd 0
	ENDIF

	endif
    endif

    if ??_align
	Dword_Align
    endif

    endif   ; Not_VxD

    Name proc near	;; The label

    ;; Phase 5:  Munge the name as exported to C/Pascal/whoever
    ;;	     Warning!  Phase 5 cannot emit code!
    ife ??_pcall or ??_ccall or ??_scall or ??_fastcall    ;; if no munging
	if ??_public
	    public Name
	else
	    ifdef DEBUG
		% ?merge @FileName,$,Name,:
		% ?merge public,,,,,@FileName,$,Name
	    endif
	endif
    endif
    if ??_ccall
	if ??_public
	    _&Name equ Name
	ifdef Not_VxD
	 public C Name
	else
		 public _&Name
	endif
	endif
    endif
    if ??_pcall
	if ??_public
	    ?toupper Name
	    ?merge  public,,,,%?upper
	endif
    endif
    ;; Phase 6:  _Debug_Flags_Service prolog
    ;;	     DO NOT CHANGE UNTIL YOU UNDERSTAND _Debug_Flags_Service

    ife ??_scall or ??_fastcall
    ?_BeginProc_Debug_Prologue
    endif

    ;; Phase 7:  Post-label code
    ;;	     <none>
endm

?_BeginProc_Debug_Prologue MACRO
    ifndef Not_VxD
    ifdef DEBUG
	if ??_dfs EQ DFS_LOG
	VMMCall Log_Proc_Call	;; no test, just log
	else
	if ??_dfs EQ DFS_TEST_REENTER
	VMMCall Test_Reenter	;; no log, just reenter
	else
	if ??_dfs or ?_LOCKABLECODE eq 0
	ifdef WIN31COMPAT
	    if ??_dfs AND DFS_LOG
	    VMMCall Log_Proc_Call
	    endif
	    if ??_dfs AND DFS_TEST_REENTER
	    VMMCall Test_Reenter
	    endif
	else
	    ife ?_LOCKABLECODE
	    ifdef ??_debug_flags
	    push    ??_debug_flags
	    if ??_dfs
	    pushfd
	    or	dword ptr [esp+4],??_dfs
	    popfd
	    endif
	    VMMCall _Debug_Flags_Service
	    elseif ??_dfs
	    push    ??_dfs
	    VMMCall _Debug_Flags_Service
	    endif
	    else
	    push    ??_dfs
	    VMMCall _Debug_Flags_Service
	    endif
	endif
	else
	  ifdef profileall
	IncProfileCount
	  endif
	endif		;if ??_dfs
	endif		; if ??_dfs EQ DFS_TEST_REENTER
	endif		; if ??_dfs EQ DFS_LOG
    endif ; DEBUG
    endif ; Not_VxD
ENDM

;
; For each BeginProc keyword, there is a corresponding macro ?XX_BeginProc.
;
; The macro ?_BeginProc is so that the null keyword is not an error.

?_BeginProc macro
endm

?PUBLIC_BeginProc macro
    ??_public = 1
endm

?LOCAL_BeginProc macro
    ??_public = 0
endm

?HIGH_FREQ_BeginProc macro
    ??_align = 1
endm

?HOOK_PROC_BeginProc macro
    ??_hook = 1
    ??_hookarg = 1  ; next arg is dword storage location
endm

?SERVICE_BeginProc macro
    ??_service = 1
    .erre ?_16ICODE, <SERVICEs must be in 32 bit code>
    .erre ?_RCODE, <SERVICEs must be in 32 bit code>
endm

?ASYNC_SERVICE_BeginProc macro
    ??_service = 1
    ??_async_service = 1
    .errnz ?_LCODE, <ASYNC_SERVICE's must be in LOCKED code>
endm

?NO_LOG_BeginProc macro
    ??_log = 0
endm

?NO_PROFILE_BeginProc macro
    ??_profile = 0
endm

?NO_TEST_CLD_BeginProc macro
    ??_test_cld = 0
endm

?TEST_BLOCK_BeginProc macro
    ??_might_block = DFS_TEST_BLOCK
endm

?TEST_REENTER_BeginProc macro
    ??_test_reenter = DFS_TEST_REENTER
endm

?NEVER_REENTER_BeginProc macro
    ??_never_reenter = DFS_NEVER_REENTER
endm

?NOT_SWAPPING_BeginProc macro
    ??_not_swapping = DFS_NOT_SWAPPING
endm

?NO_PROLOG_BeginProc macro
    ??_prolog_disabled = 1
endm

?ESP_BeginProc macro
    ??_esp = VMM_TRUE
    ifndef Not_VxD
    .erre ?_16ICODE, <Beginproc ESP attribute invalid in 16 bit seg.>
    .erre ?_RCODE, <Beginproc ESP attribute invalid in real-mode seg.>
    endif
endm

?CCALL_BeginProc macro
    ??_ccall = 1
endm

?PCALL_BeginProc macro
    ??_pcall = 1
endm

?SCALL_BeginProc macro
    ??_scall = 1
endm

?FASTCALL_BeginProc macro
    ??_fastcall = 1
endm

?ICALL_BeginProc macro
    ??_scall = 1    ;; internal calling convention is StdCall
endm

?W32SVC_BeginProc macro
    ??_scall = 1
    ??_w32svc = 1
endm

ifdef DEBUG
ifdef profileall
?ProfileHeader_BeginProc macro PL, filename
ifndef _&filename&__proc_list
  _&filename&__proc_list = 0
  PUBLIC _&filename&__proc_list
endif
    dd OFFSET32 _&filename&__proc_list
PL  dd 0
_&filename&__proc_list = PL
endm
endif

IncProfileCount macro
    if ??_service OR ??_profile
	inc dword ptr [??_name-4]
    else
	ifndef profileall
	.err <IncProfileCount can be used only in services.>
	endif
    endif
endm
else
IncProfileCount macro
endm
endif

;***	ArgVar - declares stack arguments
;
; Usage:
;
;   name   = name of argument.
;   length = a numeric expression denoting the size (in bytes)
;	 of the argument.  The symbols BYTE, WORD, and DWORD
;	 are synonyms for 1, 2, and 4 respectively.
;	 NB!  All arguments sizes are rounded up to the nearest
;	 multiple of 4.
;   used   = usually blank, but can be the symbol NOTUSED
;	 to indicate that the argument will not be used
;	 by the procedure.
;

ArgVar	macro	name,length,used
    ??_numargs = ??_numargs + 1
    if ??_pcall
	?mkarg	<name>, <length>, <used>, %??_numargs
    else
	?arg <name>, <length>, <used>
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
    endm

?mkarg	macro	name, length, used, num
    .xcref  ?MKA&num
    ?deflocal <name>
    ?MKA&num &macro
	?argvar <name>, <length>, <used>
	&endm
    ??_aframe = ??_aframe + 4
    endm
    .xcref  ?mkarg

?argvar macro	name,length,used
    local   a
    a = ??_taframe
    ??_aframe =  ??_aframe + 4
    ??_taframe =  ??_taframe + 4
    ifidni  <length>,<BYTE>
	?setname <name>, <byte ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<WORD>
	?setname <name>, <word ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<DWORD>
	?setname <name>,  <dword ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&l>,<word ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&ll>,<byte ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&lh>,<byte ptr [??_basereg+??_initaframe+a+1]>, <used>
	?setname <name&h>,<word ptr [??_basereg+??_initaframe+a+2]>, <used>
	?setname <name&hl>,<byte ptr [??_basereg+??_initaframe+a+2]>, <used>
	?setname <name&hh>,<byte ptr [??_basereg+??_initaframe+a+3]>, <used>
    else
	??_aframe =  ??_aframe - 4 + ((length + 3)/4)*4
	??_taframe =  ??_taframe - 4 + ((length + 3)/4)*4
	?setname <name>, <[??_basereg+??_initaframe+a]>, <used>
    endif
endm

?arg macro   name,length,used
  if ??_fastcall
    if ??_numargs le 2
      if length gt 4
	.err <First 2 parameters are dwords (ecx,edx) for fastcall functions>
      endif
      ??_aframe =  ??_aframe + 4
      if ??_numargs eq 1
	?merge ecx_,name,,,equ,ecx
      else
	?merge edx_,name,,,equ,edx
      endif
    else
      ?argvar name, length, used
    endif
  else
    ?argvar name, length, used
  endif
endm

;***	?setname - optionally creates the name of an ArgVar
;
;   If <used> is <NOTUSED>, then the name is defined to something
;   bogus.

?setname macro name, value, used
    ?deflocal <name>
    ifidni <used>, <NOTUSED>
	name equ _inaccessible_NOTUSED_
    else
	name equ value
	??_procflags = ??_procflags OR ??_pf_ArgsUsed OR ??_pf_Check
    endif
endm


;***	LocalVar - declares local stack variables
;
; Usage:
;
;   name   = name of local variable
;   length = a numeric expression denoting the size (in bytes)
;	 of the argument.  The symbols BYTE, WORD, and DWORD
;	 are synonyms for 1, 2, and 4 respectively.
;	 NB!  All arguments sizes are rounded up to the nearest
;	 multiple of 4 (unless PACK is indicated)
;   flag   = usually blank, but can be the symbol PACK
;	 to suppress the usual padding and aligning of variables
;	 PACK is typically used when declaring a bunch of
;	 byte or word variables.  Make sure that the total
;	 size of PACKed variables is a multiple of 4.
;

LocalVar    macro   name,length,flag
    local   a
    ??_numlocals = ??_numlocals + 1
    ??_pad = 1
    ifidni <flag>, <PACK>
	??_pad = 0
    endif
    ifidni  <length>,<BYTE>
	??_frame = ??_frame + 1 + 3 * ??_pad
	a = ??_frame
	?deflocal <name>
	name equ byte ptr [??_basereg-a]
    elseifidni <length>,<WORD>
	??_frame =  ??_frame + 2 + 2 * ??_pad
	a = ??_frame
	?deflocal <name>
	name equ word ptr [??_basereg-a]
    elseifidni <length>,<DWORD>
	??_frame = ??_frame + 4
	a = ??_frame
	?deflocal <name, name&l, name&ll, name&lh, name&h, name&hl, name&hh>
	name equ dword ptr [??_basereg-a]
	name&l equ word ptr [??_basereg-a]
	name&ll equ byte ptr [??_basereg-a]
	name&lh equ byte ptr [??_basereg-a+1]
	name&h equ word ptr [??_basereg-a+2]
	name&hl equ byte ptr [??_basereg-a+2]
	name&hh equ byte ptr [??_basereg-a+3]
    else
	??_frame =  ??_frame + ((length + 3)/4)*4
	a = ??_frame
	?deflocal <name>
	name equ [??_basereg-a]
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
endm

?deflocal macro name
    irp nm, <name>
	??_numlocalsymbols = ??_numlocalsymbols + 1
	?dodeflocal <nm>, %(??_numlocalsymbols)
    endm
endm
    .xcref  ?deflocal

?dodeflocal macro name, num
    .xcref  ?LOC&num
    ?LOC&num &macro
	name	equ <__inaccessible__NOTINSCOPE__>
	&endm
    endm
    .xcref  ?dodeflocal

;***	EnterProc - generates stack frame on entry

EnterProc macro
    .errnz ??_frame and 3, <Total size of local variables not a multiple of 4.>
    if ??_scall
	if ??_public
	ifdef Not_VxD
		?merge	%??_name,@,%(??_aframe),,label,near
		?merge	public,,,,C,%??_name,@,%(??_aframe)
	else
		?merge	_,%??_name,@,%(??_aframe),label,near
		?merge	public,,,,,_,%??_name,@,%(??_aframe)
	endif
	endif
	?_BeginProc_Debug_Prologue
    endif
    if ??_fastcall
	if ??_public
	ifdef Not_VxD
		?merge	%??_name,@,%(??_aframe),,label,near
		?merge	public,,,,C,%??_name,@,%(??_aframe)
	else
		?merge	@,%??_name,@,%(??_aframe),label,near
		?merge	public,,,,,@,%??_name,@,%(??_aframe)
	endif
	endif
	?_BeginProc_Debug_Prologue
    endif
    if ??_pcall
	??_aframe = 0
	?count = ??_numargs
	rept	??_numargs
	    ?invprg <?MKA>,%?count
	    ?count = ?count - 1
	endm
    endif
    ??_fleave = FALSE
    if ??_esp
	if  ??_frame
	    sub esp, ??_frame
	    ??_pushed = ??_pushed + ??_frame
	    ??_fleave = VMM_TRUE
	endif
    else
	if  ??_frame eq 0
	    if (??_taframe eq 0) OR ((??_procflags AND ??_pf_ArgsUsed) EQ 0)
		ifdef DEBUG
		    push    ebp
		    mov ebp,esp
		    ??_fleave = VMM_TRUE
		endif
	    else
		push	ebp
		mov ebp,esp
		??_fleave = VMM_TRUE
	    endif
	else
	    enter   ??_frame, 0
	    ??_fleave = VMM_TRUE
	endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Entered
endm

;***	LeaveProc - removes stack frame on exit
;
;   NOTE:   If there are localvar and ESP kind of stack frame
;	LeaveProc will destroy flags unless the "PRESERVE_FLAGS"
;	flag is given.	PRESERVE_FLAGS generates bigger, slower
;	code, so use it only when necessary.
;
;   WARNING: For "ESP" type stack frames, this macro DOES NOT adjust
;	 the internal stack depth for the local frame.	This is
;	 to allow jumping around the LeaveProc/Return to code
;	 after the LeaveProc/Return to use args/local variables,
;	 but code that uses the stack frame executed after the
;	 LeaveProc won't work.

LeaveProc macro flags
    if ??_fleave
	if ??_esp
	    ifidni <flags>,<PRESERVE_FLAGS>
		lea esp,[esp + ??_frame]
	    else
		add esp,??_frame
	    endif
	else
	    leave
	endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Left
endm

;***	Return - return appropriately from a procedure
;
;   For "ccall" functions it's just a ret; for "pcall" and "scall"
;   it cleans the parameters off.
;

Return	macro
    if	??_cleanoff OR ??_w32svc
	if  ??_w32svc AND (??_taframe LT 8)
	    ret 8
	else
	    ret ??_taframe
	endif
    else
	ret
    endif
    ??_procflags = ??_procflags OR ??_pf_Returned
    endm

;***	EndProc - end the procedure
;

EndProc macro Name, Flag
    Name endp		;; Masm will provide error msg for us
if ??_w32svc
    if ??_taframe lt 8
	cparm&Name equ 0
    else
	cparm&Name equ (??_taframe/4 - 2)
    endif
endif
if ??_procflags AND ??_pf_Left
if ??_fleave
if ??_esp
    ??_pushed = ??_pushed - ??_frame
endif
endif
endif
ifdifi	<Flag>,<NOCHECK>
    if ??_pushed ne 0
	%out Warning: stack not balanced in Name
    endif
    if ??_procflags AND ??_pf_Check
	ife ??_procflags AND ??_pf_Entered
	    %out Warning: ArgVar/LocalVar without EnterProc in Name
	endif
	ife ??_procflags AND ??_pf_Left
	    %out Warning: ArgVar/LocalVar without LeaveProc in Name
	endif
	ife ??_procflags AND ??_pf_Returned
	    %out Warning: ArgVar/LocalVar without Return in Name
	endif
    endif
endif
ifdifi	<Flag>,<KEEPFRAMEVARS>
    ?count = 0
    rept    ??_numlocalsymbols
	?count = ?count + 1
	?invprg <?LOC>,%?count
    endm
endif
    ??_ends
    ??_ends equ <>
    endm

;***	cCall - "C" call
;
;   Arguments pushed in "C" order, caller cleans stack
;
;   USES: Flags.

cCall	macro	name, arglst, flags
    ife .TYPE name
       CondExtern name, near
    endif
    ifdef ??_nonstandardccall_&name
    PushCParams <arglst>, <FAST>
    else
    PushCParams <arglst>, <flags>
    endif
    call    name
    ifdef ??_nonstandardccall_&name
    ClearCParams PRESERVE_FLAGS
    else
    ClearCParams <flags>
    endif
    endm
    .xcref  cCall

;***	pCall - pascal call
;
;   Arguments pushed in pascal order, callee cleans stack
;

pCall	macro	name, arglst
    local   ??saved
    ife .TYPE name
	?toupper name
    else
	?upper equ <name>
    endif
    CondExtern %?upper, near
    ??saved = ??_pushed
    irp x,<arglst>
	push	x
	??_pushed = ??_pushed + 4
    endm
    call    ?upper
    ??_pushed = ??saved
    endm
    .xcref  pCall

;***	sCall - standard call
;
;   Arguments pushed in "C" order, callee cleans stack,
;   @argc appended to name
;

sCall	macro	name, arglst
    local   ??saved
    ??saved = ??_pushed
    PushCParams <arglst>
    ?scall  _, name, %(??_argc * 4)
    ??_pushed = ??saved
    endm
    .xcref  sCall

;***	fCall - fastcall call
;
;   Arguments pushed in "C" order (except first two parms,
;   which are passed in ECX and EDX), callee cleans stack, and
;   @argc appended to name.
;
;   The only useful value for flags is PRESERVE_FLAGS,
;   which can also be achieved by simply declaring the function
;   as non-standard, like so:
;
;	DeclareNonstandardCcallService <functionname>
;

fCall	macro	name, arglst, flags
    local   ??saved
    ??saved = ??_pushed
    ife .TYPE name
       CondExtern name, near
    endif
    PushCParams <arglst>, <FASTCALL>
    ?scall  @, name, %(??_argc * 4)
    ifdef ??_nonstandardccall_&name
    ClearCParams PRESERVE_FLAGS
    else
    ClearCParams <flags>
    endif
    ??_pushed = ??saved
    endm
    .xcref  fCall

;***	iCall - internal routine call
;
;   Set to whatever type we want to use as a default.

iCall	equ <sCall>

;***	PushCParams
;
;   Processes argument list
;
;   arglist = <arg1, arg2, arg3, ...>
;   flags = the word SMALL if we should prefer size over speed
;	the word FAST if we should prefer speed over size
;
;	The default flag is SMALL, unless the current procedure
;	is High_Freq, in which case we default to FAST.
;
;   To disable this optimization, define the symbol NONSTANDARD_CCALL.
;
IFNDEF	STANDARD_CCALL
NONSTANDARD_CCALL = 1		;; disabled by default for now
ENDIF

PushCParams macro arglst, flags
    LOCAL ??_pushedargs

    ??_argc = 0 	;; number of dwords on stack (global)
IFDEF	NONSTANDARD_CCALL
    ??_popargs = 0		;; establish default
ELSE
    ??_popargs = ??_align EQ 0	;; establish default
ENDIF
    ifidni  <flags>, <SMALL>
	??_popargs = 1		;; size, not speed
    elseifidni <flags>, <FAST>
	??_popargs = 0		;; speed, not size
    elseifidni <flags>, <FASTCALL>
	??_popargs = 0		;; speed, not size
    endif

    irp x,<arglst>
	??_argc = ??_argc + 1
	ifidni <flags>, <FASTCALL>
	  if ??_argc eq 1
	    ifdifi <x>, <ecx>
	      .err <first parameter must be ECX for fastcall functions>
	    endif
	  elseif ??_argc eq 2
	    ifdifi <x>, <edx>
	      .err <first parameter must be EDX for fastcall functions>
	    endif
	  else
	    ?marg   <x>,%??_argc
	  endif
	else
	  ?marg   <x>,%??_argc
	endif
    endm
    ?count = ??_argc
    ifidni <flags>, <FASTCALL>
      ??_pushedargs = ??_argc-2
    else
      ??_pushedargs = ??_argc
    endif
    if ??_pushedargs GT 0
      rept    ??_argc
	?invprg <?AM>,%?count
	?count = ?count - 1
      endm
    endif
    endm

;***	ClearCParams
;
;   Processes stack clean up
;
;   This routine will trade size for speed (if requested)
;   by using `pop ecx' to clean off one or two arguments.
;   This relies on the convention that C-call routines do
;   not return useful information in ECX.
;
;   To disable this optimization, define the symbol NONSTANDARD_CCALL.
;
;   If flags must be preserved, pass PRESERVE_FLAGS as an argument.
;   This will generate bigger, slower code, so use it only when
;   necessary.

ClearCParams macro fPreserveFlags
    if	??_argc ne 0
	if (??_popargs) AND (??_argc LE 2)
	  rept ??_argc
	  pop ecx
	  endm
	elseifidni <fPreserveFlags>, <PRESERVE_FLAGS>
	  lea esp, [esp][??_argc * 4]
	else
	  add esp,??_argc * 4
	endif
    endif
    ??_pushed = ??_pushed - (??_argc * 4)
    endm

; Makes a macro that will push argment when invoke - used by cCall only

?marg	macro	name, num
    .xcref
    .xcref  ?AM&num
    .cref
    ?AM&num &macro
	push	name
	??_pushed = ??_pushed + 4
	&endm
    endm
    .xcref  ?marg

; Concatenates, invokes and purges a macro name - used by PushCParams

?invprg macro	name1, name2
    name1&name2
    purge   name1&name2
    endm
    .xcref  ?invprg

; Calls a concatenated standard call name and makes it external

?scall	macro	prefix, name1, name2
    CondExtern prefix&name1&@&name2, near
    call    prefix&name1&@&name2
    endm
    .xcref  ?scall

; Equates name to a name

?merge	macro	l1, l2, l3, l4, op, r1, r2, r3, r4, r5, r6, r7, r8, r9
    l1&l2&l3&l4 op r1&r2&r3&r4&r5&r6&r7&r8&r9
    endm

; Converts string to upper-case, returned in ?upper

?toupper macro s
      ?upper equ <>
      irpc x,<s>
	if '&x' GE 'a'
	  if '&x' LE 'z'
	?t1 substr <ABCDEFGHIJKLMNOPQRSTUVWXYZ>,'&x'-'a'+1,1
	?upper catstr ?upper,?t1
	  else
	?upper catstr ?upper,<&x>
	  endif
	else
	  ?upper catstr ?upper,<&x>
	endif
      endm
    endm
    .xcref

;***	CondExtern - Make name external if not already defined
;
;   This operation is quite different between MASM 5.1 and 6.0.
;

CondExtern macro name,dist
    ifdef MASM6
	ifndef name
	externdef name:dist
	endif
    else
	if2
	ifndef name
	    extrn name:dist
	endif
	endif
    endif
endm

;***	SaveReg - Save register, "fd" pushes flags, "ad" pushes all

SaveReg macro	reglist 	;; push those registers
    irp reg,<reglist>
	ifidni <reg>, <fd>
	    pushfd
	    ??_pushed = ??_pushed + 4
	else
	ifidni <reg>, <ad>
	    pushad
	    ??_pushed = ??_pushed + SIZE Pushad_Struc
	else
	    push    reg
	    ??_pushed = ??_pushed + 4
	endif
	endif
    endm
endm

;***	RestoreReg - Restore register, "fd" pops flags, "ad" pops all
;
;   Note that registers must be restored in reverse order that they
;   were saved.
;

RestoreReg macro     reglist	;; pop those registers
    irp reg,<reglist>
	ifidni <reg>, <fd>
	    popfd
	    ??_pushed = ??_pushed - 4
	else
	ifidni <reg>, <ad>
	    popad
	    ??_pushed = ??_pushed - SIZE Pushad_Struc
	else
	    pop reg
	    ??_pushed = ??_pushed - 4
	endif
	endif
    endm
endm
*/

#ifdef DEBUG
/******************************************************************************
*   The following macros are for enabling procedure call profile counting
*   of VxD's written in assembler.
*
*   Begin_Profile_List needs to be used in the file that declares the device
*   immediately after the Declare_Virtual_Device line.	Then one Profile_Link
*   line is required for each individual source file.  The list is ended with
*   the End_Profile_List macro.  Profiling only works for debug builds and
*   the sources must all be built with "-Dprofileall" masm switch.
******************************************************************************/

/* ASM
Begin_Profile_List macro devname
ifdef profileall
VxD_DATA_SEG
    db	'PROCLIST'
PUBLIC devname&_Proc_Profile_List
devname&_Proc_Profile_List label dword
endif
endm

Profile_Link macro modname
ifdef profileall
ifdifi <modname>,@filename
EXTRN _&modname&__proc_list:near
endif
    dd	OFFSET32 _&modname&__proc_list
endif
endm

End_Profile_List macro
ifdef profileall
    dd	0
VxD_DATA_ENDS
endif
endm

*/
#endif

#ifndef Not_VxD

/******************************************************************************
 *	   S C H E D U L E R   B O O S T   V A L U E S
 *****************************************************************************/

#define RESERVED_LOW_BOOST  0x00000001
#define CUR_RUN_VM_BOOST    0x00000004
#define LOW_PRI_DEVICE_BOOST	0x00000010
#define HIGH_PRI_DEVICE_BOOST	0x00001000
#define CRITICAL_SECTION_BOOST	0x00100000
#define TIME_CRITICAL_BOOST 0x00400000
#define RESERVED_HIGH_BOOST 0x40000000


/******************************************************************************
 *   F L A G S	 F O R	 C A L L _ P R I O R I T Y _ V M _ E V E N T
 *****************************************************************************/

#define PEF_WAIT_FOR_STI_BIT	    0
#define PEF_WAIT_FOR_STI	(1 << PEF_WAIT_FOR_STI_BIT)
#define PEF_WAIT_NOT_CRIT_BIT	    1
#define PEF_WAIT_NOT_CRIT	(1 << PEF_WAIT_NOT_CRIT_BIT)

#define PEF_DONT_UNBOOST_BIT	    2
#define PEF_DONT_UNBOOST	(1 << PEF_DONT_UNBOOST_BIT)
#define PEF_ALWAYS_SCHED_BIT	    3
#define PEF_ALWAYS_SCHED	(1 << PEF_ALWAYS_SCHED_BIT)
#define PEF_TIME_OUT_BIT	4
#define PEF_TIME_OUT		(1 << PEF_TIME_OUT_BIT)

#define PEF_WAIT_NOT_HW_INT_BIT     5
#define PEF_WAIT_NOT_HW_INT	(1 << PEF_WAIT_NOT_HW_INT_BIT)
#define PEF_WAIT_NOT_NESTED_EXEC_BIT	6
#define PEF_WAIT_NOT_NESTED_EXEC    (1 << PEF_WAIT_NOT_NESTED_EXEC_BIT)
#define PEF_WAIT_IN_PM_BIT	7
#define PEF_WAIT_IN_PM		(1 << PEF_WAIT_IN_PM_BIT)

#define PEF_THREAD_EVENT_BIT	    8
#define PEF_THREAD_EVENT	(1 << PEF_THREAD_EVENT_BIT)

#define PEF_WAIT_FOR_THREAD_STI_BIT 9
#define PEF_WAIT_FOR_THREAD_STI (1 << PEF_WAIT_FOR_THREAD_STI_BIT)

#define PEF_RING0_EVENT_BIT	    10
#define PEF_RING0_EVENT 	(1 << PEF_RING0_EVENT_BIT)

#define PEF_WAIT_CRIT_BIT	11
#define PEF_WAIT_CRIT	    (1 << PEF_WAIT_CRIT_BIT)

#define PEF_WAIT_CRIT_VM_BIT	    12
#define PEF_WAIT_CRIT_VM    (1 << PEF_WAIT_CRIT_VM_BIT)

#define PEF_PROCESS_LAST_BIT	    13
#define PEF_PROCESS_LAST    (1 << PEF_PROCESS_LAST_BIT)

#define PEF_WAIT_PREEMPTABLE_BIT    14
#define PEF_WAIT_PREEMPTABLE (1 << PEF_WAIT_PREEMPTABLE_BIT)

// synonyms for event restrictions above

#define PEF_WAIT_NOT_TIME_CRIT_BIT   PEF_WAIT_NOT_HW_INT_BIT
#define PEF_WAIT_NOT_TIME_CRIT	     PEF_WAIT_NOT_HW_INT
#define PEF_WAIT_NOT_PM_LOCKED_STACK_BIT PEF_WAIT_NOT_NESTED_EXEC_BIT
#define PEF_WAIT_NOT_PM_LOCKED_STACK	 PEF_WAIT_NOT_NESTED_EXEC


/******************************************************************************
 *	 F L A G S   F O R   B E G I N _ C R I T I C A L _ S E C T I O N,
 *			     E N T E R _ M U T E X
 *	       A N D   W A I T _ S E M A P H O R E
 *****************************************************************************/

#define BLOCK_SVC_INTS_BIT	0
#define BLOCK_SVC_INTS		(1 << BLOCK_SVC_INTS_BIT)
#define BLOCK_SVC_IF_INTS_LOCKED_BIT	1
#define BLOCK_SVC_IF_INTS_LOCKED    (1 << BLOCK_SVC_IF_INTS_LOCKED_BIT)
#define BLOCK_ENABLE_INTS_BIT	    2
#define BLOCK_ENABLE_INTS	(1 << BLOCK_ENABLE_INTS_BIT)
#define BLOCK_POLL_BIT		3
#define BLOCK_POLL	    (1 << BLOCK_POLL_BIT)
#define BLOCK_THREAD_IDLE_BIT		4
#define BLOCK_THREAD_IDLE		(1 << BLOCK_THREAD_IDLE_BIT)
#define BLOCK_FORCE_SVC_INTS_BIT	5
#define BLOCK_FORCE_SVC_INTS	    (1 << BLOCK_FORCE_SVC_INTS_BIT)

/******************************************************************************
 *  The following structures are pointed to by EBP when VxD routines are
 *  entered, both for VxD control calls and traps(I/O traps, software INT
 *  traps, etc.).  The first structure as DWORD values, the second WORD
 *  values and the last has BYTE values.
 *****************************************************************************/

struct Client_Reg_Struc {
    ULONG Client_EDI;		/* Client's EDI */
    ULONG Client_ESI;		/* Client's ESI */
    ULONG Client_EBP;		/* Client's EBP */
    ULONG Client_res0;		/* ESP at pushall */
    ULONG Client_EBX;		/* Client's EBX */
    ULONG Client_EDX;		/* Client's EDX */
    ULONG Client_ECX;		/* Client's ECX */
    ULONG Client_EAX;		/* Client's EAX */
    ULONG Client_Error; 	/* Dword error code */
    ULONG Client_EIP;		/* EIP */
    USHORT Client_CS;		/* CS */
    USHORT Client_res1; 	/*   (padding) */
    ULONG Client_EFlags;	/* EFLAGS */
    ULONG Client_ESP;		/* ESP */
    USHORT Client_SS;		/* SS */
    USHORT Client_res2; 	/*   (padding) */
    USHORT Client_ES;		/* ES */
    USHORT Client_res3; 	/*   (padding) */
    USHORT Client_DS;		/* DS */
    USHORT Client_res4; 	/*   (padding) */
    USHORT Client_FS;		/* FS */
    USHORT Client_res5; 	/*   (padding) */
    USHORT Client_GS;		/* GS */
    USHORT Client_res6; 	/*   (padding) */
    ULONG Client_Alt_EIP;
    USHORT Client_Alt_CS;
    USHORT Client_res7;
    ULONG Client_Alt_EFlags;
    ULONG Client_Alt_ESP;
    USHORT Client_Alt_SS;
    USHORT Client_res8;
    USHORT Client_Alt_ES;
    USHORT Client_res9;
    USHORT Client_Alt_DS;
    USHORT Client_res10;
    USHORT Client_Alt_FS;
    USHORT Client_res11;
    USHORT Client_Alt_GS;
    USHORT Client_res12;
};


struct Client_Word_Reg_Struc {
    USHORT Client_DI;		/* Client's DI */
    USHORT Client_res13;	/*   (padding) */
    USHORT Client_SI;		/* Client's SI */
    USHORT Client_res14;	/*   (padding) */
    USHORT Client_BP;		/* Client's BP */
    USHORT Client_res15;	/*   (padding) */
    ULONG Client_res16; 	/* ESP at pushall */
    USHORT Client_BX;		/* Client's BX */
    USHORT Client_res17;	/*   (padding) */
    USHORT Client_DX;		/* Client's DX */
    USHORT Client_res18;	/*   (padding) */
    USHORT Client_CX;		/* Client's CX */
    USHORT Client_res19;	/*   (padding) */
    USHORT Client_AX;		/* Client's AX */
    USHORT Client_res20;	/*   (padding) */
    ULONG Client_res21; 	/* Dword error code */
    USHORT Client_IP;		/* Client's IP */
    USHORT Client_res22;	/*   (padding) */
    ULONG Client_res23; 	/* CS */
    USHORT Client_Flags;	/* Client's flags (low) */
    USHORT Client_res24;	/*   (padding) */
    USHORT Client_SP;		/* SP */
    USHORT Client_res25;
    ULONG Client_res26[5];
    USHORT Client_Alt_IP;
    USHORT Client_res27;
    ULONG Client_res28;
    USHORT Client_Alt_Flags;
    USHORT Client_res29;
    USHORT Client_Alt_SP;
};



struct Client_Byte_Reg_Struc {
    ULONG Client_res30[4];	/* EDI, ESI, EBP, ESP at pushall */
    UCHAR Client_BL;		/* Client's BL */
    UCHAR Client_BH;		/* Client's BH */
    USHORT Client_res31;
    UCHAR Client_DL;		/* Client's DL */
    UCHAR Client_DH;		/* Client's DH */
    USHORT Client_res32;
    UCHAR Client_CL;		/* Client's CL */
    UCHAR Client_CH;		/* Client's CH */
    USHORT Client_res33;
    UCHAR Client_AL;		/* Client's AL */
    UCHAR Client_AH;		/* Client's AH */
};


typedef union tagCLIENT_STRUC { /* */
    struct Client_Reg_Struc	  CRS;
    struct Client_Word_Reg_Struc  CWRS;
    struct Client_Byte_Reg_Struc  CBRS;
    } CLIENT_STRUCT;

typedef struct Client_Reg_Struc CRS;
typedef CRS *PCRS;

#if 0	/* causes problems with MASM 6 */
/* ASM
.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX
*/
#endif

#define DYNA_LINK_INT	0x20

/* ASM

;***	DeclareNonstandardCcallService
;
;   Declare services as conforming to the C calling convention
;   for parameter-passing, but *not* conforming to the C calling
;   convention for register usage.
;
;   Services which do not use the C calling convention for
;   parameter-passing need not be declared as nonstandard.
;
;   arglst - list of services to declare as nonstandard
;
DeclareNonstandardCcallService macro arglst
    irp x,<arglst>
	??_nonstandardccall_&&x = 1
    endm
endm

;
; The following VMM services are nonstandard:
;	_BlockOnID and _LocalizeSprintf modify no registers except flags.
;	_SetLastV86Page modifies no registers except EAX and flags.
;
DeclareNonstandardCcallService <_BlockOnID, _LocalizeSprintf>
DeclareNonstandardCcallService <_SetLastV86Page>

BeginDoc
;******************************************************************************
; The VMMCall and VxDCall macros provide a dynamic link to the VMM and VxD
;   service routines. For example:
;
;   VMMCall Enable_VM_Ints	; Equivalent to STI in VM code
;
;   mov     eax,[My_IRQ_Handle]
;   VxDCall VPICD_Set_Int_Request   ; Set IRQ for my device's interrupt
;
; Note that Enable_VM_Ints is defined in VMM.INC and VPICD_Set_Int_Request is
;   defined in VPICD.INC
;
;==============================================================================
EndDoc


BeginDoc
;******************************************************************************
; VxDCall
;==============================================================================
;
;   BlockOnID is always FAST because it doesn't
;   conform to the C calling convention.  (It preserves
;   all registers.)

EndDoc

DefTable MACRO vt, vn
    vt EQU <vn>
ENDM

GenDD2 MACRO vt, sn, jf
    dd	OFFSET32 vt[sn+jf]
ENDM

GenDD	MACRO	P, vid, snum, jflag
    LOCAL   vtable
IFDEF	@@VxDName&vid
    Deftable	vtable, %@@VxDName&vid
    EXTRN   vtable:DWORD
    GenDD2 %vtable, snum, jflag
ELSE
    dd	@@&P+jflag
ENDIF

ENDM


VxDCall MACRO P, Param, flags
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)

    ifdef ??_standardccall_&P
      PushCParams <Param>, <FAST>
      .errnz ??_argc ne ??_standardccall_&P, <wrong # of parameters passed to &P&>
    else
      ifdef ??_fastcall_&P
	PushCParams <Param>, <FASTCALL>
	.errnz ??_argc ne (??_fastcall_&P), <wrong # of parameters passed to fastcall function &P&>
      else
	ifdef ??_nonstandardccall_&P
	  PushCParams <Param>, <flags>
	else
	  PushCParams <Param>, <FAST>
	endif
      endif
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, 0
    ifndef ??_standardccall_&P
      ifndef ??_fastcall_&P
	ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
	else
	ClearCParams
	endif
      else
	if(??_argc gt 2)
	    ??_pushed = ??_pushed - ((??_argc - 2) * 4)
	endif
      endif
    else
      ??_pushed = ??_pushed - (??_argc * 4)
    endif
    ENDM

VxDJmp	MACRO P, Param
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    ifdef ??_fastcall_&P
      PushCParams <Param>, <FASTCALL>
      .errnz ??_argc gt 2, <More than 2 parameters may not be passed to fastcall functions thru VxDJmp>
    else
      .errnb <Param>, <Parameters may not be passed to VxDJmp or VMMJmp>
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, DL_Jmp_Mask
    ENDM

DL_Jmp_Mask EQU 8000h
DL_Jmp_Bit  EQU 0Fh

VMMCall MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDCall <P>, <Param>
    ENDM

VMMJmp MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDJmp <P>, <Param>
    ENDM

BeginDoc
;******************************************************************************
; Segment definition macros
;
; The segment definition macros are a convenience used in defining the
;   segments used by the device driver. They are:
;VxD_INIT_CODE_SEG defines start of initialization code segment
;VxD_INIT_CODE_ENDS defines end of initialization code segment
;VxD_ICODE_SEG is an alias for VxD_INIT_CODE_SEG
;VxD_ICODE_ENDS is an alias for VxD_INIT_CODE_ENDS
;VxD_IDATA_SEG	 defines start of initialization data segment
;VxD_IDATA_ENDS  defines end of initialization data segment
;VxD_CODE_SEG	 defines start of always present code segment
;VxD_CODE_ENDS	 defines end of always present code segment
;VxD_DATA_SEG	 defines start of always present data segment
;VxD_DATA_ENDS	 defines end of always present data segment
;VxD_LOCKED_CODE_SEG	defines start of always present code segment
;VxD_LOCKED_CODE_ENDS	defines end of always present code segment
;VxD_PAGEABLE_CODE_SEG	defines start of swappable code segment
;VxD_PAGEABLE_CODE_ENDS defines end of swappable code segment
;VxD_DEBUG_ONLY_CODE_SEG defines code only loaded if debugger is present
;VxD_DEBUG_ONLY_CODE_ENDS
;VxD_DEBUG_ONLY_DATA_SEG defines data only loaded if debugger is present
;VxD_DEBUG_ONLY_DATA_ENDS
;==============================================================================




EndDoc


;   Resident protected mode code

VxD_CODE_SEG	EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS	EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_LCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_LTEXT	 ENDS
	ENDM


;   Pageable protected mode code

VxD_PAGEABLE_CODE_SEG MACRO
_PTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_PAGEABLE_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_PTEXT	 ENDS
	ENDM


;   Debug only protected mode code

VxD_DEBUG_ONLY_CODE_SEG MACRO
_DBOCODE    SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_DBOCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
	ENDM

VxD_DEBUG_ONLY_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_DBOCODE    ENDS
	ENDM


;   Protected mode initialization code

VxD_INIT_CODE_SEG   MACRO
_ITEXT	SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_ICODE
    ASSUME  cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
    ENDM

VxD_INIT_CODE_ENDS  MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_ITEXT	ENDS
	ENDM

VxD_ICODE_SEG equ VxD_INIT_CODE_SEG
VxD_ICODE_ENDS equ VxD_INIT_CODE_ENDS


;   Resident protected mode data

VxD_DATA_SEG	EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS	EQU <VxD_LOCKED_DATA_ENDS>

VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA	 ENDS
	ENDM


;   Protected mode initialization data

VxD_IDATA_SEG	MACRO
_IDATA	SEGMENT
	ENDM
VxD_IDATA_ENDS	MACRO
_IDATA	ENDS
	ENDM


;   Pageable protected mode data

VxD_PAGEABLE_DATA_SEG MACRO NO_ALIGN
_PDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_PAGEABLE_DATA_ENDS MACRO
_PDATA	 ENDS
	ENDM


;   Static code segment for DL-VxDs

VxD_STATIC_CODE_SEG MACRO
_STEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_SCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_STATIC_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_STEXT	 ENDS
	ENDM


;   Static data segment for DL-VxDs

VxD_STATIC_DATA_SEG MACRO NO_ALIGN
_SDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_STATIC_DATA_ENDS MACRO
_SDATA	 ENDS
	ENDM

;   Debug only protected mode data

VxD_DEBUG_ONLY_DATA_SEG MACRO NO_ALIGN
_DBODATA    SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_DEBUG_ONLY_DATA_ENDS MACRO
_DBODATA    ENDS
	ENDM


;   16 bit code/data put in the init group (IGROUP)

VxD_16BIT_INIT_SEG  MACRO
_16ICODE SEGMENT
ASSUME CS:_16ICODE, DS:NOTHING, ES:NOTHING, SS:NOTHING
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_16ICODE
	  ENDM

VxD_16BIT_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_16ICODE ENDS
	   ENDM

;   Real mode segment (16 bit)

VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_RCODE
	  ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_RCODE ENDS
	   ENDM
*/

#endif // Not_VxD

#ifndef DDK_VERSION

#ifdef WIN31COMPAT
#define DDK_VERSION 0x30A	    /* 3.10 */
#else  // WIN31COMPAT

#ifdef WIN40COMPAT
#define DDK_VERSION 0x400	    /* 4.00 */
#else  // WIN40COMPAT

#ifdef OPK3
#define DDK_VERSION 0x403	    /* 4.03 */
#else  // OPK3
#define DDK_VERSION 0x40A	    /*Memphis is 4.1 */
#endif // OPK3

#endif // WIN40COMPAT

#endif // WIN31COMPAT

#endif // DDK_VERSION

struct VxD_Desc_Block {
    ULONG DDB_Next;	    /* VMM RESERVED FIELD */
    USHORT DDB_SDK_Version;	/* INIT <DDK_VERSION> RESERVED FIELD */
    USHORT DDB_Req_Device_Number;   /* INIT <UNDEFINED_DEVICE_ID> */
    UCHAR DDB_Dev_Major_Version;    /* INIT <0> Major device number */
    UCHAR DDB_Dev_Minor_Version;    /* INIT <0> Minor device number */
    USHORT DDB_Flags;		/* INIT <0> for init calls complete */
    UCHAR DDB_Name[8];		/* AINIT <"        "> Device name */
    ULONG DDB_Init_Order;	/* INIT <UNDEFINED_INIT_ORDER> */
    ULONG DDB_Control_Proc;	/* Offset of control procedure */
    ULONG DDB_V86_API_Proc;	/* INIT <0> Offset of API procedure */
    ULONG DDB_PM_API_Proc;	/* INIT <0> Offset of API procedure */
    ULONG DDB_V86_API_CSIP;	/* INIT <0> CS:IP of API entry point */
    ULONG DDB_PM_API_CSIP;	/* INIT <0> CS:IP of API entry point */
    ULONG DDB_Reference_Data;	    /* Reference data from real mode */
    ULONG DDB_Service_Table_Ptr;    /* INIT <0> Pointer to service table */
    ULONG DDB_Service_Table_Size;   /* INIT <0> Number of services */
    ULONG DDB_Win32_Service_Table;  /* INIT <0> Pointer to Win32 services */
    ULONG DDB_Prev;	    /* INIT <'Prev'> Ptr to prev 4.0 DDB */
    ULONG DDB_Size;	/* INIT <SIZE(VxD_Desc_Block)> Reserved */
    ULONG DDB_Reserved1;	/* INIT <'Rsv1'> Reserved */
    ULONG DDB_Reserved2;	/* INIT <'Rsv2'> Reserved */
    ULONG DDB_Reserved3;	/* INIT <'Rsv3'> Reserved */
};

typedef struct VxD_Desc_Block	    *PVMMDDB;
typedef PVMMDDB 	    *PPVMMDDB;

#ifndef Not_VxD

/*
 *  Flag values for DDB_Flags
 */

#define DDB_SYS_CRIT_INIT_DONE_BIT  0
#define DDB_SYS_CRIT_INIT_DONE	    (1 << DDB_SYS_CRIT_INIT_DONE_BIT)
#define DDB_DEVICE_INIT_DONE_BIT    1
#define DDB_DEVICE_INIT_DONE	    (1 << DDB_DEVICE_INIT_DONE_BIT)

#define DDB_HAS_WIN32_SVCS_BIT	    14
#define DDB_HAS_WIN32_SVCS	(1 << DDB_HAS_WIN32_SVCS_BIT)
#define DDB_DYNAMIC_VXD_BIT	15
#define DDB_DYNAMIC_VXD 	(1 << DDB_DYNAMIC_VXD_BIT)

#define DDB_DEVICE_DYNALINKED_BIT   13
#define DDB_DEVICE_DYNALINKED	    (1 << DDB_DEVICE_DYNALINKED_BIT)


/* ASM
BeginDoc
;******************************************************************************
;
;   Declare_Virtual_Device macro
;
; ???? Write something here ????
;
;==============================================================================
EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

dev_id_err MACRO

IFNDEF Name&_Name_Based
.err <Device ID required when providing services>
ENDIF
    ENDM

IFB <V86_Proc>
    V86_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF

IFB <PM_Proc>
    PM_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF

IFDEF Name&_Service_Table
 IFB <Device_Num>
    dev_id_err
 ELSE
  IFE Device_Num - UNDEFINED_DEVICE_ID
    dev_id_err
  ENDIF
 ENDIF
    Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
    Serv_Tab_Len    EQU Num_&Name&_Services
ELSE
    Serv_Tab_Offset EQU 0
    Serv_Tab_Len    EQU 0
ENDIF

IFNB	<Device_Num>
  .erre (Device_Num LT BASEID_FOR_NAMEBASEDVXD), <Device ID  must be less than BASEID_FOR_NAMEBASEDVXD>
ENDIF

IFB <Reference_Data>
	Ref_Data_Offset EQU 0
ELSE
	Ref_Data_Offset EQU   <OFFSET32 Reference_Data>
ENDIF

IFDEF DEBUG
VxD_IDATA_SEG
    db	0dh, 0ah, 'D_E_B_U_G===>'
	db	"&Name", '<===', 0dh, 0ah
VxD_IDATA_ENDS
ENDIF

VxD_LOCKED_DATA_SEG

PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
	     OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
	     ,,Ref_Data_Offset,Serv_Tab_Offset, Serv_Tab_Len>

VxD_LOCKED_DATA_ENDS

    ENDM

;BeginDoc   ; comment out to make masm work ???
;******************************************************************************
; The Begin_Control_Dispatch macro is used for building a table for dispatching
; messages passed to the VxD_Control procedure.  It is used with
; Control_Dispatch and End_Control_Dispatch.  The only parameter is used to
; contruct the procedure label by adding "_Control" to the end (normally the
; device name is used i.e. VKD results in creating the procedure VKD_Control,
; this created procedure label must be included in Declare_Virtual_Device)
;
; An example of building a complete dispatch table:
;
; Begin_Control_Dispatch MyDevice
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
; Control_Dispatch  Sys_VM_Init, MyDeviceSysInitProcedure
; Control_Dispatch  Create_VM,	 MyDeviceCreateVMProcedure
; End_Control_Dispatch MyDevice
;
; (NOTE: Control_Dispatch can be used without Begin_Control_Dispatch, but
;    then it is the programmer's responsibility for declaring a procedure
;    in locked code (VxD_LOCKED_CODE_SEG) and returning Carry clear for
;    any messages not processed.  The advantage in using
;    Begin_Control_Dispatch is when a large # of messages are processed by
;    a device, because a jump table is built which will usually require
;    less code space then the compares and jumps that are done when
;    Control_Dispatch is used alone.
;
;==============================================================================
;EndDoc
Begin_Control_Dispatch MACRO VxD_Name, p1, p2
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control, p1, p2, LOCKED
ENDM

End_Control_Dispatch   MACRO VxD_Name
    LOCAL ignore, table

procoff MACRO num
IFDEF ??_cd_&&num
    dd	OFFSET32 ??_cd_&&num
ELSE
    dd	OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
    cmp eax, ??_cd_low
    ?merge  <jz>,,,,,<??_cd_>, %(??_cd_low)
    clc
    ret
ELSE
IF ??_cd_low GT 0
    sub eax, ??_cd_low
ENDIF ; ??cd_low GT 0
    cmp eax, ??_cd_high - ??_cd_low + 1
    jae short ignore
    jmp [eax*4+table]
ignore:
    clc 	    ;; this is not redundant
    ret

table label dword
    REPT   ??_cd_high - ??_cd_low + 1
    procoff %(??_cd_low)
    ??_cd_low = ??_cd_low + 1
    ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc
;******************************************************************************
; The Control_Dispatch macro is used for dispatching based on message
;   passed to the VxD_Control procedure. E.G.:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
;
; For "C" control functions:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure, sCall, <arglst>
;
; The "callc" can be sCall, cCall or pCall depending on the calling
; convention.  "arglst" is the list of registers to pass as parameters
; to "C" control procedure.  The "C" control procedure returns VXD_SUCCESS
; or VXD_FAILURE and the carry flag gets set appropriately.
;
; (NOTE: Control_Dispatch can be used with Begin_Control_Dispatch and
;    End_Control_Dispatch to create a jump table for dispatching messages,
;    when a large # of messages are processed.)
;
;==============================================================================
EndDoc
Control_Dispatch MACRO Service, Procedure, callc, arglst
    LOCAL Skip_Interseg_Jump

.errnz ?_LCODE, <Control_Dispatch must be in VxD_LOCKED_CODE_SEG.>

IFB <callc>

IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
    cmp eax, Service
    jz	Procedure
ENDIF

ELSE ; ifb callc

    cmp eax, Service
    jne SHORT Skip_Interseg_Jump
    callc   Procedure, <arglst>
IF Service EQ PNP_NEW_DEVNODE
    stc
ELSE
    cmp eax,1
ENDIF
    ret
Skip_Interseg_Jump:

ENDIF ; ifb callc

    ENDM
*/


/******************************************************************************
 *  The following are the definitions for the "type of I/O" parameter passed
 *  to a I/O trap routine.
 *****************************************************************************/

#define BYTE_INPUT  0x000
#define BYTE_OUTPUT 0x004
#define WORD_INPUT  0x008
#define WORD_OUTPUT 0x00C
#define DWORD_INPUT 0x010
#define DWORD_OUTPUT	0x014

#define OUTPUT_BIT  2
#define OUTPUT	    (1 << OUTPUT_BIT)
#define WORD_IO_BIT 3
#define WORD_IO     (1 << WORD_IO_BIT)
#define DWORD_IO_BIT	4
#define DWORD_IO    (1 << DWORD_IO_BIT)

#define STRING_IO_BIT	5
#define STRING_IO   (1 << STRING_IO_BIT)
#define REP_IO_BIT  6
#define REP_IO	    (1 << REP_IO_BIT)
#define ADDR_32_IO_BIT	7
#define ADDR_32_IO  (1 << ADDR_32_IO_BIT)
#define REVERSE_IO_BIT	8
#define REVERSE_IO  (1 << REVERSE_IO_BIT)

#define IO_SEG_MASK 0x0FFFF0000     /* Use this to get segment */
#define IO_SEG_SHIFT	0x10		/* Must shift right this many */


/* ASM
BeginDoc
;******************************************************************************
;
;   Dispatch_Byte_IO macro
;
; Dispatch_Byte_IO Byte_In_Proc, Byte_Out_Proc
;==============================================================================
EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
    je	Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
    jb	In_Proc
ELSE
    je	Out_Proc
    jmp In_Proc
ENDIF
ENDIF
    ENDM

BeginDoc
;******************************************************************************
;
;   Emulate_Non_Byte_IO
;
; Emulate_Non_Byte_IO
;
;==============================================================================
EndDoc
Emulate_Non_Byte_IO MACRO
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
    ENDM
*/


/* ASM
BeginDoc
;******************************************************************************
;
; Begin_VxD_IO_Table
;
;   Example:
; Begin_VxD_IO_Table MyTableName
;
;==============================================================================
EndDoc
*/


struct VxD_IOT_Hdr {
    USHORT VxD_IO_Ports;
};

struct VxD_IO_Struc {
    USHORT VxD_IO_Port;
    ULONG VxD_IO_Proc;
};


/* ASM
.ERRNZ SIZE VxD_IOT_Hdr - 2 ; Begin_VxD_IO_Table creates a 1 word count hdr
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD

ifndef MASM6
IF2
IFNDEF Table_Name&_Entries
.err <No End_VxD_IO_Table for &Table_Name>
ENDIF
    dw	Table_Name&_Entries
ELSE
    dw	?
ENDIF
ELSE  ; MASM6 - skip the warning message - we'll get it anyway
    dw	Table_Name&_Entries
ENDIF ; MASM6

    ENDM

.ERRNZ SIZE VxD_IO_Struc - 6	; VxD_IO creates 6 byte I/O port entries
VxD_IO MACRO Port, Proc_Name
    dw	Port
    dd	OFFSET32 Proc_Name
    ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
.err <No Begin_VxD_IO_Table for &Table_Name>
ELSE
    Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
.err <Invalid number of port traps in &Table_Name>
ENDIF
ENDIF
	ENDM


;******************************************************************************
;
; Push_Client_State takes an optional argument which if equal to the symbol
; USES_EDI saves code size by suppressing the preservation of the EDI register.
;
; Similarly, Pop_Client_State takes an optional argument which if equal to
; the symbol USES_ESI saves code size by suppressing the preservation of
; the ESI register.
;
;******************************************************************************

Push_Client_State MACRO Can_Trash_EDI
    sub esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed + SIZE Client_Reg_Struc
    ifidni <Can_Trash_EDI>, <USES_EDI>
    mov edi, esp
    VMMCall Save_Client_State
    else
    push    edi
    lea edi, [esp+4]
    VMMCall Save_Client_State
    pop edi
    endif
    ENDM

Pop_Client_State MACRO Can_Trash_ESI
    ifdifi <Can_Trash_ESI>, <USES_ESI>
    push    esi
    lea esi, [esp+4]
    VMMCall Restore_Client_State
    pop esi
    else
    mov esi, esp
    VMMCall Restore_Client_State
    endif
    add esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed - SIZE Client_Reg_Struc
    ENDM

BeginDoc
;******************************************************************************
;
;   CallRet -- Call procedure and return.  For debugging purposes only.
;	   If compiled with debugging then this will generate a call
;	   followed by a return.  If non-debugging version then the
;	   specified label will be jumped to.
;
;   PARAMETERS:
;   Label_Name = Procedure to be called
;
;   EXIT:
;   Return from current procedure
;
;------------------------------------------------------------------------------
EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
    call    P2
ELSE
    call    P1
ENDIF
    ret
ELSE
    jmp P1 P2
ENDIF
    ENDM

BeginDoc
;******************************************************************************
;
;   VxDCallRet
;   VMMCallRet -- CallRet for VxDCall and VMMCall.
;
;------------------------------------------------------------------------------
EndDoc

IFDEF	DEBUG

VxDCallRet macro p:req
    VxDCall p
    ret
endm

VMMCallRet macro p:req
    VMMCall p
    ret
endm

ELSE ; RETAIL

VxDCallRet equ <VxDJmp>
VMMCallRet equ <VMMJmp>

ENDIF


; ebp offsets to segments pushed by PMode_Fault in Fault_Dispatch
PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16


;******************************************************************************
;
; Client_Ptr_Flat takes an optional third argument which if equal to the
; symbol USES_EAX saves code size by supressing the preservation of the
; EAX register.  The USES_EAX flag is ignored if the destination register
; is itself EAX.
;
;******************************************************************************

Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off, Can_Trash_EAX

IFDIFI <Reg_32>, <EAX>
    IFDIFI <Can_Trash_EAX>, <USES_EAX>
    xchg    Reg_32, eax
    ENDIF
ENDIF
IFB <Cli_Off>
    mov ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
    mov ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
    VMMCall Map_Flat

IFDIFI <Reg_32>, <EAX>
    xchg    Reg_32, eax
ENDIF

    ENDM

;------------------------------------------------------------------------------

VxDint	MACRO	Int_Number
    if	(OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
    VMMCall Exec_VxD_Int
    ENDM

VxDintMustComplete MACRO   Int_Number
    if	(OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
	VMMCall _ExecVxDIntMustComplete
    ENDM

Load_FS 	macro
	VMMCall Load_FS_Service
endm
*/

/*XLATOFF*/
#define Load_FS VMMCall(Load_FS_Service)
/*XLATON*/

#endif // Not_VxD


/******************************************************************************
 *
 *  The following equates are for flags sent to the real mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/
#define DUPLICATE_DEVICE_ID_BIT     0	/* loaded */
#define DUPLICATE_DEVICE_ID	(1 << DUPLICATE_DEVICE_ID_BIT)
#define DUPLICATE_FROM_INT2F_BIT    1	/* loaded from INT 2F list */
#define DUPLICATE_FROM_INT2F	    (1 << DUPLICATE_FROM_INT2F_BIT)
#define LOADING_FROM_INT2F_BIT	    2	/* in the INT 2F device list */
#define LOADING_FROM_INT2F	(1 << LOADING_FROM_INT2F_BIT)


/******************************************************************************
 *
 *  The following equates are used to indicate the result of the real mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/

#define DEVICE_LOAD_OK	    0	/* load protected mode portion */
#define ABORT_DEVICE_LOAD   1	/* don't load protected mode portion */
#define ABORT_WIN386_LOAD   2	/* fatal-error: abort load of Win386 */
#define DEVICE_NOT_NEEDED   3	/* don't load protected mode portion */
				/* b/c the driver's presence is not needed */



#define NO_FAIL_MESSAGE_BIT 15	/* set bit to suppress error message */
#define NO_FAIL_MESSAGE     (1 << NO_FAIL_MESSAGE_BIT)


/******************************************************************************
 *
 *  The following equates define the loader services available to the real-mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/

#define LDRSRV_GET_PROFILE_STRING   0	/* search SYSTEM.INI for string */
#define LDRSRV_GET_NEXT_PROFILE_STRING	1   /* search for next string */
#define LDRSRV_RESERVED 	2   /* RESERVED */
#define LDRSRV_GET_PROFILE_BOOLEAN  3	/* search SYSTEM.INI for boolean */
#define LDRSRV_GET_PROFILE_DECIMAL_INT	4   /* search SYSTEM.INI for integer */
#define LDRSRV_GET_PROFILE_HEX_INT  5	/* search SYSTEM.INI for hex int */
#define LDRSRV_COPY_EXTENDED_MEMORY 6	/* allocate/init extended memory */
#define LDRSRV_GET_MEMORY_INFO	    7	/* get info about machine memory */

/* Add the new loader services contiguously here */

/****** Registry services for Real mode init time *************
 * The parameters for these are as defined in Windows.h for the
 * corresponding Win Reg API and should be on Stack. These are
 * C Callable except that the function no has to be in AX
 * ************************************************************
*/

#define LDRSRV_RegOpenKey	0x100
#define LDRSRV_RegCreateKey	0x101
#define LDRSRV_RegCloseKey	0x102
#define LDRSRV_RegDeleteKey	0x103
#define LDRSRV_RegSetValue	0x104
#define LDRSRV_RegQueryValue	    0x105
#define LDRSRV_RegEnumKey	0x106
#define LDRSRV_RegDeleteValue	    0x107
#define LDRSRV_RegEnumValue	0x108
#define LDRSRV_RegQueryValueEx	    0x109
#define LDRSRV_RegSetValueEx	    0x10A
#define LDRSRV_RegFlushKey	0x10B


/*
 *  For the Copy_Extended_Memory service, the following types of memory can be
 *  requested:
 */

#define LDRSRV_COPY_INIT	1   /* memory discarded after init */
#define LDRSRV_COPY_LOCKED	2   /* locked memory */
#define LDRSRV_COPY_PAGEABLE	    3	/* pageable memory */

/****************************************************************************
*
*   Object types supported by the vxd loader
*
*  Notes : Low bit of all CODE type objects should be set (VXDLDR uses this)
*	    Also Init type objects should be added to the second part of the
*	    list (which starts with ICODE_OBJ).
*
*****************************************************************************/

#define RCODE_OBJ	-1

#define LCODE_OBJ	0x01
#define LDATA_OBJ	0x02
#define PCODE_OBJ	0x03
#define PDATA_OBJ	0x04
#define SCODE_OBJ	0x05
#define SDATA_OBJ	0x06
#define CODE16_OBJ	0x07
#define LMSG_OBJ	0x08
#define PMSG_OBJ	0x09

#define DBOC_OBJ    0x0B
#define DBOD_OBJ    0x0C

#define PLCODE_OBJ	0x0D
#define PPCODE_OBJ	0x0F

#define ICODE_OBJ	0x11
#define IDATA_OBJ	0x12
#define ICODE16_OBJ	0x13
#define IMSG_OBJ	0x14


struct ObjectLocation {
    ULONG OL_LinearAddr ;
    ULONG OL_Size ;
    UCHAR  OL_ObjType ;
} ;

#define MAXOBJECTS  25

/*****************************************************************************
 *
 *	Device_Location structure
 *
 *****************************************************************************/

struct Device_Location_List {
    ULONG DLL_DDB ;
    UCHAR DLL_NumObjects ;
    struct ObjectLocation DLL_ObjLocation[1];
};


/* ========================================================================= */

/*
 *  CR0 bit assignments
 */
#define PE_BIT	    0	/* 1 = Protected Mode */
#define PE_MASK     (1 << PE_BIT)
#define MP_BIT	    1	/* 1 = Monitor Coprocessor */
#define MP_MASK     (1 << MP_BIT)
#define EM_BIT	    2	/* 1 = Emulate Math Coprocessor */
#define EM_MASK     (1 << EM_BIT)
#define TS_BIT	    3	/* 1 = Task Switch occured */
#define TS_MASK     (1 << TS_BIT)
#define ET_BIT	    4	/* 1 = 387 present, 0 = 287 present */
#define ET_MASK     (1 << ET_BIT)
#define PG_BIT	    31	/* 1 = paging enabled, 0 = paging disabled */
#define PG_MASK     (1 << PG_BIT)


/*
 *  EFLAGs bit assignments
 */
#define CF_BIT	    0
#define CF_MASK     (1 << CF_BIT)
#define PF_BIT	    2
#define PF_MASK     (1 << PF_BIT)
#define AF_BIT	    4
#define AF_MASK     (1 << AF_BIT)
#define ZF_BIT	    6
#define ZF_MASK     (1 << ZF_BIT)
#define SF_BIT	    7
#define SF_MASK     (1 << SF_BIT)
#define TF_BIT	    8
#define TF_MASK     (1 << TF_BIT)
#define IF_BIT	    9
#define IF_MASK     (1 << IF_BIT)
#define DF_BIT	    10
#define DF_MASK     (1 << DF_BIT)
#define OF_BIT	    11	/* Overflow flag */
#define OF_MASK     (1 << OF_BIT)
#define IOPL_MASK   0x3000  /* IOPL flags */
#define IOPL_BIT0   12
#define IOPL_BIT1   13
#define NT_BIT	    14	/* Nested task flag */
#define NT_MASK     (1 << NT_BIT)
#define RF_BIT	    16	/* Resume flag */
#define RF_MASK     (1 << RF_BIT)
#define VM_BIT	    17	/* Virtual Mode flag */
#define VM_MASK     (1 << VM_BIT)
#define AC_BIT	    18	/* Alignment check */
#define AC_MASK     (1 << AC_BIT)
#define VIF_BIT     19	/* Virtual Interrupt flag */
#define VIF_MASK    (1 << VIF_BIT)
#define VIP_BIT     20	/* Virtual Interrupt pending */
#define VIP_MASK    (1 << VIP_BIT)



/* ASM
;------------------------------------------------------------------------------
;
;     Temporary MASM macros (to be removed when supported by MASM)
;
;------------------------------------------------------------------------------

IFDEF MASM6
loopde EQU <looped>
loopdne EQU <loopned>
loopdz EQU <loopzd>
loopdnz EQU <loopnzd>
ELSE
loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>
ENDIF
*/


/******************************************************************************
 *		PAGE TABLE EQUATES
 *****************************************************************************/


#define P_SIZE	    0x1000	/* page size */

/******************************************************************************
 *
 *		PAGE TABLE ENTRY BITS
 *
 *****************************************************************************/

#define P_PRESBIT   0
#define P_PRES	    (1 << P_PRESBIT)
#define P_WRITEBIT  1
#define P_WRITE     (1 << P_WRITEBIT)
#define P_USERBIT   2
#define P_USER	    (1 << P_USERBIT)
#define P_ACCBIT    5
#define P_ACC	    (1 << P_ACCBIT)
#define P_DIRTYBIT  6
#define P_DIRTY     (1 << P_DIRTYBIT)

#define P_AVAIL     (P_PRES+P_WRITE+P_USER) /* avail to user & present */

/****************************************************
 *
 *  Page types for page allocator calls
 *
 ***************************************************/

#define PG_VM	    0
#define PG_SYS	    1
#define PG_RESERVED1	2
#define PG_PRIVATE  3
#define PG_RESERVED2	4
#define PG_RELOCK   5	    /* PRIVATE to MMGR */
#define PG_INSTANCE 6
#define PG_HOOKED   7
#define PG_IGNORE   0xFFFFFFFF

/****************************************************
 *
 *  Definitions for the access byte in a descriptor
 *
 ***************************************************/

/*
 *  Following fields are common to segment and control descriptors
 */
#define D_PRES	    0x080	/* present in memory */
#define D_NOTPRES   0	    /* not present in memory */

#define D_DPL0	    0	    /* Ring 0 */
#define D_DPL1	    0x020	/* Ring 1 */
#define D_DPL2	    0x040	/* Ring 2 */
#define D_DPL3	    0x060	/* Ring 3 */

#define D_SEG	    0x010	/* Segment descriptor */
#define D_CTRL	    0	    /* Control descriptor */

#define D_GRAN_BYTE 0x000	/* Segment length is byte granular */
#define D_GRAN_PAGE 0x080	/* Segment length is page granular */
#define D_DEF16     0x000	/* Default operation size is 16 bits */
#define D_DEF32     0x040	/* Default operation size is 32 bits */


/*
 *  Following fields are specific to segment descriptors
 */
#define D_CODE	    0x08	/* code */
#define D_DATA	    0	    /* data */

#define D_X	0	/* if code, exec only */
#define D_RX	    0x02	/* if code, readable */
#define D_C	0x04	    /* if code, conforming */

#define D_R	0	/* if data, read only */
#define D_W	0x02	    /* if data, writable */
#define D_ED	    0x04	/* if data, expand down */

#define D_ACCESSED  1	    /* segment accessed bit */


/*
 *  Useful combination access rights bytes
 */
#define RW_DATA_TYPE	(D_PRES+D_SEG+D_DATA+D_W)
#define R_DATA_TYPE (D_PRES+D_SEG+D_DATA+D_R)
#define CODE_TYPE   (D_PRES+D_SEG+D_CODE+D_RX)

#define D_PAGE32    (D_GRAN_PAGE+D_DEF32)   /* 32 bit Page granular */

/*
 * Masks for selector fields
 */
#define SELECTOR_MASK	0xFFF8	    /* selector index */
#define SEL_LOW_MASK	0xF8	    /* mask for low byte of sel indx */
#define TABLE_MASK  0x04	/* table bit */
#define RPL_MASK    0x03	/* privilige bits */
#define RPL_CLR     (~RPL_MASK) /* clear ring bits */

#define IVT_ROM_DATA_SIZE   0x500

/*XLATOFF*/

#ifndef Not_VxD

#define ENABLE_INTERRUPTS() {__asm sti}
#define DISABLE_INTERRUPTS()	{__asm cli}

#define SAVE_FLAGS(flags) {\
    {__asm pushfd}; \
    {__asm pop flags}}

#define RESTORE_FLAGS(flags) {\
    {__asm push flags}; \
    {__asm popfd}}

#define IO_Delay() {\
    {__asm _emit 0xeb}; \
    {__asm _emit 0x00}}

#define Touch_Register(Register) {_asm xor Register, Register}

typedef DWORD	HEVENT;

#define VMM_GET_DDB_NAMED 0

#pragma warning (disable:4209)	// turn off redefine warning (with basedef.h)

typedef ULONG HTIMEOUT;     // timeout handle
typedef ULONG CMS;	// count of milliseconds

#pragma warning (default:4209)	// turn on redefine warning (with basedef.h)

typedef DWORD	VMM_SEMAPHORE;


#ifndef WANTVXDWRAPS

WORD VXDINLINE
Get_VMM_Version()
{
    WORD w;
    VMMCall(Get_VMM_Version);
    _asm mov [w], ax
    return(w);
}

PVOID VXDINLINE
_HeapAllocate(ULONG Bytes, ULONG Flags)
{
    PVOID p;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    _asm push [Flags]
    _asm push [Bytes]
    VMMCall(_HeapAllocate)
    _asm add esp, 8
    _asm mov [p], eax
    return(p);
}

ULONG VXDINLINE
_HeapFree(PVOID Address, ULONG Flags)
{
    ULONG ul;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    _asm push [Flags]
    _asm push [Address]
    VMMCall(_HeapFree)
    _asm add esp, 8
    _asm mov [ul], eax
    return(ul);
}

HEVENT VXDINLINE
Call_Global_Event(void (__cdecl *pfnEvent)(), ULONG ulRefData)
{
    HEVENT hevent;
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnEvent]
    VMMCall(Call_Global_Event)
    _asm mov [hevent], esi
    return(hevent);
}

HEVENT VXDINLINE
Schedule_Global_Event(void (__cdecl *pfnEvent)(), ULONG ulRefData)
{
    HEVENT hevent;
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnEvent]
    VMMCall(Schedule_Global_Event)
    _asm mov [hevent], esi
    return(hevent);
}

void VXDINLINE
Cancel_Global_Event( HEVENT hevent )
{
    _asm mov esi, hevent
    VMMCall( Cancel_Global_Event );
}

HVM VXDINLINE
Get_Sys_VM_Handle(VOID)
{
    HVM hvm;
    Touch_Register(ebx)
    VxDCall(Get_Sys_VM_Handle);
    _asm mov [hvm], ebx
    return(hvm);
}

VOID VXDINLINE
Fatal_Error_Handler(PCHAR pszMessage, DWORD dwExitFlag)
{
    _asm mov esi, [pszMessage]
    _asm mov eax, [dwExitFlag]
    VMMCall(Fatal_Error_Handler);
}

VMM_SEMAPHORE VXDINLINE
Create_Semaphore(LONG lTokenCount)
{
    VMM_SEMAPHORE vmm_semaphore;
    _asm mov ecx, [lTokenCount]
    VMMCall(Create_Semaphore)
    _asm cmc
    _asm sbb ecx, ecx
    _asm and eax, ecx
    _asm mov [vmm_semaphore], eax
    return(vmm_semaphore);
}

void VXDINLINE
Destroy_Semaphore(VMM_SEMAPHORE vsSemaphore)
{
    _asm mov eax, [vsSemaphore]
    VMMCall(Destroy_Semaphore)
}

void VXDINLINE
Signal_Semaphore(VMM_SEMAPHORE vsSemaphore)
{
    _asm mov eax, [vsSemaphore]
    VMMCall(Signal_Semaphore)
}

void VXDINLINE
Wait_Semaphore(VMM_SEMAPHORE vsSemaphore, DWORD dwFlags)
{
    _asm mov eax, [vsSemaphore]
    _asm mov ecx, [dwFlags]
    VMMCall(Wait_Semaphore)
}

HVM VXDINLINE
Get_Execution_Focus(void)
{
    HVM hvm;
    Touch_Register(ebx)
    VMMCall(Get_Execution_Focus)
    _asm mov [hvm], ebx
    return(hvm);
}

void VXDINLINE
Begin_Critical_Section(ULONG Flags)
{
    _asm mov ecx, [Flags]
    VMMCall(Begin_Critical_Section)
}

void VXDINLINE
End_Critical_Section(void)
{
    VMMCall(End_Critical_Section)
}

void VXDINLINE
Fatal_Memory_Handler(void)
{
    VMMCall(Fatal_Memory_Error);
}

void VXDINLINE
Begin_Nest_Exec(void)
{
    VMMCall(Begin_Nest_Exec)
}

void VXDINLINE
End_Nest_Exec(void)
{
    VMMCall(End_Nest_Exec)
}

void VXDINLINE
Resume_Exec(void)
{
    VMMCall(Resume_Exec)
}

HTIMEOUT VXDINLINE
Set_VM_Time_Out(void (*pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_VM_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

HTIMEOUT VXDINLINE
Set_Global_Time_Out(void (__cdecl *pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_Global_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

void VXDINLINE
Cancel_Time_Out(HTIMEOUT htimeout)
{
    _asm mov esi, htimeout
    VMMCall(Cancel_Time_Out)
}


void VXDINLINE
Update_System_Clock(ULONG msElapsed)
{
    __asm mov ecx,[msElapsed]
    VMMCall(Update_System_Clock)
}

void VXDINLINE
Enable_Touch_1st_Meg(void)
{
    VMMCall(Enable_Touch_1st_Meg)
}

void VXDINLINE
Disable_Touch_1st_Meg(void)
{
    VMMCall(Disable_Touch_1st_Meg)
}

void VXDINLINE
Out_Debug_String(char *psz)
{
    __asm pushad
    __asm mov esi, [psz]
    VMMCall(Out_Debug_String)
    __asm popad
}

void VXDINLINE
Queue_Debug_String(char *psz, ULONG ulEAX, ULONG ulEBX)
{
    _asm push esi
    _asm push [ulEAX]
    _asm push [ulEBX]
    _asm mov esi, [psz]
    VMMCall(Queue_Debug_String)
    _asm pop esi
}

#ifdef WIN40SERVICES

HTIMEOUT VXDINLINE
Set_Async_Time_Out(void (*pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_Async_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

VXDINLINE struct VxD_Desc_Block *
VMM_Get_DDB(WORD DeviceID, PCHAR Name)
{
    struct VxD_Desc_Block *p;
    _asm movzx eax, [DeviceID]
    _asm mov edi, [Name]
    VMMCall(Get_DDB);
    _asm mov [p], ecx
    return(p);
}

DWORD VXDINLINE
VMM_Directed_Sys_Control(struct VxD_Desc_Block *DDB, DWORD SysControl, DWORD rEBX, DWORD rEDX, DWORD rESI, DWORD rEDI)
{
    DWORD dw;
    _asm mov eax, [SysControl]
    _asm mov ebx, [rEBX]
    _asm mov ecx, [DDB]
    _asm mov edx, [rEDX]
    _asm mov esi, [rESI]
    _asm mov edi, [rEDI]
    VMMCall(Directed_Sys_Control);
    _asm mov [dw], eax
    return(dw);
}

void VXDINLINE
_Trace_Out_Service(char *psz)
{
    __asm push psz
    VMMCall(_Trace_Out_Service)
}

void VXDINLINE
_Debug_Out_Service(char *psz)
{
    __asm push psz
    VMMCall(_Debug_Out_Service)
}

void VXDINLINE
_Debug_Flags_Service(ULONG flags)
{
    __asm push flags
    VMMCall(_Debug_Flags_Service)
}

void VXDINLINE _cdecl
_Debug_Printf_Service(char *pszfmt, ...)
{
    __asm lea  eax,(pszfmt + 4)
    __asm push eax
    __asm push pszfmt
    VMMCall(_Debug_Printf_Service)
    __asm add esp, 2*4
}

#endif // WIN40SERVICES

#endif // WANTVXDWRAPS

#endif // Not_VxD

/*XLATON*/

#endif /* _VMM_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\bindctx.cpp ===
#include "stock.h"
#pragma hdrstop

STDAPI BindCtx_CreateWithMode(DWORD grfMode, IBindCtx **ppbc)
{
    ASSERTMSG(ppbc != NULL, "Caller must pass valid ppbc");

    HRESULT hr = CreateBindCtx(0, ppbc);
    if (SUCCEEDED(hr))
    {
        BIND_OPTS bo = {sizeof(bo), 0, grfMode, 0};
        hr = (*ppbc)->SetBindOptions(&bo);

        if (FAILED(hr))
        {
            ATOMICRELEASE(*ppbc);
        }
    }

    ASSERT(SUCCEEDED(hr) ? (*ppbc != NULL) : (*ppbc == NULL));
    return hr;
}

STDAPI_(DWORD) BindCtx_GetMode(IBindCtx *pbc, DWORD grfModeDefault)
{
    if (pbc)
    {
        BIND_OPTS bo = {sizeof(bo)};  // Requires size filled in.
        if (SUCCEEDED(pbc->GetBindOptions(&bo)))
            grfModeDefault = bo.grfMode;
    }
    return grfModeDefault;
}

STDAPI_(BOOL) BindCtx_ContainsObject(IBindCtx *pbc, LPOLESTR psz)
{
    BOOL bResult = FALSE;
    IUnknown *punk;
    if (pbc && SUCCEEDED(pbc->GetObjectParam(psz, &punk)))
    {
        bResult = TRUE;
        punk->Release();
    }
    return bResult;
}

class CDummyUnknown : public IOleWindow
{
public:
    CDummyUnknown() : _cRef(1), _hwnd(NULL) {}
    CDummyUnknown(HWND hwnd) : _cRef(1), _hwnd(hwnd) {}
    
    //  IUnknown refcounting
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv)
    {
        static const QITAB qit[] = {
            QITABENT(CDummyUnknown, IOleWindow ),
            { 0 },
        };
        return QISearch(this, qit, riid, ppv);
    }
    STDMETHODIMP_(ULONG) AddRef(void)
    {
       return ++_cRef;
    }
    STDMETHODIMP_(ULONG) Release(void)
    {
        if (--_cRef > 0)
            return _cRef;

        delete this;
        return 0;    
    }

    // IOleWindow
    STDMETHODIMP GetWindow(HWND * lphwnd) { *lphwnd = _hwnd; return _hwnd ? S_OK : E_NOTIMPL; }
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }

protected:
    LONG _cRef;
    HWND _hwnd;
};

STDAPI BindCtx_RegisterObjectParam(IBindCtx *pbcIn, LPCOLESTR pszRegister, IUnknown *punkRegister, IBindCtx **ppbcOut)
{
    HRESULT hr = S_OK;
    *ppbcOut = pbcIn;

    if (pbcIn)
        pbcIn->AddRef();
    else
        hr = CreateBindCtx(0, ppbcOut);
        
    if (SUCCEEDED(hr))
    {
        IUnknown *punkDummy = NULL;
        if (!punkRegister)
        {
            punkRegister = punkDummy = new CDummyUnknown();
            hr = punkDummy ? S_OK : E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
            hr = (*ppbcOut)->RegisterObjectParam((LPOLESTR)pszRegister, punkRegister);

            if (punkDummy)
                punkDummy->Release();
        }
        
        if (FAILED(hr))
            ATOMICRELEASE(*ppbcOut);

    }

    return hr;
}

STDAPI BindCtx_RegisterObjectParams(IBindCtx *pbcIn, BINDCTX_PARAM *rgParams, UINT cParams, IBindCtx **ppbcOut)
{
    HRESULT hr = S_FALSE;
    //  require at least one param
    ASSERT(cParams);
    *ppbcOut = 0;
    for (UINT i = 0; SUCCEEDED(hr) && i < cParams; i++)
    {
        //  returns the in param if NON-NULL
        hr = BindCtx_RegisterObjectParam(pbcIn, rgParams[i].pszName, rgParams[i].pbcParam, &pbcIn);
            
        // we only keep the first addref()
        // and we return it
        if (SUCCEEDED(hr))
        {
            if (i == 0)
                *ppbcOut = pbcIn;
            else
                pbcIn->Release();
        }
    }

    if (FAILED(hr))
    {
        ATOMICRELEASE(*ppbcOut);
    }

    return hr;
}

STDAPI BindCtx_RegisterUIWindow(IBindCtx *pbcIn, HWND hwnd, IBindCtx **ppbcOut)
{
    IUnknown *punkDummy = new CDummyUnknown(hwnd);
    HRESULT hr = punkDummy ? S_OK : E_OUTOFMEMORY;
    if (SUCCEEDED(hr))
    {
        hr = BindCtx_RegisterObjectParam(pbcIn, STR_DISPLAY_UI_DURING_BINDING, punkDummy, ppbcOut);
        punkDummy->Release();
    }
    else
    {
        *ppbcOut = 0;
    }
    return hr;
}
        
STDAPI_(HWND) BindCtx_GetUIWindow(IBindCtx *pbc)
{
    HWND hwnd = NULL;
    IUnknown *punk;
    if (pbc && SUCCEEDED(pbc->GetObjectParam(STR_DISPLAY_UI_DURING_BINDING, &punk)))
    {
        IUnknown_GetWindow(punk, &hwnd);
        punk->Release();
    }
    return hwnd;
}
    
// dwTicksToAllow is time in msec relative to "now"

STDAPI BindCtx_CreateWithTimeoutDelta(DWORD dwTicksToAllow, IBindCtx **ppbc)
{
    HRESULT hr = CreateBindCtx(0, ppbc);
    if (SUCCEEDED(hr))
    {
        DWORD dwDeadline = GetTickCount() + dwTicksToAllow;
        if (0 == dwDeadline)
            dwDeadline = 1;

        BIND_OPTS bo = {sizeof(bo), 0, 0, dwDeadline};
        hr = (*ppbc)->SetBindOptions(&bo);
        if (FAILED(hr))
        {
            ATOMICRELEASE(*ppbc);
        }
    }

    ASSERT(SUCCEEDED(hr) ? (*ppbc != NULL) : (*ppbc == NULL));
    return hr;
}

// returns # of msec relative to "now" to allow the operation to take

STDAPI BindCtx_GetTimeoutDelta(IBindCtx *pbc, DWORD *pdwTicksToAllow)
{
    *pdwTicksToAllow = 0;

    HRESULT hr = E_FAIL;
    if (pbc)
    {
        BIND_OPTS bo = {sizeof(bo)};  // Requires size filled in.
        if (SUCCEEDED(pbc->GetBindOptions(&bo)))
        {
            if (bo.dwTickCountDeadline)
            {
                DWORD dwNow = GetTickCount();
                if (dwNow > bo.dwTickCountDeadline)
                {
                    *pdwTicksToAllow = 0;   // we have already elappsed the timeout, return 0
                }
                else
                {
                    *pdwTicksToAllow = bo.dwTickCountDeadline - dwNow;  // positive delta in the future
                }
                hr = S_OK;
            }
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\win95\vpowerd.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       VPOWERD.H
*
*  VERSION:     1.0
*
*  DATE:        01 Oct 1993
*
*  AUTHOR:      TCS
*
*  Definitions for the Virtual Power Management Device.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  01 Oct 1993 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_VPOWERD
#define _INC_VPOWERD

#ifndef Not_VxD

//
//  Virtual Power Management Device service table.
//

/*XLATOFF*/
#define VPOWERD_Service                 Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VPOWERD, VxD)

    VPOWERD_Service     (_VPOWERD_Get_Version, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Get_APM_BIOS_Version, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Get_Power_Management_Level, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Set_Power_Management_Level, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Set_Device_Power_State, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Set_System_Power_State, VxD_LOCKED_CODE)
    VPOWERD_Service     (_VPOWERD_Restore_Power_On_Defaults, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Get_Power_Status, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Get_Power_State, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_OEM_APM_Function, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Register_Power_Handler, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Deregister_Power_Handler, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_W32_Get_System_Power_Status, VxD_PAGEABLE_CODE)	
	VPOWERD_Service     (_VPOWERD_W32_Set_System_Power_State, VxD_PAGEABLE_CODE)
	// APM 1.2 services
	VPOWERD_Service     (_VPOWERD_Get_Capabilities, VxD_PAGEABLE_CODE)
	VPOWERD_Service     (_VPOWERD_Enable_Resume_On_Ring, VxD_PAGEABLE_CODE)
	VPOWERD_Service     (_VPOWERD_Disable_Resume_On_Ring, VxD_PAGEABLE_CODE)
	VPOWERD_Service     (_VPOWERD_Set_Resume_Timer, VxD_PAGEABLE_CODE)
	VPOWERD_Service     (_VPOWERD_Get_Resume_Timer, VxD_PAGEABLE_CODE)
	VPOWERD_Service     (_VPOWERD_Disable_Resume_Timer, VxD_PAGEABLE_CODE)
	VPOWERD_Service     (_VPOWERD_Enable_Timer_Based_Requests, VxD_PAGEABLE_CODE)
	VPOWERD_Service     (_VPOWERD_Disable_Timer_Based_Requests, VxD_PAGEABLE_CODE)
	VPOWERD_Service     (_VPOWERD_W32_Get_Power_Status, VxD_PAGEABLE_CODE)
	VPOWERD_Service		(_VPOWERD_Get_Timer_Based_Requests_Status, VxD_PAGEABLE_CODE)
	VPOWERD_Service		(_VPOWERD_Get_Ring_Resume_Status, VxD_PAGEABLE_CODE)

End_Service_Table(VPOWERD, VxD)
/*ENDMACROS*/


#endif

/*XLATOFF*/

#ifdef IS_32
#define POWERFAR
#else
#define POWERFAR                        _far
#endif

/*XLATON*/

//
//  Standard return type from VPOWERD services and handlers.
//
//  Error codes 0x00000001 through 0x000000FF are reserved for APM firmware
//  errors.
//
//  Error codes above 0x80000000 are reserved for definition by VPOWERD
//

typedef DWORD                           POWERRET;

#define PR_SUCCESS                      0x00000000

#define PR_PM_DISABLED                  0x00000001
#define PR_RM_CONNECT_EXISTS            0x00000002
#define PR_INTERFACE_NOT_CONNECTED      0x00000003
#define PR_16BIT_PM_CONNECT_EXISTS      0x00000005
#define PR_16BIT_PM_UNSUPPORTED         0x00000006
#define PR_32BIT_PM_CONNECT_EXISTS      0x00000007
#define PR_32BIT_PM_UNSUPPORTED         0x00000008
#define PR_UNRECOGNIZED_DEVICE_ID       0x00000009
#define PR_PARAMETER_OUT_OF_RANGE       0x0000000A
#define PR_INTERFACE_NOT_ENGAGED        0x0000000B
// 	APM 1.2 error codes
#define PR_FUNC_NOT_SUPPORTED			0x0000000C
#define PR_RESUME_TIMER_DISABLED		0x0000000D
//	end
#define PR_CANNOT_ENTER_STATE           0x00000060
#define PR_NO_PM_EVENTS_PENDING         0x00000080
#define PR_APM_NOT_PRESENT              0x00000086
#define PR_UNDEFINED_FUNCTION           0x000000FF

#define PR_DEFAULT                      0x80000000
#define PR_FAILURE                      0x80000001
#define PR_REQUEST_VETOED               0x80000002
#define PR_INVALID_POINTER              0x80000003
#define PR_INVALID_FLAG                 0x80000004
#define PR_INVALID_PMLEVEL              0x80000005
#define PR_INVALID_DEVICE_ID            0x80000006
#define PR_INVALID_POWER_STATE          0x80000007
#define PR_INVALID_REQUEST_TYPE         0x80000008
#define PR_OUT_OF_MEMORY                0x80000009
#define PR_DUPLICATE_POWER_HANDLER      0x8000000A
#define PR_POWER_HANDLER_NOT_FOUND      0x8000000B
#define PR_INVALID_FUNCTION             0x8000000C

//
//  Power device ID type and standard IDs as defined by the APM 1.1
//  specification.
//

typedef DWORD                           POWER_DEVICE_ID;

#define PDI_APM_BIOS                    0x0000
#define PDI_MANAGED_BY_APM_BIOS         0x0001
#define PDI_MANAGED_BY_APM_BIOS_OLD     0xFFFF
// 	APM 1.2
#define PDI_SPECIFIC_BATTERY			0x8000	// OR in the 1 based battery unit number
//	end

//
//  Power state type and standard power states as defined by the APM 1.1
//  specification.
//

typedef DWORD                           POWER_STATE;
typedef POWER_STATE POWERFAR*           LPPOWER_STATE;

#define PSTATE_APM_ENABLED              0x0000
#define PSTATE_STANDBY                  0x0001
#define PSTATE_SUSPEND                  0x0002
#define PSTATE_OFF                      0x0003
//	APM 1.2
#define PSTATE_HIBERNATE				0x0006
//  end

//
//  Valid power management levels.
//

#define PMLEVEL_ADVANCED                0
#define PMLEVEL_STANDARD                1
#define PMLEVEL_OFF                     2
#define PMLEVEL_MAXIMUM                 PMLEVEL_OFF

//
//  Valid request types.
//

#define REQTYPE_USER_INITIATED          0x00000000
#define REQTYPE_TIMER_INITIATED         0x00000001
#define REQTYPE_FORCED_REQUEST          0x00000002
#define REQTYPE_BIOS_CRITICAL_SUSPEND   0x00000003
#define REQTYPE_FROM_BIOS_FLAG          0x80000000                  // ;Internal

// valid values for Status returned by Get_Timer_Based_Requests_Status and Get_Ring_Resume_Status
#define CAPABILITY_ENABLED	0x00000001
#define CAPABILITY_DISABLED	0x00000000

//
//  Power status structures returned by _VPOWERD_Get_Power_Status and
//  _VPOWERD_W32_Get_Power_Status.
//

#ifndef NOPOWERSTATUSDEFINES

#define AC_LINE_OFFLINE                 0x00
#define AC_LINE_ONLINE                  0x01
#define AC_LINE_BACKUP_POWER            0x02
#define AC_LINE_UNKNOWN                 0xFF

#define BATTERY_STATUS_HIGH             0x00
#define BATTERY_STATUS_LOW              0x01
#define BATTERY_STATUS_CRITICAL         0x02
#define BATTERY_STATUS_CHARGING         0x03
#define BATTERY_STATUS_UNKNOWN          0xFF

#define BATTERY_FLAG_HIGH               0x01
#define BATTERY_FLAG_LOW                0x02
#define BATTERY_FLAG_CRITICAL           0x04
#define BATTERY_FLAG_CHARGING           0x08
//	APM 1.2 
#define BATTERY_NOT_PRESENT				0x10
//	end
#define BATTERY_FLAG_NO_BATTERY         0x80
#define BATTERY_FLAG_UNKNOWN            0xFF

#define BATTERY_PERCENTAGE_UNKNOWN      0xFF

#define BATTERY_LIFE_MINUTES_MASK       0x8000
#define BATTERY_LIFE_UNKNOWN            0xFFFF

#define BATTERY_LIFE_W32_UNKNOWN        0xFFFFFFFF

#endif  // NOPOWERSTATUSDEFINES

typedef struct _POWER_STATUS {
    BYTE PS_AC_Line_Status;
    BYTE PS_Battery_Status;
    BYTE PS_Battery_Flag;
    BYTE PS_Battery_Life_Percentage;
    WORD PS_Battery_Life_Time;	
}   POWER_STATUS;

typedef POWER_STATUS POWERFAR* LPPOWER_STATUS;

typedef struct _POWERTIME {  // st  
    WORD Year;
    WORD Month;
    WORD DayOfWeek;
    WORD Day;
    WORD Hour;
    WORD Minute;
    WORD Second;
    WORD Milliseconds;
} POWERTIME;

typedef POWERTIME POWERFAR* LPPOWERTIME;

typedef struct APM_CAPABILITIES_S	{
		WORD Capabilities;
		BYTE BatteryCount;
		BYTE Reserved;
}APM_CAPABILITIES, *PAPM_CAPABILITIES;

/*
Capability flags
Bit 0 = 1  System can enter global standby state. Indicates BIOS will post standby and standby-resume events.
Bit 1 = 1  System can enter global suspend state. Indicates BIOS will post suspend and suspend-resume events.
Bit 2 = 1  Resume timer will wake up from standby.
Bit 3 = 1  Resume timer will wake up from suspend.
Bit 4 = 1  Resume on ring indicator (internal COM or modem) will wake up from standby.
Bit 5 = 1  Resume on ring indicator (internal COM or modem) will wake up from suspend.
Bit 6 = 1  PCMCIA Ring indicator will wake up from standby.
Bit 7 = 1  PCMCIA Ring indicator will wake up from suspend.
Other bits  Reserved (must be set to 0)
*/

#define GLOBAL_STANDBY_SUPPORTED_BIT		0
#define GLOBAL_STANDBY_SUPPORTED			(1 << GLOBAL_STANDBY_SUPPORTED_BIT)

#define GLOBAL_SUSPEND_SUPPORTED_BIT  		1
#define GLOBAL_SUSPEND_SUPPORTED			(1 << GLOBAL_SUSPEND_SUPPORTED_BIT)

#define WAKE_ON_TIMER_STANDBY_BIT			2
#define WAKE_ON_TIMER_STANDBY				(1 << WAKE_ON_TIMER_STANDBY_BIT)
		
#define WAKE_ON_TIMER_SUSPEND_BIT			3
#define WAKE_ON_TIMER_SUSPEND				(1 << WAKE_ON_TIMER_SUSPEND_BIT)

#define RING_RESUME_INTERNAL_STANDBY_BIT	4
#define RING_RESUME_INTERNAL_STANDBY		(1 << RING_RESUME_INTERNAL_STANDBY_BIT)

#define RING_RESUME_INTERNAL_SUSPEND_BIT	5
#define RING_RESUME_INTERNAL_SUSPEND		(1 << RING_RESUME_INTERNAL_SUSPEND_BIT)

#define RING_RESUME_PCMCIA_STANDBY_BIT		6
#define RING_RESUME_PCMCIA_STANDBY			(1 << RING_RESUME_PCMCIA_STANDBY_BIT)

#define RING_RESUME_PCMCIA_SUSPEND_BIT		7
#define RING_RESUME_PCMCIA_SUSPEND			(1 << RING_RESUME_PCMCIA_SUSPEND_BIT)


typedef struct _WIN32_SYSTEM_POWER_STATUS {
    BYTE W32PS_AC_Line_Status;
    BYTE W32PS_Battery_Flag;
    BYTE W32PS_Battery_Life_Percent;
    BYTE W32PS_Reserved1;
    DWORD W32PS_Battery_Life_Time;
    DWORD W32PS_Battery_Full_Life_Time;
}   WIN32_SYSTEM_POWER_STATUS;

typedef WIN32_SYSTEM_POWER_STATUS POWERFAR* LPWIN32_SYSTEM_POWER_STATUS;

//
//  OEM APM Register Structure used by _VPOWERD_OEM_APM_Function.
//

struct _OEM_APM_BYTE_REGS {
    WORD OEMAPM_Reserved1[6];
    BYTE OEMAPM_BL;
    BYTE OEMAPM_BH;
    WORD OEMAPM_Reserved2;
    BYTE OEMAPM_DL;
    BYTE OEMAPM_DH;
    WORD OEMAPM_Reserved3;
    BYTE OEMAPM_CL;
    BYTE OEMAPM_CH;
    WORD OEMAPM_Reserved4;
    BYTE OEMAPM_AL;
    BYTE OEMAPM_AH;
    WORD OEMAPM_Reserved5;
    BYTE OEMAPM_Flags;
    BYTE OEMAPM_Reserved6[3];
};

struct _OEM_APM_WORD_REGS {
    WORD OEMAPM_DI;
    WORD OEMAPM_Reserved7;
    WORD OEMAPM_SI;
    WORD OEMAPM_Reserved8;
    WORD OEMAPM_BP;
    WORD OEMAPM_Reserved9;
    WORD OEMAPM_BX;
    WORD OEMAPM_Reserved10;
    WORD OEMAPM_DX;
    WORD OEMAPM_Reserved11;
    WORD OEMAPM_CX;
    WORD OEMAPM_Reserved12;
    WORD OEMAPM_AX;
    WORD OEMAPM_Reserved13[3];
};

struct _OEM_APM_DWORD_REGS {
    DWORD OEMAPM_EDI;
    DWORD OEMAPM_ESI;
    DWORD OEMAPM_EBP;
    DWORD OEMAPM_EBX;
    DWORD OEMAPM_EDX;
    DWORD OEMAPM_ECX;
    DWORD OEMAPM_EAX;
    DWORD OEMAPM_Reserved14;
};

typedef union _OEM_APM_REGS {
    struct _OEM_APM_BYTE_REGS ByteRegs;
    struct _OEM_APM_WORD_REGS WordRegs;
    struct _OEM_APM_DWORD_REGS DwordRegs;
}   OEM_APM_REGS;

typedef OEM_APM_REGS POWERFAR*          LPOEM_APM_REGS;

//
//  Possible power function codes that are sent to POWER_HANDLER callbacks.
//

typedef DWORD                           POWERFUNC;

#define PF_SUSPEND_PHASE1               0x00000000
#define PF_SUSPEND_PHASE2               0x00000001
#define PF_SUSPEND_INTS_OFF             0x00000002
#define PF_RESUME_INTS_OFF              0x00000003
#define PF_RESUME_PHASE2                0x00000004
#define PF_RESUME_PHASE1                0x00000005
#define PF_BATTERY_LOW                  0x00000006
#define PF_POWER_STATUS_CHANGE          0x00000007
#define PF_UPDATE_TIME                  0x00000008
#define PF_CAPABILITIES_CHANGE			0x00000009
#define PF_APMOEMEVENT_FIRST            0x00000200
#define PF_APMOEMEVENT_LAST             0x000002FF

//
//
//

#define PFG_UI_ALLOWED                  0x00000001
#define PFG_CANNOT_FAIL                 0x00000002
#define PFG_REQUEST_VETOED              0x00000004
#define PFG_REVERSE                     0x00000008
#define PFG_STANDBY                     0x00000010
#define PFG_CRITICAL                    0x00000020
#ifdef SUPPORT_HIBERNATE
#define PFG_HIBERNATE					0x00000040	// NEW for APM 1.2
#endif
#define PFG_KEPT_POWER					0x00000080

//
//  Standard POWER_HANDLER priority levels.
//

#define PHPL_PBT_BROADCAST              0x40000000
#define PHPL_UNKNOWN                    0x80000000
#define PHPL_CONFIGMG                   0xC0000000
#define PHPL_TIMER			0xE0000000

//
//
//

typedef POWERRET (*POWER_HANDLER)(POWERFUNC, DWORD);

//
//  VPOWERD BroadcastSystemMessage API parameter blocks.
//

typedef struct _VPOWERD_BSMAPI_HEADER {
    DWORD VBAPIH_Packet_Size;
    WORD VBAPIH_Function;
    DWORD VBAPIH_Return_Code;
}   VPOWERD_BSMAPI_HEADER;

#define VBAPIF_W32_SET_SYSTEM_STATE     0x000D

typedef struct _VPOWERD_BSMAPI_W32_SET_SYSTEM_STATE {
    struct _VPOWERD_BSMAPI_HEADER VBWSSS_VBAPIH;
    DWORD VBWSSS_Force_Flag;
}   VPOWERD_BSMAPI_W32_SET_SYSTEM_STATE;

//
//  Virtual Power Management Device service prototypes.
//

/*XLATOFF*/

BOOL
POWERFAR CDECL
VPOWERD_Get_Entry_Point(
    VOID
    );

DWORD
POWERFAR CDECL
_VPOWERD_Get_Version(
    VOID
    );

DWORD
POWERFAR CDECL
_VPOWERD_Get_APM_BIOS_Version(
    VOID
    );

DWORD
POWERFAR CDECL
_VPOWERD_Get_Power_Management_Level(
    VOID
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Set_Power_Management_Level(
    DWORD Power_Management_Level
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Set_Device_Power_State(
    POWER_DEVICE_ID Power_Device_ID,
    POWER_STATE Power_State
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Set_System_Power_State(
    POWER_STATE Power_State,
    DWORD Request_Type
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Restore_Power_On_Defaults(
    VOID
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Get_Power_Status(
    POWER_DEVICE_ID Power_Device_ID,
    LPPOWER_STATUS lpPower_Status
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Get_Power_State(
    POWER_DEVICE_ID Power_Device_ID,
    LPPOWER_STATE lpPower_State
    );

POWERRET
POWERFAR CDECL
_VPOWERD_OEM_APM_Function(
    LPOEM_APM_REGS lpOEM_APM_Regs
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Register_Power_Handler(
    POWER_HANDLER Power_Handler,
    DWORD Priority
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Deregister_Power_Handler(
    POWER_HANDLER Power_Handler
    );

BOOL
POWERFAR CDECL
_VPOWERD_W32_Get_System_Power_Status(
    LPWIN32_SYSTEM_POWER_STATUS lpWin32_System_Power_Status
    );

DWORD
POWERFAR CDECL
_VPOWERD_W32_Set_System_Power_State(
    BOOL Suspend_Flag,
    BOOL Force_Flag
    );


POWERRET
POWERFAR CDECL
_VPOWERD_Get_Capabilities(
	PAPM_CAPABILITIES pAPMCaps
	);

POWERRET
POWERFAR CDECL
_VPOWERD_Enable_Resume_On_Ring(
	VOID
	);

POWERRET
POWERFAR CDECL
_VPOWERD_Disable_Resume_On_Ring(
	VOID
	);

POWERRET
POWERFAR CDECL
_VPOWERD_Set_Resume_Timer(
	LPPOWERTIME pPowerTime
	);

POWERRET
POWERFAR CDECL
_VPOWERD_Get_Resume_Timer(
	LPPOWERTIME pPowerTime
	);

POWERRET
POWERFAR CDECL
_VPOWERD_Disable_Resume_Timer(
	VOID
	);

POWERRET
POWERFAR CDECL
_VPOWERD_Enable_Timer_Based_Requests(
	VOID
	);

POWERRET
POWERFAR CDECL
_VPOWERD_Disable_Timer_Based_Requests(
	VOID
	);

POWERRET
POWERFAR CDECL
_VPOWERD_W32_Get_Power_Status(
	POWER_DEVICE_ID Power_Device_ID,
	LPWIN32_SYSTEM_POWER_STATUS lpWin32_System_Power_Status
	);

/*XLATON*/

#endif // _INC_VPOWERD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\win95\wshioctl.h ===
/*****************************************************************************
 *
 *  (C) Copyright MICROSOFT Corp., 1994
 *
 *  Title:	WSHOICTL.H - IOCTL interface for Wshell
 *
 *  Version:    4.00
 *
 *  Date:       30-Nov-1988
 *
 *  Author:	RAL
 *
 *----------------------------------------------------------------------------
 *
 *  Change log:
 *
 *     DATE     REV                 DESCRIPTION
 *  ----------- --- ----------------------------------------------------------
 *  01-Aug-1994 RAL Original
 *
 *****************************************************************************/

#ifndef _WSHIOCTL_H
#define _WSHIOCTL_H


#define SHELLFILENAME "\\\\.\\SHELL"

//
// Flags for _SHELL_SuggestSingleMSDOSMode
//
// SSAMFLAG_KILLVM
//	A fatal application error has occurred.  Display a warning box
//	unconditionally.  Regardless of the answer, terminate the VM.
//	If this bit is set, the call does not return.
//
//  SSAMFLAG_TIMER
//	Not used.  Sorry.
//
//  SSAM_REQREALMODE
//	App requires *real* mode, not V86 mode, not EMM stuff, not
//	QEMM.  Just pure unadulterated real mode.  Also known as
//	SSAM_COMANCHE, because Comanche does an "lgdt" to enter
//	protected mode without checking if it is safe to do so.
//	This flag is inspected by AppWiz to decide how to set up
//	the config.sys and autoexec.bat.
//
//  SSAM_KILLUNLESSTOLD
//	Suggest Single MS-DOS mode (unless suppressed via PIF), and
//	if the answer is "Okay", then kill the VM.  If the user
//	says, "Keep running", then let it stay.
//
//  SSAM_FROMREGLIST
//	This app was run from a command prompt, triggered by registry
//	settings.  Just re-execute it in its own VM so that APPS.INF
//	settings will take effect.
//
//  SSAM_FAILEDAPI
//	This app just made an API call that was unsuccessful or
//	unsupported.  If the app terminates within 0.1 second,
//	then suggest single-app mode.  If the app continues
//	execution, then don't suggest.
//

#define SSAMFLAG_KILLVM 	0x0000001
#define SSAMFLAG_TIMER		0x0000002
#define SSAMFLAG_REQREALMODE	0x0000004
#define SSAMFLAG_KILLUNLESSTOLD 0x0000008
#define SSAMFLAG_FROMREGLIST	0x0000010
#define SSAMFLAG_FAILEDAPI	0x0000020

//
//  IOCTL codes
//
#define WSHIOCTL_GETVERSION	0
#define WSHIOCTL_BLUESCREEN	1
#define WSHIOCTL_GET1APPINFO	2
#define WSHIOCTL_SIGNALSEM	3
#define WSHIOCTL_MAX		4	/* Remember, _MAX = _LIMIT + 1 */

//
//  Result codes
//
#define SSR_CONTINUE	0
#define SSR_CLOSEVM	1
#define SSR_KILLAPP	2

//
//  Sizes for strings
//
#define MAXVMTITLESIZE	32
#define MAXVMPROGSIZE	64
#define MAXVMCMDSIZE	64
#define MAXVMDIRSIZE	64
#define MAXPIFPATHSIZE	260

typedef struct _SINGLEAPPSTRUC {    /* shex */

	DWORD	SSA_dwFlags;
	DWORD	SSA_VMHandle;
	DWORD	SSA_ResultPtr;
	DWORD	SSA_Semaphore;
	char	SSA_PIFPath[MAXPIFPATHSIZE];
	char	SSA_VMTitle[MAXVMTITLESIZE];
	char	SSA_ProgName[MAXVMPROGSIZE];
	char	SSA_CommandLine[MAXVMCMDSIZE];
	char	SSA_CurDir[MAXVMCMDSIZE];

} SINGLEAPPSTRUC;

//
// Structures for WSHIOCTL_BLUESCREEN.
//
// lpvInBuffer must point to a BLUESCREENINFO structure.
// lpvOutBuffer must point to a DWORD which receives the message box result.
// The message box result is an IDXX value, as defined in windows.h.
//

/* H2INCSWITCHES -t */
typedef struct _BLUESCREENINFO {    /* bsi */

	char *	pszText;	    /* Message text (OEM character set) */
	char *	pszTitle;	    /* Message title (OEM character set) */
				    /* NULL means "Windows" */
	DWORD	flStyle;	    /* Message box flags (see windows.h) */
				    /* Add'l flags defined in ddk\inc\shell.h */

} BLUESCREENINFO;
/* H2INCSWITCHES -t- */



#endif // _WSHIOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\autosecurity.cpp ===
/*****************************************************************************\
    FILE: autosecurity.cpp

    DESCRIPTION:
        Helpers functions to check if an Automation interface or ActiveX Control
    is hosted or used by a safe caller.

    BryanSt 8/20/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include "stock.h"
#pragma hdrstop

#include <autosecurity.h>       // CAutomationSecurity
#include <ieguidp.h>            // IID_IBrowserService
#include "ccstock.h"            // LocalZoneCheck


/***************************************************************\
    DESCRIPTION:
        Some hosts are always safe.  Visual Basic is one example.

    PARAMETERS:
        RETURN: This function will return TRUE if the host is
                always safe.
        HRESULT: This is a more descriptive error so the caller
                can differenciate E_OUTOFMEMORY from E_INVALIDARG, etc.
\***************************************************************/
BOOL CAutomationSecurity::IsSafeHost(OUT OPTIONAL HRESULT * phr)
{
    BOOL fAlwaysSafe;

    // _dwSafetyOptions being zero means we are in a mode
    // that needs to assume the caller or data is from
    // an untrusted source.
    if (0 == _dwSafetyOptions)
    {
        fAlwaysSafe = TRUE;
        if (phr)
            *phr = S_OK;
    }
    else
    {
        fAlwaysSafe = FALSE;
        if (phr)
            *phr = E_ACCESSDENIED;
    }

    return fAlwaysSafe;
}


/***************************************************************\
    DESCRIPTION:
        The class that implements this can check if the host is
    from the Local zone.  This way, we can prevent a host that
    would try to call unsafe automation methods or misrepresent
    the consequence of the ActiveX Control's UI.

    PARAMETERS:
        RETURN: TRUE if the security check passed.  FALSE means
                the host isn't trusted so don't care out unsafe
                operations.
        dwFlags: What behaviors does the caller want?  Currently:
            CAS_REG_VALIDATION: This means the caller needs the
                host's HTML to be registered and the checksum to
                be valid.
        HRESULT: This is a more descriptive error so the caller
            can differenciate E_OUTOFMEMORY from E_INVALIDARG, etc.
\***************************************************************/
BOOL CAutomationSecurity::IsHostLocalZone(IN DWORD dwFlags, OUT OPTIONAL HRESULT * phr)
{
    HRESULT hr;

    // See if the host is always safe.
    if (!IsSafeHost(&hr))
    {
        // It isn't, so let's see if this content is safe.
        // (Normally the immediate HTML FRAME)
        
        // Is it from the local zone?
        hr = LocalZoneCheck(_punkSite);

        // Does the caller also want to verify it's checksum?
        if ((S_OK == hr) && (CAS_REG_VALIDATION & dwFlags))
        {
            IBrowserService* pbs;
            WCHAR wszPath[MAX_PATH];

            wszPath[0] = 0;
            hr = E_ACCESSDENIED;

            // ask the browser, for example we are in a .HTM doc
            if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SShellBrowser, IID_PPV_ARG(IBrowserService, &pbs))))
            {
                LPITEMIDLIST pidl;

                if (SUCCEEDED(pbs->GetPidl(&pidl)))
                {
                    DWORD dwAttribs = SFGAO_FOLDER;

                    if (SUCCEEDED(SHGetNameAndFlagsW(pidl, SHGDN_FORPARSING, wszPath, ARRAYSIZE(wszPath), &dwAttribs))
                            && (dwAttribs & SFGAO_FOLDER))   // This is a folder. So, wszPath should be the path for it's webview template
                    {
                        IOleCommandTarget *pct;

                        // find the template path from webview, for example a .HTT file
                        if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_DefView, IID_PPV_ARG(IOleCommandTarget, &pct))))
                        {
                            VARIANT vPath;

                            vPath.vt = VT_EMPTY;
                            if (pct->Exec(&CGID_DefView, DVCMDID_GETTEMPLATEDIRNAME, 0, NULL, &vPath) == S_OK)
                            {
                                if (vPath.vt == VT_BSTR && vPath.bstrVal)
                                {
                                    DWORD cchPath = ARRAYSIZE(wszPath);

                                    if (S_OK != PathCreateFromUrlW(vPath.bstrVal, wszPath, &cchPath, 0))
                                    {
                                        // it might not be an URL, in this case it is a file path
                                        StrCpyNW(wszPath, vPath.bstrVal, ARRAYSIZE(wszPath));
                                    }
                                }
                                VariantClear(&vPath);
                            }
                            pct->Release();
                        }
                    }
                    ILFree(pidl);
                }

                pbs->Release();
            }
            else
            {
                ASSERT(0);      // no browser, where are we?
            }

            if (wszPath[0])
            {
                DWORD dwRVTFlags = (SHRVT_VALIDATE | SHRVT_REGISTERIFPROMPTOK);

                if (CAS_PROMPT_USER & dwFlags)
                    dwRVTFlags |= SHRVT_PROMPTUSER;
                hr = SHRegisterValidateTemplate(wszPath, dwRVTFlags);
            }
        }
    }
    
    if (S_FALSE == hr)
        hr = E_ACCESSDENIED;    // The caller needs to soften the hr to S_OK if it's concerned for script.

    if (phr)
        *phr = hr;

    return ((S_OK == hr) ? TRUE : FALSE);
}


/***************************************************************\
    DESCRIPTION:
        The class that implements this can check if the host is
    from the Local zone.  This way, we can prevent a host that
    would try to call unsafe automation methods or misrepresent
    the consequence of the ActiveX Control's UI.

    PARAMETERS:
        RETURN: TRUE if the security check passed.  FALSE means
                the host isn't trusted so don't care out unsafe
                operations.
        dwFlags: What behaviors does the caller want?  Currently:
            CAS_REG_VALIDATION: This means the caller needs the
                host's HTML to be registered and the checksum to
                be valid.
        HRESULT: This is a more descriptive error so the caller
            can differenciate E_OUTOFMEMORY from E_INVALIDARG, etc.
\***************************************************************/
BOOL CAutomationSecurity::IsUrlActionAllowed(IN IInternetHostSecurityManager * pihsm, IN DWORD dwUrlAction, IN DWORD dwFlags, OUT OPTIONAL HRESULT * phr)
{
    HRESULT hr;
    IInternetHostSecurityManager * pihsmTemp = NULL;

    if (!pihsm)
    {
        hr = IUnknown_QueryService(_punkSite, IID_IInternetHostSecurityManager, IID_PPV_ARG(IInternetHostSecurityManager, &pihsmTemp));
        pihsm= pihsmTemp;
    }

    hr = ZoneCheckHost(pihsm, dwUrlAction, dwFlags); 

    if (S_FALSE == hr)
        hr = E_ACCESSDENIED;    // The caller needs to soften the hr to S_OK if it's concerned for script.

    if (phr)
        *phr = hr;

    ATOMICRELEASE(pihsmTemp);
    return ((S_OK == hr) ? TRUE : FALSE);
}


HRESULT CAutomationSecurity::MakeObjectSafe(IN IUnknown ** ppunk)
{
    HRESULT hr;

    // See if the host is always safe.
    if (!IsSafeHost(&hr))
    {
        // It isn't, so let's ask the control if it's
        // going to be safe.
        hr = MakeSafeForScripting(ppunk);
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\caggunk.cpp ===
#include "stock.h"
#pragma hdrstop

#include "caggunk.h"


ULONG CAggregatedUnknown::AddRef()
{
    return _punkAgg->AddRef();
}

ULONG CAggregatedUnknown::Release()
{
    return _punkAgg->Release();
}


HRESULT CAggregatedUnknown::QueryInterface(REFIID riid, void **ppvObj)
{
    return _punkAgg->QueryInterface(riid, ppvObj);
}


HRESULT CAggregatedUnknown::CUnkInner::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown*);
        InterlockedIncrement(&_cRef);
        return S_OK;
    }

    CAggregatedUnknown* pparent = IToClass(CAggregatedUnknown, _unkInner, this);
    return pparent->v_InternalQueryInterface(riid, ppvObj);
}

ULONG CAggregatedUnknown::CUnkInner::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}


ULONG CAggregatedUnknown::CUnkInner::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        CAggregatedUnknown* pparent = IToClass(CAggregatedUnknown, _unkInner, this);

        if (!pparent->v_HandleDelete(&_cRef))
        {
            _cRef = 1000; // protect against cached pointers bumping us up then down

            delete pparent;
        }
    }
    return cRef;
}

CAggregatedUnknown::CAggregatedUnknown(IUnknown* punkAgg)
{
    _punkAgg = punkAgg ? punkAgg : &_unkInner;
}

CAggregatedUnknown::~CAggregatedUnknown()
{
}

//
//  Convert our controlling unknown to its canonical IUnknown *without*
//  altering the reference count on the outer object.
//
//  This is critical in order for QueryOuterInterface to work properly.
//
//  Returns NULL if something horrible went wrong.
//
//  OLE Magic:  Since objects are required also to return the canonical
//  IUnknown in response to any QI(IUnknown), it follows that the canonical
//  IUnknown remains valid so long as there are any outstanding references
//  to the object.  In other words, you can Release() the canonical IUnknown
//  and the pointer remains valid so long as you keep the object alive by
//  other means.
//
//  Believe it or not, this is a feature.  It's in the book!
//
IUnknown *CAggregatedUnknown::_GetCanonicalOuter(void)
{
    IUnknown *punkAggCanon;
    HRESULT hres = _punkAgg->QueryInterface(IID_IUnknown, (void **)&punkAggCanon);
    if (SUCCEEDED(hres)) 
    {
        punkAggCanon->Release(); // see "OLE Magic" comment above
        return punkAggCanon;
    } 
    else 
    {
        // The outer object is most likely some other shell component,
        // so let's ASSERT so whoever owns the outer component will fix it.
        ASSERT(!"The outer object's implementation of QI(IUnknown) is broken.");
        return NULL;
    }
}

void CAggregatedUnknown::_ReleaseOuterInterface(IUnknown** ppunk)
{
    ASSERT(IS_VALID_CODE_PTR(_punkAgg, IUnknown));

    IUnknown *punkAggCanon = _GetCanonicalOuter(); // non-refcounted pointer

    //
    //  SHReleaseOuterInterface can handle punkAggCanon == NULL
    //
    SHReleaseOuterInterface(punkAggCanon, ppunk);
}

HRESULT CAggregatedUnknown::_QueryOuterInterface(REFIID riid, void ** ppvOut)
{
    IUnknown *punkAggCanon = _GetCanonicalOuter(); // non-refcounted pointer
    //
    //  SHQueryOuterInterface can handle punkAggCanon == NULL.
    //
    return SHQueryOuterInterface(punkAggCanon, riid, ppvOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\crst.cpp ===
#include "stock.h"
#pragma hdrstop

#include "dbutil.h"

///////
// Critical section helper stuff
//
#ifdef DEBUG
UINT g_CriticalSectionCount = 0;
DWORD g_CriticalSectionOwner = 0;
#ifdef STACKBACKTRACE
DBstkback g_CriticalSectionLastCall[4] = { 0 };
#endif


void Dll_EnterCriticalSection(CRITICAL_SECTION * pcsDll)
{
#ifdef STACKBACKTRACE
    int var0;       // *must* be 1st on frame
#endif

    EnterCriticalSection(pcsDll);
    if (g_CriticalSectionCount++ == 0)
    {
        g_CriticalSectionOwner = GetCurrentThreadId();
#ifdef STACKBACKTRACE
        int fp = (int) (1 + (int *)&var0);
        DBGetStackBack(&fp, g_CriticalSectionLastCall, ARRAYSIZE(g_CriticalSectionLastCall));
#endif
    }
}

void Dll_LeaveCriticalSection(CRITICAL_SECTION * pcsDll)
{
    if (--g_CriticalSectionCount == 0)
        g_CriticalSectionOwner = 0;
    LeaveCriticalSection(pcsDll);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\cowsite.cpp ===
#include "stock.h"
#pragma hdrstop

#include "cowsite.h"

HRESULT CObjectWithSite::SetSite(IUnknown *punkSite)
{
    IUnknown_Set(&_punkSite, punkSite);
    return S_OK;
}

HRESULT CObjectWithSite::GetSite(REFIID riid, void **ppvSite)
{
    if (_punkSite)
        return _punkSite->QueryInterface(riid, ppvSite);

    *ppvSite = NULL;
    return E_FAIL;
}

HRESULT CSafeServiceSite::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CSafeServiceSite, IServiceProvider),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CSafeServiceSite::AddRef()
{ 
    return InterlockedIncrement(&_cRef); 
}

ULONG CSafeServiceSite::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CSafeServiceSite::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (_psp)
        return _psp->QueryService(guidService, riid, ppvObj);

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

HRESULT CSafeServiceSite::SetProviderWeakRef(IServiceProvider *psp)
{
    _psp = psp;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\cnctnpt.cpp ===
//
//  CConnectionPoint
//
//  Common implementation for CConnectionPoint.
//

//
//  Since EnumConnections is called so much, we have a custom
//  enumerator for it which is faster than CStandardEnum and which
//  performs fewer memory allocations.
//

#include "stock.h"
#pragma hdrstop

#include <olectl.h>
#include "ieguidp.h"
#include "cnctnpt.h"

class CConnectionPointEnum : public IEnumConnections
{
public:
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IEnumConnections methods
    //
    STDMETHOD(Next)(ULONG ccd, LPCONNECTDATA rgcd, ULONG *pcdFetched);
    STDMETHOD(Skip)(ULONG ccd) { return Next(ccd, NULL, NULL); }
    STDMETHOD(Reset)(void) { m_iPos = 0; return S_OK; }
    STDMETHOD(Clone)(IEnumConnections **ppecOut);

    friend HRESULT CConnectionPointEnum_Create(CConnectionPoint *pcp, int iPos, IEnumConnections **pecOut);

private:
    CConnectionPointEnum(CConnectionPoint *pcp, int iPos)
    : m_cRef(1), m_pcp(pcp), m_iPos(iPos) { m_pcp->AddRef(); }

    ~CConnectionPointEnum() { m_pcp->Release(); }

    int m_cRef;                         // refcount
    CConnectionPoint *m_pcp;            // my dad
    int m_iPos;                         // enumeration state
};


//
//  When we need to grow the sink array, we grow by this many.
//
#define GROWTH      8

//
//  OLE says that zero is never a valid cookie, so our cookies are
//  the array index biased by unity.
//
#define COOKIEFROMINDEX(i)      ((i) + 1)
#define INDEXFROMCOOKIE(dw)     ((dw) - 1)


//
//  LocalReAllocHelp behaves like IMalloc::Realloc, which
//  is slightly different from LocalRealloc.
//
//  IMalloc::Realloc(NULL, 0) = return NULL
//  IMalloc::Realloc(pv, 0) = IMalloc::Free(pv)
//  IMalloc::Realloc(NULL, cb) = IMalloc::Alloc(cb)
//  IMalloc::Realloc(pv, cb) = LocalRealloc()
//
void *LocalReAllocHelp(void *pv, ULONG cb)
{
    if (cb == 0)
    {
        if (pv)
        {
            LocalFree(pv);
        }
        return NULL;
    }
    else if (pv == NULL)
    {
        return LocalAlloc(LPTR, cb);
    }
    else
    {
        return LocalReAlloc(pv, cb, LMEM_MOVEABLE|LMEM_ZEROINIT);
    }
}

CConnectionPoint::~CConnectionPoint ()
{
    // clean up some memory stuff
    UnadviseAll();
    if (m_rgSinks)
        LocalFree(m_rgSinks);
}


HRESULT CConnectionPoint::UnadviseAll(void)
{
    if (m_rgSinks)
    {
        int x;

        for (x = 0; x < m_cSinksAlloc; x++)
        {
            ATOMICRELEASE(m_rgSinks[x]);
        }
    }

    return S_OK;
}

//
//  For backwards-compatibility with IE4, our superclass is
//  CIE4ConnectionPoint.
//
STDMETHODIMP CConnectionPoint::QueryInterface(REFIID riid, void **ppvObjOut)
{
    if (IsEqualIID(riid, IID_IConnectionPoint) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObjOut = SAFECAST(this, IConnectionPoint *);
        AddRef();
        return S_OK;
    }

    *ppvObjOut = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP CConnectionPoint::GetConnectionInterface(IID *piid)
{
    *piid = *m_piid;

    return S_OK;
}

STDMETHODIMP CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer **ppCPC)
{
    return m_punk->QueryInterface(IID_PPV_ARG(IConnectionPointContainer, ppCPC));
}

STDMETHODIMP CConnectionPoint::Advise(IUnknown *pUnk,DWORD *pdwCookie)
{
    HRESULT    hr;
    IUnknown **rgUnkNew;
    IUnknown  *punkTgt;
    int        i = 0;

    if (!pdwCookie)
        return E_POINTER;

    *pdwCookie = 0;

    // first, make sure everybody's got what they thinks they got

    hr = pUnk->QueryInterface(*m_piid, (void **)&punkTgt);
    if (SUCCEEDED(hr))
    {
#ifdef DEBUG
        //
        //  If we are not an IPropertyNotifySink, then we had better
        //  be derived from IDispatch.  Try to confirm.
        //
        if (m_piid != &IID_IPropertyNotifySink)
        {
            IDispatch *pdisp;
            if (SUCCEEDED(pUnk->QueryInterface(IID_PPV_ARG(IDispatch, &pdisp))))
            {
                pdisp->Release();
            }
            else
            {
                AssertMsg(0, TEXT("CConnectionPoint: IID %08x not derived from IDispatch"), m_piid->Data1);
            }
        }
#endif
    }
    else
    {
        if (m_piid != &IID_IPropertyNotifySink)
        {
            // This is against spec, but raymondc is guessing that this is done
            // for compatibility with VB or some other scripting language that
            // talks IDispatch but not necessarily the IDispatch-derived
            // thingie that we officially speak.  Since we really source
            // merely IDispatch::Invoke, we can satisfactorily accept any
            // IDispatch as a sink.
            hr = pUnk->QueryInterface(IID_IDispatch, (void **)&punkTgt);
        }
    }

    if (SUCCEEDED(hr))
    {

        // we no longer optimize the case where there is only one sink
        // because it's rarely the case any more.

        //
        //  If the table is full, then grow it.
        //
        if (m_cSinks >= m_cSinksAlloc)
        {
            //  LocalReAllocHelp is so smart.  If you realloc from NULL, it
            //  means Alloc.  What this means for us?  No special cases!

            rgUnkNew = (IUnknown **)LocalReAllocHelp(m_rgSinks, (m_cSinksAlloc + GROWTH) * sizeof(IUnknown *));
            if (!rgUnkNew)
            {
                punkTgt->Release();
                // GetLastError();
                return E_OUTOFMEMORY;
            }
            m_rgSinks = rgUnkNew;

            //
            //  OLE does not guarantee that the new memory is zero-initialized.
            //
            ZeroMemory(&m_rgSinks[m_cSinksAlloc], GROWTH * sizeof(IUnknown *));

            m_cSinksAlloc += GROWTH;
        }

        //
        //  Look for an empty slot.  There has to be one since we grew the
        //  table if we were full.
        //
        for (i = 0; m_rgSinks[i]; i++) {
            ASSERT(i < m_cSinksAlloc);
        }

        ASSERT(m_rgSinks[i] == NULL);   // Should've found a free slot
        m_rgSinks[i] = punkTgt;

        *pdwCookie = COOKIEFROMINDEX(i);
        m_cSinks++;

        // notify our owner that someone is connecting to us --
        // they may want to hook something up at the last minute
        //
        IConnectionPointCB* pcb;
        if (SUCCEEDED(m_punk->QueryInterface(IID_PPV_ARG(IConnectionPointCB, &pcb))))
        {
            pcb->OnAdvise(*m_piid, m_cSinks, *pdwCookie);
            pcb->Release();
        }
    }
    else
    {
        hr = CONNECT_E_CANNOTCONNECT;
    }

    return hr;
}

STDMETHODIMP CConnectionPoint::Unadvise(DWORD dwCookie)
{
    if (!dwCookie)
        return S_OK;

    int x = INDEXFROMCOOKIE(dwCookie);

    // Validate the cookie.
    if (x >= m_cSinksAlloc || m_rgSinks[x] == NULL)
        return CONNECT_E_NOCONNECTION;

    // notify our owner that someone is disconnecting from us --
    // they may want to clean up from the OnAdvise call
    // Perform the callback while the sink is still alive, in case
    // the callback wants to do some last-minute communication.
    //
    IConnectionPointCB* pcb;
    if (SUCCEEDED(m_punk->QueryInterface(IID_PPV_ARG(IConnectionPointCB, &pcb))))
    {
        pcb->OnUnadvise(*m_piid, m_cSinks - 1, dwCookie);
        pcb->Release();
    }

    // Free up the slot.  We cannot relocate any elements because that
    // would mess up the outstanding cookies.
    ATOMICRELEASE(m_rgSinks[x]);
    m_cSinks--;

    // Don't free the memory on the loss of the last sink; a new one
    // will probably show up soon.

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CConnectionPoint::EnumConnections
//=--------------------------------------------------------------------------=
// enumerates all current connections
//
// Paramters:
//    IEnumConnections ** - [out] new enumerator object
//
// Output:
//    HRESULT
//
// NOtes:
STDMETHODIMP CConnectionPoint::EnumConnections(IEnumConnections **ppEnumOut)
{
    return CConnectionPointEnum_Create(this, 0, ppEnumOut);
}

//
// CConnectionPoint::DoInvokeIE4
//
// Calls all sinks' IDispatch::Invoke() with Cancel semantics.
HRESULT CConnectionPoint::DoInvokeIE4(LPBOOL pf, LPVOID *ppv, DISPID dispid, DISPPARAMS *pdispparams)
{
    return IConnectionPoint_InvokeWithCancel(this->CastToIConnectionPoint(),
                                    dispid, pdispparams, pf, ppv);
}

//
//  CConnectionPointEnum
//

HRESULT CConnectionPointEnum_Create(CConnectionPoint *pcp, int iPos, IEnumConnections **ppecOut)
{
    *ppecOut = new CConnectionPointEnum(pcp, iPos);
    return *ppecOut ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CConnectionPointEnum::QueryInterface(REFIID riid, void **ppvObjOut)
{
    if (IsEqualIID(riid, IID_IEnumConnections) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObjOut = (IUnknown *)this;
        AddRef();
        return S_OK;
    }

    *ppvObjOut = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CConnectionPointEnum::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CConnectionPointEnum::Release()
{
    ULONG cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return cRef;
}

//
//  Next also doubles as Skip.  If you pass a NULL output buffer, then
//  nothing gets copied (i.e., you're a Skip).
//
STDMETHODIMP CConnectionPointEnum::Next(ULONG ccd, LPCONNECTDATA rgcd, ULONG *pcdFetched)
{
    ULONG ccdFetched = 0;

    while (ccdFetched < ccd)
    {
        //
        //  Look for the next sink or the end of the array
        //
        while (m_iPos < m_pcp->m_cSinksAlloc && m_pcp->m_rgSinks[m_iPos] == NULL)
        {
            m_iPos++;
        }

        if (m_iPos >= m_pcp->m_cSinksAlloc)
            break;

        if (rgcd)
        {
            //
            //  Copy it to the output buffer
            //
            rgcd->pUnk = m_pcp->m_rgSinks[m_iPos];
            rgcd->dwCookie = COOKIEFROMINDEX(m_iPos);
            rgcd->pUnk->AddRef();
            rgcd++;
        }
        m_iPos++;
        ccdFetched++;
    }

    if (pcdFetched)
        *pcdFetched = ccdFetched;

    return (ccdFetched < ccd) ? S_FALSE : S_OK;
}

//
//  Our clone enumerates the same CConnectionPoint from the same position.
//
STDMETHODIMP CConnectionPointEnum::Clone(IEnumConnections **ppecOut)
{
    return CConnectionPointEnum_Create(m_pcp, m_iPos, ppecOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\cobjsafe.cpp ===
#include "stock.h"
#pragma hdrstop

#include <comcat.h>
#include <hliface.h>
#include <mshtml.h>
#include <objsafe.h>
#include <perhist.h>
#include "cobjsafe.h"

// a default isafetyobject that we generally would use...  marks 
// deals with IDispatch 


HRESULT CObjectSafety::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
    if (IsEqualIID(riid, IID_IDispatch))
    {
        if (pdwSupportedOptions)
            *pdwSupportedOptions = (INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA);

        *pdwEnabledOptions = _dwSafetyOptions;
    }
    else
    {
        ::DefaultGetSafetyOptions(riid, pdwSupportedOptions, pdwEnabledOptions);
    }

    return S_OK;
}


HRESULT CObjectSafety::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
    if (dwOptionSetMask & ~(INTERFACESAFE_FOR_UNTRUSTED_CALLER |
                            INTERFACESAFE_FOR_UNTRUSTED_DATA))
    {
        return E_INVALIDARG;
    }

    if (IsEqualIID(riid, IID_IDispatch))
    {
        _dwSafetyOptions = (_dwSafetyOptions & ~dwOptionSetMask) |
                           (dwEnabledOptions & dwOptionSetMask);
        return S_OK;
    }
    else
    {
        return ::DefaultSetSafetyOptions(riid, dwOptionSetMask, dwEnabledOptions);
    }
}



// *** IObjectSafety
//
// A couple static functions called by sitemap (and webbrowser).
// These are static so anyone else in this dll who has an OC
// that's always safe can just call them.
//
// These functions say we are safe for these three interfaces we implement
//  IID_IDispatch
//  IID_IPersistStream
//  IID_IPersistPropertyBag
//
// The WebBrowser OC handles IDispatch differently.
//
HRESULT DefaultGetSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
    *pdwSupportedOptions = 0;
    *pdwEnabledOptions = 0;

    if (IsEqualIID(riid, IID_IDispatch) ||
        IsEqualIID(riid, IID_IPersistStream) ||
        IsEqualIID(riid, IID_IPersistStreamInit) ||
        IsEqualIID(riid, IID_IPersistPropertyBag) ||
        IsEqualIID(riid, IID_IPersistHistory))
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;
        *pdwEnabledOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;
    }

    return S_OK;
}

HRESULT DefaultSetSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
    if (dwOptionSetMask & ~(INTERFACESAFE_FOR_UNTRUSTED_CALLER |
                            INTERFACESAFE_FOR_UNTRUSTED_DATA))
    {
        return E_INVALIDARG;
    }

    if (IsEqualIID(riid, IID_IDispatch) ||
        IsEqualIID(riid, IID_IPersistStream) ||
        IsEqualIID(riid, IID_IPersistStreamInit) ||
        IsEqualIID(riid, IID_IPersistHistory) ||
        IsEqualIID(riid, IID_IPersistPropertyBag))
    {
        return S_OK;
    }

    return E_FAIL;
}


// When CWebBrowserOC is in the safe for scripting mode, we can't give out
// anyone else's IDispatch that is not also safe for scripting.
// This function encapsulates the basic functionality needed by both
// MakeSafeScripting and MakeSafeForInitializing (which we don't use)
BOOL MakeSafeFor(
IUnknown *punk,                 // object to test for safety
REFCATID catid,                 // category of safety
REFIID riid,                    // interface on which safety is desired
DWORD dwXSetMask,               // options to set
DWORD dwXOptions                // options to make safe for
                                    // (either INTERFACESAFE_FOR_UNTRUSTED_CALLER or
                                    //  INTERFACESAFE_FOR_UNTRUSTED_DATA)
)
{
    HRESULT hres;

    // first try IObjectSafety
    IObjectSafety *posafe;
    if (SUCCEEDED(punk->QueryInterface(IID_IObjectSafety, (LPVOID*) &posafe)))
    {
        hres = posafe->SetInterfaceSafetyOptions(riid, dwXSetMask, dwXOptions);
        posafe->Release();

        if (SUCCEEDED(hres))
            return TRUE;
    }

    // check the registry for "safe for scripting" component category

    // we need the classid -- get it thru IPersist
    CLSID clsid;
    IPersist *ppersist;
    hres = punk->QueryInterface(IID_IPersist, (LPVOID*) &ppersist);
    if (SUCCEEDED(hres))
    {
        hres = ppersist->GetClassID(&clsid);
        ppersist->Release();
    }
    if (FAILED(hres))
    {
        // trace from shdocvw, was TF_SHDCONTROL
        TraceMsg(TF_WARNING, "MakeSafeForScripting - object doesn't have IPersist!");
        return FALSE;
    }

    // Create the category manager
    ICatInformation *pcatinfo;
    hres = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
                            NULL, CLSCTX_INPROC_SERVER,
                            IID_ICatInformation, (LPVOID*) &pcatinfo);
    if (FAILED(hres))
        return FALSE;

    // Ask if the object belongs to the specified category
    CATID rgcatid[1];
    rgcatid[0] = catid;

    hres = pcatinfo->IsClassOfCategories(clsid, 1, rgcatid, 0, NULL);
    pcatinfo->Release();

    return (hres==S_OK) ? TRUE : FALSE;;	
}

HRESULT MakeSafeForScripting(IUnknown** ppDisp)
{
    HRESULT hres = S_OK;

    if (!MakeSafeFor(*ppDisp, CATID_SafeForScripting, IID_IDispatch,
                       INTERFACESAFE_FOR_UNTRUSTED_CALLER,
                       INTERFACESAFE_FOR_UNTRUSTED_CALLER))
    {
        // trace from shdocvw, was TF_SHDCONTROL
        TraceMsg(TF_WARNING, "MakeSafeForScripting - IDispatch not safe");

        (*ppDisp)->Release();
        *ppDisp = NULL;
        hres = E_FAIL;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\cstrinout.cpp ===
#include "stock.h"
#pragma hdrstop

#include "cstrinout.h"

//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void
CConvertStr::Free()
{
    if (_pstr != _ach && HIWORD64(_pstr) != 0 && !IsAtom())
    {
        delete [] _pstr;
    }

    _pstr = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void
CConvertStrW::Free()
{
    if (_pwstr != _awch && HIWORD64(_pwstr) != 0)
    {
        delete [] _pwstr;
    }

    _pwstr = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::Init
//
//  Synopsis:   Converts a LPSTR function argument to a LPWSTR.
//
//  Arguments:  [pstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD64(pwstr) == 0).
//
//              [cch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

void
CStrInW::Init(LPCSTR pstr, int cch)
{
    int cchBufReq;

    _cwchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD64(pstr) == 0)
    {
        _pwstr = (LPWSTR) pstr;
        return;
    }

    ASSERT(cch == -1 || cch > 0);

    //
    // Convert string to preallocated buffer, and return if successful.
    //
    // Since the passed in buffer may not be null terminated, we have
    // a problem if cch==ARRAYSIZE(_awch), because MultiByteToWideChar
    // will succeed, and we won't be able to null terminate the string!
    // Decrease our buffer by one for this case.
    //
    _cwchLen = MultiByteToWideChar(
            CP_ACP, 0, pstr, cch, _awch, ARRAYSIZE(_awch)-1);

    if (_cwchLen > 0)
    {
        // Some callers don't NULL terminate.
        //
        // We could check "if (-1 != cch)" before doing this,
        // but always doing the null is less code.
        //
        _awch[_cwchLen] = 0;

        if (0 == _awch[_cwchLen-1]) // account for terminator
            _cwchLen--;

        _pwstr = _awch;
        return;
    }

    //
    // Alloc space on heap for buffer.
    //

    cchBufReq = MultiByteToWideChar( CP_ACP, 0, pstr, cch, NULL, 0 );

    // Again, leave room for null termination
    cchBufReq++;

    ASSERT(cchBufReq > 0);
    _pwstr = new WCHAR[cchBufReq];
    if (!_pwstr)
    {
        // On failure, the argument will point to the empty string.
        _cwchLen = 0;
        _awch[0] = 0;
        _pwstr = _awch;
        return;
    }

    ASSERT(HIWORD64(_pwstr));
    _cwchLen = MultiByteToWideChar(
            CP_ACP, 0, pstr, cch, _pwstr, cchBufReq );

#if DBG == 1 /* { */
    if (0 == _cwchLen)
    {
        int errcode = GetLastError();
        ASSERT(0 && "MultiByteToWideChar failed in unicode wrapper.");
    }
#endif /* } */

    // Again, make sure we're always null terminated
    ASSERT(_cwchLen < cchBufReq);
    _pwstr[_cwchLen] = 0;

    if (0 == _pwstr[_cwchLen-1]) // account for terminator
        _cwchLen--;

}


//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Inits the class.
//
//  NOTE:       Don't inline this function or you'll increase code size
//              by pushing -1 on the stack for each call.
//
//----------------------------------------------------------------------------

CStrIn::CStrIn(LPCWSTR pwstr) : CConvertStr(CP_ACP)
{
    Init(pwstr, -1);
}


CStrIn::CStrIn(UINT uCP, LPCWSTR pwstr) : CConvertStr(uCP)
{
    Init(pwstr, -1);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::Init
//
//  Synopsis:   Converts a LPWSTR function argument to a LPSTR.
//
//  Arguments:  [pwstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD(pwstr) == 0).
//
//              [cwch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//  Note:       We ignore AreFileApisANSI() and always use CP_ACP.
//              The reason is that nobody uses SetFileApisToOEM() except
//              console apps, and once you set file APIs to OEM, you
//              cannot call shell/user/gdi APIs, since they assume ANSI
//              regardless of the FileApis setting.  So you end up in
//              this horrible messy state where the filename APIs interpret
//              the strings as OEM but SHELL32 interprets the strings
//              as ANSI and you end up with a big mess.
//
//----------------------------------------------------------------------------

void
CStrIn::Init(LPCWSTR pwstr, int cwch)
{
    int cchBufReq;

#if DBG == 1 /* { */
    int errcode;
#endif /* } */

    _cchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD64(pwstr) == 0 || IsAtom())
    {
        _pstr = (LPSTR) pwstr;
        return;
    }

    if ( cwch == 0 )
    {
        *_ach = '\0';
        _pstr = _ach;
        return;
    }

    //
    // Convert string to preallocated buffer, and return if successful.
    //

    _cchLen = WideCharToMultiByte(
            _uCP, 0, pwstr, cwch, _ach, ARRAYSIZE(_ach)-1, NULL, NULL);

    if (_cchLen > 0)
    {
        // This is DBCS safe since byte before _cchLen is last character
        _ach[_cchLen] = 0;
        // this may not be safe if the last character
        // was a multibyte character...
        if (_ach[_cchLen-1]==0)
            _cchLen--;          // account for terminator
        _pstr = _ach;
        return;
    }


    cchBufReq = WideCharToMultiByte(
            CP_ACP, 0, pwstr, cwch, NULL, 0, NULL, NULL);

    cchBufReq++;

    ASSERT(cchBufReq > 0);
    _pstr = new char[cchBufReq];
    if (!_pstr)
    {
        // On failure, the argument will point to the empty string.
        _cchLen = 0;
        _ach[0] = 0;
        _pstr = _ach;
        return;
    }

    ASSERT(HIWORD64(_pstr));
    _cchLen = WideCharToMultiByte(
            _uCP, 0, pwstr, cwch, _pstr, cchBufReq, NULL, NULL);
#if DBG == 1 /* { */
    if (_cchLen < 0)
    {
        errcode = GetLastError();
        ASSERT(0 && "WideCharToMultiByte failed in unicode wrapper.");
    }
#endif /* } */

    // Again, make sure we're always null terminated
    ASSERT(_cchLen < cchBufReq);
    _pstr[_cchLen] = 0;
    if (0 == _pstr[_cchLen-1]) // account for terminator
        _cchLen--;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrInMulti::CStrInMulti
//
//  Synopsis:   Converts mulitple LPWSTRs to a multiple LPSTRs.
//
//  Arguments:  [pwstr] -- The strings to convert.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

CStrInMulti::CStrInMulti(LPCWSTR pwstr)
{
    LPCWSTR pwstrT;

    // We don't handle atoms because we don't need to.
    ASSERT(HIWORD64(pwstr));

    //
    // Count number of characters to convert.
    //

    pwstrT = pwstr;
    if (pwstr)
    {
        do {
            while (*pwstrT++)
                ;

        } while (*pwstrT++);
    }

    Init(pwstr, (int)(pwstrT - pwstr));
}


//+---------------------------------------------------------------------------
//
//  Member:     CPPFIn::CPPFIn
//
//  Synopsis:   Inits the class.  Truncates the filename to MAX_PATH
//              so Win9x DBCS won't fault.  Win9x SBCS silently truncates
//              to MAX_PATH, so we're bug-for-bug compatible.
//
//----------------------------------------------------------------------------

CPPFIn::CPPFIn(LPCWSTR pwstr)
{
    SHUnicodeToAnsi(pwstr, _ach, ARRAYSIZE(_ach));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::CStrOut
//
//  Synopsis:   Allocates enough space for an out buffer.
//
//  Arguments:  [pwstr]   -- The Unicode buffer to convert to when destroyed.
//                              May be NULL.
//
//              [cwchBuf] -- The size of the buffer in characters.
//
//  Modifies:   [this].
//
//----------------------------------------------------------------------------

CStrOut::CStrOut(LPWSTR pwstr, int cwchBuf) : CConvertStr(CP_ACP)
{
    Init(pwstr, cwchBuf);
}

CStrOut::CStrOut(UINT uCP, LPWSTR pwstr, int cwchBuf) : CConvertStr(uCP)
{
    Init(pwstr, cwchBuf);
}

void
CStrOut::Init(LPWSTR pwstr, int cwchBuf) 
{
    ASSERT(cwchBuf >= 0);

    _pwstr = pwstr;
    _cwchBuf = cwchBuf;

    if (!pwstr)
    {
        // Force cwchBuf = 0 because many callers (in particular, registry
        // munging functions) pass garbage as the length because they know
        // it will be ignored.
        _cwchBuf = 0;
        _pstr = NULL;
        return;
    }

    ASSERT(HIWORD64(pwstr));

    // Initialize buffer in case Windows API returns an error.
    _ach[0] = 0;

    // Use preallocated buffer if big enough.
    if (cwchBuf * 2 <= ARRAYSIZE(_ach))
    {
        _pstr = _ach;
        return;
    }

    // Allocate buffer.
    _pstr = new char[cwchBuf * 2];
    if (!_pstr)
    {
        //
        // On failure, the argument will point to a zero-sized buffer initialized
        // to the empty string.  This should cause the Windows API to fail.
        //

        ASSERT(cwchBuf > 0);
        _pwstr[0] = 0;
        _cwchBuf = 0;
        _pstr = _ach;
        return;
    }

    ASSERT(HIWORD64(_pstr));
    _pstr[0] = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::CStrOutW
//
//  Synopsis:   Allocates enough space for an out buffer.
//
//  Arguments:  [pstr]    -- The MBCS buffer to convert to when destroyed.
//                              May be NULL.
//
//              [cchBuf]  -- The size of the buffer in characters.
//
//  Modifies:   [this].
//
//----------------------------------------------------------------------------

CStrOutW::CStrOutW(LPSTR pstr, int cchBuf)
{
    ASSERT(cchBuf >= 0);

    _pstr = pstr;
    _cchBuf = cchBuf;

    if (!pstr)
    {
        // Force cchBuf = 0 because many callers (in particular, registry
        // munging functions) pass garbage as the length because they know
        // it will be ignored.
        _cchBuf = 0;
        _pwstr = NULL;
        return;
    }

    ASSERT(HIWORD64(pstr));

    // Initialize buffer in case Windows API returns an error.
    _awch[0] = 0;

    // Use preallocated buffer if big enough.
    if (cchBuf <= ARRAYSIZE(_awch))
    {
        _pwstr = _awch;
        return;
    }

    // Allocate buffer.
    _pwstr = new WCHAR[cchBuf];
    if (!_pwstr)
    {
        //
        // On failure, the argument will point to a zero-sized buffer initialized
        // to the empty string.  This should cause the Windows API to fail.
        //

        ASSERT(cchBuf > 0);
        _pstr[0] = 0;
        _cchBuf = 0;
        _pwstr = _awch;
        return;
    }

    ASSERT(HIWORD64(_pwstr));
    _pwstr[0] = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::ConvertIncludingNul
//
//  Synopsis:   Converts the buffer from MBCS to Unicode
//
//  Return:     Character count INCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------

int
CStrOut::ConvertIncludingNul()
{
    int cch;

    if (!_pstr)
        return 0;

    cch = SHAnsiToUnicodeCP(_uCP, _pstr, _pwstr, _cwchBuf);

#if DBG == 1 /* { */
    if (cch == 0 && _cwchBuf > 0)
    {
        int errcode = GetLastError();
        ASSERT(0 && "SHAnsiToUnicode failed in unicode wrapper.");
    }
#endif /* } */

    Free();
    return cch;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::ConvertIncludingNul
//
//  Synopsis:   Converts the buffer from Unicode to MBCS
//
//  Return:     Character count INCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------

int
CStrOutW::ConvertIncludingNul()
{
    int cch;

    if (!_pwstr)
        return 0;

    cch = SHUnicodeToAnsi(_pwstr, _pstr, _cchBuf);

#if DBG == 1 /* { */
    if (cch == 0 && _cchBuf > 0)
    {
        int errcode = GetLastError();
        ASSERT(0 && "SHUnicodeToAnsi failed in unicode wrapper.");
    }
#endif /* } */

    Free();
    return cch;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::ConvertExcludingNul
//
//  Synopsis:   Converts the buffer from MBCS to Unicode
//
//  Return:     Character count EXCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------

int
CStrOut::ConvertExcludingNul()
{
    int ret = ConvertIncludingNul();
    if (ret > 0)
    {
        ret -= 1;
    }
    return ret;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::~CStrOut
//
//  Synopsis:   Converts the buffer from MBCS to Unicode.
//
//  Note:       Don't inline this function, or you'll increase code size as
//              both ConvertIncludingNul() and CConvertStr::~CConvertStr will be
//              called inline.
//
//----------------------------------------------------------------------------

CStrOut::~CStrOut()
{
    ConvertIncludingNul();
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::~CStrOutW
//
//  Synopsis:   Converts the buffer from Unicode to MBCS.
//
//  Note:       Don't inline this function, or you'll increase code size as
//              both ConvertIncludingNul() and CConvertStr::~CConvertStr will be
//              called inline.
//
//----------------------------------------------------------------------------

CStrOutW::~CStrOutW()
{
    ConvertIncludingNul();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\dka.cpp ===
#include "stock.h"
#pragma hdrstop

#include <shellp.h>
#include <dpa.h>

#define CCH_KEYMAX      64          // DOC: max size of a reg key (under shellex)

//===========================================================================
// DCA stuff - Dynamic CLSID array
// 
//  This is a dynamic array of CLSIDs that you can obtain from 
//  a registry key or add individually.  Use DCA_CreateInstance
//  to actually CoCreateInstance the element.
//
//===========================================================================


#ifdef DECLARE_ONCE

HDCA DCA_Create()
{
    HDSA hdsa = DSA_Create(sizeof(CLSID), 4);
    return (HDCA)hdsa;
}

void DCA_Destroy(HDCA hdca)
{
    DSA_Destroy((HDSA)hdca);
}

int  DCA_GetItemCount(HDCA hdca)
{
    ASSERT(hdca);
    
    return DSA_GetItemCount((HDSA)hdca);
}

const CLSID * DCA_GetItem(HDCA hdca, int i)
{
    ASSERT(hdca);
    
    return (const CLSID *)DSA_GetItemPtr((HDSA)hdca, i);
}


BOOL DCA_AddItem(HDCA hdca, REFCLSID rclsid)
{
    ASSERT(hdca);
    
    int ccls = DCA_GetItemCount(hdca);
    int icls;
    for (icls = 0; icls < ccls; icls++)
    {
        if (IsEqualGUID(rclsid, *DCA_GetItem(hdca,icls))) 
            return FALSE;
    }

    DSA_AppendItem((HDSA)hdca, (LPVOID) &rclsid);
    return TRUE;
}


HRESULT DCA_CreateInstance(HDCA hdca, int iItem, REFIID riid, void ** ppv)
{
    const CLSID * pclsid = DCA_GetItem(hdca, iItem);
    return pclsid ? SHCoCreateInstance(NULL, pclsid, NULL, riid, ppv) : E_INVALIDARG;
}

// _KeyIsRestricted           (davepl 4-20-99)
//
// Checks to see if there is a user policy in place that disables this key,
//
// For example, in the registry:
//
// CLSID_MyComputer
//   +---Shell
//         +---Manage   
//                       (Default)           = "Mana&ge"
//                       SuppressionPolicy   = REST_NOMANAGEMYCOMPUTERVERB
//
// (Where REST_NOMANAGEMYCOMPUTERVERB is the DWORD value of that particular policy)
//                       
BOOL _KeyIsRestricted(HKEY hkey)
{
    DWORD dwidRest;
    DWORD cbdwidRest = sizeof(dwidRest);
    if (S_OK == SHGetValue(hkey, NULL, TEXT("SuppressionPolicy"), NULL, &dwidRest, &cbdwidRest))
        if (SHRestricted( (RESTRICTIONS)dwidRest) )
            return TRUE;

    return FALSE;
}

#endif // DECLARE_ONCE

BOOL _KeyIsRestricted(HKEY hkey);


void DCA_AddItemsFromKey(HDCA hdca, HKEY hkey, LPCTSTR pszSubKey)
{
    HKEY hkEnum;
    if (RegOpenKeyEx(hkey, pszSubKey, 0L, KEY_READ, &hkEnum) == ERROR_SUCCESS)
    {
        TCHAR sz[CCH_KEYMAX];
        for (int i = 0; RegEnumKey(hkEnum, i, sz, ARRAYSIZE(sz)) == ERROR_SUCCESS; i++)
        {
            HKEY hkEach;
            if (RegOpenKeyEx(hkEnum, sz, 0L, KEY_READ, &hkEach) == ERROR_SUCCESS)
            {
                if (!_KeyIsRestricted(hkEach))
                {
                    CLSID clsid;
                    // First, check if the key itself is a CLSID
                    BOOL fAdd = GUIDFromString(sz, &clsid);
                    if (!fAdd)
                    {
                        LONG cb = sizeof(sz);
                        if (RegQueryValue(hkEach, NULL, sz, &cb) == ERROR_SUCCESS)
                        {
                            fAdd = GUIDFromString(sz, &clsid);
                        }
                    }

                    // Add the CLSID if we successfully got the CLSID.
                    if (fAdd)
                    {
                        DCA_AddItem(hdca, clsid);
                    }
                }
                RegCloseKey(hkEach);
            }
            

        }
        RegCloseKey(hkEnum);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\debug.c ===
//
// Debug squirty functions
//
#include "stock.h"
#pragma hdrstop

#include "shellp.h"

#include <platform.h> // LINE_SEPARATOR_STR and friends
#include <winbase.h> // for GetModuleFileNameA
#include <strsafe.h>

#define DM_DEBUG              0

#ifdef          DEBUG

//  --------------------------------------------------------------------------
//  AttachUserModeDebugger
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Attaches a user-mode debugger to the current process if one
//              is not already attached. This allows the ASSERT/RIP/TRACE to
//              be debugged in a user-mode debugger rather than ending up in
//              the kernel debugger which is sometimes limiting.
//
//  History:    2000-08-21  vtan        created
//  --------------------------------------------------------------------------

void    AttachUserModeDebugger (void)

{
    // Win95 does not support IsDebuggerPresent so we must
    // GetProcAddress for it below or we would fail to load.
    // In fact, we punt completely on Win9x
    if (GetVersion() & 0x80000000) return;

    __try
    {
        typedef BOOL (WINAPI *ISDEBUGGERPRESENT)();
        ISDEBUGGERPRESENT _IsDebuggerPresent = (ISDEBUGGERPRESENT)GetProcAddress(GetModuleHandleA("KERNEL32"), "IsDebuggerPresent");
        if (_IsDebuggerPresent && !_IsDebuggerPresent())
        {
            HKEY    hKeyAEDebug;
            TCHAR   szDebugger[MAX_PATH];

            szDebugger[0] = TEXT('\0');

            //  Read HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AEDebug\Debugger

            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                              TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AEDebug"),
                                              0,
                                              KEY_QUERY_VALUE,
                                              &hKeyAEDebug))
            {
                DWORD   dwDebuggerSize;

                dwDebuggerSize = sizeof(szDebugger);
                (LONG)RegQueryValueEx(hKeyAEDebug,
                                      TEXT("Debugger"),
                                      NULL,
                                      NULL,
                                      (LPBYTE)&szDebugger,
                                      &dwDebuggerSize);
                (LONG)RegCloseKey(hKeyAEDebug);
            }

            if (szDebugger[0] != TEXT('\0'))
            {
                static  const TCHAR     s_szDrWatsonImageName[]     =   TEXT("drwtsn32");
                HRESULT hr;
                BOOL fWatson = FALSE;

                TCHAR   szCommandLine[MAX_PATH + 64];

                //  Duplicate the string to szCommandLine and NULL terminate
                //  to compare directly for "drwtsn32" which we do NOT want
                //  attached to the process.

                hr = StringCchCopy(szCommandLine, ARRAYSIZE(szCommandLine), szDebugger);
                if (SUCCEEDED(hr))
                {
                    szCommandLine[ARRAYSIZE(s_szDrWatsonImageName)-1] = TEXT('\0');

                    if (lstrcmpi(szCommandLine, s_szDrWatsonImageName) == 0)
                    {
                        fWatson = TRUE;
                    }
                }

                if (!fWatson)
                {
                    HANDLE                  hEvent;
                    SECURITY_ATTRIBUTES     securityAttributes;

                    //  Create an unnamed event which is passed to the debugger as an
                    //  inherited handle. It will signal this handle to release this
                    //  thread when the debugger is completely attached to the process.

                    securityAttributes.nLength = sizeof(securityAttributes);
                    securityAttributes.lpSecurityDescriptor = NULL;
                    securityAttributes.bInheritHandle = TRUE;
                    hEvent = CreateEvent(&securityAttributes, TRUE, FALSE, NULL);
                    if (hEvent != NULL)
                    {
                        STARTUPINFO             startupInfo;
                        PROCESS_INFORMATION     processInformation;

                        ZeroMemory(&startupInfo, sizeof(startupInfo));
                        ZeroMemory(&processInformation, sizeof(processInformation));
                        startupInfo.cb = sizeof(startupInfo);

                        //  Now formulate the command line to pass to the debugger.
                        //  It's in the form "cdb -p %ld -e %ld -gGx".

                        hr = StringCchPrintf(szCommandLine, ARRAYSIZE(szCommandLine), szDebugger, GetCurrentProcessId(), hEvent);   // ok to truncate - devs can figure it out
                        if (SUCCEEDED(hr))
                        {
                            if (CreateProcess(NULL,
                                              szCommandLine,
                                              NULL,
                                              NULL,
                                              TRUE,
                                              0,
                                              NULL,
                                              NULL,
                                              &startupInfo,
                                              &processInformation) != FALSE)
                            {

                                //  Now wait for the event. Give a generous 10 seconds
                                //  for the debugger to signal this event. If the debugger
                                //  doesn't then continue execution. Close all handles.

                                (DWORD)WaitForSingleObject(hEvent, INFINITE);
                                (BOOL)CloseHandle(processInformation.hProcess);
                                (BOOL)CloseHandle(processInformation.hThread);
                            }
                        }
                        (BOOL)CloseHandle(hEvent);
                    }
                }
                else
                {
                    OutputDebugStringA("drwtsn32 detected in AEDebug. Dropping to KD\r\n");
                }
            }
        }
    }
    __except (EXCEPTION_CONTINUE_EXECUTION)
    {
    }
}

#endif  /*  DEBUG   */

// UnicodeFromAnsi is used by shlwapi so it should not be inside the ifdef debug
//
/*----------------------------------------------------------
Purpose: This function converts a multi-byte string to a
         wide-char string.

         If pszBuf is non-NULL and the converted string can fit in
         pszBuf, then *ppszWide will point to the given buffer.
         Otherwise, this function will allocate a buffer that can
         hold the converted string.

         If pszAnsi is NULL, then *ppszWide will be freed.  Note
         that pszBuf must be the same pointer between the call
         that converted the string and the call that frees the
         string.

Returns: TRUE
         FALSE (if out of memory)

*/
BOOL
UnicodeFromAnsi(
    LPWSTR * ppwszWide,
    LPCSTR pszAnsi,           // NULL to clean up
    LPWSTR pwszBuf,
    int cchBuf)
    {
    BOOL bRet;

    // Convert the string?
    if (pszAnsi)
        {
        // Yes; determine the converted string length
        int cch;
        LPWSTR pwsz;
        int cchAnsi = lstrlenA(pszAnsi)+1;

        cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, NULL, 0);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pwszBuf)
            {
            // Yes; allocate space
            cchBuf = cch + 1;
            pwsz = (LPWSTR)LocalAlloc(LPTR, CbFromCchW(cchBuf));
            }
        else
            {
            // No; use the provided buffer
            pwsz = pwszBuf;
            }

        if (pwsz)
            {
            // Convert the string
            cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, pwsz, cchBuf);
            bRet = (0 < cch);
            }
        else
            {
            bRet = FALSE;
            }

        *ppwszWide = pwsz;
        }
    else
        {
        // No; was this buffer allocated?
        if (*ppwszWide && pwszBuf != *ppwszWide)
            {
            // Yes; clean up
            LocalFree((HLOCAL)*ppwszWide);
            *ppwszWide = NULL;
            }
        bRet = TRUE;
        }

    return bRet;
    }

#if 0 // nobody seems to use this one any more
/*----------------------------------------------------------
 Purpose: This function converts a wide-char string to a multi-byte
 string.

 If pszBuf is non-NULL and the converted string can fit in
 pszBuf, then *ppszAnsi will point to the given buffer.
 Otherwise, this function will allocate a buffer that can
 hold the converted string.

 If pszWide is NULL, then *ppszAnsi will be freed.  Note
 that pszBuf must be the same pointer between the call
 that converted the string and the call that frees the
 string.

 Returns: TRUE
 FALSE (if out of memory)

 Cond:    --
 */
BOOL
AnsiFromUnicode(
    LPSTR * ppszAnsi,
    LPCWSTR pwszWide,        // NULL to clean up
    LPSTR pszBuf,
    int cchBuf)
{
    BOOL bRet;

    // Convert the string?
    if (pwszWide)
    {
        // Yes; determine the converted string length
        int cch;
        LPSTR psz;

        cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, NULL, 0, NULL, NULL);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pszBuf)
        {
            // Yes; allocate space
            cchBuf = cch + 1;
            psz = (LPSTR)LocalAlloc(LPTR, CbFromCchA(cchBuf));
        }
        else
        {
            // No; use the provided buffer
            ASSERT(pszBuf);
            psz = pszBuf;
        }

        if (psz)
        {
            // Convert the string
            cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, psz, cchBuf, NULL, NULL);
            bRet = (0 < cch);
        }
        else
        {
            bRet = FALSE;
        }

        *ppszAnsi = psz;
    }
    else
    {
        // No; was this buffer allocated?
        if (*ppszAnsi && pszBuf != *ppszAnsi)
        {
            // Yes; clean up
            LocalFree((HLOCAL)*ppszAnsi);
            *ppszAnsi = NULL;
        }
        bRet = TRUE;
    }

    return bRet;
}
#endif // 0


#if defined(DEBUG) || defined(PRODUCT_PROF)
// (c_szCcshellIniFile and c_szCcshellIniSecDebug are declared in debug.h)
extern CHAR const FAR c_szCcshellIniFile[];
extern CHAR const FAR c_szCcshellIniSecDebug[];
HANDLE g_hDebugOutputFile = INVALID_HANDLE_VALUE;


void ShellDebugAppendToDebugFileA(LPCSTR pszOutputString)
{
    if (g_hDebugOutputFile != INVALID_HANDLE_VALUE)
    {
        DWORD cbWrite = lstrlenA(pszOutputString);
        WriteFile(g_hDebugOutputFile, pszOutputString, cbWrite, &cbWrite, NULL);
    }
}

void ShellDebugAppendToDebugFileW(LPCWSTR pszOutputString)
{
    if (g_hDebugOutputFile != INVALID_HANDLE_VALUE)
    {
        char szBuf[500];

        DWORD cbWrite = WideCharToMultiByte(CP_ACP, 0, pszOutputString, -1, szBuf, ARRAYSIZE(szBuf), NULL, NULL);

        WriteFile(g_hDebugOutputFile, szBuf, cbWrite, &cbWrite, NULL);
    }
}

//
// We cannot link to shlwapi, because comctl32 cannot link to shlwapi.
// Duplicate some functions here so unicode stuff can run on Win95 platforms.
//
VOID MyOutputDebugStringWrapW(LPCWSTR lpOutputString)
{
    if (staticIsOS(OS_NT))
    {
        OutputDebugStringW(lpOutputString);
        ShellDebugAppendToDebugFileW(lpOutputString);
    }
    else
    {
        char szBuf[1024+40];

        WideCharToMultiByte(CP_ACP, 0, lpOutputString, -1, szBuf, ARRAYSIZE(szBuf), NULL, NULL);

        OutputDebugStringA(szBuf);
        ShellDebugAppendToDebugFileA(szBuf);
    }
}
#define OutputDebugStringW MyOutputDebugStringWrapW

VOID MyOutputDebugStringWrapA(LPCSTR lpOutputString)
{
    OutputDebugStringA(lpOutputString);
    ShellDebugAppendToDebugFileA(lpOutputString);
}

#define OutputDebugStringA MyOutputDebugStringWrapA

/*----------------------------------------------------------
Purpose: Special verion of atoi.  Supports hexadecimal too.

         If this function returns FALSE, *piRet is set to 0.

Returns: TRUE if the string is a number, or contains a partial number
         FALSE if the string is not a number

Cond:    --
*/
static
BOOL
MyStrToIntExA(
    LPCSTR    pszString,
    DWORD     dwFlags,          // STIF_ bitfield
    LONGLONG FAR * piRet)
    {
    #define IS_DIGIT(ch)    InRange(ch, '0', '9')

    BOOL bRet;
    LONGLONG n;
    BOOL bNeg = FALSE;
    LPCSTR psz;
    LPCSTR pszAdj;

    // Skip leading whitespace
    //
    for (psz = pszString; *psz == ' ' || *psz == '\n' || *psz == '\t'; psz = CharNextA(psz))
        ;

    // Determine possible explicit signage
    //
    if (*psz == '+' || *psz == '-')
        {
        bNeg = (*psz == '+') ? FALSE : TRUE;
        psz++;
        }

    // Or is this hexadecimal?
    //
    pszAdj = CharNextA(psz);
    if ((STIF_SUPPORT_HEX & dwFlags) &&
        *psz == '0' && (*pszAdj == 'x' || *pszAdj == 'X'))
        {
        // Yes

        // (Never allow negative sign with hexadecimal numbers)
        bNeg = FALSE;
        psz = CharNextA(pszAdj);

        pszAdj = psz;

        // Do the conversion
        //
        for (n = 0; ; psz = CharNextA(psz))
            {
            if (IS_DIGIT(*psz))
                n = 0x10 * n + *psz - '0';
            else
                {
                CHAR ch = *psz;
                int n2;

                if (ch >= 'a')
                    ch -= 'a' - 'A';

                n2 = ch - 'A' + 0xA;
                if (n2 >= 0xA && n2 <= 0xF)
                    n = 0x10 * n + n2;
                else
                    break;
                }
            }

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }
    else
        {
        // No
        pszAdj = psz;

        // Do the conversion
        for (n = 0; IS_DIGIT(*psz); psz = CharNextA(psz))
            n = 10 * n + *psz - '0';

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }

    *piRet = bNeg ? -n : n;

    return bRet;
    }

#endif

#ifdef DEBUG

EXTERN_C g_bUseNewLeakDetection = FALSE;

DWORD g_dwDumpFlags     = 0;        // DF_*

#ifdef FULL_DEBUG
ULONGLONG g_qwTraceFlags    = TF_ERROR | TF_WARNING;        // TF_*
DWORD g_dwBreakFlags        = BF_ASSERT | BF_ONERRORMSG;    // BF_*
#else
ULONGLONG g_qwTraceFlags    = TF_ERROR;     // TF_*
DWORD g_dwBreakFlags        = BF_ASSERT;    // BF_*
#endif

DWORD g_dwPrototype     = 0;        
DWORD g_dwFuncTraceFlags = 0;       // FTF_*

// TLS slot used to store depth for CcshellFuncMsg indentation

static DWORD g_tlsStackDepth = TLS_OUT_OF_INDEXES;

// Hack stack depth counter used when g_tlsStackDepth is not available

static DWORD g_dwHackStackDepth = 0;

static char g_szIndentLeader[] = "                                                                                ";

static WCHAR g_wszIndentLeader[] = L"                                                                                ";


static CHAR const FAR c_szNewline[] = LINE_SEPARATOR_STR;   // (Deliberately CHAR)
static WCHAR const FAR c_wszNewline[] = TEXTW(LINE_SEPARATOR_STR);

extern CHAR const FAR c_szTrace[];              // (Deliberately CHAR)
extern CHAR const FAR c_szErrorDbg[];           // (Deliberately CHAR)
extern CHAR const FAR c_szWarningDbg[];         // (Deliberately CHAR)
extern WCHAR const FAR c_wszTrace[];
extern WCHAR const FAR c_wszErrorDbg[]; 
extern WCHAR const FAR c_wszWarningDbg[];

extern const CHAR  FAR c_szAssertMsg[];
extern CHAR const FAR c_szAssertFailed[];
extern const WCHAR  FAR c_wszAssertMsg[];
extern WCHAR const FAR c_wszAssertFailed[];

extern CHAR const FAR c_szRip[];
extern CHAR const FAR c_szRipNoFn[];
extern CHAR const FAR c_szRipMsg[];
extern WCHAR const FAR c_wszRip[];
extern WCHAR const FAR c_wszRipNoFn[];


/*-------------------------------------------------------------------------
Purpose: Adds one of the following prefix strings to pszBuf:
           "t   MODULE  "
           "err MODULE  "
           "wrn MODULE  "

         Returns the count of characters written.
*/
int
SetPrefixStringA(
    OUT LPSTR pszBuf,
    IN  UINT cchBuf,
    IN  ULONGLONG qwFlags)
{
    if (TF_ALWAYS == qwFlags)
        StringCchCopyA(pszBuf, cchBuf, c_szTrace);      // ok to truncate - debug message
    else if (IsFlagSet(qwFlags, TF_WARNING))
        StringCchCopyA(pszBuf, cchBuf, c_szWarningDbg); // ok to truncate - debug message
    else if (IsFlagSet(qwFlags, TF_ERROR))
        StringCchCopyA(pszBuf, cchBuf, c_szErrorDbg);   // ok to truncate - debug message
    else
        StringCchCopyA(pszBuf, cchBuf, c_szTrace);      // ok to truncate - debug message
    return lstrlenA(pszBuf);
}


int
SetPrefixStringW(
    OUT LPWSTR pszBuf,
    IN  UINT cchBuf,
    IN  ULONGLONG  qwFlags)
{
    if (TF_ALWAYS == qwFlags)
        StringCchCopyW(pszBuf, cchBuf, c_wszTrace);     // ok to truncate - debug message
    else if (IsFlagSet(qwFlags, TF_WARNING))
        StringCchCopyW(pszBuf, cchBuf, c_wszWarningDbg);// ok to truncate - debug message
    else if (IsFlagSet(qwFlags, TF_ERROR))
        StringCchCopyW(pszBuf, cchBuf, c_wszErrorDbg);  // ok to truncate - debug message
    else
        StringCchCopyW(pszBuf, cchBuf, c_wszTrace);     // ok to truncate - debug message
    return lstrlenW(pszBuf);
}


static
LPCSTR
_PathFindFileNameA(
    LPCSTR pPath)
{
    LPCSTR pT;

    for (pT = pPath; *pPath; pPath = CharNextA(pPath)) {
        if ((pPath[0] == '\\' || pPath[0] == ':' || pPath[0] == '/')
            && pPath[1] &&  pPath[1] != '\\'  &&   pPath[1] != '/')
            pT = pPath + 1;
    }

    return pT;
}


static
LPCWSTR
_PathFindFileNameW(
    LPCWSTR pPath)
{
    LPCWSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == TEXTW('\\') || pPath[0] == TEXTW(':') || pPath[0] == TEXTW('/'))
            && pPath[1] &&  pPath[1] != TEXTW('\\')  &&   pPath[1] != TEXTW('/'))
            pT = pPath + 1;
    }

    return pT;
}


/*-------------------------------------------------------------------------
Purpose: Returns TRUE if this process is a shell-related process.
*/
BOOL _IsShellProcess()
{
    CHAR szModuleName[MAX_PATH];
    
    if (GetModuleFileNameA(NULL, szModuleName, sizeof(CHAR) * MAX_PATH) > 0 )
    {                      
        if (StrStrIA(szModuleName, "explorer.exe") || 
            StrStrIA(szModuleName, "iexplore.exe") ||
            StrStrIA(szModuleName, "rundll32.exe") || 
            StrStrIA(szModuleName, "mshtmpad.exe"))
        {
            // yes, the exe is a shell one
            return TRUE;
        }
    }

    // not a normal shell executable
    return FALSE;
}


// FEATURE (scotth): Use the Ccshell functions.  _AssertMsg and
// _DebugMsg are obsolete.  They will be removed once all the 
// components don't have TEXT() wrapping their debug strings anymore.


void 
WINCAPI 
_AssertMsgA(
    BOOL f, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        int cch;

        StringCchCopyA(ach, ARRAYSIZE(ach), c_szAssertMsg); // ok to truncate - debug message
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);

        StringCchVPrintfA(&ach[cch], ARRAYSIZE(ach) - cch, pszMsg, vArgs);  // ok to truncate - debug message

        va_end(vArgs);
        OutputDebugStringA(ach);

        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
}

void 
WINCAPI 
_AssertMsgW(
    BOOL f, 
    LPCWSTR pszMsg, ...)
{
    WCHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        int cch;

        StringCchCopyW(ach, ARRAYSIZE(ach), c_wszAssertMsg);    // ok to truncate - debug message
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        StringCchVPrintfW(&ach[cch], ARRAYSIZE(ach) - cch, pszMsg, vArgs);  // ok to truncate - debug message

        va_end(vArgs);
        OutputDebugStringW(ach);

        OutputDebugStringW(c_wszNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
}

void 
_AssertStrLenW(
    LPCWSTR pszStr, 
    int iLen)
{
    if (pszStr && iLen < lstrlenW(pszStr))
    {                                           
        // MSDEV USERS:  This is not the real assert.  Hit 
        //               Shift-F11 to jump back to the caller.
        DEBUG_BREAK;                                                            // ASSERT
    }
}

void 
_AssertStrLenA(
    LPCSTR pszStr, 
    int iLen)
{
    if (pszStr && iLen < lstrlenA(pszStr))
    {                                           
        // MSDEV USERS:  This is not the real assert.  Hit 
        //               Shift-F11 to jump back to the caller.
        DEBUG_BREAK;                                                            // ASSERT
    }
}

void 
WINCAPI 
_DebugMsgA(
    ULONGLONG flag, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[5*MAX_PATH+40];  // Handles 5*largest path + slop for message
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_qwTraceFlags, flag) && flag))
    {
        int cch;

        cch = SetPrefixStringA(ach, ARRAYSIZE(ach), flag);
        va_start(vArgs, pszMsg);

        try
        {
            StringCchVPrintfA(&ach[cch], ARRAYSIZE(ach) - cch, pszMsg, vArgs);  // ok to truncate - debug message
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            OutputDebugString(TEXT("CCSHELL: DebugMsg exception: "));
            OutputDebugStringA(pszMsg);
        }
        __endexcept

        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
}

void 
WINCAPI 
_DebugMsgW(
    ULONGLONG flag, 
    LPCWSTR pszMsg, ...)
{
    WCHAR ach[5*MAX_PATH+40];  // Handles 5*largest path + slop for message
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_qwTraceFlags, flag) && flag))
    {
        int cch;

        SetPrefixStringW(ach, ARRAYSIZE(ach), flag);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        try
        {
            StringCchVPrintfW(&ach[cch], ARRAYSIZE(ach) - cch, pszMsg, vArgs);  // ok to truncate - debug message
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            OutputDebugString(TEXT("CCSHELL: DebugMsg exception: "));
            OutputDebugStringW(pszMsg);
        }
        __endexcept

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                        // ASSERT
        }
    }
}


//
//  Smart debug functions
//



/*----------------------------------------------------------
Purpose: Displays assertion string.

Returns: TRUE to debugbreak
*/
BOOL
CcshellAssertFailedA(
    LPCSTR pszFile,
    int line,
    LPCSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCSTR psz;
    CHAR ach[256];

    psz = _PathFindFileNameA(pszFile);
    StringCchPrintfA(ach, ARRAYSIZE(ach), c_szAssertFailed, psz, line, pszEval);    // ok to truncate - debug message
    OutputDebugStringA(ach);

    if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
    {
        if (bBreakInside)
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays assertion string.

*/
BOOL
CcshellAssertFailedW(
    LPCWSTR pszFile,
    int line,
    LPCWSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCWSTR psz;
    WCHAR ach[1024];    // Some callers use more than 256

    psz = _PathFindFileNameW(pszFile);

    // If psz == NULL, CharPrevW failed which implies we are running on Win95.  We can get this
    // if we get an assert in some of the W functions in shlwapi...  Call the A version of assert...
    if (!psz)
    {
        char szFile[MAX_PATH];
        char szEval[256];   // since the total output is thhis size should be enough...

        WideCharToMultiByte(CP_ACP, 0, pszFile, -1, szFile, ARRAYSIZE(szFile), NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, pszEval, -1, szEval, ARRAYSIZE(szEval), NULL, NULL);
        return CcshellAssertFailedA(szFile, line, szEval, bBreakInside);
    }

    StringCchPrintfW(ach, ARRAYSIZE(ach), c_wszAssertFailed, psz, line, pszEval);   // ok to truncate - debug message
    OutputDebugStringW(ach);

    if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
    {
        if (bBreakInside)
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
            
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays a RIP string.

Returns: TRUE to debugbreak
*/
BOOL
CcshellRipA(
    LPCSTR pszFile,
    int line,
    LPCSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCSTR psz;
    CHAR ach[256];

    psz = _PathFindFileNameA(pszFile);
    StringCchPrintfA(ach, ARRAYSIZE(ach), c_szRipNoFn, psz, line, pszEval); // ok to truncate - debug message
    OutputDebugStringA(ach);

    if (_IsShellProcess() || IsFlagSet(g_dwBreakFlags, BF_RIP))
    {
        if (bBreakInside)
        {
            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!
            
            // MSDEV USERS:  This is not the real RIP.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays a RIP string.

*/
BOOL
CcshellRipW(
    LPCWSTR pszFile,
    int line,
    LPCWSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCWSTR psz;
    WCHAR ach[256];

    psz = _PathFindFileNameW(pszFile);

    // If psz == NULL, CharPrevW failed which implies we are running on Win95.  
    // We can get this if we get an assert in some of the W functions in 
    // shlwapi...  Call the A version of assert...
    if (!psz)
    {
        char szFile[MAX_PATH];
        char szEval[256];   // since the total output is thhis size should be enough...

        WideCharToMultiByte(CP_ACP, 0, pszFile, -1, szFile, ARRAYSIZE(szFile), NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, pszEval, -1, szEval, ARRAYSIZE(szEval), NULL, NULL);
        return CcshellRipA(szFile, line, szEval, bBreakInside);
    }

    StringCchPrintfW(ach, ARRAYSIZE(ach), c_wszRipNoFn, psz, line, pszEval);    // ok to truncate - debug message
    OutputDebugStringW(ach);

    if (_IsShellProcess() || IsFlagSet(g_dwBreakFlags, BF_RIP))
    {
        if (bBreakInside)
        {
            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}

BOOL
WINCAPI 
CcshellRipMsgA(
    BOOL f, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        OutputDebugStringA(c_szRipMsg);

        va_start(vArgs, pszMsg);
        StringCchVPrintfA(ach, ARRAYSIZE(ach), pszMsg, vArgs);  // ok to truncate - debug message
        va_end(vArgs);
        OutputDebugStringA(ach);

        OutputDebugStringA(c_szNewline);

        if (_IsShellProcess() || IsFlagSet(g_dwBreakFlags, BF_RIP))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
    return FALSE;
}

BOOL
WINCAPI 
CcshellRipMsgW(
    BOOL f, 
    LPCSTR pszMsg, ...)         // (this is deliberately CHAR)
{
    WCHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        LPWSTR pwsz;
        WCHAR wszBuf[128];
        OutputDebugStringA(c_szRipMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        ach[0] = L'\0';     // In case this fails
        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
        {
            va_start(vArgs, pszMsg);
            StringCchVPrintfW(ach, ARRAYSIZE(ach), pwsz, vArgs);    // ok to truncate - debug message
            va_end(vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
        }

        OutputDebugStringW(ach);
        OutputDebugStringA(c_szNewline);

        if (_IsShellProcess() || IsFlagSet(g_dwBreakFlags, BF_RIP))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
    return FALSE;
}

/*----------------------------------------------------------
Purpose: Keep track of the stack depth for function call trace
         messages.

*/
void
CcshellStackEnter(void)
    {
    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        DWORD dwDepth;

        dwDepth = PtrToUlong(TlsGetValue(g_tlsStackDepth));

        TlsSetValue(g_tlsStackDepth, (LPVOID)(ULONG_PTR)(dwDepth + 1));
        }
    else
        {
        g_dwHackStackDepth++;
        }
    }


/*----------------------------------------------------------
Purpose: Keep track of the stack depth for functionc all trace
         messages.

*/
void
CcshellStackLeave(void)
    {
    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        DWORD dwDepth;

        dwDepth = PtrToUlong(TlsGetValue(g_tlsStackDepth));

        if (EVAL(0 < dwDepth))
            {
            EVAL(TlsSetValue(g_tlsStackDepth, (LPVOID)(ULONG_PTR)(dwDepth - 1)));
            }
        }
    else
        {
        if (EVAL(0 < g_dwHackStackDepth))
            {
            g_dwHackStackDepth--;
            }
        }
    }


/*----------------------------------------------------------
Purpose: Return the stack depth.

*/
static
DWORD
CcshellGetStackDepth(void)
    {
    DWORD dwDepth;

    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        dwDepth = PtrToUlong(TlsGetValue(g_tlsStackDepth));
        }
    else
        {
        dwDepth = g_dwHackStackDepth;
        }

    return dwDepth;
    }


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellAssertMsgA
*/
void
CDECL
CcshellAssertMsgW(
    BOOL f,
    LPCSTR pszMsg, ...)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (!f)
    {
        WCHAR wszBuf[1024];
        LPWSTR pszEnd;
        LPWSTR pwsz;

        HRESULT hr = StringCchCopyExW(ach, ARRAYSIZE(ach), c_wszAssertMsg, &pszEnd, NULL, 0);
        if (SUCCEEDED(hr))
        {
            va_start(vArgs, pszMsg);

            // (We convert the string, rather than simply input an
            // LPCWSTR parameter, so the caller doesn't have to wrap
            // all the string constants with the TEXT() macro.)

            if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
            {
                StringCchVPrintfW(pszEnd, ach + ARRAYSIZE(ach) - pszEnd, pwsz, vArgs);    // ok to truncate - debug message
                UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
            }

            va_end(vArgs);
            OutputDebugStringW(ach);
            OutputDebugStringW(c_wszNewline);
        }

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
            
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
    }
}


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellDebugMsgA.  Note this
         function deliberately takes an ANSI format string
         so our trace messages don't all need to be wrapped
         in TEXT().

*/
void
CDECL
CcshellDebugMsgW(
    ULONGLONG flag,
    LPCSTR pszMsg, ...)         // (this is deliberately CHAR)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_qwTraceFlags, flag) && flag))
    {
        int cch;
        WCHAR wszBuf[1024];
        LPWSTR pwsz;

        SetPrefixStringW(ach, ARRAYSIZE(ach), flag);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
        {
            StringCchVPrintfW(&ach[cch], ARRAYSIZE(ach) - cch, pwsz, vArgs);    // ok to truncate - debug message
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
        }

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT
        }
    }
}


/*-------------------------------------------------------------------------
Purpose: Since the ATL code does not pass in a flag parameter,
         we'll hardcode and check for TF_ATL.
*/
void CDECL ShellAtlTraceW(LPCWSTR pszMsg, ...)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (g_qwTraceFlags & TF_ATL)
    {
        LPWSTR pszEnd;
        HRESULT hr;

        SetPrefixStringW(ach, ARRAYSIZE(ach), TF_ATL);
        hr = StringCchCatExW(ach, ARRAYSIZE(ach), L"(ATL) ", &pszEnd, NULL, 0);
        if (SUCCEEDED(hr))
        {
            va_start(vArgs, pszMsg);
            StringCchVPrintfW(pszEnd, ach + ARRAYSIZE(ach) - pszEnd, pszMsg, vArgs);   // ok to truncate - debug message
            va_end(vArgs);
            OutputDebugStringW(ach);
        }
    }
}


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellFuncMsgA.  Note this
         function deliberately takes an ANSI format string
         so our trace messages don't all need to be wrapped
         in TEXT().

*/
void
CDECL
CcshellFuncMsgW(
    ULONGLONG flag,
    LPCSTR pszMsg, ...)         // (this is deliberately CHAR)
    {
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (IsFlagSet(g_qwTraceFlags, TF_FUNC) &&
        IsFlagSet(g_dwFuncTraceFlags, flag))
        {
        int cch;
        WCHAR wszBuf[1024];
        LPWSTR pwsz;
        DWORD dwStackDepth;
        LPWSTR pszLeaderEnd;
        WCHAR chSave;

        // Determine the indentation for trace message based on
        // stack depth.

        dwStackDepth = CcshellGetStackDepth();

        if (dwStackDepth < SIZECHARS(g_szIndentLeader))
            {
            pszLeaderEnd = &g_wszIndentLeader[dwStackDepth];
            }
        else
            {
            pszLeaderEnd = &g_wszIndentLeader[SIZECHARS(g_wszIndentLeader)-1];
            }

        chSave = *pszLeaderEnd;
        *pszLeaderEnd = '\0';

        StringCchPrintfW(ach, ARRAYSIZE(ach), L"%s %s", c_wszTrace, g_wszIndentLeader);  // ok to truncate - debug message
        *pszLeaderEnd = chSave;

        // Compose remaining string

        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
            {
            StringCchVPrintfW(&ach[cch], ARRAYSIZE(ach) - cch, pwsz, vArgs);    // ok to truncate - debug message
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
            }

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);
        }
    }


/*----------------------------------------------------------
Purpose: Assert failed message only
*/
void
CDECL
CcshellAssertMsgA(
    BOOL f,
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (!f)
    {
        LPSTR pszEnd;

        HRESULT hr = StringCchCopyExA(ach, ARRAYSIZE(ach), c_szAssertMsg, &pszEnd, NULL, 0);
        if (SUCCEEDED(hr))
        {
            va_start(vArgs, pszMsg);
            StringCchVPrintfA(pszEnd, ach + ARRAYSIZE(ach) - pszEnd, pszMsg, vArgs);  // ok to truncate - debug message
            va_end(vArgs);
            OutputDebugStringA(ach);
            OutputDebugStringA(c_szNewline);
        }

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
            
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
    }
}


/*----------------------------------------------------------
Purpose: Debug spew
*/
void
CDECL
CcshellDebugMsgA(
    ULONGLONG flag,
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_qwTraceFlags, flag) && flag))
    {
        int cch;

        cch = SetPrefixStringA(ach, ARRAYSIZE(ach), flag);
        va_start(vArgs, pszMsg);
        StringCchVPrintfA(&ach[cch], ARRAYSIZE(ach) - cch, pszMsg, vArgs);   // ok to truncate - debug message
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT
        }
    }
}


/*-------------------------------------------------------------------------
Purpose: Since the ATL code does not pass in a flag parameter,
         we'll hardcode and check for TF_ATL.
*/
void CDECL ShellAtlTraceA(LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (g_qwTraceFlags & TF_ATL)
    {
        LPSTR pszEnd;
        HRESULT hr;

        SetPrefixStringA(ach, ARRAYSIZE(ach), TF_ATL);
        hr = StringCchCatExA(ach, ARRAYSIZE(ach), "(ATL) ", &pszEnd, NULL, 0);
        if (SUCCEEDED(hr))
        {
            va_start(vArgs, pszMsg);
            StringCchVPrintfA(pszEnd, ach + ARRAYSIZE(ach) - pszEnd, pszMsg, vArgs);  // ok to truncate - debug message
            va_end(vArgs);
            OutputDebugStringA(ach);
        }
    }
}


/*----------------------------------------------------------
Purpose: Debug spew for function trace calls
*/
void
CDECL
CcshellFuncMsgA(
    ULONGLONG flag,
    LPCSTR pszMsg, ...)
    {
    CHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (IsFlagSet(g_qwTraceFlags, TF_FUNC) &&
        IsFlagSet(g_dwFuncTraceFlags, flag))
        {
        int cch;
        DWORD dwStackDepth;
        LPSTR pszLeaderEnd;
        CHAR chSave;

        // Determine the indentation for trace message based on
        // stack depth.

        dwStackDepth = CcshellGetStackDepth();

        if (dwStackDepth < sizeof(g_szIndentLeader))
            {
            pszLeaderEnd = &g_szIndentLeader[dwStackDepth];
            }
        else
            {
            pszLeaderEnd = &g_szIndentLeader[sizeof(g_szIndentLeader)-1];
            }

        chSave = *pszLeaderEnd;
        *pszLeaderEnd = '\0';

        StringCchPrintfA(ach, ARRAYSIZE(ach), "%s %s", c_szTrace, g_szIndentLeader);    // ok to truncate - debug message
        *pszLeaderEnd = chSave;

        // Compose remaining string

        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        StringCchVPrintfA(&ach[cch], ARRAYSIZE(ach) - cch, pszMsg, vArgs);  // ok to truncate - debug message
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);
        }
    }


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if hrTest is a failure code.
*/
HRESULT 
TraceHR(
    HRESULT hrTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_qwTraceFlags & TF_WARNING &&
        FAILED(hrTest))
    {
        int cch;

        cch = SetPrefixStringA(ach, ARRAYSIZE(ach), TF_WARNING);
        StringCchPrintfA(&ach[cch], ARRAYSIZE(ach) - cch,
                   "THR: Failure of \"%s\" at %s, line %d (%#08lx)",
                   pszExpr, _PathFindFileNameA(pszFile), iLine, hrTest);    // ok to truncate - debug message
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  THR  !!!!  THR  !!!!  THR !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  THR  !!!!  THR  !!!!  THR !!!
        }
    }
    return hrTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if bTest is false.
*/
BOOL 
TraceBool(
    BOOL bTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_qwTraceFlags & TF_WARNING && !bTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, ARRAYSIZE(ach), TF_WARNING);
        StringCchPrintfA(&ach[cch], ARRAYSIZE(ach) - cch,
                   "TBOOL: Failure of \"%s\" at %s, line %d",
                   pszExpr, _PathFindFileNameA(pszFile), iLine);    // ok to truncate - debug message
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  TBOOL  !!!!  TBOOL  !!!!  TBOOL !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  TBOOL  !!!!  TBOOL  !!!!  TBOOL !!!
        }
    }
    return bTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if iTest is -1.
*/
int 
TraceInt(
    int iTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_qwTraceFlags & TF_WARNING && -1 == iTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, ARRAYSIZE(ach), TF_WARNING);
        StringCchPrintfA(&ach[cch], ARRAYSIZE(ach) - cch,
                   "TINT: Failure of \"%s\" at %s, line %d",
                   pszExpr, _PathFindFileNameA(pszFile), iLine);    // ok to truncate - debug message
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  TINT  !!!!  TINT  !!!!  TINT !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  TINT  !!!!  TINT  !!!!  TINT !!!
        }
    }
    return iTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if pvTest is NULL.
*/
LPVOID 
TracePtr(
    LPVOID pvTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_qwTraceFlags & TF_WARNING && NULL == pvTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, ARRAYSIZE(ach), TF_WARNING);
        StringCchPrintfA(&ach[cch], ARRAYSIZE(ach) - cch,
                   "TPTR: Failure of \"%s\" at %s, line %d",
                   pszExpr, _PathFindFileNameA(pszFile), iLine);    // ok to truncate - debug message
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  TPTR  !!!!  TPTR  !!!!  TPTR !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  TPTR  !!!!  TPTR  !!!!  TPTR !!!
        }
    }
    return pvTest;
}


/*-------------------------------------------------------------------------
Purpose: Spews a trace message if dwTest is a Win32 failure code.
*/
DWORD  
TraceWin32(
    DWORD dwTest, 
    LPCSTR pszExpr, 
    LPCSTR pszFile, 
    int iLine)
{
    CHAR ach[1024+40];    // Largest path plus extra

    if (g_qwTraceFlags & TF_WARNING &&
        ERROR_SUCCESS != dwTest)
    {
        int cch;

        cch = SetPrefixStringA(ach, ARRAYSIZE(ach), TF_WARNING);
        StringCchPrintfA(&ach[cch], ARRAYSIZE(ach) - cch,
                   "TW32: Failure of \"%s\" at %s, line %d (%#08lx)",
                   pszExpr, _PathFindFileNameA(pszFile), iLine, dwTest);    // ok to truncate - debug message
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_THR))
        {
            // !!!  THR  !!!!  THR  !!!!  THR !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  THR  !!!!  THR  !!!!  THR !!!
        }
    }
    return dwTest;
}



//
//  Debug .ini functions
//


#pragma data_seg(DATASEG_READONLY)

// (These are deliberately CHAR)
CHAR const FAR c_szNull[] = "";
CHAR const FAR c_szZero[] = "0";
CHAR const FAR c_szIniKeyBreakFlags[] = "BreakFlags";
CHAR const FAR c_szIniKeyTraceFlags[] = "TraceFlags";
CHAR const FAR c_szIniKeyFuncTraceFlags[] = "FuncTraceFlags";
CHAR const FAR c_szIniKeyDumpFlags[] = "DumpFlags";
CHAR const FAR c_szIniKeyProtoFlags[] = "Prototype";

#pragma data_seg()


// Some of the .ini processing code was pimped from the sync engine.
//

typedef struct _INIKEYHEADER
    {
    LPCTSTR pszSectionName;
    LPCTSTR pszKeyName;
    LPCTSTR pszDefaultRHS;
    } INIKEYHEADER;

typedef struct _BOOLINIKEY
    {
    INIKEYHEADER ikh;
    LPDWORD puStorage;
    DWORD dwFlag;
    } BOOLINIKEY;

typedef struct _INTINIKEY
    {
    INIKEYHEADER ikh;
    LPDWORD puStorage;
    } INTINIKEY;


#define PutIniIntCmp(idsSection, idsKey, nNewValue, nSave) \
    if ((nNewValue) != (nSave)) PutIniInt(idsSection, idsKey, nNewValue)

#define WritePrivateProfileInt(szApp, szKey, i, lpFileName) \
    {CHAR sz[7]; \
    WritePrivateProfileString(szApp, szKey, SzFromInt(sz, i), lpFileName);}


#ifdef BOOL_INI_VALUES
/* Boolean TRUE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszTrue[] =
    {
    TEXT("1"),
    TEXT("On"),
    TEXT("True"),
    TEXT("Y"),
    TEXT("Yes")
    };

/* Boolean FALSE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszFalse[] =
    {
    TEXT("0"),
    TEXT("Off"),
    TEXT("False"),
    TEXT("N"),
    TEXT("No")
    };
#endif


#ifdef BOOL_INI_VALUES
/*----------------------------------------------------------
Purpose: Determines whether a string corresponds to a boolean
          TRUE value.
Returns: The boolean value (TRUE or FALSE)
*/
BOOL
PRIVATE
IsIniYes(
    LPCTSTR psz)
    {
    int i;
    BOOL bNotFound = TRUE;
    BOOL bResult;

    ASSERT(psz);

    /* Is the value TRUE? */

    for (i = 0; i < ARRAYSIZE(s_rgpszTrue); i++)
        {
        if (IsSzEqual(psz, s_rgpszTrue[i]))
            {
            bResult = TRUE;
            bNotFound = FALSE;
            break;
            }
        }

    /* Is the value FALSE? */

    if (bNotFound)
        {
        for (i = 0; i < ARRAYSIZE(s_rgpszFalse); i++)
            {
            if (IsSzEqual(psz, s_rgpszFalse[i]))
                {
                bResult = FALSE;
                bNotFound = FALSE;
                break;
                }
            }

        /* Is the value a known string? */

        if (bNotFound)
            {
            /* No.  Whine about it. */

            TraceMsg(TF_WARNING, "IsIniYes() called on unknown Boolean RHS '%s'.", psz);
            bResult = FALSE;
            }
        }

    return bResult;
    }


/*----------------------------------------------------------
Purpose: Process keys with boolean RHSs.
*/
void
PRIVATE
ProcessBooleans(void)
    {
    int i;

    for (i = 0; i < ARRAYSIZE(s_rgbik); i++)
        {
        DWORD dwcbKeyLen;
        TCHAR szRHS[MAX_BUF];
        BOOLINIKEY * pbik = &(s_rgbik[i]);
        LPCTSTR lpcszRHS;

        /* Look for key. */

        dwcbKeyLen = GetPrivateProfileString(pbik->ikh.pszSectionName,
                                   pbik->ikh.pszKeyName, TEXT(""), szRHS,
                                   SIZECHARS(szRHS), c_szCcshellIniFile);

        if (dwcbKeyLen)
            lpcszRHS = szRHS;
        else
            lpcszRHS = pbik->ikh.pszDefaultRHS;

        if (IsIniYes(lpcszRHS))
            {
            if (IsFlagClear(*(pbik->puStorage), pbik->dwFlag))
                TraceMsg(TF_GENERAL, "ProcessIniFile(): %s set in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szCcshellIniFile,
                         pbik->ikh.pszSectionName);

            SetFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        else
            {
            if (IsFlagSet(*(pbik->puStorage), pbik->dwFlag))
                TraceMsg(TF_GENERAL, "ProcessIniFile(): %s cleared in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szCcshellIniFile,
                         pbik->ikh.pszSectionName);

            ClearFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        }
    }
#endif

/*----------------------------------------------------------
Purpose: This function reads a .ini file to determine the debug
         flags to set.  The .ini file and section are specified
         by the following manifest constants:

                SZ_DEBUGINI
                SZ_DEBUGSECTION

         The debug variables that are set by this function are
         g_dwDumpFlags, g_qwTraceFlags, g_dwBreakFlags, and
         g_dwFuncTraceFlags, g_dwPrototype.

Returns: TRUE if initialization is successful
*/
BOOL
PUBLIC
CcshellGetDebugFlags(void)
    {
    CHAR szRHS[MAX_PATH];
    ULONGLONG val;

    //  (scotth): Yes, COMCTL32 exports StrToIntEx, but I
    //  don't want to cause a dependency delta and force everyone
    //  to get a new comctl32 just because they built debug.
    //  So use a local version of StrToIntEx.

    // Trace Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyTraceFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_qwTraceFlags = val;
#ifdef FULL_DEBUG
    else
        g_qwTraceFlags = 3; // default to TF_ERROR and TF_WARNING trace messages
#endif

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#16I64x.",
             c_szIniKeyTraceFlags, g_qwTraceFlags);

    // Function trace Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyFuncTraceFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwFuncTraceFlags = (DWORD)val;

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyFuncTraceFlags, g_dwFuncTraceFlags);

    // Dump Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyDumpFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwDumpFlags = (DWORD)val;

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyDumpFlags, g_dwDumpFlags);

    // Break Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyBreakFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwBreakFlags = (DWORD)val;
#ifdef FULL_DEBUG
    else
        g_dwBreakFlags = 5; // default to break on ASSERT and TF_ERROR
#endif

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyBreakFlags, g_dwBreakFlags);

    // Prototype Flags

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            c_szIniKeyProtoFlags,
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwPrototype = (DWORD)val;

    // Are we using the new leak detection from shelldbg.dll?
    GetPrivateProfileStringA("ShellDbg",
                            "NewLeakDetection",
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_bUseNewLeakDetection = BOOLIFY(val);

    TraceMsgA(DM_DEBUG, "CcshellGetDebugFlags(): %s set to %#08x.",
             c_szIniKeyProtoFlags, g_dwPrototype);

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            "DebugOutputFile",
                            c_szNull,
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);
    if (szRHS[0] != TEXT('\0'))
    {
        g_hDebugOutputFile = CreateFileA(szRHS, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    }

    return TRUE;
    }

// Function to call in allocspy.dll (GetShellMallocSpy)
typedef BOOL (__stdcall *pfnGSMS) (IShellMallocSpy **ppout);

STDAPI_(void) IMSAddToList(BOOL bAdd, void*pv, SIZE_T cb)
{
    static BOOL bDontTry=FALSE;
    static IShellMallocSpy *pms=NULL;

    if (!bDontTry && pms == NULL)
    {
        pfnGSMS pfnGetShellMallocSpy;
        HMODULE hmod;

        bDontTry = TRUE; // assume failure
        if (hmod = LoadLibraryA("ALLOCSPY.DLL"))
        {
            pfnGetShellMallocSpy = (pfnGSMS) GetProcAddress(hmod, "GetShellMallocSpy");

            pfnGetShellMallocSpy(&pms);
        }
    }
    if (bDontTry)
        return;

    if (bAdd)
        pms->lpVtbl->AddToList(pms, pv, cb);
    else
        pms->lpVtbl->RemoveFromList(pms, pv);
}


#endif // DEBUG

#ifdef PRODUCT_PROF

DWORD g_dwProfileCAP = 0;        

BOOL PUBLIC CcshellGetDebugFlags(void)
{
    CHAR szRHS[MAX_PATH];
    LONGLONG val;

    GetPrivateProfileStringA(c_szCcshellIniSecDebug,
                            "Profile",
                            "",
                            szRHS,
                            SIZECHARS(szRHS),
                            c_szCcshellIniFile);

    if (MyStrToIntExA(szRHS, STIF_SUPPORT_HEX, &val))
        g_dwProfileCAP = (DWORD)val;

    return TRUE;
}
#endif // PRODUCT_PROF 


#ifdef DEBUG

// turn on path whacking for full-debug builds
#ifdef FULL_DEBUG
static BOOL g_fWhackPathBuffers = TRUE;
#else
static BOOL g_fWhackPathBuffers = FALSE;
#endif

void DEBUGWhackPathBufferA(LPSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, char, cch))
        {
            FillMemory(psz, cch * sizeof(char), 0xFE);
        }
    }
}

void DEBUGWhackPathBufferW(LPWSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, WCHAR, cch))
        {
            FillMemory(psz, cch * sizeof(WCHAR), 0xFE);
        }
    }
}

void DEBUGWhackPathStringA(LPSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, char, cch) && IS_VALID_STRING_PTRA(psz, -1))
        {
            UINT len = lstrlenA(psz);

            if (len >= cch)
            {
                TraceMsg(TF_WARNING, "DEBUGWhackPathStringA: caller of caller passed strange Path string (strlen > buffer size)");
            }
            else
            {
                FillMemory(psz+len+1, (cch-len-1) * sizeof(char), 0xFE);
            }
        }
    }
}

void DEBUGWhackPathStringW(LPWSTR psz, UINT cch)
{
    if (g_fWhackPathBuffers)
    {
        if (psz && IS_VALID_WRITE_BUFFER(psz, WCHAR, cch) && IS_VALID_STRING_PTRW(psz, -1))
        {
            UINT len = lstrlenW(psz);

            if (len >= cch)
            {
                TraceMsg(TF_WARNING, "DEBUGWhackPathStringW: caller of caller passed strange Path string (strlen > buffer size)");
            }
            else
            {
                FillMemory(psz+len+1, (cch-len-1) * sizeof(WCHAR), 0xFE);
            }
        }
    }
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\dobjutil.cpp ===
#include "stock.h"
#pragma hdrstop

#ifndef UNICODE 
#define UNICODE 
#endif 

#include <dobjutil.h>


STDAPI DataObj_SetBlob(IDataObject *pdtobj, UINT cf, LPCVOID pvBlob, UINT cbBlob)
{
    HRESULT hr = E_OUTOFMEMORY;
    void *pv = GlobalAlloc(GPTR, cbBlob);
    if (pv)
    {
        CopyMemory(pv, pvBlob, cbBlob);
        hr = DataObj_SetGlobal(pdtobj, cf, pv);
        if (FAILED(hr))
            GlobalFree((HGLOBAL)pv);
    }
    return hr;
}

STDAPI DataObj_GetBlob(IDataObject *pdtobj, UINT cf, void *pvBlob, UINT cbBlob)
{
    STGMEDIUM medium = {0};
    FORMATETC fmte = {(CLIPFORMAT) cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hr = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hr))
    {
        void *pv = GlobalLock(medium.hGlobal);
        if (pv)
        {
            SIZE_T cb = GlobalSize(medium.hGlobal);
            if (cb < cbBlob)
            {
                RIP(!"Corrupted IDataObject - HGLOBAL too small");
                hr = E_UNEXPECTED;
            }
            else
            {
                CopyMemory(pvBlob, pv, cbBlob);
            }
            GlobalUnlock(medium.hGlobal);
        }
        else
        {
            hr = E_UNEXPECTED;
        }
        ReleaseStgMedium(&medium);
    }
    return hr;
}

STDAPI DataObj_SetDWORD(IDataObject *pdtobj, UINT cf, DWORD dw)
{
    return DataObj_SetBlob(pdtobj, cf, &dw, sizeof(DWORD));
}

STDAPI_(DWORD) DataObj_GetDWORD(IDataObject *pdtobj, UINT cf, DWORD dwDefault)
{
    DWORD dwRet;
    if (FAILED(DataObj_GetBlob(pdtobj, cf, &dwRet, sizeof(DWORD))))
        dwRet = dwDefault;
    return dwRet;
}

STDAPI DataObj_SetGlobal(IDataObject *pdtobj, UINT cf, HGLOBAL hGlobal)
{
    FORMATETC fmte = {(CLIPFORMAT) cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium = {0};

    medium.tymed = TYMED_HGLOBAL;
    medium.hGlobal = hGlobal;
    medium.pUnkForRelease = NULL;

    // give the data object ownership of ths
    return pdtobj->SetData(&fmte, &medium, TRUE);
}

STDAPI_(LPIDA) DataObj_GetHIDAEx(IDataObject *pdtobj, CLIPFORMAT cf, STGMEDIUM *pmedium)
{
    FORMATETC fmte = {cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    if (pmedium)
    {
        pmedium->pUnkForRelease = NULL;
        pmedium->hGlobal = NULL;
    }

    if (!pmedium)
    {
        if (S_OK == pdtobj->QueryGetData(&fmte))
            return (LPIDA)TRUE;
        else
            return (LPIDA)FALSE;
    }
    else if (SUCCEEDED(pdtobj->GetData(&fmte, pmedium)))
    {
        return (LPIDA)GlobalLock(pmedium->hGlobal);
    }

    return NULL;
}

STDAPI_(LPIDA) DataObj_GetHIDA(IDataObject *pdtobj, STGMEDIUM *pmedium)
{
    static CLIPFORMAT cfHIDA = 0;
    if (!cfHIDA)
    {
        cfHIDA = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);
    }
    return DataObj_GetHIDAEx(pdtobj, cfHIDA, pmedium);
}


STDAPI_(void) ReleaseStgMediumHGLOBAL(void *pv, STGMEDIUM *pmedium)
{
    if (pmedium->hGlobal && (pmedium->tymed == TYMED_HGLOBAL))
    {
#ifdef DEBUG
        if (pv)
        {
            void *pvT = (void *)GlobalLock(pmedium->hGlobal);
            ASSERT(pvT == pv);
            GlobalUnlock(pmedium->hGlobal);
        }
#endif
        GlobalUnlock(pmedium->hGlobal);
    }
    else
    {
        ASSERT(0);
    }

    ReleaseStgMedium(pmedium);
}

STDAPI_(void) HIDA_ReleaseStgMedium(LPIDA pida, STGMEDIUM * pmedium)
{
    ReleaseStgMediumHGLOBAL((void *)pida, pmedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\dllreghelper.cpp ===
//------------------------------------------------------------------------
//
//  Microsoft Windows 
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:      DllRegHelper.cpp
//
//  Contents:  helper classes to register COM components in DLLs
//
//------------------------------------------------------------------------

#include "DllRegHelper.h"
#pragma hdrstop

#include <comcat.h>
#include <advpub.h>
#include <shlwapi.h>
#include "ccstock.h"
#include "debug.h"
#include "mluisupp.h"


#define _APLHA_ComCat_WorkAround    // { ALPHA ComCat bug work-around on alpha, nuke this eventually?
                                    // ie40:63004: comcat does RegCloseKey(invalid) on checked
                                    // nt/alpha if the clsid doesn't exist (e.g. for QuickLinksOld)

#if defined(_APLHA_ComCat_WorkAround)
//------------------------------------------------------------------------
//***   HasImplCat -- does "HKCR/CLSID/{clsid}/Implemented Categories" exist
// NOTES
//  used for ComCat bug work-around on alpha
BOOL HasImplCat(const CATID *pclsid)
{
    HKEY hk;
    TCHAR szClass[GUIDSTR_MAX];
    TCHAR szImpl[MAX_PATH];      // "CLSID/{clsid}/Implemented Categories" < MAX_PATH

    // "CLSID/{clsid}/Implemented Categories"
    SHStringFromGUID(*pclsid, szClass, ARRAYSIZE(szClass));
    ASSERT(lstrlen(szClass) == GUIDSTR_MAX - 1);

    HRESULT hr = StringCchPrintf(szImpl, ARRAYSIZE(szImpl), TEXT("CLSID\\%s\\Implemented Categories"), szClass);
    if (FAILED(hr))
    {
        return FALSE;
    }

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szImpl, 0, KEY_QUERY_VALUE, &hk) == ERROR_SUCCESS) {
        RegCloseKey(hk);
        return TRUE;
    }
    else {
        TraceMsg(DM_WARNING, "HasImplCat: %s: ret 0", szImpl);
        return FALSE;
    }
}
#endif // }


//------------------------------------------------------------------------
//***   RegisterOneCategory -- [un]register ComCat implementor(s) and category
// ENTRY/EXIT
//  eRegister   CCR_REG, CCR_UNREG, CCR_UNREGIMP
//      CCR_REG, UNREG      reg/unreg implementor(s) and category
//      CCR_UNREGIMP        unreg implementor(s) only
//  pcatidCat   e.g. CATID_DeskBand
//  idResCat    e.g. IDS_CATDESKBAND
//  pcatidImpl  e.g. c_DeskBandClasses
HRESULT DRH_RegisterOneCategory(const CATID *pcatidCat, UINT idResCat, const CATID * const *pcatidImpl, enum DRH_REG_MODE eRegister)
{
    ICatRegister* pcr;
    HRESULT hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL,
                                  CLSCTX_INPROC_SERVER, IID_PPV_ARG(ICatRegister, &pcr));
    if (SUCCEEDED(hr))
    {
        if (eRegister == CCR_REG)
        {
            // register the category
            CATEGORYINFO catinfo;
            catinfo.catid = *pcatidCat;     // e.g. CATID_DESKBAND
            catinfo.lcid = LOCALE_USER_DEFAULT;
            MLLoadString(idResCat, catinfo.szDescription, ARRAYSIZE(catinfo.szDescription));
            hr = pcr->RegisterCategories(1, &catinfo);
            ASSERT(SUCCEEDED(hr));
            
            // register the classes that implement categories
            for ( ; *pcatidImpl != NULL; pcatidImpl++)
            {
                CLSID clsid = **pcatidImpl;
                CATID catid = *pcatidCat;
                hr = pcr->RegisterClassImplCategories(clsid, 1, &catid);
                ASSERT(SUCCEEDED(hr));
            }
        }
        else
        {
            // unregister the classes that implement categories
            for ( ; *pcatidImpl != NULL; pcatidImpl++)
            {
                CLSID clsid = **pcatidImpl;
                CATID catid = *pcatidCat;

#if defined(_APLHA_ComCat_WorkAround)   // { ALPHA ComCat bug work-around on alpha, nuke this eventually?
                // workaround comcat/alpha bug
                // n.b. we do this for non-alpha too to reduce testing impact
                // ie40:63004: comcat does RegCloseKey(invalid) on checked
                // nt/alpha if the clsid doesn't exist (e.g. for QuickLinksOld)
                if (!HasImplCat(&clsid))
                    continue;
#endif // }
                hr = pcr->UnRegisterClassImplCategories(clsid, 1, &catid);
                ASSERT(SUCCEEDED(hr));
            }
            
            if (eRegister == CCR_UNREG)
            {
                // Do we want to do this?  other classes (e.g. 3rd party
                // ones) might still be using the category.  however since we're
                // the component that added (and supports) the category, it
                // seems correct that we should remove it when we unregister.

                // unregister the category
                CATID catid = *pcatidCat;
                hr = pcr->UnRegisterCategories(1, &catid);
                ASSERT(SUCCEEDED(hr));
            }
        }
        pcr->Release();
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\dllver.cpp ===
//
//  This is a separate file so the dependency on c_dllver is pulled
//  in only if the application actually calls CCDllGetVersion.
//
#include "stock.h"
#pragma hdrstop


//
//  Common worker function for DllGetVersion.  This means we can add
//  new DLLVERSIONINFO2, 3, 4... structures and have to fix only one
//  function. See ccstock.h for description of usage.
//

extern "C" const DLLVERSIONINFO2 c_dllver;

STDAPI CCDllGetVersion(IN OUT DLLVERSIONINFO * pinfo)
{
    HRESULT hres = E_INVALIDARG;

    if (pinfo != NULL)
    {
        if (pinfo->cbSize == sizeof(DLLVERSIONINFO) ||
                pinfo->cbSize == sizeof(DLLVERSIONINFO2))
        {
            CopyMemory((LPBYTE)pinfo     + sizeof(pinfo->cbSize),
                    (LPBYTE)&c_dllver + sizeof(pinfo->cbSize),
                    pinfo->cbSize     - sizeof(pinfo->cbSize));
            hres = S_OK;
        }
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\expdsprt.cpp ===
#include "stock.h"
#pragma hdrstop

#include "expdsprt.h"

HRESULT CImpIExpDispSupport::FindCIE4ConnectionPoint(REFIID riid, CIE4ConnectionPoint **ppccp)
{
    CConnectionPoint* pccp = _FindCConnectionPointNoRef(FALSE, riid);

    if (pccp)
    {
        pccp->AddRef();
        *ppccp = pccp;
        return S_OK;
    }
    else
    {
        *ppccp = NULL;
        return E_NOINTERFACE;
    }
}

HRESULT CImpIExpDispSupport::OnTranslateAccelerator(MSG __RPC_FAR *pMsg,DWORD grfModifiers)
{
    return E_NOTIMPL;
}

HRESULT CImpIExpDispSupport::OnInvoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pdispparams,
                 VARIANT FAR* pVarResult,EXCEPINFO FAR* pexcepinfo,UINT FAR* puArgErr)
{
    return E_NOTIMPL;
}

HRESULT CImpIConnectionPointContainer::FindConnectionPoint(REFIID iid, LPCONNECTIONPOINT *ppCP)
{
    if (NULL == ppCP)
        return E_POINTER;

    CConnectionPoint *pccp = _FindCConnectionPointNoRef(TRUE, iid);
    if (pccp)
    {
        pccp->AddRef();
        *ppCP = pccp->CastToIConnectionPoint();
        return S_OK;
    }
    else
    {
        *ppCP = NULL;
        return E_NOINTERFACE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\idhidden.cpp ===
#include "stock.h"
#pragma hdrstop

#include <idhidden.h>

//  the last word of the pidl is where we store the hidden offset
#define _ILHiddenOffset(pidl)   (*((WORD UNALIGNED *)(((BYTE *)_ILNext(pidl)) - sizeof(WORD))))
#define _ILSetHiddenOffset(pidl, cb)   ((*((WORD UNALIGNED *)(((BYTE *)_ILNext(pidl)) - sizeof(WORD)))) = (WORD)cb)
#define _ILIsHidden(pidhid)     (HIWORD(pidhid->id) == HIWORD(IDLHID_EMPTY))

STDAPI_(PCIDHIDDEN) _ILNextHidden(PCIDHIDDEN pidhid, LPCITEMIDLIST pidlLimit)
{
    PCIDHIDDEN pidhidNext = (PCIDHIDDEN) _ILNext((LPCITEMIDLIST)pidhid);

    if ((BYTE *)pidhidNext < (BYTE *)pidlLimit && _ILIsHidden(pidhidNext))
    {
        return pidhidNext;
    }

    //  if we ever go past the limit,
    //  then this is not really a hidden id
    //  or we have messed up on some calculation.
    ASSERT((BYTE *)pidhidNext == (BYTE *)pidlLimit);
    return NULL;
}

STDAPI_(PCIDHIDDEN) _ILFirstHidden(LPCITEMIDLIST pidl)
{
    WORD cbHidden = _ILHiddenOffset(pidl);

    if (cbHidden && cbHidden + sizeof(HIDDENITEMID) < pidl->mkid.cb)
    {
        //  this means it points to someplace inside the pidl
        //  maybe this has hidden ids
        PCIDHIDDEN pidhid = (PCIDHIDDEN) (((BYTE *)pidl) + cbHidden);

        if (_ILIsHidden(pidhid)
        && (pidhid->cb + cbHidden <= pidl->mkid.cb))
        {
            //  this is more than likely a hidden id
            //  we could walk the chain and verify
            //  that it adds up right...
            return pidhid;
        }
    }

    return NULL;
}

//
//  HIDDEN ids are sneakily hidden in the last ID in a pidl.
//  we append our data without changing the existing pidl,
//  (except it is now bigger)  this works because the pidls
//  that we will apply this to are flexible in handling different
//  sized pidls.  specifically this is used in FS pidls.
// 
//  WARNING - it is the callers responsibility to use hidden IDs
//  only on pidls that can handle it.  most shell pidls, and 
//  specifically FS pidls have no problem with this.  however
//  some shell extensions might have fixed length ids, 
//  which makes these unadvisable to append to everything.
//  possibly add an SFGAO_ bit to allow hidden, otherwise key
//  off FILESYSTEM bit.
//


STDAPI ILCloneWithHiddenID(LPCITEMIDLIST pidl, PCIDHIDDEN pidhid, LPITEMIDLIST *ppidl)
{
    HRESULT hr;

    // If this ASSERT fires, then the caller did not set the pidhid->id
    // value properly.  For example, the packing settings might be incorrect.

    ASSERT(_ILIsHidden(pidhid));

    if (ILIsEmpty(pidl))
    {
        *ppidl = NULL;
        hr = E_INVALIDARG;
    }
    else
    {
        UINT cbUsed = ILGetSize(pidl);
        UINT cbRequired = cbUsed + pidhid->cb + sizeof(pidhid->cb);

        *ppidl = (LPITEMIDLIST)SHAlloc(cbRequired);
        if (*ppidl)
        {
            hr = S_OK;

            CopyMemory(*ppidl, pidl, cbUsed);

            LPITEMIDLIST pidlLast = ILFindLastID(*ppidl);
            WORD cbHidden = _ILFirstHidden(pidlLast) ? _ILHiddenOffset(pidlLast) : pidlLast->mkid.cb;
            PIDHIDDEN pidhidCopy = (PIDHIDDEN)_ILSkip(*ppidl, cbUsed - sizeof((*ppidl)->mkid.cb));

            // Append it, overwriting the terminator
            MoveMemory(pidhidCopy, pidhid, pidhid->cb);

            //  grow the copy to allow the hidden offset.
            pidhidCopy->cb += sizeof(pidhid->cb);

            //  now we need to readjust pidlLast to encompass 
            //  the hidden bits and the hidden offset.
            pidlLast->mkid.cb += pidhidCopy->cb;

            //  set the hidden offset so that we can find our hidden IDs later
            _ILSetHiddenOffset((LPITEMIDLIST)pidhidCopy, cbHidden);

            // We must put zero-terminator because of LMEM_ZEROINIT.
            _ILSkip(*ppidl, cbRequired - sizeof((*ppidl)->mkid.cb))->mkid.cb = 0;
            ASSERT(ILGetSize(*ppidl) == cbRequired);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

// lame API that consumes pidl as input (caller must not touch after callign this)

STDAPI_(LPITEMIDLIST) ILAppendHiddenID(LPITEMIDLIST pidl, PCIDHIDDEN pidhid)
{
    //
    // FEATURE - we dont handle collisions of multiple hidden ids
    //          maybe remove IDs of the same IDLHID?
    //
    // Note: We do not remove IDLHID_EMPTY hidden ids.
    // Callers need to call ILExpungeRemovedHiddenIDs explicitly
    // if they want empty hidden ids to be compressed out.
    //
    
    RIP(pidl);  //  we require a pidl to attach the hidden id to
    if (!ILIsEmpty(pidl))
    {
        LPITEMIDLIST pidlSave = pidl;
        ILCloneWithHiddenID(pidl, pidhid, &pidl);
        ILFree(pidlSave);
    }
    return pidl;
}



STDAPI_(PCIDHIDDEN) ILFindHiddenIDOn(LPCITEMIDLIST pidl, IDLHID id, BOOL fOnLast)
{
    RIP(pidl);
    if (!ILIsEmpty(pidl))
    {
        if (fOnLast)
            pidl = ILFindLastID(pidl);
        
        PCIDHIDDEN pidhid = _ILFirstHidden(pidl);

        //  reuse pidl to become the limit.
        //  so that we cant ever walk out of 
        //  the pidl.
        pidl = _ILNext(pidl);

        while (pidhid)
        {
            if (pidhid->id == id)
                break;

            pidhid = _ILNextHidden(pidhid, pidl);
        }
        return pidhid;
    }

    return NULL;
}

STDAPI_(LPITEMIDLIST) ILCreateWithHidden(UINT cbNonHidden, UINT cbHidden)
{
    //  alloc enough for the two ids plus term and hidden tail
    LPITEMIDLIST pidl;
    UINT cb = cbNonHidden + cbHidden + sizeof(pidl->mkid.cb);
    UINT cbAlloc = cb + sizeof(pidl->mkid.cb);
    pidl = (LPITEMIDLIST)SHAlloc(cbAlloc);
    if (pidl)
    {
        // zero-init for external task allocator
        memset(pidl, 0, cbAlloc);
        PIDHIDDEN pidhid = (PIDHIDDEN)_ILSkip(pidl, cbNonHidden);

        //  grow the copy to allow the hidden offset.
        pidhid->cb = (USHORT) cbHidden + sizeof(pidhid->cb);

        //  now we need to readjust pidlLast to encompass 
        //  the hidden bits and the hidden offset.
        pidl->mkid.cb = (USHORT) cb;

        //  set the hidden offset so that we can find our hidden IDs later
        _ILSetHiddenOffset(pidl, cbNonHidden);

        ASSERT(ILGetSize(pidl) == cbAlloc);
        ASSERT(_ILNext(pidl) == _ILNext((LPCITEMIDLIST)pidhid));
    }
    return pidl;
}

// Note: The space occupied by the removed ID is not reclaimed.
// Call ILExpungeRemovedHiddenIDs explicitly to reclaim the space.

STDAPI_(BOOL) ILRemoveHiddenID(LPITEMIDLIST pidl, IDLHID id)
{
    PIDHIDDEN pidhid = (PIDHIDDEN)ILFindHiddenID(pidl, id);

    if (pidhid)
    {
        pidhid->id = IDLHID_EMPTY;
        return TRUE;
    }
    return FALSE;
}

STDAPI_(void) ILExpungeRemovedHiddenIDs(LPITEMIDLIST pidl)
{
    if (pidl)
    {
        pidl = ILFindLastID(pidl);

        // Note: Each IDHIDDEN has a WORD appended to it, equal to
        // _ILHiddenOffset, so we can just keep deleting IDHIDDENs
        // and if we delete them all, everything is cleaned up; if
        // there are still unremoved IDHIDDENs left, they will provide
        // the _ILHiddenOffset.

        PIDHIDDEN pidhid;
        BOOL fAnyDeleted = FALSE;
        while ((pidhid = (PIDHIDDEN)ILFindHiddenID(pidl, IDLHID_EMPTY)) != NULL)
        {
            fAnyDeleted = TRUE;
            LPBYTE pbAfter = (LPBYTE)pidhid + pidhid->cb;
            WORD cbDeleted = pidhid->cb;
            MoveMemory(pidhid, pbAfter,
                       (LPBYTE)pidl + pidl->mkid.cb + sizeof(WORD) - pbAfter);
            pidl->mkid.cb -= cbDeleted;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\iconutil.cpp ===
/*

Copyright (c) 2001  Microsoft Corporation

Module Name:    IconUtil.cpp
                Icon related utility functions, starting with an alpha stripped rendering

*/

#include "stock.h"

STDAPI_(HBITMAP) CreateDIB(HDC h, WORD depth, int cx, int cy, RGBQUAD** pprgb)
{
    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = cx;
    bi.bmiHeader.biHeight = cy;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = depth;
    bi.bmiHeader.biCompression = BI_RGB;

    return CreateDIBSection(h, &bi, DIB_RGB_COLORS, (void**)pprgb, NULL, 0);
}

STDAPI_(BOOL) HasAlpha(RGBQUAD* prgb, int cx, int cy)
{
    int iTotal = cx * cy;

    for (int i = 0; i < iTotal; i++)
    {
        if (prgb[i].rgbReserved != 0)
            return TRUE;
    }

    return FALSE;
}

STDAPI_(void) ProcessDIB(RGBQUAD* prgb, int cx, int cy)
{
    int iTotal = cx * cy;

    for (int i = 0; i < iTotal; i++)
    {
        // Maybe Adjust the mask to mask out Alpha that's less than 128 and keep colors
        // where alpha is mostly opaque, instead of all of it.
        prgb[i].rgbReserved = 0;
    }
}


STDAPI_(void) AlphaStripRenderIcon(HDC hdc, int x, int y, HICON hicon, HDC hdcCompatible)
{
    HICON hiconRender = hicon;
    BOOL fAlpha = FALSE;
    ICONINFO ii;
    if (GetIconInfo(hicon, &ii))
    {
        BITMAP bm;
        GetObject(ii.hbmColor, sizeof(bm), &bm);

        HDC hdcNew = CreateCompatibleDC(hdcCompatible);  // hdc for a standard dc
        HDC hdcSrc = CreateCompatibleDC(hdcCompatible);
        if (hdcNew && hdcSrc)
        {
            RGBQUAD* prgb;
            HBITMAP hbmpNew = CreateDIB(hdc, 32, bm.bmWidth, bm.bmHeight, &prgb);

            if (hbmpNew)
            {
                HBITMAP hbmpDelete = hbmpNew;
                HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcNew, hbmpNew);
                HBITMAP hbmpOld2 = (HBITMAP)SelectObject(hdcSrc, ii.hbmColor);

                BitBlt(hdcNew, 0, 0, bm.bmWidth, bm.bmHeight, hdcSrc, 0, 0, SRCCOPY);

                if (HasAlpha(prgb, bm.bmWidth, bm.bmHeight))
                {
                    fAlpha = TRUE;
                    ProcessDIB(prgb, bm.bmWidth, bm.bmHeight);
                    hbmpDelete = ii.hbmColor;
                    ii.hbmColor = hbmpNew;
                }

                SelectObject(hdcSrc, hbmpOld2);
                SelectObject(hdcNew, hbmpOld);
                DeleteObject(hbmpDelete);
            }
        }

        if (hdcNew)
            DeleteDC(hdcNew);

        if (hdcSrc)
            DeleteDC(hdcSrc);

        hiconRender = CreateIconIndirect(&ii);

        DeleteObject(ii.hbmColor);
        DeleteObject(ii.hbmMask);
    }


    DrawIcon(hdc, x, y, hiconRender);

    if (hiconRender != hicon)
    {
        DestroyIcon(hiconRender);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\dspsprt.cpp ===
#include "stock.h"
#pragma hdrstop

#include "dspsprt.h"

#define TF_IDISPATCH 0

EXTERN_C HINSTANCE g_hinst;

CImpIDispatch::CImpIDispatch(REFGUID libid, USHORT wVerMajor, USHORT wVerMinor, REFIID riid) :
    m_libid(libid), m_wVerMajor(wVerMajor), m_wVerMinor(wVerMinor), m_riid(riid), m_pITINeutral(NULL)
{
    ASSERT(NULL == m_pITINeutral);
}

CImpIDispatch::~CImpIDispatch(void)
{
    ATOMICRELEASE(m_pITINeutral);
}

STDMETHODIMP CImpIDispatch::GetTypeInfoCount(UINT *pctInfo)
{
    *pctInfo = 1;
    return S_OK;
}

// helper function for pulling ITypeInfo out of our typelib
// Uncomment to force loading libid from the calling module: #define FORCE_LOCAL_LOAD
STDAPI GetTypeInfoFromLibId(LCID lcid, REFGUID libid, USHORT wVerMajor, USHORT wVerMinor, 
                            REFGUID uuid, ITypeInfo **ppITypeInfo)
{
    *ppITypeInfo = NULL;        // assume failure

    ITypeLib *pITypeLib;
    HRESULT hr;
    USHORT wResID;

    if (!IsEqualGUID(libid, GUID_NULL))
    {
        // The type libraries are registered under 0 (neutral),
        // 7 (German), and 9 (English) with no specific sub-
        // language, which would make them 407 or 409 and such.
        // If you are sensitive to sub-languages, then use the
        // full LCID instead of just the LANGID as done here.
#ifdef FORCE_LOCAL_LOAD
        hr = E_FAIL;    // force load through GetModuleFileName(), to get fusion 1.0 support
#else
        hr = LoadRegTypeLib(libid, wVerMajor, wVerMinor, PRIMARYLANGID(lcid), &pITypeLib);
#endif
        wResID = 0;
    }
    else
    {
        // If libid is GUID_NULL, then get type lib from module and use wVerMajor as
        // the resource ID (0 means use first type lib resource).
        pITypeLib = NULL;
        hr = E_FAIL;
        wResID = wVerMajor;
    }

    // If LoadRegTypeLib fails, try loading directly with LoadTypeLib.
    if (FAILED(hr) && g_hinst)
    {
        WCHAR wszPath[MAX_PATH];
        GetModuleFileNameWrapW(g_hinst, wszPath, ARRAYSIZE(wszPath));
        // Append resource ID to path, if specified.
        if (wResID)
        {
            WCHAR wszResStr[10];
            wnsprintfW(wszResStr, ARRAYSIZE(wszResStr), L"\\%d", wResID);
            StrCatBuffW(wszPath, wszResStr, ARRAYSIZE(wszPath));
        }
        
        switch (PRIMARYLANGID(lcid))
        {
        case LANG_NEUTRAL:
        case LANG_ENGLISH:
            hr = LoadTypeLib(wszPath, &pITypeLib);
            break;
        }
    }
    
    if (SUCCEEDED(hr))
    {
        // Got the type lib, get type info for the interface we want.
        hr = pITypeLib->GetTypeInfoOfGuid(uuid, ppITypeInfo);
        pITypeLib->Release();
    }
    return hr;
}


STDMETHODIMP CImpIDispatch::GetTypeInfo(UINT itInfo, LCID lcid, ITypeInfo **ppITypeInfo)
{
    *ppITypeInfo = NULL;

    if (0 != itInfo)
        return TYPE_E_ELEMENTNOTFOUND;

    // docs say we can ignore lcid if we support only one LCID
    // we don't have to return DISP_E_UNKNOWNLCID if we're *ignoring* it
    ITypeInfo **ppITI = &m_pITINeutral; // our cached typeinfo

    // Load a type lib if we don't have the information already.
    if (NULL == *ppITI)
    {
        ITypeInfo *pITIDisp;
        HRESULT hr = GetTypeInfoFromLibId(lcid, m_libid, m_wVerMajor, m_wVerMinor, m_riid, &pITIDisp);
        if (SUCCEEDED(hr))
        {
            // All our IDispatch implementations are DUAL. GetTypeInfoOfGuid
            // returns the ITypeInfo of the IDispatch-part only. We need to
            // find the ITypeInfo for the dual interface-part.
            //
            HREFTYPE hrefType;
            HRESULT hrT = pITIDisp->GetRefTypeOfImplType(0xffffffff, &hrefType);
            if (SUCCEEDED(hrT))
            {
                hrT = pITIDisp->GetRefTypeInfo(hrefType, ppITI);
            }

            if (FAILED(hrT))
            {
                // I suspect GetRefTypeOfImplType may fail if someone uses
                // CImpIDispatch on a non-dual interface. In this case the
                // ITypeInfo we got above is just fine to use.
                *ppITI = pITIDisp;
            }
            else
            {
                pITIDisp->Release();
            }
        }

        if (FAILED(hr))
            return hr;
    }

    (*ppITI)->AddRef();
    *ppITypeInfo = *ppITI;
    return S_OK;
}

STDMETHODIMP CImpIDispatch::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE;

    //Get the right ITypeInfo for lcid.
    ITypeInfo *pTI;
    HRESULT hr = GetTypeInfo(0, lcid, &pTI);
    if (SUCCEEDED(hr))
    {
        hr = pTI->GetIDsOfNames(rgszNames, cNames, rgDispID);
        pTI->Release();
    }

#ifdef DEBUG
    TCHAR szParam[MAX_PATH] = TEXT("");
    if (cNames >= 1)
        SHUnicodeToTChar(*rgszNames, szParam, ARRAYSIZE(szParam));

    TraceMsg(TF_IDISPATCH, "CImpIDispatch::GetIDsOfNames(%s = %x) called hres(%x)",
            szParam, *rgDispID, hr);
#endif
    return hr;
}

STDMETHODIMP CImpIDispatch::Invoke(DISPID dispID, REFIID riid, 
                                   LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams, 
                                   VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE; // riid is supposed to be IID_NULL always

    IDispatch *pdisp;
    HRESULT hr = QueryInterface(m_riid, (void **)&pdisp);
    if (SUCCEEDED(hr))
    {
        //Get the ITypeInfo for lcid
        ITypeInfo *pTI;
        hr = GetTypeInfo(0, lcid, &pTI);
        if (SUCCEEDED(hr))
        {
            SetErrorInfo(0, NULL);  //Clear exceptions
    
            // This is exactly what DispInvoke does--so skip the overhead.
            hr = pTI->Invoke(pdisp, dispID, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
            pTI->Release();
        }
        pdisp->Release();
    }
    return hr;
}

void CImpIDispatch::Exception(WORD wException)
{
    ASSERT(FALSE); // No one should call this yet
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\ieplaysound.cpp ===
#include "stock.h"
#pragma hdrstop

#include "w95wraps.h"

// we stick this function in a file all by itself so that the linker can strip it
// out if you don't call the IEPlaySound function.


STDAPI_(void) IEPlaySound(LPCTSTR pszSound, BOOL fSysSound)
{
    TCHAR szKey[256];

    // check the registry first
    // if there's nothing registered, we blow off the play,
    // but we don't set the MM_DONTLOAD flag so that if they register
    // something we will play it
    wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("AppEvents\\Schemes\\Apps\\%s\\%s\\.current"),
        (fSysSound ? TEXT(".Default") : TEXT("Explorer")), pszSound);

    TCHAR szFileName[MAX_PATH];
    szFileName[0] = 0;
    DWORD cbSize = sizeof(szFileName);

    // note the test for an empty string, PlaySound will play the Default Sound if we
    // give it a sound it cannot find...

    if ((SHGetValue(HKEY_CURRENT_USER, szKey, NULL, NULL, szFileName, &cbSize) == ERROR_SUCCESS)
        && cbSize && szFileName[0] != 0)
    {
        DWORD dwFlags = SND_FILENAME | SND_NODEFAULT | SND_ASYNC | SND_NOSTOP | SND_ALIAS;

        // This flag only works on Win95
        if (IsOS(OS_WIN95GOLD))
        {
            #define SND_LOPRIORITY 0x10000000l
            dwFlags |= SND_LOPRIORITY;
        }

        // Unlike SHPlaySound in shell32.dll, we get the registry value
        // above and pass it to PlaySound with SND_FILENAME instead of
        // SDN_APPLICATION, so that we play sound even if the application
        // is not Explroer.exe (such as IExplore.exe or WebBrowserOC).

#ifdef _X86_
        // only call the wrapper on x86 (doesn't exist on ia64)
        PlaySoundWrapW(szFileName, NULL, dwFlags);
#else
        PlaySound(szFileName, NULL, dwFlags);
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\isos.cpp ===
#include "stock.h"
#pragma hdrstop

// do this before we #include <isos.c> so the function name gets set properly
#define IsOS    staticIsOS

#include <isos.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\makefile.inc ===
#
# rules for compiling stocklib files
#
$(O)\shstra.cpp: ..\shstr.cpp
    echo #ifdef UNICODE > $@
    echo #undef UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

$(O)\shstrw.cpp: ..\shstr.cpp
    echo #ifndef UNICODE > $@
    echo #define UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

$(O)\dkaa.cpp: ..\dka.cpp
    echo #ifdef UNICODE > $@
    echo #undef UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

$(O)\dkaw.cpp: ..\dka.cpp
    echo #ifndef UNICODE > $@
    echo #define UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

$(O)\nativea.cpp: ..\native.cpp
    echo #ifdef UNICODE > $@
    echo #undef UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

$(O)\nativew.cpp: ..\native.cpp
    echo #ifndef UNICODE > $@
    echo #define UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

$(O)\infotipa.cpp: ..\infotip.cpp
    echo #ifdef UNICODE > $@
    echo #undef UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

$(O)\infotipw.cpp: ..\infotip.cpp
    echo #ifndef UNICODE > $@
    echo #define UNICODE >> $@
    echo #endif >> $@
    type $** >> $@

#
# copy the generated lib to shell\lib\$O so people can include it
#
$(CCSHELL_DIR)\lib\$(O)\$(TARGETNAME).lib: $(O)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\ieutil.cpp ===
#include "stock.h"
#pragma hdrstop

#include <varutil.h>
#include <shdocvw.h>

// Use this file to house browser-related utility functions

// -------------------------------------------------------------------
// ANSI/UNICODE-neutral functions
// these only need to be compiled once, so just do it UNICODE

#ifdef UNICODE

LPITEMIDLIST _ILCreateFromPathW(LPCWSTR pwszPath)
{
    // use this shdocvw export, this deals with down level shells and funky url parsing
    LPITEMIDLIST pidl;
    return SUCCEEDED(IEParseDisplayNameWithBCW(CP_ACP, pwszPath, NULL, &pidl)) ? pidl : NULL;
}

STDAPI_(LPITEMIDLIST) VariantToIDList(const VARIANT *pv)
{
    LPITEMIDLIST pidl = NULL;
    if (pv)
    {
        if (pv->vt == (VT_BYREF | VT_VARIANT) && pv->pvarVal)
            pv = pv->pvarVal;

        switch (pv->vt)
        {
        case VT_I2:
            pidl = SHCloneSpecialIDList(NULL, pv->iVal, TRUE);
            break;

        case VT_I4:
        case VT_UI4:
            if (pv->lVal < 0xFFFF)
            {
                pidl = SHCloneSpecialIDList(NULL, pv->lVal, TRUE);
            }
#ifndef _WIN64
            //We make sure we use it as a pointer only in Win32
            else
            {
                pidl = ILClone((LPCITEMIDLIST)pv->byref);    // HACK in process case, avoid the use of this if possible
            }
#endif // _WIN64
            break;

        //In Win64, the pidl variant could be 8 bytes long!
        case VT_I8:
        case VT_UI8:
            if(pv->ullVal < 0xFFFF)
            {
                pidl = SHCloneSpecialIDList(NULL, (int)pv->ullVal, TRUE);
            }
#ifdef _WIN64
            //We make sure we use it as a pointer only in Win64
            else
            {
                pidl = ILClone((LPCITEMIDLIST)pv->ullVal);    // HACK in process case, avoid the use of this if possible
            }
#endif //_WIN64
            break;

        case VT_BSTR:
            pidl = _ILCreateFromPathW(pv->bstrVal);
            break;

        case VT_ARRAY | VT_UI1:
            pidl = ILClone((LPCITEMIDLIST)pv->parray->pvData);
            break;

        case VT_DISPATCH | VT_BYREF:
            if (pv->ppdispVal)
                SHGetIDListFromUnk(*pv->ppdispVal, &pidl);
            break;

        case VT_DISPATCH:
            SHGetIDListFromUnk(pv->pdispVal, &pidl);
            break;
        }
    }
    return pidl;
}

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\mediautil.cpp ===
// mediautil.cpp: media bar utility routines

#include "stock.h"
#include "browseui.h"
#include "mediautil.h"

#define WZ_SMIE_MEDIA           TEXT("Software\\Microsoft\\Internet Explorer\\Media")
#define WZ_SMIE_MEDIA_MIME      TEXT("Software\\Microsoft\\Internet Explorer\\Media\\MimeTypes")
#define WZ_AUTOPLAY             TEXT("Autoplay")
#define WZ_AUTOPLAYPROMPT       TEXT("AutoplayPrompt")

#define MAX_REG_VALUE_LENGTH   50
#define MAX_MIME_LENGTH        256


static LPTSTR rgszMimeTypes[] = {
    TEXT("video/avi"),            
    TEXT("video/mpeg"),           
    TEXT("video/msvideo"),        
    TEXT("video/x-ivf"),          
    TEXT("video/x-mpeg"),         
    TEXT("video/x-mpeg2a"),       
    TEXT("video/x-ms-asf"),       
    TEXT("video/x-msvideo"),      
    TEXT("video/x-ms-wm"),        
    TEXT("video/x-ms-wmv"),       
    TEXT("video/x-ms-wvx"),       
    TEXT("video/x-ms-wmx"),       
    TEXT("video/x-ms-wmp"),       
    TEXT("audio/mp3"),            
    TEXT("audio/aiff"),           
    TEXT("audio/basic"),          
    TEXT("audio/mid"),            
    TEXT("audio/midi"),           
    TEXT("audio/mpeg"),           
    TEXT("audio/mpegurl"),           
    TEXT("audio/wav"),            
    TEXT("audio/x-aiff"),         
    TEXT("audio/x-mid"),         
    TEXT("audio/x-midi"),         
    TEXT("audio/x-mpegurl"),      
    TEXT("audio/x-ms-wax"),       
    TEXT("audio/x-ms-wma"),       
    TEXT("audio/x-background"),
    TEXT("audio/x-wav"),
    TEXT("midi/mid"),
    TEXT("application/x-ms-wmd")
};



//+----------------------------------------------------------------------------------------
// CMediaBarUtil Methods
//-----------------------------------------------------------------------------------------

HUSKEY
CMediaBarUtil::GetMediaRegKey()
{
    return OpenRegKey(WZ_SMIE_MEDIA);
}

HUSKEY  
CMediaBarUtil::OpenRegKey(TCHAR * pchName)
{
    HUSKEY hUSKey = NULL;

    if (pchName)
    {
        LONG lRet = SHRegCreateUSKey(
                                pchName,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hUSKey,
                                SHREGSET_HKCU);

        if ((ERROR_SUCCESS != lRet) || (NULL == hUSKey))
        {
            hUSKey = NULL;
            ASSERT(FALSE && L"couldn't open Key for registry settings");
        }
    }

    return hUSKey;
}

HRESULT
CMediaBarUtil::CloseRegKey(HUSKEY hUSKey)
{
    HRESULT hr = S_OK;

    if (hUSKey)
    {
        DWORD dwRet = SHRegCloseUSKey(hUSKey);
        if (ERROR_SUCCESS != dwRet)
        {
            ASSERT(FALSE && L"couldn't close Reg Key");
            hr = E_FAIL;
        }
    }

    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    IsRegValueTrue
//
//  Overview:  Check if given value is true
//
//  Arguments: [hUSKey]       Key to read from
//             [pchName]      name of the value to read out
//             [pfValue]      out param (true/false Reg value)
//
//  Returns:   S_FALSE if Value does not exist
//             S_OK otherwise
//
//------------------------------------------------------------------------
HRESULT CMediaBarUtil::IsRegValueTrue(HUSKEY hUSKey, TCHAR * pchName, BOOL *pfValue)
{
    DWORD   dwSize = MAX_REG_VALUE_LENGTH;
    DWORD   dwType;
    BYTE    bDataBuf[MAX_REG_VALUE_LENGTH];
    LONG    lRet;
    BOOL    bRet = FALSE;
    HRESULT hr = E_FAIL;

    if (!hUSKey || !pfValue || !pchName)
    {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto done;
    }

    lRet = SHRegQueryUSValue(hUSKey, 
                             pchName, 
                             &dwType, 
                             bDataBuf, 
                             &dwSize, 
                             FALSE, 
                             NULL, 
                             0);
                             
    if (ERROR_SUCCESS != lRet)
    {
        hr = S_FALSE;
        goto done;
    }

    if (REG_DWORD == dwType)
    {
        bRet = (*(DWORD*)bDataBuf != 0);
    }
    else if (REG_SZ == dwType)
    {
        TCHAR ch = (TCHAR)(*bDataBuf);

        if (TEXT('1') == ch ||
            TEXT('y') == ch ||
            TEXT('Y') == ch)
        {
            bRet = TRUE;
        }
        else
        {
            bRet = FALSE;
        }
    }
    else if (REG_BINARY == dwType)
    {
        bRet = (*(BYTE*)bDataBuf != 0);
    }
    
    hr = S_OK;
done:
    if (pfValue)
        *pfValue = bRet;
    return hr;
}

// Value is implicity TRUE, unless it exists and is set to FALSE
BOOL    
CMediaBarUtil::GetImplicitMediaRegValue(TCHAR * pchName)
{
    BOOL fRet = FALSE;
    
    if (pchName)
    {
        HUSKEY hMediaKey = GetMediaRegKey();
        if (hMediaKey)
        {
            BOOL fVal = FALSE;
            HRESULT hr = E_FAIL;

            hr = IsRegValueTrue(hMediaKey, pchName, &fVal);

            if ((S_OK == hr) && (FALSE == fVal))
            {
                fRet = FALSE;
            }
            else
            {
                // true if key is not present or explicitly set to true
                fRet = TRUE;
            }

            CloseRegKey(hMediaKey);
        }
    }

    return fRet;
}

BOOL    
CMediaBarUtil::GetAutoplay()
{
    return GetImplicitMediaRegValue(WZ_AUTOPLAY);
}

HRESULT CMediaBarUtil::SetMediaRegValue(LPWSTR pstrName, DWORD dwRegDataType, void * pvData, DWORD cbData, BOOL fMime /* = FALSE */)
{
    HRESULT hr = E_FAIL;

    if (pstrName && pvData && (cbData > 0))
    {
        HUSKEY hMediaKey = (fMime == TRUE) ? GetMimeRegKey() : GetMediaRegKey();

        if (hMediaKey)
        {
            LONG lRet = SHRegWriteUSValue(hMediaKey, 
                                          pstrName, 
                                          dwRegDataType, 
                                          pvData, 
                                          cbData, 
                                          SHREGSET_FORCE_HKCU); 
            if (ERROR_SUCCESS == lRet)
            {
                hr = S_OK;
            }
            else
            {
                ASSERT(FALSE && L"couldn't write reg value");
            }

            CloseRegKey(hMediaKey);
        }
    }

    return hr;
}

HUSKEY
CMediaBarUtil::GetMimeRegKey()
{
    return OpenRegKey(WZ_SMIE_MEDIA_MIME);
}

BOOL    
CMediaBarUtil::GetAutoplayPrompt()
{
    return GetImplicitMediaRegValue(WZ_AUTOPLAYPROMPT);
}

HRESULT 
CMediaBarUtil::ToggleAutoplayPrompting(BOOL fOn)
{
    HRESULT hr = E_FAIL;
    DWORD dwData = 0;
    
    dwData = (TRUE == fOn ? 0x1 : 0x0);

    hr = SetMediaRegValue(WZ_AUTOPLAYPROMPT, REG_BINARY, (void*) &dwData, (DWORD) 1); 

    return hr;
}


HRESULT 
CMediaBarUtil::ToggleAutoplay(BOOL fOn)
{
    HRESULT hr = E_FAIL;
    DWORD dwData = 0;
    
    dwData = (TRUE == fOn ? 0x1 : 0x0);

    hr = SetMediaRegValue(WZ_AUTOPLAY, REG_BINARY, (void*) &dwData, (DWORD) 1); 

    return hr;
}


BOOL    
CMediaBarUtil::IsRecognizedMime(TCHAR * szMime)
{
    BOOL fRet = FALSE;

    if (!szMime || !(*szMime))
        goto done;

    for (int i = 0; i < ARRAYSIZE(rgszMimeTypes); i++)
    {
        if (0 == StrCmpI(rgszMimeTypes[i], szMime))
        {
            fRet = TRUE;
            goto done;
        }
    }
    
done:
    return fRet;
}


// this function checks if the media bar should play this mime type
HRESULT
CMediaBarUtil::ShouldPlay(TCHAR * szMime, BOOL * pfShouldPlay)
{
    BOOL fRet = FALSE;
    HRESULT hr = E_FAIL;

    HUSKEY hKeyMime = GetMimeRegKey();
    if (!hKeyMime)
        goto done;

    // Bail if Autoplay is disabled
    if (FALSE == GetAutoplay())
    {
        goto done;
    }

    // bail if this is not a recognized mime type
    if (FALSE == IsRecognizedMime(szMime))
        goto done;

    // check if the user wants us to play everything 
    if (FALSE == GetAutoplayPrompt())
    {
        fRet = TRUE;
        hr = S_OK;
        goto done;
    }

    // see if user wants us to play this mime type
    hr = IsRegValueTrue(hKeyMime, szMime, &fRet);
    if (FAILED(hr))
        goto done;

    if (S_FALSE == hr)
    {
        // S_FALSE means we have not asked the user about this mime type.
        // Which means the media bar should get a crack at this file
        // and ask the user if it should play this file.
        fRet = TRUE;
    }

done:
    *pfShouldPlay = fRet;

    if (hKeyMime)
        CloseRegKey(hKeyMime);

    return hr;
}


BOOL 
CMediaBarUtil::IsWMP7OrGreaterInstalled()
{
    TCHAR szPath[50];
    szPath[0] = 0;
    DWORD dwType, cb = sizeof(szPath), dwInstalled=0, cb2=sizeof(dwInstalled);
    return ((ERROR_SUCCESS==SHGetValue(HKEY_LOCAL_MACHINE, REG_WMP8_STR, TEXT("version"), &dwType, szPath, &cb))
            && ((DWORD)(*szPath-TEXT('0'))>=7)
            && (ERROR_SUCCESS==SHGetValue(HKEY_LOCAL_MACHINE, REG_WMP8_STR, TEXT("IsInstalled"), &dwType, &dwInstalled, &cb2))
            && (dwInstalled==1));
}

typedef UINT (WINAPI *GetSystemWow64DirectoryPtr) (PSTR pszBuffer, UINT uSize);
typedef BOOL (WINAPI *IsNTAdmin) (DWORD, DWORD*);

BOOL 
CMediaBarUtil::IsWMP7OrGreaterCapable()
{
    static BOOL fInitialized = FALSE;
    static BOOL fCapable = TRUE;
    if (!fInitialized)
    {
        // WMP isn't supported on NT4, IA64, or DataCenter.
        // If WMP isn't already installed, and we're not running with admin privileges, we might as well fail
        // since we need WMP to function.

        fCapable = IsOS(OS_WIN2000ORGREATER);
        if (!fCapable)
        {
            fCapable = IsOS(OS_WIN98ORGREATER);
        }
        else
        {
            CHAR szPath[MAX_PATH];

            HMODULE hModule = GetModuleHandle(TEXT("kernel32.dll"));
            if (hModule)
            {
                GetSystemWow64DirectoryPtr func = (GetSystemWow64DirectoryPtr)GetProcAddress(hModule, "GetSystemWow64DirectoryA");
                fCapable = !(func && func(szPath, ARRAYSIZE(szPath)));
            }
            if (fCapable && !IsWMP7OrGreaterInstalled())
            {
                HMODULE hModule = LoadLibrary(TEXT("advpack.dll"));
                if (hModule)
                {
                    IsNTAdmin func = (IsNTAdmin)GetProcAddress(hModule, "IsNTAdmin");
                    fCapable = func && func(0, NULL);
                    FreeLibrary(hModule);
                }
            }            
        }
        if (IsOS(OS_DATACENTER))
        {
            fCapable = FALSE;
        }
        fInitialized = TRUE;
    }
    return fCapable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\native.cpp ===
//
//  native.cpp in shell\lib
//  
//  common Utility functions that need to be compiled for 
//  both UNICODE and ANSI
//
#include "stock.h"
#pragma hdrstop

#include "shellp.h"
#include <regstr.h>

// get the name and flags of an absolute IDlist
// in:
//      dwFlags     SHGDN_ flags as hints to the name space GetDisplayNameOf() function
//
// in/out:
//      *pdwAttribs (optional) return flags

STDAPI SHGetNameAndFlags(LPCITEMIDLIST pidl, DWORD dwFlags, LPTSTR pszName, UINT cchName, DWORD *pdwAttribs)
{
    if (pszName)
    {
        *pszName = 0;
    }

    HRESULT hrInit = SHCoInitialize();

    IShellFolder *psf;
    LPCITEMIDLIST pidlLast;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
    if (SUCCEEDED(hr))
    {
        if (pszName)
            hr = DisplayNameOf(psf, pidlLast, dwFlags, pszName, cchName);

        if (SUCCEEDED(hr) && pdwAttribs)
        {
            RIP(*pdwAttribs);    // this is an in-out param
            *pdwAttribs = SHGetAttributes(psf, pidlLast, *pdwAttribs);
        }

        psf->Release();
    }

    SHCoUninitialize(hrInit);
    return hr;
}

STDAPI_(DWORD) GetUrlScheme(LPCTSTR pszUrl)
{
    if (pszUrl)
    {
        PARSEDURL pu;
        pu.cbSize = sizeof(pu);
        if (SUCCEEDED(ParseURL(pszUrl, &pu)))
            return pu.nScheme;
    }
    return URL_SCHEME_INVALID;
}

//
//  returns
//
//      TRUE if the key is present and nonzero.
//      FALSE if the key is present and zero.
//      -1 if the key is not present.
//

BOOL GetExplorerUserSetting(HKEY hkeyRoot, LPCTSTR pszSubKey, LPCTSTR pszValue)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szPathExplorer[MAX_PATH];
    DWORD cbSize = ARRAYSIZE(szPath);
    DWORD dwType;

    PathCombine(szPathExplorer, REGSTR_PATH_EXPLORER, pszSubKey);
    if (ERROR_SUCCESS == SHGetValue(hkeyRoot, szPathExplorer, pszValue, 
            &dwType, szPath, &cbSize))
    {
        // Zero in the DWORD case or NULL in the string case
        // indicates that this item is not available.
        if (dwType == REG_DWORD)
            return *((DWORD*)szPath) != 0;
        else
            return (TCHAR)szPath[0] != 0;
    }

    return -1;
}

//
//  This function allows a feature to be controlled by both a user setting
//  or a policy restriction.  The policy restriction is first checked.
//
//  If the value is 1, then the action is restricted.
//  If the value is 2, then the action is allowed.
//  If the value is absent or 0, then we look at the user setting.
//
//  If the user setting is present, then ROUS_KEYALLOWS and ROUS_KEYRESTRICTS
//  controls the return value.  ROUS_KEYALLOWS means that a nonzero user
//  setting allows the action.  ROUS_KEYRESTRICTS means that a nonzero user
//  setting restricts the action.
//
//  If the user setting is absent, then ROUS_DEFAULTALLOW and
//  ROUS_DESFAULTRESTRICT controls the default return value.
//
STDAPI_(BOOL) IsRestrictedOrUserSetting(HKEY hkeyRoot, RESTRICTIONS rest, LPCTSTR pszSubKey, LPCTSTR pszValue, UINT flags)
{
    // See if the system policy restriction trumps

    DWORD dwRest = SHRestricted(rest);

    if (dwRest == 1)
        return TRUE;

    if (dwRest == 2)
        return FALSE;

    //
    //  Restriction not in place or defers to user setting.
    //
    BOOL fValidKey = GetExplorerUserSetting(hkeyRoot, pszSubKey, pszValue);

    switch (fValidKey)
    {
    case 0:     // Key is present and zero
        if (flags & ROUS_KEYRESTRICTS)
            return FALSE;       // restriction not present
        else
            return TRUE;        // ROUS_KEYALLOWS, value is 0 -> restricted

    case 1:     // Key is present and nonzero

        if (flags & ROUS_KEYRESTRICTS)
            return TRUE;        // restriction present -> restricted
        else
            return FALSE;       // ROUS_KEYALLOWS, value is 1 -> not restricted

    default:
        ASSERT(0);  // _GetExplorerUserSetting returns exactly 0, 1 or -1.
        // Fall through

    case -1:    // Key is not present
        return (flags & ROUS_DEFAULTRESTRICT);
    }

    /*NOTREACHED*/
}

//
// Repair font attributes that don't work on certain languages.
//
STDAPI_(void) SHAdjustLOGFONT(IN OUT LOGFONT *plf)
{
    ASSERT(plf);

    //
    // FE fonts don't look good in bold since the glyphs are intricate
    // and converting them to bold turns them into a black blob.
    //
    if (plf->lfCharSet == SHIFTJIS_CHARSET||
        plf->lfCharSet == HANGEUL_CHARSET ||
        plf->lfCharSet == GB2312_CHARSET  ||
        plf->lfCharSet == CHINESEBIG5_CHARSET)
    {
        if (plf->lfWeight > FW_NORMAL)
            plf->lfWeight = FW_NORMAL;
    }
}


//
//  Some of our registry keys were used prior to MUI, so for compat
//  reasons, apps have to put non-MUI strings there; otherwise,
//  downlevel clients will display at-signs which is kinda ugly.
//
//  So the solution for these keys is to store the non-MUI string
//  in the legacy location, but put the MUI version in the
//  "LocalizedString" value.
//
STDAPI SHLoadLegacyRegUIString(HKEY hk, LPCTSTR pszSubkey, LPTSTR pszOutBuf, UINT cchOutBuf)
{
    HKEY hkClose = NULL;

    ASSERT(cchOutBuf);
    pszOutBuf[0] = TEXT('\0');

    if (pszSubkey && *pszSubkey)
    {
        DWORD dwError = RegOpenKeyEx(hk, pszSubkey, 0, KEY_QUERY_VALUE, &hkClose);
        if (dwError != ERROR_SUCCESS)
        {
            return HRESULT_FROM_WIN32(dwError);
        }
        hk = hkClose;
    }

    HRESULT hr = SHLoadRegUIString(hk, TEXT("LocalizedString"), pszOutBuf, cchOutBuf);
    if (FAILED(hr) || pszOutBuf[0] == TEXT('\0'))
    {
        hr = SHLoadRegUIString(hk, TEXT(""), pszOutBuf, cchOutBuf);
    }

    if (hkClose)
    {
        RegCloseKey(hkClose);
    }

    return hr;
}

STDAPI_(TCHAR) SHFindMnemonic(LPCTSTR psz)
{
    ASSERT(psz);
    TCHAR tchDefault = *psz;                // Default is first character
    LPCTSTR pszAmp;

    while ((pszAmp = StrChr(psz, TEXT('&'))) != NULL)
    {
        switch (pszAmp[1])
        {
        case TEXT('&'):         // Skip over &&
            psz = pszAmp + 2;
            continue;

        case TEXT('\0'):        // Ignore trailing ampersand
            return tchDefault;

        default:
            return pszAmp[1];
        }
    }
    return tchDefault;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\infotip.cpp ===
//
//  infotip.cpp in shell\lib
//  
//  common Utility functions that need to be compiled for 
//  both UNICODE and ANSI
//
#include "stock.h"
#pragma hdrstop

#include "shellp.h"

BOOL GetInfoTipHelpEx(IShellFolder* psf, DWORD dwFlags, LPCITEMIDLIST pidl, LPTSTR pszText, int cchTextMax)
{
    BOOL fRet = FALSE;

    *pszText = 0;   // empty for failure

    if (pidl)
    {
        IQueryInfo *pqi;
        if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidl, IID_IQueryInfo, NULL, (void**)&pqi)))
        {
            WCHAR *pwszTip;
            if (SUCCEEDED(pqi->GetInfoTip(dwFlags, &pwszTip)) && pwszTip)
            {
                fRet = TRUE;
                SHUnicodeToTChar(pwszTip, pszText, cchTextMax);
                SHFree(pwszTip);
            }
            pqi->Release();
        }
    }
    return fRet;
}

BOOL GetInfoTipHelp(IShellFolder* psf, LPCITEMIDLIST pidl, LPTSTR pszText, int cchTextMax)
{
    return GetInfoTipHelpEx(psf, 0, pidl, pszText, cchTextMax);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\propertybag.cpp ===
#include "stock.h"
#pragma hdrstop



void SHPropertyBag_ReadStrDef(IPropertyBag* ppb, LPCWSTR pszPropName, LPWSTR psz, int cch, LPCWSTR pszDef)
{
    if (FAILED(SHPropertyBag_ReadStr(ppb, pszPropName, psz, cch)))
    {
        if (pszDef)
        {
            StrCpyNW(psz, pszDef, cch);
        }
        else
        {
            StrCpyNW(psz, L"", cch);
        }
    }
}

void SHPropertyBag_ReadIntDef(IPropertyBag* ppb, LPCWSTR pszPropName, int* piResult, int iDef)
{
    if (FAILED(SHPropertyBag_ReadInt(ppb, pszPropName, piResult)))
    {
        *piResult = iDef;
    }
}

void SHPropertyBag_ReadSHORTDef(IPropertyBag* ppb, LPCWSTR pszPropName, SHORT* psh, SHORT shDef)
{
    if (FAILED(SHPropertyBag_ReadSHORT(ppb, pszPropName, psh)))
    {
        *psh = shDef;
    }
}

void SHPropertyBag_ReadLONGDef(IPropertyBag* ppb, LPCWSTR pszPropName, LONG* pl, LONG lDef)
{
    if (FAILED(SHPropertyBag_ReadLONG(ppb, pszPropName, pl)))
    {
        *pl = lDef;
    }
}

void SHPropertyBag_ReadDWORDDef(IPropertyBag* ppb, LPCWSTR pszPropName, DWORD* pdw, DWORD dwDef)
{
    if (FAILED(SHPropertyBag_ReadDWORD(ppb, pszPropName, pdw)))
    {
        *pdw = dwDef;
    }
}

void SHPropertyBag_ReadBOOLDef(IPropertyBag* ppb, LPCWSTR pszPropName, BOOL* pf, BOOL fDef)
{
    if (FAILED(SHPropertyBag_ReadBOOL(ppb, pszPropName, pf)))
    {
        *pf = fDef;
    }
}

BOOL SHPropertyBag_ReadBOOLDefRet(IPropertyBag* ppb, LPCWSTR pszPropName, BOOL fDef)
{
    BOOL fRet;

    SHPropertyBag_ReadBOOLDef(ppb, pszPropName, &fRet, fDef);

    return fRet;
}

void SHPropertyBag_ReadGUIDDef(IPropertyBag* ppb, LPCWSTR pszPropName, GUID* pguid, const GUID* pguidDef)
{
    if (FAILED(SHPropertyBag_ReadGUID(ppb, pszPropName, pguid)))
    {
        *pguid = *pguidDef;
    }
}

void SHPropertyBag_ReadPOINTLDef(IPropertyBag* ppb, LPCWSTR pszPropName, POINTL* ppt, const POINTL* pptDef)
{
    if (FAILED(SHPropertyBag_ReadPOINTL(ppb, pszPropName, ppt)))
    {
        *ppt = *pptDef;
    }
}

void SHPropertyBag_ReadPOINTSDef(IPropertyBag* ppb, LPCWSTR pszPropName, POINTS* ppt, const POINTS* pptDef)
{
    if (FAILED(SHPropertyBag_ReadPOINTS(ppb, pszPropName, ppt)))
    {
        *ppt = *pptDef;
    }
}

void SHPropertyBag_ReadRECTLDef(IPropertyBag* ppb, LPCWSTR pszPropName, RECTL* prc, const RECTL* prcDef)
{
    if (FAILED(SHPropertyBag_ReadRECTL(ppb, pszPropName, prc)))
    {
        *prc = *prcDef;
    }
}

void AppendScreenResString(const WCHAR* psz, WCHAR* pszBuff, ULONG cchBuff)
{
    StrCpyNW(pszBuff, psz, cchBuff);
    ULONG cch = lstrlenW(pszBuff);
    SHGetPerScreenResName(pszBuff + cch, cchBuff- cch, 0);
}

HRESULT SHPropertyBag_ReadStreamScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, IStream** ppstm)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_ReadStream(ppb, szScreenResProp, ppstm);
}

HRESULT SHPropertyBag_WriteStreamScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, IStream* pstm)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_WriteStream(ppb, szScreenResProp, pstm);
}

HRESULT SHPropertyBag_ReadPOINTSScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, POINTS* ppt)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_ReadPOINTS(ppb, szScreenResProp, ppt);
}

HRESULT SHPropertyBag_WritePOINTSScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, const POINTS* ppt)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_WritePOINTS(ppb, szScreenResProp, ppt);
}

void SHPropertyBag_ReadDWORDScreenResDef(IPropertyBag* ppb, LPCWSTR pszPropName, DWORD* pdw, DWORD dw)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    SHPropertyBag_ReadDWORDDef(ppb, szScreenResProp, pdw, dw);
}

HRESULT SHPropertyBag_WriteDWORDScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, const DWORD dw)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_WriteDWORD(ppb, szScreenResProp, dw);
}

HRESULT SHPropertyBag_ReadPOINTLScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, POINTL* ppt)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_ReadPOINTL(ppb, szScreenResProp, ppt);
}

HRESULT SHPropertyBag_WritePOINTLScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, const POINTL* ppt)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_WritePOINTL(ppb, szScreenResProp, ppt);
}

HRESULT SHPropertyBag_ReadRECTLScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, RECTL* prc)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_ReadRECTL(ppb, szScreenResProp, prc);
}

HRESULT SHPropertyBag_WriteRECTLScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, const RECTL* prc)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_WriteRECTL(ppb, szScreenResProp, prc);
}

HRESULT SHPropertyBag_DeleteScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName)
{
    WCHAR szScreenResProp[128];
    AppendScreenResString(pszPropName, szScreenResProp, ARRAYSIZE(szScreenResProp));

    return SHPropertyBag_Delete(ppb, szScreenResProp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\profsvc.cpp ===
#include "stock.h"
#pragma hdrstop

#include <profsvc.h>

typedef struct
{
    IServiceProvider *psp;
    GUID guidService;
    DWORD dwCookie;
} SERVICE_ITEM;

#define _Item(i)    (_hdsa ? (SERVICE_ITEM *)DSA_GetItemPtr(_hdsa, i) : NULL)
#define _Count()   (_hdsa ? DSA_GetItemCount(_hdsa) : 0)

IProfferServiceImpl::IProfferServiceImpl() :
    _hdsa(NULL),
    _dwNextCookie(0)
{
}

IProfferServiceImpl::~IProfferServiceImpl()
{
    for (int i = 0; i < _Count(); i++)
    {
        SERVICE_ITEM *psi = _Item(i);
        if (psi)
        {
            IUnknown_Set((IUnknown **)&psi->psp, NULL);
        }
    }

    DSA_Destroy(_hdsa);
}

HRESULT IProfferServiceImpl::ProfferService(REFGUID rguidService, IServiceProvider *psp, DWORD *pdwCookie)
{
    HRESULT hr;

    if (!_hdsa)
    {
        _hdsa = DSA_Create(sizeof(SERVICE_ITEM), 4);
    }

    SERVICE_ITEM si;
    
    si.psp = psp;
    si.guidService = rguidService;
    si.dwCookie = ++_dwNextCookie;  // start at 1

    if (_hdsa && (-1 != DSA_AppendItem(_hdsa, &si)))
    {
        psp->AddRef();
        *pdwCookie = si.dwCookie;
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT IProfferServiceImpl::RevokeService(DWORD dwCookie)
{
    HRESULT hr = E_INVALIDARG;  // not found

    for (int i = 0; i < _Count(); i++)
    {
        SERVICE_ITEM *psi = _Item(i);
        if (psi && (psi->dwCookie == dwCookie))
        {
            IUnknown_Set((IUnknown **)&psi->psp, NULL);
            DSA_DeleteItem(_hdsa, i);
            hr = S_OK;  // successful revoke
            break;
        }
    }
    return hr;
}

HRESULT IProfferServiceImpl::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;    // did not find the service object

    *ppv = NULL;

    for (int i = 0; i < _Count(); i++)
    {
        SERVICE_ITEM *psi = _Item(i);
        if (psi && IsEqualGUID(psi->guidService, guidService))
        {
            hr = psi->psp->QueryService(guidService, riid, ppv);
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\runtask.cpp ===
#include "stock.h"
#pragma hdrstop

#include "runtask.h"

#define SUPERCLASS  

// #define TF_RUNTASK  TF_GENERAL
#define TF_RUNTASK  0
// #define TF_RUNTASKV TF_CUSTOM1     // verbose version
#define TF_RUNTASKV 0


// constructor
CRunnableTask::CRunnableTask(DWORD dwFlags)
{
    _lState = IRTIR_TASK_NOT_RUNNING;
    _dwFlags = dwFlags;

    ASSERT(NULL == _hDone);
    
    if (_dwFlags & RTF_SUPPORTKILLSUSPEND)
    {
        // we signal this on suspend or kill
        // Explicitly call the ANSI version so we don't need to worry
        // about whether we're being built UNICODE and have to switch
        // to a wrapper function...
        _hDone = CreateEventA(NULL, TRUE, FALSE, NULL);
    }

#ifdef DEBUG
    _dwTaskID = GetTickCount();

    TraceMsg(TF_RUNTASK, "CRunnableTask (%#lx): creating task", _dwTaskID);
#endif

    _cRef = 1;
}


// destructor
CRunnableTask::~CRunnableTask()
{
    DEBUG_CODE( TraceMsg(TF_RUNTASK, "CRunnableTask (%#lx): deleting task", _dwTaskID); )

    if (_hDone)
        CloseHandle(_hDone);
}


STDMETHODIMP CRunnableTask::QueryInterface( REFIID riid, LPVOID * ppvObj )
{
    if ( ppvObj == NULL )
    {
        return E_INVALIDARG;
    }
    if ( riid == IID_IRunnableTask )
    {
        *ppvObj = SAFECAST( this, IRunnableTask *);
        AddRef();
    }
    else
        return E_NOINTERFACE;


    return NOERROR;
}


STDMETHODIMP_(ULONG) CRunnableTask::AddRef()
{
    return InterlockedIncrement(&_cRef);
}


STDMETHODIMP_ (ULONG) CRunnableTask::Release()
{
    AssertMsg( 0 != _cRef, TEXT("RefCount problem.") );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


/*----------------------------------------------------------
Purpose: IRunnableTask::Run method

         This does a lot of the state-related work, and then
         calls the derived-class's RunRT() method.
         
*/
STDMETHODIMP CRunnableTask::Run(void)
{
    HRESULT hr = E_FAIL;

    // Are we already running?
    if (_lState == IRTIR_TASK_RUNNING)
    {
        // Yes; nothing to do 
        hr = S_FALSE;
    }
    else if ( _lState == IRTIR_TASK_PENDING )
    {
        hr = E_FAIL;
    }
    else if ( _lState == IRTIR_TASK_NOT_RUNNING )
    {
        // Say we're running
        LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_RUNNING);
        if ( lRes == IRTIR_TASK_PENDING )
        {
            _lState = IRTIR_TASK_FINISHED;
            return NOERROR;
        }

        if (_lState == IRTIR_TASK_RUNNING)
        {
            // Prepare to run 
            DEBUG_CODE( TraceMsg(TF_RUNTASKV, "CRunnableTask (%#lx): initialize to run", _dwTaskID); )
            
            hr = RunInitRT();
            
            ASSERT(E_PENDING != hr);
        }

        if (SUCCEEDED(hr))
        {
            if (_lState == IRTIR_TASK_RUNNING)
            {
                // Continue to do the work
                hr = InternalResumeRT();
            }
            else if (_lState == IRTIR_TASK_SUSPENDED)
            {
                // it is possible that RunInitRT took a little longer to complete and our state changed
                // from running to suspended with _hDone signaled, which would cause us to not call
                // internal resume.  We simulate internal resume here
                if (_hDone)
                    ResetEvent(_hDone);
                hr = E_PENDING;
            }
        }

        if (FAILED(hr) && E_PENDING != hr)
        {
            DEBUG_CODE( TraceMsg(TF_WARNING, "CRunnableTask (%#lx): task failed to run: %#lx", _dwTaskID, hr); )
        }            

        // Are we finished?
        if (_lState != IRTIR_TASK_SUSPENDED || hr != E_PENDING)
        {
            // Yes
            _lState = IRTIR_TASK_FINISHED;
        }
    }
    
    return hr;
}


/*----------------------------------------------------------
Purpose: IRunnableTask::Kill method

*/
STDMETHODIMP CRunnableTask::Kill(BOOL fWait)
{
    if ( !(_dwFlags & RTF_SUPPORTKILLSUSPEND) )
        return E_NOTIMPL;
        
    if (_lState != IRTIR_TASK_RUNNING)
        return S_FALSE;

    DEBUG_CODE( TraceMsg(TF_RUNTASKV, "CRunnableTask (%#lx): killing task", _dwTaskID); )

    LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_PENDING);
    if (lRes == IRTIR_TASK_FINISHED)
    {
        DEBUG_CODE( TraceMsg(TF_RUNTASKV, "CRunnableTask (%#lx): task already finished", _dwTaskID); )

        _lState = lRes;
    }
    else if (_hDone)
    {
        // signal the event it is likely to be waiting on
        SetEvent(_hDone);
    }

    return KillRT(fWait);
}


/*----------------------------------------------------------
Purpose: IRunnableTask::Suspend method

*/
STDMETHODIMP CRunnableTask::Suspend( void )
{
    if ( !(_dwFlags & RTF_SUPPORTKILLSUSPEND) )
        return E_NOTIMPL;
        
    if (_lState != IRTIR_TASK_RUNNING)
        return E_FAIL;
    
    DEBUG_CODE( TraceMsg(TF_RUNTASKV, "CRunnableTask (%#lx): suspending task", _dwTaskID); )
    
    LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_SUSPENDED);

    if (IRTIR_TASK_FINISHED == lRes)
    {
        // we finished before we could suspend
        DEBUG_CODE( TraceMsg(TF_RUNTASKV, "CRunnableTask (%#lx): task already finished", _dwTaskID); )
        
        _lState = lRes;
        return NOERROR;
    }

    if (_hDone)
        SetEvent(_hDone);

    return SuspendRT();
}


/*----------------------------------------------------------
Purpose: IRunnableTask::Resume method

*/
STDMETHODIMP CRunnableTask::Resume(void)
{
    if (_lState != IRTIR_TASK_SUSPENDED)
        return E_FAIL;

    DEBUG_CODE( TraceMsg(TF_RUNTASKV, "CRunnableTask (%#lx): resuming task", _dwTaskID); )

    _lState = IRTIR_TASK_RUNNING;
    if (_hDone)
        ResetEvent(_hDone);

    return ResumeRT();
}


/*----------------------------------------------------------
Purpose: IRunnableTask::IsRunning method

*/
STDMETHODIMP_( ULONG ) CRunnableTask:: IsRunning ( void )
{
    return _lState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\rpctimeout.cpp ===
#include "stock.h"
#pragma hdrstop

#include "rpctimeout.h"

WINOLEAPI CoCancelCall(IN DWORD dwThreadId, IN ULONG ulTimeout);
WINOLEAPI CoEnableCallCancellation(IN LPVOID pReserved);
WINOLEAPI CoDisableCallCancellation(IN LPVOID pReserved);

void CRPCTimeout::_Callback(PVOID lpParameter, BOOLEAN)
{
    CRPCTimeout *self = reinterpret_cast<CRPCTimeout *>(lpParameter);
    if (SUCCEEDED(CoCancelCall(self->_dwThreadId, 0)))
    {
        self->_fTimedOut = TRUE;
    }
}

#define DEFAULT_RPCTIMEOUT      5000        // totally arbitrary number
#define REPEAT_RPCTIMEOUT       1000        // Re-cancel every second until disarmed

void CRPCTimeout::Init()
{
    _dwThreadId = GetCurrentThreadId();
    _fTimedOut = FALSE;
    _hrCancelEnabled = E_FAIL;
    _hTimer = NULL;
}

void CRPCTimeout::Arm(DWORD dwTimeout)
{
    Disarm();

    if (dwTimeout == 0)
    {
        dwTimeout = DEFAULT_RPCTIMEOUT;
    }


    // If this fails, then we don't get a cancel thingie; oh well.
    _hrCancelEnabled = CoEnableCallCancellation(NULL);
    if (SUCCEEDED(_hrCancelEnabled))
    {
        _hTimer = SHSetTimerQueueTimer(NULL, _Callback, this,
                                       dwTimeout, REPEAT_RPCTIMEOUT, NULL, 0);
    }
}

void CRPCTimeout::Disarm()
{
    if (SUCCEEDED(_hrCancelEnabled))
    {
        _hrCancelEnabled = E_FAIL;
        CoDisableCallCancellation(NULL);

        if (_hTimer)
        {
            SHCancelTimerQueueTimer(NULL, _hTimer);
            _hTimer = NULL;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\setmodebias.cpp ===
//----------------------------------------------------------------------
// SetModeBias.cpp
//
// Utility function to set to input bias mode
//
#include "stock.h"
#pragma hdrstop
#include <imm.h>

//----------------------------------------------------------------------
void SetModeBias(DWORD dwMode)
{
    if (IsOS(OS_TABLETPC))
    {
        static UINT s_msgMSIMEModeBias = 0;
        HWND hwndIME = ImmGetDefaultIMEWnd(NULL);

        if (s_msgMSIMEModeBias == 0)
        {
            s_msgMSIMEModeBias = RegisterWindowMessage(RWM_MODEBIAS);
        }

        if (hwndIME && s_msgMSIMEModeBias)
        {
            PostMessage(hwndIME, s_msgMSIMEModeBias, MODEBIAS_SETVALUE, dwMode);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\reg.cpp ===
#include "stock.h"




/////////////////////////////////////////////////////////////////////////////
//
//
//  SHRegSubKeyExists
//
//


STDAPI_(BOOL)
SHRegSubKeyExistsA(
    IN  HKEY    hkey,
    IN  LPCSTR  pszSubKey)
{
    LONG lr;

    HKEY hkSubKey;
    lr = RegOpenKeyExA(hkey, pszSubKey, 0, KEY_QUERY_VALUE, &hkSubKey);
    if (lr == ERROR_SUCCESS)
    {
        RegCloseKey(hkSubKey);
    }

    return lr == ERROR_SUCCESS;
}


STDAPI_(BOOL)
SHRegSubKeyExistsW(
    IN  HKEY    hkey,
    IN  LPCWSTR pwszSubKey)
{
    BOOL br = FALSE;

    if (IsOS(OS_NT))
    {
        HKEY hkSubKey;
        if (ERROR_SUCCESS == RegOpenKeyExW(hkey, pwszSubKey, 0, KEY_QUERY_VALUE, &hkSubKey))
        {
            RegCloseKey(hkSubKey);
            br = TRUE;
        }
    }
    else
    {
        // Thunk...
        CHAR szSubKey[MAX_PATH];
        if (0 != WideCharToMultiByte(CP_ACP, 0, pwszSubKey, -1, szSubKey, sizeof(szSubKey), NULL, NULL))
        {
            br = SHRegSubKeyExistsA(hkey, szSubKey);
        }
    }

    return br;
}




/////////////////////////////////////////////////////////////////////////////
//
//
//  SHRegGetDWORD
//
//


STDAPI
SHRegGetDWORDA(
    IN      HKEY    hkey,
    IN      PCSTR   pszSubKey,  // OPTIONAL:  NULL or "" ok
    IN      PCSTR   pszValue,   // OPTIONAL:  NULL or "" ok
    OUT     DWORD * pdwData)
{
    LONG lr;

    if (hkey && pdwData)
    {
        DWORD cbData = sizeof(DWORD);
        lr = SHRegGetValueA(hkey, pszSubKey, pszValue, SRRF_RT_REG_DWORD, NULL, pdwData, &cbData);
    }
    else
    {
        RIPMSG(!!hkey,      "SHRegGetDWORDA: caller passed null hkey!");
        RIPMSG(!!pdwData,   "SHRegGetDWORDA: caller passed null pdwData!");
        lr = ERROR_INVALID_PARAMETER;
    }

    ASSERT(lr != ERROR_MORE_DATA); // Sanity check.

    return HRESULT_FROM_WIN32(lr);
}


STDAPI
SHRegGetDWORDW(
    IN      HKEY    hkey,
    IN      PCWSTR  pwszSubKey, // OPTIONAL:  NULL or "" ok
    IN      PCWSTR  pwszValue,  // OPTIONAL:  NULL or "" ok
    OUT     DWORD * pdwData)
{
    LONG lr;

    if (hkey && pdwData)
    {
        DWORD cbData = sizeof(DWORD);
        lr = SHRegGetValueW(hkey, pwszSubKey, pwszValue, SRRF_RT_REG_DWORD, NULL, pdwData, &cbData);
    }
    else
    {
        RIPMSG(!!hkey,      "SHRegGetDWORDW: caller passed null hkey!");
        RIPMSG(!!pdwData,   "SHRegGetDWORDW: caller passed null pdwData!");
        lr = ERROR_INVALID_PARAMETER;
    }

    ASSERT(lr != ERROR_MORE_DATA); // Sanity check.

    return HRESULT_FROM_WIN32(lr);
}




/////////////////////////////////////////////////////////////////////////////
//
//
//  SHRegGetString
//
//


STDAPI
SHRegGetStringA(
    IN      HKEY    hkey,
    IN      PCSTR   pszSubKey,  // OPTIONAL:  NULL or "" ok
    IN      PCSTR   pszValue,   // OPTIONAL:  NULL or "" ok
    OUT     PSTR    pszData,
    IN      DWORD   cchData)
{
    LONG lr;

    if (hkey && pszData && cchData > 0)
    {
        DWORD cbData = cchData * sizeof(CHAR);
        lr = SHRegGetValueA(hkey, pszSubKey, pszValue, SRRF_RT_REG_SZ, NULL, pszData, &cbData);
    }
    else
    {
        RIPMSG(!!hkey,      "SHRegGetStringA: caller passed null hkey!");
        RIPMSG(!!pszData,   "SHRegGetStringA: caller passed null pszData!");
        RIPMSG(cchData > 0, "SHRegGetStringA: caller passed pszData of 0 size!");
        lr = ERROR_INVALID_PARAMETER;
    }

    if (lr != ERROR_SUCCESS && pszData && cchData > 0)
    {
        pszData[0] = '\0';
    }

    return HRESULT_FROM_WIN32(lr);
}

STDAPI
SHRegGetStringW(
    IN      HKEY    hkey,
    IN      PCWSTR  pwszSubKey, // OPTIONAL:  NULL or "" ok
    IN      PCWSTR  pwszValue,  // OPTIONAL:  NULL or "" ok
    OUT     PWSTR   pwszData,
    IN      DWORD   cchData)
{
    LONG lr;

    if (hkey && pwszData && cchData > 0)
    {
        DWORD cbData = cchData * sizeof(WCHAR);
        lr = SHRegGetValueW(hkey, pwszSubKey, pwszValue, SRRF_RT_REG_SZ, NULL, pwszData, &cbData);
    }
    else
    {
        RIPMSG(!!hkey,      "SHRegGetStringW: caller passed null hkey!");
        RIPMSG(!!pwszData,  "SHRegGetStringW: caller passed null pwszData!");
        RIPMSG(cchData > 0, "SHRegGetStringW: caller passed pszData of 0 size!");
        lr = ERROR_INVALID_PARAMETER;
    }

    if (lr != ERROR_SUCCESS && pwszData && cchData > 0)
    {
        pwszData[0] = L'\0';
    }

    return HRESULT_FROM_WIN32(lr);
}




/////////////////////////////////////////////////////////////////////////////
//
//
//  SHRegAllocString (use CoTaskMemFree() to free returned string on S_OK)
//
//


STDAPI
SHRegAllocStringA(
    IN      HKEY    hkey,
    IN      PCSTR   pszSubKey,  // OPTIONAL:  NULL or "" ok
    IN      PCSTR   pszValue,   // OPTIONAL:  NULL or "" ok
    OUT     PSTR *  ppszData)
{
    LONG lr;

    if (hkey && ppszData)
    {
        CHAR  szData[128]; // perf: best guess for average case
        DWORD cbData = sizeof(szData);
        lr = SHRegGetValueA(hkey, pszSubKey, pszValue, SRRF_RT_REG_SZ, NULL, szData, &cbData);
        if (lr == ERROR_SUCCESS || lr == ERROR_MORE_DATA)
        {
            *ppszData = (PSTR)CoTaskMemAlloc(cbData);
            if (*ppszData)
            {
                if (lr == ERROR_SUCCESS)
                {
                    memcpy(ppszData, szData, cbData);
                }
                else if (SHRegGetValueA(hkey, pszSubKey, pszValue, SRRF_RT_REG_SZ, NULL, szData, &cbData) != ERROR_SUCCESS)
                {
                    lr = ERROR_CAN_NOT_COMPLETE;
                    CoTaskMemFree(*ppszData);
                }
            }
            else
            {
                lr = ERROR_OUTOFMEMORY;
            }
        }
    }
    else
    {
        RIPMSG(!!hkey,      "SHRegAllocStringA: caller passed null hkey!");
        RIPMSG(!!ppszData,  "SHRegAllocStringA: caller passed null ppszData!");
        lr = ERROR_INVALID_PARAMETER;
    }

    if (lr != ERROR_SUCCESS && ppszData != NULL)
    {
        *ppszData = NULL;
    }

    return HRESULT_FROM_WIN32(lr);
}

STDAPI
SHRegAllocStringW(
    IN      HKEY    hkey,
    IN      PCWSTR  pwszSubKey, // OPTIONAL:  NULL or "" ok
    IN      PCWSTR  pwszValue,  // OPTIONAL:  NULL or "" ok
    OUT     PWSTR * ppwszData)
{
    LONG lr;

    if (hkey && ppwszData)
    {
        WCHAR wszData[128]; // perf: best guess for average case
        DWORD cbData = sizeof(wszData);
        lr = SHRegGetValueW(hkey, pwszSubKey, pwszValue, SRRF_RT_REG_SZ, NULL, wszData, &cbData);
        if (lr == ERROR_SUCCESS || lr == ERROR_MORE_DATA)
        {
            *ppwszData = (PWSTR)CoTaskMemAlloc(cbData);
            if (*ppwszData)
            {
                if (lr == ERROR_SUCCESS)
                {
                    memcpy(ppwszData, wszData, cbData);
                }
                else if (SHRegGetValueW(hkey, pwszSubKey, pwszValue, SRRF_RT_REG_SZ, NULL, wszData, &cbData) != ERROR_SUCCESS)
                {
                    lr = ERROR_CAN_NOT_COMPLETE;
                    CoTaskMemFree(*ppwszData);
                }
            }
            else
            {
                lr = ERROR_OUTOFMEMORY;
            }
        }
    }
    else
    {
        RIPMSG(!!hkey,      "SHRegAllocStringW: caller passed null hkey!");
        RIPMSG(!!ppwszData, "SHRegAllocStringW: caller passed null ppwszData!");
        lr = ERROR_INVALID_PARAMETER;
    }

    if (lr != ERROR_SUCCESS && ppwszData != NULL)
    {
        *ppwszData = NULL;
    }

    return HRESULT_FROM_WIN32(lr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\shco.c ===
#include "stock.h"
#pragma hdrstop

// Need to put into separate file because for some reason the /Gy compiler
// option doesn't work.

//
//  COM Initialization is weird due to multithreaded apartments.
//
//  If this thread has not called CoInitialize yet, but some other thread
//  in the process has called CoInitialize with the COINIT_MULTITHREADED,
//  then that infects our thread with the multithreaded virus, and a
//  COINIT_APARTMENTTHREADED will fail.
//
//  In this case, we must turn around and re-init ourselves as
//  COINIT_MULTITHREADED to increment the COM refcount on our thread.
//  If we didn't do that, and that other thread decided to do a
//  CoUninitialize, that >secretly< uninitializes COM on our own thread
//  and we fall over and die.
//
STDAPI SHCoInitialize(void)
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    if (FAILED(hr))
    {
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\security.cpp ===
/*****************************************************************************\
    FILE: security.cpp

    DESCRIPTION:
        Helpers functions to check if an Automation interface or ActiveX Control
    is hosted or used by a safe caller.

    BryanSt 8/25/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/
#include "stock.h"
#pragma hdrstop

#include <mshtml.h>


/***************************************************************\
    DESCRIPTION:
        We are given a site via IObjectWithSite.  Obtain the hosting
    IHTMLDocument from there.  This is typically used to get a URL from
    in order to check zones or ProcessUrlAction() attributes, or if there are
    two URLs you can compare their zones from cross-zone restrictions.
\***************************************************************/
STDAPI GetHTMLDoc2(IUnknown *punk, IHTMLDocument2 **ppHtmlDoc)
{
    *ppHtmlDoc = NULL;

    if (!punk)
        return E_FAIL;
        
    *ppHtmlDoc = NULL;
    //  The window.external, jscript "new ActiveXObject" and the <OBJECT> tag
    //  don't take us down the same road.

    IOleClientSite *pClientSite;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IOleClientSite, &pClientSite));
    if (SUCCEEDED(hr))
    {
        //  <OBJECT> tag path
        IOleContainer *pContainer;

        // This will return the interface for the current FRAME containing the
        // OBJECT tag.  We will only check that frames security because we
        // rely on MSHTML to block cross frame scripting when it isn't safe.
        hr = pClientSite->GetContainer(&pContainer);
        if (SUCCEEDED(hr))
        {
            hr = pContainer->QueryInterface(IID_PPV_ARG(IHTMLDocument2, ppHtmlDoc));
            pContainer->Release();
        }
    
        if (FAILED(hr))
        {
            //  window.external path
            IWebBrowser2 *pWebBrowser2;
            hr = IUnknown_QueryService(pClientSite, SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, &pWebBrowser2));
            if (SUCCEEDED(hr))
            {
                IDispatch *pDispatch;
                hr = pWebBrowser2->get_Document(&pDispatch);
                if (SUCCEEDED(hr))
                {
                    hr = pDispatch->QueryInterface(IID_PPV_ARG(IHTMLDocument2, ppHtmlDoc));
                    pDispatch->Release();
                }
                pWebBrowser2->Release();
            }
        }
        pClientSite->Release();
    }
    else
    {
        //  jscript path
        hr = IUnknown_QueryService(punk, SID_SContainerDispatch, IID_PPV_ARG(IHTMLDocument2, ppHtmlDoc));
    }

    ASSERT(FAILED(hr) || (*ppHtmlDoc));

    return hr;
}


/***************************************************************\
    DESCRIPTION:
        This function is supposed to find out the zone from the
    specified URL or Path.
\***************************************************************/
STDAPI LocalZoneCheckPath(LPCWSTR pszUrl, IUnknown * punkSite)
{
    DWORD dwZoneID = URLZONE_UNTRUSTED;
    HRESULT hr = GetZoneFromUrl(pszUrl, punkSite, &dwZoneID);
    
    if (SUCCEEDED(hr))
    {
        if (dwZoneID == URLZONE_LOCAL_MACHINE)
            hr = S_OK;
        else
            hr = E_ACCESSDENIED;
    }

    return hr;
}

/***************************************************************\
    DESCRIPTION:
        Get the zone from the specified URL or Path.
\***************************************************************/
STDAPI GetZoneFromUrl(LPCWSTR pszUrl, IUnknown * punkSite, DWORD * pdwZoneID)
{
    HRESULT hr = E_FAIL;
    if (pszUrl && pdwZoneID) 
    {
        IInternetSecurityManager * pSecMgr = NULL;

        // WARNING: IInternetSecurityManager is the guy who translates
        //   from URL->Zone.  If we CoCreate this object, it will do the
        //   default mapping.  Some hosts, like Outlook Express, want to
        //   over ride the default mapping in order to sandbox some content.
        //   I beleive this could be used to force HTML in an email
        //   message (C:\mailmessage.eml) to act like it's from a more
        //   untrusted zone.  We use QueryService to get this interface
        //   from our host.  This info is from SanjayS. (BryanSt 8/21/1999)
        hr = IUnknown_QueryService(punkSite, SID_SInternetSecurityManager, IID_PPV_ARG(IInternetSecurityManager, &pSecMgr));
        if (FAILED(hr))
        {
            hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IInternetSecurityManager, &pSecMgr));
        }
        
        if (SUCCEEDED(hr))
        {
            hr = pSecMgr->MapUrlToZone(pszUrl, pdwZoneID, 0);
            ATOMICRELEASE(pSecMgr);
        }
    }
    else 
    {
        hr = E_INVALIDARG;
    }
    return hr;
}


/***************************************************************\
    DESCRIPTION:
        We are given a site via IObjectWithSite.  See if that host
    maps to the Local Zone.
\***************************************************************/
STDAPI LocalZoneCheck(IUnknown *punkSite)
{
    DWORD dwZoneID = URLZONE_UNTRUSTED;
    HRESULT hr = GetZoneFromSite(punkSite, &dwZoneID);
    
    if (SUCCEEDED(hr))
    {
        if (dwZoneID == URLZONE_LOCAL_MACHINE)
            hr = S_OK;
        else
            hr = E_ACCESSDENIED;
    }

    return hr;
}

STDAPI GetZoneFromSite(IUnknown *punkSite, DWORD *pdwZoneID)
{
    //  Return S_FALSE if we don't have a host site since we have no way of doing a 
    //  security check.  This is as far as VB 5.0 apps get.
    if (!punkSite)
    {
        *pdwZoneID = URLZONE_UNTRUSTED;
        return S_FALSE;
    }

    HRESULT hr = E_ACCESSDENIED;
    BOOL fTriedBrowser = FALSE;

    // Try to find the original template path for zone checking
    IOleCommandTarget * pct;
    if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_DefView, IID_PPV_ARG(IOleCommandTarget, &pct))))
    {
        VARIANT vTemplatePath;
        vTemplatePath.vt = VT_EMPTY;
        if (pct->Exec(&CGID_DefView, DVCMDID_GETTEMPLATEDIRNAME, 0, NULL, &vTemplatePath) == S_OK)
        {
            fTriedBrowser = TRUE;
            if (vTemplatePath.vt == VT_BSTR)
            {
                hr = GetZoneFromUrl(vTemplatePath.bstrVal, punkSite, pdwZoneID);
            }

            // We were able to talk to the browser, so don't fall back on Trident because they may be
            // less secure.
            fTriedBrowser = TRUE;
            VariantClear(&vTemplatePath);
        }
        pct->Release();
    }

    // If this is one of those cases where the browser doesn't exist (AOL, VB, ...) then
    // we will check the scripts security.  If we did ask the browser, don't ask trident
    // because the browser is often more restrictive in some cases.
    if (!fTriedBrowser && (hr != S_OK))
    {
        // Try to use the URL from the document to zone check 
        IHTMLDocument2 *pHtmlDoc;

        /***************************************************************\
         NOTE:
         1. If punkSite points into an <IFRAME APPLICATION="yes"> in a
            HTA file, then the URL GetHTMLDoc2() returns
            is for the IFRAME SRC..
         2. If this isn't an HTML container, then we can't calculate a zone, so it's E_ACCESSDENIED.
        \***************************************************************/
        if (SUCCEEDED(GetHTMLDoc2(punkSite, &pHtmlDoc)))
        {
            BSTR bstrURL;

            /***************************************************************\
             QUESTION:
             1. If this HTML container isn't safe but it's URL maps to the
                Local Zone, then we have a problem.  This may happen with
                email messages, especially if they are saved to a file.
                If the user reopens a saved .eml file, it will be hosted in
                it's mail container that may support the IInternet interface
                to indicate that it's in an untrusted zone.  Will we get
                a Local Zone URL in that case?
             ANSWER:
             1. The container can override zone mappings by supporting 
                IInternetSecurityManager.

             QUESTION:
             2. What if there are multiple frames in different zones. 
                Will trident block cross frame scripting?
             ANSWER:
             2. Yes.
            \***************************************************************/
            if (SUCCEEDED(pHtmlDoc->get_URL(&bstrURL)))
            {
                // NOTE: the above URL is improperly escaped, this is
                // due to app compat. if you depend on this URL being valid
                // use another means to get this

                hr = GetZoneFromUrl(bstrURL, punkSite, pdwZoneID);
                SysFreeString(bstrURL);
            }
            pHtmlDoc->Release();
        }
    }
                            
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\shellacl.c ===
#include "stock.h"
#pragma hdrstop

#ifdef WINNT

//
// common SHELL_USER_SID's (needed for GetShellSecurityDescriptor)
//
const SHELL_USER_SID susCurrentUser = {0, 0, 0};                                                                            // the current user 
const SHELL_USER_SID susSystem = {SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID, 0};                                     // the "SYSTEM" group
const SHELL_USER_SID susAdministrators = {SECURITY_NT_AUTHORITY, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS};     // the "Administrators" group
const SHELL_USER_SID susPowerUsers = {SECURITY_NT_AUTHORITY, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_POWER_USERS};    // the "Power Users" group
const SHELL_USER_SID susGuests = {SECURITY_NT_AUTHORITY, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_GUESTS};             // the "Guests" group
const SHELL_USER_SID susEveryone = {SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID, 0};                                   // the "Everyone" group

#endif // WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\shclient.cpp ===
#include "stock.h"
#pragma hdrstop

//
//  Return root hkey and default client name.  The caller is expected to
//  retrieve the command from hkey\default\shell\open\command.
//
STDAPI_(HKEY) _GetClientKeyAndDefaultW(LPCWSTR pwszClientType, LPWSTR pwszDefault, DWORD cchDefault)
{
    HKEY hkClient = NULL;

    ASSERT(cchDefault);     // This had better be a nonempty buffer

    // Borrow pwszDefault as a scratch buffer
    wnsprintfW(pwszDefault, cchDefault, L"SOFTWARE\\Clients\\%s", pwszClientType);

    if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_LOCAL_MACHINE, pwszDefault, 0, KEY_READ, &hkClient))
    {
        DWORD dwSize = cchDefault * sizeof(*pwszDefault);
        pwszDefault[0] = 0; // in case of failure
        RegQueryValueExW(hkClient, NULL, NULL, NULL, (LPBYTE)pwszDefault, &dwSize);

        // If no default client, then fail
        if (!pwszDefault[0])
        {
            RegCloseKey(hkClient);
            hkClient = NULL;
        }

    } else if (StrCmpIW(pwszClientType, L"webbrowser") == 0)
    {
        // In theory, we could use
        // RegOpenKeyExW(HKEY_CLASSES_ROOT, NULL, 0, KEY_READ, &hkClient)
        // but that just returns HKEY_CLASSES_ROOT back anyway.
        hkClient = HKEY_CLASSES_ROOT;
        StrCpyNW(pwszDefault, L"http", cchDefault);
    }
    return hkClient;
}

// Gets the path to open the default Mail, News, etc Client.
STDAPI SHGetDefaultClientOpenCommandW(LPCWSTR pwszClientType,
        LPWSTR pwszClientCommand, DWORD dwCch,
        OPTIONAL LPWSTR pwszClientParams, DWORD dwCchParams)
{
    HRESULT hr = E_INVALIDARG;
    HKEY hkClient;
    WCHAR wszDefault[MAX_PATH];

    ASSERT(pwszClientCommand && dwCch);
    ASSERT(pwszClientParams == NULL || dwCchParams);

    hkClient = _GetClientKeyAndDefaultW(pwszClientType, wszDefault, ARRAYSIZE(wszDefault));
    if (hkClient)
    {
        // For the webbrowser client, do not pass any command line arguments
        // at all.  This suppresses the "-nohome" flag that IE likes to throw
        // in there.  Also, if we end up being forced to use the Protocol key,
        // then strip the args there, too.
        BOOL fStripArgs = hkClient == HKEY_CLASSES_ROOT;

        BOOL iRetry = 0;
        int cchDefault = lstrlenW(wszDefault);
    again:
        StrCatBuffW(wszDefault, L"\\shell\\open\\command", ARRAYSIZE(wszDefault));

        // convert characters to bytes
        DWORD cb = dwCch * (sizeof(WCHAR)/sizeof(BYTE));
        // the default value of this key is the actual command to run the app
        DWORD dwError;
        dwError = SHGetValueW(hkClient, wszDefault, NULL, NULL, (LPBYTE) pwszClientCommand, &cb);

        if (dwError == ERROR_FILE_NOT_FOUND && iRetry == 0 &&
            StrCmpICW(pwszClientType, L"mail") == 0)
        {
            // Sigh, Netscape doesn't register a shell\open\command; we have to
            // look in Protocols\mailto\shell\open\command instead.
            wszDefault[cchDefault] = L'\0';
            StrCatBuffW(wszDefault, L"\\Protocols\\mailto", ARRAYSIZE(wszDefault));
            fStripArgs = TRUE;
            iRetry++;
            goto again;
        }

        if (dwError == ERROR_SUCCESS)
        {
            // Sigh.  Netscape forgets to quote its EXE name.
            PathProcessCommand(pwszClientCommand, pwszClientCommand, dwCch,
                               PPCF_ADDQUOTES | PPCF_NODIRECTORIES | PPCF_LONGESTPOSSIBLE);

            if (pwszClientParams)
            {
                if (fStripArgs)
                {
                    pwszClientParams[0] = 0;
                }
                else
                {
                    StrCpyNW(pwszClientParams, PathGetArgsW(pwszClientCommand), dwCchParams);
                }
            }
            PathRemoveArgsW(pwszClientCommand);
            PathUnquoteSpaces(pwszClientCommand);

            // Bonus hack for Netscape!  To read email you have to pass the
            // "-mail" command line option even though there is no indication
            // anywhere that this is the case.
            if (iRetry > 0 && pwszClientParams &&
                StrCmpIW(PathFindFileName(pwszClientCommand), L"netscape.exe") == 0)
            {
                StrCpyNW(pwszClientParams, L"-mail", dwCchParams);
            }

            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwError);
        }

        // Do not RegCloseKey(HKEY_CLASSES_ROOT) or the world will end!
        if (hkClient != HKEY_CLASSES_ROOT)
            RegCloseKey(hkClient);
    }
    return hr;
}

// Gets the friendly name for the default Mail, News, etc Client.
// Note that this doesn't work for Webbrowser.

STDAPI SHGetDefaultClientNameW(LPCWSTR pwszClientType,
        LPWSTR pwszBuf, DWORD dwCch)
{
    HRESULT hr = E_INVALIDARG;
    HKEY hkClient;
    WCHAR wszDefault[MAX_PATH];

    ASSERT(pwszBuf && dwCch);

    hkClient = _GetClientKeyAndDefaultW(pwszClientType, wszDefault, ARRAYSIZE(wszDefault));
    if (hkClient && hkClient != HKEY_CLASSES_ROOT)
    {
        LONG cbValue = dwCch * sizeof(TCHAR);
        if (RegQueryValueW(hkClient, wszDefault, pwszBuf, &cbValue) == ERROR_SUCCESS &&
            pwszBuf[0])
        {
            hr = S_OK;
        }
        RegCloseKey(hkClient);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\stock.h ===
//
// stock.h: shell\lib precompiled header file
//

#ifndef __STOCK_H__
#define __STOCK_H__

#ifndef STRICT
#define STRICT
#endif

//
// NT uses DBG=1 for its debug builds, but the Win95 shell uses
// DEBUG.  Do the appropriate mapping here.
//
#if DBG
#define DEBUG 1
#endif

#define _SHLWAPI_       // Make sure we don't get declspec(dllimport) for these
#define _SHELL32_       // otherwise we get errors from the linker for the delayload
#define _OLE32_         // stubs

#include <windows.h>
#include <oleauto.h>
#include <exdisp.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <commctrl.h>
#include <shlobj.h>
#include <debug.h>
#include <port32.h>
#include <ccstock.h>

#include <shsemip.h>        // for _ILNext

STDAPI_(LPITEMIDLIST) SafeILClone(LPCITEMIDLIST pidl);
#define ILClone         SafeILClone   

// Some files are compiled twice: once for unicode and once for ansi.
// There are some functions which do not want to be declared twice
// (the ones which don't use string parameters).  Otherwise we'd get
// duplicate redefinitions.
//
// These are wrapped with #ifdef DECLARE_ONCE.
#ifdef UNICODE
#define DECLARE_ONCE
#else
#undef DECLARE_ONCE
#endif


// Note that CharNext is not supported on win95.  Normally we would
// include w95wraps.h, but comctl does not link to shlwapi and
// we don't want to add this dependency.
#ifdef UNICODE
// Note that this will still break if we ever go back to non-unicode
__inline LPWSTR CharNextWrapW_(LPWSTR psz) {return ++psz;}
#undef CharNext
#define CharNext CharNextWrapW_
#endif


#endif // __STOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\stock.inc ===
!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

NO_BROWSER_FILE = 1

TARGETPATH      = obj
TARGETTYPE      = LIBRARY

GENERATED_SOURCES =  \
                  $(O)\dkaa.cpp     \
                  $(O)\dkaw.cpp     \
                  $(O)\shstra.cpp   \
                  $(O)\shstrw.cpp   \
                  $(O)\nativea.cpp  \
                  $(O)\nativew.cpp  \
                  $(O)\infotipa.cpp \
                  $(O)\infotipw.cpp

SOURCES         = ..\autosecurity.cpp \
                  ..\bindctx.cpp    \
                  ..\caggunk.cpp    \
                  ..\cnctnpt.cpp    \
                  ..\cobjsafe.cpp   \
                  ..\cowsite.cpp    \
                  ..\cstrinout.cpp  \
                  ..\crst.cpp       \
                  ..\debug.c        \
                  ..\dllreghelper.cpp     \
                  ..\dllver.cpp     \
                  ..\dobjutil.cpp   \
                  ..\dspsprt.cpp    \
                  ..\expdsprt.cpp   \
                  ..\idhidden.cpp   \
                  ..\ieplaysound.cpp      \
                  ..\ieutil.cpp     \
                  ..\iconutil.cpp   \
                  ..\isos.cpp       \
                  ..\mediautil.cpp  \
                  ..\profsvc.cpp    \
                  ..\propertybag.cpp      \
                  ..\reg.cpp        \
                  ..\rpctimeout.cpp \
                  ..\runtask.cpp    \
                  ..\security.cpp   \
                  ..\setmodebias.cpp \
                  ..\shclient.cpp   \
                  ..\shco.c         \
                  ..\shellacl.c     \
                  ..\stdenum.cpp    \
                  ..\typelist.cpp       \
                  ..\util.cpp       \
                  ..\valid.c        \
                  ..\varutil.cpp    \
                  ..\wnetutil.cpp   \
                  $(GENERATED_SOURCES)

OBJLIBFILES     = ..\stockthk\$(O)\stockthk.lib

NTTARGETFILE1   = $(CCSHELL_DIR)\lib\$(O)\$(TARGETNAME).lib

PRECOMPILED_INCLUDE= ..\stock.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\shstr.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: Shell String Class Implementation

    shstr.cpp

Author:

    Zeke Lucas (zekel)  27-Oct-96

Environment:

    User Mode - Win32

Revision History:


 Abstract:

    this allows automatic resizing and stuff.

  NOTE: this class is specifically designed to be used as a stack variable


--*/

#include "stock.h"
#pragma hdrstop

#include <shstr.h>
#include <strsafe.h>


#define MALLOC(c)       LocalAlloc(LPTR, (c))
#define FREE(p)         LocalFree(p)

//
//  ShStr Public Methods
//

//
//  Constructors
//

ShStr :: ShStr () 
{
    _szDefaultBuffer[0] = '\0';
    _pszStr = _szDefaultBuffer;
    _cchSize = ARRAYSIZE(_szDefaultBuffer);
}


/**************
    StrStr SetStr() methods

  Return:   
    Success - a pointer to the object
    Failure - NULL
**************/

HRESULT 
ShStr :: SetStr (LPCSTR pszStr)
{
    Reset();
    
    return _SetStr(pszStr);

}

HRESULT 
ShStr :: SetStr (LPCSTR pszStr, DWORD cchStr)
{
    Reset();
    
    return _SetStr(pszStr, cchStr);

}

HRESULT 
ShStr :: SetStr (LPCWSTR pwszStr, DWORD cchStr)
{
    Reset();
    
    return _SetStr(pwszStr, cchStr);

}


HRESULT
ShStr :: Append(LPCTSTR pszStr, DWORD cchStr)
{
    HRESULT hr = S_OK;

    if(pszStr)
    {
        DWORD cchLen = GetLen();

        if(cchStr == (DWORD) -1)
            cchStr = lstrlen(pszStr);

        //
        //  StrCpyN automagically appends the null term, 
        //  so we need to give room for it
        //
        cchStr++;

        if(SUCCEEDED(SetSize(cchStr + cchLen)))
            StrCpyN(_pszStr + cchLen, pszStr, cchStr);
        else
            hr = E_OUTOFMEMORY;
    }
    else
        hr = E_INVALIDARG;

    return hr;
}

ShStr *
ShStr :: Clone()
{
    ShStr *pshstr = new ShStr;

    if (pshstr)
    {
        pshstr->SetStr(_pszStr);
    
        if(pshstr->IsValid())
            return pshstr;
    }

    if(pshstr)
        delete pshstr;

    return NULL;
}

LPSTR 
ShStr :: CloneStrA()
#ifdef UNICODE
{
    LPSTR pszStr = NULL;

    if(_pszStr)
    {
        DWORD cchStr;
    
        cchStr = WideCharToMultiByte(CP_ACP, 0,
            _pszStr, -1,
            NULL, 0,
            NULL, NULL);

        ASSERT(cchStr);

        if(cchStr)
        {
            pszStr = (LPSTR) MALLOC (CbFromCch(cchStr +1));

            if(pszStr)
            {
                cchStr = WideCharToMultiByte(CP_ACP, 0,
                    _pszStr, -1,
                    pszStr, cchStr,
                    NULL, NULL);
                ASSERT (cchStr);
            }
        }
    }

    return pszStr;
}

#else //!UNICODE

    {return _pszStr ? StrDupA(_pszStr) : NULL;}
#endif //UNICODE


#ifdef UNICODE
  
#endif
LPWSTR 
ShStr :: CloneStrW()
#ifdef UNICODE
    {return _pszStr ? StrDupW(_pszStr) : NULL;}
#else //!UNICODE
{
    LPWSTR pwsz;
    DWORD cch = lstrlenA(_pszStr) +1;

    pwsz = (LPWSTR) MALLOC (sizeof(WCHAR) * cch);
    
    if(pwsz)
        MultiByteToWideChar(CP_ACP, 0,
            _pszStr, -1,
            pwsz, cch);

    return pwsz;
}
#endif //UNICODE


/**************
    ShStr Utility methods

**************/


/**************
    ShStr SetSize method

    Sets the size of the internal buffer if larger than default

  Return:   
    Success - a pointer to the object
    Failure - NULL
**************/
HRESULT
ShStr :: SetSize(DWORD cchSize)
{
    HRESULT hr = S_OK;
    DWORD cchNewSize = _cchSize;

    ASSERT(!(_cchSize % DEFAULT_SHSTR_LENGTH));

    // so that we always allocate in increments
    while (cchSize > cchNewSize)
        cchNewSize <<= 2;
    
    if(cchNewSize != _cchSize)
    {
        if(cchNewSize > DEFAULT_SHSTR_LENGTH)
        {
            LPTSTR psz;

            psz = (LPTSTR) LocalAlloc(LPTR, CbFromCch(cchNewSize));
    
            if(psz)
            {
                StrCpyN(psz, _pszStr, cchSize);
                Reset();
                _cchSize = cchNewSize;
                _pszStr = psz;
            }
            else 
                hr = E_OUTOFMEMORY;
        }
        else
        {
            if (_pszStr && _cchSize) 
                StrCpyN(_szDefaultBuffer, _pszStr, ARRAYSIZE(_szDefaultBuffer));

            Reset();

            _pszStr = _szDefaultBuffer;
        }
    }

    return hr;
}

#ifdef DEBUG
BOOL
ShStr :: IsValid()
{
    BOOL fRet = TRUE;

    if(!_pszStr)
        fRet = FALSE;

    ASSERT( ((_cchSize != ARRAYSIZE(_szDefaultBuffer)) && (_pszStr != _szDefaultBuffer)) ||
            ((_cchSize == ARRAYSIZE(_szDefaultBuffer)) && (_pszStr == _szDefaultBuffer)) );

    ASSERT(!(_cchSize % DEFAULT_SHSTR_LENGTH));

    return fRet;
}
#endif //DEBUG

VOID 
ShStr :: Reset()
{
    if (_pszStr && (_cchSize != ARRAYSIZE(_szDefaultBuffer))) 
        LocalFree(_pszStr);

    _szDefaultBuffer[0] = TEXT('\0');
    _pszStr = _szDefaultBuffer;
    _cchSize = ARRAYSIZE(_szDefaultBuffer);
}

#define IsWhite(c)      ((DWORD) (c) > 32 ? FALSE : TRUE)
VOID
ShStr :: Trim()
{

    if(_pszStr)
    {
        // APPCOMPAT - NETSCAPE compatibility - zekel 29-JAN-97
        //  we want to leave one space in the string
        TCHAR chFirst = *_pszStr;

        //  first trim the backside
        TCHAR *pchLastWhite = NULL;
        LPTSTR pch = _pszStr;
        
        // the front side
        while (*pch && IsWhite(*pch))
            pch = CharNext(pch);

        if (pch > _pszStr)
        {
            LPTSTR pchDst = _pszStr;

            while (*pchDst = *pch)
            {
                pch = CharNext(pch);
                pchDst = CharNext(pchDst);
            }
        }

        // then the backside
        for (pch = _pszStr; *pch; pch = CharNext(pch))
        {
            if(pchLastWhite && !IsWhite(*pch))
                pchLastWhite = NULL;
            else if(!pchLastWhite && IsWhite(*pch))
                pchLastWhite = pch;
        }

        if(pchLastWhite)
            *pchLastWhite = TEXT('\0');

        if(TEXT(' ') == chFirst && !*_pszStr)
        {
            _pszStr[0] = TEXT(' ');
            _pszStr[1] = TEXT('\0');
        }
    }
}

    


//
//  ShStr Private Methods
//


/**************
    StrStr Set* methods

  Return:   
    Success - a pointer to the object
    Failure - NULL
**************/
HRESULT 
ShStr :: _SetStr(LPCSTR pszStr)
{
    HRESULT hr = S_FALSE;

    if(pszStr)
    {
        DWORD cchStr;

        cchStr = lstrlenA(pszStr);
    
        if(cchStr)
        {
            hr = SetSize(cchStr +1);

            if (SUCCEEDED(hr))
#ifdef UNICODE
                MultiByteToWideChar(CP_ACP, 0,
                    pszStr, -1,
                    _pszStr, _cchSize);
#else //!UNICODE
                StringCchCopyA(_pszStr, cchStr+1, pszStr);
#endif //UNICODE
        }
    }

    return hr;
}

HRESULT 
ShStr :: _SetStr(LPCSTR pszStr, DWORD cchStr)
{
    HRESULT hr = S_FALSE;

    if(pszStr && cchStr)
    {
        if (cchStr == (DWORD) -1)
            cchStr = lstrlenA(pszStr);

        hr = SetSize(cchStr +1);

        if(SUCCEEDED(hr))
        {
#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, 0,
                pszStr, cchStr,
                _pszStr, _cchSize);
            _pszStr[cchStr] = TEXT('\0');

#else //!UNICODE
            StrCpyN(_pszStr, pszStr, (++cchStr < _cchSize ? cchStr : _cchSize) );
#endif //UNICODE
        }
    }

    return hr;
}

HRESULT 
ShStr :: _SetStr (LPCWSTR pwszStr, DWORD cchStrIn)
{
    DWORD cchStr = cchStrIn;
    HRESULT hr = S_FALSE;

    if(pwszStr && cchStr)
    {
        if (cchStr == (DWORD) -1)
#ifdef UNICODE
            cchStr = lstrlen(pwszStr);
#else //!UNICODE
        cchStr = WideCharToMultiByte(CP_ACP, 0,
            pwszStr, cchStrIn,
            NULL, 0,
            NULL, NULL);
#endif //UNICODE

        if(cchStr)
        {
            hr = SetSize(cchStr +1);

            if(SUCCEEDED(hr))
            {
#ifdef UNICODE 
                StrCpyN(_pszStr, pwszStr, (cchStr + 1< _cchSize ? cchStr + 1: _cchSize));
#else //!UNICODE
                cchStr = WideCharToMultiByte(CP_ACP, 0,
                    pwszStr, cchStrIn,
                    _pszStr, _cchSize,
                    NULL, NULL);
                _pszStr[cchStr < _cchSize ? cchStr : _cchSize] = TEXT('\0');
                ASSERT (cchStr);
#endif //UNICODE
            }
        }
#ifdef DEBUG
        else
        {
            DWORD dw;
            dw = GetLastError();
        }
#endif //DEBUG

    }
#ifdef DEBUG
    else
    {
        DWORD dw;
        dw = GetLastError();
    }
#endif //DEBUG

    return hr;
}

#if 0  //DISABLED until i have written the SHUrl* functions - zekel 7-Nov-96
//
//  UrlStr Methods
//
  
  UrlStr &
UrlStr::SetUrl(LPCSTR pszUrl)
{
    return SetUrl(pszUrl, (DWORD) -1);
}

  UrlStr &
UrlStr::SetUrl(LPCWSTR pwszUrl)
{
    return SetUrl(pwszUrl, (DWORD) -1);
}

  UrlStr &
UrlStr::SetUrl(LPCSTR pszUrl, DWORD cchUrl)
{
    _strUrl.SetStr(pszUrl, cchUrl);
    return *this;
}

  UrlStr &
UrlStr::SetUrl(LPCWSTR pwszUrl, DWORD cchUrl)
{
    _strUrl.SetStr(pwszUrl, cchUrl);
    return *this;
}

 
UrlStr::operator LPCTSTR()
{
    return _strUrl.GetStr();
}

  
UrlStr::operator SHSTR()
{
    return _strUrl;
}




  HRESULT
UrlStr::Combine(LPCTSTR pszUrl, DWORD dwFlags)
{
    SHSTR strRel;
    SHSTR strOut;
    HRESULT hr;

    strRel.SetStr(pszUrl);

    hr = UrlCombine(_strUrl.GetStr(), 
    hr = SHUrlParse(&_strUrl, &strRel, &strOut, NULL, URL_PARSE_CREATE);

    if(SUCCEEDED(hr))
        _strUrl = strOut;

    return hr;
}

/*
    ShStr &GetLocation();
    ShStr &GetAnchor();
    ShStr &GetQuery();

    HRESULT Canonicalize(DWORD dwFlags);
    HRESULT Combine(LPCTSTR pszUrl, DWORD dwFlags);
    HRESULT Encode(DWORD dwFlags);
    HRESULT EncodeSpaces()
        {return Encode(URL_ENCODE_SPACES_ONLY)}
    HRESULT Decode(DWORD dwFlags)
*/
#endif  //DISABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\typelist.cpp ===
#include "stock.h"
#pragma hdrstop

STDAPI_(BOOL) IsTypeInList(LPCTSTR pszType, const LPCTSTR *arszList, UINT cList)
{
    BOOL fRet = FALSE;
    if (pszType && *pszType)
    {
        PCWSTR pszExt = NULL;
        PCWSTR pszProgID = NULL;
        if (*pszType == L'.')
            pszExt = pszType;
        else
            pszProgID = pszType;
        
        WCHAR szProgID[MAX_PATH];
        DWORD cb = sizeof(szProgID);
        if (!pszProgID)
        {
            ASSERT(pszExt);
            if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, szProgID, &cb))
                pszProgID = szProgID;
            else
                pszProgID = NULL;
        }

        for (UINT n = 0; FALSE == fRet && n < cList; n++)
        {
            // check extension if available
            if (pszExt)
            {
                fRet = (0 == StrCmpI(pszExt, arszList[n]));
            }

            if (!fRet && pszProgID)     
            {
                WCHAR szTempID[MAX_PATH];
                ULONG cb = sizeof(szTempID);
                if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, arszList[n], NULL, NULL, szTempID, &cb))
                {
                    fRet = 0 == StrCmpIW(pszProgID, szTempID);
                }
            }
        }
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\stdenum.cpp ===
//=--------------------------------------------------------------------------=
// StandardEnum.Cpp
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of a generic enumerator object.
//

#include "stock.h"
#pragma hdrstop

#include "stdenum.h"

// Used by creators of CStandardEnum
//
void WINAPI CopyAndAddRefObject
(
    void       *pDest,      // dest
    const void *pSource,    // src
    DWORD       dwSize      // size, ignored, since it's always 4
)
{
    IUnknown *pUnk = *((IUnknown **)pSource);
    *((IUnknown **)pDest) = pUnk;
    pUnk->AddRef();
}

void* CStandardEnum_CreateInstance(REFIID riid, BOOL fMembersAreInterfaces, int cElement, int cbElement, void *rgElements,
                                                  void (WINAPI * pfnCopyElement)(void *, const void *, DWORD))
{
    return (LPVOID)new CStandardEnum(riid, fMembersAreInterfaces, cElement, cbElement, rgElements, pfnCopyElement);
}

//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    REFCLSID        - [in] type of enumerator that we are
//    int             - [in] number of elements in the enumeration
//    int             - [in] size of each element
//    void *          - [in] pointer to element data
//    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD)
//                    - [in] copying function
//
// Notes:
//
#pragma warning(disable:4355)  // using 'this' in constructor
CStandardEnum::CStandardEnum
(
    REFCLSID rclsid,
    BOOL fMembersAreInterfaces,
    int      cElements,
    int      cbElementSize,
    void    *rgElements,
    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD)
)
: m_cRef(1),
  m_iid(rclsid),
  m_cElements(cElements),
  m_cbElementSize(cbElementSize),
  m_iCurrent(0),
  m_rgElements(rgElements),
  m_pfnCopyElement(pfnCopyElement),
  m_fMembersAreInterfaces(fMembersAreInterfaces)
{
    m_pEnumClonedFrom = NULL;
    if(m_fMembersAreInterfaces)
    {
        if(m_rgElements)
        {
            int i;
            for(i=0; i<m_cElements; i++)
            {
                LPUNKNOWN *ppunk = (IUnknown **)GetNthElement(i);
                (*ppunk)->AddRef();
            }
        }
    }
}
#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// "it is not death, but dying, which is terrible."
//    - Henry Fielding (1707-54)
//
// Notes:
//
CStandardEnum::~CStandardEnum ()
{
    // if we're a cloned object, then just release our parent object and
    // we're done. otherwise, free up the allocated memory we were given
    //
    if (m_pEnumClonedFrom)
    {
        m_pEnumClonedFrom->Release();
    }
    else
    {
        if (m_rgElements)
        {
            if(m_fMembersAreInterfaces)
            {
                int i;

                for(i=0; i<m_cElements; i++)
                {
                    LPUNKNOWN *ppunk = (IUnknown **)GetNthElement(i);
                    (*ppunk)->Release();
                }
            }
            GlobalFree(m_rgElements);
        }
    }
}

//=--------------------------------------------------------------------------=
// CStandardEnum::InternalQueryInterface
//=--------------------------------------------------------------------------=
// we support our internal iid, and that's all
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CStandardEnum::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    *ppvObjOut = NULL;
    if (IsEqualIID(riid, m_iid))
    {
        *ppvObjOut = (IEnumGeneric *)this;
    }
    else if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObjOut = (IUnknown *)this;
    }

    if (*ppvObjOut)
    {
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

ULONG CStandardEnum::AddRef(void)
{
    return ++m_cRef;
}

ULONG CStandardEnum::Release(void)
{
    int n = --m_cRef;

    if (n == 0)
        delete this;

    return(n);
}


//=--------------------------------------------------------------------------=
// CStandardEnum::Next
//=--------------------------------------------------------------------------=
// returns the next dude in our iteration
//
// Parameters:
//    unsigned long     - [in]  count of elements requested
//    void    *         - [out] array of slots to put values in.
//    unsigned long *   - [out] actual number fetched
//
// Output:
//    HRESULT           - S_OK, E_INVALIDARG, S_FALSE
//
// Notes:
//
STDMETHODIMP CStandardEnum::Next
(
    unsigned long  cElm,
    void          *rgDest,
    unsigned long *pcElmOut
)
{
    unsigned long cElementsFetched = 0;
    void         *pElementDest = rgDest;
    const void   *pElementSrc = GetNthElement(m_iCurrent);

    while (cElementsFetched < cElm) {

        // if we hit EOF, break out
        //
        if (m_iCurrent >= m_cElements)
            break;

        // copy the element out for them
        //
        m_pfnCopyElement(pElementDest, pElementSrc, m_cbElementSize);

        // increase the counters
        //
        pElementDest = (LPBYTE)pElementDest + m_cbElementSize;
        pElementSrc  = (const BYTE *)pElementSrc + m_cbElementSize;
        m_iCurrent++;
        cElementsFetched++;
    }

    if (pcElmOut)
        *pcElmOut = cElementsFetched;

    return (cElementsFetched < cElm)? S_FALSE : S_OK;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Skip
//=--------------------------------------------------------------------------=
// skips the requested number of rows.
//
// Parameters:
//    unsigned long     - [in] number to skip
//
// Output:
//    HRESULT           - S_OK, S_FALSE
//
// Notes:
//
STDMETHODIMP CStandardEnum::Skip
(
    unsigned long cSkip
)
{
    // handle running off the end
    //
    if (m_iCurrent + (int)cSkip > m_cElements) {
        m_iCurrent = m_cElements;
        return S_FALSE;
    }

    m_iCurrent += cSkip;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Reset
//=--------------------------------------------------------------------------=
// reset the counter.
//
// Output:
//    HRESULT        - S_OK
//
// Notes:
//
STDMETHODIMP CStandardEnum::Reset
(
    void
)
{
    m_iCurrent = 0;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CStandardEnum::Clone
//=--------------------------------------------------------------------------=
// clones the object and gives the new one the same position
//
// Parameters:
//    IEnumVARIANT **    - [out] where to put the new object.
//
// Output;
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP CStandardEnum::Clone
(
    IEnumGeneric **ppEnumClone
)
{
    CStandardEnum *pNewEnum = new CStandardEnum(m_iid, m_fMembersAreInterfaces, m_cElements, 
                                 m_cbElementSize, m_rgElements, m_pfnCopyElement);
    if (NULL == pNewEnum)
        return E_OUTOFMEMORY;

    // The clone has the same current position as we do
    pNewEnum->m_iCurrent = m_iCurrent;

    // hold on to who we were cloned from so m_rgElements stays alive, and we don't
    // have to copy it.
    //
    pNewEnum->m_pEnumClonedFrom = this;

    // AddRef() ourselves on their behalf.
    //
    AddRef();

    return S_OK;
}


// Helper function for creating IConnectionPoint enumerators
//
HRESULT CreateInstance_IEnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum, DWORD count, ...)
{
    DWORD  countTemp;
    IConnectionPoint **rgCPs;

    if (NULL == ppEnum)
        return E_POINTER;

    ASSERT(count > 0);

    // GlobalAlloc an array of connection points [since our standard enum
    // assumes this and GlobalFree's it later]
    //
    rgCPs = (LPCONNECTIONPOINT*)GlobalAlloc(GPTR, SIZEOF(LPCONNECTIONPOINT) * count);
    if (NULL == rgCPs)
        return E_OUTOFMEMORY;

    va_list ArgList;
    va_start(ArgList, count);

    IConnectionPoint **prgCPs = rgCPs;
    countTemp = count;
    while (countTemp)
    {
        IConnectionPoint *pArg = va_arg(ArgList, IConnectionPoint*);

        *prgCPs = pArg;

        prgCPs++;
        countTemp--;
    }

    va_end(ArgList);

    *ppEnum = (IEnumConnectionPoints *)(IEnumGeneric *) new CStandardEnum(IID_IEnumConnectionPoints,
                                TRUE, count, SIZEOF(LPCONNECTIONPOINT), (LPVOID)rgCPs,
                                CopyAndAddRefObject);
    if (!*ppEnum)
    {
        GlobalFree(rgCPs);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\valid.c ===
//
//  Validation code
//

#include "stock.h"
#pragma hdrstop

//
//  Validations
//

// Hack: size of the internal data structures, as defined in comctl32\da.c.
// We measure this by the number of DWORD-sized fields.
#ifdef DEBUG
#define CB_DSA      (6 * sizeof(DWORD))
#define CB_DPA      (6 * sizeof(DWORD))
#else
#define CB_DSA      (5 * sizeof(DWORD))
#define CB_DPA      (5 * sizeof(DWORD))
#endif

BOOL
IsValidHDSA(
    HDSA hdsa)
{
    return (IS_VALID_WRITE_BUFFER(hdsa, BYTE, CB_DSA));
}


BOOL
IsValidHDPA(
    HDPA hdpa)
{
    return (IS_VALID_WRITE_BUFFER(hdpa, BYTE, CB_DPA));
}

BOOL
IsValidPIDL(
    LPCITEMIDLIST pidl)
{
    return (IS_VALID_READ_PTR(pidl, USHORT) &&
            IS_VALID_READ_BUFFER((LPBYTE)pidl+sizeof(USHORT), BYTE, pidl->mkid.cb) &&
            (0 == _ILNext(pidl)->mkid.cb || IS_VALID_PIDL(_ILNext(pidl))));
}


BOOL 
IsValidHWND(
    HWND hwnd)
{
    /* Ask User if this is a valid window. */

    return(IsWindow(hwnd));
}


BOOL
IsValidHMENU(
    HMENU hmenu)
{
    return IsMenu(hmenu);
}    


BOOL 
IsValidHANDLE(
    HANDLE hnd)
{
    return(NULL != hnd && INVALID_HANDLE_VALUE != hnd);
}


BOOL 
IsValidHANDLE2(
    HANDLE hnd)
{
    return(hnd != INVALID_HANDLE_VALUE);
}


BOOL 
IsValidShowCmd(
    int nShow)
{
    BOOL bResult;
 
    switch (nShow)
    {
       case SW_HIDE:
       case SW_SHOWNORMAL:
       case SW_SHOWMINIMIZED:
       case SW_SHOWMAXIMIZED:
       case SW_SHOWNOACTIVATE:
       case SW_SHOW:
       case SW_MINIMIZE:
       case SW_SHOWMINNOACTIVE:
       case SW_SHOWNA:
       case SW_RESTORE:
       case SW_SHOWDEFAULT:
          bResult = TRUE;
          break;
 
       default:
          bResult = FALSE;
          TraceMsg(TF_ERROR, "IsValidShowCmd(): Invalid show command %d.",
                     nShow);
          break;
    }
 
    return(bResult);
}


BOOL 
IsValidPathA(
    LPCSTR pcszPath)
{
    return(IS_VALID_STRING_PTRA(pcszPath, MAX_PATH) &&
           EVAL((UINT)lstrlenA(pcszPath) < MAX_PATH));
}

BOOL 
IsValidPathW(
    LPCWSTR pcszPath)
{
    return(IS_VALID_STRING_PTRW(pcszPath, MAX_PATH) &&
           EVAL((UINT)lstrlenW(pcszPath) < MAX_PATH));
}


BOOL 
IsValidPathResultA(
    HRESULT hr, 
    LPCSTR pcszPath,
    UINT cchPathBufLen)
{
    return((hr == S_OK &&
            EVAL(IsValidPathA(pcszPath)) &&
            EVAL((UINT)lstrlenA(pcszPath) < cchPathBufLen)) ||
           (hr != S_OK &&
            EVAL(! cchPathBufLen ||
                 ! pcszPath ||
                 ! *pcszPath)));
}

BOOL 
IsValidPathResultW(
    HRESULT hr, 
    LPCWSTR pcszPath,
    UINT cchPathBufLen)
{
    return((hr == S_OK &&
            EVAL(IsValidPathW(pcszPath)) &&
            EVAL((UINT)lstrlenW(pcszPath) < cchPathBufLen)) ||
           (hr != S_OK &&
            EVAL(! cchPathBufLen ||
                 ! pcszPath ||
                 ! *pcszPath)));
}


BOOL 
IsValidExtensionA(
    LPCSTR pcszExt)
{
    return(IS_VALID_STRING_PTRA(pcszExt, MAX_PATH) &&
           EVAL(lstrlenA(pcszExt) < MAX_PATH) &&
           EVAL(*pcszExt == '.'));
}

BOOL 
IsValidExtensionW(
    LPCWSTR pcszExt)
{
    return(IS_VALID_STRING_PTRW(pcszExt, MAX_PATH) &&
           EVAL(lstrlenW(pcszExt) < MAX_PATH) &&
           EVAL(*pcszExt == TEXTW('.')));
}


BOOL 
IsValidIconIndexA(
    HRESULT hr, 
    LPCSTR pcszIconFile,
    UINT cchIconFileBufLen, 
    int niIcon)
{
    return(EVAL(IsValidPathResultA(hr, pcszIconFile, cchIconFileBufLen)) &&
           EVAL(hr == S_OK ||
                ! niIcon));
}

BOOL 
IsValidIconIndexW(
    HRESULT hr, 
    LPCWSTR pcszIconFile,
    UINT cchIconFileBufLen, 
    int niIcon)
{
    return(EVAL(IsValidPathResultW(hr, pcszIconFile, cchIconFileBufLen)) &&
           EVAL(hr == S_OK ||
                ! niIcon));
}


BOOL IsStringContainedA(LPCSTR pcszBigger, LPCSTR pcszSuffix)
{
    ASSERT(IS_VALID_STRING_PTRA(pcszBigger, -1));
    ASSERT(IS_VALID_STRING_PTRA(pcszSuffix, -1));
    
    return (pcszSuffix >= pcszBigger && 
            pcszSuffix <= pcszBigger + lstrlenA(pcszBigger));
}


BOOL IsStringContainedW(LPCWSTR pcszBigger, LPCWSTR pcszSuffix)
{
    ASSERT(IS_VALID_STRING_PTRW(pcszBigger, -1));
    ASSERT(IS_VALID_STRING_PTRW(pcszSuffix, -1));
    
    return (pcszSuffix >= pcszBigger && 
            pcszSuffix <= pcszBigger + lstrlenW(pcszBigger));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\varutil.cpp ===
#include "stock.h"
#pragma hdrstop

#include <varutil.h>
#include <shdocvw.h>
#include <strsafe.h>

// ---------------------------------------------------
//
// InitVariantFrom... functions
//

STDAPI InitVariantFromInt(VARIANT *pvar, int lVal)
{
    pvar->vt = VT_I4;
    pvar->lVal = lVal;
    return S_OK;
}

STDAPI InitVariantFromUINT(VARIANT *pvar, UINT ulVal)
{
    pvar->vt = VT_UI4;
    pvar->ulVal = ulVal;
    return S_OK;
}

STDAPI InitVariantFromULONGLONG(VARIANT *pvar, ULONGLONG ullVal)
{
    pvar->vt = VT_UI8;
    pvar->ullVal = ullVal;
    return S_OK;
}

STDAPI_(UINT) VariantToUINT(VARIANT varIn)
{
    VARIANT varResult = {0};
    return SUCCEEDED(VariantChangeType(&varResult, &varIn, 0, VT_UI4)) ? varResult.ulVal : 0;
}

STDAPI_(int) VariantToInt(VARIANT varIn)
{
    VARIANT varResult = {0};
    return SUCCEEDED(VariantChangeType(&varResult, &varIn, 0, VT_I4)) ? varResult.lVal : 0;
}

STDAPI_(BOOL) VariantToBOOL(VARIANT varIn)
{
    VARIANT varResult = {0};
    if (SUCCEEDED(VariantChangeType(&varResult, &varIn, 0, VT_BOOL)))
        return (varResult.boolVal == VARIANT_FALSE) ? FALSE : TRUE;
    return FALSE;
}

STDAPI_(ULONGLONG) VariantToULONGLONG(VARIANT varIn)
{
    VARIANT varResult = {0};
    return SUCCEEDED(VariantChangeType(&varResult, &varIn, 0, VT_UI8)) ? varResult.ullVal : 0;
}

STDAPI_(BOOL) VariantToBuffer(const VARIANT* pvar, void *pv, UINT cb)
{
    if (pvar && pvar->vt == (VT_ARRAY | VT_UI1))
    {
        LONG lLBound;
        LONG lUBound;
        void *pvb;

        if ( SafeArrayGetDim(pvar->parray) == 1
            && SUCCEEDED(SafeArrayGetLBound(pvar->parray, 1, &lLBound))
            && SUCCEEDED(SafeArrayGetUBound(pvar->parray, 1, &lUBound))
            && (UINT)(lUBound - lLBound) + 1 >= cb
            && SUCCEEDED(SafeArrayAccessData(pvar->parray, &pvb)))
        {
            CopyMemory(pv, pvb, cb);
            SafeArrayUnaccessData(pvar->parray);
            return TRUE;
        }
    }
    return FALSE;
}

STDAPI_(BOOL) VariantToGUID(const VARIANT *pvar, GUID *pguid)
{
    return VariantToBuffer(pvar, pguid, sizeof(*pguid));
}

STDAPI_(LPCWSTR) VariantToStrCast(const VARIANT *pvar)
{
    LPCWSTR psz = NULL;

    ASSERT(!IsBadReadPtr(pvar, sizeof(pvar)));

    if (pvar->vt == (VT_BYREF | VT_VARIANT) && pvar->pvarVal)
        pvar = pvar->pvarVal;

    if (pvar->vt == VT_BSTR)
        psz = pvar->bstrVal;
    else if (pvar->vt == (VT_BSTR | VT_BYREF))
        psz = *pvar->pbstrVal;
    
    return psz;
}

STDAPI InitVariantFromBuffer(VARIANT *pvar, const void *pv, UINT cb)
{
    HRESULT hr;
    VariantInit(pvar);
    SAFEARRAY *psa = SafeArrayCreateVector(VT_UI1, 0, cb);   // create a one-dimensional safe array
    if (psa) 
    {
        CopyMemory(psa->pvData, pv, cb);

        pvar->vt = VT_ARRAY | VT_UI1;
        pvar->parray = psa;
        hr = S_OK;
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

STDAPI_(UINT) _MyILGetSize(LPCITEMIDLIST pidl)
{
    UINT cbTotal = 0;
    if (pidl)
    {
        cbTotal += sizeof(pidl->mkid.cb);       // Null terminator
        while (pidl->mkid.cb)
        {
            cbTotal += pidl->mkid.cb;
            pidl = _ILNext(pidl);
        }
    }
    return cbTotal;
}

STDAPI InitVariantFromIDList(VARIANT* pvar, LPCITEMIDLIST pidl)
{
    return InitVariantFromBuffer(pvar, pidl, _MyILGetSize(pidl));
}

STDAPI InitVariantFromGUID(VARIANT *pvar, REFGUID guid)
{
    return InitVariantFromBuffer(pvar, &guid, sizeof(guid));
}

STDAPI InitBSTRVariantFromGUID(VARIANT *pvar, REFGUID guid)
{
    WCHAR wszGuid[GUIDSTR_MAX];
    HRESULT hr;
    if (SUCCEEDED(SHStringFromGUIDW(guid, wszGuid, ARRAYSIZE(wszGuid))))
    {
        hr = InitVariantFromStr(pvar, wszGuid);
    }
    else
    {
        hr = E_FAIL;
        VariantInit(pvar);
    }
    return hr;
}

// note, this frees the STRRET contents
STDAPI InitVariantFromStrRet(STRRET *pstrret, LPCITEMIDLIST pidl, VARIANT *pv)
{
    WCHAR szTemp[INFOTIPSIZE];
    HRESULT hres = StrRetToBufW(pstrret, pidl, szTemp, ARRAYSIZE(szTemp));
    if (SUCCEEDED(hres))
    {
        pv->bstrVal = SysAllocString(szTemp);
        if (pv->bstrVal)
            pv->vt = VT_BSTR;
        hres = pv->bstrVal ? S_OK : E_OUTOFMEMORY;
    }
    return hres;
}

// returns:
//      S_OK    success
//      S_FALSE successfully created an empty string from a NULL [in] parameter
//      E_OUTOFMEMORY
STDAPI InitVariantFromStr(VARIANT *pvar, LPCWSTR psz)
{
    VariantInit(pvar);

    // There is no NULL bstr value, so convert NULL to "".
    pvar->bstrVal = SysAllocString(psz ? psz : L"");
    if (pvar->bstrVal)
        pvar->vt = VT_BSTR;

    return pvar->bstrVal ? (psz ? S_OK : S_FALSE) : E_OUTOFMEMORY;
}

// time is in GMT. this function converts to local time

STDAPI InitVariantFromFileTime(const FILETIME *pft, VARIANT *pv)
{
    SYSTEMTIME st;
    FILETIME ftLocal;

    FileTimeToLocalFileTime(pft, &ftLocal);

    //
    //  Watch out for the special filesystem "uninitialized" values.
    //
    if (FILETIMEtoInt64(*pft) == FT_NTFS_UNKNOWNGMT ||
        FILETIMEtoInt64(ftLocal) == FT_FAT_UNKNOWNLOCAL)
        return E_FAIL;

    FileTimeToSystemTime(pft, &st);
    pv->vt = VT_DATE;
    return SystemTimeToVariantTime(&st, &pv->date) ? S_OK : E_FAIL; // delay load...
}

// Note: will allocate it for you if you pass NULL pszBuf
STDAPI_(LPTSTR) VariantToStr(const VARIANT *pvar, LPWSTR pszBuf, int cchBuf)
{
    TCHAR szBuf[INFOTIPSIZE];

    if (pszBuf)
    {
        DEBUGWhackPathBuffer(pszBuf, cchBuf);
    }
    else
    {
        pszBuf = szBuf;
        cchBuf = ARRAYSIZE(szBuf);
    }
    *pszBuf = 0;

    BOOL fDone = FALSE;
    if (pvar->vt == VT_DATE) // we want our date formatting
    {
        USHORT wDosDate, wDosTime;
        if (VariantTimeToDosDateTime(pvar->date, &wDosDate, &wDosTime))
        {
            DosTimeToDateTimeString(wDosDate, wDosTime, pszBuf, cchBuf, 0);
            fDone = TRUE;
        }
    }

    if (!fDone)
    {
        VARIANT varDst = {0};

        if (VT_BSTR != pvar->vt)
        {
            if (S_OK == VariantChangeType(&varDst, (VARIANT*)pvar, 0, VT_BSTR))
            {
                ASSERT(VT_BSTR == varDst.vt);

                pvar = &varDst;
            }
            else
                pszBuf = NULL; // error
        }

        if (VT_BSTR == pvar->vt && pvar->bstrVal)
        {
            StringCchCopy(pszBuf, cchBuf, pvar->bstrVal);
        }
        else
        {
            pszBuf = NULL; // something bad happened
        }

        if (pvar == &varDst)
            VariantClear(&varDst);
    }

    if (pszBuf == szBuf)
        return StrDup(szBuf);
    else
        return pszBuf;
}


// ---------------------------------------------------
// [in,out] pvar:  [in] initialized with property bag data
//                 [out] data in format vtDesired or VT_EMPTY if no conversion
// [in] vtDesired: [in] type to convert to, or VT_EMPTY to accept all types of data
//
STDAPI VariantChangeTypeForRead(VARIANT *pvar, VARTYPE vtDesired)
{
    HRESULT hr = S_OK;

    if ((pvar->vt != vtDesired) && (vtDesired != VT_EMPTY))
    {
        VARIANT varTmp;
        VARIANT varSrc;

        // cache a copy of [in]pvar in varSrc - we will free this later
        CopyMemory(&varSrc, pvar, sizeof(varSrc));
        VARIANT* pvarToCopy = &varSrc;

        // oleaut's VariantChangeType doesn't support
        // hex number string -> number conversion, which we want,
        // so convert those to another format they understand.
        //
        // if we're in one of these cases, varTmp will be initialized
        // and pvarToCopy will point to it instead
        //
        if (VT_BSTR == varSrc.vt)
        {
            switch (vtDesired)
            {
                case VT_I1:
                case VT_I2:
                case VT_I4:
                case VT_INT:
                {
                    if (StrToIntExW(varSrc.bstrVal, STIF_SUPPORT_HEX, &varTmp.intVal))
                    {
                        varTmp.vt = VT_INT;
                        pvarToCopy = &varTmp;
                    }
                    break;
                }

                case VT_UI1:
                case VT_UI2:
                case VT_UI4:
                case VT_UINT:
                {
                    if (StrToIntExW(varSrc.bstrVal, STIF_SUPPORT_HEX, (int*)&varTmp.uintVal))
                    {
                        varTmp.vt = VT_UINT;
                        pvarToCopy = &varTmp;
                    }
                    break;
                }
            }
        }

        // clear our [out] buffer, in case VariantChangeType fails
        VariantInit(pvar);

        hr = VariantChangeType(pvar, pvarToCopy, 0, vtDesired);

        // clear the cached [in] value
        VariantClear(&varSrc);
        // if initialized, varTmp is VT_UINT or VT_UINT, neither of which need VariantClear
    }

    return hr;
}




// ---------------------------------------------------
//
// Other conversion functions
//

STDAPI_(BSTR) SysAllocStringA(LPCSTR psz)
{
    if (psz)
    {
        WCHAR wsz[INFOTIPSIZE];  // assumes INFOTIPSIZE number of chars max

        SHAnsiToUnicode(psz, wsz, ARRAYSIZE(wsz));
        return SysAllocString(wsz);
    }
    return NULL;
}

STDAPI StringToStrRetW(LPCWSTR pszName, STRRET *pStrRet)
{
    pStrRet->uType = STRRET_WSTR;
    return SHStrDupW(pszName, &pStrRet->pOleStr);
}

STDAPI_(void) DosTimeToDateTimeString(WORD wDate, WORD wTime, LPTSTR pszText, UINT cchText, int fmt)
{
    FILETIME ft;
    DWORD dwFlags = FDTF_DEFAULT;

    // Netware directories do not have dates...
    if (wDate == 0)
    {
        *pszText = 0;
        return;
    }

    DosDateTimeToFileTime(wDate, wTime, &ft);
    switch (fmt) {
    case LVCFMT_LEFT_TO_RIGHT :
        dwFlags |= FDTF_LTRDATE;
        break;
    case LVCFMT_RIGHT_TO_LEFT :
        dwFlags |= FDTF_RTLDATE;
        break;
    }
    SHFormatDateTime(&ft, &dwFlags, pszText, cchText);
}

STDAPI GetDateProperty(IShellFolder2 *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, FILETIME *pft)
{
    VARIANT var = {0};
    HRESULT hr = psf->GetDetailsEx(pidl, pscid, &var);
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        if (VT_DATE == var.vt)
        {
            SYSTEMTIME st;
            if (VariantTimeToSystemTime(var.date, &st) && SystemTimeToFileTime(&st, pft))
            {
                hr = S_OK;
            }
        }

        VariantClear(&var); // Done with it.
    }
    return hr;
}

STDAPI GetLongProperty(IShellFolder2 *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, ULONGLONG *pullVal)
{
    *pullVal = 0;

    VARIANT var = {0};
    HRESULT hr = psf->GetDetailsEx(pidl, pscid, &var);
    if (SUCCEEDED(hr))
    {
        if (VT_UI8 == var.vt)
        {
            *pullVal = var.ullVal;
            hr = S_OK;
        }
        else
        {
            VARIANT varLong = {0};
            hr = VariantChangeType(&varLong, &var, 0, VT_UI8);
            if (SUCCEEDED(hr))
            {
                *pullVal = varLong.ullVal;
                VariantClear(&varLong);
            }
        }
        VariantClear(&var); // Done with it.
    }
    return hr;
}

STDAPI GetStringProperty(IShellFolder2 *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, LPTSTR pszVal, int cchMax)
{
    *pszVal = 0;

    VARIANT var = {0};
    HRESULT hr = psf->GetDetailsEx(pidl, pscid, &var);
    if (SUCCEEDED(hr))
    {
        hr = VariantToStr(&var, pszVal, cchMax) ? S_OK : E_FAIL;
        VariantClear(&var); // Done with it.
    }
    return hr;
}

STDAPI QueryInterfaceVariant(VARIANT v, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = E_NOINTERFACE;

    if ((VT_UNKNOWN == v.vt) && v.punkVal)
    {
        hr = v.punkVal->QueryInterface(riid, ppv);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\util.cpp ===
#include "stock.h"
#pragma hdrstop

#include <idhidden.h>
#include <regitemp.h>
#include <shstr.h>
#include <shlobjp.h>
#include <lmcons.h>
#include <validc.h>
#include "ccstock2.h"
#include "wininet.h"
#include "w95wraps.h"
#include <strsafe.h>

//------------------------------------------------------------------------
// Random helpful functions
//------------------------------------------------------------------------
//
STDAPI_(LPCTSTR) SkipServerSlashes(LPCTSTR pszName)
{
    for (pszName; *pszName && *pszName == TEXT('\\'); pszName++);

    return pszName;
}


// pbIsNamed is true if the i-th item in hm is a named separator
STDAPI_(BOOL) _SHIsMenuSeparator2(HMENU hm, int i, BOOL *pbIsNamed)
{
    MENUITEMINFO mii;
    BOOL bLocal;

    if (!pbIsNamed)
        pbIsNamed = &bLocal;
        
    *pbIsNamed = FALSE;

    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_TYPE | MIIM_ID;
    mii.cch = 0;    // WARNING: We MUST initialize it to 0!!!
    if (GetMenuItemInfo(hm, i, TRUE, &mii) && (mii.fType & MFT_SEPARATOR))
    {
        // NOTE that there is a bug in either 95 or NT user!!!
        // 95 returns 16 bit ID's and NT 32 bit therefore there is a
        // the following may fail, on win9x, to evaluate to false
        // without casting
        *pbIsNamed = ((WORD)mii.wID != (WORD)-1);
        return TRUE;
    }
    return FALSE;
}

STDAPI_(BOOL) _SHIsMenuSeparator(HMENU hm, int i)
{
    return _SHIsMenuSeparator2(hm, i, NULL);
}

//
// _SHPrettyMenu -- make this menu look darn purty
//
// Prune the separators in this hmenu to ensure there isn't one in the first or last
// position and there aren't any runs of >1 separator.
//
// Named separators take precedence over regular separators.
//
STDAPI_(void) _SHPrettyMenu(HMENU hm)
{
    BOOL bSeparated = TRUE;
    BOOL bWasNamed = TRUE;

    for (int i = GetMenuItemCount(hm) - 1; i > 0; --i)
    {
        BOOL bIsNamed;
        if (_SHIsMenuSeparator2(hm, i, &bIsNamed))
        {
            if (bSeparated)
            {
                // if we have two separators in a row, only one of which is named
                // remove the non named one!
                if (bIsNamed && !bWasNamed)
                {
                    DeleteMenu(hm, i+1, MF_BYPOSITION);
                    bWasNamed = bIsNamed;
                }
                else
                {
                    DeleteMenu(hm, i, MF_BYPOSITION);
                }
            }
            else
            {
                bWasNamed = bIsNamed;
                bSeparated = TRUE;
            }
        }
        else
        {
            bSeparated = FALSE;
        }
    }

    // The above loop does not handle the case of many separators at
    // the beginning of the menu
    while (_SHIsMenuSeparator2(hm, 0, NULL))
    {
        DeleteMenu(hm, 0, MF_BYPOSITION);
    }
}

STDAPI_(DWORD) SHIsButtonObscured(HWND hwnd, PRECT prc, INT_PTR i)
{
    ASSERT(IsWindow(hwnd));
    ASSERT(i < SendMessage(hwnd, TB_BUTTONCOUNT, 0, 0));

    DWORD dwEdge = 0;

    RECT rc, rcInt;
    SendMessage(hwnd, TB_GETITEMRECT, i, (LPARAM)&rc);

    if (!IntersectRect(&rcInt, prc, &rc))
    {
        dwEdge = EDGE_LEFT | EDGE_RIGHT | EDGE_TOP | EDGE_BOTTOM;
    }
    else
    {
        if (rc.top != rcInt.top)
            dwEdge |= EDGE_TOP;

        if (rc.bottom != rcInt.bottom)
            dwEdge |= EDGE_BOTTOM;

        if (rc.left != rcInt.left)
            dwEdge |= EDGE_LEFT;

        if (rc.right != rcInt.right)
            dwEdge |= EDGE_RIGHT;
    }

    return dwEdge;
}

STDAPI_(BYTE) SHBtnStateFromRestriction(DWORD dwRest, BYTE fsState)
{
    if (dwRest == RESTOPT_BTN_STATE_VISIBLE)
        return (fsState & ~TBSTATE_HIDDEN);
    else if (dwRest == RESTOPT_BTN_STATE_HIDDEN)
        return (fsState | TBSTATE_HIDDEN);
    else {
#ifdef DEBUG
        if (dwRest != RESTOPT_BTN_STATE_DEFAULT)
            TraceMsg(TF_ERROR, "bad toolbar button state policy %x", dwRest);
#endif
        return fsState;
    }
}

//
// SHIsDisplayable
//
// Figure out if this unicode string can be displayed by the system
// (i.e., won't be turned into a string of question marks).
//
STDAPI_(BOOL) SHIsDisplayable(LPCWSTR pwszName, BOOL fRunOnFE, BOOL fRunOnNT5)
{
    BOOL fNotDisplayable = FALSE;

    if (pwszName)
    {
        if (!fRunOnNT5)
        {
            // if WCtoMB has to use default characters in mapping pwszName to multibyte,
            // it sets fNotDisplayable == TRUE, in which case we have to use something
            // else for the title string.
            WideCharToMultiByte(CP_ACP, 0, pwszName, -1, NULL, 0, NULL, &fNotDisplayable);
            if (fNotDisplayable)
            {
                if (fRunOnFE)
                {
                    WCHAR wzName[INTERNET_MAX_URL_LENGTH];

                    BOOL fReplaceNbsp = FALSE;

                    StrCpyNW(wzName, pwszName, ARRAYSIZE(wzName));
                    for (int i = 0; i < ARRAYSIZE(wzName); i++)
                    {
                        if (0x00A0 == wzName[i])    // if &nbsp
                        {
                            wzName[i] = 0x0020;     // replace to space
                            fReplaceNbsp = TRUE;
                        }
                        else if (0 == wzName[i])
                            break;
                    }
                    if (fReplaceNbsp)
                    {
                        pwszName = wzName;
                        WideCharToMultiByte(CP_ACP, 0, pwszName, -1, NULL, 0, NULL, &fNotDisplayable);
                    }
                }
            }
        }
    }

    return !fNotDisplayable;
}

// Trident will take URLs that don't indicate their source of
// origin (about:, javascript:, & vbscript:) and will append
// an URL turd and then the source URL.  The turd will indicate
// where the source URL begins and that source URL is needed
// when the action needs to be Zone Checked.
//
// This function will remove that URL turd and everything behind
// it so the URL is presentable for the user.

#define URL_TURD        ((TCHAR)0x01)

STDAPI_(void) SHRemoveURLTurd(LPTSTR pszUrl)
{
    if (!pszUrl)
        return;

    while (0 != pszUrl[0])
    {
        if (URL_TURD == pszUrl[0])
        {
            pszUrl[0] = 0;
            break;
        }

        pszUrl = CharNext(pszUrl);
    }
}

STDAPI_(BOOL) SetWindowZorder(HWND hwnd, HWND hwndInsertAfter)
{
    return SetWindowPos(hwnd, hwndInsertAfter, 0, 0, 0, 0,
            SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
}

BOOL CALLBACK _FixZorderEnumProc(HWND hwnd, LPARAM lParam)
{
    HWND hwndTest = (HWND)lParam;
    HWND hwndOwner = hwnd;

    while (hwndOwner = GetWindow(hwndOwner, GW_OWNER))
    {
        if (hwndOwner == hwndTest)
        {
            TraceMsg(TF_WARNING, "_FixZorderEnumProc: Found topmost window %x owned by non-topmost window %x, fixing...", hwnd, hwndTest);
            SetWindowZorder(hwnd, HWND_NOTOPMOST);
#ifdef DEBUG
            if (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST)
                TraceMsg(TF_ERROR, "_FixZorderEnumProc: window %x is still topmost", hwnd);
#endif
            break;
        }
    }

    return TRUE;
}

STDAPI_(BOOL) SHForceWindowZorder(HWND hwnd, HWND hwndInsertAfter)
{
    BOOL fRet = SetWindowZorder(hwnd, hwndInsertAfter);

    if (fRet && hwndInsertAfter == HWND_TOPMOST)
    {
        if (!(GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST))
        {
            //
            // user didn't actually move the hwnd to topmost
            //
            // According to GerardoB, this can happen if the window has
            // an owned window that somehow has become topmost while the 
            // owner remains non-topmost, i.e., the two have become
            // separated in the z-order.  In this state, when the owner
            // window tries to make itself topmost, the call will
            // silently fail.
            //
            // TERRIBLE HORRIBLE NO GOOD VERY BAD HACK
            //
            // Hacky fix is to enumerate the toplevel windows, check to see
            // if any are topmost and owned by hwnd, and if so, make them
            // non-topmost.  Then, retry the SetWindowPos call.
            //

            TraceMsg(TF_WARNING, "SHForceWindowZorder: SetWindowPos(%x, HWND_TOPMOST) failed", hwnd);

            // Fix up the z-order
            EnumWindows(_FixZorderEnumProc, (LPARAM)hwnd);

            // Retry the set.  (This should make all owned windows topmost as well.)
            SetWindowZorder(hwnd, HWND_TOPMOST);

#ifdef DEBUG
            if (!(GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST))
                TraceMsg(TF_ERROR, "SHForceWindowZorder: window %x is still not topmost", hwnd);
#endif
        }
    }

    return fRet;
}

STDAPI_(LPITEMIDLIST) ILCloneParent(LPCITEMIDLIST pidl)
{   
    LPITEMIDLIST pidlParent = ILClone(pidl);
    if (pidlParent)
        ILRemoveLastID(pidlParent);

    return pidlParent;
}


// in:
//      psf     OPTIONAL, if NULL assume psfDesktop
//      pidl    to bind to from psfParent
//

STDAPI SHBindToObject(IShellFolder *psf, REFIID riid, LPCITEMIDLIST pidl, void **ppv)
{
    // NOTE: callers should use SHBindToObjectEx!!!
    return SHBindToObjectEx(psf, pidl, NULL, riid, ppv);
}


// in:
//      psf     OPTIONAL, if NULL assume psfDesktop
//      pidl    to bind to from psfParent
//      pbc     bind context

STDAPI SHBindToObjectEx(IShellFolder *psf, LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr;
    IShellFolder *psfRelease = NULL;

    if (!psf)
    {
        SHGetDesktopFolder(&psf);
        psfRelease = psf;
    }

    if (psf)
    {
        if (!pidl || ILIsEmpty(pidl))
        {
            hr = psf->QueryInterface(riid, ppv);
        }
        else
        {
            hr = psf->BindToObject(pidl, pbc, riid, ppv);
        }
    }
    else
    {
        *ppv = NULL;
        hr = E_FAIL;
    }

    if (psfRelease)
    {
        psfRelease->Release();
    }

    if (SUCCEEDED(hr) && (*ppv == NULL))
    {
        // Some shell extensions (eg WS_FTP) will return success and a null out pointer
        TraceMsg(TF_WARNING, "SHBindToObjectEx: BindToObject succeeded but returned null ppv!!");
        hr = E_FAIL;
    }

    return hr;
}

// psfRoot is the base of the bind.  If NULL, then we use the shell desktop.
// If you want to bind relative to the explorer root (e.g., CabView, MSN),
// then use SHBindToIDListParent.
STDAPI SHBindToFolderIDListParent(IShellFolder *psfRoot, LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
{
    HRESULT hr;

    // Old shell32 code in some cases simply whacked the pidl,
    // but this is unsafe.  Do what shdocvw does and clone/remove:
    //
    LPITEMIDLIST pidlParent = ILCloneParent(pidl);
    if (pidlParent) 
    {
        hr = SHBindToObjectEx(psfRoot, pidlParent, NULL, riid, ppv);
        ILFree(pidlParent);
    }
    else
        hr = E_OUTOFMEMORY;

    if (ppidlLast)
        *ppidlLast = ILFindLastID(pidl);

    return hr;
}

//
//  Warning!  brutil.cpp overrides this function
//
STDAPI SHBindToIDListParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
{
    return SHBindToFolderIDListParent(NULL, pidl, riid, ppv, ppidlLast);
}

// should be IUnknown_GetIDList()

STDAPI SHGetIDListFromUnk(IUnknown *punk, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;

    HRESULT hr = E_NOINTERFACE;
    if (punk)
    {
        IPersistFolder2 *ppf;
        IPersistIDList *pperid;
        if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IPersistIDList, &pperid))))
        {
            hr = pperid->GetIDList(ppidl);
            pperid->Release();
        }
        else if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IPersistFolder2, &ppf))))
        {
            hr = ppf->GetCurFolder(ppidl);
            ppf->Release();
        }
    }
    return hr;
}

//
//  generically useful to hide.
//
#pragma pack(1)
typedef struct _HIDDENCLSID
{
    HIDDENITEMID hid;
    CLSID   clsid;
} HIDDENCLSID;
#pragma pack()

typedef UNALIGNED HIDDENCLSID *PHIDDENCLSID;
typedef const UNALIGNED HIDDENCLSID *PCHIDDENCLSID;

STDAPI_(LPITEMIDLIST) ILAppendHiddenClsid(LPITEMIDLIST pidl, IDLHID id, CLSID *pclsid)
{
    HIDDENCLSID hc = {{sizeof(hc), 0, id}};
    hc.clsid = *pclsid;
    //  WARNING - cannot use hid.wVersion for compat reasons - ZekeL - 23-OCT-2000
    //  on win2k and winMe we appended clsid's with wVersion 
    //  as stack garbage.  this means we cannot use it for anything
    return ILAppendHiddenID(pidl, &hc.hid);
}

STDAPI_(BOOL) ILGetHiddenClsid(LPCITEMIDLIST pidl, IDLHID id, CLSID *pclsid)
{
    PCHIDDENCLSID phc = (PCHIDDENCLSID) ILFindHiddenID(pidl, id);
    //  WARNING - cannot use hid.wVersion for compat reasons - ZekeL - 23-OCT-2000
    //  on win2k and winMe we appended clsid's with wVersion 
    //  as stack garbage.  this means we cannot use it for anything
    if (phc)
    {
        *pclsid = phc->clsid;
        return TRUE;
    }
    return FALSE;
}

#pragma pack(1)
typedef struct _HIDDENSTRINGA
{
    HIDDENITEMID hid;
    WORD    type;
    CHAR    sz[1];   //  variable length string
} HIDDENSTRINGA;
#pragma pack()

typedef UNALIGNED HIDDENSTRINGA *PHIDDENSTRINGA;
typedef const UNALIGNED HIDDENSTRINGA *PCHIDDENSTRINGA;

#pragma pack(1)
typedef struct _HIDDENSTRINGW
{
    HIDDENITEMID hid;
    WORD    type;
    WCHAR   sz[1];   //  canonical name to be passed to ISTRING
} HIDDENSTRINGW;
#pragma pack()

typedef UNALIGNED HIDDENSTRINGW *PHIDDENSTRINGW;
typedef const UNALIGNED HIDDENSTRINGW *PCHIDDENSTRINGW;

#define HIDSTRTYPE_ANSI        0x0001
#define HIDSTRTYPE_WIDE        0x0002

#define HIDSTR_MAX             0xF000   // max ushort - sizeof(HIDDENSTRINGW) - other goo for original pidl

STDAPI_(LPITEMIDLIST) ILAppendHiddenStringW(LPITEMIDLIST pidl, IDLHID id, LPCWSTR psz)
{
    //  terminator is included in the ID definition
    size_t  cbString;
    HRESULT hr = StringCbLengthW(psz, HIDSTR_MAX, &cbString);
    if (FAILED(hr))
    {
        return NULL;
    }
    USHORT cb = (USHORT)(sizeof(HIDDENSTRINGW) + cbString);
    
    //
    // Use HIDDENSTRINGW* here instead of PHIDDENSTRINGW which is defined
    // as UNALIGNED.
    //

    HIDDENSTRINGW *phs = (HIDDENSTRINGW *) LocalAlloc(LPTR, cb);

    if (phs)
    {
        phs->hid.cb = cb;
        phs->hid.id = id;
        phs->type = HIDSTRTYPE_WIDE;
        //
        // Terminator is included in the ID definition but...
        // we need to now account for that extra character
        // when we copy the hidden string.
        //
        StringCbCopyW(phs->sz, cbString + sizeof(*psz), psz);

        pidl = ILAppendHiddenID(pidl, &phs->hid);
        LocalFree(phs);
        return pidl;
    }
    return NULL;
}
    
STDAPI_(LPITEMIDLIST) ILAppendHiddenStringA(LPITEMIDLIST pidl, IDLHID id, LPCSTR psz)
{
    //  terminator is included in the ID definition
    size_t  cbString;
    HRESULT hr = StringCbLengthA(psz, HIDSTR_MAX, &cbString);
    if (FAILED(hr))
    {
        return NULL;
    }
    USHORT cb = (USHORT)(sizeof(HIDDENSTRINGA) + cbString);
    
    //
    // Use HIDDENSTRINGA* here instead of PHIDDENSTRINGW which is defined
    // as UNALIGNED.
    //

    HIDDENSTRINGA *phs = (HIDDENSTRINGA *) LocalAlloc(LPTR, cb);

    if (phs)
    {
        phs->hid.cb = cb;
        phs->hid.id = id;
        phs->type = HIDSTRTYPE_ANSI;
        //
        // Terminator is included in the ID definition but...
        // we need to now account for that extra character
        // when we copy the hidden string.
        //
        StringCbCopyA(phs->sz, cbString + sizeof(*psz), psz);

        pidl = ILAppendHiddenID(pidl, &phs->hid);
        LocalFree(phs);
        return pidl;
    }
    return NULL;
}

STDAPI_(void *) _MemDupe(const UNALIGNED void *pv, DWORD cb)
{
    void *pvRet = LocalAlloc(LPTR, cb);
    if (pvRet)
    {
        CopyMemory(pvRet, pv, cb);
    }

    return pvRet;
}

STDAPI_(BOOL) ILGetHiddenStringW(LPCITEMIDLIST pidl, IDLHID id, LPWSTR psz, DWORD cch)
{
    PCHIDDENSTRINGW phs = (PCHIDDENSTRINGW) ILFindHiddenID(pidl, id);

    RIP(psz);
    if (phs)
    {
        if (phs->type == HIDSTRTYPE_WIDE)
        {
            ualstrcpynW(psz, phs->sz, cch);
            return TRUE;
        }
        else 
        {
            ASSERT(phs->type == HIDSTRTYPE_ANSI);
            SHAnsiToUnicode((LPSTR)phs->sz, psz, cch);
            return TRUE;
        }
    }
    return FALSE;
}
        
STDAPI_(BOOL) ILGetHiddenStringA(LPCITEMIDLIST pidl, IDLHID id, LPSTR psz, DWORD cch)
{
    PCHIDDENSTRINGW phs = (PCHIDDENSTRINGW) ILFindHiddenID(pidl, id);

    RIP(psz);
    if (phs)
    {
        if (phs->type == HIDSTRTYPE_ANSI)
        {
            ualstrcpynA(psz, (LPSTR)phs->sz, cch);
            return TRUE;
        }
        else 
        {
            ASSERT(phs->type == HIDSTRTYPE_WIDE);
            //  we need to handle the unalignment here...
            LPWSTR pszT = (LPWSTR) _MemDupe(phs->sz, CbFromCch(ualstrlenW(phs->sz) +1));

            if (pszT)
            {
                SHUnicodeToAnsi(pszT, psz, cch);
                LocalFree(pszT);
                return TRUE;
            }
        }
    }
    return FALSE;
}

STDAPI_(int) ILCompareHiddenString(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, IDLHID id)
{

    // if there are fragments in here, then they might
    // differentiate the two pidls
    PCHIDDENSTRINGW ps1 = (PCHIDDENSTRINGW)ILFindHiddenID(pidl1, id);
    PCHIDDENSTRINGW ps2 = (PCHIDDENSTRINGW)ILFindHiddenID(pidl2, id);

    if (ps1 && ps2)
    {
        if (ps1->type == ps2->type)
        {
            if (ps1->type == HIDSTRTYPE_WIDE)
                return ualstrcmpW(ps1->sz, ps2->sz);

            ASSERT(ps1->type == HIDSTRTYPE_ANSI);

            return lstrcmpA((LPCSTR)ps1->sz, (LPCSTR)ps2->sz);
        }
        else
        {
            SHSTRW str;

            if (ps1->type == HIDSTRTYPE_ANSI)
            {
                str.SetStr((LPCSTR)ps1->sz);
                return ualstrcmpW(str, ps2->sz);
            }
            else
            {
                ASSERT(ps2->type == HIDSTRTYPE_ANSI);
                str.SetStr((LPCSTR)ps2->sz);
                return ualstrcmpW(ps1->sz, str);
            }
        }
    }

    if (ps1)
        return 1;
    if (ps2)
        return -1;
    return 0;
}

STDAPI_(OBJCOMPATFLAGS) SHGetObjectCompatFlagsFromIDList(LPCITEMIDLIST pidl)
{
    OBJCOMPATFLAGS ocf = 0;
    CLSID clsid;

    //  APPCOMPAT: FileNet IDMDS (Panagon)'s shell folder extension returns
    //  E_NOTIMPL for IPersistFolder::GetClassID, so to detect the application,
    //  we have to crack the pidl.  (B#359464: tracysh)

    if (!ILIsEmpty(pidl)
    && pidl->mkid.cb >= sizeof(IDREGITEM)
    && pidl->mkid.abID[0] == SHID_ROOT_REGITEM)
    {
        clsid = ((LPCIDLREGITEM)pidl)->idri.clsid;
        ocf = SHGetObjectCompatFlags(NULL, &clsid);
    }

    return ocf;
}


STDAPI_(LPITEMIDLIST) _ILCreate(UINT cbSize)
{
    LPITEMIDLIST pidl = (LPITEMIDLIST)SHAlloc(cbSize);
    if (pidl)
        memset(pidl, 0, cbSize);      // zero-init for external task allocator

    return pidl;
}

//
// ILClone using Task allocator
//
STDAPI SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST * ppidlOut)
{
    *ppidlOut = ILClone(pidl);
    return *ppidlOut ? S_OK : E_OUTOFMEMORY;
}

//
// ILCombine using Task allocator
//
STDAPI SHILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST * ppidlOut)
{
    *ppidlOut = ILCombine(pidl1, pidl2);
    return *ppidlOut ? S_OK : E_OUTOFMEMORY;
}

//
//  rooted helpers
//
LPCIDREGITEM _IsRooted(LPCITEMIDLIST pidl)
{
    LPCIDREGITEM pidlr = (LPCIDREGITEM)pidl;
    if (!ILIsEmpty(pidl)
    && pidlr->cb > sizeof(IDREGITEM)
    && pidlr->bFlags == SHID_ROOTEDREGITEM)
        return pidlr;

    return NULL;
}

STDAPI_(BOOL) ILIsRooted(LPCITEMIDLIST pidl)
{
    return (NULL != _IsRooted(pidl));
}

#define _ROOTEDPIDL(pidlr)      (LPITEMIDLIST)(((LPBYTE)pidlr)+sizeof(IDREGITEM))

STDAPI_(LPCITEMIDLIST) ILRootedFindIDList(LPCITEMIDLIST pidl)
{
    LPCIDREGITEM pidlr = _IsRooted(pidl);

    if (pidlr && pidlr->cb > sizeof(IDREGITEM))
    {
        //  then we have a rooted IDList in there
        return _ROOTEDPIDL(pidlr);
    }

    return NULL;
}

STDAPI_(BOOL) ILRootedGetClsid(LPCITEMIDLIST pidl, CLSID *pclsid)
{
    LPCIDREGITEM pidlr = _IsRooted(pidl);

    *pclsid = pidlr ? pidlr->clsid : CLSID_NULL;

    return (NULL != pidlr);
}

STDAPI_(LPITEMIDLIST) ILRootedCreateIDList(CLSID *pclsid, LPCITEMIDLIST pidl)
{
    UINT cbPidl = ILGetSize(pidl);
    UINT cbTotal = sizeof(IDREGITEM) + cbPidl;

    LPIDREGITEM pidlr = (LPIDREGITEM) SHAlloc(cbTotal + sizeof(WORD));

    if (pidlr)
    {
        pidlr->cb = (WORD)cbTotal;

        pidlr->bFlags = SHID_ROOTEDREGITEM;
        pidlr->bOrder = 0;              // Nobody uses this (yet)

        if (pclsid)
            pidlr->clsid = *pclsid;
        else
            pidlr->clsid = CLSID_ShellDesktop;

        MoveMemory(_ROOTEDPIDL(pidlr), pidl, cbPidl);

        //  terminate
        _ILNext((LPITEMIDLIST)pidlr)->mkid.cb = 0;
    }

    return (LPITEMIDLIST) pidlr;
}

int CompareGUID(REFGUID guid1, REFGUID guid2)
{
    TCHAR sz1[GUIDSTR_MAX];
    TCHAR sz2[GUIDSTR_MAX];

    SHStringFromGUIDW(guid1, sz1, SIZECHARS(sz1));
    SHStringFromGUIDW(guid2, sz2, SIZECHARS(sz2));

    return lstrcmp(sz1, sz2);
}

STDAPI_(int) ILRootedCompare(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRet;
    LPCIDREGITEM pidlr1 = _IsRooted(pidl1);
    LPCIDREGITEM pidlr2 = _IsRooted(pidl2);

    if (pidlr1 && pidlr2)
    {
        CLSID clsid1 = pidlr1->clsid;
        CLSID clsid2 = pidlr2->clsid;

        iRet = CompareGUID(clsid1, clsid2);
        if (0 == iRet)
        {
            if (!ILIsEqual(_ROOTEDPIDL(pidl1), _ROOTEDPIDL(pidl2)))
            {
                IShellFolder *psfDesktop;
                if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
                {
                    HRESULT hr = psfDesktop->CompareIDs(0, _ROOTEDPIDL(pidl1), _ROOTEDPIDL(pidl2));
                    psfDesktop->Release();
                    iRet = ShortFromResult(hr);
                }
            }
        }
    }
    else if (pidlr1)
    {
        iRet = -1;
    }
    else if (pidlr2)
    {
        iRet = 1;
    }
    else
    {
        //  if neither are rootes, then they share the desktop
        //  as the same root...
        iRet = 0;
    }

    return iRet;
}

LPITEMIDLIST ILRootedTranslate(LPCITEMIDLIST pidlRooted, LPCITEMIDLIST pidlTrans)
{
    LPCITEMIDLIST pidlChild = ILFindChild(ILRootedFindIDList(pidlRooted), pidlTrans);

    if (pidlChild)
    {
        LPITEMIDLIST pidlRoot = ILCloneFirst(pidlRooted);

        if (pidlRoot)
        {
            LPITEMIDLIST pidlRet = ILCombine(pidlRoot, pidlChild);
            ILFree(pidlRoot);
            return pidlRet;
        }
    }
    return NULL;
}

const ITEMIDLIST s_idlNULL = { 0 } ;

HRESULT ILRootedBindToRoot(LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    HRESULT hr;
    CLSID clsid;
    ASSERT(ILIsRooted(pidl));

    ILRootedGetClsid(pidl, &clsid);
    pidl = ILRootedFindIDList(pidl);
    if (!pidl)
        pidl = &s_idlNULL;
    
    if (IsEqualGUID(clsid, CLSID_ShellDesktop))
    {
        hr = SHBindToObjectEx(NULL, pidl, NULL, riid, ppv);
    }
    else
    {
        IPersistFolder* ppf;
        hr = SHCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IPersistFolder, &ppf));
        if (SUCCEEDED(hr))
        {
            hr = ppf->Initialize(pidl);

            if (SUCCEEDED(hr))
            {
                hr = ppf->QueryInterface(riid, ppv);
            }
            ppf->Release();
        }
    }
    return hr;
}

HRESULT ILRootedBindToObject(LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    IShellFolder *psf;
    HRESULT hr = ILRootedBindToRoot(pidl, IID_PPV_ARG(IShellFolder, &psf));

    if (SUCCEEDED(hr))
    {
        pidl = _ILNext(pidl);

        if (ILIsEmpty(pidl))
            hr = psf->QueryInterface(riid, ppv);
        else
            hr = psf->BindToObject(pidl, NULL, riid, ppv);
    }
    return hr;
}

HRESULT ILRootedBindToParentFolder(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlChild)
{
    //
    //  there are three different cases to handle
    //  
    //  1.  Rooted pidl Alone
    //      [ rooted id [ target pidl ] ]
    //      return the parent folder of the target pidl
    //      and return its last id in ppidlChild 
    //  
    //  2.  Rooted pidl with One Child
    //      [ rooted id [ target pidl ] ][ child id ]
    //      return the rooted id as the parent folder
    //      and the child id in ppidlChild
    //  
    //  3. rooted pidl with many children
    //      [ rooted id [ target pidl ] ][ parent id ][ child id ]
    //      return rooted id bound to parent id as the folder
    //      and the child id in ppidlchild
    //
    
    HRESULT hr;
    ASSERT(ILIsRooted(pidl));

    //
    //  if this is a rooted pidl and it is just the root
    //  then we can bind to the target pidl of the root instead
    //
    if (ILIsEmpty(_ILNext(pidl)))
    {
        hr = SHBindToIDListParent(ILRootedFindIDList(pidl), riid, ppv, ppidlChild);
    }
    else
    {
        LPITEMIDLIST pidlParent = ILCloneParent(pidl);
        if (pidlParent)
        {
            hr = ILRootedBindToObject(pidlParent, riid, ppv);
            ILFree(pidlParent);
        }
        else
            hr = E_OUTOFMEMORY;

        if (ppidlChild)
            *ppidlChild = ILFindLastID(pidl);
    }


    return hr;
}

#define HIDA_GetPIDLItem(pida, i)       (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[i+1])
#define HIDA_GetPIDLFolder(pida)        (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[0])

STDAPI_(LPITEMIDLIST) IDA_ILClone(LPIDA pida, UINT i)
{
    if (i < pida->cidl)
        return ILCombine(HIDA_GetPIDLFolder(pida), HIDA_GetPIDLItem(pida, i));
    return NULL;
}

STDAPI_(void) EnableOKButtonFromString(HWND hDlg, LPTSTR pszText)
{
    BOOL bNonEmpty;
    
    PathRemoveBlanks(pszText);   // REVIEW, should we not remove from the end of
    bNonEmpty = lstrlen(pszText); // Not a BOOL, but okay

    EnableWindow(GetDlgItem(hDlg, IDOK), bNonEmpty);
    if (bNonEmpty)
    {
        SendMessage(hDlg, DM_SETDEFID, IDOK, 0L);
    }
}

STDAPI_(void) EnableOKButtonFromID(HWND hDlg, int id)
{
    TCHAR szText[MAX_PATH];

    if (!GetDlgItemText(hDlg, id, szText, ARRAYSIZE(szText)))
    {
        szText[0] = 0;
    }

    EnableOKButtonFromString(hDlg, szText);
}

//
//  C-callable versions of the ATL string conversion functions.
//

STDAPI_(LPWSTR) SHA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
    ASSERT(lpa != NULL);
    ASSERT(lpw != NULL);
    // verify that no illegal character present
    // since lpw was allocated based on the size of lpa
    // don't worry about the number of chars
    lpw[0] = '\0';
    MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
    return lpw;
}

STDAPI_(LPSTR) SHW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
    ASSERT(lpw != NULL);
    ASSERT(lpa != NULL);
    // verify that no illegal character present
    // since lpa was allocated based on the size of lpw
    // don't worry about the number of chars
    lpa[0] = '\0';
    WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
    return lpa;
}

//
//  Helper functions for SHChangeMenuAsIDList
//
//  See comment in declaration of SHChangeMenuAsIDList for caveats about
//  the pSender member.
//
//  This is tricky because IE 5.0 shipped with a Win64-unfriendly version
//  of this notification, so we have to sniff the structure and see if
//  this is an IE 5.0 style notification or a new Win64 style notification.
//  If an IE 5.0 style notification, then it was not sent by us because
//  we send the new Win64-style notification.
//
STDAPI_(BOOL) SHChangeMenuWasSentByMe(void * self, LPCITEMIDLIST pidlNotify)
{
    SHChangeMenuAsIDList UNALIGNED * pcmidl = (SHChangeMenuAsIDList UNALIGNED *)pidlNotify;
    return pcmidl->cb >= FIELD_OFFSET(SHChangeMenuAsIDList, cbZero) &&
           pcmidl->pSender == (INT64)self &&
           pcmidl->dwProcessID == GetCurrentProcessId();
}

//
//
//  Send out an extended event changenotify, using a SHChangeMenuAsIDList
//  as the pidl1 so recipients can identify whether they were the
//  sender or not.
//
//  It's okay to pass self==NULL here.  It means you don't care about
//  detecting whether it was sent by you or not.
//

STDAPI_(void) SHSendChangeMenuNotify(void * self, DWORD shcnee, DWORD shcnf, LPCITEMIDLIST pidl2)
{
    SHChangeMenuAsIDList cmidl;

    cmidl.cb          = FIELD_OFFSET(SHChangeMenuAsIDList, cbZero);
    cmidl.dwItem1     = shcnee;
    cmidl.pSender     = (INT64)self;
    cmidl.dwProcessID = self ? GetCurrentProcessId() : 0;
    cmidl.cbZero      = 0;

    // Nobody had better have specified a type; the type must be
    // SHCNF_IDLIST.
    ASSERT((shcnf & SHCNF_TYPE) == 0);
    SHChangeNotify(SHCNE_EXTENDED_EVENT, shcnf | SHCNF_IDLIST, (LPCITEMIDLIST)&cmidl, pidl2);
}


// Return FALSE if out of memory
STDAPI_(BOOL) Pidl_Set(LPITEMIDLIST* ppidl, LPCITEMIDLIST pidl)
{
    BOOL bRet = TRUE;
    LPITEMIDLIST pidlNew;

    ASSERT(IS_VALID_WRITE_PTR(ppidl, LPITEMIDLIST));
    ASSERT(NULL == *ppidl || IS_VALID_PIDL(*ppidl));
    ASSERT(NULL == pidl || IS_VALID_PIDL(pidl));

    if (pidl)
    {
        pidlNew = ILClone(pidl);
        if (!pidlNew)
        {
            bRet = FALSE;   // failed to clone the pidl (out of memory)
        }
    }
    else
    {
        pidlNew = NULL;
    }

    LPITEMIDLIST pidlToFree = (LPITEMIDLIST)InterlockedExchangePointer((void **)ppidl, (void *)pidlNew);
    if (pidlToFree) 
    {
        ILFree(pidlToFree);
    }

    return bRet;
}

//  this needs to be the last thing in the file that uses ILClone, because everywhere
//  else, ILClone becomes SafeILClone
#undef ILClone

STDAPI_(LPITEMIDLIST) SafeILClone(LPCITEMIDLIST pidl)
{
    //  the shell32 implementation of ILClone is different for win95 an ie4.
    //  it doesnt check for NULL in the old version, but it does in the new...
    //  so we need to always check
   return pidl ? ILClone(pidl) : NULL;
}

//
// retrieves the UIObject interface for the specified full pidl.
//
STDAPI SHGetUIObjectFromFullPIDL(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv)
{
    *ppv = NULL;

    LPCITEMIDLIST pidlChild;
    IShellFolder* psf;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = psf->GetUIObjectOf(hwnd, 1, &pidlChild, riid, NULL, ppv);
        psf->Release();
    }

    return hr;
}

STDAPI LoadFromFileW(REFCLSID clsid, LPCWSTR pszFile, REFIID riid, void **ppv)
{
    *ppv = NULL;

    IPersistFile *ppf;
    HRESULT hr = SHCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IPersistFile, &ppf));
    if (SUCCEEDED(hr))
    {
        hr = ppf->Load(pszFile, STGM_READ);
        if (SUCCEEDED(hr))
            hr = ppf->QueryInterface(riid, ppv);
        ppf->Release();
    }
    return hr;
}

STDAPI LoadFromIDList(REFCLSID clsid, LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    *ppv = NULL;

    IPersistFolder *ppf;
    HRESULT hr = SHCoCreateInstanceAC(clsid, NULL, CLSCTX_INPROC, IID_PPV_ARG(IPersistFolder, &ppf));
    if (SUCCEEDED(hr))
    {
        hr = ppf->Initialize(pidl);
        if (SUCCEEDED(hr))
        {
            hr = ppf->QueryInterface(riid, ppv);
        }
        ppf->Release();
    }
    return hr;
}

//
// This is a helper function for finding a specific verb's index in a context menu
//
STDAPI_(UINT) GetMenuIndexForCanonicalVerb(HMENU hMenu, IContextMenu *pcm, UINT idCmdFirst, LPCWSTR pwszVerb)
{
    int cMenuItems = GetMenuItemCount(hMenu);
    for (int iItem = 0; iItem < cMenuItems; iItem++)
    {
        MENUITEMINFO mii = {0};

        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_TYPE | MIIM_ID;

        // IS_INTRESOURCE guards against mii.wID == -1 **and** against
        // buggy shell extensions which set their menu item IDs out of range.
        if (GetMenuItemInfo(hMenu, iItem, MF_BYPOSITION, &mii) &&
            !(mii.fType & MFT_SEPARATOR) && IS_INTRESOURCE(mii.wID) &&
            (mii.wID >= idCmdFirst))
        {
            union {
                WCHAR szItemNameW[80];
                char szItemNameA[80];
            };
            CHAR aszVerb[80];

            // try both GCS_VERBA and GCS_VERBW in case it only supports one of them
            SHUnicodeToAnsi(pwszVerb, aszVerb, ARRAYSIZE(aszVerb));

            if (SUCCEEDED(pcm->GetCommandString(mii.wID - idCmdFirst, GCS_VERBA, NULL, szItemNameA, ARRAYSIZE(szItemNameA))))
            {
                if (StrCmpICA(szItemNameA, aszVerb) == 0)
                {
                    break;  // found it
                }
            }
            else
            {
                if (SUCCEEDED(pcm->GetCommandString(mii.wID - idCmdFirst, GCS_VERBW, NULL, (LPSTR)szItemNameW, ARRAYSIZE(szItemNameW))) &&
                    (StrCmpICW(szItemNameW, pwszVerb) == 0))
                {
                    break;  // found it
                }
            }
        }
    }

    if (iItem == cMenuItems)
    {
        iItem = -1; // went through all the menuitems and didn't find it
    }

    return iItem;
}

// deal with GCS_VERBW/GCS_VERBA maddness

STDAPI ContextMenu_GetCommandStringVerb(IContextMenu *pcm, UINT idCmd, LPWSTR pszVerb, int cchVerb)
{
    // Ulead SmartSaver Pro has a 60 character verb, and 
    // over writes out stack, ignoring the cch param and we fault. 
    // so make sure this buffer is at least 60 chars

    TCHAR wszVerb[64];
    wszVerb[0] = 0;

    HRESULT hr = pcm->GetCommandString(idCmd, GCS_VERBW, NULL, (LPSTR)wszVerb, ARRAYSIZE(wszVerb));
    if (FAILED(hr))
    {
        // be extra paranoid about requesting the ansi version -- we've
        // found IContextMenu implementations that return a UNICODE buffer
        // even though we ask for an ANSI string on NT systems -- hopefully
        // they will have answered the above request already, but just in
        // case let's not let them overrun our stack!
        char szVerbAnsi[128];
        hr = pcm->GetCommandString(idCmd, GCS_VERBA, NULL, szVerbAnsi, ARRAYSIZE(szVerbAnsi) / 2);
        if (SUCCEEDED(hr))
        {
            SHAnsiToUnicode(szVerbAnsi, wszVerb, ARRAYSIZE(wszVerb));
        }
    }

    StrCpyNW(pszVerb, wszVerb, cchVerb);

    return hr;
}


//
//  Purpose:    Deletes the menu item specified by name
//
//  Parameters: pcm        - Context menu interface
//              hpopup     - Context menu handle
//              idFirst    - Beginning of id range
//              pszCommand - Command to look for
//

STDAPI ContextMenu_DeleteCommandByName(IContextMenu *pcm, HMENU hpopup, UINT idFirst, LPCWSTR pszCommand)
{
    UINT ipos = GetMenuIndexForCanonicalVerb(hpopup, pcm, idFirst, pszCommand);
    if (ipos != -1)
    {
        DeleteMenu(hpopup, ipos, MF_BYPOSITION);
        return S_OK;
    }
    else
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }
}


//
// Helpers to banish STRRET's into the realm of darkness
//

STDAPI DisplayNameOf(IShellFolder *psf, LPCITEMIDLIST pidl, DWORD flags, LPTSTR psz, UINT cch)
{
    *psz = 0;
    STRRET sr;
    HRESULT hr = psf->GetDisplayNameOf(pidl, flags, &sr);
    if (SUCCEEDED(hr))
        hr = StrRetToBuf(&sr, pidl, psz, cch);
    return hr;
}

STDAPI DisplayNameOfAsOLESTR(IShellFolder *psf, LPCITEMIDLIST pidl, DWORD flags, LPWSTR *ppsz)
{
    *ppsz = NULL;
    STRRET sr;
    HRESULT hr = psf->GetDisplayNameOf(pidl, flags, &sr);
    if (SUCCEEDED(hr))
        hr = StrRetToStrW(&sr, pidl, ppsz);
    return hr;
}



// get the target pidl for a folder pidl. this deals with the case where a folder
// is an alias to a real folder, Folder Shortcuts, etc.

STDAPI SHGetTargetFolderIDList(LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;
    
    // likely should ASSERT() that pidlFolder has SFGAO_FOLDER
    IShellLink *psl;
    HRESULT hr = SHGetUIObjectFromFullPIDL(pidlFolder, NULL, IID_PPV_ARG(IShellLink, &psl));
    if (SUCCEEDED(hr))
    {
        hr = psl->GetIDList(ppidl);
        psl->Release();
    }

    // No its not a folder shortcut. Get the pidl normally.
    if (FAILED(hr))
        hr = SHILClone(pidlFolder, ppidl);
    return hr;
}

// get the target folder for a folder pidl. this deals with the case where a folder
// is an alias to a real folder, Folder Shortcuts, MyDocs, etc.

STDAPI SHGetTargetFolderPathW(LPCITEMIDLIST pidlFolder, LPWSTR pszPath, UINT cchPath)
{
    *pszPath = 0;

    LPITEMIDLIST pidlTarget;
    if (SUCCEEDED(SHGetTargetFolderIDList(pidlFolder, &pidlTarget)))
    {
        SHGetPathFromIDListW(pidlTarget, pszPath);   // make sure it is a path
        ILFree(pidlTarget);
    }
    return *pszPath ? S_OK : E_FAIL;
}

STDAPI SHGetTargetFolderPathA(LPCITEMIDLIST pidlFolder, LPSTR pszPath, UINT cchPath)
{
    *pszPath = 0;
    WCHAR szPath[MAX_PATH];
    HRESULT hr = SHGetTargetFolderPathW(pidlFolder, szPath, ARRAYSIZE(szPath));
    if (SUCCEEDED(hr))
        SHAnsiToUnicode(pszPath, szPath, cchPath);
    return hr;
}

STDAPI SHBuildDisplayMachineName(LPCWSTR pszMachineName, LPCWSTR pszComment, LPWSTR pszDisplayName, DWORD cchDisplayName)
{
    HRESULT hr = E_FAIL;

    if (pszComment && pszComment[0])
    {
        // encorporate the comment into the display name
        LPCWSTR pszNoSlashes = SkipServerSlashes(pszMachineName);
        int i = wnsprintfW(pszDisplayName, cchDisplayName, L"%s (%s)", pszComment, pszNoSlashes);
        hr = (i < 0) ? E_FAIL : S_OK;
    }
    else
    {
        // Return failure here so netfldr can do smarter things to build a display name
        hr = E_FAIL;
    }

    return hr;
}

// create objects from registered under a key value, uses the per user per machine
// reg services to do this.

STDAPI CreateFromRegKey(LPCWSTR pszKey, LPCWSTR pszValue, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    WCHAR szCLSID[MAX_PATH];
    DWORD cbSize = sizeof(szCLSID);
    if (SHRegGetUSValueW(pszKey, pszValue, NULL, szCLSID, &cbSize, FALSE, NULL, 0) == ERROR_SUCCESS)
    {
        CLSID clsid;
        if (GUIDFromString(szCLSID, &clsid))
        {
            hr = SHCoCreateInstanceAC(clsid, NULL, CLSCTX_INPROC_SERVER, riid, ppv);
        }
    }
    return hr;
}

//
// SHProcessMessagesUntilEvent:
//
// this executes message loop until an event or a timeout occurs
//
STDAPI_(DWORD) SHProcessMessagesUntilEventEx(HWND hwnd, HANDLE hEvent, DWORD dwTimeout, DWORD dwWakeMask)
{
    DWORD dwEndTime = GetTickCount() + dwTimeout;
    LONG lWait = (LONG)dwTimeout;
    DWORD dwReturn;

    if (!hEvent && (dwTimeout == INFINITE))
    {
        ASSERTMSG(FALSE, "SHProcessMessagesUntilEvent: caller passed a NULL hEvent and an INFINITE timeout!!");
        return -1;
    }

    for (;;)
    {
        DWORD dwCount = hEvent ? 1 : 0;
        dwReturn = MsgWaitForMultipleObjects(dwCount, &hEvent, FALSE, lWait, dwWakeMask);

        // were we signalled or did we time out?
        if (dwReturn != (WAIT_OBJECT_0 + dwCount))
        {
            break;
        }

        // we woke up because of messages.
        MSG msg;
        while (PeekMessage(&msg, hwnd, 0, 0, PM_REMOVE))
        {
            ASSERT(msg.message != WM_QUIT);
            TranslateMessage(&msg);
            if (msg.message == WM_SETCURSOR)
            {
                SetCursor(LoadCursor(NULL, IDC_WAIT));
            } 
            else 
            {
                DispatchMessage(&msg);
            }
        }

        // calculate new timeout value
        if (dwTimeout != INFINITE)
        {
            lWait = (LONG)dwEndTime - GetTickCount();
        }
    }

    return dwReturn;
}

// deals with goofyness of IShellFolder::GetAttributesOf() including 
//      in/out param issue
//      failures
//      goofy cast for 1 item case
//      masks off results to only return what you asked for

STDAPI_(DWORD) SHGetAttributes(IShellFolder *psf, LPCITEMIDLIST pidl, DWORD dwAttribs)
{
    // like SHBindToObject, if psf is NULL, use absolute pidl
    LPCITEMIDLIST pidlChild;
    if (!psf)
    {
        SHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
    }
    else
    {
        psf->AddRef();
        pidlChild = pidl;
    }

    DWORD dw = 0;
    if (psf)
    {
        dw = dwAttribs;
        dw = SUCCEEDED(psf->GetAttributesOf(1, (LPCITEMIDLIST *)&pidlChild, &dw)) ? (dwAttribs & dw) : 0;
        if ((dw & SFGAO_FOLDER) && (dw & SFGAO_CANMONIKER) && !(dw & SFGAO_STORAGEANCESTOR) && (dwAttribs & SFGAO_STORAGEANCESTOR))
        {
            if (OBJCOMPATF_NEEDSSTORAGEANCESTOR & SHGetObjectCompatFlags(psf, NULL))
            {
                //  switch SFGAO_CANMONIKER -> SFGAO_STORAGEANCESTOR
                dw |= SFGAO_STORAGEANCESTOR;
                dw &= ~SFGAO_CANMONIKER;
            }
        }
    }

    if (psf)
    {
        psf->Release();
    }

    return dw;
}

//===========================================================================
// IDLARRAY stuff
//===========================================================================

STDAPI_(HIDA) HIDA_Create(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST * apidl)
{
    UINT offset = sizeof(CIDA) + sizeof(UINT) * cidl;
    UINT cbTotal = offset + ILGetSize(pidlFolder);
    for (UINT i = 0; i<cidl ; i++) 
    {
        cbTotal += ILGetSize(apidl[i]);
    }

    HIDA hida = GlobalAlloc(GPTR, cbTotal);  // This MUST be GlobalAlloc!!!
    if (hida)
    {
        LPIDA pida = (LPIDA)hida;       // no need to lock

        LPCITEMIDLIST pidlNext;
        pida->cidl = cidl;

        for (i = 0, pidlNext = pidlFolder; ; pidlNext = apidl[i++])
        {
            UINT cbSize = ILGetSize(pidlNext);
            pida->aoffset[i] = offset;
            CopyMemory(((LPBYTE)pida) + offset, pidlNext, cbSize);
            offset += cbSize;

            ASSERT(ILGetSize(HIDA_GetPIDLItem(pida,i-1)) == cbSize);

            if (i == cidl)
                break;
        }

        ASSERT(offset == cbTotal);
    }

    return hida;
}

STDAPI_(UINT) HIDA_GetCount(HIDA hida)
{
    UINT count = 0;
    LPIDA pida = (LPIDA)GlobalLock(hida);
    if (pida)
    {
        count = pida->cidl;
        GlobalUnlock(hida);
    }
    return count;
}

STDAPI_(UINT) HIDA_GetIDList(HIDA hida, UINT i, LPITEMIDLIST pidlOut, UINT cbMax)
{
    LPIDA pida = (LPIDA)GlobalLock(hida);
    if (pida)
    {
        LPCITEMIDLIST pidlFolder = HIDA_GetPIDLFolder(pida);
        LPCITEMIDLIST pidlItem   = HIDA_GetPIDLItem(pida, i);
        UINT cbFolder = ILGetSize(pidlFolder) - sizeof(USHORT);
        UINT cbItem = ILGetSize(pidlItem);
        if (cbMax < cbFolder+cbItem) 
        {
            if (pidlOut) 
                pidlOut->mkid.cb = 0;
        } 
        else 
        {
            MoveMemory(pidlOut, pidlFolder, cbFolder);
            MoveMemory(((LPBYTE)pidlOut) + cbFolder, pidlItem, cbItem);
        }
        GlobalUnlock(hida);

        return cbFolder + cbItem;
    }
    return 0;
}

STDAPI_(BOOL) PathIsImage(LPCTSTR pszFile)
{
    BOOL fPicture = FALSE;
    LPTSTR pszExt = PathFindExtension(pszFile);
    if (pszExt)
    {
        // there's no ASSOCSTR_PERCEIVED so pick it up from the registry.
        TCHAR szPerceivedType[MAX_PATH];
        DWORD cb = ARRAYSIZE(szPerceivedType) * sizeof(TCHAR);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, pszExt, TEXT("PerceivedType"), NULL, szPerceivedType, &cb))
        {
            fPicture = (StrCmpI(szPerceivedType, TEXT("image")) == 0);
        }
    }
    return fPicture;
}

// helper function to create a stream or storage in a storage.
HRESULT CreateStreamOrStorage(IStorage * pStorageParent, LPCTSTR pszName, REFIID riid, void **ppv)
{
    DWORD grfModeCreated = STGM_READWRITE;
    HRESULT hr = E_INVALIDARG;

    if (IsEqualGUID(riid, IID_IStorage))
    {
        IStorage * pStorageCreated;
        hr = pStorageParent->CreateStorage(pszName, grfModeCreated, 0, 0, &pStorageCreated);

        if (SUCCEEDED(hr))
        {
            hr = pStorageParent->Commit(STGC_DEFAULT);
            *ppv = pStorageCreated;
        }
    }
    else if (IsEqualGUID(riid, IID_IStream))
    {
        IStream * pStreamCreated;
        hr = pStorageParent->CreateStream(pszName, grfModeCreated, 0, 0, &pStreamCreated);

        if (SUCCEEDED(hr))
        {
            hr = pStorageParent->Commit(STGC_DEFAULT);
            *ppv = pStreamCreated;
        }
    }

    return hr;
}


// same as PathMakeUniqueNameEx but it works on storages.
// Note: LFN only!
STDAPI StgMakeUniqueNameWithCount(IStorage *pStorageParent, LPCWSTR pszTemplate,
                                  int iMinLong, REFIID riid, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    
    RIPMSG(pszTemplate && IS_VALID_STRING_PTR(pszTemplate, -1) && lstrlen(pszTemplate)<(MAX_PATH-6), "StgMakeUniqueNameWithCount: invalid pszTemplate");
    if (pszTemplate && lstrlen(pszTemplate)<(MAX_PATH-6)) // -6 for " (999)"
    {
        WCHAR szBuffer[MAX_PATH];
        WCHAR szFormat[MAX_PATH];
        int cchStem;
    
        // Set up:
        //   cchStem  : length of pszTemplate we're going to use w/o wsprintf
        //   szFormat : format string to wsprintf the number with, catenates on to pszTemplate[0..cchStem]

        // Has template already been uniquified?
        //
        LPWSTR pszRest = StrChr(pszTemplate, L'(');
        while (pszRest)
        {
            // First validate that this is the right one
            LPWSTR pszEndUniq = CharNext(pszRest);
            while (*pszEndUniq && *pszEndUniq >= L'0' && *pszEndUniq <= L'9')
            {
                pszEndUniq++;
            }
            if (*pszEndUniq == L')')
                break;  // We have the right one!
            pszRest = StrChr(CharNext(pszRest), L'(');
        }

        if (!pszRest)
        {
            // if no (, then tack it on at the end. (but before the extension)
            // eg.  New Link yields New Link (1)
            pszRest = PathFindExtension(pszTemplate);
            cchStem = (int)(pszRest - pszTemplate);
            wnsprintf(szFormat, ARRAYSIZE(szFormat), L" (%%d)%s", pszRest ? pszRest : L"");
        }
        else
        {
            // Template has been uniquified, remove uniquing digits
            // eg.  New Link (1) yields New Link (2)
            //
            pszRest++; // step over the (

            cchStem = (int) (pszRest - pszTemplate);

            while (*pszRest && *pszRest >= L'0' && *pszRest <= L'9')
            {
                pszRest++;
            }

            // we are guaranteed enough room because we don't include
            // the stuff before the # in this format
            wnsprintf(szFormat, ARRAYSIZE(szFormat), L"%%d%s", pszRest);
        }


        if (cchStem < ARRAYSIZE(szBuffer))
        {
            // copy the fixed portion into the buffer
            //
            StrCpyN(szBuffer, pszTemplate, cchStem+1);

            // Iterate on the uniquifying szFormat portion until we find a unique name:
            //
            LPTSTR pszDigit = szBuffer + cchStem;
            hr = STG_E_FILEALREADYEXISTS;
            for (int i = iMinLong; (i < 1000) && (STG_E_FILEALREADYEXISTS == hr); i++)
            {
                wnsprintf(pszDigit, ARRAYSIZE(szBuffer) - cchStem, szFormat, i);

                // okay, we have the unique name, so create it in the storage.
                hr = CreateStreamOrStorage(pStorageParent, szBuffer, riid, ppv);
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
}


STDAPI StgMakeUniqueName(IStorage *pStorageParent, LPCTSTR pszFileSpec, REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;

    TCHAR szTemp[MAX_PATH];

    LPTSTR psz;
    LPTSTR pszNew;

    // try it without the ( if there's a space after it
    psz = StrChr(pszFileSpec, L'(');
    while (psz)
    {
        if (*(CharNext(psz)) == L')')
            break;
        psz = StrChr(CharNext(psz), L'(');
    }

    if (psz)
    {
        // We have the ().  See if we have either x () y or x ().y in which case
        // we probably want to get rid of one of the blanks...
        int ichSkip = 2;
        LPTSTR pszT = CharPrev(pszFileSpec, psz);
        if (*pszT == L' ')
        {
            ichSkip = 3;
            psz = pszT;
        }

        StrCpyN(szTemp, pszFileSpec, ARRAYSIZE(szTemp));
        SIZE_T cch = psz - pszFileSpec;
        pszNew = szTemp + cch;
        if (cch < ARRAYSIZE(szTemp))
        {
            StrCpyN(pszNew, psz + ichSkip, ARRAYSIZE(szTemp) - (int)cch);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        // 1taro registers its document with '/'.
        if (psz=StrChr(pszFileSpec, '/'))
        {
            LPTSTR pszT = CharNext(psz);
            pszNew = szTemp;
            StrCpyN(szTemp, pszFileSpec, ARRAYSIZE(szTemp));
            SIZE_T cch = psz - pszFileSpec;
            pszNew = szTemp + cch;
            if (cch < ARRAYSIZE(szTemp))
            {
                StrCpyN(pszNew, pszT, ARRAYSIZE(szTemp) - (int)cch);
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            if (lstrlen(pszFileSpec) < ARRAYSIZE(szTemp))
            {
                StrCpyN(szTemp, pszFileSpec, ARRAYSIZE(szTemp));
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = CreateStreamOrStorage(pStorageParent, szTemp, riid, ppv);
    }
    if (FAILED(hr))
    {
        hr = StgMakeUniqueNameWithCount(pStorageParent, pszFileSpec, 2, riid, ppv);
    }

    return hr;
}


STDAPI SHInvokeCommandOnPidl(HWND hwnd, IUnknown* punk, LPCITEMIDLIST pidl, UINT uFlags, LPCSTR lpVerb)
{
    IShellFolder* psf;
    LPCITEMIDLIST pidlChild;
    HRESULT hr = SHBindToFolderIDListParent(NULL, pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
    if (SUCCEEDED(hr))
    {
        hr = SHInvokeCommandOnPidlArray(hwnd, punk, psf, &pidlChild, 1, uFlags, lpVerb);
        psf->Release();
    }
    return hr;
}


STDAPI SHInvokeCommandOnPidlArray(HWND hwnd, IUnknown* punk, IShellFolder* psf, LPCITEMIDLIST *ppidlItem, UINT cItems, UINT uFlags, LPCSTR lpVerb)
{
    IContextMenu *pcm;
    HRESULT hr = psf->GetUIObjectOf(hwnd, cItems, ppidlItem, IID_X_PPV_ARG(IContextMenu, 0, &pcm));
    if (SUCCEEDED(hr) && pcm)
    {
        hr = SHInvokeCommandOnContextMenu(hwnd, punk, pcm, uFlags, lpVerb);
        pcm->Release();
    }

    return hr;
}

STDAPI SHInvokeCommandOnDataObject(HWND hwnd, IUnknown* punk, IDataObject* pdtobj, UINT uFlags, LPCSTR pszVerb)
{
    HRESULT hr = E_FAIL;

    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        IShellFolder *psf;
        LPCITEMIDLIST pidlParent = IDA_GetIDListPtr(pida, (UINT)-1);
        if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlParent, &psf))))
        {
            LPCITEMIDLIST *ppidl = (LPCITEMIDLIST *)LocalAlloc(LPTR, pida->cidl * sizeof(LPCITEMIDLIST));
            if (ppidl)
            {
                for (UINT i = 0; i < pida->cidl; i++)
                {
                    ppidl[i] = IDA_GetIDListPtr(pida, i);
                }
                hr = SHInvokeCommandOnPidlArray(hwnd, punk, psf, ppidl, pida->cidl, uFlags, pszVerb);
                LocalFree(ppidl);
            }
            psf->Release();
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    
    return hr;
}

STDAPI_(LPCITEMIDLIST) IDA_GetIDListPtr(LPIDA pida, UINT i)
{
    LPCITEMIDLIST pidl = NULL;
    if (pida && ((i == (UINT)-1) || i < pida->cidl))
    {
        pidl = HIDA_GetPIDLItem(pida, i);
    }
    return pidl;
}

STDAPI IUnknown_DragEnter(IUnknown* punk, IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = E_FAIL;
    if (punk)
    {
        IDropTarget* pdt;
        hr = punk->QueryInterface(IID_PPV_ARG(IDropTarget, &pdt));
        if (SUCCEEDED(hr)) 
        {
            hr = pdt->DragEnter(pdtobj, grfKeyState, pt, pdwEffect);
            pdt->Release();
        }
    }

    if (FAILED(hr))
        *pdwEffect = DROPEFFECT_NONE;

    return hr;
}

STDAPI IUnknown_DragOver(IUnknown* punk, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = E_FAIL;
    if (punk)
    {
        IDropTarget* pdt;
        hr = punk->QueryInterface(IID_PPV_ARG(IDropTarget, &pdt));
        if (SUCCEEDED(hr)) 
        {
            hr = pdt->DragOver(grfKeyState, pt, pdwEffect);
            pdt->Release();
        }
    }

    if (FAILED(hr))
        *pdwEffect = DROPEFFECT_NONE;

    return hr;
}

STDAPI IUnknown_DragLeave(IUnknown* punk)
{
    HRESULT hr = E_FAIL;
    if (punk)
    {
        IDropTarget* pdt;
        hr = punk->QueryInterface(IID_PPV_ARG(IDropTarget, &pdt));
        if (SUCCEEDED(hr)) 
        {
            hr = pdt->DragLeave();
            pdt->Release();
        }
    }
    return hr;
}

STDAPI IUnknown_Drop(IUnknown* punk, IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = E_FAIL;
    if (punk)
    {
        IDropTarget* pdt;
        hr = punk->QueryInterface(IID_PPV_ARG(IDropTarget, &pdt));
        if (SUCCEEDED(hr)) 
        {
            hr = pdt->Drop(pdtobj, grfKeyState, pt, pdwEffect);
            pdt->Release();
        }
    }

    if (FAILED(hr))
        *pdwEffect = DROPEFFECT_NONE;

    return hr;
}

STDAPI_(BOOL) ShouldNavigateInIE(LPCWSTR pszUrl)
{
    //  Default to navigating in IE.  The idea here is that this
    //  changes the existing behavior the least.

    BOOL fResult = TRUE;
    
    //  first, crack the URL

    WCHAR szScheme[INTERNET_MAX_SCHEME_LENGTH];
    DWORD cchScheme = ARRAYSIZE(szScheme);

    if (SUCCEEDED(UrlGetPartW(pszUrl, szScheme, &cchScheme, URL_PART_SCHEME, 0)))
    {
        //  if it is an http:, https:, file:, or ftp: URL then look up the association
        //  all other pluggable protocols go to IE

        if ((0 == StrCmpIW(szScheme, L"http")) ||
            (0 == StrCmpIW(szScheme, L"ftp")) ||
            (0 == StrCmpIW(szScheme, L"file")) ||
            (0 == StrCmpIW(szScheme, L"https")))

        {
            WCHAR szExecutable[MAX_PATH * 2];
            DWORD cchExecutable = ARRAYSIZE(szExecutable);
            WCHAR szFile[MAX_PATH];
            LPCWSTR pszQuery = szScheme;

            if (0 == StrCmpIW(szScheme, L"file"))
            {
                DWORD cchFile = ARRAYSIZE(szFile);
                if (SUCCEEDED(PathCreateFromUrl(pszUrl, szFile, &cchFile, 0)))
                {
                    pszQuery = PathFindExtension(szFile);
                }
            }
            
            if (SUCCEEDED(AssocQueryStringW(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, pszQuery, NULL, szExecutable, &cchExecutable)))
            {
                if (!StrStrIW(szExecutable, L"iexplore"))
                {                    
                    //  IE isn't the default for the verb so we'll ShellExecute it.
                    fResult = FALSE;
                }
            }
        }
    }

    return fResult;
}

STDAPI_(BOOL) IsDesktopFrame(IUnknown *punk)
{
    IUnknown *punkDesktop;

    HRESULT hr = IUnknown_QueryService(punk, SID_SShellDesktop, SID_SShellDesktop, (void **)&punkDesktop);

    BOOL fResult;
    
    if (SUCCEEDED(hr))
    {
        punkDesktop->Release();
        fResult = TRUE;
    }
    else
    {
        fResult = FALSE;
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\countedobject.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: CountedObjects.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Base class that implements object reference counting
//
//  History:    1999-08-17  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "CountedObject.h"

//  --------------------------------------------------------------------------
//  CCountedObject::CCountedObject
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the reference count to 1.
//
//  History:    1999-08-17  vtan        created
//  --------------------------------------------------------------------------

CCountedObject::CCountedObject (void) :
    _lReferenceCount(1),
    _fReleased(false)

{
}

//  --------------------------------------------------------------------------
//  CCountedObject::~CCountedObject
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Virtual destructor that just checks valid deletion.
//
//  History:    1999-08-17  vtan        created
//  --------------------------------------------------------------------------

CCountedObject::~CCountedObject (void)

{
    ASSERTMSG(_fReleased, "CCountedObject::~CCountedObject invoked without being released");
}

//  --------------------------------------------------------------------------
//  CCountedObject::AddRef
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Increments the object's reference count.
//
//  History:    1999-08-17  vtan        created
//  --------------------------------------------------------------------------

void    CCountedObject::AddRef (void)

{
    InterlockedIncrement(&_lReferenceCount);
}

//  --------------------------------------------------------------------------
//  CCountedObject::Release
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Decrements the object's reference count. When the count
//              reaches zero the object is deleted. Do NOT use referenced
//              objects when using stack based objects. These must be
//              dynamically allocated.
//
//  History:    1999-08-17  vtan        created
//  --------------------------------------------------------------------------

void    CCountedObject::Release (void)

{
    ASSERT( 0 != _lReferenceCount );
    if (InterlockedDecrement(&_lReferenceCount) == 0)
    {
        _fReleased = true;
        delete this;
    }
}

//  --------------------------------------------------------------------------
//  CCountedObject::GetCount
//
//  Arguments:  <none>
//
//  Returns:    LONG
//
//  Purpose:    Returns the count of outstanding references on the object.
//
//  History:    2000-07-17  vtan        created
//  --------------------------------------------------------------------------

LONG    CCountedObject::GetCount (void)     const

{
    return(_lReferenceCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\access.h ===
//  --------------------------------------------------------------------------
//  Module Name: Access.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  This file contains a few classes that assist with ACL manipulation on
//  objects to which a handle has already been opened. This handle must have
//  (obvisouly) have WRITE_DAC access.
//
//  History:    1999-10-05  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _Access_
#define     _Access_

#include "DynamicArray.h"

//  --------------------------------------------------------------------------
//  CSecurityDescriptor
//
//  Purpose:    This class allocates and assigns a PSECURITY_DESCRIPTOR
//              structure with the desired access specified.
//
//  History:    2000-10-05  vtan        created
//  --------------------------------------------------------------------------

class   CSecurityDescriptor
{
    public:
        typedef struct
        {
            PSID_IDENTIFIER_AUTHORITY   pSIDAuthority;
            int                         iSubAuthorityCount;
            DWORD                       dwSubAuthority0,
                                        dwSubAuthority1,
                                        dwSubAuthority2,
                                        dwSubAuthority3,
                                        dwSubAuthority4,
                                        dwSubAuthority5,
                                        dwSubAuthority6,
                                        dwSubAuthority7;
            DWORD                       dwAccessMask;
        } ACCESS_CONTROL, *PACCESS_CONTROL;
    private:
                                        CSecurityDescriptor (void);
                                        ~CSecurityDescriptor (void);
    public:
        static  PSECURITY_DESCRIPTOR    Create (int iCount, const ACCESS_CONTROL *pAccessControl);
    private:
        static  bool                    AddAces (PACL pACL, PSID *pSIDs, int iCount, const ACCESS_CONTROL *pAC);
};

//  --------------------------------------------------------------------------
//  CAccessControlList
//
//  Purpose:    This class manages access allowed ACEs and constructs an ACL
//              from these ACEs. This class only deals with access allowed
//              ACEs.
//
//  History:    1999-10-05  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CAccessControlList : private CDynamicArrayCallback
{
    public:
                                        CAccessControlList (void);
                                        ~CAccessControlList (void);

                                        operator PACL (void);

                NTSTATUS                Add (PSID pSID, ACCESS_MASK dwMask, UCHAR ucInheritence);
                NTSTATUS                Remove (PSID pSID);
    private:
        virtual NTSTATUS                Callback (const void *pvData, int iElementIndex);
    private:
                CDynamicPointerArray    _ACEArray;
                ACL*                    _pACL;
                PSID                    _searchSID;
                int                     _iFoundIndex;
};

//  --------------------------------------------------------------------------
//  CSecuredObject
//
//  Purpose:    This class manages the ACL of a secured object. SIDs can be
//              added or removed from the ACL of the object.
//
//  History:    1999-10-05  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CSecuredObject
{
    private:
                        CSecuredObject (void);
    public:
                        CSecuredObject (HANDLE hObject, SE_OBJECT_TYPE seObjectType);
                        ~CSecuredObject (void);

        NTSTATUS        Allow (PSID pSID, ACCESS_MASK dwMask, UCHAR ucInheritence)  const;
        NTSTATUS        Remove (PSID pSID)                                          const;
    private:
        NTSTATUS        GetDACL (CAccessControlList& accessControlList)             const;
        NTSTATUS        SetDACL (CAccessControlList& accessControlList)             const;
    private:
        HANDLE          _hObject;
        SE_OBJECT_TYPE  _seObjectType;
};

#endif  /*  _Access_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\countedobject.h ===
//  --------------------------------------------------------------------------
//  Module Name: CountedObjects.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Base class that implements object reference counting
//
//  History:    1999-08-17  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _CountedObject_
#define     _CountedObject_

#include "DynamicObject.h"

//  --------------------------------------------------------------------------
//  CCountedObject
//
//  Purpose:    This class is a base class that implements object reference
//              counting. The default constructor is protected to disable
//              instantiating this object unless subclassed. The reference
//              count is private because subclasses really shouldn't need to
//              know about the reference counting.
//
//  History:    1999-08-17  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CCountedObject : public CDynamicObject
{
    protected:
                                CCountedObject (void);
        virtual                 ~CCountedObject (void);
    public:
                void            AddRef (void);
                void            Release (void);

                LONG            GetCount (void)     const;
    private:
        LONG                    _lReferenceCount;
        bool                    _fReleased;
};

#endif  /*  _CountedObject_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\wnetutil.cpp ===
#include "stock.h"
#pragma hdrstop

#include <idhidden.h>
#include <regitemp.h>
#include <shstr.h>
#include <shlobjp.h>
#include <lmcons.h>
#include <validc.h>
#include "ccstock2.h"

// Alpha platform doesn't need unicode thunks, seems like this
// should happen automatically in the headerfiles...
//
#if defined(_X86_) || defined(UNIX)
#else
#define NO_W95WRAPS_UNITHUNK
#endif

#include "wininet.h"
#include "w95wraps.h"

// Put stuff to clean up URLs from being spoofed here.
// We don't want to show escaped host names
// We don't want display the username:password combo that's embedded in the url, in the UI.
// So we remove those pieces, and reconstruct the url.

STDAPI_(void) SHCleanupUrlForDisplay(LPTSTR pszUrl)
{
    switch (GetUrlScheme(pszUrl))
    {
    case URL_SCHEME_FTP:
    case URL_SCHEME_HTTP:
    case URL_SCHEME_HTTPS:
      {
        URL_COMPONENTS uc = { 0 };
        TCHAR szName[INTERNET_MAX_URL_LENGTH];
        
        uc.dwStructSize = sizeof(uc);
        uc.dwSchemeLength = uc.dwHostNameLength = uc.dwUserNameLength = uc.dwPasswordLength = uc.dwUrlPathLength = uc.dwExtraInfoLength = 1;
         
        if (InternetCrackUrl(pszUrl, 0, 0, &uc) && uc.lpszHostName)
        {
            BOOL fRecreate = FALSE;

            for (DWORD dw=0; dw < uc.dwHostNameLength; dw++)
            {
                if (uc.lpszHostName[dw]==TEXT('%'))
                {
                    URL_COMPONENTS uc2 =  { 0 };
                    uc2.dwStructSize = sizeof(uc2);
                    uc2.dwHostNameLength = ARRAYSIZE(szName);
                    uc2.lpszHostName = szName;

                    if (InternetCrackUrl(pszUrl, 0, 0, &uc2))
                    {
                        uc.dwHostNameLength = 0;
                        uc.lpszHostName = szName;
                        fRecreate = TRUE;
                    }
                    break;
                }
            }


            if (uc.lpszUserName || uc.lpszPassword)
            {
                uc.dwPasswordLength = uc.dwUserNameLength = 0;
                uc.lpszUserName = uc.lpszPassword = NULL;
                fRecreate = TRUE;
            }

            if (fRecreate)
            {
                // The length of the url will be shorter than the original
                DWORD cc = lstrlen(pszUrl) + 1;
                InternetCreateUrl(&uc, 0, pszUrl, &cc); 
            }
        }
        break;
      }
        
    default:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\access.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Access.cpp
//
//  Copyright (c) 1999, Microsoft Corporation
//
//  This file contains a few classes that assist with ACL manipulation on
//  objects to which a handle has already been opened. This handle must have
//  (obvisouly) have WRITE_DAC access.
//
//  History:    1999-10-05  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "Access.h"

#include "StatusCode.h"

//  --------------------------------------------------------------------------
//  CSecurityDescriptor::CSecurityDescriptor
//
//  Arguments:  iCount          =   Count of ACCESS_CONTROLS passed in.
//              pAccessControl  =   Pointer to ACCESS_CONTROLS.
//
//  Returns:    <none>
//
//  Purpose:    Allocates and assigns the PSECURITY_DESCRIPTOR that
//              corresponds to the description given by the parameters. The
//              caller must release the memory allocated via LocalFree.
//
//  History:    2000-10-05  vtan        created
//  --------------------------------------------------------------------------

PSECURITY_DESCRIPTOR    CSecurityDescriptor::Create (int iCount, const ACCESS_CONTROL *pAccessControl)

{
    PSECURITY_DESCRIPTOR    pSecurityDescriptor;
    PSID                    *pSIDs;

    pSecurityDescriptor = NULL;

    //  Allocate an array of PSIDs required to hold all the SIDs to add.

    pSIDs = reinterpret_cast<PSID*>(LocalAlloc(LPTR, iCount * sizeof(PSID)));
    if (pSIDs != NULL)
    {
        bool                    fSuccessfulAllocate;
        int                     i;
        const ACCESS_CONTROL    *pAC;

        for (fSuccessfulAllocate = true, pAC = pAccessControl, i = 0; fSuccessfulAllocate && (i < iCount); ++pAC, ++i)
        {
            fSuccessfulAllocate = (AllocateAndInitializeSid(pAC->pSIDAuthority,
                                                            static_cast<BYTE>(pAC->iSubAuthorityCount),
                                                            pAC->dwSubAuthority0,
                                                            pAC->dwSubAuthority1,
                                                            pAC->dwSubAuthority2,
                                                            pAC->dwSubAuthority3,
                                                            pAC->dwSubAuthority4,
                                                            pAC->dwSubAuthority5,
                                                            pAC->dwSubAuthority6,
                                                            pAC->dwSubAuthority7,
                                                            &pSIDs[i]) != FALSE);
        }
        if (fSuccessfulAllocate)
        {
            DWORD           dwACLSize;
            unsigned char   *pBuffer;

            //  Calculate the size of the ACL required by totalling the ACL header
            //  struct and the 2 ACCESS_ALLOWED_ACE structs with the SID sizes.
            //  Add the SECURITY_DESCRIPTOR struct size as well.

            dwACLSize = sizeof(ACL) + ((sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) * 3);
            for (i = 0; i < iCount; ++i)
            {
                dwACLSize += GetLengthSid(pSIDs[i]);
            }

            //  Allocate the buffer for everything and portion off the buffer to
            //  the right place.

            pBuffer = static_cast<unsigned char*>(LocalAlloc(LMEM_FIXED, sizeof(SECURITY_DESCRIPTOR) + dwACLSize));
            if (pBuffer != NULL)
            {
                PSECURITY_DESCRIPTOR    pSD;
                PACL                    pACL;

                pSD = reinterpret_cast<PSECURITY_DESCRIPTOR>(pBuffer);
                pACL = reinterpret_cast<PACL>(pBuffer + sizeof(SECURITY_DESCRIPTOR));

                //  Initialize the ACL. Fill in the ACL.
                //  Initialize the SECURITY_DESCRIPTOR. Set the security descriptor.

                if ((InitializeAcl(pACL, dwACLSize, ACL_REVISION) != FALSE) &&
                    AddAces(pACL, pSIDs, iCount, pAccessControl) &&
                    (InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION) != FALSE) &&
                    (SetSecurityDescriptorDacl(pSD, TRUE, pACL, FALSE) != FALSE))
                {
                    pSecurityDescriptor = pSD;
                }
                else
                {
                    (HLOCAL)LocalFree(pBuffer);
                }
            }
        }
        for (i = iCount - 1; i >= 0; --i)
        {
            if (pSIDs[i] != NULL)
            {
                (void*)FreeSid(pSIDs[i]);
            }
        }
        (HLOCAL)LocalFree(pSIDs);
    }
    return(pSecurityDescriptor);
}

//  --------------------------------------------------------------------------
//  CSecurityDescriptor::AddAces
//
//  Arguments:  pACL            =   PACL to add ACEs to.
//              pSIDs           =   Pointer to SIDs.
//              iCount          =   Count of ACCESS_CONTROLS passed in.
//              pAccessControl  =   Pointer to ACCESS_CONTROLS.
//
//  Returns:    bool
//
//  Purpose:    Adds access allowed ACEs to the given ACL.
//
//  History:    2000-10-05  vtan        created
//  --------------------------------------------------------------------------

bool    CSecurityDescriptor::AddAces (PACL pACL, PSID *pSIDs, int iCount, const ACCESS_CONTROL *pAC)

{
    bool    fResult;
    int     i;

    for (fResult = true, i = 0; fResult && (i < iCount); ++pSIDs, ++pAC, ++i)
    {
        fResult = (AddAccessAllowedAce(pACL, ACL_REVISION, pAC->dwAccessMask, *pSIDs) != FALSE);
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CAccessControlList::CAccessControlList
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CAccessControlList object.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

CAccessControlList::CAccessControlList (void) :
    _pACL(NULL)

{
}

//  --------------------------------------------------------------------------
//  CAccessControlList::~CAccessControlList
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the CAccessControlList object.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

CAccessControlList::~CAccessControlList (void)

{
    ReleaseMemory(_pACL);
}

//  --------------------------------------------------------------------------
//  CAccessControlList::operator PACL
//
//  Arguments:  <none>
//
//  Returns:    PACL
//
//  Purpose:    If the ACL has been constructed returns that value. If not
//              then the ACL is constructed from the ACEs and then returned.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

CAccessControlList::operator PACL (void)

{
    PACL    pACL;

    if (_pACL == NULL)
    {
        int     i;
        DWORD   dwACLSize, dwSizeOfAllACEs;

        pACL = NULL;
        dwSizeOfAllACEs = 0;

        //  Walk thru all the ACEs to calculate the total size
        //  required for the ACL.

        for (i = _ACEArray.GetCount() - 1; i >= 0; --i)
        {
            ACCESS_ALLOWED_ACE  *pACE;

            pACE = static_cast<ACCESS_ALLOWED_ACE*>(_ACEArray.Get(i));
            dwSizeOfAllACEs += pACE->Header.AceSize;
        }
        dwACLSize = sizeof(ACL) + dwSizeOfAllACEs;
        _pACL = pACL = static_cast<ACL*>(LocalAlloc(LMEM_FIXED, dwACLSize));
        if (pACL != NULL)
        {
            TBOOL(InitializeAcl(pACL, dwACLSize, ACL_REVISION));

            //  Construct the ACL in reverse order of the ACEs. This
            //  allows CAccessControlList::Add to actually insert the
            //  granted access at the head of the list which is usually
            //  the desired result. The order of the ACEs is important!

            for (i = _ACEArray.GetCount() - 1; i >= 0; --i)
            {
                ACCESS_ALLOWED_ACE  *pACE;

                pACE = static_cast<ACCESS_ALLOWED_ACE*>(_ACEArray.Get(i));
                TBOOL(AddAccessAllowedAceEx(pACL, ACL_REVISION, pACE->Header.AceFlags, pACE->Mask, reinterpret_cast<PSID>(&pACE->SidStart)));
            }
        }
    }
    else
    {
        pACL = _pACL;
    }
    return(pACL);
}

//  --------------------------------------------------------------------------
//  CAccessControlList::Add
//
//  Arguments:  pSID            =   SID to grant access to.
//              dwMask          =   Level of access to grant.
//              ucInheritence   =   Type of inheritence for this access.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Adds the given SID, access and inheritence type as an ACE to
//              the list of ACEs to build into an ACL. The ACE array is
//              allocated in blocks of 16 pointers to reduce repeated calls
//              to allocate memory if many ACEs are added.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAccessControlList::Add (PSID pSID, ACCESS_MASK dwMask, UCHAR ucInheritence)

{
    NTSTATUS            status;
    DWORD               dwSIDLength, dwACESize;
    ACCESS_ALLOWED_ACE  *pACE;

    dwSIDLength = GetLengthSid(pSID);
    dwACESize = sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + dwSIDLength;
    pACE = static_cast<ACCESS_ALLOWED_ACE*>(LocalAlloc(LMEM_FIXED, dwACESize));
    if (pACE != NULL)
    {
        pACE->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
        pACE->Header.AceFlags = ucInheritence;
        pACE->Header.AceSize = static_cast<USHORT>(dwACESize);
        pACE->Mask = dwMask;
        CopyMemory(&pACE->SidStart, pSID, dwSIDLength);
        status = _ACEArray.Add(pACE);
        if (STATUS_NO_MEMORY == status)
        {
            (HLOCAL)LocalFree(pACE);
        }
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAccessControlList::Remove
//
//  Arguments:  pSID            =   SID to revoke access from.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Removes all references to the given SID from the ACE list.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAccessControlList::Remove (PSID pSID)

{
    NTSTATUS    status;

    //  Set up for an iteration of the array.

    _searchSID = pSID;
    _iFoundIndex = -1;
    status = _ACEArray.Iterate(this);
    while (NT_SUCCESS(status) && (_iFoundIndex >= 0))
    {

        //  When the SIDs are found to match remove this entry.
        //  ALL matching SID entries are removed!

        status = _ACEArray.Remove(_iFoundIndex);
        if (NT_SUCCESS(status))
        {
            _iFoundIndex = -1;
            status = _ACEArray.Iterate(this);
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CAccessControlList::Callback
//
//  Arguments:  pvData          =   Pointer to the array index data.
//              iElementIndex   =   Index into the array.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Callback from the CDynamicArray::Iterate function. This
//              method can be used to process the array contents by index or
//              by content when iterating thru the array. Return an error
//              status to stop the iteration and have that value returned to
//              the caller of CDynamicArray::Iterate.
//
//              Converts the pointer into a pointer to an ACCESS_ALLOWED_ACE.
//              The compares the SID in that ACE to the desired search SID.
//              Saves the index if found.
//
//  History:    1999-11-15  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CAccessControlList::Callback (const void *pvData, int iElementIndex)

{
    const ACCESS_ALLOWED_ACE    *pACE;

    pACE = *reinterpret_cast<const ACCESS_ALLOWED_ACE* const*>(pvData);
    if (EqualSid(reinterpret_cast<PSID>(const_cast<unsigned long*>((&pACE->SidStart))), _searchSID) != FALSE)
    {
        _iFoundIndex = iElementIndex;
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CSecuredObject::CSecuredObject
//
//  Arguments:  hObject         =   Optional HANDLE to the object to secure.
//              seObjectType    =   Type of object specified in handle.
//
//  Returns:    <none>
//
//  Purpose:    Sets the optionally given HANDLE into the member variables.
//              The HANDLE is duplicated so the caller must release their
//              HANDLE.
//
//              In order for this class to work the handle you pass it MUST
//              have DUPLICATE access as well as READ_CONTROL and WRITE_DAC.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

CSecuredObject::CSecuredObject (HANDLE hObject, SE_OBJECT_TYPE seObjectType) :
    _hObject(hObject),
    _seObjectType(seObjectType)

{
}

//  --------------------------------------------------------------------------
//  CSecuredObject::~CSecuredObject
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Release our HANDLE reference.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

CSecuredObject::~CSecuredObject (void)

{
}

//  --------------------------------------------------------------------------
//  CSecuredObject::Allow
//
//  Arguments:  pSID            =   SID to grant access to.
//              dwMask          =   Level of access to grant.
//              ucInheritence   =   Type of inheritence for this access.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Get the DACL for the object. Add the desired access. Set the
//              DACL for the object.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CSecuredObject::Allow (PSID pSID, ACCESS_MASK dwMask, UCHAR ucInheritence)  const

{
    NTSTATUS            status;
    CAccessControlList  accessControlList;

    status = GetDACL(accessControlList);
    if (NT_SUCCESS(status))
    {
        status = accessControlList.Add(pSID, dwMask, ucInheritence);
        if (NT_SUCCESS(status))
        {
            status = SetDACL(accessControlList);
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CSecuredObject::Remove
//
//  Arguments:  pSID            =   SID to revoke access from.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Get the DACL for the object. Remove the desired access. Set
//              the DACL for the object.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CSecuredObject::Remove (PSID pSID)                                          const

{
    NTSTATUS            status;
    CAccessControlList  accessControlList;

    status = GetDACL(accessControlList);
    if (NT_SUCCESS(status))
    {
        status = accessControlList.Remove(pSID);
        if (NT_SUCCESS(status))
        {
            status = SetDACL(accessControlList);
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CSecuredObject::GetDACL
//
//  Arguments:  accessControlList   =   CAccessControlList that gets the
//                                      decomposed DACL into ACEs.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Gets the object's DACL and walk the individual ACEs and add
//              this access to the CAccessControlList object given. The access
//              is walked backward to allow CAccessControlList::Add to add to
//              end of the list but actually add to the head of the list.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CSecuredObject::GetDACL (CAccessControlList& accessControlList)             const

{
    NTSTATUS                status;
    DWORD                   dwResult;
    PACL                    pDACL;
    PSECURITY_DESCRIPTOR    pSD;

    status = STATUS_SUCCESS;
    pSD = NULL;
    pDACL = NULL;
    dwResult = GetSecurityInfo(_hObject,
                               _seObjectType,
                               DACL_SECURITY_INFORMATION,
                               NULL,
                               NULL,
                               &pDACL,
                               NULL,
                               &pSD);
    if ((ERROR_SUCCESS == dwResult) && (pDACL != NULL))
    {
        int                 i;
        ACCESS_ALLOWED_ACE  *pAce;

        for (i = pDACL->AceCount - 1; NT_SUCCESS(status) && (i >= 0); --i)
        {
            if (GetAce(pDACL, i, reinterpret_cast<void**>(&pAce)) != FALSE)
            {
                ASSERTMSG(pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE, "Expect only access allowed ACEs in CSecuredObject::MakeIndividualACEs");
                status = accessControlList.Add(reinterpret_cast<PSID>(&pAce->SidStart), pAce->Mask, pAce->Header.AceFlags);
            }
        }
    }
    ReleaseMemory(pSD);
    return(status);
}

//  --------------------------------------------------------------------------
//  CSecuredObject::SetDACL
//
//  Arguments:  accessControlList   =   CAccessControlList that contains all
//                                      ACEs to build into an ACL.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Builds the ACL for the given ACE list and sets the DACL into
//              the object handle.
//
//  History:    1999-10-05  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CSecuredObject::SetDACL (CAccessControlList& accessControlList)             const

{
    NTSTATUS    status;
    DWORD       dwResult;

    dwResult = SetSecurityInfo(_hObject,
                               _seObjectType,
                               DACL_SECURITY_INFORMATION,
                               NULL,
                               NULL,
                               accessControlList,
                               NULL);
    if (ERROR_SUCCESS == dwResult)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfErrorCode(dwResult);
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\dynamicarray.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: DynamicArray.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  This file contains related classes to manage dynamic arrays. The array is
//  grown as required but never shrunk. The base class handles struct arrays.
//  Subclasses handle special cases of these arrays (such as pointer or
//  CCountedObject arrays).
//
//  History:    1999-11-16  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "DynamicArray.h"

#include "CountedObject.h"

//  --------------------------------------------------------------------------
//  CDynamicArray::CDynamicArray
//
//  Arguments:  iElementSize    =   Size of each array element.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CDynamicArray. Stores the element size and
//              initializes the memory used to NULL.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

CDynamicArray::CDynamicArray (int iElementSize) :
    _iElementSize(iElementSize),
    _iArraySize(0),
    _pvArray(NULL)

{
    ASSERTMSG(iElementSize > 0, "Cannot have negative or zero length element size in CDynamicArray::CDynamicArray");
}

//  --------------------------------------------------------------------------
//  CDynamicArray::~CDynamicArray
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CDynamicArray. Frees the memory used by the
//              array.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

CDynamicArray::~CDynamicArray (void)

{
    ReleaseMemory(_pvArray);
}

//  --------------------------------------------------------------------------
//  CDynamicArray::Add
//
//  Arguments:  pvData  =   Pointer to the data to copy to the array.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Allocates memory for the element to be added to the array. If
//              there is no memory block it allocates an initial block. If
//              there isn't enough memory in the block to hold the next
//              element then it allocates a new larger block.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDynamicArray::Add (const void *pvData)

{
    NTSTATUS    status;

    static  const int   DEFAULT_ELEMENTS_PER_ALLOCATE   =   16;

    status = STATUS_NO_MEMORY;

    //  If no array exists then allocate the first
    //  block of memory for this array.

    if (_pvArray == NULL)
    {
        _iArraySize = 0;
        _iArrayAllocatedSize = DEFAULT_ELEMENTS_PER_ALLOCATE;
        _pvArray = LocalAlloc(LPTR, _iElementSize * _iArrayAllocatedSize);
    }

    //  If the array exists but the limit of the allocated size has
    //  been reached then allocate a new block, copy the current
    //  block contents and fall thru.

    if (_pvArray != NULL)
    {
        if (_iArraySize == _iArrayAllocatedSize)
        {
            void    *pvNewArray;

            pvNewArray = LocalAlloc(LPTR, _iElementSize * (_iArrayAllocatedSize + DEFAULT_ELEMENTS_PER_ALLOCATE));
            if (pvNewArray != NULL)
            {
                _iArrayAllocatedSize += DEFAULT_ELEMENTS_PER_ALLOCATE;
                CopyMemory(pvNewArray, _pvArray, _iElementSize * _iArraySize);
                (HLOCAL)LocalFree(_pvArray);
                _pvArray = pvNewArray;
            }
        }

        //  Otherwise there is a spare slot in the array. Copy the
        //  data to the array. Increment the array size.

        if (_iArraySize < _iArrayAllocatedSize)
        {
            CopyMemory(static_cast<char*>(_pvArray) + (_iElementSize * _iArraySize), pvData, _iElementSize);
            ++_iArraySize;
            status = STATUS_SUCCESS;
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CDynamicArray::Remove
//
//  Arguments:  iElementIndex   =   Index of the element to remove.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Removes the element from the array. Slides down all the
//              members but does not reduce the size of the memory block used
//              by the array.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDynamicArray::Remove (int iElementIndex)

{
    NTSTATUS    status;

    status = STATUS_SUCCESS;
    if (_pvArray != NULL)
    {

        //  Make sure the index is valid.

        if (iElementIndex < _iArraySize)
        {
            int     iMoveSize;

            //  Determine the amount of bytes to move when deleting this
            //  element and move the memory. Don't resize the array when
            //  shrinking. Just leave it alone.

            iMoveSize = _iElementSize * (_iArraySize - iElementIndex - 1);
            ASSERTMSG(iMoveSize >= 0, "Negative move memory size in CDynamicArray::Remove");
            if (iMoveSize > 0)
            {
                MoveMemory(static_cast<char*>(_pvArray) + (_iElementSize * iElementIndex), static_cast<char*>(_pvArray) + (_iElementSize * (iElementIndex + 1)), iMoveSize);
            }
            ZeroMemory(static_cast<char*>(_pvArray) + (_iElementSize * (_iArraySize - 1)), _iElementSize);
            --_iArraySize;
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CDynamicArray::GetCount
//
//  Arguments:  <none>
//
//  Returns:    int
//
//  Purpose:    Returns the number of elements in the array.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

int     CDynamicArray::GetCount (void)                             const

{
    return(_iArraySize);
}

//  --------------------------------------------------------------------------
//  CDynamicArray::Get
//
//  Arguments:  pvData          =   Pointer to memory to receive element.
//              iElementIndex   =   Index of element to retrieve in array.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Copies the data for the specified element by index to the
//              block of memory given. No checks for access violations.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDynamicArray::Get (void *pvData, int iElementIndex)

{
    NTSTATUS    status;

    if ((_pvArray != NULL) && (iElementIndex < _iArraySize))
    {
        CopyMemory(pvData, static_cast<char*>(_pvArray) + (_iElementSize * iElementIndex), _iElementSize);
        status = STATUS_SUCCESS;
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CDynamicArray::Set
//
//  Arguments:  pvData          =   Pointer to memory to receive element.
//              iElementIndex   =   Index of element to retrieve in array.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Copies the data for the specified element by index from the
//              block of memory given. No checks for access violations.
//
//  History:    2000-11-11  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDynamicArray::Set (const void* pvData, int iElementIndex)

{
    NTSTATUS    status;

    status = STATUS_SUCCESS;
    if (_pvArray != NULL)
    {
        if (iElementIndex < _iArraySize)
        {
            CopyMemory(static_cast<char*>(_pvArray) + (_iElementSize * iElementIndex), pvData, _iElementSize);
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CDynamicArray::Iterate
//
//  Arguments:  pDynamicArrayCallback   =   Interface containing callback.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Iterate the elements of the array. Call the callback function
//              specified in the interface and give it a pointer to the
//              element and the index. Adhere to the NTSTATUS returned from
//              the callback and terminate on an unsuccessful result.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDynamicArray::Iterate (CDynamicArrayCallback *pDynamicArrayCallback)

{
    NTSTATUS    status;

    status = STATUS_SUCCESS;
    if (_pvArray != NULL)
    {
        int     i;

        for (i = _iArraySize - 1; NT_SUCCESS(status) && (i >= 0); --i)
        {
            status = pDynamicArrayCallback->Callback(static_cast<char*>(_pvArray) + (_iElementSize * i), i);
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CDynamicPointerArray::CDynamicPointerArray
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CDynamicPointerArray. All elements of this
//              class are pointers that are allocated with LocalAlloc.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

CDynamicPointerArray::CDynamicPointerArray (void) :
    CDynamicArray(sizeof(void*))

{
}

//  --------------------------------------------------------------------------
//  CDynamicPointerArray::~CDynamicPointerArray
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CDynamicPointerArray. Walk the entire array
//              and free each pointer in the array before allowing the base
//              class destructor to release the memory allocated for the
//              actual array itself.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

CDynamicPointerArray::~CDynamicPointerArray (void)

{
    if (_pvArray != NULL)
    {
        int     i;

        for (i = _iArraySize - 1; i >= 0; --i)
        {
            ReleaseMemory(static_cast<void**>(_pvArray)[i]);
        }
    }
}

//  --------------------------------------------------------------------------
//  CDynamicPointerArray::Add
//
//  Arguments:  pvData  =   Pointer to add to the array.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Add the given pointer to the array. The pointer is passed in
//              to this function not a pointer to the pointer.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDynamicPointerArray::Add (const void *pvData)

{
    return(CDynamicArray::Add(&pvData));
}

//  --------------------------------------------------------------------------
//  CDynamicPointerArray::Remove
//
//  Arguments:  iElementIndex   =   Index of the element to remove.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Releases the memory occupied by the element and then removes
//              the element from the array.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDynamicPointerArray::Remove (int iElementIndex)

{
    if ((_pvArray != NULL) && (iElementIndex < _iArraySize))
    {
        ReleaseMemory(static_cast<void**>(_pvArray)[iElementIndex]);
    }
    return(CDynamicArray::Remove(iElementIndex));
}

//  --------------------------------------------------------------------------
//  CDynamicPointerArray::Get
//
//  Arguments:  iElementIndex   =   Index of the element to get.
//
//  Returns:    void*
//
//  Purpose:    Returns the address of the given element in the array. This
//              applies only to pointer arrays.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

void*   CDynamicPointerArray::Get (int iElementIndex)

{
    void*   pvData;

    if (!NT_SUCCESS(CDynamicArray::Get(&pvData, iElementIndex)))
    {
        pvData = NULL;
    }
    return(pvData);
}

//  --------------------------------------------------------------------------
//  CDynamicCountedObjectArray::CDynamicCountedObjectArray
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for the CDynamicCountedObjectArray. All elements
//              should be a subclass of CCountedObject in some way.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

CDynamicCountedObjectArray::CDynamicCountedObjectArray (void) :
    CDynamicArray(sizeof(CCountedObject*))

{
}

//  --------------------------------------------------------------------------
//  CDynamicCountedObjectArray::~CDynamicCountedObjectArray
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CDynamicCountedObjectArray. Walk the entire
//              array and release each CCountedObject in the array before
//              allowing the base class destructor to release the memory
//              allocated for the actual array itself.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

CDynamicCountedObjectArray::~CDynamicCountedObjectArray (void)

{
    if (_pvArray != NULL)
    {
        int     i;

        for (i = _iArraySize - 1; i >= 0; --i)
        {
            reinterpret_cast<CCountedObject**>(_pvArray)[i]->Release();
        }
    }
}

//  --------------------------------------------------------------------------
//  CDynamicCountedObjectArray::Add
//
//  Arguments:  pvData   =   CCountedObject* to add to the array.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Adds the CCountedObject* to the array. Calls
//              CCountedObject::AddRef to incremenet the reference count on
//              the object. If the object cannot be added the reference is
//              released.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDynamicCountedObjectArray::Add (CCountedObject *pvData)

{
    NTSTATUS    status;

    pvData->AddRef();
    status = CDynamicArray::Add(&pvData);
    if (!NT_SUCCESS(status))
    {
        pvData->Release();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CDynamicCountedObjectArray::Remove
//
//  Arguments:  iElementIndex   =   Index of the element to remove.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Releases the reference held on the CCountedObject* and then
//              removes the element from the array.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDynamicCountedObjectArray::Remove (int iElementIndex)

{
    if ((_pvArray != NULL) && (iElementIndex < _iArraySize))
    {
        reinterpret_cast<CCountedObject**>(_pvArray)[iElementIndex]->Release();
    }
    return(CDynamicArray::Remove(iElementIndex));
}

//  --------------------------------------------------------------------------
//  CDynamicCountedObjectArray::Get
//
//  Arguments:  iElementIndex   =   Index of the element to get.
//
//  Returns:    CCountedObject*
//
//  Purpose:    Returns the address of the given element in the array. This
//              applies only to CCountedObject* arrays. This does NOT call
//              CCountedObject::AddRef on the returned pointer.
//
//  History:    1999-11-16  vtan        created
//  --------------------------------------------------------------------------

CCountedObject*     CDynamicCountedObjectArray::Get (int iElementIndex)

{
    CCountedObject*     pObject;

    pObject = NULL;
    (NTSTATUS)CDynamicArray::Get(&pObject, iElementIndex);
    return(pObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\dynamicarray.h ===
//  --------------------------------------------------------------------------
//  Module Name: DynamicArray.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  This file contains related classes to manage dynamic arrays. The array is
//  grown as required but never shrunk. The base class handles struct arrays.
//  Subclasses handle special cases of these arrays (such as pointer or
//  CCountedObject arrays).
//
//  History:    1999-11-16  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _DynamicArray_
#define     _DynamicArray_

#include "CountedObject.h"

//  --------------------------------------------------------------------------
//  CDynamicArrayCallback
//
//  Purpose:    Abstract class definition providing a callback mechanism for
//              iterating the dynamic array.
//
//  History:    1999-11-16  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CDynamicArrayCallback
{
    public:
        virtual NTSTATUS    Callback (const void *pvData, int iElementIndex) = 0;
};

//  --------------------------------------------------------------------------
//  CDynamicArray
//
//  Purpose:    Base class that handles dynamic struct arrays. Allocates
//              memory for the array in 16 block chunks. The memory usage of
//              the array is never reduced.
//
//  History:    1999-11-16  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CDynamicArray
{
    private:
                                    CDynamicArray (void);
    public:
                                    CDynamicArray (int iElementSize);
        virtual                     ~CDynamicArray (void);

        virtual NTSTATUS            Add (const void *pvData);
        virtual NTSTATUS            Remove (int iElementIndex);

                int                 GetCount (void)                             const;
                NTSTATUS            Get (void *pvData, int iElementIndex);
                NTSTATUS            Set (const void* pvData, int iElementIndex);

                NTSTATUS            Iterate (CDynamicArrayCallback *pDynamicArrayCallback);
    protected:
                int                 _iElementSize,
                                    _iArraySize,
                                    _iArrayAllocatedSize;
                void*               _pvArray;
};

//  --------------------------------------------------------------------------
//  CDynamicPointerArray
//
//  Purpose:    Class that subclasses CDynamicArray to implement dynamic
//              pointer arrays. Removing elements automatically frees the
//              memory block used (assuming it was allocated with LocalAlloc).
//
//  History:    1999-11-16  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CDynamicPointerArray : public CDynamicArray
{
    public:
                                    CDynamicPointerArray (void);
        virtual                     ~CDynamicPointerArray (void);

        virtual NTSTATUS            Add (const void *pvData);
        virtual NTSTATUS            Remove (int iElementIndex);

                void*               Get (int iElementIndex);
};

//  --------------------------------------------------------------------------
//  CDynamicCountedObjectArray
//
//  Purpose:    Class that subclasses CDynamicArray to implement dynamic
//              CCountedObject arrays. Removing elements automatically
//              releases the reference held on the dynamic object.
//
//  History:    1999-11-16  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CDynamicCountedObjectArray : public CDynamicArray
{
    public:
                                    CDynamicCountedObjectArray (void);
        virtual                     ~CDynamicCountedObjectArray (void);

                NTSTATUS            Add (CCountedObject *pData);
        virtual NTSTATUS            Remove (int iElementIndex);

                CCountedObject*     Get (int iElementIndex);
};

#endif  /*  _DynamicArray_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\dynamicobject.h ===
//  --------------------------------------------------------------------------
//  Module Name: DynamicObject.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Base class that implements operator new and operator delete for memory
//  usage tracking.
//
//  History:    1999-09-22  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _DynamicObject_
#define     _DynamicObject_

//  --------------------------------------------------------------------------
//  CDynamicObject
//
//  Purpose:    This class is a base class that implements operator new and
//              operator delete so that memory usage can be tracked. Each time
//              an object is created the memory can be added to an array and
//              each time it is destroyed it can be removed.
//
//  History:    1999-09-22  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CDynamicObject
{
    public:
        static  void*   operator new (size_t uiSize);
        static  void    operator delete (void *pvObject);
};

#endif  /*  _DynamicObject_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\dynamicobject.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: DynamicObject.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Base class that implements operator new and operator delete for memory
//  usage tracking.
//
//  History:    1999-09-22  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "DynamicObject.h"

//  --------------------------------------------------------------------------
//  CDynamicObject::operator new
//
//  Arguments:  iSize   =   Size of memory to allocate (in bytes).
//
//  Returns:    <none>
//
//  Purpose:    Allocates a block of memory for a dynamic object.
//
//  History:    1999-09-22  vtan        created
//  --------------------------------------------------------------------------

void*   CDynamicObject::operator new (size_t uiSize)

{
    return(LocalAlloc(LMEM_FIXED, uiSize));
}

//  --------------------------------------------------------------------------
//  CDynamicObject::operator delete
//
//  Arguments:  pObject     =   Address of memory block to delete.
//
//  Returns:    <none>
//
//  Purpose:    Deallocates a block of memory for a dynamic object.
//
//  History:    1999-09-22  vtan      created
//  --------------------------------------------------------------------------

void    CDynamicObject::operator delete (void *pvObject)

{
    (HLOCAL)LocalFree(pvObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\impersonation.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Impersonation.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Classes that handle state preservation, changing and restoration.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "Impersonation.h"

#include "Access.h"
#include "SingleThreadedExecution.h"
#include "TokenInformation.h"

//  --------------------------------------------------------------------------
//  CImpersonation::s_pMutex
//  CImpersonation::s_iReferenceCount
//
//  Purpose:    Static member variables that control access to the global
//              reference count which controls calling
//              kernel32!OpenProfileUserMapping which is a global entity in
//              kernel32.dll.
//  --------------------------------------------------------------------------

CMutex*     CImpersonation::s_pMutex            =   NULL;
int         CImpersonation::s_iReferenceCount   =   -1;

//  --------------------------------------------------------------------------
//  CImpersonation::CImpersonation
//
//  Arguments:  hToken  =   User token to impersonate.
//
//  Returns:    <none>
//
//  Purpose:    Causes the current thread to impersonate the given user for
//              scope of the object. See advapi32!ImpersonateLoggedOnUser for
//              more information on the token requirements. If the thread is
//              already impersonating a debug warning is issued and the
//              request is ignored.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

CImpersonation::CImpersonation (HANDLE hToken) :
    _status(STATUS_UNSUCCESSFUL),
    _fAlreadyImpersonating(false)

{
    HANDLE      hImpersonationToken;

    ASSERTMSG(s_iReferenceCount >= 0, "Negative reference count in CImpersonation::CImpersonation");
    _fAlreadyImpersonating = (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hImpersonationToken) != FALSE);
    if (_fAlreadyImpersonating)
    {
        TBOOL(CloseHandle(hImpersonationToken));
        WARNINGMSG("Thread is already impersonating a user in CImpersonation::CImpersonation");
    }
    else
    {
        _status = ImpersonateUser(GetCurrentThread(), hToken);

        {
            CSingleThreadedMutexExecution   execution(*s_pMutex);

            //  Acquire the s_pMutex mutex before using the reference count.
            //  Control the reference count so that we only call
            //  kernel32!OpenProfileUserMapping for a single impersonation
            //  session. Calling kernel32!CloseProfileUserMapping will
            //  destroy kernel32.dll's global HKEY to the current user.

            if (s_iReferenceCount++ == 0)
            {
                TBOOL(OpenProfileUserMapping());
            }
        }
    }
}

//  --------------------------------------------------------------------------
//  CImpersonation::~CImpersonation
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Reverts to the self token for the thread on the object going
//              out of scope.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

CImpersonation::~CImpersonation (void)

{
    if (!_fAlreadyImpersonating)
    {
        {
            CSingleThreadedMutexExecution   execution(*s_pMutex);

            //  When the reference count hits zero - close the mapping.

            if (--s_iReferenceCount == 0)
            {
                TBOOL(CloseProfileUserMapping());
            }
        }
        TBOOL(RevertToSelf());
    }
}

//  --------------------------------------------------------------------------
//  CImpersonation::IsImpersonating
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the constructor successfully completed
//              impersonating the user.
//
//  History:    2001-01-18  vtan        created
//  --------------------------------------------------------------------------

bool    CImpersonation::IsImpersonating (void)  const

{
    return(NT_SUCCESS(_status));
}

//  --------------------------------------------------------------------------
//  CImpersonation::ImpersonateUser
//
//  Arguments:  hThread     =   HANDLE to the thread that will impersonate.
//              hToken      =   Token of user to impersonate.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Duplicate the given token as an impersonation token. ACL the
//              new token and set it into the thread token.
//
//  History:    1999-11-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CImpersonation::ImpersonateUser (HANDLE hThread, HANDLE hToken)

{
    NTSTATUS                        status;
    HANDLE                          hImpersonationToken;
    OBJECT_ATTRIBUTES               objectAttributes;
    SECURITY_QUALITY_OF_SERVICE     securityQualityOfService;

    InitializeObjectAttributes(&objectAttributes,
                               NULL,
                               OBJ_INHERIT,
                               NULL,
                               NULL);
    securityQualityOfService.Length = sizeof(securityQualityOfService);
    securityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    securityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    securityQualityOfService.EffectiveOnly = FALSE;
    objectAttributes.SecurityQualityOfService = &securityQualityOfService;
    status = NtDuplicateToken(hToken,
                              TOKEN_IMPERSONATE | TOKEN_QUERY | READ_CONTROL | WRITE_DAC,
                              &objectAttributes,
                              FALSE,
                              TokenImpersonation,
                              &hImpersonationToken);
    if (NT_SUCCESS(status))
    {
        PSID                pLogonSID;
        CTokenInformation   tokenInformation(hImpersonationToken);

        pLogonSID = tokenInformation.GetLogonSID();
        if (pLogonSID != NULL)
        {
            CSecuredObject  tokenSecurity(hImpersonationToken, SE_KERNEL_OBJECT);

            TSTATUS(tokenSecurity.Allow(pLogonSID,
                                        TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS | TOKEN_ADJUST_DEFAULT | TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE | READ_CONTROL,
                                        0));
        }
        status = NtSetInformationThread(hThread,
                                        ThreadImpersonationToken,
                                        &hImpersonationToken,
                                        sizeof(hImpersonationToken));
        TSTATUS(NtClose(hImpersonationToken));
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CImpersonation::StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Initializes the mutex object and the reference count. The
//              reference count is initialized to -1 by the compiler to help
//              detect cases where this function is not called!
//
//  History:    1999-10-13  vtan        created
//              2000-12-06  vtan        ignore create mutex failure
//  --------------------------------------------------------------------------

NTSTATUS    CImpersonation::StaticInitialize (void)

{
    s_pMutex = new CMutex;
    if (s_pMutex != NULL)
    {
        (NTSTATUS)s_pMutex->Initialize(TEXT("Global\\winlogon: Logon UserProfileMapping Mutex"));
    }
    s_iReferenceCount = 0;
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CImpersonation::StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Releases the mutex object.
//
//  History:    1999-10-13  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CImpersonation::StaticTerminate (void)

{
    NTSTATUS    status;

    ASSERTMSG(s_iReferenceCount == 0, "Non zero reference count in CImpersonation::StaticTerminate");
    if (s_pMutex != NULL)
    {
        status = s_pMutex->Terminate();
        delete s_pMutex;
        s_pMutex = NULL;
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\registryresources.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: RegistryResources.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  General class definitions that assist in resource management. These are
//  typically stack based objects where constructors initialize to a known
//  state. Member functions operate on that resource. Destructors release
//  resources when the object goes out of scope.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "RegistryResources.h"

#include <stdlib.h>

#include "StringConvert.h"

//  --------------------------------------------------------------------------
//  CRegKey::CRegKey
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CRegKey object.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CRegKey::CRegKey (void) :
    _hKey(NULL),
    _dwIndex(0)

{
}

//  --------------------------------------------------------------------------
//  CRegKey::~CRegKey
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the CRegKey object.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CRegKey::~CRegKey (void)

{
    TW32(Close());
}

//  --------------------------------------------------------------------------
//  CRegKey::Create
//
//  Arguments:  See the platform SDK under advapi32!RegCreateKeyEx.
//
//  Returns:    LONG
//
//  Purpose:    See advapi32!RegCreateKeyEx.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::Create (HKEY hKey, LPCTSTR lpSubKey, DWORD dwOptions, REGSAM samDesired, LPDWORD lpdwDisposition)

{
    TW32(Close());
    return(RegCreateKeyEx(hKey, lpSubKey, 0, NULL, dwOptions, samDesired, NULL, &_hKey, lpdwDisposition));
}

//  --------------------------------------------------------------------------
//  CRegKey::Open
//
//  Arguments:  See the platform SDK under advapi32!RegOpenKeyEx.
//
//  Returns:    LONG
//
//  Purpose:    See advapi32!RegOpenKeyEx.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::Open (HKEY hKey, LPCTSTR lpSubKey, REGSAM samDesired)

{
    TW32(Close());
    return(RegOpenKeyEx(hKey, lpSubKey, 0, samDesired, &_hKey));
}

//  --------------------------------------------------------------------------
//  CRegKey::OpenCurrentUser
//
//  Arguments:  lpSubKey    =   Subkey to open under the current user.
//              samDesired  =   Desired access.
//
//  Returns:    LONG
//
//  Purpose:    Opens HKEY_CURRENT_USER\<lpSubKey> for the impersonated user.
//              If the thread isn't impersonating it opens the .default user.
//
//  History:    2000-05-23  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::OpenCurrentUser (LPCTSTR lpSubKey, REGSAM samDesired)

{
    LONG        lErrorCode;
    NTSTATUS    status;
    HKEY        hKeyCurrentUser;

    status = RtlOpenCurrentUser(samDesired, reinterpret_cast<void**>(&hKeyCurrentUser));
    if (NT_SUCCESS(status))
    {
        lErrorCode = Open(hKeyCurrentUser, lpSubKey, samDesired);
        TW32(RegCloseKey(hKeyCurrentUser));
    }
    else
    {
        lErrorCode = RtlNtStatusToDosError(status);
    }
    return(lErrorCode);
}

//  --------------------------------------------------------------------------
//  CRegKey::QueryValue
//
//  Arguments:  See the platform SDK under advapi32!RegQueryValueEx.
//
//  Returns:    LONG
//
//  Purpose:    See advapi32!RegQueryValueEx.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::QueryValue (LPCTSTR lpValueName, LPDWORD lpType, LPVOID lpData, LPDWORD lpcbData)      const

{
    ASSERTMSG(_hKey != NULL, "No open HKEY in CRegKey::QueryValue");
    return(RegQueryValueEx(_hKey, lpValueName, NULL, lpType, reinterpret_cast<LPBYTE>(lpData), lpcbData));
}

//  --------------------------------------------------------------------------
//  CRegKey::SetValue
//
//  Arguments:  See the platform SDK under advapi32!RegSetValueEx.
//
//  Returns:    LONG
//
//  Purpose:    See advapi32!RegSetValueEx.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::SetValue (LPCTSTR lpValueName, DWORD dwType, CONST VOID *lpData, DWORD cbData)         const

{
    ASSERTMSG(_hKey != NULL, "No open HKEY in CRegKey::SetValue");
    return(RegSetValueEx(_hKey, lpValueName, 0, dwType, reinterpret_cast<const unsigned char*>(lpData), cbData));
}

//  --------------------------------------------------------------------------
//  CRegKey::DeleteValue
//
//  Arguments:  See the platform SDK under advapi32!RegDeleteValue.
//
//  Returns:    LONG
//
//  Purpose:    See advapi32!RegDeleteValue.
//
//  History:    1999-10-31  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::DeleteValue (LPCTSTR lpValueName)               const

{
    ASSERTMSG(_hKey != NULL, "No open HKEY in CRegKey::DeleteValue");
    return(RegDeleteValue(_hKey, lpValueName));
}

//  --------------------------------------------------------------------------
//  CRegKey::QueryInfoKey
//
//  Arguments:  See the platform SDK under advapi32!RegQueryInfoKey.
//
//  Returns:    LONG
//
//  Purpose:    See advapi32!RegQueryInfoKey.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::QueryInfoKey (LPTSTR lpClass, LPDWORD lpcbClass, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)      const

{
    ASSERTMSG(_hKey != NULL, "No open HKEY in CRegKey::QueryInfoKey");
    return(RegQueryInfoKey(_hKey, lpClass, lpcbClass, NULL, lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime));
}

//  --------------------------------------------------------------------------
//  CRegKey::Reset
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Reset the enumeration index member variable used in
//              advapi32!RegEnumValue.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

void    CRegKey::Reset (void)

{
    _dwIndex = 0;
}

//  --------------------------------------------------------------------------
//  CRegKey::Next
//
//  Arguments:  See the platform SDK under advapi32!RegEnumValue.
//
//  Returns:    LONG
//
//  Purpose:    See advapi32!RegEnumValue.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::Next (LPTSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpType, LPVOID lpData, LPDWORD lpcbData)

{
    return(RegEnumValue(_hKey, _dwIndex++, lpValueName, lpcbValueName, NULL, lpType, reinterpret_cast<LPBYTE>(lpData), lpcbData));
}

//  --------------------------------------------------------------------------
//  CRegKey::GetString
//
//  Arguments:  pszValueName        =   Name of value in key to get data of.
//              pszValueData        =   String buffer to be filled with data.
//              pdwValueDataSize    =   Size (in characters) of buffer.
//
//  Returns:    LONG
//
//  Purpose:    Queries the registry key for the specified value and returns
//              the data to the caller. Asserts for REG_SZ.
//
//  History:    1999-09-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::GetString (const TCHAR *pszValueName, TCHAR *pszValueData, int iStringCount)                    const

{
    LONG    errorCode;
    DWORD   dwType, dwValueDataSizeInBytes;

    dwValueDataSizeInBytes = iStringCount * sizeof(TCHAR);
    errorCode = QueryValue(pszValueName, &dwType, pszValueData, &dwValueDataSizeInBytes);
    if (ERROR_SUCCESS == errorCode)
    {
        if (dwType != REG_SZ)
        {
            DISPLAYMSG("CRegKey::GetString retrieved data that is not REG_SZ");
            errorCode = ERROR_INVALID_DATA;
        }
    }
    return(errorCode);
}

//  --------------------------------------------------------------------------
//  CRegKey::GetPath
//
//  Arguments:  pszValueName        =   Name of value in key to get data of.
//              pszValueData        =   String buffer to be filled with data.
//
//  Returns:    LONG
//
//  Purpose:    Queries the registry key for the specified value and returns
//              the data to the caller. Asserts for REG_SZ or REG_EXPAND_SZ.
//              Also expands the path stored as well as assumes that MAX_PATH
//              is the buffer size.
//
//  History:    1999-09-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::GetPath (const TCHAR *pszValueName, TCHAR *pszValueData)                   const

{
    LONG    errorCode;
    DWORD   dwType, dwRawPathSize;
    TCHAR   szRawPath[MAX_PATH];

    dwRawPathSize = sizeof(szRawPath);
    errorCode = QueryValue(pszValueName, &dwType, szRawPath, &dwRawPathSize);
    if (ERROR_SUCCESS == errorCode)
    {
        if (dwType == REG_SZ)
        {
            lstrcpyn(pszValueData, szRawPath, MAX_PATH);
        }
        else if (dwType == REG_EXPAND_SZ)
        {
            if (ExpandEnvironmentStrings(szRawPath, pszValueData, MAX_PATH) == 0)
            {
                lstrcpyn(pszValueData, szRawPath, MAX_PATH);
            }
        }
        else
        {
            DISPLAYMSG("CRegKey::GetPath retrieved data that is not REG_SZ or REG_EXPAND_SZ");
            errorCode = ERROR_INVALID_DATA;
        }
    }
    return(errorCode);
}

//  --------------------------------------------------------------------------
//  CRegKey::GetDWORD
//
//  Arguments:  pszValueName        =   Name of value in key to get data of.
//              pdwValueData        =   DWORD buffer to be filled with data.
//
//  Returns:    LONG
//
//  Purpose:    Queries the registry key for the specified value and returns
//              the data to the caller. Asserts for REG_DWORD.
//
//  History:    1999-09-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::GetDWORD (const TCHAR *pszValueName, DWORD& dwValueData)                   const

{
    LONG    errorCode;
    DWORD   dwType, dwValueDataSize;

    dwValueDataSize = sizeof(DWORD);
    errorCode = QueryValue(pszValueName, &dwType, &dwValueData, &dwValueDataSize);
    if (ERROR_SUCCESS == errorCode)
    {
        if (dwType != REG_DWORD)
        {
            DISPLAYMSG("CRegKey::GetString retrieved data that is not REG_DWORD");
            errorCode = ERROR_INVALID_DATA;
        }
    }
    return(errorCode);
}

//  --------------------------------------------------------------------------
//  CRegKey::GetInteger
//
//  Arguments:  pszValueName        =   Name of value in key to get data of.
//              piValueData         =   Integer buffer to be filled with data.
//
//  Returns:    LONG
//
//  Purpose:    Queries the registry key for the specified value and returns
//              the data to the caller. If the data is REG_DWORD this is
//              casted. If the data is REG_SZ this is converted. Everything
//              is illegal (including REG_EXPAND_SZ).
//
//  History:    1999-09-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::GetInteger (const TCHAR *pszValueName, int& iValueData)                    const

{
    LONG    errorCode;
    DWORD   dwType, dwValueDataSize;

    errorCode = QueryValue(pszValueName, &dwType, NULL, NULL);
    if (ERROR_SUCCESS == errorCode)
    {
        if (dwType == REG_DWORD)
        {
            dwValueDataSize = sizeof(int);
            errorCode = QueryValue(pszValueName, NULL, &iValueData, &dwValueDataSize);
        }
        else if (dwType == REG_SZ)
        {
            TCHAR   szTemp[32];

            dwValueDataSize = ARRAYSIZE(szTemp);
            errorCode = QueryValue(pszValueName, NULL, szTemp, &dwValueDataSize);
            if (ERROR_SUCCESS == errorCode)
            {
                char    aszTemp[32];

                CStringConvert::TCharToAnsi(szTemp, aszTemp, ARRAYSIZE(aszTemp));
                iValueData = atoi(aszTemp);
            }
        }
        else
        {
            DISPLAYMSG("CRegKey::GetString retrieved data that is not REG_DWORD");
            errorCode = ERROR_INVALID_DATA;
        }
    }
    return(errorCode);
}

//  --------------------------------------------------------------------------
//  CRegKey::SetString
//
//  Arguments:  
//
//  Returns:    LONG
//
//  Purpose:    
//
//  History:    1999-10-26  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::SetString (const TCHAR *pszValueName, const TCHAR *pszValueData)           const

{
    return(SetValue(pszValueName, REG_SZ, pszValueData, (lstrlen(pszValueData) + sizeof('\0')) * sizeof(TCHAR)));
}

//  --------------------------------------------------------------------------
//  CRegKey::SetPath
//
//  Arguments:  
//
//  Returns:    LONG
//
//  Purpose:    
//
//  History:    1999-10-26  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::SetPath (const TCHAR *pszValueName, const TCHAR *pszValueData)             const

{
    return(SetValue(pszValueName, REG_EXPAND_SZ, pszValueData, (lstrlen(pszValueData) + sizeof('\0')) * sizeof(TCHAR)));
}

//  --------------------------------------------------------------------------
//  CRegKey::SetDWORD
//
//  Arguments:  
//
//  Returns:    LONG
//
//  Purpose:    
//
//  History:    1999-10-26  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::SetDWORD (const TCHAR *pszValueName, DWORD dwValueData)                    const

{
    return(SetValue(pszValueName, REG_DWORD, &dwValueData, sizeof(dwValueData)));
}

//  --------------------------------------------------------------------------
//  CRegKey::SetInteger
//
//  Arguments:  
//
//  Returns:    LONG
//
//  Purpose:    
//
//  History:    1999-10-26  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::SetInteger (const TCHAR *pszValueName, int iValueData)                     const

{
    TCHAR   szString[kMaximumValueDataLength];

    wsprintf(szString, TEXT("%d"), iValueData);
    return(SetString(pszValueName, szString));
}

//  --------------------------------------------------------------------------
//  CRegKey::Close
//
//  Arguments:  <none>
//
//  Returns:    LONG
//
//  Purpose:    Closes HKEY resource (if open).
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CRegKey::Close (void)

{
    LONG    errorCode;

    if (_hKey != NULL)
    {
        errorCode = RegCloseKey(_hKey);
        _hKey = NULL;
    }
    else
    {
        errorCode = ERROR_SUCCESS;
    }
    return(errorCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\registryresources.h ===
//  --------------------------------------------------------------------------
//  Module Name: RegistryResources.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  General class definitions that assist in resource management. These are
//  typically stack based objects where constructors initialize to a known
//  state. Member functions operate on that resource. Destructors release
//  resources when the object goes out of scope.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _RegistryResources_
#define     _RegistryResources_

//  --------------------------------------------------------------------------
//  CRegKey
//
//  Purpose:    This class operates on the registry and manages the HKEY
//              resource.
//
//  History:    1999-08-18  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CRegKey
{
    private:
                                CRegKey (const CRegKey& copyObject);
        bool                    operator == (const CRegKey& compareObject)      const;
        const CRegKey&          operator = (const CRegKey& assignObject);
    public:
                                CRegKey (void);
                                ~CRegKey (void);

        LONG                    Create (HKEY hKey,
                                        LPCTSTR lpSubKey,
                                        DWORD dwOptions,
                                        REGSAM samDesired,
                                        LPDWORD lpdwDisposition);
        LONG                    Open (HKEY hKey,
                                      LPCTSTR lpSubKey,
                                      REGSAM samDesired);
        LONG                    OpenCurrentUser (LPCTSTR lpSubKey,
                                                 REGSAM samDesired);
        LONG                    QueryValue (LPCTSTR lpValueName,
                                            LPDWORD lpType,
                                            LPVOID lpData,
                                            LPDWORD lpcbData)                   const;
        LONG                    SetValue (LPCTSTR lpValueName,
                                          DWORD dwType,
                                          CONST VOID *lpData,
                                          DWORD cbData)                         const;
        LONG                    DeleteValue (LPCTSTR lpValueName)               const;
        LONG                    QueryInfoKey (LPTSTR lpClass,
                                              LPDWORD lpcClass,
                                              LPDWORD lpcSubKeys,
                                              LPDWORD lpcMaxSubKeyLen,
                                              LPDWORD lpcMaxClassLen,
                                              LPDWORD lpcValues,
                                              LPDWORD lpcMaxValueNameLen,
                                              LPDWORD lpcMaxValueLen,
                                              LPDWORD lpcbSecurityDescriptor,
                                              PFILETIME lpftLastWriteTime)      const;
        void                    Reset (void);
        LONG                    Next (LPTSTR lpValueName,
                                      LPDWORD lpcValueName,
                                      LPDWORD lpType,
                                      LPVOID lpData,
                                      LPDWORD lpcbData);

        LONG                    GetString (const TCHAR *pszValueName,
                                           TCHAR *pszValueData,
                                           int iStringCount)                    const;
        LONG                    GetPath (const TCHAR *pszValueName,
                                         TCHAR *pszValueData)                   const;
        LONG                    GetDWORD (const TCHAR *pszValueName,
                                          DWORD& dwValueData)                   const;
        LONG                    GetInteger (const TCHAR *pszValueName,
                                            int& iValueData)                    const;

        LONG                    SetString (const TCHAR *pszValueName,
                                           const TCHAR *pszValueData)           const;
        LONG                    SetPath (const TCHAR *pszValueName,
                                         const TCHAR *pszValueData)             const;
        LONG                    SetDWORD (const TCHAR *pszValueName,
                                          DWORD dwValueData)                    const;
        LONG                    SetInteger (const TCHAR *pszValueName,
                                            int iValueData)                     const;
    private:
        LONG                    Close (void);

    private:
        HKEY                    _hKey;
        DWORD                   _dwIndex;
};

#endif  /*  _RegistryResources_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\impersonation.h ===
//  --------------------------------------------------------------------------
//  Module Name: Impersonation.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Classes that handle state preservation, changing and restoration.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _Impersonation_
#define     _Impersonation_

#include "KernelResources.h"

//  --------------------------------------------------------------------------
//  CImpersonation
//
//  Purpose:    This class allows a thread to impersonate a user and revert to
//              self when the object goes out of scope.
//
//  History:    1999-08-18  vtan        created
//              1999-10-13  vtan        added reference counting
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CImpersonation
{
    private:
                                    CImpersonation (void);
    public:
                                    CImpersonation (HANDLE hToken);
                                    ~CImpersonation (void);

                bool                IsImpersonating (void)  const;

        static  NTSTATUS            ImpersonateUser (HANDLE hThread, HANDLE hToken);

        static  NTSTATUS            StaticInitialize (void);
        static  NTSTATUS            StaticTerminate (void);
    private:
        static  CMutex*             s_pMutex;
        static  int                 s_iReferenceCount;

                NTSTATUS            _status;
                bool                _fAlreadyImpersonating;
};

#endif  /*  _Impersonation_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\kernelresources.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: KernelResources.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  General class definitions that assist in resource management. These are
//  typically stack based objects where constructors initialize to a known
//  state. Member functions operate on that resource. Destructors release
//  resources when the object goes out of scope.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "KernelResources.h"

#include "StatusCode.h"

//  --------------------------------------------------------------------------
//  CHandle::CHandle
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CHandle object.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CHandle::CHandle (HANDLE handle) :
    _handle(handle)

{
}

//  --------------------------------------------------------------------------
//  CHandle::~CHandle
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the CHandle object.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CHandle::~CHandle (void)

{
    ReleaseHandle(_handle);
}

//  --------------------------------------------------------------------------
//  CHandle::operator HANDLE
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Magically converts a CHandle to a HANDLE.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CHandle::operator HANDLE (void)                             const

{
    return(_handle);
}

//  --------------------------------------------------------------------------
//  CEvent::CEvent
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CEvent object. No event is created.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CEvent::CEvent (void) :
    _hEvent(NULL)

{
}

//  --------------------------------------------------------------------------
//  CEvent::CEvent
//
//  Arguments:  copyObject  =   Object to copy on construction.
//
//  Returns:    <none>
//
//  Purpose:    Copy constructor for the CEvent object. An event is
//              duplicated.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CEvent::CEvent (const CEvent& copyObject) :
    _hEvent(NULL)

{
    *this = copyObject;
}

//  --------------------------------------------------------------------------
//  CEvent::CEvent
//
//  Arguments:  pszName     =   Optional name of an event object to create on
//                              construction.
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CEvent object. A named event is created.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CEvent::CEvent (const TCHAR *pszName) :
    _hEvent(NULL)

{
    TSTATUS(Create(pszName));
}

//  --------------------------------------------------------------------------
//  CEvent::~CEvent
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the CEvent object.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CEvent::~CEvent (void)

{
    TSTATUS(Close());
}

//  --------------------------------------------------------------------------
//  CEvent::operator =
//
//  Arguments:  assignObject    =   Object being assigned.
//
//  Returns:    const CEvent&
//
//  Purpose:    Overloaded operator = to ensure that the event is properly
//              duplicated with another handle referencing the same object.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

const CEvent&   CEvent::operator = (const CEvent& assignObject)

{
    if (this != &assignObject)
    {
        TSTATUS(Close());
        TBOOL(DuplicateHandle(GetCurrentProcess(), assignObject._hEvent, GetCurrentProcess(), &_hEvent, 0, FALSE, DUPLICATE_SAME_ACCESS));
    }
    return(*this);
}

//  --------------------------------------------------------------------------
//  CEvent::operator HANDLE
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Magically converts a CEvent to a HANDLE.
//
//  History:    1999-09-21  vtan        created
//  --------------------------------------------------------------------------

CEvent::operator HANDLE (void)                              const

{
    return(_hEvent);
}

//  --------------------------------------------------------------------------
//  CEvent::Open
//
//  Arguments:  pszName     =   Optional name of the event object to open.
//              dwAccess    =   Access level required.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Opens the event object.
//
//  History:    1999-10-26  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CEvent::Open (const TCHAR *pszName, DWORD dwAccess)

{
    NTSTATUS    status;

    TSTATUS(Close());
    _hEvent = OpenEvent(dwAccess, FALSE, pszName);
    if (_hEvent != NULL)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CEvent::Create
//
//  Arguments:  pszName =   Optional name of the event object to create. It
//                          is possible to create un-named events.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Creates the event object. The event is manually reset and NOT
//              signaled initially.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CEvent::Create (const TCHAR *pszName)

{
    NTSTATUS    status;

    TSTATUS(Close());
    _hEvent = CreateEvent(NULL, TRUE, FALSE, pszName);
    if (_hEvent != NULL)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CEvent::Set
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Set the event object state to signaled.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CEvent::Set (void)                                          const

{
    NTSTATUS    status;

    ASSERTMSG(_hEvent != NULL, "No event object in CEvent::Set");
    if (SetEvent(_hEvent) != FALSE)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CEvent::Reset
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Clears the event object state to NOT signaled.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CEvent::Reset (void)                                        const

{
    NTSTATUS    status;

    ASSERTMSG(_hEvent != NULL, "No event object in CEvent::Reset");
    if (ResetEvent(_hEvent) != FALSE)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CEvent::Pulse
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Set the event object state to signaled, releases any threads
//              waiting on this event and clears the event object state to
//              NOT signaled.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CEvent::Pulse (void)                                        const

{
    NTSTATUS    status;

    ASSERTMSG(_hEvent != NULL, "No event object in CEvent::Pulse");
    if (PulseEvent(_hEvent) != FALSE)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CEvent::Wait
//
//  Arguments:  dwMilliseconds  =   Number of milliseconds to wait until the
//                                  event becomes signaled.
//              pdwWaitResult   =   Result from kernel32!WaitForSingleObject.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Waits for the event object to become signaled.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CEvent::Wait (DWORD dwMilliseconds, DWORD *pdwWaitResult)           const

{
    NTSTATUS    status;
    DWORD       dwWaitResult;

    ASSERTMSG(_hEvent != NULL, "No event object in CEvent::Wait");
    dwWaitResult = WaitForSingleObject(_hEvent, dwMilliseconds);
    if (pdwWaitResult != NULL)
    {
        *pdwWaitResult = dwWaitResult;
    }
    if (dwWaitResult == WAIT_OBJECT_0)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CEvent::Wait
//
//  Arguments:  dwMilliseconds  =   Number of milliseconds to wait until the
//                                  event becomes signaled.
//              pdwWaitResult   =   Result from kernel32!WaitForSingleObject.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Waits for the event object to become signaled.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CEvent::WaitWithMessages (DWORD dwMilliseconds, DWORD *pdwWaitResult)   const

{
    NTSTATUS    status;
    DWORD       dwWaitResult;

    do
    {

        //  When waiting for the object check to see that it's not signaled.
        //  If signaled then abandon the wait loop. Otherwise allow user32
        //  to continue processing messages for this thread.

        dwWaitResult = WaitForSingleObject(_hEvent, 0);
        if (dwWaitResult != WAIT_OBJECT_0)
        {
            dwWaitResult = MsgWaitForMultipleObjects(1, &_hEvent, FALSE, dwMilliseconds, QS_ALLINPUT);
            if (dwWaitResult == WAIT_OBJECT_0 + 1)
            {
                MSG     msg;

                if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) != FALSE)
                {
                    (BOOL)TranslateMessage(&msg);
                    (LRESULT)DispatchMessage(&msg);
                }
            }
         }
    } while (dwWaitResult == WAIT_OBJECT_0 + 1);
    if (pdwWaitResult != NULL)
    {
        *pdwWaitResult = dwWaitResult;
    }
    if (dwWaitResult == WAIT_OBJECT_0)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CEvent::IsSignaled
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the event is signaled without waiting.
//
//  History:    2000-08-09  vtan        created
//  --------------------------------------------------------------------------

bool    CEvent::IsSignaled (void)                                   const

{
    return(WAIT_OBJECT_0 == WaitForSingleObject(_hEvent, 0));
}

//  --------------------------------------------------------------------------
//  CEvent::Close
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Closes the event object HANDLE.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CEvent::Close (void)

{
    ReleaseHandle(_hEvent);
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CJob::CJob
//
//  Arguments:  pszName     =   Optional name of an event object to create on
//                              construction.
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CJob object. A named event is created.
//
//  History:    1999-10-07  vtan        created
//  --------------------------------------------------------------------------

CJob::CJob (const TCHAR *pszName) :
    _hJob(NULL)

{
    _hJob = CreateJobObject(NULL, pszName);
    ASSERTMSG(_hJob != NULL, "Job object creation failed iN CJob::CJob");
}

//  --------------------------------------------------------------------------
//  CJob::~CJob
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the CJob object.
//
//  History:    1999-10-07  vtan        created
//  --------------------------------------------------------------------------

CJob::~CJob (void)

{
    ReleaseHandle(_hJob);
}

//  --------------------------------------------------------------------------
//  CJob::AddProcess
//
//  Arguments:  hProcess    =   Handle to the process to add to this job.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Adds the process to this job.
//
//  History:    1999-10-07  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CJob::AddProcess (HANDLE hProcess)                        const

{
    NTSTATUS    status;

    ASSERTMSG(_hJob != NULL, "Must have job object in CJob::AddProcess");
    if (AssignProcessToJobObject(_hJob, hProcess) != FALSE)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CJob::SetCompletionPort
//
//  Arguments:  hCompletionPort     =   IO completion port for job completion
//                                      messages.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Set the IO completion port for this job. The caller should
//              watch this port for messages related to this job.
//
//  History:    1999-10-07  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CJob::SetCompletionPort (HANDLE hCompletionPort)          const

{
    NTSTATUS                                status;
    JOBOBJECT_ASSOCIATE_COMPLETION_PORT     associateCompletionPort;

    ASSERTMSG(_hJob != NULL, "Must have job object in CJob::SetCompletionPort");
    associateCompletionPort.CompletionKey = NULL;
    associateCompletionPort.CompletionPort = hCompletionPort;

    //  If the job completion port cannot be set then don't use it.

    if (SetInformationJobObject(_hJob, JobObjectAssociateCompletionPortInformation, &associateCompletionPort, sizeof(associateCompletionPort)) != FALSE)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CJob:SetActiveProcessLimit
//
//  Arguments:  dwActiveProcessLimit    =   Maximum number of processes.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Sets the limit for the number of processes related to this
//              job. Typically you can use this to restrict a process from
//              starting another process whena quota (such as 1) is reached.
//
//  History:    1999-10-07  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CJob::SetActiveProcessLimit (DWORD dwActiveProcessLimit)  const

{
    NTSTATUS                            status;
    DWORD                               dwReturnLength;
    JOBOBJECT_BASIC_LIMIT_INFORMATION   basicLimitInformation;

    ASSERTMSG(_hJob != NULL, "Must have job object in CJob::SetActiveProcessLimit");
    if (QueryInformationJobObject(_hJob,
                                  JobObjectBasicLimitInformation,
                                  &basicLimitInformation,
                                  sizeof(basicLimitInformation),
                                  &dwReturnLength) != FALSE)
    {
        if (dwActiveProcessLimit == 0)
        {
            basicLimitInformation.LimitFlags &= ~JOB_OBJECT_LIMIT_ACTIVE_PROCESS;
            basicLimitInformation.ActiveProcessLimit = 0;
        }
        else
        {
            basicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_ACTIVE_PROCESS;
            basicLimitInformation.ActiveProcessLimit = dwActiveProcessLimit;
        }
        if (SetInformationJobObject(_hJob, JobObjectBasicLimitInformation, &basicLimitInformation, sizeof(basicLimitInformation)) != FALSE)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

NTSTATUS    CJob::SetPriorityClass (DWORD dwPriorityClass)            const

{
    NTSTATUS                            status;
    DWORD                               dwReturnLength;
    JOBOBJECT_BASIC_LIMIT_INFORMATION   basicLimitInformation;

    ASSERTMSG(_hJob != NULL, "Must have job object in CJob::SetPriorityClass");
    if (QueryInformationJobObject(_hJob,
                                  JobObjectBasicLimitInformation,
                                  &basicLimitInformation,
                                  sizeof(basicLimitInformation),
                                  &dwReturnLength) != FALSE)
    {
        if (dwPriorityClass == 0)
        {
            basicLimitInformation.LimitFlags &= ~JOB_OBJECT_LIMIT_PRIORITY_CLASS;
            basicLimitInformation.PriorityClass = NORMAL_PRIORITY_CLASS;
        }
        else
        {
            basicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PRIORITY_CLASS;
            basicLimitInformation.PriorityClass = dwPriorityClass;
        }
        if (SetInformationJobObject(_hJob, JobObjectBasicLimitInformation, &basicLimitInformation, sizeof(basicLimitInformation)) != FALSE)
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            status = CStatusCode::StatusCodeOfLastError();
        }
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CJob:RestrictAccessUIAll
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Restricts process in the job from accessing UI components.
//              Take care when using this feature.
//
//  History:    1999-10-07  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CJob::RestrictAccessUIAll (void)                          const

{
    NTSTATUS                            status;
    JOBOBJECT_BASIC_UI_RESTRICTIONS     basicUIRestrictions;

    ASSERTMSG(_hJob != NULL, "Must have job object in CJob::RestrictAccessUIAll");
    basicUIRestrictions.UIRestrictionsClass = JOB_OBJECT_UILIMIT_DESKTOP |
                                              JOB_OBJECT_UILIMIT_DISPLAYSETTINGS |
                                              JOB_OBJECT_UILIMIT_EXITWINDOWS |
                                              JOB_OBJECT_UILIMIT_GLOBALATOMS |
                                              JOB_OBJECT_UILIMIT_HANDLES |
                                              JOB_OBJECT_UILIMIT_READCLIPBOARD |
                                              JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS |
                                              JOB_OBJECT_UILIMIT_WRITECLIPBOARD;
    if (SetInformationJobObject(_hJob, JobObjectBasicUIRestrictions, &basicUIRestrictions, sizeof(basicUIRestrictions)) != FALSE)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CMutex::Initialize
//
//  Arguments:  pszMutexName    =   Name of the mutex to create.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Create or open a mutex object. It always tries to create the
//              mutex so a name MUST be specified.
//
//  History:    1999-10-13  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CMutex::Initialize (const TCHAR *pszMutexName)

{
    NTSTATUS    status;

    ASSERTMSG(pszMutexName != NULL, "Must specify a mutex name in CMutex::Initialize");
    _hMutex = CreateMutex(NULL, FALSE, pszMutexName);
    if (_hMutex != NULL)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CMutex::Terminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Releases the mutex object resource.
//
//  History:    1999-10-13  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CMutex::Terminate (void)

{
    ReleaseHandle(_hMutex);
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CMutex::Acquire
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Acquires the mutex object. This will block indefinitely and
//              will also block a message pump. Use this with caution!
//
//  History:    1999-10-13  vtan        created
//  --------------------------------------------------------------------------

void    CMutex::Acquire (void)

{
    if (_hMutex != NULL)
    {
        (DWORD)WaitForSingleObject(_hMutex, INFINITE);
    }
}

//  --------------------------------------------------------------------------
//  CMutex::Release
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases ownership of the mutex object.
//
//  History:    1999-10-13  vtan        created
//  --------------------------------------------------------------------------

void    CMutex::Release (void)

{
    if (_hMutex != NULL)
    {
        TBOOL(ReleaseMutex(_hMutex));
    }
}

//  --------------------------------------------------------------------------
//  CCriticalSection::CCriticalSection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the critical section object.
//
//  History:    1999-11-06  vtan        created
//  --------------------------------------------------------------------------

CCriticalSection::CCriticalSection (void)

{
    _status = RtlInitializeCriticalSection(&_criticalSection);
}

//  --------------------------------------------------------------------------
//  CCriticalSection::~CCriticalSection
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destroys the critical section object.
//
//  History:    1999-11-06  vtan        created
//  --------------------------------------------------------------------------

CCriticalSection::~CCriticalSection (void)

{
    if (NT_SUCCESS(_status))
    {
        TSTATUS(RtlDeleteCriticalSection(&_criticalSection));
    }
}

//  --------------------------------------------------------------------------
//  CCriticalSection::Acquire
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Acquire the critical section object.
//
//  History:    1999-11-06  vtan        created
//  --------------------------------------------------------------------------

void    CCriticalSection::Acquire (void)

{
    if (NT_SUCCESS(_status))
    {
        EnterCriticalSection(&_criticalSection);
    }
}

//  --------------------------------------------------------------------------
//  CCriticalSection::Release
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Release the critical section object.
//
//  History:    1999-11-06  vtan        created
//  --------------------------------------------------------------------------

void    CCriticalSection::Release (void)

{
    if (NT_SUCCESS(_status))
    {
        LeaveCriticalSection(&_criticalSection);
    }
}

//  --------------------------------------------------------------------------
//  CCriticalSection::Status
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Returns the construction status.
//
//  History:    2000-12-09  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CCriticalSection::Status (void)   const

{
    return(_status);
}

//  --------------------------------------------------------------------------
//  CCriticalSection::IsOwned
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether the critical section is owned.
//
//  History:    2001-04-05  vtan        created
//  --------------------------------------------------------------------------

bool    CCriticalSection::IsOwned (void)  const

{
    return(NT_SUCCESS(_status) && (_criticalSection.OwningThread == NtCurrentTeb()->ClientId.UniqueThread));
}

//  --------------------------------------------------------------------------
//  CModule::CModule
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CModule object. Opens the given dynamic link
//              library.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CModule::CModule (const TCHAR *pszModuleName) :
    _hModule(NULL)

{
    _hModule = LoadLibrary(pszModuleName);
}

//  --------------------------------------------------------------------------
//  CModule::~CModule
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the CModule object. Closes the
//              library if opened.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CModule::~CModule (void)

{
    if (_hModule != NULL)
    {
        TBOOL(FreeLibrary(_hModule));
        _hModule = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CModule::operator HMODULE
//
//  Arguments:  <none>
//
//  Returns:    HMODULE
//
//  Purpose:    Returns the HMODULE for the loaded library.
//
//  History:    2000-10-12  vtan        created
//  --------------------------------------------------------------------------

CModule::operator HMODULE (void)                     const

{
    return(_hModule);
}

//  --------------------------------------------------------------------------
//  CModule::GetProcAddress
//
//  Arguments:  pszProcName     =   Name of function entry point to retrieve
//                                  in the given dynamic link library. This is
//                                  ANSI by definition.
//
//  Returns:    void*   =   Address of the function if it exists or NULL if
//                          failed.
//
//  Purpose:    Retrieves the function entry point in a dynamic link library.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

void*   CModule::GetProcAddress (LPCSTR pszProcName)                    const

{
    void*   pfnResult;

    pfnResult = NULL;
    if (_hModule != NULL)
    {
        pfnResult = ::GetProcAddress(_hModule, pszProcName);
    }
    return(pfnResult);
}

//  --------------------------------------------------------------------------
//  CFile::CFile
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CFile object.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CFile::CFile (void) :
    _hFile(NULL)

{
}

//  --------------------------------------------------------------------------
//  CFile::~CFile
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the CFile object.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

CFile::~CFile (void)

{
    ReleaseHandle(_hFile);
}

//  --------------------------------------------------------------------------
//  CFile::Open
//
//  Arguments:  See the platform SDK under kernel32!CreateFile.
//
//  Returns:    LONG
//
//  Purpose:    See kernel32!CreateFile.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CFile::Open (const TCHAR *pszFilepath, DWORD dwDesiredAccess, DWORD dwShareMode)

{
    LONG    errorCode;

    ASSERTMSG((_hFile == NULL) || (_hFile == INVALID_HANDLE_VALUE), "Open file HANDLE exists in CFile::GetSize");
    _hFile = CreateFile(pszFilepath, dwDesiredAccess, dwShareMode, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (_hFile != INVALID_HANDLE_VALUE)
    {
        errorCode = ERROR_SUCCESS;
    }
    else
    {
        errorCode = GetLastError();
    }
    return(errorCode);
}

//  --------------------------------------------------------------------------
//  CFile::GetSize
//
//  Arguments:  See the platform SDK under kernel32!GetFileSize.
//
//  Returns:    LONG
//
//  Purpose:    See kernel32!GetFileSize.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CFile::GetSize (DWORD& dwLowSize, DWORD *pdwHighSize)       const

{
    LONG    errorCode;

    ASSERTMSG((_hFile != NULL) && (_hFile != INVALID_HANDLE_VALUE), "No open file HANDLE in CFile::GetSize");
    dwLowSize = GetFileSize(_hFile, pdwHighSize);
    if (dwLowSize != static_cast<DWORD>(-1))
    {
        errorCode = ERROR_SUCCESS;
    }
    else
    {
        errorCode = GetLastError();
    }
    return(errorCode);
}

//  --------------------------------------------------------------------------
//  CFile::Read
//
//  Arguments:  See the platform SDK under kernel32!ReadFile.
//
//  Returns:    LONG
//
//  Purpose:    See kernel32!ReadFile.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CFile::Read (void *pvBuffer, DWORD dwBytesToRead, DWORD *pdwBytesRead)   const

{
    LONG    errorCode;

    ASSERTMSG((_hFile != NULL) && (_hFile != INVALID_HANDLE_VALUE), "No open file HANDLE in CFile::GetSize");
    if (ReadFile(_hFile, pvBuffer, dwBytesToRead, pdwBytesRead, NULL) != FALSE)
    {
        errorCode = ERROR_SUCCESS;
    }
    else
    {
        errorCode = GetLastError();
    }
    return(errorCode);
}

//  --------------------------------------------------------------------------
//  CDesktop::CDesktop
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CDesktop. Saves the current thread's desktop.
//
//  History:    2001-02-06  vtan        created
//  --------------------------------------------------------------------------

CDesktop::CDesktop (void) :
    _hDeskCurrent(GetThreadDesktop(GetCurrentThreadId())),
    _hDesk(NULL)

{
}

//  --------------------------------------------------------------------------
//  CDesktop::~CDesktop
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CDesktop. Restores the thread's desktop to
//              its previous state prior to the object's scope.
//
//  History:    2001-02-06  vtan        created
//  --------------------------------------------------------------------------

CDesktop::~CDesktop (void)

{
    TBOOL(SetThreadDesktop(_hDeskCurrent));
    if (_hDesk != NULL)
    {
        TBOOL(CloseDesktop(_hDesk));
        _hDesk = NULL;
    }
    _hDeskCurrent = NULL;
}

//  --------------------------------------------------------------------------
//  CDesktop::Set
//
//  Arguments:  pszName     =   Name of desktop to set the thread to.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Opens the named desktop with MAXIMUM_ALLOWED access and sets
//              the current thread's desktop to it.
//
//  History:    2001-02-06  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDesktop::Set (const TCHAR *pszName)

{
    NTSTATUS    status;

    _hDesk = OpenDesktop(pszName, 0, FALSE, MAXIMUM_ALLOWED);
    if (_hDesk != NULL)
    {
        status = Set();
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CDesktop::SetInput
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Opens the input desktop and sets the current thread's desktop
//              to it.
//
//  History:    2001-02-06  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDesktop::SetInput (void)

{
    NTSTATUS    status;

    _hDesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (_hDesk != NULL)
    {
        status = Set();
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CDesktop::Set
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Sets the thread's desktop to the given HDESK.
//
//  History:    2001-02-06  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDesktop::Set (void)

{
    NTSTATUS    status;

    if (SetThreadDesktop(_hDesk) != FALSE)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\kernelresources.h ===
//  --------------------------------------------------------------------------
//  Module Name: KernelResources.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  General class definitions that assist in resource management. These are
//  typically stack based objects where constructors initialize to a known
//  state. Member functions operate on that resource. Destructors release
//  resources when the object goes out of scope.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _KernelResources_
#define     _KernelResources_

//  --------------------------------------------------------------------------
//  CHandle
//
//  Purpose:    This class manages any generic HANDLE to an object.
//
//  History:    1999-08-18  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CHandle
{
    private:
                                CHandle (void);
                                CHandle (const CHandle& copyObject);
        bool                    operator == (const CHandle& compareObject)  const;
        const CHandle&          operator = (const CHandle& assignObject);
    public:
                                CHandle (HANDLE handle);
                                ~CHandle (void);

                                operator HANDLE (void)                      const;
    private:
        HANDLE                  _handle;
};

//  --------------------------------------------------------------------------
//  CEvent
//
//  Purpose:    This class manages a named or un-named event object. Using
//              the default constructor will not create an event.
//
//  History:    1999-08-18  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CEvent
{
    private:
        bool                    operator == (const CEvent& compareObject)           const;
    public:
                                CEvent (void);
                                CEvent (const CEvent& copyObject);
                                CEvent (const TCHAR *pszName);
                                ~CEvent (void);

        const CEvent&           operator = (const CEvent& assignObject);
                                operator HANDLE (void)                              const;

        NTSTATUS                Open (const TCHAR *pszName, DWORD dwAccess);
        NTSTATUS                Create (const TCHAR *pszName = NULL);
        NTSTATUS                Set (void)                                          const;
        NTSTATUS                Reset (void)                                        const;
        NTSTATUS                Pulse (void)                                        const;
        NTSTATUS                Wait (DWORD dwMilliseconds, DWORD *pdwWaitResult)   const;
        NTSTATUS                WaitWithMessages (DWORD dwMilliseconds, DWORD *pdwWaitResult)   const;
        bool                    IsSignaled (void)                                   const;
    private:
        NTSTATUS                Close (void);
    private:
        HANDLE                  _hEvent;
};

//  --------------------------------------------------------------------------
//  CJob
//
//  Purpose:    This class manages a named or un-named job object. It hides
//              Win32 APIs to manipulate the state of the job object.
//
//  History:    1999-10-07  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CJob
{
    private:
                                CJob (const CJob& copyObject);
        bool                    operator == (const CJob& compareObject)             const;
        const CJob&             operator = (const CJob& assignObject);
    public:
                                CJob (const TCHAR *pszName = NULL);
                                ~CJob (void);

        NTSTATUS                AddProcess (HANDLE hProcess)                        const;
        NTSTATUS                SetCompletionPort (HANDLE hCompletionPort)          const;
        NTSTATUS                SetActiveProcessLimit (DWORD dwActiveProcessLimit)  const;
        NTSTATUS                SetPriorityClass (DWORD dwPriorityClass)            const;
        NTSTATUS                RestrictAccessUIAll (void)                          const;
    private:
        HANDLE                  _hJob;
};

//  --------------------------------------------------------------------------
//  CMutex
//
//  Purpose:    This class implements a mutex object management. It's not a
//              static class but each class that uses this class should
//              declare the member variable as static as only one mutex is
//              required to protect a shared resource.
//
//  History:    1999-10-13  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CMutex
{
    public:
        NTSTATUS                Initialize (const TCHAR *pszMutexName);
        NTSTATUS                Terminate (void);

        void                    Acquire (void);
        void                    Release (void);
    private:
        HANDLE                  _hMutex;
};

//  --------------------------------------------------------------------------
//  CCriticalSection
//
//  Purpose:    This class implements a critical section object management.
//
//  History:    1999-11-06  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CCriticalSection
{
    public:
                                CCriticalSection (void);
                                ~CCriticalSection (void);

        void                    Acquire (void);
        void                    Release (void);
        NTSTATUS                Status (void)   const;
        bool                    IsOwned (void)  const;
    private:
        NTSTATUS                _status;
        CRITICAL_SECTION        _criticalSection;
};

//  --------------------------------------------------------------------------
//  CModule
//
//  Purpose:    This class manages a loading an unloading of a dynamic link
//              library. The scope of the object determines how long the
//              library remains loaded.
//
//  History:    1999-08-18  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CModule
{
    private:
                                CModule (void);
                                CModule (const CModule& copyObject);
        bool                    operator == (const CModule& compareObject)  const;
        const CModule&          operator = (const CModule& assignObject);
    public:
                                CModule (const TCHAR *pszModuleName);
                                ~CModule (void);

                                operator HMODULE (void)                     const;

        void*                   GetProcAddress (LPCSTR pszProcName)         const;
    private:
        HMODULE                 _hModule;
};

//  --------------------------------------------------------------------------
//  CFile
//
//  Purpose:    This class manages a HANDLE to a file object. It is specific
//              for files and should not be abused.
//
//  History:    1999-08-18  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CFile
{
    private:
                                CFile (const CFile& copyObject);
        bool                    operator == (const CFile& compareObject)                                    const;
        const CFile&            operator = (const CFile& assignObject);
    public:
                                CFile (void);
                                ~CFile (void);

        LONG                    Open (const TCHAR *pszFilepath, DWORD dwDesiredAccess, DWORD dwShareMode);
        LONG                    GetSize (DWORD& dwLowSize, DWORD *pdwHighSize)                              const;
        LONG                    Read (void *pvBuffer, DWORD dwBytesToRead, DWORD *pdwBytesRead)             const;
    private:
        HANDLE                  _hFile;
};

//  --------------------------------------------------------------------------
//  CDesktop
//
//  Purpose:    This class manages an HDESK object.
//
//  History:    2001-02-06  vtan        created
//  --------------------------------------------------------------------------

class   CDesktop
{
    public:
                                CDesktop (void);
                                ~CDesktop (void);

        NTSTATUS                Set (const TCHAR *pszName);
        NTSTATUS                SetInput (void);
    private:
        NTSTATUS                Set (void);
    private:
        HDESK                   _hDeskCurrent;
        HDESK                   _hDesk;
};

#endif  /*  _KernelResources_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\singlethreadedexecution.h ===
//  --------------------------------------------------------------------------
//  Module Name: SingleThreadedExecution.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Classes that handle state preservation, changing and restoration.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _SingleThreadedExecution_
#define     _SingleThreadedExecution_

#include "KernelResources.h"

//  --------------------------------------------------------------------------
//  CSingleThreadedExecution
//
//  Purpose:    This class acquires the given critical section object in its
//              constructor and releases it in its destructor. Keep code
//              executed with the scope of this object to a minimum to avoid
//              impacting performance.
//
//  History:    1999-11-06  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CSingleThreadedExecution
{
    private:
                                            CSingleThreadedExecution (void);
        const CSingleThreadedExecution&     operator = (const CSingleThreadedExecution& assignObject);
    public:
                                            CSingleThreadedExecution (CCriticalSection& criticalSection);
                                            ~CSingleThreadedExecution (void);
    private:
        CCriticalSection&                   _criticalSection;
};

//  --------------------------------------------------------------------------
//  CSingleThreadedMutexExecution
//
//  Purpose:    This class acquires the given CMutex object in its constructor
//              and releases it in its destructor. Keep code executed with
//              the scope of this object to a minimum to avoid impacting
//              performance.
//
//  History:    1999-10-13  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CSingleThreadedMutexExecution
{
    private:
                                                CSingleThreadedMutexExecution (void);
        const CSingleThreadedMutexExecution&    operator = (const CSingleThreadedMutexExecution& assignObject);
    public:
                                                CSingleThreadedMutexExecution (CMutex& mutex);
                                                ~CSingleThreadedMutexExecution (void);
    private:
        CMutex&                                 _hMutex;
};

#endif  /*  _SingleThreadedExecution_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\singlethreadedexecution.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: SingleThreadedExecution.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Classes that handle state preservation, changing and restoration.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "SingleThreadedExecution.h"

//  --------------------------------------------------------------------------
//  CSingleThreadedExecution::CSingleThreadedExecution
//
//  Arguments:  criticalSection   =   CCriticalSection object containing the
//                                    critical section controlling the block
//                                    of single threaded execution.
//
//  Returns:    <none>
//
//  Purpose:    Acquires the given CriticalSection.
//
//  History:    1999-11-06  vtan        created
//  --------------------------------------------------------------------------

CSingleThreadedExecution::CSingleThreadedExecution (CCriticalSection& criticalSection) :
    _criticalSection(criticalSection)

{
    criticalSection.Acquire();
}

//  --------------------------------------------------------------------------
//  CSingleThreadedExecution::~CSingleThreadedExecution
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases the single threaded execution critical section.
//
//  History:    1999-11-06  vtan        created
//  --------------------------------------------------------------------------

CSingleThreadedExecution::~CSingleThreadedExecution (void)

{
    _criticalSection.Release();
}

//  --------------------------------------------------------------------------
//  CSingleThreadedMutexExecution::CSingleThreadedMutexExecution
//
//  Arguments:  mutex   =   CMutex object containing the mutex controlling
//                          the block of single threaded execution.
//
//  Returns:    <none>
//
//  Purpose:    Acquires the given mutex.
//
//  History:    1999-10-13  vtan        created
//  --------------------------------------------------------------------------

CSingleThreadedMutexExecution::CSingleThreadedMutexExecution (CMutex& mutex) :
    _hMutex(mutex)

{
    mutex.Acquire();
}

//  --------------------------------------------------------------------------
//  CSingleThreadedMutexExecution::~CSingleThreadedMutexExecution
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases the single threaded execution mutex.
//
//  History:    1999-10-13  vtan        created
//  --------------------------------------------------------------------------

CSingleThreadedMutexExecution::~CSingleThreadedMutexExecution (void)

{
    _hMutex.Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\standarddebug.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: StandardDebug.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  This file defines standard debug helper functions for winlogon/GINA
//  projects for neptune.
//
//  History:    1999-09-10  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"

#include <stdio.h>

#ifdef      DBG

//  --------------------------------------------------------------------------
//  gLastResult
//
//  Purpose:    Temporary global that stores the last result.
//  --------------------------------------------------------------------------

LONG    gLastResult     =   ERROR_SUCCESS;

//  --------------------------------------------------------------------------
//  CDebug::sHasUserModeDebugger
//  CDebug::sHasKernelModeDebugger
//
//  Purpose:    Booleans that indicate debugger status on this machine for
//              Winlogon. ntdll!DebugBreak should only be invoked if either
//              debugger is present (ntsd piped to kd).
//  --------------------------------------------------------------------------

bool    CDebug::s_fHasUserModeDebugger      =   false;
bool    CDebug::s_fHasKernelModeDebugger    =   false;

//  --------------------------------------------------------------------------
//  CDebug::AttachUserModeDebugger
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Attaches a user mode debugger to the current process. Useful
//              if you can't start the process under a debugger but still
//              want to be able to debug the process.
//
//  History:    2000-11-04  vtan        created
//  --------------------------------------------------------------------------

void    CDebug::AttachUserModeDebugger (void)

{
    HANDLE                  hEvent;
    STARTUPINFO             startupInfo;
    PROCESS_INFORMATION     processInformation;
    SECURITY_ATTRIBUTES     sa;
    TCHAR                   szCommandLine[MAX_PATH];

    ZeroMemory(&startupInfo, sizeof(startupInfo));
    ZeroMemory(&processInformation, sizeof(processInformation));
    startupInfo.cb = sizeof(startupInfo);
    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;
    hEvent = CreateEvent(&sa, TRUE, FALSE, NULL);
    wsprintf(szCommandLine, TEXT("ntsd -dgGx -p %ld -e %ld"), GetCurrentProcessId(), hEvent);
    if (CreateProcess(NULL,
                      szCommandLine,
                      NULL,
                      NULL,
                      TRUE,
                      0,
                      NULL,
                      NULL,
                      &startupInfo,
                      &processInformation) != FALSE)
    {
        TBOOL(CloseHandle(processInformation.hThread));
        TBOOL(CloseHandle(processInformation.hProcess));
        (DWORD)WaitForSingleObject(hEvent, 10 * 1000);
    }
    TBOOL(CloseHandle(hEvent));
}

//  --------------------------------------------------------------------------
//  CDebug::Break
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Breaks into the debugger if the hosting process has been
//              started with a debugger and kernel debugger is present.
//
//  History:    2000-09-11  vtan        created
//  --------------------------------------------------------------------------

void    CDebug::Break (void)

{
    if (s_fHasUserModeDebugger || s_fHasKernelModeDebugger)
    {
        DebugBreak();
    }
}

//  --------------------------------------------------------------------------
//  CDebug::BreakIfRequested
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    If breakins are requested then breaks into the debugger if
//              present.
//
//              This function explicitly uses Win32 Registry APIs to avoid
//              link dependencies on debug code with library code.
//
//  History:    1999-09-13  vtan        created
//              1999-11-16  vtan        removed library code dependency
//              2001-02-21  vtan        breaks have teeth
//  --------------------------------------------------------------------------

void    CDebug::BreakIfRequested (void)

{
#if     0
    Break();
#else
    HKEY    hKeySettings;

    //  Keep retrieving this value form the registry so that it
    //  can be altered without restarting the machine.

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                                      0,
                                      KEY_READ,
                                      &hKeySettings))
    {
        DWORD   dwBreakFlags, dwBreakFlagsSize;

        dwBreakFlagsSize = sizeof(dwBreakFlags);
        if ((ERROR_SUCCESS == RegQueryValueEx(hKeySettings,
                                             TEXT("BreakFlags"),
                                             NULL,
                                             NULL,
                                             reinterpret_cast<LPBYTE>(&dwBreakFlags),
                                             &dwBreakFlagsSize)) &&
            ((dwBreakFlags & FLAG_BREAK_ON_ERROR) != 0))
        {
            Break();
        }
        TW32(RegCloseKey(hKeySettings));
    }
#endif
}

//  --------------------------------------------------------------------------
//  CDebug::DisplayStandardPrefix
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Displays the standard prefix before any debug spew to help
//              identify the source.
//
//  History:    1999-10-14  vtan        created
//  --------------------------------------------------------------------------

void    CDebug::DisplayStandardPrefix (void)

{
    TCHAR   szModuleName[MAX_PATH];

    if (GetModuleFileName(NULL, szModuleName, ARRAYSIZE(szModuleName)) != 0)
    {
        TCHAR   *pTC;

        pTC = szModuleName + lstrlen(szModuleName) - 1;
        while ((pTC >= szModuleName) && (*pTC != TEXT('\\')))
        {
            --pTC;
        }
        if (*pTC == TEXT('\\'))
        {
            ++pTC;
        }
        OutputDebugString(pTC);
    }
    else
    {
        OutputDebugString(TEXT("UNKNOWN IMAGE"));
    }
    OutputDebugStringA(": ");
}

//  --------------------------------------------------------------------------
//  CDebug::DisplayError
//
//  Arguments:  eType           =   Type of error that occurred. This
//                                  determines what string is used.
//              code            =   Error code that occurred or zero if N/A.
//              pszFunction     =   Function that was invoked.
//              pszSource       =   Source file error occurred in.
//              iLine           =   Line number within the source file.
//
//  Returns:    <none>
//
//  Purpose:    Displays an error message specific the type of error that
//              occurred.
//
//  History:    1999-09-13  vtan        created
//  --------------------------------------------------------------------------

void    CDebug::DisplayError (TRACE_ERROR_TYPE eType, LONG code, const char *pszFunction, const char *pszSource, int iLine)

{
    LONG    lastError;
    char    szOutput[1024];

    switch (eType)
    {
        case TRACE_ERROR_TYPE_WIN32:
        {
            lastError = code;
            sprintf(szOutput, "Unexpected Win32 (%d) for %s in %s at line %d\r\n", lastError, pszFunction, pszSource, iLine);
            break;
        }
        case TRACE_ERROR_TYPE_BOOL:
        {
            lastError = GetLastError();
            sprintf(szOutput, "Unexpected BOOL (GLE=%d) for %s in %s at line %d\r\n", lastError, pszFunction, pszSource, iLine);
            break;
        }
        case TRACE_ERROR_TYPE_HRESULT:
        {
            lastError = GetLastError();
            sprintf(szOutput, "Unexpected HRESULT (%08x:GLE=%d) for %s in %s at line %d\r\n", code, lastError, pszFunction, pszSource, iLine);
            break;
        }
        case TRACE_ERROR_TYPE_NTSTATUS:
        {
            const char  *pszType;

            if (NT_ERROR(code))
            {
                pszType = "NT_ERROR";
            }
            else if (NT_WARNING(code))
            {
                pszType = "NT_WARNING";
            }
            else if (NT_INFORMATION(code))
            {
                pszType = "NT_INFORMATION";
            }
            else
            {
                pszType = "UNKNOWN";
            }
            sprintf(szOutput, "%s (%08x) for %s in %s at line %d\r\n", pszType, code, pszFunction, pszSource, iLine);
            break;
        }
        default:
        {
            lstrcpyA(szOutput, "\r\n");
        }
    }
    DisplayStandardPrefix();
    OutputDebugStringA(szOutput);
    BreakIfRequested();
}

//  --------------------------------------------------------------------------
//  CDebug::DisplayMessage
//
//  Arguments:  pszMessage  =   Message to display.
//
//  Returns:    <none>
//
//  Purpose:    Displays the message - no break.
//
//  History:    2000-12-05  vtan        created
//  --------------------------------------------------------------------------

void    CDebug::DisplayMessage (const char *pszMessage)

{
    DisplayStandardPrefix();
    OutputDebugStringA(pszMessage);
    OutputDebugStringA("\r\n");
}

//  --------------------------------------------------------------------------
//  CDebug::DisplayAssert
//
//  Arguments:  pszMessage      =   Message to display in assertion failure.
//              fForceBreak     =   Forces break into debugger if present.
//
//  Returns:    <none>
//
//  Purpose:    Displays the assertion failure message and breaks into the
//              debugger if requested.
//
//  History:    1999-09-13  vtan        created
//              2000-09-11  vtan        add force break
//  --------------------------------------------------------------------------

void    CDebug::DisplayAssert (const char *pszMessage, bool fForceBreak)

{
    DisplayMessage(pszMessage);
    if (fForceBreak)
    {
        Break();
    }
    else
    {
        BreakIfRequested();
    }
}

//  --------------------------------------------------------------------------
//  CDebug::DisplayWarning
//
//  Arguments:  pszMessage  =   Message to display as a warning.
//
//  Returns:    <none>
//
//  Purpose:    Displays the warning message.
//
//  History:    1999-09-13  vtan        created
//  --------------------------------------------------------------------------

void    CDebug::DisplayWarning (const char *pszMessage)

{
    DisplayStandardPrefix();
    OutputDebugStringA("WARNING: ");
    OutputDebugStringA(pszMessage);
    OutputDebugStringA("\r\n");
}

//  --------------------------------------------------------------------------
//  CDebug::DisplayDACL
//
//  Arguments:  hObject         =   HANDLE to object to display DACL of.
//              seObjectType    =   Object type.
//
//  Returns:    <none>
//
//  Purpose:    Displays the discretionary access control list of the object
//              using the kernel debugger.
//
//  History:    1999-10-15  vtan        created
//  --------------------------------------------------------------------------

void    CDebug::DisplayDACL (HANDLE hObject, SE_OBJECT_TYPE seObjectType)

{
    PACL                    pDACL;
    PSECURITY_DESCRIPTOR    pSD;

    DisplayStandardPrefix();
    OutputDebugStringA("Display DACL\r\n");
    pSD = NULL;
    pDACL = NULL;
    if (ERROR_SUCCESS == GetSecurityInfo(hObject,
                                         seObjectType,
                                         DACL_SECURITY_INFORMATION,
                                         NULL,
                                         NULL,
                                         &pDACL,
                                         NULL,
                                         &pSD))
    {
        int             i, iLimit;
        unsigned char   *pUC;

        pUC = reinterpret_cast<unsigned char*>(pDACL + 1);
        iLimit = pDACL->AceCount;
        for (i = 0; i < iLimit; ++i)
        {
            ACE_HEADER      *pAceHeader;
            char            aszString[256];

            wsprintfA(aszString, "ACE #%d/%d:\r\n", i + 1, iLimit);
            OutputDebugStringA(aszString);
            pAceHeader = reinterpret_cast<ACE_HEADER*>(pUC);
            switch (pAceHeader->AceType)
            {
                case ACCESS_ALLOWED_ACE_TYPE:
                {
                    ACCESS_ALLOWED_ACE  *pAce;

                    OutputDebugStringA("\tAccess ALLOWED ACE");
                    pAce = reinterpret_cast<ACCESS_ALLOWED_ACE*>(pAceHeader);
                    OutputDebugStringA("\t\tSID = ");
                    DisplaySID(reinterpret_cast<PSID>(&pAce->SidStart));
                    wsprintfA(aszString, "\t\tMask = %08x\r\n", pAce->Mask);
                    OutputDebugStringA(aszString);
                    wsprintfA(aszString, "\t\tFlags = %08x\r\n", pAce->Header.AceFlags);
                    OutputDebugStringA(aszString);
                    break;
                }
                case ACCESS_DENIED_ACE_TYPE:
                {
                    ACCESS_DENIED_ACE   *pAce;

                    OutputDebugStringA("\tAccess DENIED ACE");
                    pAce = reinterpret_cast<ACCESS_DENIED_ACE*>(pAceHeader);
                    OutputDebugStringA("\t\tSID = ");
                    DisplaySID(reinterpret_cast<PSID>(&pAce->SidStart));
                    wsprintfA(aszString, "\t\tMask = %08x\r\n", pAce->Mask);
                    OutputDebugStringA(aszString);
                    wsprintfA(aszString, "\t\tFlags = %08x\r\n", pAce->Header.AceFlags);
                    OutputDebugStringA(aszString);
                    break;
                }
                default:
                    OutputDebugStringA("\tOther ACE type\r\n");
                    break;
            }
            pUC += pAceHeader->AceSize;
        }
        ReleaseMemory(pSD);
    }
}

//  --------------------------------------------------------------------------
//  CDebug::StaticInitialize
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Establishes the presence of the kernel debugger or if the
//              current process is being debugged.
//
//  History:    1999-09-13  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDebug::StaticInitialize (void)

{
    NTSTATUS                            status;
    HANDLE                              hDebugPort;
    SYSTEM_KERNEL_DEBUGGER_INFORMATION  kdInfo;

    status = NtQuerySystemInformation(SystemKernelDebuggerInformation, &kdInfo, sizeof(kdInfo), NULL);
    if (NT_SUCCESS(status))
    {
        s_fHasKernelModeDebugger = (kdInfo.KernelDebuggerEnabled != FALSE);
        status = NtQueryInformationProcess(NtCurrentProcess(), ProcessDebugPort, reinterpret_cast<PVOID>(&hDebugPort), sizeof(hDebugPort), NULL);
        if (NT_SUCCESS(status))
        {
            s_fHasUserModeDebugger = (hDebugPort != NULL);
        }
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CDebug::StaticTerminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Does nothing but should clean up allocated resources.
//
//  History:    1999-09-13  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CDebug::StaticTerminate (void)

{
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CDebug::DisplaySID
//
//  Arguments:  pSID    =   SID to display as a string.
//
//  Returns:    <none>
//
//  Purpose:    Converts the given SID to a string and displays it.
//
//  History:    1999-10-15  vtan        created
//  --------------------------------------------------------------------------

void    CDebug::DisplaySID (PSID pSID)

{
    UNICODE_STRING  sidString;

    RtlInitUnicodeString(&sidString, NULL);
    TSTATUS(RtlConvertSidToUnicodeString(&sidString, pSID, TRUE));
    sidString.Buffer[sidString.Length / sizeof(WCHAR)] = L'\0';
    OutputDebugStringW(sidString.Buffer);
    OutputDebugStringA("\r\n");
    RtlFreeUnicodeString(&sidString);
}

#endif  /*  DBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\statuscode.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: StatusCode.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class that implements translation of Win32 error code to NTSTATUS and
//  the reverse.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "StatusCode.h"

//  --------------------------------------------------------------------------
//  CStatusCode::ErrorCodeOfStatusCode
//
//  Arguments:  errorCode
//
//  Returns:    NTSTATUS
//
//  Purpose:    Converts NTSTATUS status code to Win32 error code.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

LONG    CStatusCode::ErrorCodeOfStatusCode (NTSTATUS statusCode)

{
    return(RtlNtStatusToDosError(statusCode));
}

//  --------------------------------------------------------------------------
//  CStatusCode::StatusCodeOfErrorCode
//
//  Arguments:  errorCode
//
//  Returns:    NTSTATUS
//
//  Purpose:    Converts Win32 error code to NTSTATUS status code.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CStatusCode::StatusCodeOfErrorCode (LONG errorCode)

{
    NTSTATUS    status;

    if (errorCode != ERROR_SUCCESS)
    {
        status = MAKE_SCODE(STATUS_SEVERITY_ERROR, FACILITY_WIN32, errorCode);
    }
    else
    {
        status = STATUS_SUCCESS;
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CStatusCode::StatusCodeOfLastError
//
//  Arguments:  errorCode
//
//  Returns:    NTSTATUS
//
//  Purpose:    Converts last Win32 error code to NTSTATUS status code.
//
//  History:    1999-08-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CStatusCode::StatusCodeOfLastError (void)

{
    return(StatusCodeOfErrorCode(GetLastError()));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\standardheader.h ===
//  --------------------------------------------------------------------------
//  Module Name: StandardHeader.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  This file defines standard includes for the consumer Windows additions
//  to Windows 2000 msgina.
//
//  History:    1999-08-18  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _StandardHeader_
#define     _StandardHeader_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <lmsname.h>

#include <windows.h>
#include <winbasep.h>
#include <winuserp.h>

#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <aclapi.h>

#include <limits.h>

#include "StandardDebug.h"

static  const   int     kMaximumValueDataLength     =       1024;

#ifndef ARRAYSIZE
    #define ARRAYSIZE(x)                    (sizeof(x) / sizeof(x[0]))
#endif

#define ReleaseMemory(x)                ReleaseMemoryWorker(reinterpret_cast<void**>(&x))
#define ReleasePassword(x)              ReleasePasswordWorker(reinterpret_cast<void**>(&x))
#define ReleaseGDIObject(x)             ReleaseGDIObjectWorker(reinterpret_cast<void**>(&x))

static  inline  void    ReleaseMemoryWorker (HLOCAL *memory)

{
    if (*memory != NULL)
    {
        (HLOCAL)LocalFree(*memory);
        *memory = NULL;
    }
}

static  inline  void    ReleasePasswordWorker (HLOCAL *memory)

{
    if (*memory != NULL)
    {
        ZeroMemory(*memory, lstrlenW(reinterpret_cast<WCHAR*>(*memory)) + sizeof(L'\0'));
        (HLOCAL)LocalFree(*memory);
        *memory = NULL;
    }
}

static  inline  void    ReleaseGDIObjectWorker (HGDIOBJ *hGDIObject)

{
    if (*hGDIObject != NULL)
    {
        TBOOL(DeleteObject(*hGDIObject));
        *hGDIObject = NULL;
    }
}

static  inline  void    ReleaseHandle (HANDLE& handle)

{
    if (handle != NULL)
    {
        TBOOL(CloseHandle(handle));
        handle = NULL;
    }
}

static  inline  void    ReleaseHWND (HWND& hwnd)

{
    if (hwnd != NULL)
    {
        TBOOL(DestroyWindow(hwnd));
        hwnd = NULL;
    }
}

#endif  /*  _StandardHeader_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\statuscode.h ===
//  --------------------------------------------------------------------------
//  Module Name: StatusCode.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class that implements translation of Win32 error code to NTSTATUS and
//  the reverse.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _StatusCode_
#define     _StatusCode_

//  --------------------------------------------------------------------------
//  CStatusCode
//
//  Purpose:    This class manages a conversion from standard Win32 error
//              codes to NTSTATUS codes. NTSTATUS codes are widely used by
//              Windows NT in the core NT functions.
//
//  History:    1999-08-18  vtan        created
//              1999-11-24  vtan        added ErrorCodeOfStatusCode
//  --------------------------------------------------------------------------

class   CStatusCode
{
    public:
        static  LONG            ErrorCodeOfStatusCode (NTSTATUS statusCode);
        static  NTSTATUS        StatusCodeOfErrorCode (LONG errorCode);
        static  NTSTATUS        StatusCodeOfLastError (void);
};

#endif  /*  _StatusCode_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\standarddebug.h ===
//  --------------------------------------------------------------------------
//  Module Name: StandardDebug.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  This file defines standard debug macros for the consumer Windows additions
//  to Windows 2000 msgina.
//
//  History:    1999-08-18  vtan        created
//              1999-09-10  vtan        reworked macros
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _StandardDebug_
#define     _StandardDebug_

#ifdef      DBG

    typedef enum
    {
        TRACE_ERROR_TYPE_WIN32      =   1,
        TRACE_ERROR_TYPE_BOOL,
        TRACE_ERROR_TYPE_HRESULT,
        TRACE_ERROR_TYPE_NTSTATUS
    } TRACE_ERROR_TYPE;

    static  const int   FLAG_BREAK_ON_ERROR         =   0x00000001;

    extern  LONG    gLastResult;

    class   CDebug
    {
        public:
            static  void        AttachUserModeDebugger (void);
            static  void        Break (void);
            static  void        BreakIfRequested (void);
            static  void        DisplayStandardPrefix (void);
            static  void        DisplayError (TRACE_ERROR_TYPE eType, LONG code, const char *pszFunction, const char *pszSource, int iLine);
            static  void        DisplayMessage (const char *pszMessage);
            static  void        DisplayAssert (const char *pszMessage, bool fForceBreak = false);
            static  void        DisplayWarning (const char *pszMessage);
            static  void        DisplayDACL (HANDLE hObject, SE_OBJECT_TYPE seObjectType);

            static  NTSTATUS    StaticInitialize (void);
            static  NTSTATUS    StaticTerminate (void);
        private:
            static  void        DisplaySID (PSID pSID);
        private:
            static  bool        s_fHasUserModeDebugger,
                                s_fHasKernelModeDebugger;
    };

    #undef  ASSERTMSG
    #define ASSERTMSG(condition, message)               \
            if (!(condition))                           \
            {                                           \
                CDebug::DisplayAssert(message);         \
            }

    #define ASSERTBREAKMSG(condition, message)          \
            if (!(condition))                           \
            {                                           \
                CDebug::DisplayAssert(message, true);   \
            }

    #define DISPLAYMSG(message)                         \
            {                                           \
                CDebug::DisplayAssert(message);         \
            }

    #define WARNINGMSG(message)                         \
            {                                           \
                CDebug::DisplayWarning(message);        \
            }
    #define INFORMATIONMSG(message)                     \
            {                                           \
                CDebug::DisplayMessage(message);        \
            }

    #define TW32(result)                                                                                    \
            if (ERROR_SUCCESS != (gLastResult = result))                                                    \
            {                                                                                               \
                CDebug::DisplayError(TRACE_ERROR_TYPE_WIN32, gLastResult, #result, __FILE__, __LINE__);     \
            }

    #define TBOOL(result)                                                                       \
            if (result == FALSE)                                                                \
            {                                                                                   \
                CDebug::DisplayError(TRACE_ERROR_TYPE_BOOL, 0, #result, __FILE__, __LINE__);    \
            }

    #define THR(result)                                                                                     \
            if (FAILED(gLastResult = result))                                                               \
            {                                                                                               \
                CDebug::DisplayError(TRACE_ERROR_TYPE_HRESULT, gLastResult, #result, __FILE__, __LINE__);   \
            }

    #define TSTATUS(result)                                                                                 \
            if (!NT_SUCCESS(gLastResult = result))                                                          \
            {                                                                                               \
                CDebug::DisplayError(TRACE_ERROR_TYPE_NTSTATUS, gLastResult, #result, __FILE__, __LINE__);  \
            }

    #define COMPILETIME_ASSERT(condition)   \
            switch (0) case 0: case condition:

    #define DEBUGFILLMEMORY(address,size)   \
            FillMemory(address, size, 0xA7)


    inline int _DebugExceptionFilter( LONG ecode, EXCEPTION_POINTERS* pep, LPSTR pszMsg, LONG lExceptionRet )
    {
        CHAR szBuf[512];
        
#ifdef _STRSAFE_H_INCLUDED_         
        StringCchPrintfA(szBuf, ARRAYSIZE(szBuf), 
#else _STRSAFE_H_INCLUDED_         
        wsprintfA(szBuf,  
#endif _STRSAFE_H_INCLUDED_         

        "%s\nEXCEPTION INFO: code: %08lx, record (.exr): %08lx, context (.cxr): %08lx\n", 
         pszMsg, ecode, pep->ExceptionRecord, pep->ContextRecord); 
         DISPLAYMSG(szBuf);         
        return lExceptionRet;
    }

    #define DEBUG_TRY()                               __try {
    #define DEBUG_EXCEPT(pszAssertMsg)                } __except(_DebugExceptionFilter(_exception_code(), (EXCEPTION_POINTERS*)_exception_info(), \
                                                                                       pszAssertMsg, EXCEPTION_EXECUTE_HANDLER)) {\
                                                        DebugBreak();}

#else   /*  DBG */

    

    #undef  ASSERTMSG
    #define ASSERTMSG(condition, message)
    #define ASSERTBREAKMSG(condition, message)
    #define DISPLAYMSG(message)
    #define WARNINGMSG(message)
    #define TW32(result)                    (LONG)result
    #define TBOOL(result)                   (BOOL)result
    #define THR(result)                     (HRESULT)result
    #define TSTATUS(result)                 (NTSTATUS)result
    #define DEBUGFILLMEMORY(address,size)
    #define DEBUG_TRY()                     
    #define DEBUG_EXCEPT(pszAssertMsg)      


#endif  /*  DBG */

#endif  /*  _StandardDebug_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\stringconvert.h ===
//  --------------------------------------------------------------------------
//  Module Name: StringConvert.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Utility string functions. These are probably duplicated in some form in
//  shlwapi.dll. Currently this file exists to prevent some dependencies on
//  that file.
//
//  History:    1999-08-23  vtan        created
//              1999-11-16  vtan        separate file
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _StringConvert_
#define     _StringConvert_

//  --------------------------------------------------------------------------
//  CStringConvert
//
//  Purpose:    Collection of string conversion related functions bundled
//              into the CStringConvert namespace.
//
//  History:    1999-08-23  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class    CStringConvert
{
    public:
        static  int             AnsiToUnicode (const char *pszAnsiString, WCHAR *pszUnicodeString, int iUnicodeStringCount);
        static  int             UnicodeToAnsi (const WCHAR *pszUnicodeString, char *pszAnsiString, int iAnsiStringCount);
        static  void            TCharToUnicode (const TCHAR *pszString, WCHAR *pszUnicodeString, int iUnicodeStringCount);
        static  void            UnicodeToTChar (const WCHAR *pszUnicodeString, TCHAR *pszString, int iStringCount);
        static  void            TCharToAnsi (const TCHAR *pszString, char *pszAnsiString, int iAnsiStringCount);
        static  void            AnsiToTChar (const char *pszAnsiString, TCHAR *pszString, int iStringCount);
};

#endif  /*  _StringConvert_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\stringconvert.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: StringConvert.cpp
//
//  Copyright (c) 1999, Microsoft Corporation
//
//  Utility string functions. These are probably duplicated in some form in
//  shlwapi.dll. Currently this file exists to prevent some dependencies on
//  that file.
//
//  History:    1999-08-23  vtan        created
//              1999-11-16  vtan        separate file
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "StringConvert.h"

//  --------------------------------------------------------------------------
//  CStringConvert::AnsiToUnicode
//
//  Arguments:  pszAnsiString           =   ANSI string to convert.
//              pszUnicodeString        =   UNICODE string receiving output.
//              iUnicodeStringCount     =   Character count of output string.
//
//  Returns:    int     =   See kernel32!MultiByteToWideChar.
//
//  Purpose:    Explicitly converts an ANSI string to a UNICODE string.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

int     CStringConvert::AnsiToUnicode (const char *pszAnsiString, WCHAR *pszUnicodeString, int iUnicodeStringCount)

{
    return(MultiByteToWideChar(CP_ACP, 0, pszAnsiString, -1, pszUnicodeString, iUnicodeStringCount));
}

//  --------------------------------------------------------------------------
//  CStringConvert::UnicodeToAnsi
//
//  Arguments:  pszUnicodeString        =   UNICODE string receiving output.
//              pszAnsiString           =   ANSI string to convert.
//              iAnsiStringCount        =   Character count of output string.
//
//  Returns:    int     =   See kernel32!WideCharToMultiByte.
//
//  Purpose:    Explicitly converts a UNICODE string to an ANSI string.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

int     CStringConvert::UnicodeToAnsi (const WCHAR *pszUnicodeString, char *pszAnsiString, int iAnsiStringCount)

{
    return(WideCharToMultiByte(CP_ACP, 0, pszUnicodeString, -1, pszAnsiString, iAnsiStringCount, NULL, NULL));
}

//  --------------------------------------------------------------------------
//  CStringConvert::TCharToUnicode
//
//  Arguments:  pszString               =   TCHAR string to convert.
//              pszUnicodeString        =   UNICODE string receiving output.
//              iUnicodeStringCount     =   Character count of output string.
//
//  Returns:    <none>
//
//  Purpose:    Converts a TCHAR string to a UNICODE string. The actual
//              implementation depends on whether the is being compiled
//              UNICODE or ANSI.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

void    CStringConvert::TCharToUnicode (const TCHAR *pszString, WCHAR *pszUnicodeString, int iUnicodeStringCount)

{
#ifdef  UNICODE
    (const char*)lstrcpyn(pszUnicodeString, pszString, iUnicodeStringCount);
#else
    (int)AnsiToUnicode(pszString, pszUnicodeString, iUnicodeStringCount);
#endif
}

//  --------------------------------------------------------------------------
//  CStringConvert::UnicodeToTChar
//
//  Arguments:  pszUnicodeString    =   UNICODE string to convert.
//              pszString           =   TCHAR string receiving output.
//              iStringCount        =   Character count of output string.
//
//  Returns:    <none>
//
//  Purpose:    Converts a TCHAR string to a ANSI string. The actual
//              implementation depends on whether the is being compiled
//              UNICODE or ANSI.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

void    CStringConvert::UnicodeToTChar (const WCHAR *pszUnicodeString, TCHAR *pszString, int iStringCount)

{
#ifdef  UNICODE
    (const char*)lstrcpyn(pszString, pszUnicodeString, iStringCount);
#else
    (int)UnicodeToAnsi(pszUnicodeString, pszString, iStringCount);
#endif
}

//  --------------------------------------------------------------------------
//  CStringConvert::TCharToAnsi
//
//  Arguments:  pszString           =   TCHAR string to convert.
//              pszAnsiString       =   ANSI string receiving output.
//              iAnsiStringCount    =   Character count of output string.
//
//  Returns:    <none>
//
//  Purpose:    Converts a TCHAR string to a ANSI string. The actual
//              implementation depends on whether the is being compiled
//              UNICODE or ANSI.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

void    CStringConvert::TCharToAnsi (const TCHAR *pszString, char *pszAnsiString, int iAnsiStringCount)

{
#ifdef  UNICODE
    (int)UnicodeToAnsi(pszString, pszAnsiString, iAnsiStringCount);
#else
    (const char*)lstrcpyn(pszAnsiString, pszString, iAnsiStringCount);
#endif
}

//  --------------------------------------------------------------------------
//  CStringConvert::AnsiToTChar
//
//  Arguments:  pszAnsiString   =   ANSI string to convert.
//              pszString       =   TCHAR string receiving output.
//              iStringCount    =   Character count of output string.
//
//  Returns:    <none>
//
//  Purpose:    Converts a TCHAR string to a ANSI string. The actual
//              implementation depends on whether the is being compiled
//              UNICODE or ANSI.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

void    CStringConvert::AnsiToTChar (const char *pszAnsiString, TCHAR *pszString, int iStringCount)

{
#ifdef  UNICODE
    (int)AnsiToUnicode(pszAnsiString, pszString, iStringCount);
#else
    (const char*)lstrcpyn(pszString, pszAnsiString, iStringCount);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\thread.h ===
//  --------------------------------------------------------------------------
//  Module Name: Thread.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Base class that implements thread functionality. Subclass this class and
//  implement the virtual ThreadEntry function. When you instantiate this
//  class a thread gets created which will call ThreadEntry and when that
//  function exits will call ThreadExit. These objects should be created using
//  operator new because the default implementation of ThreadExit does
//  "->Release()". You should override this function if you don't want this
//  behavior. The threads are also created SUSPENDED. You make any changes
//  that are required in the subclass' constructor. At the end of the
//  constructor or from the caller of operator new a "->Resume()" can be
//  invoked to start the thread.
//
//  History:    1999-08-24  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _Thread_
#define     _Thread_

#include "CountedObject.h"

//  --------------------------------------------------------------------------
//  CThread
//
//  Purpose:    A base class to manage threads.
//
//  History:    1999-08-24  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CThread : public CCountedObject
{
    public:
                                CThread (DWORD stackSpace = 0, DWORD createFlags = 0, HANDLE hToken = NULL);
        virtual                 ~CThread (void);

                                operator HANDLE (void)                      const;

                bool            IsCreated (void)                            const;

                void            Suspend (void)                              const;
                void            Resume (void)                               const;
                NTSTATUS        Terminate (void);

                bool            IsCompleted (void)                          const;
                DWORD           WaitForCompletion (DWORD dwMilliseconds)    const;
                DWORD           GetResult (void)                            const;

                int             GetPriority (void)                          const;
                void            SetPriority (int newPriority)               const;
    protected:
        virtual DWORD           Entry (void) = 0;
        virtual void            Exit (void);

                NTSTATUS        SetToken (HANDLE hToken);
    private:
        static  DWORD   WINAPI  ThreadEntryProc (void *pParameter);
    protected:
                HANDLE          _hThread;
                bool            _fCompleted;
};

#endif  /*  _Thread_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\thread.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: Thread.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Base class that implements thread functionality. Subclass this class and
//  implement the virtual ThreadEntry function. When you instantiate this
//  class a thread gets created which will call ThreadEntry and when that
//  function exits will call ThreadExit. These objects should be created using
//  operator new because the default implementation of ThreadExit does
//  "delete this". You should override this function if you don't want this
//  behavior. The threads are also created SUSPENDED. You make any changes
//  that are required in the subclass' constructor. At the end of the
//  constructor or from the caller of operator new a "->Resume()" can be
//  invoked to start the thread.
//
//  History:    1999-08-24  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "Thread.h"

#include "Access.h"
#include "Impersonation.h"
#include "StatusCode.h"
#include "TokenInformation.h"

//  --------------------------------------------------------------------------
//  CThread::CThread
//
//  Arguments:  stackSpace              =   Size of stack to reserve for this
//                                          thread. Default = system default.
//              createFlags             =   Additional flags designating how
//                                          the thread should be created.
//                                          Default = none.
//              hToken                  =   User token to assign to the
//                                          thread. Default = none.
//              pSecurityDescriptor     =   SecurityDescriptor to assign to
//                                          thread. Default = none.
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CThread object. Creates the thread SUSPENDED
//              with given security attributes and assigns the hToken to the
//              thread. The token need not have SecurityImpersonation as a
//              duplicate is made with this access mode.
//
//  History:    1999-08-24  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

CThread::CThread (DWORD stackSpace, DWORD createFlags, HANDLE hToken) :
    CCountedObject(),
    _hThread(NULL),
    _fCompleted(false)

{
    DWORD   dwThreadID;

    //  It is important to create the thread suspended. This constructor could
    //  get pre-empted by the system and does. If pre-empted whilst executing
    //  the constructor, the derived class is NOT fully constructed and the
    //  virtual table isn't correctly initialized.

    _hThread = CreateThread(NULL,
                            stackSpace,
                            ThreadEntryProc,
                            this,
                            createFlags | CREATE_SUSPENDED,
                            &dwThreadID);
    if (_hThread != NULL)
    {

        //  Make a call to CCountedObject::AddRef here. This reference belongs
        //  to the thread. It's necessary to do it now because the creator of
        //  this thread can release its reference before the thread even begins
        //  executing which would cause the object to be released!
        //  CThread::ThreadEntryProc will release this reference when the
        //  thread's execution is finished. The creator of this thread should
        //  release its reference when it's done with the thread which may be
        //  immediately in the case of an asynhronous operation in which the
        //  thread cleans itself up.

        AddRef();

        //  Impersonate the user token if given. Also grant access to the thread
        //  object to the user. This will allow them to query thread information.

        if (hToken != NULL)
        {
            TSTATUS(SetToken(hToken));
        }
    }
}

//  --------------------------------------------------------------------------
//  CThread::~CThread
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the CThread object on thread
//              termination.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

CThread::~CThread (void)

{
    ASSERTMSG(_fCompleted, "CThread::~CThread called before ThreadEntry() completed");
    ReleaseHandle(_hThread);
}

//  --------------------------------------------------------------------------
//  CThread::operator HANDLE
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Magically converts a CThread to a HANDLE
//
//  History:    1999-09-21  vtan        created
//  --------------------------------------------------------------------------

CThread::operator HANDLE (void)                      const

{
    return(_hThread);
}

//  --------------------------------------------------------------------------
//  CThread::IsCreated
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether a thread was created or not.
//
//  History:    2000-09-08  vtan        created
//  --------------------------------------------------------------------------

bool    CThread::IsCreated (void)                            const

{
    return(_hThread != NULL);
}

//  --------------------------------------------------------------------------
//  CThread::Suspend
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Suspends thread execution.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

void    CThread::Suspend (void)                              const

{
    if (SuspendThread(_hThread) == 0xFFFFFFFF)
    {
        DISPLAYMSG("SuspendThread failed for thread handle in CThread::Suspend");
    }
}

//  --------------------------------------------------------------------------
//  CThread::Resume
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Resumes thread execution.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

void    CThread::Resume (void)                               const

{
    if ((_hThread == NULL) || (ResumeThread(_hThread) == 0xFFFFFFFF))
    {
        DISPLAYMSG("ResumeThread failed for thread handle in CThread::Resume");
    }
}

//  --------------------------------------------------------------------------
//  CThread::Terminate
//
//  Arguments:  <none>
//
//  Returns:    NTSTATUS
//
//  Purpose:    Forcibly terminates the thread. Use this with care. It should
//              only be used in case a sub-class constructor fails and the
//              thread is suspended and hasn't even run yet.
//
//  History:    2000-10-18  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThread::Terminate (void)

{
    NTSTATUS    status;

    if (TerminateThread(_hThread, 0) != FALSE)
    {
        _fCompleted = true;
        Release();
        ReleaseHandle(_hThread);
        status = STATUS_SUCCESS;
    }
    else
    {
        status = CStatusCode::StatusCodeOfLastError();
    }
    return(status);
}

//  --------------------------------------------------------------------------
//  CThread::IsCompleted
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Determines whether the thread has completed execution. This
//              does not check the signaled state of the thread handle but
//              rather checks member variables.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

bool    CThread::IsCompleted (void)                          const

{
    DWORD   dwExitCode;

    return((GetExitCodeThread(_hThread, &dwExitCode) != FALSE) && (dwExitCode != STILL_ACTIVE));
}

//  --------------------------------------------------------------------------
//  CThread::WaitForCompletion
//
//  Arguments:  dwMilliseconds  =   Number of milliseconds to wait for
//                                  thread completion.
//
//  Returns:    DWORD
//
//  Purpose:    Waits for the thread handle to become signaled.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

DWORD   CThread::WaitForCompletion (DWORD dwMilliseconds)    const

{
    DWORD       dwWaitResult;

    do
    {

        //  When waiting for the object check to see that it's not signaled.
        //  If signaled then abandon the wait loop. Otherwise allow user32
        //  to continue processing messages for this thread.

        dwWaitResult = WaitForSingleObject(_hThread, 0);
        if (dwWaitResult != WAIT_OBJECT_0)
        {
            dwWaitResult = MsgWaitForMultipleObjects(1, &_hThread, FALSE, dwMilliseconds, QS_ALLINPUT);
            if (dwWaitResult == WAIT_OBJECT_0 + 1)
            {
                MSG     msg;

                if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) != FALSE)
                {
                    (BOOL)TranslateMessage(&msg);
                    (LRESULT)DispatchMessage(&msg);
                }
            }
        }
    } while (dwWaitResult == WAIT_OBJECT_0 + 1);
    return(dwWaitResult);
}

//  --------------------------------------------------------------------------
//  CThread::GetResult
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Gets the thread's exit code. This assumes it has completed
//              execution and returns STILL_ACTIVE if not completed.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

DWORD   CThread::GetResult (void)                            const

{
    DWORD   dwResult;

    if (GetExitCodeThread(_hThread, &dwResult) == FALSE)
    {
        dwResult = STILL_ACTIVE;
    }
    return(dwResult);
}

//  --------------------------------------------------------------------------
//  CThread::GetPriority
//
//  Arguments:  <none>
//
//  Returns:    int
//
//  Purpose:    Gets the thread's priority.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

int     CThread::GetPriority (void)                          const

{
    return(GetThreadPriority(_hThread));
}

//  --------------------------------------------------------------------------
//  CThread::SetPriority
//
//  Arguments:  newPriority     =   New priority for the thread.
//
//  Returns:    <none>
//
//  Purpose:    Sets the thread's priority.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

void    CThread::SetPriority (int newPriority)               const

{
    if (SetThreadPriority(_hThread, newPriority) == 0)
    {
        DISPLAYMSG("SetThreadPriorty failed in CThread::SetPriority");
    }
}

//  --------------------------------------------------------------------------
//  CThread::ThreadExit
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Default base class implementation of thread exit. For threads
//              whose execution is self contained and termination is not an
//              issue then this will clean up after the thread. This function
//              should be overriden if this behavior is NOT desired.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

void    CThread::Exit (void)

{
}

//  --------------------------------------------------------------------------
//  CThread::SetToken
//
//  Arguments:  hToken  =   HANDLE to the user token to assign to this thread.
//
//  Returns:    NTSTATUS
//
//  Purpose:    Sets the impersonation token associated with this thread so
//              the thread will execute in the user's context from the start.
//
//  History:    1999-09-23  vtan        created
//  --------------------------------------------------------------------------

NTSTATUS    CThread::SetToken (HANDLE hToken)

{
    PSID                pLogonSID;
    CTokenInformation   tokenInformation(hToken);

    pLogonSID = tokenInformation.GetLogonSID();
    if (pLogonSID != NULL)
    {
        CSecuredObject      threadSecurity(_hThread, SE_KERNEL_OBJECT);

        TSTATUS(threadSecurity.Allow(pLogonSID,
                                     THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION,
                                     0));
        TSTATUS(CImpersonation::ImpersonateUser(_hThread, hToken));
    }
    return(STATUS_SUCCESS);
}

//  --------------------------------------------------------------------------
//  CThread::ThreadEntryProc
//
//  Arguments:  pParameter  =   "this" object.
//
//  Returns:    DWORD
//
//  Purpose:    Entry procedure for the thread. This manages the type-casting
//              and invokation of CThread::ThreadEntry and CThread::ThreadExit
//              as well as the _fCompleted member variable.
//
//  History:    1999-08-24  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI  CThread::ThreadEntryProc (void *parameter)

{
    DWORD       dwThreadResult;
    CThread     *pThread;

    pThread = static_cast<CThread*>(parameter);
    dwThreadResult = pThread->Entry();
    pThread->_fCompleted = true;
    pThread->Exit();
    pThread->Release();
    return(dwThreadResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\ieguid\ieguidp.c ===
#include <initguid.h>

#include "ieguidp.h"
#include "msieftp_i.c"
#include "iepriv_i.c"
#include "brdispp_i.c"
#include "webvw_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\ieguid\makefile.inc ===
$(CCSHELL_DIR)\lib\$O\ieguidp.lib: $(O)\ieguidp.obj
    lib -out:$@ $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\tokeninformation.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: TokenInformation.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class to get information about either the current thread/process token or
//  a specified token.
//
//  History:    1999-10-05  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "StandardHeader.h"
#include "TokenInformation.h"

//  --------------------------------------------------------------------------
//  CTokenInformation::CTokenInformation
//
//  Arguments:  hToken  =   Optional user token to get information on.
//
//  Returns:    <none>
//
//  Purpose:    Duplicates the given token if provided. Otherwise the thread
//              token is opened or the process token if that doesn't exist.
//
//  History:    1999-10-05  vtan    created
//  --------------------------------------------------------------------------

CTokenInformation::CTokenInformation (HANDLE hToken) :
    _hToken(hToken),
    _hTokenToRelease(NULL),
    _pvGroupBuffer(NULL),
    _pvPrivilegeBuffer(NULL),
    _pvUserBuffer(NULL),
    _pszUserLogonName(NULL),
    _pszUserDisplayName(NULL)

{
    if (hToken == NULL)
    {
        if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &_hToken) == FALSE)
        {
            TBOOL(OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &_hToken));
        }
        if (_hToken != NULL)
        {
            _hTokenToRelease = _hToken;
        }
    }
}

//  --------------------------------------------------------------------------
//  CTokenInformation::~CTokenInformation
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by the object.
//
//  History:    1999-10-05  vtan    created
//  --------------------------------------------------------------------------

CTokenInformation::~CTokenInformation (void)

{
    ReleaseMemory(_pszUserLogonName);
    ReleaseMemory(_pszUserDisplayName);
    ReleaseMemory(_pvUserBuffer);
    ReleaseMemory(_pvPrivilegeBuffer);
    ReleaseMemory(_pvGroupBuffer);
    ReleaseHandle(_hTokenToRelease);
}

//  --------------------------------------------------------------------------
//  CTokenInformation::GetLogonSID
//
//  Arguments:  <none>
//
//  Returns:    PSID
//
//  Purpose:    Gets token information for the token groups. Walks the groups
//              looking for the SID with SE_GROUP_LOGON_ID and returns a
//              pointer to this SID. This memory is available for the scope
//              of the object.
//
//  History:    1999-10-05  vtan    created
//  --------------------------------------------------------------------------

PSID    CTokenInformation::GetLogonSID (void)

{
    PSID    pSID;

    pSID = NULL;
    if ((_hToken != NULL) && (_pvGroupBuffer == NULL))
    {
        GetTokenGroups();
    }
    if (_pvGroupBuffer != NULL)
    {
        ULONG           ulIndex, ulLimit;
        TOKEN_GROUPS    *pTG;

        pTG = reinterpret_cast<TOKEN_GROUPS*>(_pvGroupBuffer);
        ulLimit = pTG->GroupCount;
        for (ulIndex = 0; (pSID == NULL) && (ulIndex < ulLimit); ++ulIndex)
        {
            if ((pTG->Groups[ulIndex].Attributes & SE_GROUP_LOGON_ID) != 0)
            {
                pSID = pTG->Groups[ulIndex].Sid;
            }
        }
    }
    return(pSID);
}

//  --------------------------------------------------------------------------
//  CTokenInformation::GetUserSID
//
//  Arguments:  <none>
//
//  Returns:    PSID
//
//  Purpose:    Gets token information for the token user. This returns the
//              SID for the user of the token. This memory is available for
//              the scope of the object.
//
//  History:    1999-10-05  vtan    created
//  --------------------------------------------------------------------------

PSID    CTokenInformation::GetUserSID (void)

{
    PSID    pSID;

    if ((_pvUserBuffer == NULL) && (_hToken != NULL))
    {
        DWORD   dwReturnLength;

        dwReturnLength = 0;
        (BOOL)GetTokenInformation(_hToken, TokenUser, NULL, 0, &dwReturnLength);
        _pvUserBuffer = LocalAlloc(LMEM_FIXED, dwReturnLength);
        if ((_pvUserBuffer != NULL) &&
            (GetTokenInformation(_hToken, TokenUser, _pvUserBuffer, dwReturnLength, &dwReturnLength) == FALSE))
        {
            ReleaseMemory(_pvUserBuffer);
            _pvUserBuffer = NULL;
        }
    }
    if (_pvUserBuffer != NULL)
    {
        pSID = reinterpret_cast<TOKEN_USER*>(_pvUserBuffer)->User.Sid;
    }
    else
    {
        pSID = NULL;
    }
    return(pSID);
}

//  --------------------------------------------------------------------------
//  CTokenInformation::IsUserTheSystem
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Gets token information for the token user. This returns
//              whether the user is the local system.
//
//  History:    1999-12-13  vtan        created
//  --------------------------------------------------------------------------

bool    CTokenInformation::IsUserTheSystem (void)

{
    static  const LUID  sLUIDSystem     =   SYSTEM_LUID;

    ULONG               ulReturnLength;
    TOKEN_STATISTICS    tokenStatistics;

    return((GetTokenInformation(_hToken, TokenStatistics, &tokenStatistics, sizeof(tokenStatistics), &ulReturnLength) != FALSE) &&
           RtlEqualLuid(&tokenStatistics.AuthenticationId, &sLUIDSystem));
}

//  --------------------------------------------------------------------------
//  CTokenInformation::IsUserAnAdministrator
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Gets token information for the token user. This returns
//              whether the user is a member of the local administrator group.
//
//  History:    92-05-06    davidc  created
//              1999-11-06  vtan    stolen
//  --------------------------------------------------------------------------

bool    CTokenInformation::IsUserAnAdministrator (void)

{
    bool    fIsAnAdministrator;
    PSID    pAdministratorSID;
    static  SID_IDENTIFIER_AUTHORITY    sSystemSidAuthority     =   SECURITY_NT_AUTHORITY;

    fIsAnAdministrator = false;

    if (NT_SUCCESS(RtlAllocateAndInitializeSid(&sSystemSidAuthority,
                                               2,
                                               SECURITY_BUILTIN_DOMAIN_RID,
                                               DOMAIN_ALIAS_RID_ADMINS,
                                               0, 0, 0, 0, 0, 0,
                                               &pAdministratorSID)))
    {
        BOOL fAdmin = FALSE;

        if (CheckTokenMembership(_hToken, pAdministratorSID, &fAdmin))
        {
            fIsAnAdministrator = !!fAdmin;
        }
        (void*)RtlFreeSid(pAdministratorSID);
    }
    return(fIsAnAdministrator);
}

//  --------------------------------------------------------------------------
//  CTokenInformation::UserHasPrivilege
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Gets token information for the token user. This returns
//              whether the user is a member of the local administrator group.
//
//  History:    2000-04-26  vtan    created
//  --------------------------------------------------------------------------

bool    CTokenInformation::UserHasPrivilege (DWORD dwPrivilege)

{
    bool    fUserHasPrivilege;

    fUserHasPrivilege = false;
    if ((_hToken != NULL) && (_pvPrivilegeBuffer == NULL))
    {
        GetTokenPrivileges();
    }
    if (_pvPrivilegeBuffer != NULL)
    {
        ULONG               ulIndex, ulLimit;
        TOKEN_PRIVILEGES    *pTP;
        LUID                luidPrivilege;

        luidPrivilege.LowPart = dwPrivilege;
        luidPrivilege.HighPart = 0;
        pTP = reinterpret_cast<TOKEN_PRIVILEGES*>(_pvPrivilegeBuffer);
        ulLimit = pTP->PrivilegeCount;
        for (ulIndex = 0; !fUserHasPrivilege && (ulIndex < ulLimit); ++ulIndex)
        {
            fUserHasPrivilege = (RtlEqualLuid(&pTP->Privileges[ulIndex].Luid, &luidPrivilege) != FALSE);
        }
    }
    return(fUserHasPrivilege);
}

//  --------------------------------------------------------------------------
//  CTokenInformation::GetUserName
//
//  Arguments:  <none>
//
//  Returns:    WCHAR
//
//  Purpose:    Looks up the account name of the implicit token..
//
//  History:    2000-08-31  vtan    created
//  --------------------------------------------------------------------------

const WCHAR*    CTokenInformation::GetUserName (void)

{
    if (_pszUserLogonName == NULL)
    {
        DWORD           dwUserNameSize, dwReferencedDomainSize;
        SID_NAME_USE    eUse;
        WCHAR           *pszReferencedDomain;

        dwUserNameSize = dwReferencedDomainSize = 0;
        (BOOL)LookupAccountSid(NULL,
                               GetUserSID(),
                               NULL,
                               &dwUserNameSize,
                               NULL,
                               &dwReferencedDomainSize,
                               &eUse);
        pszReferencedDomain = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, dwReferencedDomainSize * sizeof(WCHAR)));
        if (pszReferencedDomain != NULL)
        {
            _pszUserLogonName = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, dwUserNameSize * sizeof(WCHAR)));
            if (_pszUserLogonName != NULL)
            {
                if (LookupAccountSid(NULL,
                                     GetUserSID(),
                                     _pszUserLogonName,
                                     &dwUserNameSize,
                                     pszReferencedDomain,
                                     &dwReferencedDomainSize,
                                     &eUse) == FALSE)
                {
                    ReleaseMemory(_pszUserLogonName);
                }
            }
            (HLOCAL)LocalFree(pszReferencedDomain);
        }
    }
    return(_pszUserLogonName);
}

//  --------------------------------------------------------------------------
//  CTokenInformation::GetUserDisplayName
//
//  Arguments:  <none>
//
//  Returns:    WCHAR
//
//  Purpose:    Returns the display name of the implicit token.
//
//  History:    2000-08-31  vtan    created
//  --------------------------------------------------------------------------

const WCHAR*    CTokenInformation::GetUserDisplayName (void)

{
    if (_pszUserDisplayName == NULL)
    {
        const WCHAR     *pszUserName;

        pszUserName = GetUserName();
        if (pszUserName != NULL)
        {
            USER_INFO_2     *pUserInfo;

            if (NERR_Success == NetUserGetInfo(NULL, pszUserName, 2, reinterpret_cast<LPBYTE*>(&pUserInfo)))
            {
                const WCHAR     *pszUserDisplayName;

                if (pUserInfo->usri2_full_name[0] != L'\0')
                {
                    pszUserDisplayName = pUserInfo->usri2_full_name;
                }
                else
                {
                    pszUserDisplayName = pszUserName;
                }
                _pszUserDisplayName = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, (lstrlen(pszUserDisplayName) + sizeof('\0')) * sizeof(WCHAR)));
                if (_pszUserDisplayName != NULL)
                {
                    lstrcpy(_pszUserDisplayName, pszUserDisplayName);
                }
                TW32(NetApiBufferFree(pUserInfo));
            }
        }
    }
    return(_pszUserDisplayName);
}

//  --------------------------------------------------------------------------
//  CTokenInformation::LogonUser
//
//  Arguments:  See the platform SDK under LogonUser.
//
//  Returns:    DWORD
//
//  Purpose:    Calls advapi32!LogonUserW with supplied credentials using
//              interactive logon type. Returns the error code as a DWORD
//              rather than the standard Win32 API method which allows the
//              filtering of certain error codes.
//
//  History:    2001-03-28  vtan    created
//  --------------------------------------------------------------------------

DWORD   CTokenInformation::LogonUser (const WCHAR *pszUsername, const WCHAR *pszDomain, const WCHAR *pszPassword, HANDLE *phToken)

{
    DWORD   dwErrorCode;

    if (::LogonUserW(const_cast<WCHAR*>(pszUsername),
                     const_cast<WCHAR*>(pszDomain),
                     const_cast<WCHAR*>(pszPassword),
                     LOGON32_LOGON_INTERACTIVE,
                     LOGON32_PROVIDER_DEFAULT,
                     phToken) != FALSE)
    {
        dwErrorCode = ERROR_SUCCESS;
    }
    else
    {
        *phToken = NULL;
        dwErrorCode = GetLastError();

        //  Ignore ERROR_PASSWORD_MUST_CHANGE and ERROR_PASSWORD_EXPIRED.

        if ((dwErrorCode == ERROR_PASSWORD_MUST_CHANGE) || (dwErrorCode == ERROR_PASSWORD_EXPIRED))
        {
            dwErrorCode = ERROR_SUCCESS;
        }
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CTokenInformation::IsSameUser
//
//  Arguments:  hToken1     =   Token of one user.
//              hToken2     =   Token of other user.
//
//  Returns:    bool
//
//  Purpose:    Compares the user SID of the tokens for a match.
//
//  History:    2001-03-28  vtan    created
//  --------------------------------------------------------------------------

bool    CTokenInformation::IsSameUser (HANDLE hToken1, HANDLE hToken2)

{
    PSID                pSID1;
    PSID                pSID2;
    CTokenInformation   tokenInformation1(hToken1);
    CTokenInformation   tokenInformation2(hToken2);

    pSID1 = tokenInformation1.GetUserSID();
    pSID2 = tokenInformation2.GetUserSID();
    return((pSID1 != NULL) &&
           (pSID2 != NULL) &&
           (EqualSid(pSID1, pSID2) != FALSE));
}

//  --------------------------------------------------------------------------
//  CTokenInformation::GetTokenGroups
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Gets token information for the token user. This function
//              allocates the memory for the token groups. This memory is
//              available for the scope of the object.
//
//  History:    1999-11-06  vtan    created
//  --------------------------------------------------------------------------

void    CTokenInformation::GetTokenGroups (void)

{
    DWORD   dwReturnLength;

    dwReturnLength = 0;
    (BOOL)GetTokenInformation(_hToken, TokenGroups, NULL, 0, &dwReturnLength);
    _pvGroupBuffer = LocalAlloc(LMEM_FIXED, dwReturnLength);
    if ((_pvGroupBuffer != NULL) &&
        (GetTokenInformation(_hToken, TokenGroups, _pvGroupBuffer, dwReturnLength, &dwReturnLength) == FALSE))
    {
        ReleaseMemory(_pvGroupBuffer);
        _pvGroupBuffer = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CTokenInformation::GetTokenPrivileges
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Gets token privileges for the token user. This function
//              allocates the memory for the token privileges. This memory is
//              available for the scope of the object.
//
//  History:    2000-04-26  vtan    created
//  --------------------------------------------------------------------------

void    CTokenInformation::GetTokenPrivileges (void)

{
    DWORD   dwReturnLength;

    dwReturnLength = 0;
    (BOOL)GetTokenInformation(_hToken, TokenPrivileges, NULL, 0, &dwReturnLength);
    _pvPrivilegeBuffer = LocalAlloc(LMEM_FIXED, dwReturnLength);
    if ((_pvPrivilegeBuffer != NULL) &&
        (GetTokenInformation(_hToken, TokenPrivileges, _pvPrivilegeBuffer, dwReturnLength, &dwReturnLength) == FALSE))
    {
        ReleaseMemory(_pvPrivilegeBuffer);
        _pvPrivilegeBuffer = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\secutil\makefile.inc ===
#
# Copy secutil.lib to shell\lib\$(O)
#
$(PROJECT_ROOT)\lib\$(O)\secutil.lib: $(O)\secutil.lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\generic\tokeninformation.h ===
//  --------------------------------------------------------------------------
//  Module Name: TokenInformation.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class to get information about either the current thread/process token or
//  a specified token.
//
//  History:    1999-10-05  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _TokenInformation_
#define     _TokenInformation_

//  --------------------------------------------------------------------------
//  CTokenInformation
//
//  Purpose:    This class either uses the given access token or if none is
//              given then the thread impersonation token or if that doesn't
//              exist then the process token. It duplicates the token so the
//              original must be released by the caller. It returns
//              information about the access token.
//
//  History:    1999-10-05  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

class   CTokenInformation
{
    public:
                                CTokenInformation (HANDLE hToken = NULL);
                                ~CTokenInformation (void);

                PSID            GetLogonSID (void);
                PSID            GetUserSID (void);
                bool            IsUserTheSystem (void);
                bool            IsUserAnAdministrator (void);
                bool            UserHasPrivilege (DWORD dwPrivilege);
                const WCHAR*    GetUserName (void);
                const WCHAR*    GetUserDisplayName (void);

        static  DWORD           LogonUser (const WCHAR *pszUsername, const WCHAR *pszDomain, const WCHAR *pszPassword, HANDLE *phToken);
        static  bool            IsSameUser (HANDLE hToken1, HANDLE hToken2);
    private:
                void            GetTokenGroups (void);
                void            GetTokenPrivileges (void);
    private:
                HANDLE          _hToken,
                                _hTokenToRelease;
                void            *_pvGroupBuffer,
                                *_pvPrivilegeBuffer,
                                *_pvUserBuffer;
                WCHAR           *_pszUserLogonName,
                                *_pszUserDisplayName;
};

#endif  /*  _TokenInformation_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\shfusion\delaycc.h ===
#ifndef DELAYCC_H
#define DELAYCC_H

BOOL DelayLoadCC();
HANDLE NT5_CreateActCtx(ACTCTX* p);
void NT5_ReleaseActCtx(HANDLE h);
BOOL NT5_ActivateActCtx(HANDLE h, ULONG_PTR * p);
BOOL NT5_DeactivateActCtx(ULONG_PTR p);
BOOL SHActivateContext(ULONG_PTR *pdwCookie);
void SHDeactivateContext(ULONG_PTR dwCookie);

extern HANDLE g_hActCtx;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\secutil\profileutil.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: ProfileUtil.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to handle profile loading and unloading without a token.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <sddl.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <dsgetdc.h>

#include "ProfileUtil.h"
#include "TokenUtil.h"

#define ARRAYSIZE(x)    (sizeof(x) / sizeof(x[0]))
#define TBOOL(x)        (BOOL)(x)
#define TW32(x)         (DWORD)(x)

//  --------------------------------------------------------------------------
//  CUserProfile::s_szUserHiveFilename
//
//  Purpose:    Default user hive name.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

const TCHAR     CUserProfile::s_szUserHiveFilename[]    =   TEXT("ntuser.dat");

//  --------------------------------------------------------------------------
//  CUserProfile::CUserProfile
//
//  Arguments:  pszUsername     =   User name of profile to load.
//              pszDomain       =   Domain for the user.
//
//  Returns:    <none>
//
//  Purpose:    Opens a handle to the given user's hive. If the hive isn't
//              loaded then the hive is loaded and a handle opened.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

CUserProfile::CUserProfile (const TCHAR *pszUsername, const TCHAR *pszDomain) :
    _hKeyProfile(NULL),
    _pszSID(NULL),
    _fLoaded(false)

{

    //  Validate parameter.

    if (!IsBadStringPtr(pszUsername, static_cast<UINT_PTR>(-1)))
    {
        PSID    pSID;

        //  Convert the username to a SID.

        pSID = UsernameToSID(pszUsername, pszDomain);
        if (pSID != NULL)
        {

            //  Convert the SID to a string.

            if (ConvertSidToStringSid(pSID, &_pszSID) != FALSE)
            {

                //  Attempt to open the user's hive.

                if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_USERS,
                                                  _pszSID,
                                                  0,
                                                  KEY_ALL_ACCESS,
                                                  &_hKeyProfile))
                {
                    TCHAR   szProfilePath[MAX_PATH];

                    //  If that failed then convert the string to a profile path.

                    if (SIDStringToProfilePath(_pszSID, szProfilePath))
                    {

                        //  Prevent buffer overrun.

                        if ((lstrlen(szProfilePath) + sizeof('\\') + ARRAYSIZE(s_szUserHiveFilename)) < ARRAYSIZE(szProfilePath))
                        {
                            CPrivilegeEnable    privilege(SE_RESTORE_NAME);

                            //  Enable SE_RESTORE_PRIVILEGE and create the
                            //  path to the user hive. Then load the hive.

                            lstrcat(szProfilePath, TEXT("\\"));
                            lstrcat(szProfilePath, s_szUserHiveFilename);
                            if (ERROR_SUCCESS == RegLoadKey(HKEY_USERS, _pszSID, szProfilePath))
                            {

                                //  Mark the hive as loaded and open the handle.

                                _fLoaded = true;
                                TW32(RegOpenKeyEx(HKEY_USERS,
                                                  _pszSID,
                                                  0,
                                                  KEY_ALL_ACCESS,
                                                  &_hKeyProfile));
                            }
                        }
                    }
                }
            }
            (HLOCAL)LocalFree(pSID);
        }
    }
}

//  --------------------------------------------------------------------------
//  CUserProfile::~CUserProfile
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases resources used by this object.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

CUserProfile::~CUserProfile (void)

{
    if (_hKeyProfile != NULL)
    {
        TBOOL(RegCloseKey(_hKeyProfile));
    }
    if (_fLoaded)
    {
        CPrivilegeEnable    privilege(SE_RESTORE_NAME);

        TW32(RegUnLoadKey(HKEY_USERS, _pszSID));
        _fLoaded = false;
    }
    if (_pszSID != NULL)
    {
        (HLOCAL)LocalFree(_pszSID);
        _pszSID = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CUserProfile::operator HKEY
//
//  Arguments:  <none>
//
//  Returns:    HKEY
//
//  Purpose:    Returns the HKEY to the user's hive.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

CUserProfile::operator HKEY (void)  const

{
    return(_hKeyProfile);
}

//  --------------------------------------------------------------------------
//  CUserProfile::UsernameToSID
//
//  Arguments:  pszUsername     =   User name to convert.
//              pszDomain       =   Domain for the user.
//
//  Returns:    PSID
//
//  Purpose:    Uses the security accounts manager to look up the account by
//              name and return the SID.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

PSID    CUserProfile::UsernameToSID (const TCHAR *pszUsername, const TCHAR *pszDomain)

{
    DWORD                   dwSIDSize, dwComputerNameSize, dwReferencedDomainSize;
    SID_NAME_USE            eSIDUse;
    PSID                    pSID, pSIDResult;
    WCHAR                   *pszDomainControllerName;
    DOMAIN_CONTROLLER_INFO  *pDCI;
    TCHAR                   szComputerName[CNLEN + sizeof('\0')];

    pSIDResult = NULL;
    dwComputerNameSize = ARRAYSIZE(szComputerName);
    if (GetComputerName(szComputerName, &dwComputerNameSize) == FALSE)
    {
        szComputerName[0] = TEXT('\0');
    }
    if ((pszDomain != NULL) &&
        (lstrcmpi(szComputerName, pszDomain) != 0) &&
        (ERROR_SUCCESS == DsGetDcName(NULL,
                                     pszDomain,
                                     NULL,
                                     NULL,
                                     0,
                                     &pDCI)))
    {
        pszDomainControllerName = pDCI->DomainControllerName;
    }
    else
    {
        pDCI = NULL;
        pszDomainControllerName = NULL;
    }
    dwSIDSize = dwReferencedDomainSize = 0;
    (BOOL)LookupAccountName(pszDomainControllerName,
                            pszUsername,
                            NULL,
                            &dwSIDSize,
                            NULL,
                            &dwReferencedDomainSize,
                            &eSIDUse);
    pSID = LocalAlloc(LMEM_FIXED, dwSIDSize);
    if (pSID != NULL)
    {
        TCHAR   *pszReferencedDomain;

        pszReferencedDomain = static_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, dwReferencedDomainSize * sizeof(TCHAR)));
        if (pszReferencedDomain != NULL)
        {
            if (LookupAccountName(pszDomainControllerName,
                                  pszUsername,
                                  pSID,
                                  &dwSIDSize,
                                  pszReferencedDomain,
                                  &dwReferencedDomainSize,
                                  &eSIDUse) != FALSE)
            {
                if (SidTypeUser == eSIDUse)
                {

                    //  If the account was successfully looked up and the
                    //  account type is a user then return the result back
                    //  to the caller and ensure that it's not released here.

                    pSIDResult = pSID;
                    pSID = NULL;
                }
            }
            (HLOCAL)LocalFree(pszReferencedDomain);
        }
        if (pSID != NULL)
        {
            (HLOCAL)LocalFree(pSID);
        }
    }
    if (pDCI != NULL)
    {
        (NET_API_STATUS)NetApiBufferFree(pDCI);
    }
    return(pSIDResult);
}

//  --------------------------------------------------------------------------
//  CUserProfile::SIDStringToProfilePath
//
//  Arguments:  pszSIDString    =   SID string to look up.
//              pszProfilePath  =   Returned path to the profile.
//
//  Returns:    bool
//
//  Purpose:    Looks up the profile path for the given SID string in the
//              location where userenv stores it. This doesn't change
//              although no API exists for this information.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

bool    CUserProfile::SIDStringToProfilePath (const TCHAR *pszSIDString, TCHAR *pszProfilePath)

{
    bool    fResult;

    fResult = false;
    if (!IsBadStringPtr(pszSIDString, static_cast<UINT_PTR>(-1)) && !IsBadWritePtr(pszProfilePath, MAX_PATH * sizeof(TCHAR)))
    {
        HKEY    hKeyProfileList;

        pszProfilePath[0] = TEXT('\0');
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                          TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"),
                                          0,
                                          KEY_QUERY_VALUE,
                                          &hKeyProfileList))
        {
            HKEY    hKeySID;

            if (ERROR_SUCCESS == RegOpenKeyEx(hKeyProfileList,
                                              pszSIDString,
                                              0,
                                              KEY_QUERY_VALUE,
                                              &hKeySID))
            {
                DWORD   dwType, dwProfilePathSize;
                TCHAR   szProfilePath[MAX_PATH];

                dwProfilePathSize = ARRAYSIZE(szProfilePath);
                if (ERROR_SUCCESS == RegQueryValueEx(hKeySID,
                                                     TEXT("ProfileImagePath"),
                                                     NULL,
                                                     &dwType,
                                                     reinterpret_cast<LPBYTE>(szProfilePath),
                                                     &dwProfilePathSize))
                {
                    if (REG_EXPAND_SZ == dwType)
                    {
                        fResult = true;
                        if (ExpandEnvironmentStrings(szProfilePath, pszProfilePath, MAX_PATH) == 0)
                        {
                            dwType = REG_SZ;
                        }
                    }
                    if (REG_SZ == dwType)
                    {
                        fResult = true;
                        (TCHAR*)lstrcpy(pszProfilePath, szProfilePath);
                    }
                }
                TW32(RegCloseKey(hKeySID));
            }
            TW32(RegCloseKey(hKeyProfileList));
        }
    }
    return(fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\secutil\tokenutil.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: TokenUtil.cpp
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Functions that are useful for token manipulation.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//              2000-03-31  vtan        duplicated from ds to shell
//  --------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "TokenUtil.h"

//  --------------------------------------------------------------------------
//  ::OpenEffectiveToken
//
//  Arguments:  dwDesiredAccess     =   Access to open the handle with.
//
//  Returns:    BOOL
//
//  Purpose:    Opens the effective token. If the thread is impersonating then
//              this is opened. Otherwise the process token is opened.
//
//  History:    2000-03-31  vtan        created
//  --------------------------------------------------------------------------

STDAPI_(BOOL)   OpenEffectiveToken (IN DWORD dwDesiredAccess, OUT HANDLE *phToken)

{
    BOOL    fResult;

    if (IsBadWritePtr(phToken, sizeof(*phToken)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        fResult = FALSE;
    }
    else
    {
        *phToken = NULL;
        fResult = OpenThreadToken(GetCurrentThread(), dwDesiredAccess, FALSE, phToken);
        if ((fResult == FALSE) && (GetLastError() == ERROR_NO_TOKEN))
        {
            fResult = OpenProcessToken(GetCurrentProcess(), dwDesiredAccess, phToken);
        }
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CPrivilegeEnable::CPrivilegeEnable
//
//  Arguments:  pszName     =   Name of the privilege to enable.
//
//  Returns:    <none>
//
//  Purpose:    Gets the current state of the privilege and enables it. The
//              privilege is specified by name and looked up.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

CPrivilegeEnable::CPrivilegeEnable (const TCHAR *pszName) :
    _fSet(false),
    _hToken(NULL)

{
    if (OpenEffectiveToken(TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &_hToken) != FALSE)
    {
        TOKEN_PRIVILEGES    newPrivilege;

        if (LookupPrivilegeValue(NULL, pszName, &newPrivilege.Privileges[0].Luid) != FALSE)
        {
            DWORD   dwReturnTokenPrivilegesSize;

            newPrivilege.PrivilegeCount = 1;
            newPrivilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
            _fSet = (AdjustTokenPrivileges(_hToken,
                                           FALSE,
                                           &newPrivilege,
                                           sizeof(newPrivilege),
                                           &_tokenPrivilegePrevious,
                                           &dwReturnTokenPrivilegesSize) != FALSE);
        }
    }
}

//  --------------------------------------------------------------------------
//  CPrivilegeEnable::~CPrivilegeEnable
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Restores the previous state of the privilege prior to
//              instantiation of the object.
//
//  History:    1999-08-23  vtan        created
//  --------------------------------------------------------------------------

CPrivilegeEnable::~CPrivilegeEnable (void)

{
    if (_fSet)
    {
        (BOOL)AdjustTokenPrivileges(_hToken,
                                    FALSE,
                                    &_tokenPrivilegePrevious,
                                    0,
                                    NULL,
                                    NULL);
    }
    if (_hToken != NULL)
    {
        (BOOL)CloseHandle(_hToken);
        _hToken = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\shfusion\cc\makefile.inc ===
!include "$(CCSHELL_DIR)\lib\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\shfusion\downlevel\makefile.inc ===
!include "$(CCSHELL_DIR)\lib\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\shfusion\native\makefile.inc ===
!include "$(CCSHELL_DIR)\lib\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\shfusion\delaycc.c ===
#define _COMCTL32_
#define _COMDLG32_
#include "stock.h"
#pragma hdrstop
#include "delaycc.h"
#include "shfusion.h"

// Load
HINSTANCE g_hinstCC = NULL;
HINSTANCE g_hinstCD = NULL;

BOOL DelayLoadCC()
{
    if (g_hinstCC == NULL)
    {
        g_hinstCC = SHFusionLoadLibrary(TEXT("comctl32.dll"));

        if (g_hinstCC == NULL)
        {
            SHFusionUninitialize();     // Unable to get v6, don't try to use a manifest

            g_hinstCC = LoadLibrary(TEXT("comctl32.dll"));
        }
    }
    return g_hinstCC != NULL;
}

BOOL DelayLoadCD()
{
    if (g_hinstCD == NULL)
    {
        g_hinstCD = SHFusionLoadLibrary(TEXT("comdlg32.dll"));

        if (g_hinstCD == NULL)
        {
            g_hinstCD = LoadLibrary(TEXT("comdlg32.dll"));
        }
    }
    return g_hinstCD != NULL;
}

void _GetProcFromComCtl32(FARPROC* ppfn, LPCSTR pszProc)
{
    if (!g_hinstCC)
        DelayLoadCC();

    if (g_hinstCC)
        *ppfn = GetProcAddress(g_hinstCC, pszProc);
    else
    {
        // Hmm, This is a fatal error.... Dialog and Quit?
        *ppfn = NULL;
    }
}

void _GetProcFromComDlg(FARPROC* ppfn, LPCSTR pszProc)
{
    // make sure g_hinstCD isn't NULL
    DelayLoadCD();

    if (g_hinstCD != NULL)
    {
        *ppfn = GetProcAddress(g_hinstCD, pszProc);
    }
    else
    {
        *ppfn = NULL;
    }
}


#define STUB_INVOKE_FN(_pfnVar, _nargs)                                       \
do                                                                            \
{                                                                             \
    if (_pfnVar)                                                              \
    {                                                                         \
        return _pfnVar _nargs;                                                \
    }                                                                         \
} while (0)

#define STUB_INVOKE_VOID_FN(_pfnVar, _nargs)                                  \
do                                                                            \
{                                                                             \
    if (_pfnVar)                                                              \
    {                                                                         \
        _pfnVar _nargs;                                                       \
    }                                                                         \
} while (0)

#define STUB_COMCTL32(_ret, _fn, _args, _nargs, _err)                         \
_ret __stdcall _fn _args                                                      \
{                                                                             \
    static _ret (__stdcall *_pfn##_fn) _args = (_ret (__stdcall *)_args)-1;   \
    if (_pfn##_fn == (_ret (__stdcall *)_args)-1)                             \
         _GetProcFromComCtl32((FARPROC*)&_pfn##_fn, #_fn);                    \
    STUB_INVOKE_FN(_pfn ## _fn, _nargs);                                      \
    return (_ret)_err;                                                        \
}

#define STUB_COMCTL32_ORD(_ret, _fn, _args, _nargs, _ord, _err)               \
_ret __stdcall _fn _args                                                      \
{                                                                             \
    static _ret (__stdcall *_pfn##_fn) _args = (_ret (__stdcall *)_args)-1;   \
    if (_pfn##_fn == (_ret (__stdcall *)_args)-1)                             \
         _GetProcFromComCtl32((FARPROC*)&_pfn##_fn, (LPCSTR)_ord);            \
    STUB_INVOKE_FN(_pfn ## _fn, _nargs);                                      \
    return (_ret)_err;                                                        \
}

#define STUB_COMCTL32_ORD_VOID(_fn, _args, _nargs, _ord)                      \
void __stdcall _fn _args                                                      \
{                                                                             \
    static void (__stdcall *_pfn##_fn) _args = (void (__stdcall *)_args)-1;   \
    if (_pfn##_fn == (void (__stdcall *)_args)-1)                             \
         _GetProcFromComCtl32((FARPROC*)&_pfn##_fn, (LPCSTR)_ord);            \
    STUB_INVOKE_VOID_FN(_pfn ## _fn, _nargs);                                 \
}

#define STUB_COMCTL32_ORD_BOOL(_fn, _args, _nargs, _ord)  STUB_COMCTL32_ORD(BOOL, _fn, _args, _nargs, _ord, FALSE)
#define STUB_COMCTL32_BOOL(_fn, _args, _nargs)  STUB_COMCTL32(BOOL, _fn, _args, _nargs, FALSE)

#define STUB_COMCTL32_VOID(_fn, _args, _nargs)                                \
void __stdcall _fn _args                                                      \
{                                                                             \
    static void (__stdcall *_pfn##_fn) _args = (void (__stdcall *)_args)-1;   \
    if (_pfn##_fn == (void (__stdcall *)_args)-1)                             \
         _GetProcFromComCtl32((FARPROC*)&_pfn##_fn, #_fn);                    \
    STUB_INVOKE_VOID_FN(_pfn ## _fn, _nargs);                                 \
}

STUB_COMCTL32_VOID(InitCommonControls, (), ());
STUB_COMCTL32_BOOL(InitCommonControlsEx, (LPINITCOMMONCONTROLSEX a), (a));
STUB_COMCTL32_BOOL(DestroyPropertySheetPage, (HPROPSHEETPAGE a), (a));
STUB_COMCTL32(HIMAGELIST, ImageList_Create, (int cx, int cy, UINT flags, int cInitial, int cGrow), (cx, cy, flags, cInitial, cGrow), NULL);
STUB_COMCTL32_BOOL(ImageList_Destroy, (HIMAGELIST himl), (himl));
STUB_COMCTL32(int, ImageList_GetImageCount, (HIMAGELIST himl), (himl), FALSE);
STUB_COMCTL32_BOOL(ImageList_SetImageCount, (HIMAGELIST himl, UINT uNewCount), (himl, uNewCount));
STUB_COMCTL32(int, ImageList_Add, (HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask), (himl, hbmImage, hbmMask), -1);
STUB_COMCTL32(int, ImageList_ReplaceIcon, (HIMAGELIST himl, int i, HICON hicon), (himl, i, hicon), -1);
STUB_COMCTL32(COLORREF, ImageList_SetBkColor, (HIMAGELIST himl, COLORREF clrBk), (himl, clrBk), RGB(0,0,0));
STUB_COMCTL32(COLORREF, ImageList_GetBkColor, (HIMAGELIST himl), (himl), RGB(0,0,0));
STUB_COMCTL32_BOOL(ImageList_SetOverlayImage, (HIMAGELIST himl, int iImage, int iOverlay), (himl, iImage, iOverlay));
STUB_COMCTL32_BOOL(ImageList_Draw, (HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle), (himl, i, hdcDst, x, y, fStyle));
STUB_COMCTL32_BOOL(ImageList_Replace, (HIMAGELIST himl, int i, HBITMAP hbmImage, HBITMAP hbmMask), (himl, i, hbmImage, hbmMask));
STUB_COMCTL32(int, ImageList_AddMasked, (HIMAGELIST himl, HBITMAP hbmImage, COLORREF crMask), (himl, hbmImage, crMask), -1);
STUB_COMCTL32_BOOL(ImageList_DrawEx, (HIMAGELIST himl, int i, HDC hdcDst, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle), (himl, i, hdcDst, x, y, dx, dy, rgbBk, rgbFg, fStyle));
STUB_COMCTL32_BOOL(ImageList_DrawIndirect, (IMAGELISTDRAWPARAMS* pimldp), (pimldp));
STUB_COMCTL32_BOOL(ImageList_Remove, (HIMAGELIST himl, int i), (himl, i));
STUB_COMCTL32(HICON, ImageList_GetIcon, (HIMAGELIST himl, int i, UINT flags), (himl, i, flags), NULL);
STUB_COMCTL32(HIMAGELIST, ImageList_LoadImageA, (HINSTANCE hi, LPCSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags), (hi, lpbmp, cx, cGrow, crMask, uType, uFlags), NULL);
STUB_COMCTL32(HIMAGELIST, ImageList_LoadImageW, (HINSTANCE hi, LPCWSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags), (hi, lpbmp, cx, cGrow, crMask, uType, uFlags), NULL);
STUB_COMCTL32_BOOL(ImageList_Copy, (HIMAGELIST himlDst, int iDst, HIMAGELIST himlSrc, int iSrc, UINT uFlags), (himlDst, iDst, himlSrc, iSrc, uFlags));
STUB_COMCTL32_BOOL(ImageList_BeginDrag, (HIMAGELIST himlTrack, int iTrack, int dxHotspot, int dyHotspot), (himlTrack, iTrack, dxHotspot, dyHotspot));
STUB_COMCTL32_VOID(ImageList_EndDrag, (), ());
STUB_COMCTL32_BOOL(ImageList_DragEnter, (HWND hwndLock, int x, int y), (hwndLock, x, y));
STUB_COMCTL32_BOOL(ImageList_DragLeave, (HWND hwndLock), (hwndLock));
STUB_COMCTL32_BOOL(ImageList_DragMove, (int x, int y), (x, y));
STUB_COMCTL32_BOOL(ImageList_SetDragCursorImage, (HIMAGELIST himlDrag, int iDrag, int dxHotspot, int dyHotspot), (himlDrag, iDrag, dxHotspot, dyHotspot));
STUB_COMCTL32_BOOL(ImageList_DragShowNolock, (BOOL fShow), (fShow));
STUB_COMCTL32(HIMAGELIST, ImageList_GetDragImage, (POINT* ppt, POINT* pptHotspot), (ppt, pptHotspot), NULL);
STUB_COMCTL32(HIMAGELIST, ImageList_Read, (LPSTREAM pstm), (pstm), NULL);
STUB_COMCTL32_BOOL(ImageList_Write, (HIMAGELIST himl, LPSTREAM pstm), (himl, pstm));
STUB_COMCTL32_BOOL(ImageList_GetIconSize, (HIMAGELIST himl, int *cx, int*cy), (himl, cx, cy));
STUB_COMCTL32_BOOL(ImageList_SetIconSize, (HIMAGELIST himl, int cx, int cy), (himl, cx, cy));
STUB_COMCTL32_BOOL(ImageList_GetImageInfo, (HIMAGELIST himl, int i, IMAGEINFO* pImageInfo), (himl, i, pImageInfo));
STUB_COMCTL32(HIMAGELIST, ImageList_Merge, (HIMAGELIST himl1, int i1, HIMAGELIST himl2, int i2, int dx, int dy), (himl1, i1, himl2, i2, dx, dy), NULL);
STUB_COMCTL32(HIMAGELIST, ImageList_Duplicate, (HIMAGELIST himl), (himl), NULL);
STUB_COMCTL32_VOID(InitMUILanguage, (LANGID uiLang), (uiLang));
STUB_COMCTL32_BOOL(ImageList_SetFilter, (HIMAGELIST himl, PFNIMLFILTER pfnFilter, LPARAM lParamFilter), (himl, pfnFilter, lParamFilter));
STUB_COMCTL32_BOOL(ImageList_GetImageRect, (HIMAGELIST himl, int i, RECT FAR* prcImage), (himl, i, prcImage));
STUB_COMCTL32_BOOL(ImageList_SetFlags, (HIMAGELIST himl, UINT flags), (himl, flags));
STUB_COMCTL32(UINT, ImageList_GetFlags, (HIMAGELIST himl), (himl), 0);
STUB_COMCTL32(HRESULT, HIMAGELIST_QueryInterface, (HIMAGELIST himl, REFIID riid, void** ppv), (himl, riid, ppv), E_FAIL);
STUB_COMCTL32(HWND, CreateToolbarEx, (HWND hwnd,DWORD ws,UINT wID,int nBitmaps,HINSTANCE hBMInst,UINT_PTR wBMID,LPCTBBUTTON lpButtons,int iNumButtons,int dxButton,int dyButton,int dxBitmap,int dyBitmap,UINT uStructSize),(hwnd,ws,wID,nBitmaps,hBMInst,wBMID,lpButtons,iNumButtons,dxButton,dyButton,dxBitmap,dyBitmap,uStructSize), NULL );
STUB_COMCTL32(HWND, CreateStatusWindowW, (LONG style, LPCWSTR lpszText, HWND hwndParent, UINT wID), (style, lpszText, hwndParent, wID), NULL);
STUB_COMCTL32(int, DrawShadowText, (HDC hdc, LPCWSTR pszText, UINT cch, RECT* prc, DWORD dwFlags, COLORREF crText, 
    COLORREF crShadow, int ixOffset, int iyOffset), (hdc, pszText, cch, prc, dwFlags, crText, crShadow, ixOffset, iyOffset), -1);

STUB_COMCTL32_ORD(int          , ImageList_SetColorTable, (HIMAGELIST piml, int start, int len, RGBQUAD *prgb), (piml, start, len, prgb), 390, 0);
STUB_COMCTL32_ORD_BOOL(MirrorIcon, (HICON* phiconSmall, HICON* phiconLarge), (phiconSmall, phiconLarge), 414);
STUB_COMCTL32_ORD(int          , Str_GetPtrW, (LPCWSTR psz, LPWSTR pszBuf, int cchBuf), (psz,pszBuf,cchBuf), 235, -1);
STUB_COMCTL32_ORD_BOOL(Str_SetPtrW, (LPWSTR * ppsz, LPCWSTR psz), (ppsz, psz), 236);
STUB_COMCTL32_ORD_BOOL(Str_SetPtrA, (LPSTR * ppsz, LPCSTR psz), (ppsz, psz), 234);
STUB_COMCTL32_ORD(HANDLE       , CreateMRUList, (LPMRUINFO lpmi), (lpmi), 400, NULL);
STUB_COMCTL32_ORD_VOID(FreeMRUList, (HANDLE hMRU), (hMRU), 152);
STUB_COMCTL32_ORD(int     , AddMRUStringA, (HANDLE hMRU, LPCSTR szString), (hMRU, szString), 401, -1);
STUB_COMCTL32_ORD(int     , AddMRUStringW, (HANDLE hMRU, LPCWSTR szString), (hMRU, szString), 401, -1);
STUB_COMCTL32_ORD(int     , DelMRUString, (HANDLE hMRU, int nItem), (hMRU, nItem), 156, -1);
STUB_COMCTL32_ORD(int     , FindMRUStringA, (HANDLE hMRU, LPCSTR szString, LPINT lpiSlot), (hMRU, szString, lpiSlot), 402, -1);
STUB_COMCTL32_ORD(int     , FindMRUStringW, (HANDLE hMRU, LPCWSTR szString, LPINT lpiSlot), (hMRU, szString, lpiSlot), 402, -1);
STUB_COMCTL32_ORD(int     , EnumMRUList, (HANDLE hMRU, int nItem, LPVOID lpData, UINT uLen), (hMRU, nItem, lpData, uLen), 403, -1);
STUB_COMCTL32_ORD(int     , AddMRUData, (HANDLE hMRU, const void FAR *lpData, UINT cbData), (hMRU, lpData, cbData), 167, -1);
STUB_COMCTL32_ORD(int     , FindMRUData, (HANDLE hMRU, const void FAR *lpData, UINT cbData, LPINT lpiSlot), (hMRU, lpData, cbData, lpiSlot), 169, -1);
STUB_COMCTL32_ORD(HANDLE  , CreateMRUListLazyA, (LPMRUINFOA lpmi, const void FAR *lpData, UINT cbData, LPINT lpiSlot), (lpmi, lpData, cbData, lpiSlot), 404, NULL);
STUB_COMCTL32_ORD(HANDLE  , CreateMRUListLazyW, (LPMRUINFOW lpmi, const void FAR *lpData, UINT cbData, LPINT lpiSlot), (lpmi, lpData, cbData, lpiSlot), 404, NULL);
STUB_COMCTL32_ORD_BOOL(SetWindowSubclass, (HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass, DWORD_PTR dwRefData), (hWnd, pfnSubclass, uIdSubclass, dwRefData), 410);
STUB_COMCTL32_ORD_BOOL(GetWindowSubclass, (HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass, DWORD_PTR *pdwRefData), (hWnd, pfnSubclass, uIdSubclass, pdwRefData), 411);
STUB_COMCTL32_ORD_BOOL(RemoveWindowSubclass, (HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass), (hWnd, pfnSubclass, uIdSubclass), 412);
STUB_COMCTL32_ORD(LRESULT , DefSubclassProc, (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam), (hWnd, uMsg, wParam, lParam), 413, 0);
STUB_COMCTL32_ORD(HDSA    , DSA_Create, (int cbItem, int cItemGrow), (cbItem, cItemGrow), 320, NULL);
STUB_COMCTL32_ORD_BOOL(DSA_Destroy, (HDSA hdsa), (hdsa), 321);
STUB_COMCTL32_ORD_BOOL(DSA_GetItem, (HDSA hdsa, int i, void FAR* pitem), (hdsa, i, pitem), 322);
STUB_COMCTL32_ORD(LPVOID  , DSA_GetItemPtr, (HDSA hdsa, int i), (hdsa, i), 323, NULL);
STUB_COMCTL32_ORD_BOOL(DSA_SetItem, (HDSA hdsa, int i, void FAR* pitem), (hdsa, i, pitem), 325);
STUB_COMCTL32_ORD(int     , DSA_InsertItem, (HDSA hdsa, int i, void FAR* pitem), (hdsa, i, pitem), 324, -1);
STUB_COMCTL32_ORD_BOOL(DSA_DeleteItem, (HDSA hdsa, int i), (hdsa, i), 326);
STUB_COMCTL32_ORD_BOOL(DSA_DeleteAllItems, (HDSA hdsa), (hdsa), 327);
STUB_COMCTL32_ORD_VOID(DSA_EnumCallback, (HDSA hdsa, PFNDSAENUMCALLBACK pfnCB, LPVOID pData), (hdsa, pfnCB, pData), 387);
STUB_COMCTL32_ORD_VOID(DSA_DestroyCallback, (HDSA hdsa, PFNDSAENUMCALLBACK pfnCB, LPVOID pData), (hdsa, pfnCB, pData), 388);
STUB_COMCTL32_ORD(HDPA    , DPA_Create, (int cItemGrow), (cItemGrow), 328, NULL);
STUB_COMCTL32_ORD(HDPA    , DPA_CreateEx, (int cpGrow, HANDLE hheap), (cpGrow, hheap), 340, NULL);
STUB_COMCTL32_ORD_BOOL(DPA_Destroy, (HDPA hdpa), (hdpa), 329);
STUB_COMCTL32_ORD(HDPA    , DPA_Clone, (HDPA hdpa, HDPA hdpaNew), (hdpa, hdpaNew), 331, NULL);
STUB_COMCTL32_ORD(LPVOID  , DPA_GetPtr, (HDPA hdpa, INT_PTR i), (hdpa, i), 332, NULL);
STUB_COMCTL32_ORD(int     , DPA_GetPtrIndex, (HDPA hdpa, LPVOID p), (hdpa, p), 333, -1);
STUB_COMCTL32_ORD_BOOL(DPA_Grow, (HDPA pdpa, int cp), (pdpa, cp), 330);
STUB_COMCTL32_ORD_BOOL(DPA_SetPtr, (HDPA hdpa, int i, LPVOID p), (hdpa, i, p), 335);
STUB_COMCTL32_ORD(int     , DPA_InsertPtr, (HDPA hdpa, int i, LPVOID p), (hdpa, i, p), 334, -1);
STUB_COMCTL32_ORD(LPVOID  , DPA_DeletePtr, (HDPA hdpa, int i), (hdpa, i), 336, NULL);
STUB_COMCTL32_ORD_BOOL(DPA_DeleteAllPtrs, (HDPA hdpa), (hdpa), 337);
STUB_COMCTL32_ORD_VOID(DPA_EnumCallback, (HDPA hdpa, PFNDPAENUMCALLBACK pfnCB, LPVOID pData), (hdpa, pfnCB, pData), 385);
STUB_COMCTL32_ORD_VOID(DPA_DestroyCallback, (HDPA hdpa, PFNDPAENUMCALLBACK pfnCB, LPVOID pData), (hdpa, pfnCB, pData), 386);
STUB_COMCTL32_ORD(HRESULT  , DPA_LoadStream, (HDPA * phdpa, PFNDPASTREAM pfn, IStream * pstream, LPVOID pvInstData), (phdpa, pfn, pstream, pvInstData), 9, E_FAIL);
STUB_COMCTL32_ORD(HRESULT  , DPA_SaveStream, (HDPA hdpa, PFNDPASTREAM pfn, IStream * pstream, LPVOID pvInstData), (hdpa, pfn, pstream, pvInstData), 10, E_FAIL);
STUB_COMCTL32_ORD_BOOL(DPA_Sort, (HDPA hdpa, PFNDPACOMPARE pfnCompare, LPARAM lParam), (hdpa, pfnCompare, lParam), 338);
STUB_COMCTL32_ORD_BOOL(DPA_Merge, (HDPA hdpaDest, HDPA hdpaSrc, DWORD dwFlags, PFNDPACOMPARE pfnCompare, PFNDPAMERGE pfnMerge, LPARAM lParam), (hdpaDest, hdpaSrc, dwFlags, pfnCompare, pfnMerge, lParam), 11);
STUB_COMCTL32_ORD(int  , DPA_Search, (HDPA hdpa, LPVOID pFind, int iStart, PFNDPACOMPARE pfnCompare, LPARAM lParam, UINT options), (hdpa, pFind, iStart, pfnCompare, lParam, options), 339, -1);
STUB_COMCTL32_ORD(LRESULT  , SendNotify, (HWND hwndTo, HWND hwndFrom, int code, NMHDR FAR* pnmhdr), (hwndTo, hwndFrom, code, pnmhdr), 341, 0);
STUB_COMCTL32_ORD(LRESULT  , SendNotifyEx, (HWND hwndTo, HWND hwndFrom, int code, NMHDR FAR* pnmhdr, BOOL bUnicode), (hwndTo, hwndFrom, code, pnmhdr, bUnicode), 342, 0);
STUB_COMCTL32_ORD_VOID(SetPathWordBreakProc, (HWND hwndEdit, BOOL fSet), (hwndEdit, fSet), 384);
STUB_COMCTL32_ORD(HPROPSHEETPAGE , CreateProxyPage, (HPROPSHEETPAGE hpage16, HINSTANCE hinst16), (hpage16, hinst16), 164, NULL);
STUB_COMCTL32_ORD(HBITMAP , CreateMappedBitmap, (HINSTANCE hInstance, INT_PTR idBitmap, UINT wFlags, LPCOLORMAP lpColorMap, int iNumMaps), (hInstance, idBitmap, wFlags, lpColorMap, iNumMaps), 8, NULL);
STUB_COMCTL32_ORD(HWND , CreateUpDownControl, (DWORD dwStyle, int x, int y, int cx, int cy, HWND hParent, int nID, HINSTANCE hInst, HWND hwndBuddy, int nUpper, int nLower, int nPos), (dwStyle, x, y, cx, cy, hParent, nID, hInst, hwndBuddy, nUpper, nLower, nPos), 16, NULL);
//STUB_COMCTL32_ORD(DWORD , SHGetProcessDword, (DWORD idProcess, LONG iIndex), (idProcess, iIndex), 389, 0);
STUB_COMCTL32_ORD_VOID(MenuHelp, (UINT uMsg, WPARAM wParam, LPARAM lParam, HMENU hMainMenu, HINSTANCE hInst, HWND hwndStatus, UINT FAR *lpwIDs), (uMsg, wParam, lParam, hMainMenu, hInst, hwndStatus, lpwIDs), 2);
STUB_COMCTL32_ORD_VOID(GetEffectiveClientRect, (HWND hWnd, LPRECT lprc, LPINT lpInfo), (hWnd, lprc, lpInfo), 4);

// This is for OE
STUB_COMCTL32_BOOL(_TrackMouseEvent, (LPTRACKMOUSEEVENT lpEventTrack), (lpEventTrack));
STUB_COMCTL32_ORD(HWND, CreateStatusWindowA, (long style,LPCSTR lpszText,HWND hwndParent,UINT wID), (style, lpszText, hwndParent, wID),6, NULL);
STUB_COMCTL32_ORD_BOOL(MakeDragList, (HWND hLB), (hLB), 13);
STUB_COMCTL32_ORD_VOID(DrawInsert, (HWND handParent, HWND hLB, int nItem), (handParent, hLB, nItem), 15);
STUB_COMCTL32_ORD(int, LBItemFromPt, (HWND hLB, POINT pt, BOOL bAutoScroll), (hLB, pt, bAutoScroll), 14, -1);

static HPROPSHEETPAGE (__stdcall *_pfnCreatePropertySheetPageW)(LPCPROPSHEETPAGEW a) = (HPROPSHEETPAGE (__stdcall *)(LPCPROPSHEETPAGEW))-1;

// This is designed for Callers that know that they are creating a property
// sheet on behalf of another that may be using an old version of common controls
// PROPSHEETPAGE is designed so that it can contain extra information, so we can't
// just wax part of the data structure for fusion use.
HPROPSHEETPAGE __stdcall SHNoFusionCreatePropertySheetPageW (LPCPROPSHEETPAGEW a)
{
    ULONG_PTR dwCookie = 0;
    HPROPSHEETPAGE ret = NULL;
    SHActivateContext(&dwCookie);
    __try
    {
        if (_pfnCreatePropertySheetPageW == (HPROPSHEETPAGE (__stdcall *)(LPCPROPSHEETPAGEW))-1)
             _GetProcFromComCtl32((FARPROC*)&_pfnCreatePropertySheetPageW, "CreatePropertySheetPageW");
        if (_pfnCreatePropertySheetPageW)
        {
            ret = _pfnCreatePropertySheetPageW(a);
        }
    }
    __finally
    {
        SHDeactivateContext(dwCookie);
    }
    return ret;
}

HPROPSHEETPAGE __stdcall CreatePropertySheetPageW (LPCPROPSHEETPAGEW a)
{
    static HPROPSHEETPAGE (__stdcall *_pfnCreatePropertySheetPageW)(LPCPROPSHEETPAGEW a) = (HPROPSHEETPAGE (__stdcall *)(LPCPROPSHEETPAGEW))-1;
    ULONG_PTR dwCookie = 0;
    HPROPSHEETPAGE ret = NULL;
    SHActivateContext(&dwCookie);
    __try
    {
        if (_pfnCreatePropertySheetPageW == (HPROPSHEETPAGE (__stdcall *)(LPCPROPSHEETPAGEW))-1)
             _GetProcFromComCtl32((FARPROC*)&_pfnCreatePropertySheetPageW, "CreatePropertySheetPageW");
        if (_pfnCreatePropertySheetPageW)
        {
            // only apply the new info if the size is correct
            if (a->dwSize > PROPSHEETPAGE_V2_SIZE)
            {
                LPPROPSHEETPAGEW ps = (LPPROPSHEETPAGEW)a;
                ps->dwFlags |= PSP_USEFUSIONCONTEXT;
                ps->hActCtx = g_hActCtx;
            }

            ret = _pfnCreatePropertySheetPageW(a);
        }
    }
    __finally
    {
        SHDeactivateContext(dwCookie);
    }
    return ret;
}

static HPROPSHEETPAGE (__stdcall *_pfnCreatePropertySheetPageA)(LPCPROPSHEETPAGEA a) = (HPROPSHEETPAGE (__stdcall *)(LPCPROPSHEETPAGEA))-1;

// This is designed for Callers that know that they are creating a property
// sheet on behalf of another that may be using an old version of common controls
// PROPSHEETPAGE is designed so that it can contain extra information, so we can't
// just wax part of the data structure for fusion use.
HPROPSHEETPAGE __stdcall SHNoFusionCreatePropertySheetPageA (LPCPROPSHEETPAGEA a)
{
    ULONG_PTR dwCookie = 0;
    HPROPSHEETPAGE ret = NULL;
    SHActivateContext(&dwCookie);
    __try
    {
        if (_pfnCreatePropertySheetPageA == (HPROPSHEETPAGE (__stdcall *)(LPCPROPSHEETPAGEA))-1)
             _GetProcFromComCtl32((FARPROC*)&_pfnCreatePropertySheetPageA, "CreatePropertySheetPageA");
        if (_pfnCreatePropertySheetPageA)
        {
            ret = _pfnCreatePropertySheetPageA(a);
        }
    }
    __finally
    {
        SHDeactivateContext(dwCookie);
    }
    return ret;
}

HPROPSHEETPAGE __stdcall CreatePropertySheetPageA (LPCPROPSHEETPAGEA a)
{
    ULONG_PTR dwCookie = 0;
    HPROPSHEETPAGE ret = NULL;
    SHActivateContext(&dwCookie);
    __try
    {
        if (_pfnCreatePropertySheetPageA == (HPROPSHEETPAGE (__stdcall *)(LPCPROPSHEETPAGEA))-1)
             _GetProcFromComCtl32((FARPROC*)&_pfnCreatePropertySheetPageA, "CreatePropertySheetPageA");
        if (_pfnCreatePropertySheetPageA)
        {
            // only apply the new info if the size is correct
            if (a->dwSize > PROPSHEETPAGE_V2_SIZE)
            {
                LPPROPSHEETPAGEA ps = (LPPROPSHEETPAGEA)a;
                ps->dwFlags |= PSP_USEFUSIONCONTEXT;
                ps->hActCtx = g_hActCtx;
            }

            ret = _pfnCreatePropertySheetPageA(a);
        }
    }
    __finally
    {
        SHDeactivateContext(dwCookie);
    }

    return ret;
}

INT_PTR __stdcall PropertySheetA (LPCPROPSHEETHEADERA a)
{
    static INT_PTR (__stdcall *_pfnPropertySheetA)(LPCPROPSHEETHEADERA a) = (INT_PTR (__stdcall *)(LPCPROPSHEETHEADERA))-1;
    ULONG_PTR dwCookie = -1;
    INT_PTR ret = 0;
    if (_pfnPropertySheetA == (INT_PTR (__stdcall *)(LPCPROPSHEETHEADERA))-1)
         _GetProcFromComCtl32((FARPROC*)&_pfnPropertySheetA, "PropertySheetA");
    if (_pfnPropertySheetA)
    {
        NT5_ActivateActCtx(NULL, &dwCookie);
        __try
        {
            ret = _pfnPropertySheetA(a);
        }
        __finally
        {
            NT5_DeactivateActCtx(dwCookie);
        }
    }

    return ret;
}

INT_PTR __stdcall PropertySheetW (LPCPROPSHEETHEADERW a)
{
    static INT_PTR (__stdcall *_pfnPropertySheetW)(LPCPROPSHEETHEADERW a) = (INT_PTR (__stdcall *)(LPCPROPSHEETHEADERW))-1;
    ULONG_PTR dwCookie = -1;
    INT_PTR ret = 0;
    if (_pfnPropertySheetW == (INT_PTR (__stdcall *)(LPCPROPSHEETHEADERW))-1)
         _GetProcFromComCtl32((FARPROC*)&_pfnPropertySheetW, "PropertySheetW");
    if (_pfnPropertySheetW)
    {
        NT5_ActivateActCtx(NULL, &dwCookie);
        __try
        {
            ret = _pfnPropertySheetW(a);
        }
        __finally
        {
            NT5_DeactivateActCtx(dwCookie);
        }
    }

    return ret;
}




// Macro for comdlg wrappers
#define DELAY_LOAD_COMDLG_NAME_ERR(_ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    ULONG_PTR dwCookie = 0; \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _ret ret = _err; \
    _GetProcFromComDlg((FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
{ \
        SHActivateContext(&dwCookie); \
        __try \
        { \
            ret = _pfn##_fn _nargs;  \
        } \
        __finally \
        { \
        SHDeactivateContext(dwCookie); \
        } \
} \
    return (_ret)ret;           \
}



DELAY_LOAD_COMDLG_NAME_ERR(BOOL, GetOpenFileNameW, "GetOpenFileNameW", (LPOPENFILENAMEW lpofn), (lpofn), FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, GetOpenFileNameA, "GetOpenFileNameA", (LPOPENFILENAMEA lpofn), (lpofn), FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, GetSaveFileNameW, "GetSaveFileNameW", (LPOPENFILENAMEW lpofn), (lpofn), FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, GetSaveFileNameA, "GetSaveFileNameA", (LPOPENFILENAMEA lpofn), (lpofn), FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, ChooseColorW    , "ChooseColorW",     (LPCHOOSECOLORW lpcc),   (lpcc),  FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, ChooseColorA    , "ChooseColorA",     (LPCHOOSECOLORA lpcc),   (lpcc),  FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, ChooseFontW     , "ChooseFontW",      (LPCHOOSEFONTW lpcf),    (lpcf),  FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, ChooseFontA     , "ChooseFontA",      (LPCHOOSEFONTA lpcf),    (lpcf),  FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(DWORD,CommDlgExtendedError, "CommDlgExtendedError", (void),          (),      CDERR_INITIALIZATION)
DELAY_LOAD_COMDLG_NAME_ERR(HWND, FindTextW,        "FindTextW",        (LPFINDREPLACEW lpfr),   (lpfr),  NULL)
DELAY_LOAD_COMDLG_NAME_ERR(HWND, FindTextA,        "FindTextA",        (LPFINDREPLACEA lpfr),   (lpfr),  NULL)
DELAY_LOAD_COMDLG_NAME_ERR(short,GetFileTitleW,    "GetFileTitleW",    (LPCWSTR lpszFile, LPWSTR lpszTitle, WORD cbBuf), (lpszFile, lpszTitle, cbBuf), (-1))
DELAY_LOAD_COMDLG_NAME_ERR(short,GetFileTitleA,    "GetFileTitleA",    (LPCSTR lpszFile, LPSTR lpszTitle, WORD cbBuf), (lpszFile, lpszTitle, cbBuf), (-1))
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, PageSetupDlgW,    "PageSetupDlgW",    (LPPAGESETUPDLGW lppsd), (lppsd), FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, PageSetupDlgA,    "PageSetupDlgA",    (LPPAGESETUPDLGA lppsd), (lppsd), FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, PrintDlgW,        "PrintDlgW",        (LPPRINTDLGW     lppd),  (lppd),  FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(BOOL, PrintDlgA,        "PrintDlgA",        (LPPRINTDLGA     lppd),  (lppd),  FALSE)
DELAY_LOAD_COMDLG_NAME_ERR(HRESULT,PrintDlgExW,    "PrintDlgExW",      (LPPRINTDLGEXW   lppd),  (lppd),  E_FAIL)
DELAY_LOAD_COMDLG_NAME_ERR(HRESULT,PrintDlgExA,    "PrintDlgExA",      (LPPRINTDLGEXA   lppd),  (lppd),  E_FAIL)
DELAY_LOAD_COMDLG_NAME_ERR(HWND, ReplaceTextW,     "ReplaceTextW",     (LPFINDREPLACEW lpfr),   (lpfr),  NULL)
DELAY_LOAD_COMDLG_NAME_ERR(HWND, ReplaceTextA,     "ReplaceTextA",     (LPFINDREPLACEA lpfr),   (lpfr),  NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\shfusion\ansi\makefile.inc ===
!include "$(CCSHELL_DIR)\lib\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\stock4\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\stock\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\shfusion\shfusion.c ===
#include "stock.h"
#pragma hdrstop

#define SHFUSION_IMPL
#include "shfusion.h"
#include "delaycc.h"

#ifdef FUSION_DOWNLEVEL
#include <w95wraps.h>
#endif

typedef BOOL (__stdcall *PFNACTCTX)(HANDLE, ULONG_PTR *);
typedef BOOL (__stdcall *PFNDEACTCTX)(DWORD, ULONG_PTR );
typedef HANDLE (__stdcall *PFNCREATECTX)(ACTCTX*);
typedef void (__stdcall *PFNRELCTX)(HANDLE);
typedef UINT (__stdcall *PFNGSWD)(PTSTR psz, int cch);
HMODULE g_hmodKernel = NULL;
static PFNACTCTX s_pfnAct = (PFNACTCTX)-1;
static PFNDEACTCTX s_pfnDeact = (PFNDEACTCTX)-1;
static PFNCREATECTX s_pfnCreateact = (PFNCREATECTX)-1;
static PFNRELCTX s_pfnReleaseact = (PFNRELCTX)-1;
static PFNGSWD s_pfnGetSysWinDir = (PFNGSWD)-1;

HANDLE NT5_CreateActCtx(ACTCTX* p)
{
    if (s_pfnCreateact == (PFNCREATECTX)-1)
    {
        g_hmodKernel = GetModuleHandle(TEXT("Kernel32"));
        if (g_hmodKernel)
        {
#ifdef _UNICODE
            s_pfnCreateact = (PFNCREATECTX)GetProcAddress(g_hmodKernel, "CreateActCtxW");
#else
            s_pfnCreateact = (PFNCREATECTX)GetProcAddress(g_hmodKernel, "CreateActCtxA");
#endif // _UNICODE

        }
        else
            s_pfnCreateact = NULL;
    }

    if (s_pfnCreateact)
        return s_pfnCreateact(p);

    return NULL;
}

void NT5_ReleaseActCtx(HANDLE h)
{
    if (s_pfnReleaseact == (PFNRELCTX)-1)
    {
        g_hmodKernel = GetModuleHandle(TEXT("Kernel32"));
        if (g_hmodKernel)
        {
            s_pfnReleaseact = (PFNRELCTX)GetProcAddress(g_hmodKernel, "ReleaseActCtx");
        }
        else
            s_pfnReleaseact = NULL;

    }

    if (s_pfnReleaseact)
        s_pfnReleaseact(h);
}

BOOL NT5_ActivateActCtx(HANDLE h, ULONG_PTR* p)
{
    if (s_pfnAct == (PFNACTCTX)-1)
    {
        g_hmodKernel = GetModuleHandle(TEXT("Kernel32"));
        if (g_hmodKernel)
        {
            s_pfnAct = (PFNACTCTX)GetProcAddress(g_hmodKernel, "ActivateActCtx");
        }
        else
        {
            s_pfnAct = NULL;
        }
    }
    *p = 0;

    if (s_pfnAct)
    {
        return s_pfnAct(h, p);
    }

    return TRUE;
}

BOOL NT5_DeactivateActCtx(ULONG_PTR p)
{
    if (s_pfnDeact == (PFNDEACTCTX)-1)
    {
        g_hmodKernel = GetModuleHandle(TEXT("Kernel32"));
        if (g_hmodKernel)
        {
            s_pfnDeact = (PFNDEACTCTX)GetProcAddress(g_hmodKernel, "DeactivateActCtx");
        }
        else
            s_pfnDeact = NULL;
    }

    if (s_pfnDeact)
        return s_pfnDeact(0, p);

    return TRUE;
}

BOOL SHActivateContext(ULONG_PTR* pulCookie)
{
    *pulCookie = 0;

    if (g_hActCtx != INVALID_HANDLE_VALUE)
    {
        return NT5_ActivateActCtx(g_hActCtx, pulCookie);
    }

    // Default to success in activation for down level.
    return TRUE;
}

void SHDeactivateContext(ULONG_PTR ulCookie)
{
    if (ulCookie != 0)
    {
        NT5_DeactivateActCtx(ulCookie);
    }
}

#define ENTERCONTEXT(fail) \
    ULONG_PTR ulCookie = 0;\
    if (!SHActivateContext(&ulCookie)) \
        return fail;\
    __try {

#define LEAVECONTEXT \
    } __finally {SHDeactivateContext(ulCookie);}


EXTERN_C HINSTANCE g_hinst;
HANDLE g_hActCtx = INVALID_HANDLE_VALUE;

UINT NT5_GetSystemWindowsDirectory(PTSTR psz, int cch)
{
    if (s_pfnGetSysWinDir == (PFNGSWD)-1)
    {
        g_hmodKernel = GetModuleHandle(TEXT("Kernel32"));
        if (g_hmodKernel)
        {
#ifdef _UNICODE
            s_pfnGetSysWinDir = (PFNGSWD)GetProcAddress(g_hmodKernel, "GetSystemWindowsDirectoryW");
#else
            s_pfnGetSysWinDir = (PFNGSWD)GetProcAddress(g_hmodKernel, "GetSystemWindowsDirectoryA");
#endif // _UNICODE
        }
        else
            s_pfnGetSysWinDir = NULL;
    }

    if (s_pfnGetSysWinDir)
        return s_pfnGetSysWinDir(psz, cch);
    else
        return GetWindowsDirectory(psz, cch);
}

void SHGetManifest(PTSTR pszManifest, int cch)
{
    int cchWindir = NT5_GetSystemWindowsDirectory(pszManifest, cch);

    // We want to use StrCatBuff but we cannot assume that the caller
    // is using shlwapi so we do it manually. Note that it's okay to use
    // lstrcpynW even though Win9x doesn't support it, because Win9x doesn't
    // support manifests anyway!
    if (cch > cchWindir)
    {
        lstrcpyn(pszManifest + cchWindir, TEXT("\\WindowsShell.Manifest"),
                 cch - cchWindir);
    }
}

void VerifyComctl32Loaded()
{
#ifndef NOCOMCTL32
    DelayLoadCC();
#endif
}

BOOL SHFusionInitializeIDCC(PTSTR pszPath, int id, BOOL fLoadCC)
{
    TCHAR szPath[MAX_PATH];
    ACTCTX act = {0};

    if (pszPath == NULL)
    {
        SHGetManifest(szPath, ARRAYSIZE(szPath));
        pszPath = szPath;
    }
    else
    {
        act.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
        act.lpResourceName = MAKEINTRESOURCE(id);
    }

    if (g_hActCtx == INVALID_HANDLE_VALUE)
    {
        act.cbSize = sizeof(act);
        act.lpSource = pszPath;


        g_hActCtx = NT5_CreateActCtx(&act);
    }

#ifndef NOCOMCTL32
    if (fLoadCC)
        DelayLoadCC();
#endif

    return g_hActCtx != INVALID_HANDLE_VALUE;
}

BOOL SHFusionInitializeID(PTSTR pszPath, int id)
{
    return SHFusionInitializeIDCC(pszPath, id, TRUE);
}


BOOL SHFusionInitialize(PTSTR pszPath)
{
    return SHFusionInitializeID(pszPath, 123);
}

BOOL SHFusionInitializeFromModuleID(HMODULE hMod, int id)
{
    TCHAR szPath[MAX_PATH];
    GetModuleFileName(hMod, szPath, ARRAYSIZE(szPath));
    return SHFusionInitializeIDCC(szPath, id, TRUE);
}


BOOL SHFusionInitializeFromModuleIDCC(HMODULE hMod, int id, BOOL fLoadCC)
{
    TCHAR szPath[MAX_PATH];
    GetModuleFileName(hMod, szPath, ARRAYSIZE(szPath));
    return SHFusionInitializeIDCC(szPath, id, fLoadCC);
}


BOOL __stdcall SHFusionInitializeFromModuleIDNoCC(HMODULE hMod, int id)
{
    TCHAR szPath[MAX_PATH];
    GetModuleFileName(hMod, szPath, ARRAYSIZE(szPath));
    return SHFusionInitializeIDCC(szPath, id, FALSE);
}


BOOL SHFusionInitializeFromModule(HMODULE hMod)
{
    TCHAR szPath[MAX_PATH];
    GetModuleFileName(hMod, szPath, ARRAYSIZE(szPath));
    return SHFusionInitialize(szPath);
}

void SHFusionUninitialize()
{
    if (g_hActCtx != INVALID_HANDLE_VALUE)
    {
        NT5_ReleaseActCtx(g_hActCtx);
        g_hActCtx = INVALID_HANDLE_VALUE;
    }
}


HMODULE SHFusionLoadLibrary(LPCTSTR lpLibFileName)
{
    HMODULE hmod;
    ENTERCONTEXT(NULL)
    hmod = LoadLibrary(lpLibFileName);
    LEAVECONTEXT

    return hmod;
}

HWND SHFusionCreateWindow(LPCTSTR lpClassName, LPCTSTR lpWindowName, DWORD dwStyle,
                          int x, int y, int nWidth, int nHeight, HWND hWndParent, 
                          HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
{
    HWND hwnd;
    ENTERCONTEXT(NULL)
    
    VerifyComctl32Loaded();

    hwnd = CreateWindow(lpClassName, lpWindowName, dwStyle,
                      x, y, nWidth, nHeight, hWndParent, 
                      hMenu, hInstance, lpParam);
    LEAVECONTEXT
    return hwnd;
}

HWND SHFusionCreateWindowEx(DWORD dwExStyle, LPCTSTR lpClassName, LPCTSTR lpWindowName, 
                            DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, 
                            HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
{
    HWND hwnd;

    ENTERCONTEXT(NULL)
    VerifyComctl32Loaded();

    hwnd = CreateWindowEx(dwExStyle, lpClassName, lpWindowName, 
                            dwStyle, x, y, nWidth, nHeight, hWndParent, 
                            hMenu, hInstance, lpParam);
    LEAVECONTEXT
    return hwnd;
}

HWND SHNoFusionCreateWindowEx(DWORD dwExStyle, LPCTSTR lpClassName, LPCTSTR lpWindowName, 
                            DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, 
                            HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
{
    // DO NOT ACTIVATE A MANIFEST.
    HWND hwnd;
    VerifyComctl32Loaded();
        
    hwnd = CreateWindowEx(dwExStyle, lpClassName, lpWindowName, 
                            dwStyle, x, y, nWidth, nHeight, hWndParent, 
                            hMenu, hInstance, lpParam);
    return hwnd;
}


HWND SHFusionCreateDialogIndirect(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, 
                                  HWND hWndParent, DLGPROC lpDialogFunc)
{
    HWND hwnd;

    ENTERCONTEXT(NULL)
    VerifyComctl32Loaded();
    
    hwnd = CreateDialogIndirect(hInstance, lpTemplate, hWndParent, lpDialogFunc);
    LEAVECONTEXT
    return hwnd;
}

HWND SHFusionCreateDialogParam(HINSTANCE hInstance, LPCTSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    HWND hwnd;

    ENTERCONTEXT(NULL)
    VerifyComctl32Loaded();
    
    hwnd = CreateDialogParam(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
    LEAVECONTEXT
    return hwnd;
}

HWND SHFusionCreateDialogIndirectParam(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, 
                                       DLGPROC lpDialogFunc, LPARAM lParamInit)
{
    HWND hwnd;
    
    ENTERCONTEXT(NULL)
    VerifyComctl32Loaded();
    
    hwnd = CreateDialogIndirectParam(hInstance, lpTemplate, hWndParent, 
                                       lpDialogFunc, lParamInit);
    LEAVECONTEXT
    return hwnd;
}

HWND SHNoFusionCreateDialogIndirectParam(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, 
                                       DLGPROC lpDialogFunc, LPARAM lParamInit)
{
    HWND hwnd;

    VerifyComctl32Loaded();

    hwnd = CreateDialogIndirectParam(hInstance, lpTemplate, hWndParent, 
                                       lpDialogFunc, lParamInit);
    return hwnd;
}

INT_PTR SHFusionDialogBoxIndirectParam(HINSTANCE hInstance, LPCDLGTEMPLATE hDialogTemplate, HWND hWndParent, 
                                            DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    INT_PTR i;

    ENTERCONTEXT(0)
    VerifyComctl32Loaded();

    i = DialogBoxIndirectParam(hInstance, hDialogTemplate, hWndParent, 
                                            lpDialogFunc, dwInitParam);
    LEAVECONTEXT
    return i;

}

INT_PTR SHFusionDialogBoxParam(HINSTANCE hInstance, LPCTSTR lpTemplateName, HWND hWndParent, 
                               DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    INT_PTR i;

    ENTERCONTEXT(0)
    VerifyComctl32Loaded();
    
    i = DialogBoxParam(hInstance, lpTemplateName, hWndParent, 
                                       lpDialogFunc, dwInitParam);
    LEAVECONTEXT
    return i;
}

ATOM SHFusionRegisterClass(CONST WNDCLASS *lpWndClass)
{
    ATOM a;
    ENTERCONTEXT(0)
    a = RegisterClass(lpWndClass);
    LEAVECONTEXT
    return a;
}
 
ATOM SHFusionRegisterClassEx(CONST WNDCLASSEX *lpwcx)
{
    ATOM a;
    ENTERCONTEXT(0)
    a = RegisterClassEx(lpwcx);
    LEAVECONTEXT
    return a;
}

BOOL SHFusionGetClassInfo(HINSTANCE hInstance, LPCTSTR lpClassName, LPWNDCLASS lpWndClass)
{
    BOOL f;
    ENTERCONTEXT(FALSE)
    f = GetClassInfo(hInstance, lpClassName, lpWndClass);
    LEAVECONTEXT
    return f;
}

BOOL SHFusionGetClassInfoEx(HINSTANCE hinst, LPCTSTR lpszClass, LPWNDCLASSEX lpwcx)
{
    BOOL f;
    ENTERCONTEXT(FALSE)
    f = GetClassInfoEx(hinst, lpszClass, lpwcx);
    LEAVECONTEXT
    return f;
}

STDAPI SHSquirtManifest(HINSTANCE hInst, UINT uIdManifest, LPTSTR pszPath)
{
    HRESULT hr = E_FAIL;
    char szManifest[2048];  // Comctl32 has a long manifest.

    if (LoadStringA(hInst, uIdManifest, szManifest, ARRAYSIZE(szManifest)))
    {
        HANDLE hFile;

        SetFileAttributes(pszPath, FILE_ATTRIBUTE_NORMAL);
        
        hFile = CreateFile(pszPath, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY, NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            DWORD dw = lstrlenA(szManifest) * sizeof(char);
            if (WriteFile(hFile, szManifest, dw, &dw, NULL))
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }

            CloseHandle(hFile);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\shguid\makefile.inc ===
$(CCSHELL_DIR)\lib\$O\shguid.lib: $(O)\shguid.obj
    -$(LIB_NAME) $(LIBRARIAN_FLAGS) -out:$@ $**

$(CCSHELL_DIR)\lib\$O\shguidp.lib: $(O)\shguidp.obj
    -$(LIB_NAME) $(LIBRARIAN_FLAGS) -out:$@ $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\shguid\shguid.c ===
#define INITGUID
#include <initguid.h>

#define GUID_DEFS_ONLY
#include <shlguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\shguid\shguidp.c ===
#include <initguid.h>

#include <shlguidp.h>
#include <shguidp.h>
#include <shdguid.h>
#include <sfview.h>
#include <msluguid.h>
#include <adoid.h>
#include "theme_i.c"
#include "shpriv_i.c"
#include "shimgvw_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\inc\w95trace.c ===
// Copyright (c) 1996-1999 Microsoft Corporation


/*
    Implementation of Win95 tracing facility to mimic that of NT. Works on both.
*/

#pragma warning(disable:4201)	// allows nameless structs and unions
#pragma warning(disable:4514)	// don't care when unreferenced inline functions are removed
#pragma warning(disable:4706)	// we are allowed to assign within a conditional


#include "windows.h"
#include <stdio.h>
#include <stdarg.h>
#include <process.h>
#include "w95trace.h"


#if defined( _DEBUG ) ||defined( DEBUG ) || defined( DBG )

#ifdef __cplusplus
extern "C" {
#endif

static HANDLE g_hSpewFile = INVALID_HANDLE_VALUE;

__inline BOOL TestMutex()
{
    HANDLE hTestMutex = OpenMutex( SYNCHRONIZE, FALSE, TEXT("oleacc-msaa-use-dbwin") );
    if( ! hTestMutex )
        return FALSE;
    CloseHandle( hTestMutex );
    return TRUE;
}

void OutputDebugStringW95( LPCTSTR lpOutputString, ...)
{
    // Only produce output if this mutex is set...
    if (TestMutex())
	{
        HANDLE heventDBWIN;  /* DBWIN32 synchronization object */
        HANDLE heventData;   /* data passing synch object */
        HANDLE hSharedFile;  /* memory mapped file shared data */
        LPTSTR lpszSharedMem;
        TCHAR achBuffer[500];

        /* create the output buffer */
        va_list args;
        va_start(args, lpOutputString);
        wvsprintf(achBuffer, lpOutputString, args);
        va_end(args);

        /* 
            Do a regular OutputDebugString so that the output is 
            still seen in the debugger window if it exists.

            This ifdef is necessary to avoid infinite recursion 
            from the inclusion of W95TRACE.H
        */
#ifdef UNICODE
        OutputDebugStringW(achBuffer);
#else
        OutputDebugStringA(achBuffer);
#endif

        /* bail if it's not Win95 */
        {
            OSVERSIONINFO VerInfo;
            VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
            GetVersionEx(&VerInfo);
            if ( VerInfo.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS )
                return;
        }

        /* make sure DBWIN is open and waiting */
        heventDBWIN = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_BUFFER_READY"));
        if ( !heventDBWIN )
        {
            //MessageBox(NULL, TEXT("DBWIN_BUFFER_READY nonexistent"), NULL, MB_OK);
            return;            
        }

        /* get a handle to the data synch object */
        heventData = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_DATA_READY"));
        if ( !heventData )
        {
            // MessageBox(NULL, TEXT("DBWIN_DATA_READY nonexistent"), NULL, MB_OK);
            CloseHandle(heventDBWIN);
            return;            
        }
    
        hSharedFile = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE, 0, 4096, TEXT("DBWIN_BUFFER"));
        if (!hSharedFile) 
        {
            //MessageBox(NULL, TEXT("DebugTrace: Unable to create file mapping object DBWIN_BUFFER"), TEXT("Error"), MB_OK);
            CloseHandle(heventDBWIN);
            CloseHandle(heventData);
            return;
        }

        lpszSharedMem = (LPTSTR)MapViewOfFile(hSharedFile, FILE_MAP_WRITE, 0, 0, 512);
        if (!lpszSharedMem) 
        {
            //MessageBox(NULL, "DebugTrace: Unable to map shared memory", "Error", MB_OK);
            CloseHandle(heventDBWIN);
            CloseHandle(heventData);
            return;
        }

        /* wait for buffer event */
        WaitForSingleObject(heventDBWIN, INFINITE);

        /* write it to the shared memory */
        *((LPDWORD)lpszSharedMem) = _getpid();
        wsprintf(lpszSharedMem + sizeof(DWORD), TEXT("%s"), achBuffer);

        /* signal data ready event */
        SetEvent(heventData);

        /* clean up handles */
        CloseHandle(hSharedFile);
        CloseHandle(heventData);
        CloseHandle(heventDBWIN);
	}
    return;
}
void SpewOpenFile(LPCTSTR pszSpewFile)
{
#ifdef UNICODE
    // Only produce output if this mutex is set...
    if (g_hSpewFile == INVALID_HANDLE_VALUE && TestMutex())
    {
        TCHAR szSpewFile[MAX_PATH];
        GetTempPath(MAX_PATH, szSpewFile);
        if (lstrlen(szSpewFile)+lstrlen(pszSpewFile) >= MAX_PATH)
        {
            MessageBox(NULL, TEXT("SpewOpenFile:  Name will be longer than MAX_PATH"), TEXT("OOPS"), MB_OK);
            return;
        }
        lstrcat(szSpewFile, pszSpewFile);
        g_hSpewFile = CreateFile(szSpewFile, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == g_hSpewFile)
        {
//            MessageBox(NULL, TEXT("SpewOpenFile:  Unable to open spew file"), TEXT("Error"), MB_OK);
        }
    }
#endif
}
void SpewToFile( LPCTSTR lpOutputString, ...)
{
#ifdef UNICODE
    if (g_hSpewFile != INVALID_HANDLE_VALUE && TestMutex())
    {
        TCHAR achBuffer[1025];
        CHAR achAnsiBuf[500];
        DWORD dwcBytesWr, dwcBytes;
        va_list args;
        va_start(args, lpOutputString);
        wvsprintf(achBuffer, lpOutputString, args);
        dwcBytes = WideCharToMultiByte(CP_ACP, 0, achBuffer, -1, achAnsiBuf, sizeof(achAnsiBuf)*sizeof(CHAR), NULL, NULL);
        if (!WriteFile(g_hSpewFile, achAnsiBuf, dwcBytes-1, &dwcBytesWr, NULL))
        {
//            MessageBox(NULL, TEXT("SpewToFile:  Unable to write to spew file"), TEXT("Error"), MB_OK);
        }
        va_end(args);
    }
#endif
}
void SpewCloseFile()
{
#ifdef UNICODE
    if (g_hSpewFile != INVALID_HANDLE_VALUE && TestMutex())
        CloseHandle(g_hSpewFile);
#endif
}
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skdll\skdll.c ===
/*--------------------------------------------------------------
 *
 * FILE:			SKEYDLL.C
 *
 * PURPOSE:		    The file contains the SerialKeys DLL Functions
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *------------------------------------------------------------*/

#include	"windows.h"
#include	"..\skeys\sk_dllif.h"
#include	"..\skeys\sk_dll.h"
#include	"..\skeys\sk_reg.h"
#include	"skeys.h"
#include <malloc.h>
#include "w95trace.c"

#define ARRAY_SIZE(a)      (sizeof(a) / sizeof((a)[0]))

#define RUNNINGEVENT TEXT("SkeysRunning")
#define ONE_MINUTE (60 * 1000)

static BOOL SerialKeysInstall(void);
static BOOL IsSerialKeysRunning();
static BOOL IsServiceStartAllowed();
static BOOL WaitForServiceRunning();


/*---------------------------------------------------------------
 *
 * FUNCTION	int APIENTRY LibMain
 *
 *	TYPE		Global
 *
 * PURPOSE		LibMain is called by Windows when
 *				the DLL is initialized, Thread Attached, and other times.
 *				Refer to SDK documentation, as to the different ways this
 *				may be called.
 *
 *				The LibMain function should perform additional initialization
 *				tasks required by the DLL.  In this example, no initialization
 *				tasks are required.  LibMain should return a value of 1 if
 *				the initialization is successful.
 *
 * INPUTS	 
 *
 * RETURNS		TRUE - Transfer Ok
 *				FALSE- Transfer Failed
 *
 *---------------------------------------------------------------*/
INT  APIENTRY LibMain(HANDLE hInst, DWORD ul_reason_being_called, LPVOID lpReserved)
{
	return 1;

	UNREFERENCED_PARAMETER(hInst);
	UNREFERENCED_PARAMETER(ul_reason_being_called);
	UNREFERENCED_PARAMETER(lpReserved);
}


/*---------------------------------------------------------------
 *
 * FUNCTION	void SkeyGetRegistryValues()
 *
 *	TYPE		Global
 *
 * PURPOSE		Reads the values from the registry into the 
 *              SerialKeys structure
 *	
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static BOOL SkeyGetRegistryValues(HKEY hkey, LPSERIALKEYS psk)
{
	LONG lErr;
	DWORD dwType;
	DWORD cbData;
	
	psk->iPortState = 0;
	psk->iActive = 0;

	psk->dwFlags = 0;
    cbData = sizeof(psk->dwFlags);

	lErr = RegQueryValueEx(
			hkey,
			REG_FLAGS,
			0,
			&dwType,
			(LPBYTE)&psk->dwFlags,
			&cbData);

	if (ERROR_SUCCESS != lErr || dwType != REG_DWORD)
	{
		psk->dwFlags = 0;
	}
	
	psk->dwFlags |= SERKF_AVAILABLE;

	if (NULL != psk->lpszActivePort)
	{
		cbData = MAX_PATH * sizeof(*psk->lpszActivePort);
		lErr = RegQueryValueEx(
				hkey,
				REG_ACTIVEPORT,
				0,
				&dwType,
				(LPBYTE)psk->lpszActivePort,
				&cbData);

		psk->lpszActivePort[ MAX_PATH - 1 ] = '\0'; // ports are all MAX_PATH tchars
		
		if (ERROR_SUCCESS != lErr || dwType != REG_SZ)
		{
			lstrcpy(psk->lpszActivePort, TEXT("COM1"));
		}
	}

	if (NULL != psk->lpszPort)
	{
        cbData = MAX_PATH * sizeof(*psk->lpszPort);
		lErr = RegQueryValueEx(
				hkey,
				REG_PORT,
				0,
				&dwType,
				(LPBYTE)psk->lpszPort,
				&cbData);

		psk->lpszPort[ MAX_PATH - 1 ] = '\0'; // ports are all MAX_PATH tchars
		
		if (ERROR_SUCCESS != lErr || dwType != REG_SZ)
		{
			lstrcpy(psk->lpszPort, TEXT("COM1"));
		}
    }				

    cbData = sizeof(psk->iBaudRate);
	lErr = RegQueryValueEx(
			hkey,
			REG_BAUD,
			0,&dwType,
			(LPBYTE)&psk->iBaudRate,
			&cbData);

	if (ERROR_SUCCESS != lErr || dwType != REG_DWORD)
	{
		psk->iBaudRate = 300;
	}
				
	return TRUE;
}


/*---------------------------------------------------------------
 *
 * FUNCTION	BOOL SkeyGetUserValues()
 *
 *	TYPE		Local
 *
 * PURPOSE		Read the registery an collect the data for the current
 *				user.
 *	
 * RETURNS		TRUE - User wants Serial Keys Enabled
 *				FALSE- User wants Serial Keys Disabled
 *
 *---------------------------------------------------------------*/
BOOL SkeyGetUserValues(LPSERIALKEYS psk)
{
	BOOL fOk = FALSE;
    HKEY  hkey;
	DWORD dwRet;
    DWORD dwDisposition;

     dwRet = RegCreateKeyEx( HKEY_CURRENT_USER,
            TEXT("Control Panel\\Accessibility\\SerialKeys"),
            0,
            NULL,                // CLASS NAME??
            0,                   // by default is non-volatile
            KEY_READ,
            NULL,                // default security descriptor
            &hkey,
            &dwDisposition);    // yes we throw this away

    if (ERROR_SUCCESS == dwRet)
	{
		fOk = SkeyGetRegistryValues(hkey, psk);
		RegCloseKey(hkey);
	}
	if (fOk)
	{
		// Not available unless the service is running or this
		// user can start it
		if (IsSerialKeysRunning() || IsServiceStartAllowed())
		{
			psk->dwFlags |= SERKF_AVAILABLE;
		}
		else
		{
			psk->dwFlags &= ~SERKF_AVAILABLE;
		}
	}
	return(fOk);
}


/*---------------------------------------------------------------
 *
 * FUNCTION	void SetRegistryValues()
 *
 *	TYPE		Global
 *
 * PURPOSE		Writes the values in the SerialKeys structure to
 *				the Registry.
 *	
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static BOOL SkeySetRegistryValues(HKEY hkey, LPSERIALKEYS psk)
{
	LONG lErr;
	BOOL fOk;
	DWORD dwFlags;

	dwFlags = psk->dwFlags | SERKF_AVAILABLE;
	lErr = RegSetValueEx(			// Write dwFlags
			hkey,
			REG_FLAGS,
			0,REG_DWORD,
			(CONST LPBYTE)&dwFlags,
			sizeof(DWORD));

    fOk = (ERROR_SUCCESS == lErr);

	if (fOk)
	{
		lErr = RegSetValueEx(			// Write Active Port
				hkey,
				REG_ACTIVEPORT,
				0,REG_SZ,
				(CONST LPBYTE) psk->lpszActivePort,
				(NULL == psk->lpszActivePort) ? 0 : 
					(lstrlen(psk->lpszActivePort) + 1) * 
						sizeof(*psk->lpszActivePort));
					
        fOk = (ERROR_SUCCESS == lErr);
    }				

	if (fOk)
	{
		lErr = RegSetValueEx(			// Write Active Port
				hkey,
				REG_PORT,
				0,REG_SZ,
				(CONST LPBYTE)psk->lpszPort,
				(NULL == psk->lpszPort) ? 0 : 
					(lstrlen(psk->lpszPort) + 1) * sizeof(*psk->lpszPort));
					
        fOk = (ERROR_SUCCESS == lErr);
    }				

	if (fOk)
	{
		lErr = RegSetValueEx(			// Write Active Port
				hkey,
				REG_BAUD,
				0,REG_DWORD,
				(CONST LPBYTE) &psk->iBaudRate,
				sizeof(psk->iBaudRate));

        fOk = (ERROR_SUCCESS == lErr);
    }				

	return fOk;
}


/*---------------------------------------------------------------
 *
 * FUNCTION	void SetUserValues()
 *
 *	TYPE		Global
 *
 * PURPOSE		This function writes out information to the
 *				registry.
 *	
 * INPUTS		None
 *
 * RETURNS		TRUE - Write Successful
 *				FALSE- Write Failed
 *
 *---------------------------------------------------------------*/
BOOL SkeySetUserValues(LPSERIALKEYS psk)
{
	BOOL fOk = FALSE;
    HKEY  hkey;
	DWORD dwRet;
    DWORD dwDisposition;

    dwRet = RegCreateKeyEx(
			HKEY_CURRENT_USER,
	        TEXT("Control Panel\\Accessibility\\SerialKeys"),
            0,
            NULL,                // class name
            REG_OPTION_NON_VOLATILE,
            KEY_READ | KEY_WRITE,
            NULL,                // default security descriptor
            &hkey,
            &dwDisposition);    // yes we throw this away

    if (ERROR_SUCCESS == dwRet)
	{
	    fOk = SkeySetRegistryValues(hkey, psk);
		RegCloseKey(hkey);
	}
	return(fOk);
}

#if 0 // This old code is no longer needed ////////////////////////////////////
/*---------------------------------------------------------------
 *
 * FUNCTION	BOOL IsSerialKeysInstalled();
 *
 *	TYPE		Local
 *
 * PURPOSE		This function passes the information from the 
 *				Serial Keys application to the Server
 *
 * INPUTS	 	None
 *
 * RETURNS		TRUE - SerialKeys is Installed
 *				FALSE- SerialKeys Not Installed
 *
 *---------------------------------------------------------------*/
static BOOL IsSerialKeysInstalled()
{

	SC_HANDLE   schService = NULL;
	SC_HANDLE   schSCManager = NULL;

	BOOL fOk = FALSE;
	//
	// Check if the Serial Keys Service is installed
	schSCManager = OpenSCManager
	(
		NULL,                   // machine (NULL == local)
		NULL,                   // database (NULL == default)
		SC_MANAGER_ALL_ACCESS   // access required
	);

	if (NULL != schSCManager)
	{
		schService = OpenService(schSCManager, "SerialKeys", SERVICE_ALL_ACCESS);
			
		if (NULL != schService)
		{
			CloseServiceHandle(schService);
			fOk = TRUE;
        }

		CloseServiceHandle(schSCManager);
    }

	return fOk;
}
#endif ////////////////////////////////////////////////////////////////////////

BOOL IsSerialKeysRunning()
{
	BOOL fRunning = FALSE;
    HANDLE hEventSkeysServiceRunning;

	hEventSkeysServiceRunning = OpenEvent(SYNCHRONIZE, FALSE, RUNNINGEVENT);
    if (NULL != hEventSkeysServiceRunning)
	{
		DWORD dwWait;

		dwWait = WaitForSingleObject(hEventSkeysServiceRunning, 0);

		fRunning = (WAIT_OBJECT_0 == dwWait);
        CloseHandle(hEventSkeysServiceRunning);
    }
	return fRunning;
}


BOOL IsServiceStartAllowed()
{
	BOOL fServiceStartAllowed = FALSE;

	SC_HANDLE   schSCManager = NULL;

	schSCManager = OpenSCManager(   // Open Service Manager
		NULL,                       // machine (NULL == local)
	    NULL,                       // database (NULL == default)
		SC_MANAGER_CREATE_SERVICE);     // access required

	if (NULL != schSCManager)  // Did Open Service succeed?
	{
        CloseServiceHandle(schSCManager);
		fServiceStartAllowed = TRUE;
	}

	return fServiceStartAllowed;
}


BOOL SkeyServiceRequest(UINT uAction, LPSERIALKEYS psk, BOOL fWinIni)
{
	BOOL fOk = FALSE;
    SKEYDLL SKeyDLL;
	DWORD bytesRead;

	if (IsSerialKeysRunning())
	{
		memset(&SKeyDLL, 0, sizeof(SKeyDLL));
		SKeyDLL.Message = uAction;
		if (psk->lpszActivePort != NULL)
		{
			strcpy(SKeyDLL.szActivePort,psk->lpszActivePort);
		}

		if (psk->lpszPort != NULL)
		{
			strcpy(SKeyDLL.szPort,psk->lpszPort);
		}

		SKeyDLL.dwFlags		= psk->dwFlags | SERKF_AVAILABLE;
		SKeyDLL.iBaudRate	= psk->iBaudRate;
		SKeyDLL.iPortState	= psk->iPortState;
		SKeyDLL.iSave 		= fWinIni;

		fOk = CallNamedPipe(
				SKEY_NAME, 						// Pipe name
				&SKeyDLL, 
				sizeof(SKeyDLL),
				&SKeyDLL, 
				sizeof(SKeyDLL),
				&bytesRead, 
				NMPWAIT_USE_DEFAULT_WAIT);

		if (fOk)
		{
			if (psk->lpszActivePort != NULL)
			{
				strcpy(psk->lpszActivePort,SKeyDLL.szActivePort);
			}

			if (psk->lpszPort != NULL)
			{
				strcpy(psk->lpszPort,SKeyDLL.szPort);
			}

			psk->dwFlags 		= SKeyDLL.dwFlags | SERKF_AVAILABLE;	  
			psk->iBaudRate 		= SKeyDLL.iBaudRate; 
			psk->iPortState 	= SKeyDLL.iPortState;
		}
	}
    return fOk;
}


BOOL SkeyInitUser()
{
    BOOL fOk;
	SERIALKEYS sk;
	TCHAR szActivePort[MAX_PATH]; // all ports are expected to be MAX_PATH tchars
	TCHAR szPort[MAX_PATH];           // all ports are expected to be MAX_PATH tchars


	memset(&sk, 0, sizeof(sk));
	sk.cbSize = sizeof(sk);
	sk.lpszActivePort = szActivePort;
	sk.lpszPort = szPort;

	fOk = SkeyGetUserValues(&sk);
	if (fOk)
	{
		fOk = SkeyServiceRequest(SPI_SETSERIALKEYS, &sk, FALSE);
	}
	return fOk;
}


/*---------------------------------------------------------------
 *
 * FUNCTION	int APIENTRY SKEY_SystemParameterInfo
 *
 *	TYPE		Global
 *
 * PURPOSE		This function passes the information from the 
 *				Serial Keys application to the Server
 *
 * INPUTS	 
 *
 * RETURNS		TRUE - Transfer Ok
 *				FALSE- Transfer Failed
 *
 *---------------------------------------------------------------*/
BOOL APIENTRY SKEY_SystemParametersInfo(
		UINT uAction, 
		UINT uParam, 
		LPSERIALKEYS psk, 
		BOOL fWinIni)
{
	BOOL fOk;
	BOOL fStarted;

	fOk = ((uAction ==  SK_SPI_INITUSER) || 
		   (NULL != psk && (0 != psk->cbSize)));
    
    if (fOk)
	{
		switch (uAction)			
		{
		case SPI_SETSERIALKEYS:
			fOk = SkeySetUserValues(psk);
            
			if (fOk && (psk->dwFlags & SERKF_SERIALKEYSON) && IsServiceStartAllowed())
			{
				fOk = SerialKeysInstall();
			}

			if (fOk && IsSerialKeysRunning())
			{
	            fOk = SkeyInitUser();
			}
			
			break;

		case SPI_GETSERIALKEYS:	
			fOk = SkeyGetUserValues(psk);
			if (fOk && (psk->dwFlags & SERKF_SERIALKEYSON) && 
				!IsSerialKeysRunning() && IsServiceStartAllowed())
			{
				fOk = SerialKeysInstall();
			}

			if (fOk && IsSerialKeysRunning())
			{
	            fOk = SkeyInitUser();
			}

			break;

        case SK_SPI_INITUSER:
			// give the service a chance to start
			fStarted = WaitForServiceRunning();
			
			if (!fStarted)
			{
				// service does not seem to be running
				// let's try to start it
				fOk = SkeyGetUserValues(psk);

				if (fOk && (psk->dwFlags & SERKF_SERIALKEYSON) && 
					!IsSerialKeysRunning() && IsServiceStartAllowed())
				{
					SerialKeysInstall();
				}

				if (IsSerialKeysRunning())
				{
					fOk = SkeyInitUser();
				}
			}
			break;

		default:
			fOk = FALSE;			// No - Fail
		}
	}
    return fOk;
}

/*****************************************************************************/
/* WaitForServiceRunning - wait up to one minute for the SerialKeys service
 * to signal it is ready.  CreateEvent has been called by SKeys.exe before
 * this function is executed.
 */
BOOL WaitForServiceRunning()
{
	BOOL fOk = FALSE;
    HANDLE hEventSkeysServiceRunning = OpenEvent(SYNCHRONIZE, FALSE, RUNNINGEVENT);
    
    if (hEventSkeysServiceRunning)
	{
        DWORD dwWait = WaitForSingleObject(hEventSkeysServiceRunning, ONE_MINUTE);
        CloseHandle(hEventSkeysServiceRunning);

		fOk = (WAIT_OBJECT_0 == dwWait);
    }

	return fOk;
}

/****************************************************************************/

BOOL SerialKeysInstall(void)
{
    BOOL fStarted = FALSE;
	SERVICE_STATUS  ssStatus;
	DWORD   dwOldCheckPoint;
	TCHAR   szFileName[MAX_PATH + 1];

	SC_HANDLE   schService = NULL;
	SC_HANDLE   schSCManager = NULL;

	schSCManager = OpenSCManager(   // Open Service Manager
		NULL,                       // machine (NULL == local)
	    NULL,                       // database (NULL == default)
		SC_MANAGER_ALL_ACCESS);     // access required

	if (NULL != schSCManager)  // Did Open Service succeed?
	{
	    schService = OpenService(
			    schSCManager ,
			    __TEXT("SerialKeys"),
			    SERVICE_ALL_ACCESS);

	    if (NULL != schService)
		{			
			// insure the serivce is auto-start

			ChangeServiceConfig(
				schService,
				SERVICE_WIN32_OWN_PROCESS,
				SERVICE_AUTO_START,		// when to start service 
				SERVICE_NO_CHANGE,		// severity if service fails to start 
				NULL,					// pointer to service binary file name 
				NULL,					// pointer to load ordering group name 
				NULL,					// pointer to variable to get tag identifier 
				NULL,					// pointer to array of dependency names 
				NULL,					// pointer to account name of service 
				NULL,					// pointer to password for service account  
				__TEXT("SerialKeys"));	// name to display 
		}
		else
		{
			if (!GetWindowsDirectory(szFileName, ARRAY_SIZE(szFileName)))
				return FALSE;	// PREFIX #113665 don't use szFileName if call fails

			lstrcat(szFileName, __TEXT("\\system32\\skeys.exe"));

			// Is Service File installed?
			if (0xFFFFFFFF != GetFileAttributes(szFileName)) 
			{       
				schService = CreateService(
					schSCManager,               // SCManager database
					__TEXT("SerialKeys"),       // name of service
					__TEXT("SerialKeys"),       // name to display 
					SERVICE_ALL_ACCESS,         // desired access
					SERVICE_WIN32_OWN_PROCESS,  // service type
					SERVICE_AUTO_START,         // start type
					SERVICE_ERROR_NORMAL,       // error control type
					szFileName,                 // service's binary
					NULL,                       // no load ordering group
					NULL,                       // no tag identifier
					NULL,                       // no dependencies
					NULL,                       // LocalSystem account
					NULL);                      // no password
			}
		}
	    if (NULL != schService)
        {
            BOOL fOk = QueryServiceStatus(schService,&ssStatus);
			if (fOk && ssStatus.dwCurrentState != SERVICE_RUNNING)
			{
				static PTSTR pszArg = TEXT("F\0"); // force service to start
				PTSTR apszArg[] = {pszArg, NULL};
				
				if (StartService(schService, 1, apszArg))
				{   
					while(fOk && ssStatus.dwCurrentState != SERVICE_RUNNING)
					{
						dwOldCheckPoint = ssStatus.dwCheckPoint;
						Sleep(max(ssStatus.dwWaitHint, 1000));
						fOk = QueryServiceStatus(schService,&ssStatus);
						fOk = (fOk && (dwOldCheckPoint >= ssStatus.dwCheckPoint));
					}
				}
			}
			fStarted = fOk && (ssStatus.dwCurrentState == SERVICE_RUNNING);
			CloseServiceHandle(schService);
			
			if (fStarted)
			{
				fStarted = WaitForServiceRunning();
			}
        }
        CloseServiceHandle(schSCManager);
    }
    return fStarted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skdll\skeys.h ===
/*--------------------------------------------------------------
 *
 * FILE:			SKEYS.H
 *
 * PURPOSE:			The file contains data structures for the 
 *					transmission of information between the 
 *					Serial Keys Application and and the DLL.
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *------------------------------------------------------------*/

#define SK_SPI_INITUSER -1

BOOL APIENTRY SKEY_SystemParametersInfo(
    UINT uAction, UINT uParam, LPSERIALKEYS lpvParam, BOOL fWinIni);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\lib\stockthk\rtlmir.cpp ===
/****************************** Module*Header *****************************\
* Module Name: rtlmir.c                                                    *
*                                                                          *
* This module contains all the Right-To-Left (RTL) Mirroring support       *
* routines which are used across the whole IShell project. It abstracts    *
* platform-support routines of RTL mirroring (NT5 and Memphis) and removes *
* linkage depedenency with the Mirroring APIs.                             *
*                                                                          *
* Functions prefixed with Mirror, deal with the new Mirroring APIs         *
*                                                                          *
*                                                                          *
* Created: 01-Feb-1998 8:41:18 pm                                          *
* Author: Samer Arafeh [samera]                                            *
*                                                                          *
* Copyright (c) 1998 Microsoft Corporation                                 *
\**************************************************************************/

#include "..\stock.h"

#if (WINVER < 0x0500)
#error WINVER setting must be >= 0x0500
#endif

#ifndef DS_BIDI_RTL
#define DS_BIDI_RTL  0x8000
#endif

const DWORD dwNoMirrorBitmap = NOMIRRORBITMAP;
const DWORD dwExStyleRTLMirrorWnd = WS_EX_LAYOUTRTL;
const DWORD dwExStyleNoInheritLayout = WS_EX_NOINHERITLAYOUT; 
const DWORD dwPreserveBitmap = LAYOUT_BITMAPORIENTATIONPRESERVED;

/*
 * Remove linkage dependecy for the RTL mirroring APIs, by retreiving
 * their addresses at runtime.
 */
typedef DWORD (WINAPI *PFNGETLAYOUT)(HDC);                   // gdi32!GetLayout
typedef DWORD (WINAPI *PFNSETLAYOUT)(HDC, DWORD);            // gdi32!SetLayout
typedef BOOL  (WINAPI *PFNSETPROCESSDEFLAYOUT)(DWORD);       // user32!SetProcessDefaultLayout
typedef BOOL  (WINAPI *PFNGETPROCESSDEFLAYOUT)(DWORD*);      // user32!GetProcessDefaultLayout
typedef LANGID (WINAPI *PFNGETUSERDEFAULTUILANGUAGE)(void);  // kernel32!GetUserDefaultUILanguage
typedef BOOL (WINAPI *PFNENUMUILANGUAGES)(UILANGUAGE_ENUMPROC, DWORD, LONG_PTR); // kernel32!EnumUILanguages

typedef struct {
    LANGID LangID;
    BOOL   bInstalled;
    } MUIINSTALLLANG, *LPMUIINSTALLLANG;

#ifdef UNICODE
#define ConvertHexStringToInt ConvertHexStringToIntW
#else
#define ConvertHexStringToInt ConvertHexStringToIntA
#endif


/***************************************************************************\
* ConvertHexStringToIntA
*
* Converts a hex numeric string into an integer.
*
* History:
* 04-Feb-1998 samera    Created
\***************************************************************************/
BOOL ConvertHexStringToIntA( CHAR *pszHexNum , int *piNum )
{
    int   n=0L;
    CHAR  *psz=pszHexNum;

  
    for(n=0 ; ; psz=CharNextA(psz))
    {
        if( (*psz>='0') && (*psz<='9') )
            n = 0x10 * n + *psz - '0';
        else
        {
            CHAR ch = *psz;
            int n2;

            if(ch >= 'a')
                ch -= 'a' - 'A';

            n2 = ch - 'A' + 0xA;
            if (n2 >= 0xA && n2 <= 0xF)
                n = 0x10 * n + n2;
            else
                break;
        }
    }

    /*
     * Update results
     */
    *piNum = n;

    return (psz != pszHexNum);
}

/***************************************************************************\
* ConvertHexStringToIntW
*
* Converts a hex numeric string into an integer.
*
* History:
* 14-June-1998 msadek    Created
\***************************************************************************/
BOOL ConvertHexStringToIntW( WCHAR *pszHexNum , int *piNum )
{
    int   n=0L;
    WCHAR  *psz=pszHexNum;

  
    for(n=0 ; ; psz=CharNextW(psz))
    {
        if( (*psz>='0') && (*psz<='9') )
            n = 0x10 * n + *psz - '0';
        else
        {
            WCHAR ch = *psz;
            int n2;

            if(ch >= 'a')
                ch -= 'a' - 'A';

            n2 = ch - 'A' + 0xA;
            if (n2 >= 0xA && n2 <= 0xF)
                n = 0x10 * n + n2;
            else
                break;
        }
    }

    /*
     * Update results
     */
    *piNum = n;

    return (psz != pszHexNum);
}


/***************************************************************************\
* IsBiDiLocalizedSystemEx
*
* returns TRUE if running on a lozalized BiDi (Arabic/Hebrew) NT5 or Memphis.
* Should be called whenever SetProcessDefaultLayout is to be called.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/

BOOL IsBiDiLocalizedSystemEx( LANGID *pLangID )
{
    int           iLCID=0L;
    static TRIBIT s_tbBiDi = TRIBIT_UNDEFINED;
    static LANGID s_langID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    if (s_tbBiDi == TRIBIT_UNDEFINED)
    {
        BOOL bRet = FALSE;
        if(staticIsOS(OS_WIN2000ORGREATER))
        {
            /*
             * Need to use NT5 detection method (Multiligual UI ID)
             */
            s_langID = Mirror_GetUserDefaultUILanguage();

            if(s_langID)
            {
                WCHAR wchLCIDFontSignature[16];
                iLCID = MAKELCID(s_langID, SORT_DEFAULT );

                /*
                 * Let's verify this is a RTL (BiDi) locale. Since reg value is a hex string, let's
                 * convert to decimal value and call GetLocaleInfo afterwards.
                 * LOCALE_FONTSIGNATURE always gives back 16 WCHARs.
                 */

                if( GetLocaleInfoW( iLCID , 
                                    LOCALE_FONTSIGNATURE , 
                                    (WCHAR *) &wchLCIDFontSignature[0] ,
                                    (sizeof(wchLCIDFontSignature)/sizeof(WCHAR))) )
                {
          
                    /* Let's verify the bits we have a BiDi UI locale */
                    if(( wchLCIDFontSignature[7] & (WCHAR)0x0800) && Mirror_IsUILanguageInstalled(s_langID) )
                    {
                        bRet = TRUE;
                    }
                }
            }
        } else {

            /*
             * Check if BiDi-Memphis is running with Lozalized Resources (
             * i.e. Arabic/Hebrew systems) -It should be enabled ofcourse-.
             */
            if( (staticIsOS(OS_WIN98ORGREATER)) && (GetSystemMetrics(SM_MIDEASTENABLED)) )
            {
                HKEY          hKey;

                if( RegOpenKeyExA( HKEY_CURRENT_USER , 
                                   "Control Panel\\Desktop\\ResourceLocale" , 
                                   0, 
                                   KEY_READ, &hKey) == ERROR_SUCCESS) 
                {
                    CHAR szResourceLocale[12];
                    DWORD dwSize = sizeof(szResourceLocale);
                    RegQueryValueExA( hKey , "" , 0 , NULL, (LPBYTE)szResourceLocale , &dwSize );
                    szResourceLocale[(sizeof(szResourceLocale)/sizeof(CHAR))-1] = 0;

                    RegCloseKey(hKey);

                    if( ConvertHexStringToIntA( szResourceLocale , &iLCID ) )
                    {
                        iLCID = PRIMARYLANGID(LANGIDFROMLCID(iLCID));
                        if( (LANG_ARABIC == iLCID) || (LANG_HEBREW == iLCID) )
                        {
                            bRet = TRUE;
                            s_langID = LANGIDFROMLCID(iLCID);
                        }
                    }
                }
            }
        }

        COMPILETIME_ASSERT(sizeof(s_tbBiDi) == sizeof(long));
        //  close multiproc race on startup
        InterlockedExchange((long*)&s_tbBiDi, bRet ? TRIBIT_TRUE : TRIBIT_FALSE);
    }

    if (s_tbBiDi == TRIBIT_TRUE && pLangID)
    {
        *pLangID = s_langID;
    }
    
    return (s_tbBiDi == TRIBIT_TRUE);
}

BOOL IsBiDiLocalizedSystem( void )
{
    return IsBiDiLocalizedSystemEx(NULL);
}

/***************************************************************************\
* IsBiDiLocalizedWin95
*
* returns TRUE if running on a lozalized BiDi (Arabic/Hebrew) Win95.
* Needed for legacy operating system check for needed RTL UI elements
* For example, DefView ListView, TreeView,...etc 
* History:
* 12-June-1998 a-msadek    Created
\***************************************************************************/
BOOL IsBiDiLocalizedWin95(BOOL bArabicOnly)
{
    HKEY  hKey;
    DWORD dwType;
    BOOL  bRet = FALSE;
    CHAR  szResourceLocale[12];
    DWORD dwSize = sizeof(szResourceLocale)/sizeof(CHAR);
    int   iLCID=0L;

         /*
         * Check if BiDi-Win95 is running with Lozalized Resources (
         * i.e. Arabic/Hebrew systems) -It should be enabled ofcourse-.
         */
        if( (staticIsOS(OS_WIN95ORGREATER)) && (!staticIsOS(OS_WIN98ORGREATER)) && (GetSystemMetrics(SM_MIDEASTENABLED)) )
        {

            if( RegOpenKeyExA( HKEY_CURRENT_USER , 
                               "Control Panel\\Desktop\\ResourceLocale" , 
                               0, 
                               KEY_READ, &hKey) == ERROR_SUCCESS) 
            {
                RegQueryValueExA( hKey , "" , 0 , &dwType , (LPBYTE)szResourceLocale , &dwSize );
                szResourceLocale[(sizeof(szResourceLocale)/sizeof(CHAR))-1] = 0;

                RegCloseKey(hKey);

                if( ConvertHexStringToIntA( szResourceLocale , &iLCID ) )
                {
                    iLCID = PRIMARYLANGID(LANGIDFROMLCID(iLCID));
                    //
                    //If bArabicOnly we will return true if it a Arabic Win95 localized. 
                    //
                    if( (LANG_ARABIC == iLCID) || ((LANG_HEBREW == iLCID) && !bArabicOnly ))
                    {
                        bRet = TRUE;
                    }
                }
            }
        }
    
    return bRet;
}

/***************************************************************************\
* Mirror_IsEnabledOS
*
* returns TRUE if the mirroring APIs are enabled on the current OS.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL Mirror_IsEnabledOS( void )
{
    BOOL bRet = FALSE;

    if(staticIsOS(OS_WIN2000ORGREATER))
    {
        bRet = TRUE;
    } else if( staticIsOS(OS_WIN98ORGREATER) && GetSystemMetrics(SM_MIDEASTENABLED)) {
        bRet=TRUE;
    }

    return bRet;
}


/***************************************************************************\
* Mirror_GetUserDefaultUILanguage
*
* Reads the User UI language on NT5
*
* History:
* 22-June-1998 samera    Created
\***************************************************************************/
LANGID Mirror_GetUserDefaultUILanguage( void )
{
    LANGID langId=0;
    static PFNGETUSERDEFAULTUILANGUAGE pfnGetUserDefaultUILanguage=NULL;

    if( NULL == pfnGetUserDefaultUILanguage )
    {
        HMODULE hmod = GetModuleHandleA("KERNEL32");

        if( hmod )
            pfnGetUserDefaultUILanguage = (PFNGETUSERDEFAULTUILANGUAGE)
                                          GetProcAddress(hmod, "GetUserDefaultUILanguage");
    }

    if( pfnGetUserDefaultUILanguage )
        langId = pfnGetUserDefaultUILanguage();

    return langId;
}

/***************************************************************************\
* Mirror_IsUILanguageInstalled
*
* Verifies that the User UI language is installed on W2k
*
* History:
* 14-June-1999 msadek    Created
\***************************************************************************/
BOOL Mirror_IsUILanguageInstalled( LANGID langId )
{

    MUIINSTALLLANG MUILangInstalled = {0};
    MUILangInstalled.LangID = langId;
    
    static PFNENUMUILANGUAGES pfnEnumUILanguages=NULL;

    if( NULL == pfnEnumUILanguages )
    {
        HMODULE hmod = GetModuleHandleA("KERNEL32");

        if( hmod )
            pfnEnumUILanguages = (PFNENUMUILANGUAGES)
                                          GetProcAddress(hmod, "EnumUILanguagesW");
    }

    if( pfnEnumUILanguages )
        pfnEnumUILanguages(Mirror_EnumUILanguagesProc, 0, (LONG_PTR)&MUILangInstalled);

    return MUILangInstalled.bInstalled;
}

/***************************************************************************\
* Mirror_EnumUILanguagesProc
*
* Enumerates MUI installed languages on W2k
* History:
* 14-June-1999 msadek    Created
\***************************************************************************/

BOOL CALLBACK Mirror_EnumUILanguagesProc(LPTSTR lpUILanguageString, LONG_PTR lParam)
{
    int langID = 0;

    ConvertHexStringToInt(lpUILanguageString, &langID);

    if((LANGID)langID == ((LPMUIINSTALLLANG)lParam)->LangID)
    {
        ((LPMUIINSTALLLANG)lParam)->bInstalled = TRUE;
        return FALSE;
    }
    return TRUE;
}


/***************************************************************************\
* Mirror_IsWindowMirroredRTL
*
* returns TRUE if the window is RTL mirrored
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL Mirror_IsWindowMirroredRTL( HWND hWnd )
{
    return (GetWindowLongA( hWnd , GWL_EXSTYLE ) & WS_EX_LAYOUTRTL );
}




/***************************************************************************\
* Mirror_GetLayout
*
* returns TRUE if the hdc is RTL mirrored
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
DWORD Mirror_GetLayout( HDC hdc )
{
    DWORD dwRet=0;
    static PFNGETLAYOUT pfnGetLayout=NULL;

    if( NULL == pfnGetLayout )
    {
        HMODULE hmod = GetModuleHandleA("GDI32");

        if( hmod )
            pfnGetLayout = (PFNGETLAYOUT)GetProcAddress(hmod, "GetLayout");
    }

    if( pfnGetLayout )
        dwRet = pfnGetLayout( hdc );

    return dwRet;
}

DWORD Mirror_IsDCMirroredRTL( HDC hdc )
{
    return (Mirror_GetLayout( hdc ) & LAYOUT_RTL);
}



/***************************************************************************\
* Mirror_SetLayout
*
* RTL Mirror the hdc
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
DWORD Mirror_SetLayout( HDC hdc , DWORD dwLayout )
{
    DWORD dwRet=0;
    static PFNSETLAYOUT pfnSetLayout=NULL;

    if( NULL == pfnSetLayout )
    {
        HMODULE hmod = GetModuleHandleA("GDI32");

        if( hmod )
            pfnSetLayout = (PFNSETLAYOUT)GetProcAddress(hmod, "SetLayout");
    }

    if( pfnSetLayout )
        dwRet = pfnSetLayout( hdc , dwLayout );

    return dwRet;
}

DWORD Mirror_MirrorDC( HDC hdc )
{
    return Mirror_SetLayout( hdc , LAYOUT_RTL );
}


/***************************************************************************\
* Mirror_SetProcessDefaultLayout
*
* Set the process-default layout.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL Mirror_SetProcessDefaultLayout( DWORD dwDefaultLayout )
{
    BOOL bRet=0;
    static PFNSETPROCESSDEFLAYOUT pfnSetProcessDefLayout=NULL;

    if( NULL == pfnSetProcessDefLayout )
    {
        HMODULE hmod = GetModuleHandleA("USER32");

        if( hmod )
            pfnSetProcessDefLayout = (PFNSETPROCESSDEFLAYOUT)
                                     GetProcAddress(hmod, "SetProcessDefaultLayout");
    }

    if( pfnSetProcessDefLayout )
        bRet = pfnSetProcessDefLayout( dwDefaultLayout );

    return bRet;
}

BOOL Mirror_MirrorProcessRTL( void )
{
    return Mirror_SetProcessDefaultLayout( LAYOUT_RTL );
}


/***************************************************************************\
* Mirror_GetProcessDefaultLayout
*
* Get the process-default layout.
*
* History:
* 26-Feb-1998 samera    Created
\***************************************************************************/
BOOL Mirror_GetProcessDefaultLayout( DWORD *pdwDefaultLayout )
{
    BOOL bRet=0;
    static PFNGETPROCESSDEFLAYOUT pfnGetProcessDefLayout=NULL;

    if( NULL == pfnGetProcessDefLayout )
    {
        HMODULE hmod = GetModuleHandleA("USER32");

        if( hmod )
            pfnGetProcessDefLayout = (PFNGETPROCESSDEFLAYOUT)
                                     GetProcAddress(hmod, "GetProcessDefaultLayout");
    }

    if( pfnGetProcessDefLayout )
        bRet = pfnGetProcessDefLayout( pdwDefaultLayout );

    return bRet;
}

BOOL Mirror_IsProcessRTL( void )
{
    DWORD dwDefLayout=0;

    return (Mirror_GetProcessDefaultLayout(&dwDefLayout) && (dwDefLayout&LAYOUT_RTL));
}

////////////////////////////////////////////////////////////////////////////
// Skip_IDorString
//
// Skips string (or ID) and returns the next aligned WORD.
////////////////////////////////////////////////////////////////////////////
PBYTE Skip_IDorString(LPBYTE pb)
{
    LPWORD pw = (LPWORD)pb;

    if (*pw == 0xFFFF)
        return (LPBYTE)(pw + 2);

    while (*pw++ != 0)
        ;

    return (LPBYTE)pw;
}

////////////////////////////////////////////////////////////////////////////
// Skip_DialogHeader
//
// Skips the dialog header and returns the next aligned WORD. 
////////////////////////////////////////////////////////////////////////////
PBYTE Skip_DialogHeader(LPDLGTEMPLATE pdt)
{
    LPBYTE pb;

    pb = (LPBYTE)(pdt + 1);

    // If there is a menu ordinal, add 4 bytes skip it. Otherwise it is a string or just a 0.
    pb = Skip_IDorString(pb);

    // Skip window class and window text, adjust to next word boundary.
    pb = Skip_IDorString(pb);    // class
    pb = Skip_IDorString(pb);    // window text

    // Skip font type, size and name, adjust to next dword boundary.
    if (pdt->style & DS_SETFONT)
    {
        pb += sizeof(WORD);
        pb = Skip_IDorString(pb);
    }
    pb = (LPBYTE)(((ULONG_PTR)pb + 3) & ~3);    // DWORD align

    return pb;
}

////////////////////////////////////////////////////////////////////////////
// EditBiDiDLGTemplate
//
// Edits a dialog template for BiDi stuff.
// Optionally, skipping some controls.
// Works only with DLGTEMPLATE.
////////////////////////////////////////////////////////////////////////////
void EditBiDiDLGTemplate(LPDLGTEMPLATE pdt, DWORD dwFlags, PWORD pwIgnoreList, int cIgnore)
{
    LPBYTE pb;
    UINT cItems;

    if (!pdt)
        return;
    // we should never get an extended template
    ASSERT (((LPDLGTEMPLATEEX)pdt)->wSignature != 0xFFFF);
    
    if(dwFlags & EBDT_NOMIRROR)
    {
        // Turn off the mirroring styles for the dialog.
        pdt->dwExtendedStyle &= ~(WS_EX_LAYOUTRTL | WS_EX_NOINHERITLAYOUT);
    }
    cItems = pdt->cdit;

    // skip DLGTEMPLATE part
    pb = Skip_DialogHeader(pdt);

    while (cItems--)
    {
        UINT cbCreateParams;
        int i = 0;
        BOOL bIgnore = FALSE;

        if(pwIgnoreList && cIgnore)
        {
            for(i = 0;i < cIgnore; i++)
            {
                if((((LPDLGITEMTEMPLATE)pb)->id == *(pwIgnoreList +i)))
                {
                    bIgnore = TRUE;
                }
            }
        }
        
        if((dwFlags & EBDT_NOMIRROR) && !bIgnore)
        {
            // Turn off the mirroring styles for this item.
            ((LPDLGITEMTEMPLATE)pb)->dwExtendedStyle &= ~(WS_EX_LAYOUTRTL | WS_EX_NOINHERITLAYOUT); 
        }    

        if((dwFlags & EBDT_FLIP) && !bIgnore)
        {
            // Note: We do not force RTL reading for the title. The client
            // has the option of doing this via PSH_RTLREADING.
            ((LPDLGITEMTEMPLATE)pb)->x = pdt->cx - (((LPDLGITEMTEMPLATE)pb)->x + ((LPDLGITEMTEMPLATE)pb)->cx);
        }
        pb += sizeof(DLGITEMTEMPLATE);

        // Skip the dialog control class name.
        pb = Skip_IDorString(pb);

        // Look at window text now.
        pb = Skip_IDorString(pb);

        cbCreateParams = *((LPWORD)pb);

        // skip any CreateParams which include the generated size WORD.
        if (cbCreateParams)
            pb += cbCreateParams;

        pb += sizeof(WORD);

        // Point at the next dialog item. (DWORD aligned)
        pb = (LPBYTE)(((ULONG_PTR)pb + 3) & ~3);

        bIgnore = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\inc\w95trace.h ===
/*
    declarations for Win95 tracing facility
*/

#ifndef __TRACEW95__
#define __TRACEW95__



#if defined( _DEBUG ) ||defined( DEBUG ) || defined( DBG )

#define DBPRINTF OutputDebugStringW95

#define DBPRINTF_IF(exp, msg)	{if (!exp) DBPRINTF(msg);}


// redefine all the MFC macros to point to us

#undef  TRACE
#define TRACE   OutputDebugStringW95

#undef  TRACE0
#define TRACE0   OutputDebugStringW95

#undef  TRACE1
#define TRACE1   OutputDebugStringW95

#undef  TRACE2
#define TRACE2   OutputDebugStringW95

#undef  TRACE3
#define TRACE3   OutputDebugStringW95

// redefine OutputDebugString so that it works with 
// API calls
#undef OutputDebugString
#define OutputDebugString   OutputDebugStringW95


// function declarations
#ifdef __cplusplus
extern "C" {
#endif
void OutputDebugStringW95( LPCTSTR lpOutputString, ... );
void SpewOpenFile(LPCTSTR pszSpewFile);
void SpewToFile( LPCTSTR lpOutputString, ...);
void SpewCloseFile();
#ifdef __cplusplus
}
#endif



#else
// avoid warning:
// error C4353: nonstandard extension used: constant 0 as function expression.
// Use '__noop' function intrinsic instead
  #define DBPRINTF        __noop
  #define DBPRINTF_IF(exp, msg)
  #define SpewOpenFile    __noop
  #define SpewToFile      __noop
  #define SpewCloseFile   __noop
#endif  // _DEBUG || DEBUG || DBG


#endif  //__TRACEW95__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\drivers.h ===
/****************************************************************************

	DRIVERS.H

	This file defines the external calls and structures of the keyboard and 
	mouse drivers.

****************************************************************************/

typedef	struct tagKBDFILTERKEYSPARM {
	BYTE	fFilterKeysOn;		/* boolean 0 = false, 1 = true */
	BYTE	fOn_Off_Feedback;	/* boolean 0 = false, 1 = true */
	BYTE	fUser_SetUp_Option1;	/* boolean 0 = false, 1 = true */
	BYTE	fUser_SetUp_Option2;	/* boolean 0 = false, 1 = true */
	int		wait_ticks;			/* time till accept key 18.2 ticks/sec */
	int		delay_ticks;		/* delay to repeat		18.2 ticks/sec */
	int		repeat_ticks;		/* repeat rate			18.2 ticks/sec */
	int		bounce_ticks;		/* debounce rate		18.2 ticks/sec */
	BYTE	fRecovery_On;		/* boolean 0 = false, 1 = true */ 
	BYTE	fclick_on;			/* boolean 0 = false, 1 = true */ 
} KBDFILTERKEYSPARM;

extern	void FAR PASCAL Get_FilterKeys_Param(KBDFILTERKEYSPARM FAR *);	/* part of keyboard driver */
extern	void FAR PASCAL Set_FilterKeys_Param(KBDFILTERKEYSPARM FAR *);	/* part of keyboard driver */

typedef	struct tagKBDSTICKEYSPARM {
	BYTE	fSticKeysOn;		/* boolean 0 = false, 1 = true */
	BYTE	fOn_Off_Feedback;	/* boolean 0 = false, 1 = true */
	BYTE	fAudible_Feedback;	/* boolean 0 = false, 1 = true */
	BYTE	fTriState;			/* boolean 0 = false, 1 = true */
	BYTE	fTwo_Keys_Off;		/* boolean 0 = false, 1 = true */
	BYTE	fDialog_Stickeys_Off;	/* boolean 0 = false, 1 = true */
} KBDSTICKEYSPARM;

extern	void FAR PASCAL Get_SticKeys_Param(KBDSTICKEYSPARM FAR *);	/* part of keyboard driver */
extern	void FAR PASCAL Set_SticKeys_Param(KBDSTICKEYSPARM FAR *);	/* part of keyboard driver */

typedef	struct tagKBDMOUSEKEYSPARM {
	BYTE	fMouseKeysOn;		/* boolean 0 = false, 1 = true */
	BYTE	fOn_Off_Feedback;	/* boolean 0 = false, 1 = true */
	int		Max_Speed;			/* in pixels per second        */
	int		Time_To_Max_Speed;	/* in 1/100th of a second      */
	BYTE	Accel_Table_Len;
	BYTE	Accel_Table[128];
	BYTE	Constant_Table_Len;
	BYTE	Constant_Table[128];
} KBDMOUSEKEYSPARM;

extern	void FAR PASCAL Get_MouseKeys_Param(KBDMOUSEKEYSPARM FAR *);	/* part of keyboard driver */
extern	void FAR PASCAL Set_MouseKeys_Param(KBDMOUSEKEYSPARM FAR *);	/* part of keyboard driver */

typedef	struct tagKBDTOGGLEKEYSPARM {
	BYTE	fToggleKeysOn;		/* boolean 0 = false, 1 = true */
	BYTE	fOn_Off_Feedback;	/* boolean 0 = false, 1 = true */
} KBDTOGGLEKEYSPARM;

extern	void FAR PASCAL Get_ToggleKeys_Param(KBDTOGGLEKEYSPARM FAR *);	/* part of keyboard driver */
extern	void FAR PASCAL Set_ToggleKeys_Param(KBDTOGGLEKEYSPARM FAR *);	/* part of keyboard driver */

typedef	struct tagKBDTIMEOUTPARM {
	BYTE	fTimeOutOn;			/* boolean 0 = false, 1 = true */
	BYTE	fOn_Off_Feedback;	/* boolean 0 = false, 1 = true */
	int		to_value;			/* time to turn off 18.2 times/sec */
} KBDTIMEOUTPARM;

extern	void FAR PASCAL Get_TimeOut_Param(KBDTIMEOUTPARM FAR *);	/* part of keyboard driver */
extern	void FAR PASCAL Set_TimeOut_Param(KBDTIMEOUTPARM FAR *);	/* part of keyboard driver */

typedef	struct tagKBDSHOWSOUNDSPARM {
	BYTE	fshow_sound_screen;	/* boolean 0 = false, 1 = true */
	BYTE	fshow_sound_caption;	/* boolean 0 = false, 1 = true */
	BYTE	fvideo_found;
	BYTE	fvideo_flash;
} KBDSHOWSOUNDSPARM;

extern	void FAR PASCAL Get_ShowSounds_Param(KBDSHOWSOUNDSPARM FAR *);	/* part of keyboard driver */
extern	void FAR PASCAL Set_ShowSounds_Param(KBDSHOWSOUNDSPARM FAR *);	/* part of keyboard driver */

typedef  struct tagMouseKeysParam {
	int		NumButtons;		/* holds number of buttons on the mice	*/
	int		Delta_Y;		/* Relative Y motion sign extended		*/
	int		Delta_X;		/* Relative X motion sign extended		*/
	int		Status;			/* status of mouse buttons and motion	*/
} MOUSEKEYSPARAM;

//extern	void FAR PASCAL InjectMouse(MOUSEKEYSPARAM FAR *);	/* part of mouse driver */
//extern	void FAR PASCAL InjectKeys(int);	/* part of keyboard driver */
//extern	void FAR PASCAL ErrorCode(int); 	/* part of keyboard driver */

typedef  struct tagKBDINFOPARAM {
	int		kybdversion;		/* holds handicap keyboard version number */
} KBDINFOPARM;

typedef  struct tagMOUINFOPARAM {
	int		mouversion;	    	/* holds handicap mouse version number */
} MOUINFOPARM;


/*;BCK*/
//extern	void FAR PASCAL Get_KybdInfo_Param(KBDINFOPARM FAR *);	/* part of appcalls in keyboard driver */
//extern	void FAR PASCAL Get_MouInfo_Param(MOUINFOPARM FAR *);	/* part of appcalls in keyboard driver */

extern	void FAR PASCAL Save_SerialKeys_Param(int); 	/* part of appcalls.asm */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\gide.c ===
/* GIDE.C  */

//#define     WINVER 0x0300
#define     USECOMM                     /* added to be compatible with new windows.h (12/91) and wintric.h */
                                          /* last rellease of 3.1 SDK switched back to using NOCOMM in windows.h */

#include	<string.h>
#include	<stdlib.h>
#include	"windows.h"
//#include "winstric.h"                        /* added for win 3.1 compatibility 1/92 */
#include "gidei.h"
#include "vars.h"
#include "gide.h"
#include "kbd.h"
#include "mou.h"
#include "tables.h"
#include "dialogs.h"
#include "sk_ex.h"
#include "w95trace.h"


typedef	struct	tagAliasTable {
	char	*Alias;
	BYTE	Code;
} ALIASTABLE;

long 	AtoL(char *Str);

extern	void	initClear(void);

BOOL	bGIDEIokay = TRUE;				/* general flag for error in processing */
int   	nFrameCnt = 0;					/* keep track of framming errors	*/

char cInBuffer[2];						/* buffer for receiving characters	*/

//char	cInBuffer[7];					/* buffer for receiving characters, size increased */
//short	cInBuffer_count =0;			/* count of chars. returned in ReadComm */
//int		intct = 0;					/* counter for looping thru cInBuffer_count */

//char	cOutStr[2] = {0,0};				/* single char output string		*/


void handleFatalError(void)
{
	SkEx_SendBeep();
	SkEx_SendBeep();
	initClear();
	return;
}

void handleErrorReport(void)
{
	SkEx_SendBeep();
	initClear();
	return;
}

int aliasForGideiCode(unsigned char *cTempPtr)
{
	struct aliasTable *tablePtr;
	int found;

	found = FALSE;
	for (tablePtr=gideiAliasTable;(tablePtr->aliasName[0] != '\x0') && (!found);tablePtr++)
 		if (strcmp(cAliasString,tablePtr->aliasName) == 0) {
			found = TRUE;
			*cTempPtr = tablePtr->gideiCode;
			}
	return (found);
}


int aliasUsedInStandard(unsigned char *cTempPtr)
{
	struct aliasTable *tablePtr;
	int found;
	unsigned char iCode;

	if (aliasPtr == keyAliasTable) {
		if (lstrlenA(cAliasString) == 1) {
			/* use ASCII table */
			if ((iCode = asciiTable[cAliasString[0]].gideiCode1) == NOCODE) return(FALSE);
			if ((iCode == control_Code) || (iCode == shift_Code))
				iCode = asciiTable[cAliasString[0]].gideiCode2;
			*cTempPtr = iCode;
			return(TRUE);
			}
		}
	found = FALSE;
	for (tablePtr=aliasPtr;(tablePtr->aliasName[0] != '\x0') && (!found);tablePtr++)
		if (lstrcmpA(cAliasString,tablePtr->aliasName) == 0) {
			found = TRUE;
			*cTempPtr = tablePtr->gideiCode;
			}
	return (found);
}



/****************************************************************************

	FUNCTION:	pushCommandVector

	PURPOSE:	push CommandVector on to vectorStack

	COMMENTS:
****************************************************************************/

int pushCommandVector(void)
{
	if (stackPointer < MAXVECTORSTACK) {
		aliasStack[stackPointer] = aliasPtr;
		vectorStack[stackPointer++] = commandVector;
		return(TRUE);
		}
	else return(FALSE);
}

/****************************************************************************

	FUNCTION:	popCommandVector

	PURPOSE:	pop CommandVector from vectorStack

	COMMENTS:

*****************************************************************************/

int popCommandVector(void)
{
	if (stackPointer > 0) {
		aliasPtr = aliasStack[--stackPointer];
		commandVector = vectorStack[stackPointer];
		return(TRUE);
		}
	else return(FALSE);
}

/****************************************************************************

	FUNCTION:	restoreCommandVector

	PURPOSE:	restore CommandVector from vectorStack but does not update
				stack pointer.

	COMMENTS:

*****************************************************************************/

int restoreCommandVector(void)
{
	if (stackPointer > 0) {
		aliasPtr = aliasStack[--stackPointer];
		commandVector = vectorStack[stackPointer];
		++stackPointer;
		return(TRUE);
		}
	else return(FALSE);
}

/****************************************************************************/
int storeByte(unsigned char *bytePtr)
{
	if ((spos+1==rpos) || (spos+1==CODEBUFFERLEN && !rpos)) return notOKstatus;
	buf[spos++] = *bytePtr;
	if (spos==CODEBUFFERLEN) spos = 0;
	return okStatus;
}

int retrieveByte(unsigned char *bytePtr)
{
	if (rpos==CODEBUFFERLEN) rpos = 0;
	if (rpos==spos) return notOKstatus;
	++rpos;
	*bytePtr = buf[rpos-1];
	return okStatus;
}


/****************************************************************************

	FUNCTION:	noOpRoutine

	PURPOSE:	"Do nothing" routine

	COMMENTS:

****************************************************************************/
void noOpRoutine(unsigned char cJunk)
{
	return;
}

void processGen(unsigned char c)
{
	return;
}

void processComm(unsigned char c)
{
	return;
}
/****************************************************************************

	FUNCTION:	processCommand

	PURPOSE:	Determine which command is active.  Then set commandVector to
				point to appropriate routine.

	COMMENTS:

****************************************************************************/
void processCommand(unsigned char cGideiCode)
{
	switch(cGideiCode) {
		case KBDEXPANSIONCODE:
			commandVector = processKbd;
			aliasPtr = kbdAliasTable;
			beginOK = TRUE;
			break;
		case MOUEXPANSIONCODE:
			commandVector = processMou;
			aliasPtr = mouseAliasTable;
			beginOK = TRUE;
			break;
		case GENCODE:
			commandVector = processGen;
			aliasPtr = genAliasTable;
			beginOK = TRUE;
			break;
		case COMMCODE:
			commandVector = processComm;
			aliasPtr = commAliasTable;
			beginOK = TRUE;
			break;
		case KBDLOCKCODE:
			commandVector = processKbdLock;
			aliasPtr = keyAliasTable;
			beginOK = TRUE;
			break;
		case KBDRELCODE:
			commandVector = processKbdRel;
			aliasPtr = keyAliasTable;
			beginOK = TRUE;
			break;
		case KBDPRESSCODE:
			commandVector = processKbdPress;
			aliasPtr = keyAliasTable;
			beginOK = TRUE;
			break;
		case KBDCOMBINECODE:
			commandVector = processKbdCombine;
			aliasPtr = keyAliasTable;
			beginOK = TRUE;
			break;
		case KBDHOLDCODE:
			commandVector = processKbdHold;
			aliasPtr = keyAliasTable;
			beginOK = TRUE;
			break;
		case MOULOCKCODE:
			commandVector = processMouLock;
			aliasPtr = mouButtonAliasTable;
			beginOK = TRUE;
			break;
		case MOURELCODE:
			commandVector = processMouRel;
			aliasPtr = mouButtonAliasTable;
			beginOK = TRUE;
			break;
		case MOUCLICKCODE:
			commandVector = processMouClick;
			aliasPtr = mouButtonAliasTable;
			beginOK = TRUE;
			break;
		case MOUDOUBLECLICKCODE:
			commandVector = processMouDoubleClick;
			aliasPtr = mouButtonAliasTable;
			beginOK = TRUE;
			break;
		case MOUMOVECODE:
			commandVector = processMouMove;
			aliasPtr = nullTable;
			beginOK = TRUE;
			break;
		case MOUGOTOCODE:
			commandVector = processMouGoto;
			aliasPtr = nullTable;
			beginOK = TRUE;
			break;
		case MOURESETCODE:
			commandVector = processMouReset;
			aliasPtr = nullTable;
			beginOK = TRUE;
			break;
		case MOUANCHORCODE:
			commandVector = processMouAnchor;
			aliasPtr = nullTable;
			beginOK = TRUE;
			break;
		case BAUDRATECODE:
			commandVector = processBaudrate;
			aliasPtr = baudrateAliasTable;
			beginOK = TRUE;
			break;
		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			beginOK = TRUE;
		default:
			if (cGideiCode >= LOWESTGIDEICODE) handleFatalError();
			else {
				handleErrorReport();
				commandVector = noOpRoutine;
				beginOK = TRUE;
				}
			break;
		}
	return;
}



void processBytes(unsigned char iGideiCode)
{
	(*commandVector)(iGideiCode);
	if (!(--blockCount))
      {
      passAll = FALSE;
      codeVector = processGideiCode;
      }
}

void processBlock(unsigned char iGideiCode)
{
	if (blockCount--) (*commandVector)(iGideiCode);
	else {
      passAll = FALSE;
		if (iGideiCode == TERMCODE) codeVector = processGideiCode;
		else handleFatalError();
		}
}

void processGideiBlockCount(unsigned char iGideiCode)
{
	blockCount = iGideiCode;
	codeVector = processBlock;
   passAll = TRUE;
}

void processGideiClear(unsigned char iGideiCode)
{
	if (iGideiCode == TERMCODE) initClear();
	else handleFatalError();
}

void processGideiEnd(unsigned char iGideiCode)
{
	if (iGideiCode == TERMCODE) {
		if (!popCommandVector()) handleFatalError();
		else {
			if (restoreCommandVector()) {
				beginOK = TRUE;
				codeVector = processGideiCode;
				}
			else {
				commandVector = processCommand;
				codeVector = processCharMode;
				serialVector = charHandler;
				beginOK = FALSE;
				}
			lastCode = iGideiCode;
			}
		}
	else handleFatalError();
}


/****************************************************************************

	FUNCTION:	processCOMMbaudrate(Code)

	PURPOSE:	Processes the baudrate commands.

	COMMENTS:

****************************************************************************/

void processBaudrate(unsigned char Code)
{
	static int SetBaud = 0;

	switch(Code)
	{
		case TERMCODE:
			if (SetBaud != 0) 			/* valid one set */
				SkEx_SendBeep();
			break;

		case BAUD300CODE:
			SetBaud = ID_BAUD_300;
			SkEx_SetBaud(300);
			break;

		case BAUD600CODE:
			SetBaud = ID_BAUD_600;
			SkEx_SetBaud(600);
			break;

		case BAUD1200CODE:
			SetBaud = ID_BAUD_1200;
			SkEx_SetBaud(1200);
			break;

		case BAUD2400CODE:
			SetBaud = ID_BAUD_2400;
			SkEx_SetBaud(2400);
			break;

		case BAUD4800CODE:
			SetBaud = ID_BAUD_4800;
			SkEx_SetBaud(4800);
			break;

		case BAUD9600CODE:
			SetBaud = ID_BAUD_9600;
			SkEx_SetBaud(9600);
			break;

		case BAUD19200CODE:
			SetBaud = ID_BAUD_19200;
			SkEx_SetBaud(19200);
			break;

		case BAUD110CODE:
			SetBaud = ID_BAUD_110;
			SkEx_SetBaud(110);
			break;

		case BAUD14400CODE:
			SetBaud = ID_BAUD_14400;
			SkEx_SetBaud(14400);
			break;

		case BAUD38400CODE:
			SetBaud = ID_BAUD_38400;
			SkEx_SetBaud(38400);
			break;

		case BAUD56000CODE:
			SetBaud = ID_BAUD_56000;
			SkEx_SetBaud(56000);
			break;

		case BAUD57600CODE:
			SetBaud = ID_BAUD_57600;
			SkEx_SetBaud(57600);
			break;

		case BAUD115200CODE:
			SetBaud = ID_BAUD_115200;
			SkEx_SetBaud(115200);
			break;

		default:
			handleErrorReport();
			break;
	}
}

/****************************************************************************

	FUNCTION:	processGideiCode

	PURPOSE:
				

	COMMENTS:

*****************************************************************************/

void processGideiCode(unsigned char iGideiCode)
{
	if (waitForClear) {
		if (iGideiCode == CLEARCODE) codeVector = processGideiClear;
		else handleFatalError();
		return;
		}
	switch (iGideiCode) {

		case BEGINCODE:
			if (beginOK) {
				if (pushCommandVector()) lastCode = iGideiCode;
				else handleFatalError();
				}
			else handleFatalError();
			break;

		case ENDCODE:
			if (lastCode == TERMCODE) {
				codeVector = processGideiEnd;
				beginOK = FALSE;
				lastCode = iGideiCode;
				}
			else handleFatalError();
			break;

		case CLEARCODE:
			codeVector = processGideiClear;
			lastCode = iGideiCode;
			break;

		case TERMCODE:
			(*commandVector)(iGideiCode);
			if (!restoreCommandVector()) {
				commandVector = processCommand;
				codeVector = processCharMode;
				serialVector = charHandler;
				beginOK = FALSE;
				}
			else
				beginOK = TRUE;
			lastCode = iGideiCode;
			break;

		case BLKTRANSCODE:
			codeVector = processGideiBlockCount;
			(*commandVector)(iGideiCode);
			lastCode = iGideiCode;
			break;

		case BYTECODE:
			codeVector = processBytes;
			blockCount = 1;
			passAll = TRUE;
			(*commandVector)(iGideiCode);
			lastCode = iGideiCode;
			break;

		case INTEGERCODE:
			codeVector = processBytes;
			blockCount = 2;
			passAll = TRUE;
			(*commandVector)(iGideiCode);
			lastCode = iGideiCode;
			break;

		case LONGCODE:
			codeVector = processBytes;
			blockCount = 4;
			passAll = TRUE;
			(*commandVector)(iGideiCode);
			lastCode = iGideiCode;
			break;

		case DOUBLECODE:
			codeVector = processBytes;
			blockCount = 8;
			passAll = TRUE;
			(*commandVector)(iGideiCode);
			lastCode = iGideiCode;
			break;

		default:
			(*commandVector)(iGideiCode);
			lastCode = iGideiCode;
			break;
		}

}


/****************************************************************************

	FUNCTION:	processCharMode

	PURPOSE:	Handles processing of ASCII characters in Character Mode
				

	COMMENTS:

***************************************************************************/
void processCharMode(unsigned char ucSerialByte)
{
	unsigned char tempKeyCode;

	if (ucSerialByte == ESCAPE) {
		codeVector = processGideiCode;
		return;
		}

	if (waitForClear) {
		handleFatalError();
		return;
		}

	if ( ucSerialByte > 127 )			// Are We processing an Extended Code
	{
		sendExtendedKey(ucSerialByte);	// Yes - Send Code
		return;							// Exit
	}

	if ((tempKeyCode = (asciiTable[ucSerialByte]).gideiCode1) == NOCODE) {
		handleErrorReport();
		tempList.len = 0;
		return;
		}

	if ((!inLockList(tempKeyCode)) && (!inHoldList(tempKeyCode)))
		tempList.list[tempList.len++] = tempKeyCode;

	if ((tempKeyCode = asciiTable[ucSerialByte].gideiCode2) != NOCODE) {
		if ((!inLockList(tempKeyCode)) && (!inHoldList(tempKeyCode)))
			tempList.list[tempList.len++] = tempKeyCode;
		}

	sendCombineList();
	keyHoldList.len = tempList.len = 0;
	return;
}



/****************************************************************************

	FUNCTION:	executeAlias()

	PURPOSE:	Takes the alias string, convert to code, and then does
				proper processing.

	COMMENTS:

*****************************************************************************/
void executeAlias(void)
{
	static unsigned char *cTempPtr;
	static int iTemp;

	cTempPtr = cAliasString;
	if (lstrlenA(cAliasString) > MAXALIASLEN) *cTempPtr = UNKNOWNCODE;
	else 
    {
		if (!aliasForGideiCode(cTempPtr)) 
        {
			CharLowerA(cAliasString);
			if (!aliasUsedInStandard(cTempPtr))
            {
 					/* Must be a number.  But is it an ASCII coded number
 					or ASCII coded GIDEI code */
				switch (cAliasString[0]) 
                {
					case '0':
					case '+':
					case '-':
						iTemp = AtoL(cAliasString);
						*cTempPtr = INTEGERCODE;
						storeByte(cTempPtr);
						cTempPtr = (unsigned char*) &iTemp;
						storeByte(cTempPtr++);
						break;
					default:
						/* must be a ASCII coded GIDEI code */
						iTemp = AtoL(cAliasString);
						if ((unsigned)iTemp > 255) *cTempPtr = UNKNOWNCODE;
						else *cTempPtr = (unsigned char) iTemp;
						break;
				}
            }
		}
	}
	storeByte(cTempPtr);
	return;
}


/****************************************************************************

	FUNCTION:	processAlias(ucSerialByte)

	PURPOSE:	This routine builds up the alias string and then passes
				control onto executeAlias.

	COMMENTS:
*****************************************************************************/

void processAlias(unsigned char ucSerialByte)
{
	static unsigned char	tempCode, *codePtr;
	static unsigned char sbtemp[2];

	codePtr = &tempCode;

	switch (ucSerialByte) {
		case ESCAPE:
			cAliasString[0] = '\0';
			break;
		case TAB:
		case LINEFEED:
		case VERTICALTAB:
		case FORMFEED:
		case RETURN:
		case SPACE:
			if (!lstrlenA(cAliasString)) break;	/* if previous character was a */
				 								/* delimiter then eat white space */
		case COMMA:
		case PERIOD:
			if (lstrlenA(cAliasString)) executeAlias();
			else
				{
				tempCode = DEFAULTCODE;
				storeByte(codePtr);
				}
			if (ucSerialByte == '.')
				{
				tempCode = TERMCODE;
				storeByte(codePtr);
				}
			cAliasString[0] = '\0';
			for (;retrieveByte(codePtr);) (*codeVector)(tempCode);
			break;
		default:
			/* just add the char to the string */
			if ((ucSerialByte >= ' ') && (ucSerialByte <= '~'))
			{
				if (lstrlenA(cAliasString) < MAXALIASLEN+1)	/*make sure room */
				{
					sbtemp[0] = ucSerialByte;
					sbtemp[1] = 0;
					lstrcatA(cAliasString,sbtemp);
                } else
                {
                    DBPRINTF(TEXT("processAlias:  no room\r\n"));
                }
			}
			else
            {
				handleFatalError();					/* not an alias */
            }
		}
	return;
}

/****************************************************************************

	FUNCTION:	passAllCodes

	PURPOSE:	Just keeps the GIDEI hierarchy consistant

	COMMENTS:	
****************************************************************************/

void passAllCodes(unsigned char cGideiCode)
{
	(*codeVector)(cGideiCode);
	return;
}



/****************************************************************************

	FUNCTION:	determineFormat

	PURPOSE:	Figure out what Escape Sequence form (i.e. Alias, Code, KEI, etc)

	COMMENTS:
****************************************************************************/

void determineFormat(unsigned char ucSerialByte)
{
	static char cStuffStr[7], *cPtr;

	switch (ucSerialByte)
		{
		case COMMA:
			serialVector = processAlias;
			aliasPtr = commandsAliasTable;
			break;
		case ESC:
			break;
		default:
			if ((ucSerialByte >= ' ') && (ucSerialByte <= '~')) /* KEI Implied Press */
				{
				serialVector = processAlias;
				aliasPtr = commandsAliasTable;
				for (cPtr = strcpy(cStuffStr,"press,"); *cPtr != '\0'; cPtr++) processAlias(*cPtr);
				processAlias(ucSerialByte);
				}
			else
				{
				serialVector = passAllCodes;
				(*codeVector)(ucSerialByte);
				}
			break;
		}
	return;
}

/****************************************************************************

	FUNCTION:	charHandler

	PURPOSE:	If ESCAPE then set up new vectors.  Also processes the char

	COMMENTS:
****************************************************************************/

void charHandler(unsigned char ucSerialByte)
{
	if (ucSerialByte == ESC) {
		serialVector = determineFormat;
		commandVector = processCommand;
		beginOK = TRUE;
		}
	(*codeVector)(ucSerialByte);
	return;
}


BOOL  serialKeysBegin(unsigned char c)
{
	static	char junk[2];
	
	junk[0] = c;
	junk[1] = '\0';

	if (!passAll) {
		if (c == '\0')
			{
			SkEx_SendBeep();
			if ((++nullCount) >= 3) {
				initClear();
				SkEx_SendBeep();
				SkEx_SendBeep();
				SkEx_SendBeep();

				}
			}
		}
	(*serialVector)(c);
	return(TRUE);
}


long AtoL(char *s)
{
	long num = 0;
	long sign = 1L;

	while(*s == ' ' || *s == '\t')
		s++;

	if( *s == '-' ) 
    {
		sign = -1L;
		s++;
	}
	else if( *s == '+' )
    {
		s++;
    }
	while('0' <= *s  &&  *s <= '9') 
    {
		num = 10 * num + *s - '0';
		s++;
	}

	return( sign * num );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\dialogs.h ===
/****************************************************************************

	DIALOGS.H

	This file defines the definitions for handling the dialogs.

****************************************************************************/

#define		ID_COM1					400
#define		ID_COM2					401
#define		ID_COM3					402
#define		ID_COM4					403

#define		ID_BAUD_110             600
#define		ID_BAUD_300				410
#define		ID_BAUD_600				411
#define		ID_BAUD_1200			412
#define		ID_BAUD_2400			413
#define		ID_BAUD_4800			414
#define		ID_BAUD_9600			415
#define		ID_BAUD_14400           601
#define		ID_BAUD_19200			416
#define		ID_BAUD_38400           602
#define		ID_BAUD_56000           603
#define		ID_BAUD_57600           604
#define		ID_BAUD_115200          605

#define		ID_MK_TIME_1			420
#define		ID_MK_TIME_TEXT			421
#define		ID_MK_TIME_3			422
#define		ID_MK_TIME_4			423
#define		ID_MK_TIME_5			424

#define		ID_MK_SPEED_1			430
#define		ID_MK_SPEED_TEXT		431
#define		ID_MK_SPEED_3			432
#define		ID_MK_SPEED_4			433
#define		ID_MK_SPEED_5			434

#define		ID_KB_ACCEPT_0			440
#define		ID_KB_ACCEPT_1			441
#define		ID_KB_ACCEPT_TEXT		442
#define		ID_KB_ACCEPT_3			443
#define		ID_KB_ACCEPT_4			444
#define		ID_KB_ACCEPT_5			445

#define		ID_USER_OPTION1			447
#define		ID_USER_OPTION2			448
#define   	ID_ON_OFF_CLICK			449

#define		ID_KB_DELAY_0			450
#define		ID_KB_DELAY_1			451
#define		ID_KB_DELAY_TEXT		452
#define		ID_KB_DELAY_3			453
#define		ID_KB_DELAY_4			454
#define		ID_KB_DELAY_5			455

#define		ID_KB_RATE_0			460
#define		ID_KB_RATE_TEXT			461
#define		ID_KB_RATE_2			462
#define		ID_KB_RATE_3			463
#define		ID_KB_RATE_4			464
#define		ID_KB_RATE_5			465

#define		ID_OFF					470
#define		ID_ON					471
#define		ID_FLAG_1				472
#define		ID_FLAG_2				473

#define		ID_TIMEOUT_1			480
#define		ID_TIMEOUT_2			481
#define		ID_TIMEOUT_3			482
#define		ID_TIMEOUT_4			483

#define		ID_ON_OFF_FEEDBACK		490
#define		ID_TRISTATE				491
#define		ID_TWOKEYS_TURNOFF		492
#define		ID_STATE_FEEDBACK		493

#define		ID_KB_BOUNCE_0			500
#define		ID_KB_BOUNCE_1			501
#define		ID_KB_BOUNCE_TEXT		502
#define		ID_KB_BOUNCE_3			503
#define		ID_KB_BOUNCE_4			504
#define		ID_KB_BOUNCE_5			505

#define		ID_KB_TEST_0			530
#define		ID_KB_TEST_1			531
#define		ID_SHOW_SOUND_SCREEN	532
#define		ID_SHOW_SOUND_CAPTION	533
#define		ID_SHOW_SOUND_TYPE		534
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\gide.h ===
/*  GIDE.H   */

#include "gidei.h"

int pushCommandVector(void);
int popCommandVector(void);
int restoreCommandVector(void);

void noOpRoutine(unsigned char cJunk);

int storebyte(unsigned char *bytePtr);
int retrievebyte(unsigned char *bytePtr);

void processComm(unsigned char);
void processGen(unsigned char);
void processEnd(unsigned char iGideiCode);
void processBytes(unsigned char iGideiCode);
void processBlock(unsigned char iGideiCode);
void processGideiBlockCount(unsigned char iGideiCode);
void processClear(unsigned char iGideiCode);
void processGideiCode(unsigned char iGideiCode);

void executeAlias(void);
void processAlias(unsigned char ucSerialByte);
short	writeCommPort (char *outStr);

void passAllCodes(unsigned char cGideiCode);
void determineFormat(unsigned char ucSerialByte);
void charHandler(unsigned char ucSerialByte);
void processCharMode(unsigned char ucSerialByte);
void processCommand(unsigned char cGideiCode);
void	processBaudrate(unsigned char Code);

BOOL FAR serialKeysBegin(unsigned char c);

void handleErrorReport(void);
void handleFatalError(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\initgide.c ===
/*  INIT.C  */

//#define     WINVER 0x0300
#include	"windows.h"

//#include "winstric.h"                        /* added for win 3.1 compatibility 1/92 */
#include "vars.h"
#include "gide.h"
#include "initgide.h"
#include "dialogs.h"

void serialKeysStartUpInit(void)
{

	mouseX = mouseY = 0;
	mouData.NumButtons = 2;
	mouData.Delta_Y = 0;
	mouData.Delta_X = 0;
	mouData.Status = 0;
	requestButton1, requestButton2, requestButton3 = FALSE;
	button1Status, button2Status, button3Status = FALSE;
	passAll = fatalErrorFlag = stdErrorFlag = waitForClear = beginOK = FALSE;
	nullCount = blockCount = lastCode = 0;
	keyLockList.len = keyHoldList.len = tempList.len = 0;
	cAliasString[0] = '\0';
	stackPointer = 0;
	spos = rpos = 0;
	serialVector = charHandler;
	codeVector = processCharMode;
	commandVector = processCommand;
	aliasPtr = nullTable;

	return;				/* beep and set baudrate */
}

void initClear(void)
{
	passAll = fatalErrorFlag = stdErrorFlag = waitForClear = beginOK = FALSE;
	nullCount = blockCount = lastCode = 0;
	tempList.len = 0;
	cAliasString[0] = '\0';
	stackPointer = 0;
	spos = rpos = 0;
	serialVector = charHandler;
	codeVector = processCharMode;
	commandVector = processCommand;
	aliasPtr = nullTable;
	mouData.NumButtons = 2;
	mouData.Delta_Y = 0;
	mouData.Delta_X = 0;
	mouData.Status = 0;
	return;
}

VOID FAR PASCAL serialKeysStartupInitDLL(void)
{
	mouseX = mouseY = 0;
	mouData.NumButtons = 2;
	mouData.Delta_Y = 0;
	mouData.Delta_X = 0;
	mouData.Status = 0;
	requestButton1, requestButton2, requestButton3 = FALSE;
	button1Status, button2Status, button3Status = FALSE;
	passAll = fatalErrorFlag = stdErrorFlag = waitForClear = beginOK = FALSE;
	nullCount = blockCount = lastCode = 0;
	keyLockList.len = keyHoldList.len = tempList.len = 0;
	cAliasString[0] = '\0';
	stackPointer = 0;
	spos = rpos = 0;
	serialVector = charHandler;
	codeVector = processCharMode;
	commandVector = processCommand;
	aliasPtr = nullTable;
	return;						/* beep and set baudrate */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\kbd.h ===
/* KBD.H  */



void sendPressList(void);
void sendCombineList(void);
void sendExtendedKey(unsigned char cKeyCode);
void sendDownKeyCode(unsigned char cKeyCode);
void sendUpKeyCode(unsigned char cKeyCode);

int inLockList(unsigned char searchChar);
int inHoldList(unsigned char searchChar);
int inTempList(unsigned char searchChar);

void releaseKeysFromHoldList(void);
void removeKeyFromHoldList(unsigned char cTheKey);
void releaseKeysFromLockList(void);

void processKbdIndicator(unsigned char cGideiCode);
void processKbdVersion(unsigned char cGideiCode);
void processKbdDescription(unsigned char cGideiCode);
void processKbdModel(unsigned char cGideiCode);

void processKbdRel(unsigned char cGideiCode);
void processKbdLock(unsigned char cGideiCode);
void processKbdHold(unsigned char cGideiCode);
void processKbdCombine(unsigned char cGideiCode);
void processKbdPress(unsigned char cGideiCode);
void processKbd(unsigned char cGideiCode);

unsigned char xlateNumToScanCode(unsigned char Value);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\gidei.h ===
/* GIDEI Codes */

/* reserved 236-242 */
#define NOCODE 0
#define LOWESTGIDEICODE 236

#define DOUBLECODE 243
#define LONGCODE 244
#define INTEGERCODE 245
#define BYTECODE 246
#define BLKTRANSCODE 247
#define DELIMITERCODE 248
#define ENDCODE 249
#define BEGINCODE 250
#define CLEARCODE 251
#define DEFAULTCODE 252
#define UNKNOWNCODE 253
#define EXTENDEDCODE 254
#define TERMCODE 255

/* Command Codes */
#define KBDPRESSCODE 2
#define KBDCOMBINECODE 3
#define KBDHOLDCODE 4
#define KBDLOCKCODE 5
#define KBDRELCODE 6
#define KBDEXPANSIONCODE 10

#define MOULOCKCODE 11
#define MOURELCODE 12
#define MOUCLICKCODE 13
#define MOUDOUBLECLICKCODE 14
#define MOUMOVECODE 15
#define MOUGOTOCODE 16
#define MOURESETCODE 17
#define MOUANCHORCODE   18
#define MOUEXPANSIONCODE 20

#define COMMCODE 150
#define BAUDRATECODE 151
#define GENCODE 160
#define DEBUGCODE 220

/* Model Codes */

#define IBMEXTENDEDCODE 	1
#define IBMATCODE		 	2
#define IBMPCCODE			3

#define KBDINDICATORCODE 6
#define KBDVERSIONCODE	7
#define KBDMODELCODE 	8
#define KBDDESCRIPTIONCODE 9
#define KBDUNKNOWNCODE 10

#define NOBUTTON			0
#define DEFAULTBUTTONCODE	1
#define LEFTBUTTONCODE		1
#define RIGHTBUTTONCODE		2

/* BAUDRATE CODES  */

#define BAUD300CODE	1
#define BAUD600CODE  2
#define BAUD1200CODE	3
#define BAUD2400CODE	4
#define BAUD4800CODE	5
#define BAUD9600CODE	6
#define BAUD19200CODE   7
#define BAUD14400CODE   9
#define BAUD38400CODE   10
#define BAUD56000CODE   11
#define BAUD57600CODE   12
#define BAUD115200CODE  13
#define BAUD110CODE     8

/****************************************************************************

	The Key Code is the GIDEI standard Key Code.  The IBM Key Number is the
	number used in the IBM techincal reference of the American English
	extended 101 key keyboard.  It is included only for reference as to
	how this implementation mapped the key code to the IBM keys.

		Name			Key Code	IBM Key Number
****************************************************************************/


/* GIDEI KEY CODES */
/*************************************************************************/
/*************************************************************************/
/* Internal Key number table  */

#define	NOCODE			0
#define	NOKEY				0
#define	no_key			0
#define	lquote_key		1
#define	one_key			2
#define	two_key			3
#define	three_key		4
#define	four_key			5
#define	five_key			6
#define	six_key			7
#define	seven_key		8
#define	eight_key		9
#define	nine_key			10
#define	zero_key			11
#define	hyphen_key		12
#define	equal_key		13
#define	backspace_key	15

#define	tab_key			16
#define	q_key				17
#define	w_key				18
#define	e_key				19
#define	r_key				20
#define	t_key				21
#define	y_key				22
#define	u_key				23
#define	i_key				24
#define	o_key				25
#define	p_key				26
#define	lbracket_key	27
#define	rbracket_key	28
#define	bslash_key		29

#define	caps_key			30
#define	a_key				31
#define	s_key				32
#define	d_key				33
#define	f_key				34
#define	g_key				35
#define	h_key				36
#define	j_key				37
#define	k_key				38
#define	l_key				39
#define	semicolon_key	40
#define	rquote_key		41
#define	return_key		43

#define	lshift_key		44
#define	z_key				46
#define	x_key				47
#define	c_key				48
#define	v_key				49
#define	b_key				50
#define	n_key				51
#define	m_key				52
#define	comma_key		53
#define	period_key		54
#define	fslash_key		55
#define	rshift_key		57

#define	lcontrol_key	58
#define	lcommand_key	59
#define	lalt_key			60
#define	space_key		61
#define	ralt_key			62
#define	rcommand_key	63
#define	rcontrol_key	64

#define	insert_key		75
#define	delete_key		76
#define	left_key			79
#define	home_key			80
#define	end_key			81
#define	up_key			83
#define	down_key			84
#define	pageup_key		85
#define	pagedown_key	86
#define	right_key		89

#define	numlock_key		90
#define	kp7_key			91
#define	kp4_key			92
#define	kp1_key			93
#define	kpfslash_key	95
#define	kp8_key			96
#define	kp5_key			97
#define	kp2_key			98
#define	kp0_key			99
#define	kpstar_key		100
#define	kp9_key			101
#define	kp6_key			102
#define	kp3_key			103
#define	kpperiod_key	104
#define	kpminus_key		105
#define	kpplus_key		106
#define	kpequal_key		107
#define	kpenter_key		108

#define	escape_key		110

#define	f1_key			112
#define	f2_key			113
#define	f3_key			114
#define	f4_key			115

#define	f5_key			116
#define	f6_key			117
#define	f7_key			118
#define	f8_key			119

#define	f9_key			120
#define	f10_key			121
#define	f11_key			122
#define	f12_key			123

#define	print_key		124
#define	scroll_key		125
#define	pause_key		126
#define	reset_key		127

#define	shift_key		lshift_key
#define	control_key		lcontrol_key
#define	alt_key			lalt_key

#define	shift_Code		lshift_key
#define	control_Code	lcontrol_key

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\kbd.c ===
/* KBD.C  */

//#define     WINVER 0x0300

#include	<string.h>
#include	<stdlib.h>
#include	"windows.h"
//#include "winstric.h"                        /* added for win 3.1 compatibility 1/92 */

#include	"gidei.h"
#include	"vars.h"
#include	"gide.h"
#include	"kbd.h"
#include	"tables.h"
#include	"sk_ex.h"

BOOL IsInBuff(char *buf, unsigned char SerchChar, int Len);


void sendDownKeyCode(unsigned char cKeyCode)
{
	int 	scanCode;

	if (cKeyCode == NOKEY)
		return;

	if ((scanCode = IBMextendedScanCodeSet1[cKeyCode]) == 0) 
		return;

	SkEx_SendKeyDown(scanCode);
}


void sendUpKeyCode(unsigned char cKeyCode)
{
	int		scanCode;

	if (cKeyCode == NOKEY)
		return;

	if ((scanCode = IBMextendedScanCodeSet1[cKeyCode]) == 0) 
		return;

	SkEx_SendKeyUp(scanCode);
}

void sendExtendedKey(unsigned char cKeyCode)
{
	unsigned char Key[4], Tmp;

	// Start with the Alt Key
	Key[0] = ralt_key;

	Tmp = cKeyCode/10;					// Calc One's
	Key[3] = cKeyCode - (Tmp * 10);		

	cKeyCode = Tmp;						// Calc Ten's
	Tmp /= 10;
	Key[2] = cKeyCode - (Tmp * 10);		
	Key[1] = Tmp;						// Calc Hundreds

	// Translate Numbers into ScanCodes
	Key[1] = xlateNumToScanCode(Key[1]);
	Key[2] = xlateNumToScanCode(Key[2]);
	Key[3] = xlateNumToScanCode(Key[3]);

	// Send Keys to Host
	sendDownKeyCode(Key[0]);		// Send Alt Key Down
	sendDownKeyCode(Key[1]);		// Send Hundreds Key Down
	sendDownKeyCode(Key[2]);		// Send Tens Key Down
	sendDownKeyCode(Key[3]);		// Send Ones Key Down
	sendUpKeyCode(Key[3]);
	sendUpKeyCode(Key[2]);
	sendUpKeyCode(Key[1]);
	sendUpKeyCode(Key[0]);
}

unsigned char xlateNumToScanCode(unsigned char Value)
{
	switch (Value)
	{
		case 0:	return(kp0_key);
		case 1:	return(kp1_key);
		case 2: return(kp2_key);
		case 3:	return(kp3_key);
		case 4:	return(kp4_key);
		case 5:	return(kp5_key);
		case 6:	return(kp6_key);
		case 7:	return(kp7_key);
		case 8:	return(kp8_key);
		case 9:	return(kp9_key);
	}

    // should never be reached
    return 0;
}


void sendPressList(void)
{
	int i;

	for (i=0; i < keyHoldList.len; sendDownKeyCode(keyHoldList.list[i++]));
	for (i=0; i < tempList.len; i++) {
		sendDownKeyCode(tempList.list[i]);
		sendUpKeyCode(tempList.list[i]);
		}
	for (i=keyHoldList.len; i > 0; sendUpKeyCode(keyHoldList.list[--i]));
	keyHoldList.len = tempList.len = 0;
	return;
}

void sendCombineList(void)
{
	int i;

	for (i=0; i < keyHoldList.len; sendDownKeyCode(keyHoldList.list[i++]));
	for (i=0; i < tempList.len; sendDownKeyCode(tempList.list[i++]));
	for (i=tempList.len; i > 0; sendUpKeyCode(tempList.list[--i]));
	for (i=keyHoldList.len; i > 0; sendUpKeyCode(keyHoldList.list[--i]));
	keyHoldList.len = tempList.len = 0;
	return;
}

int inLockList(unsigned char searchChar)
{
	return(IsInBuff(keyLockList.list,searchChar,keyLockList.len));
}

int inHoldList(unsigned char searchChar)
{
	return(IsInBuff(keyHoldList.list,searchChar,keyHoldList.len));
}

int inTempList(unsigned char searchChar)
{
	return(IsInBuff(tempList.list,searchChar,tempList.len));
}

BOOL IsInBuff(char *buf, unsigned char SearchChar, int Len)
{
	int x = 0;

	if (!Len)					// Are there any Chars to search?
		return(FALSE);			// No - Return False
		
	while (x < Len)				// Loop until num chars reached
	{
		if (*buf == SearchChar)	// Does buffer and search char match?
			return(TRUE);		// Yes - Return found it.

		buf++;					// Inc buffer;
		x++;					// Inc byte count
	}
 	return(FALSE);				// character not found in buffer
}


void releaseKeysFromHoldList(void)
{
	unsigned char chRemove;
	int iScan,iSrc,iDst;

	if (tempList.len)
	{
		// Go through each character in the list of items to remove...
		for (iScan=0; (iScan<tempList.len) && ((chRemove = tempList.list[iScan]) != DEFAULTCODE); iScan++)
		{
			// For each character to remove, copy the hold list to itself...
			iDst = 0;
			for (iSrc=0; iSrc < keyHoldList.len; iSrc++)
			{
				// ... unless it's the character we're removing. This removes that char,
				// and shuffles all the other items down...
				if (keyHoldList.list[iSrc] != chRemove)
				{
					keyHoldList.list[iDst] = keyHoldList.list[iSrc];
					iDst++;
				}
			}
			// Update length of hold array to reflect number of chars that survived removal...
			keyHoldList.len = iDst;
		}

		if (tempList.list[iScan] == DEFAULTCODE)
		{
			keyHoldList.len = 0;
		}
	}
	return;
}

void removeKeyFromHoldList(unsigned char cTheKey)
{
//	unsigned char cTemp;
	int j,k;

	if (cTheKey != NOKEY) {
		k = 0;
		for (j=0; j < keyHoldList.len; j++)
			if ((keyHoldList.list[k] = keyHoldList.list[j]) != cTheKey) k++;
		keyHoldList.len = k;
		}
	return;
}

void releaseKeysFromLockList(void)
{
	int iScan,iSrc,iDst;
	unsigned char chRemove;

	if (tempList.len)
	{
		// Go through each character in the list of items to remove...
		for (iScan=0; (iScan<tempList.len) && ((chRemove = tempList.list[iScan]) != DEFAULTCODE); iScan++)
		{
			// For each character to remove, copy the lock list to itself...
			iDst = 0;
			for (iSrc=0; iSrc < keyLockList.len; iSrc++)
			{
				// ... unless it's the character we're removing. This removes that char,
				// and shuffles all the other items down...
				if (keyLockList.list[iSrc] != chRemove)
				{
					keyLockList.list[iDst] = keyLockList.list[iSrc];
					iDst++;
				}
				else
				{
					sendUpKeyCode(chRemove);
				}
			}
			// Update length of lock array to reflect number of chars that survived removal...
			keyLockList.len = iDst;
		}

		if (tempList.list[iScan] == DEFAULTCODE)
		{
			for (iScan=0; iScan < keyLockList.len; iScan++)
			{
				sendUpKeyCode(keyLockList.list[iScan]);
			}
			tempList.len = keyLockList.len = 0;
		}
	}
	return;
}



void processKbdIndicator(unsigned char cGideiCode)
{
	return;
}

void processKbdVersion(unsigned char cGideiCode)
{
	return;
}

void processKbdDescription(unsigned char cGideiCode)
{
	return;
}

void processKbdUnknown(unsigned char cGideiCode)
{
	return;
}


void processKbdModel(unsigned char cGideiCode)
{
	switch (cGideiCode) {
		case TERMCODE:
			break;
		default:
			break;
		}
	return;
}


void processKbdRel(unsigned char cGideiCode)
{
	unsigned char iKeyNumber;

	switch (cGideiCode)
		{
		case TERMCODE:
			if (!tempList.len)
				{
				tempList.list[0] = DEFAULTCODE;
				++tempList.len;
				}
			releaseKeysFromLockList();
			releaseKeysFromHoldList();
			tempList.len = 0;
			break;

		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			tempList.len = 0;
			beginOK = TRUE;
			break;

		default:
			if ((cGideiCode >= LOWESTGIDEICODE) && (cGideiCode != DEFAULTCODE))
				{
				handleFatalError();
				break;
				}
			if (tempList.len >= MAXLISTLENGTH)
				{
				handleErrorReport();
				commandVector = noOpRoutine;
				tempList.len = 0;
				break;
				}
			if (cGideiCode == DEFAULTCODE)
				iKeyNumber = DEFAULTCODE;
			else
				{
				if ((iKeyNumber=cGideiCode) == NOKEY)
					{
					handleErrorReport();
					commandVector = noOpRoutine;
					tempList.len = 0;
					break;
					}
				if ((inLockList(iKeyNumber)) || (inHoldList(iKeyNumber)))
					iKeyNumber = NOKEY;
				}
			if (!inTempList(iKeyNumber)) tempList.list[tempList.len++]	= iKeyNumber;
			beginOK = FALSE;
			break;
		}
	return;
}

void processKbdLock(unsigned char cGideiCode)
{
	int i;
	unsigned char iKeyNumber;
	unsigned char temp;

	switch (cGideiCode) {
		case TERMCODE:
			for (i=0; i < tempList.len; i++) {
				if (keyLockList.len<MAXLISTLENGTH &&
					(temp = tempList.list[i]) != NOKEY) {
					keyLockList.list[keyLockList.len++] = temp;
					sendDownKeyCode(temp);
					if (inHoldList(temp)) removeKeyFromHoldList(temp);
					}
				}
			if (tempList.len == 0) handleErrorReport();
			tempList.len = 0;
			break;
		
		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			tempList.len = 0;
			beginOK = TRUE;
			break;

		default:
			if (cGideiCode >= (int)LOWESTGIDEICODE) {
				handleFatalError();
				break;
				}
			if ((keyLockList.len + tempList.len) >= MAXLISTLENGTH) {
				handleErrorReport();
				commandVector = noOpRoutine;
				tempList.len = 0;
				break;
				}
			if ((iKeyNumber=cGideiCode) == NOKEY) {
				handleErrorReport();
				commandVector = noOpRoutine;
				tempList.len = 0;
				break;
				}
			if (inLockList(iKeyNumber)) iKeyNumber = NOKEY;
			if (!inTempList(iKeyNumber)) tempList.list[tempList.len++]	= iKeyNumber;
			beginOK = FALSE;
			break;
		}
}


void processKbdHold(unsigned char cGideiCode)
{
	int i;
	unsigned char iKeyNumber;

	switch (cGideiCode) {
		case TERMCODE:
			for (i=0; i < tempList.len; i++)
				if (keyHoldList.len<MAXLISTLENGTH &&
					(keyHoldList.list[keyHoldList.len] = tempList.list[i]) != NOKEY)
					++(keyHoldList.len);
			if (tempList.len == 0) handleErrorReport();
			tempList.len = 0;
			break;
		
		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			tempList.len = 0;
			beginOK = TRUE;
			break;

		default:
			if (cGideiCode >= (int)LOWESTGIDEICODE) {
				handleFatalError();
				break;
				}
			if ((keyHoldList.len + tempList.len) >= MAXLISTLENGTH) {
				handleErrorReport();
				commandVector = noOpRoutine;
				tempList.len = 0;
				break;
				}
			if ((iKeyNumber=cGideiCode) == NOKEY) {
				handleErrorReport();
				commandVector = noOpRoutine;
				tempList.len = 0;
				break;
				}
			if ((inLockList(iKeyNumber)) || (inHoldList(iKeyNumber))) iKeyNumber = NOKEY;
			if (!inTempList(iKeyNumber)) tempList.list[tempList.len++]	= iKeyNumber;
			beginOK = FALSE;
			break;
		}
}

void processKbdCombine(unsigned char cGideiCode)
{
	unsigned char iKeyNumber;

	switch (cGideiCode) {
		case TERMCODE:
			sendCombineList();
			keyHoldList.len = tempList.len = 0;
			break;
		
		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			tempList.len = 0;
			beginOK = TRUE;
			break;

		default:
			if (cGideiCode >= LOWESTGIDEICODE) {
				handleFatalError();
				break;
				}
			if (tempList.len >= MAXLISTLENGTH) {
				handleErrorReport();
				commandVector = noOpRoutine;
				tempList.len = 0;
				break;
				}
			if ((iKeyNumber=cGideiCode) == NOKEY) {
				handleErrorReport();
				commandVector = noOpRoutine;
				tempList.len = 0;
				break;
				}
			if ((inLockList(iKeyNumber)) || (inHoldList(iKeyNumber))) iKeyNumber = NOKEY;
			if (!inTempList(iKeyNumber)) tempList.list[tempList.len++] = iKeyNumber;
			beginOK = FALSE;
			break;
		}
}

void processKbdPress(unsigned char cGideiCode)
{
	unsigned char iKeyNumber;

	switch (cGideiCode) {
		case TERMCODE:
			sendPressList();
			keyHoldList.len = tempList.len = 0;
			break;
		
		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			tempList.len = 0;
			beginOK = TRUE;
			break;

		default:
			if (cGideiCode >= LOWESTGIDEICODE) {
				handleFatalError();
				break;
				}
			if (tempList.len >= MAXLISTLENGTH) {
				handleErrorReport();
				commandVector = noOpRoutine;
				tempList.len = 0;
				break;
				}
			if ((iKeyNumber=cGideiCode) == NOKEY) {
				handleErrorReport();
				commandVector = noOpRoutine;
				tempList.len = 0;
				break;
				}
			if ((inLockList(iKeyNumber)) || (inHoldList(iKeyNumber))) iKeyNumber = NOKEY;
			tempList.list[tempList.len++] = iKeyNumber;
			beginOK = FALSE;
			break;
		}
}



void processKbd(unsigned char cGideiCode)
{
	switch (cGideiCode) {
		case KBDINDICATORCODE:
			commandVector = processKbdIndicator;
			aliasPtr = kbdIndicatorAliasTable;
			beginOK = TRUE;
			break;

		case KBDVERSIONCODE:
			commandVector = processKbdVersion;
			aliasPtr = kbdVersionAliasTable;
			beginOK = TRUE;
			break;

		case KBDMODELCODE:
			commandVector = processKbdModel;
			aliasPtr = kbdModelAliasTable;
			beginOK = TRUE;
			break;

		case KBDDESCRIPTIONCODE:
			commandVector = processKbdDescription;
			aliasPtr = kbdDescriptionAliasTable;
			beginOK = TRUE;
			break;

/*		case KBDUNKNOWNCODE:
			commandVector = processKbdUnknown;
			aliasPtr = kbdUnknownAliasTable;
			beginOK = TRUE;
			break;
*/
		default:
			if (cGideiCode < LOWESTGIDEICODE) handleFatalError();
			else {
				handleErrorReport();
				commandVector = noOpRoutine;
				beginOK = TRUE;
				}
			break;
		}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\initgide.h ===
/*  INIT.H  */

void serialKeysStartUpInit(void);
void initClear(void);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\mou.c ===
/* MOU.C */

//#define     WINVER 0x0300

#include	<string.h>
#include	<stdlib.h>
#include	"windows.h"
//#include "winstric.h"                        /* added for win 3.1 compatibility 1/92 */
#include	"vars.h"
#include	"gide.h"
#include	"mou.h"
#include	"kbd.h"
#include	"sk_ex.h"				// Serial Keys Interface Routines
#include    "w95trace.h"

#if 0
#define	SF_MOVEMENT	0x0001
#define	SF_B1_DOWN	0x0002
#define	SF_B1_UP	0x0004
#define	SF_B2_DOWN	0x0008
#define	SF_B2_UP	0x0010
#define	SF_ABSOLUTE	0x8000
#else
#define	SF_MOVEMENT		MOUSEEVENTF_MOVE      
#define	SF_B1_DOWN 		MOUSEEVENTF_LEFTDOWN  
#define	SF_B1_UP 		MOUSEEVENTF_LEFTUP    
#define	SF_B2_DOWN 		MOUSEEVENTF_RIGHTDOWN 
#define	SF_B2_UP 		MOUSEEVENTF_RIGHTUP   
#define	SF_ABSOLUTE 	MOUSEEVENTF_ABSOLUTE  
#endif

void pressMouseButtonDown(void);
void pressMouseButtonUp(void);
void setTheMouseAbsolute(int PosX,int PosY);

BOOL  bmouseanchored =  FALSE;           /* flag, if false, mouse not pinned to a point */
POINT mouseanchor;

#ifndef SPI_GETMOUSESPEED
#define SPI_GETMOUSESPEED   112
#endif

void SendMouseToQueue(MOUSEKEYSPARAM *p)
{
	SkEx_SendMouse(p);
}

void processMouReset(unsigned char cGideiCode)
{
	if (cGideiCode == TERMCODE) 
    {
		// mouse_event treats button parameters as state changes not as state
		// setting; when resetting, only release a button if it is already down

		mouData.Status = SF_ABSOLUTE | SF_MOVEMENT;
		if(GetAsyncKeyState(VK_LBUTTON) > 1)
			mouData.Status |= GetSystemMetrics(SM_SWAPBUTTON) ? SF_B2_UP : SF_B1_UP;
		if(GetAsyncKeyState(VK_RBUTTON) > 1)
			mouData.Status |= GetSystemMetrics(SM_SWAPBUTTON) ? SF_B1_UP : SF_B2_UP;

		mouData.Delta_Y = 0;
		mouData.Delta_X = 0;

		SendMouseToQueue(mouseDataPtr);
		mouseX = mouseY = 0;
	}
	else 
    {
		handleErrorReport();
		commandVector = noOpRoutine;
	}
	return;
}

void moveTheMouseAbsolute(void)
{
 	short tempX, tempY;

	tempX = tempList.list[1];
	tempX = (tempX << 8) + tempList.list[0];
	tempY = tempList.list[3];
	tempY = (tempY << 8) + tempList.list[2];

	mouseX = tempX;
	mouseY = tempY;
	setTheMouseAbsolute(tempX, tempY);
	return;
}

void setTheMouseAbsolute(int PosX,int PosY)
{
	mouData.Status = SF_ABSOLUTE | SF_MOVEMENT;
	mouData.Delta_Y = (int) 0;
	mouData.Delta_X = (int) 0;
	SendMouseToQueue(mouseDataPtr);

	mouData.Status = SF_MOVEMENT;
	mouData.Delta_Y = (int) PosY;
	mouData.Delta_X = (int) PosX;
	SendMouseToQueue(mouseDataPtr);
	return;	
}

void moveTheMouseRelative(void)
{
	short xDist, yDist, newX, newY;

	xDist = tempList.list[1];
	xDist = (xDist << 8) + tempList.list[0];
	yDist = tempList.list[3];
	yDist = (yDist << 8) + tempList.list[2];
	newX = mouseX + xDist;
	newY = mouseY + yDist;
	if (newX < 0) newX = 0;
	if (newY < 0) newY = 0;
	mouseX = newX;
	mouseY = newY;
	mouData.Status = SF_MOVEMENT;
	mouData.Delta_Y = (int) yDist;
	mouData.Delta_X = (int) xDist;
	SendMouseToQueue(mouseDataPtr);
	return;
}


void processMouAnchor(unsigned char cGideiCode)
{
	switch (cGideiCode) {
		case TERMCODE:

//			if (tempList.len < 4)
// 				for ( ; tempList.len >= 4; tempList.list[tempList.len++] = 0);

         if (bmouseanchored) /* if true, need to release mouse */
            {
            bmouseanchored = FALSE;
			 if (SkEx_GetAnchor(&mouseanchor))
               {
               setTheMouseAbsolute(mouseanchor.x,mouseanchor.y);
               mouseX = mouseanchor.x;
               mouseY = mouseanchor.y;
               }
            else
               SkEx_SendBeep();  

            }
         else /* if false, need to pin the mouse */
            {
			 SkEx_SetAnchor();
            bmouseanchored = TRUE;
            }

			tempList.len = 0;
			beginOK = TRUE;
			break;
//		case INTEGERCODE:
//			commandVector = collectGotoInteger;
//			beginOK = FALSE;
//			break;
		default:
			handleFatalError();
			break;
		}
	return;
}

void collectGotoInteger(unsigned char moveByte)
{
	if (tempList.len >= 4) handleFatalError();
	else {
		tempList.list[tempList.len++] = moveByte;
		if ((tempList.len == 2) || (tempList.len == 4)) commandVector = processMouGoto;
		}
	return;
}

void collectGotoByte(unsigned char moveByte)
{
	if (tempList.len >= 4) handleFatalError();
	else 
    {
        tempList.list[tempList.len++] = moveByte;
        if (moveByte >127) 
        {
            tempList.list[tempList.len++] = 0xFF;
        }
        else
        {
            tempList.list[tempList.len++] = 0;
        }
	    commandVector = processMouGoto;
	}
	return;
}

void processMouGoto(unsigned char cGideiCode)
{
	switch (cGideiCode) {
		case TERMCODE:
			if (tempList.len < 4)
				for ( ; tempList.len >= 4; tempList.list[tempList.len++] = 0);
			moveTheMouseAbsolute();
			tempList.len = 0;
			beginOK = TRUE;
			break;
		case BYTECODE:
			commandVector = collectGotoByte;
			beginOK = FALSE;
			break;
		case INTEGERCODE:
			commandVector = collectGotoInteger;
			beginOK = FALSE;
			break;
		default:
			handleFatalError();
			break;
		}
	return;
}

void collectMoveInteger(unsigned char moveByte)
{
	if (tempList.len >= 4) 
    {
        handleFatalError();
    }
	else 
    {
		tempList.list[tempList.len++] = moveByte;
		if ((tempList.len == 2) || (tempList.len == 4)) 
        {
            commandVector = processMouMove;
        }
	}
	return;
}

void collectMoveByte(unsigned char moveByte)
{
	if (tempList.len >= 4) 
    {
        handleFatalError();
    }
	else 
    {
		tempList.list[tempList.len++] = moveByte;
        if (moveByte >127)
        {
            tempList.list[tempList.len++] = 0xFF;
        }
        else
        {
            tempList.list[tempList.len++] = 0;
        }
		commandVector = processMouMove;
	}
	return;
}

void processMouMove(unsigned char cGideiCode)
{
	switch (cGideiCode) {
		case TERMCODE:
			if (tempList.len < 4)
				for ( ; tempList.len >= 4; tempList.list[tempList.len++] = 0);
			moveTheMouseRelative();
			tempList.len = 0;
			beginOK = TRUE;
			break;
		case BYTECODE:
			commandVector = collectMoveByte;
			beginOK = FALSE;
			break;
		case INTEGERCODE:
			commandVector = collectMoveInteger;
			beginOK = FALSE;
			break;
		default:
			handleFatalError();
			break;
		}
	return;
}

void pressMouseButtonDown()
{
	mouData.Status = 0;
	if (requestButton1) {
		if (!button1Status) {
			mouData.Status += SF_B1_DOWN;
			button1Status = TRUE;
			}
		}
	if (requestButton2) {
		if (!button2Status) {
			mouData.Status += SF_B2_DOWN;
			button2Status = TRUE;
			}
		}
	if (mouData.Status != 0) 
    {
        SendMouseToQueue(mouseDataPtr);
    }
	return;
}

void	pressMouseButtonUp()
{
	mouData.Status = 0;
	if (requestButton1) {
		if (button1Status) {
			mouData.Status += SF_B1_UP;
			button1Status = FALSE;
			}
		}
	if (requestButton2) {
		if (button2Status) {
			mouData.Status += SF_B2_UP;
			button2Status = FALSE;
			}
		}
	if (mouData.Status != 0) 
    {
        SendMouseToQueue(mouseDataPtr);
    }
	return;
}

void processMouRel(unsigned char cGideiCode)
{
	switch (cGideiCode) {
		case TERMCODE:
			if ((!requestButton1) && (!requestButton2) && (!requestButton3))
				requestButton1 = requestButton2 = requestButton3 = TRUE;
			pressMouseButtonUp();
			requestButton1 = requestButton2 = requestButton3 = FALSE;
			beginOK = TRUE;
			break;
		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			break;
		case DEFAULTCODE:
		case LEFTBUTTONCODE:
			requestButton1 = TRUE;
			beginOK = FALSE;
			break;
		case RIGHTBUTTONCODE:
			requestButton2 = TRUE;
			beginOK = FALSE;
			break;
		default:
			if (cGideiCode >= LOWESTGIDEICODE)
				{
				handleFatalError();
				break;
				}
			requestButton3 = TRUE;
			beginOK = FALSE;
			break;
		}
	return;
}

void processMouLock(unsigned char cGideiCode)
{
	switch (cGideiCode)
		{
		case TERMCODE:
			if ((!requestButton1) && (!requestButton2) && (!requestButton3))
				requestButton1 = TRUE;
			pressMouseButtonDown();
			requestButton1 = requestButton2 = requestButton3 = FALSE;
			beginOK = TRUE;
			break;
		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			break;
		case DEFAULTCODE:
		case LEFTBUTTONCODE:
			requestButton1 = TRUE;
			beginOK = FALSE;
			break;
		case RIGHTBUTTONCODE:
			requestButton2 = TRUE;
			beginOK = FALSE;
			break;
		default:
			if (cGideiCode >= LOWESTGIDEICODE)
				{
				handleFatalError();
				break;
				}
			requestButton3 = TRUE;
			beginOK = FALSE;
			break;
		}
	return;
}

void processMouDoubleClick(unsigned char cGideiCode)
{
	if (cGideiCode == TERMCODE) {
		if ((!requestButton1) && (!requestButton2) && (!requestButton3 ))
			requestButton1 = TRUE;
		mouData.Status = 0;
		if ((requestButton1) && (button1Status)) {
			mouData.Status += SF_B1_UP;
			button1Status = FALSE;
			}
		if ((requestButton2) && (button2Status)) {
			mouData.Status += SF_B2_UP;
			button2Status = FALSE;
			}
		if (!mouData.Status) 
        {
            SendMouseToQueue(mouseDataPtr);
        }
		pressMouseButtonDown();
		pressMouseButtonUp();
		pressMouseButtonDown();
		pressMouseButtonUp();
		requestButton1 = requestButton2 = requestButton3 = FALSE;
		beginOK = TRUE;
		}
	else
		processMouClick(cGideiCode);
	return;
}

void processMouClick(unsigned char cGideiCode)
{
	switch (cGideiCode)
		{
		case TERMCODE:
			if ((!requestButton1) && (!requestButton2) && (!requestButton3 ))
				requestButton1 = TRUE;
			mouData.Status = 0;
			if ((requestButton1) && (button1Status)) {
				mouData.Status += SF_B1_UP;
				button1Status = FALSE;
				}
			if ((requestButton2) && (button2Status)) {
				mouData.Status += SF_B2_UP;
				button2Status = FALSE;
				}
			if (!mouData.Status) 
            {
                SendMouseToQueue(mouseDataPtr);
            }
			pressMouseButtonDown();
			pressMouseButtonUp();
			requestButton1 = requestButton2 = requestButton3 = FALSE;
			beginOK = TRUE;
			break;
		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			break;
		case DEFAULTCODE:
		case LEFTBUTTONCODE:
			requestButton1 = TRUE;
			beginOK = FALSE;
			break;
		case RIGHTBUTTONCODE:
			requestButton2 = TRUE;
			beginOK = FALSE;
			break;
		default:
			if (cGideiCode >= LOWESTGIDEICODE)
				{
				handleFatalError();
				break;
				}
			requestButton3 = TRUE;
			beginOK = FALSE;
			break;
		}
	return;
}

void processMou(unsigned char cGideiCode)
{
	switch (cGideiCode) {
		case UNKNOWNCODE:
			handleErrorReport();
			commandVector = noOpRoutine;
			beginOK = TRUE;
			break;
		default:
			if (cGideiCode < LOWESTGIDEICODE) {
				handleErrorReport();
				commandVector = noOpRoutine;
				beginOK = TRUE;
				}
			else handleFatalError();
		}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\mou.h ===
/*  MOU.H  */


void processMouClick(unsigned char cGideiCode);
void processMou(unsigned char cGideiCode);
void processMouDoubleClick(unsigned char cGideiCode);
void processMouRel(unsigned char cGideiCode);

void processMouReset(unsigned char cGideiCode);
void processMouAnchor(unsigned char cGideiCode);
//void processMouPin(unsigned char cGideiCode);
void processMouGoto(unsigned char cGideiCode);
void processMouLock(unsigned char cGideiCode);
void processMouMove(unsigned char cGideiCode);
void pressMouseButtonUp();
void pressMouseButtonDown();
void moveTheMouseAbsolute(void);
void moveTheMouseRelative(void);
void collectGotoInteger(unsigned char moveByte);
void collectGotoByte(unsigned char moveByte);
void collectMoveInteger(unsigned char moveByte);
void collectMoveByte(unsigned char moveByte);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\sk_defs.h ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_defs.h
 *
 * PURPOSE:			Global Variables & Defines
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *--- Defines ---------------------------------------------------------*/

//	Commands Process by the Service  inside the MainService Routine

#ifdef DEFDATA
#define	EXTERN	
#define PATHSZ	MAX_PATH
#else
#define	EXTERN	extern
#define PATHSZ	
#endif

// Main Service Defines ---------------------------------------

#define	SC_CLEAR		0
#define SC_LOG_OUT		1
#define SC_LOG_IN		2
#define SC_CHANGE_COMM	3
#define SC_DISABLE_SKEY	4
#define SC_ENABLE_SKEY	5

// Variables ---------------------------------------------------


// Structures ---------------------------------------------------
EXTERN SERIALKEYS	skNewKey, skCurKey;
EXTERN LPSERIALKEYS lpskSKey;

EXTERN TCHAR szNewActivePort[PATHSZ];
EXTERN TCHAR szNewPort[PATHSZ];
EXTERN TCHAR szCurActivePort[PATHSZ];
EXTERN TCHAR szCurPort[PATHSZ];


#define	SERKF_ACTIVE		0x00000040

#define REG_DEF			1
#define REG_USER		2

#define ARRAY_SIZE(a)      (sizeof(a) / sizeof((a)[0]))

void DoServiceCommand(DWORD dwServiceCommand);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\sk_dllif.h ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_DLLIF.H
 *
 * PURPOSE:			The file contains data structures for the 
 *					transmission of information between the 
 *					SerialKeys and the DLL.
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *------------------------------------------------------------*/

typedef struct _SKEYDLL
{
	int		Message;					// Get or Set Changes
	DWORD	dwFlags;
	char	szActivePort[MAX_PATH];
	char	szPort[MAX_PATH];
	DWORD	iBaudRate;
	DWORD	iPortState;
	DWORD	iSave;						// TRUE - Write to Registry
} SKEYDLL;


// Messages

#define	SKEY_NAME			TEXT("\\\\.\\PIPE\\SKeys")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\sk_comm.h ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_COMM.H
 *
 * PURPOSE:			Function prototypes for Serial Keys Comm Routines
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *--------------------------------------------------------------*/

// Global Variables ---------------------------------


// Global Function ProtoTypes --------------------------------

BOOL	InitComm();
void	TerminateComm();

void 	SuspendComm();
void 	ResumeComm();

BOOL	StartComm();
void	StopComm();

void	SetCommBaud(int Baud);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\sk_comm.c ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_COMM.C
 *
 * PURPOSE:		The file contains the Functions responsible for
 *					managing the COMM ports
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * NOTES:		
 *					
 * This file, and all others associated with it contains trade secrets
 * and information that is proprietary to Black Diamond Software.
 * It may not be copied copied or distributed to any person or firm 
 * without the express written permission of Black Diamond Software. 
 * This permission is available only in the form of a Software Source 
 * License Agreement.
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *--- Includes  ---------------------------------------------------------*/

//#define	WINVER 0x0300

// added to be compatible with new windows.h (12/91) and wintric.h 
#define	USECOMM	

#include 	<stdio.h>
#include 	<stdlib.h>
#include	<process.h>

#include	"windows.h"
//#include "winstric.h"				// added for win 3.1 compatibility 1/92

#include	"gide.h"					// Serial Keys Function Proto
#include	"initgide.h"	   			// Serial Keys Function Proto
#include    "w95trace.h"
#include	"sk_defs.h"
#include	"sk_comm.h"
#include    "drivers.h"
#include	"sk_ex.h"

#define COMMTERMINATE 0xFFFFFFFF     // this 'character' indicates a request to terminate

// Local Function ProtoTypes --------------------------------

static BOOL	OpenComm();
static void	__cdecl ProcessComm(VOID *notUsed);
static int	ReadComm();


// Local Variables ---------------------------------------------------

static DCB	s_dcbCommNew;			// New DCB for comm port
static DCB	s_dcbCommOld;			// Origional DCB for comm port

static OVERLAPPED s_oRead;			// Overlapped structure for reading.

static	HANDLE	s_hFileComm;

static	HANDLE	s_hThreadComm = NULL;

static	HDESK	s_hdeskUser = NULL;

static	DWORD	s_NullTimer;
static	int		s_NullCount=0;

static	HANDLE  s_ahEvents[2] = {NULL, NULL};

#define iEventComm			0
#define iEventExit			1


/*---------------------------------------------------------------
 *
 *	Global Functions -
 *
 *---------------------------------------------------------------*/

 /*---------------------------------------------------------------
 *
 * FUNCTION	void InitComm()
 *
 * TYPE         Global
 *
 * PURPOSE		
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
BOOL InitComm()
{
    BOOL fOk = TRUE;

	DBPRINTF(TEXT("InitComm()\r\n"));

	// Create Event for Overlap File Read 
	s_ahEvents[iEventComm] = CreateEvent(NULL, TRUE, FALSE, NULL);	
	fOk = (NULL != s_ahEvents[iEventComm]);
	if (fOk) 
	{
		s_ahEvents[iEventExit] = CreateEvent(NULL, TRUE, FALSE, NULL);	
		fOk = (NULL != s_ahEvents[iEventExit]);
	}

	if (!fOk)
	{
		TerminateComm();
	}

	return(fOk);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void TerminateComm()
 *
 *	TYPE		Global
 *
 * PURPOSE		The function is called for the final shutdown of
 *				the comm port.
 *
 * INPUTS		None
 *
 * RETURNS		TRUE - Start Successful
 *				FALSE - Start Failed
 *
 *---------------------------------------------------------------*/
void TerminateComm()
{
	BOOL fOk;
	int i;

	DBPRINTF(TEXT("TerminateComm()\r\n"));

	StopComm();

	for (i = 0; i < ARRAY_SIZE(s_ahEvents); ++i)
	{
		if (NULL != s_ahEvents[i])
		{
			fOk = CloseHandle(s_ahEvents[i]);
			DBPRINTF_IF(fOk, TEXT("Unable to Close Event\r\n"));
			s_ahEvents[i] = NULL;
		}
	}

	return;
}


/*---------------------------------------------------------------
 *
 * FUNCTION	BOOL StartComm()
 *
 *	TYPE		Global
 *
 * PURPOSE		The function is call to start the thread to 
 *				read and process data coming from the comm port.
 *				It will create a thread and an event.  This function
 *				assumes that the comm port is already opened.
 *
 * INPUTS		None
 *
 * RETURNS		TRUE - Start Successful
 *				FALSE - Start Failed
 *
 *---------------------------------------------------------------*/
BOOL StartComm()
{
	BOOL fOk = TRUE;
	DWORD 	Id;

	DBPRINTF(TEXT("StartComm()\r\n"));

	// ----------------------------------------------------------
	// Note:	Comm Threads are started and stopped whenever
	// 			the com port is changed. The User logs in or out
	// 			or the comm configuration is changed.
	// ----------------------------------------------------------

	if (NULL == s_hFileComm && // no port currently in use
		(skNewKey.dwFlags & SERKF_AVAILABLE) &&
		(skNewKey.dwFlags & SERKF_SERIALKEYSON))
	{
		if (NULL != s_hThreadComm) 
		{
			// This is an unexpected situation.  We have the comm thread
			// running with no open comm port.  The thread must be hung.
			// Let's close the open handle and forget about it.

			DBPRINTF(TEXT("StartComm() unexpected (NULL != s_hThreadComm)\r\n"));
			WaitForSingleObject(s_hThreadComm, 5 * 1000);

			if (NULL != s_hThreadComm)
			{
				DBPRINTF(TEXT("StartComm() s_hThreadComm abandoned\r\n"));
				CloseHandle(s_hThreadComm);		
				s_hThreadComm = NULL;
			}
		}


		// skNewKey is used by OpenComm.  We're setting skCurKey to default
		// values in case OpenComm fails.

		skCurKey.iBaudRate = 300;				// No - Reset To Default Values
		skCurKey.iPortState= 0;
		skCurKey.dwFlags   = 0;
		lstrcpy(skCurKey.lpszActivePort, TEXT("COM1"));
		lstrcpy(skCurKey.lpszPort, TEXT("COM1"));

		if (!OpenComm())							// Did Comm Open Ok?
		{
			skNewKey.iBaudRate = 300;				// No - Reset To Default Values
			skNewKey.iPortState= 0;
			skNewKey.dwFlags   = 0;
			lstrcpy(skNewKey.lpszActivePort, TEXT("COM1"));
			lstrcpy(skNewKey.lpszPort, TEXT("COM1"));
			fOk = FALSE;
		}
		else
		{
            // ensure we start with clean events

			ResetEvent(s_ahEvents[iEventComm]);
            ResetEvent(s_ahEvents[iEventExit]);

			memset(&s_oRead, 0, sizeof(OVERLAPPED));	// Init Struct
			s_oRead.hEvent = s_ahEvents[iEventComm];	// Store Event

			// Create thread to handle Processing Comm Port
			s_hThreadComm = (HANDLE)CreateThread(	// Start Service Thread
				0, 0,
				(LPTHREAD_START_ROUTINE) ProcessComm,
				0, 0,&Id);							// argument to thread

			if (NULL == s_hThreadComm)// Is Thread Handle Valid?
			{
				// Close out the Comm Port
				SetCommState(s_hFileComm, &s_dcbCommOld);	// Restore Comm State 
				CloseHandle(s_hFileComm);
				s_hFileComm = NULL;
				skCurKey.iPortState = 0;

				fOk = FALSE;
			}
			else
			{
				// Comm Thread Successfully Started Set The Current Values
				skCurKey.iBaudRate = skNewKey.iBaudRate;
				skCurKey.iPortState	 = 2;
				skCurKey.dwFlags = SERKF_SERIALKEYSON	
									| SERKF_AVAILABLE	
									| SERKF_ACTIVE;

				lstrcpy(skCurKey.lpszActivePort, skNewKey.lpszActivePort);
				lstrcpy(skCurKey.lpszPort, skNewKey.lpszActivePort);

				DBPRINTF(TEXT("---- Comm Started\r\n"));
			}
		}
	}
	return(fOk);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void SuspendComm()
 *
 *	TYPE		Global
 *
 * PURPOSE		The function is called to Pause the thread  
 *				reading and processing data coming from the comm port.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SuspendComm()
{
	DBPRINTF(TEXT("SuspendComm()\r\n"));

	if (NULL != s_hThreadComm)
	{
		SuspendThread(s_hThreadComm);
	}
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void ResumeComm()
 *
 *	TYPE		Global
 *
 * PURPOSE		The function is called to resume the Paused thread.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void ResumeComm()
{
	if (s_hThreadComm != NULL)
		ResumeThread(s_hThreadComm);	
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void StopComm()
 *
 *	TYPE		Global
 *
 * PURPOSE		The function is called to stop the thread  
 *				reading and processing data coming from the comm port.
 *
 * INPUTS		None
 *
 * RETURNS		TRUE - Start Successful
 *				FALSE - Start Failed
 *
 *---------------------------------------------------------------*/
void StopComm()
{
	DBPRINTF(TEXT("StopComm()\r\n"));

	if (NULL != s_hFileComm)
	{
		skCurKey.dwFlags = SERKF_AVAILABLE;	

		SetEvent(s_ahEvents[iEventExit]);

		if (NULL != s_hThreadComm)
		{
			DWORD dwRet;
			BOOL fOk;

			dwRet = WaitForSingleObject(s_hThreadComm, 5 * 1000);
            DBPRINTF_IF(WAIT_OBJECT_0 == dwRet, TEXT("StopComm() Comm Thread may be hung.\r\n"));
			CloseHandle(s_hThreadComm);		
			s_hThreadComm = NULL;

			SetCommState(s_hFileComm, &s_dcbCommOld);	// Restore Comm State 
			fOk = CloseHandle(s_hFileComm);			// Close the Comm Port
			DBPRINTF_IF(fOk, TEXT("Unable to Close Comm File\r\n"));
			s_hFileComm = NULL;

			skCurKey.iPortState	 = 0;
		}
	}
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void SetCommBaud(int Baud)
 *
 *	TYPE		Global
 *
 * PURPOSE		
 *				
 *
 * INPUTS		None
 *
 * RETURNS		TRUE - Start Successful
 *				FALSE - Start Failed
 *
 *---------------------------------------------------------------*/
void SetCommBaud(int Baud)
{
	DBPRINTF(TEXT("SetCommBaud(%d)\r\n"), Baud);

	switch (Baud)				// Check for Valid Baud Rates
	{
		case 300:
		case 600:
		case 1200:
		case 2400:
		case 4800:
		case 9600:
		case 19200:
		case 110:
		case 14400:
		case 38400:
		case 56000:
		case 57600:
		case 115200:
			break;				// Baud Ok

		default:
			return;				// Baud Invalid
	}

	skNewKey.iBaudRate = Baud;				            // Save Baud

	if (NULL != s_hFileComm)						    // Is Comm Port Open?
	{
		s_dcbCommNew.BaudRate = skNewKey.iBaudRate;	    // Set new DCB Params
        if (SetCommState(s_hFileComm, &s_dcbCommNew))   // State Change Ok?
        {
		    skCurKey.iBaudRate = skNewKey.iBaudRate;	// Save New Baud Rate
        } else
        {
            DBPRINTF(TEXT("SetCommState(%d) FAILED!\r\n"), Baud);
            // failed to set baud rate; try to revert it
		    s_dcbCommNew.BaudRate = skCurKey.iBaudRate; // reset DCB Params
  		    if (!SetCommState(s_hFileComm, &s_dcbCommNew))
                DBPRINTF(TEXT("SetCommState(%d) FAILED!\r\n"), skCurKey.iBaudRate);
        }
	}
}

/*---------------------------------------------------------------
 *
 *		Local Functions
 *
/*---------------------------------------------------------------


/*---------------------------------------------------------------
 *
 * FUNCTION     void _CRTAPI1 ProcessComm()
 *
 *	TYPE		Local
 *
 * PURPOSE		The function is the thread the cycles thru reading
 *				processing data coming from the comm port.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void __cdecl ProcessComm(VOID *notUsed)
{
	int 	c;
	HWINSTA	hwinstaSave;
	HWINSTA	hwinstaUser;
	HDESK	hdeskSave;
	DWORD	dwThreadId;
	BOOL    fCont;

	//------------------------------------------------------
	//
	// Note:
	//	The following code set the input focus to the current
	//  desktop.  It is needed to insure that keyboard and mouse
	//	events  will be passed to the current desktop.
	//
	//------------------------------------------------------

	hwinstaSave = GetProcessWindowStation();
	dwThreadId = GetCurrentThreadId();
	hdeskSave = GetThreadDesktop(dwThreadId);

	hwinstaUser = OpenWindowStation(TEXT("WinSta0"), FALSE, MAXIMUM_ALLOWED);
	SetProcessWindowStation(hwinstaUser);


	serialKeysStartUpInit();				// Initialize the Serial Keys
	fCont = TRUE;

	while (fCont)
	{
		c = ReadComm();						// Read Char from Com Port
		switch (c)
		{
		case 0:
			// Is Character a Null

			// Is Null Timer > 30 Seconds
			if ((GetTickCount() - s_NullTimer) > 30000) 
			{
				s_NullTimer = GetTickCount();	// Yes - Reset Timer
				s_NullCount = 1;				// Reset Null Count
			} else 	{
				
				s_NullCount++;				// No - Inc Null Count
				if (s_NullCount == 3)		// Have we had 3 Null in 30 Sec.?
				{
					// the user is requesting us to reset
					SetCommBaud(300);		

					// DeskSwitch should be unnessary, but if it gets out of sync,
					// this is where we resync

					s_NullCount = 0;		// Reset Null Counter
				}
			}
			break;		
			
		case COMMTERMINATE:
			fCont = FALSE;
			break;

		default:
			DeskSwitchToInput();
			serialKeysBegin((UCHAR)c);	// Process Char
			break;

		}
	}

	SetThreadDesktop(hdeskSave);
	SetProcessWindowStation(hwinstaSave);
	CloseDesktop(s_hdeskUser);
	s_hdeskUser = NULL;
	CloseWindowStation(hwinstaUser);

	ExitThread(0);					// Close Thread
}


/*---------------------------------------------------------------
 *
 * BOOL IsCommPortName()
 *
 * Determines whether a given filename is a valid COM port name.
 * Used by OpenComm so that it doesn't open a remote file or named
 * pipe instead.
 *
 *---------------------------------------------------------------*/
static BOOL IsCommPortName( LPCTSTR pszFilename )
{
    // Ensure that filename has form:
    // COMn[n]\0
    LPCTSTR pScan = pszFilename;

    // Must start with COMn, where COM can be any case,
    // and n is any 0..9 digit.
    if( *pScan != 'C' && *pScan != 'c' )
        return FALSE;
    pScan++;
    if( *pScan != 'O' && *pScan != 'o' )
        return FALSE;
    pScan++;
    if( *pScan != 'M' && *pScan != 'm' )
        return FALSE;
    pScan++;

    if( *pScan < '0' || *pScan > '9' )
        return FALSE;
    pScan++;

/*
    // TODO: are COM54 really allowed?
    // Optional second digit
    if( *pScan >= '0' && *pScan <= '9' )
        pScan++;
*/

    // Manditory terminating nul
    if( *pScan != '\0' )
        return FALSE;

    return TRUE;
}

/*---------------------------------------------------------------
 *
 * FUNCTION	BOOL OpenComm()
 *
 *	TYPE		Local
 *
 * PURPOSE		This Function opens the comm port and sets the new
 *				sets the Device Control Block.
 *
 * INPUTS		None
 *
 * RETURNS		TRUE - Open Ok / FALSE - Open Failed
 *
 *---------------------------------------------------------------*/
static BOOL OpenComm()
{
	BOOL fOk = FALSE;
	COMMTIMEOUTS ctmo;

    // Check that the path we're given looks like a COM port.
    // (Not, eg, a remote file or named pipe.)
    if( ! IsCommPortName( skNewKey.lpszActivePort ) )
    {
		DBPRINTF(TEXT("- Not a COMn port\r\n"));
		s_hFileComm = NULL;
        return FALSE;
    }

    // The Security flags ensure that if we are duped into opening
    // a named pipe, we'll do so anonymously, so that we can't be
    // impersonated.
	s_hFileComm = CreateFile(
			skNewKey.lpszActivePort,// FileName (Com Port)
			GENERIC_READ ,			// Access Mode
			0,						// Share Mode
			NULL,					// Address of Security Descriptor
			OPEN_EXISTING,			// How to Create	
			FILE_ATTRIBUTE_NORMAL	// File Attributes
			| FILE_FLAG_OVERLAPPED  // Set for Async File Reads
            | SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS, // see above comment
  			NULL);					// Templet File.

	if (INVALID_HANDLE_VALUE == s_hFileComm)	// File Ok?
	{
		DBPRINTF(TEXT("- Invalid File\r\n"));

		s_hFileComm = NULL;
	}
	else
	{
		BOOL fRet;
		COMMPROP cmmp;

		SetupComm(
			s_hFileComm,
			1024,	// size of input buffer
			1024);	// size of output buffer

		memset(&s_dcbCommOld, 0, sizeof(s_dcbCommOld));
		s_dcbCommOld.DCBlength = sizeof(s_dcbCommOld);

		GetCommState(s_hFileComm, &s_dcbCommOld);	// Save Old DCB for restore
		s_dcbCommNew = s_dcbCommOld;	// Copy to New

		// set XoffLim and XonLim based on actual buffer size

		fRet = GetCommProperties(s_hFileComm, &cmmp);
		if (fRet)
		{
			s_dcbCommNew.XoffLim = (WORD)(cmmp.dwCurrentRxQueue / 4);
			s_dcbCommNew.XonLim = (WORD)(cmmp.dwCurrentRxQueue / 4);
		}

		s_dcbCommNew.BaudRate	= skNewKey.iBaudRate; 	// Set new DCB Params
		s_dcbCommNew.ByteSize	= 8;
		s_dcbCommNew.Parity 	= NOPARITY;
		s_dcbCommNew.StopBits	= ONESTOPBIT;
		s_dcbCommNew.fOutX 		= FALSE;  	// XOn/XOff used during transmission
  		s_dcbCommNew.fInX 		= TRUE;	  	// XOn/XOff used during reception 
  		s_dcbCommNew.fNull 		= FALSE;  	// tell windows not to strip nulls 
  		s_dcbCommNew.fBinary	= TRUE;

  		s_dcbCommNew.fOutxCtsFlow	= FALSE;
  		s_dcbCommNew.fOutxDsrFlow	= FALSE;
  		s_dcbCommNew.fDtrControl	= DTR_CONTROL_ENABLE;
  		s_dcbCommNew.fDsrSensitivity   = FALSE;
  		s_dcbCommNew.fErrorChar		= TRUE;
  		s_dcbCommNew.fRtsControl	= RTS_CONTROL_DISABLE;
  		s_dcbCommNew.fAbortOnError	= FALSE;
  		s_dcbCommNew.XonChar		= (char)0x11;
  		s_dcbCommNew.XoffChar		= (char)0x13;
  		s_dcbCommNew.ErrorChar		= '\0';

  		fOk = SetCommState(s_hFileComm, &s_dcbCommNew);

		memset(&ctmo, 0, sizeof(ctmo));
		SetCommTimeouts(s_hFileComm, &ctmo);
	}

	if (!fOk && NULL != s_hFileComm)
	{
		CloseHandle(s_hFileComm);
		s_hFileComm = NULL;
	}

	return(fOk);
}


/*---------------------------------------------------------------
 *
 * FUNCTION	int ReadComm()
 *
 *	TYPE		Local
 *
 * PURPOSE		This Function reads a character from the comm port.
 *				If no character is present it wait on the HEV_COMM
 *				Event untill a character is present
 *
 * INPUTS		None
 *
 * RETURNS		int - Character read (-1 = Error Read)
 *
 *---------------------------------------------------------------*/
static int ReadComm()
{
	int     nRet;
	DWORD	cbRead = 0;
	DWORD	lastError, ComError;
	DWORD	dwRetWait;
	BOOL    fOk;
	BOOL    fExit;

	BOOL	fExitLoop = FALSE;		// Boolean Flag to exit loop.
	UCHAR   uchBuff;
	COMSTAT ComStat;
	
	fExit = (WAIT_OBJECT_0 == WaitForSingleObject(s_ahEvents[iEventExit], 0));

	if (!fExit)
	{
		fOk = ReadFile(s_hFileComm, &uchBuff, 1, &cbRead, &s_oRead);

		if (!fOk)						// Was there a Read Error?
		{
			lastError = GetLastError();	// This var can be useful for debugging
			switch (lastError)			
			{
			// If Error = IO_PENDING, wait til
			// the event hadle signals success,
			case ERROR_IO_PENDING:
				dwRetWait = WaitForMultipleObjects(
					ARRAY_SIZE(s_ahEvents), s_ahEvents, FALSE, INFINITE);

				switch (dwRetWait - WAIT_OBJECT_0)
				{
				case iEventComm:
					// this is the expected event
					GetOverlappedResult(s_hFileComm, &s_oRead, &cbRead, FALSE);

					if (cbRead < 1)			// Did we read bytes;
					{
						// There was some error, return null
						nRet = 0;
					}
					else
					{
						nRet = uchBuff;
					}
					break;

				case iEventExit:
					fExit = TRUE;
					// fall through

				default:
					// this indicates and error and we exit to prevent loop
					nRet = COMMTERMINATE;
					break;
				}
				break;

			default:	
				fOk = ClearCommError(s_hFileComm, &ComError,&ComStat);
				if (fOk)
				{
					nRet = 0;          // return a null
				}
				else
				{
					nRet = COMMTERMINATE;        // terminate
				}
				break;
			}
		}
		else
		{
			if (cbRead < 1)			// Did we read bytes;
			{
				// There was some error, return null
				nRet = 0;
			}
			else
			{
				nRet = uchBuff;
			}

		}
	}
	if (fExit)
	{
		ResetEvent(s_ahEvents[iEventExit]);
		nRet = COMMTERMINATE;
	}
	return(nRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\sk_dll.h ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_DLL.H
 *
 * PURPOSE:			The file contains the Functions responsible for
 *					managing information passed between SerialKeys
 *					and the SerialKeys DLL
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *------------------------------------------------------------*/

// Global Variables ---------------------------------

// Global Function Prototypes ---------------------------------

BOOL DoneDLL();
BOOL InitDLL();
void ResumeDLL();
void SuspendDLL();
void TerminateDLL();

// Helper functions

PSECURITY_DESCRIPTOR CreateSd(unsigned long ulRights);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\sk_dll.c ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_DLL.C
 *
 * PURPOSE:		The file contains the Functions responsible for
 *					managing information passed between SerialKeys
 *					and the SerialKeys DLL
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * NOTES:		
 *					
 * This file, and all others associated with it contains trade secrets
 * and information that is proprietary to Black Diamond Software.
 * It may not be copied copied or distributed to any person or firm 
 * without the express written permission of Black Diamond Software. 
 * This permission is available only in the form of a Software Source 
 * License Agreement.
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *--- Includes  ---------------------------------------------------------*/
#include	<process.h>

#include	"windows.h"
#include    "w95trace.h"
#include	"sk_defs.h"
#include	"sk_reg.h"
#include	"sk_dll.h"
#include	"sk_dllif.h"
#include <malloc.h>

#ifdef DEBUG

    void dbg_Output(LPSTR Header)
    {
	    DBPRINTF(Header);
	    DBPRINTF(TEXT("-- dwFlags (%d)  iBaudRate (%d) Save (%d) iPortState (%d)\r\n"), SKeyDLL.dwFlags,SKeyDLL.iBaudRate,SKeyDLL.iSave,SKeyDLL.iPortState);
	    DBPRINTF(TEXT("-- ActivePort (%s) Port (%s)\r\n"),SKeyDLL.szActivePort,SKeyDLL.szPort);
    }

    #define	DBG_DUMP(Header)	dbg_Output(Header)
#else
    #define	DBG_DUMP(Header)	
#endif

// Defines --------------------------------------------------

// Local Function Prototypes ---------------------------------

static void CleanUpDLL();
static void GetCurrentValues();
static void GetNewValues();
static void ProcessDLL();
static BOOL ReadDLL();
static void __cdecl ServiceDLL(VOID *notUsed);
static BOOL WriteDLL();

// Local Variables --------------------------------------------------

static OVERLAPPED	OverLapRd;		// Overlapped structure for reading.
static SKEYDLL		SKeyDLL; 		// Input buffer for pipe.

static BOOL			fExitDLL; 			// Set Exit Flag
static BOOL			fDoneDLL = TRUE;

static	HANDLE		hPipeDLL;
static	HANDLE		hThreadDLL;

/*---------------------------------------------------------------
 *
 *	Global Functions 
 *
/*---------------------------------------------------------------
 *
 * FUNCTION	BOOL DoneDLL()
 *
 *	TYPE		Global
 *
 * PURPOSE		Returns the state of the DLL Thread
 *
 * INPUTS		None
 *
 * RETURNS		TRUE - DLL Thread not running
 * 			FALSE - DLL Thread Is running
 *
 *---------------------------------------------------------------*/
BOOL DoneDLL()
{
	return(fDoneDLL);
}

//-----------------------------------------------------------------------------
// CreateSd
//
// Creates a SECURITY_DESCRIPTOR with an authenticated user DACL and the
// rights specified by ulRights.
//
// Caller must call free() on the returned buffer if not NULL.
//
PSECURITY_DESCRIPTOR
CreateSd(unsigned long ulRights)
{
    PSECURITY_DESCRIPTOR pSd = NULL;
    PSID psidAuthentUser;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    // Make a SID for a local administrator
	if (AllocateAndInitializeSid(&NtAuthority, 2,
                 SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                 0, 0, 0, 0, 0, 0,
                 &psidAuthentUser))
    {
        // Calculate the size of and allocate a buffer for the DACL, we need
        // this value independently of the total alloc size for ACL init.

        ULONG cbAclSize = sizeof (ACL)
             + (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))
             + GetLengthSid(psidAuthentUser);

        pSd = malloc(SECURITY_DESCRIPTOR_MIN_LENGTH + cbAclSize);

        if (pSd) 
        {
            ACL *pAcl = (ACL *)((BYTE *)pSd + SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (   !InitializeAcl(pAcl, cbAclSize, ACL_REVISION)
                || !AddAccessAllowedAce(pAcl, ACL_REVISION, ulRights, psidAuthentUser)
                || !InitializeSecurityDescriptor(pSd, SECURITY_DESCRIPTOR_REVISION)
                || !SetSecurityDescriptorDacl(pSd, TRUE, pAcl, FALSE)) 
            {
                free(pSd);   // error!
                pSd = NULL;
            }
        }

        FreeSid(psidAuthentUser);
    }

    return pSd;
}

/*---------------------------------------------------------------
 *
 * FUNCTION	BOOL InitDLL()
 *
 *	TYPE		Global
 *
 * PURPOSE		This function creates a thread that monitors when an
 *				application uses the DLL to Get or Set the state
 *				of Serial Keys.  
 *
 * INPUTS		None
 *
 * RETURNS		TRUE - Init ok & Thread installed
 *				FALSE- Thread failed
 *
 *---------------------------------------------------------------*/
BOOL InitDLL()
{
	DWORD Id;
    PSECURITY_DESCRIPTOR pSD;
    SECURITY_ATTRIBUTES sa;

	DBPRINTF(TEXT("InitDLL()\r\n"));

	hPipeDLL	= INVALID_HANDLE_VALUE;
	hThreadDLL	= NULL;
	fExitDLL 	= FALSE;

    pSD = CreateSd(FILE_CREATE_PIPE_INSTANCE|GENERIC_READ|GENERIC_WRITE);
	if (!pSD)
		return(FALSE);

	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.bInheritHandle = TRUE;
	sa.lpSecurityDescriptor = pSD;

    hPipeDLL = CreateNamedPipe(
  		SKEY_NAME, 						// Pipe name
		PIPE_ACCESS_DUPLEX,	 			// 2 way pipe.
		PIPE_TYPE_MESSAGE | 
		PIPE_READMODE_MESSAGE | 
		PIPE_WAIT,
		1,							// Maximum instance limit.
		0,							// Buffer sizes.
		0,
		1000 * 30,					// Specify time out.
		&sa);						// Default securities specified.

	free(pSD);

	if (INVALID_HANDLE_VALUE == hPipeDLL)
	{
		hPipeDLL = NULL;
		DBPRINTF(TEXT("Unable to Create DLL Named Pipe\r\n"));
		return FALSE;
	}
	
	fDoneDLL = FALSE;  						// Clear Thread Done Flag

	// Generate thread to handle DLL processing;
	hThreadDLL = (HANDLE)CreateThread(	// Start Service Thread
		0,
		0,
		(LPTHREAD_START_ROUTINE) ServiceDLL,
		0,0,&Id);								// argument to thread

	if (NULL == hThreadDLL)
	{
		DBPRINTF(TEXT("Unable to Create DLL Thread\r\n"));
		CleanUpDLL();
		return FALSE;
	}

	return(TRUE);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void SuspendDLL()
 *
 *	TYPE		Global
 *
 * PURPOSE		The function is called to Pause the thread  
 *				reading and processing data coming from the comm port.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SuspendDLL()
{
	if (NULL != hThreadDLL)
	{
		SuspendThread(hThreadDLL);	
	}
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void ResumeDLL()
 *
 *	TYPE		Global
 *
 * PURPOSE		The function is called to resume the Paused thread.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void ResumeDLL()
{
	if (NULL != hThreadDLL)
	{
		ResumeThread(hThreadDLL);	
	}
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void TerminateDLL()
 *
 *	TYPE		Global
 *
 * PURPOSE		This function is called to Terminate the DLL Process
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void TerminateDLL()
{
	DWORD bytesRead;

	DBPRINTF(TEXT("TerminateDLL()\r\n"));

	if (fDoneDLL)
		return;

	fExitDLL = TRUE;					// Set Exit Flag

	CallNamedPipe						// Trigger the DLL to Shutdown
	(
		SKEY_NAME, 						// Pipe name
		&SKeyDLL, sizeof(SKeyDLL),
		&SKeyDLL, sizeof(SKeyDLL),
		&bytesRead, NMPWAIT_NOWAIT
	);
}

/*---------------------------------------------------------------
 *
 *	Local Functions 
 *
/*---------------------------------------------------------------
 *
 * FUNCTION    static void CleanUpDLL()
 *
 *	TYPE		Local
 *
 * PURPOSE		This function cleans up file handles and misc stuff
 *				when the thread is terminated.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void CleanUpDLL()
{
	BOOL	Stat;

	DBPRINTF(TEXT("CleanUpDLL()\r\n"));

	// Close Pipe Handle
	if (NULL != hPipeDLL)
	{
		Stat = CloseHandle(hPipeDLL);
		DBPRINTF_IF(Stat,TEXT("Unable to Close DLL Pipe\r\n"));
	}

	// Close Thread Handle 
	if (NULL != hThreadDLL)
	{
		Stat = CloseHandle(hThreadDLL);
		DBPRINTF_IF(Stat,TEXT("Unable to Close DLL Thread\r\n"));
	}

	hPipeDLL	= NULL;
	hThreadDLL	= NULL;
	fDoneDLL = TRUE;							// Set Thread Done Flag
	DBPRINTF(TEXT("DLL Service Processing Done\r\n"));
}

/*---------------------------------------------------------------
 *
 * FUNCTION     void _CRTAPI1 ServiceDLL()
 *
 *	TYPE		Local
 *
 * PURPOSE		This function is a thread that monitors when an
 *				application uses the DLL to Get or Set the state
 *				of Serial Keys.  
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void __cdecl ServiceDLL(VOID *notUsed)
{
	DWORD	retCode;
	DWORD	bytesRead;
	DWORD	bytesWritten;

	DBPRINTF(TEXT("SericeDLL()\r\n"));

	while (TRUE)
	{
		if (!ConnectNamedPipe(hPipeDLL,NULL))
		{
			ExitThread(0);
			return;
		}	

		if (fExitDLL)			// Is the Service Done?
		{						// Yes - Close Down Service
			CleanUpDLL();		// Close Handles Etc.
			ExitThread(0);		// Exit The Thread
			return;
		}
		
		retCode = ReadFile(		// Read Message
				hPipeDLL, 
				&SKeyDLL, 
				sizeof(SKeyDLL), 
				&bytesRead, 
				NULL);

		if (!retCode) 			// Pipe is Broken Try & reconnect
			continue;

		ProcessDLL();	  		// Yes - Process incoming buffer

		retCode = WriteFile(	// Write Message
			hPipeDLL, 
			&SKeyDLL, 
			sizeof(SKeyDLL), 
			&bytesWritten, 
			NULL);

		if (!retCode) 			// Pipe is Broken Try & reconnect
			continue;

		DisconnectNamedPipe(hPipeDLL);
	}
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void ProcessDLL()
 *
 *	TYPE		Local
 *
 * PURPOSE		This function process the input buffer received from
 *				the DLL.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void ProcessDLL()
{
	DWORD	dwService;

	DBPRINTF(TEXT("ProcessDLL()\r\n"));

	dwService = SC_CHANGE_COMM;			

	switch (SKeyDLL.Message)			// Validate Message
	{
		case SPI_GETSERIALKEYS:
			if (skCurKey.dwFlags & SERKF_ACTIVE)	// Are We Disabled?
				GetCurrentValues();					// No - Send the actual Values
			else
				GetNewValues();						// Yes - Send the Proposed values
			DBG_DUMP("---Info Sent");
			return;
			
		case SPI_SETSERIALKEYS:
			DBG_DUMP("---Info Received");
			if ((SKeyDLL.dwFlags & SERKF_SERIALKEYSON) &&	// Are We Truning on &
				(SKeyDLL.dwFlags & SERKF_AVAILABLE))		// Is SerialKeys Available
			{
				if (!(skCurKey.dwFlags & SERKF_ACTIVE))		// Are We Disabled?
				{
					dwService = SC_ENABLE_SKEY;				// Yes - Turn SKeys On
					DBPRINTF(TEXT("Turn Serial Key On\r\n"));
				}
			}

			if (!(SKeyDLL.dwFlags & SERKF_SERIALKEYSON) &&	// Are We Truning off &
				(SKeyDLL.dwFlags & SERKF_AVAILABLE))		// Is SerialKeys Available
			{
				if (skCurKey.dwFlags & SERKF_ACTIVE) 		// Are We Active?
				{
					dwService = SC_DISABLE_SKEY;  			// Yes - Turn SKeys Off
					DBPRINTF(TEXT("Turn Serial Key Off\r\n"));
				}
			}

			skNewKey.iBaudRate	= SKeyDLL.iBaudRate;
			skNewKey.dwFlags 	= SKeyDLL.dwFlags;

            // Ensure that the strings we've just read off the named pipe
            // are NUL-terminated before we use them.
            // (All port strings are MAX_PATH long - see sk_dllif.h, sk_defs.h)
            SKeyDLL.szActivePort[ MAX_PATH - 1 ] = '\0';
            SKeyDLL.szPort[ MAX_PATH - 1 ] = '\0';

#ifdef UNICODE
			MultiByteToWideChar(
				CP_ACP, 0, SKeyDLL.szActivePort, -1,
 				skNewKey.lpszActivePort, MAX_PATH);

			MultiByteToWideChar(
				CP_ACP, 0, SKeyDLL.szPort, -1,
				skNewKey.lpszPort, MAX_PATH);

            // Just in case either of the above fail (due to insufficient
            // buffer or other reason), forcibly NUL-terminate.
            skNewKey.lpszActivePort[ MAX_PATH - 1 ] = '\0';
            skNewKey.lpszPort[ MAX_PATH - 1 ] = '\0';
#else
			lstrcpy(skNewKey.lpszActivePort,SKeyDLL.szActivePort);
			lstrcpy(skNewKey.lpszPort,SKeyDLL.szPort);
#endif

			if (*skNewKey.lpszPort == 0)
			{
                lstrcpy(skNewKey.lpszPort, skNewKey.lpszActivePort);	
			}

			// the calling dll is now responsible for saving the
			// settings because it's running in the user context
			// and can access HKEY_CURRENT_USER.  Here we're
			// running as a service (as the system) and have
			// no HKEY_CURRENT_USER
			
			DoServiceCommand(dwService);

			Sleep(1000);							// Sleep 1 Sec to set values

			if (SKeyDLL.dwFlags & SERKF_SERIALKEYSON) 	// Are We Truning on 
				GetCurrentValues();					// Yes - Send the actual Values
			else
				GetNewValues();						// No - Send the Proposed values

			DBG_DUMP("---Info Sent");
			break;

		default:
			return;
	}
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void GetCurrentValues()
 *
 *	TYPE		Local
 *
 * PURPOSE		
 *				
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void GetCurrentValues()
{
	DBPRINTF(TEXT("GetCurrentValues()\r\n"));

#ifdef UNICODE
	WideCharToMultiByte(
		CP_ACP, 0, skCurKey.lpszActivePort, -1, 
		SKeyDLL.szActivePort, sizeof(SKeyDLL.szActivePort), NULL, NULL);

	WideCharToMultiByte(
		CP_ACP, 0, skCurKey.lpszPort, -1, 
		SKeyDLL.szPort, sizeof(SKeyDLL.szPort), NULL, NULL);
#else
	lstrcpy(SKeyDLL.szActivePort,skCurKey.lpszActivePort);
	lstrcpy(SKeyDLL.szPort,skCurKey.lpszPort);
#endif

	SKeyDLL.dwFlags		= skCurKey.dwFlags;
	SKeyDLL.iBaudRate	= skCurKey.iBaudRate;
	SKeyDLL.iPortState	= skCurKey.iPortState;
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void GetNewValues()
 *
 *	TYPE		Local
 *
 * PURPOSE		
 *				
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void GetNewValues()
{
	DBPRINTF(TEXT("GetNewValues()\r\n"));


    // FEATURE a-jimhar 04-03-96 this next line is suspect.  May need to 
	// change 'skCurKey.dwFlags' to 'skNewKey.dwFlags.  This is either
	// a mistake or was done to always return the current flags.

	SKeyDLL.dwFlags		= skCurKey.dwFlags;

	SKeyDLL.iBaudRate	= skNewKey.iBaudRate;
	SKeyDLL.iPortState	= skNewKey.iPortState;

#ifdef UNICODE
	WideCharToMultiByte(
		CP_ACP, 0, skNewKey.lpszActivePort, -1, 
		SKeyDLL.szActivePort, sizeof(SKeyDLL.szActivePort), NULL, NULL);

	WideCharToMultiByte(
		CP_ACP, 0, skNewKey.lpszPort, -1, 
		SKeyDLL.szPort, sizeof(SKeyDLL.szPort), NULL, NULL);
#else
	lstrcpy(SKeyDLL.szActivePort,skNewKey.lpszActivePort);
	lstrcpy(SKeyDLL.szPort,skNewKey.lpszPort);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\sk_ex.c ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_EX.C
 *
 * PURPOSE:		This File contains the interface routines
 *					that connect Serial Keys to the Mouse or keyboard.
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * NOTES:		
 *					
 * This file, and all others associated with it contains trade secrets
 * and information that is proprietary to Black Diamond Software.
 * It may not be copied copied or distributed to any person or firm 
 * without the express written permission of Black Diamond Software. 
 * This permission is available only in the form of a Software Source 
 * License Agreement.
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *--- Includes  ---------------------------------------------------------*/

#include	<windows.h>
#include    <winable.h>
#include    "w95trace.h"
#include 	"vars.h"
#include	"sk_defs.h"
#include	"sk_comm.h"
#include 	"sk_ex.H"

#ifdef QUEUE_BUF
typedef	struct _KEYQUE
{
	BYTE	VirKey;
	BYTE	ScanCode;
	int		Flags;
} KEYQUE;

#define MAXKEYS 100

KEYQUE KeyQue[MAXKEYS];
int	KeyFront = 0;		// Pointer to front of Que
int	KeyBack	= 0;		// Pointer to Back of Que
#endif


#define 	CTRL		56
#define 	ALT			29
#define 	DEL			83

char    Key[3];
int     Push = 0;

POINT 		MouseAnchor;
HWND		MouseWnd;

static	HDESK	s_hdeskSave = NULL;
static	HDESK	s_hdeskUser = NULL;


// Local Function Prototypes -------------------------------------

static void SendAltCtrlDel();
static void CheckAltCtrlDel(int scanCode);
static void AddKey(BYTE VirKey, BYTE ScanCode, int Flags);

/* 
AdjustPixels takes the point and adjusts it such that the  
mouse cursor moves in pixels.  The system applies acceleration
to the MOUSEINPUT {dx, dy} values then scales that based on mouse
speed so this code converts the pixels into MOUSEINPUT {dx, dy}
values.
*/

int g_aiMouseParms[3] = {-1, -1, -1};
float g_fSpeedScaleFactor = 0.0;

#define MOU_THRESHOLD_1  g_aiMouseParms[0]
#define MOU_THRESHOLD_2  g_aiMouseParms[1]
#define MOU_ACCELERATION g_aiMouseParms[2]
#define MOU_SPEED_SCALE  g_fSpeedScaleFactor

#ifndef SPI_GETMOUSESPEED
#define SPI_GETMOUSESPEED   112
#endif

void AdjustPixels(int *pX, int *pY)
{
    int iX = abs(*pX);
    int iY = abs(*pY);
    int iSignX = ((*pX) >= 0)?1:-1;
    int iSignY = ((*pY) >= 0)?1:-1;

    if (!iX && !iY)
        return; // optimization for {0,0} case

    if (MOU_THRESHOLD_1 == -1)
    {
        // This code assumes the user won't changes these settings 
        // from mouse CPL w/o restarting the service.
        int iSpeed;
        SystemParametersInfo(SPI_GETMOUSE, 0, g_aiMouseParms, 0);
        SystemParametersInfo(SPI_GETMOUSESPEED, 0, &iSpeed, 0);
        g_fSpeedScaleFactor = (float)iSpeed/(float)10.0;
    }

    /*
        The system applies two tests to the specified relative mouse motion 
        when applying acceleration. If the specified distance along either 
        the x or y axis is greater than the first mouse threshold value, and 
        the mouse acceleration level is not zero, the operating system doubles 
        the distance.  If the specified distance along either the x- or y-axis 
        is greater than the second mouse threshold value, and the mouse 
        acceleration level is equal to two, the operating system doubles the 
        distance that resulted from applying the first threshold test. It is 
        thus possible for the operating system to multiply relatively-specified 
        mouse motion along the x- or y-axis by up to four times.
    */
    if (MOU_ACCELERATION)
    {
        if (iX > MOU_THRESHOLD_1)
            iX /= 2;
        if (iY > MOU_THRESHOLD_1)
            iY /= 2;

        if (MOU_ACCELERATION == 2)
        {
            if (iX > MOU_THRESHOLD_2)
                iX /= 2;
            if (iY > MOU_THRESHOLD_2)
                iY /= 2;
        }
    }

    /*
        Once acceleration has been applied, the system scales the resultant 
        value by the desired mouse speed. Mouse speed can range from 1 (slowest) 
        to 20 (fastest) and represents how much the pointer moves based on the 
        distance the mouse moves. The default value is 10, which results in no 
        additional modification to the mouse motion. 
    */
    *pX = (int)((float)iX/MOU_SPEED_SCALE) * iSignX;
    *pY = (int)((float)iY/MOU_SPEED_SCALE) * iSignY;
}


/*---------------------------------------------------------------
 *	Public Functions
/*---------------------------------------------------------------
 *
 * FUNCTION	SkEx_SetAnchor()
 *
 *	TYPE		Global
 *
 * PURPOSE		Sets an anchor to the current mouse position within
 *				the current window.
 *				
 * INPUTS		int scanCode
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SkEx_SetAnchor()
{
	GetCursorPos(&MouseAnchor);

	DBPRINTF(TEXT("SkEx_SetAnchor( x %d y %d )\r\n"), MouseAnchor.x, MouseAnchor.y);

//	MouseWnd = GetActiveWindow();
//	ScreenToClient(MouseWnd, &MouseAnchor);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	SkEx_GetAnchor()
 *
 *	TYPE		Global
 *
 * PURPOSE		Returns the mouse postion within the active window
 *				
 * INPUTS		int scanCode
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
BOOL SkEx_GetAnchor(LPPOINT Mouse)
{
#if 0
	HWND	CurrentWnd;

	CurrentWnd = GetActiveWindow();

	if (CurrentWnd != MouseWnd)			// Has the Active window Changed?
		return(FALSE);					// Yes Return False

	ClientToScreen(MouseWnd, &MouseAnchor);	// Convert Window to Screen

#endif

	Mouse->x = MouseAnchor.x;
	Mouse->y = MouseAnchor.y;

	DBPRINTF(TEXT("SkEx_GetAnchor( x %d y %d )\r\n"), MouseAnchor.x, MouseAnchor.y);

	return(TRUE);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	SkEx_SendBeep()
 *
 *	TYPE		Global
 *
 * PURPOSE		Send Keyboard Down events to the Event Manager
 *				
 * INPUTS		int scanCode
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SkEx_SendBeep()
{
	MessageBeep(0);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	SkEx_SetBaud(int Baud)
 *
 *	TYPE		Global
 *
 * PURPOSE		Sets the Baudrate for the current port
 *				
 * INPUTS		int scanCode
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SkEx_SetBaud(int Baud)
{
	DBPRINTF(TEXT("SkEx_SetBaud()\r\n"));

	SetCommBaud(Baud);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	SkEx_SendKeyDown()
 *
 *	TYPE		Global
 *
 * PURPOSE		Send Keyboard Down events to the Event Manager
 *				
 * INPUTS		int scanCode
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SkEx_SendKeyDown(int scanCode)
{
	BYTE c;
	int	Flags = 0;

	if (scanCode & 0xE000)				// Is this and Extended Key
	{
		Flags  = KEYEVENTF_EXTENDEDKEY;	// Yes - Set Ext Flag
		scanCode &= 0x000000FF;			// Clear out extended value
	}
	c = (BYTE)MapVirtualKey(scanCode, 3);

	if (scanCode == ALT || scanCode == CTRL || scanCode == DEL)
		CheckAltCtrlDel(scanCode);

	DBPRINTF(TEXT("SkEx_SendKeyDown(Virtual %d Scan %d Flag %d)\r\n"), c, scanCode, Flags);

	DeskSwitchToInput();         
	keybd_event(c, (BYTE) scanCode, Flags, 0L);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	SkEx_SendKeyDown()
 *
 *	TYPE		Global
 *
 * PURPOSE		Send Keyboard Up events to the Event Manager
 *				
 * INPUTS		int scanCode
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SkEx_SendKeyUp(int scanCode)
{
	BYTE	c;
	int		Flags = 0;

	if (Push)
	{
		Key[0] = Key[1] = Key[2] = 0;	// Clear Buffer
		Push = 0;						// Reset AltCtrlDel
	}

	if (scanCode & 0xE000)				// Is this and Extended Key
	{
		Flags  = KEYEVENTF_EXTENDEDKEY;	// Yes - Set Ext Flag
		scanCode &= 0xFF;				// Clear out extended value
	}

	Flags += KEYEVENTF_KEYUP;
	c = (BYTE) MapVirtualKey(scanCode, 3);

	DBPRINTF(TEXT("SkEx_SendKeyUp(Virtual %d Scan %d Flags %d)\r\n"), c, scanCode, Flags);

    DeskSwitchToInput();         
	keybd_event(c, (BYTE) scanCode, Flags, 0L);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	SkEx_SendMouse()
 *
 *	TYPE		Global
 *
 * PURPOSE		Send Mouse Events to the Event manager
 *				
 * INPUTS		int scanCode
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SkEx_SendMouse(MOUSEKEYSPARAM *p)
{
    INPUT input;

    // According to GIDEI spec, the move command specifies pixels. 
    // SendInput adjusts the XY values based on acceleration and
    // mouse speed so we need to adjust them so the resulting move
    // is pixels.

    AdjustPixels(&p->Delta_X, &p->Delta_Y);

	DBPRINTF(TEXT("SkEx_SendMouse(Stat %d x %d y %d )\r\n"), p->Status, p->Delta_X, p->Delta_Y);

    memset(&input, 0, sizeof(INPUT));
    input.type = INPUT_MOUSE;
    input.mi.dx = p->Delta_X;
    input.mi.dy = p->Delta_Y;
    input.mi.dwFlags = p->Status;
    input.mi.dwExtraInfo = (DWORD)GetMessageExtraInfo();    // documented assignment; must be OK?

	DeskSwitchToInput();         

    if (!SendInput(1, &input, sizeof(INPUT)))
        DBPRINTF(TEXT("SkEx_SendMouse:  SendInput FAILED 0x%x\r\n"), GetLastError());
}

#ifdef QUEUE_BUF
/*---------------------------------------------------------------
 *
 * FUNCTION	SendKey()
 *
 *	TYPE		Global
 *
 * PURPOSE		This Function Send keys from the Que to Windows NT
 *				
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SendKey()
{
	if (KeyBack == KeyFront)		// Are there Keys in the Que?
		return;						// No - Exit;

	DBPRINTF(TEXT("SkEx_SendKey(KeyBack %d )\r\n"), KeyBack);

	DeskSwitchToInput();         
	keybd_event						// Process the Key Event
	(
		KeyQue[KeyBack].VirKey,
		KeyQue[KeyBack].ScanCode,
		KeyQue[KeyBack].Flags, 0L
	);

	KeyBack++;						// Increment Key pointer
	if (KeyBack == MAXKEYS)			// Are we at the End of the buffer
		KeyBack = 0;				// Yes - Reset to start.
}			  

/*---------------------------------------------------------------
 *	Local Functions
/*---------------------------------------------------------------
 *
 * FUNCTION	AddKey(BYTE VirKey, BYTE ScanCode, int Flags)
 *
 *	TYPE		Local
 *
 * PURPOSE		Adds a key to the Key Que.  
 *						   
 * INPUTS		BYTE 	VirKey 	- Virtual Key
 *				BYTE 	ScanCode- 
 *				int		Flags	-
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void AddKey(BYTE VirKey, BYTE ScanCode, int Flags)
{
	DBPRINTF(TEXT("AddKey(KeyFront %d )\r\n"), KeyFront);

	// Add Keys to Que
	KeyQue[KeyFront].VirKey 	= VirKey;	
	KeyQue[KeyFront].ScanCode	= ScanCode;
	KeyQue[KeyFront].Flags		= Flags;

	KeyFront++;							// Point to next Que
	if (KeyFront == MAXKEYS)			// Are we at the End of the buffer
		KeyFront = 0;					// Yes - Reset to start.

	// Process the Key Event
	DeskSwitchToInput();         
	keybd_event(VirKey, ScanCode, Flags, 0L);

}
#endif		// QUE

/*---------------------------------------------------------------
 *
 * FUNCTION	CheckAltCtrlDel(int scanCode)
 *
 *	TYPE		Local
 *
 * PURPOSE		Checks for the condition of Alt-Ctrl-Del key 
 *				Combination.
 *				
 * INPUTS		int scanCode
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void CheckAltCtrlDel(int scanCode)
{
	BOOL fCtrl = FALSE;
	BOOL fAlt = FALSE;
	BOOL fDel = FALSE;
	int i;

	DBPRINTF(TEXT("CheckAltCtrlDel()\r\n"));

    // Push is reset back to 0 when a key-up is received. We only
    // have space for three keys in the Key[] buffer, so make sure
    // there's space before we add a key...
    if( Push >= 3 )
        return;

	Key[Push] = (char)scanCode;		// Save Scan Code
	Push++;							// Inc Index

	if (Push != 3)					// Have we got 3 keys?
		return;						// No - Exit

	for ( i = 0; i < 3; i++ )
	{
		switch ( Key[i] )
		{
			case CTRL:	fCtrl = TRUE; break;
			case ALT:	fAlt = TRUE; break;
			case DEL:	fDel = TRUE; break;
		}
	}
	
	if ( fCtrl && fAlt && fDel )		// Is Buffer Alt=Ctrl=Del
		SendAltCtrlDel();			// Yes - Send command
		
}

/*---------------------------------------------------------------
 *
 * FUNCTION	SendAltCtrlDel()
 *
 *	TYPE		Local
 *
 * PURPOSE		Signal system reset
 *				
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void SendAltCtrlDel()
{
	HWINSTA hwinsta;
	HDESK hdesk;
	HWND hwndSAS;
	HWINSTA	hwinstaSave;
	HDESK	hdeskSave;

	DBPRINTF(TEXT("SendAltCtrlDel()\r\n"));

	hwinstaSave = GetProcessWindowStation();
	hdeskSave = GetThreadDesktop(GetCurrentThreadId());

	hwinsta = OpenWindowStation(TEXT("WinSta0"), FALSE, MAXIMUM_ALLOWED);
	SetProcessWindowStation(hwinsta);
	hdesk = OpenDesktop(TEXT("Winlogon"), 0, FALSE, MAXIMUM_ALLOWED);
	SetThreadDesktop(hdesk);

	hwndSAS = FindWindow(NULL, TEXT("SAS window"));
////PostMessage(hwndSAS, WM_HOTKEY, 0, 0);
	SendMessage(hwndSAS, WM_HOTKEY, 0, 0);

	if (NULL != hdeskSave)
	{
		SetThreadDesktop(hdeskSave);
	}

	if (NULL != hwinstaSave)
	{
		SetProcessWindowStation(hwinstaSave);
	}
	
	CloseDesktop(hdesk);
	CloseWindowStation(hwinsta);
}

BOOL DeskSwitchToInput()
{
	BOOL fOk = FALSE;
	HANDLE	hNewDesktop;

	// We are switching desktops
	
	// get current Input desktop
	hNewDesktop = OpenInputDesktop(		
			0L,
			FALSE,
			MAXIMUM_ALLOWED);

	if (NULL == hNewDesktop)
	{
		DBPRINTF(TEXT("OpenInputDesktop failed\r\n"));
	}
	else
	{
		fOk = SetThreadDesktop(hNewDesktop);	// attach thread to desktop
		if (!fOk)
		{
			DBPRINTF(TEXT("Failed SetThreadDesktop()\r\n"));
		}
		else
		{
			if (NULL != s_hdeskUser)
			{
				CloseDesktop(s_hdeskUser);		// close old desktop
			}
			s_hdeskUser = hNewDesktop;		// save desktop
		}
	}
	return(fOk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\skeys.c ===
/*--------------------------------------------------------------
 *
 * FILE:			SKeys.c
 *
 * PURPOSE:		The main interface routines between the service
 *					manager and the Serial Keys program.
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak
 *
 * NOTES:
 *
 * This file, and all others associated with it contains trade secrets
 * and information that is proprietary to Black Diamond Software.
 * It may not be copied copied or distributed to any person or firm
 * without the express written permission of Black Diamond Software.
 * This permission is available only in the form of a Software Source
 * License Agreement.
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *--- Includes  ---------------------------------------------------------*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>
#include "vars.h"
#include "w95trace.c"

#define DEFDATA	1
#include "sk_defs.h"
#include "sk_comm.h"
#include "sk_reg.h"
#include "sk_dll.h"
#include "sk_login.h"

#include	"sk_ex.h"

#include	"..\skdll\skeys.h"

#define LONGSTRINGSIZE 1024

#define WAITMAX 0x7FFFFFFF

#define RUNNINGEVENT TEXT("SkeysRunning")

#if defined(DEBUG) && 0
	// give us a long time to startup in case we're debugging
	#define WAITSTARTUP WAITMAX  
#else
	// normal startup time
	#define WAITSTARTUP 60000
#endif


// --- Local Variables  --------------------------------------------------

static SERVICE_STATUS_HANDLE   s_sshStatusHandle;
static SERVICE_STATUS          s_ssStatus;       // current status of the service

PTSTR SERVICENAME = TEXT("SerialKeys");
PTSTR SKEYSUSERINITCMD = TEXT("SKEYS /I");
PTSTR WINLOGONPATH = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
PTSTR USERINIT = TEXT("Userinit");
PTSTR USERINITCMDSEP = TEXT(",");

DWORD   s_dwServiceCommand;

static HANDLE s_hEventServiceRequest = NULL;
static HANDLE s_hEventServiceRequestReady = NULL;
static HANDLE s_hEventServiceTerminate = NULL;
static HANDLE s_hEventSkeysServiceRunning = NULL;

void DoService();
void DoInit();
void InstallUserInit();
BOOL IsSerialKeysAutoStart();


//--- SCM Function Prototypes  ------------------------------------------------
//
// Note:	The following fuctions manage the connection of the service
//			with the Service Contol Manager.

void	PostEventLog(LPTSTR lpszMsg,DWORD Error);

VOID	ServiceMain(DWORD dwArgc, LPTSTR *ppszArgv);

VOID	StopSerialKeys(LPTSTR lpszMsg);
BOOL	ReportStatusToSCMgr(DWORD dwCurrentState,
                            DWORD dwWin32ExitCode,
                            DWORD dwCheckPoint,
                            DWORD dwWaitHint);

LPHANDLER_FUNCTION ServiceCtrl(DWORD dwCtrlCode);

// Service Routines -----------------------------------------------
//
// Note:	The following fuctions manage the internal control of the
//			Service
static void InitReg();
static BOOL	InitService();
static void PauseService();
static void	ProcessService();
static void	ResumeService();
static void	TerminateService();

static void	ProcessLogout(DWORD dwCtrlType);
static BOOL	InstallLogout();
static BOOL	TerminateLogout();
static void EnableService(BOOL fOn);

// CONSIDER - Removing this code.  It only gets executed when SKeys is 
// run from the command line.  When run as a service, ServiceMain is
// called when the service is started.  The sources file pulls in
// winmain from the runtime lib.  DoInit and DoService could also be
// removed with _tWinMain.

int WINAPI _tWinMain(
    HINSTANCE hInstance,	
    HINSTANCE hPrevInstance,
    PTSTR pszCmdLine,	
    int nCmdShow)
{

	if ((TEXT('/') == pszCmdLine[0] || TEXT('-') == pszCmdLine[0]) &&
  		(TEXT('I') == pszCmdLine[1] || TEXT('i') == pszCmdLine[1]))
	{
        DoInit();
	}
	else
	{
		DoService();
	}

	ExitProcess(0);
	return(0);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	DoInit()
 *
 *	TYPE		Global
 *
 * PURPOSE		This function is called to read skeys configuration
 *              from HKEY_CURRENT_USER at logon session startup and
 *              send the information to the service
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void DoInit()
{
    HANDLE hEventSkeysServiceRunning = NULL;
    PSECURITY_DESCRIPTOR pSD;
    SECURITY_ATTRIBUTES sa;

    pSD = CreateSd(SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE);
    if (pSD)
    {
		sa.nLength = sizeof(sa);
		sa.bInheritHandle = TRUE;
		sa.lpSecurityDescriptor = pSD;

		hEventSkeysServiceRunning = CreateEvent(
			&sa,	// Security
			TRUE,	// Manual reset?
			FALSE,  // initial state - not signaled
			RUNNINGEVENT);  // name

        free(pSD);
    }

    if (NULL != hEventSkeysServiceRunning)
	{
		DWORD dwWait;

		dwWait = WaitForSingleObject(hEventSkeysServiceRunning, 60 * 1000);

		if (WAIT_OBJECT_0 == dwWait)
		{
			SKEY_SystemParametersInfo((UINT)SK_SPI_INITUSER, 0, NULL, 0);
		}
        CloseHandle(hEventSkeysServiceRunning);
    }
	
	return;
}


/*---------------------------------------------------------------
 *
 *		SCM Interface Functions
 *
/*---------------------------------------------------------------
 *
 * FUNCTION	DoService()
 *
 *	TYPE		Global
 *
 * PURPOSE		all DoService does is call StartServiceCtrlDispatcher
 *				to register the main service thread.  When the
 *				API returns, the service has stopped, so exit.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void DoService()
{
	SERVICE_TABLE_ENTRY dispatchTable[] =
	{
		{ SERVICENAME, (LPSERVICE_MAIN_FUNCTION)ServiceMain },
		{ NULL, NULL }
	};
    PSECURITY_DESCRIPTOR pSD;
    SECURITY_ATTRIBUTES sa;

    s_hEventServiceRequest = CreateEvent(
		NULL,	// Security
		FALSE,	// Manual reset?
		FALSE,  // initial state - not signaled
		NULL);  // name

    s_hEventServiceRequestReady = CreateEvent(
		NULL,	// Security
		FALSE,	// Manual reset?
		TRUE,  // initial state - signaled (can accept one request even before ready)
		NULL);  // name

    s_hEventServiceTerminate = CreateEvent(
		NULL,	// Security
		TRUE,	// Manual reset?
		FALSE,  // initial state - not signaled
		NULL);  // name

    s_hEventSkeysServiceRunning = NULL;

    pSD = CreateSd(SYNCHRONIZE|EVENT_MODIFY_STATE|GENERIC_READ|GENERIC_WRITE);
    DBPRINTF(TEXT("DoService:  CreateSd %s\r\n"), (pSD)?TEXT("Succeeded"):TEXT("Failed"));
    if (pSD)
	{
		sa.nLength = sizeof(sa);
		sa.bInheritHandle = TRUE;
		sa.lpSecurityDescriptor = pSD;

		s_hEventSkeysServiceRunning = CreateEvent(
			&sa,	// Security
			TRUE,	// Manual reset?
			FALSE,  // initial state - not signaled
			RUNNINGEVENT);  // name

        free(pSD);
	}

    if (NULL != s_hEventServiceRequest &&
		NULL != s_hEventServiceRequestReady &&
		NULL != s_hEventServiceTerminate &&
		NULL != s_hEventSkeysServiceRunning)
	{
        DBPRINTF(TEXT("DoService:  calling StartServiceCtrlDispatcher... \r\n"));
		if (!StartServiceCtrlDispatcher(dispatchTable))
        {
            DBPRINTF(TEXT("DoService:  StartServiceCtrlDispatcher FAILED\r\n"));
			StopSerialKeys(TEXT("StartServiceCtrlDispatcher failed."));
        }
    }
	else
	{
        DBPRINTF(TEXT("DoService:  Unable to create event %p %p %p %p\r\n"), s_hEventServiceRequest, s_hEventServiceRequestReady, s_hEventServiceTerminate, s_hEventSkeysServiceRunning);
		StopSerialKeys(TEXT("Unable to create event."));
	}
	
	if (NULL != s_hEventServiceRequest)
	{
	    CloseHandle(s_hEventServiceRequest);
	}

	if (NULL != s_hEventServiceRequestReady)
	{
        CloseHandle(s_hEventServiceRequestReady);
	}

	if (NULL != s_hEventServiceTerminate)
	{
        CloseHandle(s_hEventServiceTerminate);
	}

	if (NULL != s_hEventSkeysServiceRunning)
	{
		ResetEvent(s_hEventSkeysServiceRunning);
        CloseHandle(s_hEventSkeysServiceRunning);
	}
}

/*---------------------------------------------------------------
 *
 * FUNCTION	ServiceMain()
 *
 *	TYPE		Global
 *
 * PURPOSE		this function takes care of actually starting the service,
 *				informing the service controller at each step along the way.
 *				After launching the worker thread, it waits on the event
 *				that the worker thread will signal at its termination.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
VOID ServiceMain(DWORD dwArgc, LPTSTR *ppszArgv)
{
	DBPRINTF(TEXT("ServiceMain()\r\n"));

	//
	// SERVICE_STATUS members that don't change
	s_ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
	s_ssStatus.dwServiceSpecificExitCode = 0;
    
	//
	// register our service control handler:
	s_sshStatusHandle = RegisterServiceCtrlHandler(
			SERVICENAME,
			(LPHANDLER_FUNCTION) ServiceCtrl);

	if (!s_sshStatusHandle)
	{
		TerminateService(GetLastError());
		return;
	}

	// report the status to Service Control Manager.
	ReportStatusToSCMgr(
				SERVICE_START_PENDING,	// service state
				NO_ERROR,				// exit code
				1,						// checkpoint
				WAITSTARTUP);			// wait hint

#if defined(DEBUG) && 0  /////////////////////////////////////////////////
	// This debug code gives us time to attach a debugger

    {
		int i;

		for (i = 0; i < 180; i++)  // 180 sec = 3 min
		{
			Sleep(1000);  // one second
		}
    }
#endif ////////////////////////////////////////////////////////

	InitReg();
	GetUserValues(REG_DEF);

////EnableService(skNewKey.dwFlags & SERKF_SERIALKEYSON);

	if (!InitService())					// Did Service Initiate successfully?
	{
		TerminateService(GetLastError());		// No Terminate With Error
		return;
	}

	ReportStatusToSCMgr(	// report status to service manager.
		SERVICE_RUNNING,	// service state
		NO_ERROR,			// exit code
		0,					// checkpoint
		0);					// wait hint
	
	SetEvent(s_hEventSkeysServiceRunning);

	ProcessService();					// Process the Service
	TerminateService(0);				// Terminate
	return;
}


BOOL IsSerialKeysAutoStart()
{
	BOOL fAutoStart = FALSE;
	BOOL fOk;

	SC_HANDLE   schService = NULL;
	SC_HANDLE   schSCManager = NULL;

	schSCManager = OpenSCManager(   // Open Service Manager
		NULL,                       // machine (NULL == local)
	    NULL,                       // database (NULL == default)
		MAXIMUM_ALLOWED);

	if (NULL != schSCManager)  // Did Open Service succeed?
	{
	    schService = OpenService(
			    schSCManager ,
			    __TEXT("SerialKeys"),
			    MAXIMUM_ALLOWED);

	    if (NULL != schService)
		{
			BYTE abServiceConfig[1024];
			LPQUERY_SERVICE_CONFIG pqsc = (LPQUERY_SERVICE_CONFIG)abServiceConfig;
			DWORD cbBytesNeeded;

			fOk = QueryServiceConfig(
				schService,
				pqsc,
				sizeof(abServiceConfig),
				&cbBytesNeeded);

			if (fOk)
			{
				fAutoStart = (SERVICE_AUTO_START == pqsc->dwStartType);
			}
	        CloseServiceHandle(schService);
		}
        CloseServiceHandle(schSCManager);
    }

	return fAutoStart;
}


void InstallUserInit()
{
	BOOL fOk = FALSE;
    HKEY  hkey;
	LONG lErr;
	DWORD dwType;
	TCHAR szUserinit[LONGSTRINGSIZE];
	DWORD cbData = sizeof(szUserinit);

	lErr = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
        WINLOGONPATH,
		REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        &hkey); 
	
    if (ERROR_SUCCESS == lErr)
	{
		lErr = RegQueryValueEx(
                hkey,
                USERINIT,
                0,
                &dwType,
                (LPBYTE)szUserinit,
                &cbData);
		szUserinit[LONGSTRINGSIZE-1]='\0';

		if (ERROR_SUCCESS == lErr && dwType == REG_SZ)
		{
			// check to see if we are already installed and if we have
			// enough room to install
			// the + 2 allows for the terminating null and for the command seperator char

			if (NULL == _tcsstr(szUserinit, SKEYSUSERINITCMD) &&
				    lstrlen(szUserinit) + lstrlen(SKEYSUSERINITCMD) + 2 < 
					        ARRAY_SIZE(szUserinit))
			{
				lstrcat(szUserinit, USERINITCMDSEP);
				lstrcat(szUserinit, SKEYSUSERINITCMD);

				RegSetValueEx(
					hkey,
					USERINIT,
                    0,
					REG_SZ,
				    (CONST LPBYTE)szUserinit,
				    (lstrlen(szUserinit) + 1) * 
					    sizeof(*szUserinit));
			}
		}
		RegCloseKey(hkey);
	}
    return;
}

void RemoveUserInit()
{
	BOOL fOk = FALSE;
    HKEY  hkey;
	LONG lErr;
	DWORD dwType;
	TCHAR szUserinit[LONGSTRINGSIZE];
	PTSTR pszDest;
	PTSTR pszSrc;
	DWORD cbData = sizeof(szUserinit);

	lErr = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
        WINLOGONPATH,
		REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        &hkey); 
	
    if (ERROR_SUCCESS == lErr)
	{
		lErr = RegQueryValueEx(
                hkey,
                USERINIT,
                0,
                &dwType,
                (LPBYTE)szUserinit,
                &cbData);
		szUserinit[LONGSTRINGSIZE-1]='\0';

		if (ERROR_SUCCESS == lErr && dwType == REG_SZ)
		{

			// check to see if we are already installed
			pszDest = _tcsstr(szUserinit, SKEYSUSERINITCMD);
			if (NULL != pszDest)
			{
				pszSrc =_tcsstr(pszDest, USERINITCMDSEP);
				if (NULL != pszSrc)
				{
					_tcscpy(pszDest, pszSrc+1);
				}
				else
				{
					while(szUserinit < pszDest && *SKEYSUSERINITCMD != *pszDest)
					{
						--pszDest;
					}
					*pszDest = 0;  // null terminate
				}
			}

			RegSetValueEx(
				hkey,
				USERINIT,
                0,
				REG_SZ,
				(CONST LPBYTE)szUserinit,
				(lstrlen(szUserinit) + 1) * 
					sizeof(*szUserinit));
		}
		RegCloseKey(hkey);
	}
    return;
}

static void EnableService(BOOL fOn)
{
	SC_HANDLE   schService = NULL;
	SC_HANDLE   schSCManager = NULL;

	schSCManager = OpenSCManager(   // Open Service Manager
		NULL,                       // machine (NULL == local)
	    NULL,                       // database (NULL == default)
		MAXIMUM_ALLOWED);

	if (NULL != schSCManager)  // Did Open Service succeed?
	{
	    schService = OpenService(
			    schSCManager ,
			    __TEXT("SerialKeys"),
			    SERVICE_CHANGE_CONFIG | SERVICE_STOP);

	    if (NULL != schService)
		{
			ChangeServiceConfig(
				schService,
				SERVICE_WIN32_OWN_PROCESS,
				(fOn) ? SERVICE_AUTO_START : SERVICE_DEMAND_START,
				SERVICE_NO_CHANGE,		// severity if service fails to start 
				NULL,					// pointer to service binary file name 
				NULL,					// pointer to load ordering group name 
				NULL,					// pointer to variable to get tag identifier 
				NULL,					// pointer to array of dependency names 
				NULL,					// pointer to account name of service 
				NULL,					// pointer to password for service account  
				__TEXT("SerialKeys"));	// name to display 

	        CloseServiceHandle(schService);
		}

        CloseServiceHandle(schSCManager);
    }

	if (fOn)
	{
		InstallUserInit();
	}
	else
	{
		RemoveUserInit();
	}

    return;
}


//---------------------------------------------------------------
//
// FUNCTION	void ServiceCtrl(DWORD dwCtrlCode)
//
//	TYPE		Global
//
// PURPOSE		this function is called by the Service Controller whenever
//				someone calls ControlService in reference to our service.
//
// INPUTS		DWORD dwCtrlCode -
//
// RETURNS		None
//
//-----------------------------------------------------------------
LPHANDLER_FUNCTION ServiceCtrl(DWORD dwCtrlCode)
{
	DWORD	dwState = SERVICE_RUNNING;
	DWORD	dwWait = 0;

	DBPRINTF(TEXT("ServiceCtrl()\r\n"));

	// Handle the requested control code.

	switch(dwCtrlCode)
	{
		case SERVICE_CONTROL_PAUSE:			// Pause the service if it is running.
			if (s_ssStatus.dwCurrentState == SERVICE_RUNNING)
			{
				PauseService();
				dwState = SERVICE_PAUSED;
			}
			break;

		case SERVICE_CONTROL_CONTINUE:		// Resume the paused service.
			if (s_ssStatus.dwCurrentState == SERVICE_PAUSED)
			{
				ResumeService();
				dwState = SERVICE_RUNNING;
			}
			break;

		case SERVICE_CONTROL_STOP:			// Stop the service.
			// Report the status, specifying the checkpoint and waithint,
			//  before setting the termination event.
			if (s_ssStatus.dwCurrentState == SERVICE_RUNNING)
			{
				dwState = SERVICE_STOP_PENDING;
				dwWait = 20000;
				SetEvent(s_hEventServiceTerminate);
			}
			break;

		case SERVICE_CONTROL_INTERROGATE:	// Update the service status.
		default:							// invalid control code
			break;
    }
	// send a status response.
    ReportStatusToSCMgr(dwState, NO_ERROR, 0, dwWait);
	 return(0);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	BOOL		ReportStatusToSCMgr()
 *
 *	TYPE		Global
 *
 * PURPOSE		This function is called by the ServMainFunc() and
 *				ServCtrlHandler() functions to update the service's status
 *				to the service control manager.
 *
 * INPUTS		DWORD	dwCurrentState
 *				DWORD	dwWin32ExitCode
 *				DWORD	dwCheckPoint
 *				DWORD	dwWaitHint
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                    DWORD dwWin32ExitCode,
                    DWORD dwCheckPoint,
                    DWORD dwWaitHint)
{
	BOOL fResult;

#ifdef DEBUG
{
	switch (dwCurrentState)
	{
		case SERVICE_START_PENDING:
			DBPRINTF(TEXT("ReportStatusToSCMgr(SERVICE_START_PENDING:)\r\n"));
			break;
		case SERVICE_PAUSED:
			DBPRINTF(TEXT("ReportStatusToSCMgr(SERVICE_PAUSED:)\r\n"));
			break;
		case SERVICE_CONTINUE_PENDING:
			DBPRINTF(TEXT("ReportStatusToSCMgr(SERVICE_CONTINUE_PENDING:)\r\n"));
			break;
		case SERVICE_STOP_PENDING:
			DBPRINTF(TEXT("ReportStatusToSCMgr(SERVICE_STOP_PENDING:)\r\n"));
			break;
		case SERVICE_STOPPED:
			DBPRINTF(TEXT("ReportStatusToSCMgr(SERVICE_STOPPED:)\r\n"));
			break;
		case SERVICE_RUNNING:
			DBPRINTF(TEXT("ReportStatusToSCMgr(SERVICE_RUNNING:)\r\n"));
			break;

		default:
			DBPRINTF(TEXT("ReportStatusToSCMgr(ERROR - SERVICE_UNKNOWN)\r\n"));
			break;
	}
}
#endif


    switch (dwCurrentState)
	{
	case SERVICE_STOPPED:
	case SERVICE_START_PENDING:
	case SERVICE_STOP_PENDING:
		s_ssStatus.dwControlsAccepted = 0;
		break;
    default:
    	s_ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |	SERVICE_ACCEPT_PAUSE_CONTINUE;
		break;
	}

	// These SERVICE_STATUS members are set from parameters.
	s_ssStatus.dwCurrentState	= dwCurrentState;
	s_ssStatus.dwWin32ExitCode	= dwWin32ExitCode;
	s_ssStatus.dwCheckPoint		= dwCheckPoint;
	s_ssStatus.dwWaitHint		= dwWaitHint;

	// Report the status of the service to the service control manager.

	fResult = SetServiceStatus(
		s_sshStatusHandle,				// service reference handle
		&s_ssStatus); 					// SERVICE_STATUS structure

	if (!fResult)
	{
		StopSerialKeys(TEXT("SetServiceStatus")); // If an error occurs, stop the service.
	}
	return fResult;
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void StopSerialKeys(LPTSTR lpszMsg)
 *
 *	TYPE		Global
 *
 * PURPOSE		The StopSerialKeys function can be used by any thread
 *				to report an error, or stop the service.
 *
 * INPUTS		LPTSTR lpszMsg -
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
VOID StopSerialKeys(LPTSTR lpszMsg)
{
	DBPRINTF(TEXT("StopSerialKeys()\r\n"));

	PostEventLog(lpszMsg,GetLastError());	// Post to Event Log
	SetEvent(s_hEventServiceTerminate);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void PostEventLog(LPTSTR lpszMsg, DWORD Error)
 *
 *	TYPE		Local
 *
 * PURPOSE		This function post strings to the Event Log
 *
 * INPUTS		LPTSTR lpszMsg - String to send
 *				DWORD Error		- Error Code (if 0 no error)
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void PostEventLog(LPTSTR lpszMsg,DWORD Error)
{
	WORD 	ErrType = EVENTLOG_INFORMATION_TYPE;
	WORD	ErrStrings = 0;

	TCHAR   szMsg[256];
	HANDLE  hEventSource;
	LPTSTR  lpszStrings[2];

	DBPRINTF(TEXT("PostEventLog()\r\n"));

	lpszStrings[0] = lpszMsg;

	if (Error)
	{
		ErrType = EVENTLOG_ERROR_TYPE;
		ErrStrings = 2;
		wsprintf(szMsg, TEXT("SerialKeys error: %d"), Error);
		lpszStrings[0] = szMsg;
		lpszStrings[1] = lpszMsg;
	}

	hEventSource = RegisterEventSource(NULL,SERVICENAME);

	if (hEventSource != NULL)
	{
		ReportEvent
		(
			hEventSource,		// handle of event source
			ErrType,			// event type
			0,					// event category
			0,					// event ID
			NULL,				// current user's SID
			ErrStrings,			// strings in lpszStrings
			0,					// no bytes of raw data
			lpszStrings,		// array of error strings
			NULL				// no raw data
		);

		(VOID) DeregisterEventSource(hEventSource);
	}
}

/*---------------------------------------------------------------
 *
 *		Internal Service Control Functions
 *
/*---------------------------------------------------------------
 *
 * FUNCTION	void InitService()
 *
 * PURPOSE		This function Initializes the Service & starts the
 *				major threads of the service.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static BOOL InitService()
{
	DBPRINTF(TEXT("InitService()\r\n"));

	InstallLogout();

	if (!InitDLL())
		return(FALSE);

	if (!InitLogin())
		return(FALSE);

	if (!InitComm())
		return(FALSE);

	DoServiceCommand(SC_LOG_IN);	// Set ProcessService to Login Serial Keys

	return(TRUE);
}


static void InitReg()
{
	// Set Structure pointers to Buffers
	skNewKey.cbSize = sizeof(skNewKey);
	skNewKey.lpszActivePort = szNewActivePort;
	skNewKey.lpszPort = szNewPort;

	skCurKey.cbSize = sizeof(skCurKey);
	skCurKey.lpszActivePort = szCurActivePort;
	skCurKey.lpszPort = szCurPort;

	// Set Default Values
	skNewKey.dwFlags = SERKF_AVAILABLE;

	skNewKey.iBaudRate = 300;
	skNewKey.iPortState = 2;
	lstrcpy(szNewPort,TEXT("COM1:"));
	lstrcpy(szNewActivePort,TEXT("COM1:"));
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void PauseService()
 *
 * PURPOSE		This function is called to pause the service
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void PauseService()
{
	DBPRINTF(TEXT("PauseService()\r\n"));

	SuspendDLL();
	SuspendComm();
	SuspendLogin();
}


/*---------------------------------------------------------------
 *
 * FUNCTION	void DoServiceCommand()
 *
 * PURPOSE		Passes a command to the service thread
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void DoServiceCommand(DWORD dwServiceCommand)
{
	DWORD dwWaitRet;

    dwWaitRet = WaitForSingleObject(s_hEventServiceRequestReady, 10*1000);
    
	if (WAIT_OBJECT_0 == dwWaitRet)
	{
		s_dwServiceCommand = dwServiceCommand;
		SetEvent(s_hEventServiceRequest);
	}
    else
	{
		DBPRINTF(TEXT("DoServiceCommand - wait failed or timed-out, request ignored\r\n"));
	}
}


/*---------------------------------------------------------------
 *
 * FUNCTION	void ProcessService()
 *
 * PURPOSE		This function is the main service thread for Serial
 *				Keys. 	Is monitors the status of the other theads
 *				and responds to their request.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void ProcessService()
{
    DWORD dwServiceCommand;
	DWORD dwWaitRet;
	typedef enum {
		iheventServiceRequest,    
		iheventServiceTerminate
	};
	HANDLE ahevent[2] = {s_hEventServiceRequest, s_hEventServiceTerminate};

 	DBPRINTF(TEXT("ProcessService()\r\n"));
    
    dwWaitRet = WaitForMultipleObjects(ARRAY_SIZE(ahevent), ahevent, 
		FALSE,  // wait all?
		INFINITE);

	//  This loop will terminate when iheventServiceTerminate is signaled or
	//  WaitForMultipleObjects fails

	while (iheventServiceRequest == dwWaitRet - WAIT_OBJECT_0)
	{
		dwServiceCommand = s_dwServiceCommand;
    	SetEvent(s_hEventServiceRequestReady);

		switch (dwServiceCommand)
		{
			case SC_LOG_OUT:				// Login to New User
				DBPRINTF(TEXT("---- User Logging Out\r\n"));
				StopComm();			// Stop SerialKey Processing
				if(GetUserValues(REG_DEF))	// Get Default values & Do we Start?
				{
					EnableService(skNewKey.dwFlags & SERKF_SERIALKEYSON);
					StartComm();			// Yes - Process SerialKey
				}
				break;

			case SC_LOG_IN:					// Login to New User
				DBPRINTF(TEXT("---- User Logging In\r\n"));
				StopComm();			// Stop SerialKey Processing
				if(GetUserValues(REG_DEF)) 
				{	
					EnableService(skNewKey.dwFlags & SERKF_SERIALKEYSON);
					StartComm();			// Yes - Process SerialKey
				}
				break;

			case SC_CHANGE_COMM: 			// Change Comm Configuration
				DBPRINTF(TEXT("---- Making Comm Change\r\n"));
				StopComm();			// Stop SerialKey Processing
				StartComm();				// Restart SerialKey Processing
				break;

			case SC_DISABLE_SKEY:		 	// Disable Serial Keys
				DBPRINTF(TEXT("---- Disable Serial Keys\r\n"));
				StopComm();
				break;

			case SC_ENABLE_SKEY:			// Enable Serial Keys
				DBPRINTF(TEXT("---- Enable Serial Keys\r\n"));
				StartComm();
				break;
		}
		dwWaitRet = WaitForMultipleObjects(ARRAY_SIZE(ahevent), ahevent, 
			FALSE,  // wait all?
			INFINITE);
	}
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void ResumeService()
 *
 * PURPOSE		This function is called to restore the service
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void ResumeService()
{
	DBPRINTF(TEXT("ResumeService()\r\n"));

	ResumeDLL();
	ResumeComm();
	ResumeLogin();
}

//---------------------------------------------------------------
//
// FUNCTION	void TerminateService(DWORD Error)
//
//	TYPE		Local
//
// PURPOSE		This function is called by ServiceMain to terminate
//				the server.  It closes all of the open handles &
//				and reports the service is stopped.
//
// INPUTS		DWORD Error - Any Errors that could abort the
//				Service. 0 = Normal Stop
//
// RETURNS		None
//
//---------------------------------------------------------------

static void TerminateService(DWORD Error)
{
	DBPRINTF(TEXT("TerminateService()\r\n"));

	TerminateLogout();						// Remove Logout Monitoring

	TerminateComm();						// Init Comm Thread Shutdown

	TerminateDLL();							// Init DLL Thread Shutdown

	TerminateLogin();						// Init Login Thread Shutdown

	// Loop untill all of the Threads are shut down.

	while (!DoneLogin()) 					// Loop until Login Thread is terminated
		Sleep(250);							// Sleep 

	while (!DoneDLL())	 					// Loop until DLL Thread is terminated
		Sleep(250);							// Sleep 


    // reload registery values to insure we have the current values
	GetUserValues(REG_DEF);

	EnableService(skNewKey.dwFlags & SERKF_SERIALKEYSON);

	// Report the status is stopped
	if (s_sshStatusHandle)
		(VOID)ReportStatusToSCMgr(SERVICE_STOPPED,Error,0,0);
}

/*---------------------------------------------------------------
 *
 *	Logout Functions - Process Logout request
 *
/*---------------------------------------------------------------
 *
 * FUNCTION	void InstallLogout()
 *
 * PURPOSE		This function installs a Control Handler to process
 *				logout events.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static BOOL InstallLogout()
{
	DBPRINTF(TEXT("InstallLogout()\r\n"));

	return(SetConsoleCtrlHandler((PHANDLER_ROUTINE)ProcessLogout,TRUE));
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void TerminateLogout()
 *
 * PURPOSE		This function Removes a Control Handler to process
 *				logout events.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static BOOL TerminateLogout()
{
	DBPRINTF(TEXT("TerminateLogout()\r\n"));

	return(SetConsoleCtrlHandler((PHANDLER_ROUTINE)ProcessLogout,FALSE));
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void ProcessLogout()
 *
 * PURPOSE		This function processes	logout events.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void ProcessLogout(DWORD dwCtrlType)
{
	DBPRINTF(TEXT("ProcessLogout()\r\n"));

	if (dwCtrlType == CTRL_LOGOFF_EVENT)
	{
		DoServiceCommand(SC_LOG_OUT);

		// we'll do this each time the currently logged in user logs out
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\sk_ex.h ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_EX.h
 *
 * PURPOSE:			Header file for SK_EX.C
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *------------------------------------------------------------*/
BOOL SkEx_GetAnchor(LPPOINT Mouse);
void SkEx_SetAnchor();
void SkEx_SendBeep();
void SkEx_SendKeyUp(int scanCode); 			// Send char from SerialKeys
void SkEx_SendKeyDown(int scanCode);
void SkEx_SendMouse(MOUSEKEYSPARAM *p);		// Send mouse from SerialKeys
void SkEx_SetBaud(int Baud);

BOOL DeskSwitchToInput();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\sk_login.h ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_LOGIN.H
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *------------------------------------------------------------*/

// Global Variables -------------------------------------------


// Global Function Prototypes ---------------------------------

BOOL DoneLogin();
BOOL InitLogin();
void ResumeLogin();
void SuspendLogin();
void TerminateLogin();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\sk_reg.h ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_reg.H							   
 *
 * PURPOSE:			Function prototypes for Serial registry Routines
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *------------------------------------------------------------*/

#define REG_FLAGS		TEXT("Flags")
#define REG_ACTIVEPORT	TEXT("ActivePort")
#define REG_PORT		TEXT("Port")
#define REG_BAUD		TEXT("Baud")

// Public Function ProtoTypes ----------------------------------
BOOL GetUserValues(int User);
BOOL SetUserValues();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\tables.h ===
/*  TABLES.H  */


extern	struct aliasTable	gideiAliasTable[];
extern	struct aliasTable	commandsAliasTable[];
extern	struct aliasTable	kbdAliasTable[];
extern	struct aliasTable	kbdModelAliasTable[];
extern	struct aliasTable	kbdDescriptionAliasTable[];
extern	struct aliasTable 	kbdVersionAliasTable[];
extern	struct aliasTable 	kbdIndicatorAliasTable[];



extern	struct aliasTable	mouseAliasTable[];
extern	struct aliasTable	genAliasTable[];
extern	struct aliasTable	commAliasTable[];
extern  struct aliasTable	baudrateAliasTable[];
extern  struct aliasTable	mouButtonAliasTable[];
extern	int	baudrateTable[];

extern	struct asciiTables	asciiTable[];
extern  struct aliasTable	keyAliasTable[];
extern	int	IBMextendedScanCodeSet1[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\sk_login.c ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_LOGIN.C
 *
 * PURPOSE:		The file contains the Functions responsible for
 *					managing when the user logs in and out of NT.
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * NOTES:		
 *					
 * This file, and all others associated with it contains trade secrets
 * and information that is proprietary to Black Diamond Software.
 * It may not be copied copied or distributed to any person or firm 
 * without the express written permission of Black Diamond Software. 
 * This permission is available only in the form of a Software Source 
 * License Agreement.
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *	Notes:
 *		The Login process is currently not implemented.  We need additional
 *		code to determine who is actually logged in and how to receive 
 *		notification of a login event.
 *
 *--- Includes  ---------------------------------------------------------*/
#include	<process.h>

#include	"windows.h"
#include    "w95trace.h"
#include	"sk_defs.h"
#include	"sk_login.h"

#define	DISABLE_LOGIN 1

// Local Variables --------------------------------------------

static BOOL	fDoneLogin = TRUE;
static BOOL	fExitLogin = FALSE;

static HANDLE	hEventLogin  = NULL;
static HANDLE	hThreadLogin = NULL;

// Local Function Prototypes ---------------------------------

static void CleanUpLogin();
static void __cdecl ProcessLogin(VOID *notUsed);


/*---------------------------------------------------------------
 *	Global Functions - 
/*---------------------------------------------------------------
 *
 * FUNCTION	BOOL DoneLogin()
 *
 *	TYPE		Global
 *
 * PURPOSE		Returns the state of the login Thread
 *
 * INPUTS		None
 *
 * RETURNS		TRUE - Login Thread not running
 * 			FALSE - Login Thread Is running
 *
 *---------------------------------------------------------------*/
BOOL DoneLogin()
{
	return(fDoneLogin);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void InitLogin()
 *
 *	TYPE		Local
 *
 * PURPOSE		This function creates a thread that monitors when a user
 *				has logged in and out of NT.  On each case it sets
 *				the ServiceCommand to notify the MainSerice of the
 *				change.  The MainService will then reset Serial Keys
 *				for the new user settings.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
BOOL InitLogin()
{

	DBPRINTF(TEXT("InitLogin()\r\n"));

#if DISABLE_LOGIN // clean this up /////////////////////////////////////
	return(TRUE);
#else /////////////////////////////////////////////////////////////////////////
   hEventLogin = CreateEvent(NULL,TRUE,FALSE,NULL);	

	if (NULL == hEventLogin)	// Is Handle VALID?
	{
		DBPRINTF(TEXT("Unable to Create DLL Event\r\n"));
		TerminateLogin();
		return FALSE;
	}
    
	{
  	DWORD Id;

	// Generate thread to handle Login in & Out processing;
	hThreadLogin = (HANDLE)CreateThread(	// Start Service Thread
		0,
		0,
		(LPTHREAD_START_ROUTINE) ProcessLogin,
		0,
		0,
		&Id);								// argument to thread
    }

	if (NULL == hThreadLogin)
	{
		TerminateLogin();
		return FALSE;
	}

	fDoneLogin = FALSE;
#endif ////////////////////////////////////////////////////////////////////////
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void SuspendLogin()
 *
 *	TYPE		Global
 *
 * PURPOSE		The function is called to Pause the thread  
 *				reading and processing data coming from the comm port.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void SuspendLogin()
{

	DBPRINTF(TEXT("SuspendLogin()\r\n"));

#if DISABLE_LOGIN
	return;
#else 

	if (NULL != hThreadLogin)
		SuspendThread(hThreadLogin);
#endif
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void ResumeLogin()
 *
 *	TYPE		Global
 *
 * PURPOSE		The function is called to resume the Paused thread.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void ResumeLogin()
{
	DBPRINTF(TEXT("ResumeLogin()\r\n"));

#if DISABLE_LOGIN
	return;
#else

	if (NULL != hThreadLogin)
		ResumeThread(hThreadLogin);	
#endif
}
/*---------------------------------------------------------------
 *
 * FUNCTION	void TerminateLogin()
 *
 *	TYPE		Local
 *
 * PURPOSE		Terminates the Login Thread
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
void TerminateLogin()
{
	DBPRINTF(TEXT("TerminateLogin()\r\n"));

#if DISABLE_LOGIN
	return;
#else
	if (DoneLogin())
	{
		fExitLogin = TRUE;
		SetEvent(hEventLogin);			// Trigger Login Event
		Sleep(150);
	}
#endif
}

/*---------------------------------------------------------------
 *	Local Functions
/*---------------------------------------------------------------
 *
 * FUNCTION    static void CleanUpLogin()
 *
 *	TYPE		Local
 *
 * PURPOSE		Cleans up misc handles and memory allocated for 
 *				the thread;
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void CleanUpLogin()
{
	BOOL Stat;

	DBPRINTF(TEXT("CleanUpLogin()\r\n"));

	if (NULL != hEventLogin)
	{
		Stat = CloseHandle(hEventLogin);
		DBPRINTF_IF(Stat,TEXT("Unable to Close Login Event\r\n"));
	}

	if (NULL != hThreadLogin)
	{
		Stat = CloseHandle(hThreadLogin);
		DBPRINTF_IF(Stat,TEXT("Unable to Close Login Thread\r\n"));
	}

 	hEventLogin = NULL;
 	hThreadLogin = NULL;

	DBPRINTF(TEXT("Login Service Processing Done\r\n"));
	fDoneLogin = TRUE;
}

/*---------------------------------------------------------------
 *
 * FUNCTION     void _CRTAPI1 ProcessLogin()
 *
 *	TYPE		Local
 *
 * PURPOSE		This function is a thread that monitors when a user
 *				has logged in and out of NT.  On each case it sets
 *				the ServiceCommand to notify the MainSerice of the
 *				change.  The MainService will then reset Serial Keys
 *				for the new user settings.
 *
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void __cdecl ProcessLogin(VOID *notUsed)
{
	DBPRINTF(TEXT("ProcessLogin()\r\n"));

	while (TRUE)
	{
		if (fExitLogin)
		{
			fExitLogin = FALSE;
			CleanUpLogin();
			ExitThread(0);
			return;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\sk_reg.c ===
/*--------------------------------------------------------------
 *
 * FILE:			SK_Reg.c
 *
 * PURPOSE:	   	These functions process data to and from the registry
 *
 * CREATION:		June 1994
 *
 * COPYRIGHT:		Black Diamond Software (C) 1994
 *
 * AUTHOR:			Ronald Moak 
 *
 * $Header: %Z% %F% %H% %T% %I%
 *
 *--- Includes  --------------------------------------------*/
#include	<windows.h>

#include    "w95trace.h"
#include	"sk_defs.h"
#include	"sk_comm.h"
#include	"sk_reg.h"

// Private Functions -------------------------------------------

static DWORD OpenRegistry(int User);
static void CloseRegistry();
static void SetRegistryValues();
static void GetRegistryValues();

// Variables  --------------------------------------------

HKEY	hKeyApp;

/*---------------------------------------------------------------
 *
 * FUNCTION	BOOL GetUserValues()
 *
 *	TYPE		Local
 *
 * PURPOSE		Read the registery an collect the data for the current
 *				user.  This Information is then setup in the comm routines.
 *				This is called when someone logs into NT.
 *	
 * INPUTS		User Type Default or Current User
 *
 * RETURNS		TRUE - User wants Serial Keys Enabled
 *				FALSE- User wants Serial Keys Disabled
 *
 *---------------------------------------------------------------*/
BOOL GetUserValues(int User)
{
	DWORD Status;

	DBPRINTF(TEXT("GetUserValues()\r\n"));

	if (!(Status = OpenRegistry(User)))	// Did Open Registry Succed?
		return(FALSE);					// No - Fail

	switch (Status)						// What is status?
	{
		// This case should only be true the frist time
		// the registry is opened for the current user.
		case REG_CREATED_NEW_KEY:		// Is this an empty Registry?
			SetRegistryValues(); 		// Yes - Set Default Values
			break;

		case REG_OPENED_EXISTING_KEY:	// Is this an existing Registry?
			GetRegistryValues();  		// Yes - Get Values
			break;
	}
		
	CloseRegistry();
	return(TRUE);
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void SetUserValues()
 *
 *	TYPE		Global
 *
 * PURPOSE		This function writes out information to the
 *				registry.
 *	
 * INPUTS		None
 *
 * RETURNS		TRUE - Write Successful
 *				FALSE- Write Failed
 *
 *---------------------------------------------------------------*/
BOOL SetUserValues()
{
	DWORD Status;

	DBPRINTF(TEXT("SetUserValues()\r\n"));

	if (!(Status = OpenRegistry(REG_USER)))		// Did Open Registry Succed?
		return(FALSE);					// No - Fail

	SetRegistryValues();  				// Set New Values
	CloseRegistry();					// Close Registry
	return(TRUE);
}

/*---------------------------------------------------------------
 *
 *	Local Functions - 
 *
/*---------------------------------------------------------------
 *
 * FUNCTION	DWORD OpenRegistry()
 *
 *	TYPE		Global
 *
 * PURPOSE		Opens the Registry for reading or writing
 *	
 * INPUTS		User Type Default or Current User
 *
 * RETURNS		0  = Failed
 *				>0 = REG_CREATED_NEW_KEY or REG_OPENED_EXISTING_KEY
 *
 *---------------------------------------------------------------*/
static DWORD OpenRegistry(int User)
{
	LONG	ret;
	DWORD	Disposition = 0;

	DBPRINTF(TEXT(" OpenRegistry()\r\n"));

	switch (User)
	{
		case REG_USER:				// Current User
			ret =RegCreateKeyEx
				(
					HKEY_CURRENT_USER,
                    TEXT("Control Panel\\Accessibility\\SerialKeys"),
					0,NULL,
					REG_OPTION_NON_VOLATILE,
					KEY_ALL_ACCESS,
					NULL,
					&hKeyApp,
					&Disposition
				);
			break;

		case REG_DEF:				// Default 
			ret =RegCreateKeyEx
				(
					HKEY_USERS,
                    TEXT(".DEFAULT\\Control Panel\\Accessibility\\SerialKeys"),
					0,NULL,
					REG_OPTION_NON_VOLATILE,
					KEY_ALL_ACCESS,
					NULL,
					&hKeyApp,
					&Disposition
				);
			break;

		default:
			ret = FALSE;
			break;
	}

	if (ret != ERROR_SUCCESS)		// Did open succede?
		return(FALSE);				// No -

	return (Disposition);
	
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void CloseRegistry()
 *
 *	TYPE		Global
 *
 * PURPOSE		Closes the Registry for reading or writing
 *	
 * INPUTS		None
 *
 * RETURNS		0  = Failed
 *				>0 = REG_CREATED_NEW_KEY or REG_OPENED_EXISTING_KEY
 *
 *---------------------------------------------------------------*/
static void CloseRegistry()
{
	DBPRINTF(TEXT(" CloseRegistry()\r\n"));
	RegCloseKey(hKeyApp);
}


/*---------------------------------------------------------------
 *
 * FUNCTION	void SetRegistryValues()
 *
 *	TYPE		Global
 *
 * PURPOSE		Writes the values in the SerialKeys structure to
 *				the Registry.
 *	
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void SetRegistryValues()
{
	long ret;
	DWORD dwFlags;

	DBPRINTF(TEXT(" SetRegistryValues()\r\n"));

	dwFlags = skNewKey.dwFlags | SERKF_AVAILABLE;
	ret = RegSetValueEx(				// Write dwFlags
			hKeyApp,
			REG_FLAGS,
			0,REG_DWORD,
			(CONST LPBYTE) &dwFlags,
			sizeof(DWORD));
				
	if (ret != ERROR_SUCCESS)		// Did open succede?
	{
		DBPRINTF(TEXT("Unable to Set Registry Value\r\n"));
		return;						// No -
	}


	if (NULL == skNewKey.lpszActivePort)
	{
		ret = RegSetValueEx(			// Write Active Port
				hKeyApp,
				REG_ACTIVEPORT,
				0,
				REG_SZ,
				(CONST LPBYTE) TEXT(""),
				1 * sizeof(*skNewKey.lpszActivePort)); // size of one char, the term null
	}
	else
	{
		ret = RegSetValueEx(			// Write Active Port
				hKeyApp,
				REG_ACTIVEPORT,
				0,
				REG_SZ,
				(CONST LPBYTE) skNewKey.lpszActivePort,
				(lstrlen(skNewKey.lpszActivePort) + 1) * 
					sizeof(*skNewKey.lpszActivePort));
	}			
	if (ret != ERROR_SUCCESS)		// Did open succede?
		return;						// No -

	if (NULL == skNewKey.lpszPort)
	{
		ret = RegSetValueEx(			// Write Active Port
				hKeyApp,
				REG_PORT,
				0,
				REG_SZ,
				(CONST LPBYTE) TEXT(""),
				1 * sizeof(*skNewKey.lpszPort)); // size of one char, the term null
	}
	else
	{
		ret = RegSetValueEx(			// Write Active Port
				hKeyApp,
				REG_PORT,
				0,
				REG_SZ,
				(CONST LPBYTE)skNewKey.lpszPort,
				(lstrlen(skNewKey.lpszPort) + 1) * sizeof(*skNewKey.lpszPort));
	}
					
	if (ret != ERROR_SUCCESS)		// Did open succede?
		return;						// No -

	ret = RegSetValueEx				// Write Active Port
		(
			hKeyApp,
			REG_BAUD,
			0,REG_DWORD,
			(CONST LPBYTE) &skNewKey.iBaudRate,
			sizeof(skNewKey.iBaudRate)
		);
				
	if (ret != ERROR_SUCCESS)		// Did open succede?
		return;						// No -
}

/*---------------------------------------------------------------
 *
 * FUNCTION	void GetRegistryValues()
 *
 *	TYPE		Global
 *
 * PURPOSE		Reads the values in the SerialKeys structure to
 *				the Registry.
 *	
 * INPUTS		None
 *
 * RETURNS		None
 *
 *---------------------------------------------------------------*/
static void GetRegistryValues()
{
	long lRet;
	DWORD dwType;
	DWORD cbData;
	
	DBPRINTF(TEXT(" GetRegistryValues()\r\n"));

	skNewKey.dwFlags = 0;
	cbData = sizeof(skNewKey.dwFlags);
	lRet = RegQueryValueEx(
			hKeyApp,
			REG_FLAGS,
			0,&dwType,
			(LPBYTE)&skNewKey.dwFlags,
			&cbData);
				
	skNewKey.dwFlags |= SERKF_AVAILABLE;
    
	if (NULL != skNewKey.lpszActivePort)
	{
		cbData = MAX_PATH * sizeof(*skNewKey.lpszActivePort);
		lRet = RegQueryValueEx(
				hKeyApp,
				REG_ACTIVEPORT,
				0,&dwType,
				(LPBYTE)skNewKey.lpszActivePort,
				&cbData);
					
        skNewKey.lpszActivePort[ MAX_PATH - 1 ] = '\0';
		if (lRet != ERROR_SUCCESS || dwType != REG_SZ)
		{
			lstrcpy(skNewKey.lpszActivePort, TEXT("COM1"));
		}
	}

	if (NULL != skNewKey.lpszPort)
	{
		cbData = MAX_PATH * sizeof(*skNewKey.lpszPort);
		lRet = RegQueryValueEx(				// Write Active Port
				hKeyApp,
				REG_PORT,
				0,&dwType,
				(LPBYTE)skNewKey.lpszPort,
				&cbData);
					
        skNewKey.lpszActivePort[ MAX_PATH - 1 ] = '\0';
		if (lRet != ERROR_SUCCESS || dwType != REG_SZ)
		{
			lstrcpy(skNewKey.lpszPort, TEXT("COM1"));
		}
	}

	cbData = sizeof(skNewKey.iBaudRate);
	lRet = RegQueryValueEx(			// Write Active Port
			hKeyApp,
			REG_BAUD,
			0,&dwType,
			(LPBYTE)&skNewKey.iBaudRate,
			&cbData);
				
	if (ERROR_SUCCESS != lRet)
	{
		skNewKey.iBaudRate = 300;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\tables.c ===
/* TABLES.C  */

//#define     WINVER 0x0300

#include	"windows.h"
//#include "winstric.h"                        /* added for win 3.1 compatibility 1/92 */
#include "gidei.h"
#include "vars.h"
#include "gide.h"

struct aliasTable	gideiAliasTable[] = {
	{ "BEGIN",		BEGINCODE	},
	{ "BLKTRNS",	BLKTRANSCODE},
	{ "CLEAR",		CLEARCODE	},
	{ "END", 		ENDCODE		},
	{ "",			NOCODE		},
};


struct aliasTable	commandsAliasTable[] = {
	{ "baudrate",	BAUDRATECODE	},
	{ "click",		MOUCLICKCODE	},
	{ "combine",	KBDCOMBINECODE	},
	{ "comm",		COMMCODE		},
	{ "dblclick",	MOUDOUBLECLICKCODE	},
	{ "gen",		GENCODE			},
	{ "goto",		MOUGOTOCODE		},
	{ "hold",		KBDHOLDCODE		},
	{ "kbd",		KBDEXPANSIONCODE},
	{ "lock",		KBDLOCKCODE		},
	{ "mou",		MOUEXPANSIONCODE},
   { "mouanchor", MOUANCHORCODE     },
	{ "moulock", 	MOULOCKCODE		},
	{ "mourel",		MOURELCODE		},
	{ "moureset",	MOURESETCODE	},
	{ "move",		MOUMOVECODE		},
	{ "press",		KBDPRESSCODE	},
	{ "rel",		KBDRELCODE		},
	{ "",			NOCODE		},
};

struct aliasTable	kbdAliasTable[] = {
	{ "desc",		KBDDESCRIPTIONCODE },
	{ "ind",		KBDINDICATORCODE	},
	{ "model",		KBDMODELCODE		},
	{ "ver",		KBDVERSIONCODE		},
	{ "",			NOCODE		},
};


struct aliasTable	kbdModelAliasTable[] = {
	{ "ibmat",		IBMATCODE		},
	{ "ibmenhc",	IBMEXTENDEDCODE	},		/* IBM 101 key keyboard */
	{ "ibmpc",		IBMPCCODE		},		/* IBM original keyboard */
	{ "",			NOCODE		},
};


struct aliasTable	kbdDescriptionAliasTable[] = {
	{ "",			NOCODE		},
};

struct aliasTable kbdVersionAliasTable[] = {
	{ "",			NOCODE		},
};

struct aliasTable kbdIndicatorAliasTable[] = {
	{ "",			NOCODE		},
};

struct aliasTable mouseAliasTable[] = {
	{ "",			NOCODE		},
};

struct aliasTable genAliasTable[] = {
	{ "",			NOCODE		},
};


struct aliasTable	commAliasTable[] = {
	{ "",			NOCODE		},
};



struct aliasTable	baudrateAliasTable[] = {
	{ "1200",	BAUD1200CODE	},
	{ "2400",	BAUD2400CODE	},
	{ "300",	BAUD300CODE		},
	{ "4800",	BAUD4800CODE	},
	{ "600",	BAUD600CODE		},
	{ "9600",	BAUD9600CODE	},
	{ "19200",	BAUD19200CODE	},
	{ "110",	BAUD110CODE	    },
	{ "14400",	BAUD14400CODE	},
	{ "38400",	BAUD38400CODE	},
	{ "56000",	BAUD56000CODE	},
	{ "57600",	BAUD57600CODE	},
	{ "115200",	BAUD115200CODE	},
	{ "",			NOCODE		},
};

struct aliasTable	mouButtonAliasTable[] = {
	{ "left",	LEFTBUTTONCODE	},
	{ "right",	RIGHTBUTTONCODE	},
	{ "",			NOCODE		},
};

int	baudrateTable[] = {
	{ 300		},
	{ 600		},
	{ 1200		},
	{ 2400		},
	{ 4800		},
	{ 9600		},
	{ 0			},
};


/****************************************************************************

	Table for converting the ISO characters to the keys that need to be typed
	on the keyboard.

****************************************************************************/

struct asciiTables asciiTable[] = {
	{ control_key,	two_key,},							/*   0 */
	{ control_key,	a_key,},								/*   1 */
	{ control_key,	b_key,},								/*   2 */
	{ control_key,	c_key,},								/*   3 */
	{ control_key,	d_key,},								/*   4 */
	{ control_key,	e_key,},								/*   5 */
	{ control_key,	f_key,},								/*   6 */
	{ control_key,	g_key,},								/*   7 */
	{ control_key,	h_key,},								/*   8 */
	{ control_key,	i_key,},								/*   9 */
	{ control_key,	j_key,},								/*  10 */
	{ control_key,	k_key,},								/*  11 */
	{ control_key,	l_key,},								/*  12 */
	{ control_key,	m_key,},								/*  13 */
	{ control_key,	n_key,},								/*  14 */
	{ control_key,	o_key,},								/*  15 */
	{ control_key,	p_key,},								/*  16 */
	{ control_key,	q_key,},								/*  17 */
	{ control_key,	r_key,},								/*  18 */
	{ control_key,	s_key,},								/*  19 */
	{ control_key,	t_key,},								/*  20 */
	{ control_key,	u_key,},								/*  21 */
	{ control_key,	v_key,},								/*  22 */
	{ control_key,	w_key,},								/*  23 */
	{ control_key,	x_key,},								/*  24 */
	{ control_key,	y_key,},								/*  25 */
	{ control_key,	z_key,},								/*  26 */
	{ control_key,	lbracket_key,},					/*  27 */
	{ control_key,	bslash_key,},						/*  28 */
	{ control_key,	rbracket_key,},					/*  29 */
	{ control_key,	six_key,},							/*  30 */
	{ control_key,	hyphen_key,},						/*  31 */
	{ space_key,	no_key,},							/*  32 */
	{ shift_key,	one_key,},							/*  33 */
	{ shift_key,	rquote_key,},						/*  34 */
	{ shift_key,	three_key,},						/*  35 */
	{ shift_key,	four_key,},							/*  36 */
	{ shift_key,	five_key,},							/*  37 */
	{ shift_key,	seven_key,},						/*  38 */
	{ rquote_key,	no_key,},							/*  39 */
	{ shift_key,	nine_key,},							/*  40 */
	{ shift_key,	zero_key,},							/*  41 */
	{ shift_key,	eight_key,},						/*  42 */
	{ shift_key,	equal_key,},						/*  43 */
	{ comma_key,	no_key,},							/*  44 */
	{ hyphen_key,	no_key,},							/*  45 */
	{ period_key,	no_key,},							/*  46 */
	{ fslash_key,	no_key,},							/*  47 */
	{ zero_key,		no_key,},							/*  48 */
	{ one_key,		no_key,},							/*  49 */
	{ two_key,		no_key,},							/*  50 */
	{ three_key,	no_key,},							/*  51 */
	{ four_key,		no_key,},							/*  52 */
	{ five_key,		no_key,},							/*  53 */
	{ six_key,		no_key,},							/*  54 */
	{ seven_key,	no_key,},							/*  55 */
	{ eight_key,	no_key,},							/*  56 */
	{ nine_key,		no_key,},							/*  57 */
	{ shift_key,	semicolon_key,},					/*  58 */
	{ semicolon_key,no_key,},							/*  59 */
	{ shift_key,	comma_key,},						/*  60 */
	{ equal_key,	no_key,},							/*  61 */
	{ shift_key,	period_key,},						/*  62 */
	{ shift_key,	fslash_key,},						/*  63 */
	{ shift_key,	two_key,},							/*  64 */
	{ shift_key,	a_key,},								/*  65 */
	{ shift_key,	b_key,},								/*  66 */
	{ shift_key,	c_key,},								/*  67 */
	{ shift_key,	d_key,},								/*  68 */
	{ shift_key,	e_key,},								/*  69 */
	{ shift_key,	f_key,},								/*  70 */
	{ shift_key,	g_key,},								/*  71 */
	{ shift_key,	h_key,},								/*  72 */
	{ shift_key,	i_key,},								/*  73 */
	{ shift_key,	j_key,},								/*  74 */
	{ shift_key,	k_key,},								/*  75 */
	{ shift_key,	l_key,},								/*  76 */
	{ shift_key,	m_key,},								/*  77 */
	{ shift_key,	n_key,},								/*  78 */
	{ shift_key,	o_key,},								/*  79 */
	{ shift_key,	p_key,},								/*  80 */
	{ shift_key,	q_key,},								/*  81 */
	{ shift_key,	r_key,},								/*  82 */
	{ shift_key,	s_key,},								/*  83 */
	{ shift_key,	t_key,},								/*  84 */
	{ shift_key,	u_key,},								/*  85 */
	{ shift_key,	v_key,},								/*  86 */
	{ shift_key,	w_key,},								/*  87 */
	{ shift_key,	x_key,},								/*  88 */
	{ shift_key,	y_key,},								/*  89 */
	{ shift_key,	z_key,},								/*  90 */
	{ lbracket_key,	no_key,},						/*  91 */
	{ bslash_key,	no_key,},							/*  92 */
	{ rbracket_key,	no_key,},						/*  93 */
	{ shift_key,	six_key,},							/*  94 */
	{ shift_key,	hyphen_key,},						/*  95 */
	{ lquote_key,	no_key,},							/*  96 */
	{ a_key,		no_key,},								/*  97 */
	{ b_key,		no_key,},								/*  98 */
	{ c_key,		no_key,},								/*  99 */
	{ d_key,		no_key,},								/* 100 */
	{ e_key,		no_key,},								/* 101 */
	{ f_key,		no_key,},								/* 102 */
	{ g_key,		no_key,},								/* 103 */
	{ h_key,		no_key,},								/* 104 */
	{ i_key,		no_key,},								/* 105 */
	{ j_key,		no_key,},								/* 106 */
	{ k_key,		no_key,},								/* 107 */
	{ l_key,		no_key,},								/* 108 */
	{ m_key,		no_key,},								/* 109 */
	{ n_key,		no_key,},								/* 110 */
	{ o_key,		no_key,},								/* 111 */
	{ p_key,		no_key,},								/* 112 */
	{ q_key,		no_key,},								/* 113 */
	{ r_key,		no_key,},								/* 114 */
	{ s_key,		no_key,},								/* 115 */
	{ t_key,		no_key,},								/* 116 */
	{ u_key,		no_key,},								/* 117 */
	{ v_key,		no_key,},								/* 118 */
	{ w_key,		no_key,},								/* 119 */
	{ x_key,		no_key,},								/* 120 */
	{ y_key,		no_key,},								/* 121 */
	{ z_key,		no_key,},								/* 122 */
	{ shift_key,	lbracket_key,},					/* 123 */
	{ shift_key,	bslash_key,},						/* 124 */
	{ shift_key,	rbracket_key,},					/* 125 */
	{ shift_key,	lquote_key,},						/* 126 */
	{ control_key,	kpperiod_key,},					/* 127 */
};


/****************************************************************************

	Table for converting the ASCII string of the key names into the key
	number.

****************************************************************************/

struct aliasTable	keyAliasTable[] = {
	{ "alt",		alt_key,},
	{ "backspace",	backspace_key,},
  	{ "bksp",		backspace_key,},
  	{ "break",		pause_key,},
	{ "capslk",		caps_key,},
	{ "capslock",	caps_key,},
	{ "comma",		comma_key,},
	{ "control", 	control_key,},
	{ "ctrl",		control_key,},
	{ "del",		delete_key,},
	{ "delete",		delete_key,},
	{ "divide",		kpfslash_key,},
	{ "down",		down_key,},
	{ "end",		end_key,},
	{ "enter",		return_key,},
	{ "esc",		escape_key,},
	{ "escape",		escape_key,},
	{ "f1",			f1_key,},
	{ "f10",		f10_key,},
	{ "f11",		f11_key,},
	{ "f12",		f12_key,},
	{ "f2",			f2_key,},
	{ "f3",			f3_key,},
	{ "f4",			f4_key,},
	{ "f5",			f5_key,},
	{ "f6",			f6_key,},
	{ "f7",			f7_key,},
	{ "f8",			f8_key,},
	{ "f9",			f9_key,},
	{ "home",		home_key,},
	{ "ins",		insert_key,},
	{ "insert",		insert_key,},
	{ "kp*",		kpstar_key,},
	{ "kp+",		kpplus_key,},
	{ "kp-",		kpminus_key,},
	{ "kp/",		kpfslash_key,},
	{ "kp0",		kp0_key,},
	{ "kp1",		kp1_key,},
	{ "kp2",		kp2_key,},
	{ "kp3",		kp3_key,},
	{ "kp4",		kp4_key,},
	{ "kp5",		kp5_key,},
	{ "kp6",		kp6_key,},
	{ "kp7",		kp7_key,},
	{ "kp8",		kp8_key,},
	{ "kp9",		kp9_key,},
	{ "kpdel",		kpperiod_key,},
	{ "kpdelete",	kpperiod_key,},
	{ "kpdivide",	kpfslash_key,},
	{ "kpdn",		kp2_key,},
	{ "kpdown",		kp2_key,},
	{ "kpdp",		kpperiod_key,},
	{ "kpend",		kp1_key,},
	{ "kpenter",	kpenter_key,},
	{ "kphome",		kp7_key,},
	{ "kpins",		kp0_key,},
	{ "kpinsert",	kp0_key,},
	{ "kpleft",		kp4_key,},
	{ "kpmidl",		kp5_key,},
	{ "kpminus",	kpminus_key,},
	{ "kppagedown",	kp3_key,},
	{ "kppageup",	kp9_key,},
	{ "kppgdn",		kp3_key,},
	{ "kppgup",		kp9_key,},
	{ "kpplus",		kpplus_key,},
	{ "kpright",	kp6_key,},
	{ "kpslash",	kpfslash_key,},
	{ "kpstar",		kpstar_key,},
	{ "kptimes",	kpstar_key,},
	{ "kpup",		kp8_key,},
	{ "lalt",		lalt_key,},
	{ "lcontrol",	lcontrol_key,},
	{ "lctrl",		lcontrol_key,},
	{ "left",		left_key,},
	{ "leftalt",	lalt_key,},
	{ "leftcontrol", lcontrol_key,},
	{ "leftctrl",	lcontrol_key,},
	{ "leftshift",	lshift_key,},
	{ "lshift",		lshift_key,},
	{ "multiply",	kpstar_key,},
	{ "numlk",		numlock_key,},
	{ "numlock",	numlock_key,},
	{ "pagedown", 	pagedown_key,},
	{ "pageup",		pageup_key,},
	{ "pause",		pause_key,},
	{ "period",		period_key,},
	{ "pgdn",		pagedown_key,},
	{ "pgup",		pageup_key,},
	{ "print",		print_key,},
	{ "printscreen", print_key,},
	{ "prtsc",		print_key,},
	{ "ralt",		ralt_key,},
	{ "rcontrol",	rcontrol_key,},
	{ "rctrl",		rcontrol_key,},
	{ "ret",		return_key,},
	{ "return",		return_key,},
	{ "right",		right_key,},
	{ "rightalt",	ralt_key,},
	{ "rightcontrol", rcontrol_key,},
	{ "rightctrl",	rcontrol_key,},
	{ "rightshift",	rshift_key,},
	{ "rshift",		rshift_key,},
	{ "scroll",		scroll_key,},
	{ "scrolllock",	scroll_key,},
	{ "shift",		shift_key,},
	{ "space",		space_key,},
	{ "sysreq",		print_key,},
	{ "tab",		tab_key,},
	{ "tilde",		lquote_key,},
	{ "up",			up_key,},
	{ "",			no_key,},
};




/****************************************************************************

	Constants of extended scan code for the keys on the 101 key keyboard.
	The Key Number corresponds to the IBM documentation in their technical
	reference manuals.  It is not the same as the GIDEI key code

		Name			Make Code	Key Number
****************************************************************************/

#define	lquote_scan_101		0x0029	/*   1 */
#define	one_scan_101		0x0002	/*   2 */
#define	two_scan_101		0x0003	/*   3 */
#define	three_scan_101		0x0004	/*   4 */
#define	four_scan_101		0x0005	/*   5 */
#define	five_scan_101		0x0006	/*   6 */
#define	six_scan_101		0x0007	/*   7 */
#define	seven_scan_101		0x0008	/*   8 */
#define	eight_scan_101		0x0009	/*   9 */
#define	nine_scan_101		0x000A	/*  10 */
#define	zero_scan_101		0x000B	/*  11 */
#define	hyphen_scan_101		0x000C	/*  12 */
#define	equal_scan_101		0x000D	/*  13 */
#define	backspace_scan_101	0x000E	/*  15 */

#define	tab_scan_101		0x000F	/*  16 */
#define	q_scan_101			0x0010	/*  17 */
#define	w_scan_101			0x0011	/*  18 */
#define	e_scan_101			0x0012	/*  19 */
#define	r_scan_101			0x0013	/*  20 */
#define	t_scan_101			0x0014	/*  21 */
#define	y_scan_101			0x0015	/*  22 */
#define	u_scan_101			0x0016	/*  23 */
#define	i_scan_101			0x0017	/*  24 */
#define	o_scan_101			0x0018	/*  25 */
#define	p_scan_101			0x0019	/*  26 */
#define	lbracket_scan_101	0x001A	/*  27 */
#define	rbracket_scan_101	0x001B	/*  28 */
#define	bslash_scan_101		0x002B	/*  29 */

#define	caps_scan_101		0x003A	/*  30 */
#define	a_scan_101			0x001E	/*  31 */
#define	s_scan_101			0x001F	/*  32 */
#define	d_scan_101			0x0020	/*  33 */
#define	f_scan_101			0x0021	/*  34 */
#define	g_scan_101			0x0022	/*  35 */
#define	h_scan_101			0x0023	/*  36 */
#define	j_scan_101			0x0024	/*  37 */
#define	k_scan_101			0x0025	/*  38 */
#define	l_scan_101			0x0026	/*  39 */
#define	semi_scan_101		0x0027	/*  40 */
#define	rquote_scan_101		0x0028	/*  41 */
#define	return_scan_101		0x001C	/*  43 */

#define	lshift_scan_101		0x002A	/*  44 */
#define	z_scan_101			0x002C	/*  46 */
#define	x_scan_101			0x002D	/*  47 */
#define	c_scan_101			0x002E	/*  48 */
#define	v_scan_101			0x002F	/*  49 */
#define	b_scan_101			0x0030	/*  50 */
#define	n_scan_101			0x0031	/*  51 */
#define	m_scan_101			0x0032	/*  52 */
#define	comma_scan_101		0x0033	/*  53 */
#define	period_scan_101		0x0034	/*  54 */
#define	fslash_scan_101		0x0035	/*  55 */
#define	rshift_scan_101		0x0036	/*  57 */

#define	lcontrol_scan_101	0x001D	/*  58 */
#define	lalt_scan_101		0x0038	/*  60 */
#define	space_scan_101		0x0039	/*  61 */
#define	ralt_scan_101		0xE038	/*  62 */
#define	rcontrol_scan_101	0xE01D	/*  64 */

#define	insert_scan_101		0xE052	/*  75 */
#define	delete_scan_101		0xE053	/*  76 */
#define	left_scan_101		0xE04B	/*  79 */
#define	home_scan_101		0xE047	/*  80 */
#define	end_scan_101		0xE04F	/*  81 */
#define	up_scan_101			0xE048	/*  83 */
#define	down_scan_101		0xE050	/*  84 */
#define	pageup_scan_101		0xE049	/*  85 */
#define	pagedown_scan_101	0xE051	/*  86 */
#define	right_scan_101		0xE04D	/*  89 */

#define	numlock_scan_101	0x0045	/*  90 */
#define	kp7_scan_101		0x0047	/*  91 */
#define	kp4_scan_101		0x004B	/*  92 */
#define	kp1_scan_101		0x004F	/*  93 */

#define	kpDivide_scan_101	0xE035	/*  95 */
#define	kp8_scan_101		0x0048	/*  96 */
#define	kp5_scan_101		0x004C	/*  97 */
#define	kp2_scan_101		0x0050	/*  98 */
#define	kp0_scan_101		0x0052	/*  99 */

#define	asterisk_scan_101	0x0037	/* 100 */
#define	kp9_scan_101		0x0049	/* 101 */
#define	kp6_scan_101		0x004D	/* 102 */
#define	kp3_scan_101		0x0051	/* 103 */
#define	kpdp_scan_101		0x0053	/* 104 */

#define	minus_scan_101		0x004A	/* 105 */
#define	plus_scan_101		0x004E	/* 106 */
#define	kpEnter_scan_101	0xE01C	/* 108 */

#define	esc_scan_101		0x0001	/* 110 */

#define	f1_scan_101			0x003B	/* 112 */
#define	f2_scan_101			0x003C	/* 113 */
#define	f3_scan_101			0x003D	/* 114 */
#define	f4_scan_101			0x003E	/* 115 */

#define	f5_scan_101			0x003F	/* 116 */
#define	f6_scan_101			0x0040	/* 117 */
#define	f7_scan_101			0x0041	/* 118 */
#define	f8_scan_101			0x0042	/* 119 */

#define	f9_scan_101			0x0043	/* 120 */
#define	f10_scan_101		0x0044	/* 121 */
#define	f11_scan_101		0x0057	/* 122 */
#define	f12_scan_101		0x0058	/* 123 */

#define	prtScr_scan_101		0xE037	/* 124 */
#define	scroll_scan_101		0x0046	/* 125 */
#define	pause_scan_101		0x0045	/* 126 */

/* Aliases */

#define	shift_scan_101		lshift_scan_101
#define	control_scan_101	lcontrol_scan_101
#define	alt_scan_101		lalt_scan_101

#define	sysreq_scan_101		prtScr_scan_101
#define	break_scan_101		pause_scan_101

#define	no_ScanCode			  	0
#define no_scan_101				0



/****************************************************************************

	ScanTable is the lookup table to convert a key by its keynumber to the
	scan code for the key.  The table is padded with key numbers that are
	not currently used.  The table could have been smaller if we wanted to
	not use the same reference of key number as IBM in their technical
	reference materials.  However, I decided to pad it for possible future
	growth in the number of keys, and learning to deal with it.  Also I wanted
	to keep the same key number association as in the technical reference.

	If memory is a problem, then the tables could be compacted by not
	following the same keynumbers as the IBM techincal references.

****************************************************************************/

int	IBMextendedScanCodeSet1[] = {
	 no_scan_101,	  		/*   0 */
	 lquote_scan_101, 		/*   1 */
	 one_scan_101,	  		/*   2 */
	 two_scan_101,	  		/*   3 */
	 three_scan_101,  		/*   4 */
	 four_scan_101,	  		/*   5 */
	 five_scan_101,	  		/*   6 */
	 six_scan_101,	  		/*   7 */
	 seven_scan_101,  		/*   8 */
	 eight_scan_101,  		/*   9 */
	 nine_scan_101,	  		/*  10 */
	 zero_scan_101,	  		/*  11 */
	 hyphen_scan_101, 		/*  12 */
	 equal_scan_101,  		/*  13 */
	 no_scan_101,	  		/*  14 */
	 backspace_scan_101,	/*  15 */
	 tab_scan_101,			/*  16 */
	 q_scan_101,			/*  17 */
	 w_scan_101,			/*  18 */
	 e_scan_101,			/*  19 */
	 r_scan_101,			/*  20 */
	 t_scan_101,			/*  21 */
	 y_scan_101,			/*  22 */
	 u_scan_101,			/*  23 */
	 i_scan_101,			/*  24 */
	 o_scan_101,			/*  25 */
	 p_scan_101,			/*  26 */
	 lbracket_scan_101,		/*  27 */
	 rbracket_scan_101,		/*  28 */
	 bslash_scan_101,		/*  29 */
	 caps_scan_101,			/*  30 */
	 a_scan_101,			/*  31 */
	 s_scan_101,			/*  32 */
	 d_scan_101,			/*  33 */
	 f_scan_101,			/*  34 */
	 g_scan_101,			/*  35 */
	 h_scan_101,			/*  36 */
	 j_scan_101,			/*  37 */
	 k_scan_101,			/*  38 */
	 l_scan_101,			/*  39 */
	 semi_scan_101,			/*  40 */
	 rquote_scan_101,		/*  41 */
	 no_scan_101,			/*  42 */
	 return_scan_101,		/*  43 */
	 lshift_scan_101,		/*  44 */
	 no_scan_101,			/*  45 */
	 z_scan_101,			/*  46 */
	 x_scan_101,			/*  47 */
	 c_scan_101,			/*  48 */
	 v_scan_101,			/*  49 */
	 b_scan_101,			/*  50 */
	 n_scan_101,			/*  51 */
	 m_scan_101,			/*  52 */
	 comma_scan_101,		/*  53 */
	 period_scan_101,		/*  54 */
	 fslash_scan_101,		/*  55 */
	 no_scan_101,			/*  56 */
	 rshift_scan_101,		/*  57 */
	 lcontrol_scan_101,		/*  58 */
	 no_scan_101,			/*  59 */
	 lalt_scan_101,			/*  60 */
	 space_scan_101,		/*  61 */
	 ralt_scan_101,			/*  62 */
	 no_scan_101,			/*  63 */
	 rcontrol_scan_101,		/*  64 */
	 no_scan_101,			/*  65 */
	 no_scan_101,			/*  66 */
	 no_scan_101,			/*  67 */
	 no_scan_101,			/*  68 */
	 no_scan_101,			/*  69 */
	 no_scan_101,			/*  70 */
	 no_scan_101,			/*  71 */
	 no_scan_101,			/*  72 */
	 no_scan_101,			/*  73 */
	 no_scan_101,			/*  74 */
	 insert_scan_101,		/*  75 */
	 delete_scan_101,		/*  76 */
	 no_scan_101,			/*  77 */
	 no_scan_101,			/*  78 */
	 left_scan_101,			/*  79 */
	 home_scan_101,			/*  80 */
	 end_scan_101,			/*  81 */
	 no_scan_101,			/*  82 */
	 up_scan_101,			/*  83 */
	 down_scan_101,			/*  84 */
	 pageup_scan_101,		/*  85 */
	 pagedown_scan_101,		/*  86 */
	 no_scan_101,			/*  87 */
	 no_scan_101,			/*  88 */
	 right_scan_101,		/*  89 */
	 numlock_scan_101,		/*  90 */
	 kp7_scan_101,			/*  91 */
	 kp4_scan_101,			/*  92 */
	 kp1_scan_101,			/*  93 */
	 no_scan_101,			/*  94 */
	 kpDivide_scan_101,		/*  95 */
	 kp8_scan_101,			/*  96 */
	 kp5_scan_101,			/*  97 */
	 kp2_scan_101,			/*  98 */
	 kp0_scan_101,			/*  99 */
	 asterisk_scan_101,		/* 100 */
	 kp9_scan_101,			/* 101 */
	 kp6_scan_101,			/* 102 */
	 kp3_scan_101,			/* 103 */
	 kpdp_scan_101,			/* 104 */
	 minus_scan_101,		/* 105 */
	 plus_scan_101,			/* 106 */
	 no_scan_101,			/* 107 */
	 kpEnter_scan_101,		/* 108 */
	 no_scan_101,			/* 109 */
	 esc_scan_101,			/* 110 */
	 no_scan_101,			/* 111 */
	 f1_scan_101,			/* 112 */
	 f2_scan_101,			/* 113 */
	 f3_scan_101,			/* 114 */
	 f4_scan_101,			/* 115 */
	 f5_scan_101,			/* 116 */
	 f6_scan_101,			/* 117 */
	 f7_scan_101,			/* 118 */
	 f8_scan_101,			/* 119 */
	 f9_scan_101,			/* 120 */
	 f10_scan_101,			/* 121 */
	 f11_scan_101,			/* 122 */
	 f12_scan_101,			/* 123 */
	 prtScr_scan_101,		/* 124 */
	 scroll_scan_101,		/* 125 */
	 pause_scan_101,		/* 126 */
	 no_scan_101			/* 127 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\vars.c ===
/*  VARS.C  */

//#define     WINVER 0x0300

#include	"windows.h"
//#include "winstric.h"                        /* added for win 3.1 compatibility 1/92 */
#include "drivers.h"
#include "vars1.h"
#include "gide.h"

void 	*aliasStack[MAXVECTORSTACK];
void	*vectorStack[MAXVECTORSTACK];

int	stackPointer;
unsigned char lastCode;
void	(*serialVector)();
void	(*codeVector)();
int	(*commandVector)();
struct aliasTable *aliasPtr;

struct aliasTable nullTable[] = 
{
	{ "",		0	},
};

struct listTypes tempList, keyHoldList, keyLockList;
char cAliasString[MAXALIASLEN];
int nullCount;
int blockCount;

char buf[CODEBUFFERLEN];
int spos,rpos;

int passAll, fatalErrorFlag, stdErrorFlag, waitForClear, beginOK;

int mouseX, mouseY;

MOUSEKEYSPARAM mouData = {2, 0, 0, 0};
MOUSEKEYSPARAM *mouseDataPtr = &mouData;
int requestButton1, requestButton2, requestButton3 = FALSE;
int button1Status, button2Status, button3Status = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\vars1.h ===
/*  VARS1.H  */


#define MAXALIASLEN 20
#define CODEBUFFERLEN 20
#define MAXVECTORSTACK 20
#define MAXLISTLENGTH 20

struct aliasTable {
	unsigned char *aliasName;
	unsigned char gideiCode;
	};

struct asciiTables {
	unsigned char gideiCode1, gideiCode2;
	};

struct listTypes {
	int len;
	unsigned char list[MAXLISTLENGTH];
	};




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\calc.c ===
/**************************************************************************\
 *** SCICALC Scientific Calculator for Windows 3.00.12
 *** By Kraig Brockschmidt, Microsoft Co-op, Contractor, 1988-1989
 *** (c)1989 Microsoft Corporation.  All Rights Reserved.
 ***
 *** scimain.c
 ***
 *** Definitions of all globals, WinMain procedure
 ***
 *** Last modification
 ***    Fri  22-Nov-1996
 ***
 *** -by- Jonathan Parati. [jonpa]   22-Nov-1996
 *** Converted Calc from floating point to infinite precision.
 *** The new math engine is in ..\ratpak
 ***
 ***
 *** -by- Amit Chatterjee. [amitc]  05-Jan-1990.
 *** Calc did not have a floating point exception signal handler. This
 *** would cause CALC to be forced to exit on a FP exception as that's
 *** the default.
 *** The signal handler is defined in SCIFUNC.C, in WinMain we hook the
 *** the signal.
\**************************************************************************/

#include "scicalc.h"
#include "calchelp.h"
#include "signal.h"
#include "unifunc.h"
#include "input.h"
#include "scidisp.h"
#include "strsafe.h"

#define BOOLIFY(x) ((x)?1:0)

/**************************************************************************/
/*** Global variable declarations and initializations                   ***/
/**************************************************************************/

int        nCalc=0;        /* 0=Scientific, 1=Simple.                      */
BOOL       gbUseSep=FALSE; /* display the number with a separator          */
ANGLE_TYPE nDecMode=ANGLE_DEG;  /* Holder for last used Deg/Rad/Grad mode. */
UINT       gnDecGrouping=0x03;  /* Holds the decimal digit grouping number */
int        nHexMode=0;     /* Holder for last used Dword/Word/Byte mode.   */

int        nTempCom=0,     /* Holding place for the last command.          */
           nParNum=0,      /* Number of parenthases.                       */
           nOpCode=0,      /* ID value of operation.                       */
           nOp[25],        /* Holding array for parenthasis operations.    */
           nPrecOp[25],    /* Holding array for precedence  operations.    */
           nPrecNum=0,     /* Current number of precedence ops in holding. */
           gcIntDigits;    /* Number of digits allowed in the current base */

eNUMOBJ_FMT nFE = FMT_FLOAT; /* Scientific notation conversion flag.       */

HWND       g_hwndDlg=0,     /* Global handle to main window.               */
           hEdit=0,         /* Handle to Clibboard I/O edit control        */
           hStatBox=0,      /* Global handle to statistics box.            */
           hListBox=0;      /* Global handle for statistics list box.      */
            

HMENU      g_hHexMenu=NULL;     // Global handle for hex menu 
HMENU      g_hDecMenu=NULL;     // Global handle for dec menu 

HANDLE     hAccel;              // Accelerator handle.
HINSTANCE  hInst;               // Global instance.

BOOL       bHyp=FALSE,          // Hyperbolic on/off flag.
           bInv=FALSE,          // Inverse on/off flag.
           bError=FALSE,        // Error flag.
           bColor=TRUE;         // Flag indicating if color is available.

HNUMOBJ    ghnoNum=NULL,        // Currently displayed number used everywhere.
           ghnoParNum[25],      // Holding array for parenthasis values.
           ghnoPrecNum[25],     // Holding array for precedence  values.
           ghnoMem=NULL,        // Current memory value.
           ghnoLastNum = NULL;  // Number before operation (left operand).

LONG       nPrecision = 32,         // number of digits to use in decimal mode
           nDecimalPlaces = 10,     // number of decimal places to show
           nRadix=10,               // the current base (2, 8, 10, or 16)
           dwWordBitWidth = 64;     // # of bits in currently selected word size

BOOL       g_fHighContrast = FALSE; // Are we in High Contrast mode?

HNUMOBJ g_ahnoChopNumbers[4];   // word size inforcement

BOOL    bFarEast;       // true if we need to use Far East localization

#ifdef USE_MIRRORING
BOOL    g_fLayoutRTL = FALSE;
#endif

extern CALCINPUTOBJ gcio;
extern BOOL         gbRecord;

/* DO NOT LOCALIZE THESE STRINGS.                                           */

TCHAR      szAppName[10]=TEXT("SciCalc"), /* Application name.              */
           szDec[5]=TEXT("."),            /* Default decimal character      */
           gszSep[5]=TEXT(","),           /* Default thousand seperator     */
           szBlank[6]=TEXT(" ");           /* Blank space.                   */

LPTSTR     gpszNum = NULL;
int        gcchNum = 0;
static TCHAR szInitNum[] = TEXT("0");      // text to init gpszNum with

/* END WARNING */


/* rgpsz[] is an array of pointers to strings in a locally allocated      */
/* memory block.  This block is fixed such that LocalLock does not need   */
/* to be called to use a string.                                          */

TCHAR     *rgpsz[CSTRINGS];
RECT      rcDeg[6];


void ParseCmdLine( LPSTR pszCmdA );
BOOL InitializeWindowClass( HINSTANCE hPrevInstance );
void InitialOneTimeOnlySetup();
void EverythingResettingNumberSetup();

extern WNDPROC fpOrgDispEditProc;
LRESULT CALLBACK SubDispEditProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

/**************************************************************************/
/*** Main Window Procedure.                                             ***/
/***                                                                    ***/
/*** Important functions:                                               ***/
/***     1)  Gets text dimensions and sets conversion units correctly.  ***/
/***                                                                    ***/
/***     2)  Checks the display device driver for color capability.     ***/
/***         If only 2 colors are available (mono, cga), bColor is      ***/
/***         set to FALSE, and the background brush is gray.  If        ***/
/***         color is available, the background brush colors are read   ***/
/***         from WIN.INI and the brush is created.                     ***/
/***                                                                    ***/
/***     3)  Window and hidden edit control are created.                ***/
/***                                                                    ***/
/***     4)  Contains message loop and deletes the brushes used.        ***/
/***                                                                    ***/
/**************************************************************************/

int APIENTRY WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
        LPSTR lpCmdLine,
        int nCmdShow)
{
    MSG        msg;
    INT        nx;
    LPTSTR     psz;
    int        cch = 0, cchTotal = 0;
    TCHAR      szTempString[100] = {0};
#ifdef USE_MIRRORING
    DWORD      dwLayout;
#endif

    // A bunch of sanity checks to ensure nobody is violating any of the
    // bazillion
    // assumptions calc makes about the order of controls.  Of course these 
    // asserts
    // wouldn't prevent a really dedicated person from messing things up but they
    // should help guide a rational person who might not be aware of calc's 
    // idiosyncrasies.
    // Anyone who modifies the resource file should hit these asserts which
    // will then
    // alert them to the consequences of their actions.

    // IDC_0 to IDC_F must be in sequential increasing order
    ASSERT( 15 == (IDC_F - IDC_0) );
    // Binary operators IDC_AND through IDC_PWR must be in order
    ASSERT( (95-86) == (IDC_PWR - IDC_AND) );
    // Unary operators IDC_CHOP through IDC_EQU must be in order
    ASSERT( (112-96) == (IDC_EQU - IDC_CHOP) );
    // menu item id's must be in order
    ASSERT( 5 == (IDM_LASTMENU - IDM_FIRSTMENU) );

#ifdef USE_MIRRORING
    if (GetProcessDefaultLayout(&dwLayout) && (dwLayout & LAYOUT_RTL))
    {
        SetProcessDefaultLayout(dwLayout & ~LAYOUT_RTL);
        g_fLayoutRTL = TRUE;
    }
#endif

    ParseCmdLine( lpCmdLine );

    hInst = hInstance;

    if ( !InitializeWindowClass( hPrevInstance ) )
        return FALSE;

    // Read strings for keys, errors, trig types, etc.
    // These will be copied from the resources to local memory.  A larger
    // than needed block is allocated first and then reallocated once we
    // know how much is actually used.
    try
    {
        psz = (LPTSTR) LocalAlloc(LPTR, ByteCountOf(CCHSTRINGSMAX));
        if (!psz)
            throw;

        int cchResourceBuffer = CCHSTRINGSMAX, cchLeftInBuffer;

        // build up an offset array in rgpsz
        for (nx = 0; nx <= CSTRINGS; nx++)
        {
            INT_PTR iOffset;
Retry:
            cchLeftInBuffer = cchResourceBuffer - cchTotal;
            cch = 1 + LoadString(hInstance, (UINT)(IDS_FIRSTKEY + nx), psz + cchTotal, cchLeftInBuffer);

            if (cch == (cchResourceBuffer - cchTotal)) // woops: buffer was too small
            {
                LPTSTR pszTmp = (LPTSTR)LocalReAlloc(psz, ByteCountOf(cchResourceBuffer + CCHSTRINGSMAX), LMEM_MOVEABLE);
                if (!pszTmp)
                    throw;
                psz = pszTmp;
                cchResourceBuffer += CCHSTRINGSMAX;
                goto Retry;
            }

            iOffset = (INT_PTR)cchTotal;
            rgpsz[nx] = (LPTSTR)iOffset; // first pass is offset array
            cchTotal += cch;
        }
        LPTSTR pszTmp = (LPTSTR)LocalReAlloc(psz, ByteCountOf(cchTotal), LMEM_MOVEABLE);
        if (!pszTmp)
            throw;
        psz = pszTmp;

        // convert the array of offsets into an array of pointers
        for (nx = 0 ; nx <= CSTRINGS ; nx++)
            rgpsz[nx] = psz + (INT_PTR)rgpsz[nx];
    }
    catch ( ... )
    {
        if (psz)
            LocalFree(psz);
        if (LoadString(hInst, IDS_NOMEM, szTempString, CharSizeOf(szTempString)))
        {
            MessageBox((HWND) NULL, szTempString, NULL, MB_OK | MB_ICONHAND);
        }
        return FALSE;
    }

    // The display in calc isn't really an edit control so we use this edit 
    // control to simplify cutting to the clipboard

    hEdit = CreateWindow( TEXT("EDIT"), TEXT("CalcMsgPumpWnd"), 
                          WS_OVERLAPPED | WS_VISIBLE, 
                          CW_USEDEFAULT,0,CW_USEDEFAULT,0, 
                          NULL, NULL, hInst, NULL );

    // This initializes things that only need to be set up once, including a 
    // call to ratpak so that ratpak can create any constants it needs

    InitialOneTimeOnlySetup();

    // we store in the win.ini file our desired display mode, Scientific 
    //  or Standard

    nCalc = (INT)GetProfileInt(szAppName, TEXT("layout"), 1);
    if ((nCalc != 0) && (nCalc != 1))
    {
        // Go to the default value in case of bad values
        nCalc = 1;
    }

    gbUseSep = (INT)GetProfileInt(szAppName, TEXT("UseSep"), 0);
    if ((gbUseSep != 0) && (gbUseSep != 1))
    {
        // Go to the default value in case of bad values
        gbUseSep = 0;
    }

    // InitSciCalc creates a dialog based on what the value of nCalc is. 
    // A handle to the window that is created is stored in g_hwndDlg

    InitSciCalc(TRUE);

    hAccel = LoadAccelerators(hInst, MAKEINTRESOURCE(IDA_ACCELTABLE));


    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!hStatBox || !IsDialogMessage(hStatBox, &msg))
        {
            if ( ((msg.hwnd == g_hwndDlg)||IsChild(g_hwndDlg, msg.hwnd)) && TranslateAccelerator (g_hwndDlg, (HACCEL)hAccel, &msg))
                continue;

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    LocalFree(psz);
    return (DWORD)msg.wParam;
}


/**************************************************************************\
*
*   Command Line processing routines
*
*   History
*       22-Nov-1996 JonPa       Wrote it
*
\**************************************************************************/

#define IsWhiteSpace( ch )  ((ch) == TEXT(' ') || (ch) == TEXT('\t'))
#define IsDigit( ch )       ((ch) >= TEXT('0') && (ch) <= TEXT('9'))

LPTSTR TtoL( LPTSTR psz, LONG *pl ) {
    LONG l = 0;

    while( IsDigit( *psz ) ) {
        l = l * 10 + (*psz - TEXT('0'));
        psz = CharNext( psz );
    }

    *pl = l;
    return psz;
}

void ParseCmdLine( LPSTR pszCmdA ) {
    BOOL fInQuote;
    LPTSTR pszCmdT = GetCommandLine();

    // parse cmd line
    // usage: -p:## -r:## -w:## -e -x -i
    // -e, -x, and -i currently do nothing.

    // Skip app name
    while( *pszCmdT && IsWhiteSpace( *pszCmdT )) {
        pszCmdT = CharNext( pszCmdT );
    }

    fInQuote = FALSE;
    while( *pszCmdT && (fInQuote || !IsWhiteSpace(*pszCmdT)) ) {
        if (*pszCmdT == TEXT('\"'))
            fInQuote = !fInQuote;
        pszCmdT = CharNext( pszCmdT );
    }

    while( *pszCmdT )
    {
        switch( *pszCmdT )
        {
        case TEXT('p'):
        case TEXT('P'):
            // -p:## precision
            pszCmdT = CharNext(pszCmdT);

            // Skip ':' and white space
            while( *pszCmdT && (*pszCmdT == TEXT(':') || IsWhiteSpace(*pszCmdT)) ) {
                pszCmdT = CharNext(pszCmdT);
            }

            pszCmdT = TtoL( pszCmdT, &nPrecision );

            // a percision > C_NUM_MAX_DIGITS will allow a string too long for it's buffer
            if ( nPrecision > C_NUM_MAX_DIGITS)
            {
                ASSERT( nPrecision <= C_NUM_MAX_DIGITS );
                nPrecision = C_NUM_MAX_DIGITS;
            }

            // NOTE: this code assumes there MUST be a space after the number
            break;

        case TEXT('r'):
        case TEXT('R'):
            // -r:## Radix
            pszCmdT = CharNext(pszCmdT);

            // Skip ':' and white space
            while( *pszCmdT && (*pszCmdT == TEXT(':') || IsWhiteSpace(*pszCmdT)) ) {
                pszCmdT = CharNext(pszCmdT);
            }

            pszCmdT = TtoL( pszCmdT, &nRadix );

            // since the UI only has 16 keys for digit input, we only allow upto base 16
            if (nRadix > 16)
            {
                ASSERT( nRadix <= 16 );
                nRadix = 16;
            }
            else if (nRadix < 2)    // you know some fool would try for base zero if you let them
            {
                ASSERT( nRadix >= 2 );
                nRadix = 2;
            }

           // NOTE: this code assumes there MUST be a space after the number
            break;

        case TEXT('e'):
        case TEXT('E'):
            // -e extended mode
            break;

        case TEXT('w'):
        case TEXT('W'):
            // -w:## Word size in bits
            pszCmdT = CharNext(pszCmdT);

            // Skip ':' and white space
            while( *pszCmdT && (*pszCmdT == TEXT(':') || IsWhiteSpace(*pszCmdT)) ) {
                pszCmdT = CharNext(pszCmdT);
            }

            // Set bit count
            pszCmdT = TtoL( pszCmdT, &dwWordBitWidth );

            // NOTE: this code assumes there MUST be a space after the number
            break;
        }

        pszCmdT = CharNext( pszCmdT );
    }
}

//////////////////////////////////////////////////
//
// InitalizeWindowClass
//
//////////////////////////////////////////////////
BOOL InitializeWindowClass( HINSTANCE hPrevInstance )
{
    WNDCLASSEX wndclass;

    if (!hPrevInstance)
    {
        wndclass.cbSize         = sizeof(wndclass);
        wndclass.style          = 0;
        wndclass.lpfnWndProc    = CalcWndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = DLGWINDOWEXTRA;
        wndclass.hInstance      = hInst;
        wndclass.hIcon          = LoadIcon(hInst, TEXT("SC"));
        wndclass.hCursor        = LoadCursor (NULL, IDC_ARROW);
        wndclass.hbrBackground  = GetSysColorBrush(COLOR_3DFACE);
        wndclass.lpszMenuName   = MAKEINTRESOURCE(IDM_CALCMENU);
        wndclass.lpszClassName  = szAppName;
        wndclass.hIconSm        = NULL;

        if (!RegisterClassEx(&wndclass))
            return FALSE;
    }
    return TRUE;
}

//////////////////////////////////////////////////
//
// InitialOneTimeOnlyNumberSetup
//
//////////////////////////////////////////////////
void InitialOneTimeOnlySetup()
{
    // Initialize the decimal input code.  This ends up getting called twice
    // but it's quick so that shouldn't be a problem.  Needs to be done before
    // SetRadix is called.

    CIO_vClear( &gcio );
    gbRecord = TRUE;

    // we must now setup all the ratpak constants and our arrayed pointers 
    // to these constants.
    BaseOrPrecisionChanged();

    // these rat numbers are set only once and then never change regardless of 
    // base or precision changes
    g_ahnoChopNumbers[0] = rat_qword;
    g_ahnoChopNumbers[1] = rat_dword;
    g_ahnoChopNumbers[2] = rat_word;
    g_ahnoChopNumbers[3] = rat_byte;

    // we can't call this until after we have set the radix (and thus called 
    // ChangeConstants) so we do it last.

    EverythingResettingNumberSetup();

    NumObjAssign( &ghnoMem, HNO_ZERO );
}

//////////////////////////////////////////////////
//
// EverythingResettingNumberSetup
//
//////////////////////////////////////////////////
void EverythingResettingNumberSetup()
{
    int i;

    // Initialize the decimal input code.
    CIO_vClear( &gcio );
    gbRecord = TRUE;

    NumObjAssign( &ghnoNum, HNO_ZERO );
    NumObjAssign( &ghnoLastNum, HNO_ZERO );

    // REVIEW: is it just me, or do we speew major memory wheneven this method
    // executes?

    // array used to handle ( and )
    for( i = 0; i < ARRAYSIZE(ghnoParNum); i++ )
        ghnoParNum[i] = NULL;

    // array used to handle order of operations
    for( i = 0; i < ARRAYSIZE(ghnoPrecNum); i++ )
        ghnoPrecNum[i] = NULL;

    int cbNum = sizeof(szInitNum);
    gpszNum = (LPTSTR)NumObjAllocMem( cbNum );
    if (gpszNum)
    {
        gcchNum = cbNum / sizeof(TCHAR);
        StringCchCopy(gpszNum, gcchNum, szInitNum);
    }
}

//////////////////////////////////////////////////
//
// InitSciCalc
//
//////////////////////////////////////////////////
VOID  APIENTRY InitSciCalc(BOOL bViewChange)
{
    TCHAR   chLastDec;
    TCHAR   chLastSep;
    int     nLastSepLen;
    UINT    nLastDecGrouping;
    HMENU   hMenu;
    HWND    hDispEdit;
    BOOL    bRepaint=FALSE;
    RECT    rect = {0,0,0,0};
    TCHAR   szGrouping[32];
    

    EverythingResettingNumberSetup();

    // when we switch modes, we need to remind the ui that we are no longer 
    // inputing the number we were inputting before we switched modes.

    gbRecord = FALSE;    // REVIEW: This should not be needed with the new initialization

    chLastDec = szDec[0];
    chLastSep = gszSep[0];
    nLastDecGrouping=gnDecGrouping;

    // SECURITY: szDec can have any value you want, but only the first letter is used.
    GetProfileString(TEXT("intl"), TEXT("sDecimal"), TEXT("."), 
                     szDec, CharSizeOf(szDec));
    if (szDec[0] == 0)
    {
        szDec[0] = L'.';
    }

    // SECURITY: gszSep can have any value you want, but only the first letter is used.
    GetProfileString(TEXT("intl"), TEXT("sThousand"), TEXT(","), 
                     gszSep, CharSizeOf(gszSep));
    if (gszSep[0] == 0)
    {
        gszSep[0] = L',';
    }

    ZeroMemory(szGrouping, sizeof(szGrouping));
    // SECURITY: DigitGroupingStringToGroupingNum is responsible for handling all failure cases
    GetProfileString(TEXT("intl"), TEXT("sGrouping"), TEXT("3;0"), 
                     szGrouping, CharSizeOf(szGrouping));

    gnDecGrouping=DigitGroupingStringToGroupingNum(szGrouping);

    // if the grouping pattern changed we always do the following things
    if (gnDecGrouping != nLastDecGrouping)
    {
        nLastDecGrouping=gnDecGrouping;
        bRepaint=TRUE;
    }
    
    
    // if the thousands symbol has changed we always do the following things

    if ( gszSep[0] != chLastSep )
    {
        chLastSep = gszSep[0];

        bRepaint = TRUE;
    }
    
    // if the decimal symbol has changed we always do the following things
    if ( szDec[0] != chLastDec )
    {
        chLastDec = szDec[0];

        // Re-initialize input string's decimal point.
        CIO_vUpdateDecimalSymbol(&gcio, chLastDec);

        // put the new decimal symbol into the table used to draw the decimal
        // key

        *(rgpsz[IDS_DECIMAL]) = chLastDec;

        // we need to redraw to update the decimal point button
        bRepaint = TRUE;
    }

    {
        HIGHCONTRAST hc;
        hc.cbSize = sizeof(hc);
        if ( SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0) )
        {
            if ( BOOLIFY(hc.dwFlags & HCF_HIGHCONTRASTON) != g_fHighContrast )
            {
                g_fHighContrast = BOOLIFY(hc.dwFlags & HCF_HIGHCONTRASTON);
                bRepaint = TRUE;
            }
        }
    }

    if ( bViewChange )
    {
        BOOL bUseOldPos = FALSE;

        // if we are changing views we destory the old window and create 
        // a new window

        if ( g_hwndDlg )
        {
            SetMenu(g_hwndDlg, g_hDecMenu);
            bUseOldPos = TRUE;
            GetWindowRect( g_hwndDlg, &rect );
            DestroyWindow( g_hwndDlg );
            DestroyMenu(g_hHexMenu);
            g_hHexMenu=NULL;
        }

        // create the correct window for the mode we're currently in
        if ( nCalc )
        {
            // switch to standard mode
            g_hwndDlg = CreateDialog(hInst, MAKEINTRESOURCE(IDD_STANDARD), 0, 
                                     NULL);
            g_hDecMenu=GetMenu(g_hwndDlg);

#ifdef USE_MIRRORING
            if (g_fLayoutRTL)
            {
                SetWindowLong(g_hwndDlg,
                              GWL_EXSTYLE,
                              GetWindowLong(g_hwndDlg,GWL_EXSTYLE) | \
                              WS_EX_LAYOUTRTL |  WS_EX_NOINHERITLAYOUT);
            }
#endif
        }
        else
        {
            // switch to scientific mode
            g_hwndDlg = CreateDialog(hInst, MAKEINTRESOURCE(IDD_SCIENTIFIC), 
                                     0, NULL);
            g_hDecMenu=GetMenu(g_hwndDlg);
            g_hHexMenu=LoadMenu(hInst, MAKEINTRESOURCE(IDM_HEXCALCMENU));

#ifdef USE_MIRRORING
            if (g_fLayoutRTL)
            {
                SetWindowLong(g_hwndDlg,
                              GWL_EXSTYLE,
                              GetWindowLong(g_hwndDlg,GWL_EXSTYLE) | WS_EX_LAYOUTRTL | WS_EX_NOINHERITLAYOUT);
            }
#endif

            // Stat box is initially off, disable stat buttons.
            for ( int iID = IDC_AVE; iID <= IDC_DATA; iID++ )
                EnableWindow( GetDlgItem( g_hwndDlg, iID ), FALSE );

            SwitchModes(10, nDecMode, nHexMode);

            // If precision won't fit in display, then resize it
            if (nPrecision > 32)
            {
                HWND hwndDisplay;
                RECT rc, rcMain;

                hwndDisplay=GetDlgItem( g_hwndDlg, IDC_DISPLAY );
                GetWindowRect( hwndDisplay, &rc );
                GetClientRect( g_hwndDlg, &rcMain );
                MapWindowPoints( g_hwndDlg, NULL, (LPPOINT)&rcMain, 2);

                rc.left    = rcMain.left + (rcMain.right - rc.right);
                OffsetRect( &rc, -(rcMain.left), -(rcMain.top) );

                SetWindowPos(hwndDisplay, NULL, 
                             rc.left, rc.top, 
                             rc.right - rc.left, rc.bottom - rc.top,
                             SWP_NOACTIVATE | SWP_NOZORDER );
            }
        }

        if (hDispEdit = GetDlgItem(g_hwndDlg, IDC_DISPLAY))
        {
            // subclass the Edit Control hide caret and filter out mouse msg
            fpOrgDispEditProc = (WNDPROC)GetWindowLongPtr(hDispEdit, GWLP_WNDPROC);
            if (fpOrgDispEditProc)
                SetWindowLongPtr(hDispEdit, GWLP_WNDPROC, (LONG_PTR)(WNDPROC)SubDispEditProc);
        }
        
        // keep calc in the same place it was before
        if ( bUseOldPos )
        {
            SetWindowPos( g_hwndDlg, NULL, rect.left, rect.top, 0,0, 
                          SWP_NOZORDER | SWP_NOSIZE );
        }

        // ensure the menu items for Scientific and Standard are set correctly

        CheckMenuRadioItem(g_hDecMenu, IDM_SC, IDM_SSC, 
                           (nCalc == 0 ? IDM_SC : IDM_SSC), MF_BYCOMMAND); 

        CheckMenuItem(g_hDecMenu, IDM_USE_SEPARATOR, 
                      MF_BYCOMMAND | (gbUseSep ? MF_CHECKED : MF_UNCHECKED));  

        if (g_hHexMenu)
        {
            CheckMenuRadioItem(g_hHexMenu, IDM_SC, IDM_SSC, 
                               (nCalc == 0 ? IDM_SC : IDM_SSC), MF_BYCOMMAND); 

            CheckMenuItem(g_hHexMenu, IDM_USE_SEPARATOR, 
                          MF_BYCOMMAND | (gbUseSep ? MF_CHECKED:MF_UNCHECKED)); 
        }

        // To ensure that the call to SetRadix correctly update the active 
        // state of the buttons on
        // SciCalc we must tell it to forget the previous Radix
        {
            extern long oldRadix;
            oldRadix = (unsigned)-1;
        }

        // this will set the correct buttons on the UI
        SetRadix(10);

        SetDlgItemText(g_hwndDlg, IDC_MEMTEXT, 
                       NumObjIsZero(ghnoMem) ? (szBlank) : (TEXT(" M")) );

        SendMessage(g_hwndDlg, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0);

        ShowWindow( g_hwndDlg, SW_SHOW );
        UpdateWindow(g_hwndDlg);

    } // END if ( bViewChanged )
    else if ( bRepaint )
    {
        // no need to repaint if we just changed views
        InvalidateRect( g_hwndDlg, NULL, TRUE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\calchelp.h ===
/* CalcHelp.h - help codes for Chicago Calculator */

#define CALC_STD_SIGN       80 // beginning of matchup
#define CALC_C              81
#define CALC_CE             82
#define CALC_BACK           83
#define CALC_SCI_STA        84
#define CALC_STD_DECIMAL    85

#define CALC_SCI_AND        86
#define CALC_SCI_OR         87
#define CALC_SCI_XOR        88
#define CALC_SCI_LSH        89
#define CALC_STD_SLASH      90
#define CALC_STD_ASTERISK   91
#define CALC_STD_PLUS       92
#define CALC_STD_MINUS      93
#define CALC_SCI_MOD        94
#define CALC_SCI_XCARETY    95

#define CALC_SCI_INT        96
#define CALC_SCI_NOT        97
#define CALC_SCI_SIN        98
#define CALC_SCI_COS        99
#define CALC_SCI_TAN        100
#define CALC_SCI_LN         101
#define CALC_SCI_LOG        102
#define CALC_STD_SQRT       103
#define CALC_SCI_XCARET2    140
#define CALC_SCI_XCARET3    104
#define CALC_SCI_FACTORIAL  105
#define CALC_1X             106
#define CALC_SCI_DMS        107
#define CALC_STD_PERCENT    108
#define CALC_SCI_FE         109
#define CALC_SCI_PI         110
#define CALC_STD_EQUAL      111

#define CALC_MC             112
#define CALC_MR             113
#define CALC_MS             114
#define CALC_MPLUS          115 /* was CALC_M+ but this breaks the C compiler */

#define CALC_SCI_EXP        116

#define CALC_SCI_AVE        117
#define CALC_SCI_SUM        118
#define CALC_SCI_S          119
#define CALC_SCI_DAT        120

#define CALC_SCI_OPENPAREN  40
#define CALC_SCI_CLOSEPAREN 41

#define CALC_STD_NUMBERS    48 /* are Numbers  48-57*/
#define CALC_SCI_ABCDEF     65 /* Are Numbers 65 - 70 */
// 0 - F are in here, bin should start again at 140

#define CALC_SCI_BIN        121
#define CALC_SCI_OCT        122
#define CALC_SCI_DEC        123
#define CALC_SCI_HEX        124

#define CALC_SCI_INV        125
#define CALC_SCI_HYP        126
#define CALC_SCI_DEG        127
#define CALC_SCI_RAD        128
#define CALC_SCI_GRAD       129

// if Dword, word, and byte followed Deg,rad,grad we could convert by adding three
#define CALC_SCI_OWORD      19   // reserved 128 bit
#define CALC_SCI_QWORD      20
#define CALC_SCI_DWORD      21
#define CALC_SCI_WORD       22
#define CALC_SCI_BYTE       23

#define CALC_SCI_MEM        130     // end of matchup
#define CALC_SCI_PARENS     131
#define CALC_STD_VALUE      9       // this is the display's help text
      
// these are converted seperately:                      
#define CALC_SCI_STATISTICS_VALUE 401
#define CALC_SCI_RET       402
#define CALC_SCI_LOAD      403
#define CALC_SCI_CD        404
#define CALC_SCI_CAD       405
#define CALC_SCI_NUMBER    406
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\input.h ===
/****************************Module*Header***********************************\
* Module Name: INPUT.H
*
* Module Descripton:
*
* Warnings:
*
* Created:
*
* Author:
\****************************************************************************/

// the string must hold, at a minimun, enough digits for a quadword binary number (ie 64)
#define MAX_STRLEN      64          // Seems to be the magic value for calc...

#define C_NUM_MAX_DIGITS    MAX_STRLEN
#define C_EXP_MAX_DIGITS    4

typedef struct
{
    BOOL    fEmpty;                 // TRUE if the number has no digits yet
    BOOL    fNeg;                   // TRUE if number is negative
    INT     cchVal;                 // number of characters in number (including dec. pnt)
    TCHAR   szVal[MAX_STRLEN+1];      //
} CALCNUMSEC, *PCALCNUMSEC;

#if C_NUM_MAX_DIGITS > MAX_STRLEN || C_EXP_MAX_DIGITS > MAX_STRLEN
#   pragma error(CALCNUMSEC.szVal is too small)
#endif

typedef struct
{
    BOOL    fExp;                   // TRUE if number has exponent
    INT     iDecPt;                 // index to decimal point of number portion.  -1 if no dec pnt
    CALCNUMSEC cnsNum;              // base number
    CALCNUMSEC cnsExp;              // exponent if it exists
} CALCINPUTOBJ, *PCALCINPUTOBJ;

#define CIO_bDecimalPt(pcio)    ((pcio)->iDecPt != -1)

void CIO_vClear(PCALCINPUTOBJ pcio);
BOOL CIO_bAddDigit(PCALCINPUTOBJ pcio, int iValue);
void CIO_vToggleSign(PCALCINPUTOBJ pcio);
BOOL CIO_bAddDecimalPt(PCALCINPUTOBJ pcio);
BOOL CIO_bExponent(PCALCINPUTOBJ pcio);
BOOL CIO_bBackspace(PCALCINPUTOBJ pcio);
void CIO_vUpdateDecimalSymbol(PCALCINPUTOBJ pcio, TCHAR chLastDP);
void CIO_vConvertToString(LPTSTR *ppszOut, int* pcchszOut, PCALCINPUTOBJ pcio, int nRadix);
void CIO_vConvertToNumObj(PHNUMOBJ phnoNum, PCALCINPUTOBJ pcio);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\access\skeys\vars.h ===
/*  VARS.H  */

#include "vars1.h"

typedef  struct tagMouseKeysParam {
	int		NumButtons;		/* holds number of buttons on the mice	*/
	int		Delta_Y;		/* Relative Y motion sign extended		*/
	int		Delta_X;		/* Relative X motion sign extended		*/
	int		Status;			/* status of mouse buttons and motion	*/
} MOUSEKEYSPARAM;


#define TRUE 1
#define FALSE 0

#define TAB 9
#define LINEFEED 10
#define VERTICALTAB 11
#define FORMFEED 12
#define RETURN 13
#define SPACE 32
#define COMMA 44
#define PERIOD 46
#define ESC 27
#define ESCAPE 27

#define notOKstatus 0
#define okStatus 1
#define NOKEY 0

extern void *aliasStack[MAXVECTORSTACK];
extern void *vectorStack[MAXVECTORSTACK];
extern int stackPointer;
extern unsigned char lastCode;
extern void (*serialVector)(unsigned char);
extern void (*codeVector)(unsigned char);
extern void (*commandVector)(unsigned char);
extern struct aliasTable *aliasPtr;

extern struct listTypes tempList, keyHoldList, keyLockList;
extern char cAliasString[MAXALIASLEN];
extern int nullCount;
extern int blockCount;

extern char buf[CODEBUFFERLEN];
extern int spos,rpos;

extern int passAll, fatalErrorFlag, stdErrorFlag, waitForClear, beginOK;

extern int mouseX, mouseY;
extern MOUSEKEYSPARAM mouData;
extern MOUSEKEYSPARAM *mouseDataPtr;
extern int requestButton1, requestButton2, requestButton3;
extern int button1Status, button2Status, button3Status;

extern struct aliasTable nullTable[];


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by calc.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\resource.h ===
// Resources for Calculator

// Dialog IDs:
#define IDD_SCIENTIFIC    101
#define IDD_STANDARD      102
#define IDD_SB            103
#define IDD_TIMEOUT       104

// accelerator table:
#define IDA_ACCELTABLE    105

// Menu item constants:
#define IDM_CALCMENU      106
#define IDM_DECCALCMENU   107     // alternate menu
#define IDM_HEXCALCMENU   108     // alternate menu
#define IDM_HELPPOPUP     109     // "What's this?" menu


#define IDM_FIRSTMENU     IDM_COPY
#define IDM_COPY          300   // menu command IDs must be in one consecutive block
#define IDM_PASTE         301
#define IDM_ABOUT         302
#define IDM_USE_SEPARATOR 303
#define IDM_SC            304
#define IDM_SSC           305
#define IDM_HEX           306
#define IDM_DEC           307
#define IDM_OCT           308
#define IDM_BIN           309
#define IDM_QWORD         310 
#define IDM_DWORD         311
#define IDM_WORD          312
#define IDM_BYTE          313
#define IDM_DEG           314
#define IDM_RAD           315
#define IDM_GRAD          316
#define IDM_HELPTOPICS    317
#define IDM_LASTMENU      IDM_HELPTOPICS


#define IDC_HEX           IDM_HEX
#define IDC_DEC           IDM_DEC
#define IDC_OCT           IDM_OCT
#define IDC_BIN           IDM_BIN

#define IDC_DEG           IDM_DEG
#define IDC_RAD           IDM_RAD
#define IDC_GRAD          IDM_GRAD

#define IDC_QWORD         IDM_QWORD
#define IDC_DWORD         IDM_DWORD
#define IDC_WORD          IDM_WORD
#define IDC_BYTE          IDM_BYTE


// Key IDs:
// These id's must be consecutive from IDC_FIRSTCONTROL to IDC_LASTCONTROL. 
// The actual values don't matter but the order and sequence are very important.
// Also, the order of the controls must match the order of the control names
// in the string table.
#define IDC_FIRSTCONTROL IDC_SIGN
#define IDC_SIGN         80
#define IDC_CLEAR        81
#define IDC_CENTR        82
#define IDC_BACK         83
#define IDC_STAT         84
#define IDC_PNT          85

#define IDC_AND          86     // Binary operators must be between IDC_AND and IDC_PWR
#define IDC_OR           87
#define IDC_XOR          88
#define IDC_LSHF         89
#define IDC_DIV          90
#define IDC_MUL          91
#define IDC_ADD          92
#define IDC_SUB          93
#define IDC_MOD          94
#define IDC_PWR          95

#define IDC_CHOP         96     // Unary operators must be between IDC_CHOP and IDC_EQU
#define IDC_COM          97
#define IDC_SIN          98
#define IDC_COS          99
#define IDC_TAN         100
#define IDC_LN          101
#define IDC_LOG         102
#define IDC_SQRT        103
#define IDC_SQR         104
#define IDC_CUB         105
#define IDC_FAC         106
#define IDC_REC         107
#define IDC_DMS         108
#define IDC_PERCENT     109
#define IDC_FE          110
#define IDC_PI          111
#define IDC_EQU         112

#define IDC_MCLEAR      113
#define IDC_RECALL      114
#define IDC_STORE       115
#define IDC_MPLUS       116

#define IDC_EXP         117

#define IDC_AVE         118
#define IDC_B_SUM       119
#define IDC_DEV         120
#define IDC_DATA        121

#define IDC_OPENP       122
#define IDC_CLOSEP      123

#define IDC_0           124    // The controls for 0 through F must be consecutive and in order
#define IDC_1           125
#define IDC_2           126
#define IDC_3           127
#define IDC_4           128
#define IDC_5           129
#define IDC_6           130
#define IDC_7           131
#define IDC_8           132
#define IDC_9           133
#define IDC_A           134
#define IDC_B           135
#define IDC_C           136
#define IDC_D           137
#define IDC_E           138
#define IDC_F           139     // this is last control ID which must match the string table

#define IDC_INV         140
#define IDC_HYP         141

#define IDC_LASTCONTROL IDC_HYP

// Edit control ID's for the various controls
#define IDC_MEMTEXT      401
#define IDC_PARTEXT      402
#define IDC_DISPLAY      403

// statbox control IDs:
#define IDC_CD           404
#define IDC_CAD          405
#define ENDBOX           406
#define IDC_STATLIST     407
#define IDC_NUMTEXT      408
#define IDC_NTEXT        409
#define IDC_LOAD         410
#define IDC_FOCUS        411

#define IDC_SIZERCONTROL 1000

#define CW_USEDEFAULT_X  0x8000
#define IDC_STATIC       -1

// These are defs for the stringtable.  Values are made to be sequential for each section.
// All strings must be in sequential order from 0 to CSTRINGS
#define IDS_FIRSTKEY    0
#define IDS_DECIMAL     5
#define IDS_RADIX       60
#define IDS_HEX_MODES   64
#define IDS_DEC_MODES   68
#define IDS_ERRORS      71 
#define IDS_OUTOFMEM    77
#define IDS_TIMEOUT     78
#define IDS_HELPFILE    79 
#define IDS_NOPASTE     80 
#define IDS_STATMEM     81 
#define IDS_CHMHELPFILE 82 
#define IDS_CALC        83
#define IDS_NOMEM       84
#define CSTRINGS     IDS_NOMEM  // Count of Strings.  If you add strings update this value.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\input.c ===
/****************************Module*Header***********************************\
* Module Name: INPUT.C
*
* Module Descripton: Decimal floating point input
*
* Warnings:
*
* Created:
*
* Author:
\****************************************************************************/

#include "scicalc.h"
#include "unifunc.h"
#include "input.h"
#include "strsafe.h"

extern BOOL     gbRecord;
extern TCHAR    szDec[5];       // The decimal point we use
extern INT gcIntDigits;

TCHAR const szZeroInit[] = TEXT("0");

#define CH_BASE_10_EXP          TEXT('e')
#define CH_BASE_X_EXP           TEXT('^')

/****************************************************************************/
void CIO_vClearNSec( PCALCNUMSEC pcns ) {
    pcns->fEmpty = TRUE;
    pcns->fNeg = FALSE;
    // Reference input.h for string length for pcns->szVal
    StringCchCopy(pcns->szVal, MAX_STRLEN+1, szZeroInit);
    pcns->cchVal = lstrlen(pcns->szVal);
}

void CIO_vClear(PCALCINPUTOBJ pcio)
{
    CIO_vClearNSec( &(pcio->cnsNum) );
    CIO_vClearNSec( &(pcio->cnsExp) );
    pcio->fExp = FALSE;
    pcio->iDecPt = -1;
}

/****************************************************************************/

void CIO_vConvertToNumObj(PHNUMOBJ phnoNum, PCALCINPUTOBJ pcio)
{
    HNUMOBJ hnoValue;
    LPTSTR pszExp = NULL;

    // ZTerm the strings
    pcio->cnsNum.szVal[pcio->cnsNum.cchVal] = TEXT('\0');

    if (pcio->fExp ) {
        pszExp = pcio->cnsExp.szVal;
        pszExp[pcio->cnsExp.cchVal] = TEXT('\0');
    }

    hnoValue = NumObjMakeNumber( pcio->cnsNum.fNeg, pcio->cnsNum.szVal,  pcio->cnsExp.fNeg, pszExp );
    NumObjAssign( phnoNum, hnoValue );

    return;
}

/****************************************************************************/

void CIO_vConvertToString(LPTSTR *ppszOut, int* pcchszOut, PCALCINPUTOBJ pcio, int nRadix)
{
    //In theory both the base and exponent could be C_NUM_MAX_DIGITS long.
#define CCHMAXTEMP C_NUM_MAX_DIGITS*2+4
    TCHAR szTemp[CCHMAXTEMP];
    LPTSTR psz;
    int i;

    // ZTerm the strings
    pcio->cnsNum.szVal[pcio->cnsNum.cchVal] = TEXT('\0');

    if ( pcio->fExp )
        pcio->cnsExp.szVal[pcio->cnsExp.cchVal] = TEXT('\0');

    i = 0;
    if (pcio->cnsNum.fNeg)
        szTemp[i++] = TEXT('-');

    StringCchCopy(&szTemp[i], CCHMAXTEMP - i, pcio->cnsNum.szVal);
    i += pcio->cnsNum.cchVal;

    // Add a '.' if it is not already there
    if (pcio->iDecPt == -1 )
        szTemp[i++] = szDec[0];

    if (pcio->fExp) {
        szTemp[i++] = nRadix == 10 ? CH_BASE_10_EXP : CH_BASE_X_EXP;

        if (pcio->cnsExp.fNeg)
            szTemp[i++] = TEXT('-');
        else
            szTemp[i++] = TEXT('+');

        StringCchCopy(&szTemp[i], CCHMAXTEMP - i, pcio->cnsExp.szVal);
        i += pcio->cnsExp.cchVal;
    }

    int cchszOut = lstrlen( szTemp ) + 1;
    psz = (LPTSTR)NumObjAllocMem( cchszOut * sizeof(TCHAR) );
    if (psz) {
        if (*ppszOut != NULL) {
            NumObjFreeMem( *ppszOut );
        }
        *ppszOut = psz;
        *pcchszOut = cchszOut;
    }

    // Don't show '.' if in int math
    if (F_INTMATH() && szTemp[i-1] == szDec[0])
        i--;

    szTemp[i] = TEXT('\0');

    StringCchCopy(*ppszOut, *pcchszOut, szTemp);

    return;
}

/****************************************************************************/

BOOL CIO_bAddDigit(PCALCINPUTOBJ pcio, int iValue)
{
    PCALCNUMSEC pcns;
    TCHAR chDigit;
    int cchMaxDigits;

    // convert from an integer into a character
    chDigit = (iValue < 10)?(TEXT('0')+iValue):(TEXT('A')+iValue-10);

    if (pcio->fExp)
    {
        pcns = &(pcio->cnsExp);
        cchMaxDigits = C_EXP_MAX_DIGITS;
    }
    else
    {
        pcns = &(pcio->cnsNum);
        ASSERT( gcIntDigits <= C_NUM_MAX_DIGITS );
        cchMaxDigits = gcIntDigits;
    }

    // Ignore leading zeros
    if ( pcns->fEmpty && (iValue == 0) )
    {
        return TRUE;
    }

    if ( pcns->cchVal < cchMaxDigits )
    {
        if (pcns->fEmpty)
        {
            pcns->cchVal = 0;   // Clobber the default zero
            pcns->fEmpty = FALSE;
        }

        pcns->szVal[pcns->cchVal++] = chDigit;
        return TRUE;
    }

    // if we are in base 8 entering a mantica and we're on the last digit then
    // there are special cases where we can actually add one more digit.
    if ( nRadix == 8 && pcns->cchVal == cchMaxDigits && !pcio->fExp )
    {
        BOOL bAllowExtraDigit = FALSE;

        switch ( dwWordBitWidth % 3 )
        {
            case 1:
                // in 16bit word size, if the first digit is a 1 we can enter 6 digits
                if ( pcns->szVal[0] == TEXT('1') )
                    bAllowExtraDigit = TRUE;
                break;

            case 2:
                // in 8 or 32bit word size we get an extra digit if the first digit is 3 or less
                if ( pcns->szVal[0] <= TEXT('3') )
                    bAllowExtraDigit = TRUE;
                break;
        }

        if ( bAllowExtraDigit )
        {
            pcns->szVal[pcns->cchVal++] = chDigit;
            return TRUE;
        }
    }

    return FALSE;
}

/****************************************************************************/

void CIO_vToggleSign(PCALCINPUTOBJ pcio)
{

    // Zero is always positive
    if (pcio->cnsNum.fEmpty)
    {
        pcio->cnsNum.fNeg = FALSE;
        pcio->cnsExp.fNeg = FALSE;
    }
    else if (pcio->fExp)
    {
        pcio->cnsExp.fNeg = !pcio->cnsExp.fNeg;
    }
    else
    {
        pcio->cnsNum.fNeg = !pcio->cnsNum.fNeg;
    }
}

/****************************************************************************/

BOOL CIO_bAddDecimalPt(PCALCINPUTOBJ pcio)
{
    ASSERT(gbRecord == TRUE);

    if (pcio->iDecPt != -1)                      // Already have a decimal pt
        return FALSE;

    if (pcio->fExp)                             // Entering exponent
        return FALSE;

    pcio->cnsNum.fEmpty = FALSE;                // Zeros become significant

    pcio->iDecPt = pcio->cnsNum.cchVal++;
    pcio->cnsNum.szVal[pcio->iDecPt] = szDec[0];

    return TRUE;
}

/****************************************************************************/

BOOL CIO_bExponent(PCALCINPUTOBJ pcio)
{
    ASSERT(gbRecord == TRUE);

    // For compatability, add a trailing dec pnt to base num if it doesn't have one
    CIO_bAddDecimalPt( pcio );

    if (pcio->fExp)                             // Already entering exponent
        return FALSE;

    pcio->fExp = TRUE;                          // Entering exponent

    return TRUE;
}

/****************************************************************************/

BOOL CIO_bBackspace(PCALCINPUTOBJ pcio)
{
    ASSERT(gbRecord == TRUE);

    if (pcio->fExp)
    {
        if ( !(pcio->cnsExp.fEmpty) )
        {
            pcio->cnsExp.cchVal--;

            if (pcio->cnsExp.cchVal == 0)
            {
                CIO_vClearNSec( &(pcio->cnsExp) );
            }
        }
        else
        {
            pcio->fExp = FALSE;
        }
    }
    else
    {
        if ( !(pcio->cnsNum.fEmpty) )
        {
            pcio->cnsNum.cchVal--;
        }

        if ( pcio->cnsNum.cchVal <= pcio->iDecPt )
            //Backed up over decimal point
            pcio->iDecPt = -1;

        if ((pcio->cnsNum.cchVal == 0) || ((pcio->cnsNum.cchVal == 1) && (pcio->cnsNum.szVal[0] == TEXT('0'))))
            CIO_vClearNSec( &(pcio->cnsNum) );
    }

    return TRUE;
}

/****************************************************************************/

void CIO_vUpdateDecimalSymbol(PCALCINPUTOBJ pcio, TCHAR chLastDP)
{
    int iDP;

    ASSERT(pcio);

    iDP = pcio->iDecPt;                            // Find the DP index

    if (iDP == -1)
        return;

    ASSERT(pcio->cnsNum.szVal[iDP] == chLastDP);

    pcio->cnsNum.szVal[iDP] = szDec[0];                   // Change to new decimal pt
}

/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\scidisp.h ===
UINT DigitGroupingStringToGroupingNum(PTSTR szGrouping);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\scicomm.c ===
/****************************Module*Header***********************************\
* Module Name: SCICOMM.C
*
* Module Descripton:
*
* Warnings:
*
* Created:
*
* Author:
\****************************************************************************/

#include "scicalc.h"
#include "calchelp.h"
#include "unifunc.h"
#include "input.h"
#include "strsafe.h"

extern HWND        hStatBox;
extern HNUMOBJ     ghnoNum, ghnoLastNum, ghnoMem;
extern HNUMOBJ     ghnoParNum[25], ghnoPrecNum[25];

extern eNUMOBJ_FMT nFE;
extern INT         nTempCom, nParNum, nPrecNum, gcIntDigits,
                   nOpCode, nOp[25], nPrecOp[25];
extern BOOL        bError;
extern TCHAR       szBlank[6];
extern TCHAR      *rgpsz[CSTRINGS];


int             nLastCom;   // Last command entered.
CALCINPUTOBJ    gcio;       // Global calc input object for decimal strings
BOOL            gbRecord;   // Global mode: recording or displaying


/* Puts up the wait cursor if the calc will take a long time */
HCURSOR ghcurOld = NULL;

BOOL SetWaitCursor( BOOL fOn ) {
    if (fOn && ghcurOld == NULL) {
        ghcurOld = SetCursor( LoadCursor(NULL, IDC_WAIT) );
    } else if (!fOn && ghcurOld != NULL) {
        SetCursor( ghcurOld );
        ghcurOld = NULL;
    }

    return (fOn && ghcurOld != NULL);
}

/* Process all keyclicks whether by mouse or accelerator.                 */
VOID NEAR RealProcessCommands(WPARAM wParam);

VOID NEAR ProcessCommands(WPARAM wParam)
{
    if (wParam != IDM_ABOUT)
    {
        TimeCalc(TRUE);
    }

    try
    {
        RealProcessCommands( wParam );
    }
    catch( ... )
    {
        // note:  it should be impossible for a throw to reach this level, this is put here as an
        // emergency backup only.  Throws are normally caught at the boundry between calc and ratpak.
        ASSERT( 0 );
        MessageBox( g_hwndDlg, TEXT("An unknown error has occured."), TEXT("Error"), MB_OK );
    }

    if (wParam != IDM_ABOUT)
    {
        TimeCalc(FALSE);
    }
}

VOID NEAR RealProcessCommands(WPARAM wParam)
{
    static BOOL    bNoPrevEqu=TRUE, /* Flag for previous equals.          */
                   bChangeOp=FALSE; /* Flag for changing operation.       */
    INT            nx, ni;
    TCHAR          szJunk[50], szTemp[50];
    static BYTE    rgbPrec[24]={      0,0,  IDC_OR,0, IDC_XOR,0,  IDC_AND,1, 
                                IDC_ADD,2, IDC_SUB,2,    RSHF,3, IDC_LSHF,3,
                                IDC_MOD,3, IDC_DIV,3, IDC_MUL,3,  IDC_PWR,4};

    // Make sure we're only getting commands we understand.

    ASSERT( xwParam(IDC_FIRSTCONTROL, IDC_LASTCONTROL) || // Is it a button?
            xwParam(IDM_FIRSTMENU,    IDM_LASTMENU) );    // or a menu command?

    // Save the last command.  Some commands are not saved in this manor, these
    // commands are:
    // Inv, Hyp, Deg, Rad, Grad, Stat, FE, MClear, Back, and Exp.  The excluded
    // commands are not
    // really mathematical operations, rather they are GUI mode settings.

    if ( !xwParam(IDC_INV, IDC_HYP)    && !xwParam(IDM_HEX, IDM_BIN)  &&
         !xwParam(IDM_QWORD, IDM_BYTE) && !xwParam(IDM_DEG, IDM_GRAD) &&
         wParam!=IDC_STAT && wParam!=IDC_FE &&
         wParam!=IDC_MCLEAR && wParam!=IDC_BACK && wParam!=IDC_EXP)
    {
        nLastCom=nTempCom;
        nTempCom=(INT)wParam;
    }

    // If error and not a clear key or help key, BEEP.

    if (bError && (wParam !=IDC_CLEAR) && (wParam !=IDC_CENTR) &&
        (wParam != IDM_HELPTOPICS))
    {
        MessageBeep(0);
        return;
    }

    // Toggle Record/Display mode if appropriate.

    if (gbRecord)
    {
        if (xwParam(IDC_AND, IDC_MPLUS)        ||
            xwParam(IDC_AVE, IDC_CLOSEP)       ||
            xwParam(IDC_INV, IDC_HYP)          ||
            xwParam(IDM_HEX, IDM_BIN)          ||
            xwParam(IDM_QWORD, IDM_BYTE)       ||
            xwParam(IDM_DEG, IDM_GRAD)         ||
            wParam == IDM_PASTE)
        {
            gbRecord = FALSE;
            SetWaitCursor(TRUE);
            CIO_vConvertToNumObj(&ghnoNum, &gcio);
            DisplayNum();   // Causes 3.000 to shrink to 3. on first op.
            SetWaitCursor(FALSE);
        }
    }
    else
    {
        if ( xwParam(IDC_0, IDC_F) || wParam == IDC_PNT)
        {
            gbRecord = TRUE;
            CIO_vClear(&gcio);
        }
    }

    // Interpret digit keys.

    if (xwParam(IDC_0, IDC_F))
    {
        int iValue = (int)(wParam-IDC_0);

        // this is redundant, illegal keys are disabled
        if (iValue >= nRadix)
        {
            //ASSERT( 0 );
            MessageBeep(0);
            return;
        }


        if (!CIO_bAddDigit(&gcio, iValue))
        {
            MessageBeep(0);
            return;
        }

        DisplayNum();
        return;
    }


    // STATISTICAL FUNCTIONS:
    if (xwParam(IDC_AVE,IDC_DATA))
    {
        /* Do statistics functions on data in fpStatNum array.        */
        if (hStatBox)
        {
            DisplayNum();       // Make sure gpszNum has the correct string
            try
            {
                StatFunctions (wParam);
            }
            catch ( ... )
            {
                ASSERT( 0 );    // the only thing stat box should be able to throw is out of memory
                        // which in previous versions of calc caused a program crash
            }
            if (!bError)
                DisplayNum ();
        }
        else
            /* Beep if the stat box is not active.                    */
            MessageBeep(0);

        /* Reset the inverse flag since some functions use it.        */
        SetBox (IDC_INV, bInv=FALSE);
        return;
    }


    // BINARY OPERATORS:
    if (xwParam(IDC_AND,IDC_PWR))
    {
        if (bInv && wParam==IDC_LSHF)
        {
            SetBox (IDC_INV, bInv=FALSE);
            wParam=RSHF;
        }

        /* Change the operation if last input was operation.          */
        if (nLastCom >=IDC_AND && nLastCom <=IDC_PWR)
        {
            nOpCode=(INT)wParam;
            return;
        }

        /* bChangeOp is true if there was an operation done and the   */
        /* current ghnoNum is the result of that operation.  This is so */
        /* entering 3+4+5= gives 7 after the first + and 12 after the */
        /* the =.  The rest of this stuff attempts to do precedence in*/
        /* Scientific mode.                                           */
        if (bChangeOp)
        {
        DoPrecedenceCheckAgain:

            nx=0;
            while (wParam!=rgbPrec[nx*2] && nx <12)
                nx++;

            ni=0;
            while (nOpCode!=rgbPrec[ni*2] && ni <12)
                ni++;

            if (nx==12) nx=0;
            if (ni==12) ni=0;

            if (rgbPrec[nx*2+1] > rgbPrec[ni*2+1] && nCalc==0)
            {
                if (nPrecNum <25)
                {
                    NumObjAssign( &ghnoPrecNum[nPrecNum], ghnoLastNum );
                    nPrecOp[nPrecNum]=nOpCode;
                }
                else
                {
                    nPrecNum=24;
                    MessageBeep(0);
                }
                nPrecNum++;
            }
            else
            {
                /* do the last operation and then if the precedence array is not
                 * empty or the top is not the '(' demarcator then pop the top
                 * of the array and recheck precedence against the new operator
                 */

                SetWaitCursor(TRUE);

                DoOperation(nOpCode, &ghnoNum, ghnoLastNum);

                SetWaitCursor(FALSE);

                if ((nPrecNum !=0) && (nPrecOp[nPrecNum-1]))
                {
                    nPrecNum--;
                    nOpCode=nPrecOp[nPrecNum] ;
                    if (NumObjOK( ghnoPrecNum[nPrecNum] ))
                        NumObjAssign(&ghnoLastNum , ghnoPrecNum[nPrecNum]);
                    else
                        NumObjAssign(&ghnoLastNum, HNO_ZERO);

                    goto DoPrecedenceCheckAgain ;
                }

                if (!bError)
                    DisplayNum ();
            }
        }

        NumObjAssign(&ghnoLastNum, ghnoNum);
        NumObjAssign(&ghnoNum, HNO_ZERO);
        nOpCode=(INT)wParam;
        bNoPrevEqu=bChangeOp=TRUE;
        return;
    }

    // UNARY OPERATORS:
    if (xwParam(IDC_CHOP,IDC_PERCENT))
    {
        /* Functions are unary operations.                            */

        /* If the last thing done was an operator, ghnoNum was cleared. */
        /* In that case we better use the number before the operator  */
        /* was entered, otherwise, things like 5+ 1/x give Divide By  */
        /* zero.  This way 5+=gives 10 like most calculators do.      */
        if (nLastCom >= IDC_AND && nLastCom <= IDC_PWR)
            NumObjAssign( &ghnoNum, ghnoLastNum );

        SetWaitCursor(TRUE);
        SciCalcFunctions ( &ghnoNum, (DWORD)wParam);
        SetWaitCursor(FALSE);

        if (bError)
            return;

        /* Display the result, reset flags, and reset indicators.     */
        DisplayNum ();

        /* reset the bInv and bHyp flags and indicators if they are set
            and have been used */

        if (bInv &&
            (wParam == IDC_CHOP || wParam == IDC_SIN || wParam == IDC_COS ||
             wParam == IDC_TAN  || wParam == IDC_SQR || wParam == IDC_CUB ||
             wParam == IDC_LOG  || wParam == IDC_LN  || wParam == IDC_DMS))
        {
            bInv=FALSE;
            SetBox (IDC_INV, FALSE);
        }

        if (bHyp &&
            (wParam == IDC_SIN || wParam == IDC_COS || wParam == IDC_TAN))
        {
            bHyp = FALSE;
            SetBox (IDC_HYP, FALSE);
        }
        bNoPrevEqu=TRUE;
        return;
    }

    // BASE CHANGES:
    if (xwParam(IDM_HEX, IDM_BIN))
    {
        // Change radix and update display.
        if (nCalc==1)
        {
            wParam=IDM_DEC;
        }

        SetRadix((DWORD)wParam);
        return;
    }

    SetWaitCursor(TRUE);

    /* Now branch off to do other commands and functions.                 */
    switch(wParam)
    {
        case IDM_COPY:
        case IDM_PASTE:
        case IDM_ABOUT:
        case IDM_SC:
        case IDM_SSC:
        case IDM_USE_SEPARATOR:
        case IDM_HELPTOPICS:
            // Jump to menu command handler in scimenu.c.
            MenuFunctions((DWORD)wParam);
            DisplayNum();
            break;

        case IDC_CLEAR: /* Total clear.                                       */
            NumObjAssign( &ghnoLastNum, HNO_ZERO );
            nPrecNum=nTempCom=nLastCom=nOpCode=nParNum=bChangeOp=FALSE;
            nFE = FMT_FLOAT;    // back to the default number format
            bNoPrevEqu=TRUE;

            /* clear the paranthesis status box indicator, this will not be
                cleared for CENTR */

            SetDlgItemText(g_hwndDlg, IDC_PARTEXT, szBlank);

            /* fall through */

        case IDC_CENTR: /* Clear only temporary values.                       */
            NumObjAssign( &ghnoNum, HNO_ZERO );

            if (!nCalc)
            {
                // Clear the INV, HYP indicators & leave (=xx indicator active

                SetBox (IDC_INV, bInv=FALSE);
                SetBox (IDC_HYP, bHyp=FALSE);
            }

            bError=FALSE;
            CIO_vClear(&gcio);
            gbRecord = TRUE;
            DisplayNum ();
            break;

        case IDC_STAT: /* Shift focus to Statistix Box if it's active.       */
            if (hStatBox)
                SetFocus(hStatBox);
            else
                SetStat (TRUE);
            break;

        case IDC_BACK:
            // Divide number by the current radix and truncate.
            // Only allow backspace if we're recording.
            if (gbRecord)
            {
                if (!CIO_bBackspace(&gcio))
                    MessageBeep(0);

                DisplayNum();
            }
            else
                MessageBeep(0);
            break;

        /* EQU enables the user to press it multiple times after and      */
        /* operation to enable repeats of the last operation.  I don't    */
        /* know if I can explain what the [censored] I did here...        */
        case IDC_EQU:
            do {
                // NOTE: the number pointed to by hnoHold won't get freed until process termination.
                static HNUMOBJ  hnoHold;

                /* Last thing keyed in was an operator.  Lets do the op on*/
                /* a duplicate of the last entry.                         */
                if ((nLastCom >= IDC_AND) && (nLastCom <= IDC_PWR))
                    NumObjAssign( &ghnoNum, ghnoLastNum );

                if (nOpCode) /* Is there a valid operation around?        */
                {
                    /* If this is the first EQU in a string, set hnoHold=ghnoNum */
                    /* Otherwise let ghnoNum=hnoTemp.  This keeps ghnoNum constant */
                    /* through all EQUs in a row.                         */
                    if (bNoPrevEqu)
                        NumObjAssign(&hnoHold, ghnoNum);
                    else
                        NumObjAssign(&ghnoNum, hnoHold);

                    /* Do the current or last operation.                  */
                    DoOperation (nOpCode, &ghnoNum, ghnoLastNum);
                    NumObjAssign(&ghnoLastNum, ghnoNum );

                    /* Check for errors.  If this wasn't done, DisplayNum */
                    /* would immediately overwrite any error message.     */
                    if (!bError)
                        DisplayNum ();

                    /* No longer the first EQU.                           */
                    bNoPrevEqu=FALSE;
                }
                else if (!bError)
                    DisplayNum();

                if (nPrecNum==0 || nCalc==1)
                    break;

                nOpCode=nPrecOp[--nPrecNum];
                if (NumObjOK( ghnoPrecNum[nPrecNum] ))
                    NumObjAssign(&ghnoLastNum , ghnoPrecNum[nPrecNum]);
                else
                    NumObjAssign(&ghnoLastNum, HNO_ZERO);
                bNoPrevEqu=TRUE;
            } while (nPrecNum >= 0);

            bChangeOp=FALSE;
            break;


        case IDC_OPENP:
        case IDC_CLOSEP:
            nx=0;
            if (wParam==IDC_OPENP)
                nx=1;

            // -IF- the Paren holding array is full and we try to add a paren
            // -OR- the paren holding array is empty and we try to remove a
            //      paren
            // -OR- the the precidence holding array is full
            if ((nParNum >= 25 && nx) || (!nParNum && !nx)
                || ( (nPrecNum >= 25 && nPrecOp[nPrecNum-1]!=0) ) )
            {
                MessageBeep(0);
                break;
            }

            if (nx)
            {
                /* Open level of parentheses, save number and operation.   */
                NumObjAssign( &ghnoParNum[nParNum], ghnoLastNum);
                nOp[nParNum++]=nOpCode;

                /* save a special marker on the precedence array */
                nPrecOp[nPrecNum++]=0 ;

                NumObjAssign( &ghnoLastNum, HNO_ZERO );
                nTempCom=0;
                nOpCode=IDC_ADD;
            }
            else
            {
                /* Get the operation and number and return result.         */
                DoOperation (nOpCode, &ghnoNum, ghnoLastNum);

                /* now process the precedence stack till we get to an
                    opcode which is zero. */

                while (nOpCode = nPrecOp[--nPrecNum])
                {
                    if (NumObjOK( ghnoPrecNum[nPrecNum] ))
                        NumObjAssign(&ghnoLastNum , ghnoPrecNum[nPrecNum]);
                    else
                        NumObjAssign(&ghnoLastNum, HNO_ZERO);

                    DoOperation (nOpCode, &ghnoNum, ghnoLastNum);
                }

                /* now get back the operation and opcode at the begining
                    of this paranthesis pair */

                nParNum -= 1;
                NumObjAssign( &ghnoLastNum, ghnoParNum[nParNum] );
                nOpCode=nOp[nParNum];

                /* if nOpCode is a valid operator then set bChangeOp to
                    be true else set it false */

                if  (nOpCode)
                    bChangeOp=TRUE;
                else
                    bChangeOp=FALSE ;
            }

            /* Set the "(=xx" indicator.                     */
            StringCchCopy(szJunk, ARRAYSIZE(szJunk), TEXT("(="));
            StringCchCat(szJunk, ARRAYSIZE(szJunk), UToDecT(nParNum, szTemp));
            SetDlgItemText(g_hwndDlg, IDC_PARTEXT,
                           (nParNum) ? (szJunk) : (szBlank));

            if (bError)
                break;

            if (nx)
            {
                /* Build a display string of nParNum "("'s.  */
                for (nx=0; nx < nParNum; nx++)
                    szJunk[nx]=TEXT('(');

                szJunk[nx]=0; /* Null-terminate.  */
                SetDisplayText(g_hwndDlg, szJunk);
                bChangeOp=FALSE;
            }
            else
                DisplayNum ();
            break;

        case IDM_QWORD:
        case IDM_DWORD:
        case IDM_WORD:
        case IDM_BYTE:
        case IDM_DEG:
        case IDM_RAD:
        case IDM_GRAD:

            if (!F_INTMATH())
            {
                // in decimal mode, these buttons simply set a flag which is
                // passed to the ratpak to handle angle conversions

                if (xwParam(IDM_DEG, IDM_GRAD))
                {
                    nDecMode = (ANGLE_TYPE)(wParam - IDM_DEG);

                    CheckMenuRadioItem(GetSubMenu(GetMenu(g_hwndDlg), 1),
                                       IDM_DEG, IDM_GRAD, IDM_DEG+nDecMode,
                                       MF_BYCOMMAND);
                
                    CheckRadioButton(g_hwndDlg, IDC_DEG, IDC_GRAD, 
                                     IDC_DEG+nDecMode);
                }
            }
            else
            {
                if (xwParam(IDM_DEG, IDM_GRAD))
                {
                    // if in hex mode, but we got a decimal key press this
                    // likely is the accelorator.  map this to the correct key

                    wParam=IDM_DWORD+(wParam-IDM_DEG);
                }
                
                if ( gbRecord )
                {
                    CIO_vConvertToNumObj(&ghnoNum, &gcio);
                    gbRecord = FALSE;
                }

                // Compat. mode BaseX: Qword, Dword, Word, Byte
                nHexMode = (int)(wParam - IDM_QWORD);
                switch (nHexMode)
                {
                    case 0: dwWordBitWidth = 64; break;
                    case 1: dwWordBitWidth = 32; break;
                    case 2: dwWordBitWidth = 16; break;
                    case 3: dwWordBitWidth =  8; break;
                    default:
                        ASSERT( 0 );    // Invalid Word Size
                        break;
                }

                // different wordsize means the new wordsize determines
                // the precision

                BaseOrPrecisionChanged();

                CheckMenuRadioItem(GetSubMenu(GetMenu(g_hwndDlg), 1),
                                   IDM_QWORD, IDM_BYTE, IDM_QWORD+nHexMode,
                                   MF_BYCOMMAND);

                CheckRadioButton(g_hwndDlg, IDC_QWORD, IDC_BYTE, 
                                 IDC_QWORD+nHexMode);
               
            }


            // REARCHITECT: the call to display number is what actually does the
            // chop. it would make more sense to do the chop here when the
            // wordsize changes. the chop must be done when a different
            // wordsize is selected AND when the base is changed to non-decimal
            DisplayNum();
            break;

        case IDC_SIGN:
            // Change the sign.
            if (gbRecord)
                CIO_vToggleSign(&gcio);
            else {
                NumObjNegate( &ghnoNum );
            }

            DisplayNum();
            break;

        case IDC_RECALL:
            /* Recall immediate memory value.                             */
            NumObjAssign( &ghnoNum, ghnoMem );

            DisplayNum ();
            break;

        case IDC_MPLUS:
            /* MPLUS adds ghnoNum to immediate memory and kills the "mem"   */
            /* indicator if the result is zero.                           */
            addrat( &ghnoMem, ghnoNum);
            SetDlgItemText(g_hwndDlg,IDC_MEMTEXT,
                           !NumObjIsZero(ghnoMem) ? (TEXT(" M")):(szBlank));
            break;

        case IDC_STORE:
        case IDC_MCLEAR:
            if (wParam==IDC_STORE)
            {
                NumObjAssign( &ghnoMem, ghnoNum );
            }
            else
            {
                NumObjAssign( &ghnoMem, HNO_ZERO );
            }
            SetDlgItemText(g_hwndDlg,IDC_MEMTEXT,
                           !NumObjIsZero(ghnoMem) ? (TEXT(" M")):(szBlank));
            break;

        case IDC_PI:
            if (!F_INTMATH())
            {
                /* Return PI if bInv==FALSE, or 2PI if bInv==TRUE.          */
                if (bInv)
                    NumObjAssign( &ghnoNum, HNO_2PI );
                else
                    NumObjAssign( &ghnoNum, HNO_PI );

                DisplayNum();
                SetBox(IDC_INV, bInv=FALSE);
            }
            else
                MessageBeep(0);
            break;

        case IDC_FE:
            // Toggle exponential notation display.
            nFE = NUMOBJ_FMT(!(int)nFE);
            DisplayNum();
            break;

        case IDC_EXP:
            if (gbRecord && !F_INTMATH())
                if (CIO_bExponent(&gcio))
                {
                    DisplayNum();
                    break;
                }
            MessageBeep(0);
            break;

        case IDC_PNT:
            if (gbRecord && !F_INTMATH()) {
                if (CIO_bAddDecimalPt(&gcio)) {

                    DisplayNum();
                    break;
                }
            }
            MessageBeep(0);
            break;

        case IDC_INV:
            SetBox((int)wParam, bInv=!bInv);
            break;

        case IDC_HYP:
            SetBox((int)wParam, bHyp=!bHyp);
            break;
    }

    SetWaitCursor(FALSE);
}


// change the display area from a static text to an editbox, which has the focus can make
// Magnifer (Accessibility tool) work
BOOL SetDisplayText(HWND hDlg, LPCTSTR szText)
{
    HWND    hDispEdit = GetDlgItem(hDlg, IDC_DISPLAY);
    int     nLen = lstrlen(szText);

    SetWindowText(hDispEdit, szText);
    SetFocus(hDispEdit);
    
    // make sure the number just typed is shown at the center of Magnifier
    SendMessage(hDispEdit, EM_SETSEL, nLen, nLen);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\scifunc.c ===
/**************************************************************************/
/*** SCICALC Scientific Calculator for Windows 3.00.12                  ***/
/*** By Kraig Brockschmidt, Microsoft Co-op, Contractor, 1988-1989      ***/
/*** (c)1989 Microsoft Corporation.  All Rights Reserved.               ***/
/***                                                                    ***/
/*** scifunc.c                                                          ***/
/***                                                                    ***/
/*** Functions contained:                                               ***/
/***    SciCalcFunctions--do sin, cos, tan, com, log, ln, rec, fac, etc.***/
/***    DisplayError--Error display driver.                             ***/
/***                                                                    ***/
/*** Functions called:                                                  ***/
/***    SciCalcFunctions call DisplayError.                             ***/
/***                                                                    ***/
/*** Last modification. Fri  05-Jan-1990.                               ***/
/***                                                                    ***/
/*** -by- Amit Chatterjee. [amitc]  05-Jan-1990.                                                      ***/
/*** Calc did not have a floating point exception signal handler. This  ***/
/*** would cause CALC to be forced to exit on a FP exception as that's  ***/
/*** the default.                                                                                                                                                  ***/
/*** The signal handler is defined in here, in SCIMAIN.C we hook the    ***/
/*** the signal.                                                                                                                                    ***/
/***                                                                    ***/
/*** -by- Amit Chatterjee. [amitc] 14-Dec-1989                                                   ***/
/*** The REC function will not depend on the bInv flag. It used to ret  ***/
/*** a random number when the bInv flag was set.                                                 ***/
/***                                                                    ***/
/*** -by- Amit Chatterjee.      [amitc] 08-Dec-1989                                                   ***/
/*** Did a minor bug fix. The EnableToggles routine now sets the focus  ***/
/*** back to the main window before disabling HEX,DEC etc.. Without this***/
/*** the window with the focus would get disable and cause MOVE to not  ***/
/*** work right.                                                                                                                ***/
/***                                                                    ***/
/**************************************************************************/

#include "scicalc.h"
//#include "float.h"

extern HNUMOBJ     ghnoLastNum;
extern BOOL        bError;
extern TCHAR       *rgpsz[CSTRINGS];
INT                gnPendingError ;

/* Routines for more complex mathematical functions/error checking.       */

VOID  APIENTRY SciCalcFunctions (PHNUMOBJ phnoNum, DWORD wOp)
{
    try
    {
        switch (wOp)
        {
            case IDC_CHOP:
                if (bInv)
                {
                    // fractional portion
                    fracrat( phnoNum );
                }
                else
                {
                    // integer portion
                    intrat( phnoNum );
                }
                return;

            /* Return complement.                                             */
            case IDC_COM:
                NumObjNot( phnoNum );
                return;


            case IDC_PERCENT:
                {
                    DECLARE_HNUMOBJ( hno );
                    DECLARE_HNUMOBJ( hno100 );

                    try
                    {
                        NumObjAssign( &hno, ghnoLastNum );
                        NumObjSetIntValue( &hno100, 100 );

                        divrat( &hno, hno100 );

                        NumObjDestroy( &hno100 );

                        mulrat( phnoNum, hno );

                        NumObjDestroy( &hno );
                    }
                    catch ( DWORD nErrCode )
                    {
                        if ( hno != NULL )
                            NumObjDestroy( &hno );
                        if ( hno100 != NULL ) 
                            NumObjDestroy( &hno100 );
                        throw nErrCode;
                    }
                    return;
                }

            case IDC_SIN: /* Sine; normal, hyperbolic, arc, and archyperbolic     */
                if (F_INTMATH())
                {
                    MessageBeep(0);
                    return;
                }

                if(bInv)
                {
                    if (bHyp)
                    {
                        asinhrat( phnoNum );
                    }
                    else
                    {
                        asinanglerat( phnoNum, nDecMode );
                    }
                }
                else
                {
                    if (bHyp)
                    {
                        // hyperbolic sine
                        sinhrat( phnoNum );
                    }
                    else
                    {
                        NumObjSin( phnoNum );
                    }
                }
                return;

            case IDC_COS: /* Cosine, follows convention of sine function.         */
                if (F_INTMATH())
                {
                    MessageBeep(0);
                    return;
                }

                if(bInv)
                {
                    if (bHyp)
                    {
                        acoshrat( phnoNum );
                    }
                    else
                    {
                        acosanglerat( phnoNum, nDecMode );
                    }
                }
                else
                {
                    if (bHyp)
                        coshrat( phnoNum );
                    else
                    {
                        // cos()
                        NumObjCos( phnoNum );
                    }
                }
                return;

            case IDC_TAN: /* Same as sine and cosine.                             */
                if (F_INTMATH())
                {
                    MessageBeep(0);
                    return;
                }

                if(bInv)
                {
                    if (bHyp)
                    {
                        atanhrat( phnoNum );
                    }
                    else
                    {
                        atananglerat( phnoNum, nDecMode );
                    }
                }
                else
                {
                    if (bHyp)
                        tanhrat( phnoNum );
                    else
                    {
                        // Get the answer
                        NumObjTan( phnoNum );
                    }
                }
                return;

            case IDC_REC: /* Reciprocal.                                          */
                NumObjInvert( phnoNum );
                return;

            case IDC_SQR: /* Square and square root.                              */
            case IDC_SQRT:
                if(bInv || nCalc)
                {
                    rootrat( phnoNum, HNO_TWO );
                }
                else
                {
                    ratpowlong( phnoNum, 2 );
                }
                return;

            case IDC_CUB: /* Cubing and cube root functions.                      */
                if(bInv) {
                    DECLARE_HNUMOBJ( hno );

                    // REVIEW: if constants like 3 are going to be used repeatedly, it will be
                    // much quicker to define them once and then keep around the definition.
                    try
                    {
                        NumObjAssign( &hno, HNO_ONE );
                        addrat( &hno, HNO_TWO );

                        rootrat( phnoNum, hno );

                        NumObjDestroy( &hno );
                    }
                    catch ( DWORD nErrCode )
                    {
                        if ( hno != NULL )
                            NumObjDestroy( &hno );

                        throw nErrCode;
                    }
                }
                else {
                    /* Cube it, you dig?       */
                    ratpowlong( phnoNum, 3 );
                }
                return;

            case IDC_LOG: /* Functions for common and natural log.                */
            case IDC_LN:
                if(bInv)
                {
                    /* Check maximum for exponentiation for 10 and e.       */
                    if (wOp==IDC_LOG) /* Do exponentiation.                       */
                        NumObjAntiLog10( phnoNum ); // 10.
                    else
                        exprat( phnoNum );  // e.
                }
                else
                {
                    // ratpak checks for valid range and throws error code if needed
                    if (wOp==IDC_LOG)
                        log10rat( phnoNum );
                    else
                        lograt( phnoNum );

                    // REVIEW: Is conversion of epsilon still needed?
                    NumObjCvtEpsilonToZero( phnoNum );
                }
                return;

            case IDC_FAC: /* Calculate factorial.  Inverse is ineffective.        */
                factrat( phnoNum );
                return;

            case IDC_DMS:
                {
                    if (F_INTMATH())
                    {
                        MessageBeep(0);
                    } 
                    else 
                    {
                        DECLARE_HNUMOBJ(hnoMin);
                        DECLARE_HNUMOBJ(hnoSec);
                        DECLARE_HNUMOBJ(hnoShft);

                        try
                        {
                            NumObjSetIntValue( &hnoShft, bInv ? 100 : 60 );

                            NumObjAssign( &hnoMin, *phnoNum );
                            intrat( phnoNum );

                            subrat( &hnoMin, *phnoNum );
                            mulrat( &hnoMin, hnoShft );
                            NumObjAssign( &hnoSec, hnoMin );
                            intrat( &hnoMin );

                            subrat( &hnoSec, hnoMin );
                            mulrat( &hnoSec, hnoShft );

                            //
                            // *phnoNum == degrees, hnoMin == minutes, hnoSec == seconds
                            //

                            NumObjSetIntValue( &hnoShft, bInv ? 60 : 100 );
                            divrat( &hnoSec, hnoShft );
                            addrat( &hnoMin, hnoSec );

                            divrat( &hnoMin, hnoShft );
                            addrat( phnoNum, hnoMin );

                            NumObjDestroy( &hnoShft );
                            NumObjDestroy( &hnoMin );
                            NumObjDestroy( &hnoSec );
                        }
                        catch ( DWORD nErrCode )
                        {
                            if ( hnoShft != NULL )
                                NumObjDestroy( &hnoShft );
                            if ( hnoMin != NULL )
                                NumObjDestroy( &hnoMin );
                            if ( hnoSec != NULL )
                                NumObjDestroy( &hnoSec );
                            throw nErrCode;
                        }
                    }
                    return;
                }
        }   // end switch( nOp )
    }
    catch( DWORD nErrCode )
    {
        DisplayError( nErrCode );
    }

    return;
}



/* Routine to display error messages and set bError flag.  Errors are     */
/* called with DisplayError (n), where n is a INT   between 0 and 5.      */

VOID  APIENTRY DisplayError (INT   nError)
{
    SetDisplayText(g_hwndDlg, rgpsz[IDS_ERRORS+nError]);
    bError=TRUE; /* Set error flag.  Only cleared with CLEAR or CENTR.    */
    
    /* save the pending error */
    gnPendingError = nError ;
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\scidisp.c ===
/****************************Module*Header***********************************\
* Module Name: SCIDISP.C
*
* Module Descripton:
*
* Warnings:
*
* Created:
*
* Author:
\****************************************************************************/

#include "scicalc.h"
#include "unifunc.h"
#include "input.h"
#include <tchar.h>
#include "strsafe.h"
#include <stdlib.h>


extern HNUMOBJ      ghnoNum;
extern eNUMOBJ_FMT  nFE;
extern TCHAR        szDec[5];
extern TCHAR        gszSep[5];
extern UINT         gnDecGrouping;
extern LPTSTR       gpszNum;
extern int          gcchNum;
extern BOOL         gbRecord;
extern BOOL         gbUseSep;
extern CALCINPUTOBJ gcio;


/****************************************************************************\
* void DisplayNum(void)
*
* Convert ghnoNum to a string in the current radix.
*
* Updates the following globals:
*   ghnoNum, gpszNum
\****************************************************************************/
//
// State of calc last time DisplayNum was called
//
typedef struct {
    HNUMOBJ     hnoNum;
    LONG        nPrecision;
    LONG        nRadix;
    INT         nFE;
    INT         nCalc;
    INT         nHexMode;
    BOOL        fIntMath;
    BOOL        bRecord;
    BOOL        bUseSep;
} LASTDISP;

LASTDISP gldPrevious = { NULL, -1, -1, -1, -1, -1, FALSE, FALSE, FALSE };

#define InvalidLastDisp( pglp ) ((pglp)->hnoNum == NULL )


void GroupDigits(TCHAR sep, 
                 UINT  nGrouping, 
                 BOOL  bIsNumNegative,
                 PTSTR szDisplay, 
                 PTSTR szSepDisplay,
                 int   cchSepDisplay);


void DisplayNum(void)
{
    SetWaitCursor( TRUE );

    //
    // Only change the display if
    //  we are in record mode                               -OR-
    //  this is the first time DisplayNum has been called,  -OR-
    //  something important has changed since the last time DisplayNum was
    //  called.
    //
    if ( gbRecord || InvalidLastDisp( &gldPrevious ) ||
            !NumObjIsEq( gldPrevious.hnoNum,      ghnoNum     ) ||
            gldPrevious.nPrecision  != nPrecision   ||
            gldPrevious.nRadix      != nRadix       ||
            gldPrevious.nFE         != (int)nFE     ||
            gldPrevious.nCalc       != nCalc        ||
            gldPrevious.bUseSep     != gbUseSep     ||
            gldPrevious.nHexMode    != nHexMode     ||
            gldPrevious.fIntMath    != F_INTMATH()  ||
            gldPrevious.bRecord     != gbRecord )
    {
        // Assign is an expensive operation, only do when really needed
        if ( ghnoNum )
            NumObjAssign( &gldPrevious.hnoNum, ghnoNum );

        gldPrevious.nPrecision = nPrecision;
        gldPrevious.nRadix     = nRadix;
        gldPrevious.nFE        = (int)nFE;
        gldPrevious.nCalc      = nCalc;
        gldPrevious.nHexMode   = nHexMode;

        gldPrevious.fIntMath   = F_INTMATH();
        gldPrevious.bRecord    = gbRecord;
        gldPrevious.bUseSep    = gbUseSep;

        if (gbRecord)
        {
            // Display the string and return.

            CIO_vConvertToString(&gpszNum, &gcchNum, &gcio, nRadix);
        }
        else if (!F_INTMATH())
        {
            // Decimal conversion

            NumObjGetSzValue( &gpszNum, &gcchNum, ghnoNum, nRadix, nFE );
        }
        else
        {
            // Non-decimal conversion
            int i;

            // Truncate to an integer.  Do not round here.
            intrat( &ghnoNum );

            // Check the range.
            if ( NumObjIsLess( ghnoNum, HNO_ZERO ) )
            {
                // if negative make positive by doing a twos complement
                NumObjNegate( &ghnoNum );
                subrat( &ghnoNum, HNO_ONE );
                NumObjNot( &ghnoNum );
            }

            andrat( &ghnoNum, g_ahnoChopNumbers[nHexMode] );

            NumObjGetSzValue( &gpszNum, &gcchNum, ghnoNum, nRadix, FMT_FLOAT );

            // Clobber trailing decimal point
            i = lstrlen( gpszNum ) - 1;
            if ( i >= 0 && gpszNum[i] == szDec[0] )
                gpszNum[i] = TEXT('\0');
        }

        // Display the string and return.

        if (!gbUseSep)
        {
            TCHAR szTrailSpace[256];

            StringCchCopy(szTrailSpace, ARRAYSIZE(szTrailSpace), gpszNum);
            StringCchCat(szTrailSpace, ARRAYSIZE(szTrailSpace), TEXT(" "));
            SetDisplayText(g_hwndDlg, szTrailSpace);
        }
        else
        {
            TCHAR szSepNum[256];

            switch(nRadix)
            {

                case 10:
                    GroupDigits(gszSep[0], 
                                gnDecGrouping, 
                                (TEXT('-') == *gpszNum), 
                                gpszNum,
                                szSepNum,
                                ARRAYSIZE(szSepNum));
                    break;

                case 8:
                    GroupDigits(TEXT(' '), 0x03, FALSE, gpszNum, szSepNum, ARRAYSIZE(szSepNum));
                    break;

                case 2:
                case 16:
                    GroupDigits(TEXT(' '), 0x04, FALSE, gpszNum, szSepNum, ARRAYSIZE(szSepNum));
                    break;

                default:
                    StringCchCopy(szSepNum, ARRAYSIZE(szSepNum), gpszNum);
            }

            StringCchCat(szSepNum, ARRAYSIZE(szSepNum), TEXT(" "));
            SetDisplayText(g_hwndDlg, szSepNum);
        }
    }

    SetWaitCursor( FALSE );

    return;
}

/****************************************************************************\
*
* WatchDogThread
*
* Thread to look out for functions that take too long.  If it finds one, it
* prompts the user if he wants to abort the function, and asks RATPAK to
* abort if he does.
*
* History
*   26-Nov-1996 JonPa   Wrote it.
*
\****************************************************************************/
BOOL gfExiting = FALSE;
HANDLE ghCalcStart = NULL;
HANDLE ghCalcDone = NULL;
HANDLE ghDogThread = NULL;

INT_PTR TimeOutMessageBox( void );

DWORD WINAPI WatchDogThread( LPVOID pvParam ) {
    DWORD   cmsWait;
    INT_PTR iRet;

    while( !gfExiting ) {
        WaitForSingleObject( ghCalcStart, INFINITE );
        if (gfExiting)
            break;

        cmsWait = CMS_CALC_TIMEOUT;

        while( WaitForSingleObject( ghCalcDone, cmsWait ) == WAIT_TIMEOUT ) {

            // Put up the msg box
            MessageBeep( MB_ICONEXCLAMATION );
            iRet = TimeOutMessageBox();

            // if user wants to cancel, then stop
            if (gfExiting || iRet == IDYES || iRet == IDCANCEL) {
                NumObjAbortOperation(TRUE);
                break;
            } else {
                cmsWait *= 2;
                if (cmsWait > CMS_MAX_TIMEOUT) {
                    cmsWait = CMS_MAX_TIMEOUT;
                }
            }
        }
    }

    return 42;
}

/****************************************************************************\
*
* TimeCalc
*
*   Function to keep track of how long Calc is taking to do a calculation.
* If calc takes too long (about 10 sec's), then a popup is put up asking the
* user if he wants to abort the operation.
*
* Usage:
*   TimeCalc( TRUE );
*   do a lengthy operation
*   TimeCalc( FALSE );
*
* History
*   26-Nov-1996 JonPa   Wrote it.
*
\****************************************************************************/
HWND ghwndTimeOutDlg = NULL;

void TimeCalc( BOOL fStart ) {
    if (ghCalcStart == NULL) {
        ghCalcStart = CreateEvent( NULL, FALSE, FALSE, NULL );
    }

    if (ghCalcDone == NULL) {
        ghCalcDone = CreateEvent( NULL, TRUE, FALSE, NULL );
    }

    if (ghDogThread == NULL) {
        DWORD tid;
        ghDogThread = CreateThread( NULL, 0, WatchDogThread, NULL, 0, &tid );
    }

    if (fStart) {
        NumObjAbortOperation(FALSE);
        ResetEvent( ghCalcDone );
        SetEvent( ghCalcStart );
    } else {

        SetEvent( ghCalcDone );

        if( ghwndTimeOutDlg != NULL ) {
            SendMessage( ghwndTimeOutDlg, WM_COMMAND, IDRETRY, 0L );
        }

        if( NumObjWasAborted() ) {
            DisplayError(SCERR_ABORTED);
        }
    }
}


/****************************************************************************\
*
* KillTimeCalc
*
* Should be called only at the end of the program, just before exiting, to
* kill the background timer thread and free its resources.
*
* History
*   26-Nov-1996 JonPa   Wrote it.
*
\****************************************************************************/
void KillTimeCalc( void ) {
    gfExiting = TRUE;
    SetEvent( ghCalcStart );
    SetEvent( ghCalcDone );

    WaitForSingleObject( ghDogThread, CMS_MAX_TIMEOUT );

    CloseHandle( ghCalcStart );
    CloseHandle( ghCalcDone );
    CloseHandle( ghDogThread );
}


/****************************************************************************\
*
* TimeOutMessageBox
*
*   Puts up a dialog that looks like a message box.  If the operation returns
* before the user has responded to the dialog, the dialog gets taken away.
*
* History
*   04-Dec-1996 JonPa   Wrote it.
*
\****************************************************************************/
INT_PTR
CALLBACK TimeOutDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    RECT rc;
    int y;

    switch( uMsg ) {
    case WM_INITDIALOG:
        ghwndTimeOutDlg = hwndDlg;

        //
        // Move ourselves to be over the main calc window
        //

        // Find the display window so we don't cover it up.
        GetWindowRect(GetDlgItem(g_hwndDlg, IDC_DISPLAY), &rc );
        y = rc.bottom;

        // Get the main calc window pos
        GetWindowRect( g_hwndDlg, &rc );

        SetWindowPos( hwndDlg, 0, rc.left + 15, y + 40, 0, 0,
                      SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );
        break;

    case WM_COMMAND:
        EndDialog( hwndDlg, LOWORD(wParam) );
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR TimeOutMessageBox( void ) {
    return (int)DialogBox( hInst, MAKEINTRESOURCE(IDD_TIMEOUT), NULL, TimeOutDlgProc );
}


/****************************************************************************\
* 
* DigitGroupingStringToGroupingNum
* 
* Description:
*   This will take the digit grouping string found in the regional applet and 
*   represent this string as a hex value.  The grouping numbers are represented
*   as 4 bit numbers logically shifted and or'd to together so:
*
*   Grouping_string GroupingNum
*   0;0             0x000          - no grouping
*   3;0             0x003          - group every 3 digits
*   3;2;0           0x023          - group 1st 3 and then every 2 digits
*   4;0             0x004          - group every 4 digits
*   5;3;2;0         0x235          - group 5, then 3, then every 2
* 
* Returns: the grouping number
* 
* History
*   10-Sept-1999 KPeery - Wrote it to fix grouping on Hindi
*
\****************************************************************************/
UINT
DigitGroupingStringToGroupingNum(PTSTR szGrouping)
{
    PTSTR p,q;
    UINT  n, nGrouping, shift;

    if (NULL == szGrouping)
        return 0;

    nGrouping=0;
    shift=0;
    for(p=szGrouping; *p != TEXT('\0'); /* nothing */)
    {
        n=_tcstoul(p,&q,10);

            if ((n > 0) && (n < 16))
            {
                n<<=shift;
                shift+=4;

                nGrouping|=n;
            }

        if (q)
                p=q+1;
        else
            p++;
    }

    return nGrouping;
}


/****************************************************************************\
*
* GroupDigits
*
* Description:
*   This routine will take a grouping number and the display string and
*   add the separator according to the pattern indicated by the separator.
*  
*   GroupingNum
*     0x000          - no grouping
*     0x003          - group every 3 digits
*     0x023          - group 1st 3 and then every 2 digits
*     0x004          - group every 4 digits
*     0x235          - group 5, then 3, then every 2
*
* History
*   08-Sept-1998 KPeery - Wrote orignal add num separator routine
*   10-Sept-1999 KPeery - Re-wrote it to do digit grouping in general
*
\***************************************************************************/
void
GroupDigits(TCHAR sep, 
            UINT  nGrouping, 
            BOOL  bIsNumNegative, 
            PTSTR szDisplay, 
            PTSTR szSepDisplay,
            int   cchSepDisplay)
{
    PTSTR  src,dest, dec;
    size_t len;
    int    nDigits, nOrgDigits, count; 
    UINT   nOrgGrouping, nCurrGrouping;

    if ((sep == TEXT('\0')) || (nGrouping == 0))
    {
        StringCchCopy(szSepDisplay, cchSepDisplay, szDisplay);
        return;
    }

    // find decimal point

    for(dec=szDisplay; (*dec != szDec[0]) && (*dec != TEXT('\0')); dec++)
        ; // do nothing

    // at this point dec should point to '\0' or '.' we will add the left
    // side of the number to the final string

    // length of left half of number
    len=(dec-szDisplay);

    // num of digits
    nDigits=len-(bIsNumNegative ? 1 : 0);


    nOrgDigits=nDigits;
    nOrgGrouping=nGrouping;

    //
    // ok, we must now find the adjusted len, to do that we loop
    // through the grouping while keeping track of where we are in the
    // number.  When the nGrouping reaches 0 then we simply repeat the 
    // last grouping for the rest of the digits.
    //
    nCurrGrouping=nGrouping % 0x10;

    for ( ; nDigits > 0; )
    {
        if ((UINT)nDigits > nCurrGrouping)
        {
            nDigits-=nCurrGrouping;
            len++;                      // add one for comma

            nGrouping>>=4;

            if (nGrouping > 0)
                nCurrGrouping=nGrouping % 0x10;
        }
        else
            nDigits-=nCurrGrouping;
    }

    //
    // restore the saved nDigits and grouping pattern
    //
    nDigits=nOrgDigits;
    nGrouping=nOrgGrouping;
    nCurrGrouping=nGrouping % 0x10;

    //
    // ok, now we know the length copy the digits, at the same time
    // repeat the grouping pattern and place the seperator appropiatly, 
    // repeating the last grouping until we are done
    //
        
    src=dec-1;
    dest=szSepDisplay+len-1;

    count=0;
    for( ; nDigits > 0;  ) 
    {
        *dest=*src;
        nDigits--;
        count++;

        if (((count % nCurrGrouping) == 0) && (nDigits > 0))
        {
            dest--;
            *dest=sep;

            count=0;  // account for comma

            nGrouping>>=4;

            if (nGrouping > 0)
                nCurrGrouping=nGrouping % 0x10;
        }

        dest--;
        src--;
    }

    // now copy the minus sign if it is there
    if (bIsNumNegative)
        *szSepDisplay=*szDisplay;
    
    //
    // ok, now add the right (fractional) part of the number to the final
    // string.
    //
    dest=szSepDisplay+len;

    if ((int)len < cchSepDisplay)
    {
        StringCchCopy(dest, cchSepDisplay - len, dec);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\scicalc.h ===
/****************************Module*Header***********************************\
* Module Name: SCICALC.H
*
* Module Descripton: Main header file
*
* Warnings:
*
* Created:
*
* Author:
\****************************************************************************/

#define CALC_COMPILE

/* To keep a buncha junk outa compiles */
#define NOGDICAPMASKS
#define NOSYSMETRICS
#define NODRAWFRAME
#define NOKEYSTATES
#define OEMRESOURCE
#define NOATOM
#define NOMETAFILE
#define NOOPENFILE
#define NOSOUND
#define NOWH
#define NOCOMM
#define NOKANJI

#include <windows.h>
#include <windowsx.h>
#include "scimath.h"
#include "resource.h"
#include <htmlhelp.h>

#define ASSERT(f) 

#define CSTRMAX        256   /* Maximum length of any one string.         */
#ifdef DEBUG
#define CCHSTRINGSMAX  3
#else
#define CCHSTRINGSMAX  1024  /* Initial bytes to allocate for strings.    */
#endif

#define CMS_CALC_TIMEOUT     (10 * 1000) // initial timeout == 10 secs
#define CMS_MAX_TIMEOUT      (40 * 1000) // Max timeout == 40 secs

#define xwParam(x,y) ((wParam >=x) && (wParam <=y))

#define RSHF        7

/* Error values.                                                          */
#define SCERR_DIVIDEZERO    0
#define SCERR_DOMAIN        1
#define SCERR_UNDEFINED     2
#define SCERR_POS_INFINITY  3
#define SCERR_NEG_INFINITY  4
#define SCERR_ABORTED       5


/* F_INTMATH()  returns TRUE if math should be intiger mode               */
//
// Do int math if we are not in base ten
//
#define F_INTMATH() (nRadix != 10)

////////////////////////////////////////////////////////////////////////////
//
// Function prototypes.
//
////////////////////////////////////////////////////////////////////////////

/* Exports.                                                               */
LRESULT APIENTRY CalcWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY StatBoxProc(HWND, UINT, WPARAM, LPARAM);

/* Functions called from several modules.  Must be FAR.                   */
VOID    APIENTRY DisplayError (INT);
VOID    APIENTRY EnableToggles(BOOL bEnable);
VOID    APIENTRY InitSciCalc (BOOL);
VOID    APIENTRY MenuFunctions(DWORD);
VOID    APIENTRY SciCalcFunctions (PHNUMOBJ phnoNum, DWORD wOp);
VOID    APIENTRY SetStat (BOOL);
VOID    APIENTRY StatFunctions (WPARAM);

VOID   DisplayNum (VOID);

/* Internal near calls.                                                   */
void        DoOperation (INT   nOperation, HNUMOBJ *phnoNum, HNUMOBJ hnoX);

VOID   NEAR ProcessCommands(WPARAM);
VOID   NEAR SetBox (int, BOOL);
VOID   NEAR SetRadix (DWORD);
LONG   NEAR StatAlloc (WORD, DWORD);
VOID   NEAR StatError (VOID);

void   SwitchModes(DWORD wRadix, int nDecMode, int nHexMode);

void RecalcNumObjConstants(void);
BOOL SetWaitCursor( BOOL fOn );

void KillTimeCalc( void );
void TimeCalc( BOOL fStart );
BOOL SetDisplayText(HWND, LPCTSTR);

// these functions are from SciKeys.c and are used to access data stored 
// in the key array
COLORREF   GetKeyColor( int iID );
ULONG_PTR  GetHelpID( int iID );

#define  INDEXFROMID( x )    (x-IDC_FIRSTCONTROL)


////////////////////////////////////////////////////////////////////////////
//
// Global Variables
//
////////////////////////////////////////////////////////////////////////////

extern HWND         g_hwndDlg;
extern HINSTANCE    hInst;
extern ANGLE_TYPE   nDecMode;

extern long nRadix;
extern long nPrecision;
extern long dwWordBitWidth;

extern BOOL     bInv;
extern BOOL     bHyp;

extern int      nCalc;
extern int      nHexMode;

extern HNUMOBJ  g_ahnoChopNumbers[];

extern BOOL     bFarEast;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\scimath.c ===
#include <windows.h>
#include <stdlib.h>
#include "scicalc.h"
#include "unifunc.h"
#include "..\ratpak\debug.h"

/**************************************************************************\
*                                                                          *
*                                                                          *
*                                                                          *
*    #          #                           #####                          *
*    #         #              #             #    #                         *
*    #         #  #        #  #             #    #                         *
*    #        ###            ###            #    #                         *
*    # # ###   #  # # ###  #  #   ###       #####  # ###  ###   ###        *
*    # ##   #  #  # ##   # #  #  #   #      #      ##    #   # #           *
*    # #    #  #  # #    # #  #  #####      #      #     ##### #           *
*    # #    #  #  # #    # #  #  #          #      #     #     #    ##     *
*    # #    #  #  # #    # #   #  ###       #      #      ###   ### ##     *
*                                                                          *
*                                                                          *
*              Infinte Precision Production Version                        *
*                                                                          *
\**************************************************************************/
//
// RETAIL version of NUMOBJ math that uses Infinite Precision
//
// History
//
//  16-Nov-1996 JonPa   Wrote it
//  whenever-97 ToddB   Rewrote it using improved ratpak model
//

/*****************************************************************\
*
* Generic Math Package support routines and variables
*
* History:
*   01-Dec-1996 JonPa   Wrote them
*   whenever-97 ToddB   Rewrote them
*
\*****************************************************************/

//
// Worker for NumObjRecalcConstants
//
//  Returns the nearest power of two
//
int QuickLog2( int iNum )
{
    int iRes = 0;

    // while first digit is a zero
    while ( !(iNum & 1) )
    {
        iRes++;
        iNum >>= 1;
    }

    // if our number isn't a perfect square
    if ( iNum = iNum >> 1 )
    {
        // find the largest digit
        while ( iNum = iNum >> 1 )
           ++iRes;

        // and then add two
        iRes += 2;
    }

    return iRes;
}

////////////////////////////////////////////////////////////////////////
//
//  UpdateMaxIntDigits
//
// determine the maximum number of digits needed for the current precision,
// word size, and base.  This number is conservative towards the small side
// such that there may be some extra bits left over.  The number of extra
// bits is returned.  For example, base 8 requires 3 bits per digit.  A word
// size of 32 bits allows for 10 digits with a remainder of two bits.  Bases
// that require variable numnber of bits (non-power-of-two bases) are approximated
// by the next highest power-of-two base (again, to be conservative and gaurentee
// there will be no over flow verse the current word size for numbers entered).
// Base 10 is a special case and always uses the base 10 precision (nPrecision).
void UpdateMaxIntDigits()
{
    extern int gcIntDigits;
    int iRemainderBits;

    if ( nRadix == 10 )
    {
        gcIntDigits = nPrecision;
        iRemainderBits = 0;
    }
    else
    {
        int log2;

        log2 = QuickLog2( nRadix );

        ASSERT( 0 != log2 );     // same as ASSERT( nRadix != 1 )

        gcIntDigits = dwWordBitWidth / log2;
        iRemainderBits = dwWordBitWidth % log2;
    }
}

void BaseOrPrecisionChanged( void ) 
{
    extern LONG dwWordBitWidth;
    extern int  gcIntDigits;

    UpdateMaxIntDigits();
    if ( 10 == nRadix )
    {
        // to prevent unwanted rounded digits from showing up in the
        // gcIntDigits + 1 spot during non-integer mode we don't want
        // to add the extra 1 that we ortherwise add
        ChangeConstants( nRadix, gcIntDigits );
    }
    else
    {
        ChangeConstants( nRadix, gcIntDigits+1 );
    }
}

/*****************************************************************\
*
* Unary functions
*
* History:
*   01-Dec-1996 JonPa   Wrote them
*   whenever-97 ToddB   Rewrote them
*
\*****************************************************************/

void NumObjInvert( PHNUMOBJ phno ) {
    DECLARE_HNUMOBJ( hno );

    NumObjAssign( &hno, HNO_ONE );
    divrat( &hno, *phno );
    NumObjAssign( phno, hno );
    NumObjDestroy( &hno );
}

void NumObjAntiLog10( PHNUMOBJ phno ) {
    DECLARE_HNUMOBJ( hno );

    NumObjSetIntValue( &hno, 10 );
    powrat( &hno, *phno );
    NumObjAssign( phno, hno );
    NumObjDestroy( &hno );
}

void NumObjNot( PHNUMOBJ phno )
{
    if ( nRadix == 10 )
    {
        intrat( phno );
        addrat( phno, HNO_ONE );
        NumObjNegate( phno );
    }
    else
    {
        ASSERT( (nHexMode >= 0) && (nHexMode <= 3) );
        ASSERT( phno );
        ASSERT( *phno );
        ASSERT( g_ahnoChopNumbers[ nHexMode ] );

        xorrat( phno, g_ahnoChopNumbers[ nHexMode ] );
    }
}

void NumObjSin( PHNUMOBJ phno )
{
    ASSERT(( nDecMode == ANGLE_DEG ) || ( nDecMode == ANGLE_RAD ) || ( nDecMode == ANGLE_GRAD ));

    sinanglerat( (PRAT *)phno, nDecMode );
    NumObjCvtEpsilonToZero( phno );
}

void NumObjCos( PHNUMOBJ phno )
{
    ASSERT(( nDecMode == ANGLE_DEG ) || ( nDecMode == ANGLE_RAD ) || ( nDecMode == ANGLE_GRAD ));

    cosanglerat( (PRAT *)phno, nDecMode );
    NumObjCvtEpsilonToZero( phno );
}

void NumObjTan( PHNUMOBJ phno )
{
    ASSERT(( nDecMode == ANGLE_DEG ) || ( nDecMode == ANGLE_RAD ) || ( nDecMode == ANGLE_GRAD ));

    tananglerat( (PRAT *)phno, nDecMode );
    NumObjCvtEpsilonToZero( phno );
}

/******************************************************************\
*
* Number format conversion routines
*
* History:
*   06-Dec-1996 JonPa   wrote them
\******************************************************************/
void NumObjSetIntValue( PHNUMOBJ phnol, LONG i ) {
    PRAT pr = NULL;

    pr = longtorat( i );
    NumObjAssign( phnol, (HNUMOBJ)pr );
    destroyrat(pr);
}

void NumObjGetSzValue( LPTSTR *ppszNum, int* pcchNum, HNUMOBJ hnoNum, INT nRadix, NUMOBJ_FMT fmt ) 
{
    LPTSTR psz;
    int cchNum;

    psz = putrat( &cchNum, &hnoNum, nRadix, fmt );

    if (psz != NULL) {
        if (*ppszNum != NULL) {
            NumObjFreeMem( *ppszNum );
        }
        *ppszNum = psz;
        *pcchNum = cchNum;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\scikeys.c ===
#include "scicalc.h"
#include "calchelp.h"
#include "unifunc.h"

#define RED         RGB(255,0,0)       /* Red                           */
#define PURPLE      RGB(255,0,255)     /* Dark Purple                   */
#define BLUE        RGB(0,0,255)       /* Blue                          */
#define DKBLUE      RGB(0,0,255)       /* Dark Blue                     */
#define MAGENTA     RGB(255,0,255)     /* Magenta                       */
#define DKRED       RGB(255,0,0)       /* Dark Red.                     */
#define WHITE       RGB(255,255,255)   /* White                         */
#define BLACK       RGB(0,0,0)         /* Black                         */

extern BOOL g_fHighContrast;

typedef struct
{
    COLORREF    crColor;    // text color
    DWORD       iHelpID;    // the helpfile ID for this key
//    int         bUnary  :1, // true if this key is treated as a unary operator
//                bBinary :1, // true if this key is a binary operator
//                bUseInv :1, // true if this key deactivates the Inv checkbox when used
//                bUseHyp :1; // true if this key deactivates the Hyp checkbox when used
} KEYDATA;

//    Control ID,       Color,  Help ID,            Unary,  Binary, Inv,    Hyp
KEYDATA keys[] = {
    { /*IDC_SIGN,   */  BLUE,   CALC_STD_SIGN,      /*false,  false,  false,  false*/ },
    { /*IDC_CLEAR,  */  DKRED,  CALC_C,             /*false,  false,  false,  false*/ },
    { /*IDC_CENTR,  */  DKRED,  CALC_CE,            /*false,  false,  false,  false*/ },
    { /*IDC_BACK,   */  DKRED,  CALC_BACK,          /*false,  false,  false,  false*/ },
    { /*IDC_STAT,   */  DKBLUE, CALC_SCI_STA,       /*false,  false,  false,  false*/ },
    { /*IDC_PNT,    */  BLUE,   CALC_STD_DECIMAL,   /*false,  false,  false,  false*/ },
    { /*IDC_AND,    */  RED,    CALC_SCI_AND,       /*false,  false,  false,  false*/ },
    { /*IDC_OR,     */  RED,    CALC_SCI_OR,        /*false,  false,  false,  false*/ },
    { /*IDC_XOR,    */  RED,    CALC_SCI_XOR,       /*false,  false,  false,  false*/ },
    { /*IDC_LSHF,   */  RED,    CALC_SCI_LSH,       /*false,  false,  false,  false*/ },
    { /*IDC_DIV,    */  RED,    CALC_STD_SLASH,     /*false,  false,  false,  false*/ },
    { /*IDC_MUL,    */  RED,    CALC_STD_ASTERISK,  /*false,  false,  false,  false*/ },
    { /*IDC_ADD,    */  RED,    CALC_STD_PLUS,      /*false,  false,  false,  false*/ },
    { /*IDC_SUB,    */  RED,    CALC_STD_MINUS,     /*false,  false,  false,  false*/ },
    { /*IDC_MOD,    */  RED,    CALC_SCI_MOD,       /*false,  false,  false,  false*/ },
    { /*IDC_PWR,    */  PURPLE, CALC_SCI_XCARETY,   /*false,  false,  false,  false*/ },
    { /*IDC_CHOP,   */  RED,    CALC_SCI_INT,       /*false,  false,  false,  false*/ },
    { /*IDC_COM,    */  RED,    CALC_SCI_NOT,       /*false,  false,  false,  false*/ },
    { /*IDC_SIN,    */  PURPLE, CALC_SCI_SIN,       /*false,  false,  false,  false*/ },
    { /*IDC_COS,    */  PURPLE, CALC_SCI_COS,       /*false,  false,  false,  false*/ },
    { /*IDC_TAN,    */  PURPLE, CALC_SCI_TAN,       /*false,  false,  false,  false*/ },
    { /*IDC_LN,     */  PURPLE, CALC_SCI_LN,        /*false,  false,  false,  false*/ },
    { /*IDC_LOG,    */  PURPLE, CALC_SCI_LOG,       /*false,  false,  false,  false*/ },
    { /*IDC_SQRT,   */  DKBLUE, CALC_STD_SQRT,      /*false,  false,  false,  false*/ },
    { /*IDC_SQR,    */  PURPLE, CALC_SCI_XCARET2,   /*false,  false,  false,  false*/ },
    { /*IDC_CUB,    */  PURPLE, CALC_SCI_XCARET3,   /*false,  false,  false,  false*/ },
    { /*IDC_FAC,    */  PURPLE, CALC_SCI_FACTORIAL, /*false,  false,  false,  false*/ },
    { /*IDC_REC,    */  PURPLE, CALC_1X,            /*false,  false,  false,  false*/ },
    { /*IDC_DMS,    */  PURPLE, CALC_SCI_DMS,       /*false,  false,  false,  false*/ },
    { /*IDC_PERCENT,*/  DKBLUE, CALC_STD_PERCENT,   /*false,  false,  false,  false*/ },
    { /*IDC_FE,     */  PURPLE, CALC_SCI_FE,        /*false,  false,  false,  false*/ },
    { /*IDC_PI,     */  DKBLUE, CALC_SCI_PI,        /*false,  false,  false,  false*/ },
    { /*IDC_EQU,    */  RED,    CALC_STD_EQUAL,     /*false,  false,  false,  false*/ },
    { /*IDC_MCLEAR, */  RED,    CALC_MC,            /*false,  false,  false,  false*/ },
    { /*IDC_RECALL, */  RED,    CALC_MR,            /*false,  false,  false,  false*/ },
    { /*IDC_STORE,  */  RED,    CALC_MS,            /*false,  false,  false,  false*/ },
    { /*IDC_MPLUS,  */  RED,    CALC_MPLUS,         /*false,  false,  false,  false*/ },
    { /*IDC_EXP,    */  PURPLE, CALC_SCI_EXP,       /*false,  false,  false,  false*/ },
    { /*IDC_AVE,    */  DKBLUE, CALC_SCI_AVE,       /*false,  false,  false,  false*/ },
    { /*IDC_B_SUM,  */  DKBLUE, CALC_SCI_SUM,       /*false,  false,  false,  false*/ },
    { /*IDC_DEV,    */  DKBLUE, CALC_SCI_S,         /*false,  false,  false,  false*/ },
    { /*IDC_DATA,   */  DKBLUE, CALC_SCI_DAT,       /*false,  false,  false,  false*/ },
    { /*IDC_OPENP,  */  PURPLE, CALC_SCI_OPENPAREN, /*false,  false,  false,  false*/ },
    { /*IDC_CLOSEP, */  PURPLE, CALC_SCI_CLOSEPAREN,/*false,  false,  false,  false*/ },
    { /*IDC_0,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_1,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_2,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_3,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_4,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_5,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_6,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_7,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_8,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_9,      */  BLUE,   CALC_STD_NUMBERS,   /*false,  false,  false,  false*/ },
    { /*IDC_A,      */  DKBLUE, CALC_SCI_ABCDEF,    /*false,  false,  false,  false*/ },
    { /*IDC_B,      */  DKBLUE, CALC_SCI_ABCDEF,    /*false,  false,  false,  false*/ },
    { /*IDC_C,      */  DKBLUE, CALC_SCI_ABCDEF,    /*false,  false,  false,  false*/ },
    { /*IDC_D,      */  DKBLUE, CALC_SCI_ABCDEF,    /*false,  false,  false,  false*/ },
    { /*IDC_E,      */  DKBLUE, CALC_SCI_ABCDEF,    /*false,  false,  false,  false*/ },
    { /*IDC_F,      */  DKBLUE, CALC_SCI_ABCDEF,    /*false,  false,  false,  false*/ }
};

// Returns true if the given ID is one of Calc's command buttons
BOOL IsValidID( int iID )
{
    if ( (iID >= IDC_SIGN) && (iID <= IDC_F) )
        return TRUE;

    return FALSE;
}

// Used when processing WM_DRAWITEM to get the key color
COLORREF GetKeyColor( int iID )
{
    if ( g_fHighContrast || !IsValidID( iID ))
        return GetSysColor(COLOR_BTNTEXT);

    if ( nCalc && (iID == IDC_REC) )
        return DKBLUE;

    return keys[INDEXFROMID(iID)].crColor;
}

// Used when processing WM_CONTEXTHELP to get the Help ID.
// This works for any control ID, not just the command buttons.
ULONG_PTR GetHelpID( int iID )
{
    if ( IsValidID( iID ) )
    {
        return keys[INDEXFROMID(iID)].iHelpID;
    }

    switch( iID )
    {
    case IDC_HEX:
        return CALC_SCI_HEX;
    case IDC_DEC:
        return CALC_SCI_DEC;
    case IDC_OCT:
        return CALC_SCI_OCT;
    case IDC_BIN:
        return CALC_SCI_BIN;
    case IDC_DEG:
        return CALC_SCI_DEG;
    case IDC_RAD:
        return CALC_SCI_RAD;
    case IDC_GRAD:
        return CALC_SCI_GRAD;
    case IDC_QWORD:
        return CALC_SCI_QWORD; 
    case IDC_DWORD:
        return CALC_SCI_DWORD; 
    case IDC_WORD:
        return CALC_SCI_WORD; 
    case IDC_BYTE:
        return CALC_SCI_BYTE; 
    case IDC_INV:
        return CALC_SCI_INV;
    case IDC_HYP:
        return CALC_SCI_HYP;
    case IDC_DISPLAY:
        return CALC_STD_VALUE;
    case IDC_MEMTEXT:
        return CALC_SCI_MEM;
    case IDC_PARTEXT:
        return CALC_SCI_PARENS;
    }

    ASSERT( 0 );    // an invalid help ID has been used.
    return 0;
}


/*
BOOL IsUnaryOperator( int iID )
{
    ASSERT( IsValidID( iID ) );
    return keys[INDEXFROMID(iID)].bUnary;
}

BOOL IsBinaryOperator( int iID )
{
    ASSERT( IsValidID( iID ) );
    return keys[INDEXFROMID(iID)].bBinary;
}

BOOL UsesInvKey( int iID )
{
    ASSERT( IsValidID( iID ) );
    return keys[INDEXFROMID(iID)].bUseInv;
}

BOOL UsesHypKey( int iID )
{
    ASSERT( IsValidID( iID ) );
    return keys[INDEXFROMID(iID)].bUseHyp;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\scimath.h ===
/**************************************************************************\
*                                                                          *
*                                                                          *
*                                                                          *
*    #          #                           #####                          *
*    #         #              #             #    #                         *
*    #         #  #        #  #             #    #                         *
*    #        ###            ###            #    #                         *
*    # # ###   #  # # ###  #  #   ###       #####  # ###  ###   ###        *
*    # ##   #  #  # ##   # #  #  #   #      #      ##    #   # #           *
*    # #    #  #  # #    # #  #  #####      #      #     ##### #           *
*    # #    #  #  # #    # #  #  #          #      #     #     #    ##     *
*    # #    #  #  # #    # #   #  ###       #      #      ###   ### ##     *
*                                                                          *
*                                                                          *
*              Infinte Precision Production Version                        *
*                                                                          *
\**************************************************************************/
//
// RETAIL version of NUMOBJ math that uses Infinite Precision
//
#include "..\ratpak\ratpak.h"

#define HNUMOBJ   PRAT
typedef HNUMOBJ * PHNUMOBJ;


//
// Memory Alloc functions
//
#define NumObjAllocMem( cb )         zmalloc( cb )
#define NumObjFreeMem( h )           zfree( h ),(h=NULL)

//
// Unary functions
//

void NumObjInvert( PHNUMOBJ phno );

#define NumObjNegate( phno )                ( ((PRAT)*phno)->pp->sign= -(((PRAT)*phno)->pp->sign) )
#define NumObjAbs( phno )                   ( ((PRAT)*phno)->pp->sign=1, ((PRAT)*phno)->pq->sign=1 )

extern void NumObjSin( PHNUMOBJ phno );
extern void NumObjCos( PHNUMOBJ phno );
extern void NumObjTan( PHNUMOBJ phno );
extern void NumObjAntiLog10( PHNUMOBJ phno );

extern void NumObjNot( PHNUMOBJ phno );

//
// Comparison functions
//
#define NumObjIsZero( hno )                 zerrat( hno )
#define NumObjIsLess( hno1, hno2 )          rat_lt( hno1, hno2 )
#define NumObjIsLessEq( hno1, hno2 )        rat_le( hno1, hno2 )
#define NumObjIsGreaterEq( hno1, hno2 )     rat_ge( hno1, hno2 )
#define NumObjIsEq( hno1, hno2 )            rat_equ(hno1, hno2 )

//
// Assignment operator.  ('=' in C language)
//
#define NumObjAssign( phnol, hnor )         if (1) { DUPRAT( (*phnol), hnor ); } else 


//
// Data type conversion functions
//
void NumObjSetIntValue( PHNUMOBJ phnol, LONG i );


//
//  NumObjMakeNumber
//
//      HNUMOBJ NumObjMakeNumber( LPTSTR psz );
//
//  Converts psz to a number and returns it.  Call NumObjDestroy()
//  when you are done using the returned NumObj.
//
#define     NumObjMakeNumber( fMantNeg, pszMant, fExpNeg, pszExp )      inrat( fMantNeg, pszMant, fExpNeg, pszExp )

//
//  NumObjGetSzValue
//
//      void NumObjGetSzValue( LPTSTR *ppszNum, int* pcchNum, HNUMOBJ hnoNum, INT nRadix, NUMOBJ_FMT gafmt );
//
//  Converts hnoNum to a string and places the pointer into *ppszNum.  If *ppszNum already points
//  to a string, then that string is freed.
//
//  NOTES:  *ppszNum must either be NULL or point to a string previously returned by this function!
//          If you wish to free the string without replacing it.  You MUST use the NumObjFreeMem() function!
//
void NumObjGetSzValue( LPTSTR *ppszNum, int* pcchNum, HNUMOBJ hnoNum, INT nRadix, NUMOBJ_FMT gafmt );

//
//  GetObjGetExp
//
//  returns an int that equals the exponent of the NumObj
//
#define NumObjGetExp( hno )         LOGRATRADIX(hno)

//
//  NumObjCvtEpsilonToZero
//
//  if the input is < 1*10^(-nPrecision), then it gets set to zero
//  useful for special cases in ln, log, and sin, and cos
//
#define NumObjCvtEpsilonToZero( phno )
//#define NumObjCvtEpsilonToZero( phno )  if ( NumObjGetExp( *phno ) <= -nPrecision ) { NumObjAssign( phno, HNO_ZERO );} else

//
//  NumObjAbortOperation( fAbort )
//
//  If called with fAbort==TRUE, it will cause RATPAK to abort the current calculation and to return
//  immeadiatly.
//
//  It MUST be called again with fAbort=FALSE after ratpak has aborted to reset ratpak.
//
#define NumObjAbortOperation( fAbort )  (fhalt=fAbort)
#define NumObjWasAborted()              (fhalt)

//
//  NumObjOK( hno )
//
//      returns TRUE if the HNUMOBJ is valid (ie created and initialized)
//
//  Used to check the HNUMOBJ returned from NumObjMakeNumber and NumObjCreate
//
#   define NumObjOK( hno )              ((hno) == NULL ? FALSE : TRUE)

//
//  NumObjDestroy( hno )
//
//      call this when you nolonger need the NumObj.  Failure to do so
//  will result in memory leaks.
//
#   define NumObjDestroy( phno )            destroyrat( (*(phno)) )

//
// DECLARE_HNUMOBJ( hno )
//
//  Use this macro when ever you want to declare a local variable.
//
#   define DECLARE_HNUMOBJ( hno )       HNUMOBJ hno = NULL

//
// Useful Constants.  These have to be recomputed after a base or precision change.
//
void BaseOrPrecisionChanged( void );

#define HNO_ZERO                rat_zero
#define HNO_ONE_OVER_TWO        rat_half
#define HNO_ONE                 rat_one
#define HNO_TWO                 rat_two
#define HNO_180_OVER_PI         rad_to_deg
#define HNO_200_OVER_PI         rad_to_grad
#define HNO_2PI                 two_pi
#define HNO_PI                  pi
#define HNO_PI_OVER_TWO         pi_over_two
#define HNO_THREE_PI_OVER_TWO   one_pt_five_pi
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\scioper.c ===
/**************************************************************************/
/*** SCICALC Scientific Calculator for Windows 3.00.12                  ***/
/*** By Kraig Brockschmidt, Microsoft Co-op, Contractor, 1988-1989      ***/
/*** (c)1989 Microsoft Corporation.  All Rights Reserved.               ***/
/***                                                                    ***/
/*** scioper.c                                                          ***/
/***                                                                    ***/
/*** Functions contained:                                               ***/
/***    DoOperation--Does common operations.                            ***/
/***                                                                    ***/
/*** Functions called:                                                  ***/
/***    DisplayError                                                    ***/
/***                                                                    ***/
/*** Last modification Thu  31-Aug-1989                                 ***/
/**************************************************************************/

#include "scicalc.h"

extern BOOL        bInv;
extern LONG        nPrecision;


/****************************************************************************\
* HNUMOBJ NEAR DoOperation (short nOperation, HNUMOBJ fpx)
*
* Routines to perform standard operations &|^~<<>>+-/*% and pwr.
*
\****************************************************************************/

void DoOperation (INT nOperation, HNUMOBJ *phnoNum, HNUMOBJ hnoX)
{
    // NOTE: volatile is used here because of a compiler bug! vc 5 AND 6.  This has no effect on the funcationality.
    volatile PRAT hno = NULL;

    try
    {
        switch (nOperation)
        {
        /* Buncha ops.  Hope *this* doesn't confuse anyone <smirk>.       */
        case IDC_AND:
            andrat( phnoNum, hnoX );
            return;

        case IDC_OR:
            orrat( phnoNum, hnoX );
            return;

        case IDC_XOR:
            xorrat( phnoNum, hnoX );
            return;

        case RSHF:
            NumObjAssign( &hno, *phnoNum );
            NumObjAssign( phnoNum, hnoX );

            rshrat( phnoNum, hno );
            break;

        case IDC_LSHF:
            NumObjAssign( &hno, *phnoNum );
            NumObjAssign( phnoNum, hnoX );

            lshrat( phnoNum, hno );
            break;

        case IDC_ADD:
            addrat( phnoNum, hnoX );
            return;

        case IDC_SUB:
            // in order to do ( hnoX - phnoNum ) we actually do -(phnoNum - hnoX ) cause it's quicker
            subrat( phnoNum, hnoX );
            NumObjNegate( phnoNum );
            return;

        case IDC_MUL:
            mulrat( phnoNum, hnoX );
            return;

        case IDC_DIV:
        case IDC_MOD:
            {
                // REVIEW:  These lengthly number assignments can be replaced with some quick pointer swaps.
                // the swaps cannot change the value of hnoX unless we also modify the code that calls
                // the DoOperation function.
                NumObjAssign( &hno, *phnoNum );
                NumObjAssign( phnoNum, hnoX );

                if (nOperation==IDC_DIV) {
                    divrat(phnoNum, hno );   /* Do division.                       */
                } else {
                    modrat( phnoNum, hno );
                }

                break;
            }

        case IDC_PWR:       /* Calculates hnoX to the hnoNum(th) power or root.   */
            {
                NumObjAssign( &hno, *phnoNum );
                NumObjAssign( phnoNum, hnoX );

                if (bInv)   /* Switch for hnoNum(th) root. Null root illegal.    */
                {
                    SetBox (IDC_INV, bInv=FALSE);
                    rootrat( phnoNum, hno);        /* Root.                           */
                }
                else 
                {
                    powrat( phnoNum, hno );    /* Power.                          */
                }

                break;
            }
        }

        if ( hno != NULL )
            NumObjDestroy( &hno );
    }
    catch ( DWORD dwErrCode )
    {
        // if ratpak throws an error, we may need to free the memory used by hno
        if ( hno != NULL )
            NumObjDestroy( &hno );

        DisplayError( dwErrCode );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\scimenu.c ===
/**************************************************************************/
/*** SCICALC Scientific Calculator for Windows 3.00.12                  ***/
/*** By Kraig Brockschmidt, Microsoft Co-op, Contractor, 1988-1989      ***/
/*** (c)1989 Microsoft Corporation.  All Rights Reserved.               ***/
/***                                                                    ***/
/*** scimenu.c                                                          ***/
/***                                                                    ***/
/*** Functions contained:                                               ***/
/***    MenuFunctions--handles menu options.                            ***/
/***                                                                    ***/
/*** Functions called:                                                  ***/
/***    DisplayNum                                                      ***/
/***                                                                    ***/
/*** Last modification Thu  06-Dec-1989                                 ***/
/*** (-by- Amit Chatterjee [amitc])                                     ***/
/***                                                                    ***/
/*** Modified the 'PASTE' menu to check for unary minus, e, e+ & e-     ***/
/*** in DEC mode.                                                       ***/
/***                                                                    ***/
/*** Also modified the COPY code to not copy the last '.' in the display***/
/*** if a decimal point has not been hit.                               ***/
/***                                                                    ***/
/**************************************************************************/

#include "scicalc.h"
#include "unifunc.h"
#include "input.h"
#include "strsafe.h"
#include <shellapi.h>
#include <ctype.h>

#define CHARSCAN    66

extern HWND        hEdit, hStatBox;
extern TCHAR       szAppName[10], szDec[5], gszSep[5], *rgpsz[CSTRINGS];
extern LPTSTR      gpszNum;
extern int         gcchNum;
extern BOOL        bError;
extern INT         nLayout;

extern HMENU       g_hDecMenu;
extern HMENU       g_hHexMenu;

extern CALCINPUTOBJ gcio;
extern BOOL         gbRecord;
extern BOOL         gbUseSep;

/* Menu handling routine for COPY, PASTE, ABOUT, and HELP.                */
VOID NEAR PASCAL MemErrorMessage(VOID)
{
    MessageBeep(0);
    MessageBox(g_hwndDlg,rgpsz[IDS_STATMEM],NULL,MB_OK|MB_ICONHAND);
}

VOID  APIENTRY MenuFunctions(DWORD nFunc)
{
    INT              nx;
    static const int rgbMap[CHARSCAN * 2]=
    {
        TEXT('0'),IDC_0,    TEXT('1'),IDC_1,    
        TEXT('2'),IDC_2,    TEXT('3'),IDC_3,

        TEXT('4'),IDC_4,    TEXT('5'),IDC_5,
        TEXT('6'),IDC_6,    TEXT('7'),IDC_7,

        TEXT('8'),IDC_8,    TEXT('9'),IDC_9,
        TEXT('A'),IDC_A,    TEXT('B'),IDC_B,

        TEXT('C'),IDC_C,    TEXT('D'),IDC_D,
        TEXT('E'),IDC_E,    TEXT('F'),IDC_F,

        TEXT('!'),IDC_FAC,  TEXT('S'),IDC_SIN,
        TEXT('O'),IDC_COS,  TEXT('T'),IDC_TAN,

        TEXT('R'),IDC_REC,  TEXT('Y'),IDC_PWR,
        TEXT('#'),IDC_CUB,  TEXT('@'),IDC_SQR,
                        
        TEXT('M'),IDM_DEG,  TEXT('N'),IDC_LN,
        TEXT('L'),IDC_LOG,  TEXT('V'),IDC_FE,

        TEXT('X'),IDC_EXP,  TEXT('I'),IDC_INV,
        TEXT('H'),IDC_HYP,  TEXT('P'),IDC_PI,

        TEXT('/'),IDC_DIV,  TEXT('*'),IDC_MUL,
        TEXT('%'),IDC_MOD,  TEXT('-'),IDC_SUB,

        TEXT('='),IDC_EQU,  TEXT('+'),IDC_ADD,
        TEXT('&'),IDC_AND,  TEXT('|'),IDC_OR,

        TEXT('^'),IDC_XOR,  TEXT('~'),IDC_COM,
        TEXT(';'),IDC_CHOP, TEXT('<'),IDC_LSHF,


        TEXT('('),IDC_OPENP,TEXT(')'),IDC_CLOSEP,

        TEXT('\\'),    IDC_DATA,
        TEXT('Q'),     IDC_CLEAR,
        TEXT('Q')+128, IDC_CLEAR,   // ":Q"=="Q"=>CLEAR
        TEXT('S')+128, IDC_STAT,    // ":S"=>CTRL-S
        TEXT('M')+128, IDC_STORE,   // ":M"=>CTRL-M
        TEXT('P')+128, IDC_MPLUS,   // ":P"=>CTRL-P
        TEXT('C')+128, IDC_MCLEAR,  // ":C"=>CTRL-C
        TEXT('R')+128, IDC_RECALL,  // ":R"=>CTRL-R
        TEXT('A')+128, IDC_AVE,     // ":A"=>CTRL-A
        TEXT('T')+128, IDC_B_SUM,   // ":T"=>CTRL-T
        TEXT('D')+128, IDC_DEV,     // ":D"=>CTRL-D
        TEXT('2')+128, IDC_DWORD,   // ":2"=>F2     IDC_DWORD
        TEXT('3')+128, IDC_RAD,     // ":3"=>F3     IDC_WORD
        TEXT('4')+128, IDC_GRAD,    // ":4"=>F4     IDC_BYTE
        TEXT('5')+128, IDC_HEX,     // ":5"=>F5
        TEXT('6')+128, IDC_DEC,     // ":6"=>F6
        TEXT('7')+128, IDC_OCT,     // ":7"=>F7
        TEXT('8')+128, IDC_BIN,     // ":8"=>F8
        TEXT('9')+128, IDC_SIGN,    // ":9"=>F9
        TEXT('9')+3+128, IDC_QWORD  // ":9"+2=>F12 (64 bit)
   };

    switch (nFunc)
    {
        case IDM_COPY:
        {
            TCHAR  szJunk[256];

            // Copy the string into a work buffer.  It may be modified.
            if (gbRecord)
                CIO_vConvertToString(&gpszNum, &gcchNum, &gcio, nRadix);

            StringCchCopy(szJunk, ARRAYSIZE(szJunk), gpszNum);

            // Strip a trailing decimal point if it wasn't explicitly entered.
            if (!gbRecord || !CIO_bDecimalPt(&gcio))
            {
                nx = lstrlen(szJunk);
                if (szJunk[nx - 1] == szDec[0])
                    szJunk[nx - 1] = 0;
            }

            /* Copy text to the clipboard through the hidden edit control.*/
            SetWindowText(hEdit, szJunk);
            SendMessage(hEdit, EM_SETSEL, 0, -1);   // select all text
            SendMessage(hEdit, WM_CUT, 0, 0L);
            break;
        }

        case IDM_PASTE:
        {
            HANDLE  hClipData;
            char *  lpClipData;
            char *  lpEndOfBuffer;  // used to ensure we don't GPF even if the clipboard data isn't NULL terminated
            WORD    b, bLast;
            INT     nControl;
            BOOL    bNeedIDC_SIGN = FALSE;

            /* Get a handle on the clipboard data and paste by sending the*/
            /* contents one character at a time like it was typed.        */
            if (!OpenClipboard(g_hwndDlg))
            {
                MessageBox(g_hwndDlg, rgpsz[IDS_NOPASTE], rgpsz[IDS_CALC],
                           MB_OK | MB_ICONEXCLAMATION);
                break;
            }

            hClipData=GetClipboardData(CF_TEXT);
            if (hClipData)
            {
                lpClipData=(char *)GlobalLock(hClipData);
                if (lpClipData)
                {
                    lpEndOfBuffer = lpClipData + GlobalSize(hClipData);
                    bLast=0;

                    /* Continue this as long as no error occurs.  If one      */
                    /* does then it's useless to continue pasting.            */
                    while (!bError && lpClipData < lpEndOfBuffer)
                    {
                        // we know that lpClipData points to a NULL terminated ansi 
                        // string because this is the format we requested the data in.
                        // As a result we call CharNextA.

                        b = *lpClipData;
                        lpClipData = CharNextA( lpClipData );

                        /* Skip spaces and LF and CR.                             */
                        if (b==32 || b==10 || b==13 || b==gszSep[0])
                            continue;

                        /* We're done if we get to a NULL character */
                        if ( b==0 )
                            break;

                        if (b == szDec[0])
                        {
                            bLast = b;
                            b = IDC_PNT;
                            goto MappingDone;
                        }

/*-----------------------------------------------------------------------------;
; Now we will check for certain special cases. These are:                      ;
;                                                                              ;
;       (1) Unary Minus. If bLast is still 0 and b is '-' we will force b to   ;
;         be the code for 'SIGN'.                                              ;
;       (2) If b is 'x' we will make it the code for EXP                       ;
;       (3) if bLast is 'x' and b is '+' we will ignore b, as '+' is the dflt. ;
;       (4) if bLast is 'x' and b is '-' we will force b to be SIGN.           ;
;                                                                              ;
;  In case (3) we will go back to the top of the loop else we will jmp off     ;
;  to the sendmessage point, bypassing the table lookup.                       ;
;-----------------------------------------------------------------------------*/

                        /* check for unary minuses */
                        if  (!bLast && b == TEXT('-'))
                        {
                            /* Doesn't work.
                            bLast = b ;
                            b = IDC_SIGN ;
                            goto MappingDone ;
                            */
                            bNeedIDC_SIGN = TRUE ;
                            continue ;
                        }

                        /* check for 'x' */
                        if  ((b == TEXT('x') || b == TEXT('e')) && nRadix == 10)
                        {
                            bLast = TEXT('x') ;
                            b = IDC_EXP ;
                            goto MappingDone ;
                        }

                        /* if the last character was a 'x' & this is '+' - ignore */
                        if  (bLast==TEXT('x') && b ==TEXT('+') && nRadix == 10)
                            continue ;

                        /* if the last character was a 'x' & this is '-' - change
                        it to be the code for SIGN */
                        if  (bLast==TEXT('x') && b==TEXT('-') && nRadix == 10)
                        {
                            bLast = b ;
                            b = IDC_SIGN ;
                            goto MappingDone ;
                        }

/* -by- AmitC   */
/*--------------------------------------------------------------------------*/


                        /* Check for control character.                           */
                        if (bLast==TEXT(':'))
                            nControl=128;
                        else
                            nControl=0;

                        bLast=b;
                        if (b==TEXT(':'))
                            continue;

                        b=toupper(b)+nControl;

                        nx=0;
                        while (b!=rgbMap[nx*2] && nx < CHARSCAN)
                            nx++;

                        if (nx==CHARSCAN)
                            break;

                        b=(WORD)rgbMap[(nx*2)+1];

                        if (nRadix != 10)
                        {
                            switch(b)
                            {
                                case IDC_DEG:
                                case IDC_RAD:
                                case IDC_GRAD:
                                    b=IDC_DWORD+(b-IDC_DEG);
                                break;
                            }
                        }
                                
                        // REVIEW NOTE: 
                        //   Conversion of IDC_MOD to IDC_PERCENT done in WM_COMMAND
                        //   processing so that keyboard accelerator and paste are
                        //   handled in the same place.  The old conversion was broken
                        //   anyway and actually happened in

        MappingDone:
                        /* Send the message to the window.                        */
                        SendMessage(g_hwndDlg, WM_COMMAND, GET_WM_COMMAND_MPS(b, 0, 1));
                        /* Note that we may need to apply the "+/-" key (IDC_SIGN)
                           now.  (If it had been applied earlier, it would have
                           been ignored.)  Note further that it can't be applied if we
                           have seen only the "-0" of something like "-0.1". */
                        if(bNeedIDC_SIGN && (IDC_0 != b))
                            {
                            SendMessage(g_hwndDlg, WM_COMMAND, GET_WM_COMMAND_MPS(IDC_SIGN, 0, 1));
                            bNeedIDC_SIGN = FALSE;
                            }
                    }
                    GlobalUnlock(hClipData);
                }    
            }    
            CloseClipboard();
            break;
        }

        case IDM_ABOUT:
            /* Start the About Box.                                       */
            if(ShellAbout(g_hwndDlg, rgpsz[IDS_CALC], NULL, LoadIcon(hInst, (LPTSTR)TEXT("SC"))) == -1)
                MemErrorMessage();

            break;

        case IDM_SC:
        case IDM_SSC:
        {
            INT     nTemp;
            TCHAR   szWinIni[2];

            nTemp = (INT) nFunc - IDM_SC;
            if (nCalc != nTemp)
            {
                szWinIni[0] = TEXT('0') + nTemp;
                szWinIni[1]=0;
                WriteProfileString(szAppName, TEXT("layout"), szWinIni);

                if (hStatBox && !nCalc)
                    SetStat(FALSE);

                nCalc = nTemp;
                InitSciCalc(TRUE);
            }
            break;
        }

        case IDM_USE_SEPARATOR:
        {
            gbUseSep = !gbUseSep;

            CheckMenuItem(g_hDecMenu, IDM_USE_SEPARATOR,
                          MF_BYCOMMAND|(gbUseSep ? MF_CHECKED : MF_UNCHECKED));

            if (g_hHexMenu)
            {
                CheckMenuItem(g_hHexMenu, IDM_USE_SEPARATOR,
                              MF_BYCOMMAND | \
                              (gbUseSep ? MF_CHECKED:MF_UNCHECKED));
            }

            WriteProfileString(szAppName,TEXT("UseSep"),
                               (gbUseSep ? TEXT("1") : TEXT("0")));

            break;
        }

        case IDM_HELPTOPICS:
            HtmlHelp(GetDesktopWindow(), rgpsz[IDS_CHMHELPFILE], HH_DISPLAY_TOPIC, 0L);
            break;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\unifunc.h ===
/*** unifunc.h  ***/

#define CharSizeOf(x)   (sizeof(x) / sizeof(*x))
#define ByteCountOf(x)  ((x) * sizeof(TCHAR))

#define ARRAYSIZE(x)   (sizeof(x) / sizeof(*x))

TCHAR *UToDecT( UINT value, TCHAR *sz);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\sciproc.c ===
/**************************************************************************/
/*** SCICALC Scientific Calculator for Windows 3.00.12                  ***/
/*** By Kraig Brockschmidt, Microsoft Co-op, Contractor, 1988-1989      ***/
/*** (c)1989 Microsoft Corporation.  All Rights Reserved.               ***/
/***                                                                    ***/
/*** sciproc.c                                                          ***/
/***                                                                    ***/
/*** Functions contained:                                               ***/
/***    CalcWndProc--Main window procedure.                             ***/
/***                                                                    ***/
/*** Functions called:                                                  ***/
/***    SetRadix,                                                       ***/
/***    ProcessCommands.                                                ***/
/***                                                                    ***/
/*** Last modification Fri  08-Dec-1989                                 ***/
/*** -by- Amit Chatterjee. [amitc]                                      ***/
/*** Last modification July-21-1994                                     ***/
/*** -by- Arthur Bierer [t-arthb] or abierer@ucsd.edu                   ***/
/***                                                                    ***/
/*** Modified WM_PAINT processing to display ghnoLastNum rather than    ***/
/*** ghnoNum if the last key hit was an operator.                       ***/
/***                                                                    ***/
/**************************************************************************/

#include "scicalc.h"
#include "calchelp.h"
#include "commctrl.h"

extern HWND     hStatBox;
extern HBRUSH   hBrushBk;
extern BOOL     bFocus, bError;
extern TCHAR    szDec[5], *rgpsz[CSTRINGS];
extern HNUMOBJ  ghnoNum, ghnoLastNum;
extern INT      nTempCom ;
extern INT      gnPendingError ;
extern BOOL     gbRecord;

WNDPROC fpOrgDispEditProc;
LRESULT CALLBACK SubDispEditProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


BOOL FireUpPopupMenu( HWND hwnd, HINSTANCE hInstanceWin, LPARAM lParam)
{
    HMENU hmenu;

    if ((hmenu = LoadMenu(hInstanceWin, MAKEINTRESOURCE(IDM_HELPPOPUP))))
    {
        int cmd = TrackPopupMenuEx(GetSubMenu(hmenu, 0),
            TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RETURNCMD | TPM_RIGHTBUTTON,
            LOWORD(lParam), HIWORD(lParam), hwnd, NULL);
        DestroyMenu(hmenu);
        return ( cmd == HELP_CONTEXTPOPUP ) ? TRUE : FALSE;

    }
    else
        return FALSE;
}

extern BOOL IsValidID( int iID );

LRESULT APIENTRY CalcWndProc (
HWND           hWnd,
UINT           iMessage,
WPARAM         wParam,
LPARAM         lParam)
{
    INT         nID, nTemp;       /* Return value from GetKey & temp.  */
    HANDLE      hTempBrush; // a brush to play with in WM_CTLCOLORSTATIC

    switch (iMessage)
    {
        case WM_INITMENUPOPUP:
            /* Gray out the PASTE option if CF_TEXT is not available.     */
            /* nTemp is used here so we only call EnableMenuItem once.    */
            if (!IsClipboardFormatAvailable(CF_TEXT))
                nTemp=MF_GRAYED | MF_DISABLED;
            else
                nTemp=MF_ENABLED;

            EnableMenuItem(GetMenu(hWnd),IDM_PASTE, nTemp);
            break;

        case WM_CONTEXTMENU:
            // If the user clicked on the dialog face and not one of the
            // buttons then do nothing.  If the id of the button is IDC_STATIC
            // then do nothing. 

            if ( (HWND)wParam == g_hwndDlg )
            {
                // check for clicks on disabled buttons.  These aren't seen 
                // by WindowFromPoint but are seen by ChildWindowFromPoint.
                // As a result, the value of wParam will be g_hwndDlg 
                // if the WM_RBUTTONUP event occured on a disabled button.

                POINT pt;
                HWND  hwnd;

                // convert from short values to long values
                pt.x = MAKEPOINTS(lParam).x;   
                pt.y = MAKEPOINTS(lParam).y;

                // then convert to client coordinates
                ScreenToClient( g_hwndDlg, &pt );  

                hwnd = ChildWindowFromPoint( g_hwndDlg, pt );

                if ( !hwnd || (hwnd == g_hwndDlg) || 
                     (IDC_STATIC == GetDlgCtrlID( hwnd )))
                {
                    return (DefWindowProc(hWnd, iMessage, wParam, lParam));
                }

                wParam = (WPARAM)hwnd;
            }

            if ( FireUpPopupMenu( g_hwndDlg, hInst, lParam ) )
            {
                nID = GetDlgCtrlID( (HWND)wParam );

                WinHelp((HWND) wParam, rgpsz[IDS_HELPFILE], HELP_CONTEXTPOPUP,
                        GetHelpID( nID ));
            }
            break;

        case WM_HELP:
            HtmlHelp(GetDesktopWindow(), rgpsz[IDS_CHMHELPFILE], HH_DISPLAY_TOPIC, 0L);
            return 0;

        case WM_COMMAND: /* Interpret all buttons on calculator.          */
        {
            WORD wNotifyCode = HIWORD(wParam); // notification code
            WORD wID = LOWORD(wParam);         // item, control, or accelerator identifier

            // the accelerator table feeds us IDC_MOD in response to the 
            // "%" key.  This same accelerator is used for the percent function
            // in Standard view so translate here.

            if ( (wID == IDC_MOD) && (nCalc == 1) )
                wID = IDC_PERCENT;

            // when we get an accelerator keystroke we fake a button press to provide feedback
            if ( wNotifyCode == 1 )
            {
                // For an accelerator the hwnd is not passed in the lParam so ask the dialog
                HWND hwndCtl = GetDlgItem( g_hwndDlg, wID );
                SendMessage( hwndCtl, BM_SETSTATE, 1, 0 );  // push the button down
                Sleep( 20 );                                // wait a bit
                SendMessage( hwndCtl, BM_SETSTATE, 0, 0 );  // push the button up
            }

            // we turn on notify for the text controls to automate the handling of context
            // help but we don't care about any commands we recieve from these controls. As
            // a result, only process commands that are not from a text control.
            if ( (wID != IDC_DISPLAY) && (wID != IDC_MEMTEXT) && (wID != IDC_PARTEXT) )
                ProcessCommands(wID);
            break;
        }

        case WM_CLOSE:
            if ( hStatBox )
            {
                SendMessage(hStatBox, WM_CLOSE, 0, 0L) ;
                hStatBox = NULL;
            }

            DestroyWindow(g_hwndDlg);
            KillTimeCalc();
            WinHelp(g_hwndDlg, rgpsz[IDS_HELPFILE], HELP_QUIT, 0L);
            PostQuitMessage(0);
            break;

        case WM_SYSCOMMAND:
            if ( (wParam & 0xFFF0) == SC_CLOSE )
            {
                PostQuitMessage(0);
            }
            return (DefWindowProc(hWnd, iMessage, wParam, lParam));

        case WM_NOTIFY:
        {
            NMCUSTOMDRAW* nm = (NMCUSTOMDRAW*)lParam;
            int iBtnID = (int)nm->hdr.idFrom;
            if (nm->hdr.code == NM_CUSTOMDRAW && IsValidID(iBtnID))
            {
                if (nm->dwDrawStage == CDDS_PREERASE)
                {
                    return CDRF_NOTIFYITEMDRAW;
                }
                else if (nm->dwDrawStage == CDDS_PREPAINT)
                {
                    int bkMode = SetBkMode(nm->hdc, TRANSPARENT);
                    LPCTSTR psz = rgpsz[INDEXFROMID(iBtnID)];
                    SetTextColor( nm->hdc, (nm->uItemState & CDIS_DISABLED)?GetSysColor(COLOR_GRAYTEXT):GetKeyColor( iBtnID ) );
                    DrawText( nm->hdc, psz, -1, &nm->rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE );
                    SetBkMode(nm->hdc, bkMode);
                    return CDRF_SKIPDEFAULT;
                }
            }
            break;
        }

        case WM_CTLCOLORSTATIC:
            // get the Control's id from its handle in lParam
            if ( IDC_DISPLAY == GetWindowID( (HWND) lParam) )
            {
                // we set this window to a white backround
                hTempBrush = GetSysColorBrush( COLOR_WINDOW );
                SetBkColor( (HDC) wParam, GetSysColor( COLOR_WINDOW ) );
                SetTextColor( (HDC) wParam, GetSysColor( COLOR_WINDOWTEXT ) );

                return (LRESULT) hTempBrush;
            }
            return (DefWindowProc(hWnd, iMessage, wParam, lParam));

        case WM_SETTINGCHANGE:
            if (lParam!=0)
            {
                // we only care about changes to color and internation settings, ignore all others
                if (lstrcmp((LPCTSTR)lParam, TEXT("colors")) &&
                        lstrcmp((LPCTSTR)lParam, TEXT("intl")))
                    break;
            }

            // Always call if lParam==0.  This is simply for safety and isn't strictly needed
            InitSciCalc (FALSE);
            break;

        case WM_SIZE:
            {
                HWND hwndSizer;

                nTemp=SW_SHOW;
                if (wParam==SIZEICONIC)
                    nTemp=SW_HIDE;

                if (hStatBox!=0 && (wParam==SIZEICONIC || wParam==SIZENORMAL))
                    ShowWindow(hStatBox, nTemp);

                // A special control has been added to both dialogs with an ID of
                // IDC_SIZERCONTROL.  This control is possitioned such that the bottom of
                // the control determines the height of the dialog.  If a really large menu
                // font is selected then the menu might wrap to two lines, which exposes a
                // bug in Windows that causes the client area to be too small.  By checking
                // that IDC_SIZERCONTROL is fully visible we can compensate for this bug.
                hwndSizer = GetDlgItem( g_hwndDlg, IDC_SIZERCONTROL );
                if ( hwndSizer )
                {
                    RECT rc;
                    int iDelta;
                    GetClientRect( hwndSizer, &rc );
                    MapWindowPoints( hwndSizer, g_hwndDlg, (LPPOINT)&rc, 2 );

                    // if the difference between the current height of the client area
                    // (MAKEPOINTS(lParam).y) and the desired height of the client
                    // area (rc.bottom) is non-zero then we must adjust the size of the
                    // client area.  This will enlarge the client area if you switch
                    // from a regular menu font to a jumbo menu font and shrink the
                    // client area if you switch from a jumbo menu font to a regular
                    // menu font.
                    iDelta = rc.bottom - HIWORD(lParam);
                    if ( iDelta )
                    {
                        GetWindowRect( g_hwndDlg, &rc );
                        SetWindowPos( g_hwndDlg, NULL,
                            0, 0,                       // these are ingored due to SWP_NOMOVE
                            rc.right-rc.left,           // the width remains the same
                            rc.bottom-rc.top+iDelta,    // the heigth changes by iDelta
                            SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
                        return 0;
                    }
                }
            }
            /* Fall through.                                              */

        default:
            return (DefWindowProc(hWnd, iMessage, wParam, lParam));
    }

    return 0L;
}


LRESULT CALLBACK SubDispEditProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // prevent right button to cut/del/paste... messes up the calculation
    if (uMsg >= WM_MOUSEFIRST && uMsg <= WM_MOUSELAST)
        return 0;

    // FEATURE: You can still begin a selection by holding down shift and using the arrow keys.  This should also be disabled.

    HideCaret(hWnd);
    return CallWindowProc(fpOrgDispEditProc, hWnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\sciset.c ===
/**************************************************************************/
/*** SCICALC Scientific Calculator for Windows 3.00.12                  ***/
/*** By Kraig Brockschmidt, Microsoft Co-op, Contractor, 1988-1989      ***/
/*** (c)1989 Microsoft Corporation.  All Rights Reserved.               ***/
/***                                                                    ***/
/*** sciset.c                                                           ***/
/***                                                                    ***/
/*** Functions contained:                                               ***/
/***    SetRadix--Changes the number base and the radiobuttons.         ***/
/***    SetBox--Handles the checkboxes for inv/hyp.                     ***/
/***                                                                    ***/
/*** Functions called:                                                  ***/
/***    none                                                            ***/
/***                                                                    ***/
/*** History:
 ***    12-Dec-1996 JonPa   -   Added SetMaxIntDigits
 ***    Whenever-97 ToddB   -   Removed SetMaxIntDigits
 ***/
/**************************************************************************/

#include "scicalc.h"
#include "unifunc.h"

extern TCHAR    szBlank[6];
extern INT      gcIntDigits;
extern TCHAR    *rgpsz[CSTRINGS];
extern TCHAR    szDec[];
extern RECT     rcDeg[6];
extern HMENU    g_hDecMenu;
extern HMENU    g_hHexMenu;

long oldRadix = (unsigned)-1;

void ActivateButtons()
{
    static int  aDecOnlyKeys[] = { IDC_FE, IDC_DMS, IDC_SIN, IDC_COS, IDC_TAN, IDC_EXP, IDC_PI };   // controls used only in Decimal mode

    if (oldRadix != nRadix)
    {
        int i;
        BOOL bDecMode = (nRadix == 10);
        
        // Only send messages to the the "Decimal Only keys" if this change in
        // base effects those keys

        if ((oldRadix == 10) || bDecMode)
        {
            // we are changing to or from decimal mode
            for ( i = 0; i <= ARRAYSIZE(aDecOnlyKeys) ; i++ )
            {
                EnableWindow( GetDlgItem(g_hwndDlg, aDecOnlyKeys[i]), 
                              bDecMode );
            }
        }

        // insure that nRadix is within the allowed range
        ASSERT( (nRadix >= 2) && (nRadix <= 16) );
        
        // turn on digit keys less than nRadix and turn off digit keys >= nRadix
        for (i=2; i<nRadix; i++)
            EnableWindow( GetDlgItem(g_hwndDlg, IDC_0+i), TRUE );

        for ( ; i<16; i++ )
            EnableWindow( GetDlgItem(g_hwndDlg, IDC_0+i), FALSE );
    }
    oldRadix = nRadix;
}

// SetRadix sets the display mode according to the selected button.
// ToddB:  As a hack to allow setting other bases, wRadix can be one of
//         the base buttons OR it can be the desired nRadix.

// MAXIUM: for Dec the precision is limited to the nPrecision, 
//  otherwise it is limited to the word size.

VOID NEAR SetRadix(DWORD wRadix)
{
    static INT  nRadish[4]={2,8,10,16}; /* Number bases.               */

    int   id=IDM_DEC;

    // convert special bases into symbolic values
    switch ( wRadix )
    {
    case 2:
        id=IDM_BIN;
        break;

    case 8:
        id=IDM_OCT;
        break;

    case 10:
        id=IDM_DEC;
        break;

    case 16:
        id=IDM_HEX;
        break;

    case IDM_HEX:
    case IDM_DEC:
    case IDM_OCT:
    case IDM_BIN:
        id=wRadix;
        wRadix = nRadish[IDM_BIN - wRadix];
        break;
    }

    // we select which group of toggles we are setting, decimal mode gets the
    // angular notation buttons (deg, rad, grad) otherwise we get the word size 
    // buttons (dword, word, byte)

    SwitchModes(wRadix, nDecMode, nHexMode);

    CheckMenuRadioItem(GetSubMenu(GetMenu(g_hwndDlg),1),IDM_HEX,IDM_BIN,id,
                       MF_BYCOMMAND);

    CheckRadioButton(g_hwndDlg,IDM_HEX, IDM_BIN, id);

    nRadix = wRadix;

    // inform ratpak that a change in base or precision has occured
    BaseOrPrecisionChanged();
    
    // update the UI elements to the correct state
    ActivateButtons();

    // display the correct number for the new state (ie convert displayed 
    //  number to correct base)
    DisplayNum();
}


// Check/uncheck the visible inverse/hyperbolic

VOID NEAR SetBox (int id, BOOL bOnOff)
{
    CheckDlgButton(g_hwndDlg, id, (WORD) bOnOff);
    return;
}

//
// Description:
//   This will switch the displayed/enabled mode buttons.  This also updates
//   The switches the menu under view and sets the correct state.
//
void
SwitchModes(DWORD wRadix, int nDecMode, int nHexMode)
{
    int iID, id;

    if (10 == wRadix)
    {
        id=IDM_DEG+nDecMode;

        if (NULL != g_hDecMenu)
            SetMenu(g_hwndDlg, g_hDecMenu);

        CheckMenuRadioItem(g_hDecMenu, IDM_DEG, IDM_GRAD, id, MF_BYCOMMAND);
        CheckRadioButton(g_hwndDlg,IDC_DEG, IDC_GRAD, id);
    }
    else
    {
        id=IDM_QWORD+nHexMode;

        if (NULL != g_hHexMenu)
            SetMenu(g_hwndDlg, g_hHexMenu);

        CheckMenuRadioItem(g_hHexMenu, IDM_QWORD, IDM_BYTE, id, MF_BYCOMMAND);
        CheckRadioButton(g_hwndDlg,IDC_QWORD, IDC_BYTE, id);
    }

    for (iID = IDC_QWORD; iID <= IDC_BYTE; iID++)
    {
        EnableWindow( GetDlgItem( g_hwndDlg, iID ), (wRadix != 10) );
        ShowWindow( GetDlgItem( g_hwndDlg, iID ),
                    (wRadix == 10) ? SW_HIDE : SW_SHOW );
    }

    for (iID = IDC_DEG; iID <= IDC_GRAD; iID++)
    {
        EnableWindow( GetDlgItem( g_hwndDlg, iID ), (wRadix == 10) );
        ShowWindow( GetDlgItem( g_hwndDlg, iID ), 
                    (wRadix != 10) ? SW_HIDE : SW_SHOW );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\scistat.c ===
/**************************************************************************/
/*** SCICALC Scientific Calculator for Windows 3.00.12                  ***/
/*** By Kraig Brockschmidt, Microsoft Co-op, Contractor, 1988-1989      ***/
/*** (c)1989 Microsoft Corporation.  All Rights Reserved.               ***/
/***                                                                    ***/
/*** scistat.c                                                          ***/
/***                                                                    ***/
/*** Functions contained:                                               ***/
/***    SetStat--Enable/disable the stat box, show or destroy the       ***/
/***        modeless dialog box.                                        ***/
/***    StatBoxProc--procedure for the statbox.  Handles the RET, LOAD, ***/
/***        CD, and CAD buttons, and handles double-clicks.             ***/
/***    StatFunctions--routines for DATA, SUM, AVE, and deviations.     ***/
/***                                                                    ***/
/*** Functions called:                                                  ***/
/***    SetStat                                                         ***/
/***                                                                    ***/
/*** Last modification Thu  26-Jan-1990                                 ***/
/*** -by- Amit Chatterjee [amitc]  26-Jan-1990.                         ***/
/*** Following bug fix was made:                                        ***/
/***                                                                    ***/
/*** Bug # 8499.                                                        ***/
/*** While fixing numbers in the stat array in memory, instead of using ***/
/*** the following for statement:                                       ***/
/***      for (lIndex=lData; lIndex < lStatNum - 1 ; lIndex++)          ***/
/*** the fix was to use:                                                ***/
/***      for (lIndex=lData; lIndex < lStatNum ; lIndex++)              ***/
/*** This is because lStatNum has already been decremented to care of   ***/
/*** a number being deleted.                                            ***/
/*** This fix will be in build 1.59.                                    ***/
/**************************************************************************/

#include "scicalc.h"
#include "calchelp.h"
#include "unifunc.h"

#define GMEMCHUNK 96L  /* Amount of memory to allocate at a time.         */

extern HNUMOBJ  ghnoNum;
extern HWND     hStatBox, hListBox, hEdit;
extern TCHAR    szBlank[6], *rgpsz[CSTRINGS];
extern LPTSTR   gpszNum;
extern int      gcchNum;
extern INT      nTempCom;
extern BOOL     gbRecord;

extern BOOL FireUpPopupMenu( HWND, HINSTANCE, LPARAM );

GLOBALHANDLE    hgMem, hMem;   /* Coupla global memory handles.        */
BOOL            bFocus=TRUE;
LONG            lStatNum=0,    /* Number of data.                      */
                lReAllocCount; /* Number of data before ReAlloc.       */
HNUMOBJ *       lphnoStatNum;   /* Holding place for stat data.         */


/* Initiate or destroy the Statistics Box.                                */

VOID  APIENTRY SetStat (BOOL bOnOff)
{
    static int aStatOnlyKeys[] = { IDC_AVE, IDC_B_SUM, IDC_DEV, IDC_DATA };
    int i;

    if (bOnOff)
    {
        /* Create.                                                        */
        lReAllocCount=GMEMCHUNK/sizeof(ghnoNum); /* Set up lReAllocCount.   */

        /* Start the box.                                                 */
        hStatBox=CreateDialog(hInst, MAKEINTRESOURCE(IDD_SB), NULL, StatBoxProc);

        /* Get a handle on some memory (16 bytes initially.               */
        if (!(hgMem=GlobalAlloc(GHND, 0L)))
        {
            StatError();
            SendMessage(hStatBox, WM_COMMAND, GET_WM_COMMAND_MPS(ENDBOX, 0, 0));
            return;
        }
        ShowWindow(hStatBox, SW_SHOWNORMAL);
    }
    else
    {
        int lIndex;

        if ( hStatBox )
        {
            DestroyWindow(hStatBox);

            // Free the numobj's
            lphnoStatNum=(HNUMOBJ *)GlobalLock(hgMem);
            for( lIndex = 0; lIndex < lStatNum; lIndex++ )
                NumObjDestroy( &lphnoStatNum[lIndex] );
            GlobalUnlock(hgMem);
            lStatNum = 0;

            GlobalFree(hgMem);  /* Free up the memory.                        */
            hStatBox=0;         /* Nullify handle.                            */
        }
    }

    // set the active state of the Ave, Sum, s, and Dat buttons
    for ( i=0; i<ARRAYSIZE(aStatOnlyKeys); i++)
        EnableWindow( GetDlgItem(g_hwndDlg, aStatOnlyKeys[i]), bOnOff );

    return;
}



/* Windows procedure for the Dialog Statistix Box.                        */
INT_PTR FAR APIENTRY StatBoxProc (
     HWND           hStatBox,
     UINT           iMessage,
     WPARAM         wParam,
     LPARAM         lParam)
{
    static LONG lData=-1;  /* Data index in listbox.                   */
    LONG        lIndex;    /* Temp index for counting.                 */
    DWORD       dwSize;    /* Holding place for GlobalSize.            */
    static DWORD    control[] = {
        IDC_STATLIST,   CALC_SCI_STATISTICS_VALUE,
        IDC_CAD,        CALC_SCI_CAD,
        IDC_CD,         CALC_SCI_CD,
        IDC_LOAD,       CALC_SCI_LOAD,
        IDC_FOCUS,      CALC_SCI_RET,
        IDC_NTEXT,      CALC_SCI_NUMBER,
        IDC_NUMTEXT,    CALC_SCI_NUMBER,
        0,              0 };

    switch (iMessage)
    {
        case WM_HELP:
        {
            LPHELPINFO phi = (LPHELPINFO)lParam;
            HWND hwndChild = GetDlgItem(hStatBox,phi->iCtrlId);
            WinHelp( hwndChild, rgpsz[IDS_HELPFILE], HELP_WM_HELP, (ULONG_PTR)(void *)control );
            return TRUE;
        }

        case WM_CONTEXTMENU:
            WinHelp( (HWND)wParam, rgpsz[IDS_HELPFILE], HELP_CONTEXTMENU, (ULONG_PTR)(void *)control );
            return TRUE;

        case WM_CLOSE:
            SetStat(FALSE);

        case WM_DESTROY:
            lStatNum=0L; /* Reset data count.                     */
            return(TRUE);

        case WM_INITDIALOG:
            /* Get a handle to this here things listbox display.          */
            hListBox=GetDlgItem(hStatBox, IDC_STATLIST);
            return TRUE;

        case WM_COMMAND:
            /* Check for LOAD or double-click and recall number if so.    */

            if (GET_WM_COMMAND_CMD(wParam, lParam)==LBN_DBLCLK ||
                        GET_WM_COMMAND_ID(wParam, lParam)==IDC_LOAD)
            {
                /* Lock data, get pointer to it, and get index of item.   */
                lphnoStatNum=(HNUMOBJ *)GlobalLock(hgMem);
                lData=(LONG)SendMessage(hListBox,LB_GETCURSEL,0,0L);

                if (lStatNum>0 && lData !=LB_ERR)
                    // SPEED: REVIEW: can we use a pointer instead of Assign?
                    NumObjAssign( &ghnoNum, lphnoStatNum[lData]);  /* Get the data.         */
                else
                    MessageBeep(0); /* Cannodo if no data nor selection.  */

                // Cancel kbd input mode
                gbRecord = FALSE;

                DisplayNum ();
                nTempCom = 32;
                GlobalUnlock(hgMem); /* Let the memory move!              */
                break;
            }

            // switch (wParam)
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_FOCUS:
                    /* Change focus back to main window.  Primarily for   */
                    /* use with the keyboard.                             */
                    SetFocus(g_hwndDlg);
                    return (TRUE);

                case IDC_CD:
                    /* Clear the selected item from the listbox.          */
                    /* Get the index and a pointer to the data.           */
                    lData=(LONG)SendMessage(hListBox,LB_GETCURSEL,0,0L);

                    /* Check for possible error conditions.               */
                    if (lData==LB_ERR || lData > lStatNum-1 || lStatNum==0)
                    {
                        MessageBeep (0);
                        break;
                    }

                    /* Fix listbox strings.                               */
                    lIndex=(LONG)SendMessage(hListBox, LB_DELETESTRING, (WORD)lData, 0L);

                    if ((--lStatNum)==0)
                        goto ClearItAll;

                    /* Place the highlight over the next one.             */
                    if (lData<lIndex || lIndex==0)
                        lIndex=lData+1;

                    SendMessage(hListBox, LB_SETCURSEL, (WORD)lIndex-1, 0L);

                    lphnoStatNum=(HNUMOBJ *)GlobalLock(hgMem);

                    /* Fix numbers in memory.                             */
                    for (lIndex=lData; lIndex < lStatNum ; lIndex++)
                    {
                        NumObjAssign( &lphnoStatNum[lIndex], lphnoStatNum[lIndex+1] );
                    }

                    GlobalUnlock(hgMem);  /* Movin' again.                */

                    /* Update the number by the "n=".                     */
                    SetDlgItemInt(hStatBox, IDC_NUMTEXT, lStatNum, FALSE);

                    dwSize=(DWORD)GlobalSize(hgMem); /* Get size of memory block.*/

                    /* Unallocate memory if not needed after data removal.*/
                    /* hMem is used so we don't possibly trach hgMem.     */
                    if ((lStatNum % lReAllocCount)==0)
                        if ((hMem=GlobalReAlloc(hgMem, dwSize-GMEMCHUNK, GMEM_ZEROINIT)))
                            hgMem=hMem;
                    return(TRUE);

                case IDC_CAD:
ClearItAll:
                    /* Nuke it all!                                       */
                    SendMessage(hListBox, LB_RESETCONTENT, 0L, 0L);
                    SetDlgItemInt(hStatBox, IDC_NUMTEXT, 0, FALSE);;

                    // Free the numobj's
                    lphnoStatNum=(HNUMOBJ *)GlobalLock(hgMem);
                    for( lIndex = 0; lIndex < lStatNum; lIndex++ )
                        NumObjDestroy( &lphnoStatNum[lIndex] );
                    GlobalUnlock(hgMem);

                    GlobalFree(hgMem); /* Drop the memory.                */
                    lStatNum = 0;
                    hgMem=GlobalAlloc(GHND, 0L); /* Get a CLEAN slate.    */
                    return(TRUE);
            }
    }
    return (FALSE);
}



/* Routine for functions AVE, SUM, DEV, and DATA.                         */

VOID  APIENTRY StatFunctions (WPARAM wParam)
    {
    LONG           lIndex; /* Temp index.                                 */
    DWORD          dwSize; /* Return value for GlobalSize.                */

    switch (wParam)
    {
        case IDC_DATA: /* Add current fpNum to listbox.                       */
            if ((lStatNum % lReAllocCount)==0)
            {
                /* If needed, allocate another 96 bytes.                  */

                dwSize=(DWORD)GlobalSize(hgMem);
                if (StatAlloc (1, dwSize))
                {
                    GlobalCompact((DWORD)-1L);
                    if (StatAlloc (1, dwSize))
                    {
                        StatError ();
                        return;
                    }
                }
                hgMem=hMem;
            }

            /* Add the display string to the listbox.                     */
            hListBox=GetDlgItem(hStatBox, IDC_STATLIST);

            lIndex=StatAlloc (2,0L);
            if (lIndex==LB_ERR || lIndex==LB_ERRSPACE)
            {
                GlobalCompact((DWORD)-1L);

                lIndex=StatAlloc (2,0L);
                if (lIndex==LB_ERR || lIndex==LB_ERRSPACE)
                {
                    StatError ();
                    return;
                }
            }

            /* Highlight last entered string.                             */
            SendMessage(hListBox, LB_SETCURSEL, (WORD)lIndex, 0L);

            /* Add the number and increase the "n=" value.                */
            lphnoStatNum=(HNUMOBJ *)GlobalLock(hgMem);

            NumObjAssign( &lphnoStatNum[lStatNum], ghnoNum );

            SetDlgItemInt(hStatBox, IDC_NUMTEXT, ++lStatNum, FALSE);
            break;

        case IDC_AVE: /* Calculate averages and sums.                         */
        case IDC_B_SUM: {
            DECLARE_HNUMOBJ( hnoTemp );

            lphnoStatNum=(HNUMOBJ *)GlobalLock(hgMem);

            /* Sum the numbers or squares, depending on bInv.             */
            NumObjAssign( &ghnoNum, HNO_ZERO );

            for (lIndex=0L; lIndex < lStatNum; lIndex++)
            {
                NumObjAssign( &hnoTemp, lphnoStatNum[lIndex] );
                if (bInv)
                {
                    DECLARE_HNUMOBJ( hno );
                    /* Get sum of squares.      */
                    NumObjAssign( &hno, hnoTemp );
                    mulrat( &hno, hnoTemp );
                    addrat( &ghnoNum, hno );
                    NumObjDestroy( &hno );
                }
                else
                {
                    /* Get sum.                          */
                    addrat( &ghnoNum, hnoTemp );
                }
            }

            if (wParam==IDC_AVE) /* Divide by lStatNum=# of items for mean.   */
            {
                DECLARE_HNUMOBJ( hno );
                if (lStatNum==0)
                {
                    DisplayError (SCERR_DIVIDEZERO);
                    break;
                }
                NumObjSetIntValue( &hno, lStatNum );
                divrat( &ghnoNum, hno );
                NumObjDestroy( &hno );
            }
            NumObjDestroy( &hnoTemp );
            /* Fall out for sums.                                         */
            break;
        }

        case IDC_DEV: { /* Calculate deviations.                                */
            DECLARE_HNUMOBJ(hnoTemp);
            DECLARE_HNUMOBJ(hnoX);
            DECLARE_HNUMOBJ( hno );

            if (lStatNum <=1) /* 1 item or less, NO deviation.            */
            {
                NumObjAssign( &ghnoNum, HNO_ZERO );
                return;
            }

            /* Get sum and sum of squares.                                */
            lphnoStatNum=(HNUMOBJ *)GlobalLock(hgMem);

            NumObjAssign( &ghnoNum, HNO_ZERO );
            NumObjAssign( &hnoTemp, HNO_ZERO );

            for (lIndex=0L; lIndex < lStatNum; lIndex++)
            {

                NumObjAssign(&hnoX, lphnoStatNum[lIndex]);

                addrat( &hnoTemp, hnoX );

                NumObjAssign( &hno, hnoX );
                mulrat( &hno, hnoX );
                addrat( &ghnoNum, hno );

            }


            /*      x- nx/n                               */
            /* fpTemp=fpNum-(fpTemp*fpTemp/(double)lStatNum);*/
            /*                                               */
            NumObjSetIntValue( &hno, lStatNum );
            NumObjAssign( &hnoX, hnoTemp );
            mulrat( &hnoX, hnoTemp );
            divrat( &hnoX, hno );
            NumObjAssign( &hnoTemp, ghnoNum );
            subrat( &hnoTemp, hnoX );


            /* All numbers are identical if fpTemp==0                     */
            if (NumObjIsZero( hnoTemp))
                NumObjAssign( &ghnoNum, HNO_ZERO); /* No deviation.          */
            else {
                /* If bInv=TRUE, divide by n (number of data) otherwise   */
                /* divide by n-1.                                         */
                /* fpNum=sqrt(fpTemp/(lStatNum-1+(LONG)bInv));            */
                //
                // hno still equals lStatNum
                if (!bInv) {
                    subrat( &hno, HNO_ONE );
                }
                divrat( &hnoTemp, hno );
                rootrat( &hnoTemp, HNO_TWO );
                NumObjAssign( &ghnoNum, hnoTemp );
            }
            NumObjDestroy( &hno );
            NumObjDestroy( &hnoX );
            NumObjDestroy( &hnoTemp );
            break;
        }
    }
    GlobalUnlock(hgMem); /* Da memwry is fwee to move as Findows fishes.  */
    return;
}


LONG NEAR StatAlloc (WORD wType, DWORD dwSize)
{
    LONG           lRet=FALSE;

    if (wType==1)
    {
        if ((hMem=GlobalReAlloc(hgMem, dwSize+GMEMCHUNK, GMEM_ZEROINIT)))
            return 0L;
    }
    else
    {
        lRet=(LONG)SendMessage(hListBox, LB_ADDSTRING, 0, (LONG_PTR)(LPTSTR)gpszNum);
        return lRet;
    }
    return 1L;
}


VOID NEAR StatError (VOID)
{
    TCHAR    szFoo[50];  /* This comes locally. Gets the Stat Box Caption. */

    MessageBeep(0);

    /* Error if out of room.                                              */
    GetWindowText(hStatBox, szFoo, 49);
    MessageBox(hStatBox, rgpsz[IDS_STATMEM], szFoo, MB_OK);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\calc\unifunc.c ===
/****************************Module*Header***********************************\
* Module Name: UNIFUNC.C
*
* Module Descripton: Number to string conversion routines for Unicode
*
* Warnings:
*
* Created:  22-Aug-1995
*
* Author:   JonPa
\****************************************************************************/
#include <windows.h>
#include "scicalc.h"

#define CCH_DWORD   15  // enough for 9 chars in 2^32 + sign, zterm + slop

//
// NOTE!
//
//  Even though this function uses psz++ and psz--,
//      **IT IS STILL INTERNATIONAL SAFE!**
//
//  That is because we put the chars in the string, and
//  we are only ever using chars that are single byte in ALL
//  code pages ('0'..'9').
//
TCHAR *UToDecT( UINT value, TCHAR *sz) {
    TCHAR szTmp[CCH_DWORD];
    LPTSTR psz = szTmp;
    LPTSTR pszOut;

    do {
        *psz++ = TEXT('0') + (value % 10);

        value = value / 10;
    } while( value != 0 );

    for( psz--, pszOut = sz; psz >= szTmp; psz-- )
        *pszOut++ = *psz;

    *pszOut = TEXT('\0');

    return sz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\auditchk.h ===
/******************************************************************************

                        A U D I T   C H E C K

    Name:       auditchk.h
    Date:       1/20/94
    Creator:    John Fu

    Description:
        This is the header file for auditchk.c

******************************************************************************/




#define AUDIT_PRIVILEGE_CHECK 0
#define AUDIT_PRIVILEGE_ON    1
#define AUDIT_PRIVILEGE_OFF   2



BOOL AuditPrivilege(
    int fAudit);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\auditchk.c ===
/*****************************************************************************

                                A U D I T

    Name:       audit.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:

*****************************************************************************/



#include <windows.h>
#include "clipbook.h"
#include "auditchk.h"



//////////////////////////////////////////////////////////////////////////
//
// Purpose: Tests, enables, or disables the Security privilege, which
//    allows auditing to take place.
//
// Parameters:
//    fAudit - Flag, which can take on one of these values:
//       AUDIT_PRIVILEGE_CHECK - Turns on Security, then turns it off.
//          Used to test whether you CAN edit auditing.
//       AUDIT_PRIVILEGE_ON    - Turns on auditing privilege.
//       AUDIT_PRIVILEGE_OFF   - Turns off auditing privilege.
//
// Return: TRUE if the function succeeds, FALSE on failure.
//
//////////////////////////////////////////////////////////////////////////

BOOL AuditPrivilege(
    int fAudit)
{
HANDLE              hToken;
LUID                SecurityValue;
TOKEN_PRIVILEGES    tkp;
BOOL                fOK = FALSE;


    /* Retrieve a handle of the access token. */

    if (OpenProcessToken (GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hToken))
        {
        /*
         * Enable the SE_SECURITY_NAME privilege or disable
         * all privileges, depending on the fEnable flag.
         */

        if (LookupPrivilegeValue ((LPSTR)NULL,
                                  SE_SECURITY_NAME,
                                  &SecurityValue))
            {
            tkp.PrivilegeCount     = 1;
            tkp.Privileges[0].Luid = SecurityValue;


            // Try to turn on audit privilege

            if (AUDIT_PRIVILEGE_CHECK == fAudit || AUDIT_PRIVILEGE_ON == fAudit)
                {
                tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                AdjustTokenPrivileges (hToken,
                                       FALSE,
                                       &tkp,
                                       sizeof(TOKEN_PRIVILEGES),
                                       (PTOKEN_PRIVILEGES)NULL,
                                       (PDWORD)NULL);

                /* The return value of AdjustTokenPrivileges be texted. */
                if (GetLastError () == ERROR_SUCCESS)
                    {
                    fOK = TRUE;
                    }
                }


            // Try to turn OFF audit privilege

            if (AUDIT_PRIVILEGE_CHECK == fAudit || AUDIT_PRIVILEGE_OFF == fAudit)
                {
                AdjustTokenPrivileges (hToken,
                                       TRUE,
                                       NULL,
                                       0L,
                                       (PTOKEN_PRIVILEGES)NULL,
                                       (PDWORD)NULL);

                if (ERROR_SUCCESS == GetLastError () &&
                    AUDIT_PRIVILEGE_OFF == fAudit)
                    {
                    fOK = TRUE;
                    }
                }
            }
        }

    return fOK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\callback.c ===
/*****************************************************************************

                            D D E   C A L L B A C K

    Name:       callback.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:

    History:
        Date        Description
        ----------- -------------------------------------------------------
        10-Apr-1996 johnfu, added retry count for RQ_PREVBITMAP
        03-Nov-1997 drewm, added code to fix bug 3168
*****************************************************************************/





#include <windows.h>

#include "common.h"
#include "clipbook.h"
#include "clipbrd.h"
#include "callback.h"
#include "debugout.h"
#include "cvutil.h"





// internal forwards

static HWND GetConvHwnd ( HCONV hConv );




/*
 *      DdeCallback
 *
 *  ddeml callback routine
 */

HDDEDATA EXPENTRY DdeCallback(
    WORD        wType,
    WORD        wFmt,
    HCONV       hConv,
    HSZ         hszTopic,
    HSZ         hszItem,
    HDDEDATA    hData,
    DWORD       lData1,
    DWORD       lData2)
{
HWND        hwndTmp;
CONVINFO    ConvInfo;
PDATAREQ    pDataReq;


    switch (wType)
        {
        case XTYP_ADVDATA:
            if ( hwndTmp = GetConvHwnd ( hConv ) )
                {
                InitListBox ( hwndTmp, hData );
                }
            return FALSE;
            break;

        case XTYP_DISCONNECT:
            ConvInfo.cb = sizeof(CONVINFO);
            if (DdeQueryConvInfo ( hConv, (DWORD)QID_SYNC, &ConvInfo ) == 0)
                {
                PERROR(TEXT("DdeQueryConvInfo for %p failed: %x\n\r"),
                   (DWORD_PTR)hConv, DdeGetLastError(idInst));
                break;
                }
            if (pDataReq = (PDATAREQ)ConvInfo.hUser)
                {
                PINFO(TEXT("Freeing data req on %lx at disconnect time\n\r"), hConv);
                MessageBoxID (hInst, hwndApp, IDS_PRIVILEGEERROR, IDS_APPNAME,
                              MB_OK | MB_ICONSTOP);
                ProcessDataReq   (0, pDataReq);
                DeleteDataReq    (pDataReq);
                DdeSetUserHandle (hConv, (DWORD)QID_SYNC, 0L);
                }
            else
                {
                PINFO(TEXT("Disconnect received on %lx - no datareq\n\r"), hConv );
                }
            break;

        case XTYP_XACT_COMPLETE:
            ConvInfo.cb = sizeof(CONVINFO);
            if ( DdeQueryConvInfo ( hConv, (DWORD)QID_SYNC, &ConvInfo ) == 0 )
                {
                PERROR(TEXT("DdeQueryConvInfo for %p failed: %x\n\r"),
                   (DWORD_PTR)hConv, DdeGetLastError(idInst));
                break;
                }

            PINFO(TEXT("dde callback: got %lx data from conv handle %p\n\r"),
                ConvInfo.hUser, (DWORD_PTR)hConv );

            pDataReq = (PDATAREQ)ConvInfo.hUser;

            if (hData)
                ProcessDataReq (hData,  pDataReq);
            else
                {
                if (RQ_PREVBITMAP == pDataReq->rqType &&
                    pDataReq->wRetryCnt)
                    {
                    LPLISTENTRY lpLE;
                    HWND        hwnd;
                    INT         iItem;
                    WORD        wRetryCnt;

                    wRetryCnt = pDataReq->wRetryCnt;
                    hwnd      = pDataReq->hwndMDI;
                    iItem     = pDataReq->iListbox;

                    SendMessage (GETMDIINFO(hwnd)->hWndListbox,
                                 LB_GETTEXT,
                                 iItem,
                                 (LPARAM)&lpLE);

                    GetPreviewBitmap (hwnd, lpLE->name, iItem);

                    pDataReq->wRetryCnt = wRetryCnt -1;
                    break;
                    }

                RequestXactError (hConv);
                XactMessageBox (hInst, hwndApp, IDS_APPNAME, MB_OK | MB_ICONSTOP);
                }


            DdeSetUserHandle (hConv, (DWORD)QID_SYNC, 0L);


            if (pDataReq->fDisconnect)
                {
                DdeDisconnect (hConv);
                }

            DeleteDataReq (pDataReq);
            break;

        case XTYP_REGISTER:
        case XTYP_UNREGISTER:
        case XTYP_ADVREQ:
        case XTYP_REQUEST:
        case XTYP_ADVSTART:
        case XTYP_CONNECT_CONFIRM:
        case XTYP_CONNECT:
        default:
            break;
        }

    return 0;

}






/*
 *      GetConvHwnd
 *
 *  this function retrieves the window handle associated with
 *  a conversation handle - the hande is put there by
 *  using DdeSetUserHandle at DdeConnect time
 */

static HWND GetConvHwnd ( HCONV hConv )
{
CONVINFO    ConvInfo;
PDATAREQ    pDataReq;


    ConvInfo.cb = sizeof(CONVINFO);
    if ( DdeQueryConvInfo ( hConv, (DWORD)QID_SYNC, &ConvInfo ) == 0 )
        {
        PERROR(TEXT("DdeQueryConvInfo for %p failed: %x\n\r"),
           (DWORD_PTR)hConv, DdeGetLastError(idInst));
        }

    pDataReq = (PDATAREQ)ConvInfo.hUser;

    PINFO(TEXT("GetConvHwnd: got %p as conv handle\r\n"), pDataReq);

    if ( !IsWindow ( pDataReq->hwndMDI ) )
        {
        PERROR(TEXT("Invalid window %p in conv Uhandle: %p!\n\r"),
           (DWORD_PTR)pDataReq->hwndMDI, (DWORD_PTR)hConv );
        return NULL;
        }

    return pDataReq->hwndMDI;

}









/*
 *      GetClipsrvVersion
 *
 *  Purpose: Get the version of Clipsrv connected to the given MDI
 *     child.
 *
 *  Parameters:
 *     hwndChild - The child window.
 *
 *  Returns:
 *     A version number with the Clipsrv OS version in the hiword, and
 *     the Clipsrv version in the loword.
 *
 *     Hiword values:
 *        0 - Win 3.x
 *        1 - NT 1.x
 *
 *     Loword values:
 *        0 - WFW 1.0 Clipsrv
 *        1 - NT  1.0 Clipsrv, adds [version] and [security] executes
 */

DWORD GetClipsrvVersion(
    HWND    hwndChild)
{
MDIINFO     *pMDI;
HDDEDATA    hdde;
DWORD       dwRet;
char        *lpszDDE;


    dwRet = 0;

    if (!(pMDI = GETMDIINFO(hwndChild)))
        return 0;


    if (!(pMDI->flags & F_CLPBRD))
        {
        hdde = MySyncXact (SZCMD_VERSION,
                           lstrlen(SZCMD_VERSION) + 1,
                           pMDI->hExeConv,
                           0L,
                           CF_TEXT,
                           XTYP_EXECUTE,
                           SHORT_SYNC_TIMEOUT, NULL);

        if (hdde)
            {
            lpszDDE = (char *)DdeAccessData(hdde, &dwRet);

            if (lpszDDE)
                {
                dwRet = MAKELONG(lpszDDE[0] - '0', lpszDDE[2] - '0');
                }
            else
                {
                dwRet = 0L;
                }

            DdeUnaccessData (hdde);
            DdeFreeDataHandle (hdde);
            }
        else
            {
            PINFO(TEXT("Clipsrv didn't like version execute\r\n"));
            }
        }
    else
        {
        PERROR(TEXT("No Clipsrv for clipboard!\r\n"));
        }

    return dwRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\clipbook.h ===
/*****************************************************************************

                        C L I P B O O K   H E A D E R

    Name:       clipbook.h
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This is the header file for all files in clipview directory.

    History:
        21-Jan-1994     John Fu, reformat, cleanup, and removed all externs.

*****************************************************************************/




#include   <commdlg.h>
#include   <ddeml.h>
#include   <nddeapi.h>
#include   "clpbkrc.h"
#include   "vclpbrd.h"






#define SetStatusBarText(x) if(hwndStatus)SendMessage(hwndStatus, SB_SETTEXT, 1, (LPARAM)(LPSTR)(x));







/**********************

    Data structures

**********************/



/*
 *  Per MDI client data
 */

struct MdiInfo {
   HCONV    hExeConv;                       // Used for sync transaction only
   HCONV    hClpConv;                       // Used for async transaction only
   HSZ      hszClpTopic;
   HSZ      hszConvPartner;
   HSZ      hszConvPartnerNP;
   HWND     hWndListbox;
   WORD     DisplayMode;
   WORD     OldDisplayMode;
   DWORD    flags;

   TCHAR    szBaseName[ (MAX_COMPUTERNAME_LENGTH+1) * 2];

   TCHAR    szComputerName[MAX_COMPUTERNAME_LENGTH + 1];

   UINT     CurSelFormat;
   LONG     cyScrollLast;
   LONG     cyScrollNow;
   int      cxScrollLast;
   int      cxScrollNow;
   RECT     rcWindow;
   WORD     cyLine, cxChar, cxMaxCharWidth; // Size of a standard text char
   WORD     cxMargin, cyMargin;             // White border size around clip data area
   BOOL     fDisplayFormatChanged;

   PVCLPBRD pVClpbrd;
   HCONV    hVClpConv;
   HSZ      hszVClpTopic;

   // scrollbars, etc. for the paging control

   HWND     hwndVscroll;
   HWND     hwndHscroll;
   HWND     hwndSizeBox;
   HWND     hwndPgUp;
   HWND     hwndPgDown;
};





typedef struct MdiInfo   MDIINFO;
typedef struct MdiInfo * PMDIINFO;
typedef struct MdiInfo FAR * LPMDIINFO;










/*
 *  data request record
 */

#define      RQ_PREVBITMAP   10
#define      RQ_COPY         11
#define      RQ_SETPAGE      12
#define      RQ_EXECONV      13

struct DataRequest_tag
   {
   WORD   rqType;      // one of above defines
   HWND   hwndMDI;
   HWND   hwndList;
   UINT   iListbox;
   BOOL   fDisconnect;
   WORD   wFmt;
   WORD   wRetryCnt;
   };

typedef struct DataRequest_tag DATAREQ;
typedef struct DataRequest_tag * PDATAREQ;







/*
 *  Owner draw listbox data structure
 */

#define MAX_PAGENAME_LENGTH MAX_NDDESHARENAME

struct ListEntry_tag
   {
   TCHAR name[MAX_PAGENAME_LENGTH + 1];
   HBITMAP hbmp;
   BOOL fDelete;
   BOOL fTriedGettingPreview;
   };

typedef struct ListEntry_tag LISTENTRY;
typedef struct ListEntry_tag * PLISTENTRY;
typedef struct ListEntry_tag FAR * LPLISTENTRY;








/*
 *  Extra window data for MDI child registerclass
 *  contains a pointer to above MDIINFO struct
 */

#define GWL_MDIINFO     0
#define CBWNDEXTRA      sizeof(LONG_PTR)

// per MDI window flags - used for MDIINFO.flags

#define F_LOCAL         0x00000001
#define F_CLPBRD        0x00000002

// per MDI display mode - MDIINFO.DisplayMode

#define DSP_LIST        10
#define DSP_PREV        11
#define DSP_PAGE        12






/*
 *  Data structure used to pass share info to SedCallback
 */

typedef struct
   {
   SECURITY_INFORMATION si;
   WCHAR awchCName[MAX_COMPUTERNAME_LENGTH + 3];
   WCHAR awchSName[MAX_NDDESHARENAME + 1];
   }
   SEDCALLBACKCONTEXT;








/*
 *  Data structure passed to KeepAsDialogProc (Paste)
 */

typedef struct
    {
    BOOL    bAlreadyExist;
    BOOL    bAlreadyShared;
    TCHAR   ShareName[MAX_NDDESHARENAME +2];
    }
    KEEPASDLG_PARAM, *PKEEPASDLG_PARAM;






/*************

    Macros

*************/



#define PRIVATE_FORMAT(fmt)     ((fmt) >= 0xC000)
#define GETMDIINFO(x)           (x? (PMDIINFO)(GetWindowLongPtr((x),GWL_MDIINFO)): NULL)



// parameter codes for MyGetFormat()
#define GETFORMAT_LIE       200
#define GETFORMAT_DONTLIE   201


// default DDEML synchronous transaction timeouts
// note these should be generous
#define SHORT_SYNC_TIMEOUT  (24L*1000L)
#define LONG_SYNC_TIMEOUT   (60L*1000L)


// owner draw listbox and bitmap metrics constants
#define LSTBTDX             16              // width of folder ( with or without hand )
#define LSTBTDY             16              // height of folder ( with or without hand )

#define SHR_PICT_X          0               // offsets of shared folder bitmap
#define SHR_PICT_Y          0
#define SAV_PICT_X          16              // offsets of non-shared folder bitmap
#define SAV_PICT_Y          0

#define PREVBRD             4               // border around preview bitmaps

#define BTNBARBORDER        2
#define DEF_WIDTH           400             // initial app size
#define DEF_HEIGHT          300

#define SZBUFSIZ            MAX_DDE_EXEC

#define ARRAYSIZE(a)        (sizeof(a)/sizeof((a)[0]))




// combined styles for owner draw listbox variants
#define LBS_LISTVIEW        (LBS_OWNERDRAWFIXED|LBS_DISABLENOSCROLL)
#define LBS_PREVIEW         (LBS_MULTICOLUMN|LBS_OWNERDRAWFIXED)





//////////// compile options //////////////
#define MAX_ALLOWED_PAGES       127



#define WINDOW_MENU_INDEX       4
#define DISPLAY_MENU_INDEX      3   // submenu to put format entries i.e. "&Text"
#define SECURITY_MENU_INDEX     2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\callback.h ===
/*****************************************************************************

                        D D E   C A L L B A C K

    Name:       callback.h
    Date:       21-Jan-1994
    Creator:    John Fu

    Description:
        This is the header file for callback.c

*****************************************************************************/



HDDEDATA EXPENTRY DdeCallback(
    WORD        wType,
    WORD        wFmt,
    HCONV       hConv,
    HSZ         hszTopic,
    HSZ         hszItem,
    HDDEDATA    hData,
    DWORD       lData1,
    DWORD       lData2);


DWORD GetClipsrvVersion(
    HWND    hwndChild);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\clipdsp.h ===
/*****************************************************************************

                C L I P B O O K   D I S P L A Y   H E A D E R

    Name:       clipdsp.h
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This is the header file for clipdsp.c

    History:
        21-Jan-1994     John Fu, reformat and cleanup.

*****************************************************************************/


#define VPOSLAST        100     // Highest vert scroll bar value
#define HPOSLAST        100     // Highest horiz scroll bar value
#define BUFFERLEN       160     // String buffer length

#define CBM_AUTO        WM_USER


extern  BOOL        fOwnerDisplay;
extern  HBRUSH      hbrBackground;
extern  HMENU       hDispMenu;

extern  int         OwnVerMin;
extern  int         OwnVerMax;
extern  int         OwnHorMin;
extern  int         OwnHorMax;

extern  int         OwnVerPos;
extern  int         OwnHorPos;

extern  WORD        rgfmt[];



BOOL MyOpenClipboard(
    HWND    hWnd);


void SetCharDimensions(
    HWND    hWnd,
    HFONT   hFont);


void ChangeCharDimensions(
    HWND    hwnd,
    UINT    wOldFormat,
    UINT    wNewFormat);


void ClipbrdVScroll(
    HWND    hwnd,
    WORD    wParam,
    WORD    wThumb);


void ClipbrdHScroll(
    HWND    hwnd,
    WORD    wParam,
    WORD    wThumb);


int DibPaletteSize(
    LPBITMAPINFOHEADER  lpbi);


void DibGetInfo(
    HANDLE      hdib,
    LPBITMAP    pbm);


BOOL DrawDib(
    HWND    hwnd,
    HDC     hdc,
    int     x0,
    int     y0,
    HANDLE  hdib);


BOOL FShowDIBitmap(
    HWND            hwnd,
    register HDC    hdc,
    PRECT           prc,
    HANDLE          hdib,   //Bitmap in DIB format
    int             cxScroll,
    int             cyScroll);


BOOL FShowBitmap(
    HWND            hwnd,
    HDC             hdc,
    register PRECT  prc,
    HBITMAP         hbm,
    int             cxScroll,
    int             cyScroll);


BOOL FShowPalette(
    HWND hwnd,
    register HDC    hdc,
    register PRECT  prc,
    HPALETTE        hpal,
    int             cxScroll,
    int             cyScroll);


int PxlConvert(
    int mm,
    int val,
    int pxlDeviceRes,
    int milDeviceRes);


BOOL FShowEnhMetaFile(
    HWND            hwnd,
    register HDC    hdc,
    register PRECT  prc,
    HANDLE          hemf,
    int             cxScroll,
    int             cyScroll);


BOOL CALLBACK EnumMetafileProc(
    HDC             hdc,
    HANDLETABLE FAR *lpht,
    METARECORD FAR  *lpmr,
    int             cObj,
    LPARAM          lParam);


BOOL FShowMetaFilePict(
    HWND            hwnd,
    register HDC    hdc,
    register PRECT  prc,
    HANDLE          hmfp,
    int             cxScroll,
    int             cyScroll);


void ShowString(
    HWND    hwnd,
    HDC     hdc,
    WORD    id);


LONG CchLineA(
    PMDIINFO    pMDI,
    HDC         hDC,
    CHAR        rgchBuf[],
    CHAR FAR    *lpch,
    INT         cchLine,
    WORD        wWidth);


LONG CchLineW(
    PMDIINFO    pMDI,
    HDC         hDC,
    WCHAR       rgchBuf[],
    WCHAR FAR   *lpch,
    INT         cchLine,
    WORD        wWidth);


void ShowText(
    HWND            hwnd,
    register HDC    hdc,
    PRECT           prc,
    HANDLE          h,
    INT             cyScroll,
    BOOL            fUnicode);


void SendOwnerMessage(
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam);


void SendOwnerSizeMessage (
    HWND    hwnd,
    int     left,
    int     top,
    int     right,
    int     bottom);


UINT GetBestFormat(
    HWND    hwnd,
    UINT    wFormat);


void GetClipboardName (
    register int    fmt,
    LPTSTR          szName,
    register int    iSize);


void DrawFormat(
    register HDC    hdc,
    PRECT           prc,
    int             cxScroll,
    int             cyScroll,
    WORD            BestFormat,
    HWND            hwndMDI);


void DrawStuff(
    HWND                    hwnd,
    register PAINTSTRUCT    *pps,
    HWND                    hwndMDI);


void SaveOwnerScrollInfo (
    register HWND   hwnd);


void RestoreOwnerScrollInfo (
    register HWND   hwnd);


void InitOwnerScrollInfo(void);


void UpdateCBMenu(
    HWND    hwnd,
    HWND    hwndMDI);


BOOL ClearClipboard (
    register HWND   hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\clpbkdlg.h ===
#define IDD_CONNECT                 100
#define IDC_CONNECTNAME             101
#define IDD_KEEPASDLG               300
#define IDC_KEEPASEDIT              301
#define IDC_STATICPAGENAME          302
#ifndef IDHELP
#define IDHELP                      303
#endif
#define IDC_SHARECHECKBOX           304
#define IDD_SHAREDLG                200
#define IDD_PROPERTYDLG             400
#define IDC_STATICSHRNAME           201
#define IDC_STARTAPP                203
#define IDC_APPINIT                 204
#define IDC_STATICSHARENAME         212
#define IDC_PERMISSIONS             202
#define IDC_MINIMIZED               215
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\clpbkrc.h ===
/*****************************************************************************

                C L I P B O O K   R E S O U R C E S   H E A D E R

    Name:       clpblkrc.h
    Date:       21-Jan-1994
    Creator:    John Fu

    Description:
        This file contains definitions of the resource IDs.

*****************************************************************************/


// resource ID's
#define     IDACCELERATORS      1
#define     IDFRAMEICON         2
#define     IDI_CLIPBRD         3
#define     IDI_CLIPBOOK        4
#define     IDI_REMOTE          5
#define     IDBITMAP            6
#define     IDSTATUS            7
#define     IDCVMENU            8
#define     IBM_UPARROW         9
#define     IBM_DNARROW         10
#define     IBM_UPARROWD        11
#define     IBM_DNARROWD        12
#define     IDLOCKICON          13
#define     IDSHAREICON         14
#define     IDC_TOOLBAR         401

#define     IDC_CLIPBOOK        16
#define     IDC_CLIPBRD         17
#define     IDC_REMOTE          18



// user defined messages
#define     WM_CLOSE_REALLY     WM_USER
#define     WM_F1DOWN           (WM_USER + 1)




// menuhelp constants
#define     MH_BASE             10000
#define     MH_POPUPBASE        0x1100
#define     MH_TOOLTIP          0x1200
#define     IDH_FORMATS_BASE    10400
#define     IDH_BASE            10000


/*
 *  main menu items
 */

#define IDM_FIRST               20

#define IDM_ABOUT               20
#define IDM_EXIT                21
#define IDM_COPY                22
#define IDM_DELETE              23
#define IDM_SHARE               24
#define IDM_LOCAL               25
#define IDM_PROPERTIES          26
#define IDM_OPEN                27
#define IDM_SAVEAS              28
#define IDM_NOP                 29
#define IDM_CONNECT             30
#define IDM_DISCONNECT          31
#define IDM_CONTENTS            32
#define IDM_SEARCHHELP          33
#define IDM_HELPHELP            34
#define IDM_KEEP                35
#define IDM_UNSHARE             36
#define IDM_TOOLBAR             37
#define IDM_STATUSBAR           38
#define IDM_TILEVERT            39
#define IDM_CASCADE             40
#define IDM_ARRANGEICONS        41
#define IDM_CLPWND              43
#define IDM_REFRESH             44
#define IDM_LISTVIEW            45
#define IDM_PREVIEWS            46
#define IDM_PAGEVIEW            47
#define IDM_TILEHORZ            48
#define IDM_PERMISSIONS         49
#define IDM_AUDITING            50
#define IDM_OWNER               51
#define IDM_PASTE_PAGE          52

// following have no actual menu items
#define IDM_UPDATE_PAGEVIEW     53

#define IDM_LAST                53




// strings
#define IDS_HELV                21
#define IDS_APPNAME             22
#define IDS_SHROBJNAME          23
#define IDS_INTERNALERR         26
#define IDS_LOCALCLIP           27
#define IDS_CLIPBOARD           28
#define IDS_DATAUNAVAIL         29
#define IDS_READINGITEM         30
#define IDS_VIEWHELPFMT         31
#define IDS_ACTIVATEFMT         32
#define IDS_RENDERING           33
#define IDS_DEFFORMAT           34
#define IDS_GETTINGDATA         35
#define IDS_NAMEEXISTS          36
#define IDS_NOCONNECTION        38
#define IDS_ESTABLISHING        39
#define IDS_CLIPBOOKONFMT       40
#define IDS_PAGEFMT             41
#define IDS_PAGEFMTPL           42
#define IDS_PAGEOFPAGEFMT       43
#define IDS_DELETE              44
#define IDS_DELETECONFIRMFMT    45
#define IDS_FILEFILTER          46
#define IDS_PASTEDLGTITLE       47
#define IDS_SHAREDLGTITLE       48
#define IDS_PAGENAMESYNTAX      49
#define IDS_PASSWORDSYNTAX      50
#define IDS_SHARINGERROR        51
#define IDS_MAXPAGESERROR       52
#define IDS_PRIVILEGEERROR      53
#define IDS_CB_PAGE             54
#define IDS_NOCLPBOOK           55
#define IDS_GETPERMS            56
#define IDS_FILTERTEXT          57      // Filter string in FileType combo-box
#define IDS_TSNOTSUPPORTED      58      // Not Supported from a remote session

// Header text string ids
#define IDS_ERROR               202     // as string ids.  Be sure to keep these
#define IDS_BINARY              203     // different.
#define IDS_CLEAR               204
#define IDS_CANTDISPLAY         207     // "Can't display data in this format"
#define IDS_NOTRENDERED         208     // "Application Couldn't render data"
#define IDS_ALREADYOPEN         209     // OpenClipboard() fails */
#define IDS_MEMERROR            210

// clausgi addition.. planes/bitsperpixel don't match...
#define IDS_BADBMPFMT           211
#define IDS_CLEARTITLE          212
#define IDS_CONFIRMCLEAR        213

#define IDS_TRUSTSHRKEY         256
#define IDS_CLPBKKEY            257


// First permission name -- starts an array of permnames.
#define IDS_PERMNAMEFIRST       0x0400
#define IDS_AUDITNAMEFIRST      0x0500

// control ID's
#define ID_LISTBOX              200
#define ID_VSCROLL              201
#define ID_HSCROLL              202
#define ID_SIZEBOX              203
#define ID_PAGEUP               204
#define ID_PAGEDOWN             205

// For "Special" Text
#define IDS_SPECIAL             1000

//For Menu string of Clipboard Format name.
#define MNDELTA                 500
#define CF_MN_TEXT              CF_TEXT            + MNDELTA
#define CF_MN_BITMAP            CF_BITMAP          + MNDELTA
#define CF_MN_METAFILEPICT      CF_METAFILEPICT    + MNDELTA
#define CF_MN_SYLK              CF_SYLK            + MNDELTA
#define CF_MN_DIF               CF_DIF             + MNDELTA
#define CF_MN_TIFF              CF_TIFF            + MNDELTA
#define CF_MN_OEMTEXT           CF_OEMTEXT         + MNDELTA
#define CF_MN_DIB               CF_DIB             + MNDELTA
#define CF_MN_PALETTE           CF_PALETTE         + MNDELTA
#define CF_MN_PENDATA           CF_PENDATA         + MNDELTA
#define CF_MN_RIFF              CF_RIFF            + MNDELTA
#define CF_MN_WAVE              CF_WAVE            + MNDELTA
#define CF_MN_OWNERDISPLAY      CF_OWNERDISPLAY    + MNDELTA
#define CF_MN_DSPTEXT           CF_DSPTEXT         + MNDELTA
#define CF_MN_DSPBITMAP         CF_DSPBITMAP       + MNDELTA
#define CF_MN_DSPMETAFILEPICT   CF_DSPMETAFILEPICT + MNDELTA
#define CF_MN_ENHMETAFILE       CF_ENHMETAFILE     + MNDELTA
#define CF_MN_DSPENHMETAFILE    CF_DSPENHMETAFILE  + MNDELTA
#define CF_MN_UNICODETEXT       CF_UNICODETEXT     + MNDELTA
#define CF_MN_HDROP             CF_HDROP           + MNDELTA
#define CF_MN_LOCALE            CF_LOCALE          + MNDELTA

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\clipbrd.c ===
/*****************************************************************************

                            C L I P B O A R D

    Name:       clipbrk.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This is the main clipbrd module.  It has the program entry point,
        the windows procedures and some major supporting functions.

*****************************************************************************/


#define WIN31
#define STRICT

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <lm.h>
#include <nddeapi.h>
#include <nddeagnt.h>
#include <stdio.h>
#include <htmlhelp.h>
#include <strsafe.h>

#include "common.h"
#include "clipbook.h"
#include "clipbrd.h"
#include "dialogs.h"
#include "clipdsp.h"
#include "cvutil.h"
#include "cvinit.h"
#include "auditchk.h"
#include "callback.h"
#include "debugout.h"
#include "helpids.h"
#include "initmenu.h"
#include "cvcomman.h"
#include "clipfile.h"
#include "strtok.h"
#include "security.h"



#ifndef UNICODE_CHARSET
#define UNICODE_CHARSET 1
#endif



//
// return code of OnPaint
//

#define ONPAINT_FAIL        0
#define ONPAINT_SUCCESS     1
#define ONPAINT_NOCLIPBRD   2



typedef  UINT (WINAPI *WNETCALL)(HWND, LPSTR, LPSTR, WORD, DWORD );



// Static data

static HHOOK    hMsgFilterHook;

// Stuff for dealing with minimized MDI children

static HCURSOR  hcurClipbook;
static HCURSOR  hcurClipbrd;
static HCURSOR  hcurRemote;
static BOOL     fClpOpen;


HANDLE  hmutexClp;                      // clipboard mutex
HANDLE  hXacting;                       // transaction event
HANDLE  hmodNetDriver;

HICON   hicClipbrd;
HICON   hicClipbook;
HICON   hicRemote;

HICON   hicLock;                        // Icon for Lock on thumbnail bitmaps
HFONT   hfontUni;                       // Handle for Unicode font, if it exists


// Application-wide flags

BOOL    fStatus;                         // status bar shown?
BOOL    fToolBar;                        // tool bar shown?
BOOL    fShareEnabled;                   // sharing allowed in system.ini?
BOOL    fNetDDEActive = TRUE;            // NetDDE detected?
BOOL    fAppLockedState = FALSE;         // app UI locked (see LockApp())
BOOL    fClipboardNeedsPainting = FALSE; // indicates deferred clp paint
BOOL    fSharePreference;                // shared checked on paste?
BOOL    fNeedToTileWindows = FALSE;      // need to tile windows on size
BOOL    fAppShuttingDown = FALSE;        // in process of closing
BOOL    fFillingClpFromDde = FALSE;      // in process of adding clp formats
BOOL    fAuditEnabled;

HWND    hwndNextViewer = NULL;           // for clpbrd viewer chain
HWND    hwndDummy;                       // used as dummy SetCapture target



// special case clipboard formats

UINT    cf_bitmap;                      // we send/receive these in private 'packed' format
UINT    cf_metafilepict;
UINT    cf_palette;
UINT    cf_preview;                     // PREVBMPSIZxPREVBMPSIZ preview bitmap private format



// these are formats that contain untranslated copies of link and objlink data

UINT    cf_objectlinkcopy;
UINT    cf_objectlink;
UINT    cf_linkcopy;
UINT    cf_link;



// DDEML
// These are effective constants created once and destroyed when we die

HSZ     hszSystem;
HSZ     hszTopics;
HSZ     hszDataSrv;
HSZ     hszFormatList;
HSZ     hszClpBookShare;

DWORD   idInst = 0;


DWORD   dwCurrentHelpId = 0L;



// instance proc from MSGF_DDEMGR filter

WINDOWPLACEMENT Wpl;
HOOKPROC        lpMsgFilterProc;
HINSTANCE       hInst;
HACCEL          hAccel;

HFONT           hOldFont;
HFONT           hFontStatus;
HFONT           hFontPreview;


HWND        hwndActiveChild = 0;    // this handle identifies the currently active MDI window

PMDIINFO    pActiveMDI = NULL;      // this pointer points to the MDI info struct of the
                                    // active MDI window IT SHOULD ALWAYS ==
                                    // GETMDIINFO(hwndActiveChild)


HWND        hwndClpbrd = 0;         // this handle identifies the clipboard window
HWND        hwndLocal = 0;          // this handle identifies the local clipbook window
HWND        hwndClpOwner = 0;       // this handle identifies the clipboard owning MDI child (if any)
HWND        hwndMDIClient;          // handle to MDI Client window
HWND        hwndApp;                // global app window
HDC         hBtnDC;                 // memory DC used for owner draw stuff
HBITMAP     hOldBitmap;
HBITMAP     hPreviewBmp;
HBITMAP     hPgUpBmp;
HBITMAP     hPgDnBmp;
HBITMAP     hPgUpDBmp;
HBITMAP     hPgDnDBmp;

int         dyStatus;               // height of status bar
int         dyButtonBar;            // height of button bar
int         dyPrevFont;             // height of listbox font - height+external

TCHAR       szHelpFile[]      = TEXT("clipbrd.hlp");
TCHAR       szChmHelpFile[]   = TEXT("clipbrd.chm");

TCHAR       szClipBookClass[] = TEXT("ClipBookWClass");     // frame window class
TCHAR       szChild[] = TEXT("CVchild");                    // Class name for MDI window
TCHAR       szDummy[] = TEXT("CVdummy");                    // class name of hidden dummy window

TCHAR       szNDDEcode[] = TEXT("NDDE$");
TCHAR       szNDDEcode1[] = TEXT("NDDE$0001");
TCHAR       szClpBookShare[] = TEXT("CLPBK$");


// localized strings
TCHAR       szHelv[SMLRCBUF];   // status line font
TCHAR       szAppName[SMLRCBUF];
TCHAR       szLocalClpBk[SMLRCBUF];
TCHAR       szSysClpBrd[SMLRCBUF];
TCHAR       szDataUnavail[BIGRCBUF];
TCHAR       szReadingItem[BIGRCBUF];
TCHAR       szViewHelpFmt[BIGRCBUF];
TCHAR       szActivateFmt[BIGRCBUF];
TCHAR       szRendering[BIGRCBUF];
TCHAR       szDefaultFormat[BIGRCBUF];
TCHAR       szGettingData[BIGRCBUF];
TCHAR       szEstablishingConn[BIGRCBUF];
TCHAR       szClipBookOnFmt[BIGRCBUF];
TCHAR       szPageFmt[SMLRCBUF];
TCHAR       szPageFmtPl[SMLRCBUF];
TCHAR       szPageOfPageFmt[SMLRCBUF];
TCHAR       szDelete[SMLRCBUF];
TCHAR       szDeleteConfirmFmt[SMLRCBUF];
TCHAR       szFileFilter[BIGRCBUF];
TCHAR       *szFilter;



// Registry key strings
TCHAR       szRoot[128];
TCHAR       szPref[]      = TEXT("Preferences");
TCHAR       szConn[]      = TEXT("Connections");
TCHAR       szStatusbar[] = TEXT("StatusBar");
TCHAR       szToolbar[]   = TEXT("ToolBar");
TCHAR       szShPref[]    = TEXT("AutoShare");
TCHAR       szEnableShr[] = TEXT("EnableShare");
TCHAR       szDefView[]   = TEXT("DefView");


#if DEBUG
TCHAR       szDebug[]     = TEXT("Debug");
#endif
TCHAR       szNull[]      = TEXT("");


HKEY hkeyRoot;


TCHAR       szBuf[SZBUFSIZ];
TCHAR       szBuf2[SZBUFSIZ];

TCHAR       szConvPartner[128];                         // bigger than max server name
TCHAR       szKeepAs[ MAX_NDDESHARENAME + 2 ];



static BOOL InitApplication (HINSTANCE hInstance);
static BOOL InitInstance (HINSTANCE hInstance, int nCmdShow);
static VOID StripCharRange (TCHAR *s, char lower, char upper);
static VOID SendMessageToKids (WORD msg, WPARAM wParam, LPARAM lParam);

static VOID StripAcceleratorKey (TCHAR *s);




////////////////////// functions //////////////////////////////////

int WINAPI WinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPSTR       lpCmdLine,
    int         nCmdShow)
{
MSG         msg;
OFSTRUCT    of;
PMDIINFO    pMDI;


    #if DEBUG
    DebugLevel = 2;
    #endif


    LoadString(hInstance, IDS_APPNAME, szAppName, SMLRCBUF);

    // Only one instance is supported
    // hPrevInstance always == null under NT, so we have to rely on FWin.
    if (hwndApp = FindWindow(szClipBookClass, NULL))
        {
        PINFO(TEXT("Found previous instance\r\n"));

        if (IsIconic(hwndApp))
            {
            ShowWindow(hwndApp, SW_RESTORE);
            SetForegroundWindow(hwndApp);
            }
        else
            {
            SetForegroundWindow(hwndApp);
            }

        return FALSE;
        }



    if (!InitApplication(hInstance))
        {
        PERROR(TEXT("InitApp fail\r\n"));
        return (FALSE);
        }

    if (!InitInstance(hInstance, nCmdShow ))
        {
        PERROR(TEXT("InitInstance fail\r\n"));
        return (FALSE);
        }


    UpdateWindow ( hwndApp );



    // if we were started with the name of a file on the command line,
    // attempt to load the .clp file via an open dde execute

    if (OpenFile (lpCmdLine, &of, OF_EXIST) != HFILE_ERROR )
        {
        if ( ClearClipboard(hwndApp) )
            {
            #ifdef UNICODE
                TCHAR *ptch;

                ptch = (TCHAR *)LocalAlloc (LPTR, (lstrlenA(lpCmdLine) + 1) * sizeof(TCHAR));

                MultiByteToWideChar (CP_ACP,
                                     MB_PRECOMPOSED,
                                     lpCmdLine,
                                     -1,
                                     ptch,
                                     lstrlenA(lpCmdLine)+1);


                lstrcat(lstrcpy(szBuf, SZCMD_OPEN),ptch);
            #else
                StringCchCopy(szBuf, SZBUFSIZ, SZCMD_OPEN),
                StringCchCat (szBuf, SZBUFSIZ, lpCmdLine);
            #endif

            if (pMDI = GETMDIINFO(hwndLocal))
                {
                MySyncXact ((LPBYTE)szBuf,
                            lstrlen(szBuf) +1,
                            pMDI->hExeConv,
                            0L,
                            CF_TEXT,
                            XTYP_EXECUTE,
                            SHORT_SYNC_TIMEOUT,
                            NULL );
                }

            InitializeMenu ( GetMenu(hwndApp) );
            }
        }


    while (GetMessage (&msg, NULL, 0, 0))
        {
        if (!TranslateMDISysAccel (hwndMDIClient, &msg) &&
           (hAccel? !TranslateAccelerator(hwndApp, hAccel, &msg): 1))
          {
          TranslateMessage (&msg);
          DispatchMessage (&msg);
          }
        }


    // Clear the mutex
    CloseHandle(hmutexClp);


    // free up our HSZ 'constants'
    DdeFreeStringHandle(idInst, hszTopics);
    DdeFreeStringHandle(idInst, hszFormatList );
    DdeFreeStringHandle(idInst, hszSystem);
    DdeFreeStringHandle(idInst, hszDataSrv);
    DdeFreeStringHandle(idInst, hszClpBookShare );
    DdeFreeStringHandle(idInst, hszErrorRequest);


    // Free icons & cursors
    DestroyIcon(hicClipbrd);
    DestroyIcon(hicClipbook);
    DestroyIcon(hicRemote);
    DestroyIcon(hicLock);
    DestroyCursor(hcurClipbrd);
    DestroyCursor(hcurClipbook);
    DestroyCursor(hcurRemote);


    DdeUninitialize(idInst);

    UnhookWindowsHookEx(hMsgFilterHook);

    return (int)(msg.wParam);

}



static BOOL  InitApplication (HINSTANCE hInstance)
{
WNDCLASS    wc;

    // Register the frame window
    wc.style = 0;
    wc.lpfnWndProc   = FrameWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = LoadIcon ( hInstance, MAKEINTRESOURCE(IDFRAMEICON) );
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;      // will paint whole client area
    wc.lpszMenuName  =  MAKEINTRESOURCE(IDCVMENU);
    wc.lpszClassName = szClipBookClass;

    if (0 == RegisterClass(&wc))
        {
        return FALSE;
        }

    // Register the MDI child class
    wc.lpfnWndProc   = ChildWndProc;
    wc.hIcon         = NULL;
    wc.lpszMenuName  = NULL;
    wc.cbWndExtra    = CBWNDEXTRA;
    wc.lpszClassName = szChild;
    wc.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.style         = CS_DBLCLKS;

    if (0 == RegisterClass(&wc))
        return FALSE;


    // register dummy window for SetCapture target
    wc.lpfnWndProc   = DefWindowProc;
    wc.hIcon         = NULL;
    wc.lpszMenuName  = NULL;
    wc.cbWndExtra    = 0;
    wc.lpszClassName = szDummy;
    wc.style         = 0;

    if (0 == RegisterClass(&wc))
        return FALSE;

    return TRUE;
}




/*
 *      SetupForFloatingProfile
 */

static void SetupForFloatingProfile ()
{
TCHAR           szComputerName[MAX_COMPUTERNAME_LENGTH+3] = TEXT("\\\\");
DWORD           cbName = sizeof(szComputerName) + 1;
NDDESHAREINFO   ShareInfo =
    {
    1,                          // revision
    szClpBookShare,
    SHARE_TYPE_STATIC,
    TEXT("ClipSrv|System\0\0"),
    TRUE,                       // shared
    TRUE,                       // a service
    FALSE,                      // cannot be started
    SW_SHOWNORMAL,
    {0,0},                      // mod id
    0,                          // no item list
    TEXT("")
    };


    START_NETDDE_SERVICES(hwndApp);

    GetComputerName (&szComputerName[2], &cbName);

    NDdeShareAdd (szComputerName,
                  2,
                  NULL,
                  (LPBYTE)&ShareInfo,
                  sizeof (ShareInfo));

    NDdeSetTrustedShare (szComputerName,
                         szClpBookShare,
                         NDDE_TRUST_SHARE_START |
                         NDDE_TRUST_SHARE_INIT);
}




BOOL InitInstance(
    HINSTANCE   hInstance,
    int         nCmdShow)
{
LOGFONT         UniFont;
DWORD           dwKeyStatus;
HMENU           hFileMenu;
SC_HANDLE       hsc;
SC_HANDLE       hsrvWksta;
SERVICE_STATUS  ss;
UINT            ddeErr;

// Stuff used to make the local server's name, "\\<computername>\NDDE$"
TCHAR           atchSrvName[MAX_COMPUTERNAME_LENGTH + 9];
DWORD           dwSize;

static TCHAR  szBuffer[256] = TEXT("\0");
int    cch, i;
LCID   lcid = GetThreadLocale();

    hInst = hInstance;

    hmutexClp = CreateMutex(NULL, FALSE, SZMUTEXCLP);
    hXacting  = CreateEvent (NULL, FALSE, TRUE, NULL);


    hAccel = LoadAccelerators(hInstance, (LPCTSTR)MAKEINTRESOURCE(IDACCELERATORS));

    if (NULL == hAccel)
        {
        PERROR(TEXT("error loading accelerator table\n\r"));
        #ifndef DEBUG
            return FALSE;
        #endif
        }


    // Load cursors for dragging MDI children
    hcurClipbook = LoadCursor (hInst, (LPCTSTR)MAKEINTRESOURCE(IDC_CLIPBOOK));
    hcurClipbrd  = LoadCursor (hInst, (LPCTSTR)MAKEINTRESOURCE(IDC_CLIPBRD));
    hcurRemote   = LoadCursor (hInst, (LPCTSTR)MAKEINTRESOURCE(IDC_REMOTE));


    // Load icons for MDI children
    hicClipbook = LoadIcon (hInst, (LPCTSTR)MAKEINTRESOURCE(IDI_CLIPBOOK));
    hicClipbrd  = LoadIcon (hInst, (LPCTSTR)MAKEINTRESOURCE(IDI_CLIPBRD));
    hicRemote   = LoadIcon (hInst, (LPCTSTR)MAKEINTRESOURCE(IDI_REMOTE));


    // Load Lock icon
    hicLock = LoadIcon ( hInst, MAKEINTRESOURCE(IDLOCKICON));


    // Load the Unicode font, for displaying Unicode text.
    GetObject (GetStockObject(SYSTEM_FONT), sizeof(LOGFONT), (LPBYTE)&UniFont);
    if (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_JAPANESE ||
        PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_CHINESE ||
        PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_KOREAN)
    {
        UniFont.lfCharSet = ANSI_CHARSET;
        StringCchCopy(UniFont.lfFaceName, LF_FACESIZE, TEXT("Lucida Sans Unicode"));
    }
    else
    {
        UniFont.lfCharSet = UNICODE_CHARSET;
        StringCchCopy(UniFont.lfFaceName, LF_FACESIZE, TEXT("Lucida Sans Unicode Regular"));
    }

    hfontUni = CreateFontIndirect(&UniFont);

    if (hfontUni == NULL)
        {
        hfontUni = (HFONT)GetStockObject(SYSTEM_FONT);
        }


    LoadIntlStrings();

    if(!szBuffer[0])
    {
        cch = LoadString( hInst, IDS_FILTERTEXT, szBuffer, sizeof(szBuffer) );
        for( i = 0; i <= cch; i++ )
            {
                szBuffer[i] = (szBuffer[i] == TEXT('\1')) ? TEXT('\0') : szBuffer[i];
            }
        szFilter = szBuffer;
    }

    // initialize variables in clipdsp.c
    fOwnerDisplay = FALSE;

    // initialize DDEML
    ddeErr = DdeInitialize (&idInst,(PFNCALLBACK)DdeCallback,APPCLASS_STANDARD, 0L);
    if (DMLERR_NO_ERROR != ddeErr)
        {
        PERROR(TEXT("The DDEML did not initialize\n\r"));
        DdeMessageBox (hInst, NULL, ddeErr, IDS_APPNAME, MB_OK|MB_ICONSTOP);
        return FALSE;
        }



    // create our hsz constants
    atchSrvName[0] = atchSrvName[1] = TEXT('\\');
    dwSize = MAX_COMPUTERNAME_LENGTH+1;
    GetComputerName(atchSrvName + 2, &dwSize);
    StringCchCat(atchSrvName, MAX_COMPUTERNAME_LENGTH + 9, TEXT("\\NDDE$"));

    hszDataSrv      = DdeCreateStringHandleA(idInst, atchSrvName,          CP_WINANSI);
    hszSystem       = DdeCreateStringHandleA(idInst, "CLPBK$",             CP_WINANSI);
    hszTopics       = DdeCreateStringHandleA(idInst, SZDDESYS_ITEM_TOPICS, CP_WINANSI);
    hszFormatList   = DdeCreateStringHandleA(idInst, SZ_FORMAT_LIST,       CP_WINANSI);
    hszClpBookShare = DdeCreateStringHandleA(idInst, szClpBookShare,       CP_WINANSI);
    hszErrorRequest = DdeCreateStringHandleA(idInst, SZ_ERR_REQUEST,       CP_WINANSI);

    if (DdeGetLastError(idInst) != DMLERR_NO_ERROR )
       {
       PERROR(TEXT("DDEML error during init\n\r"));
       return FALSE;
       }



    // We set this hook up so that we can catch the MSGF_DDEMGR message
    // which is called when DDEML is in a modal loop during synchronous
    // transaction processing.

    lpMsgFilterProc = (HOOKPROC)MyMsgFilterProc;
    hMsgFilterHook  = SetWindowsHookEx (WH_MSGFILTER,
                                        lpMsgFilterProc,
                                        hInst,
                                        GetCurrentThreadId());
    if (NULL == hMsgFilterHook)
        {
        PERROR(TEXT("SetWindowsHook failed\n\r"));
        return FALSE;
        }


    // get preference flags
    LoadString(hInst, IDS_CLPBKKEY, szRoot, sizeof(szRoot));
    if (ERROR_SUCCESS != RegCreateKeyEx (HKEY_CURRENT_USER,
                                         szRoot,
                                         0L,
                                         NULL,
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_QUERY_VALUE |
                                         KEY_SET_VALUE   |
                                         KEY_ENUMERATE_SUB_KEYS,
                                         NULL,
                                         &hkeyRoot,
                                         &dwKeyStatus))
        {
        PERROR(TEXT("Could not set up root key\r\n"));
        fStatus          = TRUE;
        fToolBar         = TRUE;
        fSharePreference = TRUE;
        fShareEnabled    = FALSE;
        }
    else
        {
        DWORD iSize = sizeof(fStatus);

        PINFO (TEXT("Root key created. Key Status %ld."),dwKeyStatus);

        if (ERROR_SUCCESS != RegQueryValueEx (hkeyRoot, szStatusbar,
                                              NULL, NULL, (LPBYTE)&fStatus, &iSize))
            {
            fStatus = TRUE;
            }

        iSize = sizeof(fToolBar);
        if (ERROR_SUCCESS != RegQueryValueEx (hkeyRoot, szToolbar,
                                              NULL, NULL, (LPBYTE)&fToolBar, &iSize))
            {
            fToolBar = TRUE;
            }

        iSize = sizeof(fSharePreference);
        if (ERROR_SUCCESS != RegQueryValueEx (hkeyRoot, szShPref,
                                              NULL, NULL, (LPBYTE)&fSharePreference, &iSize))
             {
             fSharePreference = FALSE;
             }

        #if DEBUG
            iSize = sizeof(DebugLevel);
            if (ERROR_SUCCESS != RegQueryValueEx (hkeyRoot, szDebug, NULL, NULL,
                                                  (LPBYTE)&DebugLevel, &iSize))
                {
                DebugLevel = 2;
                }
        #endif

        iSize = sizeof(fShareEnabled);
        if (ERROR_SUCCESS != RegQueryValueEx (hkeyRoot, szEnableShr,
                                              NULL, NULL, (LPBYTE)&fShareEnabled, &iSize))
            {
            fShareEnabled = TRUE;
            }
        }



    // Figure out if NetBIOS is active or not, thus if we can net connect

    fNetDDEActive = FALSE;

    hsc = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

    if (NULL != hsc)
        {
        hsrvWksta = OpenService(hsc, "LanmanWorkstation", SERVICE_QUERY_STATUS);
        if (NULL != hsrvWksta)
            {
            if (QueryServiceStatus(hsrvWksta, &ss))
                {
                if (ss.dwCurrentState == SERVICE_RUNNING)
                    {
                    fNetDDEActive = TRUE;
                    }
                }
            CloseServiceHandle(hsrvWksta);
            }
        CloseServiceHandle(hsc);
        }
    else
       {
       PERROR(TEXT("Couldn't open SC mgr\r\n"));
       }


    //  override if not on a domain
    {
        LPWSTR pszDomain;
        NETSETUP_JOIN_STATUS nsjs;
    
        if (NERR_Success == NetGetJoinInformation(NULL, &pszDomain, &nsjs))
        {
            if ( nsjs != NetSetupDomainName)
                fNetDDEActive = FALSE;
            NetApiBufferFree(pszDomain);
        }
    }


    fAuditEnabled = AuditPrivilege(AUDIT_PRIVILEGE_CHECK);

    // Create main window
    if ( !( hwndApp = CreateWindow (szClipBookClass,
                                    szAppName,
                                    WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                                    CW_USEDEFAULT,
                                    CW_USEDEFAULT,
                                    CW_USEDEFAULT,
                                    CW_USEDEFAULT,
                                    NULL,
                                    NULL,
                                    hInstance,
                                    NULL)))
        {
        PERROR(TEXT("CreateWindow failed!\r\n"));
        return FALSE;
        }


    SetupForFloatingProfile ();


    // Get the handle to the Display popup menu for adding format entries
    hDispMenu = GetSubMenu( GetMenu(hwndApp), DISPLAY_MENU_INDEX);


    hFileMenu = GetSubMenu(GetMenu(hwndApp), 0);

    // get rid of share menu entries?
    if ( !fShareEnabled )
        {
        EnableMenuItem ( hFileMenu, IDM_SHARE, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem ( hFileMenu, IDM_UNSHARE, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem ( hFileMenu, IDM_PROPERTIES, MF_BYCOMMAND | MF_GRAYED);
        }


    // get rid of connect/disonnect entries?
    if ( !fNetDDEActive )
        {
        EnableMenuItem ( hFileMenu, IDM_CONNECT, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem ( hFileMenu, IDM_DISCONNECT, MF_BYCOMMAND | MF_GRAYED);
        }


    DrawMenuBar(hwndApp);


    if ( ReadWindowPlacement ( szAppName, &Wpl ))
        {
        Wpl.showCmd = nCmdShow;
        Wpl.ptMaxPosition.x = -1;
        Wpl.ptMaxPosition.y = -1;
        SetWindowPlacement ( hwndApp, &Wpl );
        UpdateWindow(hwndApp);
        }
    else
        {
        ShowWindow ( hwndApp, nCmdShow );
        }


    // make our SetCapture target window
    if ( !( hwndDummy = CreateWindow (szDummy,
                                      szNull,
                                      WS_CHILD & ~WS_VISIBLE,
                                      0,
                                      0,
                                      0,
                                      0,
                                      hwndApp,
                                      NULL,
                                      hInstance,
                                      NULL )))
       return FALSE;




    // Make clipboard window -- needs to happen BEFORE we SetClipboardViewer,
    // because hwndApp will get a WM_DRAWCLIPBOARD and there won't be any windows.

    SendMessage ( hwndApp, WM_COMMAND, IDM_CLPWND, 0L );


    // Attach us to the clipboard viewer chain

    hwndNextViewer = SetClipboardViewer(hwndApp);


    // create initial local window.

    SendMessage ( hwndApp, WM_COMMAND, IDM_LOCAL, 0L );


    // force paint before restoring other connections so we don't
    // have to wait too long.

    UpdateWindow(hwndApp);


    // restore previous connections

    if ( fNetDDEActive )
        RestoreAllSavedConnections();

    return TRUE;
}



// Strip all chars between lower and upper from string s, in place.

VOID StripCharRange (
    TCHAR   *s,
    char    lower,
    char    upper)
{
    TCHAR *p = s, *q = s;

    while( *p ){

        if (IsDBCSLeadByte(*p)) {
            *q++ = *p++;
            *q++ = *p++;
        }
        else {
            if (*p < lower || *p > upper) *q++ = *p++;
            else
               p++;
        }
     }
     *q = TEXT('\0');
}



//  Strip all occurrences of "(&)" from string s, in place
//  Localized FE build uses "Bitmap(&B)" instead of "&Bitmap" in menu string.

VOID StripAcceleratorKey (
    TCHAR   *s)
{
TCHAR *p = s, *q = s;

    while( *p ) {
#ifndef UNICODE
        if (IsDBCSLeadByte(*p)) {
            *q++ = *p++;
            *q++ = *p++;
        }
        else
        {
            if ( (*p==TEXT('(')) && (*(p+1)==TEXT('&')) && (*(p+3)==TEXT(')')) )
                p += 4;
            else    *q++ = *p++;
        }

#else
        if ( (*p==TEXT('(')) && (*(p+1)==TEXT('&')) && (*(p+3)==TEXT(')')) )
                p += 4;
        else    *q++ = *p++;
#endif

    }
    *q = TEXT('\0');
}




/////////////////////////////////////////////////////////////////////////////
//
// Purpose: Message handler for WM_DRAWCLIPBOARD
//
// Params:
//    hwnd - Window handle
/////////////////////////////////////////////////////////////////////////////

void OnDrawClipboard(
    HWND    hwnd)
{
UINT    wNewFormat;
UINT    wOldFormat;
HCURSOR hCursor;


    // If we are in a transaction, defer processing this message
    // until the next unlock - if we did this now we could cause
    // other apps to break...

    // clipboard may have been empty and now isn't


    InitializeMenu ( GetMenu(hwnd) );


    if (fAppLockedState)
        {
        fClipboardNeedsPainting = TRUE;
        }
    else
        {
        fClipboardNeedsPainting = FALSE;


        hCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));


        if (IsWindow ( hwndClpbrd ))
            {
            wOldFormat = GetBestFormat (hwndClpbrd,
                                        GETMDIINFO(hwndClpbrd)->CurSelFormat );

            GETMDIINFO(hwndClpbrd)->CurSelFormat          = CBM_AUTO;
            GETMDIINFO(hwndClpbrd)->fDisplayFormatChanged = TRUE;

            wNewFormat = GetBestFormat( hwndClpbrd, CBM_AUTO );

            // NOTE OwnerDisplay stuff applies only to the "real" clipboard!

            ShowHideControls(hwndClpbrd);

            if (wOldFormat == CF_OWNERDISPLAY)
                {
                /* Save the owner Display Scroll info */
                SaveOwnerScrollInfo(hwndClpbrd);
                ShowScrollBar ( hwndClpbrd, SB_BOTH, FALSE );
                ResetScrollInfo( hwndClpbrd );
                InvalidateRect ( hwndClpbrd, NULL, TRUE );
                }
            else
                {
                if (wNewFormat == CF_OWNERDISPLAY)
                    {
                    /* Restore the owner display scroll info */
                    ShowHideControls(hwndClpbrd);
                    ShowWindow ( pActiveMDI->hwndSizeBox, SW_HIDE );
                    RestoreOwnerScrollInfo(hwndClpbrd);
                    InvalidateRect ( hwndClpbrd, NULL, TRUE );
                    }
                else
                    {
                    // Change the character dimensions based on the format.
                    ChangeCharDimensions(hwndClpbrd, wOldFormat, wNewFormat);

                    // Initialize the owner display scroll info, because the
                    // contents have changed.
                    InitOwnerScrollInfo();

                    // Force a total repaint. fOwnerDisplay gets updated during
                    // a total repaint.
                    InvalidateRect(hwndClpbrd, NULL, TRUE);
                    ResetScrollInfo(hwndClpbrd);

                    // force update here BEFORE sending on WM_DRAWCLIPBOARD
                    UpdateWindow (hwndClpbrd);
                    }
                }
            }

        SetCursor (hCursor);
        }


    // Pass the message on to the next clipboard viewer in the chain.
    if (hwndNextViewer != NULL)
        {
        SendMessage(hwndNextViewer, WM_DRAWCLIPBOARD, 0, 0);
        }
}



LRESULT OnEraseBkgnd(
    HWND    hwnd,
    HDC     hdc)
{
    return DefMDIChildProc(hwnd, WM_ERASEBKGND, (WPARAM)hdc, 0L);
}



LRESULT OnPaint(
    HWND    hwnd)
{
PMDIINFO    pMDI;
PAINTSTRUCT ps;
HPALETTE    hpal;
HPALETTE    hpalT;
HBRUSH      hbr;
LRESULT     lRet = ONPAINT_FAIL;
HCURSOR     hCursor;


    if (!(pMDI = GETMDIINFO(hwnd)))
        {
        return ONPAINT_FAIL;
        }

    hCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

    if ( IsIconic ( hwnd ))
        {
        BeginPaint(hwnd, &ps);

        if ( pMDI->flags & F_CLPBRD )
            {
            DrawIcon ( ps.hdc, 0, 0, hicClipbrd);
            }
        else if ( pMDI->flags & F_LOCAL )
            {
            DrawIcon ( ps.hdc, 0, 0, hicClipbook);
            }
        else
            {
            DrawIcon ( ps.hdc, 0, 0, hicRemote);
            }

        lRet = ONPAINT_SUCCESS;

        goto donePaint;
        }

    if (pMDI->DisplayMode != DSP_PAGE)
        {
        BeginPaint (hwnd, &ps);
        lRet = ONPAINT_FAIL;

        goto donePaint;
        }

    if (fAppShuttingDown)
        {
        BeginPaint (hwnd, &ps);
        lRet = ONPAINT_FAIL;

        goto donePaint;
        }

    if (!VOpenClipboard( pMDI->pVClpbrd, hwnd))
        {
        #if DEBUG
          SetStatusBarText("Clipboard changed but could not open");
        #endif
        lRet = ONPAINT_NOCLIPBRD;

        goto done;
        }

    BeginPaint (hwnd, &ps);


    // Fill background with proper color - DefMDIChildProc fills with app_workspace.

    hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
    FillRect(ps.hdc, &ps.rcPaint, hbr);
    DeleteObject(hbr);

    SetBkColor(ps.hdc, GetSysColor(COLOR_WINDOW));
    SetTextColor(ps.hdc, GetSysColor(COLOR_WINDOWTEXT));

    if (hpal = VGetClipboardData( pMDI->pVClpbrd, CF_PALETTE))
        {
        PINFO("Palette found, selecting & realizing\r\n");
        hpalT = SelectPalette(ps.hdc, hpal, pMDI != pActiveMDI );
        RealizePalette(ps.hdc);
        }

    DrawStuff( hwnd, &ps, hwnd );

    if (hpal)
        {
        // We don't want to put the DEFAULT palette in the foreground.
        SelectPalette(ps.hdc, hpalT, FALSE);
        }

    VCloseClipboard( pMDI->pVClpbrd );

    lRet = ONPAINT_SUCCESS;


donePaint:
    EndPaint(hwnd, &ps);

done:
    SetCursor (hCursor);
    return lRet;
}




LRESULT CALLBACK FrameWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    int     tmp;

    // PINFO(TEXT("FrameWnd Msg: %u %ld %ld\r\n"), msg, wParam, lParam);

    switch (msg)
        {
        case WM_CREATE:
            {

            CLIENTCREATESTRUCT ccs;
            RECT               rc;

            /* Find window menu where children will be listed */
            ccs.hWindowMenu  = GetSubMenu (GetMenu(hwnd), WINDOW_MENU_INDEX );
            ccs.idFirstChild = 4100; // IDM_WINDOWCHILD;

            // initialize special case clipboard formats...
            // note that CF_BITMAP, CF_METAFILEPICT, CF_PALETTE are
            // re-registered in a private format because data for these
            // formats is exchanged between this app and clipsrv.exe in
            // a flat DDEML data handle - not the regular DDE interpretation
            // of a handle that carries those format IDs

            if (LoadString (hInst, CF_BITMAP, szBuf, SZBUFSIZ))
                cf_bitmap = RegisterClipboardFormat (szBuf);

            if (LoadString (hInst, CF_METAFILEPICT, szBuf, SZBUFSIZ))
                cf_metafilepict = RegisterClipboardFormat (szBuf);

            if (LoadString (hInst, CF_PALETTE, szBuf, SZBUFSIZ))
                cf_palette = RegisterClipboardFormat (szBuf);

            cf_preview        = RegisterClipboardFormat (SZPREVNAME);
            cf_link           = RegisterClipboardFormat (SZLINK);
            cf_linkcopy       = RegisterClipboardFormat (SZLINKCOPY);
            cf_objectlink     = RegisterClipboardFormat (SZOBJECTLINK);
            cf_objectlinkcopy = RegisterClipboardFormat (SZOBJECTLINKCOPY);

            CreateTools( hwnd );   // creates toolbar window, brushes, etc.

            // determine height of toolbar window and save...
            GetClientRect ( hwndToolbar, &rc );
            dyButtonBar = rc.bottom - rc.top +1;

            // determine height of statusbar window and save...
            GetClientRect ( hwndStatus, &rc );
            dyStatus = rc.bottom - rc.top;

            // Create the MDI client - will be sized later
            hwndMDIClient = CreateWindow ("mdiclient",
                                          NULL,
                                          WS_BORDER|
                                          WS_CHILD|
                                          WS_CLIPCHILDREN|
                                          MDIS_ALLCHILDSTYLES|
                                          WS_HSCROLL|
                                          WS_VSCROLL,
                                          0,
                                          0,
                                          0,
                                          0,
                                          hwnd,
                                          (HMENU)0xCAC,
                                          hInst,
                                          (LPVOID)&ccs);

            ShowWindow ( hwndMDIClient, SW_SHOW );
            }

            break;

        case WM_QUERYNEWPALETTE:
             // Tell the active document to realize in foreground.
            if ( hwndActiveChild )
                tmp = (WORD)SendMessage(hwndActiveChild, WM_QUERYNEWPALETTE,0, 0L);
            else
               break;

            // If mapping is unchanged, other documents could still change,
            // so give them a change to realize.
            if (!tmp)
              SendMessageToKids(WM_PALETTECHANGED, (WPARAM)hwndActiveChild, 0L);
            return(tmp);
            break;


        // System palette has changed, so pass it on to the children.
        case WM_PALETTECHANGED:
            SendMessageToKids(WM_PALETTECHANGED, wParam, lParam);
            break;


        case WM_MENUSELECT:
            PINFO(TEXT("MenuSelect %lx\r\n"), wParam);

            // no context menu help for popup entries
            if ( HIWORD(wParam) & MF_POPUP )
               {
               dwCurrentHelpId = 0;
               }
            else if ( HIWORD(wParam) & MF_SYSMENU )
               {
               dwCurrentHelpId = IDH_SYSMENU;
               }
            else
               {
               // We don't care if the menuitem's disabled, checked, whatever...
               wParam = LOWORD(wParam);

               // was this a dynamically added clipboard entry?
               if (( wParam >= 0xc000 && wParam <= 0xffff ||   // registerd format?
                  wParam >= CF_TEXT && wParam <= CF_ENHMETAFILE || // intrinsic format?
                  wParam >= CF_OWNERDISPLAY && wParam <= CF_DSPMETAFILEPICT )

                  // gotta exclude sc_ stuff - overlaps with formats
                  && ! ( wParam >= SC_SIZE && wParam <= SC_HOTKEY ) )
                  {
                  GetMenuString ( GetMenu(hwnd), (UINT)wParam,
                     szBuf2, SZBUFSIZ, MF_BYCOMMAND );

                  //Localized FE build uses "Bitmap(&B)" instead of "&Bitmap" in menu string.
                  StripAcceleratorKey( szBuf2 );

                  //For non-localized string
                  StripCharRange ( szBuf2, '&', '&' );

                  StringCchPrintf( szBuf, sizeof(szBuf), szViewHelpFmt, (LPSTR)szBuf2 );
                  SendMessage( hwndStatus, SB_SETTEXT, SBT_NOBORDERS|255, (LPARAM)szBuf );

                  dwCurrentHelpId = (DWORD)(IDH_FORMATS_BASE + wParam);
                  break;
                  }

               if ( wParam >= 4100 && wParam <= 4200 )
                  {
                  GetMenuString (GetMenu(hwnd), (UINT)wParam,szBuf2,SZBUFSIZ, MF_BYCOMMAND);
                  StripCharRange ( szBuf2, '&', '&' );
                  StripCharRange ( szBuf2, '0', '9' );
                  StringCchPrintf( szBuf, sizeof(szBuf), szActivateFmt,
                                   *szBuf2 == ' ' ? (LPSTR)(szBuf2+1) : (LPSTR)szBuf2 );
                  SendMessage( hwndStatus, SB_SETTEXT, SBT_NOBORDERS|255, (LPARAM)(LPSTR)szBuf );
                  dwCurrentHelpId = IDH_NAMESWIND;
                  break;
                  }

               dwCurrentHelpId = (DWORD)(IDH_BASE + wParam);
               }

            MenuHelp( (WORD)msg, wParam, lParam, GetMenu(hwnd), hInst, hwndStatus, nIDs );
            break;

        case WM_F1DOWN:
            PINFO(TEXT("Help on context %ld\r\n"), dwCurrentHelpId);
            if ( dwCurrentHelpId )
               {
               WinHelp(hwndApp, szHelpFile, HELP_CONTEXT, dwCurrentHelpId );
               DrawMenuBar(hwndApp);
               }
            break;

        case WM_DRAWITEM:
            HandleOwnerDraw( hwnd, msg, wParam, lParam );
            break;

        case WM_INITMENU:
            InitializeMenu ((HMENU)wParam);
            UpdateCBMenu ( hwnd, hwndActiveChild );
            break;

        case WM_SYSCOLORCHANGE:
            DeleteTools( hwnd );
            CreateTools( hwnd );
            break;

        case WM_COMMAND:
            return ClipBookCommand ( hwnd, msg, wParam, lParam );

        case WM_CLOSE:

            #if DEBUG
               if ( fAppLockedState )
                  PERROR(TEXT("Very bad: WM_CLOSE while locked\n\r"));
            #endif

            // force all clipboard formats rendered before exiting
            // so we don't end up yielding in WM_RENDERALLFORMATS
            // and get into trouble.

            fAppShuttingDown = TRUE;

            ForceRenderAll(hwnd, (PVCLPBRD)NULL );
            PostMessage(hwnd, WM_CLOSE_REALLY, 0, 0L );
            WinHelp(hwnd, szHelpFile, HELP_QUIT, 0L);
            break;

        case WM_NOTIFY:
            {
            LPTOOLTIPTEXT lpTTT = (LPTOOLTIPTEXT) lParam;

            if (lpTTT->hdr.code == TTN_NEEDTEXT)
                {
                LoadString (hInst, (UINT)(MH_TOOLTIP + lpTTT->hdr.idFrom), lpTTT->szText, 80);
                return TRUE;
                }
            }
            break;

        case WM_CLOSE_REALLY:
            // this is necessary to avoid processing messages in our
            // queue when we yield getting the clipboard data in
            // ForceRenderAll and destroying the app prematurely
            return DefFrameProc (hwnd,hwndMDIClient,WM_CLOSE,0,0L);

        case WM_DESTROY:

            #if DEBUG
                if ( fAppLockedState )
                   {
                   PERROR(TEXT("Very bad: WM_DESTROY while locked\n\r"));
                   }
            #endif

            // Take us out of the viewer chain
            ChangeClipboardChain(hwnd, hwndNextViewer);

            DeleteTools ( hwnd );

            Wpl.length = sizeof ( Wpl );
            Wpl.flags = 0;
            GetWindowPlacement ( hwnd, &Wpl );
            SaveWindowPlacement ( &Wpl );

            if (hkeyRoot != NULL)
                {
                RegSetValueEx (hkeyRoot, szStatusbar, 0L, REG_DWORD,
                               (LPBYTE)&fStatus, sizeof(fStatus));
                RegSetValueEx (hkeyRoot, szToolbar, 0L, REG_DWORD,
                               (LPBYTE)&fToolBar, sizeof(fToolBar));
                RegSetValueEx (hkeyRoot, szShPref, 0L, REG_DWORD,
                               (LPBYTE)&fSharePreference, sizeof(fSharePreference));
                }

            PostQuitMessage (0);
            break;


        case WM_DRAWCLIPBOARD:
            OnDrawClipboard(hwnd);
            break;

        case WM_CHANGECBCHAIN:

            if (hwndNextViewer == NULL)
                return(FALSE);

            if ( (HWND)wParam == hwndNextViewer)
                {
                hwndNextViewer = (HWND)lParam;
                return(TRUE);
                }
             return(SendMessage(hwndNextViewer, WM_CHANGECBCHAIN, wParam, lParam));

        case WM_RENDERALLFORMATS:

            // WM_DESTROY follows close on the heels of this message, and
            // we will process it and die while another copy of FrameWndProc
            // is in sync DDEML transaction...
            //
            // Note that we now attempt to render all formats in WM_DESTROY
            // before doing the PostQuitMessage so we should not have to
            // respond to this message.

            break;

        case WM_RENDERFORMAT:
            {
            HDDEDATA    hListData = 0L;
            HDDEDATA    hFmtData  = 0L;
            HSZ         hszFmt    = 0L;
            LPTSTR      lpszList  = TEXT("");
            LPTSTR      q;
            DWORD       cbDataLen;
            UINT        RealFmt;
            UINT        uiErr;


            PINFO(TEXT("Frame WM_RENDERFORMAT: %d\r\n"),wParam);



            // If we did File/Save or File/Open then render from file.
            // When we get IDM_COPY, szSaveFileName will assigned ""

            if (szSaveFileName[0])
                {
                SetClipboardData((UINT)wParam, RenderFormatFromFile(szSaveFileName,
                    (WORD)wParam));
                break;
                }



            if ( !IsWindow(hwndClpOwner))
                {
                PERROR(TEXT("Strange?: null clipboard owner window!\n\r"));
                break;
                }


            DdeKeepStringHandle ( idInst, hszFormatList );

            hListData = MySyncXact (NULL,
                                    0L,
                                    GETMDIINFO(hwndClpOwner)->hClpConv,
                                    hszFormatList,
                                    CF_TEXT,
                                    XTYP_REQUEST,
                                    SHORT_SYNC_TIMEOUT,
                                    NULL);


            if (!hListData && !fAppShuttingDown)
                {
                uiErr = DdeGetLastError (idInst);
                PERROR (TEXT("WM_RENDERFORM: REQUEST for formatlist failed: %x\n\r"),uiErr);
                MessageBoxID (hInst,
                              hwnd,
                              IDS_DATAUNAVAIL,
                              IDS_APPNAME,
                              MB_OK|MB_ICONEXCLAMATION);
                break;
                }

            lpszList = (LPTSTR)DdeAccessData ( hListData, &cbDataLen );

            if (!lpszList && !fAppShuttingDown)
                {
                PERROR(TEXT("WM_RENDERFORM: DdeAccessData failed!\n\r"));
                MessageBoxID (hInst,
                              hwnd,
                              IDS_DATAUNAVAIL,
                              IDS_APPNAME,
                              MB_OK|MB_ICONEXCLAMATION);
                break;
                }


            for (q = strtokA (lpszList, "\t"); q; q = strtokA(NULL, "\t"))
                {
                RealFmt = MyGetFormat ( q, GETFORMAT_DONTLIE );

                if ( wParam == RealFmt || msg == WM_RENDERALLFORMATS )
                    {
                    PINFO(TEXT("Getting format %d\r\n"), RealFmt);

                    hszFmt = DdeCreateStringHandle ( idInst, q, 0 );

                    hFmtData = MySyncXact (NULL,
                                           0L,
                                           GETMDIINFO(hwndClpOwner)->hClpConv,
                                           hszFmt,
                                           MyGetFormat (q, GETFORMAT_LIE),
                                           XTYP_REQUEST,
                                           LONG_SYNC_TIMEOUT,
                                           NULL );

                    if (hFmtData)
                        {
                        SetClipboardFormatFromDDE ( hwndClpbrd, RealFmt , hFmtData );
                        }
                    else
                        PERROR(TEXT("REQUEST for %s failed %x\n\r"), q, DdeGetLastError(idInst));

                    DdeFreeStringHandle (idInst, hszFmt);
                    }
                }

            DdeUnaccessData( hListData );
            DdeFreeDataHandle ( hListData );


            // Couldn't find Bitmap, try DIB and
            //  and convert it to Bitmap.

            if (wParam == CF_BITMAP && !hFmtData)
                {
                TCHAR   szName[40];

                GetClipboardName (CF_DIB, szName, sizeof (szName));
                hszFmt = DdeCreateStringHandle (idInst, szName, 0);
                hFmtData = MySyncXact (NULL,
                                       0L,
                                       GETMDIINFO (hwndClpOwner)->hClpConv,
                                       hszFmt,
                                       MyGetFormat (szName, GETFORMAT_LIE),
                                       XTYP_REQUEST,
                                       LONG_SYNC_TIMEOUT,
                                       NULL);
                if (hFmtData)
                    SetClipboardFormatFromDDE (hwndClpbrd, DDE_DIB2BITMAP, hFmtData);

                DdeFreeStringHandle (idInst, hszFmt);
                }


            break;
            }

        case WM_SIZE:
            SendMessage (hwndToolbar, WM_SIZE, 0, 0L);
            SendMessage (hwndStatus, WM_SIZE, 0, 0L);
            AdjustMDIClientSize();
            break;

        case WM_PARENTNOTIFY:
            // PINFO(TEXT("Recieved WM_PARENTNOTIFY %d %ld\r\n"), wParam, lParam);
            break;

        default:
            return DefFrameProc (hwnd,hwndMDIClient,msg,wParam,lParam);
        }

    return 0;
}



//////////////////////////////////////////////////////////////////////
LRESULT CALLBACK ChildWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam)
{
LPMEASUREITEMSTRUCT lpmisCtl;
HDC                 hdc;
int                 tmp;
PMDIINFO            pMDI;
int                 i;
HPALETTE            hCurrentPal, hOldPal;


    // PERROR(TEXT("ChildWndProc msg: %u %ld %ld\r\n"),msg, wParam, lParam);

    switch (msg)
        {
        case WM_MDIACTIVATE:
            SendMessage(hwndMDIClient, WM_MDIREFRESHMENU, 0, 0);
            DrawMenuBar(hwndApp);

            if ((HWND)lParam != hwnd)
               break;

            // intentional fall through

        case WM_SETFOCUS:
            hwndActiveChild = hwnd;
            if (!(pActiveMDI = GETMDIINFO(hwndActiveChild)))
                break;

            if ( pActiveMDI->DisplayMode != DSP_PAGE &&
                  IsWindow(  pActiveMDI->hWndListbox ))
                {
                SetFocus (  pActiveMDI->hWndListbox );
                }
            else
                {
                SetFocus (  hwndActiveChild );
                }

            InitializeMenu( GetMenu(hwndApp) );
            UpdateNofMStatus(hwndActiveChild);
            return (DefMDIChildProc(hwnd, msg, wParam, lParam));

        case WM_LBUTTONDBLCLK:
            if (!GETMDIINFO(hwnd))
                break;

            if (GETMDIINFO (hwnd)->DisplayMode == DSP_PAGE &&
                !(GETMDIINFO(hwnd)->flags & F_CLPBRD ))
                {
                if (GETMDIINFO(hwnd)->OldDisplayMode == DSP_LIST )
                    SendMessage ( hwndApp, WM_COMMAND, IDM_LISTVIEW, 0L );
                else if ( GETMDIINFO(hwnd)->OldDisplayMode == DSP_PREV )
                    SendMessage ( hwndApp, WM_COMMAND, IDM_PREVIEWS, 0L );
                }
            break;


        case WM_PALETTECHANGED:
            if (hwnd == (HWND)wParam)
                break;

            // intentional fall through

        case WM_QUERYNEWPALETTE:

            if (!GETMDIINFO(hwnd))
                break;

            if (GETMDIINFO(hwnd)->DisplayMode != DSP_PAGE)
                return 0;

            i = 0;
            if (VOpenClipboard( GETMDIINFO(hwnd)->pVClpbrd, hwnd))
                {
                if ( hCurrentPal = VGetClipboardData( GETMDIINFO(hwnd)->pVClpbrd, CF_PALETTE))
                    {
                    hdc = GetDC(hwnd);
                    hOldPal = SelectPalette (hdc,
                                             hCurrentPal,
                                             (msg == WM_QUERYNEWPALETTE)? FALSE: TRUE);
                    i = RealizePalette(hdc);

                    SelectPalette(hdc, hOldPal, TRUE);
                    RealizePalette(hdc);
                    ReleaseDC(hwnd, hdc);
                    if (i)
                        InvalidateRect(hwnd, NULL, TRUE);
                    }
                VCloseClipboard( GETMDIINFO(hwnd)->pVClpbrd );
                }

            return(i);
            break;


        case WM_MENUSELECT:

            MenuHelp ((WORD)msg,
                      wParam,
                      lParam,
                      GetMenu(hwndApp),
                      hInst,
                      hwndStatus,
                      nIDs);
            break;


        case WM_CREATE:

            if ((pMDI = (LPMDIINFO)GlobalAllocPtr(GPTR, sizeof(MDIINFO))) == NULL)
                {
                PERROR(TEXT("MdiInfo alloc failed\n\r"));
                break;
                }

            SetWindowLongPtr (hwnd, GWL_MDIINFO, (LONG_PTR)pMDI);

            pMDI->DisplayMode           = DSP_LIST;
            pMDI->hExeConv              = 0L;
            pMDI->hClpConv              = 0L;
            pMDI->hVClpConv             = 0L;
            pMDI->flags                 = 0L;
            pMDI->CurSelFormat          = CBM_AUTO;
            pMDI->cyScrollLast          = -1L;
            pMDI->cxScrollLast          = -1;
            pMDI->cyScrollNow           = 0L;
            pMDI->cxScrollNow           = 0;
            pMDI->pVClpbrd              = NULL;
            pMDI->hszConvPartner        = 0L;
            pMDI->hszConvPartnerNP      = 0L;
            pMDI->hszClpTopic           = 0L;
            pMDI->fDisplayFormatChanged = TRUE;
            pMDI->hWndListbox           = CreateWindow (TEXT("listbox"),
                                                        szNull,
                                                        WS_CHILD |
                                                        LBS_STANDARD |
                                                        LBS_NOINTEGRALHEIGHT |
                                                        LBS_LISTVIEW,
                                                        0,
                                                        0,
                                                        100,
                                                        100,
                                                        hwnd,
                                                        (HMENU)ID_LISTBOX,
                                                        hInst,
                                                        0L );

            // create the scroll bars
            pMDI->hwndVscroll = CreateWindowW (L"scrollbar",
                                               L"",
                                               WS_CHILD|SBS_VERT,
                                               0,
                                               0,
                                               0,
                                               0,
                                               hwnd,
                                               (HMENU)ID_VSCROLL,
                                               hInst,
                                               0L);

            pMDI->hwndHscroll = CreateWindowW (L"scrollbar",
                                               L"",
                                               WS_CHILD|SBS_HORZ,
                                               0,
                                               0,
                                               0,
                                               0,
                                               hwnd,
                                               (HMENU)ID_VSCROLL,
                                               hInst,
                                               0L);

            // create the corner size box
            pMDI->hwndSizeBox = CreateWindowW (L"scrollbar",
                                               L"",
                                               WS_CHILD|SBS_SIZEBOX,
                                               0,
                                               0,
                                               0,
                                               0,
                                               hwnd,
                                               (HMENU)ID_SIZEBOX,
                                               hInst,
                                               0L);

            // create the page fwd/bkwd buttons
            pMDI->hwndPgUp    = CreateWindowW (L"button",
                                               L"",
                                               WS_CHILD | BS_OWNERDRAW,
                                               0,
                                               0,
                                               0,
                                               0,
                                               hwnd,
                                               (HMENU)ID_PAGEUP,
                                               hInst,
                                               0L);


            pMDI->hwndPgDown  = CreateWindowW (L"button",
                                               L"",
                                               WS_CHILD | BS_OWNERDRAW,
                                               0,
                                               0,
                                               0,
                                               0,
                                               hwnd,
                                               (HMENU)ID_PAGEDOWN,
                                               hInst,
                                               0L);

            SetCharDimensions( hwnd, GetStockObject (SYSTEM_FONT));
            break;


        case WM_VSCROLL:
            if (wParam != SB_THUMBTRACK)
                {
                if (fOwnerDisplay)
                    SendOwnerMessage (WM_VSCROLLCLIPBOARD, (WPARAM)hwnd, (LPARAM)wParam);
                else
                    ClipbrdVScroll (hwnd, LOWORD(wParam), HIWORD(wParam));
                }
            break;

        case WM_HSCROLL:
            if (wParam != SB_THUMBTRACK)
                {
                if (fOwnerDisplay)
                    SendOwnerMessage (WM_HSCROLLCLIPBOARD, (WPARAM)hwnd, (LPARAM)wParam);
                else
                    ClipbrdHScroll (hwnd, LOWORD(wParam), HIWORD(wParam));
                }
            break;


        case WM_QUERYDRAGICON:
            if (!GETMDIINFO(hwnd))
                break;

            if (GETMDIINFO(hwnd)->flags & F_CLPBRD)
                return (LRESULT)hcurClipbrd;
            else if ( GETMDIINFO(hwnd)->flags & F_LOCAL )
                return (LRESULT)hcurClipbook;
            else
                return (LRESULT)hcurRemote;

        case WM_CLOSE:
            if (!GETMDIINFO(hwnd))
                {
                if (!(GETMDIINFO(hwnd)->flags & (F_CLPBRD | F_LOCAL)))
                    {
                    PINFO(TEXT("removing reconn for '%s'\n\r"), (LPSTR)GETMDIINFO(hwnd)->szBaseName);

                    if (NULL != hkeyRoot)
                        {
                        StringCchCopy(szBuf, SZBUFSIZ, GETMDIINFO(hwnd)->szBaseName);
                        StringCchCat( szBuf, SZBUFSIZ, szConn);
                        RegDeleteValue(hkeyRoot, szBuf);

                        StringCchCopy(szBuf, SZBUFSIZ, GETMDIINFO(hwnd)->szBaseName);
                        StringCchCat (szBuf, SZBUFSIZ, szWindows);
                        RegDeleteValue(hkeyRoot, szBuf);
                        }
                    }
                }
            WinHelp(hwnd, szHelpFile, HELP_QUIT, 0L);
            return(DefMDIChildProc(hwnd, msg, wParam, lParam));

        case WM_PAINT:
            switch (OnPaint(hwnd))
                {
                case ONPAINT_SUCCESS:   return TRUE;
                case ONPAINT_FAIL:      return FALSE;
                case ONPAINT_NOCLIPBRD: PostMessage (hwnd, msg, wParam, lParam);
                default:                return FALSE;
                }
            break;

        case WM_KEYDOWN:
            {
            WORD sb;

            if (!(pMDI = GETMDIINFO(hwnd)))
                break;

            if ( pMDI->DisplayMode != DSP_PAGE )
                return (DefMDIChildProc(hwnd, msg, wParam, lParam));

            switch (wParam)
                {
                case VK_UP:
                    sb = SB_LINEUP;
                    goto VertScroll;
                case VK_DOWN:
                    sb = SB_LINEDOWN;
                    goto VertScroll;
                case VK_PRIOR:
                    sb = SB_PAGEUP;
                    goto VertScroll;
                case VK_NEXT:
                    sb = SB_PAGEDOWN;

                VertScroll:
                    SendMessage(hwnd, WM_VSCROLL, sb, 0L);
                    break;

                case VK_LEFT:
                    sb = SB_LINEUP;
                    goto HorzScroll;
                case VK_RIGHT:
                    sb = SB_LINEDOWN;
                    goto HorzScroll;
                case VK_TAB:
                    sb = (GetKeyState( VK_SHIFT ) < 0) ? SB_PAGEUP : SB_PAGEDOWN;
                HorzScroll:
                    SendMessage( hwnd, WM_HSCROLL, sb, 0L);
                    break;

                default:
                    return (DefMDIChildProc(hwnd, msg, wParam, lParam));
                }
            }
            break;

        case WM_SIZE:

            if (!(pMDI = GETMDIINFO(hwnd)))
                break;

            AdjustControlSizes( hwnd );
            pMDI->fDisplayFormatChanged = TRUE;
            InvalidateRect (hwnd, NULL, FALSE);

            if ( pMDI->DisplayMode == DSP_PAGE )
                ResetScrollInfo ( hwnd );

            return (DefMDIChildProc(hwnd, msg, wParam, lParam));

        case WM_DRAWITEM:

            HandleOwnerDraw( hwnd, msg, wParam, lParam );
            break;

        case WM_COMPAREITEM:

            if ( wParam != ID_LISTBOX )
               break;

            tmp = lstrcmpi (&((LPLISTENTRY)((LPCOMPAREITEMSTRUCT)lParam)->itemData1)->name[1],
                            &((LPLISTENTRY)((LPCOMPAREITEMSTRUCT)lParam)->itemData2)->name[1]);

            if ( tmp < 0 )
                {
                return -1;
                }
            else if (tmp > 0)
                {
                return 1;
                }
            else
                {
                return 0;
                }
            break;


        case WM_DELETEITEM:

            if ( wParam != ID_LISTBOX )
                break;

            // if item is marked for saving (for a new listbox), dont delete
            if ( ((LPLISTENTRY)((LPDELETEITEMSTRUCT)lParam)->itemData)->fDelete == FALSE )
                break;

            // delete preview bmp if there is one
            if (((LPLISTENTRY)((LPDELETEITEMSTRUCT)lParam)->itemData)->hbmp)
                DeleteObject (((LPLISTENTRY)((LPDELETEITEMSTRUCT)lParam)->itemData)->hbmp);

            GlobalFreePtr( (LPVOID)((LPDELETEITEMSTRUCT)lParam)->itemData );
            break;

        case WM_MEASUREITEM:

            lpmisCtl = (MEASUREITEMSTRUCT *) lParam;

            switch ( wParam )
                {
                case ID_LISTBOX:
                    if (!GETMDIINFO(hwnd))
                        break;

                    if (GETMDIINFO(hwnd)->DisplayMode == DSP_LIST)
                        lpmisCtl->itemHeight = max( LSTBTDY, dyPrevFont + 1);
                    else
                        lpmisCtl->itemHeight = 3*dyPrevFont + PREVBMPSIZ + 2*PREVBRD;

                    break;
                case ID_PAGEUP:
                case ID_PAGEDOWN:
                    lpmisCtl->itemWidth = GetSystemMetrics ( SM_CXHSCROLL );
                    lpmisCtl->itemHeight = GetSystemMetrics ( SM_CYVSCROLL );
                    break;
                }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
                case ID_LISTBOX:
                    if (!GETMDIINFO(hwnd))
                        break;

                    if (!(IsWindow(GETMDIINFO(hwnd)->hWndListbox)))
                        break;

                    switch(HIWORD(wParam))
                        {
                        case LBN_SETFOCUS:
                        case LBN_SELCHANGE:
                           UpdateNofMStatus(hwnd);
                           InitializeMenu( GetMenu(hwndApp));
                           break;
                        case LBN_SELCANCEL:
                        case LBN_KILLFOCUS:
                           break;
                        case LBN_DBLCLK:
                           // Double-clicks cause me to go to page view
                           SendMessage (hwndApp, WM_COMMAND, IDM_PAGEVIEW, 0L);
                           break;
                        }
                    break;

                case ID_PAGEUP:
                case ID_PAGEDOWN:
                    SendMessage ( hwndApp, WM_COMMAND, wParam, 0L );
                    break;

                default:
                    return(DefMDIChildProc(hwnd, WM_COMMAND, wParam, lParam));
                }
            break;


        case WM_SYSCOMMAND:
            // The Close menuitem on the system menus of the clipboard and
            // local clipbook windows should be greyed, so we shouldn't get
            // that message.
            switch ( wParam )
                {
                case SC_CLOSE:
                    if (!GETMDIINFO(hwnd))
                        break;

                    // don't allow close of local or clipboard
                    if (GETMDIINFO(hwnd)->flags & (F_LOCAL | F_CLPBRD))
                        wParam = SC_MINIMIZE;
                    break;
                default:
                    break;
                }
            return DefMDIChildProc(hwnd, msg, wParam, lParam );

        case WM_DESTROY:

            if (!(pMDI = GETMDIINFO(hwnd)))
                break;

            DdeDisconnect( pMDI->hExeConv );

            if (pMDI->hClpConv)
                 DdeDisconnect ( pMDI->hClpConv );
            if (pMDI->hVClpConv)
                 DdeDisconnect ( pMDI->hVClpConv );
            if (pMDI->hszConvPartner)
                 DdeFreeStringHandle ( idInst, pMDI->hszConvPartner );
            if (pMDI->hszConvPartnerNP)
                 DdeFreeStringHandle ( idInst, pMDI->hszConvPartnerNP );
            if (pMDI->hszClpTopic)
                 DdeFreeStringHandle ( idInst, pMDI->hszClpTopic );
            if (pMDI->hszVClpTopic)
                 DdeFreeStringHandle ( idInst, pMDI->hszVClpTopic );

            if (pMDI->pVClpbrd)
                 DestroyVClipboard ( pMDI->pVClpbrd );

            if (hwnd == hwndLocal)
                 hwndLocal = NULL;
            if (hwnd == hwndClpbrd)
                 hwndClpbrd = NULL;

            // free up the MDI info struct
            GlobalFree ( (HGLOBAL)pMDI );

            break;

        default:
            return (DefMDIChildProc(hwnd, msg, wParam, lParam));
        }

    return 0L;
}



/****************************************************************************
 *
 *  FUNCTION   : SendMessageToKids
 *
 *  PURPOSE    : Send the given message with the given parameters to all
 *               of the MDI child windows.
 *
 *  RETURNS    : None.
 *
 ****************************************************************************/

VOID SendMessageToKids(
   WORD    msg,
   WPARAM  wParam,
   LPARAM  lParam)
{
register HWND   hwndT;


    hwndT = GetWindow (hwndMDIClient, GW_CHILD);
    while (hwndT)
        {
        SendMessage (hwndT, msg, wParam, lParam);
        hwndT = GetWindow(hwndT, GW_HWNDNEXT);
        }
}



BOOL SyncOpenClipboard(
    HWND    hwnd)
{
BOOL fOK;

    if (!fClpOpen)
        {
        // PINFO(TEXT("\r\nClipbook: Opening Clipboard\r\n"));

        WaitForSingleObject(hmutexClp, 0); //INFINITE);
        fOK = OpenClipboard(hwnd);

        if (!fOK)
            {
            PERROR("OpenClipboard failed\r\n");
            ReleaseMutex(hmutexClp);
            }
        else
            {
            fClpOpen = TRUE;
            }

        return fOK;
        }
    else
        {
        PERROR("Attempt at opening clipboard twice!\r\n");
        return(FALSE);
        }

    return fOK;
}



BOOL SyncCloseClipboard (void)
{
BOOL fOK;

    // PINFO(TEXT("\r\nClipbook: Closing Clipboard\r\n"));

    fOK = CloseClipboard();
    ReleaseMutex(hmutexClp);

    if (!fOK)
        {
        PERROR("CloseClipboard failed\r\n");
        }

    fClpOpen = FALSE;

    return fOK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\clipbrd.h ===
/******************************************************************************

                        C L I P B R D   H E A D E R

    Name:       clipbrd.h
    Date:       1/20/94
    Creator:    John Fu

    Description:
        This is the header for clipbrd.c

******************************************************************************/


#define BIGRCBUF                64
#define SMLRCBUF                32

#define DDE_DIB2BITMAP          0xFFFFFFFF


extern  HANDLE  hmutexClp;
extern  HANDLE  hXacting;
extern  HANDLE  hmodNetDriver;

extern  HICON   hicClipbrd;
extern  HICON   hicClipbook;
extern  HICON   hicRemote;

extern  HICON   hicLock;                    // Icon for Lock on thumbnail bitmaps
extern  HFONT   hfontUni;                   // Handle for Unicode font, if it exists

extern  BOOL    fStatus;                    // status bar shown?
extern  BOOL    fToolBar;                   // tool bar shown?
extern  BOOL    fShareEnabled;              // sharing allowed in system.ini?
extern  BOOL    fNetDDEActive;              // NetDDE detected?
extern  BOOL    fAppLockedState;            // app UI locked (see LockApp())
extern  BOOL    fClipboardNeedsPainting;    // indicates deferred clp paint
extern  BOOL    fSharePreference;           // shared checked on paste?
extern  BOOL    fNeedToTileWindows;         // need to tile windows on size
extern  BOOL    fAppShuttingDown;           // in process of closing
extern  BOOL    fFillingClpFromDde;         // in process of adding clp formats
extern  BOOL    fAuditEnabled;

extern  HWND    hwndNextViewer;             // for clpbrd viewer chain
extern  HWND    hwndDummy;                  // used as dummy SetCapture target


// special case clipboard formats

extern  UINT    cf_bitmap;                      // we send/receive these in private 'packed' format
extern  UINT    cf_metafilepict;
extern  UINT    cf_palette;
extern  UINT    cf_preview;                     // PREVBMPSIZxPREVBMPSIZ preview bitmap private format


// these are formats that contain untranslated copies of link and objlink data

extern  UINT    cf_objectlinkcopy;
extern  UINT    cf_objectlink;
extern  UINT    cf_linkcopy;
extern  UINT    cf_link;


// DDEML
// These are effective constants created once and destroyed when we die

extern  HSZ     hszSystem;
extern  HSZ     hszTopics;
extern  HSZ     hszDataSrv;
extern  HSZ     hszFormatList;
extern  HSZ     hszClpBookShare;

extern  DWORD   dwCurrentHelpId ;


extern  WINDOWPLACEMENT Wpl;
extern  HOOKPROC        lpMsgFilterProc;
extern  HINSTANCE       hInst;
extern  HACCEL          hAccel;

extern  HFONT           hOldFont;
extern  HFONT           hFontStatus;
extern  HFONT           hFontPreview;


extern  HWND        hwndActiveChild;    // this handle identifies the currently active MDI window

extern  PMDIINFO    pActiveMDI;         // this pointer points to the MDI info struct of the
                                        // active MDI window IT SHOULD ALWAYS ==
                                        // GETMDIINFO(hwndActiveChild)

extern  HWND        hwndClpbrd;         // this handle identifies the clipboard window
extern  HWND        hwndLocal;          // this handle identifies the local clipbook window
extern  HWND        hwndClpOwner;       // this handle identifies the clipboard owning MDI child (if any)
extern  HWND        hwndMDIClient;      // handle to MDI Client window
extern  HWND        hwndApp;            // global app window
extern  HDC         hBtnDC;             // memory DC used for owner draw stuff
extern  HBITMAP     hOldBitmap;
extern  HBITMAP     hPreviewBmp;
extern  HBITMAP     hPgUpBmp;
extern  HBITMAP     hPgDnBmp;
extern  HBITMAP     hPgUpDBmp;
extern  HBITMAP     hPgDnDBmp;

extern  int         dyStatus;           // height of status bar
extern  int         dyButtonBar;        // height of button bar
extern  int         dyPrevFont;         // height of listbox font - height+external


extern  TCHAR       szHelpFile[];
extern  TCHAR       szChmHelpFile[];

extern  TCHAR       szClipBookClass[];  // frame window class
extern  TCHAR       szChild[];          // Class name for MDI window
extern  TCHAR       szDummy[];          // class name of hidden dummy window

extern  TCHAR       szNDDEcode[];
extern  TCHAR       szNDDEcode1[];
extern  TCHAR       szClpBookShare[];


// localized strings
extern  TCHAR       szHelv[SMLRCBUF];   // status line font
extern  TCHAR       szAppName[SMLRCBUF];
extern  TCHAR       szLocalClpBk[SMLRCBUF];
extern  TCHAR       szSysClpBrd[SMLRCBUF];
extern  TCHAR       szDataUnavail[BIGRCBUF];
extern  TCHAR       szReadingItem[BIGRCBUF];
extern  TCHAR       szViewHelpFmt[BIGRCBUF];
extern  TCHAR       szActivateFmt[BIGRCBUF];
extern  TCHAR       szRendering[BIGRCBUF];
extern  TCHAR       szDefaultFormat[BIGRCBUF];
extern  TCHAR       szGettingData[BIGRCBUF];
extern  TCHAR       szEstablishingConn[BIGRCBUF];
extern  TCHAR       szClipBookOnFmt[BIGRCBUF];
extern  TCHAR       szPageFmt[SMLRCBUF];
extern  TCHAR       szPageFmtPl[SMLRCBUF];
extern  TCHAR       szPageOfPageFmt[SMLRCBUF];
extern  TCHAR       szDelete[SMLRCBUF];
extern  TCHAR       szDeleteConfirmFmt[SMLRCBUF];
extern  TCHAR       szFileFilter[BIGRCBUF];
extern  TCHAR       *szFilter;


// Registry key strings
extern  TCHAR       szPref[];
extern  TCHAR       szConn[];
extern  TCHAR       szStatusbar[];
extern  TCHAR       szToolbar[];
extern  TCHAR       szShPref[];
extern  TCHAR       szEnableShr[];
extern  TCHAR       szDefView[];


#if DEBUG
extern  TCHAR       szDebug[];
#endif
extern  TCHAR       szNull[];


HKEY hkeyRoot;


extern  TCHAR       szBuf[SZBUFSIZ];
extern  TCHAR       szBuf2[SZBUFSIZ];

extern  TCHAR       szConvPartner[128];                 // bigger than max server name
extern  TCHAR       szKeepAs[MAX_NDDESHARENAME + 2];


extern  DWORD      idInst;                              // DDEML handle



//
// function prototypes
//

void OnDrawClipboard(
    HWND    hwnd);


LRESULT OnEraseBkgnd(
    HWND    hwnd,
    HDC     hdc);


LRESULT OnPaint(
    HWND    hwnd);


LRESULT CALLBACK FrameWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam);


LRESULT CALLBACK ChildWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam);


VOID SendMessageToKids (
    WORD    msg,
    WPARAM  wParam,
    LPARAM  lParam);


BOOL SyncOpenClipboard(
    HWND    hwnd);


BOOL SyncCloseClipboard(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\clipdsp.c ===
/*****************************************************************************

                        C L I P B O O K   D I S P L A Y

    Name:       clipdsp.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This module handles the drawing of the clipbook displays.

*****************************************************************************/


#define WIN31
#include <windows.h>
#include <strsafe.h>
#include "common.h"
#include "clipbook.h"
#include "clpbkrc.h"
#include "clipbrd.h"
#include "clipdsp.h"
#include "debugout.h"
#include "cvutil.h"


#define ifmtMax             (sizeof(rgfmt)/sizeof(WORD))


static MFENUMPROC   lpEnumMetaProc;


BOOL                fOwnerDisplay;
HBRUSH              hbrBackground;
HMENU               hDispMenu;



/* The scroll information for OWNER display is to be preserved, whenever
 * the display changes between OWNER and NON-OWNER; The following globals
 * are used to save and restore the scroll info.
 */

// winball: since only the Clipboard window supports owner display,
// this info is not replicated for each MDI child...

int   OwnVerMin;
int   OwnVerMax;
int   OwnHorMin;
int   OwnHorMax;

int   OwnVerPos;
int   OwnHorPos;



/* Defines priority order for show format */
WORD   rgfmt[] = {
                  CF_OWNERDISPLAY,

                  CF_UNICODETEXT,
                  CF_TEXT,
                  CF_OEMTEXT,


                  CF_ENHMETAFILE,
                  CF_METAFILEPICT,
                  CF_DIB,
                  CF_BITMAP,

                  CF_DSPTEXT,
                  CF_DSPBITMAP,
                  CF_DSPMETAFILEPICT,
                  CF_DSPENHMETAFILE,

                  CF_PALETTE,
                  CF_RIFF,
                  CF_WAVE,
                  CF_PENDATA,
                  CF_SYLK,
                  CF_DIF,
                  CF_TIFF,
                  CF_LOCALE
                  };


void ShowString( HWND, HDC, WORD);



/*
 *      MyOpenClipBoard
 */

BOOL MyOpenClipboard(
    HWND    hWnd)
{
HDC   hDC;
RECT  Rect;

    if( VOpenClipboard( GETMDIINFO(hWnd)->pVClpbrd, hWnd ))
        return(TRUE);


    PERROR(TEXT("MyOpenClipboard fail\r\n"));


    /* Some app forgot to close the clipboard */
    hDC = GetDC(hWnd);

    GetClientRect(hWnd, (LPRECT)&Rect);
    FillRect(hDC, (LPRECT)&Rect, hbrBackground);
    ShowString( hWnd, hDC, IDS_ALREADYOPEN);

    ReleaseDC(hWnd, hDC);


    return(FALSE);
}




/*
 *      SetCharDimensions
 */

void SetCharDimensions(
    HWND    hWnd,
    HFONT   hFont)

{
register HDC    hdc;
TEXTMETRIC      tm;
PMDIINFO        pMDI;


    pMDI = GETMDIINFO(hWnd);

    if (pMDI)
    {
        hdc = GetDC(hWnd);
        SelectObject(hdc, hFont);
        GetTextMetrics(hdc, (LPTEXTMETRIC)&tm);
        ReleaseDC(hWnd, hdc);

        pMDI->cxChar         = (WORD)tm.tmAveCharWidth;
        pMDI->cxMaxCharWidth = (WORD)tm.tmMaxCharWidth;
        pMDI->cyLine         = (WORD)(tm.tmHeight + tm.tmExternalLeading);
        pMDI->cxMargin       = pMDI->cxChar / 2;
        pMDI->cyMargin       = pMDI->cyLine / 4;
    }
}




/*
 *      ChangeCharDimensions
 */

void ChangeCharDimensions(
    HWND    hwnd,
    UINT    wOldFormat,
    UINT    wNewFormat)
{
    /* Check if the font has changed. */
    if (wOldFormat == CF_OEMTEXT)
        {
        if (wNewFormat != CF_OEMTEXT)       // Select default system font sizes
            SetCharDimensions(hwnd, GetStockObject ( SYSTEM_FONT ) );
        }
    else if (wNewFormat == CF_OEMTEXT)      // Select OEM font sizes
        SetCharDimensions(hwnd, GetStockObject ( OEM_FIXED_FONT ) );
}




/*
 *      ClipbrdVScroll
 *
 *  Scroll contents of window vertically, according to action code in wParam.
 */

void ClipbrdVScroll (
    HWND    hwnd,
    WORD    wParam,
    WORD    wThumb)
{
int         cyWindow;
long        dyScroll;
long        cyScrollT;
long        dyScrollAbs;
long        cyPartialChar;
PMDIINFO    pMDI;



    pMDI = GETMDIINFO(hwnd);

    if (pMDI)
    {

        /* Ensure that all the bits are valid first, before scrolling them */
        UpdateWindow(hwnd);

        cyScrollT = pMDI->cyScrollNow;
        cyWindow = pMDI->rcWindow.bottom - pMDI->rcWindow.top;

        /* Compute scroll results as an effect on cyScrollNow */
        switch (wParam)
            {
            case SB_LINEUP:
                cyScrollT -= pMDI->cyLine;
                break;

            case SB_LINEDOWN:
                cyScrollT += pMDI->cyLine;
                break;

            case SB_THUMBPOSITION:
                cyScrollT = (LONG)(((LONG)wThumb * pMDI->cyScrollLast) / VPOSLAST);
                break;

            case SB_PAGEUP:
            case SB_PAGEDOWN:
                {
                int   cyPageScroll;

                cyPageScroll = cyWindow - pMDI->cyLine;

                if (cyPageScroll < (int)(pMDI->cyLine))
                    cyPageScroll = pMDI->cyLine;

                cyScrollT += (wParam == SB_PAGEUP) ? -cyPageScroll : cyPageScroll;
                break;
                }

            default:
                return;
            }



        if ((cyScrollT < 0) || (pMDI->cyScrollLast <= 0))
            cyScrollT = 0;
        else if (cyScrollT > pMDI->cyScrollLast)
            cyScrollT = pMDI->cyScrollLast;
        else if (cyPartialChar = cyScrollT % pMDI->cyLine)
            {
            /* Round to the nearest character increment. */
            if (cyPartialChar > ((int)(pMDI->cyLine) >> 1))
                cyScrollT += pMDI->cyLine;
                cyScrollT -= cyPartialChar;
            }



        dyScroll = pMDI->cyScrollNow - cyScrollT;

        if (dyScroll > 0)
            dyScrollAbs = dyScroll;
        else if (dyScroll < 0)
            dyScrollAbs = -dyScroll;
        else
            return;             /* Scrolling has no effect here. */

        pMDI->cyScrollNow = cyScrollT;

        if (dyScrollAbs >= pMDI->rcWindow.bottom - pMDI->rcWindow.top)
            /* ScrollWindow does not handle this case */
            InvalidateRect(hwnd, (LPRECT)&(pMDI->rcWindow), TRUE);
        else
            ScrollWindow(hwnd, 0,(int)dyScroll, &(pMDI->rcWindow), &(pMDI->rcWindow));

        UpdateWindow(hwnd);

        SetScrollPos (pMDI->hwndVscroll,
                      SB_CTL,
                      (pMDI->cyScrollLast <= 0) ?
                      0 :
                      (int)((cyScrollT * (DWORD)VPOSLAST) / pMDI->cyScrollLast),
                      TRUE);
    }
}





/*
 *      ClipbrdHScroll
 *
 *  Scroll contents of window horizontally, according to op code in wParam.
 */

void ClipbrdHScroll (
    HWND    hwnd,
    WORD    wParam,
    WORD    wThumb)
{
register int    dxScroll;
register int    cxScrollT;
int             cxWindow;
int             dxScrollAbs;
int             cxPartialChar;
PMDIINFO        pMDI;



    pMDI = GETMDIINFO(hwnd);

    if (pMDI)
    {

        cxScrollT = pMDI->cxScrollNow;
        cxWindow = pMDI->rcWindow.right - pMDI->rcWindow.left;

        /* Compute scroll results as an effect on cxScrollNow */
        switch (wParam)
            {
            case SB_LINEUP:
                cxScrollT -= pMDI->cxChar;
                break;

            case SB_LINEDOWN:
                cxScrollT += pMDI->cxChar;
                break;

            case SB_THUMBPOSITION:
                cxScrollT = (int)(((LONG)wThumb * (LONG)pMDI->cxScrollLast) / HPOSLAST);
                break;

            case SB_PAGEUP:
            case SB_PAGEDOWN:
                {
                int   cxPageScroll;

                cxPageScroll = cxWindow - pMDI->cxChar;
                if (cxPageScroll < (int)(pMDI->cxChar))
                    cxPageScroll = pMDI->cxChar;

                cxScrollT += (wParam == SB_PAGEUP) ? -cxPageScroll : cxPageScroll;
                break;
                }

            default:
                return;
            }



        if ((cxScrollT < 0) || (pMDI->cxScrollLast <= 0))
            cxScrollT = 0;
        else if (cxScrollT > pMDI->cxScrollLast)
            cxScrollT = pMDI->cxScrollLast;
        else if (cxPartialChar = cxScrollT % pMDI->cxChar)
            { /* Round to the nearest character increment */
            if (cxPartialChar > ((int)(pMDI->cxChar) >> 1))
                cxScrollT += pMDI->cxChar;
                cxScrollT -= cxPartialChar;
            }



        /* Now we have a good cxScrollT value */

        dxScroll = pMDI->cxScrollNow - cxScrollT;
        if (dxScroll > 0)
            dxScrollAbs = dxScroll;
        else if (dxScroll < 0)
            dxScrollAbs = -dxScroll;
        else
            return;             /* Scrolling has no effect here. */


        pMDI->cxScrollNow = cxScrollT;

        if (dxScrollAbs >= pMDI->rcWindow.right - pMDI->rcWindow.left)
            /* ScrollWindow does not handle this case */
            InvalidateRect( hwnd, (LPRECT) &(pMDI->rcWindow), TRUE );
        else
            ScrollWindow(hwnd, dxScroll, 0, (LPRECT)&(pMDI->rcWindow),
            (LPRECT)&(pMDI->rcWindow));

        UpdateWindow(hwnd);

        SetScrollPos (pMDI->hwndHscroll,
                      SB_CTL,
                      (pMDI->cxScrollLast <= 0) ?
                      0 :
                      (int)(((DWORD)cxScrollT * (DWORD)HPOSLAST) / (DWORD)(pMDI->cxScrollLast)),
                      TRUE);
    }
}




/*
 *      DibPaletteSize
 */

int DibPaletteSize(
    LPBITMAPINFOHEADER  lpbi)
{
register int bits;
register int nRet;

    /* With the new format headers, the size of the palette is in biClrUsed
     * else is dependent on bits per pixel.
     */

    if (lpbi->biSize != sizeof(BITMAPCOREHEADER))
       {
       if (lpbi->biClrUsed != 0)
          {
          nRet = lpbi->biClrUsed * sizeof(RGBQUAD);
          }
       else
          {
          bits = lpbi->biBitCount;

          if (24 == bits)
             {
             nRet = 0;
             }
          else if (16 == bits || 32 == bits)
             {
             nRet = 3 * sizeof(DWORD);
             }
          else
             {
             nRet = (1 << bits) * sizeof(RGBQUAD);
             }
          }
       }
    else
       {
       bits = ((LPBITMAPCOREHEADER)lpbi)->bcBitCount;
       nRet = (bits == 24) ? 0 : (1 << bits) * sizeof(RGBTRIPLE);
       }

    return(nRet);
}




/*
 *      DibGetInfo
 */

void DibGetInfo(
    HANDLE      hdib,
    LPBITMAP    pbm)

{
LPBITMAPINFOHEADER lpbi;

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hdib);

    if (lpbi->biSize != sizeof(BITMAPCOREHEADER))
        {
        pbm->bmWidth  = (int)lpbi->biWidth;
        pbm->bmHeight = (int)lpbi->biHeight;
        }
    else
        {
        pbm->bmWidth  = (int)((LPBITMAPCOREHEADER)lpbi)->bcWidth;
        pbm->bmHeight = (int)((LPBITMAPCOREHEADER)lpbi)->bcHeight;
        }

    GlobalUnlock(hdib);
}




/*
 *      DrawDib
 */

BOOL DrawDib(
    HWND    hwnd,
    HDC     hdc,
    int     x0,
    int     y0,
    HANDLE  hdib)
{
LPBITMAPINFOHEADER  lpbi;
BITMAP              bm;
LPSTR               lpBits;
BOOL                fOK = FALSE;

    if (hdib)
        {
        lpbi = (LPBITMAPINFOHEADER)GlobalLock(hdib);

        if (lpbi)
            {
            DibGetInfo(hdib, (LPBITMAP)&bm);

            lpBits = (LPSTR)lpbi + (WORD)lpbi->biSize + DibPaletteSize(lpbi);

            SetDIBitsToDevice (hdc,
                               x0,
                               y0,
                               bm.bmWidth,
                               bm.bmHeight,
                               0,
                               0,
                               0,
                               bm.bmHeight,
                               lpBits,
                               (LPBITMAPINFO)lpbi,
                               DIB_RGB_COLORS);

            GlobalUnlock(hdib);
            fOK = TRUE;
            }
        }

    return(fOK);
}




/*
 *      FShowDIBitmap
 */

BOOL FShowDIBitmap (
    HWND            hwnd,
    register HDC    hdc,
    PRECT           prc,
    HANDLE          hdib,   //Bitmap in DIB format
    int             cxScroll,
    int             cyScroll)
{
BITMAP    bm;
PMDIINFO pMDI;

    pMDI = GETMDIINFO(hwnd);

    if (pMDI)
    {
        DibGetInfo(hdib, (LPBITMAP)&bm);


        // If window's been resized, determine maximum scroll positions.
        if (pMDI->cyScrollLast == -1)
            {
            /* Compute last scroll offset into bitmap */
            pMDI->cyScrollLast = bm.bmHeight -
                (pMDI->rcWindow.bottom - pMDI->rcWindow.top);
            if (pMDI->cyScrollLast < 0)
               {
               pMDI->cyScrollLast = 0;
               }
            }

        if (pMDI->cxScrollLast == -1)
            {
            /* Compute last scroll offset into bitmap */
            pMDI->cxScrollLast = bm.bmWidth -
                (pMDI->rcWindow.right - pMDI->rcWindow.left);
            if (pMDI->cxScrollLast < 0)
               {
               pMDI->cxScrollLast = 0;
               }
            }
    }

    SaveDC(hdc);
    IntersectClipRect (hdc, prc->left, prc->top, prc->right, prc->bottom);
    SetViewportOrgEx (hdc,prc->left - cxScroll, prc->top - cyScroll,NULL);
    DrawDib (hwnd, hdc, 0, 0, hdib);
    RestoreDC(hdc, -1);

    return(TRUE);
}




/*
 *      FShowBitmap
 */

BOOL FShowBitmap (
    HWND            hwnd,
    HDC             hdc,
    register PRECT  prc,
    HBITMAP         hbm,
    int             cxScroll,
    int             cyScroll)
{
register HDC    hMemDC;
BITMAP          bitmap;
int             cxBlt, cyBlt;
int             cxRect, cyRect;
PMDIINFO        pMDI;

    pMDI = GETMDIINFO(hwnd);

    if ((hMemDC = CreateCompatibleDC(hdc)) == NULL)
        return(FALSE);

    if (!SelectObject(hMemDC, (HBITMAP)hbm))
        {
        DeleteDC(hMemDC);
        ShowString( hwnd, hdc, IDS_BADBMPFMT );
        return TRUE;
        }

    GetObject((HBITMAP)hbm, sizeof(BITMAP), (LPSTR)&bitmap);


    if (pMDI->cyScrollLast == -1)
        {
        /* Compute last scroll offset into bitmap */
        pMDI->cyScrollLast = bitmap.bmHeight - (pMDI->rcWindow.bottom - pMDI->rcWindow.top);
        if (pMDI->cyScrollLast < 0)
            pMDI->cyScrollLast = 0;
        }

    if ( pMDI->cxScrollLast == -1)
        {
         /* Compute last scroll offset into bitmap */
        pMDI->cxScrollLast = bitmap.bmWidth - (pMDI->rcWindow.right - pMDI->rcWindow.left);
        if ( pMDI->cxScrollLast < 0)
            pMDI->cxScrollLast = 0;
        }


    cxRect = prc->right - prc->left;
    cyRect = prc->bottom - prc->top;
    cxBlt = min(cxRect, bitmap.bmWidth - cxScroll);
    cyBlt = min(cyRect, bitmap.bmHeight - cyScroll);

    BitBlt (hdc,
            prc->left,
            prc->top,
            cxBlt,
            cyBlt,
            hMemDC,
            cxScroll,
            cyScroll,    /* X,Y offset into source DC */
            SRCCOPY);

    DeleteDC(hMemDC);

    return(TRUE);
}



#define DXPAL  (pMDI->cyLine)
#define DYPAL  (pMDI->cyLine)

////////////////////////////////////////////////////////////////////////////
//
//  FShowPalette()
//
//  Parameters:
//    hwnd - The wMDI child we're drawing in.
//    hdc - DC for the window.
//    prc - Rectangle to draw.
//    hpal - The palette to display.
//    cxScroll, cyScroll - Scroll position in pels OF PRC. NOT OF THE WINDOW.
//       Derive window scroll position by doing a cxScroll -= pMDI->cxScrollNow
//
////////////////////////////////////////////////////////////////////////////

BOOL FShowPalette(
    HWND hwnd,
    register HDC    hdc,
    register PRECT  prc,
    HPALETTE        hpal,
    int             cxScroll,
    int             cyScroll)
{
int         n;
int         x, y;
int         nx, ny;
int         nNumEntries;
RECT        rc;
HBRUSH      hbr;
PMDIINFO    pMDI;
BOOL        fOK = FALSE;
TCHAR       achHex[] = TEXT("0123456789ABCDEF");
int         nFirstLineDrawn;



    PINFO(TEXT("Palette: (%d,%d-%d,%d),cx %d, cy %d\r\n"),
       prc->left, prc->top, prc->right, prc->bottom, cxScroll, cyScroll);


    pMDI = GETMDIINFO(hwnd);

    if (hpal)
       {
       // Correct cyScroll to show window's scroll position, not prc's.
       cyScroll -= prc->top - pMDI->rcWindow.top;
       PINFO(TEXT("Corrected cyScroll %d\r\n"), cyScroll);

       // GetObject does not return an int-- it returns a USHORT. Thus,
       // we zero out nNumEntries before getobjecting the palette.
       nNumEntries = 0;
       GetObject(hpal, sizeof(int), (LPSTR)&nNumEntries);

       // Figure how many boxes across and tall the array of color boxes
       // is
       nx = ((pMDI->rcWindow.right - pMDI->rcWindow.left) / DXPAL);
       if (nx == 0)
          {
          nx = 1;
          }
       ny = (nNumEntries + nx - 1) / nx;
       PINFO(TEXT("%d entries, %d by %d array\r\n"), nNumEntries, nx, ny);

       // If the window's been resized, we have to tell it how far you
       // can scroll off to the right and down.
       if ( pMDI->cyScrollLast == -1)
          {
          pMDI->cyScrollLast = ny * DYPAL -                  // Height of palette minus
                pMDI->rcWindow.bottom - pMDI->rcWindow.top + // height of window plus
                DYPAL;                                       // one palette entry height.

          if ( pMDI->cyScrollLast < 0)
             {
             pMDI->cyScrollLast = 0;
             }
          PINFO(TEXT("Last allowed scroll: %d\r\n"), pMDI->cyScrollLast);
          }
       if ( pMDI->cxScrollLast == -1)
          {
          /* Can't scroll palettes horizontally. */
          pMDI->cxScrollLast = 0;
          }

       SaveDC(hdc);
       IntersectClipRect(hdc, prc->left, prc->top, prc->right, prc->bottom);
       SetWindowOrgEx(hdc, -pMDI->rcWindow.left, -pMDI->rcWindow.top, NULL);

       // Set up the x and y positions of the first palette entry to draw
       // and figure out which palette entry IS the first that needs drawing.
       x = 0;
       nFirstLineDrawn = (cyScroll + prc->top - pMDI->rcWindow.top)/ DYPAL;
       n = nx * nFirstLineDrawn;
       y = DYPAL * nFirstLineDrawn - cyScroll;
       PINFO(TEXT("First entry %d at %d, %d\r\n"), n, x, y);

       // While n < number of entries and the current entry isn't off the bottom
       // of the window
       while (n < nNumEntries && y < prc->bottom)
          {
          // Figure out a DXPAL by DYPAL rect going down/right from x,y
          rc.left   = x;
          rc.top    = y;
          rc.right  = rc.left + DXPAL;
          rc.bottom = rc.top + DYPAL;
          // PINFO(TEXT("(%d,%d) "), rc.left, rc.top);

          // Draw a black box with the appropriate color inside.
          if (RectVisible(hdc, &rc))
             {
             // PINFO(TEXT("<"));

             // If you change this one to zero, you get a text display of
             // the palette indices-- I used it to debug the draw code, 'cause
             // it's near impossible, when you've got little colored
             // squares, to figure out just which color is on the bottom of THAT
             // square THERE, the one that was scrolled halfway off the bottom
             // of the window, and you just scrolled it on. ("Well, it's sorta
             // purple... of course, this entire palette is sorta purple..")
             #if 1
             InflateRect(&rc, -1, -1);
             FrameRect(hdc, &rc, GetStockObject(BLACK_BRUSH));
             InflateRect(&rc, -1, -1);
             hbr = CreateSolidBrush(PALETTEINDEX(n));
             FillRect(hdc, &rc, hbr);
             DeleteObject(hbr);
             #else
             SetBkMode(hdc, TRANSPARENT);
             TextOut(hdc, rc.left + 2, rc.top + 2, &achHex[(n / 16)&0x0f], 1);
             TextOut(hdc, (rc.left + rc.right) / 2, rc.top + 2,
                   &achHex[n & 0x0f], 1);
             #endif
             }

          // Go to next entry and advance x to the next position, "word
          // wrapping" to next line if we need to
          n++;
          x += DXPAL;
          if (0 == n % nx)
             {
             x = 0;
             y += DYPAL;
             PINFO(TEXT("Wrap at %d\r\n"), n);
             }
          }
       RestoreDC(hdc, -1);
       fOK = TRUE;
       }
    else
       {
       PERROR(TEXT("Bad palette!\r\n"));
       }
    return(fOK);
}




/*
 *      PxlConvert
 *
 * Return the # of pixels spanned by 'val', a measurement in coordinates
 * appropriate to mapping mode mm.  'pxlDeviceRes' gives the resolution
 * of the device in pixels, along the axis of 'val'. 'milDeviceRes' gives
 * the same resolution measurement, but in millimeters.
 */

int PxlConvert(
    int mm,
    int val,
    int pxlDeviceRes,
    int milDeviceRes)
{
register WORD   wMult = 1;
register WORD   wDiv = 1;
DWORD           ulPxl;
DWORD           ulDenom;
DWORD           ulMaxInt = 0x7FFF;

    if (milDeviceRes == 0)
        {
        /* to make sure we don't get divide-by-0 */
        return(0);
        }

    switch (mm)
        {
        case MM_LOMETRIC:
            wDiv = 10;
            break;

        case MM_HIMETRIC:
            wDiv = 100;
            break;

        case MM_TWIPS:
            wMult = 254;
            wDiv = 14400;
            break;

        case MM_LOENGLISH:
            wMult = 2540;
            wDiv = 10000;
            break;

        case MM_HIENGLISH:
            wMult = 254;
            wDiv = 10000;
            break;

        case MM_TEXT:
            return(val);

        case MM_ISOTROPIC:
        case MM_ANISOTROPIC:
            /* These picture types have no original size */
        default:
            return(0);
        }

    /* Add denominator - 1 to numerator, to avoid roundoff */

    ulDenom = (DWORD)wDiv * (DWORD)milDeviceRes;
    ulPxl = (((DWORD)((DWORD)wMult * (DWORD)val * (DWORD)pxlDeviceRes)) + ulDenom - 1) / ulDenom;

    return((ulPxl > ulMaxInt) ? 0 : (int)ulPxl);
}









/*
 *      FShowEnhMetaFile
 *
 * Display an enhanced metafile in the specified rectangle.
 */

BOOL FShowEnhMetaFile(
    HWND            hwnd,
    register HDC    hdc,
    register PRECT  prc,
    HANDLE          hemf,
    int             cxScroll,
    int             cyScroll)
{
int         cxBitmap;
int         cyBitmap;
RECT        rcWindow;
int         f = FALSE;
PMDIINFO    pMDI;



    pMDI = GETMDIINFO(hwnd);

    if (pMDI)
    {

        /* Not scrollable.  Resize these into the given rect. */

        pMDI->cyScrollLast = 0;
        pMDI->cxScrollLast = 0;

        cxBitmap = pMDI->rcWindow.right - pMDI->rcWindow.left;
        cyBitmap = pMDI->rcWindow.bottom - pMDI->rcWindow.top;


        /* We make the "viewport" to be an area the same size as the
         * clipboard object, and set the origin and clip region so as
         * to show the area we want. Note that the viewport may well be
         * bigger than the window.
         */

        SetMapMode(hdc, MM_TEXT);

        rcWindow.left   = prc->left - cxScroll;
        rcWindow.top    = prc->top  - cyScroll;
        rcWindow.right  = rcWindow.left + cxBitmap;
        rcWindow.bottom = rcWindow.top  + cyBitmap;

        f = PlayEnhMetaFile (hdc, hemf, &rcWindow);



        // Always return TRUE. PlayEnhMetaFile() can return
        // FALSE even when the metafile can be displayed
        // properly.  Things such as printer escap can cause
        // the call to return FALSE when painting to screen
        // but the image will be displayed fine.
        //
        // We return TRUE so we don't blank the display and
        // put "Clipbook can't display..." message.
    }

    return TRUE;

}



/*
 *      EnumMetafileProc
 *
 *  Metafile record play callback function used to work around problem
 *  with non active MDI children playing a metafile that causes a foreground
 *  palette selection
 */

BOOL CALLBACK EnumMetafileProc (
    HDC             hdc,
    HANDLETABLE FAR *lpht,
    METARECORD FAR  *lpmr,
    int             cObj,
    LPARAM          lParam )
{
    if ( lpmr->rdFunction == META_SELECTPALETTE )
       {
       return SelectPalette ( hdc, lpht[(lpmr->rdParm[0])].objectHandle[0],
             TRUE ) != NULL;
       }
    else
       {
       PlayMetaFileRecord ( hdc, lpht, lpmr, cObj );
       return TRUE;
       }
}



/*
 *      FShowMetaFilePict
 *
 *  Display a metafile in the specified rectangle.
 */

BOOL FShowMetaFilePict(
    HWND            hwnd,
    register HDC    hdc,
    register PRECT  prc,
    HANDLE          hmfp,
    int             cxScroll,
    int             cyScroll)
{
int             level;
int             cxBitmap;
int             cyBitmap;
int             f = FALSE;
LPMETAFILEPICT  lpmfp;
PMDIINFO        pMDI;



    pMDI = GETMDIINFO(hwnd);

    if (pMDI)
    {

        if ((lpmfp = (LPMETAFILEPICT)GlobalLock( hmfp )) != NULL)
            {
            METAFILEPICT mfp;

            mfp = *lpmfp;
            GlobalUnlock( hmfp );

            if ((level = SaveDC( hdc )) != 0)
                {

                /* Compute size of picture to be displayed */
                switch (mfp.mm)
                    {
                    case MM_ISOTROPIC:
                    case MM_ANISOTROPIC:
                        /* Not scrollable.  Resize these into the given rect. */
                        pMDI->cyScrollLast = 0;
                        pMDI->cxScrollLast = 0;
                        cxBitmap = pMDI->rcWindow.right - pMDI->rcWindow.left;
                        cyBitmap = pMDI->rcWindow.bottom - pMDI->rcWindow.top;
                        break;

                    default:
                        cxBitmap = PxlConvert(mfp.mm, mfp.xExt, GetDeviceCaps(hdc, HORZRES), GetDeviceCaps(hdc, HORZSIZE));
                        cyBitmap = PxlConvert(mfp.mm, mfp.yExt, GetDeviceCaps(hdc, VERTRES), GetDeviceCaps(hdc, VERTSIZE));
                        if (!cxBitmap || !cyBitmap)
                            {
                            goto NoDisplay;
                            }

                        if ( pMDI->cxScrollLast == -1)
                            {
                            pMDI->cxScrollLast =
                                cxBitmap - (pMDI->rcWindow.right - pMDI->rcWindow.left);
                            if ( pMDI->cxScrollLast < 0)
                                {
                                pMDI->cxScrollLast = 0;
                                }
                            }

                        if (pMDI->cyScrollLast == -1)
                            {
                            pMDI->cyScrollLast =
                                cyBitmap - (pMDI->rcWindow.bottom - pMDI->rcWindow.top);
                            if (pMDI->cyScrollLast < 0)
                                {
                                pMDI->cyScrollLast = 0;
                                }
                            }
                        break;
                    }

                    /* We make the "viewport" to be an area the same size as the
                     * clipboard object, and set the origin and clip region so as
                     * to show the area we want. Note that the viewport may well be
                     * bigger than the window.
                     */
                    SetMapMode(hdc, mfp.mm);

                    SetViewportOrgEx(hdc, prc->left - cxScroll, prc->top - cyScroll, NULL);
                    switch (mfp.mm)
                        {
                        case MM_ISOTROPIC:
                            if (mfp.xExt && mfp.yExt)
                               {
                               // So we get the correct shape rectangle when
                               // SetViewportExt gets called.
                               //
                               SetWindowExtEx(hdc, mfp.xExt, mfp.yExt, NULL);
                               }
                            //  FALL THRU

                        case MM_ANISOTROPIC:
                            SetViewportExtEx(hdc, cxBitmap, cyBitmap, NULL);
                            break;
                        }

                /* Since we may have scrolled, force brushes to align */
                SetBrushOrgEx(hdc, cxScroll - prc->left, cyScroll - prc->top, NULL);

                f = EnumMetaFile(hdc, mfp.hMF, EnumMetafileProc, 0L );
                FreeProcInstance ( (FARPROC) lpEnumMetaProc );

          NoDisplay:
                RestoreDC(hdc, level);
               }
            }
    }

    return(f);
}



/*
 *      ShowString
 *
 *  Blank rcWindow and show the string on the top line of the client area
 */

void ShowString(
    HWND    hwnd,
    HDC     hdc,
    WORD    id)
{
TCHAR   szBuffer[BUFFERLEN];
LPTSTR  pszBuffer   = szBuffer;
INT     iBufferSize = BUFFERLEN;

INT     iStringLen;


    /* Cancel any scrolling effects. */
    GETMDIINFO(hwnd)->cyScrollNow = 0;
    GETMDIINFO(hwnd)->cxScrollNow = 0;


    iStringLen = LoadString(hInst, id, pszBuffer, BUFFERLEN);


    // Is the buffer completely filled out?
    // We need a bigger one if yes.

    while (iStringLen == BUFFERLEN -1)
        {
        if (pszBuffer != szBuffer && pszBuffer)
            LocalFree (pszBuffer);

        iBufferSize *= 2;
        pszBuffer = LocalAlloc (LPTR, iBufferSize);

        if (!pszBuffer)
            goto done;

        iStringLen = LoadString (hInst, id, pszBuffer, iBufferSize);
        }


    FillRect (hdc, &(GETMDIINFO(hwnd)->rcWindow), hbrBackground);
    DrawText (hdc, pszBuffer, -1, &(GETMDIINFO(hwnd)->rcWindow),
              DT_CENTER | DT_WORDBREAK | DT_TOP);

done:

    if (pszBuffer != szBuffer && pszBuffer)
        LocalFree (pszBuffer);

}




/*
 *      CchLineA
 *
 *
 * Determine the # of characters in one display line's worth of lpch.
 * lpch is assumed to be an ansi string.
 *
 * Return the following:
 *       HI WORD:    # of chars to display (excludes CR, LF; will not
 *                   exceed cchLine)
 *       LO WORD:    offset of start of next line in lpch; If the current line
 *                   is NULL terminated, this contains offset to the NULL char;
 *       In RgchBuf: characters to display
 *
 *   Expands Tabs
 *
 *   Accepts any of the following as valid end-of-line terminators:
 *       CR, LF, CR-LF, LF-CR, NULL
 *   Callers may test for having reached NULL by (lpch[LOWORD] == '\0')
 */

LONG CchLineA(
    PMDIINFO    pMDI,
    HDC         hDC,
    CHAR        rgchBuf[],
    CHAR FAR    *lpch,
    INT         cchLine,
    WORD        wWidth)
{
CHAR            ch;
CHAR            *pch = rgchBuf;
register INT    cchIn = 0;
register INT    cchOut = 0;
INT             iMinNoOfChars;
SIZE            size;
INT             iTextWidth = 0;



    iMinNoOfChars = wWidth / pMDI->cxMaxCharWidth;

    while (cchOut < cchLine)
        {
        switch (ch = *(lpch + (DWORD)cchIn++))
            {
            case '\0':
                /* cchIn is already incremented; So, it is pointing to
                 * a character beyond the NULL; So, decrement it.
                 */
                cchIn--;
                goto DoubleBreak;

            case '\015':  /* CR */
            case '\012':  /* LF */
                if ((lpch[cchIn] == '\015') || (lpch[cchIn] == '\012'))
                    cchIn++;
                goto DoubleBreak;

            case '\011':  /* TAB */
                {
                INT   cchT = 8 - (cchOut % 8);

                /* Check if the width has exceeded or the total
                 * number of characters has exceeded
                 */
                if (((WORD)(iTextWidth + cchT * pMDI->cxChar) > wWidth) || ((cchOut+cchT) >= cchLine))
                   /* Tab causes wrap to next line */
                    goto DoubleBreak;

                while (cchT--)
                    rgchBuf[cchOut++] = ' ';
                break;
                }

            default:
                rgchBuf[cchOut++] = ch;
                if( IsDBCSLeadByte(ch) )
                    rgchBuf[cchOut++] = *(lpch + (DWORD)cchIn++);

            break;
            }

        /* Check if the width has been exceeded. */
        if (cchOut >= iMinNoOfChars)
            {
            GetTextExtentPointA(hDC, rgchBuf, cchOut, (LPSIZE)&size);
            iTextWidth = size.cx;
            if ((WORD)iTextWidth == wWidth)
                break;
            else if((WORD)iTextWidth > wWidth)
                {
                    if (IsDBCSLeadByte(ch))
                        {
                        cchOut--;
                        cchIn--;
                        }

                cchOut--;
                cchIn--;
                break;
                }

            iMinNoOfChars += (wWidth - iTextWidth) / pMDI->cxMaxCharWidth;
            }
        }


DoubleBreak:
    return(MAKELONG(cchIn, cchOut));

}






/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  CchLineW() -                                                             */
/*                                                                            */
/*--------------------------------------------------------------------------*/

/*Same as previous function but takes unicode strings.
 */

LONG CchLineW(
    PMDIINFO    pMDI,
    HDC         hDC,
    WCHAR       rgchBuf[],
    WCHAR FAR   *lpch,
    INT         cchLine,
    WORD        wWidth)
{
register INT    cchIn = 0;
register INT    cchOut = 0;
WCHAR           ch;
WCHAR           *pch = rgchBuf;
INT             iMinNoOfChars;
INT             iTextWidth = 0;
SIZE            size;


    iMinNoOfChars = wWidth / pMDI->cxMaxCharWidth;

    while (cchOut < cchLine)
        {
        switch (ch = *(lpch + (DWORD)cchIn++))
            {
            case L'\0':
                 /* cchIn is already incremented; So, it is pointing to
                 * a character beyond the NULL; So, decrement it.
                 */
                cchIn--;
                goto DoubleBreak;

            case L'\015':  /* CR */
            case L'\012':  /* LF */
                if ((lpch[cchIn] == L'\015') || (lpch[cchIn] == L'\012'))
                    cchIn++;
                goto DoubleBreak;

            case L'\011':  /* TAB */
                {
                INT   cchT = 8 - (cchOut % 8);

                /* Check if the width has exceeded or the total
                 * number of characters has exceeded
                 */
                if (((WORD)(iTextWidth + cchT * pMDI->cxChar) > wWidth) || ((cchOut+cchT) >= cchLine))
                    /* Tab causes wrap to next line */
                    goto DoubleBreak;

                while (cchT--)
                    rgchBuf[cchOut++] = L' ';
                break;
                }

            default:
                rgchBuf[cchOut++] = ch;
                break;
            }


        /* Check if the width has been exceeded. */
        if (cchOut >= iMinNoOfChars)
            {
            GetTextExtentPointW(hDC, rgchBuf, cchOut, &size);
            iTextWidth = size.cx;
            if ((WORD)iTextWidth == wWidth)
                break;
            else if((WORD)iTextWidth > wWidth)
                {
                  cchOut--;
                  cchIn--;
                  break;
                }

            iMinNoOfChars += (wWidth - iTextWidth) / pMDI->cxMaxCharWidth;
            }
        }


DoubleBreak:

  return(MAKELONG(cchIn, cchOut));

}



#define cchLineMax  200


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  ShowText() -                                                            */
/*                                                                            */
/*--------------------------------------------------------------------------*/

void ShowText(
    HWND            hwnd,
    register HDC    hdc,
    PRECT           prc,
    HANDLE          h,
    INT             cyScroll,
    BOOL            fUnicode)
{

CHAR FAR  *lpch;
INT       yT;
INT       cLine;
INT       cLineAllText = 0;
RECT      rc;
INT       yLine;
INT       iLineFirstShow;
WORD      wLen;
WORD      wWidth;
CHAR      rgch[cchLineMax*sizeof(WCHAR)];
PMDIINFO  pMDI;



    pMDI= GETMDIINFO(hwnd);

    rc = *prc;

    /* Expand repaint rectangle as necessary to hold an exact number of
     * lines and start on an even line boundary. This is because we may
     * get arbitrarily weird repaint rectangles when popups are moved.
     * Scrolling repaint areas should require no adjustment.
     */

    rc.top -= (rc.top - pMDI->rcWindow.top) % pMDI->cyLine;



    /* If expanding the repaint rectangle to the next line expands it */
    /* beyond the bottom of my window, contract it one line.          */
    if ((yT = (rc.bottom - rc.top) % pMDI->cyLine) != 0)
        if ((rc.bottom += pMDI->cyLine - yT) > pMDI->rcWindow.bottom)
            rc.bottom -= pMDI->cyLine;

    if (rc.bottom <= rc.top)
        return;

    if (((wWidth = (WORD)(pMDI->rcWindow.right - pMDI->rcWindow.left)) <= 0) ||
        ((cLine = (rc.bottom - rc.top) / pMDI->cyLine) <= 0)         ||
        (NULL == (lpch = (LPSTR)GlobalLock(h))) )
        {
        /* Bad Rectangle or Bad Text Handle */
        ShowString(hwnd, hdc, IDS_ERROR);
        return;
        }



    /* Advance lpch to point at the text for the first line to show. */
    iLineFirstShow = cyScroll / pMDI->cyLine;


    /* Advance lpch to point at text for that line. */
    if (!fUnicode)
        while ((*lpch) && (iLineFirstShow--))
            {
            lpch += LOWORD(CchLineA(pMDI,hdc, rgch, lpch, cchLineMax, wWidth));
            cLineAllText++;
            }
    else
        while ((*((WCHAR *)lpch)) && (iLineFirstShow--))
            {
            lpch += ((LOWORD(CchLineW(pMDI, hdc, (WCHAR *)rgch, (WCHAR FAR *)lpch,
                  cchLineMax, wWidth)))*sizeof(WCHAR));
            cLineAllText++;
            }


    /* Display string, line by line */
    yLine = rc.top;
    while (cLine--)
        {
        LONG lT;

        if (!fUnicode)
            {
            lT = CchLineA(pMDI, hdc, rgch, lpch, cchLineMax, wWidth);
            }
        else
            {
            lT = CchLineW(pMDI, hdc, (WCHAR *)rgch, (WCHAR FAR *)lpch, cchLineMax, wWidth);
            }
        wLen = LOWORD(lT);
        if (!fUnicode)
            {
            TextOutA(hdc, rc.left, yLine, (LPSTR) rgch, HIWORD(lT));
            lpch += wLen;
            }
        else
            {
            if (!TextOutW(hdc, rc.left, yLine, (LPCWSTR) rgch, HIWORD(lT)))
                {
                GetLastError();
                }
            lpch += (wLen * sizeof(WCHAR));
            }
        yLine += pMDI->cyLine;
        cLineAllText++;
        if ((!fUnicode && (*lpch == 0)) || (fUnicode && (*((WCHAR *)lpch) == L'\0')))
            {
            break;
            }
        }


    if (pMDI->cxScrollLast == -1)
        {
        /* We don't use horiz scroll for text */
        pMDI->cxScrollLast = 0;
        }

    if (pMDI->cyScrollLast == -1)
        {
        INT   cLineInRcWindow;

        /* Validate y-size of text in clipboard. */
        /* Adjust rcWindow dimensions for text display */
        cLineInRcWindow = (pMDI->rcWindow.bottom - pMDI->rcWindow.top) / pMDI->cyLine;

        do {
           if (!fUnicode)
               {
               lpch += LOWORD(CchLineA(pMDI, hdc, rgch, lpch, cchLineMax, wWidth));
               }
           else
               {
               lpch += ((LOWORD(CchLineW(pMDI, hdc, (WCHAR *)rgch,
                   (WCHAR FAR *)lpch, cchLineMax, wWidth)))*sizeof(WCHAR));
               }
           cLineAllText++;
           }
           while ((!fUnicode && (*lpch != 0)) || (fUnicode && ((*lpch != 0) || (*(lpch+1) != 0))));

        pMDI->cyScrollLast = (cLineAllText - cLineInRcWindow) * pMDI->cyLine;
        if (pMDI->cyScrollLast < 0)
            {
            pMDI->cyScrollLast = 0;
            }

       /* Restrict rcWindow so that it holds an exact # of text lines */
        pMDI->rcWindow.bottom = pMDI->rcWindow.top + (cLineInRcWindow * pMDI->cyLine);
        }


    GlobalUnlock(h);

}




/*
 *      SendOwnerMessage
 */

void SendOwnerMessage(
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
register HWND hwndOwner;

    /* Send a message to the clipboard owner, if there is one */
    hwndOwner = GetClipboardOwner();

    if (hwndOwner != NULL)
        SendMessage(hwndOwner, message, wParam, lParam);

}




/*
 *      SendOwnerSizeMessage
 *
 *  Send WM_SIZECLIPBOARD message to clipboard owner.
 *    wParam is a handle to the clipboard window
 *    LOWORD(lParam) is a handle to the passed rect
 */

void SendOwnerSizeMessage (
    HWND    hwnd,
    int     left,
    int     top,
    int     right,
    int     bottom)
{
register HANDLE hrc;
LPRECT          lprc;



    if ((hrc = GlobalAlloc (GMEM_MOVEABLE | GMEM_LOWER, (LONG)sizeof(RECT))) != NULL )
        {
        if ((lprc = (LPRECT)GlobalLock(hrc)) != NULL )
            {
            lprc->top    = top;
            lprc->bottom = bottom;
            lprc->left   = left;
            lprc->right  = right;
            GlobalUnlock(hrc);
            SendOwnerMessage(WM_SIZECLIPBOARD, (WPARAM)hwnd, (LPARAM)hrc);
            }
        GlobalFree(hrc);
        }

}




/*
 *      GetBestFormat
 *
 *  This routine decides which one of the existing formats is to be
 *  displayed in the viewer.
 */

UINT GetBestFormat(
    HWND    hwnd,
    UINT    wFormat)
{
register WORD   cFmt;
register WORD   *pfmt;


    // PINFO(TEXT("GBFormat %d\r\n"), wFormat);

    if (wFormat == CBM_AUTO)
        {
        for (cFmt=ifmtMax, pfmt=&rgfmt[0]; cFmt--; pfmt++)
            {
            // PINFO(TEXT("Looking at # %d, (%d)\r\n"), cFmt, *pfmt);
            if ( VIsClipboardFormatAvailable( GETMDIINFO(hwnd)->pVClpbrd, *pfmt ))
                {
                return(*pfmt);
                }
            }
        return(0);
        }

    return(wFormat);

}




/*
 *      GetClipboardName
 */

void GetClipboardName (
    register int    fmt,
    LPTSTR          szName,
    register int    iSize)
{
LPTSTR  lprgch;
HANDLE  hrgch;



    *szName = '\0';


    /* Get global memory that everyone can get to */
    if ((hrgch = GlobalAlloc(GMEM_MOVEABLE | GMEM_LOWER, (LONG)(iSize + 1))) == NULL)
        {
        PERROR(TEXT("GetClipboardName: alloc failure\n\r"));
        return;
        }

    if (!(lprgch = (LPTSTR)GlobalLock(hrgch)))
        goto ExitPoint;

    switch (fmt)
        {
        // These are all of the formats we have know the names of.
        case CF_RIFF:
        case CF_WAVE:
        case CF_PENDATA:
        case CF_SYLK:
        case CF_DIF:
        case CF_TIFF:

        case CF_TEXT:
        case CF_UNICODETEXT:
        case CF_OEMTEXT:
        case CF_DSPTEXT:
        case CF_LOCALE:

        case CF_BITMAP:
        case CF_DIB:
        case CF_PALETTE:
        case CF_DSPBITMAP:

        case CF_METAFILEPICT:
        case CF_DSPMETAFILEPICT:
        case CF_ENHMETAFILE:
        case CF_DSPENHMETAFILE:
        case CF_HDROP:
            LoadString(hInst, fmt, lprgch, iSize);
            break;

        case CF_OWNERDISPLAY:         /* Clipbrd owner app supplies name */
            *lprgch = '\0';
            SendOwnerMessage(WM_ASKCBFORMATNAME, (WPARAM)iSize, (LPARAM)(LPSTR)lprgch);

            if (!*lprgch)
                LoadString(hInst, fmt, lprgch, iSize);
            break;

        default:
            *lprgch = '\0';
            GetClipboardFormatName(fmt, lprgch, iSize);
            break;
        }

    StringCchCopy(szName, iSize, lprgch);

    GlobalUnlock(hrgch);


ExitPoint:
    GlobalFree(hrgch);

}




/*
 *      GetClipboardMenuName
 */

void GetClipboardMenuName (
    register int    fmt,
    LPTSTR          szName,
    register int    iSize)
{
LPTSTR  lprgch;
HANDLE  hrgch;



    *szName = '\0';


    /* Get global memory that everyone can get to */
    if ((hrgch = GlobalAlloc(GMEM_MOVEABLE | GMEM_LOWER, (LONG)(iSize + 1))) == NULL)
        {
        PERROR(TEXT("GetClipboardName: alloc failure\n\r"));
        return;
        }

    if (!(lprgch = (LPTSTR)GlobalLock(hrgch)))
        goto ExitPoint;

    switch (fmt)
        {
        // These are all of the formats we have know the names of.
        case CF_RIFF:
        case CF_WAVE:
        case CF_PENDATA:
        case CF_SYLK:
        case CF_DIF:
        case CF_TIFF:

        case CF_TEXT:
        case CF_UNICODETEXT:
        case CF_OEMTEXT:
        case CF_DSPTEXT:

        case CF_BITMAP:
        case CF_DIB:
        case CF_PALETTE:
        case CF_DSPBITMAP:

        case CF_METAFILEPICT:
        case CF_DSPMETAFILEPICT:
        case CF_ENHMETAFILE:
        case CF_DSPENHMETAFILE:

        case CF_HDROP:
        case CF_LOCALE:
            LoadString(hInst, fmt+MNDELTA, lprgch, iSize);
            break;

        case CF_OWNERDISPLAY:         /* Clipbrd owner app supplies name */
            *lprgch = '\0';
            SendOwnerMessage(WM_ASKCBFORMATNAME, (WPARAM)iSize, (LPARAM)(LPSTR)lprgch);

            if (!*lprgch)
                LoadString(hInst, CF_MN_OWNERDISPLAY, lprgch, iSize);
            break;

        default:
            GetClipboardFormatName(fmt, lprgch, iSize);
            break;
        }

    StringCchCopy(szName, iSize, lprgch);

    GlobalUnlock(hrgch);


ExitPoint:
    GlobalFree(hrgch);

}





/*
 *      DrawFormat
 *
 * Parameters:
 *    hdc - the hdc to draw in.
 *    prc - The rectangle to paint
 *    cxScroll - The scroll position of the window.
 *    cyScroll - The scroll position OF THE PAINT RECTANGLE. NOT THE WINDOW.
 *       (Gawd. Who DESIGNED this?) Measured in pels.
 *    BestFormat - The format to draw.
 *    hwndMDI - The window we're drawing in.
 *
 */

void DrawFormat(
    register HDC    hdc,
    PRECT           prc,
    int             cxScroll,
    int             cyScroll,
    WORD            BestFormat,
    HWND            hwndMDI)
{
register HANDLE h;
HFONT           hFont;
int             fOK = TRUE;
WORD            wFormat = 0;
PMDIINFO        pMDI;



    pMDI = GETMDIINFO(hwndMDI);

    PINFO(TEXT("DrawFormat: (%d, %d), %d"), cxScroll, cyScroll, BestFormat);

    if (hwndMDI == hwndClpbrd && pMDI->pVClpbrd)
        {
        PERROR(TEXT("Clipboard window shouldn't have vClp!\r\n"));
        }


    /* If "Auto" is chosen and only data in unrecognised formats is
     * available, then display "Can't display data in this format".
     */
    if ((BestFormat == 0) &&
        VCountClipboardFormats( pMDI->pVClpbrd ))
        {
        if ((wFormat = (WORD)RegisterClipboardFormat(TEXT("FileName"))) &&
             VIsClipboardFormatAvailable(pMDI->pVClpbrd, wFormat))
            {
            BestFormat = CF_TEXT;
            }
        else
            {
            PINFO(TEXT("no displayable format\n\r"));
            ShowString( hwndMDI, hdc, IDS_CANTDISPLAY);
            return;
            }
        }

    PINFO(TEXT("format %x\n\r"), BestFormat);

    h = VGetClipboardData( pMDI->pVClpbrd, wFormat ? wFormat : BestFormat );


    if ( h != NULL)
        {
        PINFO(TEXT("Got format %x from VGetClipboardData\n\r"), BestFormat );

        switch (BestFormat)
            {

            case CF_DSPTEXT:
            case CF_TEXT:
                ShowText( hwndMDI, hdc, prc, h, cyScroll, FALSE);
                break;

            case CF_UNICODETEXT:
                hFont = SelectObject(hdc, hfontUni);
                ShowText(hwndMDI, hdc, prc, h, cyScroll, TRUE);
                SelectObject(hdc, hFont);
                break;

            case CF_OEMTEXT:
                hFont = SelectObject(hdc, GetStockObject ( OEM_FIXED_FONT ) );
                ShowText(hwndMDI, hdc, prc, h, cyScroll, FALSE);
                SelectObject(hdc, hFont);
                break;

            case CF_DSPBITMAP:
            case CF_BITMAP:
                fOK = FShowBitmap( hwndMDI, hdc, prc, h, cxScroll, cyScroll);
                break;

            case CF_DIB:
                fOK = FShowDIBitmap( hwndMDI, hdc, prc, h, cxScroll, cyScroll);
                break;

            case CF_PALETTE:
                fOK = FShowPalette( hwndMDI, hdc, prc, h, cxScroll, cyScroll);
                break;

            case CF_WAVE:
            case CF_RIFF:
            case CF_PENDATA:
            case CF_DIF:
            case CF_SYLK:
            case CF_TIFF:
            case CF_LOCALE:
                ShowString( hwndMDI, hdc, IDS_BINARY);
                break;

            case CF_DSPMETAFILEPICT:
            case CF_METAFILEPICT:
                fOK = FShowMetaFilePict( hwndMDI, hdc, prc, h, cxScroll, cyScroll);
                break;

            case CF_DSPENHMETAFILE:
            case CF_ENHMETAFILE:
                fOK = FShowEnhMetaFile( hwndMDI, hdc, prc, h, cxScroll, cyScroll);
                break;

            default:
                ShowString( hwndMDI, hdc, IDS_BINARY);
                break;
            }

        // Disable scroll bars that don't work
        EnableWindow(pMDI->hwndVscroll, pMDI->cyScrollLast > 1 ? TRUE : FALSE);
        EnableWindow(pMDI->hwndHscroll, pMDI->cxScrollLast > 1 ? TRUE : FALSE);
        }
    else
        {
        PERROR(TEXT("VGetClpDta fail\r\n"));
        }

    /* Check if the Data was not rendered by the application */
    if ((h == NULL) &&
        VCountClipboardFormats( pMDI->pVClpbrd ))
        {
        ShowString( hwndMDI, hdc, IDS_NOTRENDERED);
        }
    else
        {
        /* If we are unable to display the data, display "<Error>" */
        if (!fOK)
            {
            ShowString( hwndMDI, hdc, IDS_ERROR);
            }
        }
}




/*
 *      DrawStuff
 *
 *  Paint portion of current clipboard contents given by PAINT struct
 *  NOTE: If the paintstruct rectangle includes any part of the header, the
 *    whole header is redrawn.
 */

void DrawStuff(
    HWND                    hwnd,
    register PAINTSTRUCT    *pps,
    HWND                    hwndMDI)
{
register HDC    hdc;
RECT            rcPaint;
RECT            rcClient;
WORD            BestFormat;
PMDIINFO        pMDI;



    pMDI = GETMDIINFO(hwnd);

    if (pMDI)
    {
        hdc  = pps->hdc;


        if (pps->fErase)
            FillRect(hdc, (LPRECT)&pps->rcPaint, hbrBackground);

        GetClientRect(hwnd, (LPRECT)&rcClient);


        // make room for scroll controls:

        BestFormat = (WORD)GetBestFormat( hwnd, pMDI->CurSelFormat );

        fOwnerDisplay = (BestFormat == CF_OWNERDISPLAY);

        if ( !fOwnerDisplay )
            {
            ShowScrollBar ( hwnd, SB_BOTH, FALSE );
            rcClient.right  -= GetSystemMetrics ( SM_CXVSCROLL );
            rcClient.bottom -= GetSystemMetrics ( SM_CYHSCROLL );
            }


        /* If the display format has changed, Set rcWindow,
         * the display area for clip info.
         */

        if ( pMDI->fDisplayFormatChanged )
            {
            CopyRect((LPRECT)&(pMDI->rcWindow), (LPRECT)&rcClient);

            /* We have changed the size of the clipboard. Tell the owner,
             * if fOwnerDisplay is active.
             */

            if (fOwnerDisplay)
                {
                SendOwnerSizeMessage(hwnd,
                                     pMDI->rcWindow.left,
                                     pMDI->rcWindow.top,
                                     pMDI->rcWindow.right,
                                     pMDI->rcWindow.bottom);
                }
            else
                {
                /* Give the window a small margin, for looks */
                InflateRect (&(pMDI->rcWindow),
                             -(int)(pMDI->cxMargin),
                             -(int)(pMDI->cyMargin));
                }

            pMDI->fDisplayFormatChanged = FALSE;
            }

        if (fOwnerDisplay)
            {
            /* Clipboard Owner handles display */
            HANDLE hps;

            hps = GlobalAlloc(GMEM_MOVEABLE | GMEM_LOWER, (LONG)sizeof(PAINTSTRUCT));

            if (hps != NULL)
                {
                LPPAINTSTRUCT lppsT;

                if ((lppsT = (LPPAINTSTRUCT)GlobalLock(hps)) != NULL)
                    {
                    *lppsT = *pps;
                    IntersectRect(&lppsT->rcPaint, &pps->rcPaint, &(pMDI->rcWindow));
                    GlobalUnlock(hps);
                    SendOwnerMessage(WM_PAINTCLIPBOARD, (WPARAM)hwnd, (LPARAM)hps);
                    GlobalFree(hps);
                    }
                }
            }
        else
            {
            /* We handle display */
            /* Redraw the portion of the paint rectangle that is in the clipbrd rect */
            IntersectRect(&rcPaint, &pps->rcPaint, &(pMDI->rcWindow));

            /* Always draw from left edge of window */
            rcPaint.left = pMDI->rcWindow.left;

            if ((rcPaint.bottom > rcPaint.top) && (rcPaint.right > rcPaint.left))
                {
                DrawFormat (hdc,
                            &rcPaint,
                            (int)(pMDI->cxScrollNow),
                            (int)(pMDI->cyScrollNow + rcPaint.top - pMDI->rcWindow.top),
                            BestFormat,
                            hwndMDI );
                }
            }
    }

}




/*
 *      SaveOwnerScrollInfo
 *
 * When the user switched the clipboard display from owner disp to
 *  a non-owner display, all the information about the scroll bar
 *  positions are to be saved. This routine does that.
 *  This is required because, when the user returns back to owner
 *  display, the scroll bar positions are to be restored.
 */

void SaveOwnerScrollInfo (
    register HWND   hwnd)

{
    GetScrollRange (hwnd, SB_VERT, (LPINT) & OwnVerMin, (LPINT) & OwnVerMax);
    GetScrollRange (hwnd, SB_HORZ, (LPINT) & OwnHorMin, (LPINT) & OwnHorMax);

    OwnVerPos = GetScrollPos( hwnd, SB_VERT );
    OwnHorPos = GetScrollPos( hwnd, SB_HORZ );
}




/*
 *      RestoreOwnerScrollInfo
 *
 *  When the user sitches back to owner-display, the scroll bar
 *  positions are restored by this routine.
 */

void RestoreOwnerScrollInfo (
    register HWND   hwnd)

{
    PINFO(TEXT("SETSCROLLRANGE in RestoreOwnerScrollInfo\n\r"));
    SetScrollRange( hwnd, SB_VERT, OwnVerMin, OwnVerMax, FALSE);
    SetScrollRange( hwnd, SB_HORZ, OwnHorMin, OwnHorMax, FALSE);

    SetScrollPos( hwnd, SB_VERT, OwnVerPos, TRUE);
    SetScrollPos( hwnd, SB_HORZ, OwnHorPos, TRUE);
}




/*
 *      InitOwnerScrollInfo
 */

void InitOwnerScrollInfo(void)

{
    OwnVerPos = OwnHorPos = OwnVerMin = OwnHorMin = 0;
    OwnVerMax = VPOSLAST;
    OwnHorMax = HPOSLAST;
}




/*
 *      UpdateCBMenu
 *
 * This routine is called once during initialisation and everytime
 * the contents of the clipboard change. This updates the entries
 * in the "Display" popup menu and the "grey" and "checked" status
 * based on the data formats available in the clipboard.
 */
void UpdateCBMenu(
    HWND    hwnd,
    HWND    hwndMDI)
{
register WORD   wFlags;         // Used to store the status flags for menu items
register UINT   fmt;
WORD            cFmt;
WORD            cCBCount;       // Number of data items in CB
int             iIndex;
int             nPopupCount;
BOOL            bAutoSelect;
TCHAR           szName[40];



    // Now clipboard contains at least one item...
    // Find out the number entries in the popup menu at present.

    // make sure child window is valid
    if ( !hwndMDI || !IsWindow(hwndMDI))
        {
        PERROR(TEXT("bad window arg to UpdateCBMenu\n\r"));
        return;
        }

    nPopupCount = GetMenuItemCount(hDispMenu);

    if (nPopupCount > 6)
        {
        // Delete all the entries in the popup menu below menu break. */
        for (iIndex = 6; iIndex < nPopupCount; iIndex++)
            {
            // NOTE: The second parameter must always be 6! (because we use
            // MF_BYPOSITION, when 6 is deleted, 7 becomes 6!).
            DeleteMenu(hDispMenu, 6, MF_BYPOSITION | MF_DELETE);
            }
        }


    // If this is not a page MDI window we don't want to show any entries
    if ( GETMDIINFO(hwndMDI)->DisplayMode  != DSP_PAGE )
        {
        return;
        }

    bAutoSelect = TRUE;



    if ((cCBCount = (WORD)VCountClipboardFormats( GETMDIINFO(hwndMDI)->pVClpbrd ))
        && VOpenClipboard( GETMDIINFO(hwndMDI)->pVClpbrd, hwnd))
        {
        AppendMenu ( hDispMenu, MF_SEPARATOR, 0, 0 );
        AppendMenu ( hDispMenu, MF_STRING, CBM_AUTO, szDefaultFormat );
        AppendMenu ( hDispMenu, MF_SEPARATOR, 0, 0 );

        for (fmt=0, cFmt=1; cFmt <= cCBCount; cFmt++)
            {
            wFlags = 0;
            fmt = VEnumClipboardFormats( GETMDIINFO(hwndMDI)->pVClpbrd, fmt );

            // don't show preview format in menu...
            if ( fmt != cf_preview )
                {
                switch (fmt)
                    {
                    case CF_TEXT:
                    case CF_OEMTEXT:
                    case CF_DSPTEXT:
                    case CF_UNICODETEXT:
                    case CF_DSPBITMAP:

                    case CF_DIB:
                    case CF_BITMAP:

                    case CF_METAFILEPICT:
                    case CF_DSPMETAFILEPICT:
                    case CF_ENHMETAFILE:
                    case CF_DSPENHMETAFILE:

                    case CF_OWNERDISPLAY:
                    case CF_PALETTE:
                    case CF_HDROP:
                    case CF_LOCALE:

                        /* can display all of these, put them on menu */

                        // Check if the current format is the one selected by the user
                        if (GETMDIINFO(hwndMDI)->CurSelFormat == fmt)
                            {
                            bAutoSelect = FALSE;
                            wFlags |= MF_CHECKED;
                            }

                        GetClipboardMenuName(fmt, szName, sizeof(szName));
                        AppendMenu (hDispMenu, wFlags, fmt, (LPTSTR)szName);

                        break;

                    default:        /* all the rest... later */
                        break;
                    }
                }
            }



        for (fmt=VEnumClipboardFormats (GETMDIINFO(hwndMDI)->pVClpbrd, 0);
             fmt;
             fmt=VEnumClipboardFormats (GETMDIINFO(hwndMDI)->pVClpbrd, fmt))
            if ( fmt != cf_preview )
                switch (fmt)
                    {
                    case CF_TEXT:
                    case CF_OEMTEXT:
                    case CF_DSPTEXT:
                    case CF_UNICODETEXT:
                    case CF_DSPBITMAP:
                    case CF_DIB:
                    case CF_BITMAP:
                    case CF_METAFILEPICT:
                    case CF_DSPMETAFILEPICT:
                    case CF_ENHMETAFILE:
                    case CF_DSPENHMETAFILE:
                    case CF_OWNERDISPLAY:
                    case CF_PALETTE:
                    case CF_HDROP:
                    case CF_LOCALE:
                        break;

                    default:
                        /* can't display this, put it on menu and gray it */

                        GetClipboardName(fmt, szName, sizeof(szName));
                        AppendMenu (hDispMenu, MF_GRAYED, fmt, (LPTSTR)szName);

                    //  NTRAID#DB-344956-2001/04/14-mdesai : add support for V5 bitmaps requires new strings, help changes, code to convert, etc
                    //  clipbrd was adding an empty string for this format; now we ignore the format
                    case CF_DIBV5:
                        break;
                    }

        VCloseClipboard( GETMDIINFO(hwndMDI)->pVClpbrd );

        if (bAutoSelect)
            {
            GETMDIINFO(hwndMDI)->CurSelFormat = CBM_AUTO;
            CheckMenuItem(hDispMenu, CBM_AUTO, MF_BYCOMMAND | MF_CHECKED);
            }
        }
    else
        {
        PERROR(TEXT("UpdateCBMenu:couldn't open clip, or no data on clip\r\n"));
        }

    DrawMenuBar(hwnd);
}




/*
 *      ClearClipboard
 *
 *  This is called to clear the clipboard.  If the clipboard is not
 *  empty the user is asked if it should be cleared.
 */

BOOL ClearClipboard (
    register HWND   hwnd)

{
register int    RetVal;

    if (CountClipboardFormats() <= 0)
       return(TRUE);

    if ( MessageBoxID( hInst, hwnd, IDS_CONFIRMCLEAR, IDS_CLEARTITLE,
          MB_YESNO | MB_ICONEXCLAMATION) == IDYES)
        {
        if (RetVal = SyncOpenClipboard(hwnd))
            {
            // PINFO("ClearClipboard: emptied clipboard\r\n");
            RetVal &= EmptyClipboard();
            RetVal &= SyncCloseClipboard();
            }
        else
            {
            // PERROR("ClearClipboard: could not open\r\n");

            MessageBoxID (hInst,
                          hwnd,
                          IDS_CLEAR,
                          IDS_ERROR,
                          MB_OK | MB_SYSTEMMODAL | MB_ICONHAND);
            }

        InvalidateRect(hwnd, NULL, TRUE);
        return RetVal;
        }

    return(FALSE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\cvinit.h ===
/*****************************************************************************

                    C V I N I T   H E A D E R

    Name:       cvinit.h
    Date:       20-Jan-1994
    Creator:    John Fu

    Description:
        This is the header file for cvinit.c

*****************************************************************************/



extern  HWND        hwndToolbar;
extern  HWND        hwndStatus;
extern  HBITMAP     hbmStatus;

extern  TCHAR       szWindows[];

extern  DWORD       nIDs[];
extern  TBBUTTON    tbButtons[];












VOID LoadIntlStrings (void);


VOID SaveWindowPlacement (
    PWINDOWPLACEMENT    pwp);


BOOL ReadWindowPlacement(
    LPTSTR              szKey,
    PWINDOWPLACEMENT    pwp);


BOOL CreateTools(
    HWND    hwnd);


VOID DeleteTools(
    HWND    hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\cvcomman.h ===
/******************************************************************************

                    C V C O M M A N D   H E A D E R

    Name:       cvcomman.h
    Date:       1/20/94
    Creator:    John Fu

    Description:
        This is the header file for cvcomman.c

******************************************************************************/



LRESULT OnIDMDelete(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wparam,
    LPARAM  lparam);


static void CreateClipboardWindow (void);


static void CreateLocalWindow (void);


void UnsharePage (void);


LRESULT OnIdmUnshare (DWORD dwItem);


LRESULT ClipBookCommand(
    HWND        hwnd,
    UINT        msg,
    WPARAM      wParam,
    LPARAM      lParam);


BOOL SetListboxEntryToPageWindow(
    HWND        hwndc,
    PMDIINFO    pMDIc,
    int         lbindex);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\cvutil.c ===
/*****************************************************************************

                    C L I P B O O K   U T I L I T I E S

    Name:       cvutil.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        Utility functions for clipbook viewer.


*****************************************************************************/

#define WIN31
#define STRICT

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <assert.h>
#include <memory.h>
#include <stdio.h>
#include <strsafe.h>

#include "common.h"
#include "clipbook.h"
#include "clipbrd.h"
#include "clipdsp.h"
#include "cvinit.h"
#include "cvutil.h"
#include "dib.h"
#include "strtok.h"
#include "initmenu.h"
#include "debugout.h"


DWORD   gXERR_Type      = 0;
DWORD   gXERR_Err       = 0;
HSZ     hszErrorRequest = 0;


#if DEBUG
static void DumpDataReq (PDATAREQ pdr);


static void DumpDataReq(
    PDATAREQ    pdr)
{
    PINFO(TEXT("Datareq: type %d, to window %lx, \r\nat index %u, fDisc=%u, format=%u\r\n"),
               pdr->rqType,
               pdr->hwndMDI,
               pdr->iListbox,
               pdr->fDisconnect,
               pdr->wFmt);
}
#else
#define DumpDataReq(x)
#endif



// AdjustControlSizes //////////////////
//
// This function sizes the listbox windows associated
// with an MDI child window when its size changes

VOID AdjustControlSizes (
    HWND    hwnd)
{
RECT        rc1, rc2;
PMDIINFO    pMDI;
int         cx = GetSystemMetrics ( SM_CXVSCROLL );
int         cy = GetSystemMetrics ( SM_CYHSCROLL );


    if (!(pMDI = GETMDIINFO(hwnd)))
        return;


    GetClientRect ( hwnd, &rc1 );
    rc2 = rc1;
    rc2.right -= cx - 1;
    rc2.bottom -= cy - 1;

    switch ( pMDI->DisplayMode )
        {
        case DSP_LIST:
        case DSP_PREV:
            MoveWindow ( pMDI->hWndListbox, rc1.left - 1, rc1.top - 1,
               rc1.right - rc1.left + 2, ( rc1.bottom - rc1.top ) + 2, TRUE );
            break;

        case DSP_PAGE:
            MoveWindow (pMDI->hwndHscroll,
                        rc1.left - 1,
                        rc2.bottom,
                        (rc2.right - rc2.left) +2,
                        cy,
                        TRUE );

            if ( pMDI->flags & F_CLPBRD ) {
               MoveWindow ( pMDI->hwndVscroll, rc2.right, rc1.top - 1,
                  cx, ( rc2.bottom - rc2.top ) + 2, TRUE );
               }
            else
               {
               MoveWindow ( pMDI->hwndVscroll, rc2.right, rc1.top - 1,
                  cx, ( rc2.bottom - rc2.top ) + 2 - 2*cy, TRUE );
               }
            MoveWindow ( pMDI->hwndSizeBox,  rc2.right, rc2.bottom, cx, cy, TRUE );

            if ( ! ( pMDI->flags & F_CLPBRD ) )
               {
               MoveWindow ( pMDI->hwndPgUp, rc2.right,
                  rc2.bottom + 1 - 2*cy, cx, cy, TRUE );
               MoveWindow ( pMDI->hwndPgDown, rc2.right,
                  rc2.bottom + 1 - cy, cx, cy, TRUE );
               }

            // adjust display window
            pMDI->rcWindow = rc2;
            break;
        }
}



VOID ShowHideControls (
    HWND    hwnd)
{
PMDIINFO    pMDI;
int         nShowScroll;
int         nShowList;


    if (!(pMDI = GETMDIINFO(hwnd)))
        return;


    switch ( pMDI->DisplayMode )
        {
        case DSP_PREV:
        case DSP_LIST:
           nShowScroll = SW_HIDE;
           nShowList = SW_SHOW;
           break;

        case DSP_PAGE:
           if ( GetBestFormat( hwnd, pMDI->CurSelFormat) != CF_OWNERDISPLAY )
              nShowScroll = SW_SHOW;
           else
              {
              nShowScroll = SW_HIDE;
              ShowScrollBar ( hwnd, SB_BOTH, TRUE );
              }
           nShowList = SW_HIDE;
           break;
        }

   ShowWindow ( pMDI->hWndListbox, nShowList );
   ShowWindow ( pMDI->hwndVscroll, nShowScroll );
   ShowWindow ( pMDI->hwndHscroll, nShowScroll );
   ShowWindow ( pMDI->hwndSizeBox, nShowScroll );
   ShowWindow ( pMDI->hwndPgUp,    (pMDI->flags & F_CLPBRD)? SW_HIDE: nShowScroll );
   ShowWindow ( pMDI->hwndPgDown,  (pMDI->flags & F_CLPBRD)? SW_HIDE: nShowScroll );
}



// AssertConnection /////////////////

BOOL AssertConnection (
    HWND    hwnd)
{
PMDIINFO    pMDI;

    if (!(pMDI = GETMDIINFO(hwnd)))
        return FALSE;

    if (IsWindow(hwnd))
       {
       if (pMDI->hExeConv ||
           (pMDI->hExeConv = InitSysConv (hwnd,
                                          pMDI->hszConvPartner,
                                          hszClpBookShare,
                                          FALSE))
          )
          {
          return TRUE;
          }
       }
    return FALSE;
}




// InitSysConv ////////////////////////
//
// Purpose: Establishes a conversation with the given app and topic.
//
// Parameters:
//    hwnd      - MDI child window to own this conversation
//    hszApp    - App name to connect to
//    hszTopic  - Topic to connect to
//    fLocal    - Ignored.
//
// Returns: Handle to the conversation (0L if no conv. could be established).
//

HCONV InitSysConv (
    HWND    hwnd,
    HSZ     hszApp,
    HSZ     hszTopic,
    BOOL    fLocal )
{
HCONV       hConv = 0L;
PDATAREQ    pDataReq;
DWORD       dwErr;


#if DEBUG
TCHAR       atchApp[256];
TCHAR       atchTopic[256];

    if (DdeQueryString(idInst, hszApp, atchApp,
             sizeof(atchApp), CP_WINANSI) &&
        DdeQueryString(idInst, hszTopic, atchTopic,
             sizeof(atchTopic), CP_WINANSI))
       {
       PINFO(TEXT("InitSysConv: [%s | %s]\r\n"), atchApp, atchTopic);
       }
    else
       {
       PERROR(TEXT("I don't know my app/topic pair!\r\n"));
       }
#endif


    if (LockApp (TRUE, szEstablishingConn))
        {
        hConv = DdeConnect ( idInst, hszApp, hszTopic, NULL );
        if (!hConv)
            {
            dwErr = DdeGetLastError(idInst);
            PINFO(TEXT("Failed first try at CLIPSRV, #%x\r\n"), dwErr);

            if (GetSystemMetrics(SM_REMOTESESSION) )
                {
                MessageBoxID (hInst, hwnd, IDS_TSNOTSUPPORTED, IDS_APPNAME, MB_OK | MB_ICONHAND);
                }
            else
                {
                MessageBoxID (hInst, hwnd, IDS_NOCLPBOOK, IDS_APPNAME, MB_OK | MB_ICONHAND);
                }
            }
        else
            {
            PINFO(TEXT("Making datareq."));

            if ( pDataReq = CreateNewDataReq() )
                {
                pDataReq->rqType  = RQ_EXECONV;
                pDataReq->hwndMDI = hwnd;
                pDataReq->wFmt    = CF_TEXT;
                DdeSetUserHandle ( hConv, (DWORD)QID_SYNC, (DWORD_PTR)pDataReq );

                Sleep(3000);
                PINFO(TEXT("Entering AdvStart transaction "));

                if (!MySyncXact ( NULL, 0L, hConv, hszTopics,
                         CF_TEXT, XTYP_ADVSTART, LONG_SYNC_TIMEOUT, NULL ))
                    {
                    XactMessageBox (hInst, hwnd, IDS_APPNAME, MB_OK | MB_ICONEXCLAMATION);
                    }
                }
            else
                {
                PERROR(TEXT("InitSysConv:Could not create data req\r\n"));
                }
            }
        LockApp ( FALSE, szNull );
        }
    else
        {
        PERROR(TEXT("app locked in initsysconv\n\r"));
        }

    return hConv;
}



// UpdateListBox ////////////////////////////
//
// This function updates the contents of a listbox
// given the window handle of the MDI child window
// and the conversation over which the data is to be
// obtained

BOOL UpdateListBox(
    HWND    hwnd,
    HCONV   hConv)
{
HDDEDATA    hData;
BOOL        fOK = TRUE;


    if ( hConv == 0L || !IsWindow( hwnd ))
        {
        PERROR(TEXT("UpdateListBox called with garbage\n\r"));
        fOK = FALSE;
        }
    else
        {
        if (GETMDIINFO(hwnd) && GETMDIINFO(hwnd)->flags & F_LOCAL)
            {
            PINFO(TEXT("Getting all topics\r\n"));
            }
        else
            {
            PINFO(TEXT("Getting shared topics\r\n"));
            }


        // ask clipsrv to initialize shares

        MySyncXact (SZCMD_INITSHARE,
                    sizeof (SZCMD_INITSHARE),
                    hConv,
                    0L,
                    CF_TEXT,
                    XTYP_EXECUTE,
                    SHORT_SYNC_TIMEOUT,
                    NULL);


        //get the data

        hData = MySyncXact (NULL,
                            0L,
                            hConv,
                            hszTopics,
                            CF_TEXT,
                            XTYP_REQUEST,
                            SHORT_SYNC_TIMEOUT,
                            NULL );

        if ( !hData )
            {
            XactMessageBox (hInst,
                            hwnd,
                            IDS_APPNAME,
                            MB_OK | MB_ICONEXCLAMATION);
            fOK = FALSE;
            }
        else
            {
            fOK =  InitListBox ( hwnd, hData );
            }
        }

    return fOK;
}



// GetPreviewBitmap //////////////////////////////
// Informs CLIPSRV via DDE that we need a preview bitmap
// for the given page.
//
// Parameters:
//    hwnd -   Clipbook window which wants the bitmap
//    szName - Name of the clipbook page.
//    index  - Page's index within the listbox in hwnd
//
// Returns:
//    void.
//

BOOL GetPreviewBitmap (
    HWND    hwnd,
    LPTSTR  szName,
    UINT    index)
{
HSZ         hszTopic, hszItem = 0L;
HCONV       hConv;
HDDEDATA    hRet;
PDATAREQ    pDataReq;
BOOL        fLocked;
TCHAR       tchTmp;


    if (WAIT_TIMEOUT == WaitForSingleObject (hXacting, 0))
        return FALSE;

    fLocked = LockApp (TRUE, NULL);


    tchTmp = szName[0];
    szName[0] = SHR_CHAR;

    if (0 == (hszTopic = DdeCreateStringHandle (idInst, szName, 0)))
        {
        PERROR(TEXT("GetPreviewBitmap: no topic handle\n\r"));
        goto done;
        }

    if (0 == (hszItem = DdeCreateStringHandle (idInst, SZPREVNAME, 0)))
        {
        PERROR(TEXT("GetPreviewBitmap: no item handle\n\r"));
        goto done;
        }

    if (!GETMDIINFO(hwnd))
        {
        PERROR(TEXT("GETMDIINFO(hwnd) -> NULL\n\r"));
        goto done;
        }

    if (NULL == (pDataReq = CreateNewDataReq()))
        {
        PERROR(TEXT("GetPreviewBitmap: no pdatareq\n\r"));
        goto done;
        }

    #if DEBUG
    {
    TCHAR atch[64];

    DdeQueryString(idInst, GETMDIINFO(hwnd)->hszConvPartnerNP,
          atch, 64, CP_WINANSI);
    PINFO(TEXT("GetPrevBmp: Connecting [%s | %s ! %s]\r\n"),
          atch, szName, SZPREVNAME);
    }
    #endif



    //
    // Let's try to connect up to ten times.  Sometimes when updating
    // the thumbnails if the user changes a page, the server will be
    // busy doing that and we can't connect here.  So, at least try
    // a few times.
    //
    {
    INT trycnt = 0;
    hConv = 0L;

    while (trycnt < 10 && !hConv)
        {
        hConv = DdeConnect (idInst, GETMDIINFO(hwnd)->hszConvPartnerNP, hszTopic, NULL);
        trycnt++;
        if (hConv) continue;

        PINFO (TEXT("GetPreviewBitmap: trying to connect again\r\n"));
        Sleep (200);
        }
    }


    if (hConv)
        {
        DWORD adwTrust[3];
        BOOL  fLocal = FALSE;

        if (GETMDIINFO(hwnd)->flags & F_LOCAL)
            {
            fLocal = TRUE;

            if (NDDE_NO_ERROR !=  NDdeGetTrustedShare(NULL, szName,
                  adwTrust, adwTrust + 1, adwTrust + 2))
                {
                adwTrust[0] = 0L;
                }

            NDdeSetTrustedShare (NULL,
                                 szName,
                                 adwTrust[0] | NDDE_TRUST_SHARE_INIT);
            }

        pDataReq->rqType      = RQ_PREVBITMAP;
        pDataReq->hwndList    = GETMDIINFO(hwnd)->hWndListbox;
        pDataReq->iListbox    = index;
        pDataReq->hwndMDI     = hwnd;
        pDataReq->fDisconnect = TRUE;
        pDataReq->wFmt        = (WORD)cf_preview;
        pDataReq->wRetryCnt   = 3;


        {
        /****   disable all edit function   ****/
        /**** will enable in after callback ****/

        // If the user does a paste or make some changes to the pages while
        // clipbrd is waiting for the xaction to complete, sometimes we get
        // a popup says there's a problem with connection (or something similar)
        // It seems there's some dirty code is causing this.  Below is a temp
        // fix which works well on fast machines.  On slower machines it may
        // still fail at times.  A better fix may be not to use async at all.
        //
        // NOTE: If there's multiple requests, one may complete while we're still
        // waitng for another.  This will cause the EDIT functions to be enabled
        // while we are still waiting.

        HANDLE hmenu;

        hmenu = GetMenu (hwndApp);

        EnableMenuItem (hmenu, IDM_COPY,       MF_GRAYED | MF_BYCOMMAND);
        EnableMenuItem (hmenu, IDM_KEEP,       MF_GRAYED | MF_BYCOMMAND);
        EnableMenuItem (hmenu, IDM_PASTE_PAGE, MF_GRAYED | MF_BYCOMMAND);
        EnableMenuItem (hmenu, IDM_DELETE,     MF_GRAYED | MF_BYCOMMAND);

        SendMessage (hwndToolbar, TB_ENABLEBUTTON, IDM_COPY,   FALSE);
        SendMessage (hwndToolbar, TB_ENABLEBUTTON, IDM_KEEP,   FALSE);
        SendMessage (hwndToolbar, TB_ENABLEBUTTON, IDM_DELETE, FALSE);
        }

        hRet = DdeClientTransaction (NULL,
                                     0L,
                                     hConv,
                                     hszItem,
                                     cf_preview,
                                     XTYP_REQUEST,
                                     (DWORD)TIMEOUT_ASYNC,
                                     NULL);

        if ( !hRet )
            {
            unsigned uiErr;

            uiErr = DdeGetLastError (idInst);
            PERROR(TEXT("GetPreviewBitmap: Async Transaction for (%s) failed:%x\n\r"),
               szName, uiErr);
            }

        DdeSetUserHandle ( hConv, (DWORD)QID_SYNC, (DWORD_PTR)pDataReq );
        }
    #if DEBUG
    else
        {
        unsigned uiErr;

        uiErr = DdeGetLastError(idInst);
        DdeQueryString(idInst, GETMDIINFO(hwnd)->hszConvPartner,
           szBuf, 128, CP_WINANSI );
        PERROR(TEXT("GetPreviewBitmap: connect to %lx|%lx (%s|%s) failed: %d\n\r"),
           GETMDIINFO(hwnd)->hszConvPartner, hszTopic,
           (LPTSTR)szBuf, (LPTSTR)szName, uiErr);
        }
    #endif


done:

    if (!hszTopic)
        DdeFreeStringHandle (idInst, hszTopic);

    if (!hszItem)
        DdeFreeStringHandle ( idInst, hszItem );

    if (fLocked)
        LockApp (FALSE, NULL);

    szName[0] = tchTmp;

    SetEvent (hXacting);

    return TRUE;
}




VOID SetBitmapToListboxEntry (
    HDDEDATA    hbmp,
    HWND        hwndList,
    UINT        index)
{
LPLISTENTRY lpLE;
RECT        rc;
HBITMAP     hBitmap;
LPBYTE      lpBitData;
DWORD       cbDataLen;
unsigned    uiErr;


#if DEBUG
uiErr = DdeGetLastError(idInst);
if (uiErr)
    {
    PINFO(TEXT("SBmp2LBEntr: %d\r\n"), uiErr);
    }
#endif


    if (!IsWindow (hwndList)
        || SendMessage (hwndList, LB_GETTEXT,     index, (LPARAM)(LPCSTR)&lpLE) == LB_ERR
        || SendMessage (hwndList, LB_GETITEMRECT, index, (LPARAM)(LPRECT)&rc)   == LB_ERR)
        {
        DdeFreeDataHandle(hbmp);
        PERROR(TEXT("SetBitmapToListboxEntry: bad window: %x\n\r"), hwndList);
        }
    else
        {
        if (hbmp)
            {
            if ( lpBitData = DdeAccessData ( hbmp, &cbDataLen ))
                {
                // create the preview bitmap
                hBitmap  = CreateBitmap (PREVBMPSIZ,PREVBMPSIZ,1,1, lpBitData);
                DdeUnaccessData ( hbmp );
                }
            else
                {
                PERROR(TEXT("SB2LB: Couldn't access data!\r\n"));
                hBitmap = NULL;
                }

            DdeFreeDataHandle ( hbmp );
            lpLE->hbmp = hBitmap;

            PINFO(TEXT("Successfully set bmp.\r\n"));
            }

        PINFO(TEXT("Invalidating (%d,%d)-(%d,%d)\r\n"),rc.left, rc.top,
              rc.right, rc.bottom);
        InvalidateRect ( hwndList, &rc, TRUE );
        }


    uiErr = DdeGetLastError(idInst);
    if (uiErr)
        {
        PINFO (TEXT("SBmp2LBEntr: exit err %d\r\n"), uiErr);
        }
}



/*
 *      UpdatePage
 *
 *  When user paste into an existing page, the first item
 *  in szList is the share name of the page pasted. Since
 *  the name did not change, we need to do some special
 *  processing to update the display.
 *
 */

BOOL    UpdatePage (HWND hwnd, LPTSTR szList)
{
PMDIINFO    pMDI;
PLISTENTRY  pLE;
TCHAR       szPageBuf[MAX_NDDESHARENAME+1];
LPTSTR      szPage = szPageBuf;
RECT        Rect;
INT         i;


    *szPage = TEXT('\0');

    // does the first item in szList spcifies
    // an updated page?

    if (BOGUS_CHAR != *szList)
        return FALSE;


    // get the share name

    szList++;

    while (*szList && TEXT('\t') != *szList)
        *szPage++ = *szList++;

    *szPage = TEXT('\0');


    // Find the page, notice the name comparison below does not
    // compare the first char.  This is because the updated page's
    // share state may have changed so the first char won't match.

    pMDI = GETMDIINFO(hwnd);

    for (i=0;
         LB_ERR != SendMessage(pMDI->hWndListbox, LB_GETTEXT, i, (LPARAM)&pLE);
         i++)
        {
        if (pLE)
            if (!lstrcmpiA(pLE->name+1, szPageBuf+1))
                {
                goto update;
                }
        }

    return FALSE;


update:

    // invalidate the preview bitmap

    SendMessage (pMDI->hWndListbox, LB_GETITEMRECT, i, (LPARAM)&Rect);

    if (pLE->hbmp)
        DeleteObject (pLE->hbmp);

    pLE->fTriedGettingPreview = FALSE;
    pLE->hbmp = NULL;

    InvalidateRect (pMDI->hWndListbox, &Rect, FALSE);


    // if in page view and the page is the one currently
    // selected then update the page view

    if (DSP_PAGE == pMDI->DisplayMode)
        if (SendMessage (pMDI->hWndListbox, LB_GETCURSEL, 0, 0) == i)
            PostMessage (hwndApp, WM_COMMAND, IDM_UPDATE_PAGEVIEW, 0L);

    return TRUE;
}




// InitListBox //////////////////////////////////
//
// this function initializes the entries of a listbox
// given the handle of the MDI child window that owns
// the list box and a ddeml data handle that contains the
// tab-separated list of items that are to appear in the
// listbox
//    Right now, this deletes all entries in the list and
//    then recreates them. It would be more efficient to add or
//    delete only those items that have changed. This would save
//    CONSIDERABLE time in thumbnail mode-- now, we have to
//    establish a new DDE conversation with the server for each
//    page, just to get the thumbnail bitmap.


BOOL InitListBox (
    HWND        hwnd,
    HDDEDATA    hData )
{
PMDIINFO    pMDI;
PLISTENTRY  pLE;
LPTSTR      lpszList, q;
DWORD       cbDataLen;
HWND        hwndlist;
int         OldCount;
int         NewCount;
int         OldSel;
LPTSTR      OldSelString;
BOOL        OldStringDeleted;
int         i;
BOOL        fDel;


    if ( hData == 0L || !IsWindow ( hwnd ) )
       {
       PERROR(TEXT("InitListBox called with garbage\n\r"));
       return FALSE;
       }


    // Get a copy of the data in the handle
    lpszList = (LPTSTR)DdeAccessData ( hData, &cbDataLen );
    DdeUnaccessData(hData);
    lpszList = GlobalAllocPtr(GHND, cbDataLen);
    DdeGetData(hData, lpszList, cbDataLen, 0L);

    // Sometimes, the data will be longer than the string. This
    // would make the 'put tabs back' code below fail if we didn't
    // do this.
    cbDataLen = lstrlen(lpszList);

    PINFO(TEXT("InitLB: %s \r\n"), lpszList);

    if (!lpszList)
        {
        PERROR(TEXT("error accessing data in InitListBox\n\r"));
        return FALSE;
        }


    if (!(pMDI = GETMDIINFO(hwnd)))
        return FALSE;


    if (!(hwndlist = GETMDIINFO(hwnd)->hWndListbox))
        return FALSE;


    SendMessage ( hwndlist, WM_SETREDRAW, 0, 0L );


    // let's update the page that was pasted into
    // an existing page.

    UpdatePage (hwnd, lpszList);


    OldCount = (int)SendMessage ( hwndlist, LB_GETCOUNT, 0, 0L );
    OldSel = (int)SendMessage ( hwndlist, LB_GETCURSEL, 0, 0L );
    OldSelString = (LPTSTR)SendMessage (hwndlist, LB_GETITEMDATA, OldSel, 0);
    OldStringDeleted = FALSE;


    // Delete items in list that don't exist anymore
    for (i = 0; i < OldCount; i++)
        {
        SendMessage (hwndlist, LB_GETTEXT, i, (LPARAM)&pLE);
        fDel = TRUE;

        if (pLE)
            {
            for (q = strtokA(lpszList, "\t"); q; q = strtokA(NULL, "\t"))
                {
                PINFO(TEXT("<%hs>"), q);

                if (0 == lstrcmpA(pLE->name, q))
                   {
                   fDel = FALSE;
                   *q = BOGUS_CHAR;
                   break;
                   }
                }
            PINFO(TEXT("\r\n"));

            // Put back the tab chars that strtok ripped out
            for (q = lpszList;q < lpszList + cbDataLen;q++)
                {
                if ('\0' == *q)
                   {
                   *q = '\t';
                   }
                }
            *q = '\0';
            PINFO(TEXT("Restored %hs\r\n"), lpszList);

            if (fDel)
                {
                PINFO(TEXT("Deleting item %s at pos %d\r\n"), pLE->name, i);
                pLE->fDelete = TRUE;
                if (OldSelString == (LPTSTR)pLE)
                {
                   OldStringDeleted = TRUE;
                }
                SendMessage(hwndlist, LB_DELETESTRING, i, 0L);
                i--;
                if (OldCount)
                   {
                   OldCount--;
                   }
                }
            }
        else
            {
            PERROR(TEXT("Got NULL pLE!\r\n"));
            }
        }


    // Add new items to list
    for (q = strtokA(lpszList, "\t"); q; q = strtokA(NULL, "\t"))
       {
       // only add shared items if remote, never re-add existing items
       if (BOGUS_CHAR != *q &&
           (( GETMDIINFO(hwnd)->flags & F_LOCAL ) || *q == SHR_CHAR ))
          {
          // allocate a new list entry...
          if ( ( pLE = (PLISTENTRY)GlobalAllocPtr ( GHND,
                sizeof ( LISTENTRY ))) != NULL )
             {
             // mark this item to be deleted in WM_DELETEITEM
             pLE->fDelete = TRUE;
             pLE->fTriedGettingPreview = FALSE;

             StringCchCopy(pLE->name, MAX_PAGENAME_LENGTH + 1, q);
             PINFO(TEXT("Adding item %s\r\n"), pLE->name);
             SendMessage(hwndlist, LB_ADDSTRING, 0, (LPARAM)(LPCSTR)pLE);
             }
          }
       }


    // Select the item at the same position we were at

    NewCount = (int)SendMessage (hwndlist, LB_GETCOUNT, 0, 0L);

    if (NewCount)
        if (OldCount == NewCount)
            {
            SendMessage (hwndlist,
                         LB_SETCURSEL,
                         OldSel,
                         0L);
            }
        else if ( (LB_ERR != (LRESULT)OldSelString) && (!OldStringDeleted) )
            {
            SendMessage (hwndlist,
                         LB_SELECTSTRING,
                         OldSel-1,  // listbox is sorted
                         (LPARAM)OldSelString);
            }


    SendMessage ( hwndlist, WM_SETREDRAW, 1, 0L );
    UpdateNofMStatus( hwnd );


    if (lpszList)
        GlobalFreePtr(lpszList);

    return TRUE;
}




// MyGetFormat ////////////////////////////
//
// this function returns the UINT ID of the
// format matching the supplied string. This
// is the reverse of the "getclipboardformatname" function.
//
// Note that the formats &Bitmap, &Picture and Pal&ette exist
// both as predefined windows clipboard formats and as privately
// registered formats. The integer switch passed to this function
// determines whether the instrinsic format or the privately registered
// format ID is returned
//
// GETFORMAT_DONTLIE   return instrinsic format i.e. CF_BITMAP
// GETFORMAT_LIE      return registered format i.e. cf_bitmap

UINT MyGetFormat(
    LPTSTR  szFmt,
    int     mode)
{
TCHAR       szBuff[40];
unsigned    i;
UINT        uiPrivates[] = {CF_BITMAP,
                           CF_METAFILEPICT,
                           CF_PALETTE,
                           CF_ENHMETAFILE,
                           CF_DIB};



    PINFO("\nMyGetFormat [%s] %d:", szFmt, mode);

    for (i = 0; i <= CF_ENHMETAFILE; i++)
        {
        LoadString(hInst, i, szBuff, 40);
        if (!lstrcmp( szFmt, szBuff))
            {
            if (GETFORMAT_DONTLIE == mode)
                {
                PINFO(TEXT("No-lie fmt %d\r\n"), i);
                }
            else
                {
                unsigned j;

                for (j = 0;j <sizeof(uiPrivates)/sizeof(uiPrivates[0]);j++)
                    {
                    if (i == uiPrivates[j])
                        {
                        i = RegisterClipboardFormat(szBuff);
                        break;
                        }
                    }
                }
            PINFO(TEXT("Format result %d\r\n"), i);
            return(i);
            }
        }

    for (i = CF_OWNERDISPLAY;i <= CF_DSPENHMETAFILE ;i++ )
        {
        LoadString(hInst, i, szBuff, 40);
        if (!lstrcmp( szFmt, szBuff))
            {
            if (GETFORMAT_DONTLIE != mode)
                {
                i = RegisterClipboardFormat(szBuff);
                }
            return(i);
            }
        }

    PINFO(TEXT("Registering format %s\n\r"), szFmt );

    return RegisterClipboardFormat ( szFmt );
}




// HandleOwnerDraw ////////////////////////////////
//
// This function handles drawing of owner draw buttons
// and listboxes in this app.

VOID HandleOwnerDraw(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam)
{
LPDRAWITEMSTRUCT    lpds;
RECT                tmprc;
COLORREF            OldTextColor;
COLORREF            OldBkColor;
COLORREF            BackColor;
COLORREF            TextColor;
HBRUSH              hBkBrush;
DWORD               cbData = 0L;
LPLISTENTRY         lpLE;
BOOL                fSel = FALSE;



   lpds = (LPDRAWITEMSTRUCT) lParam;

   // this section handles listbox drawing

    switch ( lpds->CtlID )
        {
        case ID_LISTBOX:
            if (!GETMDIINFO(hwnd))
                 break;

            if ( GETMDIINFO(hwnd)->DisplayMode == DSP_LIST )
                {
                if ( lpds->itemAction & (ODA_DRAWENTIRE|ODA_SELECT|ODA_FOCUS))
                    {
                    if ( SendMessage ( GETMDIINFO(hwnd)->hWndListbox, LB_GETTEXT,
                          lpds->itemID, (LPARAM)(LPCSTR)&lpLE ) == LB_ERR )
                        {
                        return;
                        }

                    hOldBitmap = SelectObject ( hBtnDC, hbmStatus );

                    tmprc = lpds->rcItem;

                    if ( lpds->itemState & ODS_SELECTED &&
                                lpds->itemState & ODS_FOCUS )
                        {
                        TextColor = GetSysColor ( COLOR_HIGHLIGHTTEXT );
                        BackColor = GetSysColor ( COLOR_HIGHLIGHT );
                        }
                    else
                        {
                        TextColor = GetSysColor ( COLOR_WINDOWTEXT );
                        BackColor = GetSysColor ( COLOR_WINDOW );
                        }

                    OldTextColor = SetTextColor ( lpds->hDC, TextColor );
                    OldBkColor = SetBkColor ( lpds->hDC, BackColor );

                    hBkBrush = CreateSolidBrush ( BackColor );
                    if ( hBkBrush )
                       FillRect ( lpds->hDC, &tmprc, hBkBrush );
                    DeleteObject ( hBkBrush );

                    hOldFont = SelectObject ( lpds->hDC, hFontPreview );


                    TextOut (lpds->hDC,
                             lpds->rcItem.left + 2 * LSTBTDX,
                             lpds->rcItem.top+1,
                             &(lpLE->name[1]),
                             lstrlen((lpLE->name)) - 1);

                    SelectObject ( lpds->hDC, hOldFont );

                    if ( IsShared( lpLE ) && fShareEnabled )
                        {
                        BitBlt ( lpds->hDC, lpds->rcItem.left + ( LSTBTDX / 2 ),
                           lpds->rcItem.top, LSTBTDX, LSTBTDY,
                           hBtnDC,
                           SHR_PICT_X,
                           SHR_PICT_Y +
                           (( lpds->itemState & ODS_SELECTED ) &&
                            ( lpds->itemState & ODS_FOCUS ) ? 0 : LSTBTDY ),
                           SRCCOPY );
                        }
                    else
                        {
                        BitBlt ( lpds->hDC, lpds->rcItem.left + ( LSTBTDX / 2 ),
                           lpds->rcItem.top, LSTBTDX, LSTBTDY,
                           hBtnDC,
                           SAV_PICT_X,
                           SAV_PICT_Y +
                           (( lpds->itemState & ODS_SELECTED ) &&
                            ( lpds->itemState & ODS_FOCUS ) ? 0 : LSTBTDY ),
                           SRCCOPY );
                        }

                    SelectObject ( hBtnDC, hOldBitmap );
                    SetTextColor ( lpds->hDC, OldTextColor );
                    SetBkColor ( lpds->hDC, OldBkColor );

                    if ( lpds->itemAction & ODA_FOCUS &&
                       lpds->itemState & ODS_FOCUS )
                        {
                        DrawFocusRect ( lpds->hDC, &(lpds->rcItem) );
                        }
                    }
                }
            else if ( GETMDIINFO(hwnd)->DisplayMode == DSP_PREV )
                {
                if ( lpds->itemAction & ODA_FOCUS )
                    {
                    DrawFocusRect ( lpds->hDC, &(lpds->rcItem) );
                    }

                if ( SendMessage ( GETMDIINFO(hwnd)->hWndListbox, LB_GETTEXT,
                      lpds->itemID, (LPARAM)(LPCSTR)&lpLE ) == LB_ERR )
                    {
                    return;
                    }

                if ( lpds->itemAction & ODA_DRAWENTIRE )
                    {

                    // erase any bogus leftover focusrect
                    if ( hBkBrush = CreateSolidBrush ( GetSysColor(COLOR_WINDOW)))
                        {
                        FillRect ( lpds->hDC, &(lpds->rcItem), hBkBrush );
                        DeleteObject ( hBkBrush );
                        }

                    tmprc.top    = lpds->rcItem.top + PREVBRD;
                    tmprc.bottom = lpds->rcItem.top + PREVBRD + PREVBMPSIZ;
                    tmprc.left   = lpds->rcItem.left + 5 * PREVBRD;
                    tmprc.right  = lpds->rcItem.right - 5 * PREVBRD;

                    Rectangle (lpds->hDC,
                               tmprc.left,
                               tmprc.top,
                               tmprc.right,
                               tmprc.bottom );

                    // draw preview bitmap if available
                    if (lpLE->hbmp == NULL)
                        {
                        if (!lpLE->fTriedGettingPreview)
                            {
                            if (!GetPreviewBitmap (hwnd,
                                                   lpLE->name,
                                                   lpds->itemID))
                                {
                                lpLE->fTriedGettingPreview = FALSE;

                                InvalidateRect (lpds->hwndItem,
                                                &(lpds->rcItem),
                                                FALSE);
                                break;
                                }
                            else
                                {
                                lpLE->fTriedGettingPreview = TRUE;
                                }
                            }
                        else
                            {
                            DrawIcon ( lpds->hDC,
                               // the magic '19' below is a function of the icon
                                  tmprc.left + PREVBMPSIZ - 19,
                                  tmprc.top,
                                  hicLock);
                            }
                        }
                    else
                        {
                        hOldBitmap = SelectObject ( hBtnDC, lpLE->hbmp );
                        BitBlt ( lpds->hDC, tmprc.left+1, tmprc.top+1,
                              ( tmprc.right - tmprc.left ) - 2,
                              ( tmprc.bottom - tmprc.top ) - 2,
                              hBtnDC, 0, 0, SRCCOPY );
                        SelectObject ( hBtnDC, hOldBitmap );
                        }

                    // draw share icon in corner...

                    if ( IsShared ( lpLE ) && fShareEnabled )
                        {
                        DrawIcon (lpds->hDC,
                                  tmprc.left - 10,
                                  tmprc.top + PREVBMPSIZ - 24,
                                  LoadIcon ( hInst, MAKEINTRESOURCE(IDSHAREICON)));
                       }
                    }

                if ( lpds->itemAction & ( ODA_SELECT | ODA_DRAWENTIRE | ODA_FOCUS ))
                    {
                    tmprc = lpds->rcItem;
                    tmprc.left += PREVBRD;
                    tmprc.right -= PREVBRD;
                    tmprc.top += PREVBMPSIZ + 2 * PREVBRD;
                    tmprc.bottom--;

                    if ((lpds->itemState & ODS_SELECTED) &&
                        (lpds->itemState & ODS_FOCUS))
                        {
                        TextColor = GetSysColor ( COLOR_HIGHLIGHTTEXT );
                        BackColor = GetSysColor ( COLOR_HIGHLIGHT );
                        }
                    else
                        {
                        TextColor = GetSysColor ( COLOR_WINDOWTEXT );
                        BackColor = GetSysColor ( COLOR_WINDOW );
                        }

                    OldTextColor = SetTextColor ( lpds->hDC, TextColor );
                    OldBkColor = SetBkColor ( lpds->hDC, BackColor );
                    hOldFont = SelectObject ( lpds->hDC, hFontPreview );

                    if ( hBkBrush = CreateSolidBrush ( BackColor ))
                        {
                        FillRect ( lpds->hDC, &tmprc, hBkBrush );
                        DeleteObject ( hBkBrush );
                        }


                    DrawText (lpds->hDC,
                              &(lpLE->name[1]),
                              lstrlen(lpLE->name) -1,
                              &tmprc,
                              DT_CENTER | DT_WORDBREAK | DT_NOPREFIX );

                    SetTextColor ( lpds->hDC, OldTextColor );
                    SetBkColor ( lpds->hDC, OldBkColor );
                    SelectObject ( lpds->hDC, hOldFont );
                    }
                }
            break;

        case ID_PAGEUP:
        case ID_PAGEDOWN:

            if (lpds->itemAction & (ODA_SELECT | ODA_DRAWENTIRE))
                {
                if (lpds->itemState & ODS_SELECTED)
                    hOldBitmap = SelectObject (hBtnDC,
                                               (lpds->CtlID==ID_PAGEUP)? hPgUpDBmp: hPgDnDBmp);
                else
                    hOldBitmap = SelectObject (hBtnDC,
                                               (lpds->CtlID==ID_PAGEUP)? hPgUpBmp: hPgDnBmp);

                StretchBlt (lpds->hDC,
                            lpds->rcItem.top,
                            lpds->rcItem.left,
                            GetSystemMetrics (SM_CXVSCROLL),
                            GetSystemMetrics (SM_CYHSCROLL),
                            hBtnDC,
                            0,
                            0,
                            17,     // x and y of resource bitmaps
                            17,
                            SRCCOPY);

                SelectObject (hBtnDC, hOldBitmap);
                }
            break;

        default:
            PERROR(TEXT("spurious WM_DRAWITEM ctlID %x\n\r"), lpds->CtlID );
            break;
        }
}




// CreateNewListBox ///////////////////////////////
//
// this function creates a new ownerdraw listbox in one of
// two styles suitable for this app: multicolumn for the
// preview bitmap display, and single column for the description
// display preceeded by the little clipboard entry icons

HWND CreateNewListBox(
    HWND    hwnd,
    DWORD   style)
{
HWND hLB;

    hLB = CreateWindow (TEXT("listbox"),
                        szNull,
                        WS_CHILD | LBS_STANDARD | LBS_NOINTEGRALHEIGHT | style,
                        0,
                        0,
                        100,
                        100,
                        hwnd,
                        (HMENU)ID_LISTBOX,
                        hInst,
                        0L );

    if ( style & LBS_MULTICOLUMN )
       SendMessage ( hLB, LB_SETCOLUMNWIDTH, PREVBMPSIZ + 10*PREVBRD, 0L );

    return hLB;
}




// SetClipboardFormatFromDDE ///////////////////////////
//
// This function accepts a ddeml data handle and uses the
// data contained in it to set the clipboard data in the specified
// format to the virtual clipboard associated with the supplied MDI
// child window handle. This could be the real clipboard if the MDI
// child window handle refers to the clipboard child window.

BOOL SetClipboardFormatFromDDE(
    HWND     hwnd,
    UINT     uiFmt,
    HDDEDATA hDDE)
{
HANDLE         hBitmap;
HANDLE         hData;
LPBYTE         lpData;
LPBYTE         lpSrc;
BITMAP         bitmap;
HPALETTE       hPalette;
LPLOGPALETTE   lpLogPalette;
DWORD          cbData;
int            err;
BOOL           fOK = FALSE;


    PINFO("SetClpFmtDDE: format %d, handle %ld | ", uiFmt, hDDE);


    // Check for existing errors, clear the error flag
    err = DdeGetLastError(idInst);


    if (err != DMLERR_NO_ERROR)
        {
        PERROR(TEXT("Existing err %x\r\n"), err);
        }


    // get size of data
    if (NULL == (lpSrc = DdeAccessData ( hDDE, &cbData )))
        {
        #if DEBUG
        unsigned i;

        i = DdeGetLastError(idInst);
        PERROR(TEXT("DdeAccessData fail %d on handle %ld\r\n"), i, hDDE);
        #endif
        goto done;
        }


    PINFO(TEXT("%d bytes of data. "), cbData);

    if (!(hData = GlobalAlloc(GHND, cbData)))
        {
        PERROR(TEXT("GlobalAlloc failed\n\r"));
        goto done2;
        }


    if (!(lpData = GlobalLock(hData)))
       {
       PERROR(TEXT("GlobalLock failed\n\r"));
       goto done2;
       }


    memcpy(lpData, lpSrc, cbData);
    GlobalUnlock(hData);



    // As when we write these we have to special case a few of
    // these guys.  This code and the write code should match in terms
    // of the sizes and positions of data blocks being written out.
    switch ( uiFmt )
        {
        case CF_METAFILEPICT:
           {
           HANDLE      hMF;
           HANDLE      hMFP;
           HANDLE      hDataOut =  NULL;
           LPMETAFILEPICT   lpMFP;

           // Create the METAFILE with the bits we read in.
           lpData = GlobalLock(hData);
           if (hMF = SetMetaFileBitsEx(cbData - sizeof(WIN31METAFILEPICT),
                    lpData + sizeof(WIN31METAFILEPICT)))
              {
              // Alloc a METAFILEPICT header.
              if (hMFP = GlobalAlloc(GHND, (DWORD)sizeof(METAFILEPICT)))
                 {
                 if (!(lpMFP = (LPMETAFILEPICT)GlobalLock(hMFP)))
                    {
                    PERROR(TEXT("Set...FromDDE: GlobalLock failed\n\r"));
                    GlobalFree(hMFP);
                    }
                 else
                    {
                    // Have to set this struct memberwise because it's packed
                    // as a WIN31METAFILEPICT in the data we get via DDE
                    lpMFP->hMF = hMF;
                    lpMFP->xExt =((WIN31METAFILEPICT *)lpData)->xExt;
                    lpMFP->yExt =((WIN31METAFILEPICT *)lpData)->yExt;
                    lpMFP->mm   =((WIN31METAFILEPICT *)lpData)->mm;

                    GlobalUnlock(hMFP);      /* Unlock the header      */
                    hDataOut = hMFP;       /* Stuff this in the clipboard */
                    fOK = TRUE;
                    }
                 }
              else
                 {
                 PERROR(TEXT("SCFDDE: GlobalAlloc fail in MFP, %ld\r\n"),
                       GetLastError());
                 }
              }
           else
              {
              PERROR(TEXT("SClipFDDE: SetMFBitsEx fail %ld\r\n"), GetLastError());
              }
           GlobalUnlock(hData);

           hData = hDataOut;
           break;
           }

        case CF_ENHMETAFILE:
           // We get a block of memory containing enhmetafile bits in this case.
           if (lpData = GlobalLock(hData))
              {
              HENHMETAFILE henh;

              henh = SetEnhMetaFileBits(cbData, lpData);

              if (NULL == henh)
                 {
                 PERROR(TEXT("SetEnhMFBits fail %d\r\n"), GetLastError());
                 }
              else
                 {
                 fOK = TRUE;
                 }

              GlobalUnlock(hData);
              GlobalFree(hData);

              hData = henh;
              }
           else
              {
              GlobalFree(hData);
              hData = NULL;
              }
           break;

        case CF_BITMAP:
           if (!(lpData = GlobalLock(hData)))
              {
              GlobalFree(hData);
              }
           else
              {
              bitmap.bmType = ((WIN31BITMAP *)lpData)->bmType;
              bitmap.bmWidth = ((WIN31BITMAP *)lpData)->bmWidth;
              bitmap.bmHeight = ((WIN31BITMAP *)lpData)->bmHeight;
              bitmap.bmWidthBytes = ((WIN31BITMAP *)lpData)->bmWidthBytes;
              bitmap.bmPlanes = ((WIN31BITMAP *)lpData)->bmPlanes;
              bitmap.bmBitsPixel = ((WIN31BITMAP *)lpData)->bmBitsPixel;
              bitmap.bmBits = lpData + sizeof(WIN31BITMAP);

              // If this fails we should avoid doing the SetClipboardData()
              // below with the hData check.
              hBitmap = CreateBitmapIndirect(&bitmap);

              GlobalUnlock(hData);
              GlobalFree(hData);
              hData = hBitmap;      // Stuff this in the clipboard

              if (hBitmap)
                 {
                 fOK = TRUE;
                 }
              }
           break;

        case CF_PALETTE:
           if (!(lpLogPalette = (LPLOGPALETTE)GlobalLock(hData)))
              {
              GlobalFree(hData);
              DdeUnaccessData( hDDE );
              DdeFreeDataHandle ( hDDE );
              fOK = FALSE;
              }
           else
              {
              // Create a logical palette.
              if (!(hPalette = CreatePalette(lpLogPalette)))
                 {
                 GlobalUnlock(hData);
                 GlobalFree(hData);
                 }
              else
                 {
                 GlobalUnlock(hData);
                 GlobalFree(hData);

                 hData = hPalette;      // Stuff this into clipboard
                 fOK = TRUE;
                 }
              }
           break;


        case DDE_DIB2BITMAP:

            // convert dib to bitmap
            {
            HBITMAP hBmp;

            hBmp = BitmapFromDib (hData,
                                  VGetClipboardData (GETMDIINFO(hwnd)->pVClpbrd, CF_PALETTE));

            GlobalFree (hData);
            hData = hBmp;

            uiFmt = CF_BITMAP;

            fOK = TRUE;
            break;
            }


        default:
           fOK = TRUE;
        }


    if (!hData)
        {
        PERROR(TEXT("SetClipboardFormatFromDDE returning FALSE\n\r"));
        }


    if (GETMDIINFO(hwnd))
        if (fOK)
            {
            PINFO(TEXT("SCFFDDE: Setting VClpD\r\n"));
            VSetClipboardData( GETMDIINFO(hwnd)->pVClpbrd, uiFmt, hData);
            }
        else if (!(GETMDIINFO(hwnd)->flags & F_CLPBRD))
            {
                VSetClipboardData (GETMDIINFO(hwnd)->pVClpbrd, uiFmt,
                                   INVALID_HANDLE_VALUE);
            }


    // No GlobalFree() call here, 'cause we've put hData on the clp


done2:
    DdeUnaccessData(hDDE);

done:
    DdeFreeDataHandle(hDDE);

    return fOK;
}




// NewWindow /////////////////////////////////////////////
//
// this function creates a new MDI child window. special
// case code detects if the window created is the special case
// clipboard MDI child window or the special case local clipbook
// window, this information is used to size the initial 2 windows
// to be tiled side-by-side


HWND  NewWindow(VOID)
{
HWND hwnd;
MDICREATESTRUCT mcs;

    mcs.szTitle = TEXT("");
    mcs.szClass = szChild;
    mcs.hOwner   = hInst;

    /* Use the default size for the window */

    if ( !hwndClpbrd )
       {
       mcs.style = WS_MINIMIZE;
       }
    else
       {
       mcs.style = 0;
       }
    mcs.x = mcs.cx = CW_USEDEFAULT;
    mcs.y = mcs.cy = CW_USEDEFAULT;

    /* Set the style DWORD of the window to default */

    // note not visible!
    mcs.style |= ( WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_CAPTION |
       WS_THICKFRAME | WS_MAXIMIZEBOX | WS_MINIMIZEBOX |
       WS_SYSMENU );

    /* tell the MDI Client to create the child */
    hwnd = (HWND)SendMessage (hwndMDIClient,
               WM_MDICREATE,
               0,
               (LPARAM)(LPMDICREATESTRUCT)&mcs);

    return hwnd;
}



// AdjustMDIClientSize //////////////////////////////
//
// this function adjusts the size of the MDI client window
// when the application is resized according to whether the
// toolbar/status bar is visible, etc.

VOID AdjustMDIClientSize(VOID)
{
RECT rcApp;
RECT rcMDI;


    if (IsIconic(hwndApp))
        return;

    GetClientRect (hwndApp, &rcApp);


    rcMDI.top    = 0;
    rcMDI.bottom = rcApp.bottom - rcApp.top;

    rcMDI.left = 0;
    rcMDI.right = rcApp.right - rcApp.left;

    MoveWindow (hwndMDIClient,
                rcMDI.left - 1,
                rcMDI.top + (fToolBar? (dyButtonBar +1): 0),
                (rcMDI.right - rcMDI.left) + 2,
                ((rcMDI.bottom - rcMDI.top) - (fStatus?dyStatus:0)) -(fToolBar?(dyButtonBar +1):0),
                TRUE);

    if (fNeedToTileWindows )
        {
        SendMessage (hwndMDIClient, WM_MDITILE, 0, 0);
        fNeedToTileWindows = FALSE;
        }
}




// GetConvDataItem ///////////////////////////////////
//
// this function retrieves the data item associated with the
// supplied topic and item from whatever local or remote host
// the MDI child window specified by the supplied handle is
// communicating with. It is used to get the preview bitmaps and
// to get individual format data.
//
// NOTE: caller should LockApp before calling this!

HDDEDATA GetConvDataItem(
    HWND    hwnd,
    LPTSTR  szTopic,
    LPTSTR  szItem,
    UINT    uiFmt)
{
HCONV       hConv;
HSZ         hszTopic;
HSZ         hszItem;
HDDEDATA    hRet = 0;
PMDIINFO    pMDI;


    PINFO(TEXT("GConvDI: %s ! %s, %x\r\n"), szTopic, szItem, uiFmt);

    if (!( hszTopic = DdeCreateStringHandle ( idInst, szTopic, 0 )))
        {
        PERROR(TEXT("GetConvDataItem: DdeCreateStringHandle failed\n\r"));
        return 0;
        }

    if (!(hszItem = DdeCreateStringHandle ( idInst, szItem, 0 )))
        {
        DdeFreeStringHandle ( idInst, hszTopic );
        PERROR(TEXT("GetConvDataItem: DdeCreateStringHandle failed\n\r"));
        return 0;
        }


    if (!(pMDI = GETMDIINFO(hwnd)))
        return 0;

    if ( hConv = DdeConnect (idInst,
                             (uiFmt == cf_preview && !(pMDI->flags & F_LOCAL))?
                              pMDI->hszConvPartnerNP:
                              pMDI->hszConvPartner,
                             hszTopic,NULL ))
        {
        hRet = MySyncXact (NULL, 0L, hConv,
                           hszItem, uiFmt, XTYP_REQUEST, SHORT_SYNC_TIMEOUT, NULL );
        if ( !hRet )
           {
           PERROR(TEXT("Transaction for (%s):(%s) failed: %x\n\r"),
              szTopic, szItem, DdeGetLastError(idInst));
           }
        }
    #if DEBUG
    else
        {
        DdeQueryString ( idInst, GETMDIINFO(hwnd)->hszConvPartner,
           szBuf, 128, CP_WINANSI );
        PERROR(TEXT("GetConvDataItem: connect to %s|%s failed: %d\n\r"),
                    (LPTSTR)szBuf,
                    (LPTSTR)szTopic, DdeGetLastError(idInst) );
        }
    #endif


    DdeDisconnect ( hConv );
    DdeFreeStringHandle ( idInst, hszTopic );

    return hRet;
}



//***************************************************************************
//  FUNCTION   : MyMsgFilterProc
//
//  PURPOSE   : This filter proc gets called for each message we handle.
//            This allows our application to properly dispatch messages
//            that we might not otherwise see because of DDEMLs modal
//            loop that is used while processing synchronous transactions.
//
//            Generally, applications that only do synchronous transactions
//            in response to user input (as this app does) does not need
//            to install such a filter proc because it would be very rare
//            that a user could command the app fast enough to cause
//            problems.  However, this is included as an example.

LRESULT  PASCAL MyMsgFilterProc(
    int     nCode,
    WPARAM  wParam,
    LPARAM  lParam)
{


    if (( nCode == MSGF_DIALOGBOX || nCode == MSGF_MENU ) &&
          ((LPMSG)lParam)->message == WM_KEYDOWN &&
          ((LPMSG)lParam)->wParam == VK_F1 )
       {
       PostMessage ( hwndApp, WM_F1DOWN, nCode, 0L );
       }

    return(0);
}




// MySyncXact ///////////////////////////////
//
// this function is a wrapper to DdeClientTransaction which
// performs some checks related to the Locked state of the app

HDDEDATA MySyncXact(
    LPBYTE  lpbData,
    DWORD   cbDataLen,
    HCONV   hConv,
    HSZ     hszItem,
    UINT    wFmt,
    UINT    wType,
    DWORD   dwTimeout,
    LPDWORD lpdwResult)
{
HDDEDATA    hDDE;
BOOL        fAlreadyLocked;
UINT        uiErr;
UINT        DdeErr = 0;
DWORD       dwTmp  = 0;

#if DEBUG
if (dwTimeout != TIMEOUT_ASYNC)
    {
    dwTimeout +=10000;
    }
#endif


    // are we already in transaction?

    if (WAIT_TIMEOUT == WaitForSingleObject (hXacting, 0))
        {
        Sleep (2000);
        ClearInput (hwndApp);
        return 0L;
        }

    fAlreadyLocked = !LockApp(TRUE, NULL);

    gXERR_Type = 0;
    gXERR_Err  = 0;


    hDDE = DdeClientTransaction (lpbData,
                                 cbDataLen,
                                 hConv,
                                 hszItem,
                                 wFmt,
                                 wType,
                                 dwTimeout,
                                 lpdwResult );

    if (!hDDE)
        {
        DWORD   size;
        LPBYTE  lpByte;


        DdeErr = DdeGetLastError(idInst);

        #if DEBUG
        PERROR("MySyncXact fail err %d.\r\n", uiErr);

        DdeQueryString (idInst, hszItem, lpbItem, 64, CP_WINANSI);
        PINFO(TEXT("Parameters: data at %lx (%s), len %ld, HCONV %lx\r\n"),
              lpbData, (CF_TEXT == wFmt && lpbData) ? lpbData : TEXT("Not text"),
              cbDataLen, hConv);

        PINFO(TEXT("item %lx (%s), fmt %d, type %d, timeout %ld\r\n"),
              hszItem, lpbItem, wFmt, wType, dwTimeout);
        #endif


        //
        // There was an error in the transaction, let's ask
        // the server what was it.
        //

        hDDE = DdeClientTransaction (NULL,
                                     0L,
                                     hConv,
                                     hszErrorRequest,
                                     CF_TEXT,
                                     XTYP_REQUEST,
                                     SHORT_SYNC_TIMEOUT,
                                     NULL);

        uiErr = DdeGetLastError (idInst);

        if (lpByte = DdeAccessData (hDDE, &size))
            sscanf (lpByte, XERR_FORMAT, &gXERR_Type, &gXERR_Err);

        DdeUnaccessData (hDDE);
        DdeFreeDataHandle (hDDE);

        hDDE = 0;
        }


    if (!gXERR_Type && DdeErr)
        {
        gXERR_Type = XERRT_DDE;
        gXERR_Err  = DdeErr;
        }


    if (!fAlreadyLocked)
        {
        LockApp(FALSE, NULL);
        }

    SetEvent (hXacting);

    return hDDE;
}



/*
 *      RequestXactError
 *
 *  Ask the server for error code.
 */

void    RequestXactError(
    HCONV   hConv)
{
HDDEDATA    hDDE;
BOOL        fAlreadyLocked;
UINT        uiErr;
UINT        DdeErr = 0;
DWORD       size;
LPBYTE      lpByte;



    // Are we already in transaction?

    if (WAIT_TIMEOUT == WaitForSingleObject (hXacting, 0))
        {
        Sleep (2000);
        ClearInput (hwndApp);
        return;
        }

    fAlreadyLocked = !LockApp(TRUE, NULL);

    gXERR_Type = 0;
    gXERR_Err  = 0;

    DdeErr = DdeGetLastError(idInst);


    hDDE = DdeClientTransaction (NULL,
                                 0L,
                                 hConv,
                                 hszErrorRequest,
                                 CF_TEXT,
                                 XTYP_REQUEST,
                                 SHORT_SYNC_TIMEOUT,
                                 NULL);

    uiErr = DdeGetLastError (idInst);


    if (lpByte = DdeAccessData (hDDE, &size))
        sscanf (lpByte, XERR_FORMAT, &gXERR_Type, &gXERR_Err);

    DdeUnaccessData (hDDE);
    DdeFreeDataHandle (hDDE);


    if (!gXERR_Type && DdeErr)
        {
        gXERR_Type = XERRT_DDE;
        gXERR_Err  = DdeErr;
        }


    if (!fAlreadyLocked)
        {
        LockApp(FALSE, NULL);
        }

    SetEvent (hXacting);
}



// ResetScrollInfo ///////////////////////////
//
// this function resets the scroll information of the
// MDI child window designated by the supplied handle

VOID ResetScrollInfo(
    HWND    hwnd)
{
PMDIINFO pMDI = GETMDIINFO(hwnd);

    if (!pMDI)
        return;

    // Invalidate object info; reset scroll position to 0.
    pMDI->cyScrollLast = -1L;
    pMDI->cyScrollNow = 0L;
    pMDI->cxScrollLast = -1;
    pMDI->cxScrollNow = 0;

    // Range is set in case CF_OWNERDISPLAY owner changed it.
    PINFO(TEXT("SETSCROLLRANGE for window '%s'\n\r"),
          (LPTSTR)(pMDI->szBaseName) );

    SetScrollRange (pMDI->hwndVscroll, SB_CTL, 0, VPOSLAST, FALSE);
    SetScrollRange (pMDI->hwndHscroll, SB_CTL, 0, HPOSLAST, FALSE);
    SetScrollPos   (pMDI->hwndVscroll, SB_CTL, (int)(pMDI->cyScrollNow), TRUE);
    SetScrollPos   (pMDI->hwndHscroll, SB_CTL, pMDI->cxScrollNow,        TRUE);
}




// IsShared ///////////////////////////////////
//
// this function checks the shared state of the ownerdraw
// listbox entry denoted by the supplied pointer. Shared/nonshared
// status is expressed as a 1 character prefix to the description string
//
// return TRUE if shared, false otherwise

BOOL IsShared(
    LPLISTENTRY lpLE)
{
    if (!lpLE)
        return FALSE;

    if ( lpLE->name[0] == SHR_CHAR )
       return TRUE;

    #if DEBUG
        if ( lpLE->name[0] != UNSHR_CHAR )
            PERROR(TEXT("bad prefix char in share name: %s\n\r"),
                   (LPTSTR)lpLE->name );
    #endif

    return FALSE;
}



// SetShared //////////////////////////////////////////
//
// sets shared state to fShared, returns previous state

BOOL SetShared(
    LPLISTENTRY lpLE,
    BOOL        fShared)
{
BOOL fSave;

    fSave = lpLE->name[0] == SHR_CHAR ? TRUE : FALSE;
    lpLE->name[0] = ( fShared ? SHR_CHAR : UNSHR_CHAR );

    return fSave;
}




// LockApp ////////////////////////////////////////////
//
// this function effectively disables the windows UI during
// synchronous ddeml transactions to prevent the user from initiating
// another transaction or causing the window procedure of this app
// or another application to be re-entered in a way that could cause
// failures... A primary example is that sometimes we are forced to
// go into a ddeml transaction with the clipboard open...  this app
// and other apps must not be caused to access the clipboard during that
// time, so this mechanism emulates the hourglass...
//
// NOTE: do not call LockApp in a section of code where the
// cursor is already captured, such as in response to a scroll
// message, or the releasecapture during unlock will cause strange and
// bad things to happen.


BOOL LockApp(
    BOOL    fLock,
    LPTSTR  lpszComment)
{
static HCURSOR  hOldCursor;
BOOL            fOK = FALSE;


    if (lpszComment)
        {
        SetStatusBarText( lpszComment );
        }

    if ( fLock == TRUE )
        {
        if ( fAppLockedState )
            {
            PERROR(TEXT("LockApp(TRUE): already locked\n\r"));
            }
        else
            {
            hOldCursor = SetCursor ( LoadCursor ( NULL, IDC_WAIT ));

            SetCapture ( hwndDummy );
            EnableWindow ( hwndApp, FALSE );

            fOK = TRUE;
            fAppLockedState = TRUE;
            }
        }
    else
        {
        if ( !fAppLockedState )
            {
            PERROR(TEXT("LockApp(FALSE): not locked\n\r"));
            }
        else
            {

            ClearInput (hwndApp);

            EnableWindow ( hwndApp, TRUE );
            ReleaseCapture ();

            SetCursor ( hOldCursor );

            fOK = TRUE;

            // take care of any deferred clipboard update requests
            if ( fClipboardNeedsPainting )
                {
                PostMessage ( hwndApp, WM_DRAWCLIPBOARD, 0, 0L );
                }

            fAppLockedState = FALSE;
            }
        }

    return fOK;

}




// ForceRenderAll ///////////////////////////////////
//
// this function forces a complete rendering of any delayed
// render clipboard formats
BOOL ForceRenderAll(
    HWND        hwnd,
    PVCLPBRD    pVclp)
{
HANDLE  h;
UINT    uiFmt;

    if ( !VOpenClipboard ( pVclp, hwnd ))
        {
        PERROR(TEXT("Can't open clipboard in ForceRenderAll\n\r"));
        return FALSE;
        }


    for ( uiFmt = VEnumClipboardFormats( pVclp, 0); uiFmt;
          uiFmt = VEnumClipboardFormats( pVclp, uiFmt))
        {
        PINFO(TEXT("ForceRenderAll: force rendering %x\n\r"), uiFmt );
        h = VGetClipboardData ( pVclp, uiFmt );
        }

    VCloseClipboard ( pVclp );
    return TRUE;
}




BOOL UpdateNofMStatus(
    HWND    hwnd)
{
HWND    hwndlistbox;
int     total = 0;
int     sel = LB_ERR;


    if (hwnd == NULL)
        {
        SendMessage ( hwndStatus, SB_SETTEXT, 0, (LPARAM)NULL );
        return TRUE;
        }


    if (!GETMDIINFO(hwnd))
        return FALSE;


    if (GETMDIINFO(hwnd)->flags & F_CLPBRD)
        {
        SendMessage ( hwndStatus, SB_SETTEXT, 0, (LPARAM)(LPTSTR) szSysClpBrd );
        return TRUE;
        }

    if ( IsWindow( hwndlistbox = GETMDIINFO(hwnd)->hWndListbox ) )
        {
        total = (int)SendMessage ( hwndlistbox, LB_GETCOUNT, (WPARAM)0, 0L );
        sel = (int)SendMessage ( hwndlistbox, LB_GETCURSEL, 0, 0L);
        }

    if ( sel == (int)LB_ERR )
        {
        if ( total == 1 )
            SendMessage (hwndStatus, SB_SETTEXT, 0, (LPARAM)(LPCSTR)szPageFmt);
        else
            {
            StringCchPrintf( szBuf, SZBUFSIZ, szPageFmtPl, total );
            SendMessage (hwndStatus, SB_SETTEXT, 0, (LPARAM)(LPCSTR)szBuf );
            }
        }
    else
        {
        StringCchPrintf(szBuf, SZBUFSIZ, szPageOfPageFmt, sel+1, total );
        SendMessage ( hwndStatus, SB_SETTEXT, 0, (LPARAM)(LPCSTR)szBuf );
        }

    return TRUE;
}



BOOL RestoreAllSavedConnections(void)
{
TCHAR       szName[80];
BOOL        ret = TRUE;
unsigned    i;

    i = lstrlen(szConn);

    if (NULL != hkeyRoot)
        {
        DWORD dwSize = 80;
        DWORD iSubkey = 0;

        while (ERROR_SUCCESS == RegEnumKeyEx(hkeyRoot, iSubkey,
                    szName, &dwSize, NULL, NULL, NULL, NULL) )
            {
            if (0 == memcmp(szName, szConn, i))
                {
                PINFO(TEXT("Restoring connection to '%s'\n\r"), szName + i);

                if ( !CreateNewRemoteWindow ( szName + i, FALSE ) )
                    {
                    TCHAR szWindowName[80];

                    // remove re-connect entry
                    RegDeleteKey(hkeyRoot, szName);

                    StringCchCopy(szWindowName, 80, szWindows);
                    StringCchCat( szWindowName, 80, szName + i);
                    RegDeleteKey(hkeyRoot, szWindowName);
                    ret = 0;
                    }
                }

            dwSize = 80;
            iSubkey++;
            }
        }

    return ret;
}




BOOL CreateNewRemoteWindow(
    LPTSTR  szMachineName,
    BOOL    fReconnect)
{
WINDOWPLACEMENT wpl;
HWND            hwndc;
PMDIINFO        pMDIc;


    // make new window active
    hwndc = NewWindow();
    if (NULL == hwndc)
       {
       return FALSE;
       }


    if (!(pMDIc = GETMDIINFO(hwndc)))
        return FALSE;


    // save base name for window
    StringCchCopy( pMDIc->szBaseName, (MAX_COMPUTERNAME_LENGTH+1)*2, szMachineName);
    StringCchCopy( pMDIc->szComputerName, MAX_COMPUTERNAME_LENGTH + 1, szMachineName);

    StringCchPrintf ( szBuf, SZBUFSIZ, TEXT("%s\\%s"), (LPTSTR)szMachineName, (LPTSTR)szNDDEcode);

    pMDIc->hszConvPartner = DdeCreateStringHandle ( idInst, szBuf, 0 );

    PINFO(TEXT("Trying to talk to %s\r\n"),szBuf);

    StringCchPrintf ( szBuf, SZBUFSIZ, TEXT("%s\\%s"), (LPTSTR)szMachineName, (LPTSTR)szNDDEcode1 );
    pMDIc->hszConvPartnerNP = DdeCreateStringHandle ( idInst, szBuf, 0 );

    PINFO(TEXT("NP = %s\r\n"),szBuf);

    #if DEBUG
    DdeQueryString(idInst, hszSystem, szBuf, 128, CP_WINANSI);
    PINFO(TEXT("Topic = %s\r\n"), szBuf);

    PINFO(TEXT("Existing err = %lx\r\n"), DdeGetLastError(idInst));
    #endif

    pMDIc->hExeConv = InitSysConv (hwndc, pMDIc->hszConvPartner, hszClpBookShare, FALSE);


    if ( pMDIc->hExeConv )
       {
       if ( UpdateListBox ( hwndc, pMDIc->hExeConv ))
          {
          StringCchPrintf(szBuf, SZBUFSIZ, szClipBookOnFmt, (LPTSTR)(pMDIc->szBaseName) );
          SetWindowText ( hwndc, szBuf );

          if ( ReadWindowPlacement ( pMDIc->szBaseName, &wpl ))
             {
             wpl.length = sizeof(WINDOWPLACEMENT);
             wpl.flags = WPF_SETMINPOSITION;
             SetWindowPlacement ( hwndc, &wpl );
             UpdateWindow ( hwndc );
             }
          else
             {
             ShowWindow ( hwndc, SW_SHOWNORMAL );
             }

          ShowWindow ( pMDIc->hWndListbox, SW_SHOW );
          SendMessage ( hwndMDIClient, WM_MDIACTIVATE, (WPARAM)hwndc, 0L );
          SendMessage ( hwndMDIClient, WM_MDISETMENU, (WPARAM) TRUE, 0L );

          hwndActiveChild = hwndc;
          pActiveMDI = GETMDIINFO(hwndc);

          if ( fReconnect )
             {
             TCHAR szName[80];
             DWORD dwData;

             StringCchCopy(szName, 80, szConn);
             StringCchCat( szName, 80, szBuf);

             dwData = pMDIc->DisplayMode == DSP_LIST ? 1 : 2;

             RegSetValueEx(hkeyRoot, szName, 0L, REG_DWORD,
                   (LPBYTE)&dwData, sizeof(dwData));

             PINFO(TEXT("saving connection: '%s'\n\r"), (LPTSTR)szBuf );
             }
          else
             {
             TCHAR szName[80];
             DWORD dwData;
             DWORD dwDataSize = sizeof(dwData);

             StringCchCopy(szName, 80, szConn);
             StringCchCat( szName, 80, pMDIc->szBaseName);

             RegQueryValueEx(hkeyRoot, szName, NULL, NULL,
                   (LPBYTE)&dwData, &dwDataSize);

             if (2 == dwData)
                {
                SendMessage ( hwndApp, WM_COMMAND, IDM_PREVIEWS, 0L );
                }
             }

          return TRUE;
          }
       else
          {
          PERROR(TEXT("UpdateListBox failed\n\r"));
          return FALSE;
          }
       }
    else
       {
       unsigned uiErr;

       #if DEBUG
       DdeQueryString(idInst, pMDIc->hszConvPartner, szBuf, 128, CP_WINANSI);
       #endif

       uiErr = DdeGetLastError(idInst);
       PERROR(TEXT("Can't find %s|System. Error #%x\n\r"),(LPTSTR)szBuf, uiErr );
       }

    return FALSE;
}



#define MB_SNDMASK (MB_ICONHAND|MB_ICONQUESTION|MB_ICONASTERISK|MB_ICONEXCLAMATION)

/*
 *      MessageBoxID
 *
 *  Display a message box with strings specified by
 *  TextID and TitleID.
 */

int MessageBoxID(
    HANDLE  hInstance,
    HWND    hwndParent,
    UINT    TextID,
    UINT    TitleID,
    UINT    fuStyle)
{
    LoadString (hInstance, TextID,  szBuf,  SZBUFSIZ);
    LoadString (hInstance, TitleID, szBuf2, SZBUFSIZ);

    MessageBeep (fuStyle & MB_SNDMASK);
    return MessageBox (hwndParent, szBuf, szBuf2, fuStyle);
}



/*
 *      NDdeMessageBox
 *
 *  Display a message box with NDde error
 *  string specified by errCode and title
 *  string specified by TitleID.
 */

int NDdeMessageBox(
    HANDLE  hInstance,
    HWND    hwnd,
    UINT    errCode,
    UINT    TitleID,
    UINT    fuStyle)
{
    if (!errCode)
        return IDOK;

    NDdeGetErrorString (errCode, szBuf, SZBUFSIZ);
    LoadString (hInstance, TitleID, szBuf2, SZBUFSIZ);

    MessageBeep (fuStyle & MB_SNDMASK);
    return MessageBox (hwnd, szBuf, szBuf2, fuStyle);

}




/*
 *      SysMessageBox
 *
 *  Display a messag box for system message
 *  strings specified by dwErr and titl string
 *  specified by TitleID.
 */

int SysMessageBox(
    HANDLE  hInstance,
    HWND    hwnd,
    DWORD   dwErr,
    UINT    TitleID,
    UINT    fuStyle)
{
DWORD   dwR;
LPTSTR  lpBuffer = NULL;
DWORD   dwSize = 20;

    if (dwErr == NO_ERROR)
        return IDOK;

    dwR = FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER|
                         FORMAT_MESSAGE_FROM_SYSTEM,
                         NULL,
                         dwErr,
                         0,
                         (LPTSTR)&lpBuffer,
                         dwSize,
                         NULL);
    if (0 < dwR)
    {
        LoadString (hInstance, TitleID, szBuf2, SZBUFSIZ);

        MessageBeep (fuStyle & MB_SNDMASK);
        dwR = MessageBox (hwnd, lpBuffer, szBuf2, fuStyle);

        LocalFree (lpBuffer);
    }

    return dwR;
}



/*
 *      XactMessageBox
 *
 *  Display a message box for error
 *  occured in an transaction.  MySyncXact
 *  must be called to do the transaction
 *  before calling this function.
 */

int XactMessageBox(
    HANDLE  hInstance,
    HWND    hwnd,
    UINT    TitleID,
    UINT    fuStyle)
{

    switch (gXERR_Type)
        {
        case XERRT_NDDE:
            return NDdeMessageBox (hInstance, hwnd, gXERR_Err, TitleID, fuStyle);
        case XERRT_DDE:
            return DdeMessageBox (hInstance, hwnd, gXERR_Err, TitleID, fuStyle);
        case XERRT_SYS:
            return SysMessageBox (hInstance, hwnd, gXERR_Err, TitleID, fuStyle);
        default:
            return IDOK;
        }
}




/*
 *      DdeNessageBox
 *
 *  Displays a message box for DDE
 *  error strings specified by errCode
 *  and title string spcified by TitleID.
 */

int DdeMessageBox(
    HANDLE  hInstance,
    HWND    hwnd,
    UINT    errCode,
    UINT    TitleID,
    UINT    fuStyle)
{
TCHAR szErr[1024];


    switch (errCode)
        {
        case DMLERR_ADVACKTIMEOUT:
        case DMLERR_DATAACKTIMEOUT:
        case DMLERR_EXECACKTIMEOUT:
        case DMLERR_POKEACKTIMEOUT:
        case DMLERR_UNADVACKTIMEOUT:
        case DMLERR_NO_CONV_ESTABLISHED:
            if (hwnd == hwndLocal)
                LoadString (hInstance, IDS_NOCLPBOOK, szBuf, SZBUFSIZ);
            else
                LoadString (hInstance, IDS_DATAUNAVAIL, szBuf, SZBUFSIZ);
            break;

        case DMLERR_NOTPROCESSED:
        case DMLERR_BUSY:
        case DMLERR_DLL_NOT_INITIALIZED:
        case DMLERR_DLL_USAGE:
        case DMLERR_INVALIDPARAMETER:
        case DMLERR_LOW_MEMORY:
        case DMLERR_MEMORY_ERROR:
        case DMLERR_POSTMSG_FAILED:
        case DMLERR_REENTRANCY:
        case DMLERR_SERVER_DIED:
        case DMLERR_SYS_ERROR:
        case DMLERR_UNFOUND_QUEUE_ID:
            LoadString (hInstance, IDS_INTERNALERR, szBuf, SZBUFSIZ);
            break;
        default:
            return IDOK;
        }

    LoadString (hInstance, TitleID, szBuf2, SZBUFSIZ);

    StringCchPrintf (szErr, 1024, "%s (%#x)", szBuf, errCode);

    MessageBeep (fuStyle & MB_SNDMASK);
    return MessageBox (hwnd, szErr, szBuf2, fuStyle);

}



/*
 *      ClearInput
 *
 *  Removes all keyboard and mouse messages
 *  from message queue
 */

void    ClearInput (HWND    hWnd)
{
MSG Msg;

    while (PeekMessage (&Msg, hWnd, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE));
    while (PeekMessage (&Msg, hWnd, WM_KEYFIRST,   WM_KEYLAST,   PM_REMOVE));
}




PDATAREQ CreateNewDataReq (void)
{
    return (PDATAREQ) GlobalAlloc (GPTR, sizeof(DATAREQ));
}



BOOL DeleteDataReq(
    PDATAREQ    pDataReq)
{
    return ((HGLOBAL)pDataReq == GlobalFree (pDataReq));
}




//
// Purpose: Handle data returned from CLIPSRV via DDE.
//
// Parameters:
//    hData - The data handle the XTYP_XACT_COMPLETE message gave us,
//            or 0L if we got XTYP_DISCONNECT instead.
//
//    pDataReq - Pointer to a DATAREQ struct containing info about what
//               we wanted the data for. This is gotten via DdeGetUserHandle.
//
// Returns:
//    TRUE on success, FALSE on failure.
//
//////////////////////////////////////////////////////////////////////////

BOOL ProcessDataReq(
    HDDEDATA    hData,
    PDATAREQ    pDataReq)
{
LPLISTENTRY lpLE;
LPSTR       lpwszList;
LPSTR       q;
HCURSOR     hSaveCursor;
DWORD       cbDataLen;
UINT        tmp;
PMDIINFO    pMDI;
UINT        uiErr;
BOOL        bRet = FALSE;


    hSaveCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));


    PINFO("PDR:");

    if ( !pDataReq || !IsWindow(pDataReq->hwndMDI) )
        {
        PERROR(TEXT("ProcessDataReq: bogus DATAREQ\n\r"));
        goto done;
        }


    if (!hData)
        {
        PERROR("ProcessDataReq: Woe, woe, we have gotten null data!\r\n");
        DumpDataReq(pDataReq);


        switch (pDataReq->rqType)
            {
            case RQ_COPY:
                MessageBoxID (hInst, hwndApp, IDS_DATAUNAVAIL, IDS_APPNAME,
                              MB_OK | MB_ICONHAND);
                break;
            case RQ_PREVBITMAP:
                // We still have to display the lock icon.
                SetBitmapToListboxEntry (hData, pDataReq->hwndList, pDataReq->iListbox);
                break;
            }

        goto done;;
        }


    if (!(pMDI = GETMDIINFO(pDataReq->hwndMDI)))
        goto done;


    switch ( pDataReq->rqType )
        {
        case RQ_PREVBITMAP:
           PINFO("Got bitmap for item %d in %x\r\n",pDataReq->iListbox,
                 pDataReq->hwndList);
           SetBitmapToListboxEntry( hData, pDataReq->hwndList, pDataReq->iListbox);
           InitializeMenu (GetMenu (hwndApp));
           bRet = TRUE;
           break;

        case RQ_EXECONV:
           // must be from disconnect
           GETMDIINFO(pDataReq->hwndMDI)->hExeConv = 0L;
           PINFO(TEXT("setting hExeConv NULL!\n\r"));
           break;

        case RQ_COPY:
           PINFO("RQ_COPY:");
           if ( hData == FALSE )
              {
              uiErr = DdeGetLastError (idInst);
              PERROR(TEXT("REQUEST for format list failed: %x\n\r"), uiErr);
              DdeMessageBox (hInst, pDataReq->hwndMDI, uiErr, IDS_APPNAME, MB_OK|MB_ICONEXCLAMATION);
              break;
              }

           lpwszList = DdeAccessData ( hData, &cbDataLen );

           if ( !lpwszList )
              {
              uiErr = DdeGetLastError (idInst);
              DdeMessageBox (hInst, pDataReq->hwndMDI, uiErr, IDS_APPNAME, MB_OK|MB_ICONEXCLAMATION);
              break;
              }

           PINFO(TEXT("formatlist:>%ws<\n\r"), lpwszList );
           // this client now becomes the clipboard owner!!!

           if (SyncOpenClipboard (hwndApp) == TRUE)
              {
              BOOL  bHasBitmap = FALSE;
              BOOL  bLocked;

              // Need to lock app while we fill the clipboard with formats,
              // else hwndClpbrd will try to frantically try to redraw while
              // we're doing it. Since hwndClpbrd needs to openclipboard() to
              // do that, we don't want it to.
              bLocked = LockApp(TRUE, szNull);

              // reset clipboard view format to auto
              pMDI->CurSelFormat = CBM_AUTO;

              EmptyClipboard();

              hwndClpOwner = pDataReq->hwndMDI;
              PINFO(TEXT("Formats:"));

              if (pDataReq->wFmt != CF_TEXT)
                 {
                 PERROR(TEXT("Format %d, expected CF_TEXT!\r\n"), pDataReq->wFmt);
                 }


              for (q = strtokA(lpwszList, "\t");q;q = strtokA(NULL, "\t"))
                 {
                 PINFO(TEXT("[%s] "),q);
                 tmp = MyGetFormat(q, GETFORMAT_DONTLIE);
                 if (0 == tmp)
                    {
                    PERROR(TEXT("MyGetFormat failure!\r\n"));
                    }
                 else
                    {
                    switch (tmp)
                        {
                        case CF_DIB:
                            // DDBitmap can be converted from Dib.
                            SetClipboardData (CF_BITMAP, NULL);
                        default:
                            SetClipboardData (tmp, NULL);
                        }
                    }
                 }

              PINFO("\r\n");

              SyncCloseClipboard();

              if (bLocked)
                 LockApp (FALSE, szNull);


              // Redraw clipboard window.
              if (hwndClpbrd)
                 {
                 InvalidateRect(hwndClpbrd, NULL, TRUE);
                 }
              }
           else
              {
              PERROR(TEXT("ProcessDataReq: unable to open clipboard\n\r"));
              }

           DdeUnaccessData ( hData );
           DdeFreeDataHandle ( hData );
           bRet = TRUE;
           break;

        case RQ_SETPAGE:
           PINFO(TEXT("RQ_SETPAGE:"));

           if ( hData == FALSE )
              {
              uiErr = DdeGetLastError (idInst);
              PERROR(TEXT("vclip: REQUEST for format list failed: %x\n\r"), idInst);
              DdeMessageBox (hInst, pDataReq->hwndMDI, idInst, IDS_APPNAME, MB_OK|MB_ICONEXCLAMATION);
              break;
              }

           if ( SendMessage ( pMDI->hWndListbox,
                 LB_GETTEXT, pDataReq->iListbox,
                 (LPARAM)(LPCSTR)&lpLE) == LB_ERR )
              {
              PERROR(TEXT("IDM_COPY: bad listbox index: %d\n\r"), pDataReq->iListbox );
              break;
              }

           lpwszList = DdeAccessData ( hData, &cbDataLen );

           if ( !lpwszList )
              {
              uiErr = DdeGetLastError (idInst);
              DdeMessageBox (hInst, pDataReq->hwndMDI, uiErr, IDS_APPNAME, MB_OK | MB_ICONEXCLAMATION );
              break;
              }

           if ( VOpenClipboard ( pMDI->pVClpbrd, pDataReq->hwndMDI ) == TRUE )
              {
              BOOL  bHasBitmap = FALSE;

              VEmptyClipboard( pMDI->pVClpbrd );

              for (q = strtokA(lpwszList, "\t");q;q = strtokA(NULL,"\t"))
                 {
                 tmp = MyGetFormat(q, GETFORMAT_DONTLIE);

                 switch (tmp)
                     {
                     case CF_DIB:
                         // DDBitmap can be converted from Dib.
                         VSetClipboardData (pMDI->pVClpbrd, CF_BITMAP, NULL);
                     default:
                         VSetClipboardData (pMDI->pVClpbrd, tmp, NULL);
                     }
                 }

              VCloseClipboard( pMDI->pVClpbrd );
              }
           else
              {
              PERROR(TEXT("ProcessDataReq: unable to open Vclipboard\n\r"));
              }

           DdeUnaccessData ( hData );
           DdeFreeDataHandle ( hData );

           // set proper window text
           if ( pMDI->flags & F_LOCAL )
              {
              StringCchPrintf( szBuf, SZBUFSIZ, TEXT("%s - %s"), szLocalClpBk, &(lpLE->name[1]) );
              }
           else
              {
              StringCchPrintf( szBuf, SZBUFSIZ, TEXT("%s - %s"), (pMDI->szBaseName), &(lpLE->name[1]) );
              }
           SetWindowText ( pDataReq->hwndMDI, szBuf );

           SetFocus ( pDataReq->hwndMDI );
           pMDI->CurSelFormat = CBM_AUTO;
           pMDI->fDisplayFormatChanged = TRUE;
           ResetScrollInfo ( pDataReq->hwndMDI );

           // means data is for going into page mode
           if ( pMDI->DisplayMode != DSP_PAGE )
              {
              pMDI->OldDisplayMode = pMDI->DisplayMode;
              pMDI->DisplayMode = DSP_PAGE;
              AdjustControlSizes ( pDataReq->hwndMDI );
              ShowHideControls ( pDataReq->hwndMDI );
              InitializeMenu ( GetMenu(hwndApp) );
              }
           else // data is for scrolling up or down one page
              {
              SendMessage ( pMDI->hWndListbox, LB_SETCURSEL,
                 pDataReq->iListbox, 0L );
              }

           UpdateNofMStatus ( pDataReq->hwndMDI );
           InvalidateRect ( pDataReq->hwndMDI, NULL, TRUE );

           // refresh preview bitmap?
           if ( !lpLE->hbmp )
              {
              GetPreviewBitmap ( pDataReq->hwndMDI, lpLE->name,
                 pDataReq->iListbox );
              }

           // PINFO("\r\n");
           bRet = TRUE;
           break;

        default:
           PERROR (TEXT("unknown type %d in ProcessDataReq\n\r"),
                 pDataReq->rqType );
           break;
        }

done:

    SetCursor (hSaveCursor);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\cvutil.h ===
/*****************************************************************************

                    C L I P B O O K   U T I L I T I E S

    Name:       cvutil.h
    Date:       21-Jan-1994
    Creator:    John Fu

    Description:
        This is the header file for cvutil.c

*****************************************************************************/




extern  DWORD   gXERR_Type;
extern  DWORD   gXERR_Err;

extern  HSZ     hszErrorRequest;




VOID AdjustControlSizes(
    HWND    hwnd);


VOID ShowHideControls(
    HWND    hwnd);


BOOL AssertConnection(
    HWND    hwnd);


HCONV InitSysConv(
    HWND    hwnd,
    HSZ     hszApp,
    HSZ     hszTopic,
    BOOL    fLocal);


BOOL UpdateListBox(
    HWND    hwnd,
    HCONV   hConv);


BOOL GetPreviewBitmap(
    HWND    hwnd,
    LPTSTR  szName,
    UINT    index);


VOID SetBitmapToListboxEntry(
    HDDEDATA    hbmp,
    HWND        hwndList,
    UINT        index);


BOOL InitListBox(
    HWND        hwnd,
    HDDEDATA    hData);


UINT MyGetFormat(
    LPTSTR  szFmt,
    int     mode);


VOID HandleOwnerDraw(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam);


HWND CreateNewListBox(
    HWND    hwnd,
    DWORD   style);


BOOL SetClipboardFormatFromDDE(
    HWND     hwnd,
    UINT     uiFmt,
    HDDEDATA hDDE);


HWND  NewWindow(void);


VOID AdjustMDIClientSize(void);


HDDEDATA GetConvDataItem(
    HWND    hwnd,
    LPTSTR  szTopic,
    LPTSTR  szItem,
    UINT    uiFmt);


LRESULT  PASCAL MyMsgFilterProc(
    int     nCode,
    WPARAM  wParam,
    LPARAM  lParam);


HDDEDATA MySyncXact(
    LPBYTE  lpbData,
    DWORD   cbDataLen,
    HCONV   hConv,
    HSZ     hszItem,
    UINT    wFmt,
    UINT    wType,
    DWORD   dwTimeout,
    LPDWORD lpdwResult);


void    RequestXactError(
    HCONV   hConv);


VOID ResetScrollInfo(
    HWND    hwnd);


BOOL IsShared(
    LPLISTENTRY lpLE);


BOOL SetShared(
    LPLISTENTRY lpLE,
    BOOL        fShared);


BOOL LockApp(
    BOOL    fLock,
    LPTSTR  lpszComment);


BOOL ForceRenderAll(
    HWND        hwnd,
    PVCLPBRD    pVclp);


BOOL UpdateNofMStatus(
    HWND    hwnd);


BOOL RestoreAllSavedConnections(void);


BOOL CreateNewRemoteWindow(
    LPTSTR  szMachineName,
    BOOL    fReconnect);


int MessageBoxID(
    HANDLE  hInstance,
    HWND    hwndParent,
    UINT    TextID,
    UINT    TitleID,
    UINT    fuStyle);


int NDdeMessageBox(
    HANDLE  hInstance,
    HWND    hwnd,
    UINT    errCode,
    UINT    TitleID,
    UINT    fuStyle);


int SysMessageBox(
    HANDLE  hInstance,
    HWND    hwnd,
    DWORD   dwErr,
    UINT    TitleID,
    UINT    fuStyle);


int XactMessageBox(
    HANDLE  hInstance,
    HWND    hwnd,
    UINT    TitleID,
    UINT    fuStyle);


int DdeMessageBox(
    HANDLE  hInstance,
    HWND    hwnd,
    UINT    errCode,
    UINT    TitleID,
    UINT    fuStyle);


void    ClearInput (HWND hWnd);


PDATAREQ CreateNewDataReq(void);


BOOL DeleteDataReq(
    PDATAREQ    pDataReq);


BOOL ProcessDataReq(
    HDDEDATA    hData,
    PDATAREQ    pDataReq);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\cvinit.c ===
/*****************************************************************************

                    C L I P B O O K   I N I T

    Name:       cvinit.c
    Date:       21-Jan-1994
    Creator:    Unknown

*****************************************************************************/


#define    OEMRESOURCE
#include <windows.h>
#include <commctrl.h>
#include <stdio.h>
#include <math.h>
#include "common.h"
#include "clipbook.h"
#include "clipbrd.h"
#include "clipdsp.h"
#include "cvinit.h"
#include "debugout.h"


static int SSplit[] = { 200, 500 };
static int SBorders[3] = { 20, 0, 0 };


HWND    hwndToolbar = NULL;
HWND    hwndStatus  = NULL;
HBITMAP hbmStatus   = NULL;


TCHAR   szWindows[]   =   TEXT("Windows");



DWORD nIDs[] =
    {
    MH_BASE ,MH_POPUPBASE, 0, 0   /* This list must be NULL terminated */
    };

TBBUTTON tbButtons[] = {
    {0,  0,             TBSTATE_ENABLED, TBSTYLE_SEP,       0},
    {0,  IDM_CONNECT,   TBSTATE_ENABLED, TBSTYLE_BUTTON,    0},
    {1,  IDM_DISCONNECT,TBSTATE_ENABLED, TBSTYLE_BUTTON,    0},
    {0,  0,             TBSTATE_ENABLED, TBSTYLE_SEP,       0},
    {2,  IDM_SHARE,     TBSTATE_ENABLED, TBSTYLE_BUTTON,    0},
    {3,  IDM_UNSHARE,   TBSTATE_ENABLED, TBSTYLE_BUTTON,    0},
    {0,  0,             TBSTATE_ENABLED, TBSTYLE_SEP,       0},
    {5,  IDM_COPY,      TBSTATE_ENABLED, TBSTYLE_BUTTON,    0},
    {6,  IDM_KEEP,      TBSTATE_ENABLED, TBSTYLE_BUTTON,    0},
    {7,  IDM_DELETE,    TBSTATE_ENABLED, TBSTYLE_BUTTON,    0},
    {0,  0,             TBSTATE_ENABLED, TBSTYLE_SEP,       0},
    {8,  IDM_LISTVIEW,  TBSTATE_ENABLED, TBSTYLE_CHECKGROUP,0},
    {9,  IDM_PREVIEWS,  TBSTATE_ENABLED, TBSTYLE_CHECKGROUP,0},
    {10, IDM_PAGEVIEW,  TBSTATE_ENABLED, TBSTYLE_CHECKGROUP,0}
};



VOID LoadIntlStrings (void)
{
    LoadString (hInst, IDS_HELV, szHelv, SMLRCBUF);
    LoadString (hInst, IDS_APPNAME, szAppName, SMLRCBUF);
    LoadString (hInst, IDS_LOCALCLIP, szLocalClpBk, SMLRCBUF);
    LoadString (hInst, IDS_CLIPBOARD, szSysClpBrd, SMLRCBUF);
    LoadString (hInst, IDS_DATAUNAVAIL, szDataUnavail, BIGRCBUF);
    LoadString (hInst, IDS_READINGITEM, szReadingItem, BIGRCBUF);
    LoadString (hInst, IDS_VIEWHELPFMT, szViewHelpFmt, BIGRCBUF);
    LoadString (hInst, IDS_ACTIVATEFMT, szActivateFmt, BIGRCBUF);
    LoadString (hInst, IDS_RENDERING, szRendering, BIGRCBUF);
    LoadString (hInst, IDS_DEFFORMAT, szDefaultFormat, BIGRCBUF);
    LoadString (hInst, IDS_GETTINGDATA, szGettingData, BIGRCBUF);
    LoadString (hInst, IDS_ESTABLISHING, szEstablishingConn, BIGRCBUF);
    LoadString (hInst, IDS_CLIPBOOKONFMT, szClipBookOnFmt, BIGRCBUF);
    LoadString (hInst, IDS_PAGEFMT, szPageFmt, SMLRCBUF);
    LoadString (hInst, IDS_PAGEFMTPL, szPageFmtPl, SMLRCBUF);
    LoadString (hInst, IDS_PAGEOFPAGEFMT, szPageOfPageFmt, SMLRCBUF);
    LoadString (hInst, IDS_DELETE, szDelete, SMLRCBUF);
    LoadString (hInst, IDS_DELETECONFIRMFMT, szDeleteConfirmFmt, SMLRCBUF);
    LoadString (hInst, IDS_FILEFILTER, szFileFilter, BIGRCBUF);
}




VOID SaveWindowPlacement (
    PWINDOWPLACEMENT    pwp )
{
WINDOWPLACEMENT wp;
int             dir_num = 0;
HWND            hwnd;


    // save main window placement

    if (hkeyRoot != NULL)
       {
       pwp->length = sizeof(WINDOWPLACEMENT);
       lstrcat(lstrcpy(szBuf2, szWindows), szAppName);
       RegSetValueEx(hkeyRoot,
             szBuf2,
             0L,
             REG_BINARY,
             (LPBYTE)pwp,
             sizeof(WINDOWPLACEMENT));

       // write out dir window strings in reverse order
       // so that when we read them back in we get the same Z order
       wp.length = sizeof (WINDOWPLACEMENT);
       wp.flags = 0;

       for (hwnd = GetWindow(hwndMDIClient, GW_CHILD); hwnd;
                hwnd = GetWindow(hwnd, GW_HWNDNEXT))
          {
          // don't save MDI icon title windows or search windows,
          // or any dir window which is currently recursing

          if (GetWindow(hwnd, GW_OWNER) == NULL &&
              GetWindowPlacement(hwnd, &wp) )
             {
             wp.length = sizeof(WINDOWPLACEMENT);
             wp.flags = (wp.showCmd == SW_SHOWMINIMIZED)
                   ? WPF_SETMINPOSITION : 0;

             if (GETMDIINFO(hwnd))
                 lstrcat(lstrcpy(szBuf2, szWindows), GETMDIINFO(hwnd)->szBaseName);

             RegSetValueEx(hkeyRoot,
                   szBuf2,
                   0L,
                   REG_BINARY,
                   (LPBYTE)&wp,
                   sizeof(wp));
             }
          }
       }

}



BOOL ReadWindowPlacement(
    LPTSTR              szKey,
    PWINDOWPLACEMENT    pwp)
{

    // AnsiToOem ( szKey, szBuf2 );
    if (hkeyRoot != NULL)
        {
        DWORD dwBufSize = sizeof(WINDOWPLACEMENT);

        lstrcat(lstrcpy(szBuf2, szWindows), szKey);
        RegQueryValueEx(hkeyRoot, szBuf2, NULL, NULL, (LPBYTE)pwp, &dwBufSize);

        if (pwp->length == sizeof(WINDOWPLACEMENT))
           {
           return TRUE;
           }
        else
           {
           PINFO(TEXT("ReadWindowPlacement: QueryValue failed\n\r"));
           }
        return FALSE;
        }

    PINFO(TEXT("ReadWindowPlacement: no entry\n\r"));

    return FALSE;

}





BOOL CreateTools(
    HWND    hwnd)
{
HDC hdc;
TEXTMETRIC tm;
int dyBorder;
int cx,cy;
HFONT hTmpFont;
SIZE  size;



    if ( !(hbrBackground = CreateSolidBrush ( GetSysColor(COLOR_WINDOW) )))
        return FALSE;


    if ( !(hbmStatus = CreateMappedBitmap(hInst, IDSTATUS, FALSE, NULL, 0)))
        return FALSE;


    // create toolbar and status bar windows
    // has all buttons initially...

    if ( !(hwndToolbar = CreateToolbarEx (hwnd,
                                          (fToolBar?WS_VISIBLE:0)|WS_BORDER|TBSTYLE_TOOLTIPS,
                                          IDC_TOOLBAR,
                                          11,
                                          hInst,
                                          IDBITMAP,
                                          tbButtons,
                                          sizeof(tbButtons)/sizeof(TBBUTTON),
                                          0,0,0,0,sizeof(TBBUTTON))))
        return FALSE;



    // get rid of share buttons?
    if (!fShareEnabled)
        {
        SendMessage (hwndToolbar, TB_DELETEBUTTON, 3,  0L);
        SendMessage (hwndToolbar, TB_DELETEBUTTON, 3,  0L);
        SendMessage (hwndToolbar, TB_DELETEBUTTON, 3,  0L);
        }


    // get rid of connect/disonnect buttons?
    if (!fNetDDEActive)
        {
        SendMessage (hwndToolbar, TB_DELETEBUTTON, 0,  0L);
        SendMessage (hwndToolbar, TB_DELETEBUTTON, 0,  0L);
        SendMessage (hwndToolbar, TB_DELETEBUTTON, 0,  0L);
        }


    if ( fToolBar )
        ShowWindow ( hwndToolbar, SW_SHOW );




    // create status bar

    if ( !(hwndStatus = CreateStatusWindow ((fStatus?WS_VISIBLE:0)|WS_BORDER|WS_CHILD|WS_CLIPSIBLINGS,
                                            szNull,
                                            hwnd,
                                            IDSTATUS )))
       return FALSE;


    // now build the parameters based on the font we will be using

    dyBorder = GetSystemMetrics(SM_CYBORDER);
    cx = GetSystemMetrics (SM_CXVSCROLL);
    cy = GetSystemMetrics (SM_CYHSCROLL);





    if ( hdc= GetDC(NULL) )
        {
        CHARSETINFO csi;
        DWORD dw = GetACP();
        LOGFONT lfDef; 

        GetObject( GetStockObject(DEFAULT_GUI_FONT), sizeof(LOGFONT), &lfDef );

        if (!TranslateCharsetInfo((DWORD*)(DWORD_PTR)dw, &csi, TCI_SRCCODEPAGE))
            csi.ciCharset = ANSI_CHARSET;

        hPreviewBmp = CreateBitmap ( 64, 64, 1, 1, NULL );

        hBtnDC = CreateCompatibleDC ( hdc );

        hPgUpBmp = LoadBitmap ( hInst, MAKEINTRESOURCE(IBM_UPARROW) );
        hPgDnBmp = LoadBitmap ( hInst, MAKEINTRESOURCE(IBM_DNARROW) );
        hPgUpDBmp = LoadBitmap ( hInst, MAKEINTRESOURCE(IBM_UPARROWD) );
        hPgDnDBmp = LoadBitmap ( hInst, MAKEINTRESOURCE(IBM_DNARROWD) );

        hFontPreview = CreateFont (lfDef.lfHeight,
                                   0,
                                   0,
                                   0,
                                   400,
                                   0,
                                   0,
                                   0,
                                   csi.ciCharset,
                                   OUT_DEFAULT_PRECIS,
                                   CLIP_DEFAULT_PRECIS,
                                   DEFAULT_QUALITY,
                                   VARIABLE_PITCH | FF_SWISS,
                                   szHelv);


        hOldFont = SelectObject(hdc, hFontPreview);

        GetTextMetrics(hdc, &tm);
        dyPrevFont = tm.tmHeight + tm.tmExternalLeading;



        if (hOldFont)
           SelectObject(hdc, hOldFont);

        // figure out where to put the first status bar splitpoint
        SendMessage ( hwndStatus, SB_GETBORDERS, 0, (LPARAM)(LPBYTE)&SBorders );

        if ( hTmpFont = (HFONT)SendMessage(hwndStatus, WM_GETFONT, 0, 0L ))
            {
            if ( hOldFont = SelectObject ( hdc, hTmpFont ))
                {
                wsprintf ( szBuf, szPageOfPageFmt, 888, 888 );

                GetTextExtentPoint(hdc, szBuf, lstrlen(szBuf),&size);
                SSplit[0] = size.cx + 2 * GetSystemMetrics(SM_CXBORDER)
                   + 2 * SBorders[0];

                if ( hOldFont )
                    SelectObject( hdc, hOldFont );
                }
            }
        ReleaseDC(NULL, hdc);

        if ( !hTmpFont || !hPgUpBmp || !hPgDnBmp || !hPgUpDBmp ||
           !hFontPreview || !hPreviewBmp || !hBtnDC )
        return FALSE;
        }
    else
        return FALSE;

    //second split point is fixed for now.

    SendMessage ( hwndStatus, SB_SETPARTS, 2, (LPARAM)(LPBYTE)&SSplit );
    return TRUE;

}



VOID DeleteTools (
    HWND    hwnd)
{
    DeleteDC ( hBtnDC );

    DeleteObject ( hPreviewBmp );

    DeleteObject ( hbmStatus );
    DeleteObject ( hFontPreview );
    DeleteObject ( hbrBackground );

    DeleteObject ( hPgUpBmp );
    DeleteObject ( hPgDnBmp );
    DeleteObject ( hPgUpDBmp );
    DeleteObject ( hPgDnDBmp );

    DestroyWindow(hwndToolbar);
    DestroyWindow(hwndStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\cvcomman.c ===
/*****************************************************************************

                C L I P B O O K   V I E W E R   C O M M A N D S

    Name:       cvcomman.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This module handles all WM_COMMAND's.

*****************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <nddeapi.h>
#include <shellapi.h>
#include <assert.h>
#include <strsafe.h>

#include "common.h"
#include "clipbook.h"
#include "clipbrd.h"
#include "clipdsp.h"
#include "dialogs.h"
#include "clpbkdlg.h"
#include "cvcomman.h"
#include "cvinit.h"
#include "cvutil.h"
#include "helpids.h"
#include "debugout.h"
#include "initmenu.h"
#include "shares.h"
#include "clipfile.h"

#include <htmlhelp.h>


// Typedef for the ShellAbout function
typedef void (WINAPI *LPFNSHELLABOUT)(HWND, LPTSTR, LPTSTR, HICON);



// Flags and typedef for the NT LanMan computer browser dialog.
// The actual function is I_SystemFocusDialog, in NTLANMAN.DLL.
#define FOCUSDLG_SERVERS_ONLY        (2)

#define FOCUSDLG_BROWSE_LOGON_DOMAIN         0x00010000
#define FOCUSDLG_BROWSE_WKSTA_DOMAIN         0x00020000
#define FOCUSDLG_BROWSE_OTHER_DOMAINS        0x00040000
#define FOCUSDLG_BROWSE_TRUSTING_DOMAINS     0x00080000
#define FOCUSDLG_BROWSE_WORKGROUP_DOMAINS    0x00100000

typedef UINT (APIENTRY *LPFNSYSFOCUS)(HWND, UINT, LPWSTR, UINT, PBOOL, LPWSTR, DWORD);


static TCHAR szDirName[256] = {'\0',};




///////////////////////////////////////////////////////////////////////
//
// Purpose: Delete the selected share.
//
///////////////////////////////////////////////////////////////////////
LRESULT OnIDMDelete(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wparam,
    LPARAM  lparam)
{
int         tmp;
LPLISTENTRY lpLE;
LISTENTRY   LE;
LRESULT     ret = FALSE;
TCHAR       PageName[MAX_PAGENAME_LENGTH+1];


    if (!pActiveMDI)
        return 0L;


    // Doing a "delete" on the clipboard window clears clipboard
    if (pActiveMDI->flags & F_CLPBRD)
        {
        if ( ClearClipboard(hwndApp) == IDOK )
            {
            EmptyClipboard();
            InitializeMenu ( GetMenu(hwnd) );

            // Force redraw of clipboard window
            if (hwndClpbrd)
                {
                InvalidateRect(hwndClpbrd, NULL, TRUE);
                ret = TRUE;
                }
            }

        return ret;
        }



    tmp = (int)SendMessage (pActiveMDI->hWndListbox, LB_GETCURSEL, 0, 0L);

    if (tmp == LB_ERR)
        {
        PERROR("Could not figure out which item was selected!\r\n");
        return ret;
        }


    SendMessage ( pActiveMDI->hWndListbox, LB_GETTEXT, tmp, (LPARAM)(LPCSTR)&lpLE);
    memcpy(&LE, lpLE, sizeof(LE));

    StringCchPrintf(szBuf, SZBUFSIZ, szDeleteConfirmFmt, (LPTSTR)((lpLE->name)+1) );
    MessageBeep ( MB_ICONEXCLAMATION );

    StringCchCopy (PageName, MAX_PAGENAME_LENGTH+1, lpLE->name);

    if (MessageBox ( hwndApp, szBuf, szDelete, MB_ICONEXCLAMATION|MB_OKCANCEL ) != IDCANCEL)
        {
        AssertConnection ( hwndActiveChild );

        if ( hwndActiveChild == hwndClpOwner )
            {
            ForceRenderAll( hwnd, NULL );
            }


        // Perform an execute to the server to let it know that
        // we're not sharing anymore.

        StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%s%s"), SZCMD_DELETE, lpLE->name);

        if (MySyncXact (szBuf,
                        lstrlen(szBuf) +1,
                        pActiveMDI->hExeConv,
                        0L,
                        CF_TEXT,
                        XTYP_EXECUTE,
                        SHORT_SYNC_TIMEOUT,
                        NULL)
            )
            {
            TCHAR   ComputerName[MAX_COMPUTERNAME_LENGTH+3] = TEXT("\\\\");
            DWORD   CNLen = sizeof(ComputerName) + 1;


            // Need to delete the trust
            GetComputerName (ComputerName+2, &CNLen);
            #ifdef USETWOSHARESPERPAGE
                if (fSharePreference)
                    PageName[0] = SHR_CHAR;
                else
                    PageName[0] = UNSHR_CHAR;
            #else
                PageName[0] = SHR_CHAR;
            #endif
            NDdeSetTrustedShare (ComputerName, PageName, NDDE_TRUST_SHARE_DEL);


            if ( pActiveMDI->DisplayMode == DSP_PAGE )
                {
                PINFO(TEXT("forcing back to list mode\n\r"));
                SendMessage (hwndApp, WM_COMMAND,
                             pActiveMDI->OldDisplayMode == DSP_PREV ?
                               IDM_PREVIEWS : IDM_LISTVIEW,
                             0L );
                }

            UpdateListBox (hwndActiveChild, pActiveMDI->hExeConv);
            InitializeMenu (GetMenu(hwndApp));
            }
        else
            {
            XactMessageBox (hInst, hwndApp, IDS_APPNAME, MB_OK | MB_ICONHAND);
            }
        }

    return ret;
}



/*
 *      OnIDMKeep
 *
 *  Purpose: Create a Clipbook page.
 */

LRESULT OnIDMKeep (
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL    bNewPage)
{
PMDIINFO        pMDI;
int             tmp;
DWORD           ret;
HANDLE          hData;
PNDDESHAREINFO  lpDdeInfo = NULL;
TCHAR           atchItem[256];
#ifdef NOOLEITEMSPERMIT
    unsigned    i;
#endif
LPTSTR          lpEnd; // Pointer to the end of the current data block
TCHAR           rgtchCName[MAX_COMPUTERNAME_LENGTH + 3];
DWORD           dwLen;
HCURSOR         hCursor = NULL;
BOOL            bShareSave = fSharePreference;
KEEPASDLG_PARAM KeepAs;
int             Size;


    if (!CountClipboardFormats())
        {
        PERROR (TEXT("Paste entered with no data on the clipboard!\r\n"));
        goto done;
        }

    if (!hwndLocal || !IsWindow(hwndLocal))
        {
        MessageBoxID (hInst, hwnd, IDS_NOCLPBOOK, IDS_APPNAME, MB_OK | MB_ICONSTOP);
        goto done;
        }

    if (!pActiveMDI)
        goto done;

    pMDI = GETMDIINFO(hwndLocal);


    if (bNewPage)
        {
        tmp = (int)SendMessage (pActiveMDI->hWndListbox, LB_GETCOUNT, 0, 0L );

        if (tmp >= MAX_ALLOWED_PAGES)
            {
            MessageBoxID (hInst, hwnd, IDS_MAXPAGESERROR, IDS_PASTEDLGTITLE, MB_OK|MB_ICONEXCLAMATION);
            goto done;
            }


        // Do the dialog and get KeepAs request

        KeepAs.ShareName[0]   = TEXT('\0');
        KeepAs.bAlreadyExist  = FALSE;
        KeepAs.bAlreadyShared = FALSE;

        dwCurrentHelpId = 0;            //  F1 will be context sensitive

        ret = (DWORD)DialogBoxParam (hInst,
                                     MAKEINTRESOURCE(IDD_KEEPASDLG),
                                     hwnd,
                                     KeepAsDlgProc ,
                                     (LPARAM)&KeepAs);

        PINFO (TEXT("DialogBox returning %d\n\r"), ret );
        dwCurrentHelpId = 0L;


        // refresh main window
        UpdateWindow (hwndApp);

        if (!ret || !KeepAs.ShareName[0])
            goto done;

        bShareSave = fSharePreference;
        }



    if (!bNewPage || KeepAs.bAlreadyExist)
        {
        PLISTENTRY lpLE;

        if (!bNewPage)
            tmp = (int)SendMessage (pMDI->hWndListbox, LB_GETCURSEL, 0, 0);
        else
            tmp = (int)SendMessage (pMDI->hWndListbox,
                                    LB_FINDSTRING,
                                    (WPARAM)-1,
                                    (LPARAM)(LPCSTR)KeepAs.ShareName);


        if (LB_ERR == tmp)
            goto done;

        SendMessage (pMDI->hWndListbox,
                     LB_GETTEXT,
                     tmp,
                     (LPARAM)&lpLE);

        StringCchCopy (KeepAs.ShareName, MAX_NDDESHARENAME +2, lpLE->name);

        KeepAs.bAlreadyShared = IsShared (lpLE);
        KeepAs.bAlreadyExist  = TRUE;

        fSharePreference = bNewPage? fSharePreference: KeepAs.bAlreadyShared;
        }


    // Set up NetDDE share for the page
    Size = 2048 * sizeof(TCHAR);
    lpDdeInfo = GlobalAllocPtr (GHND, Size);
    if (!lpDdeInfo)
       {
       MessageBoxID (hInst, hwnd, IDS_INTERNALERR, IDS_APPNAME, MB_OK|MB_ICONSTOP);
       goto done;
       }

    hCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));


    // Set up computer name with \\ in front

    rgtchCName[1] = rgtchCName[0] = TEXT('\\');
    dwLen = MAX_COMPUTERNAME_LENGTH+1;
    GetComputerName (rgtchCName + 2, &dwLen);


    lpEnd = (LPTSTR)lpDdeInfo + sizeof(NDDESHAREINFO);
    Size -= sizeof(NDDESHAREINFO);

    // Set up the constant members of the struct

    if (KeepAs.bAlreadyExist && KeepAs.bAlreadyShared)
        {
        DWORD   dwAddItem = 0;
        DWORD   dwTotal;

        ret = NDdeShareGetInfo (rgtchCName,
                                KeepAs.ShareName,
                                2,
                                (PUCHAR)lpDdeInfo,
                                2048 * sizeof (TCHAR),
                                &dwTotal,
                                (PUSHORT)&dwAddItem);
        }
    else
        {
        lpDdeInfo->lRevision        = 1L;
        lpDdeInfo->fSharedFlag      = 0;
        lpDdeInfo->fService         = 1; //0;
        lpDdeInfo->fStartAppFlag    = 0;
        lpDdeInfo->qModifyId[0]     = 0;
        lpDdeInfo->qModifyId[1]     = 0;
        lpDdeInfo->nCmdShow         = SW_SHOWMINNOACTIVE;
        lpDdeInfo->lShareType       = SHARE_TYPE_STATIC;
        }



    // Enter the share name... must be == $<PAGENAME>.
    lpDdeInfo->lpszShareName = lpEnd;

    #ifdef USETWOSHARESPERPAGE
        if (fSharePreference || KeepAs.bAlreadyShared)
            {
            *lpEnd = SHR_CHAR;
            }
        else
            {
            *lpEnd = UNSHR_CHAR;
            }
    #else
        *lpEnd = SHR_CHAR;
    #endif


    StringCchCopy(lpDdeInfo->lpszShareName + 1, Size, KeepAs.ShareName + 1);
    lpEnd += lstrlen(lpDdeInfo->lpszShareName) + 1;
    Size -= (lstrlen(lpDdeInfo->lpszShareName) + 1);

    // Start work on the app|topic list
    lpDdeInfo->lpszAppTopicList = lpEnd;

    // By default, there are no items.
    atchItem[0] = TEXT('\0');

    // Set up old-style and OLE name if cf_objectlink is
    // available, else set '\0'.
    if (OpenClipboard(hwnd))
        {
        unsigned cb;
        LPTSTR lpData;

        if ((hData = VGetClipboardData(NULL, cf_link)) &&
            (lpData = GlobalLock(hData)))
            {
            PINFO(TEXT("Link found\r\n"));
            StringCchCopy(lpEnd, Size, lpData);
            lpEnd += cb = lstrlen(lpEnd);
            *lpEnd++ = TEXT('|');
            Size -= (cb+1);
            StringCchCopy(lpEnd, Size, lpData + cb + 1);
            cb += lstrlen(lpEnd) + 2;
            Size -= (lstrlen(lpEnd) + 1);
            lpEnd += lstrlen(lpEnd) + 1;
            StringCchCopy(atchItem, 256, lpData + cb);
            GlobalUnlock(lpData);
            lpDdeInfo->lShareType |= SHARE_TYPE_OLD;
            }
        else
            {
            *lpEnd++ = TEXT('\0');
            Size--;
            }

        if ((hData = VGetClipboardData(NULL, cf_objectlink)) &&
            (lpData = GlobalLock(hData)))
            {
            PINFO(TEXT("ObjectLink found\r\n"));
            StringCchCopy(lpEnd, Size, lpData);
            lpEnd += cb = lstrlen(lpEnd);
            Size -= (cb+1);
            *lpEnd++ = TEXT('|');
            StringCchCopy(lpEnd, Size, lpData + cb + 1);
            cb += lstrlen(lpEnd) + 2;
            Size -= (lstrlen(lpEnd) + 1);
            lpEnd += lstrlen(lpEnd) + 1;
            StringCchCopy(atchItem, 256, lpData + cb);
            GlobalUnlock(lpData);
            lpDdeInfo->lShareType |= SHARE_TYPE_NEW;
            }
        else
            {
            *lpEnd++ = TEXT('\0');
            Size--;
            }

        CloseClipboard();
        }
    else // We couldn't open, we can't get objectlink.
       {
       *lpEnd++ = TEXT('\0');
       *lpEnd++ = TEXT('\0');
       Size -=2;
       }


    // Set up "CLIPSRV|*<pagename>" for a static app/topic
    // We use the *<pagename> form because when the page
    // is first created, it's ALWAYS unshared, and the server's
    // expecting us to be on the "unshared" topic name.
    // Unless the page already exists and is already shared.

    StringCchCopy(lpEnd, Size, SZ_SRV_NAME);
    StringCchCat (lpEnd, Size, TEXT(BAR_CHAR));
    Size -= (lstrlen(lpEnd)+1);
    lpEnd += lstrlen(lpEnd);

    if (KeepAs.bAlreadyShared)
        *lpEnd = SHR_CHAR;
    else
        *lpEnd = UNSHR_CHAR;


    StringCchCopy(lpEnd + 1, Size, KeepAs.ShareName + 1);
    Size -= (lstrlen(lpEnd) + 2);
    lpEnd += lstrlen(lpEnd) + 1;

    // NetDDE requires a fourth NULL at the end of the app/topic list
    *lpEnd++ = TEXT('\0');

    lpDdeInfo->lpszItemList = lpEnd;
    // If there's an item listed, we need to set the item.
    // Otherwise, set no items-- this is an OLE link to the entire
    // document. ANY item, but there's nothing but the static
    // share anyway.
    if (lstrlen(atchItem))
        {
        StringCchCopy(lpEnd, Size, atchItem);
        Size -= (lstrlen(lpEnd) + 1);
        lpEnd += lstrlen(lpEnd) + 1;
        lpDdeInfo->cNumItems = 1;
        #ifdef NOOLEITEMSPERMIT
            for (i = 0; i < NOLEITEMS; i++)
                {
                StringCchCopy(lpEnd, Size, OleShareItems[i]);
                Size -= (lstrlen(lpEnd) + 1);
                lpEnd += lstrlen(lpEnd) + 1;
                }
            lpDdeInfo->cNumItems = NOLEITEMS + 1;
        #endif
        }
    else
        {
        lpDdeInfo->cNumItems = 0;
        *lpEnd++ = TEXT('\0');
        }


    // Finish off item list with an extra null.
    *lpEnd++ = TEXT('\0');



    // Create the share

    if (!KeepAs.bAlreadyExist)
        {
        DumpDdeInfo(lpDdeInfo, rgtchCName);
        ret = NDdeShareAdd (rgtchCName, 2, NULL, (LPBYTE)lpDdeInfo, sizeof(NDDESHAREINFO) );

        PINFO(TEXT("NDdeShareAdd ret %ld\r\n"), ret);

        if (ret != NDDE_NO_ERROR && ret != NDDE_SHARE_ALREADY_EXIST)
            {
            if (NDDE_ACCESS_DENIED == ret)
                {
                MessageBoxID (hInst, hwnd, IDS_PRIVILEGEERROR, IDS_APPNAME, MB_OK|MB_ICONSTOP);
                }
            else
                {
                PERROR(TEXT("NDDE Error %d\r\n"), ret);
                NDdeMessageBox (hInst, hwnd, ret, IDS_APPNAME, MB_OK|MB_ICONSTOP);
                }
            goto done;
            }


        // Need to trust the share so that we can init through it!
        ret = NDdeSetTrustedShare (rgtchCName,
                                   lpDdeInfo->lpszShareName,
                                   NDDE_TRUST_SHARE_INIT);

        if (ret != NDDE_NO_ERROR)
            NDdeMessageBox (hInst, hwnd, ret, IDS_APPNAME, MB_OK|MB_ICONSTOP);

        }
    else
        {
        ret = NDdeShareSetInfo (rgtchCName,
                                lpDdeInfo->lpszShareName,
                                2,
                                (LPBYTE)lpDdeInfo,
                                sizeof(NDDESHAREINFO),
                                0);

        if (NDDE_NO_ERROR != ret)
            {
            NDdeMessageBox (hInst, hwnd, ret, IDS_APPNAME, MB_OK|MB_ICONSTOP);
            goto done;
            }
        }



    // Send DEExecute to tell clipsrv that we've created this page,
    // and will it please make an actual file for it?
    // NOTE must force all formats rendered to prevent deadlock
    // on the clipboard.
    ForceRenderAll (hwnd, NULL);

    StringCchCopy(szBuf, SZBUFSIZ, SZCMD_PASTE);
    StringCchCat (szBuf, SZBUFSIZ, KeepAs.ShareName);


    AssertConnection (hwndLocal);

    if (!MySyncXact ((LPBYTE)szBuf,
                     lstrlen(szBuf) +1,
                     pMDI->hExeConv,
                     0L,
                     CF_TEXT,
                     XTYP_EXECUTE,
                     LONG_SYNC_TIMEOUT,
                     NULL))
        {
        XactMessageBox (hInst, hwnd, IDS_APPNAME, MB_OK|MB_ICONSTOP);


        if (!KeepAs.bAlreadyExist)
            {
            // Problem creating the page so ask the server to delete it
            StringCchPrintf (szBuf, SZBUFSIZ, TEXT("%s%s"), SZCMD_DELETE, KeepAs.ShareName);
            MySyncXact (szBuf,
                        lstrlen (szBuf) +1,
                        pMDI->hExeConv,
                        0L,
                        CF_TEXT,
                        XTYP_EXECUTE,
                        SHORT_SYNC_TIMEOUT,
                        NULL);

            // and we'll delete the rest.
            NDdeSetTrustedShare (rgtchCName,
                                 lpDdeInfo->lpszShareName,
                                 NDDE_TRUST_SHARE_DEL);

            NDdeShareDel (rgtchCName,
                          lpDdeInfo->lpszShareName,
                          0);
            goto done;
            }
        }


    // Turn off redraw and add the new page to list.  Adding the new item
    // to list is necessary because the Properties() call below.  Turning
    // off the redraw is necessary because we sometimes get into a re-entrancy
    // problem.  When the list box is update, it is redrawn and if we're in
    // the preview mode, we get into the async xaction in the middle of some
    // sync xact.

    SendMessage (pMDI->hWndListbox, WM_SETREDRAW, FALSE, 0);

    if (!KeepAs.bAlreadyExist)
        {
        PLISTENTRY lpLE;

        // below code is copied from InitListBox()
        if (lpLE = (PLISTENTRY)GlobalAllocPtr (GHND, sizeof(LISTENTRY)))
            {
            lpLE->fDelete = TRUE;
            lpLE->fTriedGettingPreview = FALSE;
            StringCchCopy (lpLE->name, MAX_PAGENAME_LENGTH + 1, KeepAs.ShareName);
            SendMessage (pMDI->hWndListbox, LB_ADDSTRING, 0, (LPARAM)lpLE);
            }
        }


    if (fSharePreference != KeepAs.bAlreadyShared)
        {
        // get the item number
        tmp = (int)SendMessage (pMDI->hWndListbox,
                                LB_FINDSTRING,
                                (WPARAM)-1,
                                (LPARAM)(LPCSTR)KeepAs.ShareName);

        if (LB_ERR != tmp)
            {
            if (fSharePreference)
                {
                PLISTENTRY lpLE;

                SendMessage (pMDI->hWndListbox,
                             LB_GETTEXT,
                             tmp,
                             (LPARAM)&lpLE);
                Properties (hwnd, lpLE);
                }
            else
                OnIdmUnshare (tmp);
            }
        }


    // Now, turn on redraw.

    SendMessage (pMDI->hWndListbox, WM_SETREDRAW, TRUE, 0);


    // update the list box in all cases, the function
    // is smart enough to figure out which item has
    // changed and update only it.

    UpdateListBox (hwndLocal, pMDI->hExeConv);
    InvalidateRect (pMDI->hWndListbox, NULL, FALSE);



done:
    if (lpDdeInfo)
        GlobalFreePtr (lpDdeInfo);


    InitializeMenu (GetMenu (hwndApp));
    if (hCursor)
    {
        hCursor = SetCursor (hCursor);
    }

    fSharePreference = bShareSave;

    return 0L;
}




/*
 *      OnIDMCopy
 *
 *  Handles IDM_COPY to copy a page to clipbrd.
 */

LRESULT OnIDMCopy (
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam)
{
LPLISTENTRY lpLE;
PMDIINFO    pMDIc;
PDATAREQ    pDataReq;
TCHAR       tchTmp;
INT         tmp;
BOOL        fLocked;


    if (WAIT_TIMEOUT == WaitForSingleObject (hXacting, 0))
        return 0L;

    fLocked = LockApp (TRUE, NULL);


    // make a copy to ensure that the global is not
    // changed from under us in case proc is reentered

    if (!(pMDIc = GETMDIINFO(hwndActiveChild)))
        goto done;

    tmp = (int)SendMessage ( pMDIc->hWndListbox, LB_GETCURSEL, 0, 0L );

    if (tmp == LB_ERR)
        goto done;


    if (SendMessage (pMDIc->hWndListbox, LB_GETTEXT, tmp, (LPARAM)(LPCSTR)&lpLE)
        == LB_ERR )
        {
        PERROR(TEXT("IDM_COPY: bad listbox index: %d\n\r"), tmp );
        goto done;
        }

    if (!(pDataReq = CreateNewDataReq()))
        {
        PERROR(TEXT("error from CreateNewDataReq\n\r"));
        goto done;
        }

    if (pMDIc->hszClpTopic)
        {
        DdeFreeStringHandle (idInst, pMDIc->hszClpTopic);
        }


    tchTmp = lpLE->name[0];
    lpLE->name[0] = SHR_CHAR;
    pMDIc->hszClpTopic = DdeCreateStringHandle(idInst, lpLE->name, 0);


    // If we're local, trust the share so we can copy through it
    if (hwndActiveChild == hwndLocal)
       {
       DWORD adwTrust[3];

       NDdeGetTrustedShare(NULL, lpLE->name, adwTrust, adwTrust + 1,
            adwTrust + 2);
       adwTrust[0] |= NDDE_TRUST_SHARE_INIT;

       NDdeSetTrustedShare(NULL, lpLE->name, adwTrust[0]);
       }

    lpLE->name[0] = tchTmp;


    if ( !pMDIc->hszClpTopic )
       {
       MessageBoxID (hInst,
                     hwndActiveChild,
                     IDS_DATAUNAVAIL,
                     IDS_APPNAME,
                     MB_OK | MB_ICONEXCLAMATION );
       goto done;
       }



    if (pMDIc->hClpConv)
       {
       DdeDisconnect (pMDIc->hClpConv);
       pMDIc->hClpConv = NULL;
       }

    pMDIc->hClpConv = DdeConnect (idInst,
                                  pMDIc->hszConvPartner,
                                  pMDIc->hszClpTopic,
                                  NULL);


    if (!pMDIc->hClpConv)
       {
       PERROR(TEXT("DdeConnect to (%s) failed %d\n\r"),
              (LPSTR)(lpLE->name), DdeGetLastError(idInst) );

       MessageBoxID (hInst,
                     hwndActiveChild,
                     IDS_DATAUNAVAIL,
                     IDS_APPNAME,
                     MB_OK | MB_ICONEXCLAMATION);
       goto done;
       }

    pDataReq->rqType      = RQ_COPY;
    pDataReq->hwndList    = pMDIc->hWndListbox;
    pDataReq->iListbox    = tmp;
    pDataReq->hwndMDI     = hwndActiveChild;
    pDataReq->fDisconnect = FALSE;
    pDataReq->wFmt        = CF_TEXT;

    DdeSetUserHandle (pMDIc->hClpConv, (DWORD)QID_SYNC, (DWORD_PTR)pDataReq);
    DdeKeepStringHandle (idInst, hszFormatList);


    if (!DdeClientTransaction (NULL,
                               0L,
                               pMDIc->hClpConv,
                               hszFormatList,
                               CF_TEXT,
                               XTYP_REQUEST,
                               (DWORD)TIMEOUT_ASYNC,
                               NULL))
        DdeMessageBox (hInst,
                       hwndApp,
                       DdeGetLastError(idInst),
                       IDS_APPNAME,
                       MB_OK|MB_ICONEXCLAMATION);

done:
    if (fLocked)
        LockApp (FALSE, NULL);

    SetEvent (hXacting);

    return 0L;
}



/*
 *      CreateClipboardWindow
 *
 *  Purpose: Create and activate a window showing the contents of the
 *  clipboard.
 */

static void CreateClipboardWindow (void)
{
WINDOWPLACEMENT wpl;
HMENU           hSysMenu;
PMDIINFO        pMDI;


    // create Clipboard Window
    hwndClpbrd = NewWindow();
    if (NULL == hwndClpbrd)
        {
        return;
        }

    pMDI              = GETMDIINFO(hwndClpbrd);
    pMDI->flags       = F_CLPBRD;
    pMDI->DisplayMode = DSP_PAGE;

    AdjustControlSizes ( hwndClpbrd );
    ShowHideControls ( hwndClpbrd );

    StringCchCopy (pMDI->szBaseName,   (MAX_COMPUTERNAME_LENGTH+1)*2, szSysClpBrd);
    StringCchCopy (pMDI->szComputerName, MAX_COMPUTERNAME_LENGTH + 1, TEXT(""));

    SetWindowText ( hwndClpbrd, szSysClpBrd );

    // Grey out close item on sys menu
    hSysMenu = GetSystemMenu ( hwndClpbrd, FALSE );
    EnableMenuItem (hSysMenu, SC_CLOSE, MF_GRAYED | MF_BYCOMMAND);

    // Tell MDI where the Window menu is -- must do this BEFORE placing
    // the clipboard window. (If the clipboard window's maximized, its
    // System menu is the first menu-- not the app's File menu.)
    hSysMenu = GetSubMenu(GetMenu(hwndApp), WINDOW_MENU_INDEX);
    SendMessage(hwndMDIClient, WM_MDISETMENU, 0, (LPARAM)hSysMenu);

    if ( ReadWindowPlacement ( szSysClpBrd, &wpl ))
        {
        wpl.length = sizeof(WINDOWPLACEMENT);
        wpl.flags = WPF_SETMINPOSITION;
        SetWindowPlacement ( hwndClpbrd, &wpl );
        PINFO(TEXT("sizing %s from .ini\n\r"), (LPSTR)szSysClpBrd);
        UpdateWindow ( hwndClpbrd );
        }
    else
        {
        PINFO(TEXT("showing %s in default size/posiiton\n\r"),
            (LPSTR)szSysClpBrd );
        ShowWindow ( hwndClpbrd, SW_MINIMIZE );
        }

    SendMessage ( hwndMDIClient, WM_MDIACTIVATE, (WPARAM)hwndClpbrd, 0L );
}



/*
 *      CreateLocalWindow
 *
 *  Purpose: Create the "Local Clipbook" window.
 *  Parameters: None.
 *  Returns: Void.
 *
 */

static void CreateLocalWindow (void)
{
WINDOWPLACEMENT wpl;
HMENU           hSysMenu;
PMDIINFO        pMDI;


    hwndLocal = NewWindow();
    if (NULL == hwndLocal)
        {
        return;
        }

    pMDI = GETMDIINFO(hwndLocal);
    ShowHideControls (hwndLocal);

    pMDI->hszConvPartner   =
    pMDI->hszConvPartnerNP = hszDataSrv;
    pMDI->hExeConv         = InitSysConv (hwndLocal,
                                          pMDI->hszConvPartner,
                                          hszSystem,
                                          TRUE);

    if (!pMDI->hExeConv )
        goto error;

    pMDI->flags = F_LOCAL;

    if (!UpdateListBox ( hwndLocal, pMDI->hExeConv ))
        goto error;

    SetWindowText ( hwndLocal, szLocalClpBk );

    StringCchCopy (pMDI->szBaseName,   (MAX_COMPUTERNAME_LENGTH+1)*2, szLocalClpBk);
    StringCchCopy (pMDI->szComputerName, MAX_COMPUTERNAME_LENGTH + 1, TEXT(""));

    hSysMenu = GetSystemMenu ( hwndLocal, FALSE );
    EnableMenuItem ( hSysMenu, SC_CLOSE, MF_GRAYED );

    if ( ReadWindowPlacement ( szLocalClpBk, &wpl ))
        {
        wpl.length = sizeof(WINDOWPLACEMENT);
        wpl.flags = WPF_SETMINPOSITION;
        SetWindowPlacement ( hwndLocal, &wpl );
        PINFO(TEXT("sizing Local Clipbook from .ini\n\r"));
        UpdateWindow ( hwndLocal );
        }
    else
        {
        if ( !IsIconic(hwndApp))
            {
            RECT MDIrect;

            PINFO(TEXT("calculating size for Local Clipbook window\n\r"));
            GetClientRect ( hwndMDIClient, &MDIrect );
            MoveWindow ( hwndLocal,
                MDIrect.left, MDIrect.top, MDIrect.right - MDIrect.left,
                ( MDIrect.bottom - MDIrect.top )
                - GetSystemMetrics(SM_CYICONSPACING), FALSE );
            }
        else
            {
            fNeedToTileWindows = TRUE;
            }
        ShowWindow ( hwndLocal, SW_SHOWNORMAL );
        }

    SendMessage (hwndMDIClient, WM_MDIACTIVATE, (WPARAM)hwndLocal, 0L);
    SendMessage (hwndMDIClient, WM_MDIREFRESHMENU, 0, 0L);

    if (NULL != hkeyRoot)
        {
        DWORD dwDefView = IDM_LISTVIEW;
        DWORD dwSize = sizeof(dwDefView);

        if (ERROR_SUCCESS != RegQueryValueEx(hkeyRoot,
              (LPTSTR)szDefView, NULL, NULL, (LPBYTE)&dwDefView, &dwSize));
            {
            PINFO(TEXT("Couldn't get DefView value\r\n"));
            }

        SendMessage ( hwndApp, WM_COMMAND, dwDefView, 0L );
        }

    return;


error:
    #if DEBUG
        MessageBox (hwndApp,
                    TEXT("No Local Server"),
                    TEXT("ClipBook Initialization"),
                    MB_OK | MB_ICONEXCLAMATION );
    #endif

    fShareEnabled = FALSE;

    SendMessage (hwndLocal, WM_MDIDESTROY, 0, 0L);

    hwndLocal = NULL;

    return;
}




/*
 *      UnsharePage
 *
 *  Purpose: Unshare the selected page in the active window.
 *  Parameters: None.
 *  Returns: Void. All error handling is provided within the function.
 *
 */

void UnsharePage (void)
{
DWORD           adwTrust[3];
int             tmp;
LPLISTENTRY     lpLE;
DWORD           ret;
WORD            wAddlItems;
PNDDESHAREINFO  lpDdeI;
DWORD           dwRet = 2048 * sizeof(TCHAR);


    assert(pActiveMDI);

    if (!pActiveMDI);
        return;

    tmp = (int)SendMessage (pActiveMDI->hWndListbox, LB_GETCURSEL, 0, 0L);

    if ( tmp == LB_ERR )
        return;

    if (!(lpDdeI = LocalAlloc(LPTR, 2048 * sizeof(TCHAR))))
       {
       MessageBoxID (hInst, hwndApp, IDS_INTERNALERR, IDS_APPNAME, MB_OK | MB_ICONHAND);
       return;
       }

   SendMessage (  pActiveMDI->hWndListbox, LB_GETTEXT, tmp, (LPARAM)(LPCSTR)&lpLE);

   AssertConnection(hwndActiveChild);

   PINFO(TEXT("for share [%s]"), lpLE->name);
   wAddlItems = 0;
   ret = NDdeShareGetInfo ( NULL, lpLE->name, 2,
       (LPBYTE)lpDdeI, 2048 * sizeof(TCHAR), &dwRet, &wAddlItems );


    if (NDDE_ACCESS_DENIED == ret)
        {
        MessageBoxID (hInst, hwndApp, IDS_PRIVILEGEERROR, IDS_APPNAME,
                      MB_OK | MB_ICONHAND);
        }
    else if (NDDE_NO_ERROR != ret)
        {
        PERROR(TEXT("Error from NDdeShareSetInfo %d\n\r"), ret );
        NDdeMessageBox (hInst, hwndApp, ret,
                        IDS_SHAREDLGTITLE, MB_ICONHAND | MB_OK );
        }
    else
        {
        register LPTSTR lpOog;

        lpOog = lpDdeI->lpszAppTopicList;

        // Jump over the first two NULL chars you find-- these
        // are the old- and new-style app/topic pairs, we don't
        // mess with them. Then jump over the next BAR_CHAR you find.
        // The first character after that is the first char of the
        // static topic-- change that to a UNSHR_CHAR.

        while (*lpOog++) ;
        while (*lpOog++) ;

        while (*lpOog++ != TEXT('|')) ;

        *lpOog = UNSHR_CHAR;
        lpDdeI->fSharedFlag = 0L;

        DumpDdeInfo(lpDdeI, NULL);

        // We want to get trusted info BEFORE we start changing the share.
        NDdeGetTrustedShare(NULL, lpLE->name, adwTrust, adwTrust + 1, adwTrust + 2);

        ret = NDdeShareSetInfo ( NULL, lpLE->name, 2,
            (LPBYTE)lpDdeI, 2048 * sizeof(TCHAR), 0 );

        if (NDDE_NO_ERROR == ret)
            {

            // We've finished mucking with the share, now set trust info
            PINFO(TEXT("Setting trust info to 0x%lx\r\n"), adwTrust[0]);
            NDdeSetTrustedShare(NULL, lpLE->name, adwTrust[0]);

            ///////////////////////////////////////////////
            // do the execute to change the server state
            StringCchCopy(szBuf, SZBUFSIZ, SZCMD_UNSHARE);
            StringCchCat( szBuf, SZBUFSIZ, lpLE->name);
            PINFO(TEXT("sending cmd [%s]\n\r"), szBuf);

            if (MySyncXact ((LPBYTE)szBuf,
                            lstrlen(szBuf) +1,
                            GETMDIINFO(hwndLocal)->hExeConv,
                            0L,
                            CF_TEXT,
                            XTYP_EXECUTE,
                            SHORT_SYNC_TIMEOUT,
                            NULL))
                {
                SetShared(lpLE, FALSE);
                InitializeMenu(GetMenu(hwndApp));
                }
            else
                {
                XactMessageBox (hInst, hwndApp, IDS_APPNAME, MB_OK | MB_ICONSTOP);
                }
            }
        }
}




/*
 *      OnIdmUnshare
 *
 *
 *  Purpose: Set the currently selected page in the active MDI window
 *      to 'unshared'.
 *
 *  dwItem is the item number to unshare.  If == LB_ERR then the current
 *      selected item will be unshared.
 *
 *  Parameters: None.
 *
 *  Returns: 0L always, function handles its own errors.
 *
 */

LRESULT OnIdmUnshare (DWORD dwItem)
{
PNDDESHAREINFO lpDdeI;
PLISTENTRY     lpLE;
DWORD          adwTrust[3];
WORD           wAddlItems;
DWORD          ret;
DWORD          dwRet = 2048 * sizeof(TCHAR);
LPTSTR         lpOog;


    if (!pActiveMDI)
        return 0L;

    if (LB_ERR == dwItem)
        dwItem = (int)SendMessage (pActiveMDI->hWndListbox, LB_GETCURSEL, 0, 0L );

    if (LB_ERR == dwItem)
        {
        PERROR(TEXT("IDM_UNSHARE w/no page selected\r\n"));
        return 0L;
        }


    if (!(lpDdeI = LocalAlloc(LPTR, 2048 * sizeof(TCHAR))))
        {
        MessageBoxID (hInst, hwndApp, IDS_INTERNALERR, IDS_APPNAME,
                      MB_OK | MB_ICONHAND);
        return 0L;
        }

    SendMessage (pActiveMDI->hWndListbox,
                 LB_GETTEXT,
                 dwItem,
                 (LPARAM)(LPCSTR)&lpLE);

    AssertConnection(hwndActiveChild);


    PINFO(TEXT("for share [%s]"), lpLE->name);
    wAddlItems = 0;
    ret = NDdeShareGetInfo (NULL, lpLE->name,
                            2,
                            (LPBYTE)lpDdeI,
                            2048 * sizeof(TCHAR),
                            &dwRet,
                            &wAddlItems );


    if (NDDE_ACCESS_DENIED == ret)
        {
        MessageBoxID (hInst, hwndApp, IDS_PRIVILEGEERROR, IDS_APPNAME,
                      MB_OK | MB_ICONHAND);
        return 0L;
        }
    else if (ret != NDDE_NO_ERROR)
        {
        PERROR(TEXT("Error from NDdeShareSetInfo %d\n\r"), ret );
        NDdeMessageBox (hInst, hwndApp, ret,
                        IDS_SHAREDLGTITLE, MB_ICONHAND | MB_OK );
        return 0L;
        }


    lpOog = lpDdeI->lpszAppTopicList;


    // Jump over the first two NULL chars you find-- these
    // are the old- and new-style app/topic pairs, we don't
    // mess with them. Then jump over the next BAR_CHAR you find.
    // The first character after that is the first char of the
    // static topic-- change that to a SHR_CHAR.

    while (*lpOog++) ;
    while (*lpOog++) ;

    while (*lpOog++ != TEXT('|')) ;

    *lpOog = UNSHR_CHAR;
    lpDdeI->fSharedFlag = 1L;



    // Have to get trusted share settings before we modify
    // the share, because they'll be invalid.

    NDdeGetTrustedShare (NULL,
                         lpDdeI->lpszShareName,
                         adwTrust,
                         adwTrust + 1,
                         adwTrust + 2);


    DumpDdeInfo (lpDdeI, NULL);
    ret = NDdeShareSetInfo (NULL,
                            lpDdeI->lpszShareName,
                            2,
                            (LPBYTE)lpDdeI,
                            2048 * sizeof(TCHAR),
                            0);


    if (NDDE_ACCESS_DENIED == ret)
        {
        MessageBoxID (hInst, hwndApp, IDS_PRIVILEGEERROR, IDS_APPNAME,
                      MB_OK | MB_ICONHAND);
        return 0L;
        }
    else if (NDDE_NO_ERROR != ret)
        {
        NDdeMessageBox (hInst, hwndApp, ret, IDS_APPNAME,
                        MB_OK | MB_ICONHAND);
        PERROR(TEXT("Couldn't set share info\r\n"));
        return 0L;
        }


    // Setting trusted share info needs to be the last
    // operation we do on the share.
    if (NDDE_NO_ERROR != NDdeSetTrustedShare (NULL, lpDdeI->lpszShareName, adwTrust[0]))
        {
        PERROR(TEXT("Couldn't set trust status\r\n"));
        }

    ///////////////////////////////////////////////
    // do the execute to change the server state
    StringCchCopy(szBuf, SZBUFSIZ, SZCMD_UNSHARE);
    StringCchCat( szBuf, SZBUFSIZ, lpLE->name);
    PINFO(TEXT("sending cmd [%s]\n\r"), szBuf);

    if (MySyncXact ((LPBYTE)szBuf,
                    lstrlen(szBuf) +1,
                    GETMDIINFO(hwndLocal)->hExeConv,
                    0L,
                    CF_TEXT,
                    XTYP_EXECUTE,
                    SHORT_SYNC_TIMEOUT,
                    NULL))
        {

        InitializeMenu(GetMenu(hwndApp));
        }
    else
        {
        XactMessageBox (hInst, hwndApp, IDS_APPNAME, MB_OK | MB_ICONSTOP );
        }

    return(0L);
}



/*
 *      ClipBookCommand
 *
 * Purpose: Process menu commands for the Clipbook Viewer.
 *
 * Parameters: As wndproc.
 *
 * Returns: 0L, or DefWindowProc() if wParam isn't a WM_COMMAND id I
 *    know about.
 *
 */

LRESULT ClipBookCommand (
     HWND   hwnd,
     UINT   msg,
     WPARAM wParam,
     LPARAM lParam)
{
int             tmp;
UINT            wNewFormat;
UINT            wOldFormat;
LPLISTENTRY     lpLE;
BOOL            bRet;
DWORD           dwErr;


    switch (LOWORD(wParam))
        {
        case IDM_AUDITING:
            return(EditPermissions(TRUE));
            break;

        case IDM_OWNER:
            return EditOwner();
            break;

        case IDM_PERMISSIONS:
            {
            PLISTENTRY pLE;
            RECT       Rect;
            INT        i;

            i = (INT)EditPermissions(FALSE);


            // Permissions may have changed.  Get old data, they need
            //  to be updated.

            SendMessage (pActiveMDI->hWndListbox, LB_GETTEXT,     i, (LPARAM)&pLE);
            SendMessage (pActiveMDI->hWndListbox, LB_GETITEMRECT, i, (LPARAM)&Rect);


            // Delete the old bitmap.  If we are allowed to see it we'll
            //  get it when the list item is redrawn.

            DeleteObject (pLE->hbmp);
            pLE->fTriedGettingPreview = FALSE;
            pLE->hbmp = NULL;


            // Make it redraw.

            InvalidateRect (pActiveMDI->hWndListbox, &Rect, FALSE);
            }
            break;

        case IDC_TOOLBAR:
            MenuHelp( WM_COMMAND, wParam, lParam, GetMenu(hwnd), hInst,
                  hwndStatus, nIDs );
            break;

        case IDM_EXIT:
            SendMessage (hwnd, WM_CLOSE, 0, 0L);
            break;

        case IDM_TILEVERT:
        case IDM_TILEHORZ:
            SendMessage(hwndMDIClient, WM_MDITILE,
                wParam == IDM_TILEHORZ ? MDITILE_HORIZONTAL : MDITILE_VERTICAL,
                0L);
            break;

        case IDM_CASCADE:
            SendMessage (hwndMDIClient, WM_MDICASCADE, 0, 0L);
            break;

        case IDM_ARRANGEICONS:
            SendMessage (hwndMDIClient, WM_MDIICONARRANGE, 0, 0L);
            break;

        case IDM_COPY:
            szSaveFileName[0] = '\0';
            OnIDMCopy (hwnd, msg, wParam, lParam);
            break;

        case IDM_TOOLBAR:
            if ( fToolBar )
                {
                fToolBar = FALSE;
                ShowWindow ( hwndToolbar, SW_HIDE );
                AdjustMDIClientSize();
                }
            else
                {
                fToolBar = TRUE;
                AdjustMDIClientSize();
                ShowWindow ( hwndToolbar, SW_SHOW );
                }
            break;

        case IDM_STATUSBAR:

            if ( fStatus )
                {
                fStatus = FALSE;
                ShowWindow ( hwndStatus, SW_HIDE );
                AdjustMDIClientSize();
                }
            else
                {
                fStatus = TRUE;
                AdjustMDIClientSize();
                ShowWindow ( hwndStatus, SW_SHOW );
                }
            break;

        case ID_PAGEUP:
        case ID_PAGEDOWN:
            {
            HWND hwndc;
            PMDIINFO pMDIc;
            UINT iLstbox, iLstboxOld;

            // copy to make sure this value doesn't change when we yield
            hwndc = hwndActiveChild;

            if (!(pMDIc = GETMDIINFO(hwndc)))
                break;

            SetFocus ( hwndc );

            // make sure this is not clipboard window...
            if ( pMDIc->flags & F_CLPBRD )
                break;

            // must be in page view
            if ( pMDIc->DisplayMode != DSP_PAGE )
                break;

            iLstbox = (int)SendMessage ( pMDIc->hWndListbox,
                LB_GETCURSEL, 0, 0L );
            if ( iLstbox == LB_ERR )
                break;

            // page up on first entry?
            if ( iLstbox == 0 && wParam == ID_PAGEUP )
                {
                MessageBeep(0);
                break;
                }

            // page down on last entry?
            if ( (int)iLstbox == (int)SendMessage(pMDIc->hWndListbox,
                LB_GETCOUNT,0,0L) - 1 && wParam == (WPARAM)ID_PAGEDOWN )
                {
                MessageBeep(0);
                break;
                }

            // move selection up/down as appropriate
            iLstboxOld;
            if ( wParam == ID_PAGEDOWN )
                iLstbox++;
            else
                iLstbox--;

            SetListboxEntryToPageWindow ( hwndc, pMDIc, iLstbox );
            }
            break;

        case IDM_LISTVIEW:
        case IDM_PREVIEWS:
            {
            HWND    hwndtmp;
            int     OldSel;
            int     OldDisplayMode;
            TCHAR   szBuff[80];

            SetFocus (hwndActiveChild);

            if (!pActiveMDI)
                break;

            // make sure this is not clipboard window...
            if (pActiveMDI->flags & F_CLPBRD)
                break;

            // NOP?
            if (pActiveMDI->DisplayMode == DSP_PREV && wParam == IDM_PREVIEWS ||
                pActiveMDI->DisplayMode == DSP_LIST && wParam == IDM_LISTVIEW)
                break;

            OldDisplayMode = pActiveMDI->DisplayMode;

            // nuke vclipboard if there is one
            if ( pActiveMDI->pVClpbrd )
                {
                DestroyVClipboard( pActiveMDI->pVClpbrd );
                pActiveMDI->pVClpbrd = NULL;
                }


            // Save selection... (extra code to avoid strange lb div-by-zero)
            OldSel = (int)SendMessage( pActiveMDI->hWndListbox, LB_GETCURSEL, 0, 0L);
            SendMessage (pActiveMDI->hWndListbox, LB_SETCURSEL, (WPARAM)-1, 0L);
            UpdateNofMStatus (hwndActiveChild);
            SendMessage (pActiveMDI->hWndListbox, WM_SETREDRAW, 0, 0L);


            // set new display mode so listbox will get created right
            pActiveMDI->DisplayMode = (wParam == IDM_PREVIEWS)? DSP_PREV :DSP_LIST;


            // save handle to old listbox
            hwndtmp =  pActiveMDI->hWndListbox;


            // hide the old listbox - will soon destroy
            ShowWindow ( hwndtmp, SW_HIDE );


            // make new listbox and save handle in extra window data
            pActiveMDI->hWndListbox = CreateNewListBox (hwndActiveChild,
                                                        (pActiveMDI->DisplayMode == DSP_PREV)?
                                                         LBS_PREVIEW:
                                                         LBS_LISTVIEW);

            // loop, extracting items from one box and into other
            while (SendMessage (hwndtmp, LB_GETTEXT, 0, (LPARAM)(LPCSTR)&lpLE ) != LB_ERR)
                {
                // mark this item not to be deleted in WM_DELETEITEM
                lpLE->fDelete = FALSE;

                // remove from listbox
                SendMessage (hwndtmp, LB_DELETESTRING, 0, 0L);

                // reset fDelete flag
                lpLE->fDelete = TRUE;

                // add to new listbox
                SendMessage (pActiveMDI->hWndListbox, LB_ADDSTRING, 0, (LPARAM)(LPCSTR)lpLE);
                }



            // kill old (empty) listbox
            DestroyWindow ( hwndtmp );


            if ( pActiveMDI->flags & F_LOCAL )
                {
                SetWindowText ( hwndLocal, szLocalClpBk );
                StringCchCopy(szBuff, 80, szDefView);
                }
            else
                {
                StringCchPrintf(szBuff, 80, szClipBookOnFmt,(LPSTR)(pActiveMDI->szBaseName));
                SetWindowText ( hwndActiveChild, szBuff );
                StringCchCopy(szBuff, 80, pActiveMDI->szBaseName);
                StringCchCat(szBuff, 80, szConn);
                }

            if (NULL != hkeyRoot)
                {
                DWORD dwValue;

                dwValue = pActiveMDI->DisplayMode == DSP_LIST ? IDM_LISTVIEW :
                          pActiveMDI->DisplayMode == DSP_PREV ? IDM_PREVIEWS :
                          IDM_PAGEVIEW;

                RegSetValueEx (hkeyRoot, (LPTSTR)szBuff, 0L, REG_DWORD,
                               (LPBYTE)&dwValue, sizeof(DWORD));
                }


            // adjust size and show
            AdjustControlSizes( hwndActiveChild );
            ShowHideControls ( hwndActiveChild );

            // restore selection
            SendMessage( pActiveMDI->hWndListbox, LB_SETCURSEL, OldSel, 0L );
            UpdateNofMStatus ( hwndActiveChild );

            InitializeMenu ( GetMenu(hwndApp) );
            SetFocus ( pActiveMDI->hWndListbox );
            break;
            }

        case IDM_UPDATE_PAGEVIEW:
        case IDM_PAGEVIEW:
            {
            HWND hwndc;
            PMDIINFO pMDIc;

            // copy to make sure this value doesn't change when we yield
            hwndc = hwndActiveChild;

            if (!(pMDIc = GETMDIINFO(hwndc)))
                break;

            SetFocus (hwndc);


            // make sure this is not clipboard window...

            if (pMDIc->flags & F_CLPBRD)
                break;


            // if switch to page view

            if (IDM_PAGEVIEW == LOWORD(wParam))
                {
                // already in page view?
                if (pMDIc->DisplayMode == DSP_PAGE)
                    break;
                }
            else
                {
                // make sure we're not in an sync xaction, if so
                //  post a message and try again later.
                if (WAIT_TIMEOUT == WaitForSingleObject (hXacting, 0))
                    {
                    PostMessage (hwndApp, WM_COMMAND, IDM_UPDATE_PAGEVIEW, 0L);
                    break;
                    }

                // hXacting is now reset, set it so it can be used again
                SetEvent (hXacting);
                }


            tmp = (int)SendMessage (pMDIc->hWndListbox, LB_GETCURSEL, 0, 0L);
            if (tmp == LB_ERR)
                break;


            SetListboxEntryToPageWindow (hwndc, pMDIc, tmp);
            break;
            }

        case IDM_SHARE:
            if (!pActiveMDI)
                break;

            tmp = (int) SendMessage (pActiveMDI->hWndListbox,LB_GETCURSEL, 0, 0L);

            if ( tmp != LB_ERR )
                {
                SendMessage (pActiveMDI->hWndListbox, LB_GETTEXT, tmp, (LPARAM)&lpLE);

                // We create the NetDDE share when we create the page, not when we
                // share it. Thus, we're always 'editing the properties' of an existing
                // share, even if the user thinks that he's sharing the page NOW.
                Properties(hwnd, lpLE);

                // Redraw the listbox.
                if (pActiveMDI->DisplayMode == DSP_PREV)
                    {
                    InvalidateRect(pActiveMDI->hWndListbox, NULL, FALSE);
                    }
                else
                    {
                    SendMessage(pActiveMDI->hWndListbox,LB_SETCURSEL, tmp, 0L);
                    UpdateNofMStatus(hwndActiveChild);
                    }
                }
            break;

        case IDM_CLPWND:
            CreateClipboardWindow();
            break;

        case IDM_LOCAL:
            if (fNetDDEActive)
                CreateLocalWindow();
            break;

        case IDM_UNSHARE:
            bRet = (BOOL)OnIdmUnshare(LB_ERR);
            UpdateListBox (hwndActiveChild, pActiveMDI->hExeConv);
            return bRet;
            break;

        case IDM_DELETE:
            bRet = (BOOL)OnIDMDelete(hwnd, msg, wParam, lParam);
            return bRet;
            break;


        case IDM_PASTE_PAGE:
        case IDM_KEEP:
            bRet = (BOOL)OnIDMKeep (hwnd,
                                    msg,
                                    wParam,
                                    lParam,
                                    IDM_KEEP == LOWORD(wParam));
            return bRet;
            break;

        case IDM_SAVEAS:
            {
            OPENFILENAME ofn;
            CHAR         szFile[MAX_PATH+1];

            if (CountClipboardFormats())
                {
                szFile[0] = '\0';
                // Initialize the OPENFILENAME members
                ofn.lStructSize       = sizeof(OPENFILENAME);
                ofn.hwndOwner         = hwnd;
                ofn.lpstrFilter       = szFilter;
                ofn.lpstrCustomFilter = (LPTSTR) NULL;
                ofn.nMaxCustFilter    = 0L;
                ofn.nFilterIndex      = 1;
                ofn.lpstrFile         = (LPTSTR)szFile;
                ofn.nMaxFile          = sizeof(szFile);
                ofn.lpstrFileTitle    = NULL;
                ofn.nMaxFileTitle     = 0L;
                ofn.lpstrInitialDir   = szDirName;
                ofn.lpstrTitle        = (LPTSTR) NULL;
                ofn.lpstrDefExt       = "CLP";
                ofn.Flags             = OFN_HIDEREADONLY |
                                        OFN_NOREADONLYRETURN |
                                        OFN_OVERWRITEPROMPT;

                if (GetSaveFileName (&ofn) && szFile[0])
                    {
                    // NOTE must force all formats rendered!
                    ForceRenderAll (hwnd, NULL);

                    AssertConnection (hwndLocal);

                    // If user picked first filter ("NT Clipboard"), use save as..
                    // other filters would use save as old.
                    StringCchPrintf (szBuf, SZBUFSIZ, "%s%s",
                               (ofn.nFilterIndex == 1) ?
                                (LPSTR)SZCMD_SAVEAS :
                                (LPSTR)SZCMD_SAVEASOLD,
                               (LPSTR)szFile );

                    dwErr = SaveClipboardToFile (hwndApp, NULL, szFile, FALSE);
                    SysMessageBox (hInst, hwnd, dwErr, IDS_APPNAME, MB_OK|MB_ICONHAND);

                    }
                }
            break;
            }
        case IDM_OPEN:
            {
            OPENFILENAME ofn;
            TCHAR        szFile[MAX_PATH+1] = TEXT("*.clp");

            // Initialize the OPENFILENAME members
            ofn.lStructSize       = sizeof(OPENFILENAME);
            ofn.hwndOwner         = hwnd;
            ofn.lpstrFilter       = szFilter;
            ofn.lpstrCustomFilter = (LPTSTR) NULL;
            ofn.nMaxCustFilter    = 0L;
            ofn.nFilterIndex      = 1;
            ofn.lpstrFile         = (LPTSTR)szFile;
            ofn.nMaxFile          = sizeof(szFile);
            ofn.lpstrFileTitle    = NULL;
            ofn.nMaxFileTitle     = 0L;
            ofn.lpstrInitialDir   = szDirName;
            ofn.lpstrTitle        = (LPTSTR) NULL;
            ofn.Flags             = OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
            ofn.lpstrDefExt       = TEXT("CLP");

            if (GetOpenFileName (&ofn) && szFile[0])
                 {
                 // prompt for clearing clipboard
                 if (ClearClipboard(hwnd))
                    {
                    AssertConnection ( hwndLocal );

                    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%s%s"), (LPTSTR)SZCMD_OPEN, (LPTSTR)szFile);

                    dwErr = OpenClipboardFile (hwndApp, szFile);
                    SysMessageBox (hInst, hwnd, dwErr, IDS_APPNAME, MB_OK|MB_ICONHAND);

                    InitializeMenu (GetMenu(hwnd));
                    }
                 }
            break;
            }

        case IDM_DISCONNECT:

            if (!pActiveMDI)
                break;

            // don't allow close of local or clipboard window
            if (pActiveMDI->flags & (F_LOCAL | F_CLPBRD))
                break;
            SendMessage ( hwndActiveChild, WM_CLOSE, 0, 0L );
            break;

        case IDM_CONNECT:
            {
            WCHAR rgwch[MAX_COMPUTERNAME_LENGTH + 3];
            BOOL  bOK = FALSE;
            BOOL  fFoundLMDlg = FALSE;
            HMODULE hMod;
            LPFNSYSFOCUS lpfn;
            #ifndef UNICODE
              WCHAR rgwchHelp[64];
            #endif
            WCHAR szPath[MAX_PATH];
            UINT  uDirLen;

            *szConvPartner = '\0';
            rgwch[0] = L'\0';

            //  get windows\system32 directory : null terminated; doesnt have a
            //  trailing '\'; 0==api failed; need 14 tchars at the end for dllname
            uDirLen = GetSystemDirectoryW(szPath,MAX_PATH);
            if ( (uDirLen > 0) && (uDirLen < MAX_PATH-20) )
            {
               StringCchCatW(szPath, MAX_PATH, L"\\NTLANMAN.DLL");
               if (hMod = LoadLibraryW(szPath))
               {
                  if (lpfn = (LPFNSYSFOCUS)GetProcAddress(hMod, "I_SystemFocusDialog"))
                     {
                     #ifndef UNICODE
                       MultiByteToWideChar(CP_ACP, 0, szHelpFile, -1, rgwchHelp, 64);
                     #endif

                     fFoundLMDlg = TRUE;
                     (*lpfn)(hwnd,
                             FOCUSDLG_BROWSE_LOGON_DOMAIN |
                             FOCUSDLG_BROWSE_WKSTA_DOMAIN |
                             FOCUSDLG_BROWSE_OTHER_DOMAINS |
                             FOCUSDLG_BROWSE_TRUSTING_DOMAINS |
                             FOCUSDLG_BROWSE_WORKGROUP_DOMAINS |
                             FOCUSDLG_SERVERS_ONLY,
                             rgwch,
                             MAX_COMPUTERNAME_LENGTH + 3,
                             &bOK,
                             #ifndef UNICODE
                               rgwchHelp,
                             #else
                               szHelpFile,
                             #endif
                             IDH_SELECT_COMPUTER);

                     if (IDOK == bOK)
                        {
                        #ifndef UNICODE
                        WideCharToMultiByte(CP_ACP,
                            WC_COMPOSITECHECK | WC_DISCARDNS, rgwch,
                            -1, szConvPartner, MAX_COMPUTERNAME_LENGTH + 3, NULL, &bOK);
                        #else
                        lstrcpy(szConvPartner, rgwch);
                        #endif
                        }
                     else
                        {
                        szConvPartner[0] = TEXT('\0');
                        }
                     }
                  else
                     {
                     PERROR(TEXT("Couldn't find connect proc!\r\n"));
                     }
                  FreeLibrary(hMod);
                  }
               else
                  {
                  PERROR(TEXT("Couldn't find NTLANMAN.DLL\r\n"));
                  }
               }
            else
               {
               PERROR(TEXT("Couldn't get path to system32 directory\r\n"));
               }

            // If we didn't find the fancy LanMan dialog, we still can get by
            if (!fFoundLMDlg)
               {
               bOK = (BOOL)DialogBox(hInst, MAKEINTRESOURCE(IDD_CONNECT), hwnd,
                                     ConnectDlgProc);
               }

            if ( *szConvPartner )
               {
               CreateNewRemoteWindow ( szConvPartner, TRUE );
               }
            else
               {
                MessageBoxID (hInst,
                              hwnd,
                              IDS_NOCONNECTION,
                              IDS_APPNAME,
                              MB_OK | MB_ICONHAND);
               }
            UpdateWindow ( hwnd );
            break;
            }

        case IDM_REFRESH:

            if (!pActiveMDI)
                break;

            #if DEBUG
                {
                DWORD cbDBL = sizeof(DebugLevel);

                RegQueryValueEx(hkeyRoot, szDebug, NULL, NULL,
                    (LPBYTE)&DebugLevel, &cbDBL);
                }
            #endif
            if (pActiveMDI->flags & F_CLPBRD)
                break;

            AssertConnection ( hwndActiveChild );
            UpdateListBox ( hwndActiveChild, pActiveMDI->hExeConv );
            break;

        case IDM_CONTENTS:
            HtmlHelp(GetDesktopWindow(), szChmHelpFile, HH_DISPLAY_TOPIC, 0L);
            break;

        case IDM_ABOUT:
           {
           HMODULE hMod;
           LPFNSHELLABOUT lpfn;

           if (hMod = LoadLibrary(TEXT("SHELL32")))
              {
              if (lpfn = (LPFNSHELLABOUT)GetProcAddress(hMod,
                 #ifdef UNICODE
                   "ShellAboutW"
                 #else
                   "ShellAboutA"
                 #endif
                 ))
                 {
                 (*lpfn)(hwnd, szAppName, szNull,
                      LoadIcon(hInst, MAKEINTRESOURCE(IDFRAMEICON)));
                 }
              FreeLibrary(hMod);
              }
           else
              {
              PERROR(TEXT("Couldn't get SHELL32.DLL\r\n"));
              }
           }
           break;

        case CBM_AUTO:
        case CF_PALETTE:
        case CF_TEXT:
        case CF_BITMAP:
        case CF_METAFILEPICT:
        case CF_SYLK:
        case CF_DIF:
        case CF_TIFF:
        case CF_OEMTEXT:
        case CF_DIB:
        case CF_OWNERDISPLAY:
        case CF_DSPTEXT:
        case CF_DSPBITMAP:
        case CF_DSPMETAFILEPICT:
        case CF_PENDATA:
        case CF_RIFF:
        case CF_WAVE:
        case CF_ENHMETAFILE:
        case CF_UNICODETEXT:
        case CF_DSPENHMETAFILE:
        case CF_LOCALE:

            if (!pActiveMDI)
               break;

            if ( pActiveMDI->CurSelFormat != wParam)
                {
                CheckMenuItem (hDispMenu, pActiveMDI->CurSelFormat, MF_BYCOMMAND | MF_UNCHECKED);
                CheckMenuItem (hDispMenu, (UINT)wParam,                   MF_BYCOMMAND | MF_CHECKED);

                DrawMenuBar(hwnd);

                wOldFormat = GetBestFormat( hwndActiveChild, pActiveMDI->CurSelFormat);
                wNewFormat = GetBestFormat( hwndActiveChild, (UINT)wParam);

                if (wOldFormat == wNewFormat)
                    {
                    /* An equivalent format is selected; No change */
                    pActiveMDI->CurSelFormat = (UINT)wParam;
                    }
                else
                    {
                    /* A different format is selected; So, refresh... */

                    /* Change the character sizes based on new format. */
                    ChangeCharDimensions (hwndActiveChild, wOldFormat, wNewFormat);

                    pActiveMDI->fDisplayFormatChanged = TRUE;
                    pActiveMDI->CurSelFormat = (UINT)wParam;

                    // NOTE OwnerDisplay stuff applies only to the "real" clipboard!

                    if (wOldFormat == CF_OWNERDISPLAY)
                        {
                        /* Save the owner Display Scroll info */
                        SaveOwnerScrollInfo(hwndClpbrd);
                        ShowScrollBar ( hwndClpbrd, SB_BOTH, FALSE );
                        ShowHideControls(hwndClpbrd);
                        ResetScrollInfo( hwndActiveChild );
                        InvalidateRect ( hwndActiveChild, NULL, TRUE );
                        break;
                        }

                    if (wNewFormat == CF_OWNERDISPLAY)
                        {
                        /* Restore the owner display scroll info */
                        ShowHideControls(hwndClpbrd);
                        ShowWindow ( pActiveMDI->hwndSizeBox, SW_HIDE );
                        RestoreOwnerScrollInfo(hwndClpbrd);
                        InvalidateRect ( hwndActiveChild, NULL, TRUE );
                        break;
                        }

                    InvalidateRect  (hwndActiveChild, NULL, TRUE);
                    ResetScrollInfo (hwndActiveChild );
                    }
                }
            break;

        default:
            return DefFrameProc ( hwnd,hwndMDIClient,msg,wParam,lParam);
        }

    return 0;
}




/*
 *      SetListboxEntryToPageWindow
 */

BOOL SetListboxEntryToPageWindow(
    HWND        hwndc,
    PMDIINFO    pMDIc,
    int         lbindex)
{
HCONV       hConv;
LPLISTENTRY lpLE;
PVCLPBRD    pVClp;
PDATAREQ    pDataReq;
BOOL        fOK = FALSE;
TCHAR       tchTmp;
BOOL        fLocked;


    if (WAIT_TIMEOUT == WaitForSingleObject (hXacting, 0))
        return fOK;

    fLocked = LockApp (TRUE, NULL);

    if (LB_ERR == SendMessage (pMDIc->hWndListbox, LB_GETTEXT, lbindex, (LPARAM)(LPCSTR)&lpLE)
        || !lpLE
        || !(pDataReq = CreateNewDataReq()))
        {
        PERROR(TEXT("error from CreateNewDataReq\n\r"));
        goto done;
        }

    // make new clipboard
    if (!(pVClp = CreateVClipboard(hwndc)))
        {
        PERROR(TEXT("Failed to create Vclipboard\n\r"));
        goto done;
        }

    // nuke previous vclipboard if any
    if ( pMDIc->pVClpbrd )
        DestroyVClipboard( pMDIc->pVClpbrd );

    pMDIc->pVClpbrd = pVClp;

    // Set up $<page name> for topic
    if (pMDIc->hszClpTopic)
        DdeFreeStringHandle ( idInst, pMDIc->hszClpTopic );

    tchTmp = lpLE->name[0];
    lpLE->name[0] = SHR_CHAR;
    pMDIc->hszVClpTopic = DdeCreateStringHandle ( idInst, lpLE->name, 0 );
    lpLE->name[0] = tchTmp;

    if (!pMDIc->hszVClpTopic)
       {
       PERROR(TEXT("Couldn't make string handle for %s\r\n"), lpLE->name);
       goto done;
       }


    if (pMDIc->hVClpConv)
       {
       DdeDisconnect (pMDIc->hVClpConv);
       pMDIc->hVClpConv = NULL;
       }


    hConv = DdeConnect (idInst, pMDIc->hszConvPartner, pMDIc->hszVClpTopic, NULL);
    if (!hConv)
       {
       PERROR(TEXT("DdeConnect for Vclip failed: %x\n\r"), DdeGetLastError(idInst) );
       goto done;
       }

    pMDIc->hVClpConv = hConv;

    DdeKeepStringHandle (idInst, hszFormatList);

    pDataReq->rqType      = RQ_SETPAGE;
    pDataReq->hwndList    = pMDIc->hWndListbox;
    pDataReq->iListbox    = lbindex;
    pDataReq->hwndMDI     = hwndc;
    pDataReq->fDisconnect = FALSE;
    pDataReq->wFmt        = CF_TEXT;

    DdeSetUserHandle (hConv, (DWORD)QID_SYNC, (DWORD_PTR)pDataReq);

    if (!DdeClientTransaction (NULL,
                               0L,
                               hConv,
                               hszFormatList,
                               CF_TEXT,
                               XTYP_REQUEST,
                               (DWORD)TIMEOUT_ASYNC,
                               NULL ))
        DdeMessageBox (hInst,
                       pDataReq->hwndMDI,
                       DdeGetLastError (idInst),
                       IDS_APPNAME,
                       MB_OK|MB_ICONEXCLAMATION);

    fOK = TRUE;


done:
    if (!fOK)
        MessageBoxID ( hInst, hwndc, IDS_INTERNALERR, IDS_APPNAME, MB_OK | MB_ICONSTOP );

    if (fLocked)
        LockApp (FALSE, NULL);

    SetEvent (hXacting);

    return(fOK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\initmenu.h ===
/*****************************************************************************

                        I N I T M E N U   H E A D E R

    Name:       initmenu.h
    Date:       21-Jan-1994
    Creator:    John Fu

    Description:
        This is the header file for initmenu.c

*****************************************************************************/


VOID PASCAL InitializeMenu (
    HANDLE  hmenu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\helpids.h ===
#define IDH_ABOUT           10020
#define IDH_EXIT            10021
#define IDH_COPY            10022
#define IDH_DELETE          10023
#define IDH_DLG_SHARE       10024
#define IDH_OPEN            10027
#define IDH_SAVEAS          10028
#define IDH_SELECT_COMPUTER 10029
#define IDH_CONNECT         10030
#define IDH_DISCONNECT      10031
#define IDH_CONTENTS        10032
#define IDH_HELPSEARCH      10033
#define IDH_HELPHELP        10034
#define IDH_DLG_PASTEDATA   10035
#define IDH_STOPSHARE       10036
#define IDH_TOOLBAR         10037
#define IDH_STATUS_BAR      10038
#define IDH_TILEVERT        10039
#define IDH_CASCADE         10040
#define IDH_ARRANGEICONS    10041
#define IDH_REFRESH         10044
#define IDH_TABLE           10045
#define IDH_THUMBNAILS      10046
#define IDH_FULLPAGE        10047
#define IDH_TILEHORIZ       10048
#define IDH_PERMISSIONS     10049
#define IDH_AUDITING        10050
#define IDH_OWNER           10051
#define IDH_PASTE_PAGE      10052

#define IDH_STARTAPP        10203
#define IDH_MINIMIZED       10215
#define IDH_KEEPASEDIT      10301
#define IDH_SHARECHECKBOX   10304

#define IDH_DEFAULT         11024
#define IDH_TEXT            10401 //IDH_FORMATS_BASE + CF_TEXT
#define IDH_BITMAP          10402 //IDH_FORMATS_BASE + CF_BITMAP
#define IDH_METAFILEPICT    10403 //IDH_FORMATS_BASE + CF_METAFILEPICT
#define IDH_SYLK            10404 //IDH_FORMATS_BASE + CF_SYLK
#define IDH_DIF             10405 //IDH_FORMATS_BASE + CF_DIF
#define IDH_TIFF            10406 //IDH_FORMATS_BASE + CF_TIFF
#define IDH_OEMTEXT         10407 //IDH_FORMATS_BASE + CF_OEMTEXT
#define IDH_DIB             10408 //IDH_FORMATS_BASE + CF_DIB
#define IDH_PALETTE         10409 //IDH_FORMATS_BASE + CF_PALETTE
#define IDH_PENDATA         10410 //IDH_FORMATS_BASE + CF_PENDATA
#define IDH_RIFF            10411 //IDH_FORMATS_BASE + CF_RIFF
#define IDH_WAVE            10412 //IDH_FORMATS_BASE + CF_WAVE
#define IDH_OWNERDISPLAY    10528 //IDH_FORMATS_BASE + CF_OWNERDISPLAY
#define IDH_DSPTEXT         10529 //IDH_FORMATS_BASE + CF_DSPTEXT
#define IDH_DSPBITMAP       10530 //IDH_FORMATS_BASE + CF_DSPBITMAP
#define IDH_DSPMETAFILEPICT 10531 //IDH_FORMATS_BASE + CF_DSPMETAFILEPICT
#define IDH_ENHMETAFILE     10414 //IDH_FORMATS_BASE + CF_ENHMETAFILE
#define IDH_DSPENHMETAFILE  10542 //IDH_FORMATS_BASE + CF_DSPENHMETAFILE
#define IDH_UNICODETEXT     10413 //IDH_FORMATS_BASE + CF_UNICODETEXT
#define IDH_HDROP           10415 //IDH_FORMATS_BASE + CF_HDROP
#define IDH_LOCALE          10416 //IDH_FORMATS_BASE + CF_LOCALE

#define IDH_NAMESWIND       10502
#define IDH_SYSMENU         10503

#define IDH_PERMSDLG        10102
#define IDH_AUDITDLG        10103
#define IDH_ADD_USER_DLG    10105
#define IDH_ADD_MEM_LG_DLG  10106
#define IDH_ADD_MEM_GG_DLG  10107
#define IDH_FIND_ACCT_DLG   10108

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\dialogs.h ===
/*****************************************************************************

                        D I A L O G S   H E A D E R

    Name:       dialogs.h
    Date:       21-Jan-1994
    Creator:    John Fu

    Description:
        This is the header file for dialogs.c

*****************************************************************************/


INT_PTR CALLBACK ConnectDlgProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam);


INT_PTR CALLBACK ShareDlgProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam);


INT_PTR CALLBACK KeepAsDlgProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\ismember.c ===
/*****************************************************************************

                            I S M E M B E R

    Name:       ismember.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This file contains the function to check the user is a member
        of a given group.

    History:
        21-Jan-1994     John Fu, reformat and cleanup.

*****************************************************************************/


#include <windows.h>
#include "clipbook.h"
#include "ismember.h"
#include "security.h"
#include "debugout.h"




/*
 *      IsUserMember
 *
 *  Purpose: Determine if the current user is a member of the given group.
 *
 *  Parameters:
 *     psidGroup - Pointer to a SID describing the group.
 *
 *  Returns: TRUE if the user is a member of the group, FALSE
 *     otherwise
 */


BOOL IsUserMember(
    PSID    psidGroup)
{
TOKEN_GROUPS    *ptokgrp;
HANDLE          hToken=NULL;
BOOL            fRet = FALSE;
DWORD           dwInfoSize;
unsigned        i;



    PINFO(TEXT("IsMember of ? "));
    PrintSid(psidGroup);

    if (!GetTokenHandle(&hToken))
        {
        PERROR(TEXT("IsUserMember: Couldn't get token handle\r\n"));
        return FALSE;
        }


    GetTokenInformation(hToken, TokenGroups, NULL, 0, &dwInfoSize);

    if (ptokgrp = LocalAlloc(LPTR, dwInfoSize))
        {
        if (GetTokenInformation(hToken, TokenGroups, ptokgrp,
                 dwInfoSize, &dwInfoSize))
            {
            for (i = 0;i < ptokgrp->GroupCount;i++)
                {
                PrintSid(ptokgrp->Groups[i].Sid);

                if (EqualSid(ptokgrp->Groups[i].Sid, psidGroup))
                    {
                    PINFO(TEXT("YES"));
                    fRet = TRUE;
                    break;
                    }
                }
            }
        LocalFree(ptokgrp);
        }


    if (!fRet)
        {
        TOKEN_USER *ptokusr;

        GetTokenInformation(hToken, TokenUser, NULL, 0, &dwInfoSize);

        if (ptokusr = LocalAlloc(LPTR, dwInfoSize))
            {
            if (GetTokenInformation(hToken, TokenUser, ptokusr,
                  dwInfoSize, &dwInfoSize))
                {
                if (EqualSid(ptokusr->User.Sid, psidGroup))
                    {
                    PINFO(TEXT("YES"));
                    fRet = TRUE;
                    }
                }
            LocalFree(ptokusr);
            }
        }

    if (hToken)
        CloseHandle(hToken);

    PINFO(TEXT("\r\n"));

    return fRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\dialogs.c ===
/*****************************************************************************

                                D I A L O G S

    Name:       dialogs.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        Dialog handling routines.

*****************************************************************************/

#include <windows.h>
#include <nddeapi.h>
#include <strsafe.h>

#include "common.h"
#include "clipbook.h"
#include "clipbrd.h"
#include "clpbkdlg.h"
#include "cvutil.h"
#include "dialogs.h"
#include "helpids.h"
#include "debugout.h"
#include "ismember.h"
#include "shares.h"


/*
 *      ConnectDlgProc
 */

INT_PTR CALLBACK ConnectDlgProc (
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{

    switch (message)
        {
        case WM_INITDIALOG:
            szConvPartner[0] = '\0';
            break;

        case WM_COMMAND:
            switch (wParam)
                {
                case IDOK:
                    GetDlgItemText (hwnd, IDC_CONNECTNAME, szConvPartner, 32);
                    EndDialog (hwnd, 1);
                    break;

                case IDCANCEL:
                    szConvPartner[0] = '\0';
                    EndDialog (hwnd, 0);
                    break;

                default:
                    return FALSE;
                }
            break;

        default:
            return FALSE;
        }

    return TRUE;

}




/*
 *      ShareDlgProc
 *
 *  Note: this routine expectes a PNDDESHAREINFO in lParam!
 */

INT_PTR CALLBACK ShareDlgProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{

static PNDDESHAREINFO   lpDdeS;
DWORD                   dwTrustOptions;
DWORD                   adwTrust[3];
BOOL                    bRet = TRUE;

// These vars are used for determining if I'm owner of the page
PSID                    psidPage;
BOOL                    fDump;
DWORD                   cbSD;
UINT                    uRet;
PSECURITY_DESCRIPTOR    pSD = NULL;

LPHELPINFO              lphi;

const DWORD aHelpIDs[] =
{
    IDC_STARTAPP, IDH_STARTAPP,
    IDC_MINIMIZED, IDH_MINIMIZED,
    IDC_PERMISSIONS, IDH_PERMISSIONS,
    0, 0
};

UINT    iCtrlId;


    switch (message)
        {
        case WM_INITDIALOG:

            lpDdeS = (PNDDESHAREINFO)lParam;

            // set share, always static
            SetDlgItemText (hwnd, IDC_STATICSHARENAME, lpDdeS->lpszShareName+1 );

            // If the current user doesn't own the page, we gray out the
            // "start app" and "run minimized" checkboxes
            EnableWindow(GetDlgItem(hwnd, IDC_STARTAPP), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_MINIMIZED), FALSE);
            EnableWindow(GetDlgItem(hwnd, 207), FALSE);



            // Figure out who owns the page
            psidPage = NULL;
            if (!(pSD = LocalAlloc(LPTR, 50)))
                {
                PERROR(TEXT("Couldn't alloc 50 bytes\r\n"));
                break;
                }


            uRet = NDdeGetShareSecurity (NULL,
                                         lpDdeS->lpszShareName,
                                         OWNER_SECURITY_INFORMATION,
                                         pSD,
                                         50,
                                         &cbSD);

            if (uRet == NDDE_BUF_TOO_SMALL)
                {
                LocalFree (pSD);

                if (!(pSD = LocalAlloc(LPTR, cbSD)))
                   {
                   PERROR(TEXT("Couldn't alloc %ld bytes\r\n"), cbSD);
                   break;
                   }


                uRet = NDdeGetShareSecurity (NULL,
                                             lpDdeS->lpszShareName,
                                             OWNER_SECURITY_INFORMATION,
                                             pSD,
                                             cbSD,
                                             &cbSD);
                }


            if (NDDE_NO_ERROR != uRet)
                {
                PERROR(TEXT("GetSec fail %d"), uRet);
                break;
                }


            if (!GetSecurityDescriptorOwner(pSD, &psidPage, &fDump))
                {
                PERROR(TEXT("Couldn't get owner, even tho we asked\r\n"));
                break;
                }

            if (!psidPage || !IsUserMember(psidPage))
                {
                PINFO(TEXT("User isn't member of owner\r\n"));
                break;
                }



            EnableWindow (GetDlgItem (hwnd, IDC_STARTAPP), TRUE);

            // 207 is the group box around the checkboxes
            EnableWindow (GetDlgItem (hwnd, 207), TRUE);

            NDdeGetTrustedShare (NULL,
                                 lpDdeS->lpszShareName,
                                 adwTrust,
                                 adwTrust + 1,
                                 adwTrust + 2);

            if (!(adwTrust[0] & NDDE_TRUST_SHARE_START))
                {
                PINFO (TEXT("Buttons shouldn't check\r\n"));
                }
            else
                {
                CheckDlgButton(hwnd, IDC_STARTAPP, 1);

                EnableWindow (GetDlgItem (hwnd, IDC_MINIMIZED), TRUE);
                CheckDlgButton (hwnd,
                                IDC_MINIMIZED,
                                (SW_MINIMIZE == (adwTrust[0] & NDDE_CMD_SHOW_MASK)) ? 1 : 0);
               }

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
                case IDOK:
                   dwTrustOptions = NDDE_TRUST_SHARE_INIT;

                   if (IsDlgButtonChecked(hwnd, IDC_STARTAPP))
                      {
                      dwTrustOptions |= NDDE_TRUST_SHARE_START;

                      if (IsDlgButtonChecked(hwnd, IDC_MINIMIZED))
                         {
                         dwTrustOptions |= NDDE_TRUST_CMD_SHOW | SW_MINIMIZE;
                         }
                      }

                   // Update the share start flag.
                   if (dwTrustOptions & NDDE_TRUST_SHARE_START)
                       lpDdeS->fStartAppFlag = TRUE;
                   else
                       lpDdeS->fStartAppFlag = FALSE;

                   NDdeSetTrustedShare(NULL, lpDdeS->lpszShareName, dwTrustOptions);
                   EndDialog (hwnd, TRUE);
                   break;

                case IDCANCEL:
                   EndDialog (hwnd, FALSE);
                   break;

                case IDC_PERMISSIONS:
                   EditPermissions2 (hwnd, lpDdeS->lpszShareName, FALSE);
                   break;

                case  IDC_STARTAPP:
                   EnableWindow(GetDlgItem(hwnd, IDC_MINIMIZED),
                         IsDlgButtonChecked(hwnd, IDC_STARTAPP));
                   break;

                default:
                   bRet = FALSE;
                }
            break;

        case WM_HELP:
            lphi = (LPHELPINFO) lParam;
            if (lphi->iContextType == HELPINFO_WINDOW)
            {
                if ((lphi->iCtrlId == IDC_STARTAPP) ||
                    (lphi->iCtrlId == IDC_MINIMIZED) ||
                    (lphi->iCtrlId == IDC_PERMISSIONS) ||
                    (lphi->iCtrlId == IDOK) ||
                    (lphi->iCtrlId == IDCANCEL) )
                {
                WinHelp ( lphi->hItemHandle,
                          szHelpFile,
                          HELP_WM_HELP,
                          (DWORD_PTR) (LPVOID) aHelpIDs);
                }
            }
            else
            {
                bRet = FALSE;
            }
            break;

        case WM_CONTEXTMENU:
            iCtrlId = GetDlgCtrlID( (HWND) wParam );
            if ((iCtrlId == IDC_STATICSHARENAME) ||
                (iCtrlId == IDC_STARTAPP) ||
                (iCtrlId == IDC_MINIMIZED) ||
                (iCtrlId == IDC_PERMISSIONS) ||
                (iCtrlId == IDOK) ||
                (iCtrlId == IDCANCEL) )
            {
                WinHelp( (HWND) wParam,
                         szHelpFile,
                         HELP_CONTEXTMENU,
                         (DWORD_PTR) (LPVOID) aHelpIDs);
            }
            break;
        //

        default:
        bRet = FALSE;
        }



    if (pSD)
        LocalFree (pSD);

    return bRet;

}





/*
 *      IsUniqueName
 *
 *  Check to see if the name is unique
 */

static BOOL IsUniqueName (PKEEPASDLG_PARAM pParam)
{
PMDIINFO    pMDI;
LISTENTRY   ListEntry;
PLISTENTRY  pLE;
INT         i;


    if (!(pMDI = GETMDIINFO(hwndLocal)))
        return FALSE;


    StringCchCopy (ListEntry.name, MAX_PAGENAME_LENGTH + 1, pParam->ShareName);

    i = (INT)SendMessage (pMDI->hWndListbox,
                          LB_FINDSTRING,
                          (WPARAM)-1,
                          (LPARAM)(LPCSTR) &ListEntry);


    if (LB_ERR != i)
        {
        SendMessage (pMDI->hWndListbox,
                     LB_GETTEXT,
                     i,
                     (LPARAM)&pLE);

        pParam->bAlreadyShared = IsShared (pLE);

        return FALSE;
        }

    return TRUE;

}




/*
 *      KeepAsDlgProc
 *
 *  Ask the user for a page name.
 */

INT_PTR CALLBACK KeepAsDlgProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam)
{
static PKEEPASDLG_PARAM pParam;

LPHELPINFO              lphi;
const DWORD aHelpIDs[] =
{
    IDC_STATICPAGENAME, IDH_KEEPASEDIT,
    IDC_KEEPASEDIT, IDH_KEEPASEDIT,
    IDC_SHARECHECKBOX, IDH_SHARECHECKBOX,
    0, 0
};



    switch (msg)
        {
        case WM_INITDIALOG:
            pParam = (PKEEPASDLG_PARAM)lParam;

            pParam->bAlreadyExist  = FALSE;
            pParam->bAlreadyShared = FALSE;
            pParam->ShareName[0]   = '\0';

            SendDlgItemMessage (hwnd, IDC_KEEPASEDIT, EM_LIMITTEXT, MAX_NDDESHARENAME - 15, 0L);
            SendDlgItemMessage (hwnd, IDC_SHARECHECKBOX, BM_SETCHECK, fSharePreference, 0L);
            break;

        case WM_COMMAND:
            switch (wParam)
                {
                case IDOK:
                    fSharePreference = (BOOL)SendDlgItemMessage (hwnd,
                                                                 IDC_SHARECHECKBOX,
                                                                 BM_GETCHECK,
                                                                 0,
                                                                 0L );

                    if (!GetDlgItemText(hwnd, IDC_KEEPASEDIT, pParam->ShareName+1, MAX_PAGENAME_LENGTH))
                        {
                        SetFocus (GetDlgItem (hwnd, IDC_KEEPASEDIT));
                        break;
                        }

                    pParam->ShareName[0] = SHR_CHAR;

                    if (!NDdeIsValidShareName(pParam->ShareName + 1))
                        {
                        MessageBoxID (hInst,
                                      hwnd,
                                      IDS_PAGENAMESYNTAX,
                                      IDS_PASTEDLGTITLE,
                                      MB_OK|MB_ICONEXCLAMATION);
                        break;
                        }

                    pParam->ShareName[0] = UNSHR_CHAR;

                    // make sure name is unique
                    if ( !IsUniqueName (pParam))
                        {
                        if (IDOK != MessageBoxID (hInst,
                                                 hwnd,
                                                 IDS_NAMEEXISTS,
                                                 IDS_PASTEDLGTITLE,
                                                 MB_OKCANCEL|MB_ICONEXCLAMATION))
                             break;

                        pParam->bAlreadyExist = TRUE;

                        }

                    EndDialog( hwnd, TRUE );
                    break;

                case IDCANCEL:
                     EndDialog( hwnd, FALSE );
                     break;

                default:
                     return FALSE;
                }
            break;

        case WM_HELP:
            lphi = (LPHELPINFO) lParam;
            if (lphi->iContextType == HELPINFO_WINDOW)
            {
                WinHelp ( lphi->hItemHandle,
                          szHelpFile,
                          HELP_WM_HELP,
                          (DWORD_PTR) (LPVOID) aHelpIDs);
            }
            else
            {
                return FALSE;
            }
            break;

        case WM_CONTEXTMENU:
            WinHelp( (HWND) wParam,
                     szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR) (LPVOID) aHelpIDs);
            break;


        default:
            return FALSE;
        }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\ismember.h ===
/*****************************************************************************

                        I S M E M B E R   H E A D E R

    Name:       ismember.h
    Date:       21-Jan-1994
    Creator:    John Fu

    Description:
        This is the header file for ismember.c

*****************************************************************************/


BOOL IsUserMember(
    PSID    psidGroup);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\initmenu.c ===
/*****************************************************************************

                        I N I T M E N U

    Name:       initmenu.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This file contains the function to initialize the menus.

    History:
        21-Jan-1994     John Fu, reformat and cleanup.
        13-Mar-1995     John Fu, add Paste to Page

*****************************************************************************/



#define	WIN31
#define STRICT

#include <windows.h>
#include <windowsx.h>
#include <assert.h>
#include <memory.h>

#include "common.h"
#include "clipbook.h"
#include "clipbrd.h"
#include "clipdsp.h"
#include "commctrl.h"
#include "cvinit.h"
#include "cvutil.h"
#include "initmenu.h"










/*
 *      InitializeMenu
 *
 *  this function controls the enabled/grayed state of
 *  the menu items and the state of the toolbar buttons.
 *  It is called when the selection within a listbox changes,
 *  or the focus changes from one MDI child window to another.
 */

VOID PASCAL InitializeMenu (
    HANDLE  hmenu)
{
LPLISTENTRY     lpLE = NULL;
int             index;
int             fMenu;
int             fButton;
DWORD           flags;



    assert(NULL != pActiveMDI);

    hmenu = GetMenu(hwndApp);

    flags = pActiveMDI->flags;


    if (flags & F_CLPBRD)
        {
        index = LB_ERR;
        }
    else if (pActiveMDI->hWndListbox)
        {
        index = (int)SendMessage (pActiveMDI->hWndListbox, LB_GETCURSEL, 0, 0L);

        if ( index != LB_ERR )
            {
            SendMessage (pActiveMDI->hWndListbox, LB_GETTEXT, index, (LPARAM)(LPCSTR)&lpLE);
            }
       }
    else
        index = LB_ERR;



    EnableMenuItem (hmenu,
                    IDM_OPEN,
                    (flags & F_CLPBRD ? MF_ENABLED : MF_GRAYED)| MF_BYCOMMAND);

    EnableMenuItem (hmenu,
                    IDM_SAVEAS,
                    (CountClipboardFormats() && flags & (F_CLPBRD|F_LOCAL)?
                     MF_ENABLED :
                     MF_GRAYED)
                    | MF_BYCOMMAND );


    if ( fShareEnabled )
        {
        // SHARE allowed?
        if ( (flags & F_LOCAL) && (index != LB_ERR) )
            {
            fMenu = MF_ENABLED;
            fButton = TRUE;
            }
        else
            {
            fMenu = MF_GRAYED;
            fButton = FALSE;
            }
        EnableMenuItem (hmenu, IDM_SHARE, fMenu | MF_BYCOMMAND );
        SendMessage ( hwndToolbar, TB_ENABLEBUTTON, IDM_SHARE, fButton );

        // UNSHARE allowed?
        if ( (flags & F_LOCAL) && (index != LB_ERR) &&  IsShared(lpLE) )
            {
            fMenu = MF_ENABLED;
            fButton = TRUE;
            }
        else
            {
            fMenu = MF_GRAYED;
            fButton = FALSE;
            }
        EnableMenuItem (hmenu, IDM_UNSHARE, fMenu | MF_BYCOMMAND);
        SendMessage ( hwndToolbar, TB_ENABLEBUTTON, IDM_UNSHARE, fButton );
        }





    if ( fNetDDEActive )
        {
        // DISCONNECT allowed?
        EnableMenuItem (hmenu, IDM_DISCONNECT,
           (flags & ( F_LOCAL | F_CLPBRD ) ? MF_GRAYED : MF_ENABLED) | MF_BYCOMMAND );
        SendMessage ( hwndToolbar, TB_ENABLEBUTTON, IDM_DISCONNECT,
           flags & ( F_LOCAL | F_CLPBRD ) ? FALSE : TRUE );
        }
    else // If netdde isn't active, we can't connect
        {
        EnableMenuItem(hmenu, IDM_CONNECT, MF_GRAYED | MF_BYCOMMAND);
        EnableMenuItem(hmenu, IDM_DISCONNECT, MF_GRAYED | MF_BYCOMMAND);
        SendMessage(hwndToolbar, TB_ENABLEBUTTON, IDM_CONNECT, FALSE);
        SendMessage(hwndToolbar, TB_ENABLEBUTTON, IDM_DISCONNECT, FALSE);
        }



    // Delete allowed?
    if ( ( flags & F_LOCAL && index != LB_ERR ) ||
        flags & F_CLPBRD && CountClipboardFormats() )
        {
        fMenu = MF_ENABLED;
        fButton = TRUE;
        }
    else
        {
        fMenu = MF_GRAYED;
        fButton = FALSE;
        }

    EnableMenuItem (hmenu, IDM_DELETE, fMenu | MF_BYCOMMAND);
    SendMessage ( hwndToolbar, TB_ENABLEBUTTON, IDM_DELETE, fButton );



    // a page selected?
    if ( index != LB_ERR  )
        {
        fMenu = MF_ENABLED;
        fButton = TRUE;
        }
    else
        {
        fMenu = MF_GRAYED;
        fButton = FALSE;
        }

    EnableMenuItem (hmenu, IDM_COPY, fMenu | MF_BYCOMMAND);
    SendMessage ( hwndToolbar, TB_ENABLEBUTTON, IDM_COPY, fButton );



    // Paste Allowed?
    if (CountClipboardFormats() && hwndActiveChild == hwndLocal && !(flags & F_CLPBRD))
        {
        fMenu = MF_ENABLED;
        fButton = TRUE;
        }
    else
        {
        fMenu = MF_GRAYED;
        fButton = FALSE;
        }


    EnableMenuItem (hmenu, IDM_KEEP, fMenu | MF_BYCOMMAND);
    SendMessage (hwndToolbar, TB_ENABLEBUTTON, IDM_KEEP, fButton );


    // if a page is selected
    if (LB_ERR != index)
        EnableMenuItem (hmenu, IDM_PASTE_PAGE, fMenu|MF_BYCOMMAND);
    else
        EnableMenuItem (hmenu, IDM_PASTE_PAGE, MF_GRAYED|MF_BYCOMMAND);








    // TOOLBAR, STATUS BAR
    CheckMenuItem ( hmenu, IDM_TOOLBAR, fToolBar ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem ( hmenu, IDM_STATUSBAR, fStatus ? MF_CHECKED:MF_UNCHECKED );




    // disable some view options if clipboard window

    EnableMenuItem (hmenu,
                    IDM_LISTVIEW,
                    (flags & F_CLPBRD ? MF_GRAYED : MF_ENABLED) | MF_BYCOMMAND );

    EnableMenuItem (hmenu,
                    IDM_PREVIEWS,
                    (flags & F_CLPBRD ? MF_GRAYED : MF_ENABLED) | MF_BYCOMMAND );
    EnableMenuItem (hmenu,
                    IDM_PAGEVIEW,
                    ((flags & F_CLPBRD) || index != LB_ERR ? MF_ENABLED : MF_GRAYED) | MF_BYCOMMAND);

    SendMessage (hwndToolbar,
                 TB_ENABLEBUTTON,
                 IDM_LISTVIEW,
                 flags & F_CLPBRD ? FALSE : TRUE);

    SendMessage (hwndToolbar,
                 TB_ENABLEBUTTON,
                 IDM_PREVIEWS,
                 flags & F_CLPBRD ? FALSE : TRUE);

    SendMessage (hwndToolbar,
                 TB_ENABLEBUTTON,
                 IDM_PAGEVIEW,
                 (( flags & F_CLPBRD ) || index != LB_ERR ) ? TRUE : FALSE );



    // Disable "Security" menu for other than Local Clipbook window
    // or if there's no item selected in the clipbook window
    fMenu = MF_GRAYED | MF_BYCOMMAND;
    if ((flags & F_LOCAL) && LB_ERR != index)
        {
        fMenu = MF_ENABLED | MF_BYCOMMAND;
        }

    EnableMenuItem (hmenu, IDM_PERMISSIONS, fMenu);
    EnableMenuItem (hmenu, IDM_OWNER, fMenu);
    EnableMenuItem (hmenu, IDM_AUDITING, fAuditEnabled ? fMenu : MF_GRAYED | MF_BYCOMMAND);



    // check selected view...

    CheckMenuItem (hmenu,
                   IDM_LISTVIEW,
                   pActiveMDI->DisplayMode == DSP_LIST ? MF_CHECKED : MF_UNCHECKED );

    CheckMenuItem (hmenu,
                   IDM_PREVIEWS,
                   pActiveMDI->DisplayMode == DSP_PREV ? MF_CHECKED : MF_UNCHECKED );
    CheckMenuItem (hmenu,
                   IDM_PAGEVIEW,
                   pActiveMDI->DisplayMode == DSP_PAGE ? MF_CHECKED : MF_UNCHECKED );

    SendMessage (hwndToolbar,
                 TB_CHECKBUTTON,
                 IDM_LISTVIEW,
                 pActiveMDI->DisplayMode == DSP_LIST ? TRUE : FALSE );

    SendMessage (hwndToolbar,
                 TB_CHECKBUTTON,
                 IDM_PREVIEWS,
                 pActiveMDI->DisplayMode == DSP_PREV ? TRUE : FALSE );

    SendMessage (hwndToolbar,
                 TB_CHECKBUTTON,
                 IDM_PAGEVIEW,
                 pActiveMDI->DisplayMode == DSP_PAGE ? TRUE : FALSE );




    DrawMenuBar(hwndApp);


    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\shares.h ===
/*****************************************************************************

                            S H A R E S   H E A D E R

    Name:       shares.h
    Date:       21-Jan-1994
    Creator:    John Fu

    Description:
        This is the header file for shares.c

*****************************************************************************/


#if DEBUG

void DumpDdeInfo(
    PNDDESHAREINFO  pDdeI,
    LPTSTR          lpszServer);

#else
#define DumpDdeInfo(x,y)
#endif


LRESULT EditPermissions(
    BOOL    fSacl);


BOOL WINAPI EditPermissions2(
    HWND        hWnd,
    LPTSTR      pShareName,
    BOOL        fSacl);;


LRESULT EditOwner(void);


LRESULT Properties(
    HWND        hwnd,
    PLISTENTRY  lpLE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\strtok.h ===
/*****************************************************************************

                            S T R T O K   H E A D E R

    Name:       strtok.h
    Date:       21-Jan-1994
    Creator:    John Fu

    Description:
        This is the header file for strtok.c

*****************************************************************************/



BOOL IsInAlphaA(
    char    ch);


LPSTR strtokA(
    LPSTR   lpchStart,
    LPCSTR  lpchDelimiters);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\strtok.c ===
/*****************************************************************************

                                S T R T O K

    Name:       strtok.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This file contains functions for string manipulations.

    History:
        21-Jan-1994     John Fu, cleanup and reformat

*****************************************************************************/

#include <windows.h>
#include "clipbook.h"
#include "strtok.h"


static LPCSTR   lpchAlphaDelimiters;



/*
 *      IsInAlphaA
 */

BOOL IsInAlphaA(
    char    ch)
{
LPCSTR lpchDel = lpchAlphaDelimiters;

    if (ch)
        {
        while (*lpchDel)
            {
            if (ch == *lpchDel++)
                {
                return TRUE;
                }
            }
        }
    else
        {
        return TRUE;
        }

    return FALSE;

}





/*
 *      strtokA
 */

LPSTR strtokA(
    LPSTR   lpchStart,
    LPCSTR  lpchDelimiters)
{
static LPSTR lpchEnd;



    // PINFO("sTRTOK\r\n");

    if (NULL == lpchStart)
        {
        if (lpchEnd)
            {
            lpchStart = lpchEnd + 1;
            }
        else
            {
            return NULL;
            }
        }


    // PINFO("sTRING: %s\r\n", lpchStart);

    lpchAlphaDelimiters = lpchDelimiters;

    if (*lpchStart)
        {
        while (IsInAlphaA(*lpchStart))
            {
            lpchStart++;
            }

        // PINFO("Token: %s\r\n", lpchStart);

        lpchEnd = lpchStart;
        while (*lpchEnd && !IsInAlphaA(*lpchEnd))
            {
            lpchEnd++;
            }

        if (*lpchEnd)
            {
            // PINFO("Found tab\r\n");
            *lpchEnd = '\0';
            }
        else
            {
            // PINFO("Found null\r\n");
            lpchEnd = NULL;
            }
        }
    else
        {
        lpchEnd = NULL;
        return NULL;
        }

    // PINFO("Returning %s\r\n", lpchStart);

    return lpchStart;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\vclpbrd.h ===
/*****************************************************************************

                    V C L I P B O A R D   H E A D E R

    Name:       vclpbrd.H
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This is the header file for vclpbrd.c

*****************************************************************************/




#ifndef	VCLPBRD_INCLUDED
#define VCLPBRD_INCLUDED

#define	CCHMAXCLPFORMAT	79

struct VClipBrdEntry {
   UINT   Fmt;
   HANDLE Data;
   struct VClipBrdEntry * Next;
   };


typedef struct VClipBrdEntry  VCLPENTRY;
typedef struct VClipBrdEntry * PVCLPENTRY;
typedef struct VClipBrdEntry far * LPVCLPENTRY;


struct VClipBrd {
   int        NumFormats;
   BOOL       fOpen;
   PVCLPENTRY Head;
   PVCLPENTRY Tail;
   HWND Hwnd;
   };


typedef struct VClipBrd VCLPBRD;
typedef struct VClipBrd * PVCLPBRD;
typedef struct VClipBrd far * LPVCLPBRD;





PVCLPBRD CreateVClipboard (
    HWND    hwnd);


BOOL DestroyVClipboard (
    PVCLPBRD    p);


int VCountClipboardFormats (
    PVCLPBRD    p);


BOOL VEmptyClipboard (
    PVCLPBRD    p);


UINT VEnumClipboardFormats(
    PVCLPBRD    p,
    UINT        Fmt);


HANDLE VGetClipboardData(
    PVCLPBRD    pvclp,
    UINT        Fmt);


BOOL VIsClipboardFormatAvailable(
    PVCLPBRD    p,
    UINT        Fmt);


HANDLE VSetClipboardData(
    PVCLPBRD    p,
    UINT        Fmt,
    HANDLE      Data);


BOOL VOpenClipboard(
    PVCLPBRD    p,
    HWND        hwnd);


BOOL VCloseClipboard(
    PVCLPBRD    p);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\shares.c ===
/*****************************************************************************

                                S H A R E S

    Name:       shares.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This file contains functions for manipulating NetDDE shares.

*****************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <nddeapi.h>
#include <nddesec.h>
#include <sedapi.h>
#include <strsafe.h>

#include "common.h"
#include "clipbook.h"
#include "clipbrd.h"
#include "auditchk.h"
#include "clipdsp.h"
#include "dialogs.h"
#include "helpids.h"
#include "shares.h"
#include "clpbkdlg.h"
#include "cvutil.h"
#include "debugout.h"
#include "security.h"
#include "initmenu.h"



#define MAX_PERMNAMELEN     64



// Typedefs used to dynamically load and call the permission editors.

typedef DWORD (WINAPI *LPFNSACLEDIT)(HWND,
                                     HANDLE,
                                     LPWSTR,
                                     PSED_OBJECT_TYPE_DESCRIPTOR,
                                     PSED_APPLICATION_ACCESSES,
                                     LPWSTR,
                                     PSED_FUNC_APPLY_SEC_CALLBACK,
                                     ULONG_PTR,
                                     PSECURITY_DESCRIPTOR,
                                     BOOLEAN,
                                     LPDWORD,
                                     DWORD);

typedef DWORD (WINAPI *LPFNDACLEDIT)(HWND,
                                     HANDLE,
                                     LPWSTR,
                                     PSED_OBJECT_TYPE_DESCRIPTOR,
                                     PSED_APPLICATION_ACCESSES,
                                     LPWSTR,
                                     PSED_FUNC_APPLY_SEC_CALLBACK,
                                     ULONG_PTR,
                                     PSECURITY_DESCRIPTOR,
                                     BOOLEAN,
                                     BOOLEAN,
                                     LPDWORD,
                                     DWORD);


// Typedef for dynamically loading the Edit Owner dialog.
typedef DWORD (WINAPI *LPFNOWNER)(HWND,
                                  HANDLE,
                                  LPWSTR,
                                  LPWSTR,
                                  LPWSTR,
                                  UINT,
                                  PSED_FUNC_APPLY_SEC_CALLBACK,
                                  ULONG_PTR,
                                  PSECURITY_DESCRIPTOR,
                                  BOOLEAN,
                                  BOOLEAN,
                                  LPDWORD,
                                  PSED_HELP_INFO,
                                  DWORD);



static TCHAR    szDirName[256] = {'\0',};
static WCHAR    ShareObjectName[80];


static SED_APPLICATION_ACCESS KeyPerms[] =
   {
   SED_DESC_TYPE_RESOURCE,          0,                          0, NULL,
   SED_DESC_TYPE_RESOURCE,          NDDE_GUI_READ,              0, NULL,
   SED_DESC_TYPE_RESOURCE,          NDDE_GUI_READ_LINK,         0, NULL,
   SED_DESC_TYPE_RESOURCE,          NDDE_GUI_CHANGE,            0, NULL,
   SED_DESC_TYPE_RESOURCE,          GENERIC_ALL,                0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_READ,            0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_WRITE,           0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_INITIATE_STATIC, 0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_INITIATE_LINK,   0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_REQUEST,         0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_ADVISE,          0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_POKE,            0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_EXECUTE,         0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_ADD_ITEMS,       0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  NDDE_SHARE_LIST_ITEMS,      0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  DELETE,                     0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  READ_CONTROL,               0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  WRITE_DAC,                  0, NULL,
   SED_DESC_TYPE_RESOURCE_SPECIAL,  WRITE_OWNER,                0, NULL,
   };

static SED_APPLICATION_ACCESS KeyAudits[] =
   {
   SED_DESC_TYPE_AUDIT, NDDE_GUI_READ,   0, NULL,
   SED_DESC_TYPE_AUDIT, NDDE_GUI_CHANGE, 0, NULL,
   SED_DESC_TYPE_AUDIT, WRITE_DAC,       0, NULL,
   SED_DESC_TYPE_AUDIT, WRITE_OWNER,     0, NULL
   };



// Callback function gets called by the permission editor

DWORD CALLBACK SedCallback(HWND,
                  HANDLE,
                  ULONG_PTR,
                  PSECURITY_DESCRIPTOR,
                  PSECURITY_DESCRIPTOR,
                  BOOLEAN,
                  BOOLEAN,
                  LPDWORD);



#if DEBUG


/*
 *      DumpDdeInfo
 */

void DumpDdeInfo(
    PNDDESHAREINFO  pDdeI,
    LPTSTR          lpszServer)
{
LPTSTR      lpszT;
unsigned    i;



    PINFO(TEXT("Dde block:\r\n\r\n"));
    PINFO(TEXT("Server: <%s> Share: <%s>\r\n"),
          lpszServer ? lpszServer : "NULL",
          pDdeI->lpszShareName);

    lpszT = pDdeI->lpszAppTopicList;

    for (i = 0;i < 3;i++)
        {
        PINFO(TEXT("App|Topic %d: <%s>\r\n"),i, lpszT);
        lpszT += lstrlen(lpszT) + 1;
        }

    PINFO(TEXT("Rev: %ld Shared: %ld Service: %ld Start: %ld\r\n"),
          pDdeI->lRevision,
          pDdeI->fSharedFlag,
          pDdeI->fService,
          pDdeI->fStartAppFlag);

    PINFO(TEXT("Type: %ld Show: %ld Mod1: %lx Mod2: %lx\r\n"),
          pDdeI->lShareType,
          pDdeI->nCmdShow,
          pDdeI->qModifyId[0],
          pDdeI->qModifyId[1]);

    PINFO(TEXT("Items: %ld ItemList:"),
          pDdeI->cNumItems);


    lpszT = pDdeI->lpszItemList;

    if (lpszT)
        {
        for (i = 0;i < (unsigned)pDdeI->cNumItems;i++)
            {
            if ((i - 1)% 4 == 0)
                {
                PINFO(TEXT("\r\n"));
                }

            PINFO(TEXT("%s\t"),lpszT);
            lpszT += lstrlen(lpszT) + 1;
            }
        PINFO(TEXT("\r\n"));
        }
    else
        {
        PINFO(TEXT("NULL\r\n"));
        }

}


#endif // DEBUG





/*
 *      SedCallback
 *
 *  Purpose: Callback function called by ACLEDIT.DLL. See SEDAPI.H for
 *     details on its parameters and return value.
 *
 *  Notes: The CallbackContext of this callback should be a string in
 *     this format: Computername\0Sharename\0SECURITY_INFORMATION struct.
 */

DWORD CALLBACK SedCallback(
    HWND                 hwndParent,
    HANDLE               hInstance,
    ULONG_PTR            penvstr,
    PSECURITY_DESCRIPTOR SecDesc,
    PSECURITY_DESCRIPTOR SecDescNewObjects,
    BOOLEAN              ApplyToSubContainers,
    BOOLEAN              ApplyToSubObjects,
    LPDWORD              StatusReturn)
{
PSECURITY_DESCRIPTOR    psdSet;
SEDCALLBACKCONTEXT      *pcbcontext;
DWORD                   ret = NDDE_NO_ERROR + 37;
DWORD                   dwMyRet = ERROR_INVALID_PARAMETER;
DWORD                   dwLen;
DWORD                   dwErr;


    pcbcontext = (SEDCALLBACKCONTEXT *)penvstr;

    PINFO(TEXT("SedCallback: machine  %ls share %ls SI %ld\r\n"),
          pcbcontext->awchCName, pcbcontext->awchSName, pcbcontext->si);


    // Need to give this capability to remote shares somehow!!!
    if (!IsValidSecurityDescriptor(SecDesc))
        {
        PERROR(TEXT("Bad security descriptor created, can't set security."));
        *StatusReturn = SED_STATUS_FAILED_TO_MODIFY;
        dwMyRet = ERROR_INVALID_SECURITY_DESCR;
        }
    else
        {
        PINFO(TEXT("Setting security to "));
        PrintSD(SecDesc);

        SetLastError(0);
        dwLen = GetSecurityDescriptorLength (SecDesc);

        if (dwErr = GetLastError())
            {
            PERROR(TEXT("GetSecurityDescriptorLength -> %u\r\n"), dwErr);
            dwMyRet = ERROR_INVALID_SECURITY_DESCR;
            }
        else
            {
            // Try to make sure that the SD is self-relative, 'cause the
            // NetDDE functions vomit when given absolute SDs.

            if (psdSet = LocalAlloc (LPTR, dwLen))
                {
                if (FALSE == MakeSelfRelativeSD (SecDesc, psdSet, &dwLen))
                    {
                    LocalFree(psdSet);

                    if (psdSet = LocalAlloc (LPTR, dwLen))
                        {
                        if (FALSE == MakeSelfRelativeSD (SecDesc, psdSet, &dwLen))
                            {
                            LocalFree(psdSet);
                            psdSet = NULL;
                            dwMyRet = ERROR_INVALID_SECURITY_DESCR;
                            }
                        }
                    else
                        {
                        dwMyRet = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }

                if (psdSet)
                    {
                    DWORD dwTrust[3];

                    NDdeGetTrustedShareW (pcbcontext->awchCName,
                                          pcbcontext->awchSName,
                                          dwTrust,
                                          dwTrust + 1,
                                          dwTrust + 2);

                    ret = NDdeSetShareSecurityW (pcbcontext->awchCName,
                                                 pcbcontext->awchSName,
                                                 pcbcontext->si,
                                                 psdSet);

                    PINFO(TEXT("Set share info. %d\r\n"),ret);

                    if (ret != NDDE_NO_ERROR)
                        {
                        NDdeMessageBox (hInst,
                                        hwndParent,
                                        ret,
                                        IDS_APPNAME,
                                        MB_OK|MB_ICONSTOP);

                        *StatusReturn = SED_STATUS_FAILED_TO_MODIFY;
                        dwMyRet =  ERROR_ACCESS_DENIED;
                        }
                    else
                        {
                        NDdeSetTrustedShareW (pcbcontext->awchCName,
                                              pcbcontext->awchSName,
                                              0);

                        NDdeSetTrustedShareW (pcbcontext->awchCName,
                                              pcbcontext->awchSName,
                                              dwTrust[0]);

                        *StatusReturn = SED_STATUS_MODIFIED;
                        dwMyRet =  ERROR_SUCCESS;
                        }
                    LocalFree(psdSet);
                    }
                }
            }
        }

    return(dwMyRet);
}




/*
 *      EditPermissions
 *
 *  Purpose: Call the Acl Editor for the selected page.
 *
 *  Parameters:
 *     fSacl - TRUE to call the SACL editor (auditing); FALSE to call
 *        the DACL editor (permissions).
 *
 *  Returns: current selected item in list box or LB_ERR.
 */

LRESULT EditPermissions (
    BOOL    fSacl)
{
LPLISTENTRY     lpLE;
TCHAR           rgtchCName[MAX_COMPUTERNAME_LENGTH + 3];
TCHAR           rgtchShareName[MAX_NDDESHARENAME + 1];
DWORD           dwBAvail;
WORD            wItems;
unsigned        iListIndex;
TCHAR           szBuff[MAX_PAGENAME_LENGTH + 32];




    iListIndex = (int)SendMessage(pActiveMDI->hWndListbox, LB_GETCURSEL, 0, 0L);

    if (iListIndex != LB_ERR)
       {

       if (SendMessage (pActiveMDI->hWndListbox,
                        LB_GETTEXT, iListIndex, (LPARAM)(LPCSTR)&lpLE)
           == LB_ERR)
          {
          PERROR(TEXT("PermsEdit No text: %d\n\r"), iListIndex );
          }
       else
          {
          // NDdeShareGetInfo wants a wItems containing 0. Fine.
          wItems = 0;

          // Get computer name containing share
          rgtchCName[0] = rgtchCName[1] = TEXT('\\');
          if (pActiveMDI->flags & F_LOCAL)
             {
             dwBAvail = MAX_COMPUTERNAME_LENGTH + 1;
             GetComputerName (rgtchCName + 2, &dwBAvail);
             }
          else
             {
             StringCchCopy(rgtchCName + 2, MAX_COMPUTERNAME_LENGTH + 1, pActiveMDI->szBaseName);
             }

          PINFO(TEXT("Getting page %s from server %s\r\n"),
               lpLE->name, rgtchCName);

          // Set up sharename string ("$<pagename>")
          StringCchCopy(rgtchShareName, MAX_NDDESHARENAME + 1, lpLE->name);
          rgtchShareName[0] = SHR_CHAR;



          // Edit the permissions
          PINFO(TEXT("Editing permissions for share %s\r\n"), rgtchShareName);
          EditPermissions2 (hwndApp, rgtchShareName, fSacl);



          ///////////////////////////////////////////////
          // do the execute to change the security on the file.
          StringCchCopy(szBuff, sizeof(szBuff), IsShared(lpLE) ? SZCMD_SHARE : SZCMD_UNSHARE);
          StringCchCat(szBuff, sizeof(szBuff), lpLE->name);

          PINFO(TEXT("sending cmd [%s]\n\r"), szBuff);

          MySyncXact ( (LPBYTE)szBuff,
              lstrlen(szBuff) +1, GETMDIINFO(hwndLocal)->hExeConv, 0L, CF_TEXT,
              XTYP_EXECUTE, SHORT_SYNC_TIMEOUT, NULL);
          }

       }

    return iListIndex;
}




/*
 *      EditPermissions2
 *
 *  Purpose: Put up the standard "permission editor" dialog.
 *
 *  Parameters:
 *     hWnd - Parent window for the dialog.
 *     pShareName - Name of the DDE share.
 *     lpDdeI - Pointer to an NDDESHAREINFO describing the share.
 *     fSacl - TRUE if you're editing the SACL, FALSE to edit the DACL
 *
 *  Returns:
 *     TRUE on success, FALSE on failure.
 */

BOOL WINAPI EditPermissions2 (
    HWND    hWnd,
    LPTSTR  pShareName,
    BOOL    fSacl)
{
SED_OBJECT_TYPE_DESCRIPTOR  ObjectTypeDescriptor;
SED_APPLICATION_ACCESSES    ApplicationAccesses;

PSECURITY_DESCRIPTOR        pSD = NULL;
GENERIC_MAPPING             GmDdeShare;
SED_HELP_INFO               HelpInfo;
SEDCALLBACKCONTEXT          cbcontext;

DWORD       Status;
DWORD       dwRtn;
unsigned    i, iFirst;
BOOL        fRet = FALSE;
DWORD       dwSize;
BOOL        fCouldntRead;
HMODULE     hMod;
LPWSTR      szPermNames = NULL;

WCHAR	szSpecial[256];


    PINFO(TEXT("EditPermissions2: %s"), fSacl ? "SACL\r\n" : "DACL\r\n");

    if (fSacl && !AuditPrivilege (AUDIT_PRIVILEGE_ON))
        return fRet;




    SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Set up the callback context for the SedCallback function.
    cbcontext.awchCName[0] = cbcontext.awchCName[1] = L'\\';
    if (pActiveMDI->flags & (F_LOCAL | F_CLPBRD))
        {
        dwSize = MAX_COMPUTERNAME_LENGTH + 1;
        GetComputerNameW(cbcontext.awchCName + 2, &dwSize);
        }
    else
        {
        #ifdef REMOTE_ADMIN_OK
            MultiByteToWideChar (CP_ACP,
                                 0,
                                 pActiveMDI->szBaseName, -1,
                                 cbcontext.awchCName + 2,
                                 MAX_COMPUTERNAME_LENGTH + 1);
        #else
            PERROR(TEXT("EditPermissions2() on remote window!!!\r\n"));
            MessageBoxID (hInst,
                          hwndApp,
                          IDS_INTERNALERR,
                          IDS_APPNAME,
                          MB_OK | MB_ICONHAND);
        #endif
        }


    #ifdef UNICODE
        lstrcpyW(cbcontext.awchSName, pShareName);
    #else
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pShareName, -1,
                            cbcontext.awchSName, MAX_NDDESHARENAME);
    #endif

    cbcontext.si = (fSacl? SACL_SECURITY_INFORMATION: DACL_SECURITY_INFORMATION);




    pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, 30);
    if (!pSD)
        {
        PERROR(TEXT("LocalAlloc fail\r\n"));
        }
    else
        {
        // Get the security descriptor off of the share
        dwRtn = NDdeGetShareSecurityW (cbcontext.awchCName,
                                       cbcontext.awchSName,
                                       cbcontext.si |
                                       OWNER_SECURITY_INFORMATION,
                                       pSD,
                                       30,
                                       &dwSize);
        switch (dwRtn)
            {
            case NDDE_NO_ERROR:
                fCouldntRead = FALSE;
                PrintSD(pSD);
                break;

            case NDDE_BUF_TOO_SMALL:
                {
                PINFO(TEXT("GetShareSec sez SD is %ld bytes long, ret %ld\r\n"),
                      dwSize, dwRtn);

                LocalFree(pSD);
                pSD = NULL;

                if (dwSize < 65535 && (pSD = LocalAlloc(LPTR, dwSize)))
                    {
                    dwRtn = NDdeGetShareSecurityW (cbcontext.awchCName,
                                                   cbcontext.awchSName,
                                                   cbcontext.si |
                                                   OWNER_SECURITY_INFORMATION,
                                                   pSD,
                                                   dwSize,
                                                   &dwSize);

                    if (NDDE_NO_ERROR == dwRtn)
                        {
                        fCouldntRead = FALSE;
                        PINFO(TEXT("Got security!\r\n"));
                        PrintSD(pSD);
                        }
                    else
                        {
                        PERROR(TEXT("NDdeGetSecurity fail %ld!\r\n"), dwRtn);
                        fCouldntRead = TRUE;
                        LocalFree(pSD);
                        pSD = NULL;
                        break;
                        }
                    }
                else
                    {
                    PERROR(TEXT("LocalReAlloc fail (%ld bytes)\r\n"), dwSize);
                    }
                }
                break;

            case NDDE_ACCESS_DENIED:
            default:
                fCouldntRead = TRUE;
                LocalFree(pSD);
                pSD = NULL;
                break;
            }
        }



    if (!pSD && !fCouldntRead)
        {
        MessageBoxID(hInst, hWnd, IDS_INTERNALERR, IDS_APPNAME, MB_OK | MB_ICONHAND);
        goto done;
        }




    LoadStringW(hInst, IDS_SHROBJNAME, ShareObjectName,
          ARRAYSIZE(ShareObjectName));

    // Set up help contexts for all of the dialogs, so the Help
    // buttons will work.
    HelpInfo.pszHelpFileName = L"clipbrd.hlp";
    HelpInfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG]          = 0;
    HelpInfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] = 0;
    HelpInfo.aulHelpContext[HC_ADD_USER_DLG]                = IDH_ADD_USER_DLG;
    HelpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_LG_DLG]     = IDH_ADD_MEM_LG_DLG;
    HelpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_GG_DLG]     = IDH_ADD_MEM_GG_DLG;
    HelpInfo.aulHelpContext[HC_ADD_USER_SEARCH_DLG]         = IDH_FIND_ACCT_DLG;
    HelpInfo.aulHelpContext[HC_MAIN_DLG]                    = fSacl ?
                                                               IDH_AUDITDLG :
                                                               IDH_PERMSDLG;

    // Set up a GENERIC_MAPPING struct-- we don't use generic
    // rights, but the struct has to be there.
    GmDdeShare.GenericRead    = NDDE_GUI_READ;
    GmDdeShare.GenericWrite   = NDDE_GUI_CHANGE;
    GmDdeShare.GenericExecute = NDDE_GUI_READ_LINK;
    GmDdeShare.GenericAll     = NDDE_GUI_FULL_CONTROL;

    ObjectTypeDescriptor.Revision                        = SED_REVISION1;
    ObjectTypeDescriptor.IsContainer                     = FALSE;
    ObjectTypeDescriptor.AllowNewObjectPerms             = FALSE;
    ObjectTypeDescriptor.MapSpecificPermsToGeneric       = FALSE;
    ObjectTypeDescriptor.GenericMapping                  = &GmDdeShare;
    ObjectTypeDescriptor.GenericMappingNewObjects        = &GmDdeShare;
    ObjectTypeDescriptor.ObjectTypeName                  = ShareObjectName;
    ObjectTypeDescriptor.HelpInfo                        = &HelpInfo;
    ObjectTypeDescriptor.ApplyToSubContainerTitle        = NULL;
    ObjectTypeDescriptor.ApplyToSubContainerConfirmation = NULL;

    LoadStringW (hInst, IDS_SPECIAL, szSpecial, 256 );
    ObjectTypeDescriptor.SpecialObjectAccessTitle = szSpecial;

    ObjectTypeDescriptor.SpecialNewObjectAccessTitle     = NULL;

    if (fSacl)
        {
        PINFO(TEXT("Editing SACL..\r\n"));
        ApplicationAccesses.Count           = sizeof(KeyAudits)/sizeof(KeyAudits[0]);
        ApplicationAccesses.AccessGroup     = KeyAudits;
        }
    else
        {
        ApplicationAccesses.Count           = sizeof(KeyPerms)/sizeof(KeyPerms[0]);
        ApplicationAccesses.AccessGroup     = KeyPerms;
        // This corresponds to "Read and Link"
        ApplicationAccesses.DefaultPermName = KeyPerms[2].PermissionTitle;
        }


    // Load the permission names-- note ternary operator to give us
    // the AUDIT names if we're editing the SACL
    iFirst = fSacl ? IDS_AUDITNAMEFIRST : IDS_PERMNAMEFIRST;


    szPermNames = GlobalAlloc (LPTR,
                               ApplicationAccesses.Count
                               * MAX_PERMNAMELEN
                               * sizeof(WCHAR));

    if (!szPermNames)
        goto done;


    for (i=0; i<ApplicationAccesses.Count; i++)
        {
        ApplicationAccesses.AccessGroup[i].PermissionTitle
            = szPermNames + i * MAX_PERMNAMELEN;
        LoadStringW (hInst,
                     iFirst + i,
                     ApplicationAccesses.AccessGroup[i].PermissionTitle,
                     MAX_PERMNAMELEN - 1);
        }



    if (fSacl)
        {
        LPFNSACLEDIT lpfn;

        PINFO(TEXT("Finding SACL editor..\r\n"));

        if (hMod = LoadLibrary("ACLEDIT.DLL"))
            {
            if (lpfn = (LPFNSACLEDIT)GetProcAddress(hMod, "SedSystemAclEditor"))
                {
                SetCursor(LoadCursor(NULL, IDC_ARROW));

                PINFO(TEXT("Calling SACL editor..\r\n"));

                dwRtn = (*lpfn) (hWnd,                    // owner wnd
                                 hInst,                   // hinstance
                                 NULL,                    // Server (NULL means local)
                                 &ObjectTypeDescriptor,   // Object type
                                 &ApplicationAccesses,    // Access types.
                                 cbcontext.awchSName + 1, // Object name
                                 SedCallback,             // Apply security callback
                                 (ULONG_PTR)&cbcontext,   // Callback context
                                 pSD,                     // Points to current ACL
                                 (BOOLEAN)fCouldntRead,   // true if user can't read ACL list.
                                 &Status,                 // Status return code
                                 (DWORD)0);
                }
            else
                {
                MessageBoxID(hInst, hWnd, IDS_INTERNALERR, IDS_APPNAME, MB_OK | MB_ICONHAND);
                }
            FreeLibrary(hMod);
            }
        else
            {
            MessageBoxID(hInst, hWnd, IDS_INTERNALERR, IDS_APPNAME, MB_OK | MB_ICONHAND);
            }
        }
    else
        {
        LPFNDACLEDIT lpfn;

        PINFO(TEXT("Getting DACL edit \r\n"));

        if (hMod = LoadLibrary("ACLEDIT.DLL"))
            {
            if (lpfn = (LPFNDACLEDIT)GetProcAddress(hMod,
                  "SedDiscretionaryAclEditor"))
                {
                SetCursor(LoadCursor(NULL, IDC_ARROW));
                dwRtn = (*lpfn) (hWnd,                    // owner wnd
                                 hInst,                   // hinstance
                                 NULL,                    // Server (NULL means local)
                                 &ObjectTypeDescriptor,   // Object type
                                 &ApplicationAccesses,    // Access types.
                                 cbcontext.awchSName + 1, // Object name
                                 SedCallback,             // Apply security callback
                                 (ULONG_PTR)&cbcontext,   // Callback context
                                 pSD,                     // Points to current ACL
                                 (BOOLEAN)fCouldntRead,   // true if user can't read ACL list.
                                 FALSE,                   // true if user can't write ACL list
                                 &Status,                 // Status return code
                                 0L);
                }
            FreeLibrary(hMod);
            }
        }

    fRet = TRUE;

    SendMessage (hWnd, WM_COMMAND, IDM_REFRESH, 0);


done:

    if (pSD)         LocalFree((HLOCAL)pSD);
    if (szPermNames) GlobalFree (szPermNames);

    SetCursor(LoadCursor(NULL, IDC_ARROW));

    AuditPrivilege(AUDIT_PRIVILEGE_OFF);

    return fRet;
}





/*
 *      EditOwner
 *
 *  Purpose: Edit ownership on the selected page.
 */

LRESULT EditOwner(void)
{
LPLISTENTRY             lpLE;
DWORD                   dwBAvail;
unsigned                iListIndex;
DWORD                   Status;
DWORD                   ret;
WCHAR                   ShareObjName[100];
BOOL                    fCouldntRead;
BOOL                    fCouldntWrite;
DWORD                   dwSize;
HMODULE                 hMod;
SED_HELP_INFO           HelPINFO;
SEDCALLBACKCONTEXT      cbcontext;
PSECURITY_DESCRIPTOR    pSD = NULL;;



    iListIndex = (int)SendMessage(pActiveMDI->hWndListbox, LB_GETCURSEL, 0, 0L);

    if (iListIndex == LB_ERR)
        {
        PERROR(TEXT("Attempt to modify ownership with no item sel'ed\r\n"));
        goto done;
        }


    if (SendMessage ( pActiveMDI->hWndListbox, LB_GETTEXT, iListIndex, (LPARAM)(LPCSTR)&lpLE)
        == LB_ERR)
        {
        PERROR(TEXT("PermsEdit No text: %d\n\r"), iListIndex );
        goto done;
        }


    // Set up the callback context
    if (pActiveMDI->flags & F_LOCAL)
        {
        cbcontext.awchCName[0] = cbcontext.awchCName[1] = L'\\';
        dwBAvail = MAX_COMPUTERNAME_LENGTH + 1;
        GetComputerNameW(cbcontext.awchCName + 2, &dwBAvail);
        }
    else
        {
        #ifdef UNICODE
            lstrcpy (cbcontext.awchCName, pActiveMDI->szBaseName);
        #else
            MultiByteToWideChar (CP_ACP, 0, pActiveMDI->szBaseName, -1,
                                 cbcontext.awchCName, MAX_COMPUTERNAME_LENGTH + 1);
        #endif
        }



    // Get page name
    SendMessage(pActiveMDI->hWndListbox, LB_GETTEXT, iListIndex, (LPARAM)&lpLE);

    PINFO(TEXT("Getting page %s from server %ws\r\n"),
         lpLE->name, cbcontext.awchCName);

    #ifdef UNICODE
        lstrcpyW (cbcontext.awchSName, lpLE->name);
    #else
        MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, lpLE->name,
                             -1, cbcontext.awchSName, 100);
    #endif

    #ifndef USETWOSHARESPERPAGE
        cbcontext.awchSName[0] = L'$';
    #endif

    cbcontext.si = OWNER_SECURITY_INFORMATION;


    // Get object name
    LoadStringW(hInst, IDS_CB_PAGE, ShareObjName, 99);


    // Get owner
    dwSize = 0L;

    PINFO(TEXT("Getting secinfo for %ls ! %ls\r\n"),
          cbcontext.awchCName,
          cbcontext.awchSName);

    NDdeGetShareSecurityW (cbcontext.awchCName,
                           cbcontext.awchSName,
                           OWNER_SECURITY_INFORMATION,
                           pSD,
                           0L,
                           &dwSize);


    if (!(pSD = LocalAlloc(LPTR, min(dwSize, 65535L))))
        {
        PERROR(TEXT("Couldn't get current owner (%ld bytes)!\r\n"), dwSize);
        }


    PINFO(TEXT("Getting owner on %ls ! %ls..\r\n"),
          cbcontext.awchCName, cbcontext.awchSName);

    ret = NDdeGetShareSecurityW(
          cbcontext.awchCName,
          cbcontext.awchSName,
          OWNER_SECURITY_INFORMATION,
          pSD,
          dwSize,
          &dwSize);

    if (NDDE_NO_ERROR == ret)
        {
        DWORD adwTrust[3];

        fCouldntRead = FALSE;

        NDdeGetTrustedShareW(
              cbcontext.awchCName,
              cbcontext.awchSName,
              adwTrust, adwTrust + 1, adwTrust + 2);

        ret = NDdeSetShareSecurityW(
              cbcontext.awchCName,
              cbcontext.awchSName,
              OWNER_SECURITY_INFORMATION,
              pSD);

        if (NDDE_NO_ERROR == ret)
            {
            NDdeSetTrustedShareW (cbcontext.awchCName,
                                  cbcontext.awchSName,
                                  adwTrust[0]);

            fCouldntWrite = FALSE;
            }
        }
    else
        {
        PERROR(TEXT("Couldn't get owner (err %d)!\r\n"), ret);
        fCouldntRead = TRUE;
        // We just set fCouldntWrite to FALSE if we couldn't read,
        // because the only way to find out if we could would be
        // to overwrite the current ownership info (and we DON'T
        // KNOW WHAT IT IS!!)
        fCouldntWrite = FALSE;
        }

    HelPINFO.pszHelpFileName = L"CLIPBRD.HLP";
    HelPINFO.aulHelpContext[ HC_MAIN_DLG ] = IDH_OWNER;

    if (hMod = LoadLibrary("ACLEDIT.DLL"))
        {
        LPFNOWNER lpfn;

        if (lpfn = (LPFNOWNER)GetProcAddress(hMod, "SedTakeOwnership"))
            {
            ret = (*lpfn)(
               hwndApp,
               hInst,
               cbcontext.awchCName,
               ShareObjName,
               cbcontext.awchSName + 1,
               1,
               SedCallback,
               (ULONG_PTR)&cbcontext,
               fCouldntRead ? NULL : pSD,
               (BOOLEAN)fCouldntRead,
               (BOOLEAN)fCouldntWrite,
               &Status,
               &HelPINFO,
               0L);
            }
        else
            {
            PERROR(TEXT("Couldn't get proc!\r\n"));
            }
        FreeLibrary(hMod);
        }
    else
        {
        PERROR(TEXT("Couldn't loadlib!\r\n"));
        }

    PINFO(TEXT("Ownership edited. Ret code %d, status %d\r\n"), ret, Status);

    LocalFree((HLOCAL)pSD);


done:
    return 0L;

}




/*
 *      Properties
 *
 *  Purpose: Change the properties of a share by displaying the Properties
 *     dialog and applying the changes the user makes to the share.
 *
 *  Parameters:
 *     hwnd - Parent window for the properties dialog
 *     lpLE - The entry we're messing with.
 *
 *  Returns:
 *     0L always. We don't return an error code because we handle informing
 *     the user of errors inside the routine.
 */

LRESULT Properties(
    HWND        hwnd,
    PLISTENTRY  lpLE)
{
PNDDESHAREINFO  lpDdeI;
LRESULT         ret;
WORD            wAddlItems;
DWORD           dwRet;
TCHAR           szBuff[MAX_PAGENAME_LENGTH + 32];
BOOL            fAlreadyShared;
DWORD           adwTrust[3];


    PINFO(TEXT("Props "));

    lpDdeI = GlobalAllocPtr(GHND, 2048 * sizeof(TCHAR));

    if (!lpDdeI)
        {
        PERROR(TEXT("GlobalAllocPtr failed\n\r"));
        return 0L;
        }


    // Use "shared" version of name, because that's the way the DDE
    // share is named.
    fAlreadyShared = IsShared(lpLE);
    SetShared (lpLE, TRUE);

    PINFO(TEXT("for share [%s]"), lpLE->name);
    wAddlItems = 0;
    ret = NDdeShareGetInfo (NULL,
                            lpLE->name,
                            2,
                            (LPBYTE)lpDdeI,
                            2048 * sizeof(TCHAR),
                            &dwRet,
                            &wAddlItems );


    if (!fAlreadyShared)
        {
        SetShared(lpLE, FALSE);
        }


    PINFO(TEXT(" GetInfo ret %ld\r\n"), ret);

    if (NDDE_ACCESS_DENIED == ret)
        {
        MessageBoxID(hInst, hwndApp, IDS_PRIVILEGEERROR, IDS_APPNAME, MB_OK | MB_ICONHAND);
        }
    else if (ret != NDDE_NO_ERROR)
        {
        PERROR(TEXT("Error from NDdeShareGetInfo %d\n\r"), ret );
        NDdeMessageBox ( hInst,
                         hwndApp,
                         (UINT)ret,
                         IDS_SHAREDLGTITLE,
                         MB_ICONHAND | MB_OK);
        }
    else if (ret == NDDE_NO_ERROR)
        {
        PINFO(TEXT("Dialog "));

        // Put up the properties dialog
        dwCurrentHelpId = 0;            //  F1 will be context sensitive
        ret = DialogBoxParam (hInst,
                              fAlreadyShared?
                               MAKEINTRESOURCE(IDD_PROPERTYDLG):
                               MAKEINTRESOURCE(IDD_SHAREDLG),
                              hwnd,
                              ShareDlgProc,
                              (LPARAM)lpDdeI );

        dwCurrentHelpId = 0;


        // If the user hit OK, try to apply the changes asked for.
        if (ret)
            {
            PINFO(TEXT("OK "));

            // Change static app/topic to $<pagename> form
            if (!fAlreadyShared)
                {
                register LPTSTR lpOog;

                lpOog = lpDdeI->lpszAppTopicList;

                // Jump over the first two NULL chars you find-- these
                // are the old- and new-style app/topic pairs, we don't
                // mess with them. Then jump over the next BAR_CHAR you find.
                // The first character after that is the first char of the
                // static topic-- change that to a SHR_CHAR.

                while (*lpOog++) ;
                while (*lpOog++) ;


                // FEATURE: TEXT('|') should == BAR_CHAR. If not, this needs to
                // be adjusted.

                while (*lpOog++ != TEXT('|')) ;


                *lpOog = SHR_CHAR;
                }


            lpDdeI->fSharedFlag = 1L;

            // Get current trusted status
            if (NDDE_NO_ERROR != NDdeGetTrustedShare (NULL,
                                                      lpDdeI->lpszShareName,
                                                      adwTrust,
                                                      adwTrust + 1,
                                                      adwTrust + 2))
                {
                adwTrust[0] = 0;
                }



            DumpDdeInfo(lpDdeI, NULL);
            ret = NDdeShareSetInfo (NULL,
                                    lpDdeI->lpszShareName,
                                    2,
                                    (LPBYTE)lpDdeI,
                                    2048 * sizeof(TCHAR),
                                    0);


            if (NDDE_ACCESS_DENIED == ret)
                {
                MessageBoxID(hInst, hwndApp, IDS_PRIVILEGEERROR, IDS_APPNAME,
                      MB_OK | MB_ICONHAND);
                }
            else if (NDDE_NO_ERROR != ret)
                {
                PERROR(TEXT("Error from NDdeShareSetInfo %d\n\r"), ret );
                NDdeMessageBox (hInst, hwndApp, (UINT)ret,
                                IDS_SHAREDLGTITLE, MB_ICONHAND | MB_OK );
                }
            else
                {
                NDdeSetTrustedShare(NULL, lpDdeI->lpszShareName, adwTrust[0]);


                ///////////////////////////////////////////////
                // do the execute to change the server state
                StringCchCopy(szBuff, sizeof(szBuff), SZCMD_SHARE);
                StringCchCat( szBuff, sizeof(szBuff), lpLE->name);
                PINFO(TEXT("sending cmd [%s]\n\r"), szBuff);

                if (MySyncXact ((LPBYTE)szBuff,
                                lstrlen(szBuff) +1,
                                GETMDIINFO(hwndLocal)->hExeConv,
                                0L,
                                CF_TEXT,
                                XTYP_EXECUTE,
                                SHORT_SYNC_TIMEOUT,
                                NULL))
                    {
                    InitializeMenu(GetMenu(hwndApp));
                    }
                else
                    {
                    XactMessageBox (hInst, hwnd, IDS_APPNAME, MB_OK | MB_ICONSTOP);
                    }
                }
            }
        else if (!fAlreadyShared)  // User hit cancel on the dialog, restore the original shared state
            {
            SetShared(lpLE, FALSE);
            }
        }

    GlobalFreePtr(lpDdeI);

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\common\clipfile.h ===
/******************************************************************************

                    C L I P F I L E   H E A D E R

    Name:       clipfile.h
    Date:       1/20/94
    Creator:    John Fu

    Description:
        This is the header file for clipfile.c

******************************************************************************/




#define READFILE_SUCCESS         0
#define READFILE_IMPROPERFORMAT  1
#define READFILE_OPENCLIPBRDFAIL 2





extern  BOOL    fAnythingToRender;

extern  TCHAR   szFileSpecifier[];
extern  TCHAR   szFileName[MAX_PATH+1];
extern  TCHAR   szSaveFileName[MAX_PATH+1];     // Saved filename for delayed render

extern  BOOL    fNTReadFileFormat;
extern  BOOL    fNTSaveFileFormat;

extern  UINT    cf_link;
extern  UINT    cf_objectlink;
extern  UINT    cf_linkcopy;
extern  UINT    cf_objectlinkcopy;



extern TCHAR szCaptionName[];




extern  HANDLE RenderFormat(FORMATHEADER *, register HANDLE);


// winball additions

extern  BOOL AddNetInfoToClipboard (TCHAR *);
extern  BOOL AddPreviewFormat (VOID);
extern  BOOL AddCopiedFormat (UINT ufmtOriginal, UINT ufmtCopy);
extern  BOOL AddDIBtoDDB(VOID);

// end winball





// Functions


unsigned ReadFileHeader(
    HANDLE  fh);


BOOL ReadFormatHeader(
    HANDLE          fh,
    FORMATHEADER    *pfh,
    unsigned        iFormat);


short ReadClipboardFromFile(
    HWND    hwnd,
    HANDLE  fh);


DWORD OpenClipboardFile(
    HWND    hwnd,
    LPTSTR  szName);


HANDLE RenderFormatFromFile(
    LPTSTR  szFile,
    WORD    wFormat);


HANDLE RenderAllFromFile(
    LPTSTR  szFile);


BOOL IsWriteable(
    WORD Format);


int Count16BitClipboardFormats(void);


DWORD WriteFormatBlock(
    HANDLE  fh,
    DWORD   offset,
    DWORD   DataOffset,
    DWORD   DataLen,
    UINT    Format,
    LPWSTR  wszName);


DWORD WriteDataBlock(
    register HANDLE hFile,
    DWORD           offset,
    WORD            Format);


void GetClipboardNameW(
    register int    fmt,
    LPWSTR          wszName,
    register int    iSize);


DWORD SaveClipboardData(
    HWND    hwnd,
    LPTSTR  szFileName,
    BOOL    fPage);


DWORD SaveClipboardToFile(
    HWND    hwnd,
    TCHAR   *szShareName,
    TCHAR   *szFileName,
    BOOL    fPage);


BOOL AddPreviewFormat (VOID);


BOOL AddCopiedFormat (
    UINT    ufmtOriginal,
    UINT    ufmtCopy);


BOOL AddNetInfoToClipboard (
    TCHAR   *szShareName );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\common\clipfile.c ===
/*****************************************************************************

                                C L I P F I L E

    Name:       clipfile.c
    Date:       19-Apr-1994
    Creator:    Unknown

    Description:
        Windows Clipboard File I/O Routines.

        NOTE:
          When saving the contents of the clipboard we SetClipboardData(fmt, NULL)
          to free up the memory associated with each clipboard format.  Then
          after we are done saving we take over as the clipboard owner.  This
          causes OWNERDRAW formats to be lost in the save process.

*****************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <string.h>
#include <strsafe.h>

#include "common.h"
#include "clipfile.h"
#include "clipfile.h"
#include "dib.h"
#include "debugout.h"
#include "render.h"
#include "security.h"


#define ARRAYSIZE(a)        (sizeof(a)/sizeof((a)[0]))


BOOL    fAnythingToRender;

TCHAR   szFileSpecifier[] = TEXT("*.CLP");
TCHAR   szFileName[MAX_PATH+1];
TCHAR   szSaveFileName[MAX_PATH+1];     // Saved filename for delayed render

BOOL    fNTReadFileFormat;
BOOL    fNTSaveFileFormat;

UINT    cf_link;
UINT    cf_objectlink;
UINT    cf_linkcopy;
UINT    cf_objectlinkcopy;


BOOL    AddDIBtoDDB(VOID);




/*******************

 File read routines

*******************/


/*
 *      ReadFileHeader
 *
 *  Purpose: Read the file header in the given .clp file, and get the number
 *     of formats. Also sets the fNTReadFileFormat flag appropriately.
 *
 *  Parameters:
 *     fh - Handle to the file.
 *
 *  Returns:
 *     The number of formats, or 0 if it isn't a valid .clp file.
 */

unsigned ReadFileHeader(
    HANDLE  fh)
{
FILEHEADER  FileHeader;
DWORD       dwBytesRead;


    // PINFO(TEXT("ClSrv\\RdFileHdr"));

    /* Read the File Header */
    SetFilePointer(fh, 0, NULL, FILE_BEGIN);
    ReadFile(fh, &FileHeader, sizeof(FileHeader), &dwBytesRead, NULL);

    if (dwBytesRead == sizeof(FILEHEADER))
        {
        // Make sure that this is a .CLP file
        if (FileHeader.magic == CLPBK_NT_ID ||
            FileHeader.magic == CLP_NT_ID)
            {
            fNTReadFileFormat = TRUE;
            }
        else if (FileHeader.magic == CLP_ID)
            {
            fNTReadFileFormat = FALSE;
            }
        else
            {
            PERROR(TEXT("Invalid magic member (not long enough?)\r\n"));
            FileHeader.FormatCount = 0;
            }

        // Check number of formats for additional reassurance.
        if (FileHeader.FormatCount > 100)
            {
            PERROR(TEXT("Too many formats!!!\r\n"));
            FileHeader.FormatCount = 0;
            }
        }
    else
        {
        PERROR("Read err\r\n");
        FileHeader.FormatCount = 0;
        }

    if (FileHeader.FormatCount)
        {
        // PINFO(TEXT("\r\n"));
        }

    return(FileHeader.FormatCount);
}




/*
 *      ReadFormatHeader
 */

BOOL ReadFormatHeader(
    HANDLE          fh,
    FORMATHEADER    *pfh,
    unsigned        iFormat)
{
DWORD           dwMrPibb;
OLDFORMATHEADER OldFormatHeader;


    // PINFO(TEXT("ClSrv\\RdFmtHdr"));

    if (NULL == pfh || NULL == fh)
        {
        PERROR("RdFmtHdr got NULL pointer\r\n");
        return FALSE;
        }

    SetFilePointer (fh,
                    sizeof(FILEHEADER) + iFormat *
                      (fNTReadFileFormat ? sizeof(FORMATHEADER) : sizeof(OLDFORMATHEADER)),
                    NULL,
                    FILE_BEGIN);

    if (fNTReadFileFormat)
        {
        ReadFile(fh, pfh, sizeof(FORMATHEADER), &dwMrPibb, NULL);

        if (dwMrPibb != sizeof(FORMATHEADER))
            {
            PERROR(TEXT("Bad new format rd\r\n"));
            return FALSE;
            }
        }
    else
        {
        ReadFile(fh, &OldFormatHeader, sizeof(OldFormatHeader), &dwMrPibb, NULL);

        if (dwMrPibb != sizeof(OLDFORMATHEADER))
            {
            PERROR(TEXT("Bad old format rd\r\n"));
            return FALSE;
            }

        pfh->FormatID   = OldFormatHeader.FormatID;
        pfh->DataLen    = OldFormatHeader.DataLen;
        pfh->DataOffset = OldFormatHeader.DataOffset;

        MultiByteToWideChar (CP_ACP,
                             MB_PRECOMPOSED,
                             OldFormatHeader.Name,
                             -1,
                             pfh->Name,
                             CCHFMTNAMEMAX);
        }

    // PINFO(TEXT("\r\n"));
    return TRUE;
}



/*
 *      ReadClipboardFromFile()
 *
 *  Read in a clipboard file and register all the formats in delayed mode.
 *  to render things for real reopen the file specified by ofStruct.
 *
 *  NOTE:
 *     This makes us the clipboard owner.
 *
 *  Return Value:   READFILE_IMPROPERFORMAT
 *                  READFILE_OPENCLIPBRDFAIL
 *                  READFILE_SUCCESS
 */

short ReadClipboardFromFile(
    HWND    hwnd,
    HANDLE  fh)
{
register unsigned   i;
unsigned            cFormats;
FORMATHEADER        FormatHeader;



    PINFO(TEXT("Entering ReadClipboardFromFile\r\n"));

    if (!(cFormats = ReadFileHeader(fh)) )
        {
        return(READFILE_IMPROPERFORMAT);
        }


    /* We become the clipboard owner here! */
    if (!SyncOpenClipboard(hwnd))
        {
        PERROR(TEXT("Could not open clipboard!!!"));
        return(READFILE_OPENCLIPBRDFAIL);
        }

    EmptyClipboard();

    for (i=0; i < cFormats; i++)
        {
        ReadFormatHeader (fh, &FormatHeader, i);

        if (PRIVATE_FORMAT(FormatHeader.FormatID))
            {
            FormatHeader.FormatID = RegisterClipboardFormatW ((LPWSTR)FormatHeader.Name);
            }

        /*Delayed Render. */
        PINFO(TEXT("Set up delayed render for format %d .\r\n"), FormatHeader.FormatID);
        SetClipboardData (FormatHeader.FormatID, NULL);


        if (FormatHeader.FormatID == CF_DIB)
            SetClipboardData (CF_BITMAP, NULL);
        }


    /* Now, clipbrd viewer has something to render */
    if (cFormats > 0)
        {
        PINFO(TEXT("fAnythingToRender = TRUE\r\n"));
        fAnythingToRender = TRUE;
        }

    SyncCloseClipboard();

    return(READFILE_SUCCESS);
}



/*
 *      OpenClipboardFile
 */

DWORD OpenClipboardFile(
    HWND    hwnd,
    LPTSTR  szName)
{
HANDLE  fh;
DWORD   dwErr = NO_ERROR;


    PINFO(TEXT("OpenClipboardFile: %s \r\n"),szName);

    fh = CreateFile ((LPCTSTR)szName,
                     GENERIC_READ,
                     FILE_SHARE_READ,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL);

    if (fh != INVALID_HANDLE_VALUE)
        {
        // Store file name for delayed rendering stuff.
        StringCchCopy(szSaveFileName, MAX_PATH+1, szName);

        // Read it.
        switch (ReadClipboardFromFile (hwnd, fh))
            {
            case READFILE_IMPROPERFORMAT:
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            case READFILE_OPENCLIPBRDFAIL:
                dwErr = ERROR_CLIPBOARD_NOT_OPEN;
                break;
            case READFILE_SUCCESS:
            default:
                dwErr = NO_ERROR;
                break;
            }
        CloseHandle (fh);
        }
    else
        {
        PERROR(TEXT("ClSrv\\OpClpFile: can't open file!"));
        dwErr = GetLastError ();
        }

    return dwErr;
}



/*
 *      RenderFormatFormFile
 *
 *  Purpose: Go get the given format from the given file.
 */

HANDLE RenderFormatFromFile(
    LPTSTR  szFile,
    WORD    wFormat)
{
HANDLE          fh;
FORMATHEADER    FormatHeader;
HANDLE          hData = NULL;
unsigned        cFormats;
unsigned        i;
BOOL            bHasDib = FALSE;


    PINFO(TEXT("ClpSrv\\RndrFmtFromFile: Opening file %s.\r\n"),szFile);

    fh = CreateFile (szFile,
                     GENERIC_READ,
                     FILE_SHARE_READ,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL);

    if (INVALID_HANDLE_VALUE == fh)
        {
        PERROR(TEXT("Can't open file\r\n"));
        goto done;
        }


    cFormats = ReadFileHeader(fh);


    // If ReadFile didn't get the whole header, don't try to read anything else.
    if (0 == cFormats)
        {
        PERROR(TEXT("Bad file header.\r\n"));
        goto done;
        }


    for (i=0; i < cFormats; i++)
        {
        ReadFormatHeader(fh, &FormatHeader, i);

        PINFO(TEXT("Got format %ws\r\n"),FormatHeader.Name);

        if (PRIVATE_FORMAT(FormatHeader.FormatID))
            {
            FormatHeader.FormatID = RegisterClipboardFormatW(FormatHeader.Name);
            }

        if (FormatHeader.FormatID == wFormat)
            {
            hData = RenderFormat(&FormatHeader, fh);
            }

        if (FormatHeader.FormatID == CF_DIB)
            bHasDib = TRUE;
        }



    // make CF_BITMAP available when there's CF_DIB

    if (!hData && wFormat == CF_BITMAP && bHasDib)
        {
        if (SetFilePointer (fh, 0, 0, FILE_BEGIN) == 0xFFFFFFFF)
            {
            PERROR(TEXT("Cannot set file pointer to FILE_BEGIN\n"));
            goto done;
            }


        cFormats = ReadFileHeader (fh);

        for (i=0; i < cFormats; i++)
            {
            ReadFormatHeader (fh, &FormatHeader, i);

            PINFO (TEXT("Got format %ws\n"), FormatHeader.Name);

            if (FormatHeader.FormatID == CF_DIB)
                hData = RenderFormatDibToBitmap (&FormatHeader,
                                                 fh,
                                                 RenderFormatFromFile (szFile, CF_PALETTE));
            }
        }

done:

    if (fh != INVALID_HANDLE_VALUE)
        CloseHandle (fh);

    return(hData);
}




/*
 *      RenderAllFromFile
 *
 *  Purpose: Go get all formats from the given file.
 */

HANDLE RenderAllFromFile(
    LPTSTR  szFile)
{
HANDLE          fh;
FORMATHEADER    FormatHeader;
HANDLE          hData;
unsigned        cFormats;
unsigned        i;


    /* Check if the clipbrd viewer has done any File I/O before.
     * If it has not, then it has nothing to render!
     */
    if (CountClipboardFormats() && fAnythingToRender)
        {
        /* Empty the clipboard */
        if (!SyncOpenClipboard(hwndApp))
            {
            PERROR("Couldn't open clipboard!\r\n");
            }
        else
            {
            EmptyClipboard();

            fh = CreateFile (szFile,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);

            if (INVALID_HANDLE_VALUE != fh)
                {
                cFormats = ReadFileHeader(fh);

                // If ReadFile didn't get the whole header, don't try to read anything
                // else.
                if (0 == cFormats)
                    {
                    PERROR(TEXT("Bad file header.\r\n"));
                    }

                for (i=0; i < cFormats; i++)
                    {
                    ReadFormatHeader(fh, &FormatHeader, i);

                    PINFO(TEXT("Got format %ws\r\n"),FormatHeader.Name);

                    if (PRIVATE_FORMAT(FormatHeader.FormatID))
                        {
                        FormatHeader.FormatID =
                           RegisterClipboardFormatW(FormatHeader.Name);
                        }

                    // Render the format and set it into the clipboard
                    hData = RenderFormat(&FormatHeader, fh);
                    if ( hData != NULL )
                        {
                        if (!SetClipboardData(FormatHeader.FormatID, hData))
                            {
                            PERROR(TEXT("SetClipboardData fail\n\r"));
                            }
                        }
                    else
                        {
                        PERROR(TEXT("hData == NULL, bad\r\n"));
                        }
                    }
                CloseHandle(fh);
                }
            else
                {
                PERROR(TEXT("Can't open file\r\n"));
                }

            SyncCloseClipboard();
            }
        }

    return(0L);
}





/********************

 File write routines

********************/

/*
 *      IsWriteable()
 *
 *  Test if a clipboard format is writeable(i.e. if it makes sense to write it)
 *  OWNERDRAW and others can't be written because we (CLIPBRD) will become the
 *  owner when the files are reopened.
 */

BOOL IsWriteable(WORD Format)

{
    /* Are the PRIVATEFIRST and PRIVATELAST things right? */
    if ((Format >= CF_PRIVATEFIRST && Format <= CF_PRIVATELAST)
          || Format == CF_OWNERDISPLAY)
        {
        return FALSE;
        }

    // If we're not saving an NT clipboard, don't save NT-specific formats.
    if (!fNTSaveFileFormat &&
        (Format == CF_UNICODETEXT || Format == CF_ENHMETAFILE
         || Format == CF_DSPENHMETAFILE)
       )
        {
        return(FALSE);
        }

    return(TRUE);
}




/*
 *      Count16BitClipboardFormats
 *
 *  This function will return the number of clipboard formats compatible with
 *  the Windows 3.1 clipboard, this excludes CF_UNICODETEXT, CF_ENHMETAFILE and
 *  CF_DSPENHMETAFILE
 */

int Count16BitClipboardFormats(void)
{
int iCount;

    iCount = CountClipboardFormats();

    if (IsClipboardFormatAvailable(CF_UNICODETEXT))
        iCount--;

    if (IsClipboardFormatAvailable(CF_ENHMETAFILE))
        iCount--;

    if (IsClipboardFormatAvailable(CF_DSPENHMETAFILE))
        iCount--;

    return iCount;

}




/*
 *      WriteFormatBlock
 *
 *  Purpose: Writes the format header for a single data format.
 *
 *  Parameters:
 *   fh - File handle to write to.
 *   offset - Position in the file to write the format block.
 *   DataOffset - Position in the file where the data for this format will be.
 *   DataLen    - Length of the data for this format.
 *   Format     - The format number.
 *   szName     - Name of the format.
 *
 *  Returns:
 *   The number of bytes written to the file.
 */

DWORD WriteFormatBlock(
    HANDLE  fh,
    DWORD   offset,
    DWORD   DataOffset,
    DWORD   DataLen,
    UINT    Format,
    LPWSTR  wszName)
{
DWORD   dwBytesWritten = 0;


    SetFilePointer(fh, offset, NULL, FILE_BEGIN);

    if (fNTSaveFileFormat)
        {
        FORMATHEADER    FormatHeader;

        memset (&FormatHeader, 0, sizeof(FormatHeader));

        FormatHeader.FormatID   = Format;
        FormatHeader.DataLen    = DataLen;
        FormatHeader.DataOffset = DataOffset;

        StringCchCopyW(FormatHeader.Name, CCHFMTNAMEMAX, wszName);
        WriteFile (fh, &FormatHeader, sizeof(FormatHeader), &dwBytesWritten, NULL);
        }
    else
        {
        OLDFORMATHEADER OldFormatHeader;

        memset(&OldFormatHeader,0, sizeof(OldFormatHeader));

        OldFormatHeader.FormatID   = (WORD)Format;
        OldFormatHeader.DataLen    = DataLen;
        OldFormatHeader.DataOffset = DataOffset;

        WideCharToMultiByte(CP_ACP,
                            0,
                            wszName,
                            -1,
                            OldFormatHeader.Name,
                            CCHFMTNAMEMAX,
                            NULL,
                            NULL);
        WriteFile (fh,
                   &OldFormatHeader,
                   sizeof(OldFormatHeader),
                   &dwBytesWritten,
                   NULL);
        }

    return(dwBytesWritten);
}



/*
 *      WriteDataBlock() -
 *
 *  Returns:
 *     # of bytes written to the output file
 *
 *  NOTE: Write saves the name of a temp file in the clipboard for it's
 *  own internal clipboard format.  This file goes aways when Write
 *  (or windows?) shuts down.  Thus saving Write clipboards won't work
 *  (should we special case hack this?)
 *
 */

DWORD WriteDataBlock(
    register HANDLE hFile,
    DWORD           offset,
    WORD            Format)
{
WORD            wPalEntries;
LPSTR           lpData;
DWORD           dwSize = 0;
BITMAP          bitmap;
HANDLE          hMF;
HANDLE          hBitmap;
register HANDLE hData;
LPLOGPALETTE    lpLogPalette;
LPMETAFILEPICT  lpMFP;
DWORD           dwMFPSize;
BOOL            fOK = FALSE;


    if (!(hData = GetClipboardData(Format)) ||
        SetFilePointer (hFile, offset, NULL, FILE_BEGIN) != offset)
        {
        PERROR(TEXT("WriteDataBlock: couldn't get format data\n\r"));
        return 0;
        }


    /* We have to special case a few common formats but most things
     * get handled in the default case.
     */

    switch (Format)
        {
        case CF_ENHMETAFILE:
            dwSize = (DWORD) GetEnhMetaFileBits(hData, 0, NULL); /* Get data size */

            if (lpData = GlobalAllocPtr(GHND, dwSize))   /* allocate mem for EMF bits */
                {
                if (GetEnhMetaFileBits(hData, dwSize, (LPBYTE)lpData))
                    {
                    WriteFile(hFile, lpData, dwSize, &dwSize, NULL);
                    fOK = TRUE;
                    }
                GlobalFreePtr(lpData);
                }

            if (!fOK)
                {
                PERROR(TEXT("WriteDataBlock: couldn't write CF_ENHMETAFILE\r\n"));
                dwSize = 0;
                }
            break;

        case CF_METAFILEPICT:
            if (lpMFP = (LPMETAFILEPICT)GlobalLock(hData)) /* get header */
                {
                // Write METAFILEPICT header -- if we're saving in Win31 format,
                // write the old-style header.
                if (fNTSaveFileFormat)
                    {
                    WriteFile(hFile, lpMFP, sizeof(METAFILEPICT),
                        &dwMFPSize, NULL);
                    }
                else
                    {
                    WIN31METAFILEPICT w31mfp;
                    /* If we save the metafile in the Windows 3.1 .CLP file format
                       we have to save the METAFILEPICT structure as a 16bit METAFILEPICT
                       structure. This may cause loss of information if the
                       high half of the METAFILEPICT structure's fields are used.  */

                    w31mfp.mm   = (WORD)lpMFP->mm;
                    w31mfp.xExt = (WORD)lpMFP->xExt;
                    w31mfp.yExt = (WORD)lpMFP->yExt;
                    w31mfp.hMF  = (WORD)0;

                    WriteFile(hFile, &w31mfp, sizeof(WIN31METAFILEPICT), &dwMFPSize, NULL);
                    }

                hMF = lpMFP->hMF;

                GlobalUnlock(hData);            /* unlock the header */

                /* Figure out how big a block we need */
                dwSize = GetMetaFileBitsEx(hMF, 0, NULL);
                if (dwSize)
                    {
                    if (lpData = GlobalAllocPtr(GHND, dwSize))
                        {
                        if (dwSize == GetMetaFileBitsEx(hMF, dwSize, lpData))
                            {
                            WriteFile(hFile, lpData, dwSize, &dwSize, NULL);

                            dwSize += dwMFPSize;
                            }
                        else
                            {
                            dwSize = 0;
                            }

                        GlobalFreePtr(lpData);
                        }
                    else
                        {
                        dwSize = 0;
                        }
                    }
                }
            break;

        case CF_BITMAP:

            /* Writing DDBs to disk is bad. Therefore, we */
            /* write an intelligent CF_DIB block instead. */

            Format = CF_DIB;

            GetObject((HBITMAP)hData, sizeof(BITMAP), &bitmap);

            if (hBitmap = DibFromBitmap ((HBITMAP)hData,
                                         BI_RGB,
                                         (WORD) (bitmap.bmBitsPixel * bitmap.bmPlanes),
                                         IsClipboardFormatAvailable(CF_PALETTE) ?
                                           GetClipboardData(CF_PALETTE) : NULL))
               {
               if (lpData = GlobalLock(hBitmap))
                   {
                   // dwSize might be too big, but we can live with that.
                   dwSize = (DWORD)GlobalSize(lpData);

                   WriteFile(hFile, lpData, dwSize, &dwSize, NULL);

                   // Clean up
                   GlobalUnlock(hBitmap);
                   GlobalFree(hBitmap);
                   }
               }
            break;

        case CF_PALETTE:
            /* Get the number of palette entries */
            GetObject(hData, sizeof(WORD), (LPBYTE)&wPalEntries);

            /* Allocate enough place to build the LOGPALETTE struct */
            dwSize = (DWORD)(sizeof(LOGPALETTE) +
                 (LONG)wPalEntries * sizeof(PALETTEENTRY));
            if (lpLogPalette = (LPLOGPALETTE)GlobalAllocPtr(GHND, dwSize))
                {
                lpLogPalette->palVersion = 0x300;      /* Windows 3.00 */
                lpLogPalette->palNumEntries = wPalEntries;

                if (GetPaletteEntries(hData, 0, wPalEntries,
                   (LPPALETTEENTRY)(lpLogPalette->palPalEntry)) != 0)
                    {
                    /* Write the LOGPALETTE structure onto disk */
                    WriteFile(hFile, lpLogPalette, dwSize, &dwSize, NULL);
                    }
                else
                    {
                    dwSize = 0;
                    }

                GlobalFreePtr(lpLogPalette);
                }
            else
                {
                dwSize = 0L;
                }
            break;

        default:
            dwSize = (DWORD)GlobalSize(hData);

            // Just lock the data down and write it out.
            if (lpData = GlobalLock(hData))
                {
                WriteFile(hFile, lpData, dwSize, &dwSize, NULL);
                GlobalUnlock(hData);
                }
            else
                {
                dwSize = 0;
                }

            break;
            }

    /* Return the number of bytes written. */
    return(dwSize);
}



/*
 *      GetClipboardNameW
 */

void GetClipboardNameW(
    register int    fmt,
    LPWSTR          wszName,
    register int    iSize)
{
LPWSTR  lprgch = NULL;
HANDLE  hrgch  = NULL;


    *wszName = '\0';


    /* Get global memory that everyone can get to */
    if (!(hrgch = GlobalAlloc(GMEM_MOVEABLE, (LONG)(iSize + 1)*sizeof(WCHAR))))
        {
        PERROR(TEXT("GetClipboardNameW: bad alloc\r\n"));
        goto done;
        }


    if (!(lprgch = (LPWSTR)GlobalLock(hrgch)))
       {
       PERROR(TEXT("GetClipboardNameW: bad lock\r\n"));
       goto done;
       }


    memset(lprgch, 0, (iSize+1)*sizeof(WCHAR));

    switch (fmt)
        {
        case CF_RIFF:
        case CF_WAVE:
        case CF_PENDATA:
        case CF_SYLK:
        case CF_DIF:
        case CF_TIFF:
        case CF_TEXT:
        case CF_BITMAP:
        case CF_METAFILEPICT:
        case CF_ENHMETAFILE:
        case CF_OEMTEXT:
        case CF_DIB:
        case CF_PALETTE:
        case CF_DSPTEXT:
        case CF_DSPBITMAP:
        case CF_DSPMETAFILEPICT:
        case CF_DSPENHMETAFILE:
        case CF_UNICODETEXT:
            LoadStringW(hInst, fmt, lprgch, iSize);
            break;

        case CF_OWNERDISPLAY:         /* Clipbrd owner app supplies name */
            // Note: This should NEVER happen because this function only gets
            // called when we're writing a given clipboard format. Clipbrd can't
            // get away with writing CF_OWNERDISPLAY because we become clipboard
            // owner when we re-read the file, and we won't know how to deal.

            PERROR(TEXT("GetClipboardName on OwnerDisplay format!\r\n"));

            LoadStringW(hInst, fmt, lprgch, iSize);
            break;

        default:
            GetClipboardFormatNameW(fmt, lprgch, iSize);
            break;
        }

    StringCchCopyW(wszName, iSize, lprgch);

done:

    if (lprgch) GlobalUnlock(hrgch);
    if (hrgch)  GlobalFree(hrgch);
}



/*
 *      SaveClipboardData() - Writes a clipboard file.
 *
 *  In:
 *     hwnd        handle of wnd that becomes the clipboard owner
 *     szFileName  file handle to read from
 *     fPage       TRUE if this is a clipbook page (which means we secure it)
 *
 *  NOTE:
 *     When done we call ReadClipboardFromFile(). this makes us the
 *     clipboard owner.
 *
 *  Returns:
 *      NO_ERROR if no error otherwise an error code.
 */

DWORD SaveClipboardData(
    HWND    hwnd,
    LPTSTR  szFileName,
    BOOL    fPage)
{
register HANDLE fh;
register WORD   Format;

SECURITY_ATTRIBUTES sa;

DWORD       HeaderPos;
DWORD       DataPos;
DWORD       datasize;
HCURSOR     hCursor;
FILEHEADER  FileHeader;
WCHAR       wszName[CCHFMTNAMEMAX];
UINT        wHeaderSize;
UINT        uiSizeHeaderToWrite;
BOOL        fDIBUsed = FALSE;
DWORD       dwTemp;
DWORD       dwRet = NO_ERROR;


    /* First open the clipboard */
    if (!SyncOpenClipboard(hwndApp))
        return ERROR_CLIPBOARD_NOT_OPEN;

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = (fPage ? CurrentUserOnlySD() : NULL);
    sa.bInheritHandle = FALSE;

    fh = CreateFile((LPCTSTR)szFileName, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
               &sa, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (fh == INVALID_HANDLE_VALUE)
        {
        PERROR ("Error opening clipboard file!\r\n");
        dwRet = GetLastError ();
        goto done;
        }


    /* Fill out the file header structure */
    if (fNTSaveFileFormat)
        {
        FileHeader.magic = CLPBK_NT_ID;          /* magic number to tag our files */
        uiSizeHeaderToWrite = sizeof(FORMATHEADER);
        }
    else
        {
        FileHeader.magic = CLP_ID;          /* magic number to tag our files */
        uiSizeHeaderToWrite = sizeof(OLDFORMATHEADER);
        }


    FileHeader.FormatCount = 0;          /* dummy for now */

    /* Update HeaderPos and DataPos */
    HeaderPos = sizeof(FILEHEADER);

    /* This is the maximum number of formats that will be written.  Potentially
     * some may fail and some space will be wasted.
     */
    if (fNTSaveFileFormat)
        {
        DataPos = HeaderPos + (uiSizeHeaderToWrite * CountClipboardFormats());
        }
    else
        {
        DataPos = HeaderPos + (uiSizeHeaderToWrite * Count16BitClipboardFormats());
        }


   /* Now loop throught the data, one format at a time, and write out the data. */
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    ShowCursor(TRUE);


    /* Enumerate all formats */
    Format = 0;

    while ((Format = (WORD)EnumClipboardFormats(Format)))
        {
        if (IsWriteable(Format))
            {

            // DO NOT write CF_BITMAP to disk. Transform to CF_DIB
            // and write that instead.

            // If there's CF_DIB, then don't do CF_BITMAP

            if (CF_BITMAP == Format)
                if (IsClipboardFormatAvailable (CF_DIB)
                    && GetClipboardData (CF_DIB))
                    continue;   // We have DIB, don't worry about BITMAP.


            if (CF_BITMAP == Format || CF_DIB == Format)
                {
                if (!fDIBUsed)
                    fDIBUsed = TRUE;
                else
                    // Already done DIB, go on to the next format.
                    continue;
                }


            GetClipboardNameW (Format == CF_BITMAP ? CF_DIB : Format,
                               wszName,
                               ARRAYSIZE(wszName));


            PINFO(TEXT("SClipboardData: writing %ls (#)%d\r\n"), wszName,Format);

            if (datasize = WriteDataBlock(fh, DataPos, Format))
                {
                /* Create a Format header and write it to the file */
                wHeaderSize = (WORD)WriteFormatBlock (fh,
                                                      HeaderPos,
                                                      DataPos,
                                                      datasize,
                                                      Format == CF_BITMAP ? CF_DIB : Format,
                                                      wszName);
                if (wHeaderSize < uiSizeHeaderToWrite)
                    {
                    PERROR(TEXT("SaveClipboardData: error writing format block\n\r"));
                    dwRet = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                    }
                HeaderPos += wHeaderSize;

                /* Update the data pos for the next block */
                DataPos += datasize;

                FileHeader.FormatCount++;   /* this format has been written */
                }
            }
        }


    ShowCursor(FALSE);
    SetCursor(hCursor);

    SyncCloseClipboard();      /* we are done looking at this */


    // Go back and write the file header at the front of the file
    SetFilePointer (fh, 0L, NULL, FILE_BEGIN);

    if (!WriteFile (fh, &FileHeader, sizeof(FileHeader), &dwTemp, NULL))
        dwRet = GetLastError ();


    /* Now we open the clipboard and become the owner.  this places
     * all the things we just saved in the clipboard (and throws out
     * those things we didn't save)
     */

    // Set us back to the beginning
    SetFilePointer(fh, 0L, NULL, FILE_BEGIN);

    /* Under NT, the save filename will be used to get the file back */
    StringCchCopy(szSaveFileName, MAX_PATH+1, szFileName);

    PINFO(TEXT("sAVEcLIPBOARDdATA: Copied name %s to name %s\r\n"), szSaveFileName, szFileName);
    fNTReadFileFormat = fNTSaveFileFormat;

    if (dwRet == NO_ERROR) //bRet)
        {
        switch (ReadClipboardFromFile (hwndApp, fh))
            {
            case READFILE_IMPROPERFORMAT:
                dwRet = ERROR_NOT_ENOUGH_MEMORY;
                break;
            case READFILE_OPENCLIPBRDFAIL:
                dwRet = ERROR_CLIPBOARD_NOT_OPEN;
                break;
            case READFILE_SUCCESS:
            default:
                dwRet = NO_ERROR;
                break;
            }
        }

    CloseHandle(fh);

    if (dwRet != NO_ERROR)
        {
        PERROR(TEXT("SCD: Trouble in ReadClipboardFromFile\r\n"));
        DeleteFile(szFileName);
        }

done:

    if (sa.lpSecurityDescriptor)
        {
        GlobalFree((HGLOBAL)sa.lpSecurityDescriptor);
        }

    SyncCloseClipboard();

    return dwRet;
}



/*
 *      SaveClipboardToFile() -
 *  Parameters:
 *     hwnd - Passed to SaveClipboardData
 *     szShareName - Clipbook page name
 *     szFileName  - Filename to save to
 *     fPage - TRUE if this is a clbook page, FALSE if a file saved
 *        by the user.
 *
 *  Returns: NO_ERROR if no error occured otherwise an error code.
 *
 */

DWORD SaveClipboardToFile(
    HWND    hwnd,
    TCHAR   *szShareName,
    TCHAR   *szFileName,
    BOOL    fPage)
{
DWORD   dwErr = NO_ERROR;

    PINFO(TEXT("\r\n Entering SaveClipboardToFile\r\n"));
    if (fPage)
        {
        AddNetInfoToClipboard( szShareName );
        AddPreviewFormat();
        }

    dwErr = SaveClipboardData(hwnd, szFileName, fPage);

    if (dwErr != NO_ERROR)
        {
        /* If Failure, Delete the incomplete file */
        PERROR(TEXT("SaveClipboardData failed!"));
        DeleteFile(szSaveFileName);
        }

    return dwErr;

}



/*
 *      AddPreviewFormat
 */

BOOL AddPreviewFormat (VOID)
{
LPMETAFILEPICT  lpMF;
HANDLE          hClpData;
HANDLE          hBmpData;
HBITMAP         hBitmap;
HBITMAP         hClpBmp;
HBITMAP         hOldDstBmp;
HBITMAP         hOldSrcBmp;
BITMAP          Bitmap;
HDC             hDC;
HDC             hDstDC;
HDC             hSrcDC;
LPBYTE          lpBmp;
int             ret = FALSE;
RECT            rc;
int             OldMode;



    if (!IsClipboardFormatAvailable(CF_TEXT)         &&
        !IsClipboardFormatAvailable(CF_BITMAP)       &&
        !IsClipboardFormatAvailable(CF_METAFILEPICT) &&
        !IsClipboardFormatAvailable(CF_ENHMETAFILE)  &&
        !IsClipboardFormatAvailable(CF_UNICODETEXT))
        return FALSE;


    if ( !SyncOpenClipboard(hwndApp))
        return FALSE;


    if ( !(hBmpData = GlobalAlloc ( GHND, 64 * 64 / 8 )) )
        {
        SyncCloseClipboard();
        return FALSE;
        }


    hDC = GetDC ( hwndApp );
    hDstDC = CreateCompatibleDC ( hDC );
    hSrcDC = CreateCompatibleDC ( hDC );
    ReleaseDC ( hwndApp, hDC );

    if ( !( hBitmap = CreateBitmap ( 64, 64, 1, 1, NULL )) )
        PERROR (TEXT("CreateBitmap failed\n\r"));


    hOldDstBmp = SelectObject ( hDstDC, hBitmap );

    rc.top = rc.left = 0;
    rc.bottom = rc.right = 64;

    PatBlt ( hDstDC, 0, 0, 64, 64, WHITENESS );


    if (IsClipboardFormatAvailable(CF_ENHMETAFILE))
        {
        HENHMETAFILE hemf;
        ENHMETAHEADER enheader;

        if (hemf = (HENHMETAFILE)GetClipboardData(CF_ENHMETAFILE))
            {
            GetEnhMetaFileHeader(hemf, sizeof(enheader), &enheader);

            SaveDC(hDstDC);
            SetMapMode( hDstDC, MM_ISOTROPIC);
            SetViewportExtEx(hDstDC, 64, 64, NULL);
            SetWindowExtEx(hDstDC, enheader.rclBounds.right, enheader.rclBounds.bottom, NULL);
            PlayEnhMetaFile(hDstDC, hemf, (LPRECT)&enheader.rclBounds);
            RestoreDC(hDstDC, -1);
            }
        else
            {
            PERROR(TEXT("GetClipboardData fail on CF_ENHMETAFILE\r\n"));
            }
        }
    else if ( IsClipboardFormatAvailable ( CF_METAFILEPICT ))
        {
        if ( hClpData = GetClipboardData ( CF_METAFILEPICT ))
            {
            if ( lpMF = (LPMETAFILEPICT)GlobalLock ( hClpData ) )
                {
                SaveDC(hDstDC);
                SetMapMode( hDstDC, lpMF->mm);
                if ( lpMF->xExt >= lpMF->yExt )
                    {
                    SetViewportExtEx( hDstDC, 64,
                       (int)((64L*(LONG)lpMF->yExt)/(LONG)lpMF->xExt), NULL);
                    SetViewportOrgEx ( hDstDC, 0,
                       (64 - (int)((64L*(LONG)lpMF->yExt)/(LONG)lpMF->xExt))
                       / 2, NULL );
                    }
                else
                    {
                    SetViewportExtEx( hDstDC,
                       (int)((64L*(LONG)lpMF->xExt)/(LONG)lpMF->yExt),64, NULL);
                    SetViewportOrgEx( hDstDC,
                       ( 64 - (int)((64L*(LONG)lpMF->xExt)/(LONG)lpMF->yExt))
                       / 2, 0, NULL);
                    }
                if ( !PlayMetaFile ( hDstDC, lpMF->hMF ))
                    PERROR(TEXT("playmetafile failed\n\r"));
                GlobalUnlock ( hClpData );
                RestoreDC( hDstDC, -1 );
                }
            else
               PERROR(TEXT("couldn't LOCK it though...\n\r"));
            }
        else
           PERROR(TEXT("couldn't GET it though...\n\r"));
        }
    else if ( IsClipboardFormatAvailable ( CF_BITMAP ))
        {
        if ( hClpBmp = GetClipboardData ( CF_BITMAP ))
            {
            GetObject ( hClpBmp, sizeof(BITMAP), &Bitmap );
            hOldSrcBmp = SelectObject ( hSrcDC, hClpBmp );
            OldMode = SetStretchBltMode ( hDstDC, COLORONCOLOR);
            StretchBlt ( hDstDC, 0, 0, 64, 64,
                     hSrcDC, 0, 0, Bitmap.bmWidth, Bitmap.bmHeight,
                     SRCCOPY );
            SetStretchBltMode ( hDstDC, OldMode );
            SelectObject ( hSrcDC, hOldSrcBmp );
            }
        }
    else if ( IsClipboardFormatAvailable ( CF_TEXT ))
        {
        LPSTR lpText;
        HFONT hSmallFont, hOldFont;

        if ( hClpData = GetClipboardData ( CF_TEXT ))
            {
            lpText = (LPSTR)GlobalLock ( hClpData );
            FillRect ( hDstDC, &rc, GetStockObject ( WHITE_BRUSH ) );
            hSmallFont = CreateFont( -6,
               0, 0, 0, 400, 0, 0, 0, ANSI_CHARSET, OUT_DEFAULT_PRECIS,
               CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
               VARIABLE_PITCH | FF_SWISS, TEXT("Small Fonts")
               );
            hOldFont = SelectObject ( hDstDC, hSmallFont );
            DrawTextA( hDstDC,lpText, lstrlenA(lpText),
               &rc, DT_LEFT);
            SelectObject ( hDstDC, hOldFont );
            DeleteObject ( hSmallFont );
            GlobalUnlock ( hClpData );
            }
        }
    else if ( IsClipboardFormatAvailable (CF_UNICODETEXT))
        {
        LPWSTR lpText;
        HFONT hSmallFont, hOldFont;

        if ( hClpData = GetClipboardData ( CF_UNICODETEXT ))
            {
            lpText = (LPWSTR)GlobalLock ( hClpData );
            FillRect ( hDstDC, &rc, GetStockObject ( WHITE_BRUSH ) );
            hSmallFont = CreateFont( -6,
               0, 0, 0, 400, 0, 0, 0, ANSI_CHARSET, OUT_DEFAULT_PRECIS,
               CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
               VARIABLE_PITCH | FF_SWISS, TEXT("Small Fonts")
               );
            hOldFont = SelectObject ( hDstDC, hSmallFont );
            DrawTextW( hDstDC,lpText, lstrlenW(lpText),
               &rc, DT_LEFT);
            SelectObject ( hDstDC, hOldFont );
            DeleteObject ( hSmallFont );
            GlobalUnlock ( hClpData );
            }
        }

    SelectObject ( hDstDC, hOldDstBmp );
    DeleteDC ( hDstDC );
    DeleteDC ( hSrcDC );

    lpBmp = GlobalLock ( hBmpData );

    if ( GetBitmapBits ( hBitmap, 64 * 64 / 8, lpBmp ) != 64*64/8 )
        PERROR(TEXT("GetBitmapBits failed\n\r"));

    GlobalUnlock ( hBmpData );

    SetClipboardData ( cf_preview, hBmpData );
    ret = TRUE;

    DeleteObject ( hBitmap );
    SyncCloseClipboard();

    return ret;
}



/*
 *      AddCopiedFormat
 */

BOOL AddCopiedFormat (
    UINT    ufmtOriginal,
    UINT    ufmtCopy)
{
LPBYTE  lpOriginal;
LPBYTE  lpCopy;
HANDLE  hOriginal;
HANDLE  hCopy = NULL;
BOOL    ret = FALSE;
int     i;


    if (IsClipboardFormatAvailable(ufmtOriginal) && SyncOpenClipboard(hwndApp))
        {
        if ( hOriginal = GetClipboardData(ufmtOriginal))
            {
            if ( hCopy = GlobalAlloc( GHND, GlobalSize(hOriginal)))
                {
                if ( lpOriginal = GlobalLock(hOriginal))
                    {
                    if ( lpCopy = GlobalLock (hCopy))
                        {

                        for ( i=(int)GlobalSize(hOriginal); i--; )
                            *lpCopy++ = *lpOriginal++;
                        GlobalUnlock(hCopy);

                        #ifdef DEBUG
                         lpCopy = GlobalLock(hCopy);
                         GlobalUnlock(hCopy);
                        #endif

                        ret = ( SetClipboardData ( ufmtCopy, hCopy ) != NULL );
                        }
                    GlobalUnlock(hOriginal);
                    }
                }
            }
        SyncCloseClipboard();
        }


    if ( !ret )
        {
        PERROR(TEXT("AddCopiedFormat returning FALSE!\n\r"));
        if ( hCopy )
            GlobalFree (hCopy);
        }

    return ret;
}



/*
 *      AddNetInfoToClipboard
 */

BOOL AddNetInfoToClipboard (
    TCHAR   *szShareName )
{
HANDLE  hData;
HANDLE  hNewData;
TCHAR   szServerName[MAX_COMPUTERNAME_LENGTH + 1];
DWORD   dwNameLen;
LPTSTR  src;
LPTSTR  dst;


    cf_link           = RegisterClipboardFormat (SZLINK);
    cf_linkcopy       = RegisterClipboardFormat (SZLINKCOPY);
    cf_objectlink     = RegisterClipboardFormat (SZOBJECTLINK);
    cf_objectlinkcopy = RegisterClipboardFormat (SZOBJECTLINKCOPY);


    // check to see if this info already added:
    if (IsClipboardFormatAvailable (cf_linkcopy))
        {
        PINFO(TEXT("AddNetInfo: Already added\n\r"));
        return FALSE;
        }


    if (IsClipboardFormatAvailable (cf_link))
        {
        AddCopiedFormat (cf_link, cf_linkcopy);

        if (!SyncOpenClipboard (hwndApp))
           return (FALSE);

        dwNameLen = MAX_COMPUTERNAME_LENGTH+1;
        GetComputerName (szServerName, &dwNameLen);

        PINFO(TEXT("link data found\n\r"));


        if (hData = GetClipboardData (cf_link))
            {
            if (src = GlobalLock (hData))
                {
                // approx 20 extra chars for the   \\, \ndde$, .dde, and the 2 NULL chars
                size_t Size = GlobalSize(hData) + lstrlen (szServerName) +lstrlen (szShareName) +20;

                hNewData = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, Size);

                dst = GlobalLock (hNewData);

                StringCchPrintf (dst, Size, TEXT("\\\\%s\\%s"), szServerName, TEXT("NDDE$"));
                Size -= (lstrlen(dst) + 1);
                dst += lstrlen(dst) + 1;

                StringCchCopy ( dst, Size, szShareName );
                *dst = SHR_CHAR;
                Size -= lstrlen(dst);
                StringCchCat( dst, Size, TEXT(".dde") );
                Size -= 5;
                dst += lstrlen(dst) + 1;

                src += lstrlen(src) + 1;
                src += lstrlen(src) + 1;

                StringCchCopy ( dst, Size, src );

                GlobalUnlock (hData);
                GlobalUnlock (hNewData);

                SetClipboardData (cf_link, hNewData);
                }
            }

        SyncCloseClipboard ();
        }



    if (IsClipboardFormatAvailable (cf_objectlink))
        {
        AddCopiedFormat (cf_objectlink, cf_objectlinkcopy);

        if (!SyncOpenClipboard (hwndApp))
            return (FALSE);

        dwNameLen = MAX_COMPUTERNAME_LENGTH+1;
        GetComputerName (szServerName, &dwNameLen);

        PINFO(TEXT("objectlink data found\n\r"));

        if (hData = GetClipboardData (cf_objectlink))
            {
            if (src = GlobalLock (hData))
                {

                // approx 20 extra chars for the   \\, \ndde$, .dde, and the 2 NULL chars
                size_t Size = GlobalSize(hData) +lstrlen (szServerName) +lstrlen (szShareName) +20;

                hNewData = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, Size);

                dst = GlobalLock (hNewData);

                StringCchPrintf(dst, Size, TEXT("\\\\%s\\%s"), szServerName, TEXT("NDDE$"));
                Size -= (lstrlen(dst) + 1);
                dst  += lstrlen(dst) + 1;

                StringCchCopy (dst, Size, szShareName);
                Size -= lstrlen(szShareName);

                *dst = SHR_CHAR;
                StringCchCat (dst, Size, TEXT(".ole"));
                dst += lstrlen(dst) + 1;
                Size -= 5;

                src += lstrlen(src) + 1;
                src += lstrlen(src) + 1;

                StringCchCopy (dst, Size, src);

                GlobalUnlock (hData);
                GlobalUnlock (hNewData);

                SetClipboardData (cf_objectlink, hNewData);
                }
            }

        SyncCloseClipboard ();
        }


    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\common\debugout.h ===
/******************************************************************************

                    D E B U G   O U T P U T   H E A D E R

    Name:       debugout.h
    Date:       1/20/94
    Creator:    John Fu

    Description:
        This is the header file for debugout.h

******************************************************************************/


extern  INT     DebugLevel;
extern  BOOL    DebugFile;



VOID PERROR (LPTSTR format, ...);


VOID PINFO (LPTSTR format, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\clipview\vclpbrd.c ===
/*****************************************************************************

                        V I R T U A L   C L I P B O A R D

    Name:       vclpbrd.c
    Date:       21-Jan-1994
    Creator:    Unknown

    Description:
        This file contains the virtual clipboard routines.

    History:
        21-Jan-1994 John Fu     Reformat and cleanup
        19-Apr-1994 John Fu     Add code for DIB to BITMAP conversion.
        13-Mar-1995 John Fu     Fix code to delete clipboard formats.

*****************************************************************************/




#define   WIN31
#include <windows.h>

#include "common.h"
#include "clipbook.h"
#include "clipbrd.h"
#include "vclpbrd.h"
#include "clipdsp.h"
#include "ddeml.h"
#include "debugout.h"
#include "cvutil.h"




/*
 *      CreateVClipboard
 */

PVCLPBRD CreateVClipboard (
    HWND    hwnd)
{
PVCLPBRD p;



    if ( !( p = (PVCLPBRD)GlobalAlloc ( GPTR, sizeof(VCLPBRD) )))
        {
        PERROR(TEXT("CreateVClipboard returning 0\n\r"));
        return NULL;
        }

    p->NumFormats = 0;
    p->Head       = (PVCLPENTRY)NULL;
    p->Tail       = (PVCLPENTRY)NULL;
    p->fOpen      = FALSE;
    p->Hwnd       = hwnd;


    // PINFO(TEXT("CreateVClipboard OK\n\r"));

    return p;

}







/*
 *      DestroyVClipboard
 */

BOOL DestroyVClipboard (
    PVCLPBRD    p)
{

    if (!p)
        {
        PERROR(TEXT("DestroyVClipboard on NULL Vclipboard\n\r"));
        return FALSE;
        }

    if (VEmptyClipboard ( p ) == FALSE)
        {
        PERROR(TEXT("DestroyVClipboard: couldn't empty Vclipboard\n\r"));
        return FALSE;
        }

    if (GlobalFree ( (HGLOBAL)p ))
        {
        PERROR(TEXT("DestroyVClipboard: GlobalFree failure\n\r"));
        return FALSE;
        }


    // PINFO(TEXT("DestroyVClipboard OK\n\r"));

    return TRUE;

}





/*
 *      VCountClipboardFormats
 */

int VCountClipboardFormats (
    PVCLPBRD    p)
{
    if ( !p )
        return CountClipboardFormats();

    return p->NumFormats;
}







/*
 *      VEmptyClipboard
 */

BOOL VEmptyClipboard (
    PVCLPBRD    p)
{
PVCLPENTRY q, tmp;

    if ( !p )
        return EmptyClipboard();

    for ( q = p->Head; q; )
        {
        tmp = q->Next;

        if ( q->Data )
            switch ( q->Fmt )
                {
                case CF_BITMAP:
                case CF_DIB:
                case CF_PALETTE:
                    DeleteObject ( q->Data );
                    break;

                case CF_METAFILEPICT:
                case CF_ENHMETAFILE:
                    DeleteEnhMetaFile (q->Data);
                    break;

                default:
                    GlobalFree ( q->Data );
                }

        GlobalFree ( (HGLOBAL)q );

        q = tmp;
        }

    p->NumFormats = 0;

    return TRUE;

}






/*
 *      VEnumClipboardFormats
 */

UINT VEnumClipboardFormats(
    PVCLPBRD    p,
    UINT        Fmt)
{
PVCLPENTRY q;

    if ( !p )
        return EnumClipboardFormats ( Fmt );

    if ( !p->fOpen )
        return 0;

    if ( Fmt == 0 )
        return (p->Head)->Fmt;

    for (q = p->Head; q; q = q->Next)
        if ( q->Fmt == Fmt )
            {
            if ( q->Next )
                return q->Next->Fmt;
            else
                return 0;
            }

    return 0;

}












/*
 *      VGetClipboardData
 */

HANDLE VGetClipboardData (
    PVCLPBRD    pvclp,
    UINT        Fmt )
{
PVCLPENTRY  pEntry;
HSZ         hszFmt;
TCHAR       szFmt[CCHMAXCLPFORMAT];
HDDEDATA    hFmtData;
HANDLE      hClipData;
DWORD       dwR;



    PINFO(TEXT("VGetClpData: %ld %d, "), pvclp, Fmt);

    if ( !pvclp )
        {
        if (IsClipboardFormatAvailable( Fmt ))
            {
            hClipData = GetClipboardData ( Fmt );
            if (!hClipData)
                dwR = GetLastError();
            return hClipData;
            }
        else
            {
            PINFO(TEXT("No data on clp\r\n"));
            return NULL;
            }
        }

    if ( !pvclp->fOpen )
        {
        PERROR(TEXT("!pvclp->fOpen\r\n"));
        return NULL;
        }

    for ( pEntry = pvclp->Head; pEntry; pEntry = pEntry->Next )
        {
        if ( pEntry->Fmt == Fmt )
            {
            if ( pEntry->Data )
                {
                // PINFO(TEXT("pEntry->Data\r\n"));
                }
            else
                {
                // if (LockApp(TRUE, szGettingData ))
                //    {
                // this is the biggie...
                GetClipboardName (Fmt, szFmt, sizeof (szFmt));

                PINFO(TEXT("Asking for %s.\r\n"),szFmt);
                if (hszFmt = DdeCreateStringHandle(idInst, szFmt, 0))
                    {
                    hFmtData = MySyncXact (NULL,
                                           0L,
                                           GETMDIINFO(pvclp->Hwnd)->hVClpConv,
                                           hszFmt,
                                           MyGetFormat (szFmt, GETFORMAT_LIE),
                                           XTYP_REQUEST,
                                           LONG_SYNC_TIMEOUT,
                                           NULL);

                    if ( hFmtData )
                        {
                        PINFO(TEXT("Got it\r\n"));
                        SetClipboardFormatFromDDE(pvclp->Hwnd, Fmt, hFmtData);
                        }
                    else
                        {
                        PERROR(TEXT("REQUEST for %s failed %x\n\r"),
                               szFmt, DdeGetLastError(idInst));

                        VSetClipboardData(pvclp, Fmt, INVALID_HANDLE_VALUE);
                        // LockApp ( FALSE, szNull );
                        // MessageBoxID ( hInst, hwndApp, IDS_DATAUNAVAIL,
                        //    IDS_APPNAME, MB_OK | MB_ICONEXCLAMATION );
                        }




                    DdeFreeStringHandle(idInst, hszFmt);


                    // can't find bitmap, see if we can get it from dib

                    if (!hFmtData && Fmt == CF_BITMAP)
                        {
                        GetClipboardName (CF_DIB, szFmt, sizeof(szFmt));

                        if (hszFmt = DdeCreateStringHandle (idInst, szFmt, 0))
                             {
                             hFmtData = MySyncXact (NULL,
                                                    0L,
                                                    GETMDIINFO(pvclp->Hwnd)->hVClpConv,
                                                    hszFmt,
                                                    MyGetFormat (szFmt, GETFORMAT_LIE),
                                                    XTYP_REQUEST,
                                                    LONG_SYNC_TIMEOUT,
                                                    NULL);

                            if (hFmtData)
                                SetClipboardFormatFromDDE(pvclp->Hwnd, DDE_DIB2BITMAP, hFmtData);

                            DdeFreeStringHandle(idInst, hszFmt);
                            }
                        }



                //      }
                //  LockApp ( FALSE, szNull );
                    }
                else
                    {
                    PERROR(TEXT("app locked in vgetclipboarddata\n\r"));
                    }
                }
            break;
            }
        }



    return (pEntry ?
             (INVALID_HANDLE_VALUE == pEntry->Data? NULL: pEntry->Data):
             NULL);

}





/*
 *      VIsClipboardFormatAvailable
 */

BOOL VIsClipboardFormatAvailable (
    PVCLPBRD    p,
    UINT        Fmt )
{
PVCLPENTRY  q;


    if ( !p )
        {
        return IsClipboardFormatAvailable ( Fmt );
        }
    else
        {
        for ( q = p->Head; q; q = q->Next )
            {
            if ( q->Fmt == Fmt )
                {
                return TRUE;
                }
            }
        }

    return FALSE;

}







/*
 *      VSetClipboardData
 */

HANDLE VSetClipboardData(
    PVCLPBRD    p,
    UINT        Fmt,
    HANDLE      Data)
{
PVCLPENTRY  q;

    if ( !p )
        {
        PINFO(TEXT("Setting real clipboard data \r\n"));
        return SetClipboardData ( Fmt, Data );
        }

    if ( !p->fOpen )
        {
        PERROR(TEXT("VSetClipboardData on non-open Vclipboard\n\r"));
        return NULL;
        }

    // existing format?
    for ( q = p->Head; q; q = q->Next )
        {
        if (q->Fmt == Fmt)
            {
            if (q->Data)
                {
                switch (Fmt)
                    {
                    case CF_BITMAP:
                    case CF_DIB:
                    case CF_PALETTE:
                        DeleteObject ( q->Data );
                        break;

                    case CF_METAFILEPICT:
                    case CF_ENHMETAFILE:
                        DeleteEnhMetaFile (q->Data);
                        break;

                    default:
                        GlobalFree ( q->Data );
                    }
                }

            q->Data = Data;

            PINFO(TEXT("VSetClipboardData: set same as existing format\n\r"));
            return Data;
            }
        }



    if (!(q = (PVCLPENTRY)GlobalAlloc (GPTR, sizeof (VCLPENTRY))))
        {
        PERROR(TEXT("VSetClipboardData: GlobalAlloc failed\n\r"));
        return NULL;
        }



    q->Next = NULL;

    q->Data = Data;
    q->Fmt = Fmt;

    if ( p->Tail )
        {
        p->Tail->Next = q;
        }


    p->Tail = q;

    if ( !p->Head )
       p->Head = q;



    p->NumFormats++;
    PINFO(TEXT("VSetClipboardData: set new format w/%ldn\r"), Data);

    return Data;

}






/*
 *      VOpenClipboard
 */

BOOL VOpenClipboard(
    PVCLPBRD    p,
    HWND        hwnd)
{
    if ( !p )
       {
       return SyncOpenClipboard ( hwnd );
       }
    else if ( p->fOpen )
       {
       return FALSE;
       }
    else
       {
       p->fOpen = TRUE;
       p->Hwnd = hwnd;
       return TRUE;
       }
}







/*
 *      VCloseClipboard
 */

BOOL VCloseClipboard(
    PVCLPBRD    p)
{
    if ( !p )
        return SyncCloseClipboard();

    if ( !p->fOpen )
        return FALSE;

    p->fOpen = FALSE;
    p->Hwnd  = (HWND)0;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\common\debugout.c ===
#include    <windows.h>
#include    "debugout.h"


INT     DebugLevel = 0;
BOOL    DebugFile  = FALSE;



#if DEBUG


VOID PERROR (LPTSTR format, ...)
{
static  TCHAR buf[256];
HANDLE  hf;
DWORD   dwWritten;
va_list vaMark;


    if (DebugLevel <= 0)
        return;


    va_start(vaMark, format);

    _vsntprintf(buf, 256, format, vaMark);
    va_end(vaMark);


    OutputDebugString(buf);


    if (!DebugFile)
        return;


    hf = CreateFile (TEXT("c:\\clipsrv.out"),
                     GENERIC_WRITE,
                     0,
                     NULL,
                     OPEN_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL);

    if (hf != INVALID_HANDLE_VALUE)
        {
        SetFilePointer(hf, 0, NULL, FILE_END);
        WriteFile(hf, buf, lstrlen(buf), &dwWritten, NULL);
        CloseHandle(hf);
        }


}
#else
VOID PERROR (LPTSTR format, ...)
{
}
#endif





#ifdef DEBUG

VOID PINFO (LPTSTR format, ...)
{
static  TCHAR buf[256];
HANDLE  hf;
DWORD   dwWritten;
va_list vaMark;



    if (DebugLevel <= 1)
        return;

    va_start(vaMark, format);
    _vsntprintf(buf, 256, format, vaMark);
    va_end(vaMark);

    OutputDebugString(buf);


    if (!DebugFile)
        return;



    hf = CreateFile (TEXT("c:\\clipsrv.out"),
                     GENERIC_WRITE,
                     0,
                     NULL,
                     OPEN_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL);

    if (hf != INVALID_HANDLE_VALUE)
        {
        SetFilePointer(hf, 0, NULL, FILE_END);
        WriteFile(hf, buf, lstrlen(buf), &dwWritten, NULL);
        CloseHandle(hf);
        }

}
#else
VOID PINFO (LPTSTR format, ...)
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\common\common.h ===
/*****************************************************************************

                        C O M M O N   H E A D E R

    Name:       common.h
    Date:       19-Apr-1994
    Creator:    John Fu

    Description:
        This is the header common to clipview and datasrv.

*****************************************************************************/

#define   PREVBMPSIZ   64   // dim of preview bitmap ( x and y )

// non localized control strings common to Clipsrv.exe and clipbrd.exe
#define     SZ_SRV_NAME         "ClipSrv"
#define     SZ_FORMAT_LIST      TEXT("FormatList")

#define     SZCMD_INITSHARE     TEXT("[initshare]")
#define     SZCMD_EXIT          TEXT("[exit]")
#define     SZCMD_PASTESHARE    TEXT("[pasteshare]")
#define     SZCMD_DELETE        TEXT("[delete]")
#define     SZCMD_SHARE         TEXT("[markshared]")
#define     SZCMD_UNSHARE       TEXT("[markunshared]")
#define     SZCMD_PASTE         TEXT("[paste]")
#define     SZCMD_SAVEAS        TEXT("[saveas]")
#define     SZCMD_OPEN          TEXT("[open]")
#define     SZCMD_DEBUG         TEXT("[debug]")

#define     MAX_CMD_LEN         30
#define     MAX_DDE_EXEC        (MAX_PATH +MAX_CMD_LEN +1)



// These commands are new for NT clipbook.
///////////////////////////////////////////////////////////////////////

// Requesting for error code after an XTYP_EXECUTE xtransaction
#define     SZ_ERR_REQUEST      TEXT("ErrorRequest")

#define     XERRT_MASK          0xF0        // use to mask the XERR types
#define     XERRT_SYS           0x10        // XERR type, a GetLastError error code
#define     XERRT_NDDE          0x20        // XERR type, a NDde error code
#define     XERRT_DDE           0x30        // XERR type, a DDE error code
#define     XERR_FORMAT         "%x %x"     // XERR format string, "error_type error_code"


// Save clipbrd file in Win 3.1 format
#define     SZCMD_SAVEASOLD     TEXT("[saveasold]")


// Version request - NT product 1 clipsrv will return 0x3010
#define     SZCMD_VERSION       TEXT("[Version]")


// Security information
#define     SZCMD_SECURITY      TEXT("[Security]")

#define     SHR_CHAR            TEXT('$')
#define     UNSHR_CHAR          TEXT('*')
#define     BOGUS_CHAR          TEXT('?')

#define     SZPREVNAME          TEXT("Clipbook Preview")
#define     SZLINK              TEXT("Link")
#define     SZLINKCOPY          TEXT("LnkCpy")
#define     SZOBJECTLINK        TEXT("ObjectLink")
#define     SZOBJECTLINKCOPY    TEXT("ObjLnkCpy")
#define     LSZOBJECTLINK       L"ObjectLink"
#define     LSZLINK             L"Link"

// The viewer and the server use this mutex name to avoid opening
// the clipboard at the same time.
#define     SZMUTEXCLP          TEXT("ClipbrdMutex")



// The Common globals

extern      HINSTANCE           hInst;
extern      UINT                cf_preview;
extern      HWND                hwndApp;




// added for winball - clausgi
extern UINT cf_link;
extern UINT cf_objectlink;
extern UINT cf_linkcopy;
extern UINT cf_objectlinkcopy;

// end additions


#define PRIVATE_FORMAT(fmt) ((fmt) >= 0xC000)

#define CCHFMTNAMEMAX   79      /* Longest clipboard data fmt name, including
                                   terminator */


/* Structures for saving/loading clipboard data from disk */

#define      CLP_ID  0xC350
#define   CLP_NT_ID  0xC351
#define CLPBK_NT_ID  0xC352

typedef struct
   {
   WORD        magic;
   WORD        FormatCount;
   } FILEHEADER;


// Format header
typedef struct
   {
   DWORD FormatID;
   DWORD DataLen;
   DWORD DataOffset;
   WCHAR  Name[CCHFMTNAMEMAX];
   } FORMATHEADER;

// Windows 3.1-type structures - Win31 packed on byte boundaries.
#pragma pack(1)
typedef struct
   {
   WORD FormatID;
   DWORD DataLen;
   DWORD DataOffset;
   char Name[CCHFMTNAMEMAX];
   } OLDFORMATHEADER;

// Windows 3.1 BITMAP struct - used to save Win 3.1 .CLP files
typedef struct {
   WORD bmType;
   WORD bmWidth;
   WORD bmHeight;
   WORD bmWidthBytes;
   BYTE bmPlanes;
   BYTE bmBitsPixel;
   LPVOID bmBits;
   } WIN31BITMAP;

// Windows 3.1 METAFILEPICT struct
typedef struct {
   WORD mm;
   WORD xExt;
   WORD yExt;
   WORD hMF;
   } WIN31METAFILEPICT;

#pragma pack()





/*****************************  global data  *******************************/
extern HWND  hwndMain;
extern TCHAR szAppName[];
extern TCHAR szFileSpecifier[];

/* variables for the new File Open,File SaveAs and Find Text dialogs */

extern TCHAR  szSaveFileName [];
extern TCHAR  szLastDir  [];
extern TCHAR  szFilterSpec [];    /* default filter spec. for above  */
extern int    wHlpMsg;            /* message used to invoke Help     */
extern TCHAR  szOpenCaption [];   /* File open dialog caption text   */
extern TCHAR  szSaveCaption [];   /* File Save as dialog caption text  */





//
//  Common function prototypes that are
//  not defined in common lib
//


BOOL SyncOpenClipboard(
    HWND    hwnd);

BOOL SyncCloseClipboard(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\common\dib.h ===
/****************************************************************************
 *                                                                          *
 *  FILE        : SHOWDIB.H                                                 *
 *                                                                          *
 *  DESCRIPTION : Header/include file for ShowDIB example.                  *
 *                                                                          *
 ****************************************************************************/


// Macros to display/remove hourglass cursor for lengthy operations
#define StartWait() hcurSave = SetCursor(LoadCursor(NULL,IDC_WAIT))
#define EndWait()   SetCursor(hcurSave)


#define WIDTHBYTES(i)   ((i+31)/32*4)   // Round off to the closest byte


extern  DWORD       dwOffset;           // Current position if DIB file pointer


/***********************************************************/
/* Declarations of functions used in dib.c module          */
/***********************************************************/

WORD            PaletteSize (VOID FAR * pv);
WORD            DibNumColors (VOID FAR * pv);
HANDLE          DibFromBitmap (HBITMAP hbm, DWORD biStyle, WORD biBits, HPALETTE hpal);
HBITMAP         BitmapFromDib (HANDLE hdib, HPALETTE hpal);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\common\render.h ===
/******************************************************************************

                        R E N D E R   H E A D E R

    Name:       render.h
    Date:       1/20/94
    Creator:    John Fu

    Description:
        This is the header file for render.c

******************************************************************************/



HANDLE RenderFormat(
    FORMATHEADER    *pfmthdr,
    register HANDLE fh);


HANDLE RenderFormatDibToBitmap(
    FORMATHEADER    *pfmthdr,
    register HANDLE fh,
    HPALETTE        hPalette);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\common\dib.c ===
/*****************************************************************************
    Description:
        Handles Device Independent Bitmap.

        PaletteSize()       - Calculates the palette size in bytes
                              of given DIB

        DibNumColors()      - Determines the number of colors in DIB

        BitmapFromDib()     - Creates a DDB given a global handle to
                              a block in CF_DIB format.

        DibFromBitmap()     - Creates a DIB repr. the DDB passed in.

*****************************************************************************/

#include <windows.h>
#include "dib.h"


static   HCURSOR hcurSave;


/*
 *
 *  FUNCTION   :  PaletteSize(VOID FAR * pv)
 *
 *  PURPOSE    :  Calculates the palette size in bytes. If the info. block
 *                is of the BITMAPCOREHEADER type, the number of colors is
 *                multiplied by 3 to give the palette size, otherwise the
 *                number of colors is multiplied by 4.                                                         *
 *
 *  RETURNS    :  Palette size in number of bytes.
 *
 */

WORD PaletteSize (
    VOID FAR * pv)
{
LPBITMAPINFOHEADER  lpbi;
WORD                NumColors;

    lpbi      = (LPBITMAPINFOHEADER)pv;
    NumColors = DibNumColors(lpbi);

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
        return NumColors * sizeof(RGBTRIPLE);
    else
        return NumColors * sizeof(RGBQUAD);

}





/*
 *
 *  FUNCTION   : DibNumColors(VOID FAR * pv)
 *
 *  PURPOSE    : Determines the number of colors in the DIB by looking at
 *               the BitCount filed in the info block.
 *
 *  RETURNS    : The number of colors in the DIB.
 *
 */

WORD DibNumColors (
    VOID FAR * pv)
{
int                 bits;
LPBITMAPINFOHEADER  lpbi;
LPBITMAPCOREHEADER  lpbc;


    lpbi = ((LPBITMAPINFOHEADER)pv);
    lpbc = ((LPBITMAPCOREHEADER)pv);



    /*  With the BITMAPINFO format headers, the size of the palette
     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
     *  is dependent on the bits per pixel ( = 2 raised to the power of
     *  bits/pixel).
     */

    if (lpbi->biSize != sizeof(BITMAPCOREHEADER))
        {
        if (lpbi->biClrUsed != 0)
            return (WORD)lpbi->biClrUsed;
        bits = lpbi->biBitCount;
        }
    else
        bits = lpbc->bcBitCount;



    switch (bits)
        {
        case 1:
                return 2;
        case 4:
                return 16;
        case 8:
                return 256;
        default:
                /* A 24 bitcount DIB has no color table */
                return 0;
        }
}






/*
 *
 *  FUNCTION   : DibFromBitmap()
 *
 *  PURPOSE    : Will create a global memory block in DIB format that
 *               represents the Device-dependent bitmap (DDB) passed in.
 *
 *  RETURNS    : A handle to the DIB
 *
 */

HANDLE DibFromBitmap (
    HBITMAP     hbm,
    DWORD       biStyle,
    WORD        biBits,
    HPALETTE    hpal)
{
BITMAP               bm;
BITMAPINFOHEADER     bi;
BITMAPINFOHEADER FAR *lpbi;
DWORD                dwLen;
HANDLE               hdib;
HANDLE               h;
HDC                  hdc;



    if (!hbm)
        return NULL;


    if (hpal == NULL)
        {
        hpal = GetStockObject(DEFAULT_PALETTE);
        }


    if (!GetObject(hbm,sizeof(bm),(LPSTR)&bm))
        return NULL;


    if (biBits == 0)
        biBits = bm.bmPlanes * bm.bmBitsPixel;



    // make sure we have the right # of bits

    if (biBits <= 1)
        biBits = 1;
    else if (biBits <= 4)
        biBits = 4;
    else if (biBits <= 8)
        biBits = 8;
    else
        biBits = 24;



    bi.biSize           = sizeof(BITMAPINFOHEADER);
    bi.biWidth          = bm.bmWidth;
    bi.biHeight         = bm.bmHeight;
    bi.biPlanes         = 1;
    bi.biBitCount       = biBits;
    bi.biCompression    = biStyle;
    bi.biSizeImage      = 0;
    bi.biXPelsPerMeter  = 0;
    bi.biYPelsPerMeter  = 0;
    bi.biClrUsed        = 0;
    bi.biClrImportant   = 0;

    dwLen  = bi.biSize + PaletteSize (&bi);




    hdc = GetDC(NULL);

    hpal = SelectPalette (hdc, hpal, FALSE);
    RealizePalette (hdc);



    hdib = GlobalAlloc (GHND, dwLen);

    if (!hdib)
        {
        SelectPalette (hdc,hpal,FALSE);
        ReleaseDC (NULL,hdc);
        return NULL;
        }




    lpbi = (VOID FAR *)GlobalLock(hdib);
    *lpbi = bi;




    /*  call GetDIBits with a NULL lpBits param, so it will calculate the
     *  biSizeImage field for us
     */

    GetDIBits (hdc,
               hbm,
               0,
               (WORD)bi.biHeight,
               NULL,
               (LPBITMAPINFO)lpbi,
               DIB_RGB_COLORS);


    bi = *lpbi;
    GlobalUnlock(hdib);





    // If the driver did not fill in the biSizeImage field, make one up

    if (bi.biSizeImage == 0)
        {
        bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight;

        if (biStyle != BI_RGB)
            bi.biSizeImage = (bi.biSizeImage * 3) / 2;
        }




    // realloc the buffer big enough to hold all the bits

    dwLen = bi.biSize + PaletteSize(&bi) + bi.biSizeImage;

    if (h = GlobalReAlloc (hdib,dwLen,0))
        hdib = h;
    else
        {
        GlobalFree(hdib);
        hdib = NULL;

        SelectPalette(hdc,hpal,FALSE);
        ReleaseDC(NULL,hdc);
        return hdib;
        }




    /*  call GetDIBits with a NON-NULL lpBits param, and actualy get the
     *  bits this time
     */

    lpbi = (VOID FAR *)GlobalLock(hdib);

    if (0 == GetDIBits (hdc,
                        hbm,
                        0,
                        (WORD)bi.biHeight,
                        (LPSTR)lpbi + (WORD)lpbi->biSize + PaletteSize(lpbi),
                        (LPBITMAPINFO)lpbi,
                        DIB_RGB_COLORS))
        {
        GlobalUnlock (hdib);
        hdib = NULL;
        SelectPalette (hdc, hpal, FALSE);
        ReleaseDC (NULL, hdc);
        return NULL;
        }


    bi = *lpbi;
    GlobalUnlock (hdib);


    SelectPalette (hdc, hpal, FALSE);

    ReleaseDC (NULL, hdc);

    return hdib;

}








/*
 *
 *  FUNCTION   : BitmapFromDib(HANDLE hdib, HPALETTE hpal)
 *
 *  PURPOSE    : Will create a DDB (Device Dependent Bitmap) given a global
 *               handle to a memory block in CF_DIB format
 *
 *  RETURNS    : A handle to the DDB.
 *
 */

HBITMAP BitmapFromDib (
    HANDLE      hdib,
    HPALETTE    hpal)
{
LPBITMAPINFOHEADER  lpbi;
HPALETTE            hpalT;
HDC                 hdc;
HBITMAP             hbm = NULL;



    StartWait();


    if (!hdib)
        goto done;


    lpbi = (VOID FAR *)GlobalLock (hdib);
    if (!lpbi)
        goto done;



    hdc = GetDC (NULL);

    if (hpal)
        {
        hpalT = SelectPalette (hdc, hpal, FALSE);
        RealizePalette (hdc);
        }

    hbm = CreateDIBitmap (hdc,
                          (LPBITMAPINFOHEADER)lpbi,
                          (LONG)CBM_INIT,
                          (LPSTR)lpbi + lpbi->biSize + PaletteSize(lpbi),
                          (LPBITMAPINFO)lpbi,
                          DIB_RGB_COLORS);


    if (hpal)
        SelectPalette (hdc, hpalT, FALSE);


    ReleaseDC (NULL, hdc);
    GlobalUnlock (hdib);


done:

    EndWait();

    return hbm;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\common\security.h ===
/******************************************************************************

                        S E C U R I T Y   H E A D E R

    Name:       security.h
    Date:       1/20/94
    Creator:    John Fu

    Description:
        This is the header file for shares.c

******************************************************************************/




BOOL GetTokenHandle(
    PHANDLE pTokenHandle);


PSECURITY_DESCRIPTOR MakeLocalOnlySD (void);


PSECURITY_DESCRIPTOR CurrentUserOnlySD (void);




#ifdef DEBUG

void HexDumpBytes(
    char        *pv,
    unsigned    cb);


void PrintSid(
    PSID    sid);


void PrintAcl(
    PACL    pacl);


void PrintSD(
    PSECURITY_DESCRIPTOR    pSD);


#else

#define HexDumpBytes(x,y)
#define PrintSid(x)
#define PrintAcl(x)
#define PrintSD(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\datasrv\callback.h ===
/******************************************************************************

                        D D E   C A L L B A C K   H E A D E R

    Name:       callback.h
    Date:       1/20/94
    Creator:    John Fu

    Description:
        This is the header file for callback.c

******************************************************************************/


extern  TCHAR   szInitShareCmd[];
extern  TCHAR   szExitCmd[];
extern  TCHAR   szPasteShareCmd[];
extern  TCHAR   szDelShareCmd[];
extern  TCHAR   szMarkSharedCmd[];
extern  TCHAR   szMarkUnSharedCmd[];
extern  TCHAR   szKeepCmd[];
extern  TCHAR   szSaveAsCmd[];
extern  TCHAR   szSaveAsOldCmd[];
extern  TCHAR   szOpenCmd[];
extern  TCHAR   szDebugCmd[];
extern  TCHAR   szVersionCmd[];
extern  TCHAR   szSecurityCmd[];
extern  TCHAR   szDebug[];
extern  TCHAR   szVer[];


extern  TCHAR   szSection[];
extern  TCHAR   szClipviewRoot[];
extern  TCHAR   szRegClass[];

extern  HSZ     hszSysTopic;
extern  HSZ     hszTopicList;
extern  HSZ     hszFormatList;




LONG MakeTheRegKey(
    PHKEY   phkey,
    REGSAM  regsam);


int lstrncmp(
    LPTSTR  s1,
    LPTSTR  s2,
    WORD    count);


DWORD   GetConvErr(
    HCONV   hConv);


DWORD   GetXactErrType(
    HCONV   hConv);


VOID    SetXactErr(
    HCONV   hConv,
    DWORD   dwType,
    DWORD   dwErr);


HDDEDATA EXPENTRY DdeCallback(
    WORD        wType,
    WORD        wFmt,
    HCONV       hConv,
    HSZ         hszTopic,
    HSZ         hszItem,
    HDDEDATA    hData,
    DWORD       lData1,
    DWORD       lData2);


BOOL IsSupportedTopic(
    HSZ hszTopic);


BOOL CleanUpShares(void);


BOOL InitShares(void);


HDDEDATA GetFormat(
    HCONV   hConv,
    HSZ     hszTopic,
    HSZ     hszItem);


BOOL DelShare(
    HCONV   hConv,
    TCHAR   *pszName);


BOOL AddRecord(
    LPTSTR  lpszName,
    LPTSTR  lpszFileName,
    ULONG   siflags);


DWORD AddShare(
    LPTSTR  pszName,
    WORD    flags);



VOID DumpShares(void);


BOOL MarkShare(
    TCHAR   *pszName,
    WORD    flags);


void Hszize(void);


void UnHszize(void);


DWORD GetRandShareFileName(
    LPTSTR  buf);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\common\render.c ===
#include    <windows.h>
#include    "common.h"
#include    "clipfile.h"
#include    "render.h"
#include    "debugout.h"
#include    "dib.h"



/*
 *      RenderFormat() -
 *
 *  Read the data from fh and SetClipboardData() with it.
 */

HANDLE RenderFormat(
    FORMATHEADER    *pfmthdr,
    register HANDLE fh)
{
HANDLE            hBitmap;
register HANDLE   hData;
LPSTR             lpData;
DWORD             MetaOffset;     /* special case hack for metafiles */
BITMAP            bitmap;
HPALETTE          hPalette;
LPLOGPALETTE      lpLogPalette;
DWORD             dwBytesRead;
DWORD             dwDataOffset;

    if (PRIVATE_FORMAT(pfmthdr->FormatID))
       pfmthdr->FormatID = RegisterClipboardFormatW(pfmthdr->Name);


    // Special case hack for metafiles to get hData referencing
    // the metafile bits, not the METAFILEPICT structure.


    switch (pfmthdr->FormatID)
        {
        case CF_METAFILEPICT:
            if (!fNTReadFileFormat)
               {
               MetaOffset = sizeof(WIN31METAFILEPICT);
               }
            else
               {
               MetaOffset = sizeof(METAFILEPICT);
               }
            break;
        case CF_BITMAP:
            if (!fNTReadFileFormat)
               {
               MetaOffset = sizeof(WIN31BITMAP);
               }
            else
               {
               MetaOffset = sizeof(BITMAP);
               }
            break;
        default:
            MetaOffset = 0;
            break;
        }



    if (!(hData = GlobalAlloc(GHND, pfmthdr->DataLen - MetaOffset)))
        {
        PERROR(TEXT("GlobalAlloc failure in RenderFormat\n\r"));
        return NULL;
        }


    if (!(lpData = GlobalLock(hData)))
        {
        PERROR(TEXT("GlobalLock failure in RenderFormat\n\r"));
        GlobalFree(hData);
        return NULL;
        }



    dwDataOffset = pfmthdr->DataOffset + MetaOffset;

    PINFO("Getting data for %ws at offset %ld\r\n",pfmthdr->Name, dwDataOffset);
    SetFilePointer(fh, dwDataOffset, NULL, FILE_BEGIN);

    ReadFile (fh, lpData, pfmthdr->DataLen - MetaOffset, &dwBytesRead, NULL);

    if(pfmthdr->DataLen - MetaOffset != dwBytesRead)
         {
         // Error in reading the file
         GlobalUnlock(hData);
         GlobalFree(hData);
         PERROR(TEXT("RenderFormat: Read err, expected %d bytes, got %d\r\n"),
               pfmthdr->DataLen - MetaOffset, dwBytesRead);
         return (NULL);
         }

    // As when we write these, we have to special case a few of them
    // This code and the write code should match in terms of the sizes
    // and positions of data blocks being written out.
    // EVERY case in this switch should have a GlobalUnlock(hData);
    // statement. We go in with the block locked, but should come
    // out with the block unlocked.

    switch (pfmthdr->FormatID)
        {
        case CF_ENHMETAFILE:
           {
           HENHMETAFILE hemf;

           hemf = SetEnhMetaFileBits(pfmthdr->DataLen, lpData);

           GlobalUnlock(hData);
           GlobalFree(hData);
           hData = hemf;
           break;
           }

        case CF_METAFILEPICT:
           {
           HANDLE            hMF;
           HANDLE            hMFP;
           LPMETAFILEPICT    lpMFP;

           /* Create the METAFILE with the bits we read in. */
           hMF = SetMetaFileBitsEx(pfmthdr->DataLen, lpData);
           GlobalUnlock(hData);
           GlobalFree(hData);
           hData = NULL;

           if (hMF)
              {
              /* Alloc a METAFILEPICT header. */

              if (hMFP = GlobalAlloc(GHND, (DWORD)sizeof(METAFILEPICT)))
                 {
                 if (!(lpMFP = (LPMETAFILEPICT)GlobalLock(hMFP)))
                    {
                    GlobalFree(hMFP);
                    }
                 else
                    {
                    /* Reposition to the start of the METAFILEPICT header. */
                    SetFilePointer(fh, pfmthdr->DataOffset, NULL, FILE_BEGIN);

                    /* Read in the data */
                    if (fNTReadFileFormat)
                       {
                       ReadFile(fh, lpMFP, sizeof(METAFILEPICT),
                             &dwBytesRead, NULL);
                       }
                    else
                       {
                       WIN31METAFILEPICT w31mfp;

                       ReadFile(fh, &w31mfp, sizeof(w31mfp), &dwBytesRead, NULL);
                       if (sizeof(w31mfp) == dwBytesRead)
                          {
                          lpMFP->mm = w31mfp.mm;
                          lpMFP->xExt = w31mfp.xExt;
                          lpMFP->yExt = w31mfp.yExt;
                          }
                       }

                    lpMFP->hMF = hMF;         /* Update the METAFILE handle  */
                    GlobalUnlock(hMFP);       /* Unlock the header           */
                    hData = hMFP;             /* Stuff this in the clipboard */
                    }
                 }
              }
           break;
           }

        case CF_BITMAP:
           // Reposition to the start of the METAFILEPICT header.
           SetFilePointer(fh, pfmthdr->DataOffset, NULL, FILE_BEGIN);


           /* Read in the BITMAP struct */
           if (fNTReadFileFormat)
              {
              if (!ReadFile(fh, &bitmap, sizeof(BITMAP), &dwBytesRead, NULL))
                  memset(&bitmap, 0, sizeof(bitmap));
              }
           else
              {
              // Read in an old-style BITMAP struct, and set the fields
              // of the new-style BITMAP from that.
              WIN31BITMAP w31bm;
              if (ReadFile(fh, &w31bm, sizeof(w31bm), &dwBytesRead, NULL))
              {

                  bitmap.bmType       = w31bm.bmType;
                  bitmap.bmWidth      = w31bm.bmWidth;
                  bitmap.bmHeight     = w31bm.bmHeight;
                  bitmap.bmWidthBytes = w31bm.bmWidthBytes;
                  bitmap.bmPlanes     = w31bm.bmPlanes;
                  bitmap.bmBitsPixel  = w31bm.bmBitsPixel;
              }
              else
              {
                  memset(&bitmap, 0, sizeof(bitmap));
              }
              }

           // Set the bmBits member of the BITMAP to point to our existing
           // bits and make the bitmap.
           bitmap.bmBits = lpData;
           hBitmap = CreateBitmapIndirect(&bitmap);

           // Dump the original data (which was just the bitmap bits) and
           // make the bitmap handle our data handle.
           GlobalUnlock(hData);
           GlobalFree(hData);
           hData = hBitmap;       // Stuff this in the clipboard
           break;

        case CF_PALETTE:
           lpLogPalette = (LPLOGPALETTE)lpData;

           hPalette = CreatePalette(lpLogPalette);

           GlobalUnlock(hData);
           GlobalFree(hData);

           hData = hPalette;
           break;

        default:
           GlobalUnlock(hData);
           break;
        }


    return(hData);

}




HANDLE RenderFormatDibToBitmap(
    FORMATHEADER    *pfmthdr,
    register HANDLE fh,
    HPALETTE        hPalette)
{
HANDLE            hBitmap;
register HANDLE   hData;
LPSTR             lpData;
DWORD             dwBytesRead;
DWORD             dwDataOffset;



    if (PRIVATE_FORMAT(pfmthdr->FormatID))
        pfmthdr->FormatID = RegisterClipboardFormatW(pfmthdr->Name);


    if (!(hData = GlobalAlloc(GHND, pfmthdr->DataLen)))
        {
        PERROR(TEXT("GlobalAlloc failure in RenderFormat\n\r"));
        return NULL;
        }


    if (!(lpData = GlobalLock(hData)))
        {
        PERROR(TEXT("GlobalLock failure in RenderFormat\n\r"));
        GlobalFree(hData);
        return NULL;
        }



    dwDataOffset = pfmthdr->DataOffset;

    PINFO("Getting data for %ws at offset %ld\r\n",pfmthdr->Name, dwDataOffset);
    SetFilePointer(fh, dwDataOffset, NULL, FILE_BEGIN);

    ReadFile (fh, lpData, pfmthdr->DataLen, &dwBytesRead, NULL);

    if(pfmthdr->DataLen != dwBytesRead)
        {
        // Error in reading the file
        GlobalUnlock(hData);
        GlobalFree(hData);

        PERROR (TEXT("RenderFormat: Read err, expected %d bytes, got %d\r\n"),
                pfmthdr->DataLen, dwBytesRead);
        return (NULL);
        }


    GlobalUnlock(hData);

    hBitmap = BitmapFromDib (hData, hPalette);

    GlobalFree (hData);


    return (hBitmap);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\datasrv\callback.c ===
#include    <windows.h>
#include    <nddeapi.h>
#include    <nddesec.h>
#include    <string.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <memory.h>
#include    <assert.h>
#include    <ddeml.h>
#include    <strsafe.h>

#include    "common.h"
#include    "clipsrv.h"
#include    "clipfile.h"
#include    "ddeutil.h"
#include    "callback.h"
#include    "debugout.h"



#define AUTOUPDATE
#define ASKED_FOR_LINK 1
#define ASKED_FOR_OBJECTLINK 2

#define MAX_XERR    128         // maximum number of XERRs we'll store
#define XERR_INUSE  1


typedef struct _XERR            // struct for Xaction ERRor
    {
    HCONV       hConv;          // the conversation handle
    DWORD       dwErr;          // the error code
    DWORD       dwUse;          // usage, when & with XERR_MASK gives type,
    }                           //    bit 1 is set when if struct is in use.
    XERR, *PXERR;


XERR    gXactErr[MAX_XERR];
TCHAR   gszXactErrStr[30];


TCHAR szInitShareCmd[]      = SZCMD_INITSHARE;
TCHAR szExitCmd[]           = SZCMD_EXIT;
TCHAR szPasteShareCmd[]     = SZCMD_PASTESHARE;
TCHAR szDelShareCmd[]       = SZCMD_DELETE;
TCHAR szMarkSharedCmd[]     = SZCMD_SHARE;
TCHAR szMarkUnSharedCmd[]   = SZCMD_UNSHARE;
TCHAR szKeepCmd[]           = SZCMD_PASTE;
TCHAR szSaveAsCmd[]         = SZCMD_SAVEAS;
TCHAR szSaveAsOldCmd[]      = SZCMD_SAVEASOLD;
TCHAR szOpenCmd[]           = SZCMD_OPEN;
TCHAR szDebugCmd[]          = SZCMD_DEBUG;
TCHAR szVersionCmd[]        = SZCMD_VERSION;
TCHAR szSecurityCmd[]       = SZCMD_SECURITY;
TCHAR szDebug[]             = TEXT("Debug");
TCHAR szVer[]               = TEXT("1.1"); // need to be able to
                                           // handle Uni or Ansi req's for this

TCHAR szSection[]           = TEXT("Software\\Microsoft\\Clipbook Server");
TCHAR szClipviewRoot[]      = TEXT("Software\\Microsoft\\Clipbook");
TCHAR szRegClass[]          = TEXT("Config");

HSZ hszSysTopic;
HSZ hszTopicList;
HSZ hszFormatList;
HSZ hszErrorRequest;




/*
 *      MakeTheRegKey
 *
 *  Purpose: Open the usual key (the one named by szSection) with the
 *     specified access.
 *
 *  Parameters:
 *     phkey - Pointer to the HKEY to fill
 *     regsam - The access types, same as RegCreateKeyEx
 *
 *  Returns:
 *     ERROR_SUCCESS on success, whatever RegOpenKeyEx returns on fail.
 */

LONG MakeTheRegKey(
    PHKEY   phkey,
    REGSAM  regsam)
{
DWORD   dwR;
DWORD   dwIck;


    dwR = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                          szSection,
                          0,
                          szRegClass,
                          REG_OPTION_NON_VOLATILE,
                          regsam,
                          NULL,
                          phkey,
                          &dwIck);

    if (dwR == ERROR_SUCCESS)
       {
       return ERROR_SUCCESS;
       }


    dwR = RegOpenKeyEx (HKEY_LOCAL_MACHINE, szSection, 0, regsam, phkey);

    if (dwR == ERROR_SUCCESS)
       {
       return ERROR_SUCCESS;
       }

    PERROR(TEXT("Couldn't regopen %s with %lx access - #%lx\r\n"), szSection, (long)regsam, dwR);

    return dwR;
}




/*
 *      lstrncmp
 */

int lstrncmp(
    LPTSTR  s1,
    LPTSTR  s2,
    WORD    count )
{
unsigned i;
register TCHAR tch1;
register TCHAR tch2;

    for (i = 0; i < (unsigned)count; i++)
        {
        if ( (tch1 = *s1++) != (tch2 = *s2++) )
            {
            if (tch1 < tch2)
                return -1;
            else
                return 1;
            }
        }

    return 0;

}




/*
 *      AddXactErr
 *
 *  To add a XERR record for hConv.  Called
 *  when XTYP_CONNECT_CONFIRM.
 */

static VOID    AddXactErr(
    HCONV   hConv)
{
INT i;


    for (i=0; i<MAX_XERR; i++)
        if (!(gXactErr[i].dwUse & XERR_INUSE))
            {
            gXactErr[i].hConv = hConv;
            gXactErr[i].dwErr = 0;
            gXactErr[i].dwUse = XERR_INUSE;

            return;
            }
}



/*
 *      DelXactErr
 *
 *  To delete a XERR record for hConv.
 *  Called at XTYP_DISCONNECT.
 */

static VOID    DelXactErr(
    HCONV   hConv)
{
INT i;

    for (i=0; i<MAX_XERR; i++)
        if ((gXactErr[i].dwUse & XERR_INUSE) && gXactErr[i].hConv == hConv)
            {
            gXactErr[i].dwUse = 0;
            return;
            }
}



/*
 *      GetXactErr
 *
 *  Returns the XERR error code associated with hConv.
 */

DWORD   GetXactErr(
    HCONV   hConv)
{
INT i;

    for (i=0; i<MAX_XERR; i++)
        if ((gXactErr[i].dwUse & XERR_INUSE) && gXactErr[i].hConv == hConv)
            return gXactErr[i].dwErr;

    return 0L;
}



/*
 *      GetXactErrType
 *
 *  Returns the XERR error type associated with hConv.
 */

DWORD   GetXactErrType(
    HCONV   hConv)
{
INT i;

    for (i=0; i<MAX_XERR; i++)
        if ((gXactErr[i].dwUse & XERR_INUSE) && gXactErr[i].hConv == hConv)
            return gXactErr[i].dwUse & XERRT_MASK;

    return 0L;
}



/*
 *      SetXactErr
 *
 *  Sets XERR for hConv.
 *  dwType specifies type, this should be one of the XERRT_ defines.
 *  dwErr specifies error code.
 */

VOID    SetXactErr(
    HCONV   hConv,
    DWORD   dwType,
    DWORD   dwErr)
{
INT     i;

    for (i=0; i<MAX_XERR; i++)
        if ((gXactErr[i].dwUse & XERR_INUSE) && gXactErr[i].hConv == hConv)
            {
            gXactErr[i].dwErr = dwErr;
            gXactErr[i].dwUse = (gXactErr[i].dwUse & ~XERRT_MASK) | dwType;
            return;
            }
}



/*
 *      DdeCallback
 */

HDDEDATA EXPENTRY DdeCallback(
    WORD        wType,
    WORD        wFmt,
    HCONV       hConv,
    HSZ         hszTopic,
    HSZ         hszItem,
    HDDEDATA    hData,
    DWORD       lData1,
    DWORD       lData2)
{
HDDEDATA    hDDEtmp = 0L;
UINT        uiErr;


    PINFO(TEXT("\n>>>> DdeCallback\n"));

    if (!(wType & XCLASS_NOTIFICATION))
        {
        PINFO(TEXT("Impersonating\n"));
        DdeImpersonateClient(hConv);
        }


    switch ( wType )
        {
        case XTYP_CONNECT_CONFIRM:

            PINFO (TEXT("XTYP_CONNECT_CONFIRM\n"));

            AddXactErr (hConv);
            PINFO(TEXT("Confirming connect\r\n"));
            hDDEtmp = (HDDEDATA)TRUE;
            break;


        case XTYP_EXECUTE:

            PINFO (TEXT("XTYP_EXECUTE\n"));

            // no error yet
            SetXactErr (hConv, 0, 0);


            // We only take executes on the System topic.
            // And only in Unicode or CF_TEXT format.

            if ((wFmt == CF_TEXT || wFmt == CF_UNICODETEXT) &&
                DdeCmpStringHandles ( hszTopic, hszSysTopic ) )
                {
                PERROR(TEXT("XTYP_EXECUTE received on non-system topic\n\r"));
                hDDEtmp = (HDDEDATA)DDE_FNOTPROCESSED;

                break;
                }

            DdeGetData(hData, (LPBYTE)szExec, MAX_EXEC, 0);
            szExec[MAX_EXEC - 1] = '\0';

            hDDEtmp = DDE_FNOTPROCESSED;


            if (!lstrcmp (szExec, szInitShareCmd))
                {
                InitShares();
                hDDEtmp = (HDDEDATA)DDE_FACK;
                }
            else if (!lstrncmp (szExec, szKeepCmd, (WORD)lstrlen(szKeepCmd)))
                {
                DWORD dwErr;

                dwErr = AddShare ( szExec + lstrlen(szKeepCmd ), 0);
                if (dwErr != NO_ERROR)
                    SetXactErr (hConv, XERRT_SYS, dwErr);
                else
                    hDDEtmp = (HDDEDATA)DDE_FACK;
                }
            else if (!lstrncmp (szExec, szVersionCmd, (WORD)lstrlen(szVersionCmd)))
                {
                hDDEtmp = DdeCreateDataHandle(idInst, szVer, sizeof(szVer) + 1, 0, 0L, wFmt, 0L);
                }
            else if (!lstrncmp( szExec, szSaveAsCmd, (WORD)lstrlen(szSaveAsCmd)))
                {
                DWORD dwErr;

                fNTSaveFileFormat = TRUE;

                dwErr = SaveClipboardToFile (hwndApp, NULL, szExec + lstrlen(szSaveAsCmd ), FALSE);
                if (dwErr != NO_ERROR)
                    SetXactErr (hConv, XERRT_SYS, dwErr);
                else
                    hDDEtmp = (HDDEDATA)DDE_FACK;
                }
            else if (!lstrncmp (szExec, szSaveAsOldCmd, (WORD)lstrlen(szSaveAsOldCmd)))
                {
                DWORD dwErr;

                fNTSaveFileFormat = FALSE;

                dwErr = SaveClipboardToFile(hwndApp, NULL, szExec + lstrlen(szSaveAsOldCmd), FALSE);
                if (dwErr != NO_ERROR)
                    SetXactErr (hConv, XERRT_SYS, dwErr);
                else
                    hDDEtmp = (HDDEDATA)DDE_FACK;
                }
            else if (!lstrncmp (szExec, szOpenCmd, (WORD)lstrlen(szOpenCmd )) )
                {
                DWORD dwErr;

                dwErr = OpenClipboardFile(hwndApp, szExec + lstrlen(szOpenCmd));
                if (dwErr != NO_ERROR)
                    SetXactErr (hConv, XERRT_SYS, dwErr);
                else
                    hDDEtmp = (HDDEDATA)DDE_FACK;
                }
            else if (!lstrncmp (szExec, szDelShareCmd, (WORD)lstrlen(szDelShareCmd)))
                {
                PINFO(TEXT("Deleting %s\n\r"), (LPSTR)szExec + lstrlen(szDelShareCmd));

                if (DelShare ( hConv, szExec + lstrlen(szDelShareCmd) ))
                    {
                    hDDEtmp = (HDDEDATA)DDE_FACK;
                    }
                }
            else if (!lstrncmp (szExec,szMarkSharedCmd, (WORD)lstrlen(szMarkSharedCmd)))
                {
                PINFO(TEXT("Marking %s as shared\n\r"), (LPSTR)szExec + lstrlen(szMarkSharedCmd));

                if ( MarkShare (szExec + lstrlen(szMarkSharedCmd), SIF_SHARED ))
                    {
                    hDDEtmp = (HDDEDATA)DDE_FACK;
                    }
                }
            else if (!lstrncmp(szExec,szMarkUnSharedCmd, (WORD)lstrlen(szMarkUnSharedCmd)))
                {
                if ( MarkShare ( szExec + lstrlen(szMarkUnSharedCmd ), 0 ))
                    {
                    hDDEtmp = (HDDEDATA)DDE_FACK;
                    }
                }

            #if DEBUG
            else if (!lstrncmp(szExec,szDebugCmd, (WORD)lstrlen(szDebugCmd)))
                {
                DumpShares();
                hDDEtmp = (HDDEDATA)DDE_FACK;
                }
            #endif
            else
                {
                PERROR(TEXT("Invalid execute\r\n"));
                hDDEtmp = (HDDEDATA)DDE_FNOTPROCESSED;
                }

            break;

        case XTYP_DISCONNECT:

            PINFO (TEXT("XTYP_DISCONNECT\n"));

            DelXactErr (hConv);
            break;

        case XTYP_CONNECT:

            PINFO (TEXT("XTYP_CONNECT\n"));

            hDDEtmp = (HDDEDATA)FALSE;

            if ( IsSupportedTopic( hszTopic ) )
                {
                if (!DdeKeepStringHandle (idInst, hszAppName))
                    {
                    PERROR(TEXT("DdeKSHandle fail in DdeCB\r\n"));
                    }
                hDDEtmp = (HDDEDATA)TRUE;
                }
            #if DEBUG
            else
                {
                TCHAR buf[128];
                DdeQueryString ( idInst, hszTopic, buf, 128, CP_WINANSI );
                PERROR(TEXT("ClipSRV: Unsupported topic %s requested\n\r"), (LPSTR)buf );
                }
            #endif

            break;


        case XTYP_ADVREQ:
        case XTYP_REQUEST:

            // must be a valid topic
            {
            TCHAR atch[128];

            PINFO (wType==XTYP_ADVREQ?
                     TEXT("XTYP_ADVREQ\n"): TEXT("XTYP_REQUEST\n"));

            DdeQueryString(idInst, hszTopic, atch, 128, CP_WINANSI);
            PINFO(TEXT("Topic = %s, "), atch);
            DdeQueryString(idInst, hszItem, atch, 128, CP_WINANSI);
            PINFO(TEXT("item = %s\r\n"), atch);
            }

            if (!IsSupportedTopic ( hszTopic ))
                {
                #if DEBUG
                TCHAR buf[128];
                DdeQueryString ( idInst, hszTopic, buf, 128, CP_WINANSI );
                PERROR(TEXT("Topic %s unsupported!\n\r"), (LPTSTR)buf );
                #endif

                hDDEtmp = (HDDEDATA)0;
                }
            else
                {
                PINFO("System topic request\r\n");

                if (!DdeCmpStringHandles (hszTopic, hszSysTopic))
                    {
                    if (!DdeCmpStringHandles (hszItem,  hszErrorRequest))
                        {
                        StringCchPrintf (gszXactErrStr, 30,
                                 XERR_FORMAT,
                                 GetXactErrType (hConv),
                                 GetXactErr (hConv));

                        hDDEtmp = DdeCreateDataHandle (idInst,
                                                       gszXactErrStr,
                                                       lstrlen(gszXactErrStr)+sizeof(CHAR),
                                                       0,
                                                       hszErrorRequest,
                                                       wFmt,
                                                       0);

                        uiErr = DdeGetLastError (idInst);
                        }
                    else if (!DdeCmpStringHandles (hszItem, hszTopicList))
                        {
                        PINFO(TEXT("Topic list requested\r\n"));

                        SetXactErr (hConv, 0, 0);

                        if (CF_TEXT == wFmt)
                            {
                            hDDEtmp = (HDDEDATA)GetTopicListA(hConv, TRUE);
                            }
                        else if (CF_UNICODETEXT == wFmt)
                            {
                            hDDEtmp = (HDDEDATA)GetTopicListW(hConv, TRUE);
                            }
                        else // Can't get the topiclist in anything but CF_TEXT or UNICODE
                            {
                            PERROR(TEXT("ClSrv\\DdeCB: Client asked for topics in bad fmt\r\n"));
                            hDDEtmp = (HDDEDATA)0;
                            }
                        }
                    else
                        {
                        #if DEBUG
                        TCHAR rgtch[128];

                        DdeQueryString(idInst, hszItem,rgtch, 128, CP_WINANSI);
                        PERROR(TEXT("item %s requested under system\n\r"), rgtch);
                        #endif
                        hDDEtmp = (HDDEDATA)0;
                        }
                    }
                else
                    {
                    // all other topics are assumed clipboard shares!!!

                    // Is format list the requested item?
                    if (!DdeCmpStringHandles (hszItem,  hszErrorRequest))
                        {
                        StringCchPrintf (gszXactErrStr, 30, 
                                 XERR_FORMAT,
                                 GetXactErrType (hConv),
                                 GetXactErr (hConv));

                        hDDEtmp = DdeCreateDataHandle (idInst,
                                                       gszXactErrStr,
                                                       lstrlen(gszXactErrStr)+sizeof(CHAR),
                                                       0,
                                                       hszErrorRequest,
                                                       wFmt,
                                                       0);

                        uiErr = DdeGetLastError (idInst);
                        }
                    else if (!DdeCmpStringHandles (hszItem, hszFormatList))
                        {
                        PINFO(TEXT("Getting format list\r\n"));

                        SetXactErr (hConv, 0, 0);

                        if (CF_TEXT == wFmt)
                            {
                            hDDEtmp = (HDDEDATA)GetFormatListA(hConv, hszTopic);
                            }
                        else
                            {
                            hDDEtmp = (HDDEDATA)GetFormatListW(hConv, hszTopic);
                            }
                        }
                    else
                        {   // request for specific format, or invalid
                        SetXactErr (hConv, 0, 0);
                        hDDEtmp = GetFormat ( hConv, hszTopic, hszItem );
                        }
                    }
                }
            break;


        case XTYP_ADVSTART:

            PINFO (TEXT("XTYP_ADVSTART\n"));

            if (0 == DdeCmpStringHandles(hszItem, hszTopicList) &&
                0 == DdeCmpStringHandles(hszTopic, hszSysTopic))
                {
                PINFO(TEXT("Advise on topiclist OK\r\n"));
                hDDEtmp = (HDDEDATA)TRUE;
                }
            else
                {
                PERROR(TEXT("Advise loop requested on item other than topiclist\n\r"));
                hDDEtmp = (HDDEDATA)FALSE;
                }
            break;

        default:

            PINFO (TEXT("unknown wType %#x\n"), wType);
            break;
        }


    if (!(wType & XCLASS_NOTIFICATION))
        {
        RevertToSelf();
        }


    if (0L == hDDEtmp)
        {
        TCHAR atch[128];

        DdeQueryString(idInst, hszTopic, atch, 128, CP_WINANSI);
        PINFO(TEXT("Topic was %s, "), atch);
        DdeQueryString(idInst, hszItem, atch, 128, CP_WINANSI);
        PINFO(TEXT("item was %s\r\n"), atch);
        }

    PINFO(TEXT("Return %#x\n"), hDDEtmp);
    PINFO(TEXT("<<<< DdeCallback\n\n"));

    return hDDEtmp;
}




/*
 *      IsSupportedTopic
 */

BOOL IsSupportedTopic ( HSZ hszTopic )
{
pShrInfo p;

    if ( !DdeCmpStringHandles (hszTopic, hszSysTopic))
        {
        DdeKeepStringHandle ( idInst, hszTopic );
        return TRUE;
        }

    for ( p = SIHead; p; p = p->Next )
        {
        if (!DdeCmpStringHandles (hszTopic, p->hszName))
            return TRUE;
        }

    return FALSE;
}




/*
 *      CleanUpShares
 */

BOOL CleanUpShares ( VOID )
{
pShrInfo p, tmp;

    for (p=SIHead; p; p=tmp)
        {
        DdeFreeStringHandle ( idInst, p->hszName );

        #ifdef CACHEFORMATLIST
        PINFO(TEXT("freeing cached format list\n\r"));
        if ( p->hFormatList )
            DdeFreeDataHandle ( p->hFormatList );
        #endif

        #ifdef CACHEPREVIEWS
        PINFO(TEXT("freeing cached preview bitmap\n\r"));
        if ( p->hPreviewBmp )
            DdeFreeDataHandle ( p->hPreviewBmp );
        #endif

        tmp = p->Next;
        LocalFree ((HLOCAL) p );
        }

    SIHead = NULL;

    return TRUE;
}



/*
 *      InitShares
 */

BOOL InitShares (VOID)
{
TCHAR   szComputerName[MAX_COMPUTERNAME_LENGTH+3];
TCHAR   rgtchPageName[MAX_CLPSHRNAME+1];
TCHAR   rgtchPageFile[MAX_FILEPATH+1];
DWORD   dwPageSize;
DWORD   dwNameSize;
DWORD   dwType;
HKEY    hkeyClp;
DWORD   dwR;

unsigned iValue = 0;
unsigned iKeys = 0;


    CleanUpShares ();


    if (ERROR_SUCCESS != MakeTheRegKey(&hkeyClp, KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE))
        {
        PERROR(TEXT("Couldn't get to Clipbook root key\r\n"));
        return FALSE;
        }

    szComputerName[0] = szComputerName[1] = TEXT('\\');
    dwNameSize = MAX_COMPUTERNAME_LENGTH+1;
    GetComputerName (szComputerName+2, &dwNameSize);


    do  {

        dwNameSize = sizeof (rgtchPageName);
        dwPageSize = sizeof (rgtchPageFile);

        dwR = RegEnumValue (hkeyClp,
                            iValue,
                            rgtchPageName,
                            &dwNameSize,
                            NULL,
                            &dwType,
                            (LPBYTE)rgtchPageFile,
                            &dwPageSize);


        if (dwR == ERROR_SUCCESS)
            {
            rgtchPageName[dwNameSize] = 0;
            rgtchPageFile[dwPageSize] = 0;


            AddRecord (rgtchPageName,
                       rgtchPageFile,
                       (SHR_CHAR == rgtchPageName[0]) ? SIF_SHARED : 0);
            }

        iValue++;

        } while (dwR != ERROR_NO_MORE_ITEMS);


    RegCloseKey(hkeyClp);

    PINFO(TEXT("Read %d pages\r\n"),iKeys);

    return TRUE;
}



/*
 *      GetFormat
 */

HDDEDATA GetFormat (
    HCONV   hConv,
    HSZ     hszTopic,
    HSZ     hszItem )
{
HDDEDATA        hData    = 0l;
HANDLE          hClpData = NULL;
DWORD           cbData   = 0L;
pShrInfo        pshrinfo;
HANDLE          fh;
FORMATHEADER    FormatHeader;
unsigned        i;
TCHAR           szItemKey[CCHFMTNAMEMAX];
unsigned        cFormats;
BOOL            fPreviewRequested;
unsigned        fLocalAskedForLocal = 0;

#ifndef UNICODE
TCHAR           szFormatName[CCHFMTNAMEMAX * 2];
#endif


    PINFO(TEXT("Clsrv\\GetFormat:"));

    if (!DdeQueryString (idInst,hszItem,szItemKey,CCHFMTNAMEMAX,CP_WINANSI))
        {
        PERROR(TEXT("invalid item\n\r"));
        return 0;
        }


    // is the asked-for format cf_preview?
    fPreviewRequested = !lstrcmpi ( szItemKey, SZPREVNAME );


    for ( pshrinfo=SIHead; pshrinfo; pshrinfo = pshrinfo->Next )
        {
        if ( DdeCmpStringHandles ( hszTopic, pshrinfo->hszName ) == 0 )
            {
            DdeKeepStringHandle ( idInst, hszTopic );

            if ( fPreviewRequested && pshrinfo->hPreviewBmp )
                {
                return pshrinfo->hPreviewBmp;
                }
            fh = CreateFileW(pshrinfo->szFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);

            if ( INVALID_HANDLE_VALUE == fh)
                {
                PERROR(TEXT("ERROR opening %ls\n\r"), pshrinfo->szFileName );
                }
            else
                {
                cFormats = ReadFileHeader(fh);

                if (0 == cFormats)
                    {
                    PERROR(TEXT("Bad .CLP file\r\n"));
                    }

                for (i=0; i < cFormats; i++)
                    {
                    ReadFormatHeader(fh, &FormatHeader, i);


                    #ifndef UNICODE
                    WideCharToMultiByte (CP_ACP,
                                         0,
                                         FormatHeader.Name,
                                         CCHFMTNAMEMAX,
                                         szFormatName,
                                         CCHFMTNAMEMAX * 2,
                                         NULL,
                                         NULL);


                    if (!lstrcmpi (szItemKey, szFormatName))
                    #else
                    if (!lstrcmpi (szItemKey, FormatHeader.Name))
                    #endif
                        {
                        // Put back the format names, if a local client asked
                        // us for objectlink or link.
                        if (ASKED_FOR_OBJECTLINK == fLocalAskedForLocal)
                            {
                            StringCchCopyW(FormatHeader.Name, CCHFMTNAMEMAX, LSZOBJECTLINK);
                            }
                        else if (ASKED_FOR_LINK == fLocalAskedForLocal)
                            {
                            StringCchCopyW(FormatHeader.Name, CCHFMTNAMEMAX, LSZLINK);
                            }

                        hData = RenderRawFormatToDDE(&FormatHeader, fh);

                        #ifdef CACHEPREVIEWS
                        if ( fPreviewRequested )
                            {
                            PINFO(TEXT("GetFormat: caching preview\n\r"));
                            pshrinfo->hPreviewBmp = hData;
                            }
                        #endif

                        #if DEBUG
                        if (!hData)
                            {
                            PERROR(TEXT("RenderRawFormatToDDE resulted in 0 handle\n\r"));
                            }
                        #endif
                        }
                    }
                if (!hData)
                    {
                    PERROR(TEXT("GetFormat: requested format %s not found\n\r"),
                                   (LPSTR)szItemKey );
                    }
                CloseHandle(fh);
                }
            }
        }

    PINFO("Returning %lx",hData);

    return hData;
}




/*
 *      DelShare
 *
 *  Purpose: Delete a ClipBook page.
 *
 *  Parameters:
 *     pszName - The name of the page.
 *
 *  Returns:
 *     TRUE on success, FALSE on failure.
 */

BOOL DelShare(
    HCONV   hConv,
    TCHAR   *pszName)
{
pShrInfo    pshrinfo;
pShrInfo    q;
HKEY        hkeyClp;
TCHAR       atch[MAX_COMPUTERNAME_LENGTH + 3];
DWORD       dwLen = MAX_COMPUTERNAME_LENGTH + 1;
BOOL        fOK = FALSE;
DWORD       ret;
WCHAR       rgwchT[MAX_CLPSHRNAME + 1];
TCHAR       tch;


    assert(pszName);
    assert(*pszName);

    #ifndef UNICODE
    MultiByteToWideChar(CP_ACP, 0, pszName, -1, rgwchT, MAX_CLPSHRNAME + 1);
    #else
    StringCchCopy(rgwchT, MAX_CLPSHRNAME + 1, pszName);
    #endif

    PINFO(TEXT("Looking for %ls\r\n"), rgwchT);

    q = NULL;

    for (pshrinfo = SIHead; pshrinfo; pshrinfo = (q = pshrinfo)->Next)
        {
        assert(pshrinfo->szName);
        PINFO(TEXT("Comparing to %ls\r\n"), pshrinfo->szName);

        if (!lstrcmpW(pshrinfo->szName, rgwchT))
            {

            // Delete the Network DDE share for this item

            atch[0] = atch[1] = TEXT('\\');
            dwLen = MAX_COMPUTERNAME_LENGTH +1;
            GetComputerName(atch+2, &dwLen);

            tch = pszName[0];
            pszName[0] = SHR_CHAR;

            PINFO(TEXT("Deleting share %s on %s\r\n"), pszName, atch);

            ret = NDdeShareDel(atch, pszName, 0);
            pszName[0] = tch;

            if (NDDE_NO_ERROR == ret)
                {
                // Delete the key in the registry
                RevertToSelf();
                if (ERROR_SUCCESS == MakeTheRegKey(&hkeyClp, KEY_SET_VALUE))
                    {
                    RegDeleteValue(hkeyClp, pszName);
                    RegCloseKey(hkeyClp);
                    }
                else
                    {
                    PERROR(TEXT("Couldn't delete key! #%ld\r\n"), GetLastError());
                    }

                DdeImpersonateClient(hConv);


                // force render all if applicable!
                SendMessage (hwndApp, WM_RENDERALLFORMATS, 0, 0L);

                // unlink file!
                DeleteFileW(pshrinfo->szFileName);

                // Take this page out of the linked list of pages.
                if (q == NULL)
                    {
                    SIHead = pshrinfo->Next;
                    }
                else
                    {
                    q->Next = pshrinfo->Next;
                    }

                DdeFreeStringHandle ( idInst, pshrinfo->hszName );

                if ( pshrinfo->hFormatList )
                    DdeFreeDataHandle ( pshrinfo->hFormatList );

                if ( pshrinfo->hPreviewBmp )
                    DdeFreeDataHandle ( pshrinfo->hPreviewBmp );

                LocalFree ( (HLOCAL)pshrinfo );

                #ifdef AUTOUPDATE
                  DdePostAdvise ( idInst, hszSysTopic, hszTopicList );
                #endif

                fOK = TRUE;
                }
            else
                {
                PERROR(TEXT("Csrv: NDde err %ld on delshare\r\n"), ret);
                SetXactErr (hConv, XERRT_NDDE, ret);
                }

            break; // Don't loop thru additional pages if you found the right one
            }
        }

    if (!fOK)
       {
       PERROR(TEXT("Clipsrv: item to delete '%s' not found\n\r"), pszName );
       }

    return fOK;
}




/*
 *      AddRecord
 *
 *  Purpose:
 *     Add a record to the linked list of Clipbook pages in memory.
 *
 *  Parameters:
 *     lpszName - Name of the page.
 *     lpszFileName - Name of the .CLP file containing the page's data.
 *     siflags - Flags for the page.
 *
 *  Returns:
 *     TRUE on success, FALSE on failure
 */

BOOL AddRecord (
    LPTSTR  lpszName,
    LPTSTR  lpszFileName,
    ULONG   siflags)
{
    pShrInfo pshrinfo;

    PINFO(TEXT("Making page %s with file %s\r\n"), lpszName, lpszFileName);

    pshrinfo = (pShrInfo) LocalAlloc ( LPTR, sizeof ( ShrInfo ) );

    if ( !pshrinfo )
        {
        PERROR(TEXT("AddRecord: LocalAlloc failed\n\r"));
        return FALSE;
        }

    if ( !( pshrinfo->hszName = DdeCreateStringHandle ( idInst, lpszName, 0 )))
        {
        PERROR(TEXT("AddRecord: DdeCHSZ fail\r\n"));

        LocalFree (pshrinfo);
        return(FALSE);
        }


    #ifdef UNICODE
      StringCchCopy( pshrinfo->szFileName, MAX_FILEPATH, lpszFileName );
      StringCchCopy( pshrinfo->szName, MAX_CLPSHRNAME+1, lpszName );
    #else
      MultiByteToWideChar(CP_ACP, 0L, lpszFileName, -1, pshrinfo->szFileName, MAX_FILEPATH - 1);
      MultiByteToWideChar(CP_ACP, 0L, lpszName, -1, pshrinfo->szName, MAX_CLPSHRNAME);
    #endif

    PINFO(TEXT("Made page %ls with file %ls\r\n"), pshrinfo->szName, pshrinfo->szFileName);

    #ifdef CACHEFORMATLIST
     pshrinfo->hFormatList = 0L;
    #endif

    #ifdef CACHEPREVIEWS
     pshrinfo->hPreviewBmp = 0L;
    #endif

    pshrinfo->Next = SIHead;
    SIHead = pshrinfo;
    pshrinfo->flags = (WORD) siflags;

    return TRUE;
}



/*
 *      ResetRecord
 *
 *  When paste into an existing page, we need to clear the cached
 *  stuff for the old data.
 */

void    ResetRecord (pShrInfo   pInfo)
{

    // clear the format list

    if (pInfo->hFormatList)
        {
        DdeFreeDataHandle (pInfo->hFormatList);
        pInfo->hFormatList = NULL;
        }

    // clear the preview bitmap

    if (pInfo->hPreviewBmp)
        {
        DdeFreeDataHandle (pInfo->hPreviewBmp);
        pInfo->hPreviewBmp = NULL;
        }
}



/*
 *      GetShareFileName
 *
 */

pShrInfo    GetShareFileName (LPTSTR szSName, LPTSTR szFName)
{
BOOL        bRet = FALSE;
HSZ         hS;
CHAR        cSave;
pShrInfo    pInfo;


    cSave = *szSName;

    hS = DdeCreateStringHandle (idInst, szSName, 0);
    if (!hS)
        goto done;



    for (pInfo = SIHead; pInfo; pInfo = pInfo->Next)
        if (!DdeCmpStringHandles (pInfo->hszName, hS))
            {
            #ifndef UNICODE
                WideCharToMultiByte (CP_ACP,
                                     0,
                                     pInfo->szFileName,
                                     -1,
                                     szFName,
                                     MAX_PATH+1,
                                     NULL,
                                     NULL);
            #else
                StringCchCopy (szFName, MAX_PATH+1, pInfo->szFileName);
            #endif

            bRet = TRUE;
            goto done;
            }

    DdeFreeStringHandle (idInst, hS);


    // not found, change share name to shared or unshared

    if (UNSHR_CHAR == cSave)
        *szSName = SHR_CHAR;
    else
        *szSName = UNSHR_CHAR;


    // try again with new share name

    hS = DdeCreateStringHandle (idInst, szSName, 0);
    if (!hS)
        goto done;


    for (pInfo = SIHead; pInfo; pInfo = pInfo->Next)
        if (!DdeCmpStringHandles (pInfo->hszName, hS))
            {
            #ifndef UNICODE
                WideCharToMultiByte (CP_ACP,
                                     0,
                                     pInfo->szFileName,
                                     -1,
                                     szFName,
                                     MAX_PATH+1,
                                     NULL,
                                     NULL);
            #else
                StringCchCopy (szFName, MAX_PATH+1, pInfo->szFileName);
            #endif

            bRet = TRUE;
            goto done;
            }


done:

    if (hS)
        DdeFreeStringHandle (idInst, hS);

    *szSName = cSave;

    if (bRet)
        return pInfo;
    else
        return NULL;
}




/*
 *      AddShare
 *
 *  Purpose:
 *     Creates a new Clipbook page by doing this:
 *        - Save the current clipboard with some random file name.
 *        - Add the Clipbook page to the list in memory
 *        - Record the existence of the page in the Clipbook Server
 *           section of the registry. The value name is the page name,
 *           and the value is the filename.
 *
 *  Parameters:
 *     pszName - Name of the page.
 *     flags   - Flags to store with the page.
 *
 *  Returns:
 *     TRUE on success, FALSE on failure.
 */

DWORD AddShare(
    LPTSTR  pszName,
    WORD    flags)
{
TCHAR       szFName[MAX_PATH+1];
HKEY        hkeyClp;
DWORD       dwR = NO_ERROR;
pShrInfo    pInfo;


    fNTSaveFileFormat = TRUE;


    if (pInfo = GetShareFileName (pszName, szFName))
        {
        dwR = SaveClipboardToFile (hwndApp, pszName, szFName, TRUE);

        ResetRecord (pInfo);

        StringCchCopy (szUpdateName, MAX_CLPSHRNAME+1, pszName);
        }
    else
        {
        dwR = GetRandShareFileName (szFName);
        if (dwR != NO_ERROR)
            return dwR;

        dwR = SaveClipboardToFile (hwndApp, pszName, szFName, TRUE);
        if (dwR != NO_ERROR)
            return dwR;


        if (!AddRecord ( pszName, szFName, flags ))
            return ERROR_NOT_ENOUGH_MEMORY;


        if (ERROR_SUCCESS == MakeTheRegKey(&hkeyClp, KEY_SET_VALUE))
            {
            RegSetValueEx(hkeyClp, pszName, 0, REG_SZ, szFName, lstrlen(szFName));
            RegCloseKey(hkeyClp);

            PINFO(TEXT("%s is being written...\n\r"), pszName);
            }
        }

    #ifdef AUTOUPDATE
      DdePostAdvise ( idInst, hszSysTopic, hszTopicList );
    #endif

    return dwR;
}



#if DEBUG

/*
 *      DumpShares
 */

VOID DumpShares (void)
{
char     buf[65];
pShrInfo pshrinfo;
int      i;
DWORD    cbRet;

    for ( i=0, pshrinfo = SIHead; pshrinfo; pshrinfo = pshrinfo->Next, i++ )
        {
        PINFO(TEXT("---------- Share %d  flags:%x-------------\n\r"), i, pshrinfo->flags );
        cbRet = DdeQueryString ( idInst, pshrinfo->hszName, buf, 128L, CP_WINANSI );
        PINFO(TEXT("name: >%s<\n\r"), (LPSTR)pshrinfo->szName );
        PINFO(TEXT("hsz:  >%s<\n\r"), cbRet? (LPSTR)buf : (LPSTR)TEXT("ERROR") );
        }

}
#else
VOID DumpShares (void)
{
}
#endif




/*
 *      MarkShare
 *
 *  Purpose: Mark a Clipbook page as shared or unshared.
 *
 *  Parameters:
 *     pszName - Name of the page.
 *     flags   - 0 for "unshared", SIF_SHARED for "shared."
 *
 *  Returns:
 *     TRUE on success, FALSE on failure.
 *
 */

BOOL MarkShare(
    TCHAR   *pszName,
    WORD    flags)
{
PSECURITY_DESCRIPTOR pSDShare;
pShrInfo    pshrinfo;
HKEY        hkeyClp;
INT         iTmp;

ACCESS_ALLOWED_ACE *pace;
WCHAR       rgwchT[MAX_CLPSHRNAME+1];
UINT        ret;
DWORD       dwBytes = sizeof(pSDShare);
WORD        wItems = 0;
PACL        Acl;
BOOL        fDacl;
BOOL        fDefault;
DWORD       i;


#ifndef UNICODE
    MultiByteToWideChar(CP_ACP, 0, pszName, -1, rgwchT, MAX_CLPSHRNAME);
#endif


    PINFO(TEXT("Entering MarkShare\r\n"));

    for (pshrinfo = SIHead; pshrinfo; pshrinfo = pshrinfo->Next)
        {

        #ifdef UNICODE
        iTmp = lstrcmpW (pshrinfo->szName+1, pszName+1);
        #else
        iTmp = lstrcmpW (pshrinfo->szName+1, rgwchT+1);
        #endif

        if (!iTmp)
            {
            PINFO(TEXT("MarkShare: marking %s %d\n\r"), (LPSTR)pszName, flags );

            // If the name's changing, need to delete old reg key.
            // (We make the new one after hitting the file security.)
            if ((pshrinfo->flags & SIF_SHARED) != (flags & SIF_SHARED))
                {
                PINFO(TEXT("Changing shared status\r\n"));

                // Delete the registry item with the old name
                if (ERROR_SUCCESS == MakeTheRegKey(&hkeyClp, KEY_SET_VALUE))
                    {
                    PINFO(TEXT("Deleting old name %ws\r\n"),pshrinfo->szName);
                    RegDeleteValueW(hkeyClp, pshrinfo->szName);
                    RegCloseKey(hkeyClp);
                    }
                else
                    {
                    PERROR(TEXT("MarkShare: Couldn't open registry!\r\n"));
                    }
                }


            // Set name to reflect shared/unshared status
            pshrinfo->szName[0] = (flags & SIF_SHARED) ? SHR_CHAR : UNSHR_CHAR;
            pshrinfo->flags = flags;


            // Sync the security on the Clipbook page file to be
            // analogous to the security set on the NetDDE share.
            pszName[0] = SHR_CHAR;
            NDdeGetShareSecurity(NULL, pszName, DACL_SECURITY_INFORMATION, NULL, 0, &i);

            PINFO(TEXT("Getting security %ld bytes\r\n"), i);


            if (!(pSDShare = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, i)))
                {
                PERROR(TEXT("LocalAlloc fail\r\n"));
                }
            else
                {
                ret = NDdeGetShareSecurity (NULL,
                                            pszName,
                                            DACL_SECURITY_INFORMATION,
                                            pSDShare,
                                            i,
                                            &i);

                if (NDDE_NO_ERROR != ret)
                    {
                    PERROR(TEXT("Couldn't get sec #%ld\r\n"), ret);
                    }
                else if (!GetSecurityDescriptorDacl(pSDShare, &fDacl, &Acl, &fDefault))
                    {
                    PERROR(TEXT("GetDACL fail %ld\r\n"), GetLastError());
                    }
                else
                    {
                    DWORD dwGeneric;

                    for (i = 0; GetAce(Acl, i, &pace); i++)
                        {
                        dwGeneric = 0L;


                        // Convert NDDE access mask types to generic access
                        // mask types
                        if (ACCESS_ALLOWED_ACE_TYPE == pace->Header.AceType ||
                            ACCESS_DENIED_ACE_TYPE == pace->Header.AceType)
                            {
                            if ((pace->Mask & NDDE_SHARE_READ) == NDDE_SHARE_READ)
                                {
                                PINFO(TEXT("R"));
                                dwGeneric |= GENERIC_READ;
                                }

                            if ((pace->Mask & NDDE_SHARE_WRITE) == NDDE_SHARE_WRITE)
                                {
                                PINFO(TEXT("R"));
                                dwGeneric |= GENERIC_WRITE;
                                }

                            if ((pace->Mask & NDDE_GUI_CHANGE) == NDDE_GUI_CHANGE)
                                {
                                PINFO(TEXT("D"));
                                dwGeneric |= GENERIC_WRITE|GENERIC_READ|DELETE;
                                }

                            if ((pace->Mask & NDDE_GUI_FULL_CONTROL) ==
                                  NDDE_GUI_FULL_CONTROL)
                                {
                                PINFO(TEXT("A"));
                                dwGeneric |= GENERIC_ALL;
                                }

                            PINFO(TEXT(" = %ld\r\n"), dwGeneric);
                            pace->Mask = dwGeneric;
                            }
                        else
                            {
                            PERROR(TEXT("Invalid ACE type!!!\r\n"));
                            }
                        }

                    ret = SetFileSecurityW (pshrinfo->szFileName,
                                            DACL_SECURITY_INFORMATION,
                                            pSDShare);

                    if (FALSE == ret)
                        {
                        PERROR(TEXT("SetFSec err %ld\r\n"), GetLastError());
                        }

                    }

                LocalFree(pSDShare);
                }


            DdeFreeStringHandle ( idInst, pshrinfo->hszName );
            pshrinfo->hszName = DdeCreateStringHandleW( idInst, pshrinfo->szName,
                  CP_WINUNICODE);

            if ( !pshrinfo->hszName )
                {
                PERROR(TEXT("DdeCreateStringHandle failed\n\r"));
                }
            else
                {
                // update the registry to show shared/unshared status
                if (ERROR_SUCCESS == MakeTheRegKey(&hkeyClp, KEY_SET_VALUE))
                    {
                    PINFO(TEXT("Making registry key %ls from %ls, %d\r\n"),
                          pshrinfo->szName, pshrinfo->szFileName,
                          lstrlenW(pshrinfo->szFileName));

                    RegSetValueExW (hkeyClp,
                                    pshrinfo->szName,
                                    0,
                                    REG_SZ,
                                    (LPBYTE)pshrinfo->szFileName,
                                    lstrlenW (pshrinfo->szFileName) *sizeof(WCHAR) +sizeof(WCHAR));

                    RegCloseKey(hkeyClp);

                    DdePostAdvise ( idInst, hszSysTopic, hszTopicList );
                    return TRUE;
                    }
                else
                    {
                    PERROR(TEXT("Could not make registry key to record %s"),
                           pshrinfo->szName);
                    }
                }
            }
        }

    PERROR(TEXT("Item to mark '%s' not found\n\r"), pszName );

    return FALSE;
}



/*
 *      Hszize
 *  This creates often used global hszs from standard global strings.
 *  It also fills the hsz fields of the topic and item tables.
 *
 */

void Hszize(void)
{

    hszAppName      = DdeCreateStringHandle (idInst, szServer,             0L);
    hszSysTopic     = DdeCreateStringHandle (idInst, SZDDESYS_TOPIC,       0L);
    hszTopicList    = DdeCreateStringHandle (idInst, SZDDESYS_ITEM_TOPICS, 0L);
    hszFormatList   = DdeCreateStringHandle (idInst, SZ_FORMAT_LIST,       0L);
    hszErrorRequest = DdeCreateStringHandle (idInst, SZ_ERR_REQUEST, 0L);

    #ifdef DEBUG
    if ( !hszAppName || !hszSysTopic || !hszTopicList || !hszFormatList )
        {
        PERROR(TEXT("error creating HSZ constants\n\r"));
        }
    #endif
}



/*
 *      UnHszize
 */

void UnHszize(void)
{
    DdeFreeStringHandle (idInst, hszAppName);
    DdeFreeStringHandle (idInst, hszSysTopic);
    DdeFreeStringHandle (idInst, hszTopicList);
    DdeFreeStringHandle (idInst, hszFormatList);
    DdeFreeStringHandle (idInst, hszErrorRequest);
}




/*
 *      GetRandShareFileName
 *
 *  Purpose:
 *     Generate a random share file name in the Windows directory.
 *
 *  Parameters:
 *     buf - Buffer to place the file name in.
 *
 *  Returns:
 *     TRUE if a valid filename was found, or FALSE if all of the random
 *     filenames are taken up.
 */

DWORD GetRandShareFileName (
    LPTSTR  buf)
{
TCHAR   szWinDir[144];
BOOL    IsUnique = FALSE;
WORD    rand;
WORD    cTry = 0;
HANDLE  hFile;


    if (!GetWindowsDirectory( szWinDir, 144))
        {
        return GetLastError();
        }

    rand = (WORD)GetTickCount() % 10000;

    do  {
        StringCchPrintf ( buf, MAX_PATH+1, TEXT("%s\\CBK%04d.CLP"), szWinDir, rand++ );
        hFile = CreateFile (buf,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_NEW,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

        }while (INVALID_HANDLE_VALUE == hFile && cTry++ < 10000);


    if (INVALID_HANDLE_VALUE == hFile)
        {
        PERROR(TEXT("GetRandShareFileName: More than 10000 clipbook file exist!\r\n"));
        return GetLastError();
        }
    else
        {
        CloseHandle(hFile);
        return NO_ERROR;
        }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\common\security.c ===
#include <windows.h>
#include <windowsx.h>
#include "common.h"
#include "security.h"
#include "debugout.h"


/*
 *      GetTokenHandle
 */

BOOL GetTokenHandle(
    PHANDLE pTokenHandle )
{

    if (OpenThreadToken( GetCurrentThread(), TOKEN_READ, FALSE, pTokenHandle))
        return TRUE;

    if (GetLastError() != ERROR_NO_TOKEN)
        return FALSE;

    if (OpenProcessToken( GetCurrentProcess(), TOKEN_READ, pTokenHandle))
        return TRUE;

    return FALSE;
}




/*
 *      MakeLocalOnlySD
 *
 *  Purpose: Generate a self-relative SD whose ACL contains only an
 *     entry for LocalSystem/GENERIC_ALL access. This SD will be used
 *     in calls to CreateFile() for clipbook page files.
 *
 *  Parameters: None
 *
 *  Returns: Pointer to the security descriptor. This pointer may be freed.
 *     Returns NULL on failure.
 */

PSECURITY_DESCRIPTOR MakeLocalOnlySD (void)
{
PSECURITY_DESCRIPTOR        pSD;
PSECURITY_DESCRIPTOR        pSDSelfRel = NULL;
SID_IDENTIFIER_AUTHORITY    authNT     = SECURITY_NT_AUTHORITY;

PSID  sidLocal;
PACL  Acl;
DWORD dwAclSize;


    if (AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
             0, 0, 0, 0, 0, 0, 0, &sidLocal))
        {
        if (InitializeSecurityDescriptor(&pSD, SECURITY_DESCRIPTOR_REVISION))
            {
            // Allocate space for DACL with "System Full Control" access
            dwAclSize = sizeof(ACL)+ GetLengthSid(sidLocal) +
                  sizeof(ACCESS_ALLOWED_ACE) + 42; // 42==fudge factor
            if (Acl = (PACL)GlobalAlloc(GPTR, dwAclSize))
                {
                if (InitializeAcl(Acl, dwAclSize, ACL_REVISION))
                    {
                    // LocalSystem gets all access, nobody else gets any.
                    if (AddAccessAllowedAce(Acl, ACL_REVISION,
                          GENERIC_ALL, sidLocal))
                        {
                        if (SetSecurityDescriptorDacl(pSD, TRUE, Acl, TRUE))
                            {
                            DWORD dwSelfRelLen;

                            dwSelfRelLen = GetSecurityDescriptorLength(pSD);
                            pSDSelfRel = GlobalAlloc(GPTR, dwSelfRelLen);
                            if (pSDSelfRel)
                            {
                                if (!MakeSelfRelativeSD(pSD, pSDSelfRel, &dwSelfRelLen))
                                    {
                                    GlobalFree((HANDLE)pSDSelfRel);
                                    pSDSelfRel = NULL;
                                    }
                                }
                            }
                        }
                    }
                GlobalFree((HANDLE)Acl);
                }
            }
        FreeSid(sidLocal);
        }
    return(pSDSelfRel);
}




/*
 *      CurrentUserOnlySD
 *
 *  Purpose: Create a security descriptor containing only a single
 *  DACL entry-- one to allow the user whose context we are running
 *  in GENERIC_ALL access.
 *
 *  Parameters: None.
 *
 *  Returns: A pointer to the security descriptor described above,
 *     or NULL on failure.
 */

PSECURITY_DESCRIPTOR CurrentUserOnlySD (void)
{
SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

SECURITY_DESCRIPTOR   aSD;
PSECURITY_DESCRIPTOR  pSD = NULL;
BOOL                  OK;
PACL                  TmpAcl;
PACCESS_ALLOWED_ACE   TmpAce;
DWORD                 lSD;
LONG                  DaclLength;
DWORD                 lTokenInfo;
HANDLE                hClientToken;
TOKEN_USER            *pUserTokenInfo;


    if (!InitializeSecurityDescriptor(&aSD, SECURITY_DESCRIPTOR_REVISION)
        || GetTokenHandle(&hClientToken))
        {
        PERROR(TEXT("Couldn't get token handle or InitSD bad \r\n"));
        return NULL;
        }


    // See if the token info fits in 50 bytes. If it does, fine.
    // If not, realloc to proper size and get the token info.
    pUserTokenInfo = (TOKEN_USER *)LocalAlloc( LMEM_FIXED, 50 );
    if (pUserTokenInfo && !GetTokenInformation( hClientToken, TokenUser,
                 (LPVOID) pUserTokenInfo, 50, &lTokenInfo ) )
       {
       LocalFree( pUserTokenInfo );
       pUserTokenInfo = (TOKEN_USER *)LocalAlloc( LMEM_FIXED, lTokenInfo );
       if (!GetTokenInformation( hClientToken, TokenUser,
               (LPVOID) pUserTokenInfo, lTokenInfo, &lTokenInfo ) )
          {
          LocalFree( pUserTokenInfo );
          pUserTokenInfo = NULL;
          }
       }


    if (!pUserTokenInfo)
        {
        PERROR(TEXT("Couldn't get usertokeninfo\r\n"));
        }
    else
        {
        // Figure out how big a Dacl we'll need for just me to be on it.
        DaclLength = (DWORD)sizeof(ACL) +
              GetLengthSid( pUserTokenInfo->User.Sid ) +
              (DWORD)sizeof( ACCESS_ALLOWED_ACE );

        if (!(TmpAcl = (PACL)LocalAlloc(LMEM_FIXED, DaclLength )))
            {
            PERROR(TEXT("LocalAllof for Acl fail\r\n"));
            }
        else
            {
            if (!InitializeAcl( TmpAcl, DaclLength, ACL_REVISION ))
                {
                PERROR(TEXT("InitializeAcl fail\r\n"));
                }
            else if (!AddAccessAllowedAce( TmpAcl, ACL_REVISION,
                   GENERIC_ALL, pUserTokenInfo->User.Sid ))
                {
                PERROR(TEXT("AddAccessAllowedAce fail\r\n"));
                }
            else if (!GetAce( TmpAcl, 0, (LPVOID *)&TmpAce))
                {
                PERROR("GetAce error %d", GetLastError());
                }
            else
                {
                TmpAce->Header.AceFlags = 0;
                OK   = SetSecurityDescriptorDacl(&aSD, TRUE, TmpAcl, FALSE);
                lSD  = GetSecurityDescriptorLength( &aSD);

                if (pSD  = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, lSD))
                    {
                    MakeSelfRelativeSD( &aSD, pSD, &lSD);

                    if( IsValidSecurityDescriptor( pSD ) )
                        {
                        LocalFree(pSD);
                        pSD = NULL;
                        }
                    else
                        {
                        PERROR(TEXT("Failed creating self-relative SD (%d)."),
                              GetLastError());
                        }
                    }
                else
                    {
                    PERROR(TEXT("LocalAlloc for pSD fail\r\n"));
                    }
                }

            LocalFree((HANDLE)TmpAcl);
            }

        LocalFree((HANDLE)pUserTokenInfo);
        }

    CloseHandle(hClientToken);

    return pSD;
}




#ifdef DEBUG


/*
 *      HexDumpBytes
 */

void HexDumpBytes(
    char        *pv,
    unsigned    cb)
{
char        achHex[]="0123456789ABCDEF";
char        achOut[80];
unsigned    iOut;



    iOut = 0;

    while (cb)
        {
        if (iOut >= 78)
            {
            PINFO(achOut);
            iOut = 0;
            }

        achOut[iOut++] = achHex[(*pv >> 4) & 0x0f];
        achOut[iOut++] = achHex[*pv++ & 0x0f];
        achOut[iOut]   = '\0';
        cb--;
        }


    if (iOut)
        {
        PINFO(achOut);
        }
}



/*
 *      PrintSid
 */

void PrintSid(
    PSID    sid)
{
DWORD   cSubAuth;
DWORD   i;

    PINFO(TEXT("\r\nSID: "));

    if (sid)
        {
        HexDumpBytes((char *)GetSidIdentifierAuthority(sid), sizeof(SID_IDENTIFIER_AUTHORITY));

        SetLastError(0);
        cSubAuth = *GetSidSubAuthorityCount(sid);
        if (GetLastError())
            {
            PINFO(TEXT("Invalid SID\r\n"));
            }
        else
            {
            for (i = 0;i < cSubAuth; i++)
                {
                PINFO(TEXT("-"));
                HexDumpBytes((char *)GetSidSubAuthority(sid, i), sizeof(DWORD));
                }
            PINFO(TEXT("\r\n"));
            }
        }
    else
        {
        PINFO(TEXT("NULL SID\r\n"));
        }

}



/*
 *      PrintAcl
 *
 *  Purpose: Print out the entries in an access-control list.
 */

void PrintAcl(
    PACL    pacl)
{
ACL_SIZE_INFORMATION    aclsi;
ACCESS_ALLOWED_ACE      *pace;
unsigned                i;


    if (pacl)
        {
        if (GetAclInformation (pacl, &aclsi, sizeof(aclsi), AclSizeInformation))
            {
            for (i = 0;i < aclsi.AceCount;i++)
                {
                GetAce(pacl, i, &pace);

                PINFO(TEXT("Type(%x) Flags(%x) Access(%lx)\r\nSID:"),
                      (int)pace->Header.AceType,
                      (int)pace->Header.AceFlags,
                      pace->Mask);
                PrintSid((PSID)&(pace->SidStart));
                }
            }
        }
    else
        {
        PINFO(TEXT("NULL PACL\r\n"));
        }

}



/*
 *      PrintSD
 */

void PrintSD(
    PSECURITY_DESCRIPTOR    pSD)
{
DWORD   dwRev;
WORD    wSDC;
BOOL    fDefault, fAcl;
PACL    pacl;
PSID    sid;



    if (NULL == pSD)
        {
        PINFO(TEXT("NULL sd\r\n"));
        return;
        }

    if (!IsValidSecurityDescriptor(pSD))
        {
        PINFO(TEXT("Bad SD %p"), pSD);
        return;
        }

    // Drop control info and revision
    if (GetSecurityDescriptorControl(pSD, &wSDC, &dwRev))
        {
        PINFO(TEXT("SD - Length: [%ld] Control: [%x] [%lx]\r\nGroup:"),
              GetSecurityDescriptorLength(pSD), wSDC, dwRev);
        }
    else
        {
        PINFO(TEXT("Couldn't get control\r\nGroup"));
        }

    // Show group and owner
    if (GetSecurityDescriptorGroup(pSD, &sid, &fDefault) &&
        sid &&
        IsValidSid(sid))
        {
        PrintSid(sid);
        PINFO(TEXT(" %s default.\r\nOwner:"), fDefault ? TEXT(" ") : TEXT("Not"));
        }
    else
        {
        PINFO(TEXT("Couldn't get group\r\n"));
        }

    if (GetSecurityDescriptorOwner(pSD, &sid, &fDefault) &&
        sid &&
        IsValidSid(sid))
        {
        PrintSid(sid);
        PINFO(TEXT(" %s default.\r\n"), fDefault ? TEXT(" ") : TEXT("Not"));
        }
    else
        {
        PINFO(TEXT("Couldn't get owner\r\n"));
        }

    // Print DACL and SACL
    if (GetSecurityDescriptorDacl(pSD, &fAcl, &pacl, &fDefault))
        {
        PINFO(TEXT("DACL: %s %s\r\n"), fAcl ? "Yes" : "No",
              fDefault ? "Default" : " ");
        if (fAcl)
            {
            if (pacl && IsValidAcl(pacl))
                {
                PrintAcl(pacl);
                }
            else
                {
                PINFO(TEXT("Invalid Acl %p\r\n"), pacl);
                }
            }
        }
    else
        {
        PINFO(TEXT("Couldn't get DACL\r\n"));
        }

    if (GetSecurityDescriptorSacl(pSD, &fAcl, &pacl, &fDefault))
        {
        PINFO(TEXT("SACL: %s %s\r\n"), fAcl ? "Yes" : "No", fDefault ? "Default" : " ");
        if (fAcl)
            {
            if (pacl && IsValidAcl(pacl))
                {
                PrintAcl(pacl);
                }
            else
                {
                PINFO(TEXT("Invalid ACL %p\r\n"), pacl);
                }
            }
        }
    else
        {
        PINFO(TEXT("Couldn't get SACL\r\n"));
        }

}

#else
#define PrintSid(x)
#define PrintSD(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\datasrv\ddeutil.h ===
// Prototypes for DDE utiltity functions-- most with AW variants.
//


extern HDDEDATA GetTopicListA(
    HCONV   hConv,
    BOOL    fAllTopicsReq);



extern HDDEDATA GetTopicListW(
    HCONV   hConv,
    BOOL    fAllTopicsReq);

extern HDDEDATA GetFormatListA(
    HCONV   hConv,
    HSZ     hszTopic);


extern HDDEDATA GetFormatListW(
    HCONV   hConv,
    HSZ     hszTopic);


#ifdef UNICODE
    #define GetTopicList    GetTopicListA
    #define GetFormatList   GetFormatListA
#else
    #define GetTopicList    GetTopicListW
    #define GetFormatList   GetFormatListW
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\datasrv\islocal.c ===
/*
 *      islocal.c
 *
 *      Determine if a user is local.
 *
 *      Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 *      TimF    20010226
 */


#include <windows.h>
#include "common.h"
#include "clipsrv.h"
#include "security.h"
#include "debugout.h"


/*
 *      IsUserLocal
 *
 *  Purpose: Determine if the user context we're running in is
 *     interactive or remote.
 *
 *  Parameters: None.
 *
 *  Returns: TRUE if this is a locally logged-on user.
 */

BOOL
IsUserLocal(
    HCONV                   hConv
)
{
    BOOL                    fRet = FALSE;
    PSID                    sidInteractive;
    SID_IDENTIFIER_AUTHORITY NTAuthority = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(&NTAuthority,
                                  1,
                                  SECURITY_INTERACTIVE_RID,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  &sidInteractive)) {

        PERROR(TEXT("IsUserLocal: Couldn't get interactive SID\r\n"));
    } else {

        if (!DdeImpersonateClient(hConv)) {
            PERROR(TEXT("IsUserLocal: DdeImpersonateClient failed\r\n"));
        } else {

            BOOL                    IsMember;

            if (!CheckTokenMembership(NULL,
                                      sidInteractive,
                                      &IsMember)) {

                PERROR(TEXT("IsUserLocal: CheckTokenMembership failed.\r\n"));
            } else {
                fRet = IsMember;
            }

            RevertToSelf();
        }

        FreeSid(sidInteractive);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\datasrv\clipsrv.c ===
#include    <windows.h>
#include    <windowsx.h>
#include    <stdarg.h>
#include    "common.h"
#include    "clipsrv.h"
#include    "clipfile.h"
#include    "callback.h"
#include    "debugout.h"


static HANDLE   hmutexClp;      // for syncing open and close of clipboard

static BOOL     fAnythingToRender = FALSE;
static BOOL     fService = TRUE;
static BOOL     fServiceStopped = FALSE;
static TCHAR    szClass[] = TEXT("ClipSrvWClass");
static TCHAR    szServiceName[] = TEXT("Clipbook Service");

static TCHAR    wsbuf[128];

DWORD           idInst = 0;
HINSTANCE       hInst;
HWND            hwndApp;
HSZ             hszAppName = 0L;
TCHAR           szTopic[MAX_TOPIC] = TEXT("ClipData");
TCHAR           szServer[MAX_TOPIC] = TEXT("ClipSrv");
TCHAR           szExec[MAX_EXEC] = TEXT("");

TCHAR           szUpdateName[MAX_CLPSHRNAME+1] = TEXT("");

UINT            cf_preview;
ShrInfo         *SIHead = NULL;


static SERVICE_STATUS_HANDLE hService;
static SERVICE_STATUS srvstatus =
   {
   SERVICE_WIN32_OWN_PROCESS,
   SERVICE_START_PENDING,
   SERVICE_ACCEPT_STOP,
   NO_ERROR,
   0L,
   1,
   200
   };


#if DEBUG
HKEY hkeyRoot;
HKEY hkeyClp;
#endif


void ClipSrvHandler (DWORD);



/////////////////////////////////////////////////////////////////////////
//
// "main" function... just calls StartServiceCtrlDispatcher.
//
/////////////////////////////////////////////////////////////////////////

void _cdecl main(
    int     argc,
    char    **argv)
{
SERVICE_TABLE_ENTRY srvtabl[] = {{szServiceName, ClipSrvMain},
                                 {NULL,          NULL}};


#if DEBUG
    DeleteFile("C:\\CLIPSRV.OUT");
#endif

    if (argv[1] && !lstrcmpi(argv[1], "-debug"))
        {
        fService = FALSE;
        ClipSrvMain(argc, argv);
        }
    else
        {
        StartServiceCtrlDispatcher(srvtabl);
        }
}



/*
 *      ClipSrvMain
 */

void ClipSrvMain(
    DWORD   argc,
    LPSTR   *argv)
{
MSG msg;

    if (fService)
        {
        hService = RegisterServiceCtrlHandler(szServiceName, ClipSrvHandler);
        }


    if (0L != hService || FALSE == fService)
        {
        if (fService)
            {
            // Tell SCM that we're starting
            SetServiceStatus(hService, &srvstatus);
            }

        hInst = GetModuleHandle(TEXT("CLIPSRV.EXE"));

        // Perform initializations
        if (InitApplication(hInst, &srvstatus))
            {
            if (fService)
               {
               // Tell SCM we've started OK
               srvstatus.dwCurrentState = SERVICE_RUNNING;
               SetServiceStatus(hService, &srvstatus);

               PINFO(TEXT("Told system we're running\r\n"));
               }

            // Process messages
            while (GetMessage(&msg, NULL, 0, 0))
               {
               TranslateMessage(&msg);
               DispatchMessage(&msg);
               }

            UnregisterClass(szClass, hInst);

            if (fService && !fServiceStopped)
               {
               fServiceStopped = TRUE;
               srvstatus.dwCurrentState = SERVICE_STOPPED;
               SetServiceStatus(hService, &srvstatus);
               }

            if (NULL != hmutexClp)
               {
               CloseHandle(hmutexClp);
               }
            }
        else
            {
            PERROR(TEXT("ClSrv: InitApplication failed!\r\n"));
            if (fService && !fServiceStopped)
                {
                fServiceStopped = TRUE;
                srvstatus.dwCurrentState = SERVICE_STOPPED;
                SetServiceStatus(hService, &srvstatus);
                }
            }
        }
}




/*
 *      ReportStatusToSCMgr
 *
 *  This function is called by the ServMainFunc() and
 *  by the ServCtrlHandler() to update the service's status
 *  to the Service Control Manager.
 */

BOOL ReportStatusToSCMgr (
    DWORD   dwCurrentState,
    DWORD   dwWin32ExitCode,
    DWORD   dwCheckPoint,
    DWORD   dwWaitHint)
{
BOOL fResult;


    /* disable control requests until service is started */
    if (dwCurrentState == SERVICE_START_PENDING)
        {
        srvstatus.dwControlsAccepted = 0;
        }
    else
        {
        srvstatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
        }

    /* These SERVICE_STATUS members set from parameters */

    srvstatus.dwCurrentState = dwCurrentState;
    srvstatus.dwWin32ExitCode = dwWin32ExitCode;
    srvstatus.dwCheckPoint = dwCheckPoint;

    srvstatus.dwWaitHint = dwWaitHint;

    /* Report status of service to Service Control Manager */

    if (!(fResult = SetServiceStatus(hService,&srvstatus)))
        {
        /* if error occurs, stop service */
        }

    return fResult;
}




/*
 *      ClipSrvHandler
 *
 *
 *  Purpose: Acts as the HANDLER_FUNCTION for the Clipbook service.
 *
 *  Parameters:
 *     fdwControl = Flags saying what action to take
 *
 *  Returns: Void (SetServiceStatus is used to set status)
 */

void ClipSrvHandler(
    DWORD   fdwControl)
{

    if (SERVICE_CONTROL_STOP == fdwControl)
       {
       PINFO(TEXT("Handler: stopping service\r\n"));
       srvstatus.dwCheckPoint = 0;
       srvstatus.dwCurrentState = SERVICE_STOP_PENDING;
       SetServiceStatus(hService, &srvstatus);

       SendMessage(hwndApp, WM_CLOSE, 0, 0);

       if (!fServiceStopped) {
           fServiceStopped = TRUE;
           srvstatus.dwCurrentState = SERVICE_STOPPED;
           SetServiceStatus(hService, &srvstatus);
       }
       PINFO(TEXT("Handler: Service stopped\r\n"));
       }
    else
       {
       // Unhandled control request.. just keep running.
       srvstatus.dwCurrentState = SERVICE_RUNNING;
       srvstatus.dwWin32ExitCode = NO_ERROR;
       SetServiceStatus(hService, &srvstatus);
       }
    return;

}




/*
 *      InitApplication
 *
 *
 *  Purpose: Application initialization, including creation of a window
 *     to do DDE with, getting settings out of the registry, and starting
 *     up DDE.
 *
 *  Parameters:
 *     hInstance - Application instance.
 *     psrvstatus - Pointer to a SERVICE_STATUS struct. We update the
 *           dwCheckPoint member of this struct and call SetServiceStatus,
 *           so the system knows that we didn't die.
 *
 *  Returns: True on OK, false on fail.
 */

BOOL InitApplication(
    HINSTANCE       hInstance,
    SERVICE_STATUS  *psrvstatus)
{
WNDCLASS        wc;
#if DEBUG
DWORD           dwKeyStatus;
#endif
HWINSTA hwinsta;


    wc.style = 0L;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_CLIPSRV));
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = TEXT("ClipSrvWClass");

    if (!RegisterClass(&wc))
       {
       PERROR(TEXT("Couldn't register wclass\r\n"));
       return FALSE;
       }

  /*
   * We are now connected to the appropriate service windowstation
   * and desktop. In order to get stuff from clipbook, we need to
   * switch our process over to use the interactive user's
   * clipboard.  Verify that we have access to do this.
   */
  hwinsta = OpenWindowStation("WinSta0", FALSE,
          WINSTA_ACCESSCLIPBOARD | WINSTA_ACCESSGLOBALATOMS);
  if (hwinsta == NULL) {
      PERROR(TEXT("Couldn't open windowstation WinSta0\r\n"));
      return FALSE;
  }

  SetProcessWindowStation(hwinsta);

    psrvstatus->dwCheckPoint++;

    hmutexClp = CreateMutex(NULL, FALSE, SZMUTEXCLP);

    hwndApp = CreateWindow(TEXT("ClipSrvWClass"),
                              TEXT("Hidden Data Server"),
                              WS_POPUP,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              400,
                              200,
                              NULL,
                              NULL,
                              hInstance,
                              NULL
                              );

    if (!hwndApp)
       {
       PERROR(TEXT("No window created\r\n"));
       return FALSE;
       }

    psrvstatus->dwCheckPoint++;

    #if DEBUG
    if (ERROR_SUCCESS != RegCreateKeyEx (HKEY_CURRENT_USER,
                                         szClipviewRoot,
                                         0L,
                                         szRegClass,
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_QUERY_VALUE, NULL,
                                         &hkeyClp,
                                         &dwKeyStatus)
         &&

        ERROR_SUCCESS != RegOpenKeyEx   (HKEY_CURRENT_USER,
                                         szClipviewRoot,
                                         0,
                                         KEY_QUERY_VALUE,
                                         &hkeyClp))
        {
        DebugLevel = 2;
        PINFO(TEXT("Clipsrv: Could not get root key\r\n"));
        }
    else
        {
        DWORD iSize = sizeof(DebugLevel);

        RegQueryValueEx (hkeyClp,
                         szDebug,
                         NULL,
                         NULL,
                         (LPBYTE)&DebugLevel,
                         &iSize);

        RegCloseKey (hkeyClp);
        }

    if (DebugLevel > 0)
        {
        ShowWindow(hwndApp, SW_SHOWMINNOACTIVE );
        }
    #endif


    if (DdeInitialize ((LPDWORD)&idInst,
                       (PFNCALLBACK)DdeCallback,
                       APPCMD_FILTERINITS,
                       0L))
        {
        PERROR(TEXT("Couldn't initialize DDE\r\n"));
        return FALSE;
        }

    PINFO(TEXT("DdeInit OK...\r\n"));
    psrvstatus->dwCheckPoint++;
    if (fService)
        {
        SetServiceStatus(hService, psrvstatus);
        }

    Hszize();
    DdeNameService(idInst, hszAppName, 0L, DNS_REGISTER);

    InitShares();

    return TRUE;
}




/*
 *      MainWndProc
 */

LRESULT CALLBACK MainWndProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{

    switch (message)
        {
        case WM_CREATE:
            fAnythingToRender = FALSE;
            cf_preview = RegisterClipboardFormat (SZPREVNAME);

            if (fService)
                {
                // Let the SCP that started us know that we're making progress
                srvstatus.dwCheckPoint++;
                SetServiceStatus(hService, &srvstatus);
                }

            PINFO(TEXT("Creating ClSrv window\r\n"));
            break;

        case WM_DESTROYCLIPBOARD:
            /* Prevent unnecessary file I/O when getting a WM_RENDERALLFORMATS */
            fAnythingToRender = FALSE;
            break;

        case WM_RENDERALLFORMATS:
            PINFO(TEXT("ClSrv\\WM_RNDRALL rcvd\r\n"));
            return (LRESULT)RenderAllFromFile(szSaveFileName);
            break;

        case WM_RENDERFORMAT:
            SetClipboardData((UINT)wParam, RenderFormatFromFile(szSaveFileName, (WORD)wParam));
            break;

        case WM_QUERYOPEN:
            return FALSE;

        case WM_DESTROY:
            PINFO(TEXT("sTOPPING...\r\n"));
            CleanUpShares();
            DdeNameService(idInst, 0L, 0L, DNS_UNREGISTER);
            UnHszize();
            DdeUninitialize(idInst);

            if (fService)
                {
                // Tell SCP we're stopping
                srvstatus.dwCheckPoint++;
                SetServiceStatus(hService, &srvstatus);
                }
            PostQuitMessage(0);
            break;

        default:
            return (DefWindowProc(hwnd, message, wParam, lParam));
        }

    return 0L;
}




/*
 *      RenderRawFormatToDDE
 */

HDDEDATA RenderRawFormatToDDE(
    FORMATHEADER    *pfmthdr,
    HANDLE          fh )
{
HDDEDATA   hDDE;
LPBYTE     lpDDE;
DWORD      cbData;
DWORD      dwBytesRead;
BOOL       fPrivate = FALSE, fMetafile = FALSE, fBitmap = FALSE;


    PINFO(TEXT("ClSrv\\RndrRawFmtToDDE:"));

    // Note that complex-data formats are sent under a private
    // format instead.

    if (PRIVATE_FORMAT(pfmthdr->FormatID )
       || pfmthdr->FormatID == CF_BITMAP
       || pfmthdr->FormatID == CF_METAFILEPICT
       || pfmthdr->FormatID == CF_PALETTE
       || pfmthdr->FormatID == CF_DIB
       || pfmthdr->FormatID == CF_ENHMETAFILE
       )
       {
       fPrivate = TRUE;
       if (pfmthdr->FormatID == CF_BITMAP)
          {
          fBitmap = TRUE;
          }
       else if (pfmthdr->FormatID == CF_METAFILEPICT)
          {
          fMetafile = TRUE;
          }
       pfmthdr->FormatID = RegisterClipboardFormatW(pfmthdr->Name);
       }

    PINFO(TEXT("rendering format %ws as %x\n\r"), (LPTSTR)pfmthdr->Name, pfmthdr->FormatID );

    #ifdef CACHEPREVIEWS
    if ( pfmthdr->FormatID == cf_preview )
       PINFO(TEXT("making APPOWNED data\n\r"));
    #endif


    if (!(hDDE = DdeCreateDataHandle (idInst,
                                      NULL,
                                      pfmthdr->DataLen,
                                      0L,
                                      hszAppName,
                                      pfmthdr->FormatID,
                                      #ifdef CACHEPREVIEWS
                                       pfmthdr->FormatID == cf_preview ? HDATA_APPOWNED : 0
                                      #else
                                       0
                                      #endif
                                      )))
        {
        PERROR(TEXT("Couldn't createdata handle\r\n"));
        goto done;
        }


    if ( !(lpDDE = DdeAccessData ( hDDE, &cbData )) )
       {
        PERROR(TEXT("Couldn't access handle\r\n"));
        DdeFreeDataHandle(hDDE);
        hDDE = 0L;
        goto done;
        }


    if (~0 == SetFilePointer(fh, pfmthdr->DataOffset, NULL, FILE_BEGIN))
        {
        PERROR(TEXT("Couldn't set file pointer\r\n"));
        DdeUnaccessData(hDDE);
        DdeFreeDataHandle(hDDE);
        hDDE = 0L;
        goto done;
        }

    ReadFile(fh, lpDDE, pfmthdr->DataLen, &dwBytesRead, NULL);

    if (dwBytesRead != pfmthdr->DataLen)
       {
       // Error in reading the file
       DdeUnaccessData(hDDE);
       DdeFreeDataHandle(hDDE);
       PERROR(TEXT("Error reading file: %ld from lread\n\r"),
         dwBytesRead);
       hDDE =  0L;
       goto done;
       }


    // This code packs CF_METAFILEPICT and CF_BITMAP structs to WFW-type
    // structs. It may lose extents for very large bitmaps and metafiles
    // when going from NT to NT.  Main symptom would be "Moved a metafile
    // across clipbook and it suddenly grew way outside its bounds".

    if (fMetafile)
       {
       WIN31METAFILEPICT w31mfp;
       unsigned uNewSize;
       HDDEDATA hDDETmp;

       uNewSize = pfmthdr->DataLen + sizeof(WIN31METAFILEPICT) -
                   sizeof(METAFILEPICT);

       // Have to make a smaller data handle now
       hDDETmp = hDDE;
       hDDE = DdeCreateDataHandle(idInst, NULL,  uNewSize, 0L,
             hszAppName, pfmthdr->FormatID, 0);

       w31mfp.mm   = (WORD)((METAFILEPICT *)lpDDE)->mm;
       w31mfp.xExt = (WORD)((METAFILEPICT *)lpDDE)->xExt;
       w31mfp.yExt = (WORD)((METAFILEPICT *)lpDDE)->yExt;

       // Place oldmetafilepict and data in new DDE block
       DdeAddData(hDDE, (LPTSTR)&w31mfp, sizeof(WIN31METAFILEPICT), 0L);
       DdeAddData(hDDE, lpDDE + sizeof(METAFILEPICT),
             uNewSize - sizeof(WIN31METAFILEPICT),
             sizeof(WIN31METAFILEPICT));

       // Drop old handle
       DdeUnaccessData(hDDETmp);
       DdeFreeDataHandle(hDDETmp);

       // We came in with hDDE accessed
       lpDDE = DdeAccessData(hDDE, &cbData);
       }
    else if (fBitmap)
       {
       WIN31BITMAP w31bm;
       unsigned uNewSize;
       HDDEDATA hDDETmp;

       uNewSize = pfmthdr->DataLen + sizeof(WIN31BITMAP) -
                 sizeof(BITMAP);

       // Have to make a smaller data handle now
       hDDETmp = hDDE;
       hDDE = DdeCreateDataHandle(idInst, NULL,  uNewSize, 0L,
             hszAppName, pfmthdr->FormatID, 0);

       w31bm.bmType       = (WORD)((BITMAP *)lpDDE)->bmType;
       w31bm.bmWidth      = (WORD)((BITMAP *)lpDDE)->bmWidth;
       w31bm.bmHeight     = (WORD)((BITMAP *)lpDDE)->bmHeight;
       w31bm.bmWidthBytes = (WORD)((BITMAP *)lpDDE)->bmWidthBytes;
       w31bm.bmPlanes     = (BYTE)((BITMAP *)lpDDE)->bmPlanes;
       w31bm.bmBitsPixel  = (BYTE)((BITMAP *)lpDDE)->bmBitsPixel;

       // Place old-style bitmap header and data in DDE block
       DdeAddData(hDDE, (LPTSTR)&w31bm, sizeof(WIN31BITMAP), 0L);
       DdeAddData(hDDE, lpDDE + sizeof(BITMAP),
             uNewSize - sizeof(WIN31BITMAP),
             sizeof(WIN31BITMAP));

       // Drop old handle
       DdeUnaccessData(hDDETmp);
       DdeFreeDataHandle(hDDETmp);

       // We came in with hDDE accessed
       lpDDE = DdeAccessData(hDDE, &cbData);
       }

    DdeUnaccessData(hDDE);


done:
    PINFO("Ret %lx\r\n", hDDE);
    return(hDDE);
}




/*
 *      SyncOpenClipboard
 */

BOOL SyncOpenClipboard(
    HWND    hwnd)
{
BOOL fOK;

    PINFO(TEXT("\r\nClipSrv: Opening Clipboard\r\n"));

    WaitForSingleObject (hmutexClp, INFINITE);
    fOK = OpenClipboard (hwnd);
    if (!fOK)
        {
        ReleaseMutex (hmutexClp);
        }

    return fOK;
}



/*
 *      SyncCloseClipboard
 */

BOOL SyncCloseClipboard(void)
{
BOOL fOK;

    PINFO(TEXT("\r\nClipSrv: Closing Clipboard\r\n"));

    fOK = CloseClipboard ();
    ReleaseMutex (hmutexClp);

    return fOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\assocdlg.h ===
/**************************************************/
/*					                              */
/*					                              */
/*	Associations Property		                  */
/*		(Dialog)		                          */
/*					                              */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

typedef struct _tagASSOCIATIONREG{
	TCHAR	szFaceName[LF_FACESIZE];
	TCHAR	szFileName[MAX_PATH];
	TCHAR	szFileTitle[MAX_PATH];
	BOOL	FontTypeFlg;	// TRUE:TRUETYPE, FALSE:WIFE FONT
	BOOL	UpdateFlg;
} ASSOCIATIONREG;

typedef ASSOCIATIONREG FAR *LPASSOCIATIONREG;

class CRegistListBox : public CListBox
{
private:
	int	ItemHeight;

public:
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMIS);
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	virtual int  CompareItem(LPCOMPAREITEMSTRUCT lpCIS);
};

class CAssocDlg : public CDialog
{
public:
	CAssocDlg(CWnd* pParent = NULL);
	BOOL    InitSystemFontAssoc();

  //{{AFX_DATA(CAssocDlg)
	enum { IDD = IDD_ASSOCIATION };
	//}}AFX_DATA

private:
	BOOL 	SetAssociationFontType();
	BOOL	HandleImportWin95(LPTSTR TTFPath, LPTSTR BMPPath, int Idx);
  CWnd * m_pParent;

protected:
	CRegistListBox	m_RegListBox;

	//{{AFX_VIRTUAL(CAssocDlg)
	protected:
	virtual BOOL OnInitDialog();
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

protected:

	// Generated message map functions
	//{{AFX_MSG(CAssocDlg)
	afx_msg void OnDblclkRegistlist();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnModify();
	afx_msg void OnRemove();
	afx_msg void OnRadioDbcs();
	afx_msg void OnRadioSystem();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\datasrv\clipsrv.h ===
#ifndef _INC_DDEMLH
#include <ddeml.h>
#endif

#ifndef _INC_NDDEAPI
#include <nddeapi.h>
#endif



#define	CACHEFORMATLIST
#define	CACHEPREVIEWS

#define MAX_TOPIC       64
#define MAX_EXEC        MAX_DDE_EXEC

#define MAX_CLPSHRNAME  MAX_NDDESHARENAME
#define MAX_FILEPATH    MAX_PATH



// shrinfotag flags

#define	SIF_SHARED	0x1


struct ShrInfotag
        {
        WCHAR       szFileName[MAX_FILEPATH];  // no extension
        WCHAR       szName[MAX_CLPSHRNAME+1];
        HSZ         hszName;
        WORD        flags;
        #ifdef CACHEFORMATLIST
         HDDEDATA   hFormatList;
        #endif
        #ifdef CACHEPREVIEWS
         HDDEDATA   hPreviewBmp;
        #endif
        struct ShrInfotag *Next;
        };

typedef struct ShrInfotag ShrInfo;
typedef ShrInfo *pShrInfo;




extern pShrInfo SIHead;






// GLOBALS


extern  DWORD       idInst;
extern  HINSTANCE   hInst;
extern  HWND        hwndApp;
extern  HSZ         hszAppName;
extern  TCHAR       szTopic[MAX_TOPIC];
extern  TCHAR       szServer[MAX_TOPIC];
extern  TCHAR       szExec[MAX_EXEC];

extern  UINT        cf_preview;
extern  ShrInfo     *SIHead;

extern  TCHAR       szUpdateName[MAX_CLPSHRNAME+1];





// FUNCTIONS

void ClipSrvMain(
    DWORD   argc,
    LPSTR   *argv);


BOOL InitApplication(
    HINSTANCE,
    SERVICE_STATUS *);


LRESULT FAR PASCAL MainWndProc(
    HWND,
    UINT,
    WPARAM,
    LPARAM);


HDDEDATA EXPENTRY DdeCallback(
    WORD        wType,
    WORD        wFmt,
    HCONV       hConv,
    HSZ         hszTopic,
    HSZ         hszItem,
    HDDEDATA    hData,
    DWORD      lData1,
    DWORD      lData2);


void Hszize(void);

void UnHszize(void);


HDDEDATA RenderRawFormatToDDE(
    FORMATHEADER    *pfmthdr,
    HANDLE          fh);




// Resource ID
#define IDI_CLIPSRV 1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\assocdlg.cpp ===
/**************************************************/
/*						                          */
/*						                          */
/*		Registry Process		                  */
/*		  (Dialog)			                      */
/*						                          */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"assocdlg.h"
#include 	"registry.h"
#include	"ttfstruc.h"
#include	"extfunc.h"
#include	"util.h"
#include	"gagedlg.h"

#define STRSAFE_LIB
#include <strsafe.h>

#define		LSPACE	2
#define		RSPACE	2
#define		LCSPACE 17
#define		NUMITEM	3
#define		DBCSCHK	0
#define		EUDCCHK 1

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

SELECTEUDC	SelectEUDC;

static HDC	hDC;
static HWND	hWnd;
static HICON	tIcon;
static HGLOBAL	hMem;
static int	nTypeFace, nIdx, CheckFlg;
static TCHAR	FontName[LF_FACESIZE];
static LPASSOCIATIONREG	lpAssociationReg;

static int 	CheckTTF( LOGFONT);
static BOOL	CheckCharSet( int CharSet);
static BOOL 	IsEUDCTTF( TCHAR *ttffile);
static BOOL 	CheckFileName( LPTSTR FileStr);

static int CALLBACK EnumFontFamProc(
	ENUMLOGFONT FAR*, NEWTEXTMETRIC FAR*, int, LPARAM);

static int CALLBACK EnumFontNumber(
	ENUMLOGFONT FAR*, NEWTEXTMETRIC FAR*, int, LPARAM);

extern BOOL 	SetCountryInfo( UINT LocalCP);



/****************************************/
/*					*/
/*	Constructor			*/
/*					*/
/****************************************/
CAssocDlg::CAssocDlg(
CWnd* 	pParent) : CDialog(CAssocDlg::IDD, pParent)
{
	m_pParent = pParent;
	//{{AFX_DATA_INIT(CAssocDlg)
	//}}AFX_DATA_INIT
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_INITDIALOG"		*/
/*					*/
/****************************************/
BOOL
CAssocDlg::OnInitDialog()
{
	CString	DlgTtl;
 	long	WindowStyle;

	CDialog::OnInitDialog();

	WindowStyle = GetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE);
	WindowStyle |= WS_EX_CONTEXTHELP;
	SetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE, WindowStyle);

	DlgTtl.LoadString( IDS_ASSOCIATE_DLGTITLE);
	this->SetWindowText( DlgTtl);

//	Set Dialog subclass
 	m_RegListBox.SubclassDlgItem( IDC_REGISTLIST, this);
	m_RegListBox.EnableScrollBar( SB_VERT, ESB_DISABLE_BOTH);

	CheckFlg = EUDCCHK;
	this->SendDlgItemMessage( IDC_RADIO_SYSTEM, BM_SETCHECK, (WPARAM)1, 0);
	hMem = NULL;
	if( !SetAssociationFontType()){
		this->MessageBox( NotMemMsg, NotMemTtl, MB_OK |
			MB_ICONHAND | MB_SYSTEMMODAL);

		return FALSE;
	}
	tIcon = AfxGetApp()->LoadIcon( IDI_TRUETYPE);
	return TRUE;
}

/****************************************/
/*					*/
/*	Set TTF and WIFE font		*/
/*					*/
/****************************************/
BOOL
CAssocDlg::SetAssociationFontType()
{
LPASSOCIATIONREG	lpAssociationRegTmp;
	int	aFontCount[] = {0,0,0};
	int	StartIdx = 0;
	int	sts;

	nTypeFace = nIdx = 0;
	hWnd = this->GetSafeHwnd();
	hDC  = ::GetDC( hWnd);

	sts = EnumFontFamilies( hDC, NULL,
	  	(FONTENUMPROC)EnumFontNumber, (LPARAM)aFontCount);
	if( hMem != NULL){
		GlobalUnlock( hMem);
		GlobalFree( hMem);
	}
	hMem = GlobalAlloc(GHND, sizeof(ASSOCIATIONREG) * nTypeFace);
	if( hMem == NULL){
		::ReleaseDC( hWnd, hDC);
		return FALSE;
	}

  lpAssociationReg = (LPASSOCIATIONREG)GlobalLock( hMem);
  lpAssociationRegTmp = lpAssociationReg;
  sts = EnumFontFamilies( hDC, NULL,
    (FONTENUMPROC)EnumFontFamProc, (LPARAM)aFontCount);
  ::ReleaseDC( hWnd, hDC);

  lpAssociationRegTmp = lpAssociationReg;
	for( int i = 0; i < nTypeFace; i++){
		sts = m_RegListBox.AddString(
			(LPCTSTR)lpAssociationRegTmp->szFaceName);
    m_RegListBox.SetItemData(sts, i);
		if( sts == LB_ERR || sts == LB_ERRSPACE){
			GlobalUnlock( hMem);
			GlobalFree( hMem);
			return FALSE;
		}
		if( !lstrcmp(lpAssociationRegTmp->szFaceName, SelectEUDC.m_Font)){
			StartIdx = i;
		}
		lpAssociationRegTmp++;
	}
	m_RegListBox.SetCurSel( StartIdx);

	return TRUE;
}

/****************************************/
/*					*/
/*		Callback 		*/
/*					*/
/****************************************/
static int
CALLBACK EnumFontNumber(
ENUMLOGFONT FAR	*lplf,
NEWTEXTMETRIC FAR* lptm,
int 	FontType,
LPARAM 	lParam)
{
	int 	sts;

       if (!lplf)
       {
           return 0;
       }
	if( FontType == TRUETYPE_FONTTYPE){
		sts = CheckTTF( lplf->elfLogFont);
		if( sts == 1 && CheckCharSet( lplf->elfLogFont.lfCharSet)){
			nTypeFace++;
		}else if( sts == -1){
			return 0;
		}else	;
	}else if( FontType == 0x8 && lplf->elfLogFont.lfFaceName[0] != '@' &&
		  CheckCharSet( lplf->elfLogFont.lfCharSet)){
		nTypeFace++;
	}

	return 1;
}
/****************************************/
/*					*/
/*		Callback 		*/
/*					*/
/****************************************/
static int
CALLBACK EnumFontFamProc(
ENUMLOGFONT FAR	*lplf,
NEWTEXTMETRIC FAR* lptm,
int 	FontType,
LPARAM 	lParam)
{
  LPASSOCIATIONREG	lpAssociationRegTmp;
	TCHAR		FileTitle[MAX_PATH];
	TCHAR		*FilePtr;
	int		  sts;	
       TCHAR   FileSbstName[LF_FACESIZE];
       HRESULT hresult;

       if (!lplf)
       {
          return 0;
       }
	if( FontType == TRUETYPE_FONTTYPE){
		sts = CheckTTF( lplf->elfLogFont);
		if( sts == 1 && CheckCharSet( lplf->elfLogFont.lfCharSet)){
      			FindFontSubstitute(lplf->elfLogFont.lfFaceName, FileSbstName,ARRAYLEN(FileSbstName));
			lpAssociationRegTmp = lpAssociationReg + nIdx;
			//*STRSAFE* lstrcpy((TCHAR *)lpAssociationRegTmp->szFaceName,FileSbstName);
			hresult = StringCchCopy((TCHAR *)lpAssociationRegTmp->szFaceName , ARRAYLEN(lpAssociationRegTmp->szFaceName), FileSbstName);
			if (!SUCCEEDED(hresult))
			{
			   return 0;
			}

			if(!InqTypeFace(lpAssociationRegTmp->szFaceName,
			    lpAssociationRegTmp->szFileName,
			    sizeof( lpAssociationRegTmp->szFileName)/sizeof(TCHAR))){
				GetStringRes(
				(TCHAR *)lpAssociationRegTmp->szFileName,
				IDS_NOTSELECT_STR, ARRAYLEN(lpAssociationRegTmp->szFileName));

				//*STRSAFE* 				lstrcpy( lpAssociationRegTmp->szFileTitle,lpAssociationRegTmp->szFileName);
				hresult = StringCchCopy(lpAssociationRegTmp->szFileTitle , ARRAYLEN(lpAssociationRegTmp->szFileTitle), lpAssociationRegTmp->szFileName);
				if (!SUCCEEDED(hresult))
				{
				   return 0;
				}
			}else{
				//*STRSAFE* 				lstrcpy(FileTitle,lpAssociationRegTmp->szFileName);
				hresult = StringCchCopy(FileTitle , ARRAYLEN(FileTitle), lpAssociationRegTmp->szFileName);
				if (!SUCCEEDED(hresult))
				{
				   return 0;
				}
				if(( FilePtr=Mytcsrchr( FileTitle, '\\')) != NULL)
					FilePtr++;

				else{
					FilePtr = Mytcsrchr( FileTitle,':');
					if( FilePtr != NULL){
						FilePtr++;
					}else 	FilePtr = FileTitle;
				}
				//*STRSAFE* 				lstrcpy(lpAssociationRegTmp->szFileTitle, FilePtr);
				hresult = StringCchCopy(lpAssociationRegTmp->szFileTitle , ARRAYLEN(lpAssociationRegTmp->szFileTitle),  FilePtr);
				if (!SUCCEEDED(hresult))
				{
				   return 0;
				}
			}
			lpAssociationRegTmp->FontTypeFlg = TRUE;
			lpAssociationRegTmp->UpdateFlg = FALSE;
			nIdx++;
		}else if( sts == -1){
			return 0;
		}else	;
	}else if( FontType == 0x8 && lplf->elfLogFont.lfFaceName[0] != '@' &&
		  CheckCharSet( lplf->elfLogFont.lfCharSet)){
    FindFontSubstitute(lplf->elfLogFont.lfFaceName, FileSbstName,ARRAYLEN(FileSbstName));
		lpAssociationRegTmp = lpAssociationReg + nIdx;

    //*STRSAFE* lstrcpy((TCHAR *)lpAssociationRegTmp->szFaceName,	FileSbstName);
    hresult = StringCchCopy((TCHAR *)lpAssociationRegTmp->szFaceName , ARRAYLEN(lpAssociationRegTmp->szFaceName),  FileSbstName);
    if (!SUCCEEDED(hresult))
    {
	   return 0;
    }

		if( !InqTypeFace(lpAssociationRegTmp->szFaceName,
		   lpAssociationRegTmp->szFileName,
		    sizeof(lpAssociationRegTmp->szFileName)/sizeof(TCHAR))){
			GetStringRes((TCHAR *)lpAssociationRegTmp->szFileName,
				IDS_NOTSELECT_STR, ARRAYLEN(lpAssociationRegTmp->szFileName));
			//*STRSAFE* 			lstrcpy(lpAssociationRegTmp->szFileTitle, lpAssociationRegTmp->szFileName);
			hresult = StringCchCopy(lpAssociationRegTmp->szFileTitle , ARRAYLEN(lpAssociationRegTmp->szFileTitle),  lpAssociationRegTmp->szFileName);
			if (!SUCCEEDED(hresult))
			{
			   return 0;
			}
		}else{
			//*STRSAFE* 			lstrcpy(FileTitle, lpAssociationRegTmp->szFileName);
			hresult = StringCchCopy(FileTitle , ARRAYLEN(FileTitle),  lpAssociationRegTmp->szFileName);
			if (!SUCCEEDED(hresult))
			{
			   return 0;
			}
			if(( FilePtr=Mytcsrchr( FileTitle, '\\')) != NULL)
				FilePtr++;
			else{
				FilePtr = Mytcsrchr( FileTitle,':');
				if( FilePtr != NULL){
					FilePtr++;
				}else 	FilePtr = FileTitle;
			}
			//*STRSAFE* 			lstrcpy(lpAssociationRegTmp->szFileTitle, FilePtr);
			hresult = StringCchCopy(lpAssociationRegTmp->szFileTitle , ARRAYLEN(lpAssociationRegTmp->szFileTitle),  FilePtr);
			if (!SUCCEEDED(hresult))
			{
			   return 0;
			}
		}
		lpAssociationRegTmp->FontTypeFlg = FALSE;
		lpAssociationRegTmp->UpdateFlg = FALSE;
		nIdx++;
	}
	return 1;
}

/****************************************/
/*					*/
/*	Check Character Set		*/
/*					*/
/****************************************/
static BOOL
CheckCharSet(
int 	CharSet)
{
	if( CountryInfo.CharacterSet != CharSet)
		return FALSE;
	else	return TRUE;
}

/****************************************/
/*					*/
/*	COMMAND 	"IDOK"		*/
/*					*/
/****************************************/
void
CAssocDlg::OnOK()
{
  LPASSOCIATIONREG	lpAssociationRegTmp;
	TCHAR	FileList[MAX_PATH];	
	TCHAR	TTFPath[MAX_PATH];
	TCHAR	BMPPath[MAX_PATH];
	TCHAR	*FilePtr;
	HRESULT hresult;

  int	nIndex = m_RegListBox.GetCurSel();
	if( nIndex == -1){
		OutputMessageBox( this->GetSafeHwnd(),
			IDS_ASSOCIATE_DLGTITLE,
			IDS_NOTSELTYPEFACE_MSG, TRUE);
		m_RegListBox.SetFocus();
		return;
	}
   
    // It delays 1 second to call EnabelEUDC(FALSE).
    DWORD dwStart = GetTickCount();

    // Stop if this has taken too long
    while (1)
    {
        if( GetTickCount() - dwStart >= 1000 )
            break;
    }
    
	EnableEUDC( FALSE);
	lpAssociationRegTmp = lpAssociationReg;
	GetStringRes( FileList, IDS_NOTSELECT_STR, ARRAYLEN(FileList));
  nIndex = (int)m_RegListBox.GetItemData(nIndex);
	for( int i = 0; i < nTypeFace; i++)
  {
	  if( i == nIndex)
    {
      //
      // Treat as an error, if the eudc font file name is not
      // specified, yet.
      //
      if( !lstrcmp((LPCTSTR)lpAssociationRegTmp->szFileName,FileList) && 
				  (CheckFlg == DBCSCHK))
      {
        this->SendMessage(WM_COMMAND, IDC_MODIFY, NULL);
        if( !lstrcmp((LPCTSTR)lpAssociationRegTmp->szFileName,FileList))
        {
           m_RegListBox.SetFocus();
             EnableEUDC(TRUE);
		         return;
        }
      }

		  //*STRSAFE* 		  lstrcpy(SelectEUDC.m_Font, lpAssociationRegTmp->szFaceName);
		  hresult = StringCchCopy(SelectEUDC.m_Font , ARRAYLEN(SelectEUDC.m_Font),  lpAssociationRegTmp->szFaceName);
		  if (!SUCCEEDED(hresult))
		  {
                   EnableEUDC(TRUE);
		     return ;
		  }
			//*STRSAFE* 			lstrcpy(SelectEUDC.m_File, lpAssociationRegTmp->szFileName);
			hresult = StringCchCopy(SelectEUDC.m_File , ARRAYLEN(SelectEUDC.m_File),  lpAssociationRegTmp->szFileName);
			if (!SUCCEEDED(hresult))
			{
                        EnableEUDC(TRUE);
			   return ;
			}
			//*STRSAFE* 			lstrcpy(SelectEUDC.m_FileTitle, lpAssociationRegTmp->szFileTitle);
			hresult = StringCchCopy(SelectEUDC.m_FileTitle , ARRAYLEN(SelectEUDC.m_FileTitle),  lpAssociationRegTmp->szFileTitle);
			if (!SUCCEEDED(hresult))
			{
                        EnableEUDC(TRUE);
			   return ;
			}
			SelectEUDC.m_FontTypeFlg = lpAssociationRegTmp->FontTypeFlg;
		}
		if(!lstrcmp((LPCTSTR)lpAssociationRegTmp->szFileName,FileList)){
      if (lpAssociationRegTmp->UpdateFlg)
				  DeleteReg(lpAssociationRegTmp->szFaceName);
			lpAssociationRegTmp++;
			continue;
		}
		//*STRSAFE* 		lstrcpy( (LPTSTR)TTFPath, (LPCTSTR)lpAssociationRegTmp->szFileName);
		hresult = StringCchCopy((LPTSTR)TTFPath , ARRAYLEN(TTFPath),  (LPCTSTR)lpAssociationRegTmp->szFileName);
		if (!SUCCEEDED(hresult))
		{
                 EnableEUDC(TRUE);
		   return ;
		}
		//*STRSAFE* 		lstrcpy( BMPPath, TTFPath);
		hresult = StringCchCopy(BMPPath , ARRAYLEN(BMPPath),  TTFPath);
		if (!SUCCEEDED(hresult))
		{
                 EnableEUDC(TRUE);
		   return ;
		}
		if(( FilePtr = Mytcsrchr( BMPPath, '.')) != NULL)
				*FilePtr = '\0';
		//*STRSAFE* 		lstrcat( BMPPath, TEXT(".EUF"));
		hresult = StringCchCat(BMPPath , ARRAYLEN(BMPPath),  TEXT(".EUF"));
		if (!SUCCEEDED(hresult))
		{
                 EnableEUDC(TRUE);
		   return ;
		}
	
		if( OExistTTF( TTFPath))
    {
#if (WINVER >= 0x0500)
		  if (IsWin95EUDCBmp(BMPPath))
      {
			  if (!HandleImportWin95(TTFPath, BMPPath,nIndex ))
        {

//				  EnableEUDC( TRUE);
//				  return;
        }
      }
#endif
    }

		if( !lpAssociationRegTmp->UpdateFlg){
			lpAssociationRegTmp++;
			continue;
		}
 		if( !RegistTypeFace(
		    lpAssociationRegTmp->szFaceName,
		    lpAssociationRegTmp->szFileName))
		{
			EnableEUDC( TRUE);
			return;
		}

		lpAssociationRegTmp++;
	}
	EnableEUDC( TRUE);
	if( CheckFlg != DBCSCHK){
		if (!InitSystemFontAssoc())
		{
			return;
		}
	}

	GlobalUnlock( hMem);
 	GlobalFree( hMem);
	EndDialog(IDOK);
}

BOOL
CAssocDlg::InitSystemFontAssoc()
{
	TCHAR	DefaultFace[LF_FACESIZE];
	TCHAR	DefaultFile[MAX_PATH];
	TCHAR	TTFPath[MAX_PATH];
	TCHAR	BMPPath[MAX_PATH];
	TCHAR	*FilePtr;
       HRESULT hresult;

	GetStringRes(DefaultFace, IDS_SYSTEMEUDCFONT_STR, ARRAYLEN(DefaultFace));
	GetStringRes(DefaultFile, IDS_DEFAULTFILENAME, ARRAYLEN(DefaultFile));

  // if the registry data for SystemEUDC font is already there, just use that.
  if (!InqTypeFace(DefaultFace,TTFPath,MAX_PATH)) {
    GetSystemWindowsDirectory( TTFPath, MAX_PATH);
#ifdef IN_FONTS_DIR // CAssocDlg::OnOK()
		//*STRSAFE* 		lstrcat( TTFPath, TEXT("\\FONTS\\"));
		hresult = StringCchCat(TTFPath , ARRAYLEN(TTFPath),  TEXT("\\FONTS\\"));
		if (!SUCCEEDED(hresult))
		{
		   return FALSE;
		}
#else
		//*STRSAFE* 		lstrcat( TTFPath, TEXT("\\"));
		hresult = StringCchCat(TTFPath , ARRAYLEN(TTFPath),  TEXT("\\"));
		if (!SUCCEEDED(hresult))
		{
		   return FALSE;
		}
#endif // IN_FONTS_DIR
 		//*STRSAFE*  		lstrcat( TTFPath, DefaultFile);
 		hresult = StringCchCat(TTFPath , ARRAYLEN(TTFPath),  DefaultFile);
 		if (!SUCCEEDED(hresult))
 		{
 		   return FALSE;
 		}
  }

  //*STRSAFE*   lstrcpy( BMPPath, TTFPath);
  hresult = StringCchCopy(BMPPath , ARRAYLEN(BMPPath),  TTFPath);
  if (!SUCCEEDED(hresult))
  {
     return FALSE;
  }
  if(( FilePtr = Mytcsrchr( BMPPath, '.')) != NULL)
		*FilePtr = '\0';
	//*STRSAFE* 	lstrcat( BMPPath, TEXT(".EUF"));
	hresult = StringCchCat(BMPPath , ARRAYLEN(BMPPath),  TEXT(".EUF"));
	if (!SUCCEEDED(hresult))
	{
	   return FALSE;
	}

    
    // It delays 1 second to call EnabelEUDC(FALSE).
    DWORD dwStart = GetTickCount();

    // Stop if this has taken too long
    while (1)
    {
        if( GetTickCount() - dwStart >= 1000 )
            break;
    }
	
	EnableEUDC( FALSE);
	if(OExistTTF( TTFPath))
  {
#if (WINVER >= 0x0500)
		if (IsWin95EUDCBmp(BMPPath))
		{
			if (!HandleImportWin95(TTFPath, BMPPath, -1))
			{
				EnableEUDC( TRUE);
				return FALSE;
			}
		}
#endif
  }

	SelectEUDC.m_FontTypeFlg = TRUE;
	//*STRSAFE* 	lstrcpy(SelectEUDC.m_Font,(const TCHAR *)DefaultFace);
	hresult = StringCchCopy(SelectEUDC.m_Font , ARRAYLEN(SelectEUDC.m_Font), (const TCHAR *)DefaultFace);
	if (!SUCCEEDED(hresult))
	{
          EnableEUDC( TRUE);
	   return FALSE;
	}
	//*STRSAFE* 	lstrcpy(SelectEUDC.m_File,(const TCHAR *)TTFPath);
	hresult = StringCchCopy(SelectEUDC.m_File , ARRAYLEN(SelectEUDC.m_File), (const TCHAR *)TTFPath);
	if (!SUCCEEDED(hresult))
	{
          EnableEUDC( TRUE);
	   return FALSE;
	}
	//*STRSAFE* 	lstrcpy(SelectEUDC.m_FileTitle,(const TCHAR *)DefaultFile);
	hresult = StringCchCopy(SelectEUDC.m_FileTitle , ARRAYLEN(SelectEUDC.m_FileTitle), (const TCHAR *)DefaultFile);
	if (!SUCCEEDED(hresult))
	{
          EnableEUDC( TRUE);
	   return FALSE;
	}

	if( !RegistTypeFace(DefaultFace, TTFPath)){
		EnableEUDC( TRUE);
		return FALSE;
	}

  EnableEUDC( TRUE);
    return TRUE;
}
/****************************************/
/*					*/
/*	MESSAGE	"WM_DBLCLKS"		*/
/*					*/
/****************************************/
void
CAssocDlg::OnDblclkRegistlist()
{
	this->SendMessage(WM_COMMAND, IDC_MODIFY, 0);

}

/****************************************/
/*					*/
/*	COMMAND	"IDCANCEL"		*/
/*					*/
/****************************************/
void
CAssocDlg::OnCancel()
{
	GlobalUnlock( hMem);
	GlobalFree( hMem);
	EndDialog( IDCANCEL);
}

/****************************************/
/*					*/
/*	COMMAND	 "Modify"		*/
/*					*/
/****************************************/
void
CAssocDlg::OnModify()
{
LPASSOCIATIONREG	lpAssociationRegTmp;
OPENFILENAME	ofn;
	CString	sFilter;
	CWnd	*cWnd;
	TCHAR	chReplace;
	CString	szDlgTtl;
	TCHAR 	szFilter[MAX_PATH];
	TCHAR	szFileName[MAX_PATH];
	TCHAR	szTitleName[MAX_PATH];
	TCHAR	szDirName[MAX_PATH];
	HRESULT hresult;

	int	nIndex = m_RegListBox.GetCurSel();
	if( nIndex == -1){
		OutputMessageBox( this->GetSafeHwnd(),
			IDS_ASSOCIATE_DLGTITLE,
			IDS_NOTSELTYPEFACE_MSG, TRUE);
		m_RegListBox.SetFocus();
		return;
	}
	//lpAssociationRegTmp = lpAssociationReg + nIndex;
	lpAssociationRegTmp = lpAssociationReg + m_RegListBox.GetItemData(nIndex);

//	Set filter of file( from string table)
	GetStringRes(szFilter, IDS_EUDCTTF_FILTER, ARRAYLEN(szFilter));
	int StringLength = lstrlen( szFilter);
       
	chReplace = szFilter[StringLength-1];
	for( int i = 0; szFilter[i]; i++){
		if( szFilter[i] == chReplace)
			szFilter[i] = '\0';
	}
	GetSystemWindowsDirectory( szDirName, sizeof(szDirName)/sizeof(TCHAR));
#ifdef IN_FONTS_DIR // CAssocDlg::OnModify()
    //*STRSAFE*     lstrcat( szDirName, TEXT("\\FONTS\\"));
    hresult = StringCchCat(szDirName , ARRAYLEN(szDirName),  TEXT("\\FONTS\\"));
    if (!SUCCEEDED(hresult))
    {
       return ;
    }
#endif // IN_FONTS_DIR
	//*STRSAFE* 	lstrcpy( szFileName, TEXT("*.TTE"));
	hresult = StringCchCopy(szFileName , ARRAYLEN(szFileName),  TEXT("*.TTE"));
	if (!SUCCEEDED(hresult))
	{
	   return ;
	}
	szDlgTtl.LoadString( IDS_MODIFY_DLGTITLE);

//	Set data in structure of OPENFILENAME
	ofn.lStructSize = sizeof( OPENFILENAME);
	ofn.hInstance = AfxGetInstanceHandle();
	ofn.hwndOwner = this->GetSafeHwnd();
	ofn.lpstrFilter = szFilter;
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxCustFilter = 0;
	ofn.nFilterIndex = 0;
	ofn.lpstrFile = szFileName;
	ofn.lpstrFileTitle = szTitleName;
	ofn.nMaxFileTitle = sizeof( szTitleName) / sizeof(TCHAR);
	ofn.nMaxFile = sizeof( szFileName) / sizeof(TCHAR);
	ofn.lpstrInitialDir = szDirName;
	ofn.Flags = OFN_HIDEREADONLY | OFN_NOCHANGEDIR
		| OFN_PATHMUSTEXIST ; 
  // there's no direct overwrite issue here, the file will be re-cycled.
  //| OFN_OVERWRITEPROMPT;
	ofn.lpstrDefExt = TEXT("tte");
	ofn.lpstrTitle = szDlgTtl;
	if( !GetSaveFileName( &ofn)){
		return;
	}
  TCHAR tmpName[MAX_PATH];
  //*STRSAFE*   lstrcpy(tmpName, szDirName);
  hresult = StringCchCopy(tmpName , ARRAYLEN(tmpName),  szDirName);
  if (!SUCCEEDED(hresult))
  {
     return ;
  }
  //*STRSAFE*   lstrcat(tmpName, TEXT("eudc.tte"));
  hresult = StringCchCat(tmpName , ARRAYLEN(tmpName),  TEXT("eudc.tte"));
  if (!SUCCEEDED(hresult))
  {
     return ;
  }
  if( !lstrcmpi(ofn.lpstrFile, tmpName) ) {
		OutputMessageBox( this->GetSafeHwnd(),
			IDS_MODIFY_DLGTITLE,
			IDS_NOUSEEUDCFILE_MSG, TRUE);
		return;
  }
	if( !CheckFileName( ofn.lpstrFile)){
		OutputMessageBox( this->GetSafeHwnd(),
			IDS_MODIFY_DLGTITLE,
			IDS_ILLEGALFILE_MSG, TRUE);
		return;
	}
	if( OExistTTF( ofn.lpstrFile)){
		if( !IsEUDCTTF( ofn.lpstrFile)){
			OutputMessageBox( this->GetSafeHwnd(),
			IDS_MODIFY_DLGTITLE,
			IDS_NOTEUDCFILE_MSG, TRUE);
			return;
		}
	}
	//*STRSAFE* 	lstrcpy(lpAssociationRegTmp->szFileName, ofn.lpstrFile);
	hresult = StringCchCopy(lpAssociationRegTmp->szFileName , ARRAYLEN(lpAssociationRegTmp->szFileName),  ofn.lpstrFile);
	if (!SUCCEEDED(hresult))
	{
	   return ;
	}
	//*STRSAFE* 	lstrcpy(lpAssociationRegTmp->szFileTitle, ofn.lpstrFileTitle);
	hresult = StringCchCopy(lpAssociationRegTmp->szFileTitle , ARRAYLEN(lpAssociationRegTmp->szFileTitle),  ofn.lpstrFileTitle);
	if (!SUCCEEDED(hresult))
	{
	   return ;
	}
	lpAssociationRegTmp->UpdateFlg = TRUE;
	m_RegListBox.InsertString( nIndex,
		(LPCTSTR)lpAssociationRegTmp->szFaceName);
  m_RegListBox.SetItemData(nIndex, m_RegListBox.GetItemData(nIndex+1));
	m_RegListBox.DeleteString( nIndex + 1);
	m_RegListBox.SetCurSel( nIndex);

	cWnd = GetDlgItem( IDC_REGISTLIST);
	GotoDlgCtrl( cWnd);
}

/****************************************/
/*					*/
/*	COMMAND 	"Remove"	*/
/*					*/
/****************************************/
void
CAssocDlg::OnRemove()
{
LPASSOCIATIONREG	lpAssociationRegTmp;
	TCHAR	Tmp[MAX_PATH];
	HRESULT hresult;

	int	nIndex = m_RegListBox.GetCurSel();
	if( nIndex == -1){
		OutputMessageBox( this->GetSafeHwnd(),
			IDS_ASSOCIATE_DLGTITLE,
			IDS_NOTSELTYPEFACE_MSG, TRUE);
		m_RegListBox.SetFocus();
		return;
	}

	GetStringRes( Tmp, IDS_NOTSELECT_STR, ARRAYLEN(Tmp));
	//lpAssociationRegTmp = lpAssociationReg + nIndex;
	lpAssociationRegTmp = lpAssociationReg + m_RegListBox.GetItemData(nIndex);
	//*STRSAFE* 	lstrcpy(lpAssociationRegTmp->szFileName,  (const TCHAR *)Tmp);
	hresult = StringCchCopy(lpAssociationRegTmp->szFileName , ARRAYLEN(lpAssociationRegTmp->szFileName),   (const TCHAR *)Tmp);
	if (!SUCCEEDED(hresult))
	{
	   return ;
	}
	//*STRSAFE* 	lstrcpy(lpAssociationRegTmp->szFileTitle, (const TCHAR *)Tmp);
	hresult = StringCchCopy(lpAssociationRegTmp->szFileTitle , ARRAYLEN(lpAssociationRegTmp->szFileTitle),  (const TCHAR *)Tmp);
	if (!SUCCEEDED(hresult))
	{
	   return ;
	}
	lpAssociationRegTmp->UpdateFlg = TRUE;
	m_RegListBox.InsertString( nIndex,
			lpAssociationRegTmp->szFaceName);
  m_RegListBox.SetItemData(nIndex, m_RegListBox.GetItemData(nIndex+1));
	m_RegListBox.DeleteString( nIndex + 1);
	m_RegListBox.SetCurSel( nIndex);
	
//	DeleteReg(lpAssociationRegTmp->szFaceName);
	CWnd *cWnd = GetDlgItem( IDC_REGISTLIST);
	GotoDlgCtrl( cWnd);	
}

/****************************************/
/*					*/
/*	Check .TTF 			*/
/*					*/
/****************************************/
static int
CheckTTF(
LOGFONT 	LogFont)
{
struct	NamingTable	*Ntbl;
struct	NameRecord	*NameRec;
	HGLOBAL	hglb;
	DWORD	dwSize = 0L;
	DWORD	dwTable = 0L;
	LPSTR	lpBuffer, lpTable;
	HFONT	hFont = NULL;
	HGDIOBJ	OldFont = NULL;
	short	nRec = 0;
  int sysLCID;

//	Check "tategaki" or not
	if( LogFont.lfFaceName[0] == '@')
		return 0;

//	Get current font to Inquire ttf file
	hFont = ::CreateFontIndirect( &LogFont);
	if( hFont ) {
		OldFont = ::SelectObject( hDC, hFont);
	}
  

//	Get name table in ttf file
	lpTable = "name";
	dwTable = *(LPDWORD)lpTable;
	dwSize  = ::GetFontData( hDC, dwTable, 0L, NULL, 0L);
	if( dwSize == GDI_ERROR || dwSize == 0){
		if( OldFont ) ::SelectObject(hDC, OldFont);
		if( hFont ) ::DeleteObject(hFont);
		return 0;
	}
	hglb = GlobalAlloc( GHND, dwSize);
	if( hglb == NULL){
		if( OldFont ) ::SelectObject(hDC, OldFont);
		if( hFont ) ::DeleteObject(hFont);
		return -1;
	}
	lpBuffer = (LPSTR)GlobalLock( hglb);
	::GetFontData( hDC, dwTable, 0L, (LPVOID)lpBuffer, dwSize);
	if( OldFont ) ::SelectObject(hDC, OldFont);
	if( hFont ) ::DeleteObject(hFont);

	Ntbl = (struct NamingTable *)lpBuffer;
	sitom( &Ntbl->NRecs);
	nRec = Ntbl->NRecs;
	lpBuffer += sizeof(struct NamingTable);
  sysLCID = (int) LANGIDFROMLCID(GetSystemDefaultLCID());
	while( nRec-- > 0){
		NameRec = (struct NameRecord *)lpBuffer;			
		sitom( &NameRec->PlatformID);
		sitom( &NameRec->PlatformSpecEncID);
		sitom( &NameRec->LanguageID);

#ifdef BUILD_ON_WINNT
//		Unicode TTF
		if( CountryInfo.bUnicodeMode ){
// 			if( NameRec->PlatformID == 3 &&
//		    	    NameRec->LanguageID == sysLCID){
        GlobalUnlock( hglb);
				GlobalFree( hglb);
				return 1;
//			}
		}
#endif //BUILD_ON_WINNT

//		Japanese TTF
		if( CountryInfo.LangID == EUDC_JPN){
			if( NameRec->PlatformID == 3 &&
		    	    NameRec->LanguageID == EUDC_JPN){
				GlobalUnlock( hglb);
				GlobalFree( hglb);
				return 1;
			}
		}
//		Chinese Taipei TTF
		if( CountryInfo.LangID == EUDC_CHT){
			if( NameRec->PlatformID == 3 &&
        NameRec->LanguageID == EUDC_CHT){
    		GlobalUnlock( hglb);
				GlobalFree( hglb);
				return 1;
			}
		}
//		Chinese GB TTF
		if( CountryInfo.LangID == EUDC_CHS){
			if( NameRec->PlatformID == 3 &&
        NameRec->LanguageID == EUDC_CHS){
        GlobalUnlock( hglb);
				GlobalFree( hglb);
				return 1;
			}
		}
//		Korea TTF(WANSUNG)
		if( CountryInfo.LangID == EUDC_KRW){
			if( NameRec->PlatformID == 3 &&
        NameRec->LanguageID == EUDC_KRW){
		    GlobalUnlock( hglb);
				GlobalFree( hglb);
				return 1;		
			}
		}	    	
/*
//    Hebrew TTF
    if( CountryInfo.LangID == EUDC_HEBREW) {
			if( NameRec->PlatformID == 1 &&
          NameRec->LanguageID == 0 ) {
		    		GlobalUnlock( hglb);
				GlobalFree( hglb);
				return 1;		
			}
		}	    	
*/

		lpBuffer += sizeof(struct NameRecord);
	}
	GlobalUnlock( hglb);
	GlobalFree( hglb);
	return 0;
}

/****************************************/
/*					*/
/*	Radio DBCS Clicked		*/
/*					*/
/****************************************/
void
CAssocDlg::OnRadioDbcs()
{
	CWnd 	*cWnd;

	if( CheckFlg != DBCSCHK){
		CheckFlg = DBCSCHK;
		m_RegListBox.EnableWindow( TRUE);
		m_RegListBox.EnableScrollBar( SB_VERT, ESB_ENABLE_BOTH);
		m_RegListBox.UpdateWindow();

		cWnd = this->GetDlgItem( IDC_MODIFY);
		cWnd->EnableWindow( TRUE);

		cWnd = this->GetDlgItem( IDC_REMOVE);
		cWnd->EnableWindow( TRUE);
	}
}

/****************************************/
/*					*/
/*	Radio SYSTEM Clicked		*/
/*					*/
/****************************************/
void
CAssocDlg::OnRadioSystem()
{
	CWnd	*cWnd;

	if( CheckFlg != EUDCCHK){
		CheckFlg = EUDCCHK;
		m_RegListBox.EnableWindow( FALSE);
		m_RegListBox.EnableScrollBar( SB_VERT, ESB_DISABLE_BOTH);

		cWnd = this->GetDlgItem( IDC_MODIFY);
		cWnd->EnableWindow( FALSE);

		cWnd = this->GetDlgItem( IDC_REMOVE);
		cWnd->EnableWindow( FALSE);
	}
}

/****************************************/
/*					*/
/*	Inquire into file( EUDC or not)	*/
/*					*/
/****************************************/
static BOOL
IsEUDCTTF(
TCHAR 	*ttffile)
{
struct	NamingTable	*nTbl;
struct	NameRecord	*nRec;
unsigned int	BufSiz;	
	char	*TableBuf, *SearchOfs;
	char	TTFName[MAX_CODE];


	HANDLE fHdl = CreateFile(ttffile,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fHdl == INVALID_HANDLE_VALUE)
		return FALSE;

	if( TTFReadVarTable( fHdl, &TableBuf, &BufSiz, "name")){
		CloseHandle( fHdl);
		return FALSE;
	}

	SearchOfs = TableBuf;
	nTbl = (struct NamingTable *)TableBuf;

	sitom( &nTbl->OfsToStr);
	SearchOfs += sizeof(struct NamingTable);
	SearchOfs += sizeof(struct NameRecord);
	nRec = (struct NameRecord *)SearchOfs;

	sitom( &nRec->StringOfs);
	SearchOfs = TableBuf + nTbl->OfsToStr + nRec->StringOfs;
	SearchOfs += sizeof(char);
	for( short Inc = 0; Inc < MAX_CODE - 1; Inc++){
		TTFName[Inc] = (char)*SearchOfs;
		SearchOfs += sizeof(char)*2;
	}
	TTFName[Inc] = '\0';
	if( lstrcmpA( TTFName, "EUDC") == 0){
		free( TableBuf);
		CloseHandle( fHdl);
		return TRUE;
	}
	free( TableBuf);
	CloseHandle( fHdl);
	return FALSE;
}

/****************************************/
/*					*/
/*	Inquire into filename		*/
/*					*/
/****************************************/
static BOOL
CheckFileName(
LPTSTR	FileStr)
{
	TCHAR	FileTmp[MAX_PATH];
	TCHAR	Tmp[MAX_PATH];
	TCHAR	*FilePtr;
       HRESULT hresult =S_OK;

       if (!FileStr)
       {
           return FALSE;
       }
	FilePtr = FileStr;
	while( *FilePtr == ' ')
		FilePtr++;

	if( *FilePtr == '.' || *FilePtr == '\0')
		return FALSE;

	int i = 0;
	while( *FilePtr != '\0'){
		FileTmp[i] = *FilePtr;
		FilePtr++;
		i++;
	}
	FileTmp[i] = '\0';
	if(( FilePtr = Mytcsrchr( FileTmp, '.')) == NULL)
		//*STRSAFE* 		lstrcat( FileTmp, TEXT(".tte"));
		hresult = StringCchCat(FileTmp , ARRAYLEN(FileTmp),  TEXT(".tte"));
		if (!SUCCEEDED(hresult))
		{
		   return FALSE;
		}
	else{
#ifdef BUILD_ON_WINNT
		//*STRSAFE if( lstrcmpi( FilePtr, TEXT(".TTE")))
		if (CompareString(LOCALE_INVARIANT,NORM_IGNORECASE,FilePtr,-1,TEXT(".TTE"),-1) != 2 )
#else
		if( stricmp( FilePtr, ".TTE"))
#endif // BUILD_ON_WINNT
			return FALSE;
	}

	//*STRSAFE* 	lstrcpy(Tmp, FileTmp);
	hresult = StringCchCopy(Tmp , ARRAYLEN(Tmp),  FileTmp);
	if (!SUCCEEDED(hresult))
	{
	   return FALSE;
	}
	if( lstrlen(Tmp) >= MAX_PATH)
		return FALSE;
	//*STRSAFE* 	lstrcpy( FileStr, FileTmp);
	hresult = StringCchCopy(FileStr , MAX_PATH,  FileTmp);
	if (!SUCCEEDED(hresult))
	{
	   return FALSE;
	}

	return TRUE;
}
static DWORD aIds[] =
{
	IDC_MODIFY, IDH_EUDC_MODIFY,
	IDC_REMOVE, IDH_EUDC_REMOVE,
	IDC_REGISTLIST,	IDH_EUDC_ASSO_LIST,
	IDC_RADIO_SYSTEM, IDH_EUDC_ASSO_STANDARD,
	IDC_RADIO_DBCS, IDH_EUDC_ASSO_TYPEFACE,
	0,0
};

/****************************************/
/*					*/
/*		Window Procedure	*/
/*					*/
/****************************************/
LRESULT
CAssocDlg::WindowProc(
UINT 	message,
WPARAM 	wParam,
LPARAM 	lParam)
{
	if( message == WM_HELP){
		::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
			HelpPath, HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
		return(0);
	}	
	if( message == WM_CONTEXTMENU){
		::WinHelp((HWND)wParam, HelpPath,
			HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)aIds);
		return(0);
	}
	return CDialog::WindowProc(message, wParam, lParam);
}

BEGIN_MESSAGE_MAP(CAssocDlg, CDialog)
	//{{AFX_MSG_MAP(CAssocDlg)
	ON_LBN_DBLCLK(IDC_REGISTLIST, OnDblclkRegistlist)
	ON_BN_CLICKED(IDC_MODIFY, OnModify)
	ON_BN_CLICKED(IDC_REMOVE, OnRemove)
	ON_BN_CLICKED(IDC_RADIO_DBCS, OnRadioDbcs)
	ON_BN_CLICKED(IDC_RADIO_SYSTEM, OnRadioSystem)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*					*/
/*	MeasureItem			*/
/*					*/
/****************************************/
void
CRegistListBox::MeasureItem(
LPMEASUREITEMSTRUCT lpMIS)
{
	CRect	ListBoxRect;
       if (!lpMIS)
       {
           return;
       }
	this->GetClientRect( &ListBoxRect);
	ItemHeight = ListBoxRect.Height() /NUMITEM;
	lpMIS->itemHeight = ItemHeight;
}

/****************************************/
/*					*/
/*	Draw Item			*/
/*					*/
/****************************************/
void
CRegistListBox::DrawItem(
LPDRAWITEMSTRUCT lpDIS)
{
LPASSOCIATIONREG	lpAssociationRegTmp;
	LOGFONT	LogFont;
	CSize	CharSize, FontSize, cSize;
	TCHAR	FileTmp[MAX_PATH], NotSel[MAX_PATH];
	int	Offset;
	HRESULT hresult;

       if (!lpDIS)
       {
           return;
       }
	CDC* pDC = CDC::FromHandle( lpDIS->hDC);
	if( lpDIS->itemAction & ODA_DRAWENTIRE){
	  	CBrush	fBrush;

		fBrush.CreateSolidBrush(GetSysColor(COLOR_WINDOW)); // COLOR_WIN);
		pDC->FillRect( &lpDIS->rcItem, &fBrush);
		fBrush.DeleteObject();
		pDC->SetBkColor( GetSysColor(COLOR_WINDOW)); //COLOR_WIN);

		//lpAssociationRegTmp = lpAssociationReg + lpDIS->itemID;
		lpAssociationRegTmp = lpAssociationReg + lpDIS->itemData;
    if( CheckFlg == DBCSCHK)
			pDC->SetTextColor( GetSysColor(COLOR_WINDOWTEXT)); //COLOR_BLACK);
		else 	pDC->SetTextColor( GetSysColor(COLOR_GRAYTEXT));  //COLOR_SHADOW);

		GetFont()->GetObject( sizeof(LOGFONT), &LogFont);
		if( abs( LogFont.lfHeight) < ItemHeight)
			Offset = ( ItemHeight - abs( LogFont.lfHeight)) /2;
		else	Offset = 0;

		if( lpAssociationRegTmp->FontTypeFlg){
			pDC->DrawIcon( lpDIS->rcItem.left + LSPACE,
				lpDIS->rcItem.top + Offset, tIcon);
		}

		//*STRSAFE* 		lstrcpy(FileTmp,(const TCHAR *)lpAssociationRegTmp->szFileTitle);
		hresult = StringCchCopy(FileTmp , ARRAYLEN(FileTmp), (const TCHAR *)lpAssociationRegTmp->szFileTitle);
		if (!SUCCEEDED(hresult))
		{
		   return ;
		}
		GetStringRes( NotSel, IDS_NOTSELECT_STR, ARRAYLEN(NotSel));
		if( FileTmp[0] == '\0' ||
		   !lstrcmp((const TCHAR *)FileTmp,(const TCHAR *)NotSel)){

		}else{
			TCHAR	*FilePtr;
			if(( FilePtr = Mytcsrchr( FileTmp, '.')) != NULL)
				*FilePtr = '\0';
			if( lstrlen((const TCHAR *)FileTmp) > 20){
				FileTmp[20] = '\0';
				//*STRSAFE* lstrcat((TCHAR *)FileTmp, TEXT(".."));
				hresult = StringCchCat((TCHAR *)FileTmp , ARRAYLEN(FileTmp),  TEXT(".."));
		              if (!SUCCEEDED(hresult))
		              {
		                 return ;
		              }
			}
		}

		GetTextExtentPoint32( pDC->GetSafeHdc(),
			(const TCHAR *)FileTmp,
			lstrlen((const TCHAR *)FileTmp), &CharSize);

		pDC->ExtTextOut( lpDIS->rcItem.right - CharSize.cx - RSPACE,
			lpDIS->rcItem.top + Offset, 0, 0,
			(const TCHAR *)FileTmp,
			lstrlen((const TCHAR *)FileTmp), NULL);

		int	FontWidth;

		//*STRSAFE* 		lstrcpy(FontName,	(const TCHAR *)lpAssociationRegTmp->szFaceName);
		hresult = StringCchCopy(FontName , ARRAYLEN(FontName), 	(const TCHAR *)lpAssociationRegTmp->szFaceName);
		if (!SUCCEEDED(hresult))
		{
		   return ;
		}
		FontWidth = lpDIS->rcItem.right - lpDIS->rcItem.left
			- LCSPACE - RSPACE - CharSize.cx;

		GetTextExtentPoint32( pDC->GetSafeHdc(),
			(const TCHAR *)FontName,
			lstrlen((const TCHAR *)FontName), &FontSize);
			
		if( FontWidth <= FontSize.cx){
			int 	i;
			
 			GetTextExtentPoint32( pDC->GetSafeHdc(),TEXT("<<"),2, &cSize);
			i = ( FontWidth /cSize.cx) * 2;
			FontName[i-2] = '.';
			FontName[i-1] = '.';
			FontName[i] = '\0';
		}

		pDC->ExtTextOut(lpDIS->rcItem.left + LCSPACE,
			lpDIS->rcItem.top + Offset, 0, 0,
			FontName,
			lstrlen(FontName),	NULL);
	}

	if(( lpDIS->itemState & ODS_SELECTED) &&
	   ( lpDIS->itemAction & (ODA_SELECT | ODA_DRAWENTIRE))){
	   	CBrush	fBrush;

		if( CheckFlg == DBCSCHK)
			fBrush.CreateSolidBrush(::GetSysColor(COLOR_HIGHLIGHT));
		else	fBrush.CreateSolidBrush(GetSysColor(COLOR_WINDOW)); // COLOR_WIN);

		pDC->FillRect( &lpDIS->rcItem, &fBrush);
		fBrush.DeleteObject();

		//lpAssociationRegTmp = lpAssociationReg + lpDIS->itemID;
		lpAssociationRegTmp = lpAssociationReg + lpDIS->itemData;

		if( CheckFlg == DBCSCHK){
			pDC->SetBkColor(::GetSysColor( COLOR_HIGHLIGHT));
			pDC->SetTextColor(::GetSysColor( COLOR_HIGHLIGHTTEXT));
		}else{
			pDC->SetBkColor(GetSysColor(COLOR_WINDOW)); // COLOR_WIN);
			pDC->SetTextColor(GetSysColor(COLOR_GRAYTEXT)); // COLOR_SHADOW);
		}

		GetFont()->GetObject( sizeof(LOGFONT), &LogFont);
		if( abs( LogFont.lfHeight) < ItemHeight)
			Offset = ( ItemHeight - abs( LogFont.lfHeight)) /2;
		else	Offset = 0;

		if( lpAssociationRegTmp->FontTypeFlg){
			pDC->DrawIcon( lpDIS->rcItem.left + LSPACE,
				lpDIS->rcItem.top + Offset, tIcon);
		}

		//*STRSAFE* 		lstrcpy(FileTmp,lpAssociationRegTmp->szFileTitle);
		hresult = StringCchCopy(FileTmp , ARRAYLEN(FileTmp), lpAssociationRegTmp->szFileTitle);
		if (!SUCCEEDED(hresult))
		{
		   return ;
		}
		GetStringRes( NotSel, IDS_NOTSELECT_STR, ARRAYLEN(NotSel));
		if( FileTmp[0] == '\0' ||
		   !lstrcmp(FileTmp,NotSel)){

		}else{
			TCHAR 	*FilePtr;
			if(( FilePtr = Mytcsrchr( FileTmp, '.')) != NULL)
				*FilePtr = '\0';
			if( lstrlen(FileTmp) > 20){
				FileTmp[20] = '\0';
				//*STRSAFE* 				lstrcat(FileTmp, TEXT(".."));
				hresult = StringCchCat(FileTmp , ARRAYLEN(FileTmp),  TEXT(".."));
				if (!SUCCEEDED(hresult))
				{
				   return ;
				}
			}
		}

		GetTextExtentPoint32( pDC->GetSafeHdc(),
			FileTmp,
			lstrlen(FileTmp), &CharSize);

		pDC->ExtTextOut( lpDIS->rcItem.right - CharSize.cx - RSPACE,
			lpDIS->rcItem.top + Offset, 0, 0,
			FileTmp,
			lstrlen(FileTmp), NULL);

		int	FontWidth;

		//*STRSAFE* 		lstrcpy(FontName,	lpAssociationRegTmp->szFaceName);
		hresult = StringCchCopy(FontName , ARRAYLEN(FontName), 	lpAssociationRegTmp->szFaceName);
		if (!SUCCEEDED(hresult))
		{
		   return ;
		}
		FontWidth = lpDIS->rcItem.right - lpDIS->rcItem.left
			- LCSPACE - RSPACE - CharSize.cx;

		GetTextExtentPoint32( pDC->GetSafeHdc(),
			FontName,
			lstrlen(FontName), &FontSize);
			
		if( FontWidth <= FontSize.cx){
			int 	i;
			
 			GetTextExtentPoint32( pDC->GetSafeHdc(),TEXT("<<"),2, &cSize);
			i = ( FontWidth /cSize.cx) * 2;
			FontName[i-2] = '.';
			FontName[i-1] = '.';
			FontName[i] = '\0';
		}
				
		pDC->ExtTextOut( lpDIS->rcItem.left + LCSPACE,
			lpDIS->rcItem.top + Offset, 0, 0,
			FontName,
			lstrlen(FontName),	NULL);
	}

	if( !(lpDIS->itemState & ODS_SELECTED) &&
	  ( lpDIS->itemAction & ODA_SELECT)){
	  	CBrush	fBrush;

		fBrush.CreateSolidBrush(GetSysColor(COLOR_WINDOW)); // COLOR_WIN);
		pDC->FillRect( &lpDIS->rcItem, &fBrush);
		fBrush.DeleteObject();
		
		//lpAssociationRegTmp = lpAssociationReg + lpDIS->itemID;
		lpAssociationRegTmp = lpAssociationReg + lpDIS->itemData;

		pDC->SetBkColor(GetSysColor(COLOR_WINDOW)); // COLOR_WIN);
		if( CheckFlg == DBCSCHK)
			pDC->SetTextColor(GetSysColor(COLOR_WINDOWTEXT)); // COLOR_BLACK);
		else	pDC->SetTextColor(GetSysColor(COLOR_GRAYTEXT));  // COLOR_SHADOW);

		GetFont()->GetObject( sizeof(LOGFONT), &LogFont);
		if( abs( LogFont.lfHeight) < ItemHeight)
			Offset = ( ItemHeight - abs( LogFont.lfHeight)) /2;
		else	Offset = 0;

		if( lpAssociationRegTmp->FontTypeFlg){
			pDC->DrawIcon( lpDIS->rcItem.left + LSPACE,
				lpDIS->rcItem.top + Offset, tIcon);
		}

		//*STRSAFE* 		lstrcpy( FileTmp,lpAssociationRegTmp->szFileTitle);
		hresult = StringCchCopy(FileTmp , ARRAYLEN(FileTmp), lpAssociationRegTmp->szFileTitle);
		if (!SUCCEEDED(hresult))
		{
		   return ;
		}
		GetStringRes( NotSel, IDS_NOTSELECT_STR, ARRAYLEN(NotSel));
		if( FileTmp[0] == '\0' ||
		   !lstrcmp(FileTmp,NotSel)){

		}else{
			TCHAR 	*FilePtr;
			if(( FilePtr = Mytcsrchr( FileTmp, '.')) != NULL)
				*FilePtr = '\0';
			if( lstrlen(FileTmp) > 20){
				FileTmp[20] = '\0';
				//*STRSAFE* 				lstrcat(FileTmp, TEXT(".."));
				hresult = StringCchCat(FileTmp , ARRAYLEN(FileTmp),  TEXT(".."));
				if (!SUCCEEDED(hresult))
				{
				   return ;
				}
			}
		}

		GetTextExtentPoint32( pDC->GetSafeHdc(),
			FileTmp,
			lstrlen(FileTmp), &CharSize);

		pDC->ExtTextOut( lpDIS->rcItem.right - CharSize.cx - RSPACE,
			lpDIS->rcItem.top + Offset, 0, 0,
			FileTmp,
			lstrlen(FileTmp), NULL);

		int	FontWidth;

		//*STRSAFE* 		lstrcpy(FontName,	lpAssociationRegTmp->szFaceName);
		hresult = StringCchCopy(FontName , ARRAYLEN(FontName), 	lpAssociationRegTmp->szFaceName);
		if (!SUCCEEDED(hresult))
		{
		   return ;
		}
		FontWidth = lpDIS->rcItem.right - lpDIS->rcItem.left
			- LCSPACE - RSPACE - CharSize.cx;

		GetTextExtentPoint32( pDC->GetSafeHdc(),
			FontName,
			lstrlen(FontName), &FontSize);
			
		if( FontWidth <= FontSize.cx){
			int 	i;
			
 			GetTextExtentPoint32( pDC->GetSafeHdc(),TEXT("<<"),2, &cSize);
			i = ( FontWidth /cSize.cx) * 2;
			FontName[i-2] = '.';
			FontName[i-1] = '.';
			FontName[i] = '\0';
		}

		pDC->ExtTextOut( lpDIS->rcItem.left + LCSPACE,
			lpDIS->rcItem.top + Offset, 0, 0,
			FontName,	
			lstrlen(FontName),	NULL);
	}
}

int CRegistListBox::CompareItem(LPCOMPAREITEMSTRUCT lpCIS)
{
  TCHAR	TmpFontName1[LF_FACESIZE], TmpFontName2[LF_FACESIZE];
  LPASSOCIATIONREG	lpAssociationRegTmp1,lpAssociationRegTmp2;
  HRESULT hresult;
    if (!lpCIS)
    {
        return -1;
    }
    lpAssociationRegTmp1 = lpAssociationReg + lpCIS->itemData1;
    lpAssociationRegTmp2 = (LPASSOCIATIONREG) (lpCIS->itemData2);
    //*STRSAFE*     lstrcpy(TmpFontName1, lpAssociationRegTmp1->szFaceName);
    hresult = StringCchCopy(TmpFontName1 , ARRAYLEN(TmpFontName1),  lpAssociationRegTmp1->szFaceName);
    if (!SUCCEEDED(hresult))
    {
       return -1;
    }
    //*STRSAFE*     lstrcpy(TmpFontName2, lpAssociationRegTmp2->szFaceName);
    hresult = StringCchCopy(TmpFontName2 , ARRAYLEN(TmpFontName2),  lpAssociationRegTmp2->szFaceName);
    if (!SUCCEEDED(hresult))
    {
       return -1;
    }
    return (lstrcmp(TmpFontName1, TmpFontName2));
}

BOOL CAssocDlg::HandleImportWin95(
LPTSTR TTFPath,
LPTSTR BMPPath,
int Idx)
{

	TCHAR UserFont[MAX_PATH];
	LPTSTR FilePtr;
	TCHAR szTmpDir[MAX_PATH];
	HRESULT hresult;

       if ( (!TTFPath) || (!BMPPath))
       {
           return FALSE;
       }
	GetTempPath(MAX_PATH, szTmpDir);

	if (!GetTempFileName(szTmpDir, TEXT("EUF"), 0, UserFont))
	{
		//*STRSAFE* 		lstrcpy(UserFont, BMPPath);
		hresult = StringCchCopy(UserFont , ARRAYLEN(UserFont),  BMPPath);
		if (!SUCCEEDED(hresult))
		{
		   return FALSE;
		}
		if(( FilePtr = Mytcsrchr( UserFont, '\\')) != NULL)
			*FilePtr = '\0';
		//*STRSAFE* 		lstrcpy(UserFont, TEXT("EUF.tmp"));
		hresult = StringCchCopy(UserFont , ARRAYLEN(UserFont),  TEXT("EUF.tmp"));
		if (!SUCCEEDED(hresult))
		{
		   return FALSE;
		}
	}

	if (!MoveFileEx(BMPPath, UserFont, MOVEFILE_REPLACE_EXISTING))
	{
		return FALSE;

	}

  CGageDlg dlg(